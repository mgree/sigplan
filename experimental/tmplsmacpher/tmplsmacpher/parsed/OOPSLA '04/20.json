{"article_publication_date": "10-01-2004", "fulltext": "\n Mirrors: Design Principles for Meta-level Facilities of Object-Oriented Programming Languages Gilad \nBracha Sun Microsystems 4140 Network Circle Santa Clara, CA 95054 (408) 276-7025 gilad.bracha@sun.com \n ABSTRACT We identify three design principles for reflection and metaprogramming facilities in object \noriented programming languages. Encapsulation: meta-level facilities must encapsulate their implementation. \nStratification: meta-level facilities must be separated from base-level functionality. Ontological correspondence: \nthe ontology of meta-level facilities should correspond to the ontology of the language they manipulate. \nTraditional/mainstream reflective architectures do not follow these precepts. In contrast, reflective \nAPIs built around the concept of mirrors are characterized by adherence to these three principles. Consequently, \nmirror-based architectures have significant advantages with respect to distribution, deployment and general \npurpose metaprogramming. Categories and Subject Descriptors D.3.2 [Language Classifications]: Object-oriented \nlanguages.  General Terms Design, Languages.  Keywords Reflection, Metaprogramming, Mirrors, Java, \nSelf, Smalltalk. 1. INTRODUCTION Object-oriented languages traditionally support meta-level opera\u00adtions \nsuch as reflection by reifying program elements such as classes into objects that support reflective \noperations such as get-Superclass or getMethods. In a typical object oriented language with reflection, \n(e.g., Java, C#, Smalltalk, CLOS) one might query an instance for its class, as indicated in the pseudo-code \nbelow: class Car {...} Car myCar = new Car(); int numberOfDoors = myCar.numberOfDoors(); Class theCarsClass \n= myCar.getClass(); Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for profit or \ncommercial advantage and that copies bear this notice and the full citation on the first page. To copy \notherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission \nand/or a fee. OOPSLA 04, Oct. 24-28, 2004, Vancouver, British Columbia, Canada. Copyright 2004 ACM 1-58113-831-8/04/0010 \n$5.00. David Ungar Sun Microsystems 2600 Casey Ave., MTV 29-XXX Mountain View, CA 94043 (650) 336-2618 \ndavid.ungar@sun.com Car anotherCar = theCarsClass.newInstance(); Class theCarsSuperclass = theCarsClass.getSuperclass(); \nLooking at the APIs of such a system, we expect to see something like: class Object { Class getClass(); \n... } class Class { Class getSuperclass(); // many other methods: getMethods(), getFields() etc. } The \nAPIs above support reflection at the core of the system. Every object has at least one reflective method, \nwhich ties it to Class and (most likely) an entire reflective system. Base- and meta-level operations \ncoexist side-by-side. The same class object that con\u00adtains constructors and static attributes also responds \nto queries about its name, superclass, and members. The same object that exhibits behavior about the \nproblem domain also exhibits behavior about being a member of a class (getClass). This paper argues that \nmeta-level functionality should be imple\u00admented separately from base-level functionality, using objects \nknown as mirrors. Such an API might look something like this: class Object { // no re.ective methods \n... } class Class { // no re.ective methods ... } interface Mirror { String name(); ... } class Re.ection \n{ public static ObjectMirror re.ect(Object o) {...} } interface ObjectMirror extends Mirror { ClassMirror \ngetClass(); ... } interface ClassMirror extends Mirror { ClassMirror getSuperclass(); ... } In a mirror-based \nsystem, one might write our example as: ObjectMirror theCarsMirror = Re.ection.re.ect(myCar); ClassMirror \ntheCarsClassMirror = theCarsMirror.getClass(); ClassMirror theCarsSuperclassMirror = theCarsClassMirror.getSu\u00adperclass(); \nAt first glance, the change does not seem to have made much dif\u00adference. However, the changed API has \nthe effect of: divorcing the interface to meta-level operations from a partic\u00adular implementation, and \n pulling meta-level operations out into a separable subsystem.  Each of these properties manifests \nan important design principle. The former embodies the principle of encapsulation: meta-level facilities \nmust encapsulate their implementation. The latter corresponds to the principle of stratification: meta-level \nfacilities must be separated from base-level functionality. Another principle is structural correspondence: \nthe structure of meta-level facilities should correspond to the structure of the language they manipulate. \nAny meta-level language architecture that respects these principles is, by definition, a mirror-based \nsys\u00adtem. In addition, we advocate the principle of temporal correspon\u00addence: meta-level APIs should be \nlayered so as to distinguish between static and dynamic properties of the language they manipulate. These \ntwo principles can be coalesced into a broader principle of ontological correspondence: the ontology \nof meta\u00adlevel facilities should correspond to the ontology of the language they manipulate. We will show \nthat adherence to the aforementioned design princi\u00adples yields significant advantages with respect to \ndistributed devel\u00adopment and application deployment. We further argue that a well designed mirror-based \nreflective API can serve as a general pur\u00adpose metaprogramming API. Figure 1 illustrates a traditional \nreflective design and a mirror based one. In a traditional API, classes straddle the boundary between \nthe base level and the meta level. In a mirror based design, one moves from the base level to the meta \nlevels by means of a re.ect operation. The levels are clearly separated. In fact, the presence of classes \nat the base level is not strictly necessary. The principle of encapsulation is a basic rule of software \nengineer\u00ading, yet, as we will show, in many cases it has not been applied to the design of the reflective \narchitectures built-in to major program\u00adming languages. The principle of stratification is well known \nin the reflection community [Maes87], but again has not been consis\u00adtently adhered to in most programming \nlanguages. Structural cor\u00adrespondence was elucidated by, e.g., [34]; while it is substantially respected, \nwe highlight violations and their implications for main\u00adstream languages. Temporal correspondence is \nrelated to the well known distinction between compile-time, load-time and run-time reflection. These \nphases are not always applicable to a given lan\u00adguage, but even when they are, only run-time reflection \nis usually supported by the language. This paper is the first systematic discussion of the design princi\u00adples \nof mirror-based systems and the concomitant advantages. The advantages of mirrors include: The ability \nto write metaprogramming applications that are independent of a specific metaprogramming implementation \nsuch as reflection. With care, metaprogramming clients can interact with meta\u00addata sources that are \nlocal or remote without any change to the client. Furthermore, a client can interact with multiple sources \nof metadata at run time, and in fact interact with metaobjects from different implementations simultaneously. \n The ability to obtain metadata from systems executing on platforms that do not themselves include a \nfull reflective implementation. Examples:  -Small, memory-constrained devices or embedded sys\u00adtems -Deployed \napplications where concerns of footprint, security or bandwidth have discouraged or precluded the deployment \nof built-in reflection support. The ability to dynamically add/remove reflection support to/from a running \ncomputation.  The ability to deploy non-reflective applications written in reflective languages on platforms \nwithout a reflective imple\u00admentation, reducing footprint or saving communication time.  Terminology. \nReflective language architectures may be character\u00adized in terms of their support for: 1. Introspection. \nThe ability of a program to examine its own structure. 2. Self-modi.cation. The ability of a program \nto change its own structure. 3. Execution of dynamically generated code. The ability to execute program \nfragments that are not statically known. This is a special case of 2. 4. Intercession. The ability to \nmodify the semantics of the underlying programming language from within the language itself (the term \nintercession is sometimes used in a broader sense in parts of the literature, but we adopt the narrower \ndef\u00adinition of intercession given here, based on [18]).  Table 1 summarizes the support for these features \nin several reflec\u00ad tive systems mentioned in this paper. Base level getClass Traditional Reflection \n Base level getSuperclass getClass    getClassMirror Mirror Based Reflection Figure 1 Table 1 Introspection \nSelf Modi.cation Intercession Java Core Re.ection Yes No No Smalltalk Yes Yes Very limited CLOS Yes Yes \nYes JDI Yes Limited No Strongtalk Yes Yes No Self Yes Yes Very limited The term reflection refers to \nsituations where a program manipu\u00adlates itself. We use the more general term metaprogramming to describe \nsituations where a program manipulates a (possibly dif\u00adferent) program. The word program itself is often \nused to describe two distinct notions: a description given in some programming language and an executing \ncomputational process. We shall refer to the former as code, and to the latter as computation. Each of \nthe next three sections focuses on one of the three princi\u00adples identified above. In each section, we \nshow concrete problems that stem from violations of the principle being discussed, and how they can be \nsolved using mirrors. The following section discusses the principle of encapsulation and its implications \nfor distributed execution. This leads to the need for stratification, discussed in section 3 alongside \nissues of deployment. Section 4 then deals with the principle of correspondence and the problems that \narise when it is neglected. Section 5 gives an overall discussion of the issues that arise in the design \nof mirror-based systems. We then discuss related work and present our conclusions.   2. ENCAPSULATION \nIt is a basic principle of software engineering that a module should not rely on the particulars of another \nmodule s implementation. Unfortunately, clients of classical reflective APIs are dependent on implementation \ndetails of the reflective system they use. We dem\u00adonstrate this point with a case study, followed by \na more general analysis. 2.1 Case Study: Distribution Consider the following scenario. A programmer writes \na class browser, using reflection. At a later time, it becomes necessary to browse classes on remote \nmachines. We would like to reuse as much of our browser code as possible, with as little adaptation as \npossible. This goal may seem controversial; readers should note that we are not arguing for (or against) \ntransparent distribution. That contro\u00adversy is far outside the scope of this paper. Rather, we argue \nthat mirrors are a good approach to the design of a reflective API that is distribution-aware. We also \nclaim that a mirror-based, distribution aware reflective API can be designed so that it serves for the \nnon\u00addistributed case as well. With the scenario given above in mind, we contrast two APIs that are based \nupon the same programming language and virtual machine -Java core reflection and the Java Debugger Interface \n(JDI). We first present an overview of Java core reflection. Java core reflection is the reflective API \nprovided as part of the J2SE and J2EE platforms. It is a traditional reflective API rather than a mir\u00adror-based \none. Next, we ll see how core reflection deals with the scenario described above. This is followed by \na brief introduction to JDI, a mirror-based API designed to support debugging of Java programs. We then \nreturn to our example and show how JDI facili\u00adtates a satisfactory solution. 2.1.1 Java Core Reflection \nIn the Java programming language [16], reflective capabilities are centered around class java.lang.Class \n(Class for short), extended by the core reflection package java.lang.re.ect. All classes, includ\u00ading \nClass itself, are instances of Class. In addition to Class, several other classes that support reflection \nare defined, e.g., java.lang.re.ect.Method, java.lang.re.ect.Field, java.lang.re.ect.Constructor. The \nreflective API is defined using classes, rather than interfaces. The significance of this is discussed \nin section 2.2 below. Classes have methods that support introspection. One can query a class for its \nsuperclass, superinterfaces, fields, methods, construc\u00adtors and member classes. It is not possible to \nalter the structure or code of an existing class using these facilities, as they do not sup\u00adport self-modification. \n 2.1.2 Applying Core Reflection to the Class Browser Problem It s quite easy to write a browser that, \ngiven the name of a class, will allow us to examine the class structure using core reflection. However, \nonce we try and use the same code on remote classes, we encounter serious difficulties [26]. Since Java \ncore reflection does not directly support distribution, the browser will need to use an alternate implementation. \nHow do we avoid the need for a complete rewrite of the browser? One possibility, following [20], is to \ndesign the distributed metap\u00ad rogramming API to have the same class and method structure as core reflection. \nThen the browser application can switch between the local and distributed APIs by changing a single import \nstate\u00adment, from import java.lang.re.ect.* to, say, import com.mycom\u00adpany.distributed.metaprogramming.*. \nThis approach is problematic. We must maintain two (slightly dif\u00adferent) copies of the source code. We \nhave two sets of binaries to distribute and load. Consequently, at runtime, our browser code has twice \nthe memory footprint, and it is very hard for the two loaded versions to interoperate. Furthermore, if \nour browser inter\u00adacts with the class loader API [19], it will need to use class Class and hiding it \nusing import will not be possible. We may also wish to use the browser to observe source code out\u00adside \nof a running virtual machine. The problems mentioned above are exacerbated; we have three versions of \nthe source, three sets of binaries etc. Import statements fail to address the problem because they cannot \nbe used to decouple modules; rather, they couple them in a local\u00adized fashion. Another set of difficulties \nis specific to distributed programming. Our application should be able to deal with network failures \nand latency, and this will affect the logic of the application. We will also need to specify and display \nthe network locations of the classes we are browsing. Altogether, the core reflection API is unsuited \nto our purpose. 2.1.3 JDI The Java Debug Interface (JDI) is the uppermost layer of the Java Platform \nDebugger Architecture (JPDA) [29]. It is designed to support remote debugging, but supports all the introspection \ncapa\u00adbilities present in Java core reflection as well. JDI also supports limited forms of self-modification. \nJDI defines interfaces that describe all program entities that might be of interest to a debugger. These \ninclude classes, interfaces, objects, stack frames and more. All these interfaces are subtypes of the \ninterface com.sun.jdi.Mirror. Below we focus on those mirror interfaces that are most important, and \non those that involve unique issues not seen in other languages or systems. A mirror is always associated \nwith a particular virtual machine, in which the entity being mirrored exists. The interface com.sun.jdi.VirtualMachine \ndescribes a mirror on a virtual machine (VM) as a whole. One can obtain the set of loaded classes and \ninterfaces in the VM being mirrored, the set of threads on the VM, information regard\u00ading the capabilities \nof that VM, mirrors for specific classes or val\u00adues on the VM etc. Objects are mirrored by objects implementing \nthe interface com.sun.jdi.ObjectReference (this is the equivalent of the Object-Mirror interface shown \nin the introduction). It is possible to read and write the mirrored object's fields, invoke its methods, \nand to get its class. Remote mirrors on objects raise issues of distributed garbage col\u00adlection. By default, \na mirrored object may be collected by the mir\u00adrored VM. In other words, object mirrors maintain a weak \nreference to their mirrored object. It is possible to override this default, and also to determine that \nan object has been collected. Threads are mirrored by objects implementing the interface com.sun.jdi.ThreadReference, \nwhich is itself a specialization of ObjectReference, since threads are objects in the JVM. Operations \non threads include suspension and resumption, and operations on the thread's call stack. 2.1.4 Scenario \nRevisited Using JDI Using JDI, it is straightforward to write a class browser that can be used to examine \nclasses in separate processes on remote machines or on the same virtual machine. JDI was designed with \ndistributed use in mind. Debugging the same virtual machine using JDI is not recommended, because debugging \nentails stopping threads on the virtual machine being debugged. If JDI is running on that same VM, there \nis a substantial risk of deadlock. However, structural introspection does not usually require threads \nto be paused. Furthermore, even if the usual JDI implementation were not well-behaved, an alternate implementation \ncan be derived by wrapping core reflection within objects that implement the JDI interfaces as needed \nto support structural introspection. Concretely, one can construct different implementations of the interface \nVirtualMachine (mirroring a particular VM) that support reflection on either the current (local) process \nor remote processes. A class browser would query an instance of VirtualMachine for loaded classes (represented \nas a list of ClassType, the mirror inter\u00adface for classes). The browser code itself is oblivious to the \ndiffer\u00adence between the different implementations of the mirror interfaces. While we have established \nthat JDI can be used for non-distributed reflection, we have not shown that it is as convenient to use \nas Java core reflection. The main difficulty is the need to deal with poten\u00adtial exceptions that can \narise only in distributed use. While this dif\u00adficulty should not be ignored, we would argue that it is \noutweighed by the benefits of having to learn a single API rather than two. Fur\u00adthermore, as discussed \nin section 3.1.3, experience with the Self mirror APIs indicates that it is possible to employ the same \nAPI for local and distributed reflection without excessive penalty.  2.2 Analysis Our case study shows \nthat Java core reflection does not support distributed development tools, while JDI does. Partly, this \nis because JDI deals with certain distribution-specific issues, such as network failure and distributed \nmemory management, while core reflection does not. These issues could be addressed by an alternate implementation \nof core reflection that communicated with remote JVMs via proxies. In the event of network failure (or \nunacceptable latency) opera\u00adtions might fail by throwing an exception. The key point is that such an \nalternate implementation is not possi\u00adble because the core reflection API is based on classes rather \nthan interfaces. Core reflection deliberately violates the principle of encapsulation, by making its \nclients dependent upon specific implementation types (classes). This dependency is enforced by the type \nsystem and prevents clients from using alternate imple\u00admentations of the core reflection API. Of course, \nin a dynamically language one can write a proxy emu\u00adlating the reflective API without concern for quirks \nof the type sys\u00adtem. However, even in dynamically typed object oriented languages, the implementation \nof an object may be subtly exposed, as discussed below. 2.2.1 Encapsulating Class Identity In most object-oriented \nlanguages, the getClass() method (or its equivalent) exposes information about the implementation to \ncli\u00adents. Applications may come to depend on this information, mak\u00ading it very difficult to replace an \nobject with another one that has equivalent functionality but is an instance of a different class. A \nsimple example is: if (aCar.getClass() == Car.class) {...} this is very bad practice, yet not uncommon. \nThis code will fail if aCar is an instance of any alternate implementation of Car. Now consider an example \nin a language where classes have appli\u00adcation specific state and code (as in Smalltalk or CLOS). Class \nCar might have a method numberOfCarsMadeIn(y) {...} // return the number of cars manufac\u00adtured in year \ny typically used as follows: n = aCar.getClass().numberOfCarsMadeIn(1999); If aCar is a proxy for a remote \ncar object, the standard implemen\u00adtation of getClass would return Proxy, causing the code to fail. It \nis clear that we want getClass to return a proxy on the remote car class. Doing so, however, poses a \nproblem: how is reflective code going to get hold of the real class of aCar, class Proxy? We might define \nanother method, getRealClass, but this merely perpetuates the original problem of exposing class identity. \nThe functionality provided by getClass defeats the very reuse that has been pro\u00ad pounded as a motivation \nfor object-oriented programming.1 The solution is to factor the reflective functionality of getClass \nout of the API of ordinary objects. This is exactly what mirrors do. This factoring implies a functional \ndecomposition rather than a classic object-oriented one. The mirror implementation decides how to mirror \nobjects of a given kind, instead of leaving that deci\u00adsion to the implementation of the objects themselves. \nIn some scenarios, such as the class browser example, this is quite natural. The browser knows where \nit is looking for classes \u00adlocally, remotely, in a database etc., and can choose a suitable mir\u00adror factory. \nIn other cases, such as a debugger on a local process that encounters a proxy object, it isn t immediately \nclear which mirror to choose. It may be a configuration preference set by the user. It follows that mirror \nfactories may have to dispatch on the type of the object. How do they do so if access to the identity \nof the class is denied, as we recommend? The answer is that basic, local reflec\u00adtion inherently does \nnot respect the encapsulation of other objects, and can be used by reflective applications, including \nother mirror factories, to identify classes if they so choose. One might even define a public mirror \nfactory that would allow classes to be reg\u00adistered indicating what mirror implementation to use when \nreflect\u00ading upon their instances. There are usually several means other than getClass by which the identity \nof an instance s class may be detected. A common exam\u00adple is the use of constructs like instanceof or \nchecked casts in con\u00adjunction with class types (using these constructs with interface types is harmless). \nSuch usage, and any reliance on class identity, should be avoided in application code. Our conclusion \nis that separation of mirrors, at the meta-level, and classes, at the base-level, is necessary to fully \nsupport encapsula\u00adtion. This separation is a manifestation of the principle of stratifi\u00adcation, discussed \nfurther in the next section.  3. STRATIFICATION A desirable engineering property of a feature is that \nit not impose any costs when it is not used. Adherence to the principle of stratifi\u00adcation supports this \ndesideratum by making it easy to eliminate 1 This problem may not be so important to those for whom object\u00adoriented \nprogramming s modelling abilities are paramount, so per\u00adhaps we have to admit that this paper comes at \nits subject from a non-Scandinavian perspective. However it may be that the stratifi\u00adcation we propose \nis not dissonant with the separation of concepts from phenomena. reflection when it is not needed. This \nhas important benefits in the context of deployment, as discussed below. 3.1 Case Study: Deployment When \ndeploying an application, it is not always desirable to deploy it together with all the reflective facilities \navailable in the lan\u00adguage. The application may not require these reflective capabilities at all, or \nit may require them infrequently. In such cases, it may be advantageous to reduce the application footprint \nby avoiding or delaying the deployment of reflective facilities. This is especially true on small platforms \nsuch as mobile phones, PDAs, smart cards or other embedded systems. Our goal, then, is to avoid deploying \nreflection unless or until it is actually needed by the application. We now review the Smalltalk\u00ad80 reflective \nAPI, contrast it with Strongtalk, a mirror-based Smalltalk system, and give an analysis of how such different \narchi\u00adtectures affect the deployment problem. 3.1.1 Smalltalk-80 Smalltalk-80 differs from most languages \nin that a program is not defined declaratively. Instead, a computation is defined by a set of objects. \nClasses capture shared structure among objects, but they themselves are objects, not declarations. The \nonly way to create new classes, add code to classes etc. is to invoke methods upon them. Smalltalk classes \ninherently support self-modification because reflection is the sole mechanism available for constructing \nand modifying them. The method class is defined for all objects, so that one can obtain the class of \nany instance. Every object also implements the inspect method, which opens an inspector on the object. \nSmalltalk classes are not used exclusively as meta-objects. Classes typically include application specific \nmethods and state. The most common use of class methods is for instance creation. There is no special \nsyntax for instantiating a class, nor is there any notion of a constructor in Smalltalk. Instead, class \nmethods are used to create new instances. Because Smalltalk classes play both application specific and \nmeta\u00adlevel roles in a program, it is generally difficult to remove reflec\u00adtion support from a Smalltalk \napplication. We discuss this topic further in section 3.1.3. 3.1.2 Strongtalk Strongtalk differs from \ntraditional Smalltalk systems in a number of respects. The most relevant differences for the purposes \nof our discussion are: It adopts the use of mirrors instead of the traditional reflective architecture. \n It has an optional static type system [8],[6] that is based exclusively on interfaces, supporting the \nprinciple of encap\u00adsulation.  It is a mixin based system [7][9][5].  The Strongtalk mirror system supports \nintrospection and self-mod\u00adification. The class Mirror and its subclasses support reflection on mixins, \nclasses, types, methods, global variables, objects, the call stack and individual stack frames (activation \nrecords). Invoking Mirror>>on: on an object returns an appropriate mirror object. Mixins serve as the \nbasic unit of self-modification in the Strong\u00adtalk mirror API. Mixins are well suited to this task, because \nthey are stateless (unlike Smalltalk classes), and can therefore be copied freely. Modifications can \nbe made to a copy of a mixin without any effect on the ongoing computation. Only when all modifications \nare complete is the modified version installed in one atomic opera\u00adtion. Several modified mixins can \nbe installed simultaneously. This batching of modifications improves performance, but it has a more important \nadvantage. A series of modifications may be consistent as a whole, but if done piecemeal, may create \ninconsistent interme\u00addiate versions of the code, possibly leading to program failure. This problem is \navoided by the batching the modifications. See [5] for more details. The usual reflective functionality \nassociated with Class is avail\u00adable in ClassMirror. Similarly, specialized mirror classes exist for mixins, \nprotocols (the rough equivalent of interfaces in Java) and global variable declarations. Whereas in an \nordinary Smalltalk system one might ask a class to remove one of its methods, in Strongtalk one would \nobtain a mir\u00adror on the class using Mirror>>on: and then interact with the mirror, as dictated by the \nprinciple of stratification. To inspect an ordinary instance o, one does not use the inspect method. \nInstead, one invokes the method Inspector>>launchOn: on the object. This is crucial in decoupling the \nGUI from the rest of the system. To determine the class of an object for reflective purposes, rather \nthan invoke its class method, one invokes the method Re.ec\u00adtion>>classOf: on the object. This latter \nexample deserves discussion. In Smalltalk, obtaining an object's class is a routine non-reflective operation. \nClass methods are used to construct new instances and for other application pur\u00adposes. For such application \nspecific purposes, the class method can and should be used. Unlike traditional Smalltalks, this method \ncan be overridden in Strongtalk. This allows objects to hide imple\u00admentation details, including their \nclass. For example, a proxy object can hide the fact that it is an instance of a proxy class. See section \n2.2.1 for additional analysis. 3.1.3 Analysis Mirrors make it easier to eliminate reflective infrastructure \nfrom an application. To see why, we must consider the issues in both dynamically and statically typed \nlanguages. In dynamically typed languages that do not use mirrors, it can be difficult to separate reflective \nfacilities and the development envi\u00adronment from the application. For example, the ability to add new \nmethods requires access to a source code compiler. If this capabil\u00adity is placed in class Class, it becomes \ndifficult to weed it out of an application, as all applications rely on class Class. Similarly, in Smalltalk \nObject>>inspect tends to bind object inspectors and a UI framework into the application. In general, \nif reflective capabilities are part of a class that has uses other than reflection, it is hard to safely \nremove those reflective capabilities from the system. To be sure that an application does not use reflection \none needs to resort to sophisticated and costly type inference techniques [2]. Mirrors eliminate this \nproblem by clearly separating reflective functionality, and moving it into places that ordinary applications \nwill not access. It is then straightforward to establish that an appli\u00adcation does not require functionality \nfrom the reflective subsystem or from the development environment. If the application makes no reference \nto entry point(s) associated with reflection (e.g., classes Mirror and/or Re.ection in Strongtalk, the \ncom.sun.jdi.Mirror inter\u00adface in JDI, or the re.ect: method in Self [33][27]), reflection sup\u00ad port can \nbe removed In statically typed languages that employ a nominal type system, eliminating reflective functionality \nfrom an application prior to deployment is considerably easier than in dynamically typed lan\u00adguages. \nHowever, if one does not use mirrors, but wishes to avoid deploying the reflective subsystem unnecessarily, \none must stati\u00adcally determine that reflection will not be used anywhere in the application. If reflection \nis not deployed initially, it will not be pos\u00adsible to modify the existing representations of classes, \nmethods etc. to support it afterwards (since one would need self-modifica\u00adtion capabilities to do so). \nThis is a real liability in the presence of dynamic loading. Using mirrors, one can add or remove the \nreflec\u00adtive capacities at run time without special support, using dynamic class loading and unloading. \nThe ability to dynamically enable or disable reflection support is useful from a security perspective \nas well. Of course, reflection cannot be deployed dynamically with\u00adout some degree of support from the \nunderlying implementation. The capacity to reflect on a computation that does not contain a reflective \nAPI is demonstrated in Klein, a metacyclic Self VM being developed by the second author. Klein itself \ndoes not support a reflective API. Klein is debugged using a Self GUI running on the standard Self VM \nin a separate process. The GUI communi\u00adcates with the Klein VM using mirrors that communicate over sockets. \nNo changes were made to Self s mirror API - only a new implementation was needed. This experience supports \nour conten\u00adtion (in section 2.1) that a single mirror API can serve for both the distributed and local \ncases. Overall, we conclude that mirrors facilitate deployment. The advantages are more pronounced for \ndynamically typed languages, but mirrors are advantageous even when a static type system is used.  \n 4. ONTOLOGICAL CORRESPONDENCE 4.1 Temporal Correspondence Reflection is traditionally defined with reference \nto a computation. Naturally then, an underlying assumption of reflective APIs is that reflected entities \nexist within an executing context. These APIs therefore support operations such as instantiating a class, \nor query\u00ading it for all its instances. While some reflective applications (e.g., profilers and debuggers) \nactually manipulate a computation, oth\u00aders, such as compilers, class hierarchy browsers and pretty print\u00aders, \nonly manipulate the structure of a program (code). It is desirable to run applications in this latter \ncategory on code that is not embedded in a computation. A class browser might be used to view a source \ndatabase, for example. Conversely, some metap\u00adrogramming tools may assume the availability of source \ninforma\u00adtion that may be unavailable at run-time. For example, Javadoc [17] expects comments to be available. \n4.1.1 Case Study: Browsing via a Source Database vs. Browsing via Reflection If one writes a class browser \nusing Java core reflection, one cannot easily retarget the application to browse classes described in \na source database. The situation is similar to what we encountered in section 2.1.2. We cannot create \nan alternate implementation of the API that produces instances of Class, java.lang.re.ect.Method etc. \nsimply by reading source code without compiling and loading the classes into a running JVM. This is yet \nanother example of the importance of the principle of encapsulation, but there are addi\u00adtional issues \ninvolved here. Even if an alternate implementation of core reflection were possi\u00adble, we would face difficulties. \nThe reflection API allows methods to be invoked, classes to be instantiated etc. These operations make \nno sense when the browser is examining a source database. We would fare no better using JDI, which was \ndesigned primarily for debugging. It assumes that there has to be a running VM con\u00adtaining threads, from \nwhich one may obtain stack frames, objects and classes. We can see that adhering to the encapsulation \nprinci\u00adple is a necessary but insufficient condition to solve our problem. Note that the JDI subset concerned \nwith structural reflection on classes is just as applicable to classes whose structure is extracted from \nsource code or from binary class files. If those elements of JDI that do not depend on the presence of \na computation were fac\u00adtored out into a separate API, an implementation that operated upon a source database \nwould be straightforward. This leads to the following observation: mirroring code and mir\u00adroring computation \nshould be separable modules of the mirror API. This is a manifestation of the principle of temporal corre\u00adspondence. \nThe distinction a language makes between code (com\u00adpile-time) and computation (run-time) should be manifest \nin its metaprogramming APIs. The notion of code is useful for restarting programs in a fresh state, for \nproving program properties, and especially for transporting programs between processes, as discussed \nbelow. 4.1.2 Distinguishing Code and Computation in Self: Interchange of Programs and Data The Self \nsystem strives to harness people s intuitions about the real world to help them program computers. Since \nthe real world does not distinguish code and computation there is no compile/run switch in the world \nSelf attempts to unify program and computa\u00adtion. A Self program is just a set of objects, and its mirrors \nreflect that world view. So, one might argue that the principle of temporal correspondence is irrelevant \nfor Self. However, Self features the transporter, a system designed to move programs (sets of slots containing \ndata or code) from one Self world of objects to another [32]. In building the transporter, the second \nauthor was forced to see that there was a need for a pro\u00adgram, something that could be described and \nmoved into another world that would provide it with the new functionality. The objects added to the system \nto represent programs, (annotations, modules, etc.) are indeed meta-level objects that truck in code \ninstead of computation. Despite our own best intentions, when it came time to share programs, we found \nthat this principle applied after all.  4.2 Structural Correspondence Structural correspondence implies \nthat every language construct is mirrored. This principle has long been recognized in the reflection \ncommunity [23]. Nevertheless, in practice it is often violated. We discuss some of the issues that arise \nbelow. 4.2.1 Reifying Both Code and Computation Meta-object protocols ideally introduce a meta-object \nfor every object in the computation. However, in many languages, important notions like modules, import \nand export statements, metadata, types and comments exist only at compile time. Such constructs are liable \nto be excluded by a MOP that only reifies elements of the actual computation. Similarly, compile-time \nMOPs deal only with compile-time constructs; the MOP is not present at run-time, and cannot reify entities \nthat exist only at run-time (see section 6.4 for further discussion of compile-time MOPs). 4.2.2 Mirroring \nMethod Bodies In most languages, constructs below the method level, such as statements and expressions, \ndo not have corresponding meta\u00adobjects. This is also the case in the mirror systems we have dis\u00adcussed. \nAt the VM level, byte codes are often available, and these can often be mapped back into source code. \nThis strategy is typi\u00adcally used by tools such as debuggers. True structural correspondence would imply \nthat a higher level representation of method bodies should be available. This would be useful, so that \ntools that manipulate source code, such as com\u00adpilers, could use a standardized representation. Because \nsource code (or even byte code) may not always be avail\u00adable, many implementors have shied away from \nproviding such facilities. However, it is often possible to provide such functional\u00adity conditionally \n(i.e., if it is available) and/or on-demand. For example, in JDI, clients can query a VirtualMachine \nabout what kinds of operations it supports. This enables JDI to define an API to access a method s byte \ncode, but allows for implementations that do not retain byte code as well.  4.2.3 Which Language to \nReflect? Programming languages that support reflection are often imple\u00admented on top of a virtual machine \n(e.g., Java and the JVM, C# and the CLR, etc.). One must not confuse the metaprogramming API for the \nlanguage of the underlying virtual machine (the VML) with that of the high level language (HLL) running \non top of it. When designing a metaprogramming API, it is important to be clear what the base-level language \nis. This is true regardless of whether the API in question is mirror-based. Reflection has to be supported \nby the VM at some basic level, so a reflective API to the VML is a given. High level languages imple\u00admented \non top of a virtual machine should ideally include their own reflection API. Maintaining a distinct reflective \nAPI for the HLL is valuable for a number of reasons. The VML reflective API may not maintain the invariants \nof the HLL, thereby introducing potential security and correctness prob\u00adlems. There is a risk of discrepancies \nbetween the VML and the HLL. Such discrepancies often arise when implementing high level con\u00adstructs \nthat are not directly supported by the VM. A prominent example are nested classes in the Java programming \nlanguage. Implementing nested classes requires the generation of synthetic classes, interfaces, methods \nand fields that are not present in the original source code. In some cases, constructors may require \nadditional parameters. Such features should be hidden from HLL programs because they expose the details \nof a specific translation scheme between the HLL and the VML. Such a translation scheme is an implementa\u00adtion \ndetail that HLL programs must never rely on. In particular, these details should not leak through the \nreflective API. As a counter-example, consider java.lang.Class.getMethods, which returns the methods \ndeclared by a class. All the methods declared at the VM level are returned, regardless of whether they \nare syn\u00adthetic. This exposes the translation strategy of the Java compiler to clients of reflection. \nIf multiple source languages are implemented on a given virtual machine, the risk of discrepancies among \nthe virtual machine lan\u00adguage and the various source languages increases. A common example is method \noverloading, typically supported by the HLL compiler but not by the underlying VM. If two languages have \ndif\u00adferent overload resolution schemes, a single reflective API will support only one of them correctly. \nEven if the HLL and VML are in complete agreement, it is likely that discrepancies will arise over time \nas new HLL features are added and implemented by the HLL front end without VM sup\u00adport. Again, both nested \nclasses and generics in the Java program\u00adming language are examples of this. To avoid such difficulties, \nthe Strongtalk mirror API is subdivided into high level mirrors and low-level mirrors. High-level mirrors \nreflect Smalltalk, and low level mirrors reflect the underlying structures in the virtual machine. This \ndistinction is not present in any other reflective API that we are aware of. High level mirrors are defined \nby the Mirror class hierarchy. High level mirrors support Smalltalk level semantics. Low level mirrors \nare defined by the class VMMirror and its subclasses. VM mirrors manifest representational differences \nbetween different kinds of objects (e.g., integers, arrays, classes, mixins, regular objects) that are \nhidden at the language level. One can ask a ClassVMMirror for the physical size of its instances, or \nthe size of their header, for example. The low level mirror API is inherently sensitive to the design \nof the underlying virtual machine language and implemen\u00adtation. We conclude that: there should be distinct \nreflective APIs for each language in a system, in particular for the underlying virtual machine language \nand for each high level language running on top A Self objects with two slots, x and y. Sending y to \nthis object returns 17, sending x to it returns the product of rho and cos theta. There is no way in \nthe base Self language to obtain a reference to this method.  A mirror on the object above. Sending \nthe size message returns 2, sending at: y returns a mirror on 17, and sending at: x returns a mirror \non the method in the x slot. Figure 2 of the virtual machine. This is an instance of the principle of \nstruc\u00adtural correspondence.   5. ISSUES IN THE DESIGN OF MIRROR-BASED SYSTEMS 5.1 Classes vs. Prototypes \n5.1.1 Self Mirrors were first introduced in the Self programming lan\u00adguage[33]. Self uses prototypes \ninstead of classes, but unlike Actors[3], it unifies access to state and behavior. Lacking direct references \nto methods, the Self language could not support tradi\u00adtional, integrated reflective operations. Self \ns omission of direct method references stems from its unification of method invocation with variable \naccess and assignment as shown in figure 2. Conse\u00adquently, there is no way in Self to refer to a method, \nas opposed to the result of its execution! The designers of Self felt that method references were not \nobject oriented, because a method does the same thing whenever it is invoked, unlike a message sent to \nan object where the object gets to decide. However, when it came time to build a programming environment, \nit became clear that some way would be needed to refer to methods. The solution was the mirror. Named \noriginally both as a pun on reflection and also to suggest smoke and mirrors , the original notion of \nmirror was an object that would appear to be a dictionary whose entries were named by the slot names \nof the original object (the reflectee ) and whose entries contained mirrors on the con\u00adtents of the slots \nof the reflectee, thus satisfying the principle of stratification. Later, slot objects were introduced. \nWhen asked for the dictionary entry for a given slot, a mirror returns an object that represents the \nslot. It contains the slot name, attributes such as whether it is a parent slot, and a mirror on the \ncontents of the slot. Self s mirrors support introspection and self-modification. Here are some examples: \n(re.ect: anObject) size returns the number of slots in an object (re.ect: anObject) do: [|:s| s printLine] \n prints out the slots in an object, one per line (re.ect: anObject) at: newSlotName Put: (re.ect: 17) \nadds a slot containing 17 to the object ((re.ect: anObject) at: fred ) setParent: true turns the slot \nnamed fred into a parent slot As Self codesigner Randall B. Smith has observed, the down side of mirrors \nis a decrease in uniformity: sometimes it is not clear whether a new method should accept a mirror or \na base object as its argument. Worse, some functionality, such as printing, does not seem to cleanly \nfall into either base- or meta- levels. On the whole, though, the designers of Self are quite pleased \nwith how their strat\u00adified mirror design has worked out. In this paper, we argue that mainstream class-based \nlanguages ben\u00adefit from a model of metaprogramming that follows three princi\u00adples. However, if one accepts \nthe premise in this paper, then one must realize that there is a fundamental problem with class-based \nlanguages as we know them.1 Every single class-based language we know of displays the problems associated \nwith instanceOf and class identity tests as described elsewhere in this paper. We believe that the class-based \nmindset itself drags along the implication that the class of an object is a reasonable thing for client \ncode to know. But, this very knowledge inhibits reuse. On the other hand, exist\u00ading prototype-based languages, \neven Self, do not seem to allow for sufficient latitude for the programmer to express his or her inten\u00adtions \nat the linguistic level. Consequently, we agree with Ole Lehr\u00admann Madsen s view [21] that the next important \nOOPL will bring classes and prototypes together. In other words, we know some of its characteristics \nbut lack a concrete example.  5.2 The Role of Types We distinguish between 1. Structural type systems. \n 2. Nominal type systems based exclusively on interfaces. 3. Optional type systems. 4. Dynamically \ntyped systems.  All of these approaches support the principle of encapsulation, but only a mandatory \nversion of (2) can reliably help us identify when the reflective API is not actually being used, thereby \nsupporting our goals for deployment. A mandatory nominal type system that avoids implementation types \ncan shield designers from some of design errors that affect current mainstream reflective architectures. \nWe believe that such a system is a good choice for languages that seek to employ manda\u00adtory typechecking. \nHowever, many considerations impact the design of a language s type system, and discussing them is well \nbeyond the scope of this paper. Fortunately, careful mirror-based design means that one need not rely \non the type system to separate out the reflective API. The ben\u00adefits of a mirror-based API can be had \nalmost independently of the 1 Of course, there may be other problems with prototype-based languages as \nwe know them. type system used, if any. The key constraint on the type system is that it avoid relying \nexclusively on implementation types. 5.3 Designing Languages in tandem with Reflection By definition, \na reflective API reifies the ontology of a program\u00adming language. The principle of structural correspondence \ndemands that each construct in the language map to an interface in the API. Examining JDI, we see a large \nframework that has to reify a complex language ontology (primitive types, classes, interfaces, access \ncontrol, packages, methods, constructors, initializers etc.). A language s complexity becomes manifest \nin its reflective API, and the size of the API is directly related to the size of the lan\u00adguage. This \nadds to the attraction of simple languages, with a small number of very general constructs, as opposed \nto complex lan\u00adguages with a large number of highly specialized constructs. Given that reflection is \na necessity in modern applications, it seems plausible to suggest that languages be designed in tandem \nwith their reflective APIs. If the reflective API seems too large and complex, language designers can \ntake this as an indication that the language itself is too large and complex. 5.4 Metadata The idea \nof language support for user defined metadata has gar\u00adnered much attention recently, with its introduction \ninto C#. Such support has now been added to the Java programming language as well [30]. Metadata in this \ncontext consists of user specified data attached to elements of the program source, such as class or \nmethod declarations. Design of such metadata facilities raises many of the same issues discussed in this \npaper - specifically, the ability to examine metadata in distributed settings or when the source is not \nloaded. Self s mirrors provide a cozy home for its metadata. Originally, Self had no user-specifiable \nmetadata. Later on in the project, it gained the capability for user-level code to associate an arbitrary \nobject (called an annotation) with any object or slot. The Self vir\u00adtual machine implemented this facility \nwith extra space in its maps, and exposed the annotations through mirrors. Self-level methods in mirrors \nimplemented all of the annotation functional\u00adity, such as get- and set- annotations for objects and slots. \nBy pro\u00adviding a first-class place for meta-level operations, the designer who chooses mirrors prepares \nfor the future expansion of reflec\u00adtive capabilities. 5.5 Disadvantages of Mirrors Mirror-based architectures \nreify the distinction between base- and meta-level operations. When this distinction is either awkward \nor ambiguous, the mirrors can just get in the way. For instance, con\u00adsider a user-interface object that \nallows a programmer to inspect the slots of an object. Without mirrors, one might expect a proto\u00adtype \nsuch as: SlotExaminer newOn: anObject. But in a system with mirrors, one is faced with an awkward choice: \nif the message takes an object as argument, the slot examiner cannot be used with a proxy object. But \nif the message takes a mirror as argument, each invocation of the method must suffer the verbosity of \nthe mirror creation operation. In a non-uniform system, each option has drawbacks. The issue of what \nprotocol to use for an object inspector may seem moot to a true believer in reflection after all the \ninspector is reflecting, so send it a mirror and hang the (verbosity) cost but sometimes the line between \nbase- and meta- level can blur so far there is no distinction left at all. Consider the operation of \nprinting an object. What most of us consider to be a reasonable printed rep\u00adresentation does not respect \nany separation of base and meta. For example, a list object might print as A List containing (a Car, \na Truck). The first part of the string uses the name of the class of the object (meta-level), but the \nlast part uses the list iteration code (base-level). A mirror-based architecture adds complexity to print\u00ading \ncode by introducing explicit level shifts into the code. Where the distinction between base- and meta-level \nfails to model the problem to be solved, mirrors become a nuisance instead of a help.  5.6 Future Work: \nThe Ultimate Mirror System This paper envisages a reflection/metaprogramming API that: Supports introspection, \nself-modification and intercession on both code and computation.  Includes distinct layers for mirroring \nthe virtual machine lan\u00adguage and the high level language(s).  Is clearly separable from the underlying \nbase language, allowing applications that do not use the reflection/meta-pro\u00adgramming API to be deployed \nindependently of it.  Does not assume a particular implementation; rather it trans\u00adparently allows for \nlocal or remote use and demonstrably allows for multiple implementations.  Such a system should support \nan IDE remotely manipulating a small footprint VM that does not include a full implementation of reflection, \nsuch as one found on a PDA or mobile phone. None of the reflective systems constructed to date fully \nmeets this goal, as one can see in table 1, which highlights lack of support for self modification and/or \nintercession, and table 2, which summa\u00ad rizes other key properties of the mirror based systems we have \ndis\u00adcussed in this paper. In Strongtalk, the API was designed with all of these goals in mind except \nfor compile-time metaprogramming, mirroring below the method level, and intercession. However, development \nof Strong\u00adtalk ceased before the mirror API was fully mature. As a result, no distributed implementation \nwas ever constructed to validate it. In contrast, JDI successfully implements distributed metaprogram\u00adming \nin production, but it assumes it is operating on a runtime rep\u00adresentation, and makes no separation between \nthe virtual machine and the high level languages. Though the JDI interface is designed to fully support \nself-modification, actual implementations are more restrictive, and intercession support is completely \nabsent. Self still lacks complete support for VM level language reflection facilities, and does not fully \nsupport either fine-grain reflection below the method level or mirror-based intercession. Other than \nthat, it appears to satisfy our criteria. The question of how to support intercession in a mirror based \nset\u00ad Table 2 Compile time Run time VML HLL Re.ects below Method lvl Strongtalk No Yes Yes Yes No Self \nYes Yes No Yes No JDI No Yes Mixed Mixed Yes APT Yes No No Yes No ting is an intriguing one. Rather \nthan speculate we leave it for future research.  6. RELATED WORK 6.1 Pluggable Reflection The closest \nwork to this paper is [20] in which Lorenz and Vlis\u00ad sides address deficiencies of mainstream reflective \nsystems. The main focus is on the violation of the encapsulation principle. Rather than consider alternate \ndesigns for reflection and lan\u00adguages, they concentrate on a pragmatic methodology and tools that ameliorate \nthe problem for users of existing systems. Using patterns and component techniques, they work on reducing \nthe coupling between reflection and its clients. They also note the problem of temporal correspondence \n(though the terminology dif\u00adfers), but without offering a solution. They do not directly address the \nother design principles discussed here. 6.2 Declarative Metaprogramming Declarative metaprogramming \n[35] makes use of declarative lan\u00ad guages for metaprogramming. In particular, logic metaprogram\u00adming \n[36] uses a logic programming language to define metaprograms. The language being manipulated by the \nmetapro\u00adgram need not be a declarative language [37]. When metaprogram\u00ad ming occurs across languages, \nthe principle of stratification is naturally obeyed. The use of a declarative language avoids the sub\u00adtle \nproblems of class identity mentioned in section 2.2.1. It is pos\u00ad sible to construct a declarative metaprogramming \nsystem that obeys the principles of encapsulation and correspondence, but nei\u00adther property can be taken \nfor granted. 6.3 Lisp Historically, reflection was pioneered in Lisp, and the standard work on the semantics \nof reflection was done in the context of Lisp[11]. Object-oriented Lisp systems, as exemplified by CLOS, \nare the most germane to this paper. Reflection in CLOS is supported via a Meta-Object Protocol (MOP) \n[18] that is part of the language definition. A MOP is a declarative model of the language ontology. \nThe MOP is focused on support for reflection, including introspection, self-modifica\u00adtion and, most notably, \na rich notion of intercession. CLOS meta-objects include (among others) classes. As in Small\u00adtalk, classes \nare used both for application purposes, such as creat\u00ading new instances (via the method make-instance) \nand maintaining shared state (via :class variables), and may have application spe\u00adcific methods as well. \nThis contradicts the principle of stratifica\u00adtion. The MOP largely upholds structural correspondence, \nbut it only reifies entities that have run-time semantics. 6.4 Compile-time MOPs Compile-time MOPs ([12], \n[13], [31]) have two key properties: 1. They deal with code: they only define meta-objects that reify \nentities that exist at compile-time. 2. They allow code to access the MOP while the code itself is being \ncompiled. This lets the code influence how it will be compiled via compile-time computation, supporting \na form of intercession. Code can even manipulate its own structure using the MOP, supporting generative \nprogramming ([14], [28]).  Item (1) implies that the meta-objects provided by a compile-time MOP are \nnecessary but not sufficient to support the principle of correspondence. On the other hand, the ability \nto use these meta\u00adobjects in compile-time computation is not required by any of the design principles \ndiscussed in this paper. Further discussion of (2) is beyond the scope of this paper. 6.5 APT APT (Annotation \nProcessing Tool) [4] is a compile-time metapro\u00ad gramming API designed to support the processing of metadata. \nThe API is mirror based: it uses interfaces exclusively, and sup\u00adports encapsulation and stratification. \nAPT explicitly deals only with compile-time properties of the source language (Java), in line with the \nprinciple of correspondence. However, the API does not provide access to constructs below the method \nlevel. Unfortu\u00adnately, APT is not integrated with a run-time reflection API. 6.6 C#/.Net The C# reflection \nAPI supports introspection, as well as the dynamic creation and evaluation of programs, but not self-modifi\u00adcation \nor intercession. The API is mostly based on abstract classes. This allows alternate implementations to \nbe derived by subclassing. However, the prin\u00adciple of encapsulation is not uniformly adhered to. In particular, \nthe part of the API that supports the dynamic construction of pro\u00adgrams does not use abstract classes \nor interfaces. It also appears that many of the abstract classes are not fully abstract, and thereby \nfix certain properties (especially representations) for all implemen\u00adtations. Despite these flaws, there \nappears to be considerable scope for alternate implementations, at least for introspection. There is \nno clear-cut separation between the base-level and the meta-level. Classes directly support the reflective \noperations and the GetType operation is embedded in the root of the type hierar\u00adchy, object and cannot \nbe overridden. Class types are also exposed via checked casts, the typeOf operator (the equivalent of \nJava s instanceOf) and hardwired notions of type identity. While the API primarily reflects the .Net \nvirtual machine, rather than the C# language itself, there is support for constructs like enu\u00admerations \nwhich appear to be in the domain of high-level lan\u00adguages. There is no distinct layer of the API dedicated \nto the high level language. There does not appear to be a separation between code and compu\u00adtation. For \nexample, methods support an Invoke operation that could not be supported when examining classes in a \nsource code database. 6.7 Beta The Beta [22] metaprogramming system Yggdrasil [24] automati\u00ad cally produces \nclass hierarchies based on an abstract syntax given by a grammar, in close correspondence with the principle \nof struc\u00adtural correspondence. The generated hierarchies and associated tools support metaprogramming \nbut not reflection. MetaBeta [10] provides support for run-time reflection including intercession. The \ndistinction between Yggdrasil and MetaBeta is in line with the principle of temporal correspondence, \nbut unfortunately the two APIs are unrelated. 6.8 Oberon The reflective architecture of Oberon-2 [25] \nfactors out reflection into a separate module, not unlike mirror-based systems. Reflec\u00adtive information \nis accessed through riders, iterator objects that support the traversal of the reified program. Riders \nare used for introspection of the program declarations and call stack and for dynamic execution. The \nsystem does not support self-modification or intercession. Unlike mirrors, riders do not correspond directly \nto individual enti\u00adties in a program. Instead, they represent sequences of similar enti\u00adties. Riders \ncorrespond less directly to the language ontology, but appear to support stratification. 6.9 Firewall \nAllen Wirfs-Brock et al. [34] discuss the properties of a declarative model for Smalltalk programs. The \nabstract object model they propose appears to be a mirror system for Smalltalk, implemented as the Firewall \nprototype for ParcPlace (now Cincom) Smalltalk. They discuss the advantages for distributed development \nand deployment. However, their discussion is Smalltalk specific and relies critically on the more general \nnotion of a declarative pro\u00adgram model for Smalltalk. They do not discuss the separation of high-level \nmirrors and low level ones, the interactions with static typing and multithreading or the relation with \nprototypes. As Wirfs-Brock implies, a declarative language definition is a good basis for a clean mirror \nsystem. A key part of such a defini\u00adtion is the language's abstract syntax. 6.10 Aspect-Oriented Programming \nAspect-Oriented programming (AOP) has its roots in reflection and meta-object protocols in particular. \nOne view of AOP is that it identifies a subset of reflective operations that are frequently use\u00adful for \napplication development, and seeks to represent this subset at the base level via dedicated constructs. \nAs such, AOP is deeply concerned with the distinction between meta-level and base-level operations. However, \nAOP relates only peripherally to this paper, where our chief concern is the design of meta-level APIs. \n  7. CONCLUSIONS We have presented three design principles for meta-level facilities in object oriented \nprogramming languages: 1. Encapsulation. Meta-level facilities must encapsulate their implementation. \n 2. Stratification. Meta-level facilities must be separated from base-level functionality 3. Ontological \nCorrespondence. The ontology of meta\u00adlevel facilities should correspond to the ontology of the language \nthey manipulate.  Mirror-based systems substantially embody these principles. They isolate an object-oriented \nprogramming language s reflective capabilities into separate intermediary objects called mirrors that \ndirectly correspond to language structures and make reflective code independent of a particular implementation. \nAs a result: Mirrors make remote/distributed development easier.  Mirrors make deployment easier because \nreflection can be easily taken out or added, even dynamically.  The design principles behind mirrors \nmay seem obvious, and yet these principles have not been widely applied to the reflective APIs of object-oriented \nprogramming languages. Mirrors have been implemented in several different programming languages. These \ninclude class based languages, both dynamically and statically typed, as well as the prototype based \nlanguage Self in which they were originally conceived. Mirrors have been successfully demonstrated in \npractice: very rich IDEs have been built using mirror-based reflection, as well as production quality \ndebuggers. The full power of mirror-based systems has yet to be realized. Systems that fully support \nmetaprogramming of both code and computation at both the virtual machine and high-level language levels \nhave yet to be demonstrated. However, the potential is clear. Overall, we believe that the advantages \nof mirror-based systems greatly outweigh their disadvantages, and that mirror\u00adbased metaprogramming APIs \nshould be the norm in future object-oriented languages. 8. ACKNOWLEDGMENTS This work would not be possible \nwithout the teams who built the mirror-based systems described above. The Self team: Ole Agesen, Lars \nBak, Craig Chambers, Bay-Wei Chang, Urs H\u00f6lzle, Elgin Lee, John Maloney, Randy Smith, David Ungar and \nMario Wolczko. The Strongtalk team: Lars Bak, Gilad Bracha, Steffen Grarup, Robert Griesemer, David Griswold \nand Urs H\u00f6lzle. The JDI team: Robert Field, Gordon Hirsch and James McIlroy. The APT team: Joseph Darcy \nand Scott Seligman. The authors are grateful to Christian Plesner Hansen and Kenneth Russell for productive \ndiscussions of these issues, and to Roel Wuyts, Stephane Ducasse, Mads Torgersen and Sophia Drossopo\u00adlou \nand the SLURP group at Imperial College, as well as the anon\u00adymous referees, for helpful comments on \nearlier drafts of this paper. 9. REFERENCES [1] Ole Agesen, Stephen N. Freund and John C. Mitchell. \nAdding Type Parameterization to the Java Language. In Proceedings of the ACM Conference on Object-Oriented \nProgramming, Systems Lan\u00adguages and Applications, October 1997. [2] Ole Agesen, Jens Palsberg, and Michael \nI. Schwartzbach. Type inference of Self: Analysis of objects with dynamic and multiple inheritance. \nSoftware - Practice &#38; Experience, 25(9):975-995, September 1995. [3] Gul Agha. Actors: A Model of \nConcurrent Computing in Dis\u00adtributed Systems. MIT Press, Cambridge, Massachusetts, 1986. [4] Annotation \nProcessing Tool Home Page . http://java.sun.com/j2se/1.5.0/docs/guide/apt/ [5] Lars Bak, Gilad Bracha, \nSteffen Grarup, Robert Griesemer, David Griswold and Urs H\u00f6lzle. Mixins in Strongtalk. ECOOP Workshop \non Inheritance, June 2002. [6] Gilad Bracha. The Strongtalk Type System for Smalltalk, Sep\u00adtember 1996. \nOOPSLA Workshop on Extending the Smalltalk Language. [7] Gilad Bracha and William Cook. Mixin-based Inheritance. \nIn Proceedings of the Joint ACM Conference on Object-Oriented Programming, Systems Languages and Applications \nand the Euro\u00adpean Conference on Object-Oriented Programming, October 1990. [8] Gilad Bracha and David \nGriswold. Strongtalk: Typechecking Smalltalk in a Production Environment. In Proceedings of the ACM Conference \non Object-Oriented Programming, Systems Lan\u00adguages and Applications, September 1993. [9] Gilad Bracha \nand David Griswold. Extending Smalltalk with Mixins, September 1996. OOPSLA Workshop on Extending the \nSmalltalk Language. [10] Soren Brandt and Rene Schmidt. Dynamic Reflection for a Statically Typed Language. \nTechnical Report PB-505. Department of Computer Science, Aarhus University, June 1986 [11] Brian Cantwell \nSmith and Jim de Rivieres. Reflection and Semantics in LISP. In Proceedings of the 11th ACM SIGACT-SIG-PLAN \nsymposium on Principles of Programming Languages, 1984. [12] Shigeru Chiba. A Metaobject Protocol for \nC++. In Proceed\u00adings of the ACM Conference on Object-Oriented Programming Systems, Languages, and Applications, \nOctober 1995. [13] Shigeru Chiba. Macro Processing in Object-Oriented Lan\u00adguages. In Proc. of Technology \nof Object-Oriented Languages and Systems (TOOLS Pacific '98), Australia, November, IEEE Press, 1998. \n[14] Krzysztof Czarnecki and Ulrich W. Eisenecker. Generative Programming. Addison-Wesley, Reading, Massachusetts, \n2000. [15] Adele Goldberg and David Robson. Smalltalk-80: The Lan\u00adguage and its Implementation. Addison-Wesley, \nReading, Massa\u00adchusetts, 1983. [16] James Gosling, Bill Joy, Guy Steele and Gilad Bracha. The Java Language \nSpecification, Third Edition. Addison-Wesley, Reading, Massachusetts, 2004. [17] Javadoc Tool Home Page. \nhttp://java.sun.com/j2se/javadoc/. [18] Gregor Kiczales, Jim des Rivieres and Daniel G. Bobrow. The Art \nof the Metaobject Protocol. MIT Press, Cambridge, Massachu\u00adsetts, 1991. [19] Sheng Liang and Gilad Bracha. \nDynamic Class Loading in the Java Virtual Machine. In Proceedings of the ACM Conference on Object-Oriented \nProgramming, Systems Languages and Applica\u00adtions, October 1998. [20] David. H. Lorenz and John Vlissides. \nPluggable Reflection: Decoupling Meta-Interface and Implementation. In Proceedings of the International \nConference on Software Engineering, May 2003 [21] Ole Lehrmann Madsen. Keynote address. OOPSLA, Novem\u00adber \n2002. [22] Ole Lehrmann Madsen, Birger Moller-Pedersen and Kristen Nygaard. Object-Oriented Programming \nin the Beta Programming Language. Addison-Wesley, Reading, Massachusetts, 1993. [23] Pattie Maes. Concepts \nand Experiments in Computational Reflection. In Proceedings of the ACM Conference on Object-Ori\u00adented \nProgramming, Systems Languages and Applications, Octo\u00adber 1987. [24] Mjolner Informatics. The Mjolner \nSystem: Metaprogramming System. Available at http://www.mjolner.com/mjolner-sys\u00adtem/yggdrasil_en.php \n[25] Hans-Peter M\u00f6ssenb\u00f6ck and Christoph Steindl. The Oberon-2 Reflection Model and its Applications. \nIn Proceedings of the Sec\u00adond International Conference on Metalevel Architectures and Reflection, July \n1999. [26] Michael Richmond and James Noble. Reflections on Remote Reflection. Proceedings of the 24th \nAustralasian conference on Computer science. Gold Coast, Queensland, Australia, pp.163 - 170, 2001. [27] \nSelf Programming Language Homepage. http://research.sun.com/research/self/ [28] Tim Sheard and Simon \nPeyton Jones. Template Meta-pro\u00adgramming for Haskell. In Haskell 02. October, 2002. SIGPLAN Notices, \n37, No. 12, pp. 60-75. [29] Sun Microsystems. Java Platform Debugger Architecture. http://java.sun.com/products/jpda/. \n[30] Sun Microsystems. A Metadata Facility for the JavaTM Pro\u00adgramming Language. http://www.jcp.org/aboutJava/communi\u00adtyprocess/review/jsr175/ \n[31] Michiaki Tatsubori, Shigeru Chiba, Marc-Olivier Killijian and Kozo Itano. OpenJava: A Class-Based \nMacro System for Java. In Reflection and Software Engineering, LNCS 1826, Springer-Ver\u00adlag, pp.117-133, \n2000. [32] David Ungar. Annotating Objects for Transport to Other Worlds. In Proceedings of the ACM Conference \non Object-Ori\u00adented Programming, Systems Languages and Applications, Octo\u00adber 1995. [33] David Ungar \nand Randall Smith. SELF: The Power of Sim\u00adplicity. In Proceedings of the ACM Conference on Object-Oriented \nProgramming, Systems Languages and Applications, October 1987. [34] Allen Wirfs-Brock, Juanita Ewing, \nHarold Williams and Brian Wilkerson. A Declarative Model for Defining Smalltalk Programs, October 1996. \nInvited talk at OOPSLA 96; available at http://www.smalltalksystems.com/_awss97/index.htm. [35] Roel \nWuyts. Declarative Reasoning about the Structure of Object-Oriented Systems, Proceedings of TOOLS USA, \nAugust 1998. [36] Roel Wuyts, A Logic Meta - Programming Approach to Sup\u00adport the Co - Evolution of Object \n- Oriented Design and Imple\u00admentation, Ph.D. thesis, Vrije Universiteit Brussel, 2001. [37] Roel Wuyts \nand St\u00e9phane Ducasse, Symbiotic Reflection between an Object - Oriented and a Logic Programming Lan\u00adguage, \nin ECOOP 2001 International workshop on MultiParadigm Programming with Object - Oriented Languages, 2001. \n  \n\t\t\t", "proc_id": "1028976", "abstract": "<p>We identify three design principles for reflection and metaprogramming facilities in object oriented programming languages. &#60;i>Encapsulation&#60;/i>: meta-level facilities must encapsulate their implementation. &#60;i>Stratification&#60;/i>: meta-level facilities must be separated from base-level functionality. &#60;i>Ontological correspondence&#60;/i>: the ontology of meta-level facilities should correspond to the ontology of the language they manipulate. Traditional/mainstream reflective architectures do not follow these precepts. In contrast, reflective APIs built around the concept of &#60;i>mirrors&#60;/i> are characterized by adherence to these three principles. Consequently, mirror-based architectures have significant advantages with respect to distribution, deployment and general purpose metaprogramming.</p>", "authors": [{"name": "Gilad Bracha", "author_profile_id": "81100534214", "affiliation": "Sun Microsystems, Santa Clara, CA", "person_id": "P97520", "email_address": "", "orcid_id": ""}, {"name": "David Ungar", "author_profile_id": "81100365263", "affiliation": "Sun Microsystems, Mountain View, CA", "person_id": "P64183", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1028976.1029004", "year": "2004", "article_id": "1029004", "conference": "OOPSLA", "title": "Mirrors: design principles for meta-level facilities of object-oriented programming languages", "url": "http://dl.acm.org/citation.cfm?id=1029004"}