{"article_publication_date": "10-01-2004", "fulltext": "\n Converting Java Programs to Use Generic Libraries Alan Donovan Adam Kie. Matthew S. Tschantz zun Michael \nD. Ernst MIT Computer Science &#38; Arti.cial Intelligence Lab 32 Vassar St, Cambridge, MA 02139 USA \n{adonovan,akiezun,tschantz,mernst}@csail.mit.edu ABSTRACT Java 1.5 will include a type system (called \nJSR-14) that supports parametric polymorphism, or generic classes. This will bring many bene.ts to Java \nprogrammers, not least because current Java prac\u00adtice makes heavy use of logically-generic classes, including \ncon\u00adtainer classes. Translation of Java source code into semantically equivalent JSR\u00ad14 source code requires \ntwo steps: parameterization (adding type parameters to class de.nitions) and instantiation (adding the \ntype arguments at each use of a parameterized class). Parameteriza\u00adtion need be done only once for a \nclass, whereas instantiation must be performed for each client, of which there are potentially many more. \nTherefore, this work focuses on the instantiation problem. We present a technique to determine sound \nand precise JSR-14 types at each use of a class for which a generic type speci.ca\u00adtion is available. \nOur approach uses a precise and context-sensitive pointer analysis to determine possible types at allocation \nsites, and a set-constraint-based analysis (that incorporates guarded, or con\u00additional, constraints) \nto choose consistent types for both allocation and declaration sites. The technique handles all features \nof the JSR-14 type system, notably the raw types that provide backward compatibility. We have implemented \nour analysis in a tool that au\u00adtomatically inserts type parameters into Java code, and we report its \nperformance when applied to a number of real-world Java pro\u00adgrams. Categories and Subject Descriptors \nD.1.5 [Programming Techniques]: Object-oriented Programming; D.2.2 [Software Engineering]: Design Tools \nand Techniques modules and interfaces; D.3.3 [Programming Languages]: Lan\u00adguage Constructs and Features \ndata types and structures  General Terms languages, theory, experimentation  Keywords generic types, \nparameterized types, parametric polymorphism, type inference, instantiation types, JSR-14, Java 1.5, \nJava 5, raw types Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. OOPSLA 04, Oct. 24-28, 2004, Vancouver, British Columbia, Canada. Copyright 2004 ACM 1-58113-831-8/04/0010 \n...$5.00. 1. INTRODUCTION The next release of the Java programming language [21] will include support \nfor generic types. Generic types (or parametric polymorphism [7]) make it possible to write a class or \nprocedure abstracted over the types of its method arguments. In the absence of generic types, Java programmers \nhave been writing and using pseudo-generic classes, which are usually ex\u00adpressed in terms of Object. \nClients of such classes widen (up-cast) all the actual parameters to methods and narrow (down-cast) all \nthe return values to the type at which the result is used which can be thought of as the type at which \nthe pseudo-generic class is in\u00adstantiated in a fragment of client code. This leads to at least two problems: \n1. The possibility of error: Java programmers often think in terms of generic types when using pseudo-generic \nclasses. However, the Java type system is unable to prove that such types are consistently used. This \ndisparity allows the pro\u00adgrammer to write, inadvertently, type-correct Java source code that manipulates \nobjects of pseudo-generic classes in a man\u00adner inconsistent with the desired truly-generic type. A pro\u00adgrammer \ns .rst indication of such an error is typically a run\u00adtime exception due to a failing cast; compile time \nchecking is preferable. 2. An incomplete speci.cation: The types in a Java program serve as a rather \nweak speci.cation of the behavior of the program and the intention of the programmer. Generic types provide \nbetter documentation, and the type checker guaran\u00adtees their accuracy.  Non-generic solutions to the \nproblems (e.g., wrapper classes such as StringVector) are unsatisfying. They introduce nonstandard and \nsometimes inconsistent abstractions that require extra e.ort for programmers to understand. Furthermore, \ncode duplication is error-prone. Java with generic types (which we call JSR-14 after the Java Speci.cation \nRequest [4] that is being worked into Java 1.5) solves these problems while maintaining full interoperability \nwith existing Java code. Currently, programmers who wish to take advantage of the ben\u00ade.ts of genericity \nin Java must translate their source code by hand; this process is time-consuming, tedious, and error-prone. \nWe pro\u00adpose to automate the translation of existing Java source .les into JSR-14. There are two parts \nto this task: adding type parameters to class de.nitions ( parameterization ), and modifying uses of \nthe classes to supply the type parameters ( instantiation ). Parameterization must be performed just \nonce for each library class. The process might be done (perhaps with automated assis\u00adtance) by an expert \nfamiliar with the library and how it is intended to be used. Even for a non-expert, this task may be \nrelatively easy. For example, the javac compiler, the htmlparser program and the antlr parser generator \nde.ne their own container classes in addi\u00adtion to, or in lieu of, the JDK collections. One of us (who \nhad never seen the code before) fully annotated the javac libraries with generic types (135 annotations \nin a 859-line codebase) in 15 min\u00adutes, the antlr libraries in 20 minutes (72 annotations in a 532-line \ncodebase) and the htmlparser libraries in 8 minutes (27 annotations in a 430-line codebase). This paper \nfocuses on the instantiation problem. Instantiation must be performed for every library client; there \nare typically many more clients than libraries, and many more programmers are in\u00advolved. When a library \nis updated to use generic types, it is desir\u00adable to perform instantiation for legacy code that uses \nthe library, though no one may be intimately familiar with the legacy code. Generic libraries are likely \nto appear before many programs that are written in a generic style (for example, Java 1.5 will be distributed \nwith generic versions of the JDK libraries), and are likely to be a motivator for converting those programs \nto use generic types. Generically typed libraries permit programmers to incrementally add generics to \ntheir programs and gain bene.ts in a pay-as-you-go fashion. Figures 2, 3, and 4 give an example of a \n(generic) library, non\u00adgeneric client code, and the client code after being transformed by our tool. \nThe library de.nes the class Cell, which is a container holding one element, and its subclass Pair, which \nholds two ele\u00adments, possibly of di.erent types. The client code de.nes a number of methods that create \nand manipulate Cells and Pairs. The paper uses this code as a running example. In brief, the generic \ntype instantiation problem is as follows. The input is a set of generic (i.e., JSR-14 annotated) classes \n(which we call library code) and a set of non-generic (i.e., pre-JSR-14) classes (client code) that use \nthe library code. The goal is to annotate the client code with generic type information in such a way \nthat (a) the program s behavior remains unchanged, and (b) as many casts as possible can be removed. \nLater sections expand on this goal. The remainder of this paper is organized as follows. Section 2 introduces \nJSR-14, a generic version of Java that is expected to be adopted for Java 1.5. Section 3 lays out our \ndesign goals and as\u00adsumptions, and Section 4 overviews our algorithm. The next two sections describe \nthe two parts of the algorithm, namely alloca\u00adtion type inference (Section 5) and declaration type inference \n(Sec\u00adtion 6). Section 7 discusses the implementation of our prototype tool, and Section 8 presents preliminary \nexperimental results. Sec\u00adtion 9 discusses related work. Finally, Section 10 proposes future work, and \nSection 11 concludes. 2. JSR-14: JAVA WITH GENERIC TYPES This section brie.y introduces the syntax and \nsemantics of JSR\u00ad 14. Generic types are an example of bounded parametric polymor\u00adphism [7]. Parametric \npolymorphism is an abstraction mechanism that permits a single piece of code to work uniformly over many \ndistinct types in a type-safe manner. Type parameters stand for the types over which the code is (conceptually) \ninstantiated. 2.1 Syntax Figure 2 shows the de.nition of two generic classes in Java. The name of the \ngeneric class is followed by a list of type variables (V for class Cell, and F and S for class Pair). \nEach type variable has an optional upper bound or bounds. The default bound is extends Object, which \nmay be omitted for brevity. The type variables may be used within the class just as ordinary types are, \nexcept that in- Object Cell Number Integer Cell<Integer> Cell<Number>  Pair<Integer,Boolean> Pair<Number,Boolean> \n Figure 1: A portion of the type hierarchy for JSR-14 (Java with generic types), which uses invariant \nparametric subtyping. Arrows point from sub\u00adtypes to supertypes. Classes Cell in Pair are de.ned in Figure \n2. stances of the type variables may not be constructed by an instance creation expression, as in new \nV(). The Pair class shows that one generic type can extend (subclass) another. The scope of a class s \ntype variable is essentially the same as the scope of this: all in\u00adstance methods and declarations of \ninstance .elds, and any inner classes, but not static members or static nested classes. Also, a type \nparameter can be referred to in the class s declaration. A generic class may be instantiated (used) by \nsupplying type ar\u00adguments that are consistent with the bounds on the type variables (Figure 4). Type-checking \nensures that the code is type-correct, no matter what type arguments that satisfy the bounds are used. \n(See below for a caveat regarding raw types.) Methods may also be generic, adding their own additional \ntype variables. In Figure 2, replaceValue is a generic method, which is preceded by a list of (bounded) \ntype variables. (The type vari\u00adable U has a non-trivial bound.) Type arguments at uses of generic methods \nneed not be speci.ed by the programmer; they are auto\u00admatically inferred by the compiler. (Line 11 in \nFigure 4 contains a use of a generic method.) The scope of a method type variable is just the method \nitself. A raw type is a generic type used without any type parameters. (On line 30 of Figure 4, parameter \nc6 in displayValue is raw.) Raw types are a concession to backward compatibility, and they behave exactly \nlike types in non-generic Java. 2.2 Type system This section informally overviews salient points of \nthe type sys\u00adtem of JSR-14 [4]. Figure 1 shows part of the type hierarchy. Invariant parametric subtyping. \nDi.erent instantiations of a parameterized type are unrelated by the type hierarchy.1 Cell(Integer) is \nnot a subtype of Cell(Number), even though Integer is a subtype of Number; this is the right choice because \nCell(Integer) does not support the set(Number) operation. Cell(Number) is not a sub\u00adtype of Cell(Integer); \nthis is the right choice because Cell(Number) does not support the Integer get() operation. Raw types. \nGreat e.ort was expended in the design of JSR-14 to ensure maximum compatibility with existing non-generic \ncode, in both directions. As a result, the type system of JSR-14 sub\u00adsumes that of non-generic Java, \nwith the un-parameterized types of generic classes such as Cell being known as raw types, and raw types \nbeing supertypes of parameterized versions. (A raw type can 1By contrast, Java arrays use covariant subtyping: \nInteger[] is a subtype of Number[] because Integer is a subtype of Number. This violates the substitutability \nprinciple of subtyping [28]. In order to preserve type safety, the JVM implementation must perform a \nrun\u00adtime check at array stores. Since JSR-14 uses homogeneous trans\u00adlation by type erasure (see below), \nrun-time checking for generics is impossible, and soundness must be ensured statically through invariant \nsubtyping. // A Cell is a container that contains exactly one item, of type V. class Cell<V extends Object> \n{ V value; Cell(V value) { set(value); } void set(V value) { this.value = value; } V get() { return \nvalue; } <U extends V> void replaceValue(Cell<U> that) { this.value = that.value; } } // A Pair has \na first and a second element, possibly of different types. class Pair<F, S> extends Cell<F> { S second; \n Pair(F first, S second) { super(first); this.second = second; } } Figure 2: Example generic library \ncode: de.nitions of Cell and Pair. Access modi.ers are omitted for brevity throughout. 1 static void \nexample() { 1 static void example() { 2 Cell c1 = new Cell(new Float(0.0)); 2 Cell<Float> c1 = new Cell<Float>(new \nFloat(0.0)); 3 Cell c2 = new Cell(c1); 3 Cell<Cell<Float>> c2 = new Cell<Cell<Float>>(c1); 4 Cell c3 \n= (Cell) c2.get(); 4 Cell<Float> c3 = (Cell) c2.get(); 5 Float f = (Float) c3.get(); 5 Float f = (Float) \nc3.get(); 6 Object o = Boolean.TRUE; 6 Boolean o = Boolean.TRUE; 7 Pair p = 7 Pair<Number,Boolean> p \n= 8 new Pair(f, o); 8 new Pair<Number,Boolean> (f, o); 9 9 10 Cell c4 = new Cell(new Integer(0)); 10 \nCell<Number> c4 = new Cell<Number>(new Integer(0)); 11 c4.replaceValue(c1); 11 c4.replaceValue(c1); 12 \n12 13 displayValue(c1); 13 displayValue(c1); 14 displayValue(c2); 14 displayValue(c2); 15 15 16 setPairFirst(p); \n16 setPairFirst(p); 17 17 18 displayNumberValue(p); 18 displayNumberValue(p); 19 displayNumberValue(c4); \n19 displayNumberValue(c4); 20 20 21 Boolean b = (Boolean) p.second; 21 Boolean b = (Boolean) p.second; \n22 } 22 } 23 static void setPairFirst(Pair p2) { 23 static void setPairFirst(Pair<Number,Boolean> p2) \n{ 24 p2.value = new Integer(1); 24 p2.value = new Integer(1); 25 } 25 } 26 static void displayNumberValue(Cell \nc5) { 26 static void displayNumberValue(Cell<Number> c5) { 27 Number n = (Number) c5.get(); 27 Number \nn = (Number) c5.get(); 28 System.out.println(n.intValue()); 28 System.out.println(n.intValue()); 29 } \n29 } 30 static void displayValue(Cell c6) { 30 static void displayValue(Cell c6) { 31 System.out.println(c6.get()); \n31 System.out.println(c6.get()); 32 } 32 } Figure 3: Example non-generic client code that uses the library \ncode of Figure 4: Example client code of Figure 3, after being automatically up- Figure 2. The code illustrates \na number of features of JSR-14, but it does dated to use generic types. Changed declarations are underlined. \nElimi\u00ad not compute a meaningful result. nated casts are struck through. be considered equivalent to a \ntype instantiated with a bounded exis\u00ad time. However, in JSR-14, it is possible to construct programs \nin tential type, e.g., Cell(3x . x : Object), because clients using a raw which this is not the case, \nsince raw types create a loophole in the type expect some instantiation of the corresponding generic \nclass, soundness of the type system. but have no information as to what it is [25].) Calls to methods \nand accesses of .elds whose type refers to the Unchecked operations. In standard Java, the type system \nen\u00ad type variable T of a raw type are unchecked, meaning that they may sures that the type of an expression \nis a conservative approxima\u00ad violate the invariants maintained by the non-raw types, resulting in tion \nto the kind of objects that may .ow to that expression at run a class cast exception being thrown at \nrun time. The compiler is\u00ad sues a warning when it compiles such operations. (The operations are legal \nin non-generic Java, and all the same hazards apply, ex\u00adcept that the compiler issues no warnings. Use \nof raw types is no less safe than the original code, though it is less safe than use of non-raw parameterized \ntypes.) For example, coercion is permitted from a raw type to any instantiation of it, and vice versa. \nAs an\u00adother example, one may safely call the method Vector.size() on an expression of raw type, since \nit simply returns an int. On the other hand, a call to Vector.add(x) on an expression of type raw Vector \nwould be unchecked, because there may exist an alias to the same object whose declared type is Vector(Y), \nwhere the type of x is not a subtype of Y. Subsequent operations on the object through the alias may \nthen fail due to a type error. It is the programmer s responsibility to ensure that all unchecked operations \nare in fact safe. Type erasure. The type rules of JSR-14 suggest the implemen\u00adtation strategy of type \nerasure, in which after the parameterized types have been checked, they are erased by the compiler (which \ninserts casts as necessary), yielding the type that would have been speci.ed in the original non-generic \ncode. For example, the erasure of method Cell.set(V) is Cell.set(Object). Homogeneous translation. Implementation \nby type erasure im\u00adplies a homogeneous translation. A single class .le contains the implementation for \nevery instantiation of the generic class it de\u00ad.nes, and the execution behavior is identical to that \nof the same program written without the use of generic types. Parametric type information is not available \nat run time, so one cannot query the pa\u00adrameterized type of an object using instanceof or re.ection, \nnor can the Java Virtual Machine (JVM) check for type violations at run time as it does with accesses \nto the built-in array classes. Ho\u00admogeneous translation is in contrast with approaches that change the \nJVM [31], and with C++ [40, 41] and other languages [9] in which di.erent code is generated for each \ninstantiation. 2.2.1 Versions of JSR-14 JSR-14 [27] was inspired by GJ (Generic Java) [6, 5]. Di.er\u00adent \nversions of JSR-14 have introduced and eliminated a variety of features related to parametric polymorphism. \nOur work uses the version of JSR-14 implemented by version 1.3 of the early-access JSR-14 compiler2. \nThis particular version proved longer-lived and more stable than other versions, and it is quite similar \nto the latest proposal (as of July 2004), implemented by Java 1.5 Beta 2. Java 1.5 Beta 2 has one substantive \ndi.erence from JSR-14-1.3: Java 1.5 Beta 2 s type system is enriched by wildcard types [45] such as Vector(? \nextends Number), which represents the set of Vector types whose elements are instances of Number, and \nVector(? super Integer), which represents the set of Vector types into which an Integer may be stored. \nLike raw types, wildcard types are ef\u00adfectively parameterized types whose arguments are bounded exis\u00adtential \ntypes, but wildcard types generalize this idea, allowing the bounds to express either subtype or supertype \nconstraints [25, 26]. Wildcard types obviate some (though not all) uses of raw types. Wildcard types \nwill improve the precision of our analysis by per\u00admitting closer least upper bounds to be computed for \nsome sets of types; see Section 6.5.1 for further detail. This will bene.t both the union elimination \n(Section 6.5) and constraint resolution (Sec\u00adtion 6.4) components of our algorithm. A second, minor di.erence \nis that Java 1.5 Beta 2 forbids array creation expressions for arrays of parameterized types, such as \nnew Cell<String>[..], or type variables, such as new Cell<V>[..], or new T[..] where T is a type variable. \nOther constructs, such as List.toArray(), permit working around this restriction. 2 http://java.sun.com/developer/earlyAccess/adding_generics/ \n We do not foresee any major obstacles to the adaptation of our type rules, algorithms, and implementation \nto Java 1.5; such adap\u00adtation is important to the usability of our tools once Java 1.5 is .nalized. \n3. DESIGN PRINCIPLES We designed our analysis in order to be sound, behavior preserv\u00ading, compatible, \ncomplete, and practical. This section describes each of these inter-related principles, then gives the \nmetric (cast elimination) that we use to choose among multiple solutions that .t the constraints. Finally, \nwe explicitly note the assumptions upon which our approach relies. 3.1 Soundness The translation must \nbe sound: the result of the analysis must be a type-correct JSR-14 program. Crucially, however, in the \npresence of unchecked operations, simply satisfying the compiler s type\u00adchecker does not ensure type \nsafety. For instance, there exist type-correct programs in which a vari\u00adable of type Cell(Float) may \nrefer to a Cell containing an Integer. Such typings arise from the unsafe use of unchecked operations. \nWe require that all unchecked operations in the translated pro\u00adgram are safe, and are guaranteed not \nto violate the invariants of any other type declaration. This guarantee cannot be made using only local \nreasoning, and requires analysis of the whole program. 3.2 Behavior preservation The translation must \npreserve the dynamic behavior of the code in all contexts. In particular, it must not throw di.erent \nexceptions or di.er in other observable respects. It must interoperate with ex\u00adisting Java code, and \nwith JVMs, in exactly the same way that the original code did. The translation should also preserve the \nstatic structure and the design of the code, and it should not require man\u00adual rewriting before or after \nthe analysis. To help achieve these goals, we require that our analysis changes only type declarations \nand types at allocation sites; no other mod\u00adi.cations are permitted. Changing other program elements \ncould change behavior, cause the code to diverge from its documentation (and from humans understanding), \nand degrade its design, leading to di.culties in understanding and maintenance. This implies that inconvenient \nidioms may not be rewritten, nor may dead code be eliminated. (The type-checker checks dead code, and \nso should an analysis.) We leave such refactoring to humans or other tools. Furthermore, we do not permit \nthe erasure of any method signa\u00adture or .eld type to change. For instance, a .eld type or method parameter \nor return type could change from Cell to Cell(String), but not from Object to String. Changing .eld or \nmethod signatures would have far-ranging e.ects; for instance, method overriding re\u00adlationships would \nchange, a.ecting the semantics of clients or sub\u00adclasses that might not be in the scope of the analysis. \nIf the tool is working under a closed-world assumption, then it may o.er the option to change .eld and \nmethod signatures as long as the behav\u00adior is preserved. We permit changing the declared types of local \nvariables, so long as the new type is a subtype of the old, because such changes have no externally visible \ne.ect.3 Finally, we do not permit any changes to the source code of the library or the generic information \ncontained in the compiled 3This statement is not strictly true, even though the type of local variables \nis not captured in the byte codes. The types of locals can a.ect method overloading resolution and which \nversion of a .eld (that is re-declared to shadow one in a superclass) is accessed. Therefore, an implementation \nshould ensure that such behavioral changes do not occur. bytecode of the library. The analysis should \nnot even need library source code, which is often unavailable. It is straightforward to see that these \nconstraints ensure behavior preservation. The new code di.ers only in its type erasure and in the types \nof local variables; neither of these is captured in the bytecodes that run on the JVM, so the bytecodes \nare identical. (The signature attribute, which records the type parameters, is ignored by the virtual \nmachine.)   3.3 Compatibility We constrain ourselves to the con.nes of the JSR-14 language rather than \nselecting or inventing a new language that permits eas\u00adier inference or makes di.erent tradeo.s. (For \nexample, some other designs are arguably simpler, more powerful, or more expressive, but they lack JSR-14 \ns integration with existing Java programs and virtual machines.) Invariant parametric subtyping, raw \ntypes, and other features of the JSR-14 type system may be inconvenient for an analysis, but ignoring \nthem sheds no light on JSR-14 and is of no direct practical interest to Java programmers. Therefore, \nwe must address the (entire) JSR-14 language, accepting the engineer\u00ading tradeo.s made by its designers. \n 3.4 Completeness We strive to provide a nontrivial translation for all Java code, rather than a special-case \nsolution or a set of heuristics. Java code is written in many styles and paradigms, and relies on many \ndi.erent libraries. The absolute amount of code not covered by a partial solution is likely to be very \nlarge. A few important libraries, such as those distributed with the JDK, are very widely used. Special-case \nsolutions for them may be valu\u00adable [42], and such an approach is complementary to ours. How\u00adever, such \nan approach is limited by the fact that many substantial programs (two examples are javac and antlr) \nde.ne their own con\u00adtainer classes rather than using the JDK versions. Our approach works equally well \nwith non-containers. Many generic classes implement container abstractions, but not all do. For example, \nclass java.lang.Class, or the java.lang.ref package which uses generics to provide support for typed \nweak references. Our implementation also uses them for I/O adapters that convert an object of one type \nto another (say, type T to String), and the C++ Standard Template Library [37] provides additional examples. \n 3.5 Practicality Our goal is not just an algorithm for computing type arguments, but also a practical, \nautomated tool that will be of use to Java pro\u00adgrammers. For any legal Java program, the tool should \noutput legal JSR-14 code. Furthermore, if it is to be widely useful, it should not rely on any speci.c \ncompiler, JVM, or programming environment. (On the other hand, integrating it with a programming environment, \nwithout relying on that environment, might make it easier to use.) A practical tool should not require \nany special manual work for each program or library, and touch-ups of the inputs or results should not \nbe necessary. Equally importantly, as a follow-on to a point made above, special preparation of each \nlibrary is not ac\u00adceptable, because library code is often unavailable (for example, it was not provided \nwith the JSR-14 compiler that we are using), be\u00adcause library writers are unlikely to cater to such tools, \nand because human tweaking is error-prone and tedious.  3.6 Success metric: cast elimination There are \nmultiple type-correct, behavior-preserving JSR-14 trans\u00adlations of a given Java codebase. Two trivial \nsolutions are as fol\u00ad interface I {} class A {} class B1 extends A implements I {} class B2 extends \nA implements I {} // Three possible typings: void foo(boolean b) { // #1 | #2 | #3 Cell cb1 = new Cell(new \nB1()); // Cell<A> | Cell<I> | Cell<B1> Cell cb2 = new Cell(new B2()); // Cell<A> | Cell<I> | Cell<B2> \nCell c = b ? cb1 : cb2; // Cell<A> | Cell<I> | Cell // Casts eliminated: A a = (A)c.get(); // yes | no \n| no I i = (I)c.get(); // no | yes | no B1 b1 = (B1)cb1.get(); // no | no | yes B2 b2 = (B2)cb2.get(); \n// no | no | yes } Figure 5: Java code with multiple non-trivial JSR-14 translations. lows. (1) The \nnull translation, using no type arguments. JSR-14 is a superset of Java, so any valid Java program is \na valid JSR-14 program in which each type is a JSR-14 raw type. (2) Instantiate every use of a generic \ntype at its upper bounds, and retain all casts that appear in the Java program. For example, each use \nof Cell would become Cell(Object). These trivial solutions reap none of the bene.ts of parametric polymorphism. \nFigure 5 shows an example fragment of code for which multiple translations are possible. As shown in \nthe .gure, three possible typings are 1. cb1, cb2, and c are all typed as Cell(A) 2. cb1, cb2, and c \nare all typed as Cell(I) 3. cb1 is typed as Cell(B1); cb2 is typed as Cell(B2); and c is typed as (raw) \nCell. In this case c cannot be given a non-raw type due to invariant subtyping.  Because the intent \nof the library and client programmers is un\u00adknowable, and because di.erent choices capture di.erent proper\u00adties \nabout the code and are better for di.erent purposes, there is no one best translation into JSR-14. As \na measure of success, we propose counting the number of casts that can be eliminated by a particular \ntyping. Informally, a cast can be eliminated when removing it does not a.ect the pro\u00adgram s type-correctness. \nCast elimination is an important reason programmers might choose to use generic libraries, and the metric \nmeasures both reduction in code clutter and the amount of infor\u00admation captured in the generic types. \n(Casts are used for other pur\u00adposes than for generic data types as just two examples, to express invariants \nknown to the application, or to resolve method overload\u00ading so the .nal JSR-14 program is likely to \nstill contain casts.) If two possible typings eliminate the same number of casts, then we prefer the \none that makes less use of raw types. Tools could prior\u00aditize removing raw types over removing casts \nif desired. However, some use of raw types is often required in practice. In practice, when we have examined \nanalysis results for real\u00adworld code, this metric has provided a good match to what we be\u00adlieved a programmer \nwould consider the best result. As an example of the metric, Figure 5 shows that the .rst two typings \nremove one cast each; the third removes two casts, leaving c as a raw type. It is not always desirable \nto choose the most precise possible type for a given declaration, because it may lead to a worse solu\u00adtion \nglobally: precision can often be traded o. between declaration sites. In Figure 5, as a result of invariant \nparametric subtyping, the types of c, cb1, and cb2 may all be equal, or cb1 and cb2 can have more speci.c \ntypes if c has a less speci.c type. Another situation in which the use of raw types is preferred over \nthe use of non-raw types is illustrated by the method displayValue on lines 30 32 of Figure 4. If its \nparameter were to be made non-raw, the type argument must be Object, due to constraints imposed by the \ncalls at lines 13 and 14. This has many negative rami.cations. For ex\u00adample, c1 and c2 would have type \nCell(Object) and c3 would have raw Cell, and the casts at lines 4 and 5 could not be eliminated.  3.7 \nAssumptions In this section we note some assumptions of our approach. We assume that the original library \nand client programs conform to the type-checking rules of JSR-14 and Java, respectively. (This is easy \nto check by running the compilers.) The client code is Java code containing no type variables or pa\u00adrameters; \nthat is, we do not re.ne existing JSR-14 types in client code. We do not introduce new type parameters; \nfor instance, we do not parameterize either classes or methods in client code. (The type parameterization \nproblem is beyond the scope of this paper and appears to be of less practical importance.) Our analysis \nis whole-program rather than modular; this is nec\u00adessary in order to optimize the number of casts removed \nand to ensure the use of raw types is sound (Section 3.1). Furthermore, we make the closed-world assumption, \nbecause we use constraints generated from uses in order to choose declaration types. 4. ALGORITHM SYNOPSIS \nOur goal is to select sound type arguments for each use of a generic type anywhere in the program. We \ndivide this task into two parts: allocation type inference and declaration type inference. Allocation \ntype inference (Section 5) proposes types for each al\u00adlocation site (use of new) in the client code. \nIt does so in three steps. First, it performs a context-sensitive pointer analysis that de\u00adtermines the \nset of allocation sites to which each expression may refer. Second, for each use (method call or .eld \naccess) of an ob\u00adject of generic type, it uni.es the pointer analysis information with the declared type \nof the use, thereby constraining the possible in\u00adstantiation types of the relevant allocation sites. \nThird, it eliminates union types, which it uses internally to delay the choosing of com\u00admon supertypes, \nsince JSR-14 types do not always commute under this operation. The output of the allocation type inference \nis a con\u00adservative parameterized type for each object allocation site. For example, in Figure 4, the \nresults of allocation type inference for the three allocations of Cell on lines 2, 3, and 10 are Cell(Float), \nCell(Cell(Float)), and Cell(Number), respectively. Declaration type inference (Section 6) starts with \nthe allocation type inference s output, and selects types for all uses of parame\u00adterized types, including \ndeclarations (.elds, locals, and method pa\u00adrameters and returns), casts, and allocation sites. At allocation \nsites, it need not necessarily choose the type proposed by the allocation\u00adsite inference (though our \ncurrent implementation does; see Sec\u00adtion 6.4). It operates in two steps. The .rst step creates a type \ncon\u00adstraint graph that expresses the requirements of the JSR-14 type system; this graph includes variables \n(type unknowns) that stand for the type arguments at generic instantiations. The second step solves the \ntype constraints, yielding a JSR-14 typing of the entire program. Finally, our tools insert type parameters \ninto the original program s source code. The allocation type inference is a whole-program analysis; this \nis required for safety, as explained in Section 3.1, as local analysis cannot provide a guarantee in \nthe presence of unchecked opera\u00adtions. It is context-sensitive, and is potentially more precise than \nthe JSR-14 type system. The declaration type inference is context-insensitive, and its out\u00adput is sound \nwith respect to the JSR-14 type system. It can be supplied a whole program, but can also be run on any \nsubpart of a T ::= C raw type | C(T1,...,Tn) class type | T type variable | obj(Ci) type identi.er for \nallocation site Ci |{T1,...,Tn} union type | Null the null type Figure 6: Type grammar for allocation \ntype inference. program, in which case it frames the boundaries constrains the types at the interface \nso that they will not change giving possibly inferior results. 5. ALLOCATION TYPE INFERENCE Allocation \ntype inference determines possible instantiations of type parameters for each allocation site that is, \neach use of new in the client code. The goal is to soundly infer the most precise type (that is, the \nleast type in the subtype relation) for each allocation site. Soundness requires that the allocation-site \ntype be consistent with all uses of objects allocated there, no matter where in the program those uses \noccur. As an example, suppose that the allocation type inference examined only part of the code and decided \nto convert an instance of c = new Cell() into c = new Cell<Integer>(). If some unexamined code executed \nc.set(new Float(0.0)), then that code would not type-check against the converted part (or, if it was \nalready compiled or it used a raw type reference, it would sim\u00adply succeed and cause havoc at run time). \nAlternatively, the pointer analysis can avoid examining the whole program by making con\u00adservative approximations \nfor the unanalyzed code, at the cost of re\u00adduced precision. Thus, our allocation type inference could \nbe made modular, by running over a scope smaller than the whole program, but at the cost of unsoundness, \nreduced precision, or both. 5.1 De.nitions and terminology Figure 6 gives the type grammar used by the \nallocation type in\u00adference. It is based on the grammar of reference types from the JSR-14 type system. \nFor brevity, we omit array types, including primitive array types, although our formalism can be easily \nex\u00adtended to accommodate them. By convention we use C for class names and T for type variables; the distinction \nbetween these is clear from the class declarations in a program. In addition to JSR-14 types, the grammar \nincludes three other types used only during the analysis. Allocation site types: Every allocation site \nof each generic class C is given a unique label, Ci, and for each such label a unique type identi.er \nobj(Ci) is created [48]. This type identi.er represents the type of all objects created at that allocation \nsite. Some allocation sites within generic library code may be analyzed many times, due to context-sensitivity \n(see Section 5.4), and for such sites, a new label and type identi.er are created each time. All allocations \nof a non-generic class share the same label. Union types: A union type represents the least common super\u00adtype \n( join ) of a set of types without computing it immediately. Union types defer the computation of a join \nuntil the complete set of types is known, minimizing loss of precision from arbitrary choices when a \nset of Java types does not have a unique join due to multi\u00adple inheritance. The use of union types in \nnot strictly necessary for correctness; we could eliminate them earlier (at each point where they would \notherwise be introduced), but at the cost of reduced pre\u00adcision. The Null type: The Null type denotes \nthe type of the null pointer, and is a subtype of every other type.  5.2 Allocation type inference \noverview The allocation type inference consists of three steps: pointer analysis, s-uni.cation, and resolution \nof parametric types. The out\u00adput of the allocation-type inference is a parameterized type for each allocation \nsite that conservatively approximates all subsequent uses of the allocated object. 1. Pointer analysis \n(Section 5.4) abstracts every expression e in the program by a set of allocation-site labels, points-to(e). \nThe presence of a label Ci in this set indicates that objects created at Ci may .ow to e, or, equivalently, \nthat e may point to objects created at Ci. points-to sets generated by a sound pointer analysis are a \nconservative over-approximation of all possible executions of the program: the results can indicate that \ne may point to Ci when this cannot actually occur. A more precise pointer analysis produces a smaller \npoints-to set. Many di.erent pointer analysis algorithms exist, di.ering in pre\u00adcision, complexity, \nand cost [23]. We use a context-sensitive pointer analysis based on the Cartesian Product Algorithm [1]. \n 2. S-uni.cation (Section 5.5) combines the results of pointer analysis with the declarations of generic \nlibrary classes in order to generate subtype constraints. Its name comes from its similarity to conventional \nuni.cation: both generate constraints by structural in\u00adduction over types. S-uni.cation stands for uni.cation \nwith sub\u00adtyping . Whereas conventional uni.cation identi.es two terms by equating variables with their \ncorresponding subterms, s-uni.cation generates subtype constraints between variables and terms.  At \neach invocation of a generic library method, one s-uni.cation is performed for the result, if any, and \none is performed for each method parameter. Furthermore, for each allocation site of a generic library \nclass, one s-uni.cation is performed for each .eld of the class. S-uni.cation is a worklist algorithm. \nGeneric classes can refer to other generic classes (for instance, when inferring nested generic types \nsuch as Cell( Cell( Integer>>), so if more information becomes available, previous s-uni.cations may \nneed to be re-done. The result of s-uni.cation is a set of constraints on the values of the type variables \nat each generic class allocation site. For ex\u00adample, Cell( V> has method set(V). If we determine that \nfor the code c.set(x), points-to(x) = { obj(String)} and points-to(c) = { obj(Cell2)} , then we know \nthat the instantiation of V in obj(Cell2) must allow a String to be assigned to it. In other words, we \nknow that String is a subtype of the instantiation of V in obj(Cell2 ). We write this as String : Vobj(Cell2); \nsee Section 5.5. The s-uni.cation step is necessary because while pointer analy\u00adsis can distinguish di.erent \ninstances of a given class (for example, two distinct allocations of Cell), it does not directly tell \nus the type arguments of the parameterized types: it doesn t know that one is a Cell( Number> while another \nis a Cell( Cell( Number>> . The s\u00aduni.cation step examines the uses of those Cells, such as calls to \nset, to determine the instantiation of their type variables. 3. Resolution of parametric types (Section \n5.6). For each pa\u00adrameter of every allocation site of a generic class, the s-uni.cation algorithm infers \na set of subtype constraints. Taken together, each set can be considered a speci.cation of the instantiation \ntype of one type-parameter as a union type. For example, in Figure 9, obj(Cell10 ) has two constraints, \nInteger : Vobj(Cell10) and Float : Vobj(Cell10); equivalently, we say that obj(Cell10 ) has the union \ntype { Integer, Float} . If the program being analyzed uses generic types in a nested fashion, such as \nCell( Cell( Float>> , 4 then the union types may re\u00ad 4This use of nested refers to lexical nesting of \ngeneric type ar\u00adguments. It is unrelated to the Java notion of a nested class (class Local points-to \nset c1 { obj(Cell2)} c2 { obj(Cell3)} c3 { obj(Cell2)} c4 { obj(Cell10)} f { obj(Float)} Figure 7: points-to \nsets for local variables in the example of Figure 8. fer to other allocation types rather than classes. \nIn this case, the types must be resolved to refer to classes. See . 5.3 Example We illustrate the algorithm \nwith a code fragment from Figure 3: 2 Cell c1 = new Cell2(new Float(0.0)); 3 Cell c2 = new Cell3(c1); \n4 Cell c3 = (Cell) c2.get(); 5 Float f = (Float) c3.get(); 10 Cell c4 = new Cell10(new Integer(0)); 11 \nc4.replaceValue(c1); The allocation sites at lines 2, 3, and 10 are labeled Cell2, Cell3, and Cell10, \nand their types are obj(Cell2 ), obj(Cell3 ), and obj(Cell10 ). obj(Float) and obj(Integer) are not numbered: \nFloat and Integer are not generic classes, so all of their instances are considered iden\u00adtical. Figures \n7 9 demonstrate the operation of the allocation type in\u00adference algorithm. The .rst step is pointer analysis. \nFigure 7 shows the points-to sets (the output of the pointer analysis) for local variables, and Fig\u00adure \n8 shows the points-to sets of other expressions of interest. For each expression, the result of the pointer \nanalysis is the set of allo\u00adcation sites that it may point to at run-time. In this example, only Cell10.value \npoints to more than a single site. The second step is s-uni.cation, which is performed for each generic \nclass .eld, method call result, and method call parame\u00adter. The S-uni.cations column of Figure 8 shows \nthe s-uni.cations (calls to the s-unify procedure), and the resulting inferences about the instantiations \nof type variables. Informally, s-unify(context, lhs, rhs) means within the context of allocation site \ncontext, constrain the free type variables in lhs so that rhs : lhs . Section 5.5 discusses s-uni.cation \nfor this example in more detail. The third step is resolution of the s-uni.cation type constraints. Figure \n9 illustrates this process. S-uni.cation produced two di.er\u00adent constraints for Vobj(Cell10) obj(Integer) \n: V and obj(Float) : V so we represent the type of Vobj(Cell10) by the union type { obj(Float), obj(Integer)} \n. Union types may be eliminated (Section 6.5) by selecting a most precise JSR-14 type that is a supertype \nof this union in this case, it would be V = Number, resulting in the type Cell( Number> for obj(Cell10) \n but this step is not required as union types may be passed on to the next phase of the algorithm. 5.4 \nPointer analysis Pointer analysis is the problem of soundly approximating what possible allocation sites \nmay have created the object to which an expression refers; thus, it also approximates the possible classes \nof the expression. This information has many uses in program analy\u00adsis, for example in static dispatch \nof virtual methods [10, 11, 3, 44], construction of precise call graphs [14, 22], and static elimination \nof casts [48]. whose declaration occurs within the body of another class or inter\u00adface) [21]. Line Expression \npoints-to set S-uni.cations 2 new Cell2( ) {obj(Float)} s-unify(obj(Cell2), V, {obj(Float)}) ==16 s-unify(obj(Cell2), \nV, obj(Float)) ==29 obj(Float) : Vobj(Cell2) 3 new Cell3( ) {obj(Cell2)} s-unify(obj(Cell3), V, {obj(Cell2)}) \n==16 s-unify(obj(Cell3), V, obj(Cell2)) ==29 obj(Cell2 ) : Vobj(Cell3) 4 Cell3.get() {obj(Cell2)} (same \nas for new Cell3( )) 5 Cell2.get() {obj(Float)} (same as for new Cell2( )) 10 new Cell10( ) {obj(Integer)} \ns-unify(obj(Cell10), V, {obj(Integer)}) ==16 s-unify(obj(Cell10), V, obj(Integer)) ==29 obj(Integer) \n: Vobj(Cell10) 11 Cell10.replaceValue( ) {obj(Cell2)} s-unify(obj(Cell10), Cell(U), {obj(Cell2)}) ==16 \ns-unify(obj(Cell10), Cell(U), obj(Cell2)) (*) ==42 s-unify(obj(Cell10 ), Cell(U), Cell({obj(Float)})) \n==38 s-unify(obj(Cell10 ), U, {obj(Float)}) ==22 s-unify(obj(Cell10), V, {obj(Float)}) ==16 s-unify(obj(Cell10), \nV, obj(Float)) ==29 obj(Float) : Vobj(Cell10) Cell2.value {obj(Float)} (same as for new Cell2( )) Cell3.value \n{obj(Cell2)} (same as for new Cell3( )) Cell10.value {obj(Integer), obj(Float)} s-unify(obj(Cell10), \nV, {obj(Integer), obj(Float)}) ==16 s-unify(obj(Cell10), V, obj(Integer)) ==29 obj(Integer) : Vobj(Cell10) \n==16 s-unify(obj(Cell10), V, obj(Float)) ==29 obj(Float) : Vobj(Cell10) Figure 8: Example of s-uni.cation, \nfor lines 2 5 and 10 11 of Figure 3. The table shows, for each .eld and method call of a generic class, \nits points-to set, and the calls to s-unify issued for it. A bullet indicates that the points-to set \nis for the value of an actual parameter to a method call. A snapshot (see Section 5.5) of obj(Cell2) \nis taken where indicated by the asterisk (*). Subscripts on arrows indicate the line number in Figure \n10 at which the recursive call appears or the constraint is added. S-uni.cation constraints lbounds values \nResolved types JSR-14 types obj(Float) : Vobj(Cell2) obj(Cell2) : Vobj(Cell3) obj(Integer) : Vobj(Cell10) \nobj(Float) : Vobj(Cell10) Vobj(Cell2) = {obj(Float)} Vobj(Cell3) = {obj(Cell2)} Vobj(Cell10) = {obj(Integer), \nobj(Float)} obj(Cell2) = Cell(Float) obj(Cell3) = Cell(Cell(Float)) obj(Cell10) = Cell({Integer, Float}) \nobj(Cell2 ) = Cell(Float) obj(Cell3 ) = Cell(Cell(Float)) obj(Cell10 ) = Cell(Number) Figure 9: Resolution \nof s-uni.cation constraints. The .rst column shows the constraints arising from the s-unify calls of \nFigure 8. The second column shows the equivalent union types; note that obj(Cell3) depends on the type \nof obj(Cell2). The third column shows the .nal allocation-site types after type resolution. The fourth \ncolumn shows what the result would be, if union types were eliminated at this stage. To achieve greater \nprecision, a context-sensitive analysis may repeatedly examine the e.ect of a statement, or the value \nof a variable, in di.ering contexts. Our pointer analysis employs both kinds of context sensitivity, \ncall and data. This permits distinguish\u00ading among di.erent instances of a single generic class: one new \nCell() expression may create Cell(Integer), while another cre\u00adates Cell(Float). By Celli creates Cell(Integer) \n, we mean that instances of class Cell allocated at Celli are used only to contain Integers. Our method \napplies equally well to generic classes that are not containers. A call context-sensitive pointer analysis \nmay analyze a method more than once depending on where it was called from or what values were passed \nto it. Each specialized analysis of the same method is called a contour, and a contour selection function \nmaps from information statically available at the call-site to a contour. The contour selection function \nmay either return an existing con\u00adtour or create a new one. If the contour is new, the method must be \nanalyzed from scratch. For an existing contour, re-analysis of the method is necessary only if the new \nuse of the contour causes new classes to .ow to it; if the re-analysis causes the results to change, \nthen additional contours that depend on the result must be re-analyzed until a .xed point is reached. \n Data context-sensitivity concerns the number of separate abstrac\u00adtions of a single variable in the source \ncode. An insensitive algo\u00adrithm maintains a single abstraction of each .eld, and is unable to distinguish \nbetween the values of corresponding .elds in di.er\u00adent instances of the same class. In contrast, a data \ncontext-sensitive scheme models .elds of class C separately for each distinctly-labeled allocation-site \nof class C. Data context-sensitivity is sometimes called .eld cloning or the creation type scheme [48]. \nLimiting either call or data context-sensitivity reduces execution time but may also reduce the precision \nof the analysis results. Our technique uses a variant of Agesen s Cartesian Product Al\u00adgorithm (CPA) \n[1]. We brie.y explain that algorithm, then explain our variation on it. CPA is a widely-used call-context-sensitive \npointer analysis al\u00adgorithm. CPA uses an n-tuple of allocation-site labels (c1,..., cn) as the contour \nkey for an n-ary method f (x1,..., xn). The key is an element of C1 \u00d7 ... \u00d7 Cn, where each Ci is the \nset of classes that .ow to argument xi of method f at the call-site being analyzed. The execution time \nof CPA is potentially exponential, due to the number of keys the size of the cross-product of classes \n.owing to the arguments at a call-site. To enable CPA to scale, it is necessary to limit its context-sensitivity. \nTypically, this is achieved by im\u00adposing a threshold L on the size of each argument set. When more than \nL classes .ow to a particular argument, the contour selection function e.ectively ignores the contribution \nof that argument to the cross-product by replacing it with the singleton set {*}, where * is a special \nmarker. Call-sites treated in this way are said to be meg\u00adamorphic. The reduction in precision in this \napproach is applied to only those call sites at which the threshold is exceeded; at another call-site \nof the same method, analysis of the same parameter may be fully context-sensitive. CPA is primarily used \nfor determining which classes .ow to each use, so in the explanation of CPA above, the abstract values \nde\u00adscribed were classes. The abstraction in our variant of CPA is al\u00adlocation site type identi.ers, which \nis more precise since it distin\u00adguishes allocations of the same class. Our variant of CPA limits both \ncall and data context-sensitivity so that they apply only to the generic parts of the program. This policy \n.ts well with our intended application, for it reduces analysis costs while limiting negative impacts \non precision. First, to reduce call sensitivity, our contour selection function makes all non-generic \nmethod parameter positions megamorphic. More precisely, only those parameter positions (and this) whose \ndeclared type contains a type variable are analyzed polymorphi\u00adcally. Thus, only generic methods, and \nmethods of generic classes, may be analyzed polymorphically. We do not employ a limit-based megamorphic \nthreshold. For example, Cell.set(V) may be analyzed arbitrarily many times, but a single contour is used \nfor all calls to PrintStream .println(Object x), because neither its this nor x parameters contains a \ntype variable. Calls to a method f(Set<T> x, Object y) would be analyzed context-sensitively with respect \nto parameter x, but not y. A few heavily-used non-generic methods, such as Object.clone and System.arraycopy, \nneed to be treated context-sensitively. We provide annotations to the analysis to ensure this treatment \nand prevent a loss of precision. Additional methods can be annotated using the same mechanism to ensure \nprecise treatment as required. Second, to reduce data sensitivity, we use the generic type infor\u00admation \nin libraries to limit the application of data context-sensitivity to .elds. Only .elds of generic classes, \nwhose declared type in\u00adcludes a type variable, are analyzed sensitively. For example, a separate abstraction \nof .eld Cell.value (declared type: V) is cre\u00adated for each allocation site of a Cell, but only a single \nabstraction of .eld PrintStream.textOut (of type BufferedWriter) is cre\u00adated for the entire program. \nOur implementation of the pointer analysis is similar to the frame\u00adwork for context-sensitive constraint-based \ntype inference for ob\u00adjects presented by Wang and Smith [48]. Their framework per\u00admits use of di.erent \ncontour-selection functions and data context\u00adsensitivity functions (such as their DCPA [48]); our choices \nfor these functions were explained immediately above. Our implemen\u00adtation adopts their type constraint \nsystem and closure rules. The analysis generates a set of initial type constraints from the program, \nand iteratively applies a set of closure rules to obtain a .xed point solution to them. Once the closure \nis computed, the points-to sets can be read o. the resulting type-constraint graph. In summary, pointer \nanalysis discovers the types that .ow to the .elds and methods of a class, for each allocation site of \nthat class. However, this information alone does not directly give a parame\u00adterized type for that allocation \nsite: we must examine the uses of 1 // s-unify uni.es lhs with rhs, in the process constraining, in 2 \n// lbounds, the type variables of context so that rhs : lhs. 3 // context is an allocation site of a \ngeneric class C. 4 // lhs is the type of a JSR-14 declaration appearing within class 5 // C, typically \ncontaining free type variables of C. 6 // rhs is a type, typically a union of obj(Ci) types denoting \na 7 // points-to-set; it never contains free type variables. 8 procedure s-unify(context, lhs, rhs) 9 \nif lhs has no free type variables then  10 return 11 // First, switch based on rhs 12 if rhs = Null \nthen 13 return 14 else if rhs = {T1,. . . ,Tn} then // Union type 15 for all Ti E rhs do 16 s-unify(context, \nlhs, Ti) 17 return 18 // Second, switch based on lhs 19 if lhs = T then // Type variable 20 if T is declared \nby a generic method then 21 for all b E bounds(T) do 22 s-unify(context, b, rhs) 23 return 24 let tclass \n:= the class that declares T 25 if tclass * class(context) then 26 let lhs' := instantiation expression \nof T in class(context) 27 s-unify(context, lhs' , rhs) 28 return 29 lbounds(context, lhs):= lbounds(context, \nlhs) U{rhs} 30 if lbounds changed then 31 for all (c, l, r) E reunify | r = lhs do 32 s-unify(c, l, r) \n 33 return 34 else if lhs = C(T1,...,Tn> then // Class type 35 if rhs = D(T1',...,T'> then m C(T'' 36 \nlet rhs' := widen(rhs, C) // rhs' = 1 ,...,T''n > 37 for 1 : i : n do 38 s-unify(context,Ti,T''i ) 39 \nreturn 40 else if rhs = obj(Ci) then 41 reunify := reunify U{(context, lhs, rhs)} 42 s-unify(context, \nlhs, snapshot(rhs)) 43 return 44 else 45 error: This cannot happen 46 else // There are no other possibilities \nfor lhs 47 error: This cannot happen Figure 10: S-uni.cation algorithm. the objects (allocated at the \nsite) in order to determine the type ar\u00adguments. It is necessary to unify the pointer analysis results \nfor .elds and methods with their declared types in order to discover constraints on the instantiation \ntype for the allocation site. The uni\u00ad.cation process is the topic of the next section.   5.5 S-uni.cation \nS-uni.cation combines the results of pointer analysis with the declarations of generic library classes \nin order to generate subtype constraints. S-uni.cation has some similarity to the uni.cation used in \ntype inference of ML and other languages. Both are de\u00ad.ned by structural induction over types. Conventional \nuni.cation points-to(expr) is the pointer-analysis result for expr: a union type whose elements are the \nallocation site type identi.ers obj(Ci) that expr may point to. lbounds(context, typevar) is the (mutable) \nunion type whose ele\u00adments are the discovered lower-bounds on type variable type\u00advar within allocation \nsite type context. snapshot(obj(Ci)) = C(S1,..., Sn) where Sj = lbounds(obj(Ci), T j) and T j is C s \njth type variable. reunify is a global set of triples (obj(Ci), T, obj(Dj)). The presence of a triple \n(context, lhs, rhs) E reunify indicates that a call to s-unify with those arguments depended upon the \ncurrent value of lbounds(rhs), and that if that value should change, the call should be re-issued. bounds(T) \nreturns the set of upper bounds of a type variable T. widen(D(T1,...,Tn), C) returns the (least) supertype \nof D(T1,...,Tn) whose erasure is C. class(obj(Ci)) = C is the class that is constructed at allocation \nsite Ci. Figure 11: S-uni.cation helper de.nitions. identi.es two terms by .nding a consistent substitution \nof the vari\u00adables in each term with the corresponding subterm; the substitution, or uni.er, is a set \nof equalities between variables and subterms In s-uni.cation, the uni.er is a set of inequalities, or \nsubtype con\u00adstraints. S-uni.cation also di.ers in that it is a worklist algorithm: as new information \nbecomes available, it may be necessary to re\u00adpeat some s-uni.cations. S-uni.cation is performed by the \ns-unify procedure of Figure 10. It can be thought of as inducing the subtype constraint rhs : lhs resulting \nfrom the Java assignment lhs = rhs; . The three parame\u00adters of the s-unify procedure are as follows. \nThe context argument is the type identi.er of an allocation site of generic class C, whose variables \nare to be constrained. The lhs argument is the declared type of a JSR-14 .eld or method parameter declaration \nappearing within class C. The rhs argument is typically the corresponding points-to set that is, a union \nof allocation site types for decla\u00adration lhs inferred by the pointer analysis of Section 5.4. Figure \n11 lists several helper de.nitions used by the s-uni.cation algorithm. S-uni.cation infers, for each \ntype variable T of each distinct al\u00adlocation site type obj(Ci), a set of types, each of which is a lower \nbound on the instantiation of the type variable; in other words, it in\u00adfers a union type. When s-uni.cation \nis complete, this union type captures all the necessary constraints on the instantiation of the type \nvariable. These lower bounds are denoted lbounds(context, typevar), where context is an allocation site \ntype, and typevar is a type variable be\u00adlonging to the class of the allocation. (Vobj(Cell10) is shorthand \nfor lbounds(obj(Cell10), V).) All lbounds are initialized to the empty union type, and types are added \nto them as s-uni.cation proceeds. After the pointer analysis of Section 5.4 is complete, s-unify is called \nfor each .eld and method de.ned in the generic classes in the program. Speci.cally, it is called for \neach context-sensitive abstraction of a .eld or method parameter or result. Our example has three di.erent \nCell allocation sites, each with a distinct abstraction of .eld value, so s-unify is called once for \neach. The information in Figure 8 is therefore data context-sensitive. In these calls to s-unify, the \ncontext argument is the allocation site type, lhs is the declared type of the .eld, and rhs is the points-to \nset of the .eld. (See the last three rows of Figure 8.) In contrast, a single abstraction is used for \nall instances of Float, since it is non-generic (s-unify is not called for non-generic types). Similarly, \nthere may be many context-sensitive method-call ab\u00adstractions for a single source-level call site (although \nin our small example, they are one-to-one). s-unify is called once for each for\u00admal parameter and return \nparameter at each such call. The in\u00adformation in Figure 8 is therefore call context-sensitive. In these \ncalls to s-unify, the context argument is the allocation site type of the receiver expression (in our \nexample it is the sole element of points-to(this)), lhs is the declared type of the method parame\u00adter, \nand rhs is the points-to set of the argument or result. In con\u00adtrast, a single abstraction would be maintained \nfor all calls to a non-generic method such as PrintStream.println (not shown). See Section 5.4 for more \ndetails. To build some initial intuitions of the workings of the algorithm before showing all details \nof its operation, we present the steps per\u00adformed for some expressions of Figure 8. The Cell constructor \ns formal parameter type is V, and at new Cell3( ) on line 3, the actual parameter points to obj(Cell2 \n). There\u00adfore, whatever type is ascribed to obj(Cell2), it must be assignable to (i.e., a subtype of) \nthe type of V in obj(Cell3). This requirement is expressed by issuing a call to s-unify(obj(Cell3 ), \nV, {obj(Cell2)}). When processing Cell10.value, uni.cation against a non-trivial union type results in \nmultiple recursive calls to s-unify. In the second line of the replaceValue s-uni.cation call, in\u00addicated \nby the asterisk (*) in Figure 8, s-unify must unify Cell(U) with obj(Cell2). However, the type of obj(Cell2) \nis not yet known the goal of allocation type inference is to determine constraints on the obj types. \nTo permit uni.cation to proceed, s-unify uses, in place of obj(Cell2), a snapshot: the type implied by \nits current constraints. In this case, because the only constraint on Cell2 is obj(Float) : Vobj(Cell2), \nthe snapshot is Cell({obj(Float)}). If subse\u00adquent uni.cations add any new constraints on obj(Cell2), \nthen the snapshot changes and the uni.cation must be re-performed. Re\u00aduni.cation is not necessary in \nour example. As can be seen from the duplicated entries in the S-uni.cations column of Figure 8, there \nis signi.cant redundancy in the Cell ex\u00adample. The formal parameter to method set (which is not used \nby this part of the client code), the result of method get, and the .eld value are all of declared type \nV. Since the points-to sets for all three of these will typically be identical, many of the uni\u00ad.cations \nissued will be identical. In this particular case, it would su.ce for the algorithm to examine just the \nvalue .eld. However, in more complex generic classes (e.g., Vector or HashSet), there may be no single \ndeclaration in the class whose points-to set can be examined to determine the instantiation, and in such \ncases, the analysis must use information from .elds, method parameters, and method results. (Also, this \nensures correct results even in the pres\u00adence of unchecked operations, such as a cast to a type variable \nT. An approach that assumes that any such cast succeeds may choose incorrect type parameters.) 5.5.1 \nS-uni.cation algorithm details This section discusses the s-unify algorithm presented in Fig\u00adure 10. \nReaders who are not interested in a justi.cation of the de\u00adtails of the algorithm may skip this section. \nLine numbers refer to the pseudocode of Figure 10. The .rst few cases in the algorithm are straightforward. \nIf there are no free type variables to constrain (lines 9 10), or only the null value .ows to a type \nvariable (lines 12 13), then no constraints can be inferred. When the rhs of a uni.cation is a union \ntype (as for Cell10.value in Figure 8), s-unify descends into the set and uni.es against each element \nin turn (lines 14 17). Otherwise, lhs contains free type variables, so it is either a type variable or \na (parameterized) class type. First, consider the case when it is a type variable (lines 19 33). JSR-14 \nsource code need not explicitly instantiate type variables declared by generic methods, so our algorithm \nneed not track con\u00adstraints on such variables. Without loss of precision, uni.cations against type variables \ndeclared by a method are replaced by uni\u00ad.cations against the method variable s type bound (lines 20 \n23), which may refer to a class variable. Care must be exercised to pre\u00advent in.nite recursion in the \npresence of F-bounded variables such as T extends Comparable<T>; for clarity, this is not shown in the \nalgorithm of Figure 10. The call to replaceValue gives a concrete example. In the fourth call to s-unify \n(see Figure 8), lhs is the type variable U. This variable is declared by the generic method <U extends \nV> replaceValue(Cell<U>) and not by the generic class of context, which is Cell. Since we cannot meaningfully \nconstrain U in this context, we replace this type variable by its bound, which is V, and s-unify again, \neventually obtaining a Float constraint on V. The type variable may be declared in a di.erent class than \ncontext for example, when processing inherited methods and .elds, which may refer to type variables \ndeclared by a superclass of the receiver. Lines 24 28 handle this case. For example, Pair(F, S) inherits \n.eld V value from class Cell(V). It would be meaningless to constrain V in the context of a Pair allocation, \nsince Pair has no type variable V. The instantiation expression of Cell s V in Pair is F. So, a uni.cation \nin Pair context, whose lhs is V, becomes a uni\u00ad.cation against F. This produces the correct results for \narbitrarily complex instantiation expressions in extends-clauses. The last possibility for a type variable \nis that it is declared by the class being constrained that is, the class of context. In this case, lbounds(obj(Cell2), \nV) is updated by adding rhs to it (line 29). This is the only line in the algorithm that adds a type \nconstraint. Now, consider the case when lhs is a class type (lines 34 43); rhs is either a class type \nor an allocation site type. If rhs is a class type, then corresponding type parameters of lhs and rhs \ncan be uni.ed (lines 37 38). This is only sensible if the classes of lhs and rhs are the same, so that \ntheir type parameters correspond. The class of rhs is widened to satisfy this requirement. In our example, \nwhile processing Cell10.replaceValue( ), the widening is the identity operation since the classes of \nlhs and rhs already match: they are both Cell. The algorithm s .nal case handles the possibility that \nrhs is an allocation type (lines 40 43). In this case, the allocation type is replaced by a snapshot: \nthe type implied by the current set of type constraints on the allocation type. A snapshot uses the current \nstate of information about a type variable, but this information is subject to change if the variable \ns lbounds-set grows. If this happens, uni.cations that depended upon snapshot information must be recomputed \n(lines 30 32). Each time an allocation-site type o appears as the rhs of a call to s-unify,a snapshot \nof it is used, and a triple (context, lhs, rhs) is added to the set reunify . (A\u00d7T \u00d7 A), where A is the \nset of allocation-site types. This set is global (its value is preserved across calls to s-unify), and \ninitially empty. Each triple in reunify is the set of arguments to the call to s-unify in which a snapshot \nwas used. Whenever the value of lbounds(o) grows, snapshot(o) becomes stale, so we must again call s-unify(c, \nl, r), for each triple (c, l, r) E reunify such that r = o. Since the process of s-uni.cation is idempotent \nwith respect to the same argument values, and monotonic with respect to larger rhs argument values, this \nis sound. 5.6 Resolution of parametric types The result of s-uni.cation is an lbounds union type for \neach type variable of each generic allocation-site type, where the union ele\u00adments are allocation-site \ntypes. For our example, these are illus\u00adtrated in the lbounds values column of Figure 9. The step of \nreso\u00adlution uses these unions to determine a type for each allocation site; we call this type the resolved \ntype. For a non-generic allocation site type such as Float, the resolved type is just the type of the \nclass itself. However, one allocation site type can depend on another allocation site type. In particular, \nthe resolved type of a generic allocation depends on other resolved types: obj(Cell2) depends upon obj(Float), \nand obj(Cell3) depends upon obj(Cell2). Intuitively, if obj(Cell3) is a Cell of obj(Cell2) , then we \nneed to know the resolved type of obj(Cell2) before we can give a resolved type to obj(Cell3). To perform \nresolution, we re\u00adsolve allocation site types in reverse topological order of resolution dependencies. \nFor our running example, the resolution dependency graph is: obj(Cell 10) obj(Integer) obj(Cell 3) \n obj(Cell 2) obj(Float) Additional code (included in our implementation) is required for correct handling \nof type variable bounds constraints, out-of-bounds types, and to prevent in.nite recursion for F-bounded \nvariables such as T extends Comparable<T>. The graph of resolution dependencies is not necessarily acyclic: \nan expression such as cell.set(cell) gives rise to a cycle. A type system with support for recursive \ntypes could assign a type such as .x Ax.Cell(x). However, JSR-14 has no means of express\u00ading recursive \ntypes, so we instantiate all types within a strongly\u00adconnected component of the dependency graph as raw \ntypes (e.g., raw Cell). We have not yet observed cycles in any real-world pro\u00adgrams. The semantic contract \nof some generic interfaces makes cycles unlikely: for example, the speci.cation of the Set interface \nexpressly prohibits a set from containing itself. 6. DECLARATION TYPE INFERENCE The allocation type inference \nproduces a precise parameterized type for each allocation site of a generic class. The next step, called \ndeclaration type inference, uses this information to derive a new type for every variable declaration \nin the client code, including .elds and method parameters. We note two requirements and one goal for \nthe new types. (1) They must be mutually consistent, so that the resulting program obeys the type rules \nof the language. (2) They must be sound, so that they embody true statements about the execution of the \npro\u00adgram; we cannot give a declaration the type Cell(Float) if its ele\u00adment may be an Integer. (3) They \nshould to be precise, ascribing the the most speci.c type possible to each declaration. The consistency \nrequirement is enforced by type constraints [35], which expresses relationships between the types of \nprogram vari\u00adables and expressions in the form of a collection of monotonic in\u00adequalities on the types \nof those expressions. A solution to such a system of constraints corresponds to a well-typed program. \nThe soundness requirement is satis.ed by using the results of allocation type inference for the type \nof each allocation site. Since T ::= C raw type | C(T1,...,Tn) class type | T type variable | Xi type \nunknown |{T1,...,Tn} union type | Null the null type Figure 12: Type grammar for declaration type inference. \nthe behavior of the whole program was examined in order to derive these types, they represent all possible \nuses. Since the types of allocation sites are sound, all other type declarations are also sound in any \nconsistent solution. To achieve the goal of precision, we would like to obtain a min\u00adimal solution to \nthe system of type constraints, if possible. As we have seen, there may be no unique minimal solution, \nso we have to content ourselves with solutions composed of local minima. Sections 6.1 and 6.2 discuss \nthe form of the type constraints. Section 6.3 describes how they are generated from the input pro\u00adgram, \nwith an explanation of the need for conditional constraints to properly handle raw types. Finally, Sections \n6.4 and 6.5 how the system of type constraints can be solved to obtain a translated program. Due to space \nlimitations, we illustrate the generation of type con\u00adstraints for a core subset of the features of the \nJSR-14 language. The ideas can be extended naturally to support all features of the real language, as \nin our implementation. 6.1 Type Constraints A constraint a1 -R -a2 is a manifestation of a relationship \nR be\u00adtween two terms a1 and a2. A constraint is satis.ed if and only if the pair (a1,a2) is a member \nof relation R. If the terms are par\u00adtially unknown in other words, they contain variables then the \nsatisfaction of the constraint depends upon the values of those vari\u00adables. The problem of constraint \nsolving is therefore to .nd a set of assignments to the variables that satis.es the complete system of \nconstraints. Type constraints [35] express relationships between the types of program elements, such \nas .elds and method formal parameters. The relation R is the subtype relation :, and the grammar of terms \nis the grammar of types. Type constraint solving assigns to each type constraint variable, a value from \nthe type domain. For this problem, we use the type grammar T, shown in Fig\u00adure 12. This grammar modi.es \nthe type grammar of Figure 6 by removing allocation site types and augmenting it with variables, which \nwe call type unknowns or constraint variables, to distinguish them from the normal usage of type variable \nin JSR-14 as a syn\u00adonym for type parameter . The subtype relation can be viewed as a directed graph whose \nnodes are types and edges are constraints. The subtype relation is transitive, re.exive, and antisymmetric, \nso we use the equality notation a1 = a2 as an abbreviation for a pair of subtype constraints a1 : a2 \nand a2 : a1. Our algorithm contains three di.erent constraint systems (de\u00adscribed in Sections 5.4, 5.5, \nand 6), because di.erent parts of the algorithm have di.erent purposes and require di.erent technical \nmachinery. The pointer analysis (Section 5.4) is context-sensitive for precision in computing value .ow; \nwe adopt the constraints directly from previous work [48]. By contrast, the results of dec\u00adlaration type \ninference (Section 6) must satisfy the type-checker, which is context-insensitive, so that constraint \nsystem is most natu\u00adrally context-insensitive. The s-uni.cation constraints (Section 5.5) Suppose we \nhave declarations: class B(U1,..., Ui) class C(T1 a S 1,..., Tn a S n) a B(T1,...,Ti) where a is an \nabbreviation for extends/implements Then: widening(C, C) = 0 widening(C, A) = [U1 : T1,..., Ui : Ti] \n\u00d8 widening(B, A) where A \" C elaborate(C) = C(X1,..., Xn) (Xi are fresh) Generates constraints: Xi \n: S i ( where ( = [T1 : X1,..., Tn : Xn] receiver(E.x) = declared([E]) \u00d8 widening(C, A) where class \nA declares member x declared(C(T1,...,Ti)) = [T1 : T1,..., Ti : Ti] Figure 13: Auxiliary de.nitions for \ndeclaration type inference: widening, which models the widening conversion of parameterized types; elaborate, \nwhich creates a fresh elaboration of a parametric class with type unknowns; and receiver, which de.nes \nthe substitution applied to the type of class instance members due to the parameterized type of the receiver. \nbridge these two di.erent abstractions, essentially collapsing the context-sensitivity. It might be possible \nto unify some of these con\u00adstraint systems, but to do so would complicate them and intertwine conceptually \ndistinct phases of our algorithm. 6.2 De.nitions This section de.nes terminology used in the description \nof the declaration type inference. The term instantiation denotes a ground type resulting from the application \nof a generic type to a set of type arguments. A type ar\u00adgument is an actual type parameter used for a \ngeneric instantiation. A generic instantiation is either a parameterized type, if the generic type is \napplied to one or more type arguments, or a raw type, if it is applied without explicit type arguments. \nFor example, the parame\u00adterized type Cell(String) is the generic instantiation resulting from the application \nof generic type Cell(V) to the type argument String. In our notation, the metavariable C ranges over \nclass names, E ranges over expressions, F ranges over .eld names, and M ranges over method names. F and \nM denote the declaration of a speci.c .eld or method, including its type and the name of the class in \nwhich it is declared. Metavariable X ranges over type unknowns. We say that a method M in class C overrides \na method M' in class C' if M and M' have identical names and formal parameter types, and C is a subclass \nof C' . [A : T] denotes the substitution of the type variable A with type (or type unknown) T. Substitutions \nare denoted by the metavariable (. We denote the empty substitution with 0, the composition of two substitutions \nwith ( \u00d8 (' , and the application of substitution ( to type T with T (. The result of substitution application \nis a type (or a type unknown). For example, given class Pair of Figure 2, Pair(F, S)[F : X1, S : X2] \n= Pair(X1, X2). Figure 13 de.nes auxiliary functions. The widening function de.nes the widening conversion \n[21] of (generic) types: it indicates which instantiation of a superclass is a supertype of a given instantiation \nof a subclass. For example, in the context of types shown in Figures 1 and 2, widening(Pair, Cell) = \n[V : F], which informally means that Pair is a subtype of Cell when the type variable V of Cell is substituted \nby F of Pair, so Pair(String, Boolean) is a subtype of Cell(String). The elaborate function takes a class \ntype C and returns the elab\u00adoration of the type the type obtained by applying C s generic type to a \nset of fresh type unknowns, one for each type parameter of the class. In addition, this function generates \ntype constraints that ensure the fresh type unknowns are within their bound. For example, elaborate(Pair) \nmight return Pair(X1, X2) and generate constraints X1 : Object and X2 : Object, since both variables \nF and S are bounded at Object. (We occasionally refer to the type unknowns created during the elaboration \nof a particular declaration as belonging to that declaration.) The receiver function returns the receiver-type \nsubstitution for an instance member (.eld or method) expression. This substitu\u00adtion, when applied to \nthe declared type of the member, yields the apparent type of the member through that reference. For exam\u00adple, \nin Figure 4, variable p has type Pair(Number, Boolean), so the receiver substitution receiver(p.value) \nis [V : Number]. There are two components to the receiver substitution; the .rst corresponds to the parameterization \nof the declaration of p, and is [F : Number, S : Boolean]. The second corresponds to the extends clauses \nbetween the declared class of p (Pair) and the class that declared the member value (Cell); in this case, \nit is [V : F]. The result of receiver is the composition of these substitutions, [V : Number]. The erasure \nfunction (not shown) returns the erased [6, 27] ver\u00adsion of a generic type. For example, erasure(Pair(String, \nBoolean)) = Pair and erasure(Return(Cell.get)) = erasure(V) = Object. 6.3 Creating the type constraint \nsystem Generation of type constraints consists of two steps. First, dec\u00adlarations are elaborated to include \ntype unknowns for all type argu\u00adments. Each use of a generic type in the client program, whether in a \ndeclaration (e.g., of a .eld or method parameter), or in an op\u00aderator (e.g., a cast or new), is elaborated \nwith fresh type unknowns standing for type arguments. For example, consider the types in Figure 2 and \nthe statement Pair p = new Pair(f, o) on lines 7 8 of Figure 3. The declaration type inference creates \nfour fresh type unknowns X1,..., X4, so the elaborated code is Pair<X1,X2>p = new Pair<X3,X4>(). Second, \nthe declaration type inference algorithm creates type constraints for various program elements. Some \ntype constraints are unconditionally required by the JSR-14 (and Java) type system, or to ensure behavior \npreservation; see Section 6.3.1. Other type constraints may be in e.ect or not, depending on the values \ngiven to type unknowns. In particular, declaring a generic instantiation to be raw induces di.erent constraints \non the rest of the program than does selecting speci.c type arguments for the generic instantiation; \nsee Section 6.3.2. 6.3.1 Ordinary type constraints Figure 14 shows type constraints induced by the key \nfeatures of JSR-14. To cover the entire language, additional constraints are required for exceptions, \narrays, instanceof expressions, etc. We omit their presentation here because they are similar to those \npre\u00adsented. For a more detailed list of various program features and type constraints for them, see [43]. \nAlso, to ensure certain properties of the translation (i.e., princi\u00adples presented in Section 3), an \nadditional set of constraints is gen\u00aderated. Informally, we must ensure that the erasure of the program \nremains unchanged (which places constraints on declared types of method parameters and return types, \n.elds, etc.) and that, in the translated program, the declared types of all program elements are no less \nspeci.c than in the original program (and in the case of li\u00adbrary code the types must remain exactly \nthe same). This approach is similar to that taken in [43] and [13]. These type constraints are straightforward \nand are omitted here. Constraint generation is achieved by descent over the syntax of all the method \nbodies within the client code. Figure 14 de.nes the metasyntactic function [\u00b7], pronounced type of , \nwhich maps from expression syntax to types, generating constraints as a side e.ect. The .gure also de.nes \nthree other metafunctions, Field, Param, and Return, for the types of .elds, method parameters, and results. \nTerms of the form [E] . (... ) are not constraints, but form the de.nition of [\u00b7]. As an example, consider \nline 11 of Figure 3: c4.replaceValue(c1), where c1 s declaration, elaborated by the introduction of a \ntype unknown, is Cell(X1) and the declaration of c4 is elaborated to Cell(X4). Thus, we have that: [c1] \n. Cell(V)[V : X1]  [c4] . Cell(V)[V : X4]  ( = [V : X4]  (fresh = [U : XU](XU is fresh)  Rules \n(10) (11) give us, respectively: [c1] : Cell(U)[V : X4][U : XU ] i.e., Cell(X1): Cell(XU ) XU : X4 6.3.2 \nGuarded type constraints Generic instantiations are of two kinds: parameterized types and raw types. \nFor parameterized types, the generated type constraints represent type arguments by a type unknown. For \nraw types, there is no X for which raw Cell is a Cell(X); constraints that try to refer to this X are \nmeaningless. Type con\u00adstraints are invalid if they refer to type unknowns arising from an elaboration \nof a generic declaration that is later assigned a raw type. In that case, a di.erent set of constraints \nis required, in which the types that previously referred to the killed type unknown are now replaced \nby their erasure. For example, consider the following code: void foo(Cell c) { x = c.get(); c.set(\"foo\"); \n} If the declaration of c is parameterized (say, Cell(X1)), then the constraint X1 : [x] must be satis.ed \n(rules (1) and (9) in Fig\u00adure 14). On the other hand, if the declaration is raw, then the con\u00adstraint \nerasure(Return(Cell.get)) = Object : [x] must be satis\u00ad.ed. Similar constraints arise from the call to \nset: if the declara\u00adtion is parameterized, then [\"foo\"] : X1; otherwise, [\"foo\"] : erasure(Param(set, \n1)) = Object. Each method invocation (or .eld reference) on an object whose declaration is a generic \ninstantiation gives rise to two alternative sets of conditional constraints. Any constraint that references \na type unknown must be predicated upon the parameterizedness of the type of the receiver expression; \nwe call such expressions guard expressions. (Actually, our implementation uses a representation in which \nall temporaries are explicit, so we call them guard vari\u00adables.) When the type of a guard variable is \nraw, the alternative constraint after erasure is used instead, so the killed type unknown is no longer \nmentioned. For example, the guarded type constraints created for the second line in the example above \nare [X1] :c [x] (c is the guarding variable), which is interpreted only if [c] is non\u00adraw, and Object \n:c [x] (the left-hand side is erased), which is interpreted only if [c] is raw. Depending on c, exactly \none of these two constraints is interpreted, and the other is ignored. statement E1 := E2; [E2] < [E1] \n(1) statement return E; (in method M) [E] < Return(M) (2) expression this (in class B) [this] . B (3) \nexpression null [null] . Null (4) expression xi (in method M) [xi] . Param(M, i) (5) expression new B(T1, \n. . . , Tk) B has type variables (T1 . S 1, . . . , Tk . S k) ( = [T1 : T1, . . . , Tk : Tk] [new B(T1, \n. . . , Tk)] . B(T1, . . . , Tk) T j < S j ( (6) (7) expression E. f (.eld F of class B) ( = receiver(E. \nf ) [E. f] . Field(F) ( (8) expression E.m(E1, . . . , En) (method M of class B) ( = receiver(E.m) M \nhas type variables (T1 . S 1, . . . , Tk . S k) (fresh = [T1 : X1, . . . , Tk : Xk] (fresh Xi) [E.m(E1, \n. . . , En)] . Return(M) ( (fresh [Ei] < Param(M, i) ( (fresh T j ( f resh < S j ( ( f resh (9) (10) \n(11) method M overrides method M' Param(M' , i) = Param(M, i) Return(M) < Return(M' ) (12) (13) method \nM is de.ned in library code as: (T1 . S 1, . . . , Tn . S n) T M(T1 x1, . . . , Tn xn) Return(M) . T \nParam(M, i) . Ti (14) (15) method M is de.ned in client code as: T M(T1 x1, . . . , Tn xn) Return(M) \n. elaborate(T) Param(M, i) . elaborate(Ti) (16) (17) .eld F is de.ned in library code as: T F Field(F) \n. T (18) .eld F is de.ned in client code as: T F Field(F) . elaborate(T) (19) Figure 14: Type constraints \nfor key features of JSR-14. The type for an expression E or a metasyntactic expression such as Field(F) \nis de.ned using the notation [E] . (.. . ). The generation of constraints is explained in Section 6.3.1. \nThe three sections of the table show the constraints generated for statements, expressions, and declarations, \nrespectively.  6.3.3 Allocation Types For soundness, the types of allocation sites must be consistent \nwith the types inferred by the allocation type inference of Section 5. The most straightforward way to \nincorporate the results of alloca\u00adtion type inference into the constraint system is simply to de.ne the \ntypes of each generic allocation site (as used in rule (6)) to be exactly the type inferred for it. This \nis simple and easy to implement (and is what our imple\u00admentation does). It is, though, somewhat overconstrained \nbeyond what is necessary for correctness. A slightly more .exible approach would be to instantiate the \nnew expression with a set of fresh type unknowns, and to constrain each of these unknowns to be a subtype \nof the corresponding parameter type from the inferred type. This approach permits choosing a less speci.c \nassignment for a type un\u00adknown, which may be desirable, as illustrated by Figure 5. For example, allocation \ntype inference reports the type Pair(Number, Boolean) for the allocation on line 8 of Figure 4. The .rst \napproach would simply make this the type of the new ex\u00adpression. The second approach would instead make \nthe type of the expression Pair(X1, X2), where X1 and X2 are fresh type unknowns constrained in the following \nway: Number < X1, Boolean < X2. 6.4 Solving the type constraints The algorithm of Section 6.3 creates \ntype unknowns for each type argument, and creates (ordinary and guarded) type constraints that relate \nthe type unknowns to one another and to types of other program elements, such as .elds, method parameters, \netc. The .nal type constraint graph expresses the type rules of JSR-14, plus our additional constraints \ncreated for behavior preservation. Any solu\u00adtion to the constraint graph (i.e., assignment of types to \nconstraint variables) therefore represents a well-typed and semantically equiv\u00adalent translation of the \nprogram. Conceptually, solving the constraints is simple: for each con\u00adstraint variable in turn, assign \na type that satis.es its current con\u00adstraints. If this choice leads to a contradiction (i.e., there is \nno satisfying assignment to the remaining constraint variables), then choose a di.erent type for the \nconstraint variable. If all choices for this constraint variable lead to a contradiction, then backtrack \nand make a di.erent choice for some previously-assigned constraint variable. Because valid typings always \nexist (Section 3.7), the pro\u00adcess is guaranteed to terminate.5 In principle, the space of type assignments \ncould be exhaustively searched to .nd the best typing (that eliminates the largest number of casts, per \nSection 3.6). This section outlines one practical algorithm for .nding a solu\u00adtion to the type constraints; \nit is based upon a backtracking search, but attempts to reduce the degree of backtracking to a practical \nlevel. We have implemented this technique, and it performs well in practice. See Section 8 for the results. \nThe algorithm constructs a graph, initially containing edges only for the unconditional constraints. \nThe algorithm iterates over all the guard variables in order, trying, for each guard variable g, .rst \nto .nd a solution in which g s type is parameterized (non-raw), and if that fails, to .nd a solution \nin which g has a raw type. If no solution can be found due to a contradiction, such as a graph edge whose \nhead is a proper subtype of its tail, or an attempt to assign two unequal values to the same type unknown, \nthen a previously\u00admade decision must be to blame, and the algorithm backtracks. Each time it begins a \nsearch rooted at a (tentative) decision on the type for a particular guard, the algorithm adds to the \ngraph all of the conditional edges predicated upon that guard decision, whether parameterized or raw. \nBacktracking removes these edges. As the edges are added, several closure rules are applied. For 5Strictly \nspeaking, the set of possible types is in.nite, so it cannot be enumerated. However, it is rare to .nd \ncompletely unconstrained type unknowns, and in any case, a k-limited subset of the Herbrand universe \nof types is enumerable. REIFIED ASSIGNED INITIAL KILLED Figure 15: States in the declaration type inference \nalgorithm for each type unknown. At each step, every type unknown is associated with a state: initially \nthe initial state, and at completion, either the assigned or killed state. Edges indicate the permitted \ntransitions between states; only during backtracking is a previous state restored. example, if the graph \ncontains a path from Cell(X) to Cell(Y), then the interpretation of this path is Cell(X): Cell(Y), and \nby the rules of invariant parametric subtyping, this implies X = Y. This causes the addition of two new \nconstraints, X : Y and Y : X. This process is iterated until no further closure rules are applicable. \nThe other closure rules are omitted for brevity. Once the conditional edges have been added, if the search \nis try\u00ading to infer a parameterized type for guard variable g, then for each unknown Xu belonging to \ng, the algorithm computes the union of the types that reach X through paths in the graph. This is the \nset of lower bounds on Xu, and the least upper bound of this union is the type that will be assigned \nto Xu. 6.4.1 Dependency graph This section describes how to order the guard variables so as to minimize \nthe backtracking required. This strategy nearly or com\u00adpletely eliminates backtracking in every case \nwe have observed. We create a dependency graph that indicates all nodes whose as\u00adsignment might a.ect \na node, under any type assignment. The set of nodes in this graph is the same as of the type constraint \ngraph. The set of edges consists of every ordinary edge (from the type constraint graph of Section 6.3.1), \nevery guarded edge (from Sec\u00adtion 6.3.2), and, for every guarded edge, an edge from the type of the guard \nto the head. In the absence of cycles in the dependency graph, no backtrack\u00ading is required: the nodes \ncan be visited and their types assigned in the topological order. If the dependency graph has cycles, \nthen backtracking (undoing decisions and their consequences) may be required, but only within a strongly \nconnected component. As a heuristic, within a strongly connected component, we decide any nodes that \nare guards for some constraints .rst, because such choices are likely to have the largest impact. 6.4.2 \nDeciding guards, assigning types In the declaration type inference algorithm, each type unknown is in \none of four states, illustrated in Figure 15. Each type unknown starts in the initial state (or is reset \nto it via backtracking), which means that it has not yet been considered by the algorithm. A type unknown \nis in the killed state if the guard variable to which it be\u00adlongs has has been assigned a raw type. The \nreified state indicates that the algorithm decided to give a parameterized type to the guard variable \nto which the type unknown belongs, but that the choice of which type to assign it has not yet been made. \nAs soon as a type unknown becomes killed or reified, the algorithm adds the relevant conditional edges. \nFinally, the assigned state means that the type is parameterized, and the type arguments have been decided \nupon. (The type argu\u00adments themselves are indicated by a separate table of assignments.) When the algorithm \n.nishes, every type unknown is in the assigned or killed state. We use the term decide for the process \nof moving a type un\u00adknown from the initial state to one of the other states. All the type unknowns belonging \nto the same guard variable are decided simul\u00adtaneously. We distinguish between reified and assigned \nto permit deferring the choice of assigned type. Unconstrained type unknowns remain in the reified state \nuntil a constraint is added. This prevents pre\u00admature assignment from causing unnecessary contradictions \nand backtracking, and yields more precise results. Section 6.5 presents a join algorithm that determines \nthe least upper bound of a set of JSR-14 types. The solving algorithm uses that procedure extended to \nhandle reified type unknowns. The al\u00adgorithm treats reified type unknowns as a free choice, so long as \nthat choice is used consistently. This is best illustrated with an ex\u00adample: reified-join({Pair(Number, \nX1), Pair(X2, Boolean)}) = Pair(Number, Boolean) reified-join({Pair(Number, X3), Pair(X3, Boolean)}) \n= Pair The function reified-join can unify the rei.ed type unknowns with other types to achieve a more \nprecise result. In the .rst exam\u00adple, it successfully assigns types to X1 and X2. Allocation type inference \nreturns Null as the element type of an empty container; leaving the type unknown standing for the type \nar\u00adgument fully unconstrained (Null : X is a vacuous constraint). The declaration type inference algorithm \ncan select a non-null type for the element based upon other constraints. For example, if an allo\u00adcation \nof an empty cell only .ows to a variable of type Cell(String), then we can assign Cell(String) to the \nempty cell also. Any reified unknowns remaining when all the guards have been decided can be assigned \na type arbitrarily; our implementation chooses the upper bound on the unknown, typically Object. 6.5 \nJoin algorithm Union types are converted into JSR-14 types that represent their least common supertype \n(or join) by the following procedure. Consider a union type u as a set of types. For each non-Null element \nt E u, compute the set of all its supertypes, including itself. The set of common supertypes is the intersection \nof these sets. n common supertypes(u) = { s | t : s } t E u This set always contains at least Object. \nAt this point, we dis\u00adcard marker interfaces from the set. Marker interfaces such as Serializable, Cloneable, \nand RandomAccess declare no meth\u00adods, but are used to associate semantic information with classes that \ncan be queried with an instanceof test. Such types are not use\u00adful for declarations because they permit \nno additional operations beyond what is allowed on Object. Furthermore, they are mis\u00adleadingly frequent \nsuperclasses, which would lead to use of (say) Serializable in many places that Object is preferable. \nWe also discard the raw Comparable type. Even though it is not strictly a marker, this widely-used interface \nhas no useful meth\u00adods in the case where its instantiation type is not known: calling compareTo without \nspeci.c knowledge of the expected type usu\u00adally causes an exception to be thrown. Parameterized instantiations \nof this interface, such as Comparable(Integer), are retained. From the resulting set, we now discard \nany elements that are a strict supertype of other elements of the set, yielding the set of least common \nsupertypes of u: least common supertypes(u) = { t E cs | \u00ac3 tl E cs. tl < t} where cs = .ltered common \nsupertypes(u) Again, this set is non-empty, and usually, there is just a single item remaining. (Though \nthe java.util package makes extensive use of multiple inheritance, least common supertypes are always \nuniquely de.ned for these classes. Also, the boxed types such as Integer, Float, etc., have common supertype \nNumber once the rules for marker interfaces are applied.) However, if after application of these rules \nthe set has not been reduced to a single value, the union elimination procedure chooses arbitrarily. \nThis occurred only once in all of our experiments. The procedure just described is derived directly from \nthe subtyp\u00ading rules of the JSR-14 speci.cation, and thus implements invariant parametric subtyping. \nSo, for example: union elim Cell({Integer, Float}) - ------m Cell(Number) {} union elim Cell(Integer), \nCell(Float) - ------m raw Cell 6.5.1 Wildcard types Java 1.5 has not yet been .nalized, but it appears \nthat it will include wildcard types, which generalize the use of bounded ex\u00adistentials as type arguments. \nEvery parameterized type such as Cell(Number) has two corresponding wildcard supertypes, which are written \nCell<? extends Number> and Cell<? super Number> in the proposed syntax. The syntax Cell<? extends Number> \ndenotes the type Cell(3T. T : Number), which is the type of all Cells whose ele\u00adments are some (unspeci.ed) \nsubtype of Number. It is therefore a supertype of Cell(Integer) and Cell(Float), but a more speci.c one \nthan raw Cell: it allows one to get elements at type Number, and forbids potentially dangerous calls \nto set, since the required argument type T is unknown. Cell<? super Number> denotes the type Cell(3T. \nNumber : T), whose elements are of some unspeci.ed supertype of Number. It is a supertype of Cell(Number) \nand Cell(Object). This type permits one to set elements that are instances of Number, but the result \ntype T of get is unknown, i.e., Object. Use of wildcard types may increase the precision our results, \nas they represent a closer and more appropriate least upper bound than a raw type in many situations. \nHowever, the methods of Cell that reference a type variable from both their parameter and result types \nbelong to neither wildcard type, because Cell(3T. T : Number) has only the get-like methods while Cell(3T. \nNumber : T) has all the set-like ones. In order to ascribe a wildcard type to a variable declaration, \nan analysis must solve an additional set of constraints that restrict which members may be accessed through \nthat variable. Investigat\u00ading this problem would be an interesting direction for future work.  7. IMPLEMENTATION \nWe have implemented the algorithms described in this paper as a fully-automated translation tool called \nJiggetai. Jiggetai s output is a type-correct, behaviorally equivalent JSR-14 version of the orig\u00adinal \nJava program. Figure 16 shows the tool s architecture. This section notes a few salient points of the \nimplementation. 7.1 Program representation Since the allocation-type inference is a whole-program analysis, \nand we cannot demand that source be available for pre-compiled libraries, the analysis must be performed \non the bytecode (class\u00ad.le) representation of the program. However, the declaration-type inference is \nlogically a source-level analysis. For uniformity, we implement both analyses at the bytecode level. \nThe .rst component of our system is called the lossless compiler, which is a modi.ed version of the standard \nJSR-14 compiler that preserves source-level information by inserting additional tables of Library Class \nFiles  (generic) (translated) data as attributes (comments) in the class .le. This information in\u00adcludes: \n(i) the mappings between source variables and virtual ma\u00adchine registers; (ii) the type of each source \nvariable; and (iii) the type and lexical extent of every declaration or other use of a type\u00adname in the \nprogram (locals, .elds, methods, casts, allocation sites, extends-clauses, etc.). In addition, the compiler \ndisables certain optimizations such as dead-code elimination. Dead program statements are still subject \nto type checking and must be visible to the analysis. We have extended the Soot [46] class-.le analysis \npackage to perform analysis at the source level of abstraction by mapping un\u00adtyped JVM registers to typed \nsource variables. Our lossless com\u00adpiler and Soot extensions may be useful to other researchers and tool \nbuilders who desire the relative simplicity of the bytecode for\u00admat while retaining tight integration \nwith source code. 7.2 Allocation type inference JSR-14 requires that bytecode class.les that de.ne generic \ntypes include a Signature attribute that gives information about the type parameters that they de.ne. \nThis attribute is ignored by the JVM, but is required for type-checking client code: Due to JSR-14 s \ntype erasure strategy for compilation, it is the only way to know that a class.le represents a generic \ntype, or how many type parameters that class takes. Generic type information (Signature attributes) is \nmissing from all private and anonymous classes in JSR-14-1.3 s java.util pack\u00adage. Our analysis interprets \nclasses without a Signature attribute as non-generic, so the context sensitivity policy of Section 5.4 \nan\u00adalyzes them only once, e.ectively merging all instances of them together. For example, this e.ect \noccurs with (the second type pa\u00adrameter of) Hashtable and HashMap. We have implemented two solutions \nto this problem. 1. Perform more comprehensive retro.tting, which e.ectively adds Signature attributes \nto all classes, not just named pub\u00adlic ones. This approach is sound, regardless of the accuracy of the \nretro.tting, because the retro.tted types on private li\u00adbrary classes are used only as a context-sensitivity \nhint by the pointer analysis. The retro.tting can be done by hand or via heuristics. For instance, the \nfollowing heuristic captures the missing information in the JDK libraries almost perfectly: If a private \nor anonymous class extends a generic container class, inherit all generic annotations from the superclass. \nProgram Lines NCNB Casts Gen. casts antlr 47621 26349 161 50 htmlparser 27640 13062 488 33 JavaCUP 11048 \n4433 595 472 JLex 7841 4737 71 56 junit 10174 5727 54 26 TelnetD 11190 3976 46 38 v poker 6316 4703 40 \n31 Figure 17: Subject programs. Lines is the total number of lines of Java code, and NCNB is the number \nof non-comment, non-blank lines. Casts is the number of casts in the original Java program, and Gen. \ncasts is the number of those that are due to use of raw types.  Program Gen. casts Elim % Elim Time \n(sec) antlr 50 49 98 % 396 htmlparser 33 26 78 % 462 JavaCUP 472 466 99 % 235 JLex 57 56 98 % 35 junit \n26 16 62 % 181 TelnetD 38 37 97 % 32 v poker 31 24 77 % 47 Figure 18: Experimental results. Gen. casts \nis the number of generic casts (resulting from use of raw types) in the original Java program; Elim is \nthe number of casts eliminated by our translation to JSR-14, and % Elim ex\u00adpresses that number as a percentage. \n 2. Create a type-correct stub version of the library, and use it in place of the real library when \ncompiling. (This approach is taken by Tip et al. [42].) This approach is labor-intensive and unsound, \nbecause the stub method bodies do not necessarily induce the same generic type constraints as the original \nli\u00adbrary would. We implemented it to compare its performance and results with the retro.tting approach. \nAggregated over all the benchmarks in Figure 18, the use of stubs enabled an additional 0.7% of casts \nto be eliminated, and execution took 1% longer. The use of stubs roughly halved the running time of the \npointer analysis, although the contribution of this phase to the overall runtime was rela\u00adtively small. \nAs with all whole-program static analyses, our pointer analysis requires hand-written annotations to \nsummarize the e.ects of call\u00ading native methods and re.ective code; without them, soundness cannot be \nensured. Currently, we use very naive and conservative annotations for such methods; none of our benchmarks \nmakes sig\u00adni.cant use of them.  8. EXPERIMENTS In order to evaluate our analyses and tools, we ran \nour imple\u00admentation over the programs listed in Figure 17. The programs are as follows: antlr is a scanner/parser \ngenerator toolkit6; htmlparser is a library of parsing routines for HTML7 . JavaCUP is an LALR parser \ngenerator8; JLex is a lexical analyzer generator9; junit is a unit-testing framework10; TelnetD is a \nTelnet daemon11; v poker is 6 http://www.antlr.org/ 7 http://htmlparser.sourceforge.net/ 8 http://www.cs.princeton.edu/~appel/modern/java/CUP/ \n9 http://www.cs.princeton.edu/~appel/modern/java/JLex/ 10 http://www.junit.org/ 11 http://telnetd.sourceforge.net/ \n a video poker game12 . Figure 17 gives their sizes. The notable number of generic casts in the JavaCUP \nparser generator is due to its parser, which is implemented by a machine-generated source .le that makes \nheavy use of a Stack of grammar symbols. Figure 18 shows the results of our experiments. As our library, \nwe used all generic library classes from pack\u00adage java.util, as shipped with the JSR-14-1.3 compiler. \nThis package contains 166 classes, of which 37 are non-generic, 30 are generic top-level classes, and \n99 are generic inner classes. As noted in Section 3.6, casts are used for other purposes than for downcasting \nelements retrieved from generic classes, so even a perfect translation would not eliminate all casts \nfrom the program. We counted the number of generic casts by hand, determining for each cast whether or \nnot it was statically safe, based on human inspection of the values stored into each generic container. \n(For four of the benchmarks, we performed a complete manual generic translation and counted the number \nof casts eliminated.) We executed our tools within Sun s 1.4.1 HotSpot Client JVM with a maximum heap \nsize of 200 MB, running under Linux kernel 2.4 on a 3GHz Pentium 4. Our unoptimized implementation took \nno more than 8 minutes to translate any program. The execution time of the larger benchmarks was overwhelm\u00adingly \ndominated by the naive implementation of the resolution al\u00adgorithm of Section 6.4. We believe that the \nrunning time of this phase could be brought down to a small number of seconds, en\u00adabling applications \nbased upon interactive re.nement of the solu\u00adtion. 8.1 Evaluation For most of the benchmarks Jiggetai \neliminated over 95% of the generic casts. For the other programs, a few speci.c causes can be identi.ed. \nConservative extends parameterization. Whenever the anal\u00adysis encounters a client class that extends \na generic library class, the extends clause is parameterized very conservatively, with each type variable \ninstantiated at its erasure. For example, the declara\u00adtion class PersonList extends List is translated \nto extends List<Object>, even if the elements of PersonList are always of class Person. Without this \nconservative assumption, extends-clause informa\u00adtion would be only partial during analysis, but our algorithm \nre\u00adquires it to be complete. This assumption was responsible for the 7 generic casts remaining in v poker. \nMissing clone covariance. The declared result type of the clone method in existing Java code is Object, \neven though clone always returns an instance of the same class as its receiver. JSR-14 allows one to \nspecify covariant result types that capture this fact, so for example, the clone method of HashSet.T. \ncould be de\u00adclared HashSet<T> clone(). Nonetheless, the Set interface, via which instances of HashSet \nmay be frequently manipulated, does not covariantly specialize clone, since it does not require that \nits instances be cloneable.13 Therefore, type information is lost during calls to Set.clone. This is \nthe reason for the low score obtained for junit. We re\u00adpeated the experiment after replacing (C) c.clone() \nwith just c, and the score went up to 100%. This suggests that type constraint generation for the clone \nmethod should be handled with a covari\u00adant special case. Filter idiom. One particular pathological case, \nwhich we have named the .lter idiom, is typi.ed by the following code: 12 http://vpoker.sourceforge.net/ \n 13Or, for compatibility, clone may not have been covariantly spe\u00adcialized, as is the case for HashSet. \n List strings = new ArrayList(); void filterStrings(Object o) { if (o instanceof String) strings.add(o); \n} Here, strings contains only instances of String, but the call to add(o) generates a constraint that \nthe element type is Object. If the programmer had explicitly cast o to String before the call to add, \nthe desired type List.String. would have been inferred. But in non-generic Java, there is no need for \nsuch a cast, because List will accept values of any type, so it was omitted14 . The .lter idiom is heavily \nused by the htmlparser benchmark. This problem could be addressed by exploiting path-dependent data\u00ad.ow \ninformation arising from the instanceof test. Declaration splitting. Occasionally, a single variable \ndeclara\u00adtion was used sequentially for two di.erent webs (du-ud chains), such as using Iterator i to \ntraverse .rst one list, then another of a di.erent type. Even though the webs are disjoint, the single \ndeclaration of i means the analysis infers a single type for i. Sim\u00adilarly, multiple variables declared \nin the same statement, such as Iterator i, j;, are constrained to have the same type. In JavaCUP, we \nfound one example of each. After we manually split the declarations, the analysis eliminated 6 more casts \n(100%).  9. RELATED WORK Our primary contribution in this paper is a practical refactoring tool for \nautomated migration of existing Java programs into JSR\u00ad 14. We .rst discuss work related to our goal; \nnamely, existing work on introducing generic types into programs to broaden the applica\u00adbility of a pre-existing \ncomponents. Then, we brie.y discuss work related to our techniques: type constraint systems and type \ninfer\u00adence. 9.1 Generalization for re-use Two notable previous papers [39, 17] use automated inference \nof polymorphism with the goal of source-code generalization for re\u00aduse for example, to permit the code \nto be used in more situations or to provide compile-time type correctness guarantees. Since the result \nis source code for human consumption, rather than deduc\u00adtions for later analysis or optimization, a primary \ngoal is restricting the degree of polymorphism so that the results do not overwhelm the user. Typically, \nprograms contain much more latent polymor\u00adphism than that actually exploited by the program. Si. and \nReps [39] aim to translate C to C++. They use type inference to detect latent polymorphism in C functions \ndesigned for use with parameters of primitive type, and the result of gen\u00aderalization is a collection \nof C++ function templates that oper\u00adate on a larger set of types. A major issue addressed by Si. and \nReps is that C++ classes can overload arithmetic operators for class types. Their algorithm determines \n and documents the set of constraints imposed by the generalized function on its argument. (They give \nas an example the xy function pow(), which is de.ned only for numbers but could be applied to any type \nfor which mul\u00adtiplication is de.ned, such as Matrix or Complex.) Their work focuses exclusively on generic \nfunctions, not classes, and tries to detect latent reusability; in contrast, our work seeks to enforce \nstronger typing where reusability was intended by the programmer. The problem domain is quite di.erent \nthan ours, because unlike JSR-14, C++ templates need not type-check and are never sepa\u00adrately compiled; \nthe template is instantiated by simple textual sub\u00ad 14Interestingly, this is an example of a JSR-14 \nprogram that requires more casts than its non-generic counterpart. stitution, and only the resulting \ncode need type-check. This permits the template to impose arbitrary (implicit) constraints on its type \nvariables, in contrast to JSR-14 s erasure approach. Duggan [17] presents a type analysis for inferring \ngenericity in a Java-like language. Duggan gives a modular (intra-class) constraint\u00adbased parameterization \nanalysis that translates a monomorphic object-oriented kernel language called MiniJava into a polymor\u00adphic \nvariant, PolyJava, that permits abstracting classes over type variables. The translation creates generic \nclasses and parameterized instantiations of those classes, and it makes some casts provably re\u00addundant. \nPolyJava di.ers from JSR-14 in a number of important re\u00adspects. In particular, it supports a very restricted \nmodel of paramet\u00adric subtyping: abstract classes and interfaces are not supported, and each class must \ndeclare exactly as many type variables as its super\u00adclass. The type hierarchy is thus a forest of trees, \neach of which has exactly the same number of type variables on all classes within it. (Each tree inherits \nfrom Object.. via a special-case rule.) Because the analysis does not use client information to reduce \ngenericity, we suspect the discovered generic types are unusably over-generic; however, the system is \nnot implemented, so we are unable to con\u00ad.rm this. Von Dincklage and Diwan [47] address both the parameteriza\u00adtion \nand instantiation problems. They use a constraint-based al\u00adgorithm employing a number of heuristics to \n.nd likely type pa\u00adrameters. Their Ilwith tool determined the correct generalization of several classes \nfrom the standard libraries, after hand editing to rewrite constructs their analysis does not handle. \nThe technique requires related classes to be analyzed as a unit. However, it does not perform a whole-program \nanalysis and so can make no guaran\u00adtees about the correctness of its choices of type arguments. In con\u00adtrast \nto our sound approach, they try to capture common patterns of generic classes using an unsound collection \nof heuristics. For ex\u00adample, their implementation assumes that public .elds are not ac\u00adcessed from outside \nthe class and that the argument of equals has the same type as the receiver. Their approach can change \nmethod signatures without preserving the overriding relation, or change the erasure of parameterized \nclasses, making them possibly incompat\u00adible with their existing clients. Also in contrast to our work, \ntheir approach fails for certain legal Java programs, they do not handle raw types, their implementation \ndoes not perform source transla\u00adtion, and they do not yet have any experience with real-world appli\u00adcations. \n(We previously explored a similar approach to the parame\u00adterization and instantiation problems [16]. \nWe restricted ourselves to a sound approach, and abandoned the approach after discovering that heuristics \nuseful in speci.c circumstances caused unacceptable loss of generality in others.) Tip et al. [42] present \na technique for migrating non-generic Java code to use generic container classes. Tip et al. s algorithm \nem\u00adploys a variant of CPA to create contexts for methods and then uses these contexts in type constraint \ngeneration and solving. In our approach, CPA is used for pointer analysis, the results of which are then \nused to compute allocation site type arguments and, lastly, context-less type constraints are used to \ncompute type arguments for all declarations in the client code. Their tool is implemented as a source-code \nanalysis and a refactoring in the Eclipse [18] inte\u00adgrated development environment (IDE). Because it \nfocuses only on the standard collections library and it is source-code-based, their approach uses hand-made \nmodels of the collection classes. While they do not handle raw types, their method is capable of discover\u00ading \ntype parameters for methods, thus changing them into generic methods. This may help reduce the number \nof (possibly danger\u00adous) unchecked warnings and raw references without sacri.cing the number of eliminated \ncasts. For example, the method display\u00ad Value in Figure 3 could be changed into a generic method, rather \nthan leaving the reference raw. The authors do not discuss sound\u00adness or behavior preservation. Tip, \nKie.zun, and Ba\u00a8umer [43] present the use of type constraints for refactoring (i.e., modifying the program \ns source code without a.ecting its behavior). While their work focused on refactoring for generalization, \nours can be seen as refactoring for specialization, changing types from raw to non-raw. The CodeGuide \n[12] IDE o.ers a Generify refactoring with broadly the same goal as our work. It can operate over a whole \nprogram or a single class; we have veri.ed that the latter mode is unsound, but because no details are \nprovided regarding its imple\u00admentation, we cannot compare it to our own. The IDEA [24] IDE also supports \na Generify refactoring; again, no details about the analysis techniques are available, and we have not \nexperimented with this tool. 9.2 Type constraint systems Both our allocation type inference and declaration \ntype infer\u00adence are type-constraint-based algorithms in the style of Aiken and Wimmers [2], who give \na general algorithm for solving systems of inclusion constraints over type expressions. Our type constraints \nare di.erent in that they include guarded constraints in order to model JSR-14 s special rules for raw \ntypes. Most work in type in\u00adference for OO languages is based on the theory of type constraint systems; \na general theory of statically typed object-oriented lan\u00adguages is laid out in [36]. Our pointer analysis \nmakes use of the conceptual framework of Wang and Smith [48]; we instantiate it with a particular set \nof choices for polymorphism that .t well with our problem. Plevyak and Chien [38] provide an iterative \nclass analysis that derives con\u00adtrol and data .ow information simultaneously, with the goal of opti\u00admizations \nsuch as static binding, inlining, and unboxing. Some rep\u00adresentative applications are statically discharging \nrun-time casts [8, 48], eliminating virtual dispatch [3], and alias analysis [33, 32]. 9.3 Polymorphic \ntype inference There is a vast literature on polymorphic type inference dating from Milner [30], who \nintroduced the notion in the context of the ML programming language. Our goal is quite di.erent than \nthat of Algorithm W, since we are not trying to infer generic types, only the type arguments with which \nexisting generic types are instantiated. Subsequent work [34, 35] extends Hindley-Milner typechecking \nto object-oriented languages and to many other application domains. More recent work that extends it \nto object-oriented languages uses type constraints instead of equality constraints [19, 17], just as \nour s-unify algorithm does, though the technical machinery is di.erent. McAdam et al. [29] extend ML \nwith Java s subtyping and method overloading. The application of type inference algorithms gener\u00adally \nfalls into two categories: (1) enabling the implementation of languages in which principal typings for \nterms are inferred auto\u00admatically, which saves the programmer from writing them explic\u00aditly, and (2) \nas a means of static program analysis, e.g., to eliminate casts or to resolve virtual method dispatches. \nGagnon et al. [20] present a modular, constraint-based technique for inference of static types of local \nvariables in Java bytecode; this analysis is typically unnecessary for bytecode generated from Java code, \nbut is sometimes useful for bytecode generated from other sources. No polymorphic types are inferred, \nhowever. 10. FUTURE WORK We would like to extend our tool into an interactive application that would \nallow the user to manually correct suboptimal results, and iteratively re-solve the constraint system \nafter the user s anno\u00adtations have been incorporated. This would make it very easy for users to achieve \nthe ideal results. Once the Java 1.5 speci.cation is .nalized, we would like to update the tool to include \nsupport for it. It is largely a superset of the version of JSR-14 we have been studying; its most signi.\u00adcant \ndi.erence is the introduction of wildcard types, as discussed in Section 6.5.1. We plan to make our tool \navailable, once licens\u00ading issues are resolved (the implementation currently depends upon Sun s prototype \ncompiler). The C# language is a experiencing a parallel evolution towards generic types [49]; the ideas \nin our approach may be applicable to that language. In order to further increase the number of casts \neliminated from client code, we could replace our type constraint solution proce\u00addure (Section 6.4) with \none that performs more exhaustive search or other optimizations. Addressing the parameterization problem \n(i.e., introduction of type parameters to class de.nitions) is another area of potential future work, \nthough in our experience that part of the process is not particularly di.cult or time-consuming. 11. \nCONCLUSION With the release of Java 1.5, many programmers will wish to con\u00advert their programs to take \nadvantage of the improved type safety provided by generic libraries. We have presented a general algo\u00adrithm \nfor the important practical problem of converting non-generic Java sources to use generic libraries, \nand an implementation capa\u00adble of translating real applications. Our algorithm achieves the goals laid \nout in Section 3. It is sound: it never infers an unsafe type for a declaration. It is behavior\u00adpreserving: \nit does not change method signatures, the erasure of parameterized classes, or other observable aspects \nof a program. It is complete: it produces a valid result for arbitrary Java input and arbitrary generic \nlibraries. It is compatible with the JSR-14 gener\u00adics proposal: in particular, its type system addresses \nall features of the proposal, including raw types. It is practical: we have produced an implementation \nthat automatically inserts type parameters into Java code, without any manual intervention. It is precise: \nit elimi\u00adnated the overwhelming majority of generic casts in real-world ap\u00adplications, and the translation \nwas little di.erent than the result of manual annotation. As another contribution, our approach is, to \nour knowledge, the .rst analysis for Java that uses generic type annotations for target\u00ading the use of \ncontext-sensitivity, such targeting is critical to over\u00adcome poor scalability. Our application is type \nanalysis, but this technique could equally well be used for many other abstractions, such as interprocedural \ndata.ow problems. Raw types require the use of conditional constraints, since the type rules for accessing \nmembers through raw types and through parameterized types are quite di.erent. The presence of raw types \nin the type system is a loophole allowing potentially unsafe oper\u00adations; analyzing the e.ects of such \noperations requires a whole\u00adprogram analysis. (In the absence of raw types and unchecked op\u00aderations, \nit would be possible to solve the type inference problem soundly although perhaps not as precisely \nwithout pointer anal\u00adysis.) Because of unchecked operations, the assignability relation in JSR-14 is \nnot antisymmetric; in other words, x=y; y=x; may be permitted even when the types of x and y are unequal. \nThis has some subtle rami.cations for subtype constraint-based analyses, as the assignment constraint \ngraph may have no subtype interpretation in pathological cases. Our work is unique in supporting raw \ntypes, which is essential for producing good results without forbidding many realistic programs. Additional \ndetails on our work can be found in [15].  Acknowledgments Comments from Todd Millstein and the anonymous \nreferees im\u00adproved the presentation of our work. This research was funded in part by NSF grants CCR-0133580 \nand CCR-0234651, the Oxygen project, and gifts from IBM and NTT.  REFERENCES [1] O. Agesen. The cartesian \nproduct algorithm: Simple and precise type inference of parametric polymorphism. In ECOOP, pages 2 26, \nAug. 1996. [2] A. Aiken and E. L. Wimmers. Type inclusion constraints and type inference. In Functional \nProgramming Languages and Computer Architecture, pages 31 41, June 1993. [3] D. F. Bacon and P. F. Sweeney. \nFast static analysis of C++ virtual function calls. In OOPSLA, pages 324 341, Oct. 1996. [4] G. Bracha, \nN. Cohen, C. Kemper, S. Mark, M. Odersky, S.-E. Panitz, D. Stoutamire, K. Thorup, and P. Wadler. Adding \ngenerics to the Java programming language: Participant draft speci.cation. Technical report, Sun Microsystems, \nApr. 27, 2001. [5] G. Bracha, M. Odersky, D. Stoutamire, and P. Wadler. GJ speci.cation. http://www.cis.unisa.edu.au/~pizza/gj/ \nDocuments/#gj-specification, May 1998. [6] G. Bracha, M. Odersky, D. Stoutamire, and P. Wadler. Making \nthe future safe for the past: Adding genericity to the Java programming language. In OOPSLA, pages 183 \n200, Oct. 1998. [7] L. Cardelli and P. Wegner. On understanding types, data abstraction, and polymorphism. \nACM Computing Surveys, 17(4):471 522, Dec. 1985. [8] R. Cartwright and M. Fagan. Soft typing. In PLDI, \npages 278 292, June 1991. [9] R. Cartwright and G. L. Steele Jr. Compatable genericity with run-time \ntypes for the Java programming language. In OOPSLA, pages 201 215, Oct. 1998. [10] C. Chambers and D. \nUngar. Customization: Optimizing compiler technology for Self, a dynamically-typed object-oriented language. \nIn PLDI, pages 146 160, Portland, OR, USA, June 1989. [11] C. Chambers, D. Ungar, and E. Lee. An e.cient \nimplementation of Self, a dynamically-typed object-oriented language based on prototypes. In OOPSLA, \npages 49 70, Oct. 1989. [12] OmniCore CodeGuide. http://www.omnicore.com/codeguide.htm. [13] B. De Sutter, \nF. Tip, and J. Dolby. Customization of Java library classes using type constraints and pro.le information. \nIn ECOOP, June 2004. [14] J. Dean, D. Grove, and C. Chambers. Optimization of object-oriented programs \nusing static class hierarchy analysis. In ECOOP, pages 77 101, Aug. 1995. [15] A. Donovan. Converting \nJava programs to use generic libraries. Master s thesis, MIT Dept. of EECS, Sept. 2004. [16] A. Donovan \nand M. D. Ernst. Inference of generic types in Java. Technical Report MIT/LCS/TR-889, MIT Lab for Computer \nScience, Mar. 22, 2003. [17] D. Duggan. Modular type-based reverse engineering of parameterized types \nin Java code. In OOPSLA, pages 97 113, Nov. 1999. [18] Eclipse project. http://www.eclipse.org/. [19] \nJ. Eifrig, S. Smith, and V. Trifonov. Sound polymorphic type inference for objects. In OOPSLA, pages \n169 184, Oct. 1995. [20] E. Gagnon, L. J. Hendren, and G. Marceau. E.cient inference of static types \nfor Java bytecode. In Static Analysis Symposium, pages 199 219, June 2000. [21] J. Gosling, B. Joy, G. \nSteele, and G. Bracha. The Java Language Speci.cation. Addison Wesley, Boston, MA, second edition, 2000. \n [22] D. Grove and C. Chambers. A framework for call graph construction algorithms. ACM Transactions \non Programming Languages and Systems, 23(6):685 746, Nov. 2001. [23] M. Hind and A. Pioli. Evaluating \nthe e.ectiveness of pointer alias analyses. Science of Computer Programming, 39(1):31 55, Jan. 2001. \n[24] JetBrains IntelliJ IDEA. http://www.intellij.com/idea/. [25] A. Igarashi, B. C. Pierce, and P. Wadler. \nA recipe for raw types. In FOOL, London, Jan. 2001. [26] A. Igarashi and M. Viroli. On variance-based \nsubtyping for parametric types. In ECOOP, pages 441 469, June 2002. [27] JavaSoft, Sun Microsystems. \nPrototype for JSR014: Adding generics to the Java programming language v. 1.3. http://jcp.org/jsr/detail/14.html, \nMay 7, 2001. [28] B. H. Liskov and J. M. Wing. A behavioral notion of subtyping. ACM Trans. Prog. Lang. \nSyst., 16(6):1811 1841, Nov. 1994. [29] B. McAdam, A. Kennedy, and N. Benton. Type inference for MLj. \nIn Scottish Functional Programming Workshop, pages 159 172, 2001. Trends in Functional Programming, volume \n2, Chapter 13. [30] R. Milner. A theory of type polymorphism in programming. Journal of Computer and \nSystem Sciences, 17(3):348 375, 1978. [31] A. C. Myers, J. A. Bank, and B. Liskov. Parameterized types \nfor Java. In POPL, pages 132 145, Jan. 1997. [32] R. O Callahan. Generalized Aliasing as a Basis for \nProgram Analysis Tools. PhD thesis, Carnegie-Mellon University, Pittsburgh, PA, May 2001. [33] R. O Callahan \nand D. Jackson. Lackwit: A program understanding tool based on type inference. In ICSE, pages 338 348, \nMay 1997. [34] A. Ohori and P. Buneman. Static type inference for parametric classes. In OOPSLA, pages \n445 456, Oct. 1989. [35] J. Palsberg and M. I. Schwartzbach. Object-oriented type inference. In OOPSLA, \npages 146 161, Oct. 1991. [36] J. Palsberg and M. I. Schwartzbach. Object-Oriented Type Systems. John \nWiley and Sons, 1994. [37] P. Plauger, A. A. Stepanov, M. Lee, and D. R. Musser. The C++ Standard Template \nLibrary. Prentice Hall PTR, 2000. [38] J. Plevyak and A. A. Chien. Precise concrete type inference for \nobject-oriented languages. In OOPSLA, pages 324 340, Oct. 1994. [39] M. Si. and T. Reps. Program generalization \nfor software reuse: From C to C++. In FSE, pages 135 146, Oct. 1996. [40] B. Stroustrup. The Design and \nEvolution of C++. Addison-Wesley, Reading, Massachusetts, 1994. [41] B. Stroustrup. The C++ Programming \nLanguage. Addison-Wesley, Boston, MA, special edition, 2000. [42] F. Tip, R. Fuhrer, J. Dolby, and A. \nKie.zun. Refactoring techniques for migrating applications to generic Java container classes. IBM Research \nReport RC 23238, IBM T.J. Watson Research Center, Yorktown Heights, NY, USA, June 2, 2004. [43] F. Tip, \nA. Kie.zun, and D. B\u00a8aumer. Refactoring for generalization using type constraints. In OOPSLA, pages 13 \n26, Nov. 2003. [44] F. Tip and J. Palsberg. Scalable propagation-based call graph construction algorithms. \nIn OOPSLA, pages 281 293, Oct. 2000. [45] M. Torgersen, C. P. Hansen, E. Ernst, P. von der Ah\u00b4e, G. Bracha, \nand N. Gafter. Adding wildcards to the Java programming language. In SAC, pages 1289 1296, Mar. 2004. \n [46] R. Vall\u00b4ee-Rai, L. Hendren, V. Sundaresan, P. Lam, E. Gagnon, and P. Co. Soot -a Java bytecode \noptimization framework. In CASCON, pages 125 135, Nov. 1999. [47] D. von Dincklage and A. Diwan. Converting \nJava classes to use generics. In OOPSLA, Oct. 2004. [48] T. Wang and S. Smith. Precise constraint-based \ntype inference for Java. In ECOOP, pages 99 117, June 2001. [49] D. Yu, A. Kennedy, and D. Syme. Formalization \nof generics for the .NET common language runtime. In POPL, pages 39 51, Jan. 2004.    \n\t\t\t", "proc_id": "1028976", "abstract": "<p>Java 1.5 will include a type system (called JSR-14) that supports &#60;i>parametric polymorphism&#60;/i>, or &#60;i>generic&#60;/i> classes. This will bring many benefits to Java programmers, not least because current Java practice makes heavy use of logically-generic classes, including container classes.</p> <p>Translation of Java source code into semantically equivalent JSR-14 source code requires two steps: parameterization (adding type parameters to class definitions) and instantiation (adding the type arguments at each use of a parameterized class). Parameterization need be done only once for a class, whereas instantiation must be performed for each client, of which there are potentially many more. Therefore, this work focuses on the instantiation problem. We present a technique to determine sound and precise JSR-14 types at each use of a class for which a generic type specification is available. Our approach uses a precise and context-sensitive pointer analysis to determine possible types at allocation sites, and a set-constraint-based analysis (that incorporates guarded, or conditional, constraints) to choose consistent types for both allocation and declaration sites. The technique handles all features of the JSR-14 type system, notably the raw types that provide backward compatibility. We have implemented our analysis in a tool that automatically inserts type parameters into Java code, and we report its performance when applied to a number of real-world Java programs.</p>", "authors": [{"name": "Alan Donovan", "author_profile_id": "81100611698", "affiliation": "MIT Computer Science & Artificial Intelligence Lab, Cambridge, MA", "person_id": "P698412", "email_address": "", "orcid_id": ""}, {"name": "Adam Kie&#382;un", "author_profile_id": "81100087482", "affiliation": "MIT Computer Science & Artificial Intelligence Lab, Cambridge, MA", "person_id": "P698410", "email_address": "", "orcid_id": ""}, {"name": "Matthew S. Tschantz", "author_profile_id": "81100490837", "affiliation": "MIT Computer Science & Artificial Intelligence Lab, Cambridge, MA", "person_id": "P698419", "email_address": "", "orcid_id": ""}, {"name": "Michael D. Ernst", "author_profile_id": "81100204056", "affiliation": "MIT Computer Science & Artificial Intelligence Lab, Cambridge, MA", "person_id": "PP14080528", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1028976.1028979", "year": "2004", "article_id": "1028979", "conference": "OOPSLA", "title": "Converting java programs to use generic libraries", "url": "http://dl.acm.org/citation.cfm?id=1028979"}