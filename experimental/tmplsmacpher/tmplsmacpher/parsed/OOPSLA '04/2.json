{"article_publication_date": "10-01-2004", "fulltext": "\n A Practical Type System and Language for Reference Immutability Adrian Birka Michael D. Ernst MIT Computer \nScience and Arti.cial Intelligence Lab Cambridge, MA 02139 USA {adbirka,mernst}@csail.mit.edu Abstract \nThis paper describes a type system that is capable of expressing and enforcing immutability constraints. \nThe speci.c constraint ex\u00adpressed is that the abstract state of the object to which an immutable reference \nrefers cannot be modi.ed using that reference. The ab\u00adstract state is (part of) the transitively reachable \nstate: that is, the state of the object and all state reachable from it by following ref\u00aderences. The \ntype system permits explicitly excluding .elds or ob\u00adjects from the abstract state of an object. For \na statically type-safe language, the type system guarantees reference immutability. If the language is \nextended with immutability downcasts, then run-time checks enforce the reference immutability constraints. \nIn order to better understand the usability and ef.cacy of the type system, we have implemented an extension \nto Java, called Javari, that includes all the features of our type system. Javari is interop\u00aderable with \nJava and existing JVMs. It can be viewed as a proposal for the semantics of the Java const keyword, though \nJavari s syn\u00adtax uses readonly instead. This paper describes the design and implementation of Javari, \nincluding the type-checking rules for the language. This paper also discusses experience with 160,000 \nlines of Javari code. Javari was easy to use and provided a number of bene.ts, including detecting errors \nin well-tested code. Categories and Subject Descriptors D.3.3 [Programming languages]: Language Constructs \nand Fea\u00adtures data types; F.3.1 [Logics and meanings of programs]: Spec\u00adifying and Verifying and Reasoning \nabout Programs; D.1.5 [Pro\u00adgramming techniques]: Object-oriented programming General Terms Languages, \ntheory, experimentation  Keywords type system, veri.cation, immutability, readonly, mutable, Javari, \nJava, const Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n04, Oct. 24-28, 2004, Vancouver, British Columbia, Canada. Copyright 2004 ACM 1-58113-831-8/04/0010 ...$5.00. \n1. Introduction This paper presents a type system for specifying reference im\u00admutability: the transitively \nreachable state of the object to which a given reference refers cannot be modi.ed using the reference. \nThe transitively reachable state is the object and all state reachable from it by following references. \nA type system enforcing reference immutability has a number of bene.ts: it can increase expressive\u00adness, \nenhance program understanding and reasoning by providing explicit, machine-checked documentation, save \ntime by prevent\u00ading and detecting errors that would otherwise be very dif.cult to track down, or enable \nanalyses and transformations that depend on compiler-veri.ed properties. Our type system differs from \nprevious proposals (for Java, C++, and other languages) in a number of ways. It offers reference, not \nobject, immutability; reference immutability is more .exible, as it provides useful guarantees even about \ncode that manipulates muta\u00adble objects. For example, many objects are modi.ed during a con\u00adstruction \nphase but not thereafter, or an interface can specify that a method that receives an immutable reference \nas a parameter does not modify the parameter through that reference, or that a caller does not modify \na return value. Furthermore, a subsequent analy\u00adsis can strengthen reference immutability into stronger \nguarantees, such as object immutability, where desired. Our system offers guarantees for the entire transitively \nreachable state of an object. A programmer may use the type system to sup\u00adport reasoning about either \nthe representation state of an object or its abstract state; in order to support the latter, parts of \na class can be marked as not part of its abstract state. The abstract state is (part of) the transitively \nreachable state: that is, the state of the object and all state reachable from it by following references. \nOur type system permits excluding speci.c .elds from the abstract state. Our system combines static and \ndynamic checking in a safe and expressive way. Dynamic checking is necessary only for programs that use \nimmutability downcasts, but such downcasts can be con\u00advenient for interoperation with legacy code or \nto express facts that cannot be proved by the type system. Our system also offers pa\u00adrameterization over \nimmutability. A type system is of limited interest if programmers cannot ef\u00adfectively use it. In the \nabsence of experience using an implementa\u00adtion, the practicality of previous proposals is speculative. \nWe have designed and implemented Javari (which stands for Java with ref\u00aderence immutability ), an extension \nto the Java language that per\u00admits the speci.cation and enforcement of reference immutability constraints. \nJavari speci.es immutability constraints using the key\u00adword readonly. The language is backward compatible \nwith Java. In addition, Javari code is interoperable with legacy Java code, and runs on an unmodi.ed \nJava Virtual Machine. The Javari compiler is publicly available at http://pag.csail.mit.edu/javari/. \nWe obtained experience with Javari by writing code in it, as well as by annotating Java code with readonly \nto convert it to Javari. /** This class represents a set of integers. **/ public class IntSet { /** \nIntegers in the set with no duplications. **/ private int[] ints; /** Removes all elements from this \nthat * are not in set, without modifying set. **/ public void intersect(IntSet set) { ... } /** Makes \nan IntSet initialized from an int[]. * Throws BadArgumentException if there are  * duplicate elements \nin the argument ints. **/ public IntSet(int[] ints) { if (hasDuplicates(ints)) throw new BadArgumentException(); \n  this.ints = ints; } /** Number of distinct elements of this. **/ public int size() { return ints.length; \n} public int[] toArray() { return ints; } } Figure 1: A partial implementation of a set of integers. \nIn total, we have over 160,000 lines of Javari code, including the Javari compiler itself. This experience \nhelped us design language features for Javari to make it more useful and easier to use. In addition, \nthe experience helped clarify the bene.ts of using Javari. This paper is organized as follows. Section \n2 gives examples of the use of immutability constraints. Section 3 describes the Javari language, and \nsection 4 presents our type-checking rules in the con\u00adtext of Javari. Section 5 relates our experience \nwith using Javari. Finally, section 6 surveys related work, and section 7 concludes. 2. Examples Reference \nimmutability provides a variety of bene.ts in different situations. This section gives three simple examples \nof immutabil\u00adity constraints. The examples show enforcement of interface con\u00adtracts, granting clients \nread-only access to internal data, and pre\u00advention of certain representation exposures. (Section 3.8 \ndiscusses how analyses can provide guarantees such as these by building on reference immutability, possibly \nwith the assistance of a limited es\u00adcape or alias analysis.) We use a class representing a set of integers \n(.gure 1) to illustrate the problems and their solutions. A method contract may state that the method \ndoes not modify some of its arguments, as is the case with IntSet.intersect(). Compiler enforcement of \nthis contract guarantees that implementers do not inadvertently violate the contract and permits clients \nto de\u00adpend on this property. Javari allows the designer of IntSetto write public void intersect(readonly \nIntSet set) { and the compiler veri.es the method s speci.cation about not mod\u00adifying set. Accessor \nmethods often return data that already exists as part of the representation of the module. For example, \nconsider the toArray method of the IntSet class. It is simple and ef.cient, but it exposes IntSet s representation. \nA Java solution would be to return a copy of the array ints [5]. Our system permits a better solution: \npublic readonly int[] toArray() { The readonlykeyword ensures that the caller of IntSet.toArray cannot \nmodify the returned array, thus permitting the simple and ef.cient implementation of the method to remain \nin place without exposing the representation to undesired changes.1 Representation exposure occurs when \nimplementation details are accessible to clients. Java s access control mechanisms (for exam\u00adple, the \nprivatekeyword) partly address this problem; Javari pre\u00advents some additional problems. A system for \nimmutability can address the serious problem of mutational representation exposure, which permits modi.cation \nof values and violation of data structure invariants, but is not relevant to observational representation \nexpo\u00adsure, which may be innocuous or desirable. For example, in the IntSet example of .gure 1, the toArray \naccessor method exists to provide external access to the object s state. In the IntSet example, the content \nof the private data mem\u00adber ints is externally accessible through the reference passed to the constructor \nIntSet(int[]). Client code can directly change the state of the IntSet object, which is undesirable. \nEven worse, client code can violate the representation invariant and put an IntSet object into an inconsistent \nstate. For example, the client code could put a duplicate integer into the array ints, which would cause \nthe method IntSet.size()to return an incorrect value. Javari would catch this representation exposure \nat compile time. Since the constructor of IntSet is not intended to change the ar\u00adgument ints, the IntSetprogrammer \nwould write public IntSet(readonly int[] ints) { and the compiler would issue an error at the attempt \nto assign ints to this.ints, preventing the IntSetprogrammer from forgetting to do a deep copy in the \nconstructor. 3. The Javari language The Javari language extends Java with explicit mechanisms for specifying \nimmutability constraints, compile-time type checking to guarantee those constraints, and run-time checking \nfor programs that use potentially unsafe casts. Javari adds two new keywords to Java: readonlyand mutable.2 \nThe readonly keyword speci.es immutability constraints. The mutable keyword indicates a .eld that is \nnot part of the abstract state of an object, or downcasts from read-only types to non-read\u00adonly types. \nThe keywords are used as follows: readonlyis used in three ways: 1. As a type modi.er: For every Java \nreference type T, readonly T is a valid type in Javari (and is a supertype of T), and a variable of such \na type is known as a read-only reference. lThe returned array is aliased by the ints .eld, so IntSet \ncode can still change it even if external code cannot. The (unspeci.ed) semantics of toArray may permit \nthis. The method speci.ca\u00adtion might note that the returned reference re.ects changes to the IntSet; \nalternately, the method speci.cation, or an external analy\u00adsis, might require that the result is used \nbefore the next modi.cation of the IntSet. 2Java reserves, but does not currently use, the keyword const,so \nonly one new keyword is strictly necessary. We have chosen to introduce the new keyword readonly instead \nof reusing const for two reasons. First, we believe that readonly better describes the concept of reference \nimmutability. Second we wish to avoid confusion with the C++ keyword const (see section 6.1). Read-only \nreferences cannot be used to change the state of the object or array to which they refer. A read-only \nreference type can be used in a declaration of any variable, .eld, pa\u00adrameter, or method return type. \nA read-only reference type can also appear in a type-cast. See section 3.1. 2. As a method/constructor \nmodi.er: readonlycan be used af\u00adter the parameter list of a non-static method declaration (and likewise \nfor an inner class constructor), making that method a read-only method. Read-only methods cannot change \nthe state of the receiver ( this ) object. Only read-only meth\u00adods can be called through a read-only \nreference. See section 3. As a class modi.er: readonly can be used as a modi.er in a class or interface \ndeclaration. It speci.es that instances of that class or interface are immutable. See section 3.3.  \n3.2. mutable is used in two ways: 1. In a non-static .eld declaration, mutable speci.es that the .eld \nis not part of the abstract state of the object. Muta\u00adble .elds can be modi.ed by read-only methods and \nthrough read-only references, while non-mutable .elds cannot. See section 3.4. 2. In a type cast, mutable \nconverts a read-only reference to a non-read-only reference. Run-time checks are inserted to maintain \nsoundness and enforce immutability at run time. See section 3.6.  Javari supports type parameterization \nas a principled way to cre\u00adate related versions of code (section 3.5). Javari is backward com\u00adpatible \nwith Java: any Java program that uses none of Javari s key\u00adwords is a valid Javari program, with the \nsame semantics. Also, Javari is interoperable with Java; Java and Javari code can call one another without \nrecompilation (section 3.7). A postpass analysis can build on Javari s guarantee of reference immutability \nin order to make stronger guarantees about program behavior (section 3.8). 3.1 Read-only references A \nread-only reference is a reference that cannot be used to mod\u00adify the object to which it refers. A read-only \nreference to an object of type T has type readonly T. For example, suppose a variable robuf is declared \nas readonly StringBuffer robuf; Then robufis a read-only reference to a StringBufferobject; it can be \nused only to perform actions on the StringBuffer object that do not modify it. For example, robuf.charAt(0) \nis valid, but robuf.reverse()causes a compile-time error. When a return type of a method is a read-only \nreference, the code that calls the method cannot use the return value to modify the object to which that \nvalue refers. Note that finaland readonlyare orthogonal notions in a vari\u00adable declaration: final makes \nthe variable not assignable, but the object it references is mutable, while readonly makes the refer\u00adenced \nobject immutable (through that reference), but the variable remains assignable. Using both keywords gives \nvariables whose transitively reachable state cannot be changed except through a non-readonly aliasing \nreference. The following rules for usage of read-only references (detailed in section 4) ensure that \nany code that only has access to read-only references to a given object cannot modify that object. A \nread-only reference cannot be copied, either through as\u00adsignment or by parameter passing, to a non-read-only \nref\u00aderence. In the robuf example above, a statement such as StringBuffer buf = robuf;would cause a compile-time \nerror. If a is a read-only reference, and b is a .eld of an object referred to by a, then a.b cannot \nbe assigned to and is a read-only reference.  Only read-only methods (section 3.2) can be called on \nread\u00adonly references.  Javari also allows declarations of arrays of read-only references. For example, \n(readonly StringBuffer)[] means an array of read-only references to StringBufferobjects. For such an \narray, assignments into the array are allowed, while modi.cations of ob\u00adjects stored in the array are \nnot. This is in contrast to readonly StringBuffer[], which speci.es a read-only reference to an ar\u00adray \nof StringBuffers, and disallows both array element assign\u00adment and modi.cation of objects stored in the \narray. A non-read-only reference can be implicitly converted to a read\u00adonly one by an assignment, including \nimplicit assignment to param\u00adeters during method or constructor invocations. A non-read-only reference \ncan also be explicitly cast to a read-only one by using a typecast with a type of the form (readonly \nT). For example: readonly StringBuffer robuf = new StringBuffer(); StringBuffer buf = new StringBuffer(); \nrobuf = buf; // OK robuf = (readonly StringBuffer) buf; // OK buf = robuf; // error buf = (StringBuffer) \nrobuf; // error See section 3.6 for more details about type casts. 3.2 Read-only methods and constructors \nRead-only methods are methods that can be called through read\u00adonly references. They are declared with \nthe keyword readonly immediately following the parameter list of the method. It is a compile-time error \nfor a read-only method to change the state of the receiver object. For example, an appropriate declaration \nfor the StringBuffer.charAtmethod in Javari is: public char charAt(int index) readonly Read-only constructors \nare constructors that can be called with enclosing instance given through a read-only reference. (The \nJava Language Speci.cation requires that a constructor for a (non-static) inner class be called on an \ninstance of the outer class; this instance is called the enclosing instance.) Read-only constructors \nare de\u00adclared with the keyword readonly immediately following the pa\u00adrameter list of the constructor. \nIt is a compile-time error for a read\u00adonly constructor to change the state of the enclosing instance. \nRead-only constructors can be used when the enclosing instance is supplied through a read-only reference, \nas they promise not to modify the enclosing object. Read-only constructors do not con\u00adstrain the constructor \ns effects on the object being constructed, nor how the invoker uses the returned object. Whether a method \nor constructor is read-only is part of its sig\u00adnature, and therefore it is possible to have two methods \nwith the same name and parameters, if one is read-only and the other is not. Similarly, a read-only method \ndeclared in a subclass overloads (not overrides) a non-read-only one of same name and parameters de\u00adclared \nin a superclass, and vice versa. 3.3 Immutable classes A class or an interface can be declared to be \nimmutable via the readonly modi.er in its declaration.3 This means that all of its 3We use the term read-only \ntype to mean readonly T, for some T, and immutable type to mean a class or interface whose de.ni\u00adtion \nis marked with readonly and which therefore is immutable. non-mutable non-static .elds are implicitly \nread-only and .nal, and all of its non-static methods are implicitly read-only. In addition, if the class \nis an inner class, then all of its constructors are also implicitly read-only. For an immutable class \nor interface T, read-only and non-read\u00adonly references to objects of type T are equivalent. In particular, \nread-only references can be copied to non-read-only references, something that is normally disallowed. \nSubclasses or subinterfaces of immutable classes and interfaces must be declared immutable. Any instance \n.eld inherited by an immutable class or interface must be either .nal and of read-only type, or mutable. \nAny instance method inherited by such a class or interface must be read-only. 3.4 Mutable .elds Mutable \n.elds (declared with the mutablemodi.er) are not con\u00adsidered to be part of the abstract state of an object. \nA mutable .eld of an object .can be changed through a read-only reference to .. One use of mutable .elds \nis to enable creation of read-only con\u00adtainers that hold non-read-only elements. Another use of muta\u00adble \n.elds is to cache results of read-only methods. For example, this situation arises in the Javari compiler, \nwhere a name resolution method resolve() needs to cache the result of its computation. The solution looks \nsomewhat like the following: class ASTName { ... private mutable Resolution res = null; public Resolution \nresolve() readonly { if (res == null) res = doResolve(); // OK: res is mutable return res; } } \nWithout mutable .elds, objects are unable to cache the results of read-only methods, and consequently \nJavari would force the pro\u00adgrammer to either not label methods as read-only, or to take a sig\u00adni.cant \nperformance penalty. The readonly, mutable, and final keywords capture distinct concepts. If a .eld is \ndeclared as both mutable and readonly, the transitive state of the object it refers to is unchangeable \nthrough the .eld (because of readonly), while the .eld itself is assignable (because of mutable). If \na .eld is declared as both mutable and final, it is not assignable (because of final), but the state \nof the object to which it refers is changeable through the .eld, even when the .eld is accessed through \na read-only reference (be\u00adcause of mutable). If a .eld is declared with all three keywords, mutable has \nno effect. 3.5 Type parameterization Javari adopts the type (class and interface) and method param\u00adeterization \nmechanisms of Java 1.5 [8], also known as generics . Among other bene.ts, this feature reduces code duplication. \nFor example, it eases the de.nition of container classes, permitting one de.nition of Vector to be instantiated \neither as a container of Objectsor of readonly Objects, and either as a container whose abstract state \nincludes the elements or excludes the elements. More importantly, parameterization permits a single method \nde.ni\u00adtion to expand into multiple de.nitions that differ in the immutabil\u00adity of the parameters or of \nthe method itself. Javari augments the generics of Java 1.5 to permit a type quali.er (either readonly \nor the empty type quali.er) as a type parameter. This enables parameterization over whether a method \nis read-only (section 3.2). It also eases writing de.nitions in which references have different Java \ntypes but the same quali.er, such as this exam\u00adple from the InvMap class of Daikon (section 5.3): public \n<RO> RO List<RO Invariant> get(RO PptTopLevel ppt) RO; Java compiles generics via erasure (after type \nchecking is com\u00adplete): the same bytecodes are used for all instantiations of the class or method. Our \nprototype compiler uses a different compilation strategy (for immutability generics only): it duplicates \nthe param\u00adeterized declaration. Care must be taken when dealing with the different kinds of parameters \n essentially, splitting them into pos\u00adsibly overlapping parts and processing the parts separately. (First, \nduplicate code as necessary to eliminate all immutability parame\u00adterization, and then process the remaining \nparameters in the usual way.) Likewise, when a cast changes both the Java type and whether the type is \nread-only (section 3.6), the cast is converted into two casts (one for the Java type and one for readonly), \nand each is processed separately. 3.6 Type casts Every non-trivial type system rejects some programs \nthat are safe they never perform an erroneous operation at run time but whose safety proof is beyond \nthe capabilities of the type sys\u00adtem. Like Java itself, Javari allows such programs, but requires spe\u00adci.c \nprogrammer annotations (downcasts); those annotations trig\u00adger Javari to insert run-time checks at modi.cation \npoints to guar\u00adantee that no unsafe operation is executed. Among other bene.ts, programmers need not \ncode around the type system s constraints when they know their code to be correct, and interoperation \nwith legacy libraries is eased. The alternatives prohibiting all pro\u00adgrams that cannot be proved safe \n(including many uses of arrays), or running such programs without any safety guarantee are un\u00adsatisfactory, \nand are also not in the spirit of Java. If a program is written in the typesafe subset of Javari, then \nstatic type-checking suf.ces. For our purposes, the unsafe operation is the downcast, which converts \na reference to a superclass into a ref\u00aderence to a subclass. These can appear explicitly, and also in \ncertain uses of arrays of references, for which Java s covariant array types prevent sound static type-checking. \nAn example of the latter, where B is a subtype of A that de.nes b method,is B[] b_arr = new B[10]; A[] \na_arr; A a = new A(); a_arr = b_arr; a_arr[0] = a; // ArrayStoreException b_arr[0].b_method(); // \nstatically OK Java inserts checks at each down-cast (and array store), and throws an exception if the \ndown-cast fails. Javari s syntax for downcasting from a read-only type to a non\u00adread-only type is (mutable)expression \n. Regular Java-style casts cannot be used to convert from read-only to non-read-only types. Special downcast \nsyntax highlights that the cast is not an ordinary Java one, and makes it easy to .nd such casts. (See \nsection 5.1.) Downcasting from a read-only to a non-read-only type, or poten\u00adtially storing a read-only \nreference in a non-read-only array, trig\u00adgers the insertion of run-time checks, wherever a modi.cation \n(an assignment) may be applied to a reference that has had readonly cast away. The run-time checks guarantee \nthat even if a read-only reference .ows into a non-read-only reference, it is impossible for modi.cations \nto occur through the non-read-only reference. Thus, Javari soundly maintains its guarantee that a read-only \nreference cannot be used, directly or indirectly, to modify its referent. 3.6.1 Run-time checking Conceptually, \nJavari s checking works in the following way. The system associates a single readonly Boolean x..with \neach refer\u00adence x (not with each object), regardless of the reference s static type. Array references \nare treated similarly, but they need both a Boolean for the array and a Boolean for each reference element. \nThe readonly Boolean is true for each non-read-only reference de\u00adrived from a readonly reference as a \nresult of a downcast. The readonly Boolean is set when readonly is cast away, is propagated by assignments, \nand is checked whenever a modi.ca\u00adtion (i.e., a .eld update) is performed on a non-read-only refer\u00adence. \nThe instanceof operator checks the Boolean to determine whether x instanceof mutable for x of non-read-only \nstatic type. The key rules for checking are as follows. Let T be a type, a and b be expressions, and \nf be a .eld name. First, each operation that yields a reference is modi.ed to also produce a readonly \nBoolean for that reference. Two such rules are (a.f).. = a.. ((mutable) a)..= true where a is of read-only \nstatic type Second, each .eld update is modi.ed to check the readonly Boolean for the reference being \nupdated. The statement a.f= b;becomes if a..then throw exception; a.f= b; (a.f)..=b..; Method calls \nare modeled as assignments from the actuals to the formals, plus an assignment from the return statement \nto the call result itself. The remainder of the rules are straightforward (for example, array elements \nare treated analogously to .elds) and are omitted from this paper for brevity. Many optimizations to \nthe above rules are possible. For exam\u00adple, an analysis such as CHA [10] or RTA [3] could determine which \nclasses an unsafe operation may be applied to, and which classes are reachable from those. Checks only \nneed to be inserted in reachable classes. Furthermore, checks never need be inserted for immutable classes, \nnor for classes reached only via immutable references. (In other words, the more instances of readonlyin \nthe program, the less the overhead of run-time checking, if any, will be.) Checks can also be hoisted \nout of loops or eliminated where static analysis indicates them to be unnecessary. Explicit readonly \nBooleans need not be created for intermediate results. We have implemented a prototype implementation \nof the run\u00adtime checking. It is inserted by a source-to-source postpass that is invoked if the program \nbeing compiled contains any unsafe casts or array uses. The resulting code then runs on an unmodi.ed \nJVM. Our implementation is not highly tuned; for instance, it includes none of the above optimizations \nexcept for a partial hoisting op\u00adtimization. Furthermore, because it is a source-to-source transfor\u00admation, \nit incurs substantial overhead by introducing many wrapper classes to hold the readonly Boolean value \nthat indicates whether a reference is immutable.4 Despite all these inef.ciencies, the pro\u00adtotype introduces \nslowdowns averaging less than 10% on our suite of real and benchmark programs containing no readonly \nanno\u00adtations. (We ran our experiments using the Sun 1.4.1 JDK on a Pentium 4 running Red Hat Linux 7.2.) \n4In some cases the Boolean can be added as a new variable or .eld for example, if .eld f exists, then \nBoolean .eld f..is added and is manipulated or checked whenever f is used. In other cases, as for libraries \nfor which source is not available, for arrays (which are not .rst-class objects), or for return values, \nwrapping is inevitable, introducing space and (especially) time costs. Our main focus in this paper is \nthe type system and its usability, which are more important than run-time ef.ciency, and we have not \nbeen hindered by these relatively small slowdowns. However, we believe the optimizations listed above \ncould substantially re\u00adduce the overhead. Another approach is to modify the JVM di\u00adrectly, rather than \noperating at the source level. For instance, we could place the readonly Boolean in an unused bit in \nJava refer\u00adences. Such an approach would eliminate the need for new slots in objects and for wrapper \nobjects. No updating code would be nec\u00adessary for assignments: copying the reference would automatically \ncopy the immutability Boolean. Checking code would still be re\u00adquired, and the bit would need to be masked \nout when pointers are dereferenced. Most seriously, a modi.ed JVM would be required in order to run Javari \nprograms. We hope to investigate such opti\u00admizations in future work.  3.7 Interoperability with Java \nJavari is interoperable with Java and existing JVMs. The lan\u00adguage treats any Java method as a Javari \nmethod with no immutabil\u00adity speci.cation in the parameters or return type, or on the method (and similarly \nfor constructors, .elds, and classes). Since the Javari type system does not know what a Java method \ncan modify, it as\u00adsumes that the method may modify anything. This approach allows Javari to call Java \ncode safely, without any immutability guarantees being violated. However, in many cases this analysis \nis over-conservative. For example, Object.to\u00adString()can safely be assumed to be a read-only method. \nThere\u00adfore, Javari permits the user to specify alternative signatures for methods, constructors, and \n.elds in Java libraries or native code. The compiler trusts these annotations without checking them. \nWhile Java methods can be called from Javari, Java code can only call Javari methods that do not contain \nreadonlyin their sig\u00adnatures. The Javari compiler achieves this by using standard Java names for non-read-only \ntypes, methods, and classes, and by man\u00adgling the names of read-only types, methods, and classes into \nones that cannot be referenced by legal Java code. If a Javari program uses downcasts, which trigger \nthe insertion of run-time checks (sec\u00adtion 3.6), then any called Java code must be recompiled with the \nJavari compiler, or the run-time checks must be inserted at the call site, or the call must be proved \nto never pass a downcasted refer\u00adence, or checks must be inserted by the JVM. The Javari compiler guarantees \nthat Javari code maintains the reference immutability constraints. However, a malicious client could \nsubvert the type system by writing classes directly in JVM bytecode. In order to prevent such loopholes, \nthe bytecode veri.er should be extended to verify the reference immutability constraints, just as it \nveri.es other type constraints that are initially checked at the source code level. Class.le checking \nsuggests an alternative syntax: express information about reference immutability (in the source code \nand in and class.les) as metadata, a new feature in Java 1.5. Such an approach would eliminate the need \nfor the 1 2 new keywords in our proposal. 3.8 Type-based analyses This section describes several type-based \nanalyses that can be run after Javari type-checking in order to provide stronger guaran\u00adtees. A type-based \nanalysis assumes that the program type checks [27], but type-checking is independent of any subsequent \nanalysis. Javari enforces reference immutability a read-only reference is never used to side-effect \nany object reachable from it. Refer\u00adence immutability itself has many bene.ts (section 5). However, other \nguarantees may be desirable in certain situations. Four of these guarantees are object immutability, \nthread non-interference, parameter non-mutation, and return value non-mutation. One ad\u00advantage of reference \nimmutability is that a subsequent analysis can often establish these other properties from it (as outlined \nbelow), but the converse is not true. Extending reference immutability to stronger guarantees requires \nescape analysis or partial information about aliasing. Determining complete, accurate alias information \nremains beyond the state of the art; fortunately, the analyses below do not require full alias anal\u00adysis. \nObtaining alias information about a particular reference can be easier and more precise than the general \nproblem [1]. Many pro\u00adgrams use (some) pointers in disciplined and limited ways; these may correspond \nto, and may be motivated by, the places where programmers desire to reason about immutability. As new \nalias analyses become available, they can be applied to the below anal\u00adyses; this is preferable to embedding \nassumptions about a partic\u00adular alias analysis in the type system. Programmers can use other mechanisms \nfor controlling or analyzing aliasing, such as owner\u00adship types [6], alias types [2], linear types [37, \n13], or checkers of pointer properties [12, 15]. In the absence of an automated analy\u00adsis, a programmer \ncan use application knowledge about aliasing. Object immutability. An object cannot be modi.ed if all \nref\u00aderences to the object are read-only references. For example, this is guaranteed if at instantiation \nan object is assigned to a read-only reference, because only one reference exists. A further side con\u00addition \nis required: the constructor must not leak a non-read-only reference to the object or its parts. This \ncircumstance is rare, and a trivial analysis reveals that almost no classes in the JDK leak even a read-only \nreference to this. The object immutability analysis accommodates interning, logging, tracing, and other \nmechanisms that retain/leak read-only references. Another example is data structures that are treated \ndifferently by different phases of a program. For example, it is most natural for a graph or doubly-linked \nlist to be mutable while being built, but it may be used immutably elsewhere. A simple analysis can often \nindicate when only immutable references remain after construction. Thread non-interference. Other threads \ncannot modify an ob\u00adject if no other thread has a non-read-only reference to the object. Escape analysis \nfor multithreaded programs [32] can indicate what references escape to other threads. In some cases the \nguarantee may be necessary only between synchronization points or within a critical region, which may \nbe easier than a program-wide analysis. Parameter non-mutation. An object that is passed as a readonly \nparameter is not modi.ed until control exits the callee so long as no non-read-only reference aliases \nthe object within the procedure scope (or in another thread; see above). Effectively, this means that \nthe object should not be aliased by a non-read-only parameter or global variable. A variation on escape \nanalysis [28, 9] can indicate whether an object may be placed in a non-read-only global variable. Parameter \naliasing is simpler than the general alias problem, espe\u00adcially because parameters may be of incompatible \ntypes or may all be readonly. Return value non-mutation. An object returned as a readonly result is not \nmodi.ed outside the callee s module so long as no non\u00adread-only reference to the object escapes; this \nis a direct application of escape analysis. 3.9 Extension to new properties and languages This paper \npresents a type system for reference immutability and develops it in the context of Java. While the intuition \nbehind the enforced constraints is simple, our type rules and implementation cover the entire Java language. \nThis permits us to explore how the type system interacts with real-world constructs including sub\u00adtyping, \ninner types, exceptions, covariant arrays, and more. This experience leads us to believe that our approach \nshould be easy to extend to other languages especially imperative object-oriented languages, but most \nlikely others as well. (The primary dif.culty with a language such as C++ is its lack of type safety; \nC++ s loop\u00adholes prevent making any guarantees even after type checking.) We also believe that our approach, \nwhich combines static type checking with dynamic checking where necessary and appropriate in order to \nkeep the static rules simple and understandable by a programmer, should be extensible to other properties. \nFor exam\u00adple, one interesting annotation would be writeonly, which per\u00admits speci.c clients to set a \nvariable while prohibiting them from reading the value (for instance, seeing what others have written). \nA common paradigm that Javari supports (particularly when aug\u00admented by a type-based analysis) is an \ninitialization phase followed by a read-only phase; this could be made explicit in a writeonce annotation \nthat (like readonly) permitted unlimited reading. Such an analysis would be similar to a typestate analysis \n[34]. Further work is required to validate these intuitions and indicate the limits of our approach, \nbut our success to date is encouraging.  4. Type-checking rules Javari has the same run-time behavior \nas Java (except for pos\u00adsible run-time checks as described in section 3.6). However, at compile time, \nJavari ensures that modi.cation of objects through read-only references, or similar violations of the \nlanguage, do not occur. Section 4.1 introduces some de.nitions. Section 4.2 presents type-checking rules, \nin the style of the Java Language Speci.ca\u00adtion [17]. A technical report [4] contains complete type checking \nrules. Section 4.3 gives intuitive explanations of our treatment of inner classes and exceptions. 4.1 \nDe.nitions 4.1.1 Javari s types Javari s type hierarchy extends that of Java by including, for ev\u00adery \nJava reference type T, a new type readonly T. References of type readonly T are just like those of type \nT, but cannot be used to modify the object to which they refer. Formally, the types in Javari are the \nfollowing: 1. The null type null. 2. The Java primitive types. 3. Instance references. If C is any \nclass or interface, then C is a type representing a reference to an instance of C. 4. Arrays. For any \nnon-null type T, T[] is a type, representing an array of elements of type T. 5. Read-only types. For \nany non-null type T, readonly T is a type.  For convenience in the exposition later, we de.ne the depth \nand the base of a type. Informally, the depth is just the nesting depth of an array type, while the base \nof an array type is the type with all array dimensions removed. Formally, for a type T, we de.ne: Depth: \n-depth(T[])depth(T) -depth(readonly T)depth(T) -depth(T)if T is null, primitive, or an instance reference \n Base: -base(T[])base(T) -base(readonlyT)base(T)if base(T)is a read-only type -base(readonly T)readonly \nbase(T) if base(T)is a non-read-only type -base(T)T if T is null, primitive, or an instance reference \n Figure 2: A portion of the Javari type hierarchy, which includes read-only and non-read-only versions \nof each Java reference type. Arrows connect subtypes to supertypes.  4.1.2 Type equality and subtyping \nThe equality relation on types is de.ned as follows: 1. For primitive types, the null type, and references \nto instances of classes and interfaces, two types are equal iff they are the same Java type. 2. readonly \nT and readonly S are equal iff depth(T) depth(S)and base(readonly T)base(readonly S). 3. T[] and S[] \nare equal iff T and S are equal. 4. For a non-read-only type T, T and readonly S are equal iff Tand \nSare equal, and Tis either primitive or is a reference to an instance of an immutable class or interface \n(section 3.3).  Item 2 implies that readonly int[][]and readonly (readonly int[])[]are equivalent. \nIn other words, a read-only array of int arrays is the same as a read-only array of read-only int arrays. \nThis is because read-only is a transitive property, and hence if a level of an array is marked as read-only, \nthen all the lower levels are read-only. Equal types are considered to be the same type. They are inter\u00adchangeable \nin any Javari program. A subtyping relationship (T subtype of S, written as T <S)is also de.ned on types. \nIt is the transitive re.exive closure of the following: 1. byte <char, byte <short, char <int, short \n<int, int <long, long <float, float <double. 2. null <T for any non-primitive type T. 3. If Tand Sare \nclasses such that Textends Sor interfaces such that T extends S,or S is an interface and T is a class \nimple\u00admenting S, then T <S. 4. For any non-null types T and S,if T <S then T[] <S[]. 5. For any non-read-only \nnon-null type T, T <readonly T. 6. For any non-read-only non-null types T and S,if T <S then readonly \nT <readonly S.  7. For any non-null type T, T[] <java.io.Serializable, T[] <Cloneable, and T[] <Object. \n8. For any non-read-only non-null type T, (readonly T)[]< readonly T[]. Figure 2 shows an example of \nthe subtype hierarchy.  4.1.3 De.nitions relating to method invocations These de.nitions are the same \nas those in Java [17], except for the presence of the third clause in the de.nition of speci.city. Our \nde.nitions and rules do not consider constructors to be methods; we always specify which (or both) we \nmean. Compatibility: Given a method or constructor Mand a list of ar\u00adguments AlA2An, we say that the \narguments are compatible with Mif Mis declared to take nparameters, and for each ifrom to n, the type \nof Aiis a subtype of the declared type of the ith parameter of M. Speci.city: Given two methods of the \nsame name or two con\u00adstructors of the same class, Mland M2, we say that Mlis more speci.c than M2if the \nfollowing three conditions hold: 1. Mland M2take the same number of parameters, say with types PlPPnfor \nMl, and QlQ2Qnfor M2, 2 and for each ifrom to n, Piis a subtype of Qi. 2. The class (respectively, interface) \nin which Mlis declared is a subclass (subinterface) of the one where M2is declared, or Mland M2are declared \nin the same class (interface). 3. Either Mlis not read-only or M2is read-only (or both).   4.2 Type-checking \nrules 4.2.1 Programs A program type checks if every top-level class and interface dec\u00adlaration in the \nprogram type checks. 4.2.2 Class/interface declarations A class or interface declaration type checks \nif all of the following hold: 1. One of the following two conditions holds: (a) The class or interface \nis immutable and each method inherited from any superclass or superinterface is static, or read-only, \nand each of the inherited .elds inherited is static, mutable, or both .nal and of a read-only type. \n(b) The class or interface is not immutable, and neither is its direct superclass nor any of its direct \nsuperinterfaces.  2. No two .elds of the same name are declared within the body of the class/interface. \n 3. No two methods of the same name and signature are declared within the body of the class/interface. \nThe signature includes the number and declared types of the parameters, as well as whether the method \nis read-only. 4. No two constructors of the same signature are declared within the body of the class/interface. \n 5. Every .eld, method, constructor, member type, instance ini\u00adtializer, and static initializer declared \nwithin the class or in\u00adterface type checks.   4.2.3 Variable declarations For a .eld or local variable \ndeclaration of type T:  If it does not have an initializer, it type checks.  If it has an initializer \nof the form = E for an expression E, it type checks iff the assignment of the expression Eto a left hand \nside with type T would type check.  If it has an initializer of the form = {hl h } , where hare initializers, \nit type checks iff T = S[]or T = readonly   S[]for some type S, and the declaration Sv= hor readonly \n Sv= hrespectively would type check for every kbetween and n.  4.2.4 Method declarations A method, \nconstructor, instance initializer, or static initializer type checks if every expression, local variable \ndeclaration, and lo\u00adcal type declaration in the body type checks. 4.2.5 Expressions Each expression has \na type and a boolean property called assign\u00ad ability. An expression is type checked recursively, with \nall subex\u00adpressions type checked .rst. If the subexpressions type check, then their types and assignability \nare used to type check the given ex\u00adpression and deduce its type and assignability. Otherwise, the given \nexpression does not type check. For brevity, this paper gives only the type-checking rules for ex\u00adpressions \nthat are substantially different from those of Java; a tech\u00adnical report [4] contains the complete type \nchecking rules. Assignment: The rules for type checking assignments are the same as in Java, except that \nthe assignment expression does not type check if the lvalue is not assignable. The type of any assignment \nexpression that type checks is the same as the type of the lvalue, and the expression is not assignable. \nTypecast (T)A: In addition to the Java rules, a type cast must not cast from a read-only type to a non-read-only \ntype. The type of the cast expression is T and the expression is not assignable. Mutability typecast \n(mutable) A: Always type checks. If the type of Ais non-read-only, this expression is of the same type. \nIf the type of Ais readonly S[] for some S, then the type of this expression is (readonly S)[]. If the \ntype of Ais readonly S where depth(S), the type of this expression is S. The ex\u00adpression is never assignable. \nThis expression also triggers run-time checks (see section 3.6). Receiver reference this: In a static \ncontext, this does not type check. In a non-static context, this has type C if C is a class and thisappears \ninside a non-read-only method, a non-read-only con\u00adstructor, or an initializer of C. Inside a read-only \nmethod or a read\u00adonly constructor of C, this has type readonly C. this is not assignable. Containing \nobject reference name.this: Type checks if it oc\u00adcurs in a non-static context in a method, constructor, \nor initializer of a class I, and name names a class Cfor which Iis an inner class. The type of the expression \nis C unless it appears inside a read-only method or a read-only constructor of I, in which case the type \nis readonly C. This expression is not assignable. Instance creation new T(...): For creation of an inner \nclass, if the enclosing reference is read-only, then only read-only construc\u00adtors are eligible. If there \nis no enclosing reference, or the enclosing reference is not read-only, all constructors are eligible. \nThe ex\u00adpression type checks if there is a most speci.c accessible eligible constructor compatible with \nthe arguments to the class instance cre\u00adation expression. The type of the expression is readonly T if \nthe enclosing reference is a read-only reference, and T otherwise. This expression is never assignable. \nArray dereference A[E]: Type checks if Eis of integral type and Ais of type T[] or readonly T[] for some \ntype T; the type of the expression is respectively T or readonly T. The expression is assignable in the \n.rst case, and not assignable in the second. Field access: Let T be the declared type of the .eld being \nac\u00adcessed. If T is a read-only type, or the .eld is accessed through a non-read-only reference, or the \n.eld is a mutable or static .eld, then the type of the expression is T. Otherwise, the type of the ex\u00adpression \nis readonly T. The expression is assignable if the .eld is mutable or static, or if the reference through \nwhich the .eld is accessed is not a read-only reference. As an exceptional case, in\u00adside a read-only \nconstructor, barename .eld access expressions for .elds of the class that is being constructed are assignable. \nMethod invocation E (): If the invoking reference is read\u00adonly, only static or read-only methods are \neligible. If there is no invoking reference, only static methods are eligible. Otherwise, all methods \nare eligible. The expression type checks if there is a most speci.c accessible eligible method compatible \nwith the arguments to the method invocation. The type of the expression is the declared return type of \nthe method. A method invocation expression is never assignable. Exception throw E: Javari prohibits read-only \nexceptions from being thrown. A technical report [4] describes other approaches that we rejected because \nthey introduced loopholes into the type system or they require a complicated analysis that would provide \nvery little bene.t. Special rule: Any reference to an instance of an immutable class C, when used inside \nthe body of a non-immutable superclass or superinterface, is of type readonly C.  4.3 Inner classes \nand exceptions Previous work on language-level immutability has not addressed inner classes or exceptions. \nThis section explains how we handle them. It also provides an intuitive explanation of some of Javari \ns type checking rules. 4.3.1 Inner classes The type-checking rules guarantee that read-only methods do \nnot change any non-static non-mutable .elds of this. The inner class feature of Java adds complexity \nto this guarantee. Javari must en\u00adsure that no code inside an inner class can violate an immutabil\u00adity \nconstraint. There are three places in an inner class where im\u00admutability violations could occur: in a \nconstructor, in a .eld or instance initializer, or in a method. The Javari type-checking rules (section \n4) prevent any such violation. This section explains the rules by way of an example. class Outer { inti \n=1; // foo is readonly, so foo should not change i public void foo() readonly { class Local() { Local() \nreadonly { i = 2; // ERROR: changes i j=3; //OK } intj=(i=4); //ERROR:changesi void bar() readonly \n{ i = 5; // ERROR: changes i } } // Would be erroneous if either Local() // or bar() were not declared \nas readonly. new Local().bar(); } } Constructors: Read-only constructors (see section 3.2) prevent \nthis change. There are two possibilities for a change of i in a constructor of Local. This change could \nhappen inside a read\u00adonly constructor, or inside a non-read-only one. If the constructor of Local is \nread-only, the assignment i=2 will not type check: read-only constructor bodies type check like read-only \nmethod bod\u00adies, except that a .eld of the class being constructed accessed by simple name is assignable \nand non-read-only. On the other hand, if the constructor of Local() is not read-only, it cannot be in\u00advoked, \nsince Javari allows only read-only constructors to be in\u00advoked through a read-only enclosing instance, \nand the enclosing instance is implicitly this, a read-only reference inside foo(). Initializers: If at \nleast one read-only constructor exists in a given class or if an anonymous class is being constructed \nwith read-only enclosing instance, the compiler treats instance initializers and in\u00adstance .eld initializers \nas if they were in the body of a read-only constructor. The second case is necessary because anonymous \ncon\u00adstructors have an implicit constructor, which is considered a read\u00adonly constructor if the enclosing \ninstance is read-only. This rule prevents modi.cations to the state of a read-only enclosing instance \nfrom initializers of inner classes. Methods: The rule that new Local()must have type readonly Local if \nthe enclosing instance is read-only prevents modi.cation of the enclosing instance. If bar() is declared \nas read-only, the assignment to i inside it will fail to type check. If bar() is not declared as read-only, \nthen the call to bar() in the example above does not type check, because new Local() has type readonly \nLocal. 4.3.2 Exceptions Our desire for interoperability with Java and the JVM compli\u00adcates Javari s \nhandling of exceptions. An exception thrown with a throw statement whose argument is a read-only reference \nshould only be catchable by a catch statement whose parameter is de\u00adclared as readonly, because otherwise \nthe catchstatement would be able to change the exception s state. Javari prohibits read-only exceptions \nfrom being thrown. There\u00adfore, the type-checker rejects some safe uses of read-only refer\u00adences to exceptions. \nThis restriction has so far caused no dif.culty in practice (see section 5). A technical report [4] describes \nother approaches that we re\u00adjected because they introduced loopholes into the type system or they require \na complicated analysis that would provide very lit\u00adtle bene.t. The key idea underlying these approaches \nis to wrap some exceptions at run-time in special wrapper objects, so that non\u00adreadonly catch statements \ndo not catch read-only exceptions. Since Javari runs on an unmodi.ed Java Virtual Machine and inter\u00adoperates \nwith legacy bytecode .les, each wrapper class should be a subtype of Throwable (which Java treats specially). \nHowever, in Javari, readonly Throwable is a supertype of Throwable (see .gure 2). Reconciling these problems \nis possible, but it is compli\u00adcated, introduces possibilities for error in the type system and the implementation, \nand provides little practical bene.t.  5. Experience This section presents our experience with using \nJavari. Our pri\u00admary goal was to gain qualitative experience, and our key result is that the type system \nand language are practical, usable, and effec\u00adtive. Section 5.1 expands on our observations. Then, the \nremain\u00adder of this section provides supporting details about our experience. Section 5.2 describes the \nJavari programs. Section 5.3 discusses the annotation process. Section 5.4 categorizes every type-checking \ner\u00adror that occurred while annotating two of the .ve codebases, with examples of errors in each category. \nSection 5.5 discusses our ex\u00adperience with generics. 5.1 Qualitative results A type system should be \neasy to use and understand. The lan\u00adguage design should not overly constrain programmers, and it should \n.t with the way they work. Because practicality was one of our goals, we evaluated our type system, language, \nand implementa\u00adtion by both writing code in Javari and also annotating existing Java code with readonly. \nWriting code in Javari provides ex\u00adperience with the language the way many programmers would use it. \nIn addition, it permits greater .exibility in working around type\u00adchecking errors than working with existing \ncode does, and it can be more bene.cial than annotation of existing code, since it pro\u00advides earlier \nindication of errors. On the other hand, annotation of existing code is more quanti.able, since it is \npossible to track the time spent annotating and the problems discovered in original code. Also, it permits \nevaluation of how Javari .ts with the existing prac\u00adtice of code written by programmers who did not have \nimmutability in mind while coding. The bene.ts of reference immutability included improving doc\u00adumentation \n(and making it consistent with the implementation), en\u00adhancing our understanding of the programs, eliminating \nerrors, ex\u00adcising convoluted code, and ef.ciency improvements (by eliminat\u00ading copying). We found writing \ncode from scratch to be faster, easier, and more natural than annotating existing code. The effort of \nadding readonly annotations seemed to be subsumed by that of writing the types, and we felt the ability \nto specify reference immutability caused us to think more formally about interfaces and make fewer design \nand implementation mistakes. Annotating existing code was not dif.cult, particularly since the code could \nbe annotated module by module, relying primarily on local reasoning. The bulk of our annotation effort \nwas consumed in reverse en\u00adgineering (determining both what the code did and what it ought to do) and \nin debugging. We strove to minimize disruptive code changes, but found that some problems could not be \nworked around entirely within the type system. The Javari problems (section 5.4.2) were few in number \n(rarer than Java casts) and most could be worked around by use of downcasts, though six unsafe uses required \nrewrit\u00ading. Our experience led us to add language features for parameter\u00adization and for downcasts. The \nparameterization feature was not strictly necessary, but it did prevent signi.cant code duplication. \nOverall, adding parameterization was an easy task, especially when it parameterized over the immutability \nof the receiver object or when it was added identically to all subclasses of a class, as hap\u00adpened for \nseveral class hierarchies. See section 5.5 for more details. The downcast mechanism was necessary because \nof legacy li\u00adbraries, the pre-existing design of the software, and facts beyond the type system. We conclude \nthat a fully statically enforced im\u00admutability type system is likely to be of limited applicability in \npractice. Using an explicit keyword (mutable) for immutability downcasts was critical in preventing us \nfrom accidentally leaving a Java cast in place but forgetting to add readonly to its type. Such a cast, \nif permitted to affect immutability, would cause Javari to silently insert run-time checks, and the error \nwould be discovered only at run time. Without such a feature, or an analysis to indicate which casts \nare immutability downcasts, we estimate that at least a third, and perhaps many more, of the annotation \nerrors we made would not have been caught until run time. Our experience with Javari also convinced us \nthat reference im\u00admutability is often suf.cient. We were rarely able to use immutable types (object immutability); \nit is possible that redesigning the pro\u00adgrams from the ground up may have increased the applicability \nof object immutability, but doing so would have had a severe perfor\u00admance cost. By contrast, reference \nimmutability enabled us to rea\u00adson about interfaces and program phases. We found human reason\u00ading effective; \nwe had not implemented the type-based analyses of section 3.8, but we suspect they would have helped \neven more. Our experience revealed some weaknesses of our type system. In complex systems, transitive \nimmutability may be too strong a constraint. For example, all Swing containers have child and parent \nreferences, so transitive immutability of any reference implies that almost every container is unchangeable. \nThus, few references to Swing containers can be annotated as read-only. Similarly, legacy libraries may \nneed access to a portion of the transitive state of a read-only reference (for an example, see section \n5.4.2). Finally, our type system does not support re.ection. These problems can be solved by run-time \nchecks, but they reduce Javari s ability to help programmers by detecting errors at compile-time.  \nNew code Annotated Java code java java Gizmo-Program .util Javari .util ball Daikon Code size classes \n42 191 29 118 781 methods 373 1049 331 671 7454 lines 2412 16089 7666 15480 121607 NCNB lines 1740 9826 \n2793 9276 81269 Opportunities readonly 1312 4615 1269 2357 31687 Annotations readonly 854 2235 724 \n520 10369 mutable 24 28 9 17 110 generics 105 66 94 13 717 downcast 3 3 14 6 85    readonlyuses \nlocal 81 468 93 69 1668 .eld 16 54 9 0 83 parameter 152 211 180 69 2148 cast 19 377 29 27 1148 return \ntype 154 88 85 24 459 method 197 462 114 212 2913 class 1 37 1 3 94 generics arg 234 538 213 116 1856 \nCode errors N/A N/A N/A Documentation 2 1 Implementation 1 19 Bad Style 3 4 Javari problems In.exibility \n3 23 Re.ection 1 2 Annotation errors Signature 11 124 Implementation 31 486 Library 3 18 Time (hh:mm) \nN/A N/A N/A Signature 2:40 5:30 Implementation 4:30 7:35 Type check and 6:10 55:05 .x errors Figure \n3: Programs written in Javari or converted from Java to Javari. The number of classes includes both classes \nand interfaces. The number of methods includes constructors. NCNB lines is the number of non-comment, \nnon-blank lines. Opportunities counts the number of places where readonly could appear (not includ\u00ading \nprimitive types or common immutable classes such as String and subclasses of Number, and counting each \nmulti-dimensional array as only one opportunity). Section 5.4 explains the error cat\u00adegories. Section \n5.3 explains the time categories. Errors and time were recorded for only two of the programs. 5.2 Javari \nprograms We wrote many of the container classes in the java.utilpack\u00adage from scratch in Javari, both \nto gain experience with Javari and because Javari requires parameterized container classes. We also annotated \nfour existing Java codebases. Javari s compiler was our .rst major annotation experience. The annotation \nwas intermixed with changes to the language and bug .xes in the compiler. Sun container classes. We complemented \nthe parameterized container classes we had written from scratch by annotating ad\u00additional classes from \nthe Sun JDK 1.4.1 reference implementation. We found an instance of bad coding style (see section 5.4). \nGizmoball, an extensible pinball game, is the .nal project in a software engineering class at MIT (6.170 \nLaboratory in Software Engineering). It was designed and written in two months by a group of four people \nthat included the .rst author of this paper, who wrote about a third of the code. Daikon is a tool for \ndynamic detection of likely invariants in programs [11]. The annotation was performed, without any help, \nby a programmer who had no previous experience with Daikon (not even as a user). The annotation time \nincluded time to understand this large, complex system well enough to annotate it. 5.3 Annotation process \nOur methodology for annotating Java programs with readonly proceeded in three stages. During the .rst \nstage of the annotation ( Signature in the bottom section of .gure 3), we read the docu\u00admentation and \nthe signatures of all public and protected methods in the program, and marked the parameters, return \ntypes, and methods themselves with readonly. For example, if the documentation for a method speci.ed \nthat the method does not modify a parameter, we marked it with readonly. The second stage of the annotation \n( Implementation in .gure 3) was to annotate the signatures of private methods and the implementations \nof all methods. The third stage ( Type check and .x errors ) involved running the compiler on the resulting \nprogram, and considering and correcting any type checking failures. Our annotation experience represents \na pessimistic upper bound on the time cost, for six reasons. 1. The programmer was not familiar with \nthe code, so the time includes program understanding and error diagnosing. 2. Completed code was annotated, \nbut our experience indicates that the effort is signi.cantly smaller when writing new code, because programmers \nalready make design decisions about immutability, and catching errors would have recouped part or all \nof the cost. 3. The Javari system was still under development and contained some limitations and bugs. \n 4. Recording every type-checking error message (732 in all) was time-consuming and distracting. 5. \nThe code contained no generic types, which would have eased the process. 6. We had no mechanical assistance \nsuch as type inference.  Despite these problems, the annotation process was quick and represented a \nsmall fraction of the original development time (un\u00adder 5% for Gizmoball and considerably less for Daikon; \n1200 and 1800 lines per hour, respectively). 5.4 Error classi.cations The Javari compiler issues an \nerror for three general reasons. First, the code may be erroneous, or the documentation may in\u00adcorrectly \ndescribe it. Second, the Javari type system may be too restrictive, issuing an error about code that \ndoes not type check but that would be safe if it were run. Third, the user may have made an error during \nannotation, which the compiler has discovered. Fig\u00adure 3 classi.es each type checking error encountered \nwhile annotat\u00ading the Gizmoball and Daikon systems, which together are 137,000 lines of code (91,000 \nnon-comment non-blank lines). The .nal an\u00adnotated code passed the Javari type checker without errors. \nThis section describes the categorization of .gure 3 and gives examples of errors in each category. A \ntechnical report [4] describes all 59 of the code errors and Javari problems. 5.4.1 Code errors Code \nerrors are problems with the original Java program that were discovered during the annotation and type \nchecking process. These errors had remained in the code despite extensive testing; for example, Daikon \nhas a worldwide user base and an 8-hour-long regression test that runs nightly. We subdivided code errors \ninto three subcategories. Documentation: This subcategory represents errors in the doc\u00adumentation of \na class or a public or protected method, causing an incorrect annotation. For example, the documentation \nof Daikon s process samplemethod did not document that the second param\u00adeter, ValueTuple vt, is mutated \nby side effect. We updated the documentation to indicate this fact. Implementation: This subcategory \nrepresents bugs in the orig\u00adinal code, found during the type checking of the annotated code. The Gizmoball \nerror was a representation exposure caused by a method improperly returning a reference to private data. \nWe .xed it by adding readonlyto the return type of the misbehaving method. An example of a Daikon error \nwas a method that sorted its input array before computing some statistics about the array. We .xed this \nerror by rewriting the method to do an array copy .rst. It was obvious that some of the errors could \nlead to user-visible failures; however, we did not verify this for every error. Bad Style: This subcategory \nrepresents type checking failures caused by bad coding style. The code that causes these errors does \nnot, to our knowledge, cause run-time failures, but it could have easily been written in a better style \nthat would not only allow the code to type check, but would also make the program easier to maintain \nand debug. For example, Gizmoball recalculates the size of gizmos that are displayed to the screen during \neach paint()call. A better alterna\u00adtive, which would also type check under Javari s rules, would be to \nrecalculate only when the window size changes. Daikon s method canCreateAndWrite(readonlyFile file) tests \nwhether file can be created by calling file.createNew\u00adFile()and file.delete(). These calls fail to type-check, \nsince they modify the File (and the .le system). It is cleaner, and ade\u00adquate for the purpose, to test \nwhether the directory containing the .le is writable. Another example of bad coding style that is caught \nby the type system is in java.util.TreeMap. This class has a private method buildFromSortedthat takes \nan Iteratorparameter; this Itera\u00adtor iterates either over keys or over entries in the map, depending \non the value of a different parameter. It would be preferable to have two separate code paths for the \ntwo different iterators. (The code authors feared that if they duplicated this particularly subtle imple\u00admentation, \nthen in the future a maintainer might change one copy but not the other [19].) In Javari there is no \ncorrect typing of the Iteratorparameter. The early release Java 1.5 libraries use a raw rather than a \nparameterized type for that Iterator. 5.4.2 Javari problems In order to guarantee safety, type systems \ntend to conservatively reject programs that might behave unsafely i.e., that cannot be proved to behave \nsafely. In.exibility of the language: This subcategory represents safe code rejected by the type system \ns conservative analysis. We worked around them by omitting readonly annotations, by adding down\u00adcasts, \nor by rewriting code. Half of all the type system in.exibility problems (13 instances in Daikon) were \ndue to code of the form readonly A a = new A(); foo(new A[] { a }); // ERROR The array created by new \nA[]is typed as A[], so cannot contain a readonly A. The problem was .xed by rewriting the code as readonly \nA a = new A(); readonly A[] as = { a }; foo(as); Another way to prevent the problem would be to change \nthe lan\u00adguage to introduce a new syntax for array constructors: foo(new readonly A[] { a }); As another \nexample, consider the following Gizmoball code snip\u00adpet: public class BuildDriver { private JFrame jf; \n ... private void askForLoad() readonly { final JDialog jd = new JDialog(jf, true); // use dialog box \njd only to get a filename } } The JDialogconstructor (not shown) is declared to take a mutable JFrame, \nbecause JDialog.getOwner()returns the JFrame, and a caller of getOwner often needs to modify the result. \nThus, the new JDialog expression in the above code does not type check. Method askForLoad never calls \njg.getOwner(), nor does jd escape that method, but those facts are beyond the type checker s static analysis, \nand so the compiler rejects this safe code. We .xed the problem by adding downcasts, similarly to adding \na cast to work around Java s type system. Re.ection: This subcategory represents uses of re.ection in \nthe original program. Analysis of re.ection is beyond our type sys\u00adtem, and other Java type systems of \nwhich we are aware. (Indeed, re.ection already permits Java code to violate accessibility modi\u00ad.ers and \nmodify the contents of a String.) The dynamic checks of section 3.6 can ensure safety in the presence \nof re.ection. 5.4.3 Annotation errors This category represents mistakes committed by us during the annotation \nprocess. Usually, these were due to unfamiliarity with the code or to poor documentation. The Signature \nMisannotation subcategory represents errors due to an incorrect annotation of a signature of a public \nor protected method during the .rst stage of the annotation. The Implementation Misannotation subcategory \nrepresents the errors caused by an incorrect annotation of the type of a private .eld, the signature \nof a private method, the type of a local variable, or a type used in a cast expression. The Library Mis\u00adannotation \nsubcategory represents the errors caused by an incorrect annotation of a library method, for example \nan AWT method. (As noted in section 3.7, Javari provides annotated Java libraries. The library annotation \ntime is not included in .gure 3, but we discov\u00adered some errors in the library annotations while annotating \nclient code.)  5.5 Generics Our annotation introduced a fairly large amount of genericity ( generics \nin .gure 3). Of the uses of genericity in Daikon, 24 (3%) are parameterized types and the other 97% are \nparameterized methods. 48% of the parameterization appears in two external li\u00adbraries that are included \nin the Daikon distribution, and they caused additional genericity at uses of the libraries. Overall, \nfor method parameterization, the type parameters were used in the following ways: in return type 56% \nin formal types 59% in method type 79% as type parameter 50% We found it natural and .exible to declare \nthe immutability of a reference at a variable declaration, rather than using an immutable type (which \nJavari also supports). Furthermore, adding a type pa\u00adrameter would have required a change to all client \ncode that men\u00adtioned the type name. As a minor point, method parameterization resulted in less code duplication. \nPerhaps some of the generic\u00adity could have been converted from method to type generics; this would further \nreduce the number of annotations required.  6. Related work Many other researchers have noticed the \nneed for a mechanism for specifying and checking immutability. This section discusses other proposals \nand how ours differs from them. Similarly to Javari, JAC [18] has a readonly keyword in\u00addicating transitive \nimmutability, an implicit type readonly T for every class and interface T de.ned in the program, and \na mutable keyword. However, the other aspects of the two lan\u00adguages syntax and semantics are quite different. \nFor exam\u00adple, JAC provides a number of additional features, such as a larger access right hierarchy (readnothing \n<readimmutable <readonly <writeable) and additional keywords (such as nontransferrable) that address \nother concerns than immutabil\u00adity. The JAC authors propose implementing JAC by source rewrit\u00ading, creating \na new type readonly T that has as methods all methods of T that are declared with the keyword readonly \nfol\u00adlowing the parameter list (and then compiling the result with an ordinary Java compiler). However, \nthe return type of any such method is readonly. For example, if class Person has a method public Address \ngetAddress() readonly, then readonly Personhas method publicreadonlyAddress getAddress() readonly. In \nother words, the return type of a method call de\u00adpends on the type of the receiver expression and may \nbe a super\u00adtype of the declared type, which violates Java s typing rules. Ad\u00additionally, JAC is either \nunsound for, or does not address, arrays of readonly objects, casts, exceptions, inner classes, and subtyp\u00ading. \nJAC readonly methods may not change any static .eld of any class. The paper suggests that supplying readonly \ntypes can be supplied as type variables for generic classes without change to the GJ proposal. By contrast \nto JAC, in Javari the return type of a method does not depend on whether it is called through a read\u00adonly \nreference or a non-read-only one. Javari obeys the Java type rules, uses a type checker rather than a \npreprocessor, and integrates immutability with type parameterization. Additionally, we have implemented \nJavari and evaluated its usability. The above comments also explain why use of read-only inter\u00adfaces \nin Java is not satisfactory for enforcing reference immutabil\u00adity. A programmer could de.ne, for every \nclass C, an interface RO C that declares the readonly methods and that achieves transitivity by changing \nmethods that returned (say) B to return RO B. Use of RO C could then replace uses of Javari s readonly \nC. This is similar to JAC s approach and shares similar problems. For instance, to permit casting, C \nwould need to implement RO C, but some method return and argument types are incompatible. Furthermore, \nthis ap\u00adproach does not allow readonly versions of arrays or even Object, since RO Object would need \nto be implemented by Object.It also forces information about a class to be maintained in two sepa\u00adrate \n.les, and it does not address how to perform run-time checking of potentially unsafe operations or various \nother Java constructs. Skoglund and Wrigstad [33] take a different attitude toward im\u00admutability than \nother work: In our point of [view], a read-only method should only protect its enclosing object s transitive \nstate when invoked on a read reference but not necessarily when invoked on a write reference. A read \n(read-only) method may behave as a write (non-read-only) method when invoked via a write reference; a \ncaseModeOf construct permits run-time checking of reference writeability, and arbitrary code may appear \non the two branches. This suggests that while it can be proved that read ref\u00aderences are never modi.ed, \nit is not possible to prove whether a method may modify its argument. In addition to read and write references, \nthe system provides context and any references that behave differently depending on whether a method \nis invoked on a read or write context. Compared to this work and JAC, Javari s type parameterization \n(adopted from Java 1.5) gives a less ad hoc and more disciplined way to specify families of declarations. \n   The functional methods of Universes [25] are pure methods that are not allowed to modify anything \n(as opposed to merely not being allowed to modify the receiver object). Pechtchanski and Sarkar [29] \nprovide a framework for immutabil\u00adity speci.cation along three dimensions: lifetime, reachability, and \ncontext. The lifetime is always the full scope of a reference, which is either the complete dynamic lifetime \nof an object or, for param\u00adeter annotations, the duration of a method call. The reachability is either \nshallow or deep. The context is whether immutability applies in just one method or in all methods. The \nauthors provide 5 instan\u00adtiations of the framework, and they show that immutability con\u00adstraints enable \noptimizations that can speed up some benchmarks by 5 10%. Javari permits both of the lifetimes and supplies \ndeep reachability, which complements the shallow reachability provided by Java s final keyword. Capabilities \nfor sharing [7] are intended to generalize various other proposals for immutability and uniqueness. When \na new ob\u00adject is allocated, the initial pointer has 7 access rights: read, write, identity (permitting \naddress comparisons), exclusive read, exclu\u00adsive write, exclusive identity, and ownership (giving the \ncapability to assert rights). Each (pointer) variable has some subset of the rights. These capabilities \ngive an approximation and simpli.cation of many other annotation-based approaches. Porat et al. [30] \nprovide a type inference that determines (deep) immutability of .elds and classes. (Foster et al. [14] \nprovide a type inference for C s (non-transitive) const.) A .eld is de.ned to be immutable if its value \nnever changes after initialization and the ob\u00adject it refers to, if any, is immutable. An object is de.ned \nto be immutable if all of its .elds are immutable. A class is immutable if all its instances are. The \nanalysis is context-insensitive in that if a type is mutable, then all the objects that contain elements \nof that type are mutable. Libraries are neither annotated nor analyzed: every virtual method invocation \n(even equals) is assumed to be able to modify any .eld. The paper discusses only class (static) variables, \nnot member variables. The technique does not apply to method parameters or local variables, and it focuses \non object rather than reference immutability, as in Javari. An experiment in\u00addicted that 60% of static \n.elds in the Java 2 JDK runtime library are immutable. This is the only other implemented tool for immutabil\u00adity \nin Java besides ours, but the tool is not publicly available for comparison. Effect systems [21, 36, \n26] specify what state (in terms of regions or of individual variables) can be read and modi.ed by a \nprocedure; they can be viewed as labeling (procedure) types with additional information, which the type \nrules then manipulate. Type systems for immutability can be viewed as a form of effect system. Our system \nis .ner-grained than typical effect systems, operates over references rather than values, and considers \nall state reachable from a reference. Our focus in this paper is on imperative object-oriented languages. \nIn such languages, .elds are mutable by default. In our type sys\u00adtem, when a type is read-only, the default \nis for each .eld to be immutable unless the user explicitly marks it as mutable. Func\u00adtional languages \nsuch as ML [23] always use the latter policy: they default all .elds to being immutable. OCaml [20] combines \nobject\u00adorientation with a mutable annotation on .elds (for example, ref\u00aderences are implemented as a \none-.eld mutable record). However, without a notion of read-only types, users are forced to hide muta\u00adbility \nvia use of interfaces and subtyping, which is less .exible and expressive than our proposal. A programming \nlanguage automatically provides a sort of im\u00admutability constraint for parameters that are passed, or \nresults that are returned, by value. Since the value is copied at the procedure call or return, the original \ncopy cannot be modi.ed by the imple\u00admentation or client, respectively. Pass-and return-by-vale is typi\u00adcally \nused for values that are small. Some programming languages, such as Pascal and Ada, permit variables \nto be explicitly annotated as in, out, or in/out parameters; this is an early and primitive form of compiler-enforced \nimmutability annotation. 6.1 C++ const C++ s const keyword is intended to aid in interfaces, not sym\u00adbolic \nconstants [35]. Our motivation is similar, but our notion of immutability, and our type system, differ \nfrom those of C++, thus avoiding the pitfalls that led Java s designers to omit const. Because of numerous \nloopholes, the constnotation in C++ pro\u00advides no guarantee of immutability even for accesses through \nthe const reference. An unchecked cast can remove const from a variable, as can (mis)use of type system \nweaknesses such as unions and varargs (unchecked variable-length procedure arguments). C++ permits the \ncontents of a read-only pointer to be modi\u00ad.ed: read-only methods protect only the local state of the \nenclos\u00ading object. To guarantee transitive non-mutability, an object must be held directly in a variable \nrather than in a pointer. However, this precludes sharing, which is a serious disadvantage. Addition\u00adally, \nwhereas C++ permits speci.cation of const at each level of pointer dereference, it does not permit doing \nso at each level of a multi-dimensional array. Finally, C++ does not permit parameteri\u00adzation of code \nbased on the immutability of a variable. By contrast to C++, Javari is safe: its type system contains \nno loopholes, and its downcast is dynamically checked. Furthermore, it differs in providing guarantees \nof transitive immutability, and in not distinguishing references from objects themselves; these differ\u00adences \nmake Javari s type system more uniform and usable. Unlike C++, Javari permits mutability of any level \nof an array to be spec\u00adi.ed, and permits parameterization based on mutability of a vari\u00adable. Javari \nalso supports Java features that do not appear in C++, such as nested classes. Most C++ experts advocate \nthe use of const(for example, Mey\u00aders advises using constwherever possible [22]). However, as with many \nother type systems (including those of C++ and Java), some programmers feel that the need to specify \ntypes outweighs the ben\u00ade.ts of type checking. At least three studies have found that static type checking \nreduces development time or errors [24, 16, 31]. We are not aware of any empirical (or other) evaluations \nregarding the costs and bene.ts of immutability annotations. Java programmers seem eager for compiler-checked \nimmutability constraints: as of May 2004, support for const is the fourth most popular Java re\u00adquest \nfor enhancement.5 A common criticism of const is that transforming a large ex\u00adisting codebase to achieve \nconst correctness is dif.cult, because const pervades the code: typically, all (or none) of a codebase \n.See http://developer.java.sun.com/developer/bugPa\u00adrade/top25rfes.html. The .rst and third most popular \nrequests (generics and covariant return types) are addressed by the Java 1.5 language, and the second \nmost popular request is Provide docu\u00admentation in Chinese. must be annotated. This propagation effect \nis unavoidable when types or externally visible representations are changed. Inference of constannotations \n(such as that implemented by Foster et al. [14]) eliminates such manual effort. Even without a type inference, \nwe found the work of annotation to be greatly eased by fully annotat\u00ading each part of the code in turn \nwhile thinking about its contract or speci.cation, rather than inserting partial annotations and attempt\u00ading \nto address type checker errors one at a time. The proper solu\u00adtion, of course, is to write const annotations \nin the code from the beginning, which takes little or no extra work. Another criticism of C++ s constis \nthat it can occasionally lead to code duplication, such as the two versions of strchrin the C++ standard \nlibrary. Immutability parameters (section 3.5) make the need for such duplication rare in Javari. Finally, \nthe use of type casts (section 3.6) permits a programmer to soundly work around problems with annotating \na large codebase or with code duplica\u00adtion.  7. Conclusion We have presented a type system that is capable \nof expression, compile-time veri.cation, and run-time checking of reference im\u00admutability constraints. \nReference immutability guarantees that the reference cannot be used to perform any modi.cation of a (tran\u00adsitively) \nreferred-to object. The type system should be generally applicable to object-oriented languages, but \nfor concreteness we have presented it in the context of Javari, an extension to the full Java language. \nWe have implemented the language and presented experience with non-trivial Javari programs. The evidence \nsuggests that, although a language designer s budget (in terms of new lan\u00adguage features) is limited, \nreference immutability is worthy of se\u00adrious consideration and further investigation. Our goal is not \nto produce a complicated and subtle new type system, but a solution to an important problem that others \nhave grappled with unsuccessfully. Many of the components of our ap\u00adproach have previously appeared in \nthe literature. We have synthe\u00adsized these pieces in a novel way, resulting in a simple and effective \napproach. This paper s contributions include the following. We chose a practical and effective combination \nof language fea\u00adtures. For instance, we describe a type system for reference rather than object immutability. \nReference immutability is useful in more circumstances, such as specifying interfaces, or objects that \nare only sometimes immutable. We proposed a set of type-based analyses that can run after type checking \nin order to make stronger guarantees or to enable veri.\u00adcation or transformation. For example, we show \nhow to guarantee object immutability. The type-based analyses require only limited aliasing information; \nusually a simple escape or alias analysis suf\u00ad.ces, but an arbitrary alias analysis may be used. We combined \ncompile-time and run-time checking to create an effective, practical, and safe system. The system detects \nall vio\u00adlations of the immutability constraints at compile time, in the ab\u00adsence of immutability downcasts. \nIf a programmer chooses to use downcasts (which are sometimes essential for interoperability with legacy \ncode or to express application invariants), then ef.cient run\u00adtime checking at modi.cation points catches \nall unsafe uses while permitting safe ones. We provided a safe type system for transitive immutability \nin the context of a full, real, object-oriented language, Java, rather than a model or subset. It is \nsimple to see how our ideas would apply to an idealized toy language, but it was nontrivial to support \na real language with all its wrinkles. Our success indicates that the system is comprehensible and usable \nin practice. The syntax and semantics of Javari are backward compatible with Java and the Java Virtual \nMachine. Java and Javari code can call one another in a safe manner. This compatibility and inter\u00adoperability \nwith Java eases the transition between the languages; developers can continue to use existing libraries \nand can adopt a pay-as-you-go strategy to annotating their code with immutability constraints. Javari \nis also faithful to the spirit of Java: it feels like Java and introduces run-time checks only as a result \nof constructs that already result in Java run-time checks. We have provided the .rst implementation and \nevaluation of tran\u00adsitive (deep) immutability in the context of a safe language. Experi\u00adence with 160,000 \nlines of Javari code demonstrates that the syntax, rules, and checking are workable in practice. Even \na user unfamil\u00adiar with a 120,000-line program was able to annotate it quickly and discover errors. Our \nstudy provides insight into what immutability\u00adrelated errors users make in the absence of Javari s features. \nJavari revealed over two dozen real errors in well-tested code. The bene.ts, especially in reducing wasted \ntime and clarifying spec\u00adi.cations, are potentially much greater when Javari is used through\u00adout the \ndevelopment cycle rather than after the fact. Even the guar\u00adantee of reference immutability alone is \nenough to improve docu\u00admentation, .nd errors, and expose other problems.  Acknowledgments Iuliu Vasilescu \nimplemented the prototype run-time checking sys\u00adtem. We are grateful to Adam Kie. zun, Chandra Boyapati, \nCraig Chambers, Walter Tichy, and the anonymous referees for their help\u00adful comments on a draft of this \npaper. This work was supported in part by NSF grant CCR-0133580 and a gift from TIBCO Software. References \n[1] A. Aiken, J. S. Foster, J. Kodumal, and T. Terauchi. Checking and inferring local non-aliasing. In \nProceedings of the ACM SIGPLAN 2003 Conference on Programming Language Design and Implementation, pages \n129 140, San Diego, CA, June 9 11, 2003. [2] J. Aldrich, V. Kostadinov, and C. Chambers. Alias annotations \nfor program understanding. In Object-Oriented Programming Systems, Languages, and Applications (OOPSLA \n2002), pages 311 330, Seattle, WA, USA, Oct. 28 30, 2002. [3] D. F. Bacon and P. F. Sweeney. Fast static \nanalysis of C++ virtual function calls. In Conference on Object-Oriented Programming, Systems, Languages, \nand Applications, pages 324 341, San Jose, CA, USA, Oct. 6 10, 1996. [4] A. Birka. Compiler-enforced \nimmutability for the Java language. Technical Report MIT-LCS-TR-908, MIT Laboratory for Computer Science, \nCambridge, MA, June 2003. Revision of Master s thesis. [5] J. Bloch. Effective Java Programming Language \nGuide. Addison Wesley, Boston, MA, 2001. [6] C. Boyapati, B. Liskov, and L. Shrira. Ownership types \nfor object encapsulation. In Proceedings of the 30th Annual ACM SIGPLAN-SIGACT Symposium on Principles \nof Programming Languages, pages 213 223, New Orleans, LA, Jan. 15 17, 2003. [7] J. Boyland, J. Noble, \nand W. Retert. Capabilities for sharing: A generalisation of uniqueness and read-only. In ECOOP 2001 \n Object-Oriented Programming, 15th European Conference, pages 2 27, Budapest, Hungary, June 18 22, 2001. \n[8] G. Bracha, M. Odersky, D. Stoutamire, and P. Wadler. Making the future safe for the past: Adding \ngenericity to the Java programming language. In Object-Oriented Programming Systems, Languages, and Applications \n(OOPSLA 98), pages 183 200, Vancouver, BC, Canada, Oct. 20 22, 1998. [9] J.-D. Choi, M. Gupta, M. J. \nSerrano, V. C. Sreedhar, and S. P. Midkiff. Escape analysis for Java. In Object-Oriented Programming \nSystems, Languages, and Applications (OOPSLA 99), pages 1 19, Denver, Colorado, Nov. 3 5, 1999. [10] \nJ. Dean, D. Grove, and C. Chambers. Optimization of object-oriented programs using static class hierarchy \nanalysis. In ECOOP 95, the 9th European Conference on Object-Oriented Programming, pages 77 101, \u00b0 Aarhus, \nDenmark, Aug. 7 11, 1995. [11] M. D. Ernst, J. Cockrell, W. G. Griswold, and D. Notkin. Dynamically discovering \nlikely program invariants to support program evolution. IEEE Transactions on Software Engineering, 27(2):1 \n25, Feb. 2001. A previous version appeared in ICSE 99, Proceedings of the 21st International Conference \non Software Engineering, pages 213 224, Los Angeles, CA, USA, May 19 21, 1999. [12] D. Evans. Static \ndetection of dynamic memory errors. In Proceedings of the SIGPLAN 96 Conference on Programming Language \nDesign and Implementation, pages 44 53, Philadelphia, PA, May 21 24, 1996. [13] M. F\u00a8ahndrich and R. \nDeLine. Adoption and focus: Practical linear types for imperative programming. In Proceedings of the \nACM SIGPLAN 2002 Conference on Programming Language Design and Implementation, pages 13 24, Berlin, Germany, \nJune 17 19, 2002. [14] J. S. Foster, M. F\u00a8ahndrich, and A. Aiken. A theory of type quali.ers. In Proceedings \nof the ACM SIGPLAN 99 Conference on Programming Language Design and Implementation, pages 192 203, Atlanta, \nGA, May 1 4, 1999. [15] J. S. Foster, T. Terauchi, and A. Aiken. Flow-sensitive type quali.ers. In Proceedings \nof the ACM SIGPLAN 2002 Conference on Programming Language Design and Implementation, pages 1 12, Berlin, \nGermany, June 17 19, 2002. [16] J. D. Gannon. An experimental evaluation of data type conventions. Commun. \nACM, 20(8):584 595, Aug. 1977. [17] J. Gosling, B. Joy, G. Steele, and G. Bracha. The Java Language Speci.cation. \nAddison Wesley, Boston, MA, second edition, 2000. [18] G. Kniesel and D. Theisen. JAC access right based \nencapsulation for Java. Software: Practice and Experience, 31(6):555 576, 2001. [19] D. Lea. Personal \ncommunictation, Aug. 1, 2004. [20] X. Leroy. The Objective Caml system, release 3.07, Sept. 29, 2003. \nwith Damien Doligez, Jacques Garrigue, Didier R\u00b4 emy and J\u00b4ome Vouillon. er [21] J. M. Lucassen and D. \nK. Gifford. Polymorphic effect systems. In Proceedings of the Fifteenth Annual ACM Symposium on Principles \nof Programming Languages, pages 47 57, San Diego, CA, Jan. 1988. [22] S. Meyers. Effective C++. Addison-Wesley, \nsecond edition, 1997. [23] R. Milner, M. Tofte, and R. Harper. The De.nition of Standard ML. MIT Press, \n1990. [24] J. H. Morris. Sniggering type checker experiment. Experiment at Xerox PARC, 1978. Personal \ncommunication, May 2004. [25] P. M\u00a8uller and A. Poetzsch-Heffter. Universes: A type system for alias \nand dependency control. Technical Report 279, Fernuniversit\u00a8at Hagen, 2001. [26] F. Nielson and H. R. \nNielson. Type and effect systems. In E. R. Olderog and B. Steffen, editors, Correct System Design, number \n1710 in Lecture Notes in Computer Science, pages 114 136. Springer-Verlag, 1999.  [27] J. Palsberg. \nType-based analysis and applications. In ACM SIGPLAN/SIGSOFT Workshop on Program Analysis for Software \nTools and Engineering (PASTE 01), Snowbird, Utah, USA, June 18 19, 2001. [28] Y. G. Park and B. Goldberg. \nEscape analysis on lists. In Proceedings of the SIGPLAN 92 Conference on Programming Language Design \nand Implementation, pages 116 127, San Francisco, CA, June 17 19, 1992. [29] I. Pechtchanski and V. Sarkar. \nImmutability speci.cation and its applications. In Joint ACM-ISCOPE Java Grande Conference, pages 202 \n211, Seattle, WA, Nov. 3 5, 2002. [30] S. Porat, M. Biberstein, L. Koved, and B. Mendelson. Automatic \ndetection of immutable .elds in Java. In CASCON, Mississauga, Ontario, Canada, Nov. 13 16, 2000. [31] \nL. Prechelt and W. F. Tichy. A controlled experiment to assess the bene.ts of procedure argument type \nchecking. IEEE Transactions on Software Engineering, 24(4):302 312, Apr. 1998. [32] A. Salcianu and M. \nRinard. Pointer and escape analysis for multithreaded programs. In Proceedings of the 8th ACM SIGPLAN \nSymposium on Principles and Practice of Parallel Programming, pages 12 23, Snowbird, Utah, June 18 20 \n2001. [33] M. Skoglund and T. Wrigstad. A mode system for read-only references in Java. In 3rd Workshop \non Formal Techniques for Java Programs, Budapest, Hungary, June 18, 2001. Revised. [34] R. E. Strom and \nS. Yemini. Typestate: A programming language concept for enhancing software reliability. IEEE Transactions \non Software Engineering, SE-12(1):157 171, Jan. 1986. [35] B. Stroustrup. The C++ Programming Language. \nAddison-Wesley, Boston, MA, special edition, 2000. [36] J.-P. Talpin and P. Jouvelot. The type and effect \ndiscipline. In Proceedings of the Seventh Annual IEEE Symposium on Logic in Computer Science, pages 162 \n173, Santa Cruz, CA, June 22 25 1992. [37] P. Wadler. Linear types can change the world! In IFIP TC 2 \nWorking Conference on Programming Concepts and Methods, pages 347 359, Sea of Galilee, Israel, Apr. 1990. \n \n\t\t\t", "proc_id": "1028976", "abstract": "<p>This paper describes a type system that is capable of expressing and enforcing immutability constraints. The specific constraint expressed is that the abstract state of the object to which an immutable reference refers cannot be modified using that reference. The abstract state is (part of) the transitively reachable state: that is, the state of the object and all state reachable from it by following references. The type system permits explicitly excluding fields or objects from the abstract state of an object. For a statically type-safe language, the type system guarantees reference immutability. If the language is extended with immutability downcasts, then run-time checks enforce the reference immutability constraints.</p> <p>In order to better understand the usability and efficacy of the type system, we have implemented an extension to Java, called Javari, that includes all the features of our type system. Javari is interoperable with Java and existing JVMs. It can be viewed as a proposal for the semantics of the Java const keyword, though Javari's syntax uses readonly instead. This paper describes the design and implementation of Javari, including the type-checking rules for the language. This paper also discusses experience with 160,000 lines of Javari code. Javari was easy to use and provided a number of benefits, including detecting errors in well-tested code.</p>", "authors": [{"name": "Adrian Birka", "author_profile_id": "81100429226", "affiliation": "MIT Computer Science and Artificial Intelligence Lab, Cambridge, MA", "person_id": "P698411", "email_address": "", "orcid_id": ""}, {"name": "Michael D. Ernst", "author_profile_id": "81100204056", "affiliation": "MIT Computer Science and Artificial Intelligence Lab, Cambridge, MA", "person_id": "PP14080528", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1028976.1028980", "year": "2004", "article_id": "1028980", "conference": "OOPSLA", "title": "A practical type system and language for reference immutability", "url": "http://dl.acm.org/citation.cfm?id=1028980"}