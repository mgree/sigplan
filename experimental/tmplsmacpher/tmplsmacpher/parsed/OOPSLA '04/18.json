{"article_publication_date": "10-01-2004", "fulltext": "\n Recovering Binary Class Relationships: Putting Icing on the UML Cake * Yann-Ga\u00a8el Gu\u00b4eh\u00b4eneuc Herv\u00b4e \nAlbin-Amiot Universite de Montreal Ecole des Mines de Nantes \u00b4 Montr\u00b4ebec, Canada \u00b4\u00b4 eal, Qu\u00b4Nantes, \nFrance guehene@iro.umontreal.ca albin@emn.fr ABSTRACT A discontinuity exists between object-oriented \nmodeling and programming languages. This discontinuity arises from am\u00adbiguous concepts in modeling languages \nand a lack of cor\u00adresponding concepts in programming languages. It is par\u00adticularly acute for binary \nclass relationships association, aggregation, and composition. It hinders the traceability between software \nimplementation and design, thus hamper\u00ading software analysis. We propose consensual de.nitions of the \nbinary class relationships with four minimal properties exclusivity, invocation site, lifetime, and multiplicity. \nWe describe algorithms to detect automatically these proper\u00adties in source code and apply these on several \nframeworks. Thus, we bridge the gap between implementation and design for the binary class relationships, \neasing software analysis. Categories and Subject Descriptors D.1.5 [Programming techniques]: Object-oriented \npro\u00adgramming; D.2.1 [Software engineering]: Requirements and or speci.cations Languages; D.2.7 [Software \nengi\u00adneering]: Distribution, maintenance, and enhancement Restructuring, reverse engineering, and reengineering; \n General Terms Design, standardisation, languages, theory.  Keywords Design implementation discontinuity, \nbinary class relation\u00adships, consensual de.nitions, formalisations, minimal prop\u00aderties, detection algorithms, \nUML, Java. * This work has been partly funded by IBM OTI Labs 2670 Queensview Drive Ottawa, Ontario, \nK2B 8K1 Canada. This work is partly funded by Soft-Maint 4, rue du Chateau de l \u00b4 ere 44 324 Nantes \n France. Eraudi` Permission to make digital or hard copies of all or part of this work for personal or \nclassroom use is granted without fee provided that copies are not made or distributed for pro.t or commercial \nadvantage and that copies bear this notice and the full citation on the .rst page. To copy otherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. OOPSLA 04, Oct. 24-28, 2004, Vancouver, British Columbia, Canada. Copyright 2004 ACM 1-58113-831-8/04/0010 \n...$5.00. 1. INTRODUCTION Design models, such as class diagrams, describe the ar\u00adchitecture of programs \nat a higher level of abstraction than source code. These models are an invaluable help for soft\u00adware \nengineers both developers and maintainers to anal\u00adyse programs architectures, design choices, behaviours, \nand implementations. However, design models produced during the design phase are often forgotten during \nthe implementation phase under time pressure usually and thus present major discrepancies with their \nactual implementation frequently. Such divergent models are of little help to software engineers who \nmust un\u00adderstand or analyse a program during its development and after its release. A recurrent problem \nin the object-oriented software (re)engineering community is the automated recov\u00adery of design models \nfrom a program implementation. Modeling and programming languages possess similar con\u00adcepts with similar \nsemantics, such as class and inheritance, guaranteeing a continuity between implementation and de\u00adsign. \nHowever, modeling languages aspire to provide higher\u00adlevel abstractions and thus include concepts absent \nfrom programming languages, in particular binary class relation\u00adships. The very existence of binary class \nrelationships in modeling languages brings a discontinuity in the transition between implementation and \ndesign. This discontinuity hinders the understanding of a pro\u00adgram implementation, limits the capabilities \nand e.ciency of automated reverse engineering tools, and impedes the communication among software engineers. \nDe.nitions of binary class relationships proposed by modeling languages should answer the problem of \ndiscontinuity. However, most de.nitions present ambiguities, as stated for example by Henderson-Sellers \nand Barbier [26], and o.er no operational semantics, i.e., no implementation choices [11, 23]. It is \nessential to bridge the gap between programming and mod\u00adeling languages for binary class relationships \nto build sound foundations for understanding, round-tripping [9, page 517], design pattern identi.cation. \n. . A .rst solution to bridge the gap is to design a new pro\u00adgramming language (or an extension to an \nexisting one) in\u00adcluding binary class relationships, for examples [16, 24, 30]. However, this solution \nuses a non-standard programming language and thus eliminates the bene.ts of standardisation (debuggers, \ndevelopment environments, e.cient compilers). A second solution is to de.ne binary class relationships \nat implementation level, in terms of constructs of an existing programming language. This solution relies \non de.nitions of the binary class relationships at design and implementa\u00adtion levels and on detection \nalgorithms, which bring conti\u00adnuity between implementation and design. We apply this second solution \nto the Java programming language with a pragmatic study of UML association, aggregation, and com\u00adposition \nrelationships. In section 2, we detail the problem and summarise previ\u00adous work. In section 3, we propose \nconsensual de.nitions of the binary class relationships and discuss their properties at implementation \nlevel. In section 4, we focus on four common properties: Exclusivity, invocation site, lifetime, and \nmulti\u00adplicity. In section 5, we formalise the de.nitions with the properties and show that the properties \nform a minimal set. In section 6, we propose algorithms to detect binary class relationships using their \nproperties. These algorithms bring continuity between programming and modeling languages. In sections \n7, we introduce and validate implementations of our algorithms on several frameworks. In section 8, we \nconclude and present future work. 2. QUESTION AND PREVIOUS ANSWERS We study de.nitions of binary class \nrelationships at de\u00adsign and implementation levels to bridge the gap between implementation and design. \nWe consider only unidirectional association, aggregation, and composition relationships be\u00adcause these \nrelationships exist in common modeling lan\u00adguages, such as the UML, but are not explicit in standard \nprogramming languages, such as Java. Moreover, bidirec\u00adtional relationships may be expressed as two unidirectional \nrelationships, as we further discuss in section 5.4, after the formalisations of the relationships. The \nUML class diagram in Figure 1(a) de.nes three classes A, B,and C, an inheritance relationship from B \nto A,and an aggregation relationship between B and C. Figure 1(b) shows Java source code corresponding \nto the classes A, B,and C. While we can identify easily the inheritance relationship in Java (extends \nkeyword), how would the aggregation rela\u00adtionship between class B and class C be expressed? As a .eld? \nAs a collection? How would the implementation re\u00ad.ect an aggregation or a composition relationship? More \ngenerally: How to de.ne binary class relationships so we can detect them in implementation? public class \nA { } public class B extends A { ... }public class C {} (a) A UML class di- (b) Possible implementation \nagram for the UML class diagram in Figure 1(a). Figure 1: Illustration of the question. A lot of work \nexists on binary class relationships. How\u00adever, none of this work tackles the discontinuity between implementation \nand design and answers the previous ques\u00adtion. We only present here four lines of work typifying main\u00adstream \nresearches on binary class relationships. We further detail work related to de.nitions of binary class \nrelation\u00adships when discussing their formalisations in section 5. The interested reader may report to \na previous work [21] for a more complete depiction of the state of the art. Some researchers studied \nbinary class relationships with\u00adout linking their results to implementation-level constructs, such as \n[10, 11, 14, 25, 26, 34]. For example, in their survey of the UML relationships [26], Henderson-Sellers \nand Bar\u00adbier proposed a set of characteristics for whole part relation\u00adships. They showed that de.nitions \nof the aggregation and composition relationships are incomplete, overlapping, and contradictory, and \nproposed revised de.nitions. However, they did not link their de.nitions with implementation. Other researchers \nformalised object-oriented programming languages without focusing on implementation issues [1, 4, 10, \n32]. For example, Abadi and Cardelli create a simple model that is .exible enough to represent more complex \nno\u00adtions [of object classi.cation and inheritance], but that does not directly embody any particular \none [1, page 51]. They developed a type calculus for object-oriented programming languages, focusing \non objects, classes, inheritance, and del\u00adegation. They did not consider more complex relationships. \nYet, some other researchers only considered subsets of the binary class relationships and of their de.nitions \nat im\u00adplementation level, such as [12, 27, 29, 31]. For exam\u00adple, Jackson and Waingold developed a tool, \nWomble,for lightweight extraction of object-models from Java byte-codes [27]. They proposed algorithms \nfor detecting association re\u00adlationships between classes and heuristics to infer their mul\u00adtiplicity \nand mutability properties and to deal with container classes. The authors limited their research to the \nassociation relationship: They only mentioned aggregation relationships and did not discuss detection \nof composition relationships. Currently, industrial and open-source CASE tools, such as Rational Rose \nand ArgoUML, do not clearly de.ne binary class relationships. They distinguish graphically the associ\u00adation, \naggregation, and composition relationships, but their reverse engineering algorithms produce erroneous \nor incon\u00adsistent relationships. For example, the UML diagram in Figure 2(a) represents two classes Example1 \nand A that an aggregation relationship links together. We could implement this diagram with the source \ncode in Figure 2(b). If we reverse-engineer with Rose v2002.05.00 the source code in Figure 2(b), the \noriginal aggregation relationship is not detected. The class diagram recovered from the source code displays \nan association relationship between classes Example1 and A, as shown in Figure 3. We could replace the \narray by a collection from the Java collection hierarchy, for example the List interface and its ArrayList \nimplementation, as in Figure 4(a). Figure 4(b) shows the class diagram recovered using Rose for the alter\u00adnate \nimplementation. The aggregation relationship still does not exist, an associ\u00adation relationship links \nthe Example2 class and the collection class, which is inconsistent with the expected class diagram. An \nimplementation detail the use of a collection erro\u00adneously changes the class diagram representing the \nprogram design because of the lack of continuity between implemen\u00adtation and design for binary class \nrelationships. (a) UML class diagram. public class Example1 {private A[] listOfAs = new A[10]; private \nint numberOfAs =0; public void addA(.nal Aa) { // Complete implementation not shown here. this.listOfAs[numberOfAs++] \n= a; } public AgetA(.nal int index) { return this.listOfAs[index]; } public void removeA(.nal Aa) { \n // Complete implementation not shown here. } public static void main(.nal String[ ] args) {.nal Example1 \nexample1 = new Example1(); example1.addA(new A()); // ... }} (b) Implementation of the diagram in Figure \n2(a). Figure 2: A simple case study. Figure 3: Class diagram recovered from the source code in Figure \n2(b) using Rational ROSE. Thus, to our best knowledge, previous work focused on di.erent problems related \nto binary class relationships: Def\u00adinitions and properties at design level, formalisations and detections \nof a subset of the relationships. We build on this work and further study the association, aggregation, \nand composition relationships to bridge the gap between imple\u00admentation and design. 3. DEFINITIONS OF \nTHE BINARY CLASS RELATIONSHIPS We propose de.nitions of the association, aggregation, and composition \nrelationships at design and implementation level. We advocate that these de.nitions are as consensual \nas possible with the literature. Our approach requires that one accepts our de.nitions, however, beyond \nthe de.nitions, our approach shows that it is possible to bridge software im\u00adplementation and design. \npublic class Example2 {private List listOfAs = new ArrayList(); public void addA(.nal Aa) { this.listOfAs.add(a); \n } public AgetA(.nal int index) { return (A) this.listOfAs.get(index); } public void removeA(.nal Aa) \n{ this.listOfAs.remove(a); } public static void main(.nal String[] args) {.nal Example2 example2 = new \nExample2(); example2.addA(new A()); // ... }} (a) Alternate implementation of the case study. (b) Class \ndiagram recovered from the source code in Figure 4(a) using Ratio\u00adnal Rose. Figure 4: Other implementation \nof the case study. 3.1 Association Relationship At design level, anassociationrelationshipisaconcep\u00adtual \nlink between two classes. Each class can have multiple instances involved in the relationship. At implementation \nlevel, most authors agree that an as\u00adsociation relationship involves instances of two classes, an origin \nand a target. An association relationship is oriented, irre.exive, anti-symmetric at instance and class \nlevel, and asymmetric at instance level [26]. Thus, we propose that an association relationship between \nclasses A and B be the ability of an instance of A to send a message to an instance of B. Nothing prevents \nother relation\u00adships to link classes A and B: An association, an aggregation, or a composition relationship \nmay exist between A and B (as well as between B and A). The following source code represents two classes \nA and B linked by an association relationship, through the void ope\u00adration1(B) method. public class AssociationExample1 \n{ public static void main(String[] args) { Aa = new A(); Bb = new B(); a.operation1(b); b.operation2(); \n... } } public class A { public void operation1(Bb) { b.operation2(); }} public class B { public void \noperation2() { } } An alternate implementation of the association relation\u00adship between classes A and \nB could use a declaration of a local variable in a method of class A, for example: void operation3() \n{ BanotherB = new B(); anotherB.operation2(); } 3.2 Aggregation Relationship At design level, an aggregation \nrelationship is an associa\u00adtion between two classes, respectively whole and part. At implementation level, \nwe say that an aggregation rela\u00adtionship exists between classes A and B when the de.nition of A, the \nwhole, contains instances of B,its part. The whole must de.ne a .eld ( simple , array, or collec\u00adtion) \nof the type of its part. Instances of the whole send messages to instances of its part. Subclasses inherit \naggre\u00adgation relationships, because subclasses inherit the structure and behaviour of their superclasses, \nwith respect to access\u00adcontrol limitations [5]. The following source code represents two classes A and \nB linked by an aggregation relationship. The aggregation re\u00adlationship exists through the .eld Bb and \nthe void opera\u00adtion1() method body. public class AggregationExample1 { public static void main(String[] \nargs) { Bb = new B(); Aa = new A(b); a.operation1(); b.operation2(); ... }} public class A { private \nBb; public A(Bb) { this.b = b; } public void operation1() { this.b.operation2(); }} public class B { \npublic void operation2() { } } The aggregation relationship could be implemented also using a collection \nof instances of class B, for example: private List listOfBs; public void operation3() { ((B) listOfBs.get(0)).operation2(); \n} 3.3 Composition Relationship At design level, a composition relationship is an aggrega\u00adtion relationship \nwhich parts are destroyed when the whole is destroyed. Parts might be instantiated before the whole is \ninstantiated and they can be exchanged during the lifetime of the whole. All parts owned by a whole at \nthe moment of its destruction are also destroyed. At implementation level, we de.ne a composition rela\u00adtionship \nas an aggregation relationship with a constraint between the lifetimes of the whole and of its part and \na constraint on the ownership of the part by the whole. In\u00adstances of the whole own the instances of \nits part. Instances of the part might be instantiated before the whole is instan\u00adtiated, but they must \nnot belong to any other whole. They are exclusive to the instance of the whole. The de.nition of the \ncomposition relationship allows only an association relationship between part and whole, to ensure the \nlifetime and ownership properties between whole and part. The following code represents two classes A \nand B linked by a composition relationship. The composition relationship exists through the private .eld \nBb,the void operation1() method, and the Java virtual machine garbage-collector. The instance of class \nB is garbage-collected1 along with the instance of class A. The privateness of .eld Bb and the ab\u00adsence \nof methods returning a reference on this .eld partici\u00adpate in the lifetime dependency and in the exclusive \nowner\u00adship between instances of A and B. public class CompositionExample1 { public static void main(String[] \nargs) { Aa = new A(); a.operation1(); ... }} public class A { private Bb = new B(); public void operation1() \n{ this.b.operation2(); }} public class B { public void operation2() { } } As with an aggregation relationship, \nthe composition re\u00adlationship could be implemented using a collection also. 3.4 Discussion of the De.nitions \nThe de.nitions at implementation level of the binary class relationships use four language-independent \nproperties, sub\u00adset of all existing properties of the relationships. Association and aggregation relationships \nallow multiple instances of A and B to take part in the relationships, while the composition relationship \nallows multiple instances of B to be in a rela\u00adtionship with one instance of A at a time. In an aggregation \nrelationship, instances of A access instances of B through a particular invocation site: A .eld. In a \ncomposition rela\u00adtionship, instances of B are exclusive to their corresponding instances of A and instances \nof A and B have related lifetimes. 1Garbage-collection of instances of class B happens actually before \nor after the garbage-collection of instances of class A.  4. PROPERTIES OF THE BINARY CLASS RELATIONSHIPS \nWe detail and discuss now the four properties of the binary class relationships at implementation level. \n4.1 Exclusivity Property An instance of class B involved at a given time in a re\u00adlationship with an instance \nof class A can, or cannot, be in another relationship at the same time. We name B the set {true, false}. \nWe de.ne the exclusivity property as: EX : Class \u00d7Class .B Given A and B, two classes: EX(A, B) .{true, \nfalse}. Value true states that an instance of class B can take part in another relationship with another \ninstance of class A or of another class. Value false indicates that it cannot. The exclusivity property \nonly holds at a given time and it does not prevent possible transferals. For example, in a Country Language \nrelationship, a Lan\u00adguage may be part of more than one Country: EX(Country, Language)= false.Ina Computer \nKeyboard relationship, a Keyboard is part of one and only one Computer at a given time: EX(Computer, \nKeyboard)= true. 4.2 Invocation-Site Property Instances of class A, involved in a relationship, send \nmes\u00adsages to instances of class B.Wename any the set of all possible invocation sites. any = {field, \narray field, collection field, parameter, array parameter, collection parameter, local variable, local \narray, local collection} We distinguish three levels of invocation sites: Fields, pa\u00adrameters, and local \nvariables. Also, we distinguish simple invocation sites, arrays, and collections because they imply di.erent \nsets of programming idioms for their declarations and for their uses, which we need to individualise \nwhen de\u00adtecting the relationships, as we further discuss in section 6. The set any of invocation sites \nis language-independent and its elements map to source code constructs in class-based programming languages, \nsuch as C++ (whether using point\u00aders or not, as detailed in section 6.4), Java, and Smalltalk. We de.ne \nthe invocation-site property as: IS : Class \u00d7Class .any Given A and B, two classes: IS(A, B) .any. Valuesofthe \nIS property describe the invocation sites for messages sent from instances of class A to instances of \nclass B.There can be no message sent from class A to class B: IS(A, B)=\u00d8, or messages can be sent from \nA through a field (respectively a parameter,a local variable)oftype B,an array field, or a .eld of type \ncollection. For example, in a Figure Line relationship, the Figure propagates draw() messages to its \ncomposing lines using a collection of instances of Line: IS(Figure, Line)= {col\u00adlection field}.A Line \nshould not know its enclosing Figure: IS(Line, Figure) = \u00d8 [8]. If class Figure de\u00adclares a contains(Line[]) \nmethod (to check whether a .g\u00adure encloses a set of lines), then IS(Line, Figure)= {array parameter, \ncollection field}. 4.3 Lifetime Property The lifetime property constrains the lifetimes of all in\u00adstances \nof class B with respect to the lifetimes of all instances of class A. It relates to the di.erence between \nthe times of destruction LTd of two instances of classes A and B [14]. The time is in any convenient \nunit, in seconds, in CPU ticks. LTd : Instance .N In programming languages with garbage collection, LTd \nmatches the moment where an instance is ready to be col\u00adlected for garbage. We infer from LTd a relation \nbetween the lifetimes of all instances of two classes A and B.Wename the set {-, +}. LT : Class \u00d7Class \n.. Given A and B, two classes: LT (A, B) .{-, +}. LT (A, B)= +if all instancesofclass B are destroyed \nbefore the cor\u00adresponding instances of class A, LT (A, B)= - if destroyed after. We shall write LT (A, \nB) .if the times of destruction of instances of classes A and B are unspeci.ed: The property does not \nstate if instances of class B are destroyed before or after instances of class A. For example, in a Window \nButton relationship, when the Window closes and is ready for garbage collection, the Button must also \nbe ready for garbage collection: LT (Window, But\u00adton)=+. 4.4 Multiplicity Property The multiplicity \nproperty speci.es the number of instances of class B allowed in a relationship with class A.Weexpress \nthis property as: MU : Class \u00d7Class .N .{+8} Given A and B, two classes: MU(A, B) .N .{+8}.For the sake \nof simplicity, we use an interval of the minimum and maximum numbers to represent multiplicity. We only \nconsider multiplicity at the target end of a relationship. The interested reader may refer to Jackson \nand Waingold [27] for a discussion on multiplicity at both ends of a relationship. For example, in a \nCell DNACode relationship, a Cell pos\u00adsesses one and only one DNACode: MU(Cell, DNACode)= [1, 1]. Ina \nCar Wheel relationship, a Car usually possesses four Wheels but may have a .fth spare Wheel: MU(Car, \nWheel)= [4, 5]. 4.5 Discussion of the Properties The four properties, which we propose to de.ne binary \nclass relationships, are orthogonal. However, the exclusiv\u00adity and multiplicity properties are closely \nrelated with each other. For example, in the Country Language relationship: The multiplicity property \nstates the number of instan\u00adces of class Language that each instance of the Country class possesses: \nMU(Country, Language)=[1, +8]. (Canada possesses two o.cial languages, English and French, and several \nspoken languages: Inuktitut; Pun\u00adjabi; Portuguese...)  The exclusivity property states if an instance \nof class Language is shared among instances of class Country or of other classes: EX(Country, Language)= \nfalse. (French is spoken in France, in Canada...)  Also, we show that LT (A, B)=+ .LT (B, A)= -, indeed \nLT (A, B)=+ .LTd(A) >LTd(B) .LT (B, A)= -.  5. FORMALISATIONS OF THE BINARY CLASS RELATIONSHIPS We formalise \nthe binary class relationships at implemen\u00adtation level as three conjunctions of the four properties, \nre\u00adspectively AS, AG,and CO. We show examples and dis\u00adcuss characteristics of these formalisations, in \nparticular the minimality of the set of properties. Formalisations of the binary class relationships \nare impor\u00adtant in two respects: First, they provide formal language\u00adindependent de.nitions of the relationships \nfor understand\u00ading and communication among software engineers; Second, they are the basis of the detection \nalgorithms needed to bridge the gap between implementation and design, as pre\u00adsented in section 6. 5.1 \nAssociation Relationship We de.ne an association relationship between classes A and B, AS(A, B), as: \nAS(A, B)= (EX(A, B) .B) . (EX(B,A) .B) . (IS(A, B)= any) . (IS(B, A)=\u00d8) . (LT(A, B) .) . (LT(B, A) .) \n. (MU(A, B)=[0, +8]) . (MU(B, A)=[0, +8]) We forbid message invocation from instances of class B to instances \nof class A because we consider unidirectional rela\u00adtionships only. Bidirectional relationships may be \nexpressed as two unidirectional relationships, as we show in section 5.4. For example, the following \nsource code, incomplete as it is, veri.es the values of the properties of the association rela\u00adtionships. \nThe naming of instances a and b precludes their mutual exclusivity: They can be used later in the main() \nmethod body. Possible uses of instances a and b also sug\u00adgests unrelated lifetimes. public class AssociationExample2 \n{ public static void main(String[] args) { Aa = new A(); // EX(A, B)= EX(B, A) .B // because of the possible \nlater use of a and b. Bb= new B(); // LT(A, B)= LT(B, A) .. a.operation1(b); // MU(A, B)= MU(B, A)=[0, \n+8] b.operation2(); ... // Possible uses of a and b. } } public class A { public void operation1(B b) \n{b.operation2(); // IS(A, B) .any } } public class B { public void operation2() {// IS(B, A)= \u00d8 } } \n 5.2 Aggregation Relationship We de.ne the aggregation relationship between classes A and B, AG(A, B), \nas: AG(A, B)= (EX(A, B) .B) . (EX(B, A) .B) . (IS(A,B) .{field,array field, collection field}) . (IS(B,A) \n= \u00d8) . (LT(A, B) .) . (LT(B, A) .) . (MU(A,B)=[0, +8]) . (MU(B, A)=[1, +8]) The following source code \nillustrates an aggregation rela\u00adtionship between classes A and B. For example, the .eld Bb sets the lower \nbound of MU(A,B) to 1, possibility of other .eld declarations sets the upper bound to +8. public class \nAggregationExample2 { public static void main(String[] args) {Bb = new B(); // EX(A, B) .B Aa= new A(b); \n//EX(B, A) .B a.operation1(); // LT(A, B) .. b.operation2(); // LT(B, A) .. ... // Possible uses and \ncreations of instances of B. } } public class A { private Bb; // MU(A, B)=[1, +8] .[0, +8] public A(B \nb) {this.b = b; // MU(B, A)=[1, 1] .[1, +8] } public void operation1() {this.b.operation2(); // IS(A, \nB)= {field}// .{field, array field, collection field} } ... // Possible declarations and uses of instances \nof B. }public class B {public void operation2() {// IS(B, A)= \u00d8 } }  5.3 Composition Relationship We \nde.ne the composition relationship between classes A and B, CO(A,B), as: CO(A,B)= (EX(A,B)= true) . (EX(B,A)= \nfalse) . (IS(A, B) .{field,array field, collection field}) . (IS(B, A) = \u00d8) . (LT(A, B)=+) . (LT(B, A)= \n-) . (MU(A, B)=[1, +8]) . (MU(B, A)=[1, 1]) The following code represents a composition relationship \nbetween classes A and B. For example, the value of MU(A,B) is [1, 1] because the instance of class B \ncan belong to one and only one instance of class A. public class CompositionExample2 { public static \nvoid main(String[] args) { Aa = new A(); // EX(B, A)= false // because of the possible later creation \n// and use of other instances of A. a.operation1(); // (LT(A, B)=+) .(LT(B, A)= -) ... // Possible uses \nand creations of instances of A. } } public class A { private Bb= new B(); // MU(A, B)=[1, 1] .[1, +8] \npublic void operation1() {// MU(B, A)=[1, 1] this.b.operation2(); // EX(A, B)= true }// IS(A, B)= {field}.{field, \narray field, // collection field} }public class B {public void operation2() {// IS(B, A)= \u00d8 } }  5.4 \nDiscussion of the Formalisations Interesting characteristics of the binary class relationships stem from \ntheir formalisations: Minimality of the set of properties; Order among the relationships; Decomposition \nof the relationships in static and dynamic parts. Also, our formalisations support common usages of binary \nclass re\u00adlationships: Acquaintance and optimisations; Aggregation and shared aggregation; Navigability; \nQuali.cation; Sym\u00admetrical relationships and backpointers. Minimality of the Set of Properties. The four \nproper\u00adties form a subset of all properties proposed in the litera\u00adture, for examples in [14, 26]. We \nprove that this subset P= {EX,IS, LT,MU}is minimal with respect to our for\u00admalisations and to other de.nitions \nin two steps. First, we show that this subset is minimal with respect to our formalisations: If we remove \nany property from P,then some of our formalisations are undistinguishable. Let us assume a composition \nrelationship CO(A, B)be\u00adtween classes A and B.Ifweremovethe EX property from P, then we can no longer \ndistinguish CO(A, B) from an ag\u00adgregation relationship, AG(A, B). Indeed, the values of the properties \nfor CO(A,B)minus EX satisfy the values of the properties for AG(A, B): (IS(A, B) .{...})CO =(IS(A, B) \n.{...})AG (IS(B, A)=\u00d8)CO =(IS(B, A)=\u00d8)AG (LT(A, B)=+)CO . (LT(A, B) .)AG (LT(B, A)= -)CO . (LT(B, A) \n.)AG (MU(A, B)=[1,+8])CO . (MU(A, B)=[0, +8])AG (MU(B, A)=[1, 1])CO . (MU(B, A)=[1, +8])AG Now, let us \nassume an aggregation relationship AG(A, B) between classes A and B.Ifweremovethe IS property from P, \nthen we can no longer distinguish AG(A, B) from an as\u00adsociation relationship, AS(A, B). Indeed, the values \nof the properties for AG(A, B)minus IS satisfy the values of the properties for AS(A, B): (EX(A, B) .B)AG \n=(EX(A, B) .B)AS (EX(B, A) .B)AG =(EX(B, A) .B)AS (LT(A, B) .)AG =(LT(A,B) .)AS (LT(B, A) .)AG =(LT(B,A) \n.)AS (MU(A, B)=[0, +8])AG =(MU(A, B)=[0, +8])AS (MU(B, A)=[1, +8])AG . (MU(B, A)=[0, +8])AS Likewise, \nlet us assume a composition relationship be\u00adtween classes A and B,CO(A, B). If we remove the LT prop\u00aderty \nfrom P, then we can no longer distinguish CO(A, B) from an aggregation relationship, AG(A, B). The values \nof the IS and MU properties for CO(A, B) satisfy the values of these properties for AG(A, B), as do the \nvalues of the EX property: (EX(A, B)= true)CO . (EX(A, B) .B)AG (EX(B, A)= false)CO . (EX(B, A) .B)AG \nFinally, let us assume an aggregation relationship AG(A,B) between classes A and B.Ifweremovethe MU property \nfrom P, then we can no longer distinguish AG(A, B) from an asso\u00adciation relationship, AS(A, B). Thevaluesofthe \nEX and LT properties for AG(A, B) satisfy the values of these properties for AS(A,B), as do the values \nof the IS property: (IS(A, B) .{...})AG . (IS(A, B)= any)AS (IS(B, A)=\u00d8)AG =(IS(B, A)=\u00d8)AS Thus, the \nfour properties in P are all required to distin\u00adguish our formalisations of the association, aggregation, \nand composition relationships: P forms a minimal subset of all properties of binary class relationships \nwith respect to our de.nitions. We explain why the association and aggregation relationships are distinguished \nby the IS and MU proper\u00adties and the aggregation and composition relationships by the EX and LT properties \nin a following discussion on the static and dynamic parts of the relationships. Second, we show that \nall properties in Pappear in all def\u00adinitions of binary class relationships in the literature. How\u00adever, \nfor lack of space, we cannot detail all de.nitions of bi\u00adnary class relationships in the literature. \nIndeed, we found in a previous survey 26 de.nitions distributed in 5 cate\u00adgories [21]. Thus, we only \npresent one example per category: De.nitions in natural languages: 5 de.nitions. For example, de.nitions \nof the association and aggrega\u00adtion relationships in the precursor book by Rumbaugh et al. [33, sections \n3.2, 4.1, and 15.6] states that: It is sometimes necessary to check whether a part al\u00adready belongs to \na whole, which relates to exclusivity, and the multiplicity of instances of classes involved; Some operations \nof a whole apply to its part, using at\u00adtributes containing pointers to the part, which relates to invocation \nsite.The lifetime property is not ex\u00adplicitly mentioned, but memory management object deletion, dangling \npointer, memory leak is cited as concern for implementation of the relationships.  Formal de.nitions: \n5 de.nitions. For example, inter\u00adpretation of association relationships in the Syntropy methodology [7] \nexplicitly mentions cardinality con\u00adstraints, related to multiplicity and lifetime,aswellas lifetime \nconstraints, related to exclusivity. Also, data encapsulation (value attribute or reference attribute) \nis described as a mean to implement association and aggregation relationships, which relates to invocation \nsite, although the formalisation interprets the asso\u00adciation without any knowledge of the structure of \nthe object it associates [7, page 8].  De.nitions with properties: 5 de.nitions. For exam\u00adple, de.nitions \nof the aggregation and composition re\u00adlationships by Henderson-Sellers and Barbier [26, ta\u00adble 4, page \n356] use several characteristics, such as: C1. Propagation of one or more operations and C5. Propagation \nof destruction operation, related to invo\u00adcation site and lifetime; C2. Ownership, related to exclusivity; \nP1. Whole part, related to multiplicity.  De.nitions embodied in programming languages: 3 de.nitions. \nFor example, in the Troll programming language [24], de.nitions of static aggregations, dy\u00adnamic aggregations, \nand disjointed aggregations dis\u00adtinguish two kinds of complex objects: Non-disjoint  and disjoint, which \nrelates to exclusivity. Complex ob\u00adjects may belong to one or several aggregations, which relates to \nmultiplicity. They possess attribute values which they alter by local events (events are abstrac\u00adtions \nof methods), related to invocation site.They have explicit life cycles, which relates to lifetime. De.nitions \nat the implementation level: 8 de.nitions. For example, in the tool Womble [27] for lightweight extraction \nof object-models from Java byte-codes, an association relationship may be annotated to show its multiplicity \nand its mutability, which relates to ex\u00adclusivity. Heuristics infer multiplicity and mutability properties \nand deal with container classes, which re\u00adlate to invocation site. However, the tool does not distinguish \naggregation from association relationships and does not consider composition relationships, al\u00adthough \nthe authors mention that lifetime-dependency inference would be required. Thus, with the two previous \nsteps, we show that P is a minimal subset of all properties of binary class relationships. Order among \nthe Binary Class Relationships. The for\u00admalisations of the relationships with their properties show that \nan order exists among the association, aggregation, and composition relationships. The values of the \naggregation re\u00adlationship properties are more constraining than those of the association relationship: \nAG(A, B)= AS(A, B) . (IS(A, B)= {field,array field, collection field}) . (MU(B, A) = [1, +8]) The values \nof the composition relationship properties are more constraining than those of the aggregation relation\u00adship. \nIn particular, the exclusivity property is stronger for the part in a composition relationship than in \nan aggrega\u00adtion relationship, because, in a composition relationship, the part must not belong to any \nother aggregation or composi\u00adtion relationship: CO(A, B)= AG(A, B) . (EX(A, B)= true) . (EX(B, A)= false) \n. (LT(A, B)=+) . (LT(B, A)= -) . (MU(A, B)=[1, +8]) . (MU(B, A)=[1,1]) Static and Dynamic Parts. The \nformalisations of the bi\u00adnary class relationships decompose in two fundamental parts: A static part corresponding \nto the MU and IS properties; A dynamic part corresponding to the EX and LT proper\u00adties. Association and \naggregation relationships are inher\u00adently static, thus their static parts are important for their distinction \nand their detection. A composition relationship is an aggregation relationship with additional constraints \non the behaviour of composed instances, thus its dynamic parts are important for its distinction from \nan aggregation relationship and its detection. Acquaintance and Optimisation. For optimisation pur\u00adposes, \na class A associated with a class B may declare a .eld of type B to record a particular instance of B. \nAccording to our de.nitions, the relationship between A and B then evolves from an association to an \naggregation relationship. This is not a problem because we aim at bringing continu\u00adity between design \nand implementation. We try to expose consistently, not to interpret, software engineers intent. For example, \nsoftware designers speci.ed an association relationship between classes Person and Course. Software engineers \nimplemented this association relationship by de\u00adclaring a .eld of type Course in class Person.If the \nrecov\u00adered relationship is an aggregation relationship, it provides important data to software maintainers: \nFirst, maintainers know that an aggregation relationship actually exists be\u00adtween classes Person and \nCourse; Second, maintainers may act about the discrepancy between the actual implementa\u00adtion and the \ndesired design as appropriate. Composition and Shared Composition. We only consider non-shared composition \nrelationships. The multiplicity of the part for the composition relationship, MU(B, A)=[1,1], prevents \na part to belong to more than one whole. This mul\u00adtiplicity ensures the lifetime property of a part with \nrespect to its whole for the composition relationship and consistency between the de.nitions of the aggregation \nand composition relationships. Navigability. In the UML notation, navigability is spec\u00adi.ed with arrows \non association ends (respectively aggre\u00adgation and composition ends). We choose to study only unidirectional \nrelationships because: A bidirectional relationship can be expressed as two opposite unidirectional relationships \nwith constraints between them [28], if appropriate. For example, we could express the UML class diagram \nin Figure (a) using the class diagram in Figure (b). (In the UML notation, no arrow is displayed when \na relationship is bidirectional.) (a) Bidirectional aggrega\u00adtion relationship (b) Unidirectional aggrega\u00adtion \nand association rela\u00adtionships  In standard programming languages, bidirectional re\u00adlationships are \nactually implemented as two opposite unidirectional relationships. Thus, we think that it is adequate \nto express bidirec\u00adtional relationships as two opposite unidirectional relation\u00adships. Software engineers \nmay decide to fusion semantically\u00adrelated opposite unidirectional relationships at design level after \nreverse-engineering. Quali.cation. We do not qualify the formalisations of the relationships with labels \nidentifying the particular relation\u00adships being speci.ed. Indeed, the formalisations de.ne the association, \naggregation, and composition relationships and are characteristics that particular relationships may \nhave. For example, there may exist two associations relation\u00adships, teaches and takes, between the classes \nPerson and Course. We would say that: teaches veri.es AS(Person,Course) takes veri.es AS(Person,Course) \nSymmetrical Relationships and Backpointers. The pres\u00adence of a binary class relationship between classes \nA and B does not preclude the existence of other relationships. Thus, relationships between classes A \nand B may induce a cycle. Typically, there is a cycle when a backpointer records the owner of an instance \nor when two classes possess .elds of each other s type. In such cases, two symmetrical aggrega\u00adtion relationships \nwould exist: AG(A,B)and AG(B,A).  6. DETECTION ALGORITHMS FOR THE BINARY CLASS RELATIONSHIPS We bring \ncontinuity between implementation and design by de.ning detection algorithms for the previous proper\u00adties \nand formalisations of the binary class relationships. We introduce algorithms to compute the values of \nthe four prop\u00aderties that we use to infer the existence of association, aggre\u00adgation, and composition \nrelationships in Java source code. For the sake of brevity, we describe the principles of the algorithms \nonly, the interested reader may refer to previ\u00adous work for detailed explanations on static and dynamic \nanalyses for Java [21, 22]. The algorithms are independent of the target programming language, because \nthey rely on language-independent properties only. However, the algo\u00adrithms take advantage of language-dependent \nprogramming idioms as we show for the Java programming language. 6.1 Principles of the Detection Algorithms \nDetection of association relationships requires collecting the value of the IS property only. Detection \nof aggregation relationships requires inferring the values of the IS and MU properties. Detection of \ncomposition relationships requires collecting the value of the IS and MU properties and of the EX and \nLT properties. We collect values of the invocation site, IS, and multiplicity, MU, properties using static \nanal\u00adyses. We infer values of the exclusivity, EX, and lifetime, LT, properties using dynamic analyses. \n 6.2 Association, Aggregation Relationships We use static analyses to compute values of the static part \nthe MU and IS properties of the association and aggregation relationships. The Java programming language \nuses an intermediate language made of byte-codes. We per\u00adform static analyses on this intermediate language, \nusing a byte-code analysis framework: IBM CFParse v1.21. We choose to work with the intermediate language \nbecause class .les are always available, while source code may be unavail\u00adable when proprietary [35]. \nComputation of IS. We iterate through the byte-codes of each class, looking for byte-codes corresponding \nto method invocations: InvokeInterface, InvokeStatic, InvokeSpe\u00adcial,and InvokeVirtual. Then, depending \non invocation sites (field, array field, collection field, parameter, array parameter, collection parameter, \nlocal variable, local array, local collection), we assign values to the IS property and identify the \ntarget of the relationships. A di.culty arises when invocation sites are collections, collection field, \ncollection parameter, local collec\u00adtion, because collections are typically un-typed. If we as\u00adsume that \nthese kinds of collections are homogeneous (con\u00adtaining instances with a common superclass di.erent from \nObject), it is possible to determine their types using well\u00adknown Java programming idioms, such as pairs \nof add() remove() accessors [27]. Also, the algorithm are parameterised speci.cally to recog\u00adnise user-de.ned \ncollections in addition to collections from the standard Java class libraries, such as Map, List,and \nSet and their implementations. Computation of MU. Detection of the values of the MU property uses invocation \nsites also: We assign value [0,1] to the MU property if the invocation site is field, parameter, local \nvariable,value [0,+8] if the invocation site is array field, array parameter, local array, collection \nfield, collection parameter,or local collection. 6.3 Composition Relationships The dynamic part the \nEX and LT properties of the composition relationship is di.cult to detect. We propose a solution using \na trace-analysis technique [22]. A composi\u00adtion relationship is an aggregation relationship with speci.c \nvalues for the exclusivity and lifetime properties. Thus, we use the trace-analysis technique to compute, \nfor each ag\u00adgregation relationship, values of the exclusivity and lifetime properties and, if the values \nmatch, to change it to a com\u00adposition relationship. Model. We model a program execution as a trace: A \nse\u00adquence of execution events. There are three kinds of events, represented as Prolog terms: Assignment \nevents emitted ev\u00adery time a .eld of an instance of class A is assigned with an instance of class B; \nFinalise events emitted when the Java virtual machine garbage-collects an instance2;A program\u00adend event \nthat is emitted when the program terminates. We generate and analyse on the .y the trace of a program \nexe\u00adcution using Prolog predicates. Then, we infer the existence of composition relationships from computed \nvalues of the exclusivity and lifetime properties. 2 We assume our tool emits a .nalise event as soon \nas an instance becomes ready for garbage collection. Computation of LT . We assess the lifetime property \nof ag\u00adgregation relationships using a Prolog predicate, checkLT\u00adProperty/3 [21]. This predicate builds \na list of terms ab\u00adstracting sequences of events in the execution trace depend\u00ading on the order in which \nassignations, .nalisations, and program-end happen. The checkLTProperty/3 builds and maintains a list \nof pendingAssignation and of lifetime-Property terms: pendingAssignation terms are added to the list \nupon assignation of an instance of class B to a field (re\u00adspectively, array field, collection field)ofanin\u00adstance \nof class A.  pendingAssignation terms are converted into life\u00adtimeProperty terms upon .nalisation of \ninstances of classes A and B if appropriate, i.e., .nalisations of in\u00adstances of class A occur after \n.nalisations of all corre\u00adsponding instances of class B (LTd(A) >LTd(B)).  pendingAssignation terms \nare converted into life\u00adtimeProperty terms when the program terminates.  Computation of EX. Following \nthe same principle, we de\u00ad.ne a predicate to check the exclusivity property of aggre\u00adgation relationships, \ncheckEXProperty/3 [21], which builds and maintains a list of exclusivityProperty terms, accord\u00ading to \nassignations and program-termination events. Finally, the terms in the lists represent values of the \nexclu\u00adsivity and lifetime properties between instances of classes A and B. We infer values of the exclusivity \nand lifetime prop\u00aderties of the two classes by conjunctions (and operator) of the values between their \ncorresponding instances. 6.4 Discussion of the Detection Algorithms The set of invocation sites map \nto Java source code di\u00adrectly. With other programming languages such as C++, it is necessary to adapt \nthe static analyses to handle pointers and structures, for example. However, the set of invocation sites \ndoes not change with di.erent class-based program\u00adming languages, it is language independent. Our detection \nalgorithms su.er from two main limitations which impedes their correctness and completeness. We base \nthe detection of aggregation relationships on static analyses and on heuristics expressing common programming \nidioms, i.e., a collection is generally ac\u00adcess through speci.c accessors, to infer the type of stored \ninstances. However, developers may not have followed the common programming idioms, which leads to a \ndecreased precision of the algorithms, as shown in the following validations, in section 7.1.  We base \nthe detection of composition relationships on dynamic analyses, which have well-known limitations, such \nas code coverage, statistical signi.cance of the runs, and dependency of the overall results on the and \noperator used to combine results from runs. These limitations decrease the precision and usability of \nthe detection algorithms, as shown in section 7.2.  We could replace our heuristics and dynamic analyses \nwith alias analyses but their bene.ts are yet unclear with respect to simplicity and performance of the \nalgorithms.  7. VALIDATIONS OF THE DETECTION ALGORITHMS We have adapted the static analysis algorithms \nfrom our previous tool PatternsBox [3] in Ptidej, a tool to reverse\u00adengineer Java programs, and we implemented \nthe dynamic analysis algorithms using Caffeine [22], a tool for the dy\u00adnamic analysis of Java programs. \nWe have tested our im\u00adplementations on: Java AWT v1.2.2 [37], JHotDraw v5.1 [18], and JUnit v3.7 [17]. \n7.1 Association, Aggregation Relationships The association relationship is the simplest relationship \nto detect and provides an overwhelming number of hits: There are respectively 2, 784+1, 505+636 = 4, \n925 association rela\u00adtionships for the 583 classes of the three frameworks. Thus, aggregation relationships \nare the most informative with re\u00adspect to static analyses. Static analyses of the three frame\u00adworks take \nrespectively 18.66, 7.81, and 7.11 seconds on a Pentium II 600 Mhz. Table 1 shows the results of detection \nof aggregation re\u00adlationships for the di.erent frameworks. It details the num\u00adber: Of classes per framework; \nOf relationships (multiplicity +8) found; Of relationships (multiplicity +8) detected by a manual analysis; \nAnd, of false hits.The results do not include aggregation relationships of multiplicity 1, because detection \nof these relationships is not an issue and would in\u00adaccurately increase the precision3 . Their detection \nrequires only static analyses of classes to .nd simple .elds, such as private B b;, which multiplicity \nand target are obvi\u00adous. Also, the results involve only aggregation relationships that are homogeneous4, \nand that do neither involve prim\u00aditive types, nor wrapper types, nor the String type, nor listeners5 \n. Such homogeneous aggregation relationships are typically described using collection classes implementing \nthe List interface, such as the Vector class. We performed a manual analysis to check the accuracy of \nour algorithms. We do not obtain a precision of 100% because developers of the three frameworks did not \nrespect some of the Java idioms assumed by our detection algo\u00adrithms. Developers implemented add() methods \nwithout the corresponding remove() or get() methods, or pairs of add() remove() methods with di.erent \nargument types. For example, the Component class of Java AWT declares meth\u00adods add(PopupMenu) and remove(MenuComponent) \nto add and to remove popup menus from a component. However, this lack of precision actually helps in \nunder\u00adstanding programs and in identifying potential problems through the enforcement of programming \nstandards. Thus, the absence of aggregation relationship between classes Com\u00adponent and PopupMenu highlights \nthe discrepancy between methods add(PopupMenu) and remove(MenuComponent). 3For example, on JHotDraw v5.1, \nthe precision is 98% for 151 existing aggregation relationships, multiplicity 1 and +8, to compare with \na precision of 75% for 8 existing ag\u00adgregation relationships, multiplicity +8 only. 4We say that an aggregation \nrelationship is homogeneous if it involves instances of classes with a common superclass di.erent from \nObject. 5The detection of aggregation relationships with primitive types, wrappers, String, or listeners \ndoes not provide help\u00adful information to bridge the gap between implementa\u00adtion and design, because primitive \ntypes are not instances of classes while wrappers, String, and listeners are not application-speci.c \nclasses. Aggregation relationships with multiplicity +8 Frameworks Classes Found Manual False hits Java \nAWT v1.2.2 367 17 20 1 JHotDraw v5.1 171 6 8 0 JUnit v3.7 45 1 4 0 Total 583 24 32 1 Precision: 0.75 \n( Found Manual ) Recall: 0.96 ( Found Found+False hits ) Table 1: Results of static analyses for aggregation \nrelationships with multiplicity +8. 7.2 Composition Relationships Table 2 presents the results of detecting \ncomposition rela\u00adtionships in the JUnit v3.7 framework, using dynamic anal\u00adyses on the junit.samples.money.MoneyTest \ntest case with three di.erent user interfaces (UI). We did not perform dy\u00adnamic analyses on the JHotDraw \nv5.1 framework, because it requires user-interaction, nor on the Java AWT v1.2.2 framework because it \nis not runnable. We perform the analyses based on previously found aggre\u00adgation relationships, because \ncomposition relationships are aggregation relationships with stronger dynamic properties. A complete \nanalysis of the program would be too costly in time and would not provide more results. Some aggregation \nrelationships reveal themselves as com\u00adposition relationships upon dynamic analyses of the Money-Test \ntest case with the di.erent UI: Properties of lifetime and of exclusivity hold. We performed a manual \nanalysis to check the accuracy of our dynamic analyses and we obtain a precision of 100% and a recall \nof 100% for the given condi\u00adtions of execution (multiple runs of the MoneyTest test case with the di.erent \nUI). However, the results are subject to caution because they correspond to a subset of all possible \nexecution paths: De\u00adpending on the execution path, the inferred relationships may vary. For example, \nthere is no composition relationship between classes TestSuite and Test [21] with the AWT\u00adbased UI while \nthere is one with the text-based UI. Code coverage analyses [6, 15] are being considered to increase \ncon.dence on the dynamic analyses. 7.3 Discussion of the Validations Quantitative and Qualitative. Preceding \nresults are inter\u00adesting in two respects: Quantitatively, we can compute metrics based on de\u00adtected \nrelationships. These metrics further enhance the understanding that software engineers have of a program \nusing other metrics, such as Chidamber and Kemerer s metrics [13].  Qualitatively, we can assess the \nquality of a design us\u00ading the number of detected relationships, the presence of opposite relationships. \nWe can also compare de\u00adtected relationships and relationships de.ned during design, identify design anomalies, \nhighlight implemen\u00adtation discrepancies and bugs [27].  Practicality. Results of the static analyses \nhave a precision of 75% and a recall of 96%. They show that our algorithms, although neither complete \nnor correct, are good enough in practice to detect aggregation relationships and, by exten\u00adsion, composition \nrelationships correctly. It is possible to take in consideration more Java idioms, however, the cur\u00adrent \nversions of our algorithms represent acceptable compro\u00admises between computation time, complexity, and \nprecision. The dynamic part of the composition relationship is subject to caution because of the limitations \nof dynamic analyses between executions. Also, dynamic analyses are time con\u00adsuming: Our dynamic analysis \ntool, Caffeine, slows down program executions up to a factor of 5,000 [22]. Thus, detec\u00adtion of composition \nrelationships should only be performed to answer speci.c questions from software engineers [36]. Comparisons. \nValidations of our de.nitions and of results from our algorithms against third-party de.nitions and tools \nis a very di.cult task. We would like to apply our algo\u00adrithms on documented frameworks and to compare \nresults with the documentation of these frameworks or analyses of other tools. However, developers mainly \nuse modeling lan\u00adguage with little operational semantics when designing their software, such as the UML, \nand thus do not consider di.er\u00adences among the association, aggregation, and composition relationships. \nAlso, we were unable to .nd a framework both publicly available and of reference in which the de\u00advelopers \nexplicitly distinguished the three binary class rela\u00adtionships. For example, the authors of JHotDraw \nv5.1 use the notation proposed by Gamma et al. [19]. This notation o.ers the association relationship, \ncalled acquaintance rela\u00adtionship, and a generic aggregation relationship, called the part-of relationship. \nThe notation de.nes the implementa\u00adtion of acquaintance and of part-of relationships only loosely and \ndoes not mention the composition relationship. Consequences. Detection of the binary class relationships \nin the Java AWT, JHotDraw,and JUnit frameworks re\u00adduces the gap between implementation and design. Indeed, \nsoftware maintainers have a better understanding of both the inner working and of the design of the frame\u00adworks \nthrough the knowledge of the relationships among classes. They can check desired designs against actual \nimple\u00admentations and identify possible design defects or erroneous relationship implementations. They \ncan also identify design patterns more easily, thus developing their understanding of the frameworks \none step further [2]. Finally, software engineers could use the knowledge of the relationships to translate \nthe frameworks to other class\u00adbased object-oriented programming languages. Indeed, they can translate \nthe relationships among classes from one pro\u00adgramming language to another accurately using their lan\u00adguage-independent \nproperties.  8. CONCLUSION AND FUTURE WORK We tackled the problem of discontinuity between program\u00adming \nand modeling languages in the speci.c case of three bi\u00adnary class relationships: Association, aggregation, \nand com\u00adposition. We answered the question: How to de.ne binary class relationships so we can detect \nthem in implementa\u00adtion? We proposed and formalised de.nitions of the rela\u00adtionships with a minimal set \nof four language-independent properties at implementation level. We presented detection algorithms based \non the properties and sketched their im\u00adplementations. We validated the algorithms on well-known frameworks \nwith respect to our de.nitions. These de.ni\u00adtions and algorithms bring continuity in the transition be\u00adtween \na program implementation and its design. We in\u00adtegrated implementations of our algorithms in two reverse\u00ad \n Composition relationships with multiplicity +8 User interfaces Found Manual False hits Classes in the \nrelationships Text 3 3 0 TestResult TestFailure (\u00d72), TestSuite Test Java AWT 3 3 0 TestResult TestFailure \n(\u00d72), junit.awtui.TestRunner Throwable Java Swing 3 3 0 TestResult TestFailure (\u00d72), junit.swingui.TestRunner \nTestRunView Total 3 3 0 Precision: 1.00 ( Found Manual ) Recall: 1.00 ( Found Found+False hits ) Table \n2: Results of dynamic analyses for composition relationships with multiplicity +8 in the JUNITv3.7 framework \n(MoneyTest class). engineering tools for Java programs, Ptidej and Caffeine. These tools ensure consistent \ncontinuity and traceability be\u00adtween implementation and design, which is a major improve\u00adment over existing \nindustrial and academic software and or reverse engineering tools. Currently, we enhance and use our \nreverse engineering tools to study on .rm foundations the identi.cation of micro\u00adarchitectures similar \nto solutions of design-patterns in Java programs and of detect design defects [2, 20]. We also work on \nimproving static and dynamic analyses for the C++ and Smalltalk programming languages. Future work includes: \n To assess the bene.ts of full-.edge alias analyses and their implementations to improve the detection \nof the relationships.  To implement code coverage analyses to increase the con.dence in the dynamic \nanalyses.  To develop a set of criteria to assess the quality of reverse-engineered class diagrams, \nto compare reverse\u00adengineering tools objectively.  To verify that our de.nitions are really consensual \nwith respect to developers intent when designing software.  To apply our reverse engineering tools, \nPtidej and Caffeine, on real-life programs and to validate their results with the programs developers. \n To apply our approach on other programming lan\u00adguages. For instance, we could use an abstract-syntax \ntree for the static analyses of C++ programs, and destructor-related events for dynamic analyses.  To \ndevelop our approach with more .avours of binary class relationships, such as the use, shared-aggregation, \nand container relationships.  To express our formal de.nitions with OCL, the con\u00adstraint language supplied \nwith UML, to allow seamless integration with UML tools.  To improve the precision of the detection by \nconsid\u00adering alternate implementations of the algorithms and alternate de.nitions of the relationships. \n   ACKNOWLEDGMENTS We gratefully thank R\u00b4emi Douence, Pierre Cointe, Houari Sahraoui, and the anonymous \nreviewers for their valuable help and comments on previous versions of this paper. REFERENCES [1] Mart\u00b4in \nAbadi and Luca Cardelli. A Theory of Objects. Monographs in Computer Science. Springer-Verlag, second \nedition, 1998. [2] Herv\u00b4e Albin-Amiot, Pierre Cointe, Yann-Ga\u00a8el Gu\u00b4eh\u00b4eneuc, and Narendra Jussien. Instantiating \nand detecting design patterns: Putting bits and pieces together. In Debra Richardson, Martin Feather, \nand Michael Goedicke, editors, proceedings of the 16th conference on Automated Software Engineering,pages \n166 173. IEEE Computer Society Press, November 2001. [3] Herv\u00b4e Albin-Amiot and Yann-Ga\u00a8el Gu\u00b4eh\u00b4eneuc. \nMeta-modeling design patterns: Application to pattern detection and code synthesis. In Bedir Tekinerdogan, \nPim Van Den Broek, Motoshi Saeki, Pavel Hruby, and Gerson Suny\u00b4e, editors, proceedings of the 1st ECOOP \nworkshop on Automating Object-Oriented Software Development Methods. Centre for Telematics and Information \nTechnology, University of Twente, October 2001. TR-CTIT-01-35. [4] Pascal Andr\u00b4e, Annya Romanczuk, Jean-Claude \nRoyer, and Aline Vasconcelos. An algebraic view of UML class diagrams. In Christophe Dony and Houari \nSahraoui, editors, proceedings of the 6th colloquium on Languages and Models with Objects, pages 261 \n276. Herm`es Science Publications, January 2000. [5] Gilles Ardourel and Marriane Huchard. AGATE: Access \nGraph bAsed Tools for handling Encapsulation. In proceedings of the 16th conference on Automated Software \nEngineering, pages 311 314. IEEE Computer Society Press, November 2001. Short paper. [6] Boris Bezier. \nSoftware Testing Techniques.Van Nostrand Rheinhold Company, New York, 1990. [7] Juan C. Bicarregui, \nKevin C. Lano, and Tom S. E. Maibuam. Objects, associations and subsystems: A hierarchical approach to \nencapsulation. In Mehmet Aksit and Satoshi Matsuoka, editors, proceedings of 11th European Conference \non Object-Oriented Programming, pages 324 343. Springer-Verlag, June 1997. [8] Edwin Blake and Steve \nCook. On including part hierarchies in object-oriented languages, with an implementation in Smalltalk. \nIn Jean B\u00b4ezivin, Jean-Marie Hullot, Pierre Cointe, and Henry Lieberman, editors, proceedings of the \n1st European Conference on Object-Oriented Programming,pages 41 50. Springer-Verlag, June 1987. [9] \nGrady Booch. Object-Oriented Design with Applications. The Benjamin/Cummings Publishing Company, Inc., \n2nd edition, September 1993. [10] Ruth Breu, Ursula Hinkel, Christoph Hofmann, Cornel Klein, Barbara \nPaech, Bernhard Rumpe, and Veronika Thurner. Towards a formalization of the unifed modeling language. \nIn Mehmet Aksit and Satoshi Matsuoka, editors, proceedings of the 11th European Conference for Object-Oriented \nProgramming, pages 344 366. Springer-Verlag, June 1997. [11] Jean-Michel Bruel, Brian Henderson-Sellers, \nFranck Barbier, Annig Le Parc, and Robert B. France. Improving the UML metamodel to rigorously specify \naggregation and composition. In Shushma Patel, Yingxu Wang, and Ronald H. Johnston, editors, proceedings \nof the 7th international conference on Object-Oriented Information Systems, pages 5 14. Springer-Verlag, \nAugust 2001. [12] M. Ajmal Chaumun, Hind Kabaili, Rudolf K. Keller, Fran\u00b8cois Lustman, and Guy Saint-Denis. \nDesign properties and object-oriented software changeability. In J\u00a8urgen Ebert and Chris Verhoef, editors, \nproceedings of the 4th Conference on Software Maintenance and Reengineering, pages 45 54. IEEE Computer \nSociety Press, February 2000. [13] Shyam R. Chidamber and Chris F. Kemerer. A metrics suite for object-oriented \ndesign. Technical Report E53-315, MIT Sloan School of Management, December 1993. [14] Franco Civello. \nRoles for composite objects in object-oriented analysis and design. In Andreas Paepcke, editor, proceedings \nof the 8th conference on Object-Oriented Programming, Systems, Languages, and Applications, pages 376 \n393. ACM Press, September 1993. [15] Lori A. Clarke, Andy Podgurski, Debra J. Richardson, and Steven \nJ. Zeil. A formal evaluation of data .ow path selection criteria. IEEE Transaction on Software Engineering, \n15(11):1318 1332, November 1989. [16] St\u00b4ephane Ducasse, Mireille Blay-Fornarino, and Anne-Marie Pinna-Dery. \nA re.ective model for .rst class dependencies. In Frank Manola, editor, proceedings of 10th conference \non Object-Oriented Programming, Systems, Languages, and Applications, pages 265 280. ACM Press, October \n1995. [17] Erich Gamma and Kent Beck. Test infected: Programmers love writing tests. Java Report, 3(7):37 \n50, July 1998. [18] Erich Gamma and Thomas Eggenschwiler. JHotDraw. Web site, 1998. [19] Erich Gamma, \nRichard Helm, Ralph Johnson, and John Vlissides. Design Patterns Elements of Reusable Object-Oriented \nSoftware. Addison-Wesley, 1st edition, 1994. [20] Yann-Ga\u00a8el Gu\u00b4eh\u00b4eneuc and Herv\u00b4e Albin-Amiot. Using \ndesign patterns and constraints to automate the detection and correction of inter-class design defects. \nIn Quioyun Li, Richard Riehle, Gilda Pour, and Bertrand Meyer, editors, proceedings of the 39th conference \non the Technology of Object-Oriented Languages and Systems, pages 296 305. IEEE Computer Society Press, \nJuly 2001. [21] Yann-Ga\u00a8el Gu\u00b4eh\u00b4eneuc, Herv\u00b4e Albin-Amiot, R\u00b4emi Douence, and Pierre Cointe. Bridging \nthe gap between modeling and programming languages. Technical Report 02/09/INFO, Computer Science Department, \n\u00b4 Ecole des Mines de Nantes, July 2002. [22] Yann-Ga\u00a8el Gu\u00b4eh\u00b4eneuc, R\u00b4emi Douence, and Narendra Jussien. \nNo Java without Ca.eine A tool for dynamic analysis of Java programs. In Wolfgang Emmerich and Dave \nWile, editors, proceedings of the 17th conference on Automated Software Engineering, pages 117 126. IEEE \nComputer Society Press, September 2002. [23] William Harrison, Charles Barton, and Mukund Raghavachari. \nMapping UML designs to Java. In Doug Lea, editor, proceedings of the 15th conference on Object-Oriented \nProgramming, Systems, Languages, and Applications, pages 178 188. ACM Press, October 2000. [24] Thorsten \nHartmann, Ralf Jungclaus, and Gunter Saake. Aggregation in a behavior oriented object model. In Ole Lehrmann \nMadsen, editor, proceedings of 6th European Conference for Object-Oriented Programming, pages 57 77. \nSpringer-Verlag, June July 1992. [25] Brian Henderson-Sellers. Some problems with the UML v1.3 metamodel. \nIn Ralph H. Sprague Jr., editor, proceedings of the 34th annual Hawaii International Conference on System \nSciences,pages 3052 3064. IEEE Computer Society Press, January 2001. [26] Brian Henderson-Sellers and \nFranck Barbier. A survey of the UML s aggregation and composition relationships. L objet : Logiciel, \nBase de donn\u00b4ees, R\u00b4eseaux, 5(3/4):339 366, December 1999. [27] Daniel Jackson and Allison Waingold. \nLightweight extraction of object models from bytecode. In David Garlan and Je. Kramer, editors, proceedings \nof the 21st International Conference on Software Engineering, pages 194 202. ACM Press, May 1999. [28] \nRalf Kollmann and Martin Gogolla. Application of UML associations and their adornments in design recovery. \nIn Elizabeth Burd and Peter Aiken, editors, proceedings of the 8th Working Conference on Reverse Engineering, \npages 81 91. IEEE Computer Society Press, October 2001. [29] Christian Kr\u00a8amer and Lutz Prechelt. Design \nrecovery by automated search for structural design patterns in object-oriented software. In Linda M. \nWills and Ira Baxter, editors, proceedings of the 3rd Working Conference on Reverse Engineering, pages \n208 215. IEEE Computer Society Press, November 1996. [30] Bent Bruun Kristensen. Complex associations: \nAbstractions in object-oriented modeling. In J. Eliot B. Moss, editor, proceedings of the 9th conference \non Object-Oriented Programming, Systems, Languages, and Applications, pages 272 283. ACM Press, October \n1994. [31] Esperanza Marcos, Belen Vela, Jos\u00b4e M. Cavero, and Paloma C\u00b4aceres. Aggregation and composition \nin object-Relational database design. In Albertas Caplinskas and Johann Eder, editors, proceedings of \nthe 5th east-european conference on Advances in Databases and Information Systems, pages 195 209. Springer-Verlag, \nSeptember 2001. [32] James Noble and John Grundy. Explicit relationships in object-oriented development. \nIn Bertrand Meyer, editor, proceedings of the 18th conference on the Technology of Object-Oriented Languages \nand Systems, pages 211 226. Prentice-Hall, November 1995. [33] James Rumbaugh, Michael Blaha, William \nPremerlani, Frederick Eddy, and William Lorenson. Object-Oriented Modeling and Design. Prentice Hall, \nInc., 1st edition, October 1991. [34] Monika Saksena, Robert B. France, and Maria M. Larrondo-Petrie. \nA characterization of aggregation. In Colette Rolland, editor, proceedings of the 5th international conference \non Object-Oriented Information Systems, pages 363 372. Springer-Verlag, September 1998. [35] Pamela Samuelson. \nReverse engineering under siege. Communications of the ACM, 45(10):15 20, October 2002. [36] Elliot Soloway, \nJeannine Pinto, Stanley Letovsky, David Littman, and Robin Lampert. Designing documentation to compensate \nfor delocalized plans. Communication of the ACM, 31(11):1259 1267, November 1988. [37] Sun Microsystems, \nInc. Java Abstract Window Toolkit, May 2000.  \n\t\t\t", "proc_id": "1028976", "abstract": "<p>A discontinuity exists between object-oriented modeling and programming languages. This discontinuity arises from ambiguous concepts in modeling languages and a lack of corresponding concepts in programming languages. It is particularly acute for binary class relationships---association, aggregation, and composition. It hinders the traceability between software implementation and design, thus hampering software analysis. We propose consensual definitions of the binary class relationships with four minimal properties---exclusivity, invocation site, lifetime, and multiplicity. We describe algorithms to detect automatically these properties in source code and apply these on several frameworks. Thus, we bridge the gap between implementation and design for the binary class relationships, easing software analysis.</p>", "authors": [{"name": "Yann-Ga&#235;l Gu&#233;h&#233;neuc", "author_profile_id": "81100289421", "affiliation": "Universit&#233; de Montr&#233;al, Montr&#233;al, Qu&#233;bec, Canada", "person_id": "P698425", "email_address": "", "orcid_id": ""}, {"name": "Herv&#233; Albin-Amiot", "author_profile_id": "81100274008", "affiliation": "&#201;cole des Mines de Nantes, Nantes, France", "person_id": "P698417", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1028976.1029002", "year": "2004", "article_id": "1029002", "conference": "OOPSLA", "title": "Recovering binary class relationships: putting icing on the UML cake", "url": "http://dl.acm.org/citation.cfm?id=1029002"}