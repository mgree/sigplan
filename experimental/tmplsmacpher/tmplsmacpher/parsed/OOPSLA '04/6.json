{"article_publication_date": "10-01-2004", "fulltext": "\n Scalable Extensibility via Nested Inheritance Nathaniel Nystrom Stephen Chong Andrew C. Myers Computer \nScience Department Cornell University {nystrom,schong,andru}@cs.cornell.edu ABSTRACT Inheritance is \na useful mechanism for factoring and reusing code. However, it has limitations for building extensible \nsystems. We describe nested inheritance, a mechanism that addresses some of the limitations of ordinary \ninheritance and other code reuse mech\u00adanisms. Using our experience with an extensible compiler frame\u00adwork, \nwe show how nested inheritance can be used to construct highly extensible software frameworks. The essential \naspects of nested inheritance are formalized in a simple object-oriented lan\u00adguage with an operational \nsemantics and type system. The type system of this language is sound, so no run-time type checking is \nrequired to implement it and no run-time type errors can occur. We describe our implementation of nested \ninheritance as an unob\u00adtrusive extension of the Java language, called Jx. Our prototype implementation \ntranslates Jx code to ordinary Java code, without duplicating inherited code.  Categories and Subject \nDescriptors D.3.2 [Language Classi.cations]: Object-oriented languages; D.3.3 [Language Constructs and \nFeatures]: Classes and objects, frameworks, inheritance, modules, packages  General Terms Languages \n Keywords Object-oriented programming languages, inheritance, nested classes, virtual classes 1. INTRODUCTION \nConventional language mechanisms do not adequately support the reuse and extension of existing code. \nLibraries and module sys\u00adtems are perhaps the most widely used mechanisms for code reuse; a given library \ncan be used by any code that respects its interface. Inheritance adds more power: it enables frameworks, \nclass libraries that can be reused with some modi.cations or extensions. But these Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 04, Oct. 24 28, 2004, \nVancouver, British Columbia, Canada. Copyright 2004 ACM 1-58113-831-8/04/0010 ...$5.00. mechanisms do \nnot adequately support our goal of scalable exten\u00adsibility: the ability to extend a body of code while \nwriting new code proportional to the differences in functionality. In our work on the Polyglot extensible \ncompiler framework [27], we found that ordinary object-oriented inheritance and method dis\u00adpatch do not \nadequately support extensibility. Because inheritance operates on one class at a time, some kinds of \ncode reuse are dif\u00ad.cult or impossible. For example, inheritance does not support extension of an existing \nclass library by adding a given .eld or method to all subclasses of a given class. Inheritance is also \nin\u00adadequate for extending a set of classes whose objects interact ac\u00adcording to some protocol, a pattern \nthat occurs in many domains ranging from compilers to user interface toolkits. It can be dif.cult to \nuse inheritance to reuse and extend interdependent classes. Nested inheritance is a language mechanism \ndesigned to sup\u00adport scalable extensibility. Nested inheritance creates an inter\u00adaction between containment \nand inheritance. When a container (a namespace such as a class or package) is inherited, all of its components \neven nested containers are inherited too. In ad\u00addition, inheritance and subtyping relationships among \nthese com\u00adponents are preserved in the derived container. By deriving one container from another, inheritance \nrelationships may be concisely constructed among many contained classes. To avoid surprises when extending \na base system, it is impor\u00adtant that inherited code remain type-safe in its new context; further, type \nsafety should be enforced statically. Nested inheritance sup\u00adports sound compile-time type checking. \nThis soundness is not eas\u00adily obtained, because for extensibility, types mentioned in inherited code \nneed to be interpreted differently in the new, inheriting con\u00adtext. Two new type constructs make sound \nreinterpretation of types possible: dependent classes and pre.x types. We have designed a new language, \nJx, which adds nested in\u00adheritance to Java. Jx demonstrates that nested inheritance inte\u00adgrates smoothly \ninto an existing object-oriented language: it is a lightweight mechanism that supports scalable extensibility, \nyet it is hardly noticeable to the novice programmer. Many language extensions and design patterns have \nbeen pro\u00adposed or implemented to address the limitations of inheritance, in\u00adcluding virtual classes [21, \n22, 35], mixins [2], mixin layers [33], delegation layers [31], higher-order hierarchies [10], and open \nclasses [6]. A relationship between containment and inheritance is also introduced by virtual classes \nand higher-order hierarchies [10], but there are two key differences. First, unlike virtual classes, \nnested inheritance is statically type-safe; no run-time type checking is required to implement it. Second, \nnested inheritance associates nested classes with their containing classes rather than with objects of \nthose classes. The rest of this paper explores nested inheritance in more depth. Section 2 discusses \nwhy existing language mechanisms do not solve the problems that nested inheritance addresses. Section \n3 presents nested inheritance. Section 4 describes the design of Jx and discusses adding nested inheritance \nto Java. We have imple\u00admented a prototype Jx compiler, described in Section 5. Because Jx is complex, \na simpler language that captures the essence of nested inheritance is presented in Section 6, including \nits formal seman\u00adtics and static type safety results. Section 7 discusses more broadly related work, \nand Section 8 concludes. 2. SCALABLE EXTENSIBILITY Various programming language features support code \nreuse, in\u00adcluding inheritance, parametric polymorphism, and mixins. But when code is reused, the programmer \noften .nds that extension is not scalable: the amount of new code needed to obtain the desired changes \nin behavior is disproportionate to the perceived degree of change. More expressive language mechanisms \nare needed to make extension scalable. 2.1 Procedures vs. types One reason why extension is often not \nscalable is the well-known dif.culty of extending both types and the procedures that manipu\u00adlate them \n[32, 38]. Object-oriented languages make it easy to add new types but not new procedures (methods) that \noperate on them; functional programming style makes it easy to add new procedures but not new types. \nExtensions to an existing body of code are often sparse in the sense that new types that are added can \nbe treated in a boilerplate way by most procedures, and the new procedures that are added have interesting \nbehavior for only a few of the types on which they operate. However, standard programming methods cannot \nex\u00adploit this sparsity. In an object-oriented style, it is easy to add new classes, but to add new methods \nit is necessary to modify existing code, often duplicating the boilerplate code. In typical functional \nstyle, adding new functions that manipulate data is straightforward (assuming that the data representation \nis not encapsulated behind a module boundary), but modifying existing functions to handle new data types \nagain requires modifying existing code. This con.ict is particularly noticeable in the context of an \nex\u00adtensible compiler, where new types are added in the form of new abstract syntax nodes, and new procedures \nare added in the form of new compiler passes. With the usual strategy for compiler im\u00adplementation, adding \nnew abstract syntax requires changes to all passes, even if the new node types are relevant to only a \nfew passes. Similarly, adding a new pass may require changes to all nodes, even if the pass interacts \nin an interesting way with only a few node types. Thus, the con.ict between extending procedures and \ntypes creates an incentive to structure a compiler as a few complex passes rather than as a larger number \nof simple passes, resulting in a less modular compiler that is harder to understand, maintain, and reuse. \nSimilar problems arise in other application domains, such as user interface toolkits. Inheritance is \na useful mechanism for extensibility because adding new types becomes more scalable: in general, a new \ntype can inherit default behavior from some existing, similar type. How\u00adever, inheritance does not handle \nextensions that need to add new .elds or methods to an existing inheritance hierarchy in a uniform way. \nSome existing language mechanisms do help [6, 33, 31] but they do not solve the extensibility problems \nthat we have encoun\u00adtered in developing Polyglot. 2.2 Hooks and extensibility Making code extensible \nrequires careful design so that the ex\u00adtension implementer has available the right hooks: interposition \npoints at which new behavior or state can be added. However, there is often a price to pay: these hooks \ncan often clutter or obfus\u00adcate the base code. One way to provide hooks is through language mechanisms \nthat provide some kind of parametric genericity, such as parameterized types [20], parameterized mixins \n[2], and func\u00adtors [24]. Explicit parameterization over types, classes, or modules precisely describes \nthe ways in which extension is permitted. How\u00adever, it is often an awkward way to achieve extensibility, \nespecially when a number of modules are designed in conjunction with one another and have mutual dependencies. \nIt is often dif.cult to de\u00adcide which explicit parameters to introduce for purposes of future extension, \nand the overhead of declaring and using parameters can be awkward. Inheritance embodies a different approach \nto extensibility. By giving names to methods, the programmer creates less obtrusive, implicit parameters \nthat can be overridden when the code is reused. Nested inheritance builds on this insight by enabling \nnested classes to be used as hooks too.  3. NESTED INHERITANCE Nested inheritance is a statically safe \ninheritance mechanism designed to be applicable to object-oriented languages that, like Java [13] or \nC++ [34], support nested classes or other containment mechanisms such as packages or namespaces. We have \ndesigned a language, Jx, that extends Java with nested inheritance. In this section, we concentrate on \ndescribing the nested inheritance mech\u00adanism, ignoring details of its interaction with Java and its imple\u00admentation. \nThese issues are discussed in Sections 4 and 5. 3.1 Overview There are two key ideas behind nested inheritance. \nThe .rst idea is similar to Ernst s higher-order hierarchies [10] and is re\u00adlated to virtual classes \n[21, 22]: a class inherits all members of its superclass not only methods, but also nested classes and \nany subclass relationships among them.As with ordinary inheritance, the meaning of code inherited from \nthe superclass is as if it were copied down from the superclass. A subclass may override any of the members \nit inherits. Like virtual classes, when a nested class is overridden, the overriding class does not replace \nthe class it over\u00adrides, but instead enhances it. Thus, an overriding class is a sub\u00adclass of the class \nit overrides, inheriting all its members. We extend this notion in one important way: the overriding \nclass is not only a subclass but also a subtype of the class it overrides. This feature al\u00adlows more \nopportunities for code reuse than with virtual classes or higher-order hierarchies. In addition, nested \ninheritance provides a form of virtual superclasses [22, 8], permitting the subclass rela\u00adtionships among \nthe nested classes to be preserved when inherited into a new container class.1 This feature allows new \nclass members to be mixed in to a nested class by overriding its base class. The second key idea in nested \ninheritance is a rich language for expressing types so that when code is inherited, types are reinter\u00adpreted \nin the context of the inheriting class. The innovation is an intuitive way to name types that gives the \nexpressive power of vir\u00adtual classes while also permitting sound typing. Nested inheritance largely eliminates \nthe need for factory meth\u00adods [12] and other design patterns that address the problem of scal\u00adable extensibility \n[27]. Thus, a container such as a class or package 1Note that the similar-sounding term virtual base \nclass is used by C++ but has a very different meaning. class A { class A2 extends A { class B { int x; \n} class B { int y; } class C extends B {...} int m(B b) { int m(B b) { return b.x + b.y; return b.x; \n} } } C n() { return new C(); } } Figure 1: Nested inheritance example may contain several nested classes \nor nested packages that depend on each other in complex ways. When the container is extended and individual \ncomponents overridden, interactions between the com\u00adponents are preserved in the derived container. The \nstrength of nested inheritance as an extension mechanism is that it requires less advance planning to \nreuse code. Every class and method provides a hook for further extension, so less programmer overhead \nis needed to identify the possible ways in which the code can be extended than in the functor and mixin \napproaches. In this paper, nested inheritance is presented in the context of Java s nested classes. However, \nthe same mechanism applies equally well to packages or other namespace abstractions. In the Jx language, \npackages may have a declared inheritance relationship; they act very much like classes whose components \nare all static. Section 3.7 discusses packages in more detail. In Java, nested classes can be either \ninner classes or static nested classes. An instance of an inner class has a reference to an enclos\u00ading \ninstance of its containing class; static nested classes do not have this pointer. This distinction is \ndiscussed further in Section 4.5. In the following discussion, we consider all nested classes to be static \nnested classes. This choice allows the mechanism to be ap\u00adplicable to classes nested within packages, \nwhich have no run-time instances. 3.2 A simple example Consider the Java-like code in Figure 1. Because \nclass A contains nested classes B and C, its subclass A2 inherits nested classes B and C where the nested \nclasses A2.B and A2.C are subclasses of A.B and A.C, respectively. Class A2 explicitly declares a nested \nclass B, overriding A.B; declarations within A2.B (such as the instance variable y) extend A.B as if \nA2.B were an explicitly declared sub\u00adclass of A.B. Class C is inherited into A2 as the implicit class \nA2.C. The programmer writes no code for A2.C; it is a subclass of both A2.B and A.C. Subclass and subtype \nrelationships are preserved by inheritance. For example, in Figure 1, the class A2.C is a subclass (and \na sub\u00adtype) of A2.B because A.C is a subclass of A.B. In addition, the constructor call new C() constructs \nan object of the class A2.C when the method n is invoked on an object of class A2. Types named in inherited \ncode are reinterpreted in the inheriting context. For example, the argument of the method m in the class \nA has type B, meaning A.B in the context of A. But when inher\u00adited into the class A2, the argument type \nbecomes A2.B because the meaning of the name B is reinterpreted in the inheriting context. With this \nchange, A2 might not seem to conform to A because an argument method type has changed covariantly. However, \nsubtyp\u00ading between A2 and A is still sound because the type system ensures the m method can only be called \nwhen its argument is known to be from the same implementation of A as the method receiver. class Java \n{ class Expr { Type type; void accept(Visitor v) { v.visitExpr(this); } } class Plus extends Expr { Expr \nleft, right; void accept(Visitor v) { left.accept(v); right.accept(v); v.visitPlus(this); } } class Visitor \n{ void visitExpr(Expr e) { } void visitPlus(Plus b) { } } class TypeChecker extends Visitor { void visitPlus(Plus \np) { if (...) { p.type = Int; } else ... } } } Figure 2: Base compiler code class Jif extends Java { \nclass Expr { Label lbl; } class Label extends Expr { ... } class Visitor { void visitLabel(Label l) { \n} } class TypeChecker extends Visitor { void visitPlus(Plus p) { super.visitPlus(p); p.lbl = p.left.lbl.join(p.right.lbl); \n} } } Figure 3: Jif extension 3.3 Compiler example Figures 2 and 3 suggest how nested inheritance can \nbe used to build an extensible compiler. Figure 2 gives simpli.ed code for an ordinary Java compiler. \nFigure 3 uses nested inheritance to create a compiler for a language like Jif [25] that extends Java \nwith in\u00adformation .ow labels. This code uses the visitor pattern [12], in which compiler passes such \nas type checking are factored out into separate visitor objects, and boilerplate tree traversal is found \nin accept methods. The Expr and Plus classes implement abstract syntax tree (AST) nodes, and TypeChecker \nimplements the type\u00adchecking pass, inheriting common functionality from its superclass Visitor. Nested \ninheritance is effective for building this kind of ex\u00adtensible system. By adding a .eld lbl to the class \nExpr,ev\u00adery kind of expression node, including Plus, acquires this .eld. Similarly, adding a visitLabel \nmethod to Visitor causes ev\u00adery visitor, such as TypeChecker, to acquire this new method. The method \nTypeChecker.visitPlus can be then overridden class A { class B {...} class C extends This.B {...} int \nm(this.class.B b) { return b.x; } this.class.C n() { return new this.class.C(); } } Figure 4: Desugared \nversion of class A from Figure 1 to perform additional static checking on labels in addition to the ordinary \ntype checking it performs by delegating to the super\u00adclass Java.TypeChecker. Note that the overridden \nvisitPlus method expects a Jif.Plus, which has a lbl .eld, rather than a Java.Plus, which does not. This \nexample is suggestive of how nested inheritance could be used to implement the actual Polyglot and Jif \ncompilers. Note that Jif.Expr and Java.Expr are different classes and both classes can coexist within \nthe same compiler, permitting Jif abstract syntax trees to be translated to Java ASTs. 3.4 Naming types \nThe examples in Figures 1 3 look very much like Java; a Java programmer could be excused for not noticing \nthe discrepancies. In fact, Jx is mostly backward compatible with Java: a Java pro\u00adgram is a valid Jx \nprogram as long as nested classes are declared final or their containing classes are not subclassed. \nHowever, Jx obtains additional expressive power from new syntax for naming types (which is not shown \nin Figures 1 3). This syntax can be seen in Figure 4, which shows the class A from Figure 1 in a desugared \nform. Class A.C is declared to extend This.B. When This isused ina declaration, it refers to the most \nspeci.c class that inherits that dec\u00adlaration. In the body of A, This resolves to A and This.B therefore \nresolves to A.B. When C is inherited into A2, This.B is reinter\u00adpreted in the context of A2 and resolves \nto A2.B. Thus, A.C is a subclass of A.B and A2.C is a subclass of A2.B. Returning to Figure 1, observe \nthat the method m takes a formal parameter of type B. Since A2.B is a subclass of A.B, one might try \nto write unsafe code like the following, which passes an A.B to the method A2.m: A a = new A2(); A.B \nb = new A.B(); a.m(b); Because A.B does not have a y .eld, the behavior of the memory access b.y in \nthe method m would be unde.ned. For this reason the above code does not type-check in Jx. Of course, \nthis po\u00adtential unsoundness results because the formal argument type is changed covariantly in the subclass \nA2. The virtual class mecha\u00adnism in Beta [21] is unsound for precisely this reason, and therefore Beta \nrequires a run-time check at method invocation. These checks create run-time overhead, but more importantly, \nthey can lead to unexpected run-time errors. Our approach is instead to introduce a dependent type mechanism \nthat ensures programs are statically safe and thus do not need run-time checks. In Figure 1, the method \nA.m is declared with a formal parameter of type B, which is syntactic sugar for the type this.class.B,as \nshown in Figure 4. The dependent class this.class denotes the run-time class of the expression this,but \nnot any subclass of the run-time class of this. As with ordinary non-dependent classes, a nested class \ncan be selected from this.class. If the run-time class of this is A2, then this.class.B is really the \nclass A2.B. If, at run time, this is an instance of class A, then this.class.B is A.B,but not A2.B. Declaring \nthe method parameter for m as this.class.B ensures that m in A2.B cannot be called with a superclass \nof A2.B. Callers of m must demonstrate that the method is invoked with a B selected from the receiver \ns class. In the following (safe) code, the variable a contains a value with run-time class A2. final \nA a = new A2(); final a.class.B b = new a.class.B(); a.m(b); To call the method m with receiver a, the \ncaller must pass an argu\u00adment of type a.class.B. Even if the receiver has static type A2,it is illegal \nto invoke m with an A2.B, since the actual run-time class of the receiver may be a subtype of A2 that \noverrides A2.m. The argu\u00adment must have the type a.class.B. Note that a must be declared final to ensure \nits run-time class does not change. In general, a dependent class is of the form p.class, where p is \na final access path: either a final local variable (including formal parameters and this) or a .eld access \np.f, where p. is a final access path and f is a final .eld. The run-time class of an object speci.ed \nby a final access path does not change. The dependent type this.class is similar to the MyType (self \ntype) construct of LOOM [3] and PolyTOIL [5]. The key dif\u00adference is that with MyType, an instance of \na subtype of MyType may be assigned to a variable of type MyType. Although MyType is covariant with respect \nto the subclassing relationship, the type MyType may be used as a method parameter type because subtyp\u00ading \nand subclassing are decoupled. The dependent class p.class is also closely related to the path dependent \ntype p.type in the .Obj calculus [29] and in the Scala [28]; however p.type is a single\u00adton type, meaning \nthe only member of the type is the object ref\u00aderenced by p. p.class is not a singleton. In particular, \none can create new instances of the class through the new operator (e.g., new p.class(...)). While subclasses \nof the static type of a path a are not subtypes of a.class, the same is not true of classes selected \nrelative to a.class. In particular, using the classes in Figure 1, a.class.C is a subtype of a.class.B, \nand therefore the call a.m(b) above is permitted. 3.5 Pre.x types Now consider the code in Figure 2, \nin which the classes Expr and Visitor are mutually recursive because of their respective accept and visitExpr \nmethods. The class Jif extends Java, overriding both classes, so Jif.Expr and Jif.Visitor are mutually \ndepen\u00addent in the same way as Java.Expr and Java.Visitor. For code reuse, Expr and Visitor need to be \nable refer to each other without hard-coding the name of their enclosing class Java. Our solution is \na type system that gives the ability to name the enclosing class of a given value. For a non-dependent \nclass P, and arbitrary class T , the pre.x type P[T ] is the innermost enclosing class of T that is a \nsubclass of P. Pre.x types permit an unambiguous way of naming containers. For example, assuming the \nvariable b has the static type A.B, then A[b.class] is the container of the run-time class of the value \nin b;if b contains a value of run-time class A2.B, then A[b.class] is the class A2. In Figure 2 the method \nExpr.accept has a parameter with the (desugared) pre.x type Java[this.class].Visitor, and Visitor.visitExpr \nhas a parameter with the pre.x type Java[this.class].Expr. When accept is invoked on a Java.Expr, it \nexpects an argument of type Java.Visitor,but when invoked on a Jif.Expr, it expects Jif.Visitor. Thus, \nthe relationship among the component classes is preserved. Ref\u00aderences to Expr within Visitor in Figure \n2 are merely sugar for Java[this.class].Expr, and conversely for references to Visitor within Expr. No \ninstance of the class Java need be in scope to use the type Java[this.class].Expr. This syntax thus makes \nit possible to refer to other classes in the current package even though packages do not have instances. \n 3.6 Overriding the superclass When overriding a class in a containing class, the programmer can change \nthe superclass. This feature allows new functionality to be mixed in to several classes in the new containing \nclass without code duplication. The superclass of a nested class bounds the type of the nested class. \nOverriding the superclass permits this bound to be tightened, enabling a virtual type-like pattern. In \nparticular, if D is a nested class that extends some other class C, then D is like a virtual type, bounded \nby C; when D s container is subclassed, the superclass of D can be modi.ed to be a subclass of the original \nsuperclass of D. This has the effect of making the virtual type D more precise in the container s subclass. \n 3.7 Package inheritance The language mechanisms described for nested inheritance ap\u00adply to packages \nas well as to classes. Indeed, we expect nested inheritance of packages to be the most common use of \nnested in\u00adheritance. In Jx, packages, like classes, may have a declared inheritance relationship. If \npackage P2 extends package P, then P2 inherits all members of package P, including nested packages.2 \nThe dec\u00adlaration that P2 extends P is made in a special source .le in the package P2, which facilitates \nseparate compilation by allowing the package P to be ignorant of its descendants. The declaration is \nnot made in each separate source .le of the package P2, since doing so would duplicate package inheritance \ndeclarations, introducing pos\u00adsible inconsistencies and making modi.cation of the inheritance relationship \nmore dif.cult. Pre.x types extend to accommodate packages: if P is a package name and T is an arbitrary \nclass, then P[T ] is the innermost en\u00adclosing package of T that is derived from P. Pre.x types may also \nappear in import declarations. For example, consider a package P with nested packages Q and R, and a \nsource .le in Q that im\u00adports classes from R. To allow code reuse via nested inheritance, these classes \nmust be imported without hard-coding the names of their enclosing packages. The source .le in Q uses \nthe declaration import P[Package].R.* to import the appropriate classes. The keyword Package refers to \nthe package of the most speci.c class that inherits the import declaration, analogous to the use of This \nin a declaration to denote the most speci.c class that inherits that dec\u00adlaration. We use the name Package \nsince neither This nor this are in scope at import declarations. Dependent classes, on the other hand, \ndo not need to be ex\u00adtended to handle packages because packages do not have run-time instances. 2Nested \npackages are called subpackages in Java [13]. We refrain from using this term to avoid confusion between \nnested packages and derived packages. 3.8 Genericity Nested inheritance is intended to be a mechanism \nfor extensi\u00adbility and not for genericity. Jx is an extension of Java and, as of version 1.5, Java already \nhas a genericity mechanism, parameter\u00adized types. Nested inheritance as presented above does not provide \nan ab\u00adstract type construct. To use virtual types for genericity, abstract types are used to equate a \nvirtual type with a class. For example, the following code fragment implements a generic List class and \na List of Integers, IntList, in a hypothetical extension of Jx with abstract types. class List { abstract \nclass T extends Object { } void add(this.class.T x) { ... } } class IntList extends List { class T = \nInteger; } By declaring IntList.T to be an alias for Integer, the add method may be called with an argument \nof type Integer. Without abstract types, the best that can be done using nested classes is to declare \nIntList.T as class T extends Integer { } But in this case, only instances of IntList.T can be added to \nan IntList, not instances of the Integer class. However, a list of Integer can be implemented more succinctly \nas the parameterized type List<Integer>. 3.9 Final binding As in Java, classes in Jx may be declared \nfinal to prevent the class from being subclassed. This naturally extends to nested in\u00adheritance be requiring \nthat a final nested class can be neither sub\u00adclassed explicitly with an extends declaration nor overridden \nin a subclass of its enclosing class. This .nal binding of nested classes is useful for enabling optimizations \nand for modeling purposes. In addition, virtual classes in Beta may be inherited from only if they are \n.nal bound. Jx does not permit inheritance from dependent classes and thus this restriction is not needed. \nFinal classes also enable backward compatibility with Java; if all nested classes are final, a Jx program \nis a legal Java program.  4. INTERACTIONS WITH JAVA Nested inheritance introduces several new features \nthat are dis\u00adcussed in Section 3. It is worth discussing how these features in\u00adteract with some existing \nobject-oriented programming features in Java. 4.1 Conformance In Jx, a class conforms to its superclass \nunder the same rules as in Java: a method s parameter types and return type must be identical in both \nclasses. In principle this rule could be relaxed to permit covariant re.nement of method return types, \nbut we have not explored this relaxation.  4.2 Method dispatch In Java, method calls are dispatched \nto the method body in the most speci.c class of the receiver that implements the method. In the code \nin Figure 5(a), both A2.B and A.B2 override A.B s imple\u00admentation of m. The implicit class A2.B2 inherits \nm from both A.B2 and A2.B. Which of the two implementations is the most speci.c? class A { class A2 \nextends A { class B { class Binh { int m() { return 0; } int m() { return 0; } } } class B2 extends B \n{ class B extends Binh { int m() { return 1; } int m() { return 2; } } } } class B2inh extends B { class \nA2 extends A { int m() { return 1; } class B { } int m() { return 2; } } } } (a) Original code (b) A2 \nwith implicit classes shown in italics class B2 extends B { Object m() {...}  Figure 5: Method dispatch \nexample A A2 Figure 6: Dispatch order The same issue arises in languages that support multiple inher\u00aditance. \nFor example, in C++ this situation is considered an error. However, because nested inheritance introduces \nimplicit classes, this rule would effectively prevent a class from overriding any methods of a class \nit overrides, since its implicit subclasses would inherit both implementations. Instead, we exploit the \nstructure of the inheritance mechanism. When A is subclassed to A2,if B is not overridden, it is an implicit \nclass of A2. We write this class A2.Binh. Now when A2.B is de\u00adclared, overriding A.B, we can consider \nits immediate superclass to be not A.B, but rather the implicit class A2.Binh inherited into A2. We can \nthink of the code for A2 in Figure 5(a) as the code in Fig\u00adure 5(b). Thus, in order from most to least \nspeci.c, the classes in A2 are: A2.B2inh, A2.B, and A2.Binh, or equivalently: A.B2, A2.B, and A.B. This \ndispatch order is depicted in Figure 6. This dispatch order is not chosen arbitrarily: A.B2 should be \ndis\u00adpatched to before A2.B because the B2 classes are specializations of the B classes, and thus all \nB2 classes should be regarded as being more speci.c than any B class. The same dispatch order is used \nin delegation layers [31].  4.3 Naming con.icts To support separate compilation of classes, Jx needs \na mecha\u00adnism for resolving naming con.icts, which arise when a class in\u00adherits more than one implementation \nof a given method or .eld. For example, consider the code in Figure 7. The classes A.B2 and A2.B class \nA { class A2 extends A { classB{} classB{ int m() {...} } } class B2 extends B { } void n() { m(); // \nA.B2.m() or // A2.B.m()?! } } } Figure 7: Name con.ict example have a common ancestor A.B, and both declare \na method m(),but with incompatible return types. Both of these method declarations are allowed, because \nin general, each class could be compiled inde\u00adpendently of the other particularly, if the container A \nwere a pack\u00adage instead of a class. However, in the method body of A2.B2.n(), it is not clear which method \nm() is referred to. In addition, if A2.B2 wished to override one or both of the methods m(), then the \nmethod declarations need to indicate which method they are overriding. Jx resolves naming con.icts for \ncalls by requiring the caller to cast the receiver of the method invocation to a class in which there \nis no such con.ict. For example, in A2.B2.n(), the method call ((A2.B)this).m() would be permitted, as \nthe name m() is not in con.ict in the class A2.B. Field accesses are handled similarly. Naming con.icts \nfor method overriding are resolved by ensur\u00ading the overriding method declaration supplies the class \nname of an ancestor class on which the overridden method is de.ned. For example, if the class A2.B2 wished \nto override the method m() de\u00adclared in class A.B2, the method declaration in A2.B2 would be written \nint A.B2.m() {...}. Since we expect naming con.icts to be exceptional, rather than the norm, the additional \nmechanisms required by Jx to resolve nam\u00ading con.icts should not be overly burdensome. 4.4 Constructors \nNested inheritance requires that constructors, like methods, are inherited by subclasses, so that it \nis possible to call constructors of dependent classes and pre.x types. Suppose that the class A.B contains \na constructor that takes an integer as an argument. Then the following code is permitted: final A a = \nnew A2(); final a.class.B b = new a.class.B(7); The expression new a.class.B(7) is allowed because the \nstat\u00adically known type of a is the class A, and there is a suitable construc\u00adtor for the class A.B. However, \nat runtime the variable a contains a value of run-time class A2, and therefore an object of class A2.B \nis constructed. In order to be sound, the class A2.B must have a constructor with a suitable signature. \nSince A2.B may in general be an implicit class, A2.B must inherit the constructors of A.B, and of any \nother superclasses, in the same way that it inherits methods. The primary use of constructors is for \ninitializing .elds; if a .nal .eld does not have an initializer, then every constructor of the class \nmust ensure that the .nal .eld is initialized. Initializing .nal .elds is particularly important for \nnested inheritance, because some .nal .elds may be used to de.ne dependent classes. Failure to initialize \nthese .elds would lead to unsoundness. Therefore, if a class de\u00adclares a .nal .eld, that .eld must either \nhave an initializer, or else all constructors inherited from superclasses must be overridden and that \n.eld must be initialized in each constructor. Figure 8: Target classes and interfaces 4.5 Inner classes \nWe have assumed that nested classes are static and are thus not inner classes. An instance of a static \nnested class does not have a reference to an enclosing instance of its container class. In Java, these \nenclosing instances are written P.this, where P is the name of an enclosing class. Jx can accommodate \ninner classes by assign\u00ading the type P[this.class] to the enclosing instance P.this. Allowing inner classes \nraises the possibility of extending Jx to allow dependent classes to appear in the extends clause of \nnested classes. For example, if the class A had inner class B and a .nal .eld f, then B could be declared \nto extend this.f.class. De\u00adpendent classes cannot currently appear in the extends clause of a nested \nclass, as this is not in scope during the declaration of a static nested class. If the use of dependent \nclasses in extends clauses is restricted to this.class or pre.xes of this.class, then the current type \nsys\u00adtem of Jx suf.ces, because this.class is equivalent to This when this is in scope. References to \nenclosing instances can be imple\u00admented as .elds of the nested instance, as is done by javac and by Igarashi \nand Pierce s formalization of inner classes [17]. However, if arbitrary dependent classes are allowed, \nsuch as this.f.class, then the type system of Jx would need to be modi.ed, and the im\u00adplementation described \nlater, in Section 5, would need signi.cant redesign.  5. IMPLEMENTATION We have implemented a prototype \ntranslation from Jx to Java as a 3700-line extension in the Polyglot compiler framework [27]. The prototype \nsupports class inheritance but not package inheritance as described in Section 3.7. However, a design \nfor implementing package inheritance is presented in Section 5.4. The translation is ef.cient in that \nit does not duplicate code, although each Jx class, including implicit member classes, is represented \nexplicitly in the target language. 5.1 Translating classes As depicted in Figure 8, each source Jx class \n(including implicit member classes) is represented in translation by two Java classes and two Java interfaces: \nthe instance class, the method interface, the class class, and the static interface. The instance class \nfor a Jx class C contains the translation of any methods and constructors declared in C. An object of \nthe Jx class C is represented at runtime by a collection of instance class objects, one instance class \nobject for C and each Jx class that C subclasses. The instance objects that represent C point to each \nother via dispatch .elds. For example, the class A2.B2 of Figure 5 is represented by four objects as \nshown in Figure 9. The instance class also provides methods for accessing .elds and for dispatching to \nmethods, including those C inherits; these dispatch methods simply forward the .eld access or method \ncall to an appropriate instance object of a superclass of C, using the dispatch .elds. Note that A2.B2 \n Figure 9: Representation of an A2.B2 object Java s normal method dispatch mechanism cannot be used, \nbecause instance objects of superclasses of C are not superclasses of C s instance object. Hence, the \ntranslation must make dispatch explicit. Each instance class has two constructors: a master constructor \nand a slave constructor. If an object of class C is being created, then the master constructor of C s \ninstance class is invoked, creat\u00ading the other instance objects needed to represent a Jx C object by \ninvoking the necessary slave constructors. The slave constructor of C s instance class is invoked when \nthe instance object is being used to represent a subclass of C. The instance class also contains the \ntranslations of the Jx con\u00adstructors of C. Jx constructors are translated into methods in the in\u00adstance \nclass, which are invoked by the class class (see below); the translation of constructors into methods \nfacilitates the inheritance of constructors. The instance class for C implements the method interface \nfor C, which declares all methods that C de.nes, as well as getter and setter methods for all non-private \n.elds declared in C. The method interface extends all the method interfaces of C s superclasses. The \nclass class provides means at runtime to both access type information about C and create new C objects \n(that is, collections of appropriate instance classes). For every Jx class, there is a single class class \nobject instantiated at runtime. Every instance class has a method that returns the appropriate class \nclass, analogous to Java s getClass() method on the Object class. Information about C s superclasses, \nenclosing class, and nested classes is available at runtime in order to create instances of pre\u00ad.x types. \nFor example, if v is a Jx object, and a new object of type P[v.class] needs to be created via a constructor \ncall new P[v.class](...), then v s class class must be interrogated to .nd the class class for the most \nspeci.c enclosing class of v.class that is a subclass of P. The class class object found is then used \nto create the new object: the class class for C has a method newThis(...) for every constructor declared \nor inherited by C. These methods create a new instance class object for C, with the master constructor, \nand then invoke the appropriate translated con\u00adstructor on the instance class object. The class class \nalso provides a method to test if a given object is an instance of the Jx class, and a cast(Object o) \nmethod, which throws a ClassCastException if the object o is not an instance of the Jx class, and returns \no otherwise. These methods are needed to support the translation of casts and instanceof expressions \nin the source language. The class class implements the static interface, which declares all constructors \nthat C declares or inherits. The static interface ex\u00adtends all static interfaces of C s superclasses. \nAll methods on class class objects are invoked via an appropriate static interface. This permits the \ntranslation of constructor calls on dependent classes. For example, suppose A2 is a subclass of A. Then \nA2 s class class implements A s static interface. Now, if the variable a has static type A, the Jx expression \nnew a.class() will be translated to a call to newThis() on A s static interface. Supposing that the run-time \nclass of a is A2, then that method call will actually invoke newThis() on A2 s class class, and thus \ncreate a new instance of A2. 5.2 Translating methods A method declaration in a Jx class C is translated \ninto a method declaration in C s instance class; any method that C inherits has a dispatch method created \nin C s instance class. Since a Jx object is represented at runtime by a collection of instance objects, \nthe source language expression this must be translated into something other than the target language \nexpression this, in order to allow method invocations and .eld accesses on the Jx object. To achieve \nthis, the translation adds an additional parameter self to every source language method and constructor. \nThe self parameter is the translation of the special variable this and always refers to the master instance \nobject, the instance object that created the other instance objects that collectively represent a Jx \nobject. 5.3 Translating .elds A .eld declaration in a Jx class C is translated into a .eld dec\u00adlaration \nin C s instance class. Getter and setter methods are also produced for any non-private .elds, which allows \nthe method dis\u00adpatch mechanism to be used to access the .elds. Field accesses in Jx code are translated \ninto calls to the getter and setter methods. 5.4 Translating packages This section describes a design \nfor translating package inheri\u00adtance in Jx. This design is not yet implemented. Packages, like classes, \nrequire a means to access type informa\u00adtion about the package at runtime. For a given package P, the \npack\u00adage class for P provides type information about P to resolve pre.x types, analogous to a class class. \nThe package class is able to pro\u00advide information about what package P inherits from, the package that \ncontains P, packages nested inside P, and classes contained in the package P. Since a package class needs \nto know about all classes in the pack\u00adage, care must be taken to ensure that the classes in a given pack\u00adage \ncan be compiled separately while guaranteeing that the package class contains correct information. Correctness \ncan be achieved by generating the package class every time a class within the pack\u00adage is compiled, under \nthe assumption that all previously compiled classes within the package are available at that time. Removal \nof a class from a package requires the package class to be regener\u00adated. The re.ection mechanism of Java \nmay provide a more .ex\u00adible mechanism to ensure the correctness of information provided by package classes. \n  6. SIMPLE LANGUAGE MODEL To explore the soundness of type checking with nested inheri\u00adtance, we developed \na simple Java-like language that demonstrates the core features of nested inheritance with dependent \nclasses. For simplicity, many features of the full Jx language are absent. In par\u00adticular, the language \npresented here includes nested classes but not packages. A package can be modeled as a class in which \nall classes in the package are nested. The language is based on Featherweight Java (FJ) [16], but includes \na number of additional features found in the full Java language notably, a heap and super calls needed \nto model im\u00adportant features of nested inheritance. We include a heap in order to model recursive data \nstructures, which interact with dependent classes in non-trivial ways. The language includes static nested \nclasses, dependent classes and pre.x types. 6.1 Syntax The syntax of the language is shown in Figure \n10. We write xx to mean the list x1,...,xn and x to mean the set {x1,...,xn} for some n = 0. A term with \nlist subterms (e.g., xf =xe) should be interpreted as a list of those terms (i.e., f1 = e1,..., fn = \nen). We write #(xx) for the length of xx. The empty list is written []. The singleton list containing \nx is denoted [x]. We write x,xx for the list with head x and tail xx, and xx1 ,xx2 for the concatenation \nof xx1 and xx2. A program Pr is a pair (L,e) of a set of top-level class decla\u00adrations L and an expression \ne, which models the program s main method. To simplify presentation, we assume a single global top\u00adlevel \nclass table TCT, which maps top-level class names C to their corresponding class declarations class C \nextends S { L xFM}. A class declaration L may include a set of nested class declara\u00adtions L , a list \nof .elds xF, and a set of methods M. Fields are in a list since the order of the .elds is important for \n.eld initialization. There are two forms of class declaration L. In the TCT, a class dec\u00adlaration s extends \nclause cannot mention a dependent class, but it may refer to the type schema This, which is used to name \nthe en\u00adclosing class into which the class declaration is inherited. During class lookup, This is replaced \nwith the name of the enclosing class, producing a class declaration with an extends clause of the form \nextends T . Types T are either top-level classes C, quali.ed types T.C, de\u00adpendent classes p.class, or \npre.x types P[T : P.C], where P de\u00adnotes a non-dependent class name. A type may depend on an ac\u00adcess \npath expression p; the dependent class p.class is the run-time class of the object referred to by access \npath p. To be a well-formed type, p must be a final access path; if p were mutable, the class of the \nobject it refers to could change at run time, leading to an unsoundness. A pre.x type P[T : P.C] is the \ninnermost enclosing class T ' of T such that T ' is a subtype of P and T is a subtype of T '.C (and thus \nof P.C). For the pre.x type to be well-formed P.C must exist and T must be a dependent class or another \npre.x type. This de.nition of pre.x type differs from the description given in Section 3; the change \nsimpli.es the semantics. Although the pre.x type syntax can name only the immediately enclosing class \nof T , further enclosing classes can be named by pre.xing the pre.x type (e.g., A[A.B[x.class :A.B.C] \n:A.B]). Fields F may declared final or non-final. All .eld declara\u00adtions include an initializer expression. \nThe syntax for methods M is similar to that of Java. Expressions e are similar to Java expressions of \nthe same form. Access paths p are either .eld accesses p.f or values v, which include base values b and \nvariables x. Base values b are either memory locations eP of type P or null. Locations are not valid \nsurface syntax, although they appear during evaluation. All vari\u00adables x, including formal parameters \nand the special variable this, are final and are initialized at their declaration. The declaration final \nTx =e1; e2 initializes x to e1, then evaluates e2. Fields and methods are accessed only through .nal \naccess paths p. Field assignments may optionally be annotated with the keyword final, permitting assignment \nto final .elds when initializing an object. These final assignments are not allowed in the surface syntax. \nMethods dispatch to the method body in the most speci.c superclass of the receiver, as described in Section \n4.2. A method implemented by a superclass of P may be invoked with the expres\u00adsion v.superP.m(xv). In \nthe surface syntax, v must be this,but v can take on arbitrary values during evaluation as substitutions \noc\u00ad Syntax: programs Pr ::=(L,e) class declarations L ::=class C extends S {LFxM} | class C extends \nT {L xFM}type schemas S ::=C | S.C | This | P[S :P.C] types T ::=C | T.C | p.class | P[T :P.C] simple \nnested classes P, Q ::=C | P.C .eld declarations F ::=[final]Tf =e method declarations M ::=Tm(Tx ){e} \nx access paths p ::=v | p. f base values b ::=eP | null values v ::=b | x expressions e ::=p | final \nTx =e1; e2 | p. f =[final] e1; e2 | p.m(xv) | v.superP.m(xv) | new T as x {xf =xe} objects o ::=P {f \n=eP} typing environments G ::=0/ | G,x : T Evaluation contexts: evaluation contexts E ::=[\u00b7] | final \nTE x =e1; e2 | final Tx =E; e | E. f type eval contexts TE | E. f =e1; e2 | b. f =E; e2 | E.m(xb) | new \nTE as x {xf ::=TE.C =xe} null eval contexts N | P[TE :P.C] | E.class ::=null. f | final TE[null]x =e1; \ne2 | null. f =b; e | null.m(xb) | null.superP.m(xb) | new TE[null]as x {xf =xe}  Type interpretation: \nexact-class(eP.class)=P exact-class(P[T :P.C])=pre.x(P,exact-class(T ), exact-class(T ), P.C) runtime-class(C)=C \nruntime-class(T.C)=runtime-class(T ).C runtime-class(eP.class)=P runtime-class(P[T :P.C])=pre.x(P,runtime-class(T \n), runtime-class(T ),P.C) pre.x(P,P0,P ' .C,P.C)=P ' pre.x(P,P0,T, P.C)=pre.x(P,P0,next(0/,P0,T ), P.C) \n=P ' (T .C for any P ')  Class lookup: classes(G, T0,P)=Ls TCT(C)=C ext P {L xFM} (CT-OUTER) CT(G,T0,C)=C \next P {Ls L{T0/This}xFM} C ext Ts {L xFM}.classes(G, T,T) classes(G, T0,Ts)=Ls (CT-NEST) CT(G,T0,T.C)=C \next Ts {Ls L{T0/This}xFM} exact-class(T )=P classes(G, T0,P)=L (CT-RUNTIME) if Li =Ci ext Ti {Li xFi \nMi} L(Ci)= CT(G,T0,T )= ext P {L 0/} P[T :P.C] .dom(exact-class) CT(G,T0,P[T :P.C])= classes(G,T0,P)=L \next P {L 0/} (CT-PRE) p.class .dom(exact-class) Gf p final P classes(G, T0,P)=L CT(G,T0, p.class)= ext \nP {L 0/} (CT-DEP) Member class inheritance: L1 L2 = [ L1(C) L2(C) C.dom(L1.L2) Li absent otherwise \nC ext T1 {L1 Fx1 M1} C ext T2 {L2 xF2 M2}= C ext T2 {L1 L2 xF2 M2}  C ext T1 {L1 xF1 M1} absent =C ext \nT1 {L1 0/} absent C ext T2 {L2 Fx2 M2}=C ext T2 {L2 Fx2 M2} Final access paths: fP wf (F-LOC) feP final \nP G fT wf (F-NULL) G fnull final T x : T .G (F-VAR) G fx final T G f p final T ftype(G,T, fi)=final \nTi (F-GET) G f p. fi final Ti{p/this} G f p final T exact-class(T )=P exact-class(T ')=P ' G f p final \nT (F-RUNTIME)  Figure 10: Syntax and class lookup functions Superclasses: CT(G,T,T )=C ext Ts {L xFM} \nsuper(G,T )=Ts  Nested classes: classes(G,T0,Object)=0/ ' CT(G,T0,T )=C ext T { L xFM}classes(G,T0,T \n)=L Fields: .elds(G,T0,Object)=[] CT(G,T0,T )=C ext Ts {L xFM} ' next(G,T0,T )=T '' .elds(G,T0,T )=xF \n.elds(G,T0,T )=xF ' , Fx.elds(G,T,T)=[final]xT xf =xe ftype(G,T, fi)=[final]Ti .elds(G,T,T)=[final]xT \nxf =xe .nit(G,T, fi)=ei .elds(G,T,T)=[final]xT xf =xe fnames(G,T )= f  Methods: CT(G,T0,T )=C ext Ts \n{L xFM}Tr m(Tx ){e}.M xmethod(G,T0,T,m)=Tr m(Tx ){e} x x CT(G,T0,T )=C ext Ts {L xFM} x Tr m(Tx ){e}.M \n' next(G,T0,T )=T ' method(G,T0,T ,m)=M method(G,T0,T,m)=M method(0/,T0,T,m)=Tr m(Tx ){e} xmbody(T0,T,m)=(x \n,e) method(G,T0,T,m)=Tr m(Tx ){e} xmtype(G,T0,T,m)=(x : xT ).Tr  Operational semantics: runtime-class(T \n)=P (R-LET) (H,final Tx =b; e)-.(H,e{b/x}) H(eP)=P {f =b}  (R-GET) (H,eP.fi)-.(H,bi)  H(eP)=P {f =b} \nH ' =H[eP :=P {f1 =b1,..., fi =b ' i,..., fn =bn}] (R-SET) (H,eP.fi =[final] b ' i; e)-.(H ' ,e) mbody(P,P,m)=(x \n,e) (R-CALL) xx (H,eP.m(b))-.(H,e{eP/this,b/xx}) next(0/,P,Q)=Q ' mbody(P,Q ' ,m)=(x ,e) (R-SUPER) \nxx (H,eP.superQ.m(b))-.(H,e{eP/this,b/xx}) runtime-class(T )=P ' fnames(0/,P)=xf ' f . f eP .dom(H) \nH '' =H[eP =P {f =null }] ' ei =ei{eP/x}if fi . f ' ei =.nit(0/,P, fi){eP/this}if fi . f '- f '' x' \nx e =eP.f = final e ' ; eP (R-NEW) '' (H,new T as x {xf =xe})-.(H ' ,e ) ' (H,e)-.(H ' ,e ) (R-CONG) \n' (H,E[e])-.(H ' ,E[e ]) (H,E[N])-.(H,null) (R-NULL)  Dispatch ordering: ord(G,T )=xT next(G,T,Ti)=Ti+1 \nord(G,Object)=[Object] ord(G,T.C)=ord(G,T ).C ,ord(G,super(G,T.C)) ord(G,T )=T,ord(G,super(G,T )) where \nT =Object and '' T =T .C for any T '' ord(G,T ).C is the list of T .C such that T .ord(G,T )and ' G \nfT .C wf Figure 11: Member lookup functions and operational semantics cur. To simplify dispatch, a \nsuper call is marked with the name of the class lexically P containing the call. Allocation is performed \nwith the new operator. The calculus does not include constructors. Instead, the new operator has an inline \nconstructor body that may initialize zero or more .elds of the new object. The .eld initializers may \nrefer to the new object through the variable x. Fields not assigned in the inline constructor body are \ninitialized with their default initializers. Field initialization order is left unde.ned; .elds are initialized \nto null by default. Access to an uninitialized .eld is treated as a null dereference. A heap H maps locations \neP to objects o, which are simple records annotated with their class type. For any term t, value v, and \nvariable x we write t{v/x}for the capture-free substitution of v for x in t. As is standard practice, \na\u00adequivalent terms are identi.ed. We write FV(t) for the set of free variables in t.  6.2 Class lookup \nClasses are de.ned in a .xed top-level class table TCT that maps all top-level class names C to class \ndeclarations L. We extend the top-level class table TCT to a function CT, shown in Figure 10. CT returns \nclass declarations not only for top-level class names, but for arbitrary types. Member lookup and subtyping \nare de.ned using CT. In addition to the type to lookup, CT has two more parameters. Because the language \nhas dependent classes, the CT function takes an environment G that maps variables to types. G is a .nite \nordered list of x : T pairs in the order in which they came into scope. To be well-formed, an environment \nG may contain at most one pair x : T for a given x. In addition to returning a class declaration for \na type, CT also interprets the extends clause of the class declaration, replacing any occurrences of \nThis with the actual enclosing class. This type is passed as the second argument to CT. Thus, CT(G,T0,T \n) returns the interpreted class declaration for T in an environment G where T0 is substituted into the \nextends clause of member classes of the class declaration. To save space, we write C ext T {LFxM}to represent \nclass C extends T {L xFM}. Classes inherit member classes of the base class into the body of the derived \nclass. The set L1 L2, de.ned in Figure 10, merges the class bodies of identically named classes in L1 \nand L2, creat\u00ading class declarations for implicit classes when needed. Classes in L1 classes inherited \nfrom the base class are overridden by classes in L2 nested classes of the derived class. Fields and meth\u00adods \nof classes de.ned in a base class are not copied when the nested class is inherited into the subclass; \nthey can be found by the mem\u00adber lookup functions de.ned in Figure 11. The function classes(G,T0,T ) \nde.ned in Figure 11 returns the set of member classes of T with T0 substituted for This in the extends \nclause of the member classes. The rules CT-OUTER and CT-NEST de.ne the CT function for top-level classes \nC and nested classes T.C, respectively, using the top-level class table TCT. The three rules CT-RUNTIME,CT-PRE, \nand CT-DEP return class declarations for dependent classes and pre.x types. In these rules, the CT function \nreturns for type T an anonymous class declaration whose superclass is a simple class type P bounding \nT .3 Member classes are copied down into the anonymous class declaration as with top-level and nested \nclasses. In each rule, the type T0 is substituted for This in the extends clauses of nested classes. \nFor L = C ext S {LFxM}, we de\u00ad 3Anonymous class declarations should not be confused with Java anonymous \nclasses.    .ne L{T0/This}as C ext S{T0/This}{L xFM}, and we de.ne S{T0/This}as: C{T0/This}= C S.C{T0/This}= \nS{T0/This}.C This{T0/This}= T0 P[S :P.C]{T0/This}= pre.x(P,P ' ,P ' ,P.C) where S{T0/This}= P ' P[S :P.C]{T0/This}= \nP[T :P.C] where S{T0/This}= T = P ' for any P ' The function pre.x is de.ned in Figure 10 and is used \nto ensure the type produced by the substitution is well-formed. The rule CT-RUNTIME de.nes class lookup \nfor types whose ex\u00adact run-time class can be determined statically. The partial function exact-class, \nde.ned in Figure 10, returns a simple class type P for these types. exact-class is only de.ned only for \ndependent classes and pre.x types containing access paths of the form eP.class. Since these types are \nnot valid surface syntax CT-RUNTIME is not used when type-checking the program, but is needed to prove \nthe type system sound. The rule CT-PRE de.nes class lookup for pre.x types P[T :P.C] whose run-time class \nis not statically known. An anonymous class declaration whose superclass is P is returned. Similarly, \nthe rule CT-DEP de.nes class lookup for dependent classes p.class whose run-time class is not statically \nknown by returning an anonymous class declaration whose superclass is the declared type of p. The judgment \nG fp final T , de.ned in Figure 10, is used to check that an access path has type T and is immutable. \nThe rules for G fp final T and for CT(G,T0,T ) are mutually recursive (via the de.nition ftype, de.ned \nin Figure 11). For a dependent class p.class to be well-formed, the static type of p must be a sim\u00adple \ntype P; this restriction is suf.cient to ensure the de.nition of CT for dependent classes is well-founded. \nAs in [29], we wish to ensure that no type information is lost when typing a .nal access path so that \nwe can tightly bound p.class. Consequently, there is no subsumption rule that can be used to prove G \nfp final T . Rules F-LOC and F-VAR bound the types of locations and local variables, respectively. F-LOC \nrequires that the type of the loca\u00adtion eP be well-formed according to the rules in Figure 13. Rule F-NULL \nstates that the null value may have any type. Rule F-GET uses the ftype function to retrieve the type \nof the .eld. The target of a .eld access in a .nal access path must be final. Finally, the rule F-RUNTIME \npermitstwotypeswiththesamerun-timeclass(if statically known) to be considered to have the same type. \n 6.3 Method and .eld lookup Method and .eld lookup functions are de.ned in Figure 11. The functions are \nde.ned using the linearization of superclasses de\u00adscribed informally in Section 3. The ordering, ord(G,T \n), is de.ned so that classes that T overrides occur before T s declared super\u00adclass, super(G,T ). The \nnext function is used to iterate through the superclasses to locate the most-speci.c method or .eld de.nition. \nIn Figure 11, the function .elds(G,T0,T ) returns all .elds de\u00adclared in class T0 or superclasses of \nT0, iterating through super\u00adclasses of T0 using the next function, beginning with T . Auxil\u00adiary functions \nftype, .nit, and fnames are de.ned from .elds to return the type of a given .eld, the initializer of \na .eld, and the set of all .eld names for a given class, respectively. The func\u00adtion method(G,T0,T, m) \nreturns the most-speci.c method declara\u00ad ' super(G,T )=T (=-EXTENDS) ' G fT =T ' G fT =T (=-NEST) ' G \nfT.C =T .C ' exact-class(T )=P exact-class(T )=P (=-RUNTIME) ' G fT =T Figure 12: Subtyping tion for \nmethod m, iterating through the superclasses of T0, begin\u00adning with T . Functions mbody and mtype return \nthe method body and method type, respectively, for a method. 6.4 Operational semantics The operational \nsemantics of the language are given in Figure 11. The semantics are de.ned using a reduction relation \n-.that maps a con.guration of a heap H and expression e to a new con.guration. A heap H is a function \nfrom memory locations eP to objects P {f = ' eP'}. The notation (H,e)-.(H ' ,e )means that expression \ne and ' heap H step to expression e and heap H '. The initial con.guration for program (TCT,e)is (0/,e). \nFinal con.gurations are of the form (H,eP)or (H,null). The reduction rules are mostly straightforward. \nR-CALL and R-SUPER use the mbody function de.ned in Figure 10 to locate the most speci.c implementation \nof m. Recall that super calls are annotated with the name of lexically enclosing class containing the \ncall. R-SUPER uses the next function, de.ned in Figure 11 to start the search for the method body at \nthe next-most speci.c method after the lexically enclosing class Q. For a new T as x expression, R-NEW \nallocates an object of the run-time class P of type T . The rule initializes all .elds of the new object \nto null and then steps to a sequence of .eld assignments to initialize the expression, and .nally evaluates \nto the location of the newly allocated object. The .eld assignments are annotated with the keyword final \nto indicate that it is permitted to assign to final .elds. Since .nal assignments are not permitted in \nthe surface syntax, final .elds may only be assigned once. The .eld initializers xe appearing explicitly \nin the new expression are evalu\u00adated with the new location substituted for x. The other .elds of the \nobject are initialized using the default initializers xe ' with the new location substituted for this. \nThe run-time class of T is computed using the function runtime-class, de.ned in Figure 10. For pre.x \ntypes P[T ' : P.C], runtime-class uses the pre.x function to compute the run-time class of the pre.x \ntype by iterating through the superclasses of T ' until a class overriding P.C is found; the container \nof this class is the run-time class of the pre.x type. Order of evaluation is captured by an evaluation \ncontext E (an expression with a hole [\u00b7]) and the congruence rule R-CONG. The rule R-NULL propagates \na dereference of a null pointer out through the evaluation contexts, simulating a Java NullPointer-Exception. \n 6.5 Static semantics The static semantics of the language are de.ned by rules for sub\u00adtyping, type \nwell-formedness, typing, and conformance. Subtyping The subtyping relation is the smallest re.exive, \ntransitive relation consistent with the rules in Figure 12. Rule =-EXTENDS says that a class is a subtype \nof its declared superclass. The subtyping re- C .dom(TCT) (WF-OUTER) G fC wf G fT wf classes(G,T,T )=Ls \nC ext Ts {L xF M}.Ls G fT.C wf (WF-NEST) G fp final P G fp.class wf (WF-DEP) G fP.C wf G fT wf is-exact(T \n) G fP[T :P.C] wf G fT =P.C (WF-PRE) ' false if T =C .T =T .C is-exact(T )= true otherwise Figure 13: \nType well-formedness lationships for dependent classes and pre.x types are covered by =-EXTENDS. Rule \n=-NEST says that a nested class C in T is a sub\u00ad' class of the class C in T that it overrides. Finally, \nrule =-RUNTIME states that two types are subtypes of each other if their run-time classes are equal. \n Type well-formedness Since types may depend on variables, we de.ne type well\u00adformedness in Figure 13 \nwith respect to an environment G, writ\u00adten G fT wf. A non-dependent type is well-formed if a class declaration \nfor it can be located through the TCT. A dependent class p.class is well-formed if p is final and has \na simple non\u00addependent class type P. A pre.x type P[T : P.C] is well-formed if its subterms are well-formed \nand if T is an exact type and is also a subtype of P.C. The last requirement ensures the run-time class \nof the type can be determined. A type is exact if it is a dependent class or a pre.x type. The subtyping \nrules ensure that no type can be proved a subtype of an exact type. This restriction ensures that a variable \nof type p.class can be assigned only values with the same run-time class as the ob\u00adject referred to by \np. The restriction does not limit expressiveness since non-exact pre.x types can be desugared to either \nexact pre.x types or to non-pre.x types.  Typing The typing rules are shown in Figure 14. The typing \ncontext con\u00adsists of an environment G. The typing judgment G fe : T is used to type-check expressions. \nRules T-NULL and T-VAR are standard. The rule T-LOC allows a location of type P to be used as a member \nof any type T where runtime-class(T )=P. This rule helps to ensure types are preserved across the evaluation \nof a new expression. The rule T-LETtype-checks a local variable initialization expres\u00adsion. The declared \ntype T must be well-formed in the environment ' G. The expression e following the declaration is type-checked \nwith the new variable in scope. The type of e ' must be well-formed in the original environment to ensure \nthat its type does not depend on ' the new variable, which is not in scope outside of e . Rules T-GET \nand T-SET use the ftype function to retrieve the type of the .eld. The target of a .eld access or assignment \nmust be a final path, permitting substitution to be performed on the .eld runtime-class(T )=P fT wf feP \n: T fP wf (T-LOC) G fT wf G fnull : T (T-NULL) x : T .G G fx : T (T-VAR) G fe : T G,x : T fe ' : T ' \nG fT wf G fT ' wf x .dom(G) '' G ffinal Tx =e; e : T G fp final T ftype(G,T, fi)=[final]Ti G fp. fi \n: Ti{p/this} G fp final T G fe : Ti{p/this} ftype(G,T, fi)=[final]Ti '' G fe : T '' G fp. fi =[final] \ne; e : T (T-LET) (T-GET) (T-SET) Figure 14: Static semantics type: occurrences of this in the .eld type \nare replaced with the actual target p. Rule T-SET permits assignment to final .elds, but only for assignments \nannotated with final. This enables final .elds to be initialized, but not assigned to arbitrarily. Rules \nT-CALL and T-SUPER are used to check calls. The func\u00adtion mtype returns the method s type. The method \ntype may depend on this or on its parameters x , which are considered part of the method type. The receiver \nmust be final to permit substitution for argument and return types dependent on this. The arguments are \nalso substituted into the type. Rule T-NEW is used to check a new expression. The .elds used in the inline \nconstructor body must be declared in the class being allocated and the initializers must have the appropriate \ntypes. Since the initializers use x to refer to the newly allocated object, x is sub\u00adstituted for this \nin the .eld types. Rule T-DEP allows any .nal access path with a simple nested class type to take on \na dependent type. Finally, rule T-= is the usual subsumption rule for subtyping.  Declarations To initiate \ntype-checking, declarations are checked as shown in Fig\u00adure 15. The program is checked with rule OK-PROGRAM, \nwhich checks every class in the TCT and type-checks the main expres\u00adsion e in an empty environment. Rule \nOK-CLASS type-checks a class declaration of the form C ext S {L xFM}, nested within a class P, where \nP is possibly e (i.e., C is top-level). Type-checking recurses on all member dec\u00adlarations including \nnested classes. The rule also checks member classes and methods for conformance with the corresponding \ndec\u00adlarations in their superclass. To ensure no other type can be proved a subtype of a dependent class \nor of a pre.x type, it is required that a class cannot be declared to extend the type schema This or \nany pre.x of This. This requirement is enforced by substituting this.class for the schema This in the \nsuperclass S; and check\u00ading that this type is well-formed and not an exact type. Rule OV-CLASS checks \nthat a class declaration conforms to any class declarations it overrides. When overriding a class with \nsuperclass Ts, it is required that the new superclass G fp final T ' mtype(G,T,T, m)=(x : xT ).T G fxv \n: xT {p/this,xv/xx} ' G fp.m(xv): T {p/this,xv/xx} G fP wf G fv0: P ' mtype(G,P,super(P),m)=(x : xT ).T \nG fxv : xT {v0/this,xv/xx} ' G fv0.superP.m(xv): T {v0/this,xv/xx} ftype(G,T, f )=T G,x : T fe : T {x/this} \n x G fnew T as x {f =xe}: T G fp final P G fp : p.class ' G fe : T G fT =T ' G fe : T fL ok in e fe:T \nf(L, e)ok fL ok in P.C fxF ok in P.C fM ok in P.C classes(0/,S{P/This},S{P/This})=Ls C .dom(L).C .dom(Ls) \n.fL(C)in P.C overrides class of S{P/This} fM in P.C overrides method of S{P/This} this :P fS{this.class/This}wf \n\u00acis-exact(S{this.class/This}) fC ext S {L xFM}ok in P (OK-CLASS) super({this : Ps},this.class.C)=Ts \nclasses(0/,S{P/This},S{P/This})=Ls C .dom(L).C .dom(Ls) .fL(C)in P.C overrides class of S{P/This} fM \nin P.C overrides method of Ps.C this :P fS{this.class/This}=Ts fC ext S {L xFM}in P overrides class of \nPs this :P fT wf this :P fe : T f[final]Tf =e ok in P this :P,x1:T1,...,xi-1:Ti-1 fTi wf this :P,xx :xT \nfT0 wf this :P,xx :xT fe : T0 x fT0 m(Tx ){e}ok in P xx ' : x'' mtype(0/,P, Ps,m)=(T ).T 0 0 .Tx' =xT \n{xx ' /xx}.T ' =T0{xx ' /xx} P fT0 m(Tx ){e}overrides method of Ps x Figure 15: Checking declarations \n(T-CALL) (T-SUPER) (T-NEW) (T-DEP) (T-=) (OK-PROGRAM) (OV-CLASS) (OK-FIELD) (OK-METHOD) (OV-METHOD) S{this.class/This}be \na subtype of Ts in the typing environment this :P. This restriction differentiates nested class overriding \nfrom arbitrary multiple inheritance. Rule OK-FIELD states that in the body of class P, a .eld dec\u00adlaration \nof the form [final] Tf =e type-checks if the type T is well-formed and the initializer e type-checks \nin an environment where this has type P. For simplicity, we assume a .eld named f is declared at most \nonce in the program, and we assume all methods and nested classes are uniquely named up to overriding. \nRule OK-METHOD checks that each parameter type Ti is well\u00adformed in an environment that includes only \nthis and the param\u00adeters to the left of Ti. The method body must have the same type as the declared return \ntype. As in Java, method types are invariant; OV-METHOD enforces this requirement.  6.6 Soundness Our \nsoundness proof is structurally similar to the proof of sound\u00adness for Featherweight Java (FJ) [16]. \nThe proof uses the standard technique of proving subject reduction and progress lemmas [37]. The key \nlemmas are stated here. The complete proof is available in a technical report [26]. Subject reduction \nBecause expressions in our language are evaluated in a heap, to state the subject reduction lemma, we \n.rst de.ne a well-typedness condition for heaps and for con.gurations (H,e). De.nition 6.1 (Well-typed \nheaps) A heap H is well-typed if for any memory location eP .dom(H),  H(eP)=P {f =eP'}, fftype(0/,P, \nf )=T ,  feP' :T {eP/this}, and  eP'.dom(H)  De.nition 6.2 (Well-formed con.gurations) A con.guration \n(H,e) is well-formed if H is well-typed and for any location eP free in e, eP .dom(H). The subject reduction \nlemma states that a step taken in the eval\u00aduation of a well-formed con.guration results in a well-formed \ncon\u00ad.guration. Lemma 6.3 (Subject reduction) Suppose fe : T , (H,e) is well\u00ad '' formed, and (H,e)-.(H \n' ,e ). Then fe ' : T and (H ' ,e )is well\u00adformed. Progress The progress lemma states that for any well-formed \ncon.guration (H,e), either e is a base value eP or null,or (H,e)can make a step according to the operational \nsemantics. Lemma 6.4 (Progress) If fe : T , fT wf, (H,e)is well-formed, ' then either e = b or there \nis a con.guration (H ' ,e ) such that ' (H,e)-.(H ' ,e ). Soundness Finally, we de.ne the normal form \nof a con.guration, de.ne well\u00adformedness for programs, and state the soundness theorem. De.nition 6.5 \n(Normal forms) A con.guration (H, e)is in normal '' form if there is no (H ' ,e )such that (H,e)-.(H \n' ,e ). De.nition 6.6 A program Pr = (TCT, e) is well-formed if f TCT ok and 0/ fe:T for some T such \nthat 0/ fT wf. Theorem 6.7 (Soundness) Given a well-formed program Pr = (TCT,e), if the con.guration \n(0/,e)is well-formed and fe : T , and '' if (H ' ,e )is a normal form such that (0/,e)-.* (H ' ,e ), \nthen e ' is ' either a location eP .dom(H ')or null and fe : T .  7. RELATED WORK Over the past decade \na number of mechanisms have been pro\u00adposed to provide object-oriented languages with additional exten\u00adsibility. \nNested inheritance uses ideas from many of these other mechanisms to create a .exible and largely transparent \nmechanism for code reuse. Virtual classes Nested inheritance is related to virtual types and virtual \nclasses. Virtual types were originally developed for the language Beta [21, 22], primarily as a mechanism \nfor generic programming rather than for extensibility. Later work proposed virtual types as a means of \nproviding genericity in Java [35]. Nested classes in Jx are similar, but not identical, to virtual classes. \nUnlike virtual classes, nested classes in Jx are attributes of their enclosing class, not attributes \nof instances of their enclos\u00ading class. Suppose class A has a nested class B and that a1 and a2 are references \nto instances of possibly distinct subclasses of A. The virtual classes a1.B and a2.B are distinct classes. \nIn contrast, the Jx types a1.class.B and a2.class.B may be considered equiv\u00adalent if it can be proved, \neither statically or at run-time, that a1 and a2 refer to instances of the same class. Virtual types \nare not statically safe because they permit method parameter types to change covariantly with subtyping, \nrather than contravariantly. Beta and other languages with virtual types in\u00adsert run-time checks when \na method invocation cannot be stati\u00adcally proved sound. Dependent classes in Jx provide the expressive \npower of covariant method parameter types without introducing un\u00adsoundness. Recent work on type-safe \nvariants of virtual types has limited method parameter types to be invariant [36] and used self types \n[4] as discussed below. Nested inheritance supports a form of virtual superclasses; nested classes may \nextend other nested classes referred to by This, providing mixin-like functionality. The language Beta \ndoes not support virtual superclasses, but gbeta [8] does. As discussed in Section 3, nested inheritance \ndoes not support generic types. A nested class may only be declared a subtype of another type (via the \nclass s extends clause), not equal to another type. Generic types may be used to provide genericity, \nwhich is already supported in Java through parameterized types. To ensure inheritance relationships can \nbe determined statically, a virtual type in Beta may be inherited from only if it is .nal bound. Since \nnested classes in Jx are static, Jx does not permit inheritance from de\u00adpendent classes, ensuring a static \ninheritance hierarchy. Igarashi and Pierce [15] model the semantics of virtual types and several variants \nin a typed lambda-calculus with subtyping and de\u00adpendent types. The work most closely related to nested \ninheritance is Oder\u00adsky et al. s language Scala [28, 39], which supports scalable ex\u00adtensibility through \na statically safe virtual type mechanism and path-dependent types similar to Jx s dependent classes. \nHowever, Scala s path dependent type p.type is a singleton type containing only the value named by access \npath p; our p.class is not a sin\u00adgleton: new x.class(...), for instance, creates a new object of type \nx.class distinct from the object referred to by p. This difference gives Jx more .exibility, while preserving \ntype soundness. Scala has no analogue to pre.x types. Scala permits extensions to be composed through \nmixins. Jx sup\u00adports mixin-like functionality via virtual superclasses. With nested inheritance, several \nmixins can be applied at once to a collection of nested classes by overriding the base class (or base \npackage) of their container. In contrast, Scala requires the programmer to explicitly name the superclass \nof each individual mixin when it is applied. Family polymorphism Ernst [9] introduces the term family \npolymorphism to describe polymorphism that allows reuse of groups of mutually dependent classes, that \nis a family of classes. The basic idea is to use an ob\u00adject as a repository for a family of classes. \nVirtual classes of the same object are considered part of the same family. The language gbeta [8], as \nwell as Scala [28], described above, provides fam\u00adily polymorphism using a dependent type system that \nprevents the confusion of classes from different families. Nested inheritance is a limited form of family \npolymorphism. In the original formulation, each object de.nes a distinct family consisting of its nested \nclasses. With nested inheritance, since nested classes are associated with an enclosing class rather \nthan with an instance of the enclosing class, each class de.nes a distinct family. Thus, nested inheritance \nper\u00admits only a .nite number of families. However, consider the case of a class A with nested class B \nand references a1 and a2 of type A. If a1.class and a2.class cannot be shown statically to have the same \ntype, then a1.class.B and a2.class.B may be considered to be of distinct families, although at run-time \nthey may be of the same family. Jx allows objects to be passed between the two fam\u00adilies by casting a1.class \nto a2.class or vice versa. This added .exibility enables greater reuse. Moreover, using pre.x types, \na family need not be identi.ed solely be a single object. In gbeta, an explicit representative of the \nfamily must be passed around. It lacks an analogy to pre.x types, which enable a member of a family to \nunambiguously identify that family. Delegation layers [31] use virtual classes and delegation to pro\u00advide \nfamily polymorphism, solving many of the problems of mixin layers. With normal inheritance and virtual \nclasses, when a method is not implemented by a class, the call is dispatched to the super\u00adclass. With \ndelegation, the superclass view of an object may be implemented by another object. Methods are dispatched \nthrough a chain of delegate objects rather than through the class hierarchy. Delegation layers provide \nmuch of the same power as nested in\u00adheritance. Since delegates are associated with objects at run-time \nrather than at compile-time, delegation allows objects to be com\u00adposed more .exibly than with mixins \nor with nested inheritance. However, no formal semantics has been given for delegation lay\u00aders, and because \ndelegation layers rely on virtual classes, they are not statically type-safe. Higher-order hierarchies \nNested inheritance is similar to Ernst s higher-order hierar\u00adchies [10]. Like nested inheritance, higher-order \nhierarchies sup\u00adport family polymorphism. Additionally, when a subclass A2 over\u00adrides a nested class \nB of A2 s base class A, the overriding class A2.B inherits from A.B. However, unlike nested inheritance, \nthere is no subtyping relationship between A.B and A2.B. By ensuring A2.B is a subtype of A.B, nested \ninheritance permits more code reuse. Like nested inheritance, the inheritance hierarchy can be modi.ed \nby overriding the superclass of a nested class. Other nested types Nested classes originated with Simula \n[7]. Igarashi and Pierce [17] present a formalization of Java s inner classes, using Featherweight Java \n[16]. An instance of a Java inner class holds a reference to its enclosing instance. If inner classes \nare permitted in Jx, a translation similar to Igarashi and Pierce s can be applied, where if inner class \nC has an immediately enclosing instance of class P, then the translation of C has a .nal .eld of type \nP[this.class]. Odersky and Zenger [30] propose nested types, which com\u00adbine the abstraction properties \nof ML-style modules with support, through encoding, for object-oriented constructs like virtual types, \nself types, and covariant families of classes. Self types and matching Bruce et al. [5, 3] introduce \nmatching as an alternative to subtyp\u00ading in an object oriented language. With matching, the self type, \nor MyType, can be used in a method signature to represent the run-time class of the method s receiver. \nTo permit MyType to be used for method parameters, type systems with MyType decouple subtyping and subclassing. \nIn PolyTOIL and LOOM, a subclass matches its base class but is not a subtype. Although there is no explicit \nnotion of matching in our type system, the rules for sub\u00adtyping and type equivalence given here have \na similar effect. The p.class construct provides similar functionality to MyType, but is more .exible \nsince it permits this.class to escape the body of its class by assigning this.class into another variable \nor returning a value of that type from a method. Mixins A mixin [2, 11], also known as an abstract subclass, \nis a class pa\u00adrameterized on its superclass. Mixins are able to provide uniform extensions, such as adding \nnew .elds or methods, to a large num\u00adber classes. Recent work has extended Java with mixin function\u00adality \n[23, 1]. Because nested inheritance as described here has no type parametricity, it cannot provide a \nmixin that can be applied to many different, unrelated classes, Nested inheritance does, how\u00adever, provides \nmixin-like functionality by allowing the superclass of an existing base class to be changed or .elds \nand methods to be added by overriding the class s superclass through extension of the superclass s container. \nAdditionally, nested inheritance allows the implicit subclasses of the new base class to be instantiated \nwithout writing any additional code. Mixins have no analogous mechanism. Mixin layers [33] are a generalization \nof mixins to multiple classes. A mixin layer is a design pattern for implementing a group of interrelated \nmixin classes and extending them while preserving their dependencies. Mixin layers do not provide family \npolymor\u00adphism. Delegation layers [31], described above, were designed to overcome this limitation through \na new language mechanism. Open classes An open class [6] is a class to which new methods can be added \nwithout needing to edit the class directly, or recompile code that depends on the class. Nested inheritance \nis also able to add new methods to a class without the need for recompilation of clients of the class, \nprovided that the class is nested in a container that can be extended, and that clients of the class \nrefer to it using depen\u00addent types. Nested inheritance provides additional extensibility that open classes \ndo not, such as the virtual behavior of constructors. An important difference is that open classes modify \nexisting class hierarchies. The original hierarchy and the modi.ed hierarchy can\u00adnot coexist within the \nsame program. Nested inheritance creates a new class hierarchy by extending the container of the classes \nin the hierarchy, permitting use of the original hierarchy in conjunction with the new one. Aspect-oriented \nprogramming Aspect-oriented programming (AOP) [19, 18] is concerned with the management of aspects, functionality \nthat crosscuts standard mod\u00adular boundaries. Nested inheritance provides aspect-like extensibil\u00adity, \nin that an extension to a container may implement functionality that cuts across the class boundaries \nof the nested classes. Like open classes, aspects modify existing class hierarchies, preventing the new \nhierarchy from being used alongside the old.  8. CONCLUSIONS Nested inheritance is an expressive yet \nunobtrusive mechanism for writing highly extensible frameworks. It provides the ability to inherit a \ncollection of related classes while preserving the relation\u00adships among those classes, and it does so \nwithout sacri.cing type safety or imposing new run-time checks. The use of dependent classes and pre.x \ntypes enables reusable code to unambiguously yet .exibly refer to components on which it depends. Nested \nin\u00adheritance is fundamentally an inheritance mechanism rather than a parameterization mechanism, which \nmeans that every name intro\u00adduced by a component becomes a possible implicit hook for future extension. \nTherefore extensible code does not need to be burdened by explicit parameters that attempt to capture \nall the ways in which it might be extended later. We formalized the essential aspects of nested inheritance \nin an object calculus with an operational semantics and type system, and were able to show that this \ntype system is sound. Thus extensibility is obtained without sacri.cing compile-time type safety. Our \nexperience with implementing extensible frameworks gives us con.dence that nested inheritance will prove \nuseful. We de.ned a language Jx that incorporates the nested inheritance mechanism and implemented a \nprototype compiler for the core mechanisms of this language. The translation implemented by this compiler \ndoes not duplicate inherited code. The next step is clearly to complete the Jx implementation; we look \nforward to using it to build the next version of Polyglot. Acknowledgments Michael Clarkson and Jed Liu \nparticipated in early design discus\u00adsions. Matthew Fluet, Michael Clarkson, Jens Palsberg, and the anonymous \nreviewers provided thorough and insightful comments. This research was supported in part by ONR Grant \nN00014-01\u00ad1-0968, NSF Grants 0208642 and 0133302, and an Alfred P. Sloan Research Fellowship. Nathaniel \nNystrom was supported by an In\u00adtel Foundation Ph.D. Fellowship. The U.S. Government is autho\u00adrized to \nreproduce and distribute reprints for Government purposes, notwithstanding any copyright annotation thereon. \nThe views and conclusions here are those of the authors and do not necessarily re.ect those of ONR, the \nNavy, or the NSF. 9. REFERENCES [1] Davide Ancona, Giovanni Lagorio, and Elena Zucca. Jam: A smooth \nextension of Java with mixins. In Proc. ECOOP 00, LNCS 1850, pages 154 178, Cannes, France, 2000. [2] \nGilad Bracha and William Cook. Mixin-based inheritance. In Norman Meyrowitz, editor, Proc. OOPSLA 90, \npages 303 311, Ottawa, Canada, 1990. ACM Press. [3] Kim B. Bruce, Adrian Fiech, and Leaf Petersen. Subtyping \nis not a good match for object-oriented languages. In Proceedings of 11th European Conference on Object-Oriented \nProgramming (ECOOP 97), number 1241 in Lecture Notes in Computer Science, pages 104 127, Jyv\u00a8askyl\u00a8a, \nFinland, June 1997. Springer-Verlag. [4] Kim B. Bruce, Martin Odersky, and Philip Wadler. A statically \nsafe alternative to virtual types. In European Conference on Object-Oriented Programming (ECOOP), number \n1445 in Lecture Notes in Computer Science, pages 523 549, Brussels, Belgium, July 1998. Springer-Verlag. \n[5] Kim B. Bruce, Angela Schuett, and Robert van Gent. PolyTOIL: A type-safe polymorphic object-oriented \nlanguage. In European Conference on Object-Oriented Programming (ECOOP), number 952 in Lecture Notes \nin Computer Science, pages 27 51. Springer-Verlag, 1995. [6] Curtis Clifton, Gary T. Leavens, Craig \nChambers, and Todd Millstein. MultiJava: Modular open classes and symmetric multiple dispatch for Java. \nIn OOPSLA 2000 Conference on Object-Oriented Programming, Systems, Languages, and Applications, Minneapolis, \nMinnesota, volume 35(10), pages 130 145, 2000. [7] O.-J. Dahl et al. The Simula 67 common base language. \nPublication No. S-22, Norwegian Computing Center, Oslo, 1970. [8] Erik Ernst. gbeta a Language with \nVirtual Attributes, Block Structure, and Propagating, Dynamic Inheritance. PhD thesis, Department of \nComputer Science, University of Aarhus, \u00b0 Arhus, Denmark, 1999. [9] Erik Ernst. Family polymorphism. \nIn Proceedings of the 15th European Conference on Object-Oriented Programming (ECOOP), LNCS 2072, pages \n303 326, Heidelberg, Germany, 2001. Springer-Verlag. [10] Erik Ernst. Higher-order hierarchies. In Proceedings \nof the 17th European Conference on Object-Oriented Programming (ECOOP), volume 2743 of Lecture Notes \nin Computer Science, pages 303 329, Heidelberg, Germany, July 2003. Springer-Verlag. [11] Matthew Flatt, \nShriram Krishnamurthi, and Matthias Felleisen. Classes and mixins. In Proc. 25th ACM Symp. on Principles \nof Programming Languages (POPL), pages 171 183, San Diego, California, 1998. [12] Erich Gamma, Richard \nHelm, Ralph Johnson, and John Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. \nAddison Wesley, Reading, MA, 1994. [13] James Gosling, Bill Joy, Guy Steele, and Gilad Bracha. The Java \nLanguage Speci.cation. Addison Wesley, 2nd edition, 2000. ISBN 0-201-31008-2. [14] Carl Gunter and John \nC. Mitchell, editors. Theoretical aspects of object-oriented programming. MIT Press, 1994. [15] Atsushi \nIgarashi, Benjamin Pierce, and Philip Wadler. Foundations for virtual types. In Proceedings of the Thirteenth \nEuropean Conference on Object-Oriented Programming (ECOOP 99), number 1628 in Lecture Notes in Computer \nScience, pages 161 185. Springer-Verlag, June 1999. [16] Atsushi Igarashi, Benjamin Pierce, and Philip \nWadler. Featherweight Java: A minimal core calculus for Java and GJ. ACM Transactions on Programming \nLanguages and Systems, 23(3):396 450, 2001. [17] Atsushi Igarashi and Benjamin C. Pierce. On inner classes. \nInformation and Computation, 177(1):56 89, August 2002. [18] Gregor Kiczales, Erik Hilsdale, Jim Hugunin, \nMik Kersen, Jeffrey Palm, and William G. Griswold. An overview of AspectJ. In Proceedings of European \nConference on Object-Oriented Programming (ECOOP 01), volume 2072 of Lecture Notes in Computer Science, \npages 327 353, Berlin, Heidelberg, and New York, 2001. Springer-Verlag. [19] Gregor Kiczales, John Lamping, \nAnurag Mendhekar, Chris Maeda, Cristina Videira Lopes, Jean-Marc Loingtier, and John Irwin. Aspect-oriented \nprogramming. In Proceedings of 11th European Conference on Object-Oriented Programming (ECOOP 97), number \n1241 in Lecture Notes in Computer Science, pages 220 242, Jyv\u00a8askyl\u00a8a, Finland, June 1997. Springer-Verlag. \n[20] B. Liskov et al. CLU reference manual. In Goos and Hartmanis, editors, Lecture Notes in Computer \nScience, volume 114. Springer-Verlag, Berlin, 1981. [21] O. Lehrmann Madsen, B. M\u00f8ller-Pedersen, and \nK. Nygaard. Object Oriented Programming in the BETA Programming Language. Addison-Wesley, June 1993. \n[22] Ole Lehrmann Madsen and Birger M\u00f8ller-Pedersen. Virtual classes: A poweful mechanism for object-oriented \nprogramming. In Proc. OOPSLA 89, pages 397 406, October 1989. [23] Sean McDirmid, Matthew Flatt, and \nWilson C. Hsieh. Jiazzi: New-age components for old-fashioned Java. In Proc. OOPSLA 01, October 2001. \n[24] Robin Milner, Mads Tofte, and Robert Harper. The De.nition of Standard ML. MIT Press, Cambridge, \nMA, 1990. [25] Andrew C. Myers, Lantian Zheng, Steve Zdancewic, Stephen Chong, and Nathaniel Nystrom. \nJif: Java information .ow. Software release. Located at http://www.cs.cornell.edu/jif, July 2001 2003. \n[26] Nathaniel Nystrom, Stephen Chong, and Andrew C. Myers. Scalable extensibility via nested inheritance. \nTechnical Report 2004 1940, Computer Science Dept., Cornell University, June 2004. [27] Nathaniel Nystrom, \nMichael Clarkson, and Andrew C. Myers. Polyglot: An extensible compiler framework for Java.InG\u00a8orel Hedin, \neditor, Compiler Construction, 12th International Conference, CC 2003, number 2622 in Lecture Notes in \nComputer Science, pages 138 152, Warsaw, Poland, April 2003. Springer-Verlag. [28] Martin Odersky, Philippe \nAltherr, Vincent Cremet, Burak Emir, Sebastian Maneth, St\u00b4ephane Micheloud, Nikolay Mihaylov, Michel \nSchinz, Erik Stenman, and Matthias Zenger. An overview of the Scala programming language, June 2004. \nhttp://scala.epfl.ch/docu/files/\u00adScalaOverview.pdf. [29] Martin Odersky, Vincent Cremet, Christine R\u00a8ockl, \nand Matthias Zenger. A nominal theory of objects with dependent types. In Proceedings of 17th European \nConference on Object-Oriented Programming (ECOOP 2003), number 2743 in Lecture Notes in Computer Science, \npages 201 224. Springer-Verlag, July 2003. [30] Martin Odersky and Christoph Zenger. Nested types. In \n8th Workshop on Foundations of Object-Oriented Languages (FOOL), 2001. [31] Klaus Ostermann. Dynamically \ncomposable collaborations with delegation layers. In Proceedings of the 16th European Conference on Object-Oriented \nProgramming (ECOOP), volume 2374 of Lecture Notes in Computer Science, pages 89 110, M\u00b4alaga, Spain, \n2002. Springer-Verlag. [32] John C. Reynolds. User-de.ned types and procedural data structures as complementary \napproaches to data abstraction. In Stephen A. Schuman, editor, New Directions in Algorithmic Languages, \npages 157 168. Institut de Recherche d Informatique et d Automatique, Le Chesnay, France, 1975. Reprinted \nin [14], pages 13 23. [33] Yannis Smaragdakis and Don Batory. Implementing layered design with mixin \nlayers. In Eric Jul, editor, Proceedings ECOOP 98, pages 550 570, Brussels, Belgium, 1998. [34] B. Stroustrup. \nThe C++ Programming Language. Addison-Wesley, 1987. [35] Kresten Krab Thorup. Genericity in Java with \nvirtual types. In Proceedings of the European Conference on Object-Oriented Programming (ECOOP), number \n1241 in Lecture Notes in Computer Science, pages 444 471. Springer-Verlag, 1997. [36] Mads Torgerson. \nVirtual types are statically safe. In 5th Workshop on Foundations of Object-Oriented Languages (FOOL), \nJanuary 1998. [37] Andrew K. Wright and Matthias Felleisen. A syntactic approach to type soundness. Information \nand Computation, 115(1):38 94, 1994. [38] Matthias Zenger and Martin Odersky. Extensible algebraic datatypes \nwith defaults. In Proc. 6th ACM SIGPLAN International Conference on Functional Programming (ICFP), Firenze, \nItaly, September 2001. [39] Matthias Zenger and Martin Odersky. Independently extensible solutions to \nthe expression problem. Technical Report IC/2004/33, Ecole Polytechnique F\u00b4ed\u00b4erale de \u00b4 Lausanne, March \n2004.   \n\t\t\t", "proc_id": "1028976", "abstract": "<p>Inheritance is a useful mechanism for factoring and reusing code. However, it has limitations for building extensible systems. We describe &#60;i>nested inheritance&#60;/i>, a mechanism that addresses some of the limitations of ordinary inheritance and other code reuse mechanisms. Using our experience with an extensible compiler framework, we show how nested inheritance can be used to construct highly extensible software frameworks. The essential aspects of nested inheritance are formalized in a simple object-oriented language with an operational semantics and type system. The type system of this language is sound, so no run-time type checking is required to implement it and no run-time type errors can occur. We describe our implementation of nested inheritance as an unobtrusive extension of the Java language, called Jx. Our prototype implementation translates Jx code to ordinary Java code, without duplicating inherited code.</p>", "authors": [{"name": "Nathaniel Nystrom", "author_profile_id": "81100144238", "affiliation": "Cornell University", "person_id": "P328197", "email_address": "", "orcid_id": ""}, {"name": "Stephen Chong", "author_profile_id": "81100287555", "affiliation": "Cornell University", "person_id": "PP17000898", "email_address": "", "orcid_id": ""}, {"name": "Andrew C. Myers", "author_profile_id": "81100011022", "affiliation": "Cornell University", "person_id": "PP14016809", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1028976.1028986", "year": "2004", "article_id": "1028986", "conference": "OOPSLA", "title": "Scalable extensibility via nested inheritance", "url": "http://dl.acm.org/citation.cfm?id=1028986"}