{"article_publication_date": "10-01-2004", "fulltext": "\n Resolving Feature Convolution in Middleware Systems Charles Zhang and Hans-Arno Jacobsen Department \nof Electrical and Computer Engineering Department of Computer Science University of Toronto {czhang, \njacobsen}@eecg.toronto.edu ABSTRACT Middleware provides simplicity and uniformity for the de\u00advelopment \nof distributed applications. However, the modu\u00adlarity of the architecture of middleware is starting to \ndisin\u00adtegrate and to become complicated due to the interaction of too many orthogonal concerns imposed \nfrom a wide range of application requirements. This is not due to bad design but rather due to the limitations \nof the conventional ar\u00adchitectural decomposition methodologies. We introduce the principles of horizontal \ndecomposition (HD) which addresses this problem with a mixed-paradigm middleware architec\u00adture. HD provides \nguidance for the use of conventional de\u00adcomposition methods to implement the core functionalities of \nmiddleware and the use of aspect orientation to address its orthogonal properties. Our evaluation of \nthe horizontal decomposition principles focuses on refactoring major mid\u00addleware functionalities into \naspects in order to modularize and isolate them from the core architecture. New versions of the middleware \nplatform can be created through combining the core and the .exible selection of middleware aspects such \nas IDL data types, the oneway invocation style, the dynamic messaging style, and additional character \nencoding schemes. As a result, the primary functionality of the middleware is supported with a much simpler \narchitecture and enhanced performance. Moreover, customization and con.guration of the middleware for \na wide-range of requirements becomes possible.  Categories and Subject Descriptors D.2.11 [Software \nEngineering]: Software Architectures  General Terms Design, Measurement  Keywords Aspect Oriented Middleware, \nMiddleware Architecture Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. OOPSLA 04, Oct. 24-28, 2004, Vancouver, British Columbia, Canada. Copyright 2004 ACM 1-58113-831-8/04/0010 \n...$5.00. 1. INTRODUCTION Middleware platforms, such as CORBA, DCOM, J2EE, and .NET, o.er abstraction \nand simplicity for the complex and heterogeneous computing environment. They facili\u00adtate the development \nof high quality distributed applications with a shorter development cycle and a much smaller cod\u00ading \ne.ort. Middleware systems are being adopted in a very broad spectrum of application domains, ranging \nfrom tra\u00additional enterprise platforms to mobile devices, embedded systems, real time systems, and safety \ncritical systems. General middleware design is particularly challenging be\u00adcause no assumptions can be \nmade about the speci.c ap\u00adplication domain of the middleware, neither should its ar\u00adchitecture be coupled \nwith any particular operating system or hardware platform. Consequently, generality, the de\u00adsigner s \nor vendor s interest to provide a set of commonly shared and reusable features, constantly wrestles with \nspe\u00adcialty, which represents the user s desire of having a tai\u00adlored middleware to .t her speci.c needs. \nOne solution to this dilemma is through multiple speci.cations and large product families. For example, \nwithin the common frame of CORBA technology, there is a proliferation of speci.cations such as CORBA, \nRealtime CORBA, Minimum CORBA, Data-parallel CORBA, and Fault-tolerant CORBA1, and a proliferation of \nvarious product lines in which each mem\u00adber is engineered for speci.c domains including realtime en\u00advironments, \nsmall memory devices, enterprise computing, and many others.2 Newer middleware technologies, such as \nJ2SE, J2EE, and J2ME, appear to have taken the same direction3 . A serious limitation of these solutions, \nin addi\u00adtion to the increased complexity of development and main\u00adtenance, is that they only provide a \n.xed set of options for users, and, as a result, imperatively partition the ap\u00adplication domains on behalf \nof the users. The mainstream of middleware implementations is heavyweight, monolithic and in.exible [9]. \n As many researchers have pointed out [9, 24, 25, 1, 21, 20], the e.ective solution to the problems described \nabove 1These speci.cation are collectively de.ned in [17] except for Data-parallel CORBA, which is located \nat http://www. omg.org/technology/documents/specialized corba.htm 2The IONA product line includes Orbix \nEnterprise, Orbix standard, Orbix mainframe and ORBacus. http://www. iona.ie/products/orbix.htm. The \nOpenFusion product line includes embedded edition, realtime edition, and en\u00adterprise edition. 3Runtime \nlibraries of Java provide a rich set of middleware functionality including RMI and CORBA. is to achieve \na high degree of con.gurability, adaptability and customizability in the middleware architecture. The \nul\u00adtimate goal is to customize middleware according to a spe\u00adci.c user need, a concrete usage scenario, \nand a particular deployment or runtime instance. In many existing middle\u00adware implementations, this goal \nis unattainable because, as our past analysis shows [41, 43], many middleware features do not exist in \nmodular forms and crosscut implementa\u00adtions of other functionalities. A majority of the current re\u00adsearch \ne.orts in alleviating the insu.ciency of modulariza\u00adtion aim at leveraging advanced programming models \nsuch as re.ection [27] and component frameworks [31]. Compo\u00adnent frameworks operate within the modularization \ncapabil\u00adities of conventional programming languages, therefore, can\u00adnot e.ectively address concern crosscutting. \nRe.ection, in addition to costly infrastructures, operates at a level of ab\u00adstraction above programming \nlanguages, which often makes it di.cult to write correct, easily readable and maintainable code. The \naspect oriented programming paradigm, on the other hand, treats crosscutting concerns as .rst-class en\u00adtities. \nExisting middleware applications of AOP [12, 16, 37] primarily focus on modularizing non-functional prop\u00aderties \n[13] as aspects and treat the middleware core as a monolithic building block. Our observations [41, 42, \n43] reveal that the poor modularization of crosscutting con\u00adcerns is an inherent phenomenon within this \nmonolithic core. By inherent we mean that the failure of modularizing certain middleware features is \nnot due to unwise design decisions but unavoidable using conventional programming paradigms. The implementations \nof these features do not have clear modular boundaries and are tangled among one another. We use the \nnotion feature convolution to de\u00adscribe the deep entanglement of these functionalities in the middleware \narchitecture. As a remedy to this implementation convolution problem, we propose the method of horizontal \ndecomposition (HD) and advocate the use of mixed-paradigms in middleware architectures. That is, we use \nconventional programming paradigms to provide generality: referring to a hierarchi\u00adcally decomposed architecture \nfor a minimal, specialized, and commonly shared core; and we use aspect oriented pro\u00adgramming to provide \nspecialty: referring to domain-speci.c properties, which can be composed as aspects. HD consists of a \nset of principles aiming towards the proper utilization of both paradigms in transforming the relationships \namong middleware functionalities from convo\u00adluted coupling to binary coupling. Our initial assessment \nof horizontal decomposition on a commercially deployed mid\u00addleware product shows that the primary functionality \nof middleware can be supported with a much more coherent and simpler architecture with over 40% code \nreduction and around 8% performance improvement as compared to its original implementation. In addition, \nnine major functional\u00adities ranging from various type supports to invocation styles become modular and \nselectable for customization. We are able to obtain over sixty 4 possible versions of the middle\u00adware; \nall through post-compilation transformations without changing a single line of source code. This paper \ndescribes our approach and makes the follow\u00ading contributions: 4This rough calculation is based on 6 \naspects and 26 possible combinations. 1. We present the convoluted implementation problem and describe \nthe loss of modularity when decomposing mul\u00adtiple orthogonal design concerns using conventional de\u00adcomposition \nmethods. 2. We develop the method of horizontal decomposition as a set of principles for guiding aspect \noriented decompo\u00adsition of large middleware systems in order to address the convoluted implementation \nproblem. Horizontal decomposition is a mixed-paradigm method exempli\u00ad.ed on the analysis of a speci.c \nmiddleware implemen\u00adtation. 3. We evaluate the e.ectiveness of the horizontal decom\u00adposition principles \nand show that a number of innate and non-trivial middleware features can actually be implemented as aspects. \nThis evaluation is performed through a case study of using aspect oriented refactor\u00ading on an industrial-strength \nCORBA implementation. 4. We provide a comparison of the refactored implemen\u00adtation to its original non-refactored \ncounterpart th\u00adrough both structural metrics and runtime evaluation using a third-party performance benchmarking \nsuite. This constitutes a quantitative evaluation of the e.ec\u00adtiveness and bene.ts of the horizontal \ndecomposition principles.  The rest of the paper is organized as follows. In the next section, we brie.y \nde.ne middleware, describe the recent architectural challenges, and introduce the adopted aspect language: \nAspectJ5. We then present the problem of feature convolution in Section 3. In Section 4 we develop the \nprinci\u00adples of horizontal decomposition and discuss these principles in light of middleware architecture \ndesign. Section 5 exer\u00adcises the principles through the refactoring of a production strength CORBA implementation. \nA quantitative evalua\u00adtion of the approach is presented in Section 6. A thorough discussion of related \nwork is deferred to Section 7 to better position our work next to related approaches.  2. BACKGROUND \n2.1 Middleware and Its Challenges The term middleware has various interpretations. In this work, we focus \non middleware that facilitates the devel\u00adopment of distributed systems in a heterogeneous networked environment. \nExamples of these kinds of middleware imple\u00admentations include CORBA, Java RMI, and .NET remot\u00ading. All \nof these are based on transparent remote proce\u00addure calls for providing a simpli.ed network programming \nmodel. In recent years, in addition to traditional enterprise systems, middleware systems are being adopted \nin many emerging platforms such as routers6 , combat control sys\u00adtems [11], and wireless devices [6]. \nThe new design require\u00adments introduced by these platforms have catalyzed the fast evolution of middleware \nfunctionality and, in the mean time, created many problems for its architecture. Firstly, the structural \ncomplexity of middleware architecture increases 5AspectJ. URL: http://www.eclipse.org/aspectj 6Cisco \nONS 15454 optical transport platform uses CORBA to deal with hardware customizations and communications \nbetween the management software and hardware drivers. Figure 1: The Evolution of JacORB In Both Size \nand Modules. dramatically. For example, as in Figure 1, the numbers of classes in JacOrb7 , an open source \nCORBA implementa\u00adtion in Java, increased around 50% in a development time of approximately four years. \nIts size has tripled during the same time. Secondly, in spite of the enriched functionality, the typical \nruntime of middleware platforms requires more and more computing resources, such as CPU, memory and power. \nFor example, the minimum runtime of ORBacus Java8 , an industrial strength implementation of CORBA, requires \naround 10MB of memory. The C based CORBA implementation ORBit9 requires around 2MB of memory space. This \nhas become the main concern for using mid\u00addleware systems on platforms with stringent resource con\u00adstraints. \nFor example, the typical memory space of newer wireless mobile devices is on the order of tens of mega-bytes \nwith battery power of a few days10 . In these cases, middle\u00adware systems are typically re-designed and \nseparately imple\u00admented, and, at the same time, become too resource aware to satisfy enterprise computing \nneeds. 2.2 Vertical Decomposition We use the term vertical decomposition to denote the hierarchical \ndecomposition of code modules advocated by many pioneers of software architecture including Dijkstra \n[10] and Parnas [28]. Hierarchical decomposition is based on levels of abstractions and step-wise re.nements \nto divide\u00adand-conquer complex problems. Hierarchical decomposition is mostly suitable for implementing \na single independent function and performing a single logical task [3]. However, the drastic di.erences \namong aspects of complex systems are inherent and permanent, not mere artifacts of our cur\u00adrent ways \nof doing things. [39]. The rest of the paper uses the terms veridical decomposition and hierarchical \nde\u00adcomposition interchangeably.  2.3 Aspect Oriented Programming Aspect oriented programming o.ers a \nnew paradigm for software development by complementing conventional pro\u00adgramming paradigms with a higher \ndegree of separation of concerns. Examples of aspects, often simply referred to as a system s ilities \n[13], include security, reliability, man\u00adageability, and, further, non-functional requirements. The existence \nof aspects is attributed to the use of the vertical 7JacORB http://www.jacorb.org 8ORBacus: http://www.orbacus.com \n 9ORBit. URL:http://www.gnome.org/projects/ORBit2/ 10Motorola A760 supports 32MB of memory http://www. \n gsmarena.com/motorola a760-392.php decomposition paradigm to handle crosscutting concerns in software \narchitecture. AOP overcomes this limitation by providing new language level constructs to modularize \ncross\u00adcutting concerns. The development of an aspect oriented ap\u00adplication is commonly supported by a \ncomponent language, such as Java or C, to implement the primary decomposition of a system; by an aspect \nlanguage, such as AspectJ11 and Hyper/J12, to modularize crosscutting concerns as aspects; and also by \nthe aspect weaver (a.k.a., aspect complier) that instruments the component program with aspect programs \nto produce the .nal system. AspectJ is one of the most ma\u00adture aspect languages. In addition to conventional \nJava lan\u00adguage features, AspectJ de.nes a set of new language con\u00adstructs to modularize crosscutting \nconcerns. For instance, a join point represents a well-de.ned point in the execution .ow of the component \nprogram at which the AspectJ code can be executed. A pointcut construct denotes a collection of join \npoints. For example, cflow,a pointcut construct, taking the de.nition of another pointcut, Pointcut, \nas its argument, picks out each join point in the control .ow of any join point P picked out by Pointcut, \nincluding P it\u00adself 13 . AspectJ code can be executed before, after or in place of the program execution \nwhen a join point is reached. These actions are de.ned using AspectJ speci.c constructs before, after, \nand around. These constructs are called ad\u00advices. An aspect module in AspectJ contains pointcuts and \nthe associated advices. It also contains inter-type declara\u00adtions, which are used to declare new members \n(.elds, meth\u00adods, and constructors) in other types or to change Java type hierarchies.   3. THE IMPLEMENTATION \nCONVOLUTION PROBLEM The implementation convolution problem refers to the phenomenon that, for a large \nnumber of non-trivial mid\u00addleware functionalities, although their semantics are dis\u00adtinctive, their implementations \ndo not have clear modular boundaries within the middleware code space and, more se\u00adriously, often tangle \nwith one another. This prohibits these functionalities from being pluggable. Let us further exem\u00adplify \nthis problem through CORBA [17] and its two common features, portable interceptors and the dynamic program\u00adming \nstyle14 . Figure 2 illustrates the convolution among these two features as well as with the remote invocation \nmechanism, exempli.ed using classes from ORBacus. The class types are represented as vertical bars, of \nwhich the heights represent implementation sizes of these types. The .gure shows that the implementation \nof the original client invocation mechanism (types Downcall and DowncallStub) becomes more complex with \nthe additive code for address\u00ading two other features, depicted as intermingled shades. Two additional \nclass types are also created to implement the re\u00adlationships among these three design concerns. Figure \n3 shows implementation convolution in an actual ORBacus  11AspectJ http://www.eclipse.org/aspectj 12Hyper/J \nhttp://www.alphaworks.ibm.com/tech/hyperj 13The AspectJ Programming Guide. URL:http://www. eclipse.org/aspectj/. \n14Interceptors are standardized callback mechanism in CORBA to allow the registration of additional CORBA \nser\u00ad vices. The dynamic programming style refers to the re.ec\u00ad tive invocation mechanism of CORBA.  \nFigure 2: Implementation Convolution in ORBacus. code snippet. In this short piece of code, three concerns \nare present: places 3 and 5 deal with interceptors, 2, 4, 6, and 8 with oneway calls which will be discussed \nin detail in later sections, and 1, 7 with support for both interceptors and the dynamic programming \nstyle. This type of problem is not due to the design limitations of ORBacus. Our examination of three \ndi.erent CORBA implementations [41, 43] shows that around 50% of the classes coordinate with a second \ndesign concern. Moreover, 10% of these classes coordinates with three and more concerns. The phenomenon \nof crosscutting arises whenever two properties being programmed must compose di.erently and yet be coordinated \n[23]. We ex\u00adtend this AOP term and use implementation convolution to describe this large scale N-by-N \ncrosscutting phenomenon. Implementation convolution means the loss of modularity and con.gurability. \nIt also incurs runtime overhead since, in a particular middleware deployment or runtime instance, not \nall functionalities are required to participate in the main operational logic of the middleware. However, \nthese func\u00adtionalities still exist in forms of class variables, method argu\u00adments, and branching conditions, \nwhich constitute parts of the overall execution path, the application memory space, and the program control \n.ow. For example, although the asynchronous oneway invocation semantics is not used in many CORBA applications, \nit is not yet possible to .exibly load or unload this feature in today s middleware architec\u00adtures due \nto, as illustrated above, its non-modular imple\u00admentation. To enable customizability of this feature, \nits implementation must be separately modularized outside of the middleware core. But before proceeding \nto this action, it is necessary to answer two fundamental questions: 1. Why should a particular functionality, \nsuch as oneway, be treated as an aspect? 2. What steps are required to untangle convoluted fea\u00adtures? \n The next sections are devoted to answers of these ques\u00adtions. Figure 3: Convoluted Code: Interceptor, \nDII and oneway, all tangled together.  4. HORIZONTAL DECOMPOSITION 4.1 Overview of Horizontal Decomposition \nThe goal of horizontal decomposition (HD) is to achieve a mixed-paradigm architecture in which the conventional \nde\u00adcomposition methods and the aspect oriented approaches are used together, each addressing a di.erent \ncategory of functionalities with its maximum strength. Horizontal de\u00adcomposition comprises a set of guidelines \nto, .rstly and most importantly, distinguish aspect functionalities from non-as\u00adpect ones in order to \nlay out clear responsibilities for AOP and, secondly, to enable super-impositional architectures. By \nsuper-imposition we mean that, in the context of hor\u00adizontal decomposition, implementations of aspects \ncan be transparently applied onto a generic core through the weav\u00ading process to achieve the desired \ncustomization of middle\u00adware functionality. We use the term horizontal to empha\u00adsize its complementarity \nand its synergistic co-existence with the vertical decomposition. In the rest of this section, we .rst \nabstractly present and discuss the HD principles. We then discuss the principles application within the \ncontext of middleware architecture. In Section 5, we implement and validate the principles through a \nrefactoring based aspect oriented middleware architecture approach.  4.2 Horizontal Decomposition Principles \nThe horizontal decomposition method consists of .ve prin\u00adciples synthesized from our past experience \n[41, 42, 43] and the ongoing application of AOP to middleware architecture. These principles are listed \nfollowing a logical order in which they can be sequentially applied. Principle 1: Recognize the relativity \nof aspects. The semantics of an aspect is determined by the primary func\u00adtionality of the application. \nFrom the de.nition of concern crosscutting, the semantics of an aspect can only be determined with respect \nto the primary function of the application. For example, logging, a well known crosscutting concern, \ndoes not crosscut the logging facilities itself. A further example draws from mid\u00addleware implementations \nthat specializes in making remote invocations; there, the e.cient invocation of local servers is recognized \nas a crosscutting concern (cf. Section 4.3). However, in the context of non-distributed applications, \nthe remote invocation mechanism can be implemented as an as\u00adpect [35]. We use these examples to highlight \nthe possible ambiguity for the semantics of aspects in large and complex systems. This ambiguity should \nbe clari.ed as much as pos\u00adsible because we believe aspects and non-aspects ought to be handled in di.erent \nways. The recognition of the rela\u00adtivity property is the .rst step of applying aspect oriented decomposition. \nPrinciple 2: Establish the coherent core decompo\u00adsition. The basis of aspect oriented decomposition is \nthe establishment of a functionally coherent and vertically de\u00adcomposed core. Cohesion, .rst introduced \nin [38], expresses the degree of as\u00ad sociation between components in a module. Among the mul\u00adtiple levels \nof cohesion, the most desired level is functional cohesion where every function within a module contributes \nto directly performing a single task [3]. The semantics of aspects has to be discussed with respect to \nan architecture which, ideally, should be functionally coherent and does not contain convoluted features. \nWe refer to this referential ar\u00adchitecture as the core decomposition, or just simply core . In large \nsoftware systems, such as middleware, the core con\u00adsists of several conceptual components [36]15 . Each \nof the components focuses on a single task and they are logically coherent in supporting the primary \nsystem functionality or its most typical usage. For this reason, it is minimal and simplistic. For example, \nsince the primary functionality of a telecommunication system is call processing, its core is the basic \ncall processing system excluding features such as call waiting or call forwarding [40]. Our de.nition \nof a core has the following two bene.ts: 1. It is easier to obtain e.cient hierarchical decompositions \nif the system only supports a limited number of functionalities. 2. Since the core cap\u00adtures the most \nessential functionality of a software system, we can use it as the basis for further customization. Principle \n3: De.ne the semantics of an aspect ac\u00adcording to the core decomposition. Using the core as a reference, \na functionality is considered orthogonal if both its semantics and its implementations are not local \nto a single component of the core. Only the orthogonal functionality is treated in the aspect oriented \nway. Our de.nition of aspects is more aggressive and more precise as compared to ilities [13], quality-of-service \n(QoS) require\u00ad ments [12], or general distributed computing concerns [4]. For instance, the customization \nof communication protocols could be described as both an ility (customizability) and a distributed concern, \nand, hence, could be classi.ed as an as\u00adpect. However, it is not an aspect by our de.nition because its \nsemantics are likely local to the communication compo\u00adnent of the application. In practice, techniques \nsuch as com\u00adponent frameworks can con.ne this customization within the protocol layer of the architecture \nas in the OCI plug-in framework used by ORBacus and the ACE framework16 . On the other hand, the asynchronous \ninvocation style of middle\u00ad 15In this paper, we use the term component in short for conceptual component. \nA conceptual component can be mapped to one or more physical components. 16The Adaptive Communication \nFramework. URL: http: //www.cs.wustl.edu/~schmidt/ACE.html ware (i.e., oneway semantic), however, is \nan aspect because it requires not only the non-blocking support from communi\u00adcation protocols and additional \nrequest processesing routes but also the corresponding programming model in the ser\u00advice description \nlanguage. Studies on AOP implementation of design patterns [18] show that certain concerns are better \naddressed by conventional techniques than by AOP, and vice versa. It is then crucial to avoid ambiguity \nof the seman\u00adtics of aspects as much as possible in order to maximize the modularization capabilities \nof both vertical decomposition and the AOP paradigm. Principle 4: Maintain a class-directional architec\u00adture. \nCrosscutting concerns should be implemented class-di\u00adrectional towards the core. Class-directional is \na category of relationships between base modules (classes) and aspects in which aspects know about the \nclass but not vice-versa [22]. Class-directional in HD means the system core does not have the knowledge \nof aspect implementations. Our previous work shows that middleware aspects, such as the interception \nsupport and the dynamic invocation semantics, can be completely separated from the core implementation \nand transparently super-imposed back [41, 43]. Later in this paper, we show that maintaining class\u00addirectional \ncan even be achieved for crosscutting concerns of a much larger scale. The property of class-directional \ndoes imply a strong dependency of aspect implementations on a fairly stable architecture of the core. \nThis is because, if the model of the core architecture evolves too quickly over time, the semantics of \nan aspect has to be modi.ed correspond\u00adingly due to the relativity principle. However, we believe a stable \ncore architecture is a natural outcome of the hori\u00adzontal decomposition. With a single or a few design \ngoals, the architecture tends to be focused and stable. Design pat\u00adterns [15] are excellent examples \nof stable architectural ideas being repeated many times for specialized problems. Principle 5: Apply \nincremental refactoring. Decom\u00adposition in the aspect dimension is assisted by incremental refactoring. \nThe establishment of the coherent core often requires a se\u00adries of re.nements. There are at least two \nreasons for this to happen. First, the identi.cation of the core in complex systems is not always straightforward \nand could be com\u00adpleted gradually. Second, the composition of the core can be viewed at di.erent levels \nof granularity. In other words, a functionality well localized within a single component can become scattered, \nhence, crosscutting, if this component is further factored into several parts. The re.nements of the \ncore semantics can result in the discovery of new aspects, and refactoring must be performed to resolve \ntheir convo\u00adlution with the newly established core as well as with the code of existing aspects. For \nexample, during our resolu\u00adtion of the convolution presented previously in Figure 3, it had not occurred \nto us that oneway is an aspect until after DII and PI were already refactored. Two types of refactor\u00ading \nwere then performed: 1. Re-factorization of oneway out of the core; 2. Re-factorization of oneway out \nof aspect DII and aspect Interceptor Support. We refer to these two types as the .rst and second degree \nrefactoring. The horizontal decomposition is, hence, conducted in an incremental and accumulative fashion. \nWe illustrate this process further in Section 5.3.2.  4.3 Application to Middleware Architecture In \nthis section, we further explain the horizontal decom\u00ad position principles through a discussion of their \napplication to the aspect oriented analysis of the middleware architec\u00ad ture. This analysis is carried \nout in the following logical steps: Middleware aspects are relative to the primary function\u00ad ality of \nmiddleware. (Principle 1) The relativity principle prescribes that the semantics of an aspect must be \ndiscussed within the context of the application, i.e., in our case, the middleware architecture itself. \nTherefore, we oriented our\u00ad selves, prior to the detailed analysis, as follows: we .rst de.ne the primary \nfunctionality of middleware as the sup\u00ad port for transparent remote invocation; we then de.ne a middleware \naspect as a middleware feature that crosscuts the implementation of this functionality. The middleware \ncore consists of a set of components that support transparent remote invocations. (Principle 2) To establish \nthe basis for the semantics of middleware aspects, we .rstly de.ne the middleware core as the mechanism \nof composing, transporting, and dispatching invocation requests in enabling transparent remote invocations. \nThis mech\u00ad anism is supported by service description languages and the associated stubs/skeletons, service \nidenti.cation mech\u00ad anism, request dispatching mechanisms, and transport pro\u00ad tocols. Table 117 gives \nconcrete examples of these compo\u00ad nents in popular middleware implementations. Since remote invocations \nare emulated as normal method calls, the mid\u00ad dleware core also needs to support various data types in \nthe description languages, synchronous/asynchronous com\u00ad munications, and statically or dynamically typed \nrequests. We aggressively simplify the middleware core to only sup\u00ad port one primitive type, the synchronous \ninvocation style, and the statically typed requests. All other functionalities are treated as customization \noptions. Middleware aspects are features that cannot be encapsu\u00ad lated within an individual component \nof the core decompo\u00ad sition (Principle 3). Let us further exemplify this concept using the CORBA feature \nof server collocation as an ex\u00ad ample. One of the drawbacks of transparent remote invo\u00ad cation is that \nthe location of the remote service is hidden and could be in the same process as the client. A common \noptimization is that middleware transparently detects this situation and directly dispatches the request \nwithout going through the network layer. In the ORBacus implementa\u00ad tion of CORBA, a normal remote invocation \ntraverses the middleware stack in the following logical order (Figure 4): client marshalling of data, \nthe transport of data in the pro\u00ad tocol layer, server dispatch of the request, and server un\u00ad marshalling. \nFigure 5 illustrates the invocation sequence when this optimization is added. Not surprisingly, the se\u00ad \nquence becomes more complex. This optimization creates a logic glitch because the client request traverses \ninto the dispatch layer , a server side component (Figure 4), inside the Protocol layer at the client-side. \nThe hallow arrows represent program logic corresponding to the optimization, and the shaded boxes represent \nthe activities spent in per\u00ad forming the optimization. It is not hard to conclude that the Local Invocation \nOptimization is an aspect because it 17In this table, ROT refers to Running Object Table. http://msdn.microsoft.com/library/en-us/dndcom/ \n html/msdn dcomarch.asp.  Figure 4: Remote Invocation: ORBacus requires the collaboration among three \ncomponents: Mar\u00adshalling, Protocol, and Dispatch. It is noteworthy that this optimization only addresses \nin-process servers. Adding fur\u00adther optimizations for in-host servers undoubtedly compli\u00adcates the picture \neven further. Two main disadvantages for this implementation can be completely overcome if modu\u00adlarized \nin aspects instead: 1. The implementation scatters around di.erent parts of the core architecture which \nmakes it hard to understand and change. 2. The inability of plug\u00adging out this feature incurs redundancy \nin the execution of remote method calls. The implementation of middleware aspects are class-di\u00adrectional \nand super-impositional. (Principle 4) We char\u00adacterize super-impositional middleware architecture as \nfol\u00adlows18: 1. Multiple sets of vertical decompositions: As will be de\u00adscribed in Section 5.3.1, we distinguish \nthe functional\u00adity of an aspect from its crosscutting interaction with the core. The core of the application \nand the function\u00adality of aspects are separately decomposed into vertical hierarchies of modules. Each \ncan be compiled indepen\u00addently. The core decomposition is fully operational in supporting the primary \nfunctionality of the applica\u00adtion. 2. Exclusive application of AOP to the crosscutting logic of an aspect: \nThe crosscutting logic is the interaction between the functionality of an aspect with both the core and, \nif necessary, other aspects. This interac\u00adtion is the only place where AOP is applied, and we metaphorically \nrefer to the architecture of the interac\u00adtion as the glue architecture. 3. Flexible combination of architectures: \nThe goal of the super-impositional architecture is that the combina\u00adtion of the middleware core and aspect \nfunctional\u00adity is .exible and conducted at the post compilation stage, e.g., through source code transformation \nas in AspectC++19, or bytecode weaving as in AspectJ, or  18By super-imposition we mean that, in the \ncontext of horizontal decomposition, implementations of aspects can be transparently applied onto a generic \ncore through the weaving process to achieve the desired customization of middleware functionality. 19AspectC++ \nhttp://www.aspectc.org CORBA DCOM .NET Web Services Description Language IDL MIDL C#,CLR languages Identity \nPublication IOR OBJREF WSDL File Request Dispatching POA ROT ASP.NET process Protocol IIOP Object RPC \nSOAP Table 1: Core Middleware Architecture Elements. Figure 5: Addressing Remote and Local Invocations \nSimultaneously in ORBacus. even runtime weaving [44]. Therefore, the glue ar\u00adchitecture of an aspect \nmust address its interactions with the core and other aspects individually. This is a desired property \nbecause it reduces the complexity of the implementation from a convoluted relationship to a set of binary \nrelationships. We show in later sections that this super-impositional ar\u00adchitecture for middleware can \nbe achieved. We do have to modify how certain core semantics are expressed in the code in order to obtain \nthe necessary contexts in AspectJ pointcuts. However, none of the modi.cations change our core decomposition \nmodel, and, secondly, this might be a language-speci.c phenomenon of AspectJ. Middleware aspects are \nimplemented incrementally. (Prin\u00adciple 5) Re.nements of the de.nition for the core decom\u00adposition give \nrise to the identi.cation of new aspects. To alleviate this problem, we use both the .rst and the sec\u00adond \ndegree refactoring to separate new aspects from both the middleware core and previously identi.ed aspects. \nOur experience shows that the second degree refactoring, con\u00adtrary to intuition, does not cause major \nchanges to existing aspect code. This is because many aspects identi.ed and implemented at early stages \nmainly crosscut the core within the body of procedures. We refer to these aspects, such as logging, tracing, \nand certain type manipulations, as code\u00adlevel aspects in contrast to the architectural aspects, which \ncrosscut the middleware core at the level of attributes and methods. The .rst degree refactoring of these \naspects, such as dynamic programming styles, typically involves pruning core objects at the method level, \nwhile preserving most of the intra-procedural interactions or pointcuts of the code\u00adlevel aspects.  \n 5. RE-FACTORING BASED IMPLEMENTATION OF HORIZONTAL DECOMPOSITION We choose to use the technique of refactoring \n[14] to eval\u00ad uate the horizontal decomposition principles. We use refac\u00adtoring since it conveniently \nallows us to focus on modular compositions through the re-use of design decisions and to systematically \nand fairly compare horizontally decomposed middleware with its conventional counterpart. With no loss \nof generality, we use CORBA, one of the most developed middleware technologies, as a case study, and \nORBacus, an industrial strength Java CORBA implementation, as the target of our re-implementation. The \nAOP language we choose is AspectJ. We have identi.ed and refactored a total of nine major functionalities \nas aspects in ORBacus. Most of them can also be found in other CORBA or even non-CORBA middleware systems. \nOur implementation shows that horizontal decomposition can deliver its promise. We have obtained a much \nmore concise and e.cient middleware core which, at the time of writing this paper, exhibits around 8% \nimprovement in benchmark performance and over 40% reduction in code size, with ample room for further \nimprove\u00adments. In addition, we have a super-impositional architec\u00adture in which combinations of these \nnine aspects can be freely selected to form new versions of ORBacus supporting both the core functionality \nand the aspectual functionality. In the following sections, we describe our implementation in detail \nand present the evaluation results. 5.1 De.ning the Middleware Core Our reference model of the ORBacus \ncore consists of the following layers listed top-down. in accordance with Table 1. Each layer performs \none speci.c task. Identity publication is a specialized CORBA operation. The corresponding imple\u00admentation \nin ORBacus is compact and coherent and, hence, omitted from the list. 1. IDL Layer: Stub and Skeleton. \nThe function of stubs and skeletons, generated from a service descrip\u00adtion language, is to support the \nmasking of remote invo\u00adcations as local method calls at the interface level. They are common middleware \nelements serving as translators be\u00adtween application semantics and the middleware substrate. Our working \nde.nition of minimum stubs and skeletons only supports statically typed invocations, the synchronous \ninvo\u00adcation style, and the IDL de.nitions for essential primitive data types such as integer. In other \nwords, the descrip\u00adtions of advanced features are not enabled by default. These features include: advanced \ndata types such as Any, multi\u00adbyte characters, invocations through re.ection such as DII or DSI, the \nasynchronous invocation style denoted by the oneway keyword in CORBA s IDL. These features are wo\u00adven \ninto the stubs and skeletons by an aspect-aware IDL compiler [42]. 2. Messaging Layer: Client-side and \nServer-side. This layer consists of two conceptual components: the client\u00adside downcall mechanism responsible \nfor marshalling the requests and the server-side upcall mechanism responsible for unmarshalling and request \ndispatching. Corresponding to our de.nition of the minimum skeleton and stub, the downcall and upcall \nmechanisms should only support primitive data types, synchronous and statically typed in\u00advocations. 3. \nTransport and Protocol Layer. This layer handles the communication with peer ORBs using IIOP. ORBacus \nimplements the Open Connector Interface (OCI) (i.e., plug\u00adgable transports) based on acceptors and connectors \n[30]. We de.ne this layer to only support the synchronous com\u00admunication and no interoperability with \ndi.erent code sets (i.e., character encoding schemes.) We do not claim that this core model is crosscutting \nfree. Each component can be further broken down into .ner log\u00ad ical constituents. Nevertheless, it is \ncoherent enough for us to apply AOP to a large number of ORBacus features.  5.2 De.ning CORBA Aspects \nAs previously stated, a middleware functionality can be classi.ed as an aspect if it interacts with multiple \ncom\u00adponents. Below, with omission of the internal details of CORBA, we summairze the logical independence \n(orthog\u00adonality) of .ve aspects, their functional intend (semantics), and characterize their original \ncrosscutting implementation. I Oneway invocation semantic. Semantics: Supports the best-e.ort and asynchronous \ndelivery of client requests. No response is expected. Orthogonality: The core supports the synchronous \ninvocation semantic. Crosscutting: IDL Layer: The support of IDL key\u00adword oneway . Messaging Layer: Additional \nlogic in the downcall process for not expecting a response as well as in the upcall process for no need \nto issue a response. Protocol Layer: The support of GIOP en\u00adcoding of the oneway .ag as well as the setting \nof a timeout value for the socket. II Dynamic typing. Semantics: Supports re.ective composition of remote \ninvocations. Any and Dynamic Any (DynAny) are used to represent arbitrary IDL data types including primitive \ntypes and abstract ones. Typecode is used to encode the type information Orthogonality: The core supports \nstatically typed invocation requests. Crosscutting: IDL Layer: The support of dynamic IDL data types \nsuch Any, Dynamic Any and the as\u00adsociated stub/skeleton operations. Messaging Layer: The marshaling and \nunmarshalling of these data types. Protocol Layer: None. Data is treated as byte streams. III The wchar \nand wstring support. Semantics: Supports the expanded character sets such as Unicode20 . Orthogonality: \nWe view IDL data types as inde\u00adpendent, hence, orthogonal ways of encapsulating and interpreting the \ntransported bytes. Crosscutting: IDL Layer: The support of wchar and wstring IDL data types and the associated \nstub/skeleton operations. Messaging Layer: The marshalling and unmarshalling of these data types. Protocol \nLayer: None. This layer treats all data as byte streams. IV The encoding conversion. Semantics: Supports \ntransparent conversions for the data exchange, as part of the interoperability support of CORBA, if the \ncommunicating ORBs use di.erent character encoding schemes. Orthogonality: The functionality of managing \ndif\u00adferent character encoding schemes is clearly logically independent of the semantic of the CORBA core \nwhich manages transparent remote invocations. 20Unicode. URL: http://www.unicode.org Crosscutting: \nIDL Layer: None. The functional\u00adity is transparent to applications. Messaging Layer: Adding logic to \nboth downcall and upcall pro\u00adcesses as to decide if conversion should take place when reading and writing \ncharacters to the data bu.er. Pro\u00adtocol Layer: Adding logic to the server side protocol layer which builds \nthe conversion schemes for an in\u00adcoming request based on the encoding information in GIOP, before passing \nit up to the messaging layer. V The local invocation support. Semantics: Supports direct forwarding of \nrequests if the remote service is located in the same process. Orthogonality: Local invocation is logically \northog\u00adonal to remote invocation functionality of the CORBA core. Crosscutting: Please refer to Figure \n5 for details. Concluding from the analysis presented above, these cross\u00adcutting features have both \ndesign and runtime implications. Their implementation is scattered and, thus, hidden . It is hard for \nprogrammers to change and to maintain them. Though often optional in normal operations of CORBA, these \nfeatures are always initialized and evaluated during the execution. This runtime redundancy degrades \nthe per\u00adformance of the core as con.rmed by our evaluation. Re\u00adcent dynamic compilation techniques can \nprovide solutions to eliminate runtime redundancy. However, more coherent application semantics are always \nmore e.ective in perfor\u00admance improvements.  5.3 Resolving Implementation Convolution The goal of our \naspect oriented treatment is to eliminate the convoluted features in the original code base through modularizing \northogonal functionality as aspects and un\u00adtangling of the code convolution among aspects themselves. \nThe next two sections provide detailed descriptions of these two stages. 5.3.1 Implementing Middleware \nAspects Our implementation of middleware aspects generally con\u00adsists of two distinct parts: the implementation \nof the aspect functionality itself, which is best handled in a hierarchical decomposition; and the implementation \nof the interaction between this aspect and the core, which is decomposed in the aspect oriented way. \nFor example, the complete implemen\u00adtation of the support for codeset conversion, as illustrated in Figure \n6, consists of the implementation of its functionality (left) and of its crosscutting logic with the \ncore (right). Its functionality is decomposed into a normal Java class hierar\u00adchy which embodies the \nbasic design rational of composing a converter from both a Reader and a Writer . The hierar\u00adchy of the \ncrosscutting logic consists of three aspects repre\u00adsenting three di.erent parts of the crosscutting logic \ninclud\u00ading the conversion of character streams, the setup of conver\u00adsion utilities, and the error handling \nregarding conversions. Figure 7 shows a speci.c implementation instance in sup\u00ad porting conversion of \ncharacter streams. The area enclosed by the dotted box in the original implementation (left) rep\u00adresents \nthe crosscutting logic and it is re-implemented as an around advice (lower-right). This advice, when \nwo\u00adven into the core implementation by the AspectJ compiler, Figure 6: Aspect Implementation of Character \nCon\u00adversion. replaces calls to the method InputStream.read char as fol\u00adlows: it proceeds to the normal \nread char call (upper-right) if conversion is not necessary; otherwise it creates a con\u00adverter and performs \nconversion before returning. With this we have achieved a dramatic simpli.cation of the original core \nimplementation, read char, as well as the preservation of its functionality together with the aspect \ncode. The separation of functionality and crosscutting logic, com\u00adbined with refactoring, bene.ts us \nin the following ways: 1. The original design choice is fully respected and pre\u00adserved. There is no shifting \nof programming paradigms in implementing the functionality of aspects. Hence, the domain expertise embedded \nin the design is left intact. Even for new implementations, our approach places no restrictions on the \nuse of the vast and rich repertoire of vertical design techniques such as design patterns. 2. The crosscutting \nlogic is isolated and, therefore, can be conveniently analyzed for the discovery of implementa\u00adtion patterns. \nBy patterns we mean the concerns com\u00admonly addressed while implementing the crosscutting logic. We describe \nsome of the patterns we observed from our initial implementation later in this section. 3. The separation \nof the aspect functionality and its cross\u00adcutting logic is explicit and can be completely decou\u00adpled. \nSimilarly to the advantage of separating an inter\u00adface and its implementation in the objected oriented \nparadigm, we believe this separation is fundamental in supporting the plug-and-play of new aspects such \nas a new invocation style or a new character encod\u00ading scheme. However, a thorough exploration of this \nproperty is outside the scope of this paper.  We feel that a good decomposition of the crosscutting \nlogic is the most challenging task in horizontal decomposition. Deferring a more serious analysis and \nformulation to our fu\u00adture research, we summarize our experience as observations of commonly addressed \ncrosscutting logic patterns in our implementation of aspects: 1. Lifecyle. Lifecyle crosscutting intercepts \nthe set-up and the tear-down stages of the core and performs the ini\u00adtialization and the destruction \nof aspect-speci.c utilities. This crosscutting pattern is present in all aspects except oneway which \ndoes not have the functionality implemen\u00adtation. Because of this temporal relationship, this type of \ncrosscutting logic is commonly implemented in before and after advices. 2. Data. Data crosscutting enables \ndi.erent views of the same data stream by adding APIs to di.erent components of   Figure 7: Implementation \nof Crosscutting Logic: Code Example. the core. These APIs support the instantiation of new data types, \nconversions between streams and data types, and con\u00adversions between di.erent data types. Aspects that \nheavily exhibit this type of logic crosscutting include dynamic types, the wide character support, and \ncodeset conversion support. Data crosscutting is mostly implemented as methods which are woven into the \nclass de.nition of the core classes via the inter-type declaration mechanism of AspectJ. 3. Error. Error \ncrosscutting augments the error han\u00addling mechanism of the core with that of the aspect. It primarily \ninvolves adding aspect-speci.c error codes and de\u00adscriptions using inter-type declarations. It also involves \nthe validation of the states of aspects prior or posterior to core method calls. These checks are naturally \ncaptured in before and after advices of AspectJ. This crosscutting logic can be found in all the aspects. \n 4. Messaging. Messaging crosscutting alters the normal invocation sequence of the core to support di.erent \ninvoca\u00adtion styles. This type of crosscutting logic is usually found in aspects that add alternative \ninvocation paths to the core components, and, hence, does not have any aspect-speci.c functionality implementation. \nThe implementation of as\u00adpects, such as oneway , extensively uses the control-.ow join points of AspectJ, \nsuch as cflow and cflowbelow.   5.3.2 Untangling Convoluted Aspects As previously described, aspects \ncan also crosscut each other in supporting a complex functionality in middleware implementations. We \nhave depicted such a scenario in Fig\u00adure 3 in which three aspects, interceptor support, the dy\u00ad namic \nrequesting style, and oneway, are convoluted in pro\u00adviding interceptable-dynamic-oneway requests. Let \nus use this same example to illustrate how convoluted implemen\u00adtations can be resolved. Figure 8 shows \nsimpli.ed code snippets of our resolution. The aspect code snippet 1 only deals with DII by adding a \nmethod createDIIDowncall to the core class DowncallStub (line 2) for the creation of a DII downcall using \nan inter-type declaration. Code snip\u00adpet 2 uses AspectJ s capability of return-value modi.cation, after \nreturning (line 1), and changes the return value of createDIIDowncall to its subtype PIDIIDowncall (line \n7) if interception is enabled (line 3). Code snippet 3 uses the same return-value modi.cation feature \nto set the response-Expected .ag of the Downcall to either true or false de\u00adpending on whether the request \nis marked oneway or not in the global hashtable (line 8). We have improved over the original implementation \nwith better cohesion as each code snippet in Figure 8 is specialized in providing one par\u00ad ticular functionality. \nWe have also untangled a convoluted relationship into a set of simpler binary relationships: DII\u00adcore, \nPI-DII, and Oneway-DII. Through the use of the byte\u00adcode weaver, we can con.gure the following seven \nversions of ORBacus without touching the source code: Plain ORBa\u00adcus (CORE), CORE+PI (Portable interceptor), \nCORE+-DII, CORE+Oneway, CORE+PI+DII, CORE+PI+Oneway, CORE+DII+Oneway. We use the matrix in Table 2 to \nsummarize the convoluted relationships among the aspects that we have identi.ed so far. Each x in the \ntable means the row aspect crosscuts the column aspect. We also include three aspects identi.ed in our \nprevious work [41, 43], including portable interceptor support (PI), local invocation (LI), and the dynamic \npro\u00adgramming interface (DPI), as these relationships were not explored previously. We purposely leave \nout the core archi\u00adtecture since every aspect crosscuts the core by default. LI Conv Dyn DPI PI OW Wchar \nConv. x N/A x x x x Dyn x N/A x x x PI x N/A OW x x N/A Wchar x x x N/A Table 2: Convolution Matrix. \n(Conv: Conversion. Dyn: Dynamic Typing. OW: Oneway. CO: Collo\u00adcated Server. DPI: Dynamic Programming \nInter\u00adface. PI: Portable Interceptor. Wchar: Wide char\u00adacter and wide string). Stage A B C 1 PI, CO DPI \nDyn, Wchar, Conv, OW 2 OW Dyn, Wchar, Conv DPI, PI CO 3 Dyn Conv,Wchar CO, DPI, PI 4 Wch Conv Dyn, PI \n5 Conv CO, OW, PI, Dyn, Wchar Figure 8: Resolving convolution of aspects: Code Example.  5.4 Incremental \nDecomposition: A Retrospective It is hard to identify all aspects due to the di.culty of de.ning the \nconvolution-free core of the system. This is partly because of the limitations of existing aspect discov\u00adery \ntechniques and tools. It is also because the de.nition of the core architecture is not likely to be very \nprecise at the beginning of the decomposition process. Our experience shows that the de.nition of the \nminimal core is adjusted and re.ned gradually over time. Consequently, we contin\u00aduously discover new \naspects as our de.nition of the core architecture evolves. The complete untangling of new as\u00adpects involves \nboth their separation from the core and pre\u00adviously identi.ed aspects. Therefore, the complete aspect \ndecomposition model is obtained in an incremental fash\u00adion since each identi.cation of new aspects possibly \ntrig\u00adgers both .rst and second degree refactoring. Table 3 sum\u00ad marizes our decomposition process of \nthe aforementioned aspects retrospectively, where we list our implementation stages of aspects in a chronological \norder. For instance, our initial refactoring (Stage 1) starts with aspects Portable In\u00adterceptors (PI), \nDynamic Programming Interface (DPI), and Collocated Server (CO) listed in Column A while the other aspects \n(Column B) are yet to be identi.ed. The subsequent refactoring (Stage 2) of the oneway (OW) aspect involves \nTable 3: Incremental Decomposition of Aspects (A: Aspects being refactored. B: Aspects contained in core. \nC: Aspects being refactored in 2nd phase. Ab\u00adbreviations are the same as in Table 2. modifying not only \nthe core but also the three aspects in Column C (Row 2). This table shows that both the .rst and the \nsecond-degree refactoring play important roles in resolving the convolution. As the result of keeping \nno knowledge of aspects in the core, the architecture of the refactored ORBacus is self\u00ad contained. The \nbasic functionality of CORBA is preserved. In fact, our CORBA core coincidently fully supports all op\u00ad \nerations of a third-party benchmarking tool. Meanwhile, combinations of the horizontal features can be \nselected and transparently con.gured into the core architecture through di.erent build .les and the AspectJ \ncompiler 21 . There is no restrictions to the combinations except portable inter\u00ad ceptors, which requires \nthe support of type Any.  6. IMPLEMENTATION EVALUATION The emphasis of our evaluation is to measure \nhow well the principles of horizontal decomposition deliver their most important promise supporting \nthe core functionality of middleware more e.ciently in a much less convoluted archi\u00adtecture. We divide \nthe evaluation for our refactoring-based implementation into two parts. We .rst measure, using standard \nmetrics, the architectural changes over the orig\u00adinal implementation as the result of decomposing a number \nof major middleware features in aspect modules. We are interested in, while supporting the same core \nfunctionality, how much more concise middleware architecture has become with implementation convolution \nresolved. We then perform the performance evaluation by comparing the horizontally decomposed ORBacus \ncore with the original implementa\u00adtion in supporting a set of standard CORBA functionality provided using \na third-party benchmarking suite. 6.1 Structural Comparison To measure the structural di.erences, we \nemploy a set of standard software engineering metrics which we refer to as structural metrics. They are \nexplained in great detail in [41]. These metrics include the following: size of the executable source \ncode, cyclomatic complexity, weight of the class and e.erent coupling. We .rst measure the direct impact \nof horizontal decomposition on the entire ORBacus implemen\u00adtation, i.e., all classes in the com package \nhierarchy. This in\u00adcludes both the functionality of aspects and their interaction logic with the core. \nTable 4 shows that, by applying hor\u00ad izontal decomposition and stripping out crosscutting func\u00adtionalities, \nwe have reduced the size of the ORBacus core by 21The AspectJ compiler simply issues a warning for applying \naspects to un-found classes. around 10K lines or 42% of code, 855 or 35.6% fewer meth\u00adods, around 17% \nsimpli.cation in terms of the control .ow, and 22% reduction of coupling. This shows that, in spite of \nits rich set of functionality, the original implementation is monolithic and oversized for common CORBA \nopera\u00adtions. Our refactored version is much lighter and much more .exible for con.guration and customization. \nTable 5 presents a di.erent perspective for the resolution of the crosscutting logic in the ORBacus core \nclasses. We count the reduction of three types of language elements that have further runtime implications. \nThe reduction of argu\u00adments for methods and constructors not only allow the se\u00admantics of classes to \nbe expressed more concisely but also enables more energy-e.cient execution in power-stringent platforms \n[2]22 The reduction of conditional statements im\u00adproves branch predictions and achieves better cache \nperfor\u00admance. The reduction of attributes of classes simpli.es the runtime stack of programs and decreases \nthe memory foot\u00adprint of objects. Implementation Size CC WC EC Original Re-factored 23277 13524 3.69 \n3.05 2404 1549 2423 1899 Reduction 9753 0.64 855 525 Implementation Median Average None 157 203 Original \n167 221 All 180 238 Table 6: Invocation Cost in microseconds. Table 4: Reduction of Overall Structure. \n(CC: Cy\u00adclomatic complexity. WC: Weight of Class. EC: E.erent coupling).  6.2 Performance Evaluation \nThis section presents the benchmarking results collected on three versions of the OBRacus implementation: \nthe refac\u00adtored ORBacus core with aspects taken out (None), the original implementation (Original), and \nthe combined imple\u00admentation with all aspects woven back in via the AspectJ compiler (All). We use the \nOpen CORBA Benchmarking Suite (OCBS) [33] to provide a thorough comparison of the runtime performance \nof these three versions. OCBS mea\u00adsures the performance of the following CORBA functional areas: invocation, \nmarshalling, dispatching, parallelism, as well as combinations of these areas. All of the benchmark\u00ading \noperations are supported without modi.cation by both the original ORBacus implementation and our refactored \nversion at almost half of the original size. The tests are per\u00adformed on Pentium 4 2GHZ running Redhat \n8.0 with 1G of memory. 22Although the paper s analysis is based on Java systems, we believe, that our \ndiscussion is not limited to Java systems either. Aspect Arguments Condi\u00adtional Attri\u00adbutes Any &#38; \nTypeCode 0 8 2 Encoding Conversion 6 9 9 Oneway Call 8 7 1 Wchar &#38; Wstring 4 44 8 Total 18 68 20 \n Table 5: Reduction of Code Elements Caused by Crosscutting. Figure 9: Invocation Time Distribution in \nmicrosec\u00adonds. 6.2.1 Invocation Roundtrip The invocation round-trip is to measure how fast can mes\u00adsage \ntraverse the middleware stack excluding the network delay. Table 6 presents the median and average invocation \ntime (microsecond) observed by OCBS with a client invoking a do-nothing service on the server. The numbers \nare com\u00adputed as averages of over 4,500 sample invocations. It shows that the refactored core achieves \napproximately 8% perfor\u00admance gain on average. The combined implementation (All) incurs 7.6% invocation \noverhead. Figure 9 compares the his\u00ad tograms of the round trip delays for all three versions. It can \nbe observed that a large majority of the round-trips made over the refactored version densely concentrate \nwithin the 150-175 microsecond interval. Distributions for the original version and the woven version \n(All) are primarily beyond the 160 mark and largely the same. This shows the invo\u00adcation time of the \nrefactored core is also statistically better than the original. 6.2.2 Data Transport In this category, \nOCBS measures the time taken by CORBA to transport a certain amount of data between the client and the \nserver. The weighting core functionality in this test is the e.ciency of marshalling and unmarshalling. \nFigure 10 shows the performance measurement of a client sending a stream of octets to the server. Figure \n11 shows the reverse communication with the same input parameters. The X\u00adaxis denotes the number of octets \nand the Y-axis the aver\u00adage invocation time. The samples for these graphs, as well as for all graphs \nhereafter, are the round-trip times for all invocations made in a period of 10 seconds. Our observa\u00adtion \nis that, for the best possible performance Figure 10(1), the refactored core is equivalent to the original \ncore. On average, the refactored core performs slightly better than the original. In the minimum and \nthe average case, all three versions are largely equivalent. The refactored core performs the best and \nthe combined performs the worst in the majority of cases. This improvement is a combined ef\u00adfect of: \n1. a lighter-weight marshalling/unmarshalling layer supporting a fewer number of CORBA data types; 2. \na sim\u00adpler marshalling/unmarshalling logic with no need to decide on character encoding schemes and to \nsetup a proper con\u00adversion mechanism. The performance of the All version shows that con.guring these \nfunctionalities back into the marshalling/unmarshalling mechanisms does not incur sig\u00adni.cant overhead. \n 6.2.3 Request Dispatch Figure 12 present the evaluation for the invocation cost in the presence of multiple \nserver objects. This re.ects the e.ect of server side call dispatching mechanisms. The X\u00adaxis is labeled \nby the number of instantiated objects. The Y-axis represents the invocation time. As the number of server \nobjects increases, the average invocation time also increases in all versions. We observe a similar pattern, \nas the refactored core (None) is most e.cient in request dis\u00adpatching, as compared to the original implementation. \nThis is not surprising since the dispatching logic is simpli.ed by taking out decisions on dispatching \nboth dynamic requests and local invocations. The combined version, in the best (Min) and average scenarios, \nexhibits a penalty between 5% to 13% as a result of AspectJ s bytecode weaving . In the worse-case scenario \n(Max), the dispatching performance of all three versions are equivalent. 6.2.4 Parallel Execution Figure \n13 measures the performance of remote invocations in the multi-threaded scenario. The X-axis is the number \nof threads created on the client side and the Y-axis the invoca\u00adtion time in microseconds. The multi-threaded \nperformance agrees with the single threaded invocation performance with the refactored core performs \nthe best, the original in the medium range, and the combined the worst. The overall mechanism of downcall \nin the refactored core is much sim\u00adpler and lighter compared to the original implementation, which contributes \nto its improved performance. Moreover, refactoring orthogonal functionalities away from the core re\u00adduces \nthe shared data among threads. This shared data orig\u00adinally exists in process-wide singletons and includes \ncodeset factories, conversion utilities, default dynamic servers, just to name a few. Therefore, the \noverhead for inter-thread communication is reduced. 6.2.5 Combined Execution In Table 7, we show the \nperformance evaluated by com\u00ad bining multiple servers and multiple threads and exchang\u00ading messages of \nsize 50K octets between the client and the server. The benchmarking tool measures the following sce\u00adnarios: \nA. Message sending using 100 client threads; B. Mes\u00adsage receiving using 100 client threads; C. Remote \ninvoca\u00adtions (Ping) by 100 client threads to 50,000 servers; D. Mes\u00adsage sending to 50,000 servers; E. \nMessage receiving from 50,000 servers; F. Message sending by 100 client threads to 50,000 servers; G. \nMessage receiving of 100 client threads from 50,000 servers. Except for scenarios A and F, the refactored \nORB gen- A B C D E F G Re-factored 7036 2161 193 954 1061 6020 2689 Original 2332 2395 199 976 1055 1686 \n3130 Combined 6142 2366 238 1003 1103 5396 3111 Table 7: Combined Benchmarking Results in mi\u00adcroseconds. \n erally performs the best although the di.erences among all three versions are typically within 5%. Scenarios \nA and F are anomalies possibly caused by the OS scheduler. Simi\u00adlar anomalies are also noted by the original \nauthors of the benchmark [33].  6.2.6 Cache Performance Another important metric for evaluating the \nruntime ef\u00adfect of the horizontal decomposition method is the cache behavior of the system. We use the \nperformance counter li\u00adbrary23 to count various microprocessor events. These mea\u00adsurements are conducted \nby using a simple loop to send a long integer to a remote server. The entire data collec\u00adtion period \nconsists of 100 epochs, where each epoch equals 1500 remote method calls conducted with ORBacus. Ta\u00adble \n8 depicts the cache-miss rates computed as the average over 100 epochs. A decrease of the instruction-cache \nmiss rate is an indicator of a simpler control .ow. Better L224 cache performance represents better locality \nand a higher degree of cohesion in the program. The data shows that, to support the same functionality, \nthe combined version adds a slight overhead. The refactored core performs better than the original version. \nThis is consistent with our previously presented benchmarking results. None Original All L1 Instruction \nMisses 368869 380404 404187 L2 Miss Rate 3.25% 3.83% 4.4% Table 8: Middleware Cache Measurements: L1 \nand L2. 23http://www.fz-juelich.de/zam/PCL/ 24L2 miss rate is calculate by number of cache misses divided \nby the total number of load/store instructions in that epoch   6.2.7 Concluding Remarks In conclusion, \nthe benchmark data clearly indicates that, for the primary ORB functionalities, ORBacus achieves good \nperformance gains with orthogonal features separated into the aspect code. Although this improvement \nis not as dra\u00admatic as we previously anticipated, it validates that hori\u00adzontal decomposition principles \nare e.ective in separating convoluted features from the middleware core without com\u00adpromising its functionality. \nWe expect to observe more dra\u00admatic improvements with continued refactoring e.orts. Hor\u00adizontal decomposition \nis applicable to any middleware imple\u00admentation, and more generally, any software system, yet we are \nlimited by the maturity of aspect oriented programming languages available to date. Choosing AspectJ \nand aspec\u00adtizing applications running on virtual machines might be another contributing factor for less \ndramatic speed-ups25 . We are not too concerned with the small overhead in some of the results induced \nby combining aspects. This is because negligible overhead is one of the most vital design objectives \nof the AspectJ compiler. We expect research in more e.\u00adcient code generation and JIT techniques for AspectJ \nwill eventually amortize this cost. We defer the benchmark com\u00adparison for the aspectual functionality \nto future work since the required benchmarking options are not available to us in the benchmarking tool. \nOur past work, however, has shown that features supported through aspects do not experience signi.cant \nruntime overhead using AspectJ [41].   7. RELATED WORK There is a broad range of research related to \nhorizontal decomposition principles, or, more generally, improving the con.gurability and the adaptability \nof software systems th\u00adrough the use of new modularization techniques. We present the related research \nin three categories: existing aspect ori\u00adented applications to middleware, adaptive and customiz\u00adable \nmiddleware, and feature oriented programming. 7.1 Existing Middleware Applications of AOP A large number \nof current applications of aspect oriented programming to middleware architectures focus on provid\u00ading \nbetter modularization and support for QoS properties, or, more broadly speaking, support for non-functional \nprop\u00aderties in general. The QuO project at BBN Technologies constitutes a framework supporting the development \nof dis\u00adtributed applications with QoS requirements (see [26, 12], for example). QuO uses quality description \nlanguages (QDL) to specify client-side QoS needs, regions of possible level of QoS, system conditions \nthat need to be monitored, certain behavior desired by clients, and QoS conditions. Loyall et al. [26] \ninterpret these di.erent description languages as as\u00ad pect languages that are processed by a code generator \nto assembled a runtime environment supporting the desired and expected quality of service by client and \nserver in a distributed application. The COMQUAD [16] project uses a similar approach to addresses non-functional \naspects in component-based systems. CQML+ is an XML-based lan\u00adguage in COMQUAD for the description of \nquality char\u00adacteristics . This description is then interpreted and main\u00adtained by the component containers. \nThe JBoss applica\u00ad 25A measure of raw socket performance on the same machine shows a 90 microsecond \nroundtrip for sending 1K of data. tion server26 provides interceptors to allow the hosted ap\u00ad plications \nto handle crosscutting concerns. It also directly supports common crosscutting concerns in J2EE application \nservers such as persistence, security, and transaction. Colyer and Clement [8] demonstrate how to apply \naspect orienta\u00ad tion techniques in an industrial setting to refactor a major crosscutting concern from \nan application server. Hunleth et al. [19], as well as its extended work, FACET27, take a similar position \nas we do and aim at customizing middle\u00ad ware with aspect oriented techniques. It is suggested that aspects \ncould be used for consistency checking, error han\u00ad dling, and at the interface speci.cation level. None \nof the concepts suggested appears to be evaluated, so a compari\u00ad son with our approach is di.cult. Similarly, \nJacobsen and Kr\u00a8amer [20] have suggested to expose certain crosscutting concerns at the interface level \nto make them pluggable on a by-need basis. Our research di.ers from many of the above approaches by focusing \non the customizability of the middleware mech\u00ad anism itself rather than modularizing its extrinsic proper\u00ad \nties. The crosscutting problems we attack are not limited to non-functional concerns but more generally \napply to any or\u00ad thogonal functionality of the architecture. Moreover, unique to our approach is that \nwe introduce and evaluate a set of principles to guide the aspect oriented design of systems and the \nrefactoring of such systems.  7.2 Adaptive Middleware The discussion of separation of concerns for the \ndesign of middleware platforms can be broadly classi.ed into appro\u00ad aches that provide customization \nof the middleware through static or dynamic policy selection [1, 34], approaches that adapt the operation \nof the middleware to changing runtime conditions through the use of re.ection [7, 25, 24, 5], and approaches \nbased on various forms of aspect de.nitions and interpretations [26, 32, 19]. Many of these projects \nuse sev\u00ad eral of these techniques in combination. Below, we discuss each category in turn and point out \nhow our approach is dis\u00ad tinguished. Upfront we can say that the key di.erentiator in our approach is \nthe focus on a methodology to design .ex\u00ad ible and customizable software systems in general and mid\u00ad \ndleware in particular and the evaluation of this methodol\u00ad ogy through extensive aspect oriented refactoring \nof a legacy middleware platform. Our overall emphasize is re-designing and re-structuring the system \nimplementation based on the emerging aspect oriented development paradigm. Astley et al. [1] achieve \nmiddleware customization through tech\u00ad niques based on separation of communication styles from protocols \nand a framework for protocol composition. The CompOSE Q [34] project uses an actor-based model for runtime \nadaptation. Both approaches do not employ aspect orientation to isolated crosscutting design concerns \nfrom the middleware implementation. Several projects exploit re.ective programming techniques to allow \nthe middleware platform to adapt itself dynamically to changing runtime conditions [7, 25, 24, 5]. This \nincludes projects such as openORB [7], openCORBA [25], dynam\u00ad icTAO [24], the OpenOrb project [5], \nand also the Com- pOSE Q project [34]. In these approaches, the re.ective middleware implementation observes \nand reacts to changing 26JBoss URL:http://www.jboss.org 27FACET URL: http://www.cs.wustl.edu/~doc/RandD/ \n PCES/facet/  environmental conditions by selecting di.erent implementa\u00adtion strategies. The platform \nadapts itself to the environ\u00adment, but is not customized to domain or application re\u00adquirements. LegORB28, \nthe Universally Interoperable Core (UIC)29, and Jonathan30 are customizable middleware plat\u00adforms. Customization \nranges from selecting the transport protocol to method dispatching and marshalling routines. While these \napproaches focus on customizing key platform functions, they do not concern themselves with the actual \nimplementation and whether or not the function is indeed a crosscutting concern. Moreover, the customization \nfocuses on a coarse level. In our approach, customization is much .ner-grained, allowing individual types \nto be separated from the middleware implementation.  7.3 Feature Oriented Programming Feature oriented \nprogramming [29] is an alternative pro\u00ad gramming paradigm for increasing the .exibility of conven\u00adtional \ninheritance-based typing in object oriented systems. In FOP, base objects, features which crosscut base \nob\u00adjects, and the interactions between features and base objects exit in separate modules. Hindsight \nshows some properties of FOP can also be identi.ed in our AOP implementation. The concept of feature \ninteraction bears similarities to the implementation convolution problem. However, the former is an intended \nengineering principle of FOP whereas the lat\u00adter describes an unintended phenomenon in legacy imple\u00admentations. \nMoreover, like AOP, guidelines are still needed as how FOP can be applied to improve the middleware ar\u00adchitecture. \nThe idea of separating the core from features can also be found in research on telecommunication systems \n[40] where the relationship is discussed at the level of system functionality not at the architectural \nlevel.  8. CONCLUSION Distributed applications are becoming more and more re\u00adliant on the middleware \nlayer, which decouples them from the complexity of distributed application development. The increasing \nheterogeneity and versatility of application do\u00admains requires middleware to support an unprecedented \nlevel of con.gurability and adaptability. We believe this level is di.cult to achieve with vertical decomposition \nmethods alone, due to their inability in maintaining convolution-free implementations. Hence, we propose \nthe horizontal decom\u00adposition principles and advocate the mixed-paradigm ar\u00adchitecture of middleware. \nThis is based on using the con\u00adventional hierarchically-decomposed architecture to support core operations \nand aspect oriented decomposition for adding orthogonal properties. In the horizontal decomposition, \nwe emphasize the relative nature of aspects and the importance of de.ning the core decomposition as the \nbasis of the AOP decomposition. Through horizontal decomposition, we have made two major improvements \nas compared to the conven\u00adtional architecture: 1. We have made considerable progress in factoring out \nmajor middleware functionality as aspects and have obtained a stripped-down version of the middleware \ncore. This core is 40% of its original size, and its 28http://choices.cs.uiuc.edu/2k/LegORB/ 29http://www.ubi-core.com/ \n30http://www.objectweb.org/jonathan/jonathanHomePage.htm performance has improved on all of the third-party \nbenchmarks. This is not at the cost of compromis\u00ading overall functionality: the stripped-out properties \ncan be transparently brought into, or taken out of the middleware on a by-need basis through the weaving \nmechanism of AspectJ. 2. We have dramatically increased the degree of con.g\u00adurability and adaptability \nof the middleware by re\u00adsolving the convolution among aspects and making the architecture super-impositional. \nWe have turned a monolithic architecture into an architecture with over 60 possible combinations of features31 \n. These combi\u00adnations are composed at the post-compilation stage at which point no source code modi.cation \nis required. Although our primary experiments with horizontal de\u00ad composition focus on middleware, we \nbelieve that our ap\u00ad proach, of using multiple decomposition paradigms to un\u00ad tangle and to separate \nthe architectures of both core opera\u00ad tions and orthogonal functionalities, is generally applicable to \nany software architecture. We suspect that horizontal decomposition principles are best suitable for \napplications that serve multiple domains and support a wide range of usage scenarios. The successful \napplication of horizontal decomposition is based on discern\u00ad ing the most common functionality, i.e., \nthe core, from a large and complex system. We are somewhat blessed in that the requirements and the functionalities \nof most middleware technologies, such as CORBA, are well-studied. Software architecture in other areas \nmight not have this advantage. Another issue, which is out of the scope of this paper but cannot be neglected, \nis the question of how to ensure con\u00ad sistency across aspects. That is to ensure that functionality in \none aspect does not negate or indirectly change the se\u00ad mantics of another aspect. We had not encountered \nthis problem due to the refactoring of an existing application. However, this becomes a serious issue \nwhen developing new applications or adding new aspects. Besides intuition and heuristics, this problem \ncould be addressed, either at the requirements engineering level, or through the use of model checking. \nIt is also a challenge to manage various con.g\u00ad urations, since the possibilities of combinations of \naspects to form new product versions grows exponentially with the number of aspects. An e.ective con.guration \ntool must ac\u00ad company the architecture to assist the customization pro\u00ad cess. In our future work, we \nwill continue to accumulate more experience in applying the horizontal design principles to im\u00ad prove \nthe modularity of middleware. We will continue our refactoring work to separate out more horizontal design \ncon\u00ad cerns from the middleware core. For example, we can further decompose primitive IDL data types as \naspects. The inter\u00ad face compiler, such as the IDL compiler in CORBA, is often an integral part of the \nmiddleware functionality. We have started studying the interface compiler support for horizon\u00ad tal decomposition. \nWe will also explore the application of the horizontal decomposition method more extensively by experimenting \nwith other middleware types such as J2EE application servers. This will greatly assist us in designing \n 31A rough calculation: the number of combinations of 6 as\u00ad pects: interceptor support, DII, DSI, local \ninvocation, wide characters, conversion support is 26=64. a fully aspect oriented middleware platform, \nwhich is our long term objective. Acknowledgments This research has been supported in part by an NSERC \ngrant and in part by an IBM CAS fellowship for the .rst author. The authors are very grateful for this \nsupport.  9. REFERENCES [1] M. Astley, D.C. Sturman, and G. A. Agha. Customizable Middleware for Modular \nSoftware. ACM Communications, May 2001. [2] Luca Benini and Giovanni De Micheli. System-Level Power Optimization: \nTechniques and Tools. ACM Transactions on Design Automation of Electronic Systems, 5(2):115 192, 2000. \np173. [3] G. D. Bergland. Structured Design Methodologies. In Proceedings of the No 15 Design Automation \nConference on Design Automation, pages 475 493. IEEE Press, 1978. [4] L. Bergmans and M. Aksit. Aspects \nand crosscutting in layered middleware systems. Re.ective Middleware (RM 2000) workshop held in conjunction \nwith the IFIP/ACM Intl. Conf. on Distributed System Platforms and Open Distributed Processing (Middleware \n2000)., April 2000. [5] Gordon S. Blair, Geo. Coulson, Anders Andersen, Lynne Blair, Michael Clarke, \nFabio Costa, Hector Duran-Limon, Tom Fitzpatrick, Lee Johnston, Rui Moreira, Nikos Parlavantzas, and \nKatia Saikoski. The design and implementation of Open ORB 2. IEEE Distributed Systems Online Journal \n2(6), 2001. [6] Joey Caron, Scott Herscher, and Ann Marie O Connor. CORBA in the palm of your hand whitepaper. \nVertel Corporation. [7] M. Clarke, G. Blair, G. Coulson G., and N. Parlavantzas. An e.cient component \nmodel for the construction of adaptive middleware. In IFIP/ACM International Conference on Distributed \nSystems Platforms (Middleware 2001), November 2001. [8] Adrian Colyer and Andrew Clement. Large-scale \nAOSD for middleware. In 3rd International Conference on Aspect-oriented Software Development (AOSD 04), \npages 56 65, Lancaster, UK, 2004. [9] Geo. Coulson, Gordon S. Blair, Michael Clarke, and Nikos Parlavantzas. \nThe design of a con.gurable and recon.gurable middleware platform. Distributed Computing, 15(2):109 126, \n2002. [10] Edsger W. Dijkstra. The humble programmer. Commun. ACM, 15(10):859 866, 1972. [11] Louis DiPalma \nand Robert Kelly. Applying CORBA in a contemporary embedded military combat system. OMG s Second Workshop \non Real-time and Embedded Distributed Object Computing, June 2001. [12] Gary Duzan, Joseph Loyall, Richard \nSchantz, Richard Shapiro, and John Zinky. Building adaptive distributed applications with middleware \nand aspects. In Proceedings of the 3rd international conference on aspect oriented software development. \nACM, 2004. [13] Robert Filman. Achieving ilities. URL: http://ic.arc.nasa.gov/~filman/text/oif/ wcsa-achieving-ilities.pdf, \n1999. [14] Martin Fowler. Refactoring: Improving the Design of Existing Code. Addison-Wesley, 1999. \n[15] Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. Design Patterns. Addison-Wesley, 1995. \n[16] Ste.en Gobel, Christoph Pohl, Simone Rottger, and Ste.en Zschaler. The COMQUAD Component Model: \nEnabling Dynamic Selection of Implementations by Weaving Non-functional Aspects. In Proceedings of the \n3rd International Conference on Aspect Oriented Software Development. ACM, 2004. [17] Object Management \nGroup. The Common Object Request Broker: Architecture and Speci.cation. Technical report, December 2001. \n[18] Jan Hannemann and Gregor Kiczales. Design Pattern Implementation in Java and AspectJ. In Proceedings \nof the 17th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications, \npages 161 173. ACM Press, 2002. [19] Frank Hunleth, Ron Cytron, and Christopher Gill. Building customizable \nmiddleware using aspect oriented programming. In Workshop at OOPSLA, 2001. [20] H.-A. Jacobsen and B. \nJ. Kr\u00a8amer. A design pattern based approach to generating synchronization adaptors from annotated IDL. \nIn IEEE Automated Software Engineering Conference (ASE 98), pages 63 72. IEEE Computer Society, September \n1998. [21] Hans-Arno Jacobsen. Middleware architecture design based on aspects, the open implementation \nmetaphor and modularity. In Workshop on Aspect-Oriented Programming and Separation of Concerns, Lancaster, \nUK, August 2001. [22] Mik Kersten and Gail C. Murphy. Atlas: a case study in building a web-based learning \nenvironment using aspect-oriented programming. In Proceedings of the 14th ACM SIGPLAN conference on Object-Oriented \nProgramming, Systems, Languages, and Applications, pages 340 352. ACM Press, 1999. [23] Gregor Kiczales, \nJohn Lamping, Anurag Menhdhekar, Chris Maeda, Cristina Lopes, Jean-Marc Loingtier, and John Irwin. Aspect-oriented \nprogramming. In Mehmet Ak\u00b8sit and Satoshi Matsuoka, editors, Proceedings European Conference on Object-Oriented \nProgramming, volume 1241, pages 220 242. Springer-Verlag, Berlin, Heidelberg, and New York, 1997. [24] \nFabio Kon, Manuel Rom\u00b4an, Ping Liu, Jina Mao, Tomonori Yamane, Luiz Claudio Magalh aes, and Roy H. Campbell. \nMonitoring, Security, and Dynamic Con.guration with the dynamicTAO Re.ective ORB. In Proceedings of the \nIFIP/ACM International Conference on Distributed Systems Platforms and Open Distributed Processing (Middleware \n2000), number 1795 in LNCS, pages 121 143, New York, April 2000. Springer-Verlag. [25] Thomas Ledoux. \nOpenCorba: a re.ective open broker. In Pierre Cointe, editor, Meta-Level Architectures and Re.ection, \nSecond International Conference, Re.ection 99, volume 1616 of Lecture Notes in Computer Science, pages \n197 214, Saint-Malo, France, July 1999. Springer-Verlag. [26] Joseph P. Loyall, David E. Bakken, Richard \nE. Schantz, John A. Zinky, David A. Karr, Rodrigo Vanegas, and Kenneth R. Anderson. QoS aspect languages \nand their runtime integration. In Fourth Workshop on Languages, Compilers, and Run-time Systems for Scalable \nComputers. Lecture Notes in Computer Science, Vol. 1511, Springer-Verlag, Pittsburgh, Pennsylvania, USA, \nMay 28th-30th 1998. [27] Pattie Maes. Concepts and experiments in computational re.ection. In Conference \nproceedings on Object-Oriented Programming Systems, Languages and Applications, pages 147 155. ACM Press, \n1987. [28] D. L. Parnas. On the Criteria To Be Used in Decomposing Systems into Modules. Communications \nof the ACM, 15(12):1053 58, December 1972. [29] Christian Prehofer. Feature-oriented programming: A fresh \nlook at objects. In ECOOP, volume 1241 of Lecture Notes in Computer Science, page 419 ., 1997. [30] Douglas \nSchmidt, Michael Stal, Hans Rohnert, and Frank Buschmann. Pattern-Oriented Software Architecture Patterns \nfor Concurrent and Networked Objects, volume 2 of Software Design Patterns. John Wiley &#38; Sons, Ltd, \n1 edition, 1999. [31] C. Szyperski. Component Software: Beyond Object-Oriented Programming. Addison-Wesley, \n1998. [32] L. Teboul, R. Pawlak, L. Seinturier, E. Gressier-Soudan, and E. Becquet. AspectTAZ: A new \napproach based on aspect-oriented programming for object-oriented industrial messaging services design. \nIn WFCS 2002, August 2002. [33] Petr Tuma and Adam Buble. Open CORBA Bench Marking. SPECTS 2001. URL: \nhttp://nenya.ms.mff.cuni.cz/~bench. [34] Nalini Venkatasubramanian, Mayur Deshpande, Shivjit Mohapatra, \nSebastian Gutierrez-Nolasco, and Jehan Wickramasuriya. Design &#38; implementation of a composable re.ective \nmiddleware framework. In IEEE International Conference on Distributed Computer Systems (ICDCS-21), April \n2001. [35] Robert J. Walker, Elisa L.A. Baniassad, and Gail C. Murphy. An initial assessment of aspect-oriented \nprogramming. In In Proceedings of the 21st International Conference on Software Engineering, pages 120 \n130, 1999. [36] Roel Wieringa. A survey of structured and object-oriented software speci.cation methods \nand techniques. ACM Comput. Surv., 30(4):459 527, 1998. [37] Eric Wohlstadter, Stoney Jackson, and Premkumar \nDevanbu. Dado: enhancing middleware to support crosscutting features in distributed, heterogeneous systems. \nIn Proceedings of the 25th International Conference on Software Engineering, pages 174 186. IEEE Computer \nSociety, 2003. [38] Edward Yourdon and Larry L. Constantine. Structured Design. Prentice-Hall, Inc., \n1979. [39] Pamela Zave. A compositional approach to multiparadigm programming. IEEE Software, 6(5):15 \n25, September 1989. [40] Pamela Zave. Feature interactions and formal speci.cations in telecommunications. \nIEEE Computer, 26(8):20 29, August 1993. [41] Charles Zhang and Hans-Arno Jacobsen. Quantifying Aspects \nin Middleware Platforms. In 2nd International Conference on Aspect Oriented Systems and Design, pages \n130 139, Boston, MA, March 2003. [42] Charles Zhang and Hans-Arno Jacobsen. Refactoring Middleware Systems: \nA Case Study. In International Symposium on Distributed Objects and Applications (DOA 2003), Catania, \nSicily (Italy), 2003. Lecture Notes in Computer Science, Springer Verlag. [43] Charles Zhang and Hans-Arno \nJacobsen. Refactoring Middleware with Aspects. IEEE Transactions on Parallel and Distributed Systems, \n14(11):1058 1073, November 2003. [44] Charles Zhang and Hans-Arno Jacobsen. TinyC2 towards a dynamic \nweaving aspect language based on C. In Foundation of Aspect Oriented Languages (FOAL) jointly held with \nthe 2nd International Conference on Aspect Oriented Systems and Design, Boston, MA, March 17th 2003. \n \n\t\t\t", "proc_id": "1028976", "abstract": "<p>Middleware provides simplicity and uniformity for the development of distributed applications. However, the modularity of the architecture of middleware is starting to disintegrate and to become complicated due to the interaction of too many orthogonal concerns imposed from a wide range of application requirements. This is not due to bad design but rather due to the limitations of the conventional architectural decomposition methodologies. We introduce the principles of horizontal decomposition (HD) which addresses this problem with a mixed-paradigm middleware architecture. HD provides guidance for the use of conventional decomposition methods to implement the core functionalities of middleware and the use of aspect orientation to address its orthogonal properties. Our evaluation of the horizontal decomposition principles focuses on refactoring major middleware functionalities into aspects in order to modularize and isolate them from the core architecture. New versions of the middleware platform can be created through combining the core and the flexible selection of middleware aspects such as IDL data types, the oneway invocation style, the dynamic messaging style, and additional character encoding schemes. As a result, the primary functionality of the middleware is supported with a much simpler architecture and enhanced performance. Moreover, customization and configuration of the middleware for a wide-range of requirements becomes possible.</p>", "authors": [{"name": "Charles Zhang", "author_profile_id": "81435599989", "affiliation": "University of Toronto, Toronto, ON, Canada", "person_id": "PP14051117", "email_address": "", "orcid_id": ""}, {"name": "Hans-Arno Jacobsen", "author_profile_id": "81452606405", "affiliation": "University of Toronto, Toronto, ON, Canada", "person_id": "PP15035345", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1028976.1028992", "year": "2004", "article_id": "1028992", "conference": "OOPSLA", "title": "Resolving feature convolution in middleware systems", "url": "http://dl.acm.org/citation.cfm?id=1028992"}