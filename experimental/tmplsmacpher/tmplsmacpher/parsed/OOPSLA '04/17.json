{"article_publication_date": "10-01-2004", "fulltext": "\n Instrumentation of Standard Libraries in Object-Oriented Languages: the Twin Class Hierarchy Approach \n Michael Factor Assaf Schuster Konstantin Shagin IBM Research Lab in Haifa Israel Institute of Technology \nIsrael Institute of Technology Haifa University Campus Technion City Technion City Haifa 31905, Israel \nHaifa 32000, Israel Haifa 32000, Israel factor@il.ibm.com assaf@cs.technion.ac.il konst@cs.technion.ac.il \n ABSTRACT Code instrumentation is widely used for a range of purposes that include pro.ling, debugging, \nvisualization, logging, and distributed computing. Due to their special status within the language infrastructure, \nthe standard class libraries,also known as system classes, provided by most contemporary object-oriented \nlanguages are di.cult and sometimes im\u00adpossible to instrument. If instrumented, the use of their rewritten \nversions within the instrumentation code is usually unavoidable. However, this is equivalent to instrumenting \nthe instrumentation , and thus may lead to erroneous re\u00adsults. Consequently, most systems avoid rewriting \nsystem classes. We present a novel instrumentation strategy that alleviates the above problems by renaming \nthe instrumented classes. The proposed approach does not require any mod\u00adi.cations to the language, compiler \nor runtime. It allows system classes to be instrumented both statically and dy\u00adnamically. In fact, this \nis the .rst technique that enables dy\u00adnamic instrumentation of Java system classes without mod\u00adi.cation \nof any runtime components. We demonstrate our approach by implementing two instrumentation-based sys\u00adtems: \na memory pro.ler and a distributed runtime for Java. Categories and Subject Descriptors D.1.5 [PROGRAMMING \nTECHNIQUES]: Object-ori\u00adented Programming; D.2.7 [SOFTWARE ENGINEER-ING]: Distribution, Maintenance, \nand Enhancement Re\u00adstructuring, reverse engineering, and reengineering General Terms Algorithms, Languages \n Keywords Code Instrumentation, Standard Class Libraries, Inheritance, Java Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. OOPSLA 04, Oct. 24-28, 2004, Vancouver, British \nColumbia, Canada. Copyright 2004 ACM 1-58113-831-8/04/0010 ...$5.00. 1. INTRODUCTION Code instrumentation \nis the act of modifying the code of an existing application by inserting new code statements and modifying \nor deleting existing ones. Instrumentation may be applied to source code as well as to compiled code. \nIn the latter case, it may be applied statically, before the execution begins, or dynamically at run \ntime. Code instrumentation is a powerful mechanism for under\u00adstanding and modifying program behavior. \nIt is employed in various .elds, including debugging, logging, visualization, access control, performance \nevaluation, distributed comput\u00ading, and aspect-oriented programming. (Note that the latter canbe usedin \nany of the other .elds.) Many modern object-oriented languages, e.g.,Java, C#, Ei.el, Smalltalk, O Caml \nand Objective-C, supply a rich set of reusable core classes, known as standard class libraries or system \nclasses. These classes improve the usability of a language, allowing the programmer to concentrate on \nthe higher-level tasks. A subset of standard classes provides convenient interfaces to operating system \nfacilities, e.g.,I/O and networking. Henceforth, we will use the terms system classes and user classes \nto designate the standard library classes and user-de.ned classes, respectively. In general, instrumentation \nmay a.ect any code used by the original program. In the context of object-oriented languages, the instrumentation \nprocess may modify system classes. If the inserted code utilizes the instrumented sys\u00adtem classes, it \nmay lead to incorrect results. This is because the functionality of the instrumented system classes is \ndi.er\u00adent from the original. To put it simply, using instrumented classes in the inserted code is equivalent \nto instrumenting the instrumentation . For instance, consider a pro.ler for Java that instruments Java \nbytecode to record the sizes of objects created by the application. After each object creation statement, \nit inserts code that stores the size of the new object in an instance of a system class java.util.LinkedList \nby calling its add method. Assume that the original application also uses this list class. Therefore, \nduring pro.ling, the application must use the instrumented list class to detect the objects created in \nits own instances of the list class. However, if the code added by the pro.ler uses the instrumented \nversion as well, in.nite recursion occurs. When an object is created, the pro.ler invokes the add method \nof the list; this method cre\u00adates an object representing a new list entry. If the list class used in \nthe instrumentation code is itself instrumented, the creation of a new entry in the add method will be \nfollowed by another invocation of add, leading to in.nite recursion. Even without the recursion problem, \nthe pro.ler would yield incorrect results, recording the sizes of the list entry objects created by the \ninstrumentation code. To produce correct results, the instrumentation code must use the original system \nclasses, while all other code uses their instrumented counterparts. (Certain types of instru\u00admentation \nmay still require that the instrumented system classes be used.) Therefore, the runtime must use the \norig\u00adinal and instrumented versions of the same class simultane\u00adously. This, however, is problematic \nbecause both versions have thesamename, i.e.,there is a name clash problem. We propose an instrumentation \napproach that allows both the original and instrumented versions of a system class to coexist within \nthe same execution environment. It solves the name clash problem by renaming the instrumented classes \nand modifying all code, other than the instrumentation code, to use these renamed classes. The inheritance \nhier\u00adarchy of the instrumented classes is isomorphic to the orig\u00adinal one. Therefore, we call our solution \nthe Twin Class Hierarchy approach (TCH). One of the most important features of TCH is its portabil\u00adity. \nBeing entirely based on instrumentation, it is orthogonal to the implementation of the targeted language \nframework. Neither the compiler nor the runtime environment need to be modi.ed. Since in most cases the \ninitial goal of code in\u00adstrumentation is portability, a nonportable solution would be unacceptable. In \nmost languages, the TCH class name transformation does not preserve the integrity of the code and may \ncome into con.ict with features such as inheritance, exceptions, and re.ection. Therefore, we augment \nthe TCH approach with techniques that overcome these di.culties. Despite the language-speci.c nature \nof several problematic features, most of our solutions are generic, or at least can be employed by the \npopular contemporary languages, e.g., C#, Small\u00adtalk, and Java. The implementation of TCH is not entirely \nautomatic, but may require a certain amount of hand tuning to adapt it to a particular language. However, \nonce the tuning is completed, TCH can be used automatically by any general instrumentation in that language. \nOf course, one could argue that the problem could be solved by avoiding the use of system classes in \nthe inserted code. However, this restriction signi.cantly limits the conve\u00adnience and power of the instrumentation. \nInstead of reusing system classes, the user would have to reimplement them. In addition, the functionality \nof those classes that cannot be reimplemented would become unavailable. For example, in the Microsoft \nIntermediate Language (MSIL) used in .NET, it is impossible to synchronize thread activities without \nus\u00ading classes from the System.Threading package. Their special status within the runtime makes system \nclasses di.cult to instrument. In fact, most frameworks, ([1, 2, 4, 15, 16] for example), avoid instrumenting \nthem, modifying only user classes. Some systems [1, 2, 4] limit their functionality to user classes, \nwhile others [15, 16] in\u00advest considerable e.ort into implementing context-speci.c workarounds. TCH facilitates \nthe instrumentation of system classes. With TCH class name transformation, the instrumented system classes \nbecome user classes, which are easily instru\u00admented by most frameworks. In particular, as we show in \nSection 3, TCH allows Java system classes to be instru\u00admented, statically or dynamically, without any \nmodi.cation of the Java Virtual Machine (JVM) or the operating sys\u00adtem components. By contrast, existing \nframeworks that are capable of instrumenting Java system classes compromise portability. For example, \nKeller et al. [12] make changes in the JVM. Duncan et al. [10] modify the dynamically linked libraries \n(DLLs) that are used to access the .le system. Although our main motivation is to allow the original \nsys\u00adtem classes to be used, our solution can be applied to user classes as well. This is useful when \na reusable non-standard library, e.g., a library for management of log .les, employed by the application \nto be instrumented, is also utilized in the code inserted by the instrumentation. We focus on system \nclasses because it is the more di.cult problem. We have employed the TCH approach in an instrumentation-based \npro.ler for Java and in a dis\u00adtributed runtime for Java, which we call JavaSplit [11]. The pro.ler collects \nstatistics about memory allocations per\u00adformed by an application. We use it to explore the SPECjbb benchmark \n[5]. The JavaSplit runtime instruments a stan\u00addard multithreaded Java program for distributed execution. \nThe instrumentation intercepts events that are interesting in the context of distributed execution, e.g., \naccesses to shared data, synchronization, and creation of new threads. In both systems, the inserted \ncode uses the original ver\u00adsions of system classes, while all other code uses their in\u00adstrumented counterparts. \nThe ability of TCH to instrument all system classes plays an important role in the implemen\u00adtation of \nboth systems. Without it, the pro.ler would not be able to detect many of the allocations that occur \nwithin the system classes, whereas JavaSplit would not be able to maintain the correctness of memory \nand synchronization op\u00aderations. The main contributions of this paper are as follows. First, we present \na novel instrumentation strategy that extends the capabilities of code instrumentation in object-oriented \nlanguages. Second, we discuss issues that arise when imple\u00admenting our strategy in contemporary languages. \nFinally, we show how TCH enables dynamic instrumentation of Java system classes. The structure of the \nrest of this paper is as follows. Sec\u00adtion 2 presents the Twin Class Hierarchy approach. In Sec\u00adtion \n3 we discuss the di.culties of instrumenting system classes and show how TCH alleviates them. Section \n4 ex\u00adplores the overhead of TCH. Section 5 demonstrates the con\u00adtribution of TCH in pro.ling and distributed \ncomputing. In Section 6 we present approaches similar to TCH. Section 7 describes several load-time instrumentation \nframeworks and their relation to TCH. We conclude in Section 8.  2. TWIN CLASS HIERARCHY At the heart \nof the TCH approach lies the idea of renam\u00ading the instrumented classes to allow the instrumented and \noriginal classes to be used simultaneously by the runtime. For each original user or system class we \nproduce an instru\u00admented version with a di.erent name. The inheritance rela\u00adtions of the instrumented \nclasses mimic the original inher\u00aditance hierarchy. Thus, the new hierarchy is isomorphic to the original \none. Figure 1 illustrates class renaming in Java. (The new name is produced by adding a pre.x TCH. to \nthe original one, so that SomeClass becomes TCH.SomeClass.) In the instrumented version of a class, all \ncode other than that inserted by the instrumentation is modi.ed to use  (a) Original class hierarchy \n (b) Twin class hierarchy Figure 1: A fragment of the class hierarchy in Java, before and after the TCH \ntransformation. The instru\u00admented versions of system classes become user classes. (Java system classes \nare designated by dark gray.) The irregularity of java.lang.Throwable is discussed in Section 2.3. public \nclass Example extends java .util. Vector { private int intField ; protected java.lang.Long longObjfield; \nprivate java . lang . Object objField ; // constructor public Example{ ... } java.util.List someMethod( \nint n, java . lang . String s ) {... } java . lang . Integer someOtherMethod ( java .util. Vector vec \n, java.lang.Object obj) { ... if (obj instanceof java . lang . String){... } .. java . lang . Integer \nlocal = new java.lang. Integer(n); java.lang.System.out. println(local ); ... return localVar ; }}  \n  (a) Original class  public class TCH.Example extends TCH.java. util .Vector { private int intField \n; protected TCH.java.lang.Long longObjfield; private java . lang . Object objField ; // constructor public \nExample{ ... } TCH.java.util.List someMethod( int n , TCH. java . lang . String s ) { ... } TCH. java \n. lang . Integer someOtherMethod ( TCH.java.util.Vector vec, java.lang.Object obj) { ... if (obj instanceof \nTCH. java . lang . String ){... } .. TCH. java . lang . Integer local = new TCH. java . lang . Integer(n); \nTCH.java.lang.System.out. println (local ); ... return localVar ; }} (b) Twin class Figure 2: A Java \nclass before and after the TCH transformation. (Although we present source code, the actual transformation \ncan be performed on bytecode as well.) All referenced class names, except java.lang.Object, are replaced. \nObject (OOC) original Object (OOC) class TCH.Object (IOC)  runtime original class irregular hierarchy \nclasses phase 1 phase 2 Figure 3: Instrumentation process. The code in-Figure 4: High-level view of class \nhierarchy trans\u00adserted during the second phase uses original class formation names. the TCH class names \n(see Figure 2). For example, in Java bytecode, the renaming a.ects the instructions instanceof, invokevirtual, \nnew, getfield, etc. (See [14] for the ex\u00adact semantics of the above instructions.) However, as we show \nin Section 2.7, there is no need to modify the strings that designate class names. (In fact, they cannot \nalways be distinguished from the other strings.) The TCH-related transformations are independent of the \npurpose-speci.c instrumentation. Therefore, it is possible to rewrite the code in two phases, applying \nthe TCH transfor\u00admations prior to the purpose-speci.c transformations (see Figure 3). To solve the circular \ndependency problems de\u00adscribed in the previous section, the latter phase inserts code that uses the original \nclass names. Both phases can be per\u00adformed statically, or both can be performed dynamically. It is also \npossible to produce the TCH versions of classes stat\u00adically, and then apply the purpose-speci.c transformations \nat run time. The TCH phase is implemented only once per language. When implemented, it can be reused \nwith any general instrumentation process. The class name transformation, if performed naively, com\u00adpromises \nthe integrity of the instrumented code in several contexts, including inheritance, re.ection, and exception \nhandling. In this section we study the problems that emerge and present techniques to resolve them. Together \nwith the modi.cation of class names, the presented solutions con\u00adstitute the previously mentioned TCH \ntransformations. In this section, the term instrumented class means class result\u00ading from applying the \nTCH transformations on the original class. 2.1 Root class Most modern object-oriented languages, e.g., \nJava, Small\u00adtalk and C#, have an object class at the top of their class hierarchy (java.lang.Object in \nJava, Object in Smalltalk, System.Object in C#). Due to the name change, the in\u00adstrumented object class \n(IOC) is not the top hierarchy class, but a subclass of the original object class (OOC). Figure 4 presents \na high-level view of the class hierarchy transformation. In the new class hierarchy, the IOC is a di\u00adrect \nsubclass of the OOC. Since the IOC is not the root class, the language may have certain special classes \nthat are not its subclasses. For example, in C#, the TCH transforma\u00adtion cannot replace the superclass \nof an array class, because arrays are implicitly de.ned (using the [] operator at the source code level). \nAs a result, despite the TCH transfor\u00admation, arrays remain subclasses of System.Object and are not subclasses \nof TCH.System.Object. Classes that do not subclass the IOC are denoted irregular classes. These classes \npresent a few problems that are discussed and resolved in Section 2.2. 2.2 Irregular classes The presence \nof irregular classes is problematic mainly in languages with static typing, e.g., Java, C# and O Caml. \nLanguages with dynamic typing (such as Smalltalk) may be a.ected by it, depending on whether the purpose-speci.c \ninstrumentation modi.es OOC behavior. In statically typed languages, TCH class renaming trans\u00adforms all \nuses of OOC in the original code, e.g.,local vari\u00adables, class .elds, and method parameters, into uses \nof IOC. Thus, a variable of type OOC that originally could have referenced an irregular class, e.g., \nan array class, is trans\u00adclass TCH. IntArrayWrapper extends TCH. Object { private int [] array ; // \nconstructor, substitutes NEWARRAY public TCH. IntArrayWrapper( int size ){array = new int [size ]; } \n// subs titutes IALOAD final public int load ( int index ){ return array  [ index ] ; } // subs titutes \nIASTORE final public void store ( int index , int value ){array [ index ] = value ; } } Figure 5: A \npossible wrapper for a Java integer ar\u00adray. Accessor methods are final to enable inlining. formed to \na variable that is unable to do so, because irregular classes do not subclass IOC. For example, in instrumented \nC# code, a local variable of type TCH.System.Object can\u00adnot contain a reference to an array of integers \nwhose direct superclass remains System.Object, despite the class name transformation. To solve this problem, \nOOC references are not replaced by IOC references in the instrumented code. Rather, they are left as \nthey are, in order to allow them to reference the irregular classes (see Figure 2). The only exception \nto this rule is made in the code that originally creates an OOC instance: after instrumentation it creates \nan IOC instance. Another problem with irregular classes is that they are not a.ected by the changes made \nby a purpose-speci.c in\u00adstrumentation in the implementation of IOC. For example, if a .eld myID and \na method id() returning this .eld are added to IOC, only the subclasses of IOC will have an ID. This \nproblem, which is relevant also in languages with dy\u00adnamic typing, may be resolved by applying the transforma\u00adtions \napplied to the IOC directly to the implementation of irregular classes. In the above example, all irregular \nclasses should be augmented with the ID .eld and ID method. Un\u00adfortunately, this solution is inapplicable \nto classes that do not have a class de.nition, but rather are de.ned implic\u00aditly, e.g., array classes. \nIn these special cases, the problem is solved by de.ning a wrapper class around the implicitly de.ned \nclasses. This wrapper should subclass the IOC, thus inheriting all its functionality. All references \nto the origi\u00adnal class should be replaced with references to the wrapper. Figure 5 illustrates a wrapper \nfor a one-dimensional Java integer array. In all the instrumented bytecode the invo\u00adcations of the bytecode \ninstructions newarray, iaload and iastore should be replaced by invocations of the wrapper constructor, \nand methods load and store respectively. In statically typed languages, a variable of type OOC that points \nto a subclass of IOC needs to be downcast to IOC whenever accessing a method or a (public) .eld added \nto IOC by the purpose-speci.c instrumentation. If the object referenced by a variable of type OOC is \nan instance of an ir\u00adregular class, then it needs to be downcast to its own class, before accessing the \nadditional member. (If the irregular class was not augmented with these members, the code ac\u00adcessing \nthem must be skipped.) 2.3 Classes with special semantics Some languages attribute special semantics \nto certain classes (or other class-like constructs, e.g.,Java interfaces). For instance, in Java, only \na subclass of java.lang.Throw\u00adable canbe thrownas anexception. Only a classimple\u00admenting the java.io.Serializable \ninterface can be mar\u00adshaled into a bitstream. The renaming causes the instru\u00admented classes to lose their \nspecial semantics, often violat\u00ading the integrity of the instrumented code. For example, in the instrumented \ncode the argument of a throw statement in Java is no longer a subclass of java.lang.Throwable, but rather \na subclass of TCH.java.lang.Throwable,which is illegal. Since the special semantics are class-speci.c, \nso in theory should be the solution. In practice, a general technique pre\u00adsented below solves the problem \nfor those cases of special class semantics of which we are aware. (Note that very few system classes \nhave unusual semantics.) In order to regain the special semantics of an instrumented class, we make it \na direct subclass of its original version. This solves the problem, because it creates an is a re\u00adlationship \nbetween the instrumented class and its original counterpart. For instance, in the case of Java s throwable \nclass, the instrumented class TCH.java.lang.Throwable be\u00adcomes a subclass of java.lang.Throwable (Figure \n1(b)) and therefore can be used in a throw statement. This solution also works for all of Java s special \ninterfaces. When this technique is applied, additional irregular classes are created. The above solution \nwould not be possible unless the orig\u00adinal special classes could be subclassed. For example, it would \nnot work if Java s throwable class were a final class. (In Java, final classes cannot be subclassed.) \nIt would also fail if the original class was not a direct subclass of the OOC. Fortunately, those classes \nwith special semantics can be subclassed and directly subclass the OOC. 2.4 Illegal method overriding \nIn most languages with static typing, an inherited method cannot be overridden by a method with a di.erent \nreturn type and the same argument types. In previous sections we saw cases of instrumented classes subclassing \ntheir orig\u00adinal counterparts. In section 2.1, we describe how an IOC is made a direct subclass of an \nOOC. In section 2.3 we show how instrumented classes regain their special seman\u00adtics by subclassing their \noriginal versions. One consequence of the TCH class name transformation is that an instru\u00admented class \nmay contain a method that di.ers from the original method only by a return type. (Method arguments remain \nthe same if a method does not have object refer\u00adence arguments.) Therefore, subclassing a non-TCH class \nby its instrumented version can lead to a violation of method overriding rules. For example, in Java, \nthe return type of the method toString() in IOC is TCH.java.lang.String, which is di.erent from its return \ntype in OOC. We solve this problem by renaming the problematic meth\u00adods, and modifying the code to use \nthe new names, which are produced by adding the pre.x TCH to the original names. For example, when creating \nthe IOC, its toString() method is renamed TCH toString(). 2.5 Object constants Most languages contain \nobject constants. For instance, in Java, string literals are objects of type java.lang.String. In pure \nobject-oriented languages like Smalltalk, all con\u00adstants and strings, e.g., 1977, 0.333 and hi , are \nobjects. Since object constants are instances of the original system classes, they are not compatible \nwith the rest of the code, which is instrumented to use the TCH classes. We solve this problem by replacing \neach object constant of a class A with an instance of TCH.A. For example, in Java, each string literal \nis replaced with a corresponding instance of TCH.ja\u00adva.lang.String. (A regular string may be converted \ninto a TCH string by using the underlying character array of the former to create an instance of the \nlatter.) The above problem exists both in statically and dynamically typed lan\u00adguages. In the latter, \nif object constants are not converted to the TCH form, they will not be a.ected by the instru\u00admentation. \n2.6 Runtime exceptions Runtime environments, e.g., JVM or .NET Common Language Runtime (CLR), may throw \nruntime exceptions. These exceptions are not TCH objects. In statically typed languages the exceptions \nare caught on the basis of their class. The TCH class name transfor\u00admation causes the rewritten catch \nstatements to catch the TCH exceptions but miss the runtime exceptions. To solve this problem we modify \neach catch statement to catch both the instrumented and the original versions of the exception classes \nassociated with it. In both dynamically and statically typed languages, a caught runtime exception is \nconverted, before the execution of an exception handler, to an instance of the corresponding TCH class. \nThis ensures that the ex\u00adception handler will process a TCH version of the exception. 2.7 Re.ection The \nTCH approach modi.es class names and method names (Section 2.4). Consequently, it must be adapted to \npreserve the behavior of the re.ection mechanisms of a lan\u00adguage. Since re.ection may be implemented \ndi.erently in each language, there is no generic solution for this problem. However, the following simple \ntechnique allows the support of the basic features of re.ection in most languages. In the instrumented \ncode, when invoking re.ection re\u00adlated methods, we perform translation between the original and the instrumented \nclass (or method) names. Each in\u00adput parameter of a re.ection method designating the name of a class \n(or a method) is converted to the TCH form (by addition of the TCH pre.x). Each output (usually the re\u00adturn \ntype) designating the name of a class (or a method) is converted to the non-TCH form. (Note that if a \nname is al\u00adready in the desired form, we leave it as is.) The translation is performed inside the re.ection-related \nmethods. For example, consider the methods forName and getName of the Java class java.lang.Class. The \nformer method re\u00adturns an instance of java.lang.Class that corresponds to its single string parameter. \nThe latter method, which does not have any parameters, returns the name of a class rep\u00adresented by the \ngiven instance of java.lang.Class.Inthe instrumented code, the class name parameter of forName, SomeClass \nis converted to TCH.SomeClass . Therefore, the returned instrumented class object represents the in\u00adstrumented \nclass rather than the original class. Thus, if  class TCH. File extends TCH. Object { private File \norigImpl ; // constructor public File (TCH. String name) { origImpl = new File (name. TCH toOrigString \n() ); } // write abyte to a file public void write ( byte b){ origImpl .write (b); } // read a byte \nfrom a file public byte read () { return origImpl .read (); } ... // other API methods } Figure 6: Implementation \nof an instrumented na\u00adtive class using the delegation pattern (in Java-like coding style). Note the string \nconversion in the con\u00adstructor. we use the returned class to create an instance, we will create an instance \nof the instrumented class and not the original. Similarly, the instrumented string returned by getName, \nTCH.SomeClass is translated to SomeClass . Consequently, if the returned string is compared to a hard\u00adcoded \nclass name string, the result of the comparison will be correct because the hardcoded names remain in \nnon-TCH form, despite the TCH transformations. 2.8 Built-in classes Contemporary languages have system \nclasses whose im\u00adplementation is integrated into the runtime. More specif\u00adically, the implementation \nof a subset of their methods is hardcoded. Such methods are called native in Java and internalcalls in \nC#. Henceforth, we conform to Java termi\u00adnology and call them native methods. System classes that contain \nnative methods will be referred to as native classes. Implementation of a native method is always bound \nto a particular method in a particular class. It can be accessed only by calling that method, but cannot \nbe reused in the im\u00adplementation of another method (or in another class). For example, consider the native \nmethod currentTimeMillis() de.ned in the Java class java.lang.System. Its implemen\u00adtation, which queries \nthe underlying OS for the current time, cannot be incorporated into some other class. Therefore, af\u00adter \nTCH class renaming, the native functionality is unavail\u00adable in the instrumented system classes. To correct \nthis, TCH must provide the instrumented system classes with an alternative implementation that simulates \nthe original API. We accomplish this by using the original version of a class in the implementation of \nits instrumented counterpart. This is possible only because the TCH approach allows the original and \nthe instrumented versions of a class to coexist. In most cases, an instrumented version of a native class \nis implemented as a wrapper around the original class. The wrapper methods delegate invocations of the \nnative API methods to an encapsulated instance of the original class. Figure 6 illustrates the implementation \nof the instrumented version of a hypothetical class File that originally had na\u00adtive APImethods to access \nthe .le it represents. If neces\u00adsary, the wrapper methods convert the parameters and the return type \nfrom TCH form to the original form and vice\u00adversa. Normally, only a small portion of the system classes \nare native. Most of these are related to re.ection, GUI, I/O, and networking. In Java they constitute \nabout 3% of the system classes. A much smaller portion is required to run most programs that do not contain \na GUI. We have success\u00adfully executed various applications, including SPECjbb, and applications that \nperform I/O and networking. 2.9 Applicability discussion Some techniques used to alleviate the side e.ects \nof the TCH approach are language speci.c. Therefore, in theory there can be a language to which TCH would \nbe inapplica\u00adble. TCH is a general methodology and not an algorithm. Thus, the techniques to alleviate \nits side e.ects should be perceived as guidelines rather than speci.c instructions. If a certain issue \ncannot be resolved by the proposed tech\u00adniques, then language-speci.c solutions should be sought. The \nstrength of TCH is in the fact that once all issues are resolved for a particular language, it can be \nautomatically employed by any general purpose instrumentation in that language.  3. FACILITATING INSTRUMENTATION \nOF SYSTEM CLASSES Code instrumentation can be performed statically, be\u00adfore the execution begins, or \ndynamically at run time. The special status of system classes makes their transformation problematic \nin both modes. TCH eliminates most of the dif\u00ad.culties, because, after renaming, the instrumented versions \nof system classes are no longer part of the standard class li\u00adbraries but are rather user classes, which \nare much easier to instrument. In contrast to the instrumentation frameworks that allow arbitrary transformations \nof all system classes, TCH does not require modi.cation of any components of the language infrastructure, \ne.g., the compiler or the run\u00adtime. In this section, due to a variety of language-speci.c mech\u00adanisms \nand issues, we focus our discussion on Java. How\u00adever, most of it is valid for other frameworks with \ndynamic loading, including the .NET platform. 3.1 Static instrumentation If the instrumentation does \nnot modify the class names, static instrumentation of system classes must force the run\u00adtime to use the \ninstrumented versions instead of the origi\u00adnals. This may not always be possible, because the system \nclasses may be deeply integrated into the runtime. In Java, most popular JVMs, e.g., Sun and IBM JDKs, \nprovide a command line option that allows the user to spec\u00adify the path from which system classes should \nbe loaded. In the JDKs mentioned above, it is also possible to change the implementation of system classes \nby modifying the con\u00adtents of the .le rt.jar in which most of the system classes are stored. Unfortunately, \nneither option is standardized. Therefore, in theory, there may be a valid JVM that does not allow static \ninstrumentation of system classes. With TCH class name transformation, the instrumented system classes \nbecome user classes. Therefore, they are loaded as ordinary user classes, not instead of, but in addi\u00adtion \nto their original versions, rendering the need to replace them or update their loading path obsolete. \nThus, TCH avoids potential portability problems. Runtime environments can make assumptions regarding \nthe structure and loading order of system classes. If these assumptions do not hold, a runtime may terminate \nabnor\u00admally, often without a comprehensive error message. For ex\u00adample, most JVM implementations make \nassumptions about the size of the classes java.lang.Object, java.lang.Class and java.lang.String. If \nthe instrumentation process aug\u00adments one of these classes with a .eld, the JVM crashes. It will also \ncrash if the loading order is changed as a result of instrumenting the above classes. Note that these \nproblems arise not only in static but also in dynamic instrumenta\u00adtion. TCH lets the JVM keep the original \nde.nitions of the problematic classes, thus avoiding these di.culties. 3.2 Dynamic instrumentation The \nmain advantage of dynamic instrumentation is that it does not require apriori knowledge of the classes \nused by a program (closed world assumption). Since re.ection allows the loading of classes whose identity \nis determined at run time, it may be impossible to determine the transitive clo\u00adsure of classes used \nby a program. Moreover, classes created at run time can only be instrumented dynamically. The most important \nchallenge in dynamic instrumenta\u00adtion is to intercept all the classes employed by an ap\u00adplication. In \nmost runtimes, it is di.cult to intercept system classes. In Java, there are two main obstacles. Both \nare related to the Java class loading mechanism, which is used by most contemporary frameworks to im\u00adplement \ndynamic instrumentation. First, a subset of sys\u00adtem classes (approximately 200 in Sun JDK 1.4.2) is al\u00adready \nloaded by the JVM, before the class loading mech\u00adanism can be modi.ed to enable rewriting. Since most \nof these preloaded classes are used extensively by non\u00adtrivial applications, it is important that they \ncan be in\u00adstrumented. (Among the preloaded classes are: java.lang.-Integer, java.lang.String, java.util.HashMap, \njava.\u00adlang.Thread.) Second, the class loading mechanism at\u00adtempts to ensure that the system classes are \nde.ned by the bootstrap class loader. Since the bootstrap class loader is integrated into the JVM, the \nuser cannot gain any control over it without modifying the JVM, which is highly unde\u00adsirable. Consequently, \nit is hard to modify the de.nition of a system class. Existing portable load-time instrumentation frameworks, \nsuch as JMangler [13], Javassist [7], JOIE [8], BCEL [9], As\u00adpectWerkz [2], and JBoss AOP [4], do not \ninstrument system classes (due to the problems mentioned above). The frame\u00adworks that are capable of \ninstrumenting system classes, e.g., [12] and [10], compromise portability by modifying the JVM or the \nunderlying DLLs. Our recent communication with the representatives of JMangler, AspectWerkz, and JBoss \nAOP has revealed their desire to perform dynamic transformation of system classes as well as their inability \nto accomplish this. The TCH approach accomplishes dynamic instrumenta\u00adtion of Java system classes. TCH \ndoes not su.er from the problems mentioned above because it renames system classes, thus transforming \nthem into user classes. Since most runtimes (with dynamic loading) allow dynamic instru\u00admentation of \nuser classes, TCH e.ectively allows all system if the name of requested class starts with tch. : read \nthe original class produce its tch version apply the purpose-specific transformations otherwise : load \nthe class in the usual way Figure 7: Dynamic class loading procedure classes to be instrumented without \nany modi.cation of the runtime infrastructure. To the best of our knowledge, TCH is the only technique \nthat achieves this in Java. 3.2.1 TCH-based dynamic instrumentation in Java In Java and similar frameworks, \nsuch as .NET Common Language Runtime, TCH supports dynamic instrumenta\u00adtion in the following way. Let \nAppMain be the class that contains the main method of the application to be executed. At the beginning \nof the execution, we convert the string parameters of the main method into TCH form. Then, we hook into \nthe class loading system either by installing a cus\u00adtom class loader, as is done in Javassist, or by \nreplacing the de.nition of the system class loader (java.lang.ClassLo\u00adader), as is done in JMangler. \nAfter that, we instruct the adapted class loading system to load TCH.AppMain,and then employ re.ection \nto execute its main method. When asked to load a class whose name begins with TCH. , e.g., TCH.somePackage.SomeClass, \nthe adapted class loading mechanism fetches the de.nition of the correspond\u00ading original class (somePackage.SomeClass) \nfrom the load\u00ading path, and then sequentially applies to it the TCH and purpose-speci.c transformations, \nas described in the begin\u00adning of Section 2. When asked to load a class whose name does not begin with \nTCH. , the adapted class loader loads the class without applying any transformations to it. The above \nprocedure is summarized in Figure 7. The entire twin hierarchy, including the system classes, is produced \non the .y. The implementation of TCH versions of native system classes described in Section 2.8 is hardcoded \ninto the transformer and thus can also be generated dynam\u00adically. Alternatively, the TCH versions of \nsystem classes can be produced statically, while the TCH versions of user classes are produced dynamically. \n  4. TCH OVERHEAD ANALYSIS We estimate the overhead of TCH using sequential ap\u00adplications from the \nJava Grande Forum (JGF) Benchmark Suite (version 2.0) [6] and the SPECjbb benchmark [5], which is probably \nthe most important existing benchmark for server-side Java. We compare the throughput of the original \nprograms with their TCH counterparts, which are produced statically. The measurements were performed \non Intel s dual-processor machine, 2x1.7 GHz with 1 GB mem\u00adory, using Sun JDK 1.4.2. The sequential benchmarks \nin the JGF benchmark suite are divided into three categories. The .rst one measures the performance of \nlow level operations such as arithmetic, casts, assignments, allocation of data, exceptions, loops, and \nmethod invocations. The applications in the second cate\u00ad Table 1: JGF Benchmark Suite microbenchmark \nresults. Due to space limitations we present only a subset of benchmarks. The throughput di.erence of \nthe omitted benchmarks is insigni.cant. Benchmark Original TCH Di.erence (%) Units Arith:Add:Int 864733630 \n852847490 1.37 (adds/s) Arith:Add:Long 192838016 188321840 2.34 (adds/s) Arith:Add:Float 1484273.1 1482983.4 \n0.09 (adds/s) Arith:Add:Double 1485996.2 1481910.2 0.27 (adds/s) Arith:Mult:Int 116997232 116747128 0.21 \n(multiplies/s) Arith:Mult:Long 59741112 60856160 -1.87 (multiplies/s) Arith:Mult:Float 1522337 1519513.2 \n0.19 (multiplies/s) Arith:Mult:Double 1464426.1 1457029 0.51 (multiplies/s) Assign:Same:Scalar:Local \n2362722050 2344758530 0.76 (assignments/s Assign:Same:Scalar:Instance 911725950 917389310 -0.62 (assignments/s \nAssign:Same:Scalar:Class 737395200 736152770 0.17 (assignments/s Assign:Other:Scalar:Instance 295890272 \n296040640 -0.05 (assignments/s Assign:Other:Scalar:Class 268851840 267262064 0.59 (assignments/s Cast:IntFloat \n50712684 50638232 0.15 (casts/s) Cast:IntDouble 50532808 50759816 -0.45 (casts/s) Create:Array:Int:16 \n7181555 6869601.5 4.34 (arrays/s) Create:Array:Int:32 4960039 4688108 5.48 (arrays/s) Create:Array:Long:1 \n9575687 9376753 2.08 (arrays/s) Create:Array:Long:2 9238229 9014085 2.43 (arrays/s) Create:Array:Long:64 \n1286189.8 1214997.6 5.54 (arrays/s) Create:Array:Long:128 717790.56 672445.5 6.32 (arrays/s) Create:Array:Object:1 \n9900894 9530014 3.75 (arrays/s) Create:Array:Object:2 9549455 9252315 3.11 (arrays/s) Create:Array:Object:4 \n9270639 9013093 2.78 (arrays/s) Create:Array:Object:8 8566349 8227791 3.95 (arrays/s) Create:Object:Simple \n2048000 1788802.5 12.66 (objects/s) Create:Object:Simple:Constructor 2032149.2 1788802.5 11.97 (objects/s) \nCreate:Object:Simple:1Field 1933169.8 1709515.9 11.57 (objects/s) Create:Object:Subclass 2038216.5 1764908.6 \n13.41 (objects/s) Create:Object:Complex 1678138.4 1481374.4 11.73 (objects/s) Exception:New 196439.53 \n141303.75 28.07 (exceptions/s) Exception:Method 185749.53 135227.94 27.20 (exceptions/s) Loop:For 511600320 \n505679008 1.16 (iterations/s) Loop:ReverseFor 511201248 482592032 5.60 (iterations/s) Math:AbsLong 37215220 \n37261768 -0.13 (operations/s) Math:AbsDouble 31678268 31813592 -0.43 (operations/s) Math:MaxFloat 28885754 \n28957228 -0.25 (operations/s) Math:MaxDouble 29534024 28959788 1.94 (operations/s) Math:MinLong 33553144 \n31863088 5.04 (operations/s) Math:MinDouble 29999084 28429638 5.23 (operations/s) Math:SinDouble 8395163 \n8399036 -0.05 (operations/s) Math:CosDouble 7619756.5 7624011 -0.06 (operations/s) Math:AtanDouble 4082934.5 \n4059867.2 0.56 (operations/s) Math:Atan2Double 3620613.5 3464433.8 4.31 (operations/s) Math:FloorDouble \n4026740 3768169.2 6.42 (operations/s) Math:PowDouble 750348.06 788845.25 -5.13 (operations/s) Math:RintDouble \n4026344.2 3810941.5 5.35 (operations/s) Math:RoundFloat 2788671 2745308.2 1.55 (operations/s) Math:IEEERemainderDouble \n422791.1 422895.84 -0.02 (operations/s) Method:Same:Instance 159960944 158750080 0.76 (calls/s) Method:Same:SynchronizedInstance \n5423729 5422652 0.02 (calls/s) Method:Same:FinalInstance 174646240 168646416 3.44 (calls/s) Method:Same:Class \n175735072 175511520 0.13 (calls/s) Method:Other:Instance 31480450 31538018 -0.18 (calls/s) Method:Other:InstanceOfAbstract \n31528914 31538018 -0.03 (calls/s) Method:Other:Class 39130644 39163380 -0.08 (calls/s) Average of all \nJGF microbenchmarks 3.01 Table 2: Benchmark application results Benchmark Original TCH Di.erence (%) \nUnits SPECjbb 6727 6524 3.02 (Operations/s) Series LUFact HeapSort Crypt FFT SOR SparseMatmult 488.05 \n192.70 634678.90 2235.01 129814.42 16.84 12.72 533.15 189.64 632111.25 2239.02 138070.45 16.14 12.76 \n-9.24 1.59 0.40 -0.18 -6.36 4.15 -0.24 (Coe.cients/s) (M.ops/s) (Items/s) (Kbyte/s) (Samples/s) (Iterations/s) \n(Iterations/s) Euler MolDyn MonteCarlo RayTracer AlphaBetaSearch 4.44 181487.31 406.16 1183.73 798061.56 \n4.67 187443.61 277.48 1249.95 798356.90 -5.18 -3.28 31.68 -5.59 -0.04 (Timesteps/s) (Interactions/s) \n(Samples/s) (Pixels/s) (Positions/s) gory are short codes that carry out speci.c operations fre\u00adquently \nused in Grande applications. The third category consists of large scale applications that demonstrate \nJava s potential in tackling real problems. With few exceptions, the comparison shows that the per\u00adformance \nof the rewritten bytecodes is close to their original performance. Tables 1 and 2 summarize the results. \nThe for\u00admer presents the throughput of microbenchmarks from the .rst section of the JGF benchmark suite. \nThe latter presents the results of SPECjbb and of the remaining applications from the JGF benchmark suite. \nThe Di.erence column shows the di.erence between the original and instrumented benchmarks. Let A and \nB be the throughputs of the origi\u00adnal benchmark and its TCH version respectively. The corre\u00adsponding \nvalue in the Di.erence column is 100*(A-B)/A. Consequently, a positive value indicates higher throughput \nof the original application. The most signi.cant performance di.erence in Table 1 is observed for object \ncreation benchmarks (denoted by the pre.x Create:Object ), and exception benchmarks (de\u00adnoted by the \npre.x Exception ). In both cases, the dif\u00adference is caused by the increased cost of creating rewrit\u00adten \nobjects. This increased cost is due to the fact that these objects inheritance chain is augmented with \nan addi\u00adtional class at the top of the hierarchy (java.lang.Object or java.lang.Throwable; see Figure \n1). As a result, an ad\u00additional constructor needs to be called during their creation. The instrumentation \noverhead in SPECjbb (Table 2) is only 3%. The most signi.cant throughput di.erence among the macrobenchmarks \nis observed in the Monte Carlo bench\u00admark, whose throughput decreases by 32% as a result of the instrumentation. \nThe Monte Carlo benchmark extensively uses the class java.util.Random, whose methods are often inlined \nby the just-in-time compiler (JIT). However, the JIT does not inline the counterparts of these methods \nin the in\u00adstrumented code, which causes a decrease in performance.  5. APPLICATIONS OF TCH We have employed \nTCH in Java to implement two byte\u00adcode instrumentation-based systems: (i) a memory pro.ler, and (ii) \na distributed runtime for Java. In both systems the instrumentation is performed using the Bytecode Engineer\u00ading \nLibrary (BCEL) [9]. 5.1 Memory pro.ler Our memory pro.ler is a tool for gathering memory alloca\u00adtion \nstatistics. It can be used to explore memory usage and detect memory leaks in any Java program. The bytecode \nin\u00adstrumentation is performed dynamically, by intercepting the class loading process with the BCEL custom \nclass loader. The pro.ling transformation intercepts all bytecode in\u00adstructions used in object and array \ncreation (i.e., new, newarray, anewarray,and multinewarray). It also in\u00adtercepts the system APIcalls \nthat create new object instances, i.e., java.lang.Object.clone(),and java.\u00adlang.reflect.Constructor.newInstance(Object[]). \nIn the bytecode, after each such allocation event, the pro.ler transformer inserts a call to a special \nhandler. This handler may record any interesting data associated with the event, e.g., the class of the \ncreated object, its size, the time of its creation, etc. (The newly created object is passed as a parameter \nto the handler.) The pro.ling transformation augments each class with a method that returns its instance \nsize. The pro.ler handler accesses the internal pro.ler logic, which is implemented in pure Java. The \nimplementation of the pro.ler logic extensively uses system classes, e.g., java.\u00adlang.System, java.util.Hashtable, \njava.util.Linked-List, java.util.Iterator, java.io.PrintStream,and ja\u00adva.io.FileOutputStream. For example, \nan instance of class java.util.Hashtable is used for mapping between a class name and a counter of allocated \nclass instances. An instance of java.util.LinkedList is used to record the times of allocation events. \nInstances of class java.io.-FileOutputStream are used to spool the collected data to .les. (The .les \nare used during the execution because the ac\u00adcumulated data may be too large, especially in long-running \napplications.) TCH bene.ts the pro.ler in two ways. First, it allows the pro.ler to explore applications \nthat use the same system classes that it uses in its implementation. While the ap\u00adplication uses the \ninstrumented system classes, the pro.ler logic employs their original counterparts. Thus, the origi\u00adnal \nfunctionality of system classes remains available to the pro.ler. Without TCH, the pro.ler would have \nto use the instrumented system classes, which would result in in.nite recursion. Second, TCH enables \nthe pro.ler to instrument Table 3: Pro.ler output object and array allocations in SPECjbb Class User \nclasses System classes count % count % char[] TCH.java.lang.String TCH.java.util.Hashtable$Entry[] TCH.java.util.Hashtable$Entry \nint[] java.lang.Object[] 567268 8099041 0 0 76235 700428 22.27 85.35 0.00 0.00 99.65 99.98 1979950 1390047 \n76188 38097 270 163 77.73 14.65 100.00 100.00 0.35 0.02 all system classes (dynamically). Consequently, \nit can col\u00adlect more accurate results. If the pro.ler instrumented only user classes, then allocations \nperformed within the system classes would not be detected. If system classes are not modi.ed, then allocations \nof arrays and system class ob\u00adject instances that are performed within the code of system classes are \nimpossible to intercept. By contrast, allocations of user class instances can still be intercepted by \nmodifying their constructors. Table 3 illustrates the importance of the second feature in pro.ling of \nthe SPECjbb benchmark. The table presents the .nal values of creation counters of several classes used \nby the benchmark. The columns User classes and Sys\u00adtem classes indicate the number of instances created \nin user classes and system classes respectively. The table shows that a large number of allocations occur \nwithin the code of the system classes. For example, most character arrays (char[]) are allocated within \nthe system classes. Moreover, the cre\u00adation of the system classes java.util.Hashtable$Entry[] and java.util.Hashtable$Entry \noccurs only within the system code. Without the ability to instrument system classes, all these allocations \nwould remain undetected. 5.1.1 Related systems The Cougaar Memory Pro.ler (CMP) [3] is a bytecode instrumentation-based \ntool for memory pro.ling of Java programs. The developer selects which classes should be tracked and \nruns an automated class .le editor (using BCEL) to add pro.ling instructions to the constructors. The \npro.ler maintains pointers to the live instances and can display various useful debugging information, \ne.g.,the total number of allocations of a pro.led class, including the number of live and garbage-collected \ninstances. In contrast to our memory pro.ler, the instrumentation is performed statically, i.e., before \nthe execution. Until recently, CMP did not have any support for pro.ling Java system classes. Currently, \nit allows the user to (stati\u00adcally) transform the classes in system packages. The instru\u00admented classes \nare loaded into the JVM by means of the command line option -Xbootclasspath, which allows an al\u00adternative \nlocation of the system classes to be speci.ed when starting the JVM. The CMP manual advises users to \navoid modifying system classes as much as possible in order to prevent the potential loading errors that \noccur if the pro.ler s code uses system classes that are being analyzed. The manual states that ... acall \nto new HashSet() will fail if HashSet is pro.led, due to a stack over.ow caused by the circular reference. \nSimi\u00adlarly, if all of java.lang willbe pro.led, then Strings should be carefullyhandled to avoid string \nallocations, including any calls to System.out. By contrast, TCH allows our memory pro.ler to easily \nanalyze any system class, even when this system class is used in the pro.ler s logic.  5.2 Instrumenting \nJava bytecode for distributed execution We have employed the TCH approach to implement a portable distributed \nruntime for multithreaded Java, which we call JavaSplit [11]. JavaSplit uses bytecode instrumenta\u00adtion \nto transparently distribute the threads and objects of a standard Java application among the available \nmachines. The instrumentation intercepts events that are interesting in the context of distributed execution, \nsuch as thread cre\u00adation, accesses to shared data, and synchronization. Shared data is managed by an \nobject-based distributed shared mem\u00adory (DSM). All the runtime logic, including DSM, is imple\u00admented \nin pure Java. Therefore, each node carries out its part of the distributed computation using nothing \nbut its lo\u00adcal standard (unmodi.ed) JVM. JavaSplit employs IP-based communication, accessing the network \nthrough the standard Java socket interface. The distinguishing feature of JavaSplit is its portability. \nThe use of standard JVMs in conjunction with IP-based communication allows virtually any commodity workstation \nto join JavaSplit. Moreover, a new node does not need to install any software or hardware. It needs only \nto receive the application bytecode and the runtime modules (both of which it can get by means of the \ncustomizable class loading mechanism). The correctness and consistency of the JavaSplit system depends \non its ability to intercept various events such as ac\u00adcesses to shared data, lock operations, etc. Therefore, \nJava-Split must be able to instrument any Java class required by the original application, including \nthe Java system classes. Using TCH enables JavaSplit to achieve this goal by allevi\u00adating the di.culties \nof transforming Java system classes, as describedinSection 3. Many system classes are used in the implementation \nof the JavaSplit runtime modules. In particular, we make extensive use of classes from the java.util, \njava.io,and java.net packages. The java.util package provides JavaSplit mod\u00adules with complex data structures. \nThe other two packages are used for I/O and networking. TCH enables the origi\u00adnal versions of these classes, \nwhich are used by the runtime modules, to coexist with their instrumented counterparts, which are required \nby the application. Without TCH we would have had to use the instrumented versions of system classes \nin the runtime modules, or else avoid using system classes in the runtime modules com\u00adpletely. Neither \noption is practical. The former would result in erroneous behavior of the runtime modules, e.g., in.nite \nrecursion. The latter would require reimplementing the data structures from java.util, as well as the \nI/O and network\u00ading facilities. While reimplementing data structures from java.util would be a long, \ntedious task, reimplementing the I/O and networking would require incorporating user\u00adde.ned native methods \nin the runtime code, thus compro\u00admising portability. 5.2.1 Related systems Like JavaSplit, J-Orchestra \n[16] partitions Java applica\u00adtions for distributed execution through bytecode instrumen\u00adtation. However, \nthe goal of partitioning is di.erent. While JavaSplit creates a supercomputer from interconnected com\u00admodity \nworkstations, J-Orchestra aims to split a centralized application into distinct entities running on the \nmost func\u00adtionally suitable sites. For example, J-Orchestra may ex\u00adecute a computation intensive application \nwith a GUIon two machines: one with a fast processor and another with a graphical screen. Unlike JavaSplit, \nwhich employs an object\u00adbased distributed shared memory and monitors accesses to the shared data, J-Orchestra \nuses proxies to access remote objects. It substitutes method calls and direct object ref\u00aderences with \nremote method calls and proxy references re\u00adspectively. The key di.erence between the two systems is \nin the treat\u00adment of Java system classes with native dependencies (i.e., classes that have native methods \nor can be accessed from such classes). In J-Orchestra they are perceived as unmodi.\u00adable code and therefore \ncannot be rewritten to access remote objects through a proxy. This results in certain constraints on \nthe data placement. All instances of a system class with native dependencies are placed on the same node. \nMore\u00adover, any class that can be referenced from it must also be placed on that node. Due to the strong \nclass dependencies within Java packages, this usually results in partitions that coincide with package \nboundaries. In contrast, JavaSplit supports arbitrary partitioning because TCH allows even system classes \nwith native dependencies to be rewritten for distributed execution. Addistant [15] is yet another system \nthat partitions Java programs. Like J-Orchestra, it aims at functional distribu\u00adtion, rather than high \nperformance computing. It instru\u00adments Java bytecode at load-time using the Javassist [7] framework. \nLike J-Orchestra, it employs the remote proxy model to bridge between objects on di.erent nodes. As a \nresult of the di.culties described in Section 3.2, Addistant is unable to transform system classes at \nload-time. There\u00adfore, it introduces several bytecode rewriting workarounds, the applicability of which \ndepends on the type of interaction between the classes. The creators of Addistant admit that even if \nall system classes could, like user classes, be rewrit\u00adten, it would still be hard to modify them consistently, \nsince ...certain runtime systems such as a system class loader depend on the de.nition of the system \nclasses. This is ad\u00additional evidence of the circular dependency introduced by the requirement to use \na single (instrumented) version of a class. The use of TCH would allow Addistant to mod\u00adify all system \nclasses dynamically while avoiding the in.nite recursion problem. Figure 8: Summary of existing interception \ntech\u00adniques for JVM  6. RELATED INSTRUMENTATION APPROACHES The key idea in the TCH approach is creation \nof a hi\u00aderarchy of instrumented classes isomorphic to the original one. This idea has been employed (for \nsubsets of classes) in the context of application partitioning [15, 16], mainly to implement hierarchies \nof proxies used to access remote ob\u00adjects. The inheritance relationship between the proxy classes is \nmade identical to that of the original classes in order to allow a variable of type proxy of A to contain \na reference to a proxy of any subclass of A. J-Orchestra [16], already mentioned in Section 5.2.1, has \nan instrumentation approach closest to that of TCH. It cre\u00adates class hierarchies that mimic the structure \nof the orig\u00adinal one. It di.ers from TCH mainly in that each isomor\u00adphic hierarchy is created only for \na subset of classes. For two system classes with native dependencies, A and its sub\u00adclass B, J-Orchestra \ngenerates two proxies, anchored.A and anchored.B, the latter subclassing the former. For other classes, \nJ-Orchestra makes the names of the proxy classes identical to the original class names, whereas the names \nof the real application classes are augmented with the su.x remote . For example, two classes, A and \nits subclass B, are renamed A remote and B remote, the latter subclassing the former. 7. LOAD-TIME INSTRUMENTATION \nFRAMEWORKS In this section we overview the existing frameworks for dy\u00adnamic instrumentation of Java bytecode, \nfocusing on their ability to intercept system classes. Figure 8 illustrates the various approaches to \nclass interception. Our main obser\u00advation is that, without the use of TCH, only nonportable techniques \nallow instrumenting system classes at run time. 7.1 Custom class loaders The Java class loading mechanism \nallows users to in\u00adstall custom class loaders to intercept class .les at load\u00adtime. A custom class loader \nmust subclass the system class java.lang.ClassLoader. Thisstrategy isemployed by Javassist [7], JOIE \n[8], and BCEL [9]. The applicabil\u00adity of this approach is limited to applications that do not use their \nown custom class loaders. This is because only one class loader can a.ect the de.nition of a class when \nit is being loaded. Without TCH, a custom class loader can\u00adnot intercept all system classes because of \nthe di.culties described in section 3.2, such as the preloaded classes prob\u00adlem. 7.2 JVM dependent interception \nThe behavior of the class loading mechanisms can be af\u00adfected by modifying the implementation of the \nJVM. Binary Component Adaptation (BCA) [12] introduces an adapta\u00adtion module for transforming the internal \nJVM data struc\u00adture that represents a loaded class. Unlike most instrumen\u00adtation frameworks, BCA allows \nthe system classes to be re\u00adde.ned. Unfortunately BCA requires a custom JVM, thus compromising portability. \n 7.3 Library-based interception Duncan and H\u00a8olzle [10] introduce library-based load time adaptation. \nThey intercept and modify the class .les as they are being fetched from the .le system. This is achieved \nby modifying a dynamically-linked standard library that is re\u00adsponsible for reading .les. Like BCA, this \napproach allows instrumentation of system classes at the expense of porta\u00adbility. It requires that a \ncustom DLL be provided for every operating system. 7.4 Class loader independent interception JMangler \n[13] provides a portable interception facility, which, unlike Javassist, BCEL and JOIE, allows the ap\u00adplication \nto use custom class loaders. This is achieved by providing a modi.ed version of the .nal method defineClass() \nin the class java.lang.ClassLoader.Be\u00adcause the modi.ed behavior is enforced for every subclass of java.lang.ClassLoader, \nJMangler is activated whenever an application-speci.c class is loaded. In contrast to BCA and DLL-based \nload-time adaptation, this approach is lim\u00adited because it cannot transform system classes without em\u00adploying \nTCH.  8. CONCLUSION We have presented TCH, a general instrumentation strat\u00adegy capable of instrumenting \nsystem classes while avoiding the associated pitfalls. In contrast to those few approaches [10, 12] that \nallow arbitrary transformations of system classes, TCH does not modify the language infrastructure and \nis therefore portable. Most existing instrumentation\u00adbased systems do not transform system classes, thus \nmaking an unnatural distinction between user-de.ned and system classes. Consequently, these systems either \ninvest consider\u00adable e.ort in .nding context-speci.c solutions to overcome their inability to transform \nsystem classes, or limit their functionality to user classes. The TCH approach provides these systems \nwith an opportunity to overcome their limi\u00adtations and .nd simpler and more e.cient ways to achieve their \ngoals without compromising portability.  9. REFERENCES [1] The AspectJ home page. http://eclipse.org/aspectj/. \n[2] The AspectWerkz home page. http://aspectwerkz.codehaus.org. [3] The Cougaar Memory Pro.ler home \npage. http://cougaar.org/projects/pro.ler/ or http://pro.ler.cougaar.org.  [4] The JBoss AOP project \nhome page. http://www.jboss.org/developers/projects/jboss/aop.jsp. [5] The Standard Performance Evaluation \nCorporation. SPEC JBB 2000. http://www.spec.org/osg/jbb2000/. [6] J. M.Bull, L. A. Smith, M. D. Westhead,D.S.Henty, \nand R. A. Davey. A benchmark suite for high performance Java. Concurrency: Practice and Experience, 12(6):375 \n388, 2000. [7] S. Chiba. Load-time structural re.ection in Java. Lecture Notes in Computer Science, \n1850:313 336, 2000. [8] G. Cohen, J. Chase, and D. Kaminsky. Automatic program transformation with JOIE. \nIn 1998 USENIX Annual Technical Symposium, pages 167 178, 1998. [9] M. Dahm. Byte code engineering. \nIn Java-Informations-Tage, pages 267 277, 1999. [10] A. Duncan and U. H\u00a8olzle. Load-time adaptation: \nE.cient and non-intrusive language extension for virtual machines. Tech. Rep. 99-09, Department of Computer \nScience, February 1999. [11] M. Factor, A. Schuster, and K. Shagin. JavaSplit: A runtime for execution \nof monolithic Java programs on heterogeneous collections of commodity workstations. In IEEE Fifth Int \nl. Conference on Cluster Computing, pages 110 119, Hong Kong, December 2003. [12] R. Keller and U. H\u00a8olzle. \nBinary component adaptation. Lecture Notes in Computer Science, 1445, 1998. [13] G. Kniesel, P. Costanza, \nand M. Austermann. JMangler a framework for load-time transformation of Java class .les. In IEEE International \nWorkshop on Source CodeAnalysis andManipulation(SCAM), 2001. [14] T. Lindholm and F. Yellin. The JVM \nSpeci.cation, 2nd edition. Addison-Wesley, 1999. [15] M. Tatsubori, T. Sasaki, S. Chiba, and K. Itano. \nA bytecode translator for distributed execution of legacy Java software. Lecture Notes in Computer Science, \n2072, 2001. [16] E. Tilevich and Y. Smaragdakis. J-Orchestra: Automatic Java application partitioning. \nIn European Conference on Object-Oriented Programming (ECOOP), Malaga, Spain, June 2002.  \n\t\t\t", "proc_id": "1028976", "abstract": "<p>Code instrumentation is widely used for a range of purposes that include profiling, debugging, visualization, logging, and distributed computing. Due to their special status within the language infrastructure, the &#60;i>standard class libraries&#60;/i>, also known as &#60;i>system classes&#60;/i> provided by most contemporary object-oriented languages are difficult and sometimes impossible to instrument. If instrumented, the use of their rewritten versions within the instrumentation code is usually unavoidable. However, this is equivalent to `instrumenting the instrumentation', and thus may lead to erroneous results. Consequently, most systems avoid rewriting system classes. We present a novel instrumentation strategy that alleviates the above problems by renaming the instrumented classes. The proposed approach does not require any modifications to the language, compiler or runtime. It allows system classes to be instrumented both statically and dynamically. In fact, this is the first technique that enables dynamic instrumentation of Java system classes without modification of any runtime components. We demonstrate our approach by implementing two instrumentation-based systems: a memory profiler and a distributed runtime for Java.</p>", "authors": [{"name": "Michael Factor", "author_profile_id": "81100211658", "affiliation": "IBM Research Lab in Haifa, Haifa University Campus, Haifa, Israel", "person_id": "PP14082918", "email_address": "", "orcid_id": ""}, {"name": "Assaf Schuster", "author_profile_id": "81100625706", "affiliation": "Israel Institute of Technology, Technion City, Haifa, Israel", "person_id": "P22680", "email_address": "", "orcid_id": ""}, {"name": "Konstantin Shagin", "author_profile_id": "81100569910", "affiliation": "Israel Institute of Technology, Technion City, Haifa, Israel", "person_id": "P397724", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1028976.1029000", "year": "2004", "article_id": "1029000", "conference": "OOPSLA", "title": "Instrumentation of standard libraries in object-oriented languages: the twin class hierarchy approach", "url": "http://dl.acm.org/citation.cfm?id=1029000"}