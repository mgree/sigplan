{"article_publication_date": "10-01-2004", "fulltext": "\n Pluggable Veri.cation Modules: An Extensible Protection Mechanism for the JVM Philip W. L. Fong Department \nof Computer Science University of Regina Regina, Saskatchewan, Canada S4S 0A2 pwlfong@cs.uregina.ca \nABSTRACT Through the design and implementation of a JVM that sup\u00adports Pluggable Veri.cation Modules \n(PVMs), the idea of an extensible protection mechanism is entertained. Link-time bytecode veri.cation \nbecomes a pluggable service that can be readily replaced, recon.gured and augmented. Appli\u00adcation-speci.c \nveri.cation services can be safely introduced into the dynamic linking process of the JVM. This feature \nis enabled by the adoption of a previously proposed mod\u00adular veri.cation architecture, Proof Linking \n[23, 24], which decouples bytecode veri.cation from the dynamic linking process, rendering the veri.er \na replaceable module. The PVM mechanism has been implemented in an open source JVM, the Aegis VM [21]. \nTo evaluate the software engineer\u00ading and security engineering bene.ts of this extensible pro\u00adtection \nmechanism, an augmented type system JAC (Java Access Control) [37] has been successfully implemented \nas a PVM.  Categories and Subject Descriptors D.2.0 [Software Engineering]: General protection mech\u00adanisms; \nD.3.4 [Programming Languages]: Processors run-time environments; D.3.2 [Programming Languages]: Language \nClassi.cation object-oriented languages, macro and assembly languages; D.2.11 [Software Engineering]: \nSoftware Architectures domain-speci.c architectures; D.4.6 [Operating Systems]: Security and Protection \naccess con\u00adtrols General Terms Security, Languages, Veri.cation  Keywords Pluggable veri.cation modules, \nproof linking, extensible pro\u00adtection mechanism, Java virtual machine, bytecode veri.ca\u00adtion, Aegis VM, \nmobile code security, extensible systems Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. OOPSLA 04, Oct. 24 28, 2004, Vancouver, British Columbia, Canada. Copyright \n2004 ACM 1-58113-831-8/04/0010 ...$5.00. 1. INTRODUCTION As our society becomes increasingly aware of \nthe need for secure computing infrastructures, the programming lan\u00adguage community has invested in recent \nyears an unprece\u00addented interest in the interplay between software security and programming language \nenvironments. One emerging challenge arises from the growing popularity of Dynamically Extensible Software \nSystems, such as mobile code language environments [11, 53], scriptable applications, and software systems \nwith plug-in architectures [5, 19, 44]. In such sys\u00adtems, executable extensions can be dynamically linked \ninto the address space of a host software system, either to deliver a short lived service, or to augment \nthe capability of the un\u00adderlying host in a permanent manner. If adopted unchecked, malicious software \nextensions could compromise the security of the host. An e.ective protection approach is to mandate the \nuse of a safe language for programming software ex\u00adtensions. Strongly typed object-oriented programming \nlan\u00adguages, with support for enforcing data encapsulation on the one hand, and support for constructing \nextensible ap\u00adplication framework on the other, becomes a natural linguis\u00adtic choice. Such an approach \nforms the security foundation of the Java Virtual Machine (JVM) [39], an archetypical platform for constructing \nextensible systems. Software ex\u00adtensions are compiled into strongly typed intermediate code units called \nclass.les, which are in turn typechecked by a bytecode veri.er at the time of dynamic loading. Since \nbyte\u00adcode veri.cation is an integral part of the classloading se\u00admantics, typechecking is therefore nonbypassable. \nFuture applications of the JVM will likely demand ad\u00additional forms of veri.cation to provide enhanced \nlevels of protection. To address this need, the attention of scholar\u00adship has turned to safety properties \nthat go beyond sim\u00adple type safety . These application-speci.c safety proper\u00adties are captured in augmented \ntype systems [12, 55, 7, 37, 2], annotation languages [33, 1], and other forms of static analyses. One \ncritique of these works is that the notion of safety is often formulated as a compile-time property, \nen\u00adforced by the code producer, at the level of the source lan\u00adguage. In the context of the JVM, in which \ncode units bind via dynamic linking, program veri.cation that is performed against source code, or administrated \nonly by the code pro\u00adducer, cannot be trusted. Unfortunately, given the inherent complexity of Java s \ndynamic linking process, and its tight coupling with the bytecode veri.er, programming alterna\u00adtive static \nanalyses into the existing bytecode veri.cation procedure is an extremely taxing and error-prone exercise. \nThis partly explains why it is rare to see the mentioned works materialize into link-time protection \nmechanisms for the JVM. This analysis reveals a fundamental design .aw in the protection architecture \nof the JVM, in which the link\u00adtime static veri.cation service is a .xture that cannot be extended conveniently. \nAs new security needs arise, there exists no mechanism whereby alternative static analyses can be retro.tted \ninto the dynamic linking process of the run\u00adtime system. This problem is in no way speci.c to the JVM: \nthe critique applies equally to other safe language environ\u00adments such as the Common Language Infrastructure \n(CLI) [18]. Through the design and implementation of a JVM that supports Pluggable Veri.cation Modules \n(PVMs), the idea of an extensible protection mechanism is entertained. Link\u00adtime bytecode veri.cation \nbecomes a pluggable service that can be readily replaced, recon.gured and augmented. Ap\u00adplication-speci.c \nveri.cation services can be safely intro\u00adduced into the dynamic linking process of the JVM. This feature \nis enabled by the novel application of a previously proposed modular veri.cation architecture, Proof \nLinking [23, 24], which decouples bytecode veri.cation from the dy\u00adnamic linking process. The main contributions \nof this paper are the proposal of Pluggable Veri.cation Modules as a stan\u00addard feature for JVM-like extensible \nsoftware systems, and the report of a concrete design and implementation of such a facility in an open \nsource Java Virtual Machine, the Aegis VM [21]. To evaluate the utility of the extensible protection \nmechanism, an augmented type system JAC (Java Access Control) [37] has been implemented as a PVM. This \nimple\u00admentation exercise illustrates two aspects of utility: Firstly, it demonstrates that incorporating \nan application-speci.c static analysis into the link-time veri.cation procedure of the Aegis VM through \nthe PVM extension mechanism requires only a tractable amount of programming e.ort. Secondly, it demonstrates \nhow Proof Linking, as implemented in the PVM facility, can be exploited to enable secure cooperation \n[49] among mutually distrusting code units. This paper is organized as follows. Section 2 analyzes the \narchitectural de.ciencies of existing JVMs, and articulates how the Proof Linking architecture can be \nnovelly applied to turn link-time static veri.cation into a pluggable service. The concrete design of \nthe PVM facility as implemented in the Aegis VM is detailed in Sections 3 and 4. The utility of the extensible \nprotection mechanism is evaluated in Sections 5 and 6, in which the implementation of the JAC type sys\u00adtem \nas a PVM is used to illustrate the software engineering and security engineering bene.ts of the PVM facility. \nDis\u00adcussion, related work, future work, and conclusion can be found in Section 7.  2. PLUGGABLE VERIFICATION \nSERVICE VIA PROOF LINKING This section analyzes the veri.cation architecture of ex\u00adisting JVMs, and explains \nwhy extensibility is not properly supported in such an architecture (Section 2.1). It then re\u00adviews the \npreviously proposed Proof Linking architecture (Section 2.2), and subsequently outlines a novel applica\u00adtion \nof this modular veri.cation architecture to turn link\u00adtime static veri.cation into a pluggable service \n(Section 2.3). Lastly, the implementation status of this extensible protec\u00adtion mechanism is reported \n(Section 2.4). 2.1 Problem Analysis The lack of modularity in the veri.cation architecture of existing \nJVMs is the main obstacle to rendering bytecode veri.cation a pluggable service. To see this, note that \ncode safety is in general a whole-program notion: the safety of a class.le depends not only on properties \nthat can be es\u00adtablished by examining the class.le alone, but also on the compatibility of the established \nproperties with the runtime environment into which the class.le is linked. In the context of typechecking, \nthe two tasks roughly correspond to the in\u00adference of a type interface for a code unit, and the checking \nof the compatibility between this type interface and a given type environment. Cardelli succinctly called \nthe two tasks intrachecking and interchecking [10]. Unfortunately, the two tasks are not cleanly separated \nfrom each other and from the rest of the VM in a typical implementation of the bytecode veri.cation procedure \n[39]: 1. Interleaving of Intrachecking and Intercheck\u00ading: In the course of intrachecking a class.le, \nclass\u00adloading may be initiated by the bytecode veri.er in order to bring in the type interface of other \nclass.les for interchecking purposes. The result of mixing some interchecking into intrachecking is a \ntight coupling be\u00adtween the bytecode veri.er and the dynamic linking logic of the runtime environment. \nUnder this veri\u00ad.cation architecture, if an application-speci.c static analysis is to be introduced into \nthe dynamic linking process of the JVM, not only will the intrachecking component have to possess intimate \nknowledge of the VM internal, any undisciplined classloading performed by the component for the sake \nof interchecking may also perturb the soundness of the dynamic linking se\u00admantics. 2. Delocalization \nof Interchecking: Because of the incremental nature of dynamic loading, not all code units of a program \nis present at run time. The bulk of interchecking, therefore, has to be performed incre\u00admentally as new \nclasses are linked into the VM. Under this veri.cation architecture, application-speci.c in\u00adterchecking \nlogic has to be carefully grafted at strategic locations of the dynamic linking procedure. Not only is \nthis a nontrivial software engineering undertake, the process is inherently error prone.  Simply put, \nthe veri.cation architecture of a typical JVM implementation is not designed to support extensibility. \nAny extension mechanism for supporting application-speci.c ver\u00adi.cation must involve a complete rethinking \nof the veri.ca\u00adtion architecture. 2.2 The Proof Linking Architecture The Proof Linking architecture \n[23, 24] was originally proposed as a means to improve the comprehensibility and maintainability of the \nstandard bytecode veri.er in the JVM. This has been achieved by modularizing the JVM veri.ca\u00adtion procedure. \nTo understand the Proof Linking architec\u00adture, consider the example depicted in Figure 1. Suppose class \nC de.nes a method M (S), the body of which contains an invokespecial bytecode instruction that delegates \nthe call to A.M(S). For this instruction to be properly typed, JVM semantics require that C must be a \nsubclass of A.This requirement is an example of interchecking. Figure 1: A Typechecking Example Proof \nLinking cleanly separates intrachecking and inter\u00adchecking. Intrachecking of class.les is performed by \na modu\u00adlar veri.er, which infers for each class.le a veri.cation inter\u00adface composed of proof obligations \nand commitments (Figure 2). Commitments are assertions established by the modu\u00adlar veri.er, while proof \nobligations are assumptions made during the process. Proof obligations and commitments are analogous \nrespectively to the import and export parts of a module interface. For example, a modular veri.er that \nim\u00adplements intrachecking for the standard JVM type system will scan the body of C.M(S), and, noticing \nthe invokespe\u00adcial instruction, generate a proof obligation subclass(C, A) to record the intermodular \ndependency. The modular veri.er also generates the commitment extends(C, B) to indicate that class C \ninherits directly from class B.In\u00adterchecking thus involves the discharging of proof obligations using \ncommitments of loaded classes. Due to the incremen\u00adtal nature of dynamic loading and lazy, dynamic linking, \na JVM program may not be completely loaded or linked, and thus not all proof obligations can be discharged \nright away. Consequently, also included in the veri.cation interface is an obligation discharging schedule, \nwhich assigns to each proof obligation a linking primitive (i.e., a linking event), prescribing that \nthe obligation should be discharged prior to the execution of the linking primitive. For example, the \nabove proof obligation subclass(C, A) is scheduled to be discharged before the linking primitive resolve \nA.M(S) in C is executed. Obligation discharging is therefore staged carefully to dovetail with the dynamic \nloading of class.les and their commitments. Incremental interchecking is achieved through a process called \nproof linking (Figure 3). Whenever a linking primi\u00adtive is to be executed, the JVM attempts to discharge \nthe associated proof obligations using commitments of classes that are already loaded. Execution of the \nlinking primitive is only authorized if the check succeeds. In previous works [23, 24], incremental proof \nlinking is modeled abstractly us\u00ading deductive database concepts [40], whereby proof obliga\u00adtions are \ndeductive queries, commitments are facts stored in a database, and logic programs are formulated to express \ninterchecking logics such as type rules. For example, the following Horn clause expresses de.nes the \nsubclass/2 re\u00adlation to be the re.exive transitive closure of extends/2. subclass(X, X). subclass(X, \nY) :-extends(X, Z), subclass(Z, Y). The obligation subclass(C, A) canbedischargedifboth the commitments \nextends(C, B) and extends(B, A) are already loaded before the linking primitive resolve A.M(S) Untrusted \nVerified Code Unit Code Unit Run-time Loader Verifier Environment Commitments + Obligations Proof Linker \nObligations Commitments resolve S in X Linking Primitives Obligations 321 OO O   Obligation Discharging \nSchedule Figure 2: Modular Veri.cation Request that symbol S is to be resolved in X  Prove obligations \nby consulting commitments  Figure 3: Incremental Proof Linking in C is executed. Correctness of the \nproof linking process is assessed through the examination of a linking strategy,which formally speci.es \nthe temporal dependencies between link\u00ading primitives as a partially ordered set. Three correctness conditions, \nnamely, Safety, Monotonicity and Completion, have been established with the help of the PVS speci.ca\u00adtion \nand veri.cation system. 2.3 A Solution Approach One of the main contributions of this work is the novel \nemployment of the Proof Linking architecture to create an extensible protection mechanism for the Aegis \nVM. Because Proof Linking cleanly separates intrachecking and intercheck\u00ading through the use of a veri.cation \ninterface, intrachecking is decoupled from the dynamic linking process. No longer entangled with classloading \nlogic, intrachecking code can be engineered as a separate component that interacts with the VM solely \nby generating veri.cation interfaces. This architectural property is exploited to allow arbitrary plug\u00adgable \nveri.cation modules (PVMs) to be dynamically linked into the JVM to augment the standard bytecode veri.er. \nEvery PVM implements an intrachecking procedure for an application-speci.c veri.cation domain. Without \nhaving to perform any interchecking and classloading, each PVM in\u00adfers a veri.cation interface to capture \nintermodular depen\u00addencies. Details of the PVM facility and the design of a domain-independent representation \nof veri.cation interface is describedinSection 3. A generic proof linking mechanism is built into the \nAegis VM for supporting domain-independent interchecking. Specif\u00adically, proof obligations and commitments \ngenerated by PVMs are tracked by the Aegis VM, which discharges proof obliga\u00adtions according to the obligation \ndischarging schedules em\u00adbedded in veri.cation interfaces. Consequently, the com\u00adplexity of grafting \ninterchecking code into the dynamic link\u00ading procedure is now replaced by a reusable proof linking engine. \nUser-de.ned veri.cation domains can be speci.ed through the creation of obligation libraries, which are \nused by the generic proof linking mechanism for evaluating obli\u00adgations speci.c to a veri.cation domain. \nDetails of the generic proof linking mechanism and obligation libraries can be found in Section 4. The \nPVM extension mechanism o.ers a number of soft\u00adware engineering bene.ts to developers of an application\u00adspeci.c \nveri.cation technology. Firstly, intrachecking code no longer needs to assume implementation-level knowledge \nof the VM internal. Instead, a PVM depends only on an abstract model of proof linking over which veri.cation \ninter\u00adfaces are de.ned. Secondly, interchecking is now a fully au\u00adtomated service provided by the generic \nproof linking mech\u00adanism, thereby freeing the developers from having to man\u00adually graft interchecking \ncode into the dynamic linking pro\u00adcedure. Thirdly, Safety and Completion are guaranteed for free. The \nPVM extension facility is designed in such a way that user-de.ned PVMs and obligation libraries au\u00adtomatically \nsatisfy the two aforementioned correctness con\u00additions of Proof Linking. Developing well-mannered link\u00adtime \nstatic analyses under the PVM framework is therefore highly tractable. A detail demonstration of these \nsoftware engineering bene.ts in the context of the JAC type system can be found in Section 5. The PVM \nextension mechanism also o.ers a number of security engineering bene.ts to the administrators and users \nof a JVM platform. Firstly, the administrator is free to mix and match PVMs to create a custom-made JVM \nplat\u00adform that addresses the speci.c security needs of an appli\u00adcation area (e.g., embedded VM for mobile \nphones). When a security .aw is discovered in a PVM, it can be replaced as an individual component. Con.guration \nmanagement of the veri.cation service is therefore streamlined. Secondly, application-speci.c access \ncontrol policies can be easily ex\u00adpressed in terms of proof obligations and commitments. En\u00adabled by \nthe generic proof linking mechanism, safe dynamic linking allows an extensible application to erect protection \nboundaries between the application core and dynamically loaded extensions. An illustration of this latter \nsecurity en\u00adgineering bene.t in the context of the JAC type system can be found in Section 6.  2.4 Implementation \nStatus The PVM facility and the generic proof linking mechanism have been fully implemented in the Aegis \nVM. The imple\u00admentation e.ort has been administrated as an open source project [21]. Six development \nreleases result in a VM that supports features including dynamic linking, access control, delegation \nstyle classloading, loading constraints, re.ection, garbage collection, native method dispatching and \nall as\u00adpects of bytecode interpretation. The VM does not yet sup\u00adport multithreading. The Aegis VM currently \nruns on the GNU/Linux (x86) platform. It provides a realistic platform on which to test the feasibility \nof the Proof Linking architec\u00adture. Features described in this paper has been incorporated into release \n0.2.0. Design highlights are outlined in Sections 3 and 4 to illustrate the utility of the approach. \nConsult [22] for low-level implementation details.  3. PLUGGABLE VERIFICATION MODULES PVMs are dynamically \nloadable shared libraries on the GNU/Linux platform. Programmers may implement an app\u00adlication-speci.c \nanalysis as a PVM, and subsequently use it to augment the Aegis VM through the PVM extension mechanism. \nThis section outlines the design of this plug-in mechanism. 3.1 PVM Life Cycle The Aegis VM can be con.gured \nwith an arbitrary num\u00adber of PVMs. The PVMs are loaded when the VM boot\u00adstraps. Every PVM exports an \nidenti.er specifying the veri\u00ad.cation domain to which it belongs. The Aegis VM uses this identi.er to \nmatch the PVM with a corresponding obliga\u00adtion library, with which the veri.cation interfaces generated \nby this PVM will be interpreted. Next, the initialization function exported by each PVM is invoked. From \nthis point on, the veri.cation facilities of the loaded PVMs will be called into service whenever a class \nis to be de.ned. Speci.cally, prior to the de.nition of a class, the corresponding class.le representation \nis parsed into an abstract syntax tree (AST). A built-in data.ow an\u00adalyzer is then employed to typecheck \nthe bytecode meth\u00adods in the AST. The results of data.ow analyses are passed along with the AST into \nthe veri.cation function of every loaded PVM, whereby application-speci.c intrachecking is conducted \n(Section 3.2). Successful intrachecking generates a veri.cation interface (Section 3.3), which is then \nprocessed by the generic proof linking mechanism. Class de.nition is authorized only if all PVMs endorse \nthe safety of the corre\u00adsponding class.le representation. When the Aegis VM shuts down, the clean-up \nfunction exported by each PVM is invoked before the PVM is un\u00adloaded. 3.2 Veri.cation Function The veri.cation \nfunction implements the core functional\u00adity of a PVM. To reduce the overhead of user-de.ned in\u00adtrachecking, \nand to facilitate PVM development, the AST of the target class.le and the results of typechecking byte\u00adcode \nmethods are passed as arguments to the veri.cation function. Speci.cally, the built-in data.ow analyzer \nof the Aegis VM generates (1) an explicit intraprocedural control .ow graph for each bytecode method \n(control .ow is implicit due to the presence of the notorious subroutine construct in the JVM bytecode \nlanguage [52, 45]), and (2) a type state for each program point. Each type state describes (i) the depth \nof the operand stack, (ii) the type of each data item residing in the operand stack and local variable \narray, and (iii) the subroutine call chain leading to the program point. A veri.cation function may reuse \nthe above information to avoid analyzing a class.le from scratch. Experience from implementing the JAC \ntype system has con.rmed that the availability of this additional information greatly facilitates the \ndevelopment of PVMs. obligation ::= predicate-identi.er { symbolic-argument }* symbolic-argument ::= \nthis | super | interface index | field index | method index | literal index | import-symbol index | auxiliary-symbol \nindex | global-class index | global-constant index Figure 4: Abstract Syntax of Proof Obligations  3.3 \nVeri.cation Interface The veri.cation function constructs a veri.cation inter\u00adface for each class.le \npassing intrachecking. Every veri.\u00adcation interface is composed of three components proof obligations \n(3.3.1), commitments (3.3.2), and an obligation discharging schedule (3.3.3). The Aegis VM stores veri.\u00adcation \ninterfaces in class de.nitions. Unloading of a class automatically cleans up the memory resources occupied \nby the associated veri.cation interfaces. 3.3.1 Proof Obligations The veri.cation function formulates \nproof obligations to capture external dependencies of a target class.le. Every proof obligation represents \na condition to be checked at link time by the generic proof linking mechanism. The PVM facility provides \nan expressive, symbolic representation for veri.cation functions to encode proof obligations. Under this \nrepresentation, every proof obligation is a ground query composedofa predicate identi.er and zero or \nmore symbolic arguments. The abstract syntax of a proof obligation is given in Figure 4. Every veri.cation \ndomain de.nes a .xed number of pred\u00adicate symbols (Section 4.1). Each predicate symbol repre\u00adsents a \nboolean function that checks if some condition holds. The predicate identi.er of an obligation is a numeric \nindex specifying a predicate symbol in the veri.cation domain to which the PVM belongs. Intuitively, \nthe boolean function corresponding to the predicate symbol will be applied to the symbolic arguments \nwhen the obligation is discharged. The veri.cation function may name various components of the class \nbeing veri.ed as the arguments of an obligation. Speci.cally, the this, super, interface, field and method \nargument syntax are used for naming the target class, its immediate superclass, immediate superinterfaces, \ndeclared .elds and declared methods respectively. The index .eld identi.es the speci.c candidate of a \ngiven argument type. A literal argument names an int, float, long, double, or UTF-8 string literal in \nthe constant pool. The index .eld refers to the index of the literal in the constant pool. An import-symbol \nargument names the resolved target of a class, .eld, method, or interface method reference in the constant \npool. The index .eld refers to the index of the symbolic reference in the constant pool. Occasionally, \nthe veri.cation function may need to name an argument that corresponds to a class that cannot be ref\u00aderenced \nusing the above argument syntax. Such a class ref\u00aderence is said to be an auxiliary symbol. Every veri.cation \ninterface provides its own symbol table for storing auxil\u00adiary class symbols. The auxiliary-symbol argument \nsyn\u00adtax identi.es an entry of this auxiliary symbol table. When a class is prepared, all the class symbols \nmentioned in the auxiliary symbol table are loaded and cached, so that they can be readily retrieved \nat the time of obligation discharging (Section 4.4). The obligation argument types described so far \nrefer to run-time JVM data structures that are de.ned indepen\u00addently of any speci.c veri.cation domain. \nObligation ar\u00adgument types global-class and global-constant provide syntax for naming data structures \nspeci.c to a veri.cation domain. Speci.cally, every veri.cation domain may iden\u00adtify a.xednumberofJavaclassestobeinstrumentalto \nveri.cation (e.g., the class java.lang.Throwable is needed for checking if a class can be thrown as an \nexception). These classes can be named as obligation arguments through the global-class syntax. Every \nveri.cation domain may also de.ne a .xed number of immutable, native data structure to represent domain \nconstants. Such constants can be named using the global-constant syntax. See Section 4.1 for more details. \nAs the Aegis VM has to explicitly track proof obliga\u00adtions, a compact obligation encoding has been derived \n[22], whereby an obligation with k arguments can be encoded with k + 1 32-bit machine words. 3.3.2 Commitments \n Static properties successfully established by the veri.ca\u00adtion function for a target class.le are captured \nin commit\u00adments. To maximize optimization opportunities, the Aegis VM does not mandate a particular representation \nfor com\u00admitments. Any appropriate data structures can be employed by a veri.cation function to represent \ncommitments for the veri.cation domain of the PVM. 3.3.3 Obligation Discharging Schedule Because of \nlazy, dynamic linking, obligation discharging proceeds in an incremental manner. Every proof obligation \nformulated by a veri.cation function is explicitly scheduled to be discharged when a speci.c linking \nprimitive is exe\u00adcuted. Such an obligation is said to be attached to the tar\u00adget linking primitive. Speci.cally, \nthe following family of linking primitives are de.ned for every class C: endorse C: Endorsement of a \nclass C occurs when C is prepared [39, Section 5.4.2]. endorse C.F : Endorsement of a .eld C.F occurs \nprior to the .rst access of F , and after the endorsement of class C. endorse C.M: Endorsement of a \nmethod C.M occurs prior to the .rst invocation of M, and after the endorsement of class C. resolve S \nin C: This primitive coincides with the resolu\u00adtion of constant pool reference S. It occurs after the \nendorsement of class C, and after the endorsement of the referent of S. In practice, proof obligations \nthat require the checking of C against the commitments of its supertypes or auxiliary symbols are attached \nto endorsement primitives, while those that validate import symbols are attached to resolution prim\u00aditives. \nThe design of the PVM facility is intentionally constrained, so that a veri.cation function may only \nattach proof obliga\u00adtions to endorse C , endorse C.F , endorse C.M , and resolve S in C when the class.le \nrepresentation of class C is intrachecked. This constraint guarantees that the correctness condition \nSafety is satis.ed [23]. Speci.cally, the design guarantees that, when a linking primitive is executed, \nall proof obligations that may be attached to it are already generated.   4. DOMAIN-INDEPENDENT PROOF \nLINKING A generic proof linking mechanism has been implemented so that Aegis VM can process the proof \nobligations and com\u00admitments generated by PVMs. At the heart of this facility is a mechanism that allows \nusers to de.ne new veri.cation domain. 4.1 Obligation Libraries Users may de.ne an application-speci.c \nveri.cation do\u00admain by developing an obligation library. As a dynamically loadable shared library on \nGNU/Linux, each obligation li\u00adbrary supplies the de.nitions for predicate symbols, global classes and \nglobal constants of a veri.cation domain. An obligation library developer has to program the following: \nPredicate functions. A native boolean function is de.ned for each predicate symbol in the veri.cation \ndomain1 . This function will be dispatched when a corresponding obligation is to be discharged. A predicate \ndispatching table, analogous to a virtual function table, must be exported by an obligation library. \nGlobal classnames. An array of classnames must be ex\u00adported to specify the names of global classes in \nthe veri.cation domain. These classes will be automat\u00adically loaded by the bootstrap classloader when \nthe Aegis VM bootstraps. Global constants. An array of native data structures must be exported as global \nconstants for the veri.cation do\u00ad main.  4.2 Obligation Library API To facilitate the evaluation of \nobligations, the Aegis VM provides an obligation library API, whereby native predi\u00adcate functions can \nexamine the run-time state of the VM and look up commitments. A brief summary of the API facilities is \ngiven in Figure 5. The obligation library API is carefully designed so that native predicate functions \nonly have access to type interfaces and commitments of classes that are already loaded. This guarantees \nthat the correct\u00adness condition Completion is satis.ed [23]. 1The formulation of the native predicate \nfunctions must cor\u00adrespond to a monotonic logic in order for the correctness condition Monotonicity to \nbe satis.ed [23]. It is the respon\u00adsibility of the obligation library developer to take care of this \nrequirement. Package interface interrogation. Examine the name and classloader of a loaded package. \nClass interface interrogation. Examine the access con\u00adtrol .ags, package, classloader, name, superclass, \nsu\u00adperinterfaces, declared .elds, declared methods, and constant pool entries of a loaded class. Field \ninterface interrogation. Examine the access con\u00adtrol .ags, declaring class, name, and type signature \nof a .eld. Method interface interrogation. Examine the access control .ags, declaring class, name, type \nsignature, and exception class names of a method. Subtyping tests. Subclassing, subinterfacing, subtyping, \netc. Contextual information. Retrieve commitments of a class for the current veri.cation domain; access \nglobal classes and global constants of the current veri.cation domain. Figure 5: Facilities in the Obligation \nLibrary API  4.3 Life Cycle of an Obligation Library The Aegis VM can be con.gured with an arbitrary \nnum\u00adber of obligation libraries, thereby equipping the VM with vocabularies for multiple veri.cation \ndomains. When the Aegis VM starts up, all the con.gured obligation libraries are loaded and initialized. \nThe global classes speci.ed by each obligation library are loaded by the bootstrap class\u00adloader when \nthe Aegis VM bootstraps. After this point, the native predicate functions are made available to the generic \nproof linking mechanism for obligation discharging. Obliga\u00adtion libraries are properly cleaned up and \nunloaded before the Aegis VM shuts down. 4.4 Obligation Discharging Sequence Whenever a linking primitive \nis executed, the Aegis VM attempts to discharge all the attached proof obligations. To discharge a proof \nobligation, the following steps are followed: 1. The predicate identi.er is used as an index to look \nup the corresponding native predicate function in the predicate dispatching table of the current veri.cation \ndomain. This is a constant-time operation 2. Each symbolic argument of the proof obligation is re\u00adsolved \ninto a corresponding pointer to a VM data struc\u00adture or a global constant of the current veri.cation \ndo\u00admain. As argument resolution amounts to a constant\u00adtime look up operation, construction of the argument \narray takes time linear to the number of arguments involved. 3. The native predicate function is invoked \nwith the ar\u00adgument array as input. A boolean value is returned to indicate the result of evaluation. \n  Execution of the linking primitive is authorized only when all attached proof obligations are successfully \ndischarged. This concludes the discussion of the PVM facility and the generic proof linking mechanism. \nWe now turn to the assessment of their utility.  5. SOFTWARE ENGINEERING BENEFITS This section assesses \nthe utility of the PVM facility in supporting the development of link-time static veri.cation procedures \nfor the JVM. Due to its simplicity and its rel\u00adevance to access control, the augmented type system JAC \n[37] is chosen as an example veri.cation domain to be im\u00adplemented on top of the PVM facility. Speci.cally, \nthe JAC type system, which is originally designed for typing Java source programs at compile time (Section \n5.1), is recast here as a type system for the JVM bytecode language, enforce\u00adable at link time (Section \n5.2). An annotation scheme is designed for embedding JAC type interfaces into Java class\u00ad.les (Section \n5.3). An obligation library is implemented for the JAC veri.cation domain (Section 5.4). A PVM for the \nJAC type system is described (Section 5.5). Through the recounting of this implementation exercise, the \nreader may gain a better appreciation of the development e.ort involved in the introduction of a non-standard \nstatic analysis into the dynamic linking process of the JVM through the PVM facil\u00adity. This in turn provides \nthe basis for a fair assessment of the software engineering bene.ts of the PVM facility (Sec\u00adtion 5.6). \n 5.1 JAC for the Java Source Language JAC (Java with Access Control) [37] was proposed as an augmented \ntype system for controlling the proliferation of side e.ects due to alias creation in object-oriented \nprograms. Rather than preventing the creation of aliases, JAC prevents undesirable side e.ects from occurring \nwhen aliasing is un\u00adavoidable. Speci.cally, it allows a Java reference type to be quali.ed as being readonly, \nwhich e.ectively protects the transitive state of the reference from any write access. Un\u00adlike the C \ntype quali.er const, which only protects the state of the object directly accessible from a const-quali.ed \nref\u00aderence/pointer, the write protection of JAC extends to all objects reachable from a readonly-quali.ed \nreference in the underlying object graph. To understand how transitive write protection works, con\u00adsider \nthe following Java linked-list class. public class List { public int data; public List next; public List(int \ndata, List next) { this.data = data; this.next = next; } } Notice that the instance variables of List \nare public,and as such they can be freely modi.ed by client code. However, a List variable quali.ed as \nreadonly cannot be used for modifying the transitive state reachable from the variable. readonly List \nx = new List(1, new List(2, null)); x.data = 5; // Error: Writing to immediate state x.next.data = 6; \n// Error: Writing to transitive state Objects reachable from a readonly reference are readonly. Furthermore, \nunquali.ed reference types can be converted to readonly ones, but not vice versa. The original JAC type \nsystem is designed for typing Java source programs at compile time. As discussed above, code units that \nare checked to be type safe in the compilation environment may no longer be type safe when they are linked \nagainst those code units in the run-time environment. For access control type systems to become a viable \nprotection mechanism for mobile code systems, they must be enforced at link time. To this end, the JAC \ntype system is recast in this section as a type system for the JVM bytecode language. Furthermore, this \nbytecode incarnation of JAC di.ers from Kniesel and Theisen s work [37] in the following ways: 1. The \noriginal JAC syntax forces the return type of an instance method to share the same type quali.er with \nthe type of this, the object instance to which method invocation is targeted. This restriction is purely \na source-level syntactic constraint, and will not be en\u00adforced here. The bytecode version of JAC presented \nbelow is fully capable of qualifying the two types in\u00addependently. 2. The original JAC type system has \na mutable type qual\u00adi.er for decorating instance variables, thereby selec\u00adtively shielding the quali.ed \n.elds from the transitive e.ect of write protection. The mutable quali.er is not modeled in this work. \nExtending the current work to include the mutable quali.er is a straightforward ex\u00adercise. 3. Theoriginalworkin[37]describes \nan extensionofJAC to accommodate the generic type system of GJ [9], a variant of Java that supports genericity. \nThis exten\u00adsion is beyond the scope of this paper.  5.2 JAC for the JVM Bytecode Language The JAC type \nsystem is recast here as a type system for the JVM bytecode language. Similar to its source language \ncounterpart, the bytecode version of the JAC type system de.nes two types, namely, readonly and .. The \nbottom type . applies to both mutable object references and prim\u00aditive values (i.e., int, boolean, etc). \nThe readonly type applies to object references for which transitive states are protected. 5.2.1 Subtyping \n The bottom type . is a subtype of readonly,and as such the conversion of . to readonly is permitted. \nWe write A<: Bif type Ais equivalent to or a subtype of B.Method subtyping follows the usual contravariant \nrule: A. B<: A. . Bif A<: Aand B<: B. 5.2.2 Type Interface Associated with each Java class.le is a \nJAC type interface, which consists of an export part and an import part. Each part is a list of type \nassertions, relating symbols to their types. The export part describes type assertions for .elds and \nmethods declared in the class.le. The import part con\u00adtains type assertions for .eld, method and interface \nmethod references in the constant pool. The type assertion of a .eld simply assigns a JAC type to the \n.eld. The type assertion of a method assigns a JAC type to the return value and to each formal parameter, \nincluding this in the case of an in\u00adstance method. A type assertion is well-formed if primitive types \nin the standard Java type system are quali.ed by the . type. 5.2.3 Interchecking Subclassing is safe \nonly if method overriding honors the usual subtyping rule. That is, if method C.M : T overrides method \nC..M : T .,then T<: T . . A similar requirement applies to subinterfacing. This check can be performed \nwhen the class endorsement primitive is executed. Resolution of a constant pool method reference (or \nin\u00adterface method reference) C.M with import type assertion C.M : T is type safe if the resolved target \nC..M is de.ned in a class.le that exports type assertion C..M : T . and T . <: T . Resolution of a constant \npool .eld reference with import type assertion C.F : T is type safe if the resolved target has an export \ntype assertion C..F : T . Notice that the typing requirements are di.erent in the two cases.  5.2.4 \nIntrachecking The export type assertion of a bytecode method is valid if every program point in the method \nbody can be consistently assigned a JAC type state. A JAC type state is an assign\u00adment of a JAC type \nto every location in the local variable array and the operand stack. Every bytecode instruction imposes \ntyping constraints on the JAC type states at the program points before and after the instruction. The \ntyping constraints for a sample of bytecode instructions are pre\u00adsented below. A more complete list can \nbe found in [22]. The e.ect of a bytecode instruction is presented in a nota\u00adtion popularized by [39]. \nFor example, the iadd instruction pops twointegersfromthe topofthe operandstack, and push their sum back. \nThis can be illustrated as follows. ..., i1, i2 -. ..., i3 where integer i3 is the sum of i1 and i2. \naastore Operand Stack: ..., a, i, v -. ... Operation: Store reference value v into array refer\u00adence a \nas the component at index i. Type Constraints: Neither a nor v is readonly. get.eld . .eldref . Operand \nStack: ..., o -. ..., v Operation: Load the value v of the instance variable . .eldref . from object \ninstance o. Type Constraints: If the constant pool entry . .eldref . is a reference .eld with a readonly \nim\u00adport type, then v must be readonly.If . .eldref . is a reference .eld, and o has a readonly type, \nthen v must be readonly. Otherwise, v must be . . put.eld . .eldref . Operand Stack: ..., o, v -. ... \nOperation : Store the value v into the instance vari\u00adable . .eldref . of object instance o. Type Constraints: \nThe type of o must not be readonly. If the constant pool entry . .eldref . is a reference .eld with an \nimport type . ,then v must not have a readonly type. invokevirtual . methodref. Operand Stack: ..., \no, a1, a2, ..., ak -. ..., v Operation: Invoke method . methodref . ,with argu\u00adments a1, a2, ..., ak, \non object instance o.Any return value v is pushed into the operand stack. Type Constraints: Let the type \nof o, a1, ..., ak and v be A0, A1, ..., Ak and A, and the im\u00adport type of the constant pool entry . methodref \n. be . B0,B1,...,Bk. B.Then Ai <: Bi for 0 = i = k,and B<: A.  5.3 Embedding JAC Type Interfaces To \nmake JAC enforceable at link time, every class.le must carry a JAC type interface. A compact encoding \nhas been designed [22] for embedding JAC type interfaces into class\u00ad.les through the class.le attribute \nfacility [39, Section 4.7]. A well-formed JAC attribute assigns no more than one type to an export symbol \nor an import reference. It is how\u00adever, not necessary for all symbols to receive a type assign\u00adment. \nThe symbols left untyped are said to have default types. In fact, a class.le may not even have a JAC \nattribute. In such a case, all import references and export symbols are assumed to have default types. \nThe default type of a .eld is . ; the default type of a method is such that the return valueand allformalparametershavetype \n. .This de.nition of default types is consistent with the interpre\u00adtation of the standard Java type system \nin the context of JAC. The provision of assuming a default type interface for a class.le not carrying \na JAC attribute renders it possible to reuse legacy class.les not compiled for JAC typechecking, so long \nas client classes do not pass read-only references to the legacy classes. This is particularly handy \nin the case of the standard Java class library hundreds of system classes can be reused as is. This \nsimple choice of default type makes the experiments described in Section 6 tractable2 . A command line \nutility was developed to facilitate the in\u00adjection of JAC attributes into class.les. The program takes \na class.le and a high level JAC type interface speci.cation as input, and generate a version of the input \nclass.le with the corresponding JAC attribute embedded3 . 5.4 Obligation Library for JAC An obligation \nlibrary has been implemented for the JAC veri.cation domain. The JAC obligation library exports the following \npredicates: 1. Import safety predicates: safe-field-import .eld import-type safe-method-import method \nimport-type where .eld is a .eld, method a method, and import\u00adtype a UTF-8 literal representing an import \ntype sig\u00adnature. The predicates checks if the export type of 2A more sophisticated design is to extend \nthis version of JAC to incorporate polymorphism, and to automatically generate a principal type interface \nfor each library class us\u00ading a type inference algorithm. Not needed by the experi\u00adments in this paper, \nsuch a feature is left for future work. 3Alternatively, the speci.cation and embedding of JAC type annotations \ncan be performed in the framework of the new JDK 5.0 metadata facility [6]. .eld/method is compatible \nwith import-type.Imple\u00admentation of the two predicate functions involves the invocation of obligation \nlibrary API functions to re\u00adtrieve commitment data structures. 2. Method overriding safety predicate: \nsafe-method-override class For each of the method declared in class,check that its export type is a subtype \nof the export type of ev\u00adery method it overrides. Implementation of this predi\u00adcate function involves \napplying obligation library API functions to visit all superclasses and superinterfaces of class, and \nto retrieve their commitment data struc\u00adtures. The obligation library also exports a global constant \nfor rep\u00adresenting default types. No global class is speci.ed for the JAC veri.cation domain.  5.5 PVM \nfor JAC A PVM has been implemented for JAC. When the veri.\u00ad cation function of the JAC PVM is invoked \non a class.le, it performs the following veri.cation steps: 1. Parsing the type interface into a commitment \ndata structure. If the class.le carries a JAC at\u00adtribute, then the embedded JAC type interface is check\u00aded \nfor well-formedness. Otherwise, a default JAC type interface is assumed. In either case, a JAC-speci.c \ncommitment data structure is generated to store the JAC type interface. 2. Intrachecking bytecode methods. \nAn iterative data.ow analysis algorithm is applied to verify that the bytecode methods satisfy the type \nconstraints spec\u00adi.ed in Section 5.2.4. Notice that, if all import refer\u00adences have default types, then \nthere is no need to run the data.ow analysis on a method with default export type. In such a case, the \nanalysis merely repeats what has already been checked by the built-in bytecode ver\u00adi.cation procedure. \nConsequently, intrachecking can be safely skipped for class.les with no JAC attribute. 3. Generating \nobligation attachments. Firstly, a corresponding import safety obligation is attached to the resolution \nprimitive of each import reference in the constant pool. For example, an obligation of the fol\u00adlowing \nform will be generated for a .eld reference in the constant pool:  safe-field-import import-symbol i \nliteral j where i is the constant pool index of the .eld reference, and j is the constant pool index \nof the UTF-8 string storing the import type. If the import type of the .eld reference is not explicitly \nspeci.ed in the JAC attribute, then the reference has a default type, and the following obligation should \nbe generated instead: safe-field-import import-symbol i global-constant 0 where global-constant 0 denotes \nthe global con\u00adstant representing default types. The formulation of PVM Obl. Lib. Shared Total 2082 490 \n75 2647 Figure 6: LOC for the JAC Implementation import safety obligations for method references is \nsim\u00adilar. Notice that obligation attachments should still be gen\u00aderated for an import reference even \nif it has default type, since the export type of the reference target may not be compatible with the \ndefault import type. In other words, although intraprocedural typechecking may be optimized away in special \ncases (see step 2 for details), interprocedural typechecking must never be bypassed. Secondly, a method \noverriding safety obligation is at\u00adtached to the class endorsement primitive of the target class. safe-method-override \nthis 4. Formulating veri.cation interface. Averi.cation interface composed of the commitment data structure \nfrom step 1 and the proof obligations from step 3 is constructed. No auxiliary symbol is needed in this \nveri.cation domain.  5.6 Assessment Reduction of Code Complexity. Figure 6 gives an estimate of the \ncomplexity of the JAC implementation de\u00adscribed in Sections 5.4 and 5.5. Speci.cally, the number of lines \nof (moderately commented) C code for the JAC PVM, the corresponding obligation library, and common data \nstructures shared between the two are displayed. Such a modest complexity is achieved because the Aegis \nVM pro\u00advides reusable facilities to ease the development of veri.\u00adcation services. These include, for \nexample, construction of AST and type analysis results, API for interrogation of VM state, utilities \nfor formulating and managing commit\u00adments and obligations, and, most importantly, automated interchecking \nthrough proof linking. In short, the Aegis VM provides a reusable development platform for developers \nof link-time veri.cation services. Reduction of Cognitive Stain. Notice from Section 5.5 that a PVM developer \nworks with an abstract proof linking model rather than concrete details of the Aegis VM internal. Not \nonly that, Safety and Completion are granted for free: violations of the two correctness conditions cannot \neven be expressed in a PVM. Such provisions make the construction of well-mannered veri.cation services \na cognitively tractable task.  6. SECURITY ENGINEERING BENEFITS Using the JAC type system as an example, \nthis section il\u00adlustrates that features built into the PVM facility, including user-de.ned intrachecking, \nand safe dynamic linking through proof linking, can be exploited to impose access control con\u00adstraints \namong mutually distrusting code units within the same application. 6.1 Protection Through Import Type \nAnnotations Suppose an application class Alice needs to compute the sum of all integers in a List it \ncreates. The task is dele\u00adgated to another class Bob, which provides a sum method that computes the sum \nof all elements in a given List. public class Alice { public static void main(String[] args) { List L \n= new List(1, new List(2, new List(3, null))); System.out.println(Bob.sum(L)); } } Suppose Alice cannot \ntrust that Bob is side-e.ect free. To ensure Bob does not accidentally or maliciously modify the values \nstored in the List argument, the class.le of Alice can be annotated with a JAC attribute containing the \nfollowing import type assertion. Bob.sum : readonly .. When the Alice class is de.ned at load time, the \nJAC PVM will attach a safe-method-import obligation to the resolu\u00adtion primitive of the import reference \nBob.sum. The generic proof linking mechanism will thus refuse to link Alice with any implementation of \nBob that does not honor this import type speci.cation. Consequently, the transitive state of the List \nreference passed into sum will be write protected.  6.2 Inspiring Trust by Asserting Export Types Suppose \nthe class Bob indeed provides a side-e.ect free implementation of the sum method. public class Bob { \npublic static int sum(List L) { intacc= 0; while (L != null) { acc += L.data; L = L.next; } return acc; \n} } To inspire trust, the class.le of Bob will need to be annotated properly. Speci.cally, the following \nexport type assertion is embedded into the class.le of Bob. Bob.sum : readonly .. When the class Bob \nis de.ned at load time, the veri.cation function of the JAC PVM will be invoked, and data.ow analysis \nis conducted on the body of the Bob.sum method so as to ensure that the implementation indeed lives up \nto its promise. In this case, the JAC PVM successfully veri\u00ad.es the export type assertion of the method, \nand class def\u00adinition is therefore granted. Next, when the import ref\u00aderence Bob.sum is resolved in Alice, \nthe proof obligation safe-method-import will be discharged to make sure that the export type of sum in \nBob is compatible with its cor\u00adresponding import type in Alice. Again, the check will succeed, and resolution \nwill be granted. To appreciate the robustness of trust inspiration, consider a version of Bob in which \nthe sum method silently corrupts the List argument. public class Bob { public static int sum(readonly \nList L) { int acc = 0; while (L != null) { acc += L.data; if (L.next == null) // corrupt last node L.data \n= 0; L = L.next; } return acc; } } The sum method perturbs the integer datum stored in the last node \nof the List argument, corrupting its transitive state. Without further annotation, Alice will not link \nwith Bob due to the incompatibility between the default export type of Bob.sum and its expected import \ntype in Alice.Yet, the class.le of Bob could be annotated with a JAC attribute that falsely claims that \nthe sum method is side-e.ect free. Bob.sum : readonly .. When the Aegis VM attempts to verify this version \nof Bob with the JAC PVM, the data.ow analyzer will fail to con\u00ad.rm the consistency of the export type \nassertion, and class de.nition will fail. In either case, write protection is guar\u00adanteed. 6.3 Secure \nSoftware Extension Consider a more realistic example, in which the class Alice dynamically loads a user-speci.ed \nextension to carry out the summation operation. public class Alice { public static void main(String[] \nargs) throws Throwable { List L = new List(1, new List(2, new List(3, null))); Class C = Class.forName(args[0]); \nBob b = (Bob) C.newInstance(); System.out.println(b.sum(L)); } } In this example, Bob is de.ned as an \ninterface specifying the invocation convention of the summation service. public interface Bob { int sum(List \nL); } To protect Alice, the class.le of Bob is annotated to ensure that any implementation of the sum \nservice must treat the List argument as readonly. Speci.cally, Bob.sum has the following export type \nin Bob. Bob.sum : readonly .. Notice, however, that there is no need to annotate Alice, because a default \nimport type for Bob.sum is assumed. Bob.sum : ... When the interface method reference Bob.sum is resolved \nin Alice, the corresponding safe-method-import obligation will be discharge successfully since the export \ntype of the resolved target (readonly ..) is a subtype of the default import type (...). Suppose the \nclass Charlie provides a non-compliant im\u00adplementation of Bob.sum. public class Charlie implements Bob \n{ public int sum(List L) { int acc = 0; while (L != null) { if (L.next == null) // corrupt last node \nL.data = 0; acc += L.data; L = L.next; } return acc; } } If Charlie is not annotated, then the default \nexport type of Charlie.sum will violate the subtyping constraint required for type safe method overriding. \nThe obligation safe-method-override will thus fail to discharge when Charlie is prepared. Alternatively, \nif Charlie falsely ex\u00adports the following type assertion Charlie.sum : readonly .. then the JAC PVM will \ndetect the inconsistency when the Charlie class is de.ned. In both cases, this faulty imple\u00admentation \nof Bob will be rejected.  6.4 Assessment A fundamental security challenge in dynamically extensi\u00adble \nsoftware systems has been the facilitation of secure co\u00adoperation among mutually distrusting code units \nwithin the same application. This problem and its variations have been known by many names: the problem \nof mutual suspicion [50] safe invocation [49], confused deputy [30], layered protection [22], etc. Although \nthe examples in this section are speci.c to the JAC type system, they do illustrate how the PVM facility \nand the generic proof linking mechanism may serve as an enabling technology by which application-speci.c \nsolu\u00adtions for secure cooperation can be implemented: 1. Protection by Access Contracts. Access control \nconstraints may be formulated as commitments, spec\u00adifying a contract between a class and its potentially \nmalicious collaborators (e.g., JAC import types). 2. Safe Dynamic Linking. Appropriate obligations must \nbe formulated to enforce the contract at link time (e.g., safe-method-import). The semantics of the obligations \nare de.ned through the development of an obligation library. 3. Trust Inspiration. To inspire trust, \ncollaborating code units must formulate matching commitments (e.g., JAC export types), and ensure that \nthey live up to their promises. The latter check is performed at link time by a PVM. 4. Secure Software \nExtension. Dynamic software ex\u00adtension is enabled in Java through the combination of dynamic loading \nand subtyping. The current protec\u00adtion scheme can also handle dynamic software exten\u00adsion through the \ndesign of appropriate subtyping rules (e.g., safe-method-override).  PVM Obl. Lib. Shared Total JAC \n2082 490 75 2647 Con.ned Type 2257 579 90 2926  Figure 7: Relative Complexity (in LOC) of the JAC and \nCon.ned Types Implementations Capability type systems [8] similar to JAC can be readily enforced in the \nPVM framework.  7. CONCLUDING REMARKS 7.1 Discussion Wider Applicability. Although only JAC was examined \nin this paper, the PVM framework is designed to be a gen\u00aderal extension mechanism for hosting a wide \nrange of link\u00adtime veri.cation services. E.orts are underway to develop PVMs and obligation libraries \nfor con.ned types [55] and alias burying [7], the other two alias control type systems that appear with \nJAC [37] in the SP&#38;E Special Issue on Aliasing in Object-Oriented Systems. Given our previous experience \nwith JAC, a .rst working implementation4 of con.ned types was obtained in 35 hours, with a complexity \ncomparable to that of JAC (see Figure 7). Implementation of alias burying is still on-going. Such implementation \nex\u00adercises will further demonstrate the generality of the PVM framework, and reveal potential areas of \nimprovement. Trusted Computing Base. The administrator of the Aegis VM is responsible for con.guring \nit with PVMs and obliga\u00adtion libraries, which are developed in native code, and are considered part of \nthe trusted computing base (TCB). A potential objection to this design is that application-speci.c veri.ers \nshould be part of the application layer, expressed in JVM bytecode as a classloader. Such an alternative \nap\u00adproach, if viable, would reduce the size of the TCB, and prevent buggy veri.ers from crashing the \nJVM. Attractive as it is, such an approach is unfortunately not feasible in the general case. Firstly, \nsuch a proposal overlooks the need for interchecking application classes with built-in classes. The latter \nare de.ned by the bootstrap classloader rather than user-de.ned classloaders, and thus a veri.cation \nmod\u00adule embedded in an user-de.ned classloader will have no way of generating proof obligations and commitments \nfor those built-in classes. Secondly, and more importantly, the attach\u00adment and discharging of proof \nobligations at speci.c linking events cannot be modeled at the bytecode level. Introducing application-speci.c \nchecks to strategic points of the dynamic linking process can only be achieved by modifying the inter\u00adnal \nbehavior of the JVM. The existing design appears to be the only technically feasible approach in the \ngeneral case. We however do not rule out the possibility that some veri\u00ad.cation domains (e.g., [15]) \nmay admit an implementation embedded in a classloader. An interesting approach to reduce programming \nerrors in PVMs and obligation libraries is to design alternative PVM and obligation library APIs that \nsupport plugins coded in 4This implementation can be found in the CVS repository of the Aegis VM Project. \na safe C dialect such as Cyclone [32]. The feasibility of this approach is currently being explored. \nEf.ciency. Early experience with small example code does not indicate that the PVM facility causes any \nsigni.cant performance degradation. Because there is no existing Java code base that are heavily annotated \nwith augmented types such as JAC, it is very di.cult to obtain performance mea\u00adsurement with real Java \napplications. However, we predict that any performance impact caused by the introduction of the PVM framework \nis correlated to the degree of static and dynamic coupling of application classes: the tighter classes \nare coupled, the more linking primitives are executed, and thus more obligation discharging and veri.cation \nsessions will be resulted. To better pro.le the performance char\u00adacteristics of the PVM facility, we \nare currently designing an arti.cial application domain in which the degree of class coupling can be \nprecisely manipulated. Self-Certifying Code. To reduce the performance over\u00adhead incurred by link-time \nveri.cation, a code producer may annotate untrusted code with a program-analytic certi.cate that witness \nto the safety of the code. Upon receiving the an\u00adnotated code, the link-time veri.cation service checks \nstati\u00adcally if the certi.cate indeed establishes the safety property in question. Intuitively, certi.cate \nchecking is more e.cient than establishing code safety from scratch. This is the mo\u00adtivation behind the \nidea of Proof-Carrying Code (PCC) [44, 43] and J2ME pre-veri.cation. The Proof Linking archi\u00adtecture \nand its PVM realization support the adoption of self-certifying code in a legacy environment, in which \na Java application may contain both unannotated code and self\u00adcertifying code. Speci.cally, a PVM may \nbe constructed to perform e.cient certi.cate checking for self-certifying code, and resort to full veri.cation \nfor unannotated code. In both cases, the PVM generates a veri.cation interface (i.e., proof obligations \nand commitments) for the class.le in question. Because of the modular veri.cation architecture, proof \nlinking processes proof obligations and commitments consistently in both cases despite the di.erence \nin how in\u00adtrachecking is performed (i.e., certi.cation checking vs full veri.cation). Consult [24, 22] \nfor an extensive discussion of how Proof Linking supports the interoperability of various distributed \nveri.cation protocols.  7.2 Related Work The correctness of the Proof Linking architecture, espe\u00adcially \nits interaction with lazy, dynamic linking, has been studied rigorously [23]. The correctness proof has \nbeen gen\u00aderalized to account for multiple classloaders [24]. Previous work focuses on how the Proof Linking \narchitecture may improve the comprehensibility and maintainability of the standard bytecode veri.er [23], \nand how it can facilitate distributed veri.cation [24]. This paper takes the research program a signi.cant \nstep further by (1) providing a com\u00adplete implementation of the Proof Linking architecture in the Aegis \nVM, (2) applying the Proof Linking architecture to build an extensible protection mechanism, in which \nthe link\u00adtime veri.cation service becomes pluggable, and (3) evalu\u00adating the utility of the extension \nmechanism in a concrete veri.cation domain. The lack of extensibility in mainstream VM implementa\u00adtions \nhas motivated a number of design alternatives. The XVM [31] allows applications to load code expressing \nappli\u00adcation-speci.c policies for customizing the run-time com\u00adpilation strategy, object placement within \nthe heap, and thread scheduling. The Jupiter VM [16] is based on a build\u00ading block architecture, in which \npluggable resource factories can be used to control run-time mechanisms such as thread model, memory \nallocation strategy, and object locality. The OVM [46] employs an object-oriented application framework \nto provide a re.ective, customizable intermediate language. The Aegis VM is the .rst to address the need \nof extensibil\u00adity on the security front by o.ering a con.gurable link-time veri.cation service within \na formally veri.ed architecture. The study of type-safe linking was pioneered in the work of Cardelli \n[10], which was followed by works such as typed object .les for TAL [28] and the comprehensive type system \nof Duggan [17]. Built on their prior experience in formalizing various as\u00adpects of Java s bytecode veri.er \nand dynamic linking model [29, 14, 47, 13], Qian et al [48] proposed a formal speci.ca\u00adtion of the Java \nclassloading model, taking into account of both bytecode veri.cation and the on-going maintenance of \nloading constraints. In their speci.cation, bytecode veri.ca\u00adtion is modeled as a modular primitive. \nInterchecking and classloading is avoided by the formulation of subtype con\u00adstraints to capture intermodular \ndependencies, a strategy similar to the formulation of proof obligation. The subtype constraints are \nmaintained and veri.ed lazily in the same way as the type equivalence constraints mandated by Liang and \nBracha [38, 39]. Two points of comparison are observed. While proof obligations can be arbitrary queries, \nQian et al focus only on Java subtyping constraints. Type consistency is modeled as a constraint problem \nover semilattices. In con\u00adtrast, the generic proof linking model can be applied to a wide spectrum of \nveri.cation domains. Furthermore, sub\u00adtype constraints are maintained on-the-.y, whereas proof obligations \nare scheduled to be discharged prior to the ex\u00adecution of their target linking primitives. This scheduling \nelement introduces an additional dimension of complexity into the Proof Linking architecture. Foster \net al [26] developed a general framework for adding user-de.ned type quali.ers to a language. The framework \nsupports quali.er polymorphism, and handles quali.er in\u00adferences separately from the standard type system. \nThe framework has been successfully applied to detect format string vulnerabilities [51]. The framework \nwas subsequently extended to account for .ow-sensitive type quali.ers [27]. The inference algorithm has \nbeen implemented in a tool Cqual, which allows programmers to annotate C programs with application-speci.c \ntype quali.ers, and subsequently checks for type-safety statically. Although the work of Fos\u00adter et al \nshares with PVM the same goal of enabling users to incorporate application-speci.c veri.cation into a \npro\u00adgramming language system, the two works di.er in several aspects. Firstly, while the work of Foster \net al represents a type-theoretic study of user-de.ned type quali.ers, PVM is a plug-in architecture \naimed at supporting a wide-range of static veri.cation tasks. Generality is achieved through a customizable \nproof linking mechanism, in which veri.cation interfaces are represented as proof obligations and commit\u00adments. \nSecondly, while Cqual is a compile-time analysis tool, the PVM facility is a link-time protection mechanism. \nThe explicit modeling of linking primitives and the formu\u00adlation of obligation discharging schedules \nare essential for enforcing safety in a lazy, dynamic linking environment. Extensibility is achieved \nin this work through modulariza\u00adtion. Alternatively, software adaptation could be conducted in a more \nsystematic manner through the application of ad\u00advanced programming constructs. Originally proposed as \nan alternative to encapsulation for implementing separation of concern, aspect-oriented programming [34, \n35] can be seen as a high-level program extension mechanism. Speci.cally, aspect-oriented programming \nsystems allow the weaving of aspect code into programmer-speci.ed join points,thereby modifying the behavior \nof the underlying program. Behav\u00adioral re.ection [20] and intercessory metaobject protocols [36] allow \noperations such as method invocation to be in\u00adtercepted. When an interception occurs, a metaobject will \nbe noti.ed of the event via some kind of method call back facility. Programmers can customize the semantics \nof the metaobject to achieve the e.ect of software extension.  7.3 Future Work As the extension APIs \nfor PVMs and obligation libraries are orthogonal to the rest of the VM architecture, an in\u00adteresting \nendeavor is to reproduce the same extension APIs in other JVM implementations, thereby making PVMs and \nobligation libraries interoperable with multiple JVMs. To facilitate program analysis, the Aegis VM passes \nto the PVM veri.cation function the AST and type analysis results of the target class.le. The veri.cation \nfunction can utilize the control .ow and typing information to speed up intra\u00adchecking. Further speedup \nmay be achievable if the data.ow structure of bytecode methods can be made explicit, and is passed along \nwith the class.le AST to the veri.cation func\u00adtion. One promising direction is to develop reusable PVMs \nthat summarize the data.ow structure of a bytecode method in a SSA-based representation [4] along the \nline of Jimple [54] or SafeTSA [3]. To support this, an extension of the PVM API is planned to allow \nPVMs to share analysis re\u00adsults with each other. The author is exploring the design of a capability type \nsystem in which high-level access control constraints can be expressed to enable secure cooperation in \nJava bytecode pro\u00adgrams [25]. Such a type system will exploit the PVM facility as a development platform. \nAnother direction of interest is to explore the embedding of Jif (Java Information Flow) [42, 41] in \nthe PVM framework. Proof Linking generalizes the link-time access control checks performed in a standard \nJVM. An extensible protection mechanism is obtained by making these access control checks customizable. \nAnother set of safety checks performed by the JVM are loading constraints, which are essentially equiva\u00adlence \nconstraints over binding of class symbols from di.erent namespaces [38]. An interesting direction is \nto generalize the idea of Qian et al [48], and make loading constraints customizable: users may introduce \napplication-speci.c con\u00adstraint systems over the binding of class symbols, and main\u00adtain binding consistency \nwith pluggable constraint solvers. This .exibility could yield an extensible protection mecha\u00adnism for \nwhich the subtype constraint system of Qian et al becomes a special case. Both the the PVM facility and \nthe extensible loading constraint system suggested in the previous paragraph are special-purpose extension \nmechanisms. An existing check is identi.ed, and customizability is introduced through some kind of special-purpose \nplug-in mechanism. An alternative is to consider the application of general-purpose software adaptation \nmechanisms, such as Aspect-Oriented Program\u00adming, to extend the protection mechanism of a JVM. In this \napproach, customizable join points are documented and publicized as an Extension Programming Interface. \nCus\u00adtomization code is then weaved into these join points as security aspects. Such an approach may reduce \nthe proba\u00adbility of programming error, and thus simplify the process of transforming an existing protection \nmechanism into an extensible one.  7.4 Conclusion A extensible protection mechanism, Pluggable Veri.ca\u00adtion \nModules, has been designed and implemented for the JVM. Enabled by the Proof Linking architecture, the \nexten\u00adsion mechanism turns link-time veri.cation into a pluggable service. The software engineering and \nsecurity engineer\u00ading bene.ts of the extension framework have been demon\u00adstrated. This suggests the notion \nof pluggable veri.cation services is more than just an isolated technological novelty, but rather it \nrepresents a paradigm for building safe lan\u00adguage environments. The notion of safety changes as the protection \nneeds of a language environment evolve. A well\u00addesigned language environment should anticipate evolution \nby building into itself an extension mechanism that sup\u00adports the augmentation of its veri.cation service. \nMuch like a pipeline architecture (i.e., scanner, parser, optimizer, code generator, etc) is a standard \narchitecture for compilers, the author argues that a modular veri.cation architecture such as Proof Linking \nshould be a standard design for safe lan\u00adguage environments.  8. ACKNOWLEDGEMENTS This work was supported \nin part by an NSERC Discovery Grant. The author is grateful for the valuable comments from Warren Burton, \nRobert Cameron, James Cordy, Tiko Kameda, and the anonymous reviewers. 9. REFERENCES [1] Jonathan Aldrich, \nCraig Chambers, and David Notkin. ArchJava: Connecting software architecture to implementation. In Proceedings \nfo the 24th International Conference on Software Engineering (ICSE 02), pages 187 197, Orlando, Florida, \nUSA, May 2002. [2] Jonathan Aldrich, Valentin Kostadinov, and Craig Chambers. Alias annotations for \nprogram understanding. In Proceedings of the 17th ACM SIGPLAN Conference on Object-Oriented Programming, \nSystems, Languages, and Applications (OOPSLA 02), pages 311 330, Seattle, Washington, USA, November 2002. \n[3] Wolfram Amme, Niall Dalton, Je.ery von Ronne, and Michael Franz. SafeTSA: A type safe and referentially \nsecure mobile-code representation based on static single assignment form. In Proceedings of the ACM SIGPLAN \n2001 Conference on Programming Language Design and Implementation (PLDI 01), pages 137 147, Snowbird, \nUtah, USA, May 2001. [4] John Aycock and Nigel Horspool. Simple generation of static single-assignment \nform. In Proceedings of the 9th International Conference on Compiler Construction (CC 00), volume 1781 \nof Lecture Notes in Computer Science, pages 110 124, Berlin, Germany, April 2000. [5] Brian Bershad, \nStefan Savage, Przemyslaw Pardyak, Emin Gun Sirer, David Becker, Marc Fiuczynski, Craig Chambers, and \nSusan Eggers. Extensibility, safety and performance in the SPIN operating system. In Proceedings of the \n15th ACM Symposium on Operating System Principles (SOSP 95), pages 267 284, Copper Mountain, Colorado, \nUSA, December 1995. [6] Joshua Bloch. JSR 175: A metadata facility for the Java programming language. \nhttp://www.jcp.org/en/jsr/detail?id=175. [7] John Boyland. Alias burying: Unique variables without destructive \nreads. Software Practice and Experience, 31(6):533 553, May 2001. [8] John Boyland, James Noble, and \nWilliam Retert. Capabilities for sharing: A generalisation of uniqueness and read-only. In Proceedings \nof the 15th European Conference on Object-Oriented Programming (ECOOP 01), Budapest, Hungary, June 2001. \n[9] Gilad Bracha, Martin Odersky, David Stoutamire, and Philip Wadler. Making the future safe for the \npast: adding genericity to the Java programming language. In Proceedings of the Conference on Object-Oriented \nProgramming, Systems, Languages, and Applications (OOPSLA 98), pages 183 200, Vancouver, British Columbia, \nCanada, October 1998. [10] Luca Cardelli. Program fragments, linking, and modularization. In Proceedings \nof the 24th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL 97), pages 256 \n265, Paris, France, January 1997. [11] Antonio Carzaniga, Gian Pietro Picco, and Giovanni Vigna. Designing \ndistributed applications with mobile code paradigms. In Proceedings of the 19th International Conference \non Software Engineering (ICSE 97), pages 22 32, Boston, Massachusetts, USA, May 1997. [12] David G. Clarke, \nJohn M. Potter, and James Noble. Ownership types for .exible alias protection. In Proceedings of the \n13th ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA \n98), pages 48 64, Vancouver, British Columbia, Canada, October 1998. [13] Alessandro Coglio and Allen \nGoldberg. Type safety in the JVM: Some problems in JDK 1.2.2 and proposed solutions. In Proceedings of \nthe 2nd ECOOP Workshop on Formal Techniques for Java Programs, Sophia Antipolis and Cannes, France, June \n2000. [14] Alessandro Coglio, Allen Goldberg, and Zhenyu Qian. Toward a provably-correct implementation \nof the JVM bytecode veri.er. In Proceedings of the OOPSLA 98 Workshop on the Formal Underpinnings of \nJava, October 1998. [15] John Corwin, David F. Bacon, David Grove, and Chet Murthy. MJ: A rational module \nsystem for Java and its applications. In Proceedings of the 18th ACM SIGPLAN Conference on Object-Oriented \nProgramming, Systems, Languages, and Applications (OOPSLA 03), pages 241 254, Anaheim, California, USA, \nOctober 2003. [16] Patrick Doyle and Tarek S. Abdelrahman. A modular and extensible JVM infrastructure. \nIn Proceedings of the USENIX 2nd Java Virtual Machine Research and Technology Symposium (JVM 02), San \nFrancisco, California, USA, August 2002. [17] Dominic Duggan. Type-safe linking with recursive DLL and \nshared libraries. ACM Transactions on Programming Languages and Systems, 24(6):711 804, November 2002. \n[18] ECMA. Common language infrastructure (CLI). Standard 335, ECMA, December 2002. [19] Dawson R. Engler, \nM. Frans Kaashoek, and James O Toole Jr. Exokernel: An operating system architecture for application-level \nresource management. In Proceedings of the 15th ACM Symposium on Operating System Principles (SOSP 95), \nCopper Mountain, Colorado, USA, December 1995. [20] Jacques Ferber. Computational re.ection in class \nbased object oriented languages. In Proceedings of the Conference on Object-Oriented Programming Systems, \nLanguages and Applications (OOPSLA 89),pages 317 326, New Orleans, Louisiana, USA, October 1989. [21] \nPhilip W. L. Fong. The Aegis VM Project. http://aegisvm.sourceforge.net. [22] Philip W. L. Fong. Proof \nLinking: A Modular Veri.cation Architecture for Mobile Code Systems. PhD thesis, School of Computing \nScience, Simon Fraser University, Burnaby, B.C., Canada V5A 1S6, 2004. [23] Philip W. L. Fong and Robert \nD. Cameron. Proof linking: Modular veri.cation of mobile programs in the presence of lazy, dynamic linking. \nACM Transactions on Software Engineering and Methodology, 9(4):379 409, October 2000. [24] Philip W. \nL. Fong and Robert D. Cameron. Proof linking: Distributed veri.cation of Java class.les in the presence \nof multiple classloaders. In Proceedings of the USENIX Java Virtual Machine Research and Technology Symposium \n(JVM 01), pages 53 66, Monterey, California, USA, April 2001. [25] Philip W. L. Fong and Cheng Zhang. \nCapabilities as alias control: Secure cooperation in dynamically extensible systems. Technical Report \nCS-2004-3, Department of Computer Science, University of Regina, Regina, Saskatchewan, Canada S4S 0A2, \n2004. ISBN:0-7731-0479-8. [26] Je.rey S. Foster, Manuel F\u00a8ahndrich, and Alexander Aiken. A theory of \ntype quali.ers. In Proceedings of the ACM SIGPLAN 1999 Conference on Programming Language Design and \nImplementation (PLDI 99), pages 192 203, Atlanta, Georgia, USA, May 1999. [27] Je.rey S. Foster, Tachio \nTerauchi, and Alex Aiken. Flow-sensitive type quali.ers. In Proceedings of the ACM SIGPLAN 2002 Conference \non Programming Lanuage Design and Implementation (PLDI 02),pages 1 12,Berlin,Germany,June 2002. [28] \nNeal Glew and Greg Morrisett. Type-safe linking and modular assembly language. In Proceedings of the \n26th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL 99), pages 250 261, San \nAntonio, Texas, USA, January 1999. [29] Allen Goldberg. A speci.cation of Java loading and bytecode veri.cation. \nIn Proceedings of the 5th ACM Conference on Computer and Communications Security (CCS 98), pages 49 58, \nSan Francisco, California, USA, November 1998. [30] Norm Hardy. The confused deputy (or why capabilities \nmight have been invented). ACM SIGOPS Operating Systems Review, 22(4):36 38, October 1988. [31] Timothy \nL. Harris. Extensible virtual machines. Technical Report 525, University of Cambridge Computer Laboratory, \nCambridge, UK, December 2001. [32] Trevor Jim, Greg Morrisett, Dan Grossman, Michael Hicks, James Cheney, \nand Yanling Wang. Cyclone: A safe dialect of C. In Proceedings of the USENIX Annual Technical Conference, \npages 275 288, Monterey, California, USA, June 2002. [33] Sarfraz Khurshid, Darko Marinov, and Daniel \nJackson. An analyzable annotation language. In Proceedings of the 17th ACM SIGPLAN Conference on Object-Oriented \nProgramming, Systems, Languages, and Applications (OOPSLA 02), pages 231 245, Seattle, Washington, USA, \nNovember 2002. [34] Cregor Kiczales, John Lamping, Anurag Mendhekar, Chris Maeda, Christina Videira Lopes, \nJean-Marc Loingtier, and John Irwin. Aspect-oriented programming. In Proceedings of the 11th European \nConference on Object-Oriented Programming (ECOOP 97), volume 1241 of Lecture Notes in Computer Science, \nFinland, June 1997. Springer-Verlag. [35] Gregor Kiczales, Erik Hilsdale, Jim Hugunin, Mik Kersten, Je.rey \npalm, and William Griswold. An overview of AspectJ. In Proceedings of the 15th European Conference on \nObject-Oriented Programming (ECOOP 01), volume 2072, pages 327 353, Budapest, Hungary, June 2001. [36] \nGregor Kiczales, Jim Des Rivieres, and Daniel Bobrow. The Art of the Metaobject Protocol.MIT Press, 1991. \n[37] G\u00a8unter Kniesel and Dirk Theisen. JAC access right based encapsulation for Java. Software Practice \nand Experience, 31(6):555 576, May 2001. [38] Sheng Liang and Gilad Bracha. Dynamic class loading in \nthe Java virtual machine. In Proceedings of the 1998 ACM SIGPLAN Conference on Object-Oriented Programming, \nSystems, Languages and Applications (OOPSLA 98), pages 36 44, Vancouver, British Columbia, Canada, October \n1998. [39] Tim Lindholm and Frank Yellin. The Java Virtual Machine Speci.cation. Addison Wesley, 2nd \nedition, 1999. [40] J. W. Lloyd. Foundations of Logic Programming. Springer-Verlag, 2nd edition, 1987. \n[41] Andrew C. Myers. JFlow: Practical mostly-static information .ow control. In Proceedings of the 26th \nACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL 99), pages 228 241, San Antonio, \nTexas, USA, January 1999. [42] Andrew C. Myers and Barbara Liskov. Complete, safe information .ow with \ndecentralized labels. In Proceedings of the 1998 IEEE Symposium on Security and Privacy (S&#38;P 98), \nOakland, California, USA, May 1998. [43] George C. Necula. Proof-carrying code. In Proceedings of the \n24th ACM Symposium on Principles of Programming Languages (POPL 97), pages 106 119, Paris, France, January \n1997. [44] George C. Necula and Peter Lee. Safe kernel extensions without run-time checking. In Proceedings \nof the Second Symposium on Operating System Design and Implementation (OSDI 96), pages 229 243, Seattle, \nWashington, USA, October 1996. [45] R. O Callahan. A simple, comprehensive type system for Java bytecode \nsubroutines. In Proceedings of the 26th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming \nLanguages (POPL 99), pages 70 78, San Antonio, Texas, USA, January 1999. [46] K. Palacz, J. Baker, C. \nFlack, C. Grotho., H. Yamauchi, and J. Vitek. Engineering a customizable intermediate representation. \nIn Proceedings of the Workshop on Interpreters, Virtual Machines and Emulators (IVME 03), San Diego, \nCalifornia, USA, June 2003. [47] Zhenyu Qian. Standard .xpoint iteration for Java bytecode veri.cation. \nACM Transactions on Programming Languages and Systems, 22(4):638 672, July 2000. [48] Zhenyu Qian, Allen \nGoldberg, and Alessandro Coglio. A formal speci.cation of Java class loading. In Proceedings of the 15th \nConference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA 00), pages 325 \n336, Minneapolis, Minnesota, USA, October 2000. [49] Jonathan A. Rees. A security kernel based on the \nlambda-calculus. A.I. Memo 1564, MIT, 1996. [50] Michael D. Schroeder. Cooperation of Mutually Suspicious \nSubsystems in a Computer Utility.Ph.D. thesis, Massachusetts Institute of Technology, September 1972. \n[51] Umesh Shankar, Kunal Talwar, Je.rey S. Foster, and David Wagner. Detecting format-string vulnerabilities \nwith type quali.ers. In Proceedings of the 10th USENIX Security Symposium, Washington, D.C., USA, August \n2001. [52] Raymie Stata and Martin Abadi. A type system for Java bytecode subroutines. ACM Transactions \non Programming Languages and Systems, 21(1):90 137, January 1999. [53] Tommy Thorn. Programming languages \nfor mobile code. ACM Computing Surveys, 29(3):213 239, September 1997. [54] Raja Vall\u00b4ee-Rai, Phong Co, \nEtienne Gagnon, Laurie Hendren, Patrick Lam, and Vijay Sundaresan. Soot -a Java bytecode optimization \nframework. In Proceedings of the 1999 Conference of the Centre for Advanced Studies on Collaborative \nResearch (CASCON 99), Mississauga, Ontario, Canada, November 1999. [55] Jan Vitek and Boris Bokowski. \nCon.ned types in Java. Software Practice and Experience, 31(6):507 532, May 2001.  \n\t\t\t", "proc_id": "1028976", "abstract": "<p>Through the design and implementation of a JVM that supports Pluggable Verification Modules (PVMs), the idea of an extensible protection mechanism is entertained. Link-time bytecode verification becomes a pluggable service that can be readily replaced, reconfigured and augmented. Application-specific verification services can be safely introduced into the dynamic linking process of the JVM. This feature is enabled by the adoption of a previously proposed modular verification architecture, Proof Linking [23, 24], which decouples bytecode verification from the dynamic linking process, rendering the verifier a replaceable module. The PVM mechanism has been implemented in an open source JVM, the Aegis VM [21]. To evaluate the software engineering and security engineering benefits of this extensible protection mechanism, an augmented type system JAC (Java Access Control) [37] has been successfully implemented as a PVM.</p>", "authors": [{"name": "Philip W. L. Fong", "author_profile_id": "81100096354", "affiliation": "University of Regina, Regina, Canada", "person_id": "PP39060893", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1028976.1029010", "year": "2004", "article_id": "1029010", "conference": "OOPSLA", "title": "Pluggable verification modules: an extensible protection mechanism for the JVM", "url": "http://dl.acm.org/citation.cfm?id=1029010"}