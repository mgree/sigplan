{"article_publication_date": "10-23-2004", "fulltext": "\n\t\t\t", "proc_id": "1028664", "abstract": "<p>In the domain of hard real-time systems, which language is better: C++ or the Real-Time Specification for Java (RTSJ)? Although standard Java provides a more productive programming environment than C++ due to automatic memory management, that benefit does not apply to RTSJ when using NoHeapRealtimeThread and non-heap memory areas. As a result, RTSJ programmers must manage non-heap memory explicitly. Although that's a common practice in real-time applications, it's also a common source of programmer error, regardless of language. In an ironic role reversal, this paper shows that C++ is able to provide a safer programming environment than RTSJ (or C) for managing memory in a hard-real-time producer/consumer pattern. C++ accomplishes this via a reference-counting pointer. RTSJ (and C) cannot provide an equivalent mechanism because it lacks the necessary language features. Despite other attractive features of RTSJ, the relative simplicity and safety of the C++ programming model for this common pattern suggests that C++ will be a strong competitor to RTSJ in the domain of real-time mission-critical systems.</p>", "authors": [{"name": "Daniel L. Dvorak", "author_profile_id": "81539235056", "affiliation": "Jet Propulsion Laboratory, Pasadena, CA", "person_id": "P598249", "email_address": "", "orcid_id": ""}, {"name": "William K. Reinholtz", "author_profile_id": "81309491172", "affiliation": "Jet Propulsion Laboratory, Pasadena, CA", "person_id": "PP14082321", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1028664.1028770", "year": "2004", "article_id": "1028770", "conference": "OOPSLA", "title": "Hard real-time: C++ versus RTSJ", "url": "http://dl.acm.org/citation.cfm?id=1028770"}