{"article_publication_date": "10-01-2004", "fulltext": "\n Practical Predicate Dispatch Todd Millstein Computer Science Department University of California, Los \nAngeles todd@cs.ucla.edu ABSTRACT Keywords Predicate dispatch is an object-oriented (OO) language mechanism \nfor determining the method implementation to be invoked upon a message send. With predicate dispatch, \neach method implemen\u00adtation includes a predicate guard specifying the conditions under which the method \nshould be invoked, and logical implication of predicates determines the method overriding relation. Predicate \ndispatch naturally uni.es and generalizes several common forms of dynamic dispatch, including traditional \nOO dispatch, multimethod dispatch, and functional-style pattern matching. Unfortunately, prior languages \nsupporting predicate dispatch have had several de.cien\u00adcies that limit its utility in practice. We introduce \nJPred, a backward-compatible extension to Java supporting predicate dispatch. While prior languages with \npredi\u00adcate dispatch have been extensions to toy or non-mainstream lan\u00adguages, we show how predicate dispatch \ncan be naturally added to a traditional OO language. While prior languages with predicate dispatch have \nrequired the whole program to be available for type\u00adchecking and compilation, JPred retains Java s modular \ntypecheck\u00ading and compilation strategies. While prior languages with predi\u00adcate dispatch have included \nspecial-purpose algorithms for reason\u00ading about predicates, JPred employs general-purpose, off-the-shelf \ndecision procedures. As a result, JPred s type system is more .ex\u00adible, allowing several useful programming \nidioms that are spuri\u00adously rejected by those other languages. After describing the JPred language and \ntype system, we present a case study illustrating the utility of JPred in a real-world application, including \nits use in the detection of several errors.  Categories and Subject Descriptors D.1.5 [Programming Techniques]: \nObject-oriented Programming; D.3.3 [Programming Languages]: Language Constructs and Fea\u00adtures classes \nand objects, inheritance, procedures, functions, and subroutines  General Terms Design, Languages Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 04, Oct. \n24-28, 2004, Vancouver, British Columbia, Canada. Copyright 2004 ACM 1-58113-831-8/04/0010 ...$5.00. \npredicate dispatch, dynamic dispatch, modular typechecking 1. INTRODUCTION Many programming languages \noffer a form of dynamic dispatch, a declarative mechanism for determining the code to be executed upon \na function invocation. In this style, a function consists of a set of implementations, each with a guard \nspecifying the condi\u00adtions under which that implementation should be executed. When a function is invoked, \nall the implementations that are applicable, meaning that their guards are satis.ed, are considered. \nOf the ap\u00adplicable implementations, the one that overrides all other imple\u00admentations is selected to \nbe executed. For example, a method m in mainstream object-oriented (OO) languages like Java [3, 28] has \nan implicit guard specifying that the runtime class of the receiver argument must be a subclass of m \ns enclosing class. A method m1 overrides another method m2 if the enclosing class of m1 is a subclass \nof the enclosing class of m2. Multimethod dispatch, as found in languages like Cecil [11, 13] and MultiJava \n[16], generalizes the implicit OO guards to sup\u00adport runtime class tests on any subset of a method s \narguments, and the overriding relation is likewise generalized to all arguments. As another example, \npattern matching in functional languages like ML [40] allows guards to test the datatype constructor \ntags of ar\u00adguments and to recursively test the substructure of arguments. In that setting, the textual \nordering of function implementations deter\u00admines the overriding relation. Dynamic dispatch offers a number \nof important advantages over manual dispatch using if statements. First, dynamic dispatch al\u00adlows the \nguards on each implementation to be declaratively spec\u00adi.ed, and the best implementation is automatically \nselected for a given invocation. Second, in the presence of OO-style inher\u00aditance, dynamic dispatch makes \nfunctions extensible: a function can be extended simply by writing additional implementations that override \nexisting ones or handle new scenarios, without modifying any existing code. Finally, dynamic dispatch \nsupports better static typechecking than manual dispatch using if statements. Dynamic dispatch alleviates \nthe need for explicit runtime type casts, which subvert the static type system. Static typechecking for \ndynamic dispatch additionally ensures that method lookup cannot fail: there can never be dynamic message-not-understood \nerrors (which oc\u00adcur when no methods are applicable to an invocation) or message\u00adambiguous errors (which \noccur when multiple methods are appli\u00adcable to an invocation, but no unique applicable method overrides \nall others). In 1998, Ernst et al. introduced the concept of predicate dis\u00adpatch [20]. With predicate \ndispatch, a method implementation may specify an arbitrary predicate as a guard. A method m1 overrides \nanother method m2 if m1 s predicate logically implies m2 s pred\u00adicate. Ernst et al. provide a number \nof examples illustrating how predicate dispatch uni.es and generalizes several existing language concepts, \nincluding ordinary OO dynamic dispatch, multimethod dispatch, and functional-style pattern matching. \nThey also formally de.ne predicate evaluation and provide a static type system that en\u00adsures that method \nlookup cannot fail. Finally, Ernst et al. de.ne a conservative algorithm for testing validity of predicates, \nwhich is necessary both for computing the method overriding relation and for static typechecking. Despite \nthis strong initial work, and despite additional work on the topic [14, 54, 47], to date predicate dispatch \nhas had several de.ciencies that limit its utility in practice. First, implementations of predicate dispatch \nhave all been in the context of toy or non\u00admainstream languages, and none of these implementations has \nin\u00adcluded static typechecking. Second, there has been no progress on static typechecking for predicate \ndispatch since the original work, and the type system described there is global, requiring access to \nthe entire program before typechecking can be performed. This makes it dif.cult to ensure basic well-formedness \nproperties of in\u00addividual classes, and it clashes with the modular typechecking style of mainstream OO \nlanguages. Third, the existing static type system for predicate dispatch is overly conservative, ruling \nout many de\u00adsirable uses of predicate dispatch. For example, that type system cannot determine that the \npredicates x > 0 and x = 0, where x is an integer argument to a function, are exhaustive and mutually \nexclu\u00adsive. Therefore, the type system will reject a function consisting of two implementations with \nthese guards as potentially containing both exhaustiveness and ambiguity errors. Finally, little evidence \nhas been presented to illustrate the utility of predicate dispatch in real-world applications. This paper \nremedies these de.ciencies. We present JPred, a backward-compatible extension to Java supporting predicate \ndis\u00adpatch. Our contributions are as follows: We illustrate through the design of JPred how predicate \ndis\u00adpatch can be practically incorporated into a traditional OO language. The extension is small syntactically \nand yet makes a variety of programming idioms easier to express and vali\u00addate.  We describe a static \ntype system for JPred that naturally re\u00adspects Java s modular typechecking strategy: each compila\u00adtion \nunit (typically a single class) can be safely typechecked in isolation, given only information about \nthe classes and in\u00adterfaces on which it explicitly depends. We achieve modular typechecking by adapting \nand generalizing our prior work on modular typechecking of multimethods [37].  We describe how to use \noff-the-shelf decision procedures to determine relationships among predicates. We use de\u00adcision procedures \nboth to compute the method overriding relation, which affects the semantics of dynamic dispatch, and \nto ensure exhaustiveness and unambiguity of functions, which is part of static typechecking. The use \nof decision pro\u00adcedures provides precise reasoning about the predicates in JPred s predicate language. \nThis contrasts with the special\u00adized and overly conservative algorithms for reasoning about predicates \nthat are used in previous languages containing pred\u00adicate dispatch.  Our implementation uses CVC Lite \n[17], a successor to the Cooperating Validity Checker [53]. CVC Lite contains de\u00adcision procedures for \nseveral decidable theories, including propositional logic, rational linear arithmetic, and the theory \npred ::= lit | tgt | Identi.er as tgt | [Identi.er as] tgt@ClassType | uop pred | pred bop pred lit ::= \nnull | IntegerLiteral | BooleanLiteral tgt ::= this | Identi.er | tgt.Identi.er uop ::= ! | \u00ad bop ::= \n&#38;&#38; | || | == | != | < | <= | > | >= | + | -| * Figure 1: The abstract syntax of predicate expressions \nin JPred. Brackets enclose optional pieces of syntax. Nontermi\u00adnals Identi.er, ClassType, IntegerLiteral, \nand BooleanLiteral are de.ned as in the Java Language Speci.cation [28]. of equality. CVC Lite is sound \nand complete for validity queries over JPred s predicate language, so our language and type system remain \nwell de.ned and predictable. We have implemented JPred as an extension in the Polyglot extensible compiler \nframework for Java [44]. In addition to the modular typechecking strategy, we have implemented a simple \nmodular compilation strategy that compiles JPred source to regular Java source, which can be compiled \nwith a standard Java compiler and executed on a standard Java vir\u00adtual machine. In this way, JPred source \nand bytecode .les interoperate seamlessly with Java source and bytecode .les, including precompiled Java \nlibraries.  To demonstrate the utility of JPred in practice, we have un\u00addertaken a realistic case study \nusing the language. We have rewritten a Java implementation of a discovery service that is part of the \none.world platform for pervasive computing [29] to use JPred. We illustrate and quantify the advantages \nthat JPred provides, including its use in the detection of several errors.  Section 2 introduces JPred \nand illustrates its expressiveness by example. Section 3 discusses our modular static type system for \nJPred. Section 4 describes how we use off-the-shelf decision pro\u00adcedures to reason about relationships \namong predicates. Section 5 overviews our JPred implementation, including the modular com\u00adpilation strategy. \nSection 6 describes the case study illustrating JPred s effectiveness. Section 7 discusses related work, \nand sec\u00adtion 8 concludes. 2. JPRED BY EXAMPLE In this section we overview the JPred language, illustrating \nits bene.ts to programmers via a number of examples. The section ends with a precise description of the \nsemantics of method invoca\u00adtion in JPred. JPred augments the Java language by allowing each method dec\u00adlaration \nto optionally include a clause of the form when pred, just before the optional throws clause. The predicate \nexpression pred is a boolean expression specifying the conditions under which the method may be invoked. \nThe abstract syntax of predicate expres\u00adsions is given in .gure 1. Predicate expressions may include \nlit\u00aderals, references to formals and .elds in scope, identi.er binding, dynamic dispatch on classes, \nand a host of boolean, relational, and arithmetic operations. We call a method containing a when clause \na predicate method. class FileEditor { void handle(Event e) { if (e instanceof Open) { Open o = (Open) \ne; ... // open a .le } else if (e instanceof SaveAs) { SaveAs s = (SaveAs) e; ... // save to a new \n.le } else if (e instanceof Save) { Save s = (Save) e; ... // save the .le } else { ... // handle unexpected \nevents }}} Figure 2: A .le editor implemented in Java. 2.1 Multimethod Dispatch 2.1.1 Event-Based Systems \nFigure 2 illustrates an event-based implementation of a .le ed\u00aditor in Java. The handle operation is \ninvoked when an event is triggered by the user s action. The passed event is handled differ\u00adently according \nto its runtime class. This implementation style for event-based systems allows multiple clients to handle \nposted events in different ways within an application. It also allows each client to handle a different \nsubset of posted events. Finally, the style allows new events to be added to the system without having \nto modify all existing clients. However, this style also has a number of disadvantages. First, the programmer \nhas the burden of manually performing event dis\u00adpatch, and the cases of the monolithic ifstatement must \nbe ordered such that the right code will be executed for each scenario. For example, assuming that SaveAs \nis a subclass of Save, the second and third cases in .gure 2 must appear in that order, or else the handler \nfor SaveAs will never be invoked. Second, the monolithic style makes the event handlers dif.cult to reuse \nand extend by sub\u00adclasses. For example, a subclass cannot easily choose to inherit some of FileEditor \ns handlers, override others, and add new han\u00addlers for other events. Third, the heavy use of runtime \ntype tests and casts provides the potential for dynamic cast failures. Finally, there is no static checking \nto ensure that all possible events are han\u00addled and that no handlers are redundant. For example, the \nhandle method in .gure 2 would still typecheck successfully if the else case were removed, even though \nthat could cause errors to occur dynamically. Figure 3 shows how the .le editor can be equivalently imple\u00admented \nin JPred. The .rst three methods are multimethods [8], us\u00ading JPred s specializer expression to dynamically \ndispatch on their arguments in addition to the receiver. Similar to multimethod nota\u00adtion in Cecil [11, \n13], the predicate e@Open declares the specialized type (or specializer) of the target e to be Open: \nthe .rst method in the .gure is only applicable to an invocation of handle if the run\u00adtime class of the \nactual argument is a subclass of Open. When type\u00adchecking the body of the .rst handlemethod, the formal \nparameter e is considered to have type Open, thereby allowing the body to ac\u00adcess .elds and methods that \nare speci.c to the Open subclass of Event. JPred s semantics differs from Java s static overloading mecha\u00ad \nclass FileEditor {void handle(Event e) when e@Open { ... // open a .le }void handle(Event e) when e@SaveAs \n{ ... // save to a new .le }void handle(Event e) when e@Save { ... // save the .le }void handle(Event \ne) { ... // handle unexpected events } } Figure 3: The .le editor implemented in JPred. class PrintingEditor \nextends FileEditor {void handle(Event e) when e@Open { ... // a better way to open .les }void handle(Event \ne) when e@Print { ... // print the .le } } Figure 4: An extension to the .le editor. nism, which uses \nthe static type of an actual argument expression to statically determine which methods are applicable. \nFor example, a Java method of the form void handle(Open e) { ... // open a .le } will never be executed \nfrom a handle call site whose actual argu\u00adment expression has static type Event, even if at runtime the \nactual argument is an instance of Open. The method overriding relation in JPred is determined by pred\u00adicate \nimplication; the textual order of methods is irrelevant. The @ predicate corresponds to Java s instanceof \nexpression and has the same semantics. The last handle method in .gure 3 implicitly has the predicate \ntrue. Therefore, the .rst three methods each override the last one (since every predicate logically implies \ntrue), and the second method overrides the third (since an instance of SaveAs can always be viewed as \nan instance of Save). For example, if an invo\u00adcation of handle dynamically has a SaveAs instance as the \nargu\u00adment, then the last three methods in the .gure are applicable, since their guards evaluate to true, \nand the second method is invoked because it overrides the third and fourth methods. While Java s instanceof \nexpression can be used to test against both classes and interfaces, JPred s specializer expression requires \nthe given type to be a class. As mentioned in section 3, this requirement allows us to preserve modular \nstatic typechecking. The JPred implementation of the editor resolves the problems of the Java implementation \nin .gure 2. Each conceptual handler is now encapsulated in its own method, and its guard declaratively \nstates the conditions under which that handler should be invoked. JPred s dispatch semantics naturally \nmatches programmer intent: the handlers can appear in any order, and JPred ensures that the right handler \nis invoked for each scenario. Further, the code is now statically type safe: there is no potential for \ndynamic cast failures, and as described in section 3, the JPred typechecker ensures that the handlers \ncover all possible scenarios and are not ambiguous with one another. Finally, unlike the original implementation, \nthe JPred implemen\u00adtation of FileEditor is easily extensible, allowing for deep hier\u00adarchies of event \nhandlers that share code in .exible ways. Pred\u00adicate methods have the same properties as regular methods, \nand class TypeCheck { Type typeCheck(TypeEnv te, Node@If n) { ... } Type typeCheck(TypeEnv te, Node@While \nn) { ... } ... } Figure 5: Noninvasive visitors in JPred. hence they are naturally inherited by subclasses. \nFor example, an extended version of the editor is shown in .gure 4. This editor pro\u00advides a more optimized \nimplementation of .le opening and addi\u00adtionally provides printing functionality. JPred dispatches an \ninvoca\u00adtion to one of the methods in FileEditor whenever no method in PrintingEditoris applicable. For \nexample, if a PrintingEditor instance is sent a Save instance, the third method in .gure 3 will automatically \nbe invoked. In practice, event handlers can be signi.cantly more complicated than the example shown in \n.gure 2. For example, a handler may test its current state in addition to the runtime type of the event, \nin order to determine how to handle the event. JPred s advantages over Java for implementing event-based \nsystems increase as han\u00addlers become more complex. Our case study in section 6 illustrates JPred s usage \nin a real-world event-based system to create reliable and extensible event handlers. As a syntactic sugar, \nJPred supports MultiJava-style syntax for specializer expressions [16], so the .rst handle method in \n.gure 3 can be equivalently written as follows: void handle(Event@Open e) { ... } MultiJava-style specializers \nget desugared into a conjunction of JPred specializer expressions, which are conjoined to the front of \nany explicit predicate expression for the method.  2.1.2 Noninvasive Visitors A well-known limitation \nof traditional OO languages is the in\u00adability to easily add new operations to existing class hierarchies. \nMultimethod dispatch provides a partial solution to this problem [37]. For example, .gure 5 illustrates \nhow multimethod dispatch is used to add a new typechecking pass to a hypothetical compiler. The compiler \ncontains a class hierarchy to represent abstract syn\u00adtax tree (AST) nodes, with base class Node. The \nmethods in the TypeCheck class dynamically dispatch on different subclasses of Node, in order to provide \nfunctionality for typechecking the vari\u00adous constructs in the language being compiled. Adding new operations \nto existing classes via multimethod dis\u00adpatch has several advantages over use of the visitor design pat\u00adtern \n[25], which is the standard solution in traditional OO lan\u00adguages. First, the visitor pattern requires \nthe original implementer of the Node class and subclasses to plan ahead for visitors by in\u00adcluding appropriate \naccept methods. This is necessary so that nodes can be dynamically dispatched upon via a double dispatch \n[32] protocol. In contrast, a JPred visitor is completely noninva\u00adsive, requiring no special-purpose \nhooks in the original nodes. Second, the visitor pattern requires all external operations to have the \nsame argument and result types. This often requires argument and result passing to be unnaturally simulated \nvia .elds. In con\u00adtrast, each JPred visitor operation can naturally have its own ar\u00adgument and result \ntypes, as shown in .gure 5. Finally, the visitor pattern requires each visitor class to have one method \nper Nodesub\u00adclass, making it dif.cult for a node to inherit the behavior of its su\u00adperclass. In contrast, \na JPred visitor naturally supports inheritance among the nodes. abstract class TreeNode { abstract TreeNode \nleft(); abstract TreeNode right(); ... } class DataNode extends TreeNode { int data; TreeNode left; \n TreeNode right; ... }class EmptyNode extends TreeNode { ... } Figure 6: A class hierarchy for binary \nsearch trees. class TreeIsomorphism { boolean isomorphic(TreeNode@EmptyNode t1, TreeNode@EmptyNode t2) \n { return true; } boolean isomorphic(TreeNode t1, TreeNode t2) when t1@EmptyNode || t2@EmptyNode { \nreturn false; } boolean isomorphic(TreeNode t1, TreeNode t2) { return isomorphic(t1.left(), t2.left()) \n&#38;&#38; isomorphic(t1.right(), t2.right()); }} Figure 7: Disjunction in JPred predicate expressions. \n 2.1.3 Generalized Multimethods While a traditional multimethod is expressed in JPred as a pred\u00adicate \nconsisting of a conjunction of specializer expressions on for\u00admals, JPred also allows arbitrary disjunctions \nand negations. An example of disjunction is shown in .gure 7. The code operates over the class hierarchy \nin .gure 6: TreeNode is the base class for binary search tree nodes, DataNode represents a node in the \ntree, and EmptyNode is used as a sentinel when a node lacks a left or right child (or both). The TreeIsomorphism \nclass in .gure 7 de\u00adtermines whether two binary trees (represented by their root nodes) are isomorphic. \nThe .rst two methods in the .gure handle scenar\u00adios when at least one of the two given tree nodes is \nempty. By the semantics of predicate implication, the .rst isomorphic method overrides the second one \nas desired. The presence of disjunction and negation in predicates raises the issue of when to allow \nspecialized types from a method s predi\u00adcate to be used when typechecking the method s body. For ex\u00adample, \nit would be unsafe to allow t1 to be considered to have static type EmptyNode when typechecking the body \nof the second isomorphic method, because that method can be invoked in a sce\u00adnario where t1 is not an \ninstance of EmptyNode. In JPred we take a simple approach to handling this issue: specialized types may \nnever escape from underneath disjunction and negation. There\u00adfore, the specialized types for t1 and t2 \nare not used when type\u00adchecking the body of the second isomorphicmethod, while t1and t2 may safely be \nconsidered to have static type EmptyNode when typechecking the body of the .rst method. It is possible \nto relax JPred s requirement, for example by allowing a specialized type for a formal that appears in \nboth sides of a disjunction to be used when typechecking the method body [20]. However, the current rule \nhandles the common case and is simple to understand. class TypeCheck { ... Type typeCheck(TypeEnv te, \nNode@BinaryExpr n) when n.operator@Plus || n.operator@Minus { ... // check that the arguments are integers \n} Type typeCheck(TypeEnv te, Node@BinaryExpr n) when n.operator@Concat { ... // check that the arguments \nare strings } } Figure 8: Field dispatch in JPred. class DataNode extends TreeNode { ... int getMin() \nwhen this.left@EmptyNode { return this.data; }int getMin() { return this.left.getMin(); }} Figure 9: \nAnother example of .eld dispatch.  2.2 Field Dispatch JPred supports dispatch on the substructure of \na method s argu\u00adments, as found in functional-style pattern matching. This idiom is expressed through \npredicates on .elds. Any .eld in scope within a method may be dispatched upon in the method s predicate, \nin\u00adcluding .elds of the receiver argument, visible .elds of the other arguments, visible static .elds \nof other classes, and .elds of .elds (recursively). For example, consider the typechecking visitor in \n.gure 5, and suppose a BinaryExpr subclass of Node represents invocations of a binary operator. It is \nnecessary to know which binary operator is invoked in order to decide how to typecheck the invocation, \nand .eld dispatch provides a natural and declarative solution, as shown in .gure 8. The example also \nillustrates another use of disjunction in predicates. As another example, .gure 9 uses .eld dispatch \nto .nd the mini\u00admum element of a binary search tree, in the context of the hierarchy in .gure 6. The \ncode mirrors the way such functionality would be naturally written in a language with pattern matching, \nlike ML. As usual, this.left can equivalently be written as left in the pred\u00adicate expression. Unlike \nspecialized types for formals, specialized types for .elds are never used when typechecking the associated \nmethod body. For example, this.leftis still considered to have static type TreeNode when typechecking \nthe body of the .rst getMin method in .gure 9, even though the method can only be invoked when this.left \nis an instance of EmptyNode. The unsound method in .gure 10 illus\u00adtrates why this rule is necessary. \nSince the static type of n.left is TreeNode, the .rst statement in the body of unsound typechecks. If \nthe static type of this.left is narrowed to its specialized type DataNode, then the return statement \nalso typechecks. However, the return statement will dynamically attempt to access the data .eld of an \nEmptyNode instance on an invocation dn.unsound(dn), where dn has static type DataNode. In the above example, \nan invocation dn.unsound(dn) causes this.left and n.left to be aliases: they have the same l-value. The \nunsoundness occurs because the two .eld expressions are mu\u00adtable but are considered to have different \ntypes. By forcing a .eld expression to retain its original static type, JPred ensures type sound\u00adness \nregardless of how the .eld is modi.ed through aliases. In class DataNode extends TreeNode { ... int unsound(DataNode \nn) when this.left@DataNode {n.left = new EmptyNode(); return this.left.data; }} Figure 10: Narrowing \nthe static type of a .eld is unsound. JPred, the code in .gure 10 is rejected because this.left.data \nfails to typecheck this.left has static type TreeNode and hence does not have a data .eld. Formal parameters, \nunlike .eld expressions, are guaranteed to be unaliased: each formal parameter is given a fresh memory \nloca\u00adtion. It is for this reason that the types of formal parameters may be safely narrowed to their \nspecialized types when typechecking a method body, even in the presence of mutation. This observation \nprovides a mechanism for safely narrowing the types of .elds that have specialized types as well. JPred \nallows a specializer expres\u00adsion to bind a new identi.er to the specialized target s value, and this \nidenti.er may be referenced in the associated method body. We refer to the new identi.er as a specialized \nname. Specialized names are fresh local variables and hence are guaranteed to be unaliased. Therefore, \nit is sound to narrow the type of a specialized name to the specialized type of its target. For example, \nthe following variant of the method in .gure 10 is allowed by the JPred typechecker and is perfectly \nsound: class DataNode extends TreeNode { ... int sound(DataNode n) when l as this.left@DataNode { n.left \n= new EmptyNode(); return l.data; }} In the example, the method body is able to access the data .eld \nof this.left s specialized name l, because l is considered to have static type DataNode. While an invocation \ndn.unsound(dn) still causes this.left and n.left to be aliases, l is not aliased to either of these .eld \nexpressions. Therefore, assigning to n.left does not modify the value pointed to by l. The use of specialized \nnames to soundly narrow the type of a target in JPred is reminis\u00adcent of the focus construct in Vault \n[21] and the restrict con\u00adstruct in CQUAL [23], which allow a potentially aliased location to be temporarily \ntreated as unaliased. As with specialized types, we do not allow new identi.ers bound in predicates to \nescape from underneath disjunction and negation. JPred also allows a target to be bound to a new identi.er \nusing the Identi.er as tgt syntax, without providing a specializer for the target. In that case, the \nnew identi.er acts simply as a convenient shorthand for use in the method s body. For the purposes of \ndeter\u00admining predicate implication, such a predicate is considered to be the predicate true, since it \nalways succeeds (modulo null derefer\u00adences, which JPred, like Java, does not statically prevent). 2.3 \nEquality Functional languages like ML allow formals and (the analogue of) .elds to be tested against \nconstants via pattern matching. JPred can express this idiom via equality testing against literals and \nother class FileProtocol { static final int WANT OPEN = 0; static final int WANT CLOSE = 1; int state \n= WANT OPEN; void check(Event@Open o) when state==WANT OPEN { state = WANT CLOSE; } void check(Event@Open \no) { throw new FileException(\"Error opening file!\"); } void check(Event@Close c) when state==WANT CLOSE \n{ state = WANT OPEN; }void check(Event@Close c) {throw new FileException(\"Error closing file!\"); } void \ncheck(Event e) { // no state change for other events }} Figure 11: A .nite-state machine in JPred. class \nExtendedFileProtocol extends FileProtocol { static final int WANT SAVE = 2; void check(Event@Modify \nm) when state==WANT CLOSE { state = WANT SAVE; }void check(Event@Save s) when state==WANT SAVE { state \n= WANT CLOSE; }} Figure 12: Extending a .nite-state machine in JPred. compile-time constant expressions. \nFor example, FileProtocol in .gure 11 implements a .nite-state machine (FSM) that checks that users of \nthe .le editor in .gure 2 never attempt two opens or two closes in a row. Typical for the implementation \nof FSMs in Java, the states are represented by compile-time constant .elds, WANT OPEN and WANT CLOSE. \nJPred allows each transition of the FSM to be encapsulated in its own method, and the equality predi\u00adcate \nis used to declaratively test the current state. Unlike a corresponding implementation with functional-style \npat\u00adtern matching, the FSM in .gure 11 is easily extensible. For exam\u00adple, .gure 12 extends the FSM to \nadditionally check that a modi.ed .le is saved before it is closed. One new state and two new transi\u00adtions \nare added to the FSM. As in Java, the == operator may also be used to compare ob\u00adjects for reference \nequality. (JPred disallows method invocations in predicate expressions, so equality testing via Object \ns equals method is not supported.) For example, we can provide special\u00adpurpose behavior for null values. \nConsider the handle function\u00adality in .gure 3. As currently written, if handle is passed a null event, \nthe only applicable method will be the last one in the .g\u00adure. (Recall that the @ predicate has the same \nsemantics as Java s instanceof expression. Therefore, null@C is false for every class C.) For safety, \nthat method s body should test whether e is null be\u00adfore attempting to access one of its .elds or methods. \nAs a declara\u00adtive alternative in JPred, we can provide a separate method to han\u00addle the erroneous situation \nwhen e is null, which overrides the last handle method: void handle(Event e) when e==null { ... } JPred \ns equality predicate is more general than its analogue in functional-style pattern matching, since JPred \nallows targets to be class DataNode extends TreeNode { ... boolean equals(Object o) when o==this { return \ntrue; } boolean equals(Object o) when o@DataNode &#38;&#38; data==o.data { return left.equals(o.left) \n&#38;&#38; right.equals(o.right); }} Figure 13: Another example of equality predicates in JPred. class \nDataNode extends TreeNode { ... boolean contains(int elem) when elem == data { return true; }boolean \ncontains(int elem) when elem < data { return left.contains(elem); }boolean contains(int elem) when elem \n> data {{ return right.contains(elem); }} Figure 14: Linear inequalities in JPred. compared against one \nanother. An example is shown in .gure 13, where the equals method inherited from Object is overridden. \nThe .rst method s predicate shows that JPred subsumes alias dis\u00adpatch [34, 4], in which procedure implementations \ncan be special\u00adized to particular alias scenarios of their arguments. The second method s predicate tests \nequality of the .elds of arguments to de\u00adtermine applicability. It also illustrates that specialized \ntypes and identi.ers that escape to the method body may also be used later in the predicate expression: \nthe data .eld of o may only be accessed because the type of o has been narrowed to DataNode. As shown \nin the example, JPred methods may override any existing methods, including those in the Java standard \nlibrary.1 If neither method in the .gure is applicable to some invocation, then the default equals method \nin Object will automatically be selected for execution (as\u00adsuming TreeNode does not contain an overriding \nequals method).  2.4 Linear Arithmetic JPred supports arithmetic inequalities in predicate expressions, \nvia the various relational and arithmetic operators shown in .g\u00adure 1. All arithmetic expressions in \na predicate are required to be linear. The JPred typechecker enforces this requirement by check\u00ading that, \nfor every predicate expression of the form pred1 *pred2,at least one of the two operands is a compile-time \nconstant expression as de.ned by Java [28]. Forcing arithmetic to be linear ensures that testing relationships \namong predicates, such as logical implication, remains decidable. Figure 14 illustrates a simple example \nof linear inequalities in JPred. The contains operation checks whether a given data ele\u00adment is in a \nbinary search tree. The .gure shows the implementa\u00adtion of containsfor DataNode; the implementation for \nEmptyNode is the base case and simply returns false. By predicate implication, none of the methods in \nthe .gure overrides any of the others. As another example, consider an nth method on tree nodes, 1Technically, \nthe methods in .gure 13 should be declared public, in order to properly override Object s equalsmethod, \nbut we have elided such modi.ers for readability. abstract class TreeNode { ... abstract int nth(int \nn); int nth(int n) when n < 0 { throw new TreeException( \"nth invoked with a negative number!\"); }} \nFigure 15: Partially abstract methods in JPred. which takes an integer argument n and returns the nth \nsmallest element (counting from zero) in the tree. It may be desirable to make the nth method in the \nTreeNode class abstract, thereby forc\u00ading each subclass to provide an appropriate implementation. At \nthe same time, it is likely that all subclasses will act identically when nthis passed a negative integer \nas an argument. Therefore, it would be nice to write the code to handle this erroneous scenario once, \nal\u00adlowing all subclasses to inherit that functionality. In essence, we would like to make TreeNode s \nnth method partially abstract. Figure 15 shows how inheritance of predicate methods in JPred naturally \nallows operations to be declared partially abstract. The .rst nth method in TreeNode is declared abstract, \nbut it is partially overridden by the second method, which handles the error case. Subclasses of TreeNode \ninherit the second method, but they are still obligated to provide implementations of nth that handle \nsit\u00aduations when the integer argument is nonnegative; the static type system described in section 3 enforces \nthis obligation. Many other operations besides nth naturally have error scenar\u00adios and hence would also \nbene.t from being partially abstract. Par\u00adtially abstract operations are particularly useful for large \nclass hi\u00aderarchies. For example, TreeNode could represent a base class for many different kinds of binary \ntrees (binary search trees, heaps, etc.). Although each binary tree will have a different implementa\u00adtion \nof nth, they can all share code to handle the error case, which is nicely modularized. In contrast, Java \nand its type system force the programmer either to make TreeNode s nth method (fully) ab\u00adstract or to \nimplement it for all possible integer values. 2.5 Method Invocation Semantics We end this section by \ndescribing more precisely the semantics of method invocation in JPred. To simplify the discussion, we \nas\u00adsume that all methods have a when clause and that MultiJava-style specializers have been desugared. \nA method without a when clause is equivalent to one with the clause when true. Consider a message send \nof the form e1.m(e2,...,en) appearing in some JPred program. At compile time, static overload resolution \nis performed exactly as in Java, based on the name m and the static types of e1,...,en. This has the \neffect of determining which generic function [8, 41] a collection of methods of the same name, num\u00adber \nof arguments, and static argument and result types will be invoked dynamically. At runtime, each expression \nei is evaluated to produce a value vi and the unique most-speci.c applicable method belonging to the \nstatically determined generic function is invoked. A method is ap\u00adplicable if its associated predicate \nexpression evaluates to true in the context of the given actual arguments v1,...,vn. A method is the \nunique most-speci.c applicable method if it is the unique appli\u00adcable method that overrides all other \napplicable methods. Finally, one method m1 overrides another method m2 if either of the follow\u00ading holds: \nclass C { private Object f; void m() when f@String { ... } ... }class D extends C { Object g; void \nm() when g@String { ... } ... } Figure 16: A problem with the symmetric approach to method lookup. Method \nm1 s receiver class is a strict subclass of m2 s re\u00adceiver class.  Methods m1 and m2 are declared in \nthe same class, and m1 s predicate expression logically implies m2 s predicate expres\u00adsion. We use off-the-shelf \ndecision procedures, which are discussed in section 4, to test predicate implication.  For example, \nconsider the invocation treeIso.isomorphism(en, dn) in the context of the class in .gure 7, where treeIso, \nen, and dn have runtime types TreeIsomorphism, EmptyNode, and DataNode, respectively. The second and \nthird methods in the .gure are applicable, and the second method is the unique most-speci.c applicable \none. If there are no applicable methods for a message send, a message\u00adnot-understood error occurs. If \nthere is at least one applicable method but no unique most-speci.c applicable method, a message\u00adambiguous \nerror occurs. The modular static type system in sec\u00adtion 3 ensures that these kinds of errors cannot \noccur. JPred s method-lookup semantics can be viewed as a generaliza\u00adtion of the encapsulated style of \nmultimethod dispatch [10]. In this style, dispatch consists of two phases. In the .rst phase, ordinary \nOO-style dispatch .nds the receiver argument s class. In the second phase, the unique most-speci.c applicable \nmethod in the receiver class is selected, recursively considering methods in the superclass if no methods \nin the receiver are applicable. Other multimethod semantics could instead be generalized in JPred without \naffecting our results. For example, we could gener\u00adalize the symmetric multimethod semantics, in which \nthe receiver argument is not treated specially. This semantics is used in multi\u00admethod languages such \nas Cecil and MultiJava. In the symmetric approach to JPred dispatch, a method m1 would be considered \nto override another method m2 only if m1 s receiver class is a (re\u00ad.exive, transitive) subclass of m2 \nand m1 s predicate expression logically implies m2 s predicate expression. We chose the encapsulated \nstyle in JPred for several reasons. First, the encapsulated style is arguably quite natural in a language \nlike Java, which is already heavily receiver-centric. Further, the en\u00adcapsulated style reduces the dependence \nof classes on their super\u00adclasses: a class s methods cannot be ambiguous with any methods in superclasses. \nFinally, receiver-based encapsulation can some\u00adtimes make the symmetric semantics impossible to satisfy, \nas shown in .gure 16. Under JPred s invocation semantics, D s m method overrides C s m method. In contrast, \nunder the symmetric seman\u00adtics, neither of the two methods in the .gure is considered to over\u00adride the \nother: a message-ambiguous error will occur if m is ever invoked on a D instance whose f and g .elds \nare both instances of String. Therefore, under the symmetric semantics a static typechecker must reject \nthe program in .gure 16. If f were accessible from D, then the implementer of D could resolve the ambiguity \nand allow the program to typecheck by adding a new method as follows: void m() when f@String &#38;&#38; \ng@String { ... } Since fis private to C, however, there is no way for the implementer of D to resolve \nthe ambiguity. Indeed, under the symmetric seman\u00adtics, every m method in class D (except methods whose \npredicates are logically false) is ambiguous with C s m method.  3. STATIC TYPECHECKING This section \ndescribes our extensions to Java s static type sys\u00adtem to support predicate methods. A key feature is \nthe retention of Java s modular typechecking approach, whereby each compi\u00adlation unit can be typechecked \nseparately, given type information about the other compilation units on which it depends. Others have \nformalized Java s notion of modular typechecking and compila\u00adtion [19, 2]. 3.1 Typechecking Message Sends \nMessage sends are typechecked in JPred exactly as in Java; no modi.cations are required. As mentioned \nin section 2.5, Java s static overload resolution is performed to determine which generic function a \nmessage send invokes, based on the message name, num\u00adber of arguments, and static types of the argument \nexpressions. As usual, the result type of the generic function is then used as the type of the entire \nmessage send expression. 3.2 Typechecking Method Declarations Typechecking for method declarations is \naugmented to reason about when clauses. First we describe the local checks performed on each predicate \nmethod in isolation. Then we describe the checks ensuring that a generic function s methods are exhaustive, \nso that message-not-understood errors cannot happen at runtime. Finally, we describe the checks ensuring \nthat a generic function s methods are unambiguous, so that message-ambiguous errors cannot happen at \nruntime. 3.2.1 Local Checks Local checks on a predicate method are largely straightforward. The main \nrequirement is that the method s associated predicate ex\u00adpression typechecks successfully and has the \ntype boolean. The predicate expressions (see .gure 1) that are also legal Java expres\u00adsions literals, \ntargets, unary predicate expressions, and binary predicate expressions are typechecked exactly as they \nare in Java. Arithmetic predicate expressions are additionally checked to be linear, as described in \nsection 2.4. Specializer expressions of the form tgt@ClassType are typechecked like Java s instanceof \nexpressions, with the additional constraint that the specialized type be a class that is a strict subtype \nof the target s static type. Special\u00adized types may not be interfaces because of challenges for modular \nexhaustiveness and ambiguity checking of multimethod dispatch in the presence of multiple inheritance \n[39]. Specializer expressions of the form Identi.er as tgt@ClassType are typechecked like regular specializer \nexpressions, and the spe\u00adcialized name Identi.er is additionally given the static type ClassType. An \nidenti.er binding of the form Identi.er astgt is typechecked by typechecking the target as in Java and \nadditionally giving Identi.er the static type determined for the target. It is an error if an iden\u00adti.er \nis bound more than once in a predicate. Specialized types for formals and type bindings for identi.ers \nthat can escape to the method body are used when typechecking the method body. They also propagate from \nleft to right during the typechecking of the predicate itself. A predicate method may not be declared \nabstract. However, concrete predicate methods are allowed in abstract classes, and they can be used to \nimplement partially abstract methods, as shown in .gure 15. Consistent with Java, a predicate method \nmay have weaker access restrictions than overridden methods in superclasses, and it may declare a subset \nof the exceptions declared by over\u00adridden methods in superclasses. However, we require a predicate method \nto have the same modi.ers and declared exceptions as all other methods belonging to the same generic \nfunction that are in the same class. It is possible to relax this rule, analogous with Java s requirements. \nFor example, it would be sound to allow the .rst check method in .gure 11 to be declared public, since \nthe two methods it overrides are both implicitly package-visible. We have decided not to allow this relaxation, \nsince it requires the ability to statically evaluate predicate expressions in order to be useful. For \nexample, if the .rst check method were declared public, an invocation of check from outside of FileProtocol \ns package could only be allowed to typecheck if the JPred type\u00adchecker could statically prove that the \nargument event is an in\u00adstance of Open or a subclass and the receiver s state .eld is equal to WANT OPEN. \nRather than forcing the type system to incorporate a conservative analysis for statically evaluating \npredicate expres\u00adsions, our current rule gives up a bit of .exibility, keeping the type system simple \nyet still backward-compatible with Java s type sys\u00adtem. 3.2.2 Exhaustiveness Checking Exhaustiveness \nchecking ensures that message-not-understood errors will not occur in well-typed programs: each type-correct \ntu\u00adple of arguments to a message has at least one applicable method. Such checking is already a part \nof Java s modular typechecks. For example, a static error is signaled in Java if a concrete class does \nnot implement an inherited abstract method, because that situation could lead to a dynamic NoSuchMethodException, \nthe equivalent of our message-not-understood error. JPred naturally augments Java s class-by-class exhaustiveness \nchecking. As in Java, for each concrete class C we check that C implements any inherited abstract methods. \nFor example, as\u00adsuming that TreeNode s contains method is declared abstract, DataNode in .gure 14 will \nbe checked to implement contains for all possible scenarios. In JPred we must also check that C im\u00adplements \nany inherited partially abstract methods. For example, DataNode will be checked to implement the partially \nabstract nth method in .gure 15 for all nonnegative integer arguments. Finally, in JPred we must check \nthat C fully implements any new generic functions declared in C (i.e., methods in C that have no overridden \nmethods in superclasses). For example, FileEditor in .gure 3 will be checked to implement the new handle \ngeneric function for all possible pairs of argument events. All of these checks are performed in a uniform \nway. To check exhaustiveness of a generic function from a class C, we collect all of the concrete methods \nof that generic function declared in C and inherited from superclasses of C. If at least one of these \nmethods is a regular Java method (i.e., it has no when clause), then exhaus\u00adtiveness is assured and the \ncheck succeeds. Otherwise, all of the methods are predicate methods, and the check succeeds if the dis\u00adjunction \nof all of the methods predicates is logically valid. For example, consider exhaustiveness checking of \nhandlein .g\u00adure 3. Since the last method has no when clause, the check suc\u00adceeds. As another example, \nconsider exhaustiveness checking of contains for DataNode in .gure 14. None of the declared meth\u00adods \nis a regular Java method, but the disjunction of the methods predicates is logically valid (since one \ninteger is always either equal to, less than, or greater than another integer), so the check succeeds. \nOur exhaustiveness checking algorithm is conservative in the face of partial program knowledge, which \nis critical for modular typechecking. For example, consider again exhaustiveness check\u00ading for handle \nin .gure 3, and suppose that the last method were missing. In that case, our typechecker would signal \na static ex\u00adhaustiveness error, since the disjunction of the remaining methods predicates is not valid. \nIndeed, it is possible that there exist con\u00adcrete subclasses of Event other than Open, Save, and SaveAs, \nand these events may not be visible from FileEditor.2 Java and MultiJava share JPred s conservatism, \nand in fact those languages are strictly more conservative than JPred. Both Java and MultiJava always \nrequire the existence of a default method, which handles all possible arguments of the appropriate type, \nto ensure exhaustiveness. In contrast, JPred can sometimes safely ensure ex\u00adhaustiveness without forcing \nthe existence of a default method, as shown in the contains example above. Ernst et al. s exhaustive\u00adness \nchecking algorithm for predicate dispatch [20] safely requires fewer default methods than JPred, but \nthe algorithm can only be performed when the whole program is available. In the handle example, Open \nand Save must be known to be the only direct con\u00adcrete subclasses of Event in the entire program in order \nto ensure exhaustiveness without requiring the last handle method. 3.2.3 Ambiguity Checking Ambiguity \nchecking ensures that message-ambiguous errors will not occur in well-typed programs: if a type-correct \ntuple of argu\u00adments to a message has at least one applicable method, then it has a unique most-speci.c \napplicable method. Again, such checking is already a part of Java s modular typechecks. In particular, \nJava signals a static error if a class contains two methods of the same name, number of arguments, and \nstatic argument types. Languages that support multiple inheritance, like C++ [52], perform additional \nambiguity checks modularly. JPred performs ambiguity checking for each class C by compar\u00ading each pair \nof methods declared in C that belong to the same generic function. The algorithm for checking each method \npair generalizes our earlier algorithm for modular ambiguity checking in Extensible ML (EML) [38] to \nhandle JPred s predicate expres\u00adsions, which subsume EML s pattern-matching facility. Consider a pair \nof methods m1 and m2. If each method overrides the other, then the methods have the same logical predicate \nand hence are ambiguous. This check subsumes Java s check for duplicate meth\u00adods. If one method overrides \nthe other, but not vice versa, then one method is strictly more speci.c than the other, so the methods \nare not ambiguous. Finally, suppose neither method overrides the other. Then m1 and m2 are predicate \nmethods, with predicates pred1 and pred2, respectively. There are two cases to consider. If the methods \nare disjoint, meaning that they cannot be simultaneously applicable, then they are not ambiguous. The \nmethods are disjoint if pred1 and pred2 are mutually exclusive: \u00ac(pred1. pred2) is valid. If the methods \nare not disjoint, then the methods are ambiguous unless the set m of methods that override both m1 and \nm2 isa resolving set, meaning that at least one member of m is applicable whenever both m1 and m2 are \napplicable. The set m, with associated predicates . pred, is a resolving set if ((pred1 . pred2) . pred) \nis valid. Consider ambiguity checking for checkin FileProtocolof .g\u00ad 2These events may not even have \nbeen written when FileEditor is typechecked and compiled. ure 11. There are ten pairs of methods to consider. \nThe .rst four methods each override the last method, but not vice versa, so these pairs are unambiguous. \nThe pair consisting of the .rst and second methods passes the check similarly, as does the pair consisting \nof the third and fourth methods. Finally, each of the .rst two methods is disjoint from each of the third \nand fourth methods. Therefore, ambiguity checking for check in FileProtocol succeeds. To illustrate resolving \nsets, consider an OpenAssubclass of Open, which copies a .le to a new name and opens it, and suppose \nFile-Protocol contained a method of the following form: void check(Event@OpenAs o) { ... } In that case, \nthe JPred typechecker would signal a static error in\u00addicating that the above method is ambiguous with \nthe .rst check method in .gure 11: the methods are not disjoint and there are no methods that override \nboth of them, so the test for a resolv\u00ading set fails trivially. Indeed, the two methods will cause a \ndy\u00adnamic message-ambiguous error if check is ever passed an OpenAs event when the receiver is in the \nWANT OPEN state. However, the ambiguity would be resolved, and typechecking would succeed, if FileProtocol \nadditionally contained a method of the following form: void check(Event@OpenAs o) when state==WANT OPEN \n { ... } JPred s ambiguity checking algorithm is naturally modular: only pairs of methods declared in \nthe same class are considered. The semantics of method invocation described in section 2.5 ensures that \ntwo methods declared in different classes cannot be ambiguous with one another. If one method s class \nis a strict subclass of the other method s class, then the .rst method overrides the second. Otherwise, \nneither method s class is a subclass of the other, so the methods are guaranteed to be disjoint. JPred \ns modular ambiguity checking algorithm is very similar to the original ambiguity algorithm for predicate \ndispatch [20]. How\u00adever, that algorithm is performed on all pairs of methods belonging to the same generic \nfunction in the entire program. Further, that al\u00adgorithm does not check for a set of resolving methods, \ninstead con\u00adservatively rejecting the program whenever two methods are not in an overriding relation \nand are not disjoint.  4. AUTOMATICALLY REASONING ABOUT PREDICATES As described in sections 2 and 3, \nboth the dynamic and static semantics of JPred rely on the ability to test relationships among predicate \nexpressions. All of these tests reduce to the ability to check validity of propositional combinations \nof formulas express\u00adible in JPred s predicate language. Prior languages containing pred\u00adicate dispatch \nhave used their own specialized algorithms for con\u00adservatively checking validity of predicates [20, 54, \n47]. In contrast, JPred employs general-purpose off-the-shelf decision procedures, which are more .exible \nand precise than these specialized algo\u00adrithms. In particular, we rely on an automatic theorem prover \nthat con\u00adsists of a combination of decision procedures for various logical theories. Using an automatic \ntheorem prover as a black box allows us to easily incorporate advances in decision procedures as they \narise. For example, the search for more ef.cient decision proce\u00addures for propositional satis.ability \nis an active area of research. Using an automatic theorem prover also makes it easier to aug\u00adment our \nlanguage with new kinds of predicates. Rather than be\u00ading forced to extend a specialized validity algorithm \nto handle the new predicates, we have the simpler task of deciding how to appro\u00adpriately represent the \nnew predicates in the logic accepted by the prover. In this section we describe the interface between \nJPred and an automatic theorem prover. First we describe CVC Lite [17], which is the automatic theorem \nprover that our implementation uses. Then we describe how JPred s predicate expressions are represented \nin CVC Lite s input language. Finally we describe the axioms we provide to CVC Lite so it can reason \nprecisely about objects and classes. 4.1 CVC Lite CVC Lite is an automatic theorem prover in the Nelson-Oppen \nstyle [43]. The theorem prover integrates separate decision proce\u00addures for several decidable theories, \nincluding: propositional logic  rational linear arithmetic  the theory of equality with uninterpreted \nfunction symbols  the theory of arrays  CVC Lite also allows users to plug in decision procedures for \nother theories, but we have not exploited this feature. CVC Lite s input language allows expression of \nquanti.er-free .rst-order formulas over the above interpreted theories. The logic of CVC Lite s input \nlanguage is decidable, so CVC Lite is sound, complete, and fully automatic.3 In a typical usage, various \nformu\u00adlas are provided as axioms, which CVC Lite assumes to be true. These user-de.ned axioms, along \nwith the axioms and inference rules of the underlying theories, are then used to automatically de\u00adcide \nwhether a query formula is valid. For our purposes, there is nothing special about CVC Lite. There are \nseveral automatic theorem provers of comparable expressive\u00adness to CVC Lite, including Simplify [18], \nVampyre [7], CVC [53], and Verifun [22]. Moving to one of these provers would merely re\u00adquire us to translate \nthe queries and axioms we provide to CVC Lite (see the next two subsections) into the input language \nof the new prover. 4.2 Representing Predicate Expressions Before translating a predicate expression \ninto the syntax of CVC Lite s input language, we convert it to internal form. This con\u00adversion process \ncanonicalizes the predicate expression so it can be properly compared to a predicate expression of another \nmethod. First, we replace the ith formal name with the name argi every\u00adwhere.4 Second, we replace any \ncompile-time constant expressions with their constant values. Third, we convert targets to their full \nnames, for example adding a pre.x of this if it was left implicit. Fourth, we substitute any use of a \nbound identi.er in the predi\u00adcate expression with the identi.er s associated target expression, which \nis itself recursively internalized. Finally, we remove identi\u00ad.er bindings. Ordinary identi.er binding \nexpressions are replaced by true, and specialized identi.er bindings simply have the bind\u00ading removed, \nleaving the specializer expression. 3An extension to CVC Lite allows formulas to contain explicit uni\u00adversal \nand existential quanti.cation. The resulting logic is unde\u00adcidable, so CVC Lite uses various heuristics \nto prove such formu\u00adlas valid, remaining sound but losing completeness. JPred does not make use of this \nextension to CVC Lite. 4The actual internal-form argument names are slightly more com\u00adplicated, to prevent \naccidental clashes with other variable names in the program. We elide the issue of name mangling throughout \nthis section. It is straightforward to translate predicate expressions in inter\u00adnal form into the syntax \nof CVC Lite s input language. All of our allowed unary and binary operators (see .gure 1) are translated \nto their counterparts in CVC Lite, as are all of the literals except null. The literal null and all targets \nappearing in a given pred\u00adicate expression are translated to themselves; they are treated as variable \nnames by CVC Lite. For example, the target this.data is treated as an atomic variable name, with no relation \nto the target this. Finally, a specializer expression tgt@ClassType is translated as instanceof(tgt, \nClassType), where instanceof is an uninter\u00adpreted function symbol that we declare. For example, consider \nthe contains methods in DataNode of .gure 14. During static ambiguity checking, the .rst and second methods \nare tested for disjointness by posing the following query to CVC Lite: NOT(arg1 = this.data AND arg1 \n< this.data) Here = is CVC Lite s analogue of Java s == operator. CVC Lite easily proves this formula \nto be valid, because of the relationship between =and <, so the methods are proven to be disjoint and \nhence unambiguous. 4.3 Axioms Consider testing disjointness of the .rst and fourth check meth\u00adods in \n.gure 11. After converting their predicates to internal form, we pose the following query to CVC Lite: \nNOT((instanceof(arg1, Open) AND this.state = 0) AND instanceof(arg1, Close)) Since instanceof is an \nuninterpreted function symbol, CVC Lite does not know anything about its semantics. Therefore, CVC Lite \ncannot prove that the above formula is valid, even though the two methods are in fact disjoint. To address \nthis issue, we provide CVC Lite with axioms about the semantics of instanceof. These axioms effectively \nmirror the relevant portion of the associated JPred program s class hierarchy in CVC Lite. We call a \ntarget a reference target if it has reference type. Let F be a query formula provided to CVC Lite. We \ndeclare one axiom per pair ({C1,C2}, tgt), where C1 and C2 are distinct class names mentioned in F and \ntgt is a reference target mentioned in F. In particular: If C1 is a subclass of C2, we declare the axiom \ninstanceof( tgt, C1) => instanceof(tgt, C2), where => is the logi\u00adcal implication operator in CVC Lite. \n If C2 is a subclass of C1, we declare the axiom instanceof( tgt, C2) => instanceof(tgt, C1).  If C1 \nis not a subclass of C2 and C2 is not a subclass of C1, we declare the axiom NOT(instanceof(tgt, C1) \nAND instanceof(tgt, C2)).  For the check example query above, we automatically produce the following \naxiom: NOT(instanceof(arg1, Open) AND instanceof(arg1, Close)) In the presence of this axiom, CVC Lite \ncan now prove that the above query is valid, and hence the JPred typechecker will correctly conclude \nthat the .rst and fourth check methods in .gure 11 are disjoint. Our axioms for instanceof are similar \nto the implication rules used to rule out infeasible truth assignments in Ernst et al. s special-purpose \nalgorithm for validity checking [20]. To complete the semantics of instanceof, we have two other kinds \nof axioms. First, for each class name C in a query formula F, we declare the axiom NOT(instanceof(null, \nC)). This ax\u00adiom re.ects the fact that JPred s specializer expression evaluates to false whenever the \ntarget is null. The axiom allows JPred to prop\u00aderly conclude that the handle method near the end of section \n2.3, which tests whether the argument event is null, is disjoint from each of the .rst three handle methods \nin .gure 3. Second, for every ref\u00aderence target tgt in F, we declare the axiom instanceof(tgt, C) OR \ntgt = null, where C is the static type of tgt. For the special reference target this, which can never \nbe null, we leave off the second disjunct in this axiom. Finally, we provide CVC with axioms that relate \nreference tar\u00adgets and their .elds. For each set of targets {tgt1, tgt2, tgt1. f , tgt2. f } mentioned \nin a query formula F, we declare the axiom tgt1 = tgt2 => tgt1. f = tgt2. f This axiom allows JPred to \nproperly conclude that the .rst equals method in .gure 13 overrides the second one.  5. IMPLEMENTATION \nWe have implemented JPred in the Polyglot extensible compiler framework for Java [44], declaring new \nabstract syntax tree (AST) nodes to represent predicate expressions and predicate methods. In this section, \nwe describe our augmentations to Polyglot for type\u00adchecking and compiling a class containing predicate \nmethods. 5.1 Typechecking The local checks on predicate methods, described in section 3.2.1, are performed \non each predicate method as part of Polyglot s exist\u00ading typechecking pass. In a subsequent pass, we \npartition a class s methods by generic function: each generic function s methods, where at least one \nof the methods is a predicate method, are col\u00adlected in a dispatcher; the methods belonging to the same \ndis\u00adpatcher are called dispatcher mates [15]. Finally, we perform ex\u00adhaustiveness and ambiguity checking \non each dispatcher in a class, using the algorithms described in section 3. This checking involves sending \nqueries to CVC Lite using the translation and axioms de\u00adscribed in section 4. As part of ambiguity checking \nwe compute the method overriding partial order, which is also used during code generation. 5.2 Code \nGeneration We generate code for JPred in two steps. First we rewrite all of the JPred-speci.c AST nodes \ninto Java AST nodes. Then we use an existing pass in Polyglot to output a source-code representation \nof Java AST nodes. The resulting .java .les can be compiled with a standard Java compiler and executed \non a standard Java virtual machine. Our modular compilation strategy generalizes that of MultiJava [16, \n15] to handle JPred s predicate language. First, there are sev\u00aderal modi.cations to each method m associated \nwith a dispatcher. We modify m to be declared private and to have a unique name. If m has a predicate \npred, we add a new local variable at the be\u00adginning of m s body for each identi.er bound in pred that \nescapes to the body. The new local variable is initialized with the iden\u00adti.er s corresponding target, \nwhich is .rst cast to the associated specialized type, if any. Static typechecking has ensured that this \ncast cannot fail dynamically. If a formal parameter is specialized in pred and that specialized type \nescapes to the body, we replace the formal s original static type in m with the specialized type. Finally, \nm s associated when clause is removed. private boolean isomorphic1(EmptyNode t1, EmptyNode t2) { return \ntrue; }private boolean isomorphic2(TreeNode t1, TreeNode t2) { return false; }private boolean isomorphic3(TreeNode \nt1, TreeNode t2) {return isomorphic(t1.left(), t2.left()) &#38;&#38; isomorphic(t2.right(), t2.right()); \n} Figure 17: The translation of the isomorphic methods in .g\u00adure 7 to Java. boolean isomorphic(TreeNode \narg1, TreeNode arg2) { if (arg1 instanceof EmptyNode &#38;&#38; arg2 instanceof EmptyNode) { return \nisomorphic1((EmptyNode) arg1, (EmptyNode) arg2); } else if (arg1 instanceof EmptyNode || arg2 instanceof \nEmptyNode) { return isomorphic2(arg1, arg2); } else { return isomorphic3(arg1, arg2); }} Figure 18: \nA dispatcher method for the methods in .gure 17. For example, .gure 17 illustrates the Java translation \nof the iso\u00admorphicmethods from .gure 7. In the .rst method, the static argu\u00adment types have been narrowed \nto re.ect their specialized types. In the second method, which corresponds to the original method with \npredicate t1@EmptyNode || t2@EmptyNode, the argument types are unchanged, because neither specializer \nescapes to the body. To complete the translation from JPred to Java, we create a dis\u00adpatcher method for \neach dispatcher d. The method has the same name, modi.ers, and static argument and return types as the \norig\u00adinal methods associated with d. Therefore, compilation of clients of the generic function is unchanged. \nThe body of the dispatcher method uses an if statement to test the guards of each associated method one \nby one, from most-to least-speci.c, in some total or\u00adder consistent with the method overriding partial \norder. The .rst method whose guard evaluates to true is invoked. Static ambigu\u00adity checking ensures that \nthis method is in fact the unique most\u00adspeci.c applicable method. If all the methods in d are predicate \nmethods and there exist inherited methods belonging to the same generic function, the last branch of \nthe dispatcher method s if statement uses super to recursively invoke the superclass s dis\u00adpatcher method. \nStatic exhaustiveness checking ensures that an applicable method will eventually be found. Figure 18 \ncontains the dispatcher method for the methods in .g\u00adure 17. The dispatcher method is given a canonical \nset of formal names. Each method s predicate is tested by converting the predi\u00adcate to internal form, \ndescribed in section 4.2, and replacing each specializer expression with its equivalent instanceof expression. \nAlthough not necessary in this example, the internal form of a pred\u00adicate is also augmented with casts, \nwherever a target is substituted for its corresponding specialized name and wherever a formal with a \nspecialized type that can escape to the body is referenced. Simi\u00ad public interface EventHandler {void \nhandle(Event event); } Figure 19: The interface for event handlers in one.world. larly, a formal with \nan escaping specialized type must be cast to the specialized type before invoking a predicate s associated \nmethod, as shown in the .rst branch of the if statement. As above, static typechecking has ensured that \nnone of these casts can fail. Because the original methods are now private, calls to them from the dispatcher \nmethod are statically bound and therefore do not in\u00adcur the performance overhead of dynamic dispatch. \nA Java com\u00adpiler can inline these methods in the dispatcher method, to further reduce overhead.  6. \nCASE STUDY This section describes a case study that we undertook to evaluate JPred s effectiveness in \na realistic setting. First we describe the Java application that we rewrote in JPred. Then we illustrate \nthe basic technique we used to perform the translation from Java to JPred. Finally, we discuss results \nof the case study, including the detection of several errors. 6.1 Application The one.world system is \na framework for building pervasive ap\u00adplications in Java, designed and implemented by others [29]. Users \nbuild applications in one.world as collections of components that communicate through asynchronous events. \nEach component C imports a set of event handlers, to which C can pass events, and likewise exports a \nset of event handlers, to which others can pass events meant for C. The one.world system is implemented \nas a class library in Java. Users write one.world components by subclassing from the abstract Componentclass. \nEvent handlers in one.world use the same style as the event handlers in our FileEditor example in .gure \n2. In par\u00adticular, one.world event handlers meet the simple interface shown in .gure 19: an event handler \nprovides a handle method, which is passed the event that occurs. A component s exported event handlers \nare typically implemented as inner classes. The set of handlers that a component imports is initially \ndecided during static initialization, but it can also be modi.ed dynamically. Having all event handlers \nmeet the same interface facilitates such dynamic re\u00adbinding. The one.world system includes a set of basic \nservices that helps programmers build applications that meet the unique demands of pervasive computing. \nThese services are themselves written in the component-based style described above. One such service \nis a dis\u00adcovery service, which allows a component to query for event han\u00addlers that satisfy a particular \ndescription; the querying component can then import the resulting event handler(s) and begin commu\u00adnication. \nA canonical example is a component that queries for a printer in the current environment, which can subsequently \nbe sent .les to be printed. The discovery service in one.world supports sev\u00aderal varieties of querying \nand communication, which are described elsewhere [29]. 6.2 Overview In this case study, we rewrote the \nevent handlers in the imple\u00admentation of one.world s discovery service to use JPred. We started with \nthe discovery service implementation from one.world version 0.7.1, which is freely available for download \n[46]. The discovery service implementation consists of two components, Discovery-Client and DiscoveryServer, \ntotaling 2371 non-comment, non\u00adblank lines of code (LOC). Together the two components include 11 event \nhandlers as inner classes totaling 977 LOC, or 41% of the code. Figure 20 shows the Java implementation \nof an event handler of average complexity in DiscoveryClient.5 Handlers typically subclass from the abstract \nAbstractHandler class, which in turn implements the EventHandlerinterface. AbstractHandler s han\u00addle \nmethod invokes an abstract helper method handle1, which is implemented by each concrete subclass in order \nto provide the subclass s event-handling functionality. A handle1 method should return true if the associated \nsubclass was able to successfully han\u00addle the given event and false otherwise. The implementation of \nAbstractHandler is discussed further in section 6.3.4. Figure 21 illustrates how we implement MainHandler \nfrom .g\u00adure 20 in JPred. All of the advantages of JPred for event-based sys\u00adtems, as described in section \n2.1, apply to our one.world case study. Unlike the Java version, the JPred implementation is declarative \nand statically typesafe, removing a large source of potential run\u00adtime errors. The JPred implementation \nis also extensible, opening up the possibility of .ne-grained handler reuse in one.world.For example, \na subclass of DiscoveryClient could contain an inner handler that subclasses from MainHandler (if it \nwere not declared final), inherits some of MainHandler s handle1 methods, over\u00adrides others, and handles \nnew scenarios with additional handle1 methods. The JPred style of implementing event handlers is very \nnatu\u00adral. This is illustrated by the fact that the original implementers of the discovery service often \nmanually simulated JPred-style de\u00adcomposition, as shown in .gure 22. To manage the complexity of event \nhandling in ServerManager, the code has been divided into two layers. The handle1 method manually dispatches \non the event (and on the event .eld of a RemoteEvent) in order to in\u00advoke an appropriate private helper \nmethod (whose implementation is not shown), which actually handles the event. With JPred, each helper \nmethod naturally becomes one or more handle1 methods, each declaratively specifying its dispatch constraints. \nThe origi\u00adnal handle1 method is then removed, since JPred automatically dispatches to the appropriate \nhandler. Indeed, as described in sec\u00adtion 5.2 the JPred compiler will generate a dispatcher method that \nis almost identical to the handle1 method in .gure 22. The handlers in .gure 21 that only dispatch on \nthe event s run\u00adtime type could be implemented in MultiJava. In fact, MultiJava has been successfully \nused to implement other event-based sys\u00adtems [37], and this experience led us to use an event-based sys\u00adtem \nfor the current case study. The handlers that dispatch on .elds cannot be directly expressed in MultiJava. \nInstead, helper methods must be created to perform .eld dispatch. For example, the trans\u00adlation to MultiJava \nof the fourth and .fth methods in .gure 21 is shown in .gure 23. This style is tedious and forces the \ndispatching logic to be spread across multiple generic functions. Further, as we show in section 6.3.2 \nbelow, some predicates cannot be expressed at all in MultiJava. Although our case study only involves \nrewriting the implemen\u00adtation of one.world s discovery service, the ways in which we em\u00adploy JPred are \nmore general. JPred would provide similar bene.ts for other services provided by one.world as well as \nfor applications written by programmers on top of one.world. Further, our usage of JPred would apply \nto the implementation of event-based sys\u00ad 5In examples throughout this section, we elide comments and \ncode used for debugging. final class MainHandler extends AbstractHandler {protected boolean handle1(Event \ne) {if (e instanceof EnvironmentEvent) {EnvironmentEvent ee = (EnvironmentEvent) e; switch(ee.type) {case \nEnvironmentEvent.ACTIVATED: ... break; default: ... break; }return true; } else if (e instanceof BindingResponse) \n{return true; } else if (e instanceof InputResponse) {InputResponse ir = (InputResponse) e; if (ir.tuple \ninstanceof AnnounceEvent) {AnnounceEvent ae = (AnnounceEvent) ir.tuple; ... }return true; } else if (e \ninstanceof ListenResponse) {ListenResponse lr = (ListenResponse) e; ... return true; }return false; }} \nFigure 20: An event handler in DiscoveryClient. final class MainHandler extends AbstractHandler {protected \nboolean handle1(Event@EnvironmentEvent ee) when ee.type == EnvironmentEvent.ACTIVATED {... return true; \n}protected boolean handle1(Event@EnvironmentEvent ee) {... return true; }protected boolean handle1(Event@BindingResponse \nbr) {return true; }protected boolean handle1(Event@InputResponse ir) {return true; }protected boolean \nhandle1(Event@InputResponse ir) when ae as ir.tuple@AnnounceEvent {... return true; }protected boolean \nhandle1(Event@ListenResponse lr) {... return true; }protected boolean handle1(Event e) {return false; \n}} Figure 21: The translation of the code in .gure 20 to JPred. final class ServerManager extends AbstractHandler \n{protected boolean handle1(Event e) { if (e instanceof RemoteEvent) { RemoteEvent re = (RemoteEvent) \ne; if (re.event instanceof BindingResponse) { handleBindingResponse(re.source, (BindingResponse) re.event); \nreturn true; } else if (re.event instanceof LeaseEvent) {handleLeaseEvent(re.source, (LeaseEvent) re.event); \nreturn true; } else if (re.event instanceof ExceptionalEvent) {ExceptionalEvent eev = (ExceptionalEvent) \nre.event; ... } return false; } else if (e instanceof LeaseRenew) { handleLeaseRenew((LeaseRenew) e); \nreturn true; } else if (e instanceof ServerCheck) { handleServerCheck((ServerCheck) e); return true; \n } else if (e instanceof EntryEvent) { handleEntryEvent((EntryEvent) e); return true; } else if (e instanceof \nExceptionalEvent) {handleExceptionalEvent((ExceptionalEvent) e); return true; } else { return false; \n }}} Figure 22: Another event handler in DiscoveryClient. protected boolean handle1(Event@InputResponse \nir) {return handleIR(ir, ir.tuple); } protected boolean handleIR(InputResponse ir, Tuple tuple) { return \ntrue; }protected boolean handleIR( InputResponse ir, Tuple@AnnounceEvent tuple) { ... return true; } \n Figure 23: Simulating .eld dispatch in MultiJava. Tuple is a superclass of Event and is the static type \nof the tuple .eld of InputResponse. Table 1: Quantitative results. Java JPred methods 20 87 total LOC \n844 736 avg LOC 42 8.5 max LOC 181 44 instanceofs 80 6 casts 82 18 compile time (sec) 4.5 8.6 CVC Lite \nqueries N/A 452 tems other than one.world. The event-based style has been recom\u00admended for the implementation \nof many important classes of ap\u00adplications, from Internet services [48, 56] to sensor networks [30, 27]. \nFinally, section 2 illustrated other uses of JPred, for example to implement compilers and data structures. \n 6.3 Results 6.3.1 Quantitative Results We can quantify several basic properties of the original and \nrewrit\u00adten discovery service implementation. These properties are de\u00adscribed in table 1. Java refers \nto the original implementation of the code, and JPred refers to the version rewritten in JPred. Twenty \noriginal methods were rewritten to use JPred s features. These include nine handle1 methods and 11 helper \nmethods like handleBindingResponse, whose usage is illustrated in .gure 22. These methods have an average \nsize of 42 LOC, with the biggest method being 181 LOC. In the JPred implementation, the elimina\u00adtion \nof manual dispatching logic causes the number of methods to roughly quadruple and the total code size \nto be reduced, leading to corresponding reductions in the average and maximum method sizes. The small \nmethod sizes indicate that each logical handler is quite simple. JPred allows these conceptually distinct \nhandlers to be written as distinct methods, whose headers declaratively specify their applicability constraints \nand whose bodies are easy to under\u00adstand. The table shows the number of instanceofs and casts present \nin the original and rewritten methods. Almost all of the manual event dispatching is obviated by the \nJPred style. The six remaining instanceofs could be removed by introducing helper methods to perform \nthe type dispatch declaratively, but in these cases it seemed unnatural to do so. The bulk of the remaining \ncasts are related to issues other than event dispatch, for example the lack of parametric polymorphism \nin Java 1.4. Table 1 also includes the time to compile each discovery service implementation. We compiled \nthe Java version with Polyglot and the JPred version with our extension to Polyglot, measuring the time \nto output Java source in each case. The number in each col\u00adumn is the real time averaged over .ve runs \nof the compilers on a lightly loaded, modern PC running Linux. Polyglot takes 4.5 sec\u00adonds to parse and \ntypecheck the Java version and output equivalent code. While the JPred version is slower to compile than \nthe Java version, in absolute terms the JPred version is still quite practical, at 8.6 seconds. Both \nversions require an additional 1.4 seconds to compile the resulting Java source to bytecode using Sun \ns javac compiler. The increase in compile time is largely due to time spent in the automatic theorem \nprover. This case study makes particularly heavy use of predicate dispatch, requiring 452 queries to \nCVC Lite. protected boolean handle1(Event e) {if (state != ACTIVE) { ... return true; } if (e instanceof \nRemoteEvent) ... } Figure 24: The need for negation predicates in the case study. protected boolean handle1(Event \ne) when state != ACTIVE { ... return true; } protected boolean handle1(Event e) when state == ACTIVE \n{ return handleActive(e); } Figure 25: The translation of the code in .gure 24 to JPred. There are several \nopportunities for reducing the number of queries that we have not yet explored. For example, when computing \nan overriding relationship between two methods m1 and m3,if m1 is already known to override m2 and m2 \nis already known to over\u00adride m3, then we are guaranteed that m1 overrides m3 so there is no need to \nask the theorem prover. Also, CVC Lite is optimized for handling large formulas with complex boolean \nstructures; other automatic theorem provers, such as Simplify [18], may be better suited for the kinds \nof small queries that we pose [5]. Finally, de\u00adspite the increase in compile time, JPred s modular class-by-class \ncompilation style should allow compilation to scale well with pro\u00adgram size. 6.3.2 Expressiveness Figure \n21 shows event handlers that employ conjunctions of spe\u00adcializer expressions and equality tests against \nconstants. Many of JPred s other idioms are also utilized in this case study. For exam\u00adple, the portion \nof .gure 22 that is elided by an ellipsis looks as follows: if (eev.x instanceof LeaseDeniedException \n|| eev.x instanceof LeaseRevokedException || eev.x instanceof ResourceRevokedException || eev.x instanceof \nUnknownResourceException) { ... } JPred s disjunction predicate allows this event dispatch to be declar\u00adatively \nspeci.ed. JPred s negation predicate is also used several times. For ex\u00adample, the event-handling code \nfrom DiscoveryServer shown in .gure 24 naturally requires negation predicates. The handler main\u00adtains \nan integer .eld that records the handler s state, one of sev\u00aderal constants represented by static, .nal \n.elds (e.g., ACTIVE, IN-ACTIVE, CLOSING). If the handler is not active, then the action to be performed \ndoes not depend on the passed event. Otherwise, event dispatch is performed via a large if statement \nas usual. The JPred version of this code is shown in .gure 25. The handle1 generic ... ServerEntry entry \n= ...; if (null != entry) { if (ae.capacity >= 0) { ... } else if (ae.capacity == DiscoveryServer.ANNOUNCE \nCLOSING) { ... } else if (ae.capacity == DiscoveryServer.ANNOUNCE CLOSED) { ... }} else { if (ae.capacity \n>= 0) { ... } else { ... }} Figure 26: Null dispatch and linear arithmetic in the case study. function \ndispatches on state, invoking handleActive to dispatch on the event (via several predicate methods) if \nthe state is active. Other idioms, including null dispatch, linear arithmetic, and alias dispatch, are \nalso necessary for the case study. An example of the .rst two idioms occurs in DiscoveryClient s MainHandler,in \nplace of the second-to-last ellipsis in .gure 20. After declaring and initializing a variable entry, \nboth entry and the AnnounceEvent ae are dispatched upon, as shown in .gure 26. JPred s predicate language \nis expressive enough to allow this code to be modularized into its conceptual handlers. Of the 87 new \nmethods in the JPred implementation of the dis\u00adcovery service, only 30 of them either have no predicate \nor per\u00adform MultiJava-style multimethod dispatch. Therefore, MultiJava is unable to express 57 of the \nmethods, or 66%. Of these 57 meth\u00adods, 46 of them consist of conjunctions of formal and .eld dis\u00adpatches, \nwhere each dispatch is either a runtime type test or an equality comparison against a constant. Although \nMultiJava can\u00adnot express these methods directly, it can simulate them by creating appropriate helper \nmethods to perform the dispatch, as shown in .gure 23. However, in many cases, MultiJava would require \nmul\u00adtiple helper generic functions to properly simulate a single JPred method, making MultiJava s solution \ntedious and unnatural. The .nal 11 methods, or 13% of the total, rely on predicates that cannot be declaratively \nexpressed in MultiJava, even with unlimited helper methods. A few expressiveness limitations of JPred \narose in the course of the case study. First, there was one case where disjunction would have been used \nbut our rule that conservatively disallows identi.er bindings from escaping disjunction was too restrictive. \nIt would be straightforward to extend JPred to resolve this problem. Second, there were two situations \nwhere the textual order of if cases in the Java implementation was useful. The example in .gure 24 illus\u00adtrates \none of these situations; the other is analogous. The handler s state is tested before commencing dispatch \non the event. We imple\u00admented this ordering constraint by introducing the handleActive helper generic \nfunction, as shown in .gure 25. Unlike the helper method illustrated in .gure 23, which is used to work \naround a syn\u00adtactic limitation of MultiJava, the handleActive helper generic function serves to make \nexplicit a semantic asymmetry in the dis\u00adpatch logic. It is possible to do away with handleActive, dis\u00adpatching \ndirectly on the given event in handle1 methods, but this requires conjoining the predicate state == ACTIVE \nto the predi\u00ad ... else if (e instanceof ExceptionalEvent) { ExceptionalEvent ee = (ExceptionalEvent) \ne; if (ee.x instanceof LeaseRevokedException) { return true; } ... // several more branches of the \nif statement } else if (ee.x instanceof LeaseRevokedException) {// This wasn t the bug since it would \nhave complained. // FIXME: handle this right } ... } ... return false; Figure 27: An ambiguity found \nin the discovery service. cate of each such method, which is tedious and harder to understand than the \ncurrent solution. Third, there was one situation where it would have been natu\u00adral to put a method invocation \nin a predicate, but JPred does not allow this. Finally, there were two cases of event dispatch that did \nnot occur at top level in a method. One of these is shown in .gure 26. Because there are several statements \n(represented by the initial ellipsis in the .gure) before the dispatch code, a helper generic function \nhandleAnnounceEvent was created in the JPred implementation, which is invoked after those statements \nin order to dispatch on entry and ae. 6.3.3 Errors Found During the course of the case study, we found \nambiguity errors, nonexhaustive errors, and cast failures. We discuss each in turn. One redundancy was \nfound during the case study. An ambigu\u00adity error was signaled by the JPred typechecker when the handle1 \nmethod of DiscoveryClient s InputHandler was rewritten to use JPred. This method is the largest of the \n20 methods we trans\u00adlated, at 181 LOC. The relevant code snippet is shown in .gure 27. Not only are there \ntwo handlers for the case when the event is an ExceptionalEvent whose x .eld is a LeaseRevokedException, \nbut the handlers have different behavior. The .rst handler returns true, while the second one falls through \nand eventually returns false. The method is so complex that even this simplest kind of ambigu\u00adity was \nnot caught by the original implementers. The comment in the second handler is in the original code and \nsuggests an unsuc\u00adcessful attempt to .nd a related error, most likely without realizing that the second \nhandler is redundant and can therefore never be ex\u00adecuted. The author of this code unfortunately does \nnot recall the circumstances. Three potential nonexhaustive errors were found during the case study. \nThese correspond to situations where a target is assumed to have one of a .nite number of runtime types \nor values, and no de\u00adfault case is provided to handle situations when this assumption is false. One example \nis shown in .gure 26, which was described ear\u00adlier. The code does not handle the case when entry is nonnull \nand ae.capacity is a negative number other than the two constants that are explicitly tested. This nonexhaustive \nerror was found auto\u00admatically by JPred when typechecking the handleAnnounceEvent generic function. Of \ncourse, the original programmer could have known about the potential error and simply decided that the \nmiss\u00ading scenarios were impossible. However, ignoring these scenar\u00adios makes the code brittle in the \nface of changes to the surround\u00ad ... else if (e instanceof LeaseEvent) { LeaseEvent le = (LeaseEvent) \ne; switch(le.type) { ... case LeaseEvent.CANCELED: ... LocalClosure lc = (LocalClosure) le.closure; \n ... }} Figure 28: An unprotected cast found in the discovery service. ing system; such changes can occur \nfrequently and dynamically in one.world applications. JPred forces the programmer to explicitly address \nall possible scenarios. In some sense, all of the original handlers in the Java implemen\u00adtation are already \nguaranteed to be exhaustively implemented, since the Java typechecker ensures that handle1 returns a \nboolean value on all feasible paths. However, the Java style of event handling encourages shortcuts that \nmake this checking insuf.cient. In our example, all the handlers corresponding to the code in .gure 26 \nshare a single return true; statement. Therefore, the missing case also returns true, even though it \nshould in fact return false to indicate that the event could not be handled. In JPred, each handler is \nnaturally de.ned in its own method that must explicitly return true or false, so there is no incentive \nto take such a shortcut. Two of the three nonexhaustive errors were found automatically by the JPred \ntypechecker when typechecking a helper method. One of these helper methods, handleAnnounceEvent, was \nintroduced by us during the case study, as described above. The other helper method existed in the original \ncode. The third nonexhaustive error was detected when we realized that the natural JPred implementa\u00adtion \nof one event handler returned false in error cases, whereas the original code returned true. Even in \ncases where the original handler correctly returned false to handle erroneous situations, the JPred version \nmakes it much easier to understand exactly what con\u00additions correspond to an erroneous situation. Lastly, \nseveral unprotected casts were discovered during the case study. Typically unprotected casts arose when \nthe programmer as\u00adsumed a correlation between the properties of two different targets. An example from \nDiscoveryClient is shown in .gure 28. It is assumed that when the LeaseEvent s type is LeaseEvent.CAN-CELED, \nthe event s closure is a LocalClosure. If that is not the case, a dynamic cast failure will result. In \nthe case study, we re\u00admoved 11 unprotected casts from the discovery service. JPred s style encourages \nsuch dispatch assumptions to be documented in a method s header and makes it natural to do so. 6.3.4 \nHandler Reuse In addition to making one.world services like the discovery ser\u00advice more understandable \nand reliable, JPred opens up new possi\u00adbilities for handler reuse. An example appears in the implementa\u00adtion \nof AbstractHandler. As mentioned earlier, AbstractHand\u00adler s handle method invokes the abstract method \nhandle1, which all subclasses must implement. This structure is used precisely be\u00adcause the Java style \nof event handling makes handler inheritance awkward. The handle1 helper method allows subclasses to in\u00adherit \nfrom AbstractHandler the functionality for handling erro\u00ad neous scenarios, as shown in .gure 29. The \noriginal developers could have done away with handle1, public void handle(Event e) {if (handle1(e)) {return; \n} if (e instanceof ExceptionalEvent) { ... } else { ... // handle unexpected events }} Figure 29: AbstractHandler \ns handle method. public void handle(Event@ExceptionalEvent e) { ... }public void handle(Event e) { ... \n// handle unexpected events } Figure 30: AbstractHandler s handle method in JPred. removed the .rst three \nlines from the handle method in .gure 29, and required subclasses to simply override handle. However, \nin Java this design would require each subclass to use superto explic\u00aditly invoke the superclass handler \nwhenever none of the subclass s handlers is applicable, which is tedious and could easily be acci\u00addentally \nomitted. Even with the handle1 helper generic function, subclasses must still explicitly return false \nto invoke the inherited error handler, but the Java typechecker helps to ensure that this is not forgotten. \nIn contrast, JPred can support the desired handler inheritance in the natural way, as shown in .gure \n30. The handle1 generic function is no longer necessary. AbstractHandler provides two handlers, one for \nExceptionalEvents and another for unexpected events. These handlers are implicitly inherited by subclasses, \nwho can add new handle methods for particular scenarios of interest. The inherited handlers are automatically \ndispatched to whenever no method in a subclass is applicable; there is no need for the subclass to explicitly \ninvoke inherited handlers by either invoking super or returning false. This design in JPred easily generalizes \nto support deep hierarchies of handlers with .ne-grained code reuse, an idiom which is too unwieldy to \nconsider in Java.  7. RELATED WORK There have been several previous languages containing a form of \npredicate dispatch. The original work by Ernst et al. [20] was discussed in the introduction and throughout \nthe paper. They im\u00adplemented predicate dispatch in an interpreter for Dubious [39], a simple core language \nfor formal study of multimethod-based lan\u00adguages. That implementation did not include their static type \nsys\u00adtem. The predicate language of Ernst et al. is more general than ours, including arbitrary boolean \nexpressions from the underlying host language. They also support predicate abstractions, which are pred\u00adicate \nexpressions that are given a name and then referred to in method predicates by name. However, their algorithms \nfor rea\u00adsoning about predicates only precisely handle propositional logic and specializer expressions, \ntreating all other kinds of predicates as black boxes that are related only by AST equivalence. This \nsub\u00adstantially limits the ways in which their predicate language can be used. For example, two methods \nwith predicates x == 3 and x == 4 would be considered ambiguous. In contrast, JPred s use of off-the-shelf \ndecision procedures supports precise reasoning over JPred s predicate language. Finally, as mentioned \nin section 3, the static type system described by Ernst et al. is global while ours retains Java s modular \ntypechecking strategy. Ucko [54] describes an extension of the Common Lisp Object System (CLOS) [51, \n24] to support predicate dispatch. Similar to the work of Ernst et al., arbitrary Lisp expressions are \nallowed as predicates. Again a special-purpose algorithm is used for checking validity of predicates. \nThe algorithm is not described in detail, but it appears to only precisely handle propositional logic, \nspecializer expressions, and equality against constants. Static typechecking is not supported. Ucko applies \npredicate dispatch to enhance the ex\u00adtensibility of an existing computer algebra system written in CLOS. \nHe shows how predicate dispatch is used in the enhanced system to implement symbolic integration and \nanother mathematical func\u00adtion. Fred [47] is a language that uni.es predicate dispatch with fea\u00adtures \nof aspect-oriented programming (AOP) [33]. Like predicate dispatch, methods have predicates associated \nwith them, and logi\u00adcal implication determines method overriding. Like AOP, there is a notion of an around \nmethod, which is a special method that is always considered to override non-around methods, thereby sup\u00adporting \nthe addition of new crosscutting code. The language is im\u00adplemented as a library extension to the MzScheme \n[42] implemen\u00adtation of Scheme [1]. Similar to the two languages described above, a special-purpose validity \nchecking algorithm is used, which han\u00addles propositional logic, specializer expressions, and a limited \nform of equality. There is no static type system. Instead, the language reports method lookup errors \ndynamically. Chambers and Chen [14] describe an algorithm to construct ef.\u00adcient dispatch functions for \npredicate dispatch. The algorithm com\u00adputes a directed acyclic graph (DAG) called a lookup DAG, which \ndetermines the order in which targets are tested. Each node of the lookup DAG is in turn implemented \nby a decision tree, which de\u00adtermines the order of tests to be performed on a given target (e.g., test \nthat a target is an instance of C1 before testing that it s an in\u00adstance of C2). The authors show performance \nimprovements of up to 30% on a collection of large Cecil programs. Our compilation strategy likely generates \nless ef.cient code than the algorithm of Chambers and Chen. At the same time, our strategy interacts \nwell with Java s modular compilation strategy, and it is essentially what a Java programmer would write \nby hand. Although Chambers and Chen describe their algorithm as a global one, it could probably be adapted \nto replace our per-class dispatch methods. Predicate classes [12] are a precursor to predicate dispatch \nthat allow an instance of a class C to be considered to be an instance of some subclass D whenever a \ngiven predicate is true. Methods may dispatch on D, and this has the effect of dispatching on whether \nor not a C instance satis.es D s predicate. Predicate dispatch is more general, allowing predicates that \nrelate multiple arguments to a method. Logical implication is used to determine the subclass relation \namong predicate classes, analogous with the use of log\u00adical implication to determine method overriding \nin predicate dis\u00adpatch. However, predicate classes require the implication relation\u00adships among predicates \nto be explicitly declared by the program\u00admer. Similarly, the programmer must declare information about \nother relationships among predicates, such as disjointness, for use in static typechecking. Classi.ers \n[31] provide similar capabilities to predicate classes, but they use the textual order of methods to \nde.ne the overriding relation, as in functional languages. Objective Caml (OCaml) [49, 45] and Scala \n[50] both extend ordinary ML-style pattern matching with the ability to test an arbi\u00adtrary boolean expression \nguard. Unlike JPred, which uni.es predi\u00adcate dispatch with Java s existing dynamic dispatch, pattern \nmatch\u00ading in OCaml and Scala is independent of the OO dispatch mech\u00adanism provided by each of the languages. \nIn both languages, the set of cases in a pattern-matching expression is not extensible, and the textual \norder of cases de.nes the overriding relation. Scala does not appear to statically check for nonexhaustive \nerrors or redundan\u00adcies. OCaml s typechecker does check for nonexhaustive errors, but it does so simply \nby assuming that every predicate guard could evaluate to false simultaneously. This has the effect of \nstatically signaling a warning whenever there does not exist a default case (i.e., a case without a predicate). \nIn contrast, JPred sometimes does not require default methods. Unlike in JPred, pattern matching in OCaml \nand Scala is a .rst-class expression and need not appear at the top level of a function s implementation. \nJMatch [36] extends Java with a sophisticated form of pattern matching that includes many of the idioms \nsupported by JPred, in\u00adcluding type dispatch, dispatch on .elds, and identi.er binding. JMatch s patterns \nadditionally provide support for expressing iter\u00adation, for de.ning abstract patterns that hide a value \ns underlying representation, and for bidirectional computation as provided by logic programming languages. \nAs with OCaml and Scala, pattern matching in JMatch has a functional style: pattern matching is sep\u00adarate \nfrom Java s OO dispatch mechanism, pattern matching is a .rst-class expression, the cases in a pattern-match \nexpression are not extensible, and the textual order of cases de.nes the overriding relation. JMatch \ndoes not statically check for nonexhaustive errors or redundancies. Several recent languages, including \nXStatic [26], CDuce [6], and HydroJ [35], support pattern matching for XML-like [9] data. The patterns \nin these languages overlap with JPred s predicate lan\u00adguage; for example, JPred s disjunction predicate \ncorresponds to union patterns for XML data. However, each can express things that the other cannot. The \nXML languages lack support for re\u00adlational and arithmetic predicates as well as predicates that relate \nmultiple arguments to a function. JPred lacks support for arbitrary regular expressions. Most of the \nlanguages proposed for manipu\u00adlating XML data are based on functional languages, and their pat\u00adtern matching \nconstructs therefore have the same style as pattern matching in OCaml, Scala, and JMatch. An exception \nis HydroJ, an extension of Java with support for XML data. HydroJ uni.es XML pattern matching with Java \ns OO dispatch and uses a form of predicate implication as the overriding relation. Like JPred, Hy\u00addroJ \nadapts our prior work on modular typechecking of multimeth\u00adods [38] to support modular typechecking of \npatterns. Our previous languages MultiJava [16] and Extensible ML (EML) [38] support modular typechecking \nin the presence of multimeth\u00adods. MultiJava s multimethod dispatch can be viewed as the subset of JPred \nsupporting only conjunctions of specializer expressions and equality tests against constants, and only \nfor formal parame\u00adters. MultiJava also supports open classes, the ability to add new methods to existing \nclasses noninvasively. JPred does not support open classes, but it would be straightforward to add them. \nEML subsumes MultiJava s predicate language, additionally containing the ML-style pattern matching idioms \nof identi.er binding and dis\u00adpatch on substructure. JPred extends EML s pattern language to include disjunction \nand negation, arbitrary equality and other rela\u00adtional predicates, linear arithmetic, and predicates \nthat relate multi\u00adple arguments, while retaining modular typechecking and compila\u00adtion. JPred safely \nrelaxes the modularity requirements of MultiJava and EML, for example not always requiring a default \nmethod. This relaxation allows new programming idioms to be expressed, includ\u00ading partially abstract \nmethods. JPred s use of off-the-shelf decision procedures is also novel. 8. CONCLUSIONS AND FUTURE WORK \nWe have described JPred, a practical design and implementa\u00adtion of predicate dispatch for Java. JPred \nnaturally augments Java while retaining its modular typechecking and compilation strate\u00adgies. This contrasts \nwith the global typechecking and compilation algorithms of prior languages containing predicate dispatch. \nJPred uses off-the-shelf decision procedures to reason about predicates, both for determining the method \noverriding relation and for static exhaustiveness and ambiguity checking. This contrasts with the special-purpose \nand overly-conservative algorithms for reasoning about predicates that are used by prior languages with \npredicate dispatch. We presented a case study illustrating the utility of JPred on an existing Java application, \nincluding its use in the detection of several errors. JPred could be extended in several ways. The predicate \nlan\u00adguage currently only supports literals of integer and boolean type. It would be straightforward to \nsupport the other Java literals as well as arrays, along with many of their associated primitive op\u00aderations. \nNamed predicate abstractions could be convenient and would not cause any technical problems. The case \nstudy identi.ed a few ways to extend our predicate language, as described in sec\u00adtion 6.3.2. These include \nrelaxing the rules for when identi.ers can escape from disjunction and supporting method calls in predicates. \nTo allow method calls in predicates, it may be necessary to intro\u00adduce a pure modi.er, to declare a method \nto be side-effect-free. Similar to method calls, it may be useful to incorporate a notion of views [55] \nin JPred. This would allow a class to export a virtual representation to be dispatched upon by clients, \nas an alternative to allowing clients to dispatch directly on .elds. Finally, a notion of resend[13, \n37], which generalizes Java s superto walk up JPred s method-overriding partial order, could be useful \nto allow predicate methods within a class to easily share code. 9. ACKNOWLEDGMENTS Thanks to Sergey Berezin \nand Stephen Chong for their incred\u00adibly responsive support regarding CVC Lite and Polyglot, respec\u00adtively. \nThanks to Eric Lemar for answering questions about the one.world code used in the case study. Thanks \nto Dan Grossman for pointers and discussion about related work. Thanks to Craig Chambers, Mike Ernst, \nRobert Grimm, Keunwoo Lee, and Jens Palsberg for helpful comments on the paper. Finally, thanks to the \nanonymous reviewers for their useful and detailed feedback, in\u00adcluding the idea of allowing a set of \nresolving methods instead of a single one. 10. REFERENCES [1] H. Abelson, R. K. Dybvig, C. T. Haynes, \nG. J. Rozas, N. I. A. IV, D. P. Friedman, E. Kohlbecker, G. L. Steele Jr., D. H. Bartley, R. Halstead, \nD. Oxley, G. J. Sussman, G. Brooks, C. Hanson, K. M. Pitman, and M. Wand. Revised5 report on the algorithmic \nlanguage Scheme. Higher-Order and Symbolic Computation, 11(1):7 105, Aug. 1998. [2] D. Ancona, G. Lagorio, \nand E. Zucca. A formal framework for Java separate compilation. In Proceedings of the 2002 European Conference \non Object-Oriented Programming, LNCS 2374, Malaga, Spain, June 2002. Springer-Verlag. [3] K. Arnold, \nJ. Gosling, and D. Holmes. The Java Programming Language Third Edition. Addison-Wesley, Reading, MA, \nthird edition, 2000. [4] M. G. Assaad and G. T. Leavens. Alias-free parameters in C for better reasoning \nand optimization. Technical Report 01-11, Department of Computer Science, Iowa State University, Ames, \nIowa, Nov. 2001. [5] C. Barrett. Personal communication, Mar. 2004. [6] V. Benzaken, G. Castagna, and \nA. Frisch. CDuce: An XML-centric general-purpose language. In Proceedings of the eighth ACM SIGPLAN international \nconference on Functional programming, pages 51 63. ACM Press, 2003. [7] D. Blei, C. Harrelson, R. Jhala, \nR. Majumdar, G. C. Necula, S. P. Rahul, W. Weimer, and D. Weitz. Vampyre: A Proof Generating Theorem \nProver. http://www.cs.ucla.edu/ rupak/Vampyre. [8] D. G. Bobrow, K. Kahn, G. Kiczales, L. Masinter, M. \nSte.k, and F. Zdybel. CommonLoops: Merging Lisp and object-oriented programming. In Conference proceedings \non Object-oriented programming systems, languages and applications, pages 17 29. ACM Press, 1986. [9] \nT. Bray, J. Paoli, C. M. Sperberg-McQueen, E. Maler, and F. Yergeau. eXtensible Markup Language (XML) \n1.0 (Third Edition). World Wide Web Consortium recommendation, http://www.w3.org/TR/REC-xml, 2004. [10] \nG. Castagna. Covariance and contravariance: Con.ict without a cause. ACM Transactions on Programming \nLanguages and Systems, 17(3):431 447, Mar. 1995. [11] C. Chambers. Object-oriented multi-methods in Cecil. \nIn O. L. Madsen, editor, Proceedings ECOOP 92, LNCS 615, pages 33 56. Springer-Verlag, June 1992. [12] \nC. Chambers. Predicate classes. In Proceedings of the 7th European Conference on Object-Oriented Programming, \npages 268 296, July 1993. [13] C. Chambers. The Cecil language speci.cation and rationale: Version 2.1. \nwww.cs.washington.edu/research/ projects/cecil/pubs/cecil-spec.html, Mar. 1997. [14] C. Chambers and \nW. Chen. Ef.cient multiple and predicate dispatching. In Proceedings of the 14th ACM SIGPLAN Conference \non Object-Oriented Programming, Systems, Languages, and Applications, pages 238 255, Denver, Colorado, \n1999. ACM Press. [15] C. Clifton. MultiJava: Design, implementation, and evaluation of a Java-compatible \nlanguage supporting modular open classes and symmetric multiple dispatch. Technical Report 01-10, Department \nof Computer Science, Iowa State University, Ames, Iowa, Nov. 2001. [16] C. Clifton, G. T. Leavens, C. \nChambers, and T. Millstein. MultiJava: Modular open classes and symmetric multiple dispatch for Java. \nIn OOPSLA 2000 Conference on Object-Oriented Programming, Systems, Languages, and Applications, pages \n130 145, Minneapolis, Minnesota, Oct. 2000. [17] CVC Lite home page. http://verify.stanford.edu/CVCL. \n[18] D. Detlefs, G. Nelson, and J. B. Saxe. Simplify: A theorem prover for program checking. Technical \nReport HPL-2003-148, HP Labs, 2003. [19] S. Drossopoulou, S. Eisenbach, and D. Wragg. A fragment calculus \n towards a model of separate compilation, linking and binary compatibility. In Logic in Computer Science, \npages 147 156, 1999. [20] M. Ernst, C. Kaplan, and C. Chambers. Predicate dispatching: A uni.ed theory \nof dispatch. In E. Jul, editor, ECOOP 98 Object-Oriented Programming, LNCS 1445, pages 186 211. Springer, \n1998. [21] M. Fahndrich and R. DeLine. Adoption and focus: Practical linear types for imperative programming. \nIn Proceedings of the ACM SIGPLAN 2002 Conference on Programming language design and implementation, \npages 13 24. ACM Press, 2002. [22] C. Flanagan, R. Joshi, X. Ou, and J. B. Saxe. Theorem proving using \nlazy proof explication. In CAV: International Conference on Computer Aided Veri.cation, Boulder, Colorado, \nUSA, July 2003. [23] J. S. Foster, T. Terauchi, and A. Aiken. Flow-sensitive type quali.ers. In Proceedings \nof the ACM SIGPLAN 2002 Conference on Programming language design and implementation, pages 1 12. ACM \nPress, 2002. [24] R. P. Gabriel, J. L. White, and D. G. Bobrow. CLOS: Integrating Object-Oriented and \nFunctional Programming. Commun. ACM, 34(9):28 38, Sept. 1991. [25] E. Gamma, R. Helm, R. E. Johnson, \nand J. Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, Massachusetts, \n1995. [26] V. Gapeyev and B. C. Pierce. Regular object types. In Proceedings of the 2003 European Conference \non Object-Oriented Programming, LNCS 2743, Darmstadt, Germany, July 2003. Springer-Verlag. [27] D. Gay, \nP. Levis, R. von Behren, M. Welsh, E. Brewer, and D. Culler. The nesC language: A holistic approach to \nnetworked embedded systems. In Proceedings of the ACM SIGPLAN 2003 conference on Programming language \ndesign and implementation, pages 1 11. ACM Press, 2003. [28] J. Gosling, B. Joy, G. Steele, and G. Bracha. \nThe Java Language Speci.cation Second Edition. The Java Series. Addison-Wesley, Boston, Mass., 2000. \n[29] R. Grimm. System Support for Pervasive Applications. Ph.D. dissertation, Department of Computer \nScience &#38; Engineering, University of Washington, 2002. [30] J. Hill, R. Szewczyk, A. Woo, S. Hollar, \nD. E. Culler, and K. S. J. Pister. System architecture directions for networked sensors. In Architectural \nSupport for Programming Languages and Operating Systems (ASPLOS 2000), pages 93 104, 2000. [31] J. G. \nHosking, J. Hamer, and W. Mugridge. Integrating functional and object-oriented programming. In Proceedings \nof the 1990 TOOLS Paci.c, pages 345 355, 1990. [32] D. H. H. Ingalls. A simple technique for handling \nmultiple polymorphism. In Conference proceedings on Object-oriented programming systems, languages and \napplications, pages 347 349. ACM Press, 1986. [33] G. Kiczales, J. Lamping, A. Menhdhekar, C. Maeda, \nC. Lopes, J.-M. Loingtier, and J. Irwin. Aspect-oriented programming. In M. Aks\u00b8it and S. Matsuoka, editors, \nECOOP 97 Object-Oriented Programming 11th European Conference, Jyv\u00a8askyl\u00a8a, Finland, LNCS 1241, pages \n220 242. Springer-Verlag, New York, NY, June 1997. [34] G. T. Leavens and O. Antropova. ACL Eliminating \nparameter aliasing with dynamic dispatch. Technical Report 98-08a, Department of Computer Science, Iowa \nState University, Ames, Iowa, Feb. 1999. [35] K. Lee, A. LaMarca, and C. Chambers. HydroJ: Object-oriented \npattern matching for evolvable distributed systems. In Proceedings of the 2003 ACM Conference on Object-Oriented \nProgramming Systems, Languages, and Applications, Anaheim, CA, Oct. 2003. [36] J. Liu and A. C. Myers. \nJMatch: Iterable abstract pattern matching for Java. In V. Dahl and P. Wadler, editors, Practical Aspects \nof Declarative Languages, 5th International Symposium, volume 2562 of Lecture Notes in Computer Science, \npages 110 127. Springer, 2003. [37] T. Millstein. Reconciling Software Extensibility with Modular Program \nReasoning. Ph.D. dissertation, Department of Computer Science &#38; Engineering, University of Washington, \n2003. [38] T. Millstein, C. Bleckner, and C. Chambers. Modular typechecking for hierarchically extensible \ndatatypes and functions. In Proceedings of the ACM SIGPLAN International Conference on Functional Programming \n(ICFP 02), volume 37(9) of ACM SIGPLAN Notices, pages 110 122, New York, NY, Sept. 2002. ACM. [39] T. \nMillstein and C. Chambers. Modular statically typed multimethods. Information and Computation, 175(1):76 \n118, May 2002. [40] R. Milner, M. Tofte, R. Harper, and D. MacQueen. The De.nition of Standard ML (Revised). \nThe MIT Press, 1997. [41] D. A. Moon. Object-oriented programming with Flavors. In Conference proceedings \non Object-oriented programming systems, languages and applications, pages 1 8. ACM Press, 1986. [42] \nMzScheme home page. http://www.plt-scheme.org/software/mzscheme. [43] G. Nelson and D. C. Oppen. Simpli.cation \nby cooperating decision procedures. ACM Trans. Program. Lang. Syst., 1(2):245 257, 1979. [44] N. Nystrom, \nM. R. Clarkson, and A. C. Myers. Polyglot: An extensible compiler framework for Java. In Proceedings \nof CC 2003: 12 th International Conference on Compiler Construction. Springer-Verlag, Apr. 2003. [45] \nOCaml home page. http://www.ocaml.org. [46] one.world home page. http://cs.nyu.edu/rgrimm/one.world. \n[47] D. Orleans. Incremental programming with extensible decisions. In Proceedings of the 1st international \nconference on Aspect-oriented software development, pages 56 64. ACM Press, 2002. [48] V. S. Pai, P. \nDruschel, and W. Zwaenepoel. Flash: An ef.cient and portable web server. In Proceedings of the 1999 USENIX \nAnnual Technical Conference (USENIX-99), pages 199 212, Berkeley, CA, June 6 11 1999. USENIX Association. \n[49] D. R\u00b4emy and J. Vouillon. Objective ML: An effective object-oriented extension of ML. Theory and \nPractice of Object Systems, 4(1):27 52, 1998. [50] The Scala language home page. http://lamp.epfl.ch/ \nodersky/scala. [51] G. L. Steele Jr. Common Lisp: The Language, Second Edition. Digital Press, Bedford \n(MA), USA, 1990. [52] B. Stroustrup. The C++ Programming Language: Third Edition. Addison-Wesley, Reading, \nMass., 1997. [53] A. Stump, C. W. Barrett, and D. L. Dill. CVC: A Cooperating Validity Checker. In E. \nBrinksma and K. G. Larsen, editors, 14th International Conference on Computer Aided Veri.cation (CAV), \nvolume 2404 of Lecture Notes in Computer Science, pages 500 504. Springer-Verlag, 2002. Copenhagen, Denmark. \n[54] A. M. Ucko. Predicate Dispatching in the Common Lisp Object System. Technical Report 2001-006, MIT \nArti.cial Intelligence Laboratory, June 2001. [55] P. Wadler. Views: A way for pattern matching to cohabit \nwith data abstraction. In Proceedings of the 14th ACM SIGACT-SIGPLAN Symposium on Principles of Programming \nLanguages, pages 307 313. ACM Press, 1987. [56] M. Welsh, D. Culler, and E. Brewer. SEDA: An Architecture \nfor Well-Conditioned, Scalable Internet Services. In G. Ganger, editor, Proceedings of the 18th ACM Symposium \non Operating Systems Principles, pages 230 243, 2001.   \n\t\t\t", "proc_id": "1028976", "abstract": "<p>&#60;i>Predicate dispatch&#60;/i> is an object-oriented (OO) language mechanism for determining the method implementation to be invoked upon a message send. With predicate dispatch, each method implementation includes a predicate guard specifying the conditions under which the method should be invoked, and logical implication of predicates determines the method overriding relation. Predicate dispatch naturally unifies and generalizes several common forms of dynamic dispatch, including traditional OO dispatch, multimethod dispatch, and functional-style pattern matching. Unfortunately, prior languages supporting predicate dispatch have had several deficiencies that limit its utility in practice.</p> <p>We introduce JPred, a backward-compatible extension to Java supporting predicate dispatch. While prior languages with predicate dispatch have been extensions to toy or non-mainstream languages, we show how predicate dispatch can be naturally added to a traditional OO language. While prior languages with predicate dispatch have required the whole program to be available for type-checking and compilation, JPred retains Java's modular typechecking and compilation strategies. While prior languages with predicate dispatch have included special-purpose algorithms for reasoning about predicates, JPred employs general-purpose, off-the-shelf decision procedures. As a result, JPred's type system is more flexible, allowing several useful programming idioms that are spuriously rejected by those other languages. After describing the JPred language and type system, we present a case study illustrating the utility of JPred in a real-world application, including its use in the detection of several errors.</p>", "authors": [{"name": "Todd Millstein", "author_profile_id": "81100018064", "affiliation": "University of California - Los Angeles, Los Angeles, CA", "person_id": "PP14019523", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1028976.1029006", "year": "2004", "article_id": "1029006", "conference": "OOPSLA", "title": "Practical predicate dispatch", "url": "http://dl.acm.org/citation.cfm?id=1029006"}