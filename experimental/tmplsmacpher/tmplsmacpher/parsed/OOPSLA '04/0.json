{"article_publication_date": "10-01-2004", "fulltext": "\n Converting Java Classes to Use Generics * Daniel von Dincklage Amer Diwan Department of Computer Science \nDepartment of Computer Science University of Colorado University of Colorado danielvd@cs.colorado.edu \ndiwan@cs.colorado.edu ABSTRACT Generics o.er signi.cant software engineering bene.ts since they provide \ncode reuse without compromising type safety. Thus generics will be added to the Java language in the \nnext release. While this extension to Java will help programmers when they are writing new code, it will \nnot help legacy code unless it is rewritten to use generics. In our experience, man\u00adually modifying existing \nprograms to use generics is complex and can be error prone and labor intensive. We describe a system, \nIlwith, that (i) converts non-generic classes to generic classes and (ii) rewrites their clients to use \nthe newly generi.ed classes. Our experiments with a number of Java container classes show that our system \nis e.ective in modifying legacy code to use generics.  Categories and Subject Descriptors D.2.7 [Software \nEngineering]: Distribution, Maintenance, and Enhancement General Terms Languages  Keywords Generics, \nParametric Polymorphism, Type Inference 1. INTRODUCTION Generics, a special case of bounded parametric \npolymor\u00adphism [3], are useful for writing data-structures that are reusable without compromising static \ntype checking. For ex\u00adample, a generic list package, parameterized by its element * This work was supported \nby NSF ITR grant CCR-0085792, an NSF Career Award CCR-0133457, and an IBM faculty partnership award. \nAny opinions, .ndings and conclusions or recommendations expressed in this material are the au\u00adthors \nand do not necessarily re.ect those of the sponsors. Permission to make digital or hard copies of all \nor part of this work for personal or classroom use is granted without fee provided that copies are not \nmade or distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. OOPSLA 04, Oct. 24-28, 2004, Vancouver, British Columbia, Canada. \nCopyright 2004 ACM 1-58113-831-8/04/0010 ...$5.00. type, is not only reusable, but also preserves type \ninforma\u00adtion via the type parameter. In contrast, a non-generic list package, as distributed with Java \n[8], is reusable but oper\u00adations on a list return or take parameters of type Object. Thus clients of \nthe list must explicitly apply narrowing con\u00adversions, compromising static checking and readability of \ncode. In addition to the software engineering bene.ts, gener\u00adics can also provide performance bene.ts. \nFor example, the increased type information provided by generics can give compilers more freedom in reordering \ncomputations [4, 13]. It is therefore no surprise that many modern languages such as Ei.el [10], Modula-3 \n[12], and SML [11] support generics. Java does not yet support generics but will do so with the next \nmajor release. In order to get the most bene.t from the addition of generics to Java, programmers will \nneed to modify existing classes. We show that even for simple classes this process is complex and thus \ncan be error prone. To help programmers in rewriting existing classes to use generics we describe and \nevaluate a system, Ilwith, that performs two functions: (i) it analyzes existing Java classes and discovers \nopportunities for converting them into generic classes; (ii) it analyzes clients of non-generic classes \nand discovers how to modify the clients to use generic versions of the classes. Programmers may use the \noutput of Ilwith as a guideline for manually rewriting classes to use generics or may feed the output \ninto a tool that performs the rewriting automatically. Ilwith analyzes the classes it should generify, \nderiving con\u00adstraints on the types of all variables (instance variables, local variables, parameters, \netc.). These constraints are subset based [7] and capture all uses and de.nitions of variables in the \nanalyzed classes. They determine the range of types one can use for each variable without violating the \ntype safety of the analyzed classes. Ilwith uses these constraints to iden\u00adtify and bound type parameters \nfor the generic classes and to instantiate any generic classes used by the classes being analyzed. While \nthe constraint-based analysis described above pro\u00adduces Java programs that use generics and are correct \nwith respect to the Java type system, it is too aggressive: it re\u00adsults in generic classes with a large \nnumber of type parame\u00adters even for simple classes. In the worst case, the approach above can result \nin generic classes with type parameters for each variable, method parameter, return type, etc. While \nthese parameters are all correct, they are not what a pro\u00adgrammer would have chosen: programmers tend \nto pick one or a few type parameters for each generic class, not tens or hundreds of parameters. Thus, \nto reduce the number of type Listing 1: Dependency between the two tasks class ListWrapper {void set \n( Object arg ) {data .add(arg) ; } Object get () { return data . get (0) ; } List data ; } parameters, \nIlwith employs a number of coarsening heuris\u00adtics. We designed our initial set of heuristics based on \nour study of how Ei.el programs use generics. However, the set of heuristics is extensible and we expect \nto revise them as we gain experience with our system. Ilwith is modular: it does not need whole program \nanaly\u00adsis. For best results, Ilwith needs to analyze a class after all classes that it depends on have \nalready been converted to use generics. In the case of cyclic dependencies, Ilwith can analyze multiple \nclasses at once. Our experience with Ilwith indicates that it often pro\u00adduces the same output as an expert \nprogrammer. When Ilwith was unable to produce the same output as our man\u00adual e.ort, we found the cause \nto be type problems in the Java class that were masked by weak type checking due to a lack of generics. \nThe remainder of this paper is organized as follows: Sec\u00adtion 2 describes our approach intuitively. Section \n3 gives the language that Ilwith operates upon and its type sys\u00adtem. Section 4 presents the basic algorithm \nused in Ilwith. Section 5 re.nes our basic algorithm to handle Java-speci.c features. Section 6 presents \nand motivates heuristics for im\u00adproving the quality of results produced by Ilwith. Section 7 presents \nour results. Section 8 presents related work and Section 9 concludes.  2. INTUITION BEHIND OUR APPROACH \nIn order to convert classes to take advantage of gener\u00adics, Ilwith must perform two tasks: (i) convert \nnon-generic classes to generic classes, which involves determining what types to make into formal generic \nparameters and the con\u00adstraints to use for the parameters; (ii) convert clients of a non-generic class \nto use the generic version of the class. While, for ease of explanation, we will treat these tasks as \nindependent, we must actually perform them simulta\u00adneously to achieve the best results. For example, \nconsider the class ListWrapper (Listing 1) which is a simple wrap\u00adper around the class List. Assume that \nList is a generic class that takes a single type parameter determining the type of its elements. If we \ndetermine the type formals for a generic ListWrapper without considering the type parame\u00adters to List, \nwe will have to assume that data.add requires an Object and data.get returns an Object. On the other \nhand, if we determine the type actuals to List without si\u00admultaneously converting ListWrapper to a generic \nclass, we will end up instantiating List with type Object. In both cases we will fail to convert ListWrapper \ninto a generic class. We now use the class in Listing 2 to intuitively describe Listing 2: A simple example \nclass Example {void set ( Object o ) {data = o; } Object get () { return data ; } Object data ; } Listing \n3: With replaced type variables class Example {void set ( t1 o) {data = o; } t2 get () { return data \n; } t3 data ; } our algorithm. Section 4 describes the algorithm more for\u00admally. Ilwith starts by replacing \nall explicit type references with fresh type variables (Listing 3). Next, Ilwith generates con\u00adstraints \non the type variables based on the body of the class. For our example, Ilwith produces two constraints: \n(i) t1, is a subtype or equal to t3 from the statement data= o and (ii) t3 is a subtype or equal to t2 \nfrom the statement return data. Since generic Java allows type formals to be bound only from above (i.e., \nonly by supertype constraints), t1 is the only variable that Ilwith can turn into a type parameter for \nthe generic Example class (both t2 and t3 are bound from below). Ilwith next looks at the constraints \non t1 to determine what bound to use for it. Since there are no non\u00adtrivial constraints on t1 (it is \nconstrained from above only by type variables, which Ilwith can .x after it has a type for t1) Ilwith \nmakes t1 into a type formal bound by Object. Finally, Ilwith picks the types to use for t2 and t3. t2 \nand t3 are constrained from below by t1 (which has been picked to be a type parameter) and from above \nby Object (from their declarations). Thus any type that is a supertype of t1 and a subtype of Object \nwill be a legal instantiation for t2 and t3. Since we have already decided not to make t2 and t3 into \ntype parameters, we pick Object instead of t1. Listing 4 shows the output of Ilwith when using this approach. \nWhile the code in Listing 4 is a generic version of the class in Listing 2, it is not what an expert \nprogrammer would produce. The problem here is the opposite of what program analyses typically face: the \noutput of the analysis is too precise rather than not precise enough . By introduc\u00ading subtype constraints \nfor each assignment, Ilwith assumes that it is desirable to exploit subtype polymorphism when\u00adever possible. \nIlwith addresses this using heuristics that selectively introduce imprecision into the analysis. Ilwith \nis We use t(x,V ) to represent the type parameter that will Listing 4: The output with the basic algorithm \nbe passed to V in the declaration of x. For example, let s class Example( t<: Object ){ suppose x is \ndeclared to be of type List(... ) and the generic void set ( t o) { type List takes a single type parameter \ncalled E. Then t(x,E) data = o; is the type parameter passed to List in the declaration of } x. Object \nget () { return data ; } Object data ; } Listing 5: The desired output class Example( t<: Object ){ \nvoid set ( t o) {data = o; } t get () { return data ; } t data ; } extensible with respect to heuristics; \nthe initial set of heuris\u00adtics capture our intuition for styles that result in a good generic class. \nBy applying a heuristic (Section 6.2) designed to limit the overzealous use of subtype polymorphism, \nIlwith is able to merge t1, t2 and t3 into a single type variable. After choos\u00ading this new type variable \nas a formal generic parameter and calculating the bound, Ilwith produces the desired output, as shown \nin Listing 5.  3. ANALYZED LANGUAGE AND NOTATION This section describes the language that we operate \non, the type system that we use, and notation in the rest of the paper. 3.1 Analyzed Language Ilwith \noperates on a simple representation of Java pro\u00adgrams that is at the same level as Java bytecodes except \nthat it is expression based (as opposed to stack based). Our representation simpli.es the task of our \nanalysis in the fol\u00adlowing ways: (i) It makes all pointer dereferences (includ\u00ading accesses of instance \nvariables of this ) explicit; (ii) It breaks down multi-level pointer dereferences into a sequence of \nsingle-level dereferences; (iii) It rewrites statements so that each statement has at most one dereference; \n(iv) It renames variables to be globally unique; (v) It introduces variables to represent the return \nvalue of each method; (vi) It resolves overloading. 3.2 Type Variables Our algorithm starts by substituting \na type variable for every Java type in the program. Ilwith uses two forms of type variables. Since the \nform of the type variables a.ects the precision of our analysis we describe them in some detail here. \nThe above notation is useful if we already know that a type is generic (e.g., List is generic in the \nexample above). When Ilwith is analyzing mutually dependent classes, it may not know that a class is \ngeneric until late in the analysis. Thus, we need the second representation. t(x,[v]) represents the \ntype of v, when accessed though x, for example x.v. [v] maps v to the equivalence class that represents \nv. An equivalence class represents all variables that are merged together (Section 6.2). Since the [v] \nis rarely needed, we will often use t(x,v) as an abbreviation for t(x,[v]). Also, for local and instance \nvariables of the class being analyzed, we will often use the abbreviation t(a) instead of t(this,a). \nWe treat local variables as instance variables. Our implementation actually uses a slight variation of \nthe above. To see why, consider the expressions x.v.a and y.v.a. Our type names can represent only one \nlevel of deref\u00aderence (e.g., t(v,a)) and thus would not be able to distinguish between the types of x.v.a \nand y.v.a. Our implementation essentially chains type variables to precisely represent the type of variables \nreached with a long access path.  3.3 Types Used by our Analysis Our analysis needs to be able to .nd \nthe unique lowest\u00adcommon supertype and unique greatest-common subtype of two types. In Java, due to interfaces, \nit is not always pos\u00adsible to determine the non-trivial (i.e., not Object) lowest\u00adcommon supertype of \ntwo types. Thus, we use a variant of the Java type system in which any two types have a unique lowest-common \nsupertype and greatest common subtype. Il\u00adwith s types include a powerset of all Java classes in the \nclasses being analyzed. The mapping from a Java type, T1 to an Ilwith type is the smallest set of types \nthat includes T1 and all its supertypes in the Java type system. As the elements in Ilwith s type lattice \nare sets, the least-common supertype operation is the intersection of the two sets; the greatest-common \nsubtype the union of the two sets. It should be clear that there is always a unique lowest-common supertype \nand greatest\u00adcommon subtype in this type system. Donovan et al. [5] use a similar type system in their \ntool, using the term union type for a set of types. To see the bene.t of Ilwith s type system, let s \nsuppose Ilwith needs to compute the least-common supertype of two Java classes C1 and C2, both of which \nimplement the inter\u00adfaces I1 and I2. Since there are two common immediate supertypes of C1 and C2, there \nis no unique least-common supertype. In Ilwith s type system, the C1 and C1 would be represented by {C1, \nI1, I2, Object} and {C2, I1, I2, Object}respectively. In this type system, we can easily compute the \nleast-common supertype of these types: it is simply the intersection of the two sets (i.e., {I1, I2, \nObject}). Ultimately Ilwith must map its types to the Java types. However, there is no guarantee that \nthe Ilwith type will actually exist in the original Java classes. If such a type does not exist, then \nIlwith can either choose an alternative real class, e.g., Object (thereby incurring a loss of precision) \nor ask the user for help (e.g., the user can create a new type). If a Ilwith type contains a type that \nhas been made generic, the conversion to a Java type is more complicated. Let s sup\u00adpose Ilwith needs \nto convert the type of the type variable t(a) {Object, Set, SortedSet} to a Java type. Assume that SortedType \nand Set are generic: Set has a formal generic parameter F1, SortedSet has a formal generic parameter \nF2 and extends Set(F2). Since SortedSet is the common sub\u00adtype of all types in the type set {Object, \nSet, SortedSet}, Ilwith picks SortedSet. To instantiate SortedSet Ilwith takes the least common subtype \nof the parameters passed to Set and SortedSet in the declarations of the variables represented by t(a) \n(i.e., t(a,F 1) and t(a,F 2)). In this case it is valid to intersect the types computed for t(a,F 1) \nand t(a,F 2), since during inheritance F2 is the actual for F1. For example assume that t(a,F 1) is {Object, \nC1} and t(a,F 2) is {Object, C2}. The common subtype of these two types, and thus the type parameter \nto SortedSet, is {Object, C1, C2}.  3.4 Notational Conventions We use the following notation in the \nrest of the paper. t(this,[a]), t(this,X), t1, t2, ., \u00b5 t(a) s G T Type variables Abbreviation for t(this,[a]) \nSome Java type Some type in Generic Java Some Java class X, K, V, E Formal generic parameters a, b, u, \nw, x, v, t Variables  4. BASIC ALGORITHM To illustrate our algorithm, we will use the class in Listing \n6 as a running example. At a high level Ilwith works as follows: 1. Replace all types in the classes \nto be generi.ed with type variables (Section 4.1). 2. Generate constraints by applying the constraint \ngen\u00aderation rules to the analyzed classes (Section 4.2) 3. Merge all type variables that can be merged \nwithout loss in precision (Section 4.3) 4. Select which type variables will become formal type parameters \n(Section 4.4) 5. Calculate bounds for the type parameters (Section 4.5) 6. Instantiate the other type \nvariables (Section 4.6)  The above algorithm works on individual or groups of Java classes. For best \nresults, a class should be analyzed with or after all classes that it depends on. 4.1 Replacing Java \nTypes with Type Variables This step replaces all Java types with type variables. Il\u00adwith uses the naming \nscheme in Section 3.2 to come up with the type variables. Listing 7 shows our running example after replacing \nJava types with type variables.  4.2 Generating Constraints Ilwith generates constraints by processing \nthe code of the analyzed classes. Since Ilwith does not require a whole\u00adprogram analysis, some of the \nreferences it encounters dur\u00ading constraint generation may refer to classes other than the Listing 6: \nRunning Example class S {S next ; Comparable val ; List val2 ; void setVal(Comparable to) { val = to; \nnext.val = to; val2 .add(to) ; } Comparable getVal() { return val ; }} ; Listing 7: Running example \nafter introducing type variables class S {t(next) next ; t(val) val ; t(val2) val2 ; void setVal (t(to) \nto ) { val = to; next.val = to; val2 .add(to) ; } t(getV alRet) getVal () { return val ; }} ; ones \nbeing analyzed (foreign classes). For this reason, Ilwith uses two constraint generation strategies: \none that involves only classes in the set of classes currently being analyzed and the other that involves \na foreign class. Recall that our representation guarantees that each state\u00adment has at most one dereference \n(i.e., access to a .eld). We do not consider accesses to local variables and instance variables of this \nas a dereference. We use the following decision procedure for determining which set of constraint generation \nrules to use for a given statement: If the statement explicitly refers to a Java type (e.g., assigns \na string literal or is an invocation of new ) use the rules in Section 4.2.1.  If the type of the variable \ndereferenced is in the set of currently analyzed classes, use the rules described in Section 4.2.2. If \nthere is no dereference expression in the statement (i.e., only local variables and instance variables \nof this are accessed), also apply these rules after inserting dereferences of this as necessary to match \nthe rules. As t(this,x) is the same as t(x) we are free to use whichever version is more convenient for \na constraint generation rule if more than one is applicable.  If the type of the variable dereferenced \nis a foreign class, use the rules in Section 4.2.3  a = new T() T <: t(a) a = (String) String <: t(a) \nDe.nition 1: Constraints due to explicit type references Listing 8: A class bene.ting from distinguishing \nthe variable used to access it class Storage {Object data ; Storage a , b; void do something() { a . \ndata = new A() ; b. data = new B() ;  }} 4.2.1 Constraints for Explicit Type References De.nition 1 \ngives a sampling of the rules for generating constraints that arise from explicit type references, such \nas allocation and assignment of literals. For example, after a = new T(), we place the constraint that \nT <: t(a) (i.e., T is a subtype of t(a)). Similarly, after a = \"hello\", we place the constraint that \nString <: t(a). 4.2.2 Constraints for Accesses to Analyzed Classes De.nition 2 gives the constraint \ngeneration rules for ac\u00adcesses involving only analyzed classes. Note that our type\u00adname notation quali.es \naccesses to .elds with the variable used to get to the .eld (e.g., t(x,v)). To see the value of this, \nconsider the example in Listing 8: if we did not distinguish between the data .elds of a and b using \ntype names t(a,data) and t(b,data) we would end up using the same type for the data .elds of all Storage \nobjects, which is clearly imprecise.  4.2.3 Constraints for Accesses to Foreign Classes If the type \nof the variable dereferenced is not in the set of classes being analyzed, and thus of a foreign class, \nthere are three possibilities: 1. The type of the dereference is a normal Java type (e.g., String) 2. \nThe type of the dereference is a formal generic param\u00adeter of the foreign class. 3. The type of the \ndereference is an instantiation of a generic class.  De.nition 3 gives the rules for generating the \nconstraints for the above cases. This de.nition uses a helper function . which has three cases, one for \neach of the possibilities above. We now describe the three cases in detail. Constraints for Normal Java \nTypes The .rst case of De.nition 4 gives the constraint generation rules when the foreign access evaluates \nto a normal Java type. a = x.v x.v : t(v) t(x,v) <: t(a) x.v = a x.v : t(v) t(a) <: t(x,v) a = x.f(... \n) x.f : t(p1),...,t(pm ) . t(fret) t(x,fret) <: t(a) x.f(a1,...,am) x.f : t(p1),...,t(pm) . t(fret) .n.1=n=m \n: t(an) <: t(x,pn) De.nition 2: Constraints for accesses of analyzed classes a = u.t u.t :G .(a, u, G, \n:>) u.t = a u.t :G .(a, u, G,<:) a = u.f(... ) u.f :G1,..., Gm . G .(a, u, G, :>) u.f (a1,...,an) u.f \n:G1,..., Gm . G .n.1=n=m : .(an, u, Gn,<:) De.nition 3: Constraints for dereferenced accesses of foreign \nclasses For an example consider a = u.t, where a is a variable in the analyzed class and t is a String-typed \n.eld of a foreign class. In this case we generate the constraint String <: t(a). Constraints for Formal \nGeneric Parameters The second case of De.nition 4 gives the constraint gen\u00aderation rules when the type \nof the dereference is a formal generic parameter of the foreign class. To see the motivation for this \ncase, imagine that the an\u00adalyzed class uses a variable u declared to be of type Stack which has a formal \ntype parameter called E and a method E top(). Assume now the assignment a = u.top() where a is a variable \nin an analyzed class and u declared to be of type Stack. In this case, we would like to pose the constraint \nE <: t(a). However, this is too imprecise: Consider two un\u00adrelated stack variables, u and w. After the \nassignments a = u.top() and b = w.top(), we will end up generating the constraints E <: t(a) and E <: \nt(b). In other words, we are constraining the types of a and b by the same type of E even though there \nis no relationship between a and b. What we really want to do is to constrain a and b by the actual type \nthat is passed to E in the declarations of u and w (e.g., Stack(Integer) w; Stack(Boolean) u;). To do \nthat, we use a type variable of the form t(x,E) (Section 3.3). For example, t(u,E), and t(w,E) represent \nthe actual types passed to the formal E on instantiations for u and w respectively. In the example above \n(a = u.top()) we would generate the constraint t(u,E) <: t(a). 8 >>>>>< >>>>>: (1) t(a) Rs G is normal \ntype s (2) t(a) Rt(u,X) G is formal generic parameter X (3) t(a) R s, G is parameterized type s(... \n)  .(a, u, G,R) := .(Y, G.) . F ormalBindings(G): withG. actual of formal generic parameter Y t(a,Y \n) Rs. G. is normal type s. t(a,Y ) Rt(u,X.) G. is formal generic parameter X De.nition 4: De.nition of \n. Constraints for Parameterized Classes The third case of De.nition 4 gives the constraint generation \nrules when the type of the dereference is an instantiation of a class. To see why we need this rule, \nconsider the assignment a= u.iterator(), with iterator() declared to have the return type Iterator(E), \nwhere E is a formal generic parameter of the class of u. Moreover, let s suppose that u.iterator() returns \nIterator(Integer). If we did not have the third case, we would generate only the constraint Iterator(... \n)<: t(a). While this constraint is correct, it does not cap\u00adture the relationship between the type parameter \npassed to Iterator on a s declaration and Integer when determining the type of a (Section 4.6). The third \ncase in De.nition 4 explicitly generates the constraint Integer <: t(a,E) to capture that relationship. \nFor ease of explanation the de.nition of . in De.nition 4 is slightly simpli.ed. Speci.cally, it does \nnot work when a generic class is instantiated with an instantiation of another generic class, such as \nSet(Iterator(Integer)). Our system uses a slight variation of . which uses recursion to handle such cases. \n 4.2.4 Constraints for the Running Example Ilwith generates the following constraints using the rules \nin De.nition 2: (i) t(to) <: t(val) for the statement val = to; (ii) t(to) <: t(next,val) for the statement \nnext.val = to; and (iii) t(val) <: t(getValRet), for the statement return val. To pick the correct constraint \ngeneration rule from De.ni\u00adtion 4 for val2.add(to), we need to examine the declaration of val2. Assuming \nthat the List used is declared as List(E)with the method void add(E), we will chose rule 2 from ., as \nthe G in our case will be X. Therefore, we will generate constraint (iv) t(to) <: t(val2,E).  4.3 Merging \nType Variables After generating the constraints, Ilwith analyzes the con\u00adstraints and merges type variables \nthat are in a strongly\u00adconnected component of constraints. For example, if we have the constraints t1 \n<: t2,t2 <: t1, we merge t1 and t2. If Ilwith merges two variables t(this,[a]) and t(this,[b]) Il\u00adwith \nconsiders a and b to be equivalent, that is [a] = [b]. Once Ilwith merges a and b, it makes sense to \nalso merge the type variables that refer to [a] with the type variables that refer to [b]. More speci.cally, \nmerging [a] and [b] causes t(x,[a]) and t(x,[b]) to be merged. While the above merging strategy does \nnot result in any loss in precision, sometimes it may make sense to merge even when there is a loss in \nprecision. Section 6.2 presents optional merging strategies that lose precision but may ac\u00adtually enable \nIlwith to produce better overall results. Our running example does not have any opportunities for merging. \n 4.4 Selecting Type Parameters Parameters to Java generic classes may be bound from above but not from \nbelow. For example, the following could be a legal declaration for a generic Java class: class SortedList(Elt \n<: Comparable) where Elt is the name of the type parameter to SortedList and Comparable bounds it from \nabove (i.e., any type passed to Elt must be a subtype of Comparable). Bounding a type from below (e.g., \nrequiring Elt to be a supertype of Comparable) does not make much sense and thus Java will not support \nit. Thus, all type variables that are bound only from above and do not involve primitive types (which \ncannot be type pa\u00adrameters in Java) are candidate for type parameters. Using the basic algorithm, Ilwith \nconverts all such type variables into type parameters. For our running example, there is only one type \nvariable that is bound only from above: t(to). Thus we select t(to) to be a type parameter. Section 6.1 \nextends this strategy by including optional heuristics based on good programming style.  4.5 Calculating \nthe Bounds To determine the bound on a type parameter, Ilwith takes the greatest common subtype of (i) \nall concrete (i.e., not type variable) types that constrain the type parameter; and (ii) the declared \ntypes of all variables represented by the type parameter. This greatest-common subtype becomes the constraint \non the type parameter. For example, if the constraints on t1 are t1 <: String and t1 <: t2, and the declared \ntype of the variable represented by t1 is Object, Ilwith determines the bound for the type parameter \nt1 by picking the common subtype of String and Object. Once Ilwith computes the bound, it can .x the \nremaining type variables (e.g., t2) based on the calculated bounds. A formal generic parameter generated \nby this method can be used as a formal generic parameter with its calculated bound: As there were no \nsubtype constraints on the original type variable, it is legal to substitute the formal with any subtype \nof the bound or the bound itself during instantiation of the new generic class. If there had been a statement \nthat could be invalidated by this i.e. assigning a concrete value to a location new represented by the \nformal a subtype constraint would have been imposed on the original type variable. To understand the \nvalidity of the bound, let s consider when it would be invalid. To be invalid, the new formal generic \nparameter would need to represent a location that was originally declared with a subtype of the newly \ncalcu\u00adlated bound. However, as the bound includes the common subtype of all declarations represented \nby the new formal, this clearly cannot be the case. 6 For our running example, we need to calculate \nthe bound for the one type parameter t(to). As there are no explicit constraints on t(to), we simply \ntake the type of the single location it represents Comparable as a bound.  4.6 Determining Instantiations \nfor Type Variables As discussed earlier, we generate type variables (such as t(z,a)) to represent the \ntype of various locations in the pro\u00adgram, including the actual type parameters to pass to generic classes \nat their instantiation. Some of these type variables are chosen by Ilwith to be formal generic parameters. \nHow\u00adever, for the remaining type variables, we need to calculate new types in order to generate a class \nthat will typecheck. We also need to calculate parameters to pass to allocations of generic classes. \nFor example, given List x = new List(), where List is a generic class with a type formal E, we need to \ndetermine the type parameters to pass to the declaration of x and to the allocation of the List. In this \ncase, both type parameters are represented by the type variable t(x,E). The type variables considered \nin this section may be constrained from both above and below. There are three steps to solving the constraints \nfor a type variable: (i) .nd the greatest common subtype of all the supertype constraints (call it T); \n(ii) .nd the least common supertype of all the subtype constraints (call it U); (iii) any type on the \npath from U to T is a legal type to use. To lose as little information as possible, we pick U provided \nthat it is a subtype of T. Choosing the most speci.c type here is a heuristic based on our intuition. \nOne could, for example, choose T instead of U or alternately, Ilwith could try out the various possibilities \nfor instantiations in an attempt to get at the best overall result. It is worth noting that due to type-unsafe \ncode (Section 7) it may happen that Ilwith is unable to .nd any type with which to instantiate a type \nvariable. In this case, Ilwith asks the user of the system for feedback. An alternate would be to use \nraw types [2] as used by Donovan et al. [5]. We now argue that our method for instantiating type vari\u00adables \nis valid. First, the instantiation for a type variable will always be a subtype of the declared types \nof all locations rep\u00adresented by the type variable. Thus, all uses of the repre\u00adsented locations will \nremain valid. Second, the instantiation for a type variable will always be a supertype of all subtype \nconstraints (which are caused by assignments to locations represented by the type variable). Thus, an \nassignment to the locations represented by the type variable will remain valid. Thus, Ilwith s instantiation \nof type variables will be valid in all cases. For our running example, we need to calculate the types \nfor the remaining type variables: Most of them (t(val), t(getValRet), t(next,val), t(val2,E)) are constrained \nto be a su\u00adpertype of t(to), and thus of Comparable, and subtype of Comparable due to the declarations. \nTherefore we can choose Comparable or t(to) for each of them. However since earlier Ilwith had already \ndecided to not make these variables into type formals, we instantiate them with Comparable instead of \nt(to). We now need to instantiate t(val2) whose only constraints come from its declared type (List(... \n)). Since the declared type is generic, we need to instantiate it. Thus, we look up the constraints on \nt(val2,E) which represents the type param\u00adeter passed to E on the declaration of val2. Since t(val2,E) \nis Listing 9: Running example after instantiating type vari\u00adables class S(X extends Comparable ){ S(Comparable) \nnext ; Comparable val ; List (Comparable) val2 ; void setVal(X to) { val = to; next.val = to; val2 .add(to) \n; } Comparable getVal() { return val ; }} ; Listing 10: The internal per-method polymorphism class \nPoly { static void poly ( Object a , Object b ) { a = b; b = a; } void use () { Object x, y; poly (new \nA() ,x) ; poly (new B() ,y) ; }} constrained only by its bound (Comparable), we instantiate the List \nin the declaration of val2 with Comparable. Finally, since S is now a generic type, we need to instan\u00adtiate \nit in the declaration of next. Since t(next,to) is the formal type parameter to S in the declaration \nof next we look for constraints on t(next,to). The only constraint on t(next,to) comes from the bound \non the formal generic pa\u00adrameter (i.e., Comparable) and thus we instantiate S with Comparable in the \ndeclaration of next. The above instantiations give us the representation in Listing 9. While Listing \n9 makes some use of generics, it is not what a programmer would have produced. The heuris\u00adtics in Section \n6 address the problems with this output.  4.7 Per-Method Polymorphism Without per-method polymorphism, \nIlwith will merge in\u00adformation from di.erent call sites, resulting in a loss in pre\u00adcision. Ilwith supports \noptional per-method polymorphism for methods of analyzed and non-analyzed classes: While imposing the \nconstraints on methods belonging to analyzed classes, Ilwith generates new type variables repre\u00adsenting \nthe arguments and the return value of the method for each call-site of the method. If the original type \nvariables are merged, Ilwith will merge the corresponding copies. To see the bene.t of this approach, \nconsider the example shown in Listing 10. If one choses not to use per-method polymorphism, Ilwith imposes \nthe constraints t(x) <: t(b), t(y) <: t(b), A <: t(a), and B <: t(a). Since t(a) <: t(b) and t(b) <: \nt(a) (from body of poly) t(a) and t(b) will be merged, producing the constraint system t(x) <: t([a,b]), \nt(y) <: t([a,b]), A <: t([a,b]), B <: t([a,b]). If one now applies a heuristic that causes these variables \nto be merged (see Sec\u00adtion 6.2), x and y would end up being of a common subtype of A and B, a clearly \nunacceptable result. However, if one uses per-method polymorphism the sys\u00adtem will generate the constraints \nt(x) <: t(b1) and t(y) <: t(b2) as well as A <: t(a1) and B <: t(a2). As a merge of the original variables \nimplies a merge of the correspond\u00ading copies, merging t(a) and t(b) will produce the constraint system \nt(x) <: t([a1,b2]), t(y) <: t([a2,b2]), A <: t([a1,b1]), B <: t([a2,b2]). As there now is no constraint \nthat links t(x) and t(y) together, subsequent application of heuristics will not degrade the results. \nIf the polymorphic method resides outside the set of ana\u00adlyzed classes we can use a simpler approach. \nAs we already know which parameters of the method have the same type parameter, we do not need to create \ncopies of the actuals when calling a polymorphic method. Instead, we can use a special set of constraint \ngeneration rules (De.nition 5) that directly use the generic signature rather than waiting for the representatives \nto be merged. Note that the previous description has treated the fea\u00adture as optional. Ilwith normally \ndoes not use per-method polymorphism, as long as it is not explicitly enabled on a per-method basis. \nSection 6.4 gives a heuristic that choses for which methods to use per-method polymorphism.  5. HANDLING \nFEATURES OF JAVA We now describe how our algorithm handles some of the trickier aspects of analyzing \nJava programs. 5.1 Arrays Ilwith models arrays as instances of the java.lang. reflect.Array class, which \nit treats as a generic class with one type parameter (X extends Object) representing its el\u00adement type. \nLoads and stores into the array translate into invocations of the set and get methods with signature \nvoid set(X, int) and X get(int) respectively. 5.2 Public .elds Ilwith does not have access to all uses \nand modi.cations of public instance variables since any class may use or mod\u00adify these variables. There \nare three possibilities for handling public instance variables: (i) Assume that a public .eld can only \nbe of its declared type. This assumption may constrain the types of other variables in the class. Though \nsound, this alternative is too restrictive, since Java programmers, in our experience, frequently use \npublic .elds even in situations where such broad access is unnecessary; (ii) Assume that a public .eld \nwill not be modi.ed from outside the class. This is potentially unsound. (iii) Perform a whole program \nanaly\u00adsis (e.g., escape analysis) to .gure out how public .elds may be modi.ed outside of their classes. \nSince whole program analysis of Java is in general impossible (due to dynamic class loading) this possibility \nhas limited applicability. For our experiments we use the second strategy above. 5.3 Interfaces Since \ninterfaces do not contain any code, Ilwith cannot directly convert a non-generic interface into a generic \ninter\u00adface. Ilwith handles interfaces by analyzing implementations of the interface. Each type variable \nof a implementation is declared to be equal to the type variable representing the same declaration in \nthe interface. By doing this, the types in the interface will end up being types and formals that ful.ll \nall requirements of all implementations. Ilwith uses a similar approach to convert abstract classes to \nbe generic. While the approach above works well in practice it is un\u00adsound (unless we can analyze all \npossible implementations of the interface). 5.4 Inheritance If class S is a subclass of class T, Ilwith \ntreats class S as if it had a (specially named) .eld of type T. Method invocations and variable accesses \nto ancestor classes are delegated to this .eld. Thus, Ilwith can instantiate superclasses in the same \nway that it instantiates types for instance and local variables. 5.5 Native Methods and Re.ection Since \nnative methods are not written in Java, Ilwith can\u00adnot analyze them and therefore assumes the worst case \nabout them. Since classes rarely call native methods we have not found the worst case assumption to be \na problem in practice. Ilwith handles some but not all uses of re.ection. Consider for example the use \nof Object[] newInstance(Class,int) in java.lang.relect.Array to create a new instance. The problem here \nis that Ilwith needs to know the value of the .rst argument to newInstance to determine the return type \nof newInstance. To handle this situation, we assume that Class is a generic type and that the signature \nof newInstance method is X[] newInstance(Class[X],int). In other words, newInstance s return type is \nthe same type with which Class is parameterized. The, however, does not explain how Class objects are \nconstructed. Ilwith does this by providing spe\u00adcial treatment for functions that generate these objects, \nsuch as getClass: When analyzing a invocation such as a= x.getClass(), Ilwith imposes the constraints \nClass <: t(a) and t(x) <: t(a,X). This ensures that the formal type of the Class object (the X) always \nhas the same type as the value it is constructed from.  6. COARSENING HEURISTICS As we saw in Section \n4, our algorithm produces results that are too precise to be useful. In this section we present heuristics \nthat Ilwith uses to coarsen its results. These heuristics are based on our study of programming style \nused in Ei.el s generic classes [9]. As such, these heuristics are not meant to be complete. Users of \nIlwith can selectively en\u00adable or disable the heuristics or extend Ilwith with heuristics of their own. \nOur current set of heuristics are based on the following observations about the style of the generic \ncode that we examined: Style observation 1: Generic classes have a small number of type parameters and \nthese type parame\u00adters are usually unconstrained or constrained with an abstract class or interface. \nStyle observation 2: Generic classes use type pa\u00adrameters only if they give some bene.t that cannot be \neasily obtained using subtype polymorphism. Style observation 3: Generic classes use their type parameters \nfrequently throughout the class. Moreover, generic classes commonly have methods with the type b = f(. \n. . , a, argn,... ) f : . . ., X, sn, \u00b7\u00b7\u00b7 . X t(a) = t(b) f (. . . , a, argn, . . . , b, argm ... ) f \n: . . . , X, sn, . . . , X, sm, \u00b7\u00b7\u00b7 . sret t(a) = t(b) De.nition 5: The constraints used for per-method \npolymorphism. parameter as argument or return type or have instance variables with the type parameter \nas its type. Style observation 4: Type parameters are seldom used polymorphically inside a class. For \nexample, if we have a variable whose type is determined by a type parameter, it is rarely assigned to \na variable of a dif\u00adferent type. Style observation 5: Methods such as equals are usually used to compare \nobjects of the exact same type. 6.1 Selection Heuristics These heuristics determine when we use a type \nvariable as a formal of the generic class. We have two such heuristics. 6.1.1 Selection Heuristic 1 Turn \na type variable into a formal of the enclosing generic class if it ful.lls at least one of the following \nrequirements: It is used as a parameter type or the return type of at least two methods of the class. \n It is used as a parameter type and the return type for at least one method of the class.  It is used \nas the type of at least one instance variable of the class.  The second criterion above is subsumed \nby the .rst cri\u00adterion. However, we include both in our system to provide users more choices since the \nsecond criterion is more picky than the .rst. This heuristic is motivated by style observation 3 (and \nto a lesser extent style observation 1). 6.1.2 Selection Heuristic 2 Select a type variable t(a,X) as \na formal if it is a formal of another type variable . that has already been selected as a formal generic \nparameter and neither t(a,X), nor any other variable t(a,Xn) representing a formal of . is constrained. \nFurthermore, prevent . from being used as a formal. To motivate this heuristic, consider the class in \nListing 11 and its desired generic version in Listing 12. Without the above heuristic Ilwith will not \nproduce the output in Listing 12 because the class does not actually do anything with data or arg. Instead \nIlwith will produce the output in Listing 13. Using the above heuristic allows Ilwith to produce the \ndesired output.  6.2 Merging Heuristic A merging heuristic merges type variables together so that the \ncombined type variable can be a candidate for being made into a type parameter. Listing 11: Motivation \nfor selection heuristic 2 class Client {void set ( List arg ) {data = arg; } List get () { return data \n; } List data ; } Listing 12: Desired output for Listing 11 class Client (Y <: Object){ void set ( List \n(Y) arg ) {data = arg; } List (Y) get () { return data ; } List (Y) data ; } Listing 13: What Ilwith \nproduces for Listing 11 class Client (X <: List (Object)) { void set( Xarg ) {data = arg; } X get () \n{ return data ; } X data ; } a = x.clone() t(a) = t(x) x.equals(a) t(a) = t(x) De.nition 6: The constraint \ngeneration rules for equals and clone Listing 14: An example of the equals heuristic class equalsProblem \n{boolean isSet ( Object arg ) {return data . equals(arg) ; } void set ( Object arg ) { data = arg; } \nObject get () { return data ; } Object data ; } The heuristic is as follows: Merge two type variables \nt1 and t2, if t1 <: t2, and t1 as well as t2 are constrained to be subtypes of the same set of concrete \ntypes. This heuristic is motivated by style observation 4. To see this, consider again the class of the \nsimple example in List\u00ading 2. Without the merging heuristic, Ilwith produces the class in Listing 3 which \nis probably not what a programmer would have written. The set method takes an argument of type t and \nimmediately widens it to Object, thus losing type information. The merging heuristic merges the type \nvariables corresponding to the types of data, get, and set and results in the output in Listing 4. 6.3 \nConstraints for equals and clone Methods such as equals in Java can take arguments of any type (as long \nas it is a class). Thus, one could use equals to compare objects of completely unrelated types. However, \nas stated in style observation 5, it is common for equals to be used only for the same type as the receiver. \nThis heuristic forces the type of the argument and receiver to be the same. De.nition 6 gives the constraint \ngeneration rules for equals and clone. To see the e.ect of this heuristic consider the class in Listing \n14. Without this heuristic, Ilwith will not discover any connection between the argument type of isSet \nand the argument type of set. If a class uses equals to compare arguments of di.erent types, Ilwith will \nstill produce correct but possibly inferior results with this heuristic. One possibility is for the user \nto try both with and without the heuristic and pick the better result.  6.4 Polymorphic Functions Java \nprograms frequently use static functions. As these functions are shared throughout a system, it would \nbe hard to generate a useful generic representation of a static method that could be used from all clients, \nusing the many di.erent actual parameterizations possible. Thus, we use per-method polymorphism for the \nstatic methods. 6.5 Running Example We had the following constraints for our running example: (i) t(to) \n<: t(val), (ii) t(to) <: t(next,val), (iii) t(val) <: t(getValRet) and (iv) t(to) <: t(val2,E). The merging \nheuristic merges t(val) and t(getValRet). As both the type variables being merged are of the form t(this,a), \nwe need to declare [val] = [getValRet] (Section 4.2). As a result of the merge we get t([val,getValRet]). \nIt is important to note that, as a result of declaring [val] = [getValRet], constraint (ii) now becomes \nt(to) <: t(next,[val,getValRet]). After performing this merge, we now have the constraint system: (i) \nt(this,to) <: t(this,[val,getValRet]), (ii) t(this,to) <: t(next,[val,getValRet]), (iii) t(to) <: t(val2,E). \nThe merging heuristic is applicable again this time to t(this,to) and t(this,[val,getValRet]), yielding \nt(this,[val,getValRet,to]). Having done this, we then can collapse the constraint t(this,[val,getValRet,to]) \n<: t(next,[val,getValRet,to]), ending up with the type variable t([this,next],[val,getValRet,to]). The \nsole re\u00admaining constraint now is t([this,next],[val,getValRet,to]) <: t(val2,E), which we can merge \ntoo. The remaining type vari\u00ad able t([this,next,val2],[val,getValRet,to,E]) clearly ful.lls the re\u00adquirements \nof the selection heuristic, so we chose to make it a formal generic parameter. We now need to calculate \nthe bound for the type formal to the generic class. As we have no concrete constraints \u00adother than the \ndeclarations of the locations it represents \u00adwe use the bound Comparable. Finally we need to instantiate \nthe remaining type vari\u00adables. As previously, the type variable t(val2) is uncon\u00adstrained, so the type \nchosen will be List(... ) again. Simi\u00adlarly, we look for t(val2,E) to determine the type used to in\u00adstantiate \nthe list. Although we do not .nd the type variable itself, we .nd something that has been declared equivalent \nto it: t([this,next,val2],[val,getValRet,to,E]). As this type variable had been made into a formal generic \nparameter, we instan\u00adtiate the List with the newly generated formal parameter, X. Finally we need to \ninstantiate S in the declaration of next. As our formal generic parameter represents the locations val, \ngetValRet and to, we need to locate the type variable t([this,next,val2],[val,getValRet,to,E]) to calculate \nthe instantia\u00adtion. Incidentally, this is exactly the type variable we chose to make a formal generic \nparameter -allowing us to simply chose the formal itself, generating the .nal program shown in Listing \n15.  7. RESULTS Ilwith operates on the jimple representation of the Soot framework [18]. Jimple is \na high-level intermediate represen\u00adtation for Java programs that already provides most of the simpli.cations \ndiscussed in Section 3.1. The inputs to Ilwith are one or more compiled Java classes and a description \nof classes that are already generic. The output of Ilwith is a new description, which is a superset of \nthe input .le that also includes information for making the input classes generic. Listing 15: Running \nExample class S(X extends Comparable ){ S(X) next ; X val ; List (X) val2 ; void setVal(X to) { val = \nto; next.val = to; val2 .add(to) ; } X getVal() { return val ; }} ; Class Signature ArrayList (Java \n1.4) (E extends Object) Vector (Java 1.4) (E extends Object) Stack (Java 1.4) (E extends Object) HashSet \n(Java 1.4) (E extends Object) TreeMap (Java 1.4) (K, V extends Object) HashMap (Java 1.4) (K, V extends \nObject) LinkedList (Java 1.4) (E extends Object) Vector (Antlr) (E extends Object) LList (Antlr) (E \nextends Object) Table 1: Discovered type parameters 7.1 Converting Non-Generic Classes to Generic Classes \nTo evaluate Ilwith s ability in converting non-generic classes to generic classes, we applied it to several \ndata structures taken from the Sun Java 1.4 and Antlr class hierarchies. For all our test classes, Ilwith \nwas fast, taking less than two minutes on a 2.66 Ghz Pentium 4 workstation with 2 GB of memory. Table \n1 gives the signatures that Ilwith discovers for classes in the Class column. All the discovered sig\u00adnatures \nare correct and are consistent with what we would have done manually. For all classes except for TreeMap \nand HashMap, Ilwith converted the classes fully automatically. We discuss the issues with TreeMap and \nHashMap in the re\u00admainder of this section. For the HashMap, Ilwith initially reported the signature HashMap(t(val) \nextends HashMap$Entry( Object, t(val) )), rather than the expected HashMap(t(key), t(val) extends Object). \nTo .nd the cause for this output, we instructed Ilwith to calculate the formals and instantiations for \neach type variable before and after each merge. Using this out\u00adput, it is easy to locate the causes of \nt(val) s strange signa\u00adture: One simply locates the .rst merge after which the cal\u00adculated bound of t(key) \ndi.ers from the desired one. As each merge is caused by a constraint, which, in turn was gener\u00adated by \nsome statement, one then can inspect the statement that caused the undesired merge. Applying this method, \nwe found the statement in the HashMap that had imposed the constraint to be the return e; in the following \nfragment: if (e == null ) return e; if (e.hash == hash &#38;&#38; eq(k, e.key)) return e. value ; The \nintended behavior of this code is as follows: if the entry e is null, it should return null; if the entry \nis non null and matches the key, k, it should return the value stored at the entry. Looking at the code \nwe see that rather than having a return null when the e is null, it returns e itself. Thus, the code \nreturns values of two di.erent types: the type of the entry and the type of the value stored in the entry. \nThis issue is re.ected by the output generated by Ilwith , as choosing the undesired bound will not generate \nany typing errors. However, if we modify this code to return the constant null Ilwith produces the expected \nbound. After resolving this issue, we found that our system still did not create a generic parameter \nfor the key of the HashMap. On investigation we found that the HashMap uses an instance of the Object \nclass (allocated in the HashMap code) as the empty key. This assignment forced the key s type to be a \nsupertype of Object which disquali.ed it from being a parameter. After removing the second issue from \nthe class, Ilwith did discover the desired generic representation of the HashMap and the dependent classes. \nBesides issues similar to the ones for HashMap, we found additional problems with TreeMap. Ilwith initially \nreported a generic signature of TreeMap$Entry(t(data)extends TreeMap$Entry(... )) for the TreeMap$Entry \nclass. This is clearly problematic since it would allow us to store only ob\u00adjects of type TreeMap$Entry \nin the TreeMap We found the reason for this signature to be as follows. Internally, the TreeMap stores \nkey/value pairs inside the helper class TreeMap$Entry. TreeMap also de.nes a class TreeMap$EntryIterator, \nfor iterating over all entries stored in the tree map. This iterator returns TreeMap$Entry from its next \nmethod. The TreeMap also de.nes two subtypes of the EntryIterator, one for iterating over the values \nstored in the map and one for iterating over the keys in the map. Similarly, these iterators return values \nand keys from their respective next method. Even though the next methods of the three iterators return \ncompletely unrelated types, the in\u00adheritance and overriding forces them all to return the same type. \nIt is worth noting that, although the HashMap uses in\u00adheritance similarly, it it does not exhibit the \nabove problem, since the code for HashMap does not mix unrelated types. Even after we had addressed the \nabove issue in the code of TreeMap, Ilwith was still unable to infer the desired type parameters for \nTreeMap; it inferred the keys of the map to be of type TreeMap$Entry. The reason for this turned out \nto be a method, buildFromSorted, in TreeMap. TreeMap uses this method as an e.cient way to construct \na new tree if sorted data is already available, e.g. in the case of a clone. buildFromSorted takes an \niterator that returns the key/\u00advalue pairs in the correct order for constructing the tree. However, buildFromSorted \nalso contains special support for the deserialization of the TreeSet: it enables the iterator to return \nboth keys and key/value pairs. Thus, Ilwith con\u00adcludes that the iterator may return either TreeMap$Entry \nor Object (from the key) and thus infers the incorrect type for the key. When we commented out the special \nsupport for TreeSet Ilwith found the desired generic signature for TreeMap and its dependent classes. \nTo summarize, Ilwith is e.ective in converting classes to use generics. When it failed it was due to \nweak typing in the original Java classes. No matter how these classes are converted to be generic, whether \nusing a tool or manually, the issues above will have to be .xed. Disabled None Merging Selection equals \nAll ArrayList 1 6 8 1 24 LinkedList 1 5 10 1 48 HashMap 2 6 19 4 99 Table 3: E.ectiveness of the heuristics \nwrt. the number of discovered type parameters Disabled None Merging Selection equals All ArrayList LinkedList \nHashMap 15 32 2 6 16 6 16 37 19 12 28 4 20 42 99 Table 4: E.ectiveness of the heuristics wrt. the number \nof times a type parameter is used in the class  7.2 Instantiating Generic Classes Table 2 shows sample \ninstantiations that Ilwith computed in our benchmark classes. In addition to .elds and meth\u00adods, entries \nwith extends denote instantiations that were computed for superclasses. (init) denotes a signature of \na constructor. All instantiations were correct. 7.3 Effectiveness of Heuristics Table 3 presents the \nnumber of type parameters of the discovered generic class with di.erent heuristics. Each col\u00adumn presents \nthe data when one or more of the heuristics is disabled. 1 At two extremes, None gives the results of \nthe default con.guration, where no heuristic is disabled, and All gives the results where all of the \nheuristics are dis\u00adabled. Table 4 gives the number of functions and .elds that get their type from a \ntype parameter. From the None column we see that even though the classes have one or two type parameters, \nthey are used in many places. From these tables we see that all heuristics o.er some bene.t. equals o.ers \nthe least bene.t while the merging and selection heuristics are most bene.cial. However, to achieve the \ndesired result our benchmarks, we had to enable all the heuristics. 7.4 Complexity of the Problem Figures \n1 and 2 show a more detailed view of the LinkedList and HashMap test cases. Each node represents an analyzed \nclass while an edge goes from a class to classes used by that class. From these .gures we see that even \nseemingly simple classes, such as LinkedList, are complicated and use many inner classes. In the process \nof analyzing the classes in Table 1 we analyzed a total of 47 classes (which includes inner classes and \nabstract classes). We also see that there are complex dependencies between classes and there are several \nstrongly\u00adconnected components (indicating circular dependency) in the two graphs. These circular dependencies \nvalidate our decision to combine the tasks of instantiating classes and converting non-generic classes \nto generic classes.  8. RELATED WORK We are aware of only of three pieces of prior work on con\u00adverting \nnon-generic Java classes to generic classes. However, 1Due to implementation artifacts we could not disable \nthe polymorphic functions heuristic completely.  Figure 2: The java.util.HashMap-test. much of the work \non type inference, constraint-based anal\u00adyses, and refactoring is also relevant to our paper. Duggan \n[6] describes an analysis for converting Java classes to use generics. Like our work, Duggan s approach \nis based on type inference. However, unlike us, their analysis does not help in the instantiation of \nalready generic classes. Also, unlike us they do not present any experimental results or rec\u00adognize the \nneed for incorporating heuristics into their anal\u00adysis in order to yield useful results. Donovan et al. \n[5], in concurrent work, describe a system for instantiating already generic classes. Unlike our anal\u00adysis, \ntheir system does not convert non-generic classes to generic classes. The analyses used by Donovan et \nal. are more aggressive than ours, requiring whole-program points\u00adto analysis. Donovan et al. s analysis \nessentially does the Cartesian Product whole program analysis [1] to determine the space of possible \nsolutions and then a type inference that picks between the possible solutions. Since whole program analysis \nis not, in general, feasible for Java programs (with dynamic class loading) our analysis is more generally \nap\u00adplicable. On the other hand, Donovan et al. also generate uses of raw types [2] which our analysis \ndoes not consider. It would be worthwhile to try to combine the strengths of Donovan et al. s analysis \nwith ours. Tip et al. [16], also in concurrent work, describes a system for instantiating generic container \nclasses. Unlike us, Tip et al. do not try to convert non-generic classes to generic Signatures calculated \nin LinkedList(E extends Object)extends AbstractSequentialList(E)E set(int,E) boolean addAll(Collection(E)) \nArray(E) toArray(Array(E)) LinkedList$ListItr(E) listIterator() LinkedList$Entry(E) addBefore(E,LinkedList$Entry(E)LinkedList$Entry(E) \nheader Signatures calculated in LinkedList$Entry(E extends Object)(init)(E,LinkedList$Entry(E),LinkedList$Entry(E)) \nelement E LinkedList$Entry(E) next Signatures calculated in LinkedList$Iterator(E extends Object)extends \nAbstractList$ListIterator(E)(init)(LinkedList(E)) E next() void set(E) Signatures calculated in HashMap$EntrySet(K,V \nextends Object)(init)(HashMap(K,V)) void remove(HashMap$Entry(K,V)) HashMap$EntryIterator(K,V) iterator() \nSignatures calculated in HashMap$HashIterator(K,V extends Object)(init)(HashMap(K,V)) HashMap$Entry(K,V) \ncurrent Signatures calculated in HashMap$KeyIterator(K,V extends Object)extends HashIterator(K,V)(init)(HashMap(K,V)) \nK next() Signatures calculated in HashMap$KeySet(K,V extends Object) (init)(HashMap(K,V)) boolean contains(K) \nboolean remove(K) HashMap$KeyIterator(K,V) iterator() Signatures calculated in HashMap$Entry(K,V extends \nObject)V getValue() K getKey() void recordRemoval( HashMap(K,V)) boolean equals( HashMap$Entry(K,V) ) \nSignatures calculated in HashMap(K,V extends Object)extends AbstractMap(K,V)void putAll(Map(K,V)) V get(K) \nV put(K,V) void createEntry(int,K,V,int) HashMap$Entry(K,V) removeEntryForKey(K) void transfer(Array(Entry(K,V))) \nArray(Entry(K,V)) table HashMap$KeySet(K,V) keySet() HashMap$EntrySet(K,V) entrySet() HashMap$KeyIterator(K,V) \nnewKeyIterator() HashMap$EntryIterator(K,V) entryIterator() HashMap$ValueIterator(K,V) newValueIterator() \nSignatures calculated in TreeMap(K,V extends Object)void buildFromSorted( int, Iterator(Map$Entry(K,V)), \nIOStream, V) V put(K,V) TreeMap$Entry(K,V) parentOf(TreeMap$Entry(K,V)) Signatures calculated in LList(E \nextends Object)E deleteHead() LLEnumeration(E) elements Table 2: Some discovered signatures classes. \nTip et al. s approach is similar to Donovan et al. s approach in that it starts with the Cartesian Product \nalgo\u00adrithm. Tip et al. s approach uses the results of the Cartesian Product algorithm to identify the \ncalling contexts and does a type inference that uses the calling context information. The work on type \ninference and constraint based analyses [7, 15, 14] all in.uenced our work. To some degree our ap\u00adproach \ncan be considered an application of constraint based techniques from prior work. Lackwit [14] uses a \nconstraint\u00adbased analysis to detect possible errors in C programs. Lack\u00adwit identi.es variables, based \non assignments in the pro\u00adgram, that must have an identical type and representation. By examining these \ntypes the programmer can detect erro\u00adneous .ows of values. The output generated by Ilwith can also be \nused in a manner similar to Lackwit, as seen in the experimental results. Type inference in Standard \nML [11] also aims at discovering parametric polymorphism in SML programs. We found that constrained-based \ntype inference alone was not enough for converting classes to use generics: we also needed to use heuristics \nto yield desirable results. Tip, Kiezun and B\u00a8aumer describe an approach to refac\u00adtoring Java programs \n[17]. The refactorings they describe including extracting interfaces and moving class members. The approach \nused for the refactoring uses type constraints that are used in a similar fashion to our approach. The \nconstraint generation and resolution used in our system can be viewed as a special case of their approach. \nHowever, we demonstrate that constraint generation and resolution alone is inadequate: one also needs \nto incorporate heuristics in order to obtain generic classes that are similar to what programmers would \nmanually produce. 9. CONCLUSIONS The next major release of Java will include support for generic classes. \nSince generics have software engineering and performance bene.ts, programmers may wish to con\u00advert their \nlegacy Java code to use generics. To aid in this task, we describe a system that automatically converts \nJava classes to use generics. This conversion has two parts: (i) de\u00adtermining the type parameters and \ntheir bounds to use for a generic version of a non-generic class; and (ii) rewriting clients of the newly-generic \nclass to pass appropriate type parameters to the generic class. Our approach handles both of these tasks \nusing the same basic mechanism, which is based on type inference. Our system analyzes one strongly connected \ncomponent of the class-dependency graph at a time. Thus, it can be used to convert a non-generic class \nto a generic class without knowing anything about clients of the class. We show that our system is e.ective \nin that it usu\u00adally produces the same output that an expert programmer would produce. 10. REFERENCES \n[1] O. Agesen. The cartesian product algorithm: Simple and precise type inference of parametric polymorphism. \nIn Proceedings of the 9th European Conference on Object-Oriented Programming, pages 2 26. Springer-Verlag, \n1995. [2] G. Bracha, M. Odersky, D. Stoutamire, and P. W. adler. Making the future safe for the past: \nAdding genericity to the Jav a programming language. In C. Chambers, editor, ACM Symposium on Object \nOriented Programming: Syst ems, Languages, and Applications (OOPSLA), pages 183 200, Vancouver, BC, 1998. \n[3] L. Cardelli and P. Wegner. On understanding types, data abstraction, and polymorphism. ACM Comput. \nSurv., 17(4):471 522, December 1985. [4] A. Diwan, K. McKinley, and E. Moss. Using types to analyze and \noptimize object-oriented programs. ACM Transactions on Programming Languages and Systems, 23(1):30 72, \nFebruary 2001. [5] A. Donovan, A. Kiezun, and M. D. Ernst. Converting java programs to use generic libraries. \nIn ACM Symposium on Object Oriented Programming: Systems, Languages, and Applications (OOPSLA), Vancouver, \nCanada, October 2004. ACM. To appear. [6] D. Duggan. Modular type-based reverse engineering of parameterized \ntypes in Java code. In Proceedings of the 14th ACM SIGPLAN conference on Object-Oriented Programming, \nSystems, Languages, and Applications, pages 97 113. ACM Press, 1999. [7] M. F\u00a8ahndrich and A. Aiken. \nProgram analysis using mixed term and set constraints. In Static Analysis Symposium, 1997. [8] J. Gosling, \nB. Joy, G. Steele, and G. Bracha. The Java Language Speci.cation Second Edition. Addison-Wesley, Boston, \nMass., 2000. [9] B. Meyer. Ei.el: a language and environment for software engineering. Journal of Systems \nand Software, 8(3):199 246, 1988. [10] B. Meyer. Ei.el: the language. Prentice-Hall, Inc., 1992. [11] \nR. Milner, M. Tofte, and R. Harper. The De.nition of Standard ML. MIT Press, Cambridge, Massachusetts, \n1990. [12] G. Nelson, editor. Systems Programming with Modula-3. Prentice Hall, New Jersey, 1991. [13] \nN. Nystrom, A. L. Hosking, D. Whitlock, Q. Cutts, and A. Diwan. Partial redundancy elimation for access \npath expressions. Software-Practice and Experience, 31(6):577 600, 2001. [14] R. O Callahan and D. Jackson. \nLackwit: A program understanding tool based on type inference, 1997. [15] B. Steensgaard. Points-to analysis \nin almost linear time. In Symposium on Principles of Programming Languages, pages 32 41, 1996. [16] F. \nTip, R. Fuhrer, J. Dolby, and A. Kiezun. Refactoring techniques for migrating applications to generic \njava container classes. Technical Report RC23238(W0406-045), IBM Research Division, June 2004. [17] F. \nTip, A. Kiezun, and D. B\u00a8aumer. Refactoring for generalization using type constraints. In ACM Symposium \non Object Oriented Programming: Systems, Languages, and Applications (OOPSLA), pages 13 26, Anaheim, \nCA, October 2003. [18] R. Vall\u00b4ee-Rai, P. Co, E. Gagnon, L. Hendren, P. Lam, and V. Sundaresan. Soot \n-a Java bytecode optimization framework, 1999.   \n\t\t\t", "proc_id": "1028976", "abstract": "<p>Generics offer significant software engineering benefits since they provide code reuse without compromising type safety. Thus generics will be added to the Java language in the next release. While this extension to Java will help programmers when they are writing new code, it will not help legacy code unless it is rewritten to use generics. In our experience, manually modifying existing programs to use generics is complex and can be error prone and labor intensive.</p> <p>We describe a system, Ilwith, that (i) converts non-generic classes to generic classes and (ii) rewrites their clients to use the newly generified classes. Our experiments with a number of Java container classes show that our system is effective in modifying legacy code to use generics.</p>", "authors": [{"name": "Daniel von Dincklage", "author_profile_id": "81100459374", "affiliation": "University of Colorado", "person_id": "P647140", "email_address": "", "orcid_id": ""}, {"name": "Amer Diwan", "author_profile_id": "81100202872", "affiliation": "University of Colorado", "person_id": "PP15025608", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1028976.1028978", "year": "2004", "article_id": "1028978", "conference": "OOPSLA", "title": "Converting Java classes to use generics", "url": "http://dl.acm.org/citation.cfm?id=1028978"}