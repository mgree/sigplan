{"article_publication_date": "10-01-1994", "fulltext": "\n GENERALIZED SUPPORT SOFTWARE: DOMAIN ANALYSIS AND IMPLEMENTATION EXPERIENCE REPORT SUBMITTED TO OOPSLA \n94 Mike Stark Ed Seidewitz NASA Goddard Space Flight Center Code 552.3 Greenbelt MD 20771 michael.e.stark@gsfc.nasa.gov \n/ (301)286-5048 ed.seidewitz@gsfc.naa.gov / (301)286-763 1 For the past five years, the Flight Dynamics \nDivision (FDD) at NASA s Goddard Space Flight Center has been carrying out a detailed domain analysis \neffort and is now beginning to implement Generalized Support Software (GSS) based on this analysis GSS \nis part of the larger Flight Dynamics Distributed System (FDDS), and is designed to run under the FDDS \nUser Interface / Executive (UIX). The FDD is transitioning from a mainframe based environment to FDDS \nbased systems running on engineering workstations The GSS will be a library of highly reusable components \nthat may be conjigured within the standard FDDS architecture to quickly produce low-cost satellite ground \nsupport systems. release is that this library 200,000 lines of code. The main driver for software is \ndevelopment The estimates for the first will contain approximately developing generalized cost and schedule \n improvement. The goal is to ultimately have at least 80 percent of all software required for a spacecraft \nmission (within the domain supported by the GSS) to be configured from the generalized components. Domain \nAnalysis The GSS domain analysis effort originally grew out of a study of the feasibility of generalizing \nthe attitude ground support systems (AGSSs) produced by the FDD for various spacecraft missions. FDD \nsoftware tends to be similar from mission to mission. An AGSS is used to determine the orientation of \na spacecraft from on-board sensor data and to compute maneuvers to change that orientation. It typically \nhas several executable programs that are used for specialized areas such as attitude estimation and sensor \ncalibration. These programs share models to varying degrees. For example, just about every FDD system \nhas an orbit propagator in it. Part of the domain analysis effort is intended to reduce overlap and redundancy \nbetween systems. As part of an ambitious project to re-engineer a majority of the FDD software systems, \nthe domain covered by the analysis was later expanded to also include a number of mission analysis and \nplanning functions. Indeed, at one point plans called for this project to eventually encompass all FDD \nfunctionality, adding orbit models to the attitude and mission planning functionality. Portland, OR October \n23-27, 1994 Project History The domain analysis effort began by studying the functional specifications \nof existing AGSSs. These specifications used data flow diagrams, so it was natural to adopt this technique \nfor the generalized domain model. However, the limitations of this approach soon became apparent, especially \nin the lack of classification techniques crucial to capturing generalizations. Despite the fact that \nmost of the people working on the effort were not particularly familiar with object-oriented approaches, \na consensus developed that object-oriented analysis would be a better technique than data-flow diagrams \nfor our purposes. Following this decision, we developed a Specification Concepts document [ Seidewitz \n9 l] that captured the object-oriented analysis approach used in subsequent analysis. Unfortunately, \nbudgetary pressures prevented the ambitions re-engineering plans from becoming reality. Further, the \nexpanding scope of the analysis effort became increasingly difficult to handle. Thus, the domain analysis \neffort was refocused generally to concentrate once again on the attitude support domain. The end effect \nwas that the domain analysis team did not increase as planned, leaving a small team to do the analysis \nover several years. The effort has specifically proceeded to focus in detail on the analysis of the first \ntwo GSS releases: telemetry simulation and real-time attitude determination, We have now completed two \nversions of the generalized specifications for the first release [Klitsch 931 and work is proceeding \non the specifications for the second release [Klitsch 941.  Specification Concepts The specification \nproducts of the domain analysis effort are all based on our standard specification concepts. Actually, \nthese specification concepts have continued to evolve based on our analysis experiences [Seidewitz 931. \nTh roughout this process there has been a continual tension between keeping the concepts as simple as \npossible and assuring that they are powerful enough to allow specification of domain functionality without \nundue complication. The core concepts of the model include the basic object-oriented principles of classes, \nobjects and messages. Additional concepts have been added to this core only when not including the new \nconcept would make it difficult or impossible to clearly specify some specific domain functionality under \nconsideration. For example, we have used only two levels of classification of objects. Each specific \nobject class belangs to exactly one superclass that represents a general domain category (e.g., a Sun \nSensor would be in the Sensor category). Further, superclasses only specify common interfaces, not common \nfunctionality, so there is no inheritance of functionality by subclasses. This restricted approach has \nallowed us to cleanly and simply introduce the required generalization concepts while maintaining the \nlocality of specification of the functionality of any class. The approach worked well through the first \nversions of our specifications. However, current work is indicating an increasing number of opportunities \nwhere deeper classification hierarchies would be useful, and we may add this to our concepts. Another \nrestriction in our concepts is that objects are not dynamically created or destroyed. InsteadI, objects \nand their interdependencies are specified as part of the configuration of an application. Once these \nobjects are created, they exist for the duration of the execution of the application. Data passed between \nobjects is not itself object-oriented, but is instead drawn from a set of standard data types (Integer, \nReal, Vector, Matrix, etc.). This approach provides us with a clear definition of configuration, which \nwas a topic of many long discussions. The resolution of these discussions was that the generalized specifications \ndeal exclusively with the definition of classes, while the configuration specifications deal exclusively \nwith the definition of the objects in an application. This philosophy also provides a fundamental connection \nto our implementation approach. Besides restrictions in using object-oriented, concepts, the specification \nconcepts evolved to eliminate unnecessary and sometimes complex concepts. For example, the original concepts \ncalled for modeling separate subsystems that only communicate via data objects. These subsystems were \nintended to be configured as separate exe&#38;table programs. This made it hard to specify models (such \nas estimation algorithms) that are usable in more than one subsystem (such as attitude determination \nand sensor calibration). The solution was to create a single domain map, and replace the subsystem driver \nwith application categories that provide the same set of actions to the UIX. These application categories \nalso map to separately configured programs, but can draw on classes throughout the domain map, instead \nof classes contained in a single subsystem.  Lessons Learned The current specifications are defined \nwith more detail and less ambiguity than the typical FDD specification documents. This has had a positive \nimpact on the development process, since class specifications are generally detailed enough to serve \nas PDL. However, these specifications are harder for the analyst to understand when specifying the configuration \nof an application program for a given satellite. The generalized specification document is currently \nweak at showing how an entire application would behave. One reason is that the specification effort has \nfocused the limited resources on producing class specifications to implement, at the expense of producing \ninformation that the analysts would use when defining a configuration. A more important reason is that \nFDD attitude and orbit analysts don t think in terms of objects, but in terms of algorithms such as a \nKalman Filter estimation algorithm. The concept of this algorithm can be expressed to the mathematician \nin 5 or 6 equations. To understand the GSS specification, the analyst needs to understand how several \nclasses contribute to the processing needed to implement these equations. The specification concepts \nneed to be updated to improve the description of how classes interact to support algorithm. Part of the \nanswer is to complete the intended documentation for each subdomain (major group of categories) to explain \nthese interactions. The concept of scenarios or use cases (as discussed by e.g. [Jacobson 921 ) may be \nappropriate for describing the overall behavior of an application. Another key lesson for domain analysis \nis that developers need to be involved in the process. This is primarily because the class specifications \nare written at a level of detail that often raises implementation issues such as performance. The GSS \nproject has always had developer involvement in the domain analysis process. This process may be improved \nby increasing this involvement, perhaps even evolving towards a joint analysis / development team. This \nis because as more classes are implemented the developers have a greater stake in making sure that new \nanalysis work won t have any negative effects on the existing class library.  Development The creation \nof a generalized design is made possible by the standardization of class specifications in the Specification \nConcept document, and by the standardization of the interaction between the UIX and the GSS application \n[Booth 931. The UIX drives application processing by calls to three operations provided by the application. \nThese operations allow the user to access and modify operations, or to execute the next action in the \napplication. The application may also send messages to the UIX. The key feature of a GSS application \nis that it is built from a library of classes, and can then be configured at run time. The run time configuration \nprocess includes allocating the objects for each class, setting the specific dependencies between objects \n(the generalized specifications define dependencies between classes, which are implemented at compile \ntime using the Ada generic parameters), and setting default parameter values. Implementation The classes \nin our generalized specifications are implemented as a set of two Ada packages. A class pockage implements \nan abstract data type representing the class, and an object manager package contains all the objects \nfor a given class, These classes are arranged in a hierarchy with category packages implementing the \ninterface for a specified category, and the Application Interface package implementing a root object \nthat dispatches to categories the operations to allocate objects, set dependencies and interact with \nparameters (instance variables). The bodies of the Portland, OR October 23-27,1994 category packages \nand the Application Interface package implement only dispatching code. All the functionality resides \nin class and object manager packages. Ada was chosen as a development language for two reasons. The organizational \nreason at the beginning of the GSS project the division had experience with several Ada simulators, C++ \nwas not considered mature technology by division management, and no other language met the need for \nobject orientation, support on a wide variety of platforms, and a core of experienced developers in the \nFDD. The technical reason was the use of generics to add flexibility to the configuration process. The \nGSS generic packages use both types (defining the class or category depended on) and subprograms (defining \nmessages sent to the class or category depended on). The configuration process consists of instantiating \nthe generics to set the dependencies between classes and categories and calling dependency operations \nto set the actual connections between objects. The use of generics allows categories dependencies to \nbe satisfied by classes, bypassing the dispatching code when it is not needed. This fact was important \nin addressing user concerns that the overhead of dispatching code would hurt run time performance. A \nclass can actually be instantiated using any class that provides the operations that are needed to match \nthe generic parameters.  Code Generation (Classgen) The code for the allocation, dependency and parameter \noperations is similar in structure from class to class, but each of these operations depends on the specification \nof the particular class. This means that the implementation code can not be written at the root of the \nclassification tree, but that there is still a lot of tedious repetition to the coding of classes. The \ndevelopment team s solution was to write a code generator (named Classgen) that reads in a concise notation \ndescribing class functions, dependencies and parameters. The output of the code generator is the implementation \nof all the functions specified at the Application Interface level, plus subprogram interfaces and stubs \nfor the constructors and selectors defined in the specification document. This was made possible by the \nexistence of a generalized design that mapped standard specification features into the Ada implementation. \nThe input language for Classgen also has features corresponding to those defined in the specification \nconcepts, and adds design features such as the error handling. The tool generates a type definition for \na class that contains all the parameters, internal data, and dependencies defined for the class, implementation \nof stubs for the functions in the specification, and implementation of the subprograms needed for allocating \nobjects, setting dependencies, and accessing or modifying parameter values. This code is about 75% of \nthe code needed to implement a class, with one line of Classgen input generating about 10 lines of Ada \ncode. Classgen generates all the code that can be generated based on the standardized specifications \nand design. The remaining code is the implementation of the functions specified for the class.  Classgen \nLessons Having a code generator has saved time and effort on the GSS project, but it has taken time for \nthe tool to mature. The main reason for this is that the initial concept was for Classgen to be run once \nper class to generate the code, and editing the created files after that. In practice it was necessary \nto edit the regenerated code, both because the generalized design evolved and required changes and because \nthe developers used the tool to regenerate files if there were substantial modifications to a class. \nThe problem was that the original version of Classgen required the developer to edit most of the files \ngenerated for a class. A notation was defined to mark these changes, but regenerating the class meant \nhaving to merge these changes into the new file. Classgen has been modified in stages so that in most \ncases the only file a developer edits is a separately compiled subunit file in which the specified functions \nare implemented. Changes to the other files still occur, but they are rare enough and small enough that \nthey don t have a major impact. These changes were generally made by extending the Classgen grammar, \nbut in some cases the generalized design was modified to facilitate code generation. A simple example \nof this was to move all with clauses (which define dependencies between Ada packages) into package specifications, \nand having all utility packages imported into a class be with ed into the Classgen input as well. This \nsometimes makes packages visible in a larger amount of code than strictly necessary, but it captures \nthe design information in the Classgen input and removes the need to edit files to add the importing \nof packages.  Process Lessons The use of standardized, object-oriented specification concepts has had \nseveral effects on development. We have already noted that the specifications are complete enough to \nserve as PDL. The specification of dependencies between classes, together with the generalized design \nfor dependencies, completely captures the system structure typically defined in preliminary design. The \ndevelopment of a build typically starts with detailed design of classes, which is expressed in terms \nof changes to the specification. Given this shift of design work to the domain analysis team, a joint \ndomain analysis and design team may be justified. This is particularly true once the class library is \npopulated and changes to the domain may have major effects on the existing code. Using object-oriented \nspecifications will enable incremental development. However, the flight dynamics domain is one where \na substantial number of core classes (integrators, dynamic models, environmental models,...) are needed \nbefore anything useful can be done. The builds are still being done incrementally, but a system that \nis testable by the end user won t be available until the third build is complete. The good news is that \nonce the first application is complete, added capabilities can be created in single builds. For example, \nthe first two releases of GSS will be delivering components to support simulation and real-time attitude \nestimation in a total of 5 builds. Adding the generalized components for non-real time estimation and \nfor sensor calibration will take one or two additional builds. Similar scale builds can be used to add \nnew models to the existing categories, or to expand into the orbit or maneuver planning areas. Thus design \na little, code a little, test a little will work for GSS, but only after a base of core classes has been \nimplemented. The integration of these generalized classes has been easier than for typical projects. \nThis is another benefit of having standard object-oriented specifications that clearly define internal \nand external interfaces, and a generalized design that standardizes the implementation of dependencies \nbetween classes. Together these factors assure that if a class depends on a given operation from another \nclass that class will provide the operation and the two classes will interface correctly.  Summary The \nlessons described above have been learned during the specification and the early development of the GSS \nproject. These lessons will be applied to further specification and development work. The initial releases \nwill be complete by the end of 1995, at which point the FDD will start seeing return on the investment \nin this project. References [Booth 931 E. Booth et. al., Flight Dynamics Distributed System (FDDS) Generalized \nSupport Software (GSS) Release 1 (GSSRl) Implementation Description , 552-FDD-93/068ROUDO (draft), October \n1993 [Jacobson 921 I. Jacobson et. al., Object-Oriented Software Engineering, Addison-Wesley 1992 [Klitsch \n931 G Klitsch et. al., Flight Dynamics Distributed System (FDDS) Generalized Support Software (GSS) Functional \nSpecifications (Revision l), 553-FDD-93/046RlUDO, June 1993 [Klitsch 941 G Klitsch et. al., Flight Dynamics \nDistributed System (FDDS) Generalized Support Software (GSS) Functional Specifications (Revision 1, Update \nl), 553-FDD-93/046Rl UD 1, December 1994 Portland, OR October 23-27.1994 [Seidewitz 911 E. Sedewitz et. \nal., Combined Operational Mission Planning and Attitude Support System (COMPASS) Specification Concepts, \n550-COMPASS-103, May 1991 [Seidewitz 931 E. Sel dewitz et. al., Flight Dynamics Distributed System (FDDS) \nGeneralized Support Software (GSS) Specification Concepts (Revision l), 553-FDD-93/057RlUDO (draft), \nAugust 1993  \n\t\t\t", "proc_id": "260028", "abstract": "", "authors": [{"name": "Mike Stark", "author_profile_id": "81100218836", "affiliation": "NASA Goddard Space Flight Center, Code 552.3, Greenbelt, MD", "person_id": "PP31095781", "email_address": "", "orcid_id": ""}, {"name": "Ed Seidewitz", "author_profile_id": "81100621844", "affiliation": "NASA Goddard Space Flight Center, Code 552.3, Greenbelt, MD", "person_id": "P74588", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260028.260081", "year": "1994", "article_id": "260081", "conference": "OOPSLA", "title": "Generalized support software: domain analysis and implementation: experience report submitted to OOPSLA'94", "url": "http://dl.acm.org/citation.cfm?id=260081"}