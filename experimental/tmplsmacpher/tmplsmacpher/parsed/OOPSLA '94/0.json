{"article_publication_date": "10-01-1994", "fulltext": "\n Mission-Critical Objects Kevin Pollari Andersen Consulting Abstract Developing a large utility Customer \nInformation System (CIS) involves significant risk due to broad scope, mission-critical functionality, \nand technical complexity. Many consider these characteristics best suited for a traditional development \napproach. Southern California Gas (SCG), like Brooklyn Union Gas, has pursued an object-oriented approach \nfor their CIS. SCG and Andersen Consulting are near the end of a three year development effort. We plan \nto meet the originally scheduled conversion date of September 1995. In this paper we discuss the key \nmanagement risks encountered, strategic decisions made, and lessons learned in three areas: 0 Software \nArchitecture . Macro Process and Team Organization . Development Methodology Business Context SCG, a \nLos Angeles-based subsidiary of Pacific Enterprises, is the largest natural gas distribution utility \nin North America. Three business factors drove SCG to initiate the CIS Project. First, deregulation has \ncatalyzed SCG to streamline for competitiveness. The new regulatory environment established by the California \nPublic Utility Commission (CPUC) introduced a myriad changes to the industry. SCG now faces a dynamic, \nmarket-driven environment with a critical timeline to react to competition. Second, SCG needs to provide \nflexible customer service and marketing. SCG has 4.7 million meters serving 16 million people. However, \nthe 2,000 largest industrial and non-core customers represent a disproportionately large, strategic portion \nof the business. Third, SCG needs to upgrade its systems infrastructure. SCG views the CIS as a strategic, \ncorporate asset required to support the business for lo-20 years. This degree of longevity requires a \ntechnology platform positioned for future growth. CIS Overview To address these business challenges, \nSCG initiated the CIS Project in September 1992. Specific objectives of the new CIS are to: a increase \nflexibility and configurability in the user interface, software, and data model . increase the efficiency \nand flexibility of marketing, billing, and collections . enhance training and productivity of users through \nan advanced user interface . provide a scalable client/server architecture to support long-term growth \nCIS will provide the following major, business functions: . billing and financial processing 0 customer \norders and service activities 0 credit and collections CIS will support 1500 diverse users ranging from \nhigh volume, order processing Customer Service Representatives (CSRs) to low volume case workers such \nas billing and marketing analysts. Portland, OR October 23-27,1994 CIS will consist of approximately \n270 windows, 350 tables, and 475 GB of application data. The technical architecture components include: \n. Intel-based 486 client workstations running OS/2, PARTS, and Digitalk SmalltalkN . a custom, message-oriented \nmiddleware layer developed in C using APPC and LU6.2 . an IBM mainframe running MVS, CICS and DB2 The \nCIS client/server architecture is based upon a distributed fimction model. The majority of the online \nbusiness logic (i.e., approximately 75%) resides on the workstation in Smalltalk. PARTS is being employed \nprimarily as a GUI builder tool. COBOL is the programming language on the mainframe. An important requirement \nof the CIS technical architecture is to support online response time of two seconds or less. This challenge \nis increased by the relatively high peaks in load that occur, for example, after an earthquake. Why \nObject? We did not originally view object-orientation as a primary goal. The user interface design initially \ndrove the consideration of object-orientation. Prior to the CIS Project kick-off, we developed a series \nof Graphical User Interface (GUI) design prototypes. The users found these initial attempts cumbersome \nand non-intuitive. Our breakthrough came when we transitioned from an application-centric to object- \ncentric GUI approach, based upon IBM s Common User Access (CUA) 9 1 User Interface Standards. Our revised, \nCUA-based GUI prototype was well received by the users. We chose Smalltalk primarily due to its capability \nto support these early GUI prototyping efforts. We still faced the decision whether to implement the \nmajority of online business logic procedurally or object-oriented. Long-term maintenance costs drove \nthe rationale to choose an object-oriented approach. Flexibility was a critical issue due to the CIS \nbusiness requirements including a changing marketplace, diverse customer base, and system longevity. \nWe repeatedly asked ourselves, What software architecture would produce the most stable model of the \nbusiness? Answering this question lead us to an object-oriented solution. Another key consideration was \nhow best to integrate with the traditional batch architecture being developed in parallel. We did not \nconsider object development for the batch system due to the additional risks related to performance (the \nsystem needs to produce 250,000 bills per night), team size, and object tools availability on the mainframe. \nOur architecture for reuse between online and batch is described below.  Software Architecture An important \ntechnical challenge was developing our application architecture, or framework [ 11. The CIS Framework \ndictates the domain-specific design and execution architecture of the application. We distinguish our \nCIS Framework from the CIS Technical Architecture, or middleware. The boundary between the two is basically \nthe Smalltalk image. The CIS Technical Architecture provides messaging, error handling, and other low-level \nservices. These services are implemented in C on the workstation and COBOL on the host. Application \nFramework Our approach followed principles of separation of concern along the lines of interface, control, \nand model [2]. The major CIS Framework components are described below (see Figure 1). The BIC layer, \nor Business Interface Component, captures and interprets user events from PARTS. Most of this layer is \neither provided by the architecture or generated through a custom tool we developed. The BEC layer, or \nBusiness Event Control, coordinates business events received from the BIC layer. Most of the business \nlogic is delegated to the Object Domain Model. The BEC provides a fairly narrow set of behaviors, which \nare critical to adequately decouple the interface from the model. The ODM layer, or Object Domain Model, \nrepresents the business model. Due to the size of our model, roughly 250 aggregate classes, we found \nit important to distinguish the most important 25-30 classes. These Focus Aggregates provide another \nlevel of event coordination and control, enabling better distribution of intelligence through the model. \nThe DEC layer, or Data Event Control, encapsulates the interface to the host. The DEC bundles data service \nrequests at run-time into a single transaction. These data service requests (e.g., retrieve, update) \nare issued by Request Classes for a particular aggregate or group of aggregates. This approach allowed \nus to avoid hard-coded transactions, yet maintain a transaction oriented interface to the mainframe. \nThe Context sub-system coordinates with application components to provide services including logical \nunit-of-work control, object identity and caching, and error handling.  Client/Server Architecture Perhaps \nour most difficult problem was how to architect the client/server interface to support persistence and \nremote business functions. This introduced several pragmatic concerns. Most important was the goal for \ntwo-second response time. Other considerations included mapping Smdlrslk c Figure 1 objects to DB2 tables, \noptimistic locking, and the reuse between batch and online. Early in design we tested persistence approaches \nwith significant performance prototyping. From this work we realized we could not embed SQL on the workstation, \nand thus would have to custom develop our data access services. This presented the problem of how to \narchitect the on-line mainframe modules. Our solution was to mirror the ODM on the host. The online host \narchitecture is comprised of object- based Aggregate Request Modules (ARMS). Every ODM aggregate (e.g., \nfacility, customer, meter) on the workstation has a corresponding ARM on the host. Each ARM provides \ndata access services for its corresponding aggregate. We used a similar architecture for Service Request \nModules (SRMs). SRMs provide an interface for host-based functions not performed by an ARM. A major intent \nof SRMs was to enable reuse between batch and online. A workstation aggregate can invoke a SRM through \na Service Aggregate. Whether the aggregate performed the service locally or remotely through the Service \nAggregate is considered private to the aggregate. Service Aggregates and SRMs thus mirror each other \nin the same way as Aggregates and ARMS. Portland, OR October 23-27,1994  Macro Process and Organization \nThe planning phases and team organization were critical due to the large size and duration of the project. \nOur three year development peaked at 55 people for the online effort and 200 people for the entire project \n(e.g., including batch, support, training, etc). Macro Process A conventional approach to project planning \nis the classic waterfall model. Benefits are clarity of work steps, control of the process (i.e., analyze, \ndesign, and then code), and well-defined review check points. A waterfall approach was also important \nfor us to stay synchronized with the traditional batch development proceeding in parallel. There are, \nhowever, well-documented problems with the waterfall model [4]. Our primary concern with the waterfall \nstemmed from the degree of change implicit in our approach. We knew we could not always get things correct \nthe first time with the high degree of invention in our technical architecture, methodology, and user \ninterface design. Our approach was to blend waterfall and iterative techniques. We based this on two \nconclusions: . different types of development tasks need to proceed at different rates from problem \ndefinition through solution . both top-down and bottom-up development models are important Most of \nthe development team followed a relatively top-down, waterfall approach analyzing and designing the business \nprocess, domain model, and user interface. Concurrently, an Architecture Team proceeded bottom-up building \nthe platform, technical architecture and frameworks (see Figure 2). We enabled iteration through multiple \npilot efforts coordinated by a Frameworks Team (see below). The frameworks and related pilot development \nflowed through three major iterations for each specific task (see Figure 3). I MidcJ.ws.-*dl * 1 Figure \n2 Figure 3  Team Organization The standard team organization for large projects is functionally partitioned, \ne.g., orders, credit &#38; collections. A key benefit of this approach is functional cohesiveness, integrity, \nand direction. Work goals are also easily defined, e.g., completing the window, front-to-back. We identified \nseveral problems with this approach such as how to: 0 enable object reuse across functional partitions, \nsince many key business aggregates are used in almost every single business event . support specialization \nof skills as people scaled the learning curve, since the front-end and back-end frameworks were fairly \ndistinct . ensure consistency and quality of methodology and architecture across teams The above issues \nlead us to an architecturally based organization (e.g., BICYBEC Team, ODM Team). This approach solved \nthe above issues; however, it introduced new ones. The problems with this organization were basically \nthe same points that were strengths of the functionally oriented approach (e.g., functional integrity, \nclarity of task partitions). Our resolution was to combine the two approaches into a matrix, workcell \napproach (see Figure 4). The workcell model ensured both functional integrity and work direction within \nthe cell, while maintaining quality, and consistency across cells, Sicnisn Figure 4  Development Methodology \nWe have developed a custom, hybrid methodology incorporating ideas internal to our companies as well \nas from diverse industry sources [2], [4], [5]. Developing a custom, hybrid approach added work and risk \nto our effort. We felt compelled to proceed with this approach for two reasons. First, due to our large \nteam size and application complexity, we needed a very detailed approach. We found that a large team \nwith varying technical experience needs a higher degree of rigor, specificity, and standards. It was \nimportant for us to customize the guidelines and standards to the architecture and problem-domain. Second, \nwe pursued a high degree of task codification to ensure improvements in quality and productivity. Furthermore, \nthe tasks performed by the BICYBEC role differed from that of the ODM role and the Frameworks role. We \nconcluded each needed slightly different techniques. BIUBEC Role Individuals performing BIC/BEC design \ntasks worked extensively with users to specify the functional requirements and user interface design. \nLater in the design phase they focused on dynamic modeling, making extensive use of state transition \nanalysis. This team comprised the least experienced object developers. Their methodology was the most \nrigorous and sequential in nature. ODM Role The ODM role in the cell was filled by people with some \nobject-oriented experience or extensive domain and data modeling experience. Early in design they drove \nout structural aspects including the class hierarchy and object aggregation. They also had primary responsibility \nfor complex behaviors. We partitioned their work by domain area and assigned ownership for classes. A \nBIC/BEC analyst would analyze a scenario to the point they required a complex business event (e.g., prorate \na read, write off bill). The BICYBEC analyst drove the requirements and public interface for the complex \nbehavior; the ODM analyst then drove the private design details. Online Host Role The Online Host people \nused a traditional methodology. A key difference was the degree of iteration and regression testing required \nto support many windows reusing the same service modules (ARMS and SRMs). In addition, planning for reuse \nof SRMs was particularly complex and required foresight and experience. Portland, OR October 23-27,1994 \n Frameworks Role The Frameworks Team comprised 5-7 of our most experienced, technical object-oriented \ndevelopers. This group drove out solution templates (i.e., patterns) for the initial hard problems [3]. \nThey would first scavenge for use cases [4]; then, they proceeded to develop, pilot, and roll-out the \narchitecture and methodology solution in parallel. The timing between use cases and frameworks was critical. \nDevelopment of the framework required use cases, however, the framework needed to be built and tested \nbefore implementing the use cases.  Summary We are well on our way to successfully delivering a large-scale, \nmission-critical system using object- oriented technology. The implementation learning curve has often \nbeen stressed as a key risk. Our experience has shown that the management and architecture strategies \nare much more important. The following are key conclusions for scaling up object techniques: 1) A consistent, \nunderstandable application framework is critical to success. 2) Resolving conflicts between performance, \nflexibility, and ease of use requires significant iteration and prototyping; a minimum of three iterations \nappears to be a magic number. 3) Managing iteration is difficult but possible. A useful strategy for \nlarge projects is to control iteration with a smaller frameworks team and selective pilot or scout efforts. \n4) A more sophisticated team organization, incorporating workcell concepts, is necessary. 5) Methodology \nsupport is key to developer productivity and quality; large teams require a higher degree of rigor and \nspecificity. Acknowledgments Debbie Taylor of The Southern California Gas Company provides overall project \ndirection. The management team also includes Paul Battles, Praful Pate1 and Asdrig Kerametlian of SCG, \nand Bob Delves, Bob Linka, Trent Mayberry, and Julienne Van Der Ziel of Andersen Consulting. Key team \nmembers providing architecture or development leadership include Jim Guth, Jim Conti, Michael Ljung, \nMatt Roche, Herag Haleblian, Paul Feuerbom, John Blong, Lance Starck, Vanessa Yuan, Shashi Sharma, and \nDan Giles. Trademarks SmalltalldV and PARTS are trademarks of Digitalk, Incorporated. OS/2, DB2, MVS, \nCICS,and CUA are trademarks of IBM Corporation. Other product names mentioned herein are used for identification \npurposes only, and may be trademarks of their companies. References [l] Ralph E. Johnson and Brian Foote. \nDesigning reusable classes. Journal of Object-Oriented Programming 1(2):22-35, June/July 1988. [2 Ivar \nJacobson, Magnus Christerson, Patrik Jonsson, and Gunnar Overgaard. Object-Oriented Software Engineering--A \nUse Case Driven Approach. Addison-Wesley, Wok&#38;ham, England, 1992. [3] Erich Gamma, Richard Helm, \nRalph Johnson, John Vlissides. Design Patterns, Elements of Reusable Object-Oriented Software. Addison-Wesley, \nReading, Massachusetts, 1995. ] Grady Booth. Object-Oriented Analysis r4 Design with Applications. Benjamin/ \nCummings, Redwood City, 1994. Second Edition. ] Rebecca Wirfs-Brock, Wilkerson, and Weiner. [5 Designing \nObject-Oriented Software. Prentice-Hall, Englewood Cliffs, NJ, 1990.  Contact Information Kevin Pollari \nAndersen Consulting 5215 North O Conner Blvd, #2100 Irving, TX 75039 214-444-3 168  \n\t\t\t", "proc_id": "260028", "abstract": "", "authors": [{"name": "Kevin Pollari", "author_profile_id": "81332521590", "affiliation": "Andersen Consulting, 5215 North O'Conner Blvd, #2100, Irving, TX", "person_id": "P161155", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260028.260077", "year": "1994", "article_id": "260077", "conference": "OOPSLA", "title": "Mission-critical objects", "url": "http://dl.acm.org/citation.cfm?id=260077"}