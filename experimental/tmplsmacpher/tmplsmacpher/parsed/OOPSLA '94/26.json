{"article_publication_date": "10-01-1994", "fulltext": "\n Subjectivity in Object-Oriented Systems Workshop Summary William Harrison, * Harold Ossher,* Randall \nB. Smith,? and David Ungart *IBM Thomas J. Watson Research Center P.O. Box 704, Yorktown Heights, NY \n10598 tSun MicroSystems Laboratories, Inc. 2550 Garcia Ave, Mountain View, CA 94043-l 100 Abstract . \nConstruction of large and growing suites of appli- Subjectivity in object-oriented systems is a new research \ncations manipulating shared objects. New applica-area. At this, the first workshop in this area, there \nwas tions often introduce the need for new extrinsic much discussion of fundamental concepts and issues, \nas properties and behavior that cannot be derived effi-well as of perceived needs for subjectivity and \nmodels for ciently, or at all, from the intrinsic properties andrealizing it. The discussion is summarized \nhere, and a list behavior. Different applications might even need to of issues that were identified \nduring the workshop is presented. classify the same objects differently. . Multiple views. An array \nof data, for example might be displayed as a histogram or as a pie chart. These 1. Introduction separate \ndisplays can be taken as different points of view on the same data. The display routines can be According \nto the accepted way of thinking about objects, directly associated with the array object, and can sometimes \ncalled the classical model [6], an object even have access to encapsulated state. They should encapsulates \nall its state and behavior. Ideally, the de- not be considered intrinsic properties of arrays,signer \nof an object (or class) defines and implements the however, and it should be possible to write them as \nintrinsic properties and behavior of the object, and all separate applications. other properties and \nbehavior required by clients can be . Versions. Different state associated with a single derived from \nthese using the public operations. object can be seen as a use of subjectivity. Users or applications \nmay find it convenient to pass around This classical ideal is inadequate to deal with situations or even \nstore a reference to a single object, without in which different, subjective views of shared objects \nare worrying about updating the reference to refer to the used in different parts of a system, by different \nusers, or latest version. One reference would suffice for all at different times. For example: versions. \n. Debugging, especially debugging code that the debugger uses. By giving the debugger a safe point of \nview on an application, it is possible for the debugger to be used on objects the debugger itself will \nuse. For example, window system code might be viewed from a stable, base point of view, while a programmer \nadopts a temporary, trial perspective where s/he makes speculative changes to the win- dow system. When \nan error arises, the programmer can run the debugger using window system code from the known, stable \npoint of view. Allowing objects to present multiple views to different clients [3.4,7] is a first step \ntowards subjectivity. The views must, however, either be implemented by the ob- ject designer as intrinsic, \nor be implemented as extrinsic in terms of already-available views. True subjectivity re-quires that \nthe separate views contribute towards or even constitute the definition of the object. This approach \nhas been taken in the past in some systems that are not object-oriented [1,2]. Support for subjectivity \nin a truly object-oriented setting has been addressed only recently [5,8]. It raises the promise of greater \nflexibility in writing, extending and combining object-oriented applications, and at the same time, many \ninteresting technical and even philosophical issues. This is a new area of research. The primary purpose \nof the workshop was, therefore, to facilitate exploratory discussion of the domain and identify some \nof the key concepts and issues. To this end, the workshop was structured as a morning of brief presentations \nto introduce ideas and to set the context, followed by an afternoon of discussion. This report summarizes \nthe morning presentations and the afternoon discussion groups, and concludes with a list of issues identified. \nFurther details are contained in the thirty position papers submitted to the workshop. 2. Morning Presentations \nIn the morning, there were seven short presentations of material drawn from position papers to help set \nthe con- text in terms of concepts, applications, and models and implementations. 2.1. Concepts David \nUngar and Randall Smith summarized the support that the language Us contains for subjectivity that allows \nan object to behave differently depending on the per- spective employed by the client. A perspective \nis formed by a series of layers, nested so that there is greater sharing and greater stability nearer \nthe core. Each layer contains a piece of each object in the perspective. Inheritance from inner layers \nexactly mirrors inheritance from parent objects. The perspectives are first-class computational elements. \nTwo significant issues raised by this approach are the problem of maintaining invari-ants when access \nto an object occurs through a perspec- tive not constrained by the invariant and the problem of what \nit means to copy or initialize an object which is in many perspectives. David Griswold presented an analysis \nof many of the abstract elements that make up a model of subjectivity. Since defining something which \nis relative to some observer , natural questions are: what is the something s identity, what is the observer, \nand how are they related? Once these questions are answered, the is- sues arise of where the objects \nbehavior and state are and whether the observer can be manipulated. Then one can ask whether the views \nare in the something or in the observer. If in the something , the elements of the view can be made available \nby visibility, by subtyping, or by adding to the base. These are called revealing, knowing, and burdening. \nIf in the observer, one can ask how much is in the observer s eye : behavior only, added state and behavior, \nor all state and behavior. The first of these are called intercepting. Depending on the relationship \nbe-tween the observer and the something , the second is either called inheriting or viewing. When all \nstate and behavior is in the observer, the third might be migrating if the same identity is used for \nthe object in both ob-servers or reparsing if even the identities are not preservable. In all cases where \nthe state is in the observer the problem of specifying identity must be addressed.  2.2. Applications \nHayden Lindsey reviewed the software development problems that motivate interest in subjective approaches. \nAs 00 approaches are being used for larger projects, they are being applied in multi-project development \nof sys- tems. This results both in overloading objects with the conceptual issues from a number of applications \nand also in overloading objects with the physical support for the many applications. One way of addressing \nthese over-loads is with refactoring, but refactoring of classes is hampered by lack of time and foresight. \nFurthermore, when extensions to object function for new projects re-quire more state, the development \nresponsibilities for the object become fragmented. Finally, there emerges a need for multiple versions \nof the same method from different development groups. These problems can be addressed to some extent \nin development environments; for exam-ple, in ENVY, behavior is spread across applications but adding \nstate must be done in the owning applica- tion. However, complex application development needs extension \nof the 00 paradigm to provide for first-class treatment of subjects (modules that use their own par- \nticular view of shared objects), for the ability to create customized views of class state (especially \nto eliminate state), and for the ability to specify like-named methods within several applications Dave \nCleal addressed the need for support for subjectivity to enhance reusability. The needs were re-cognized \nin analyzing why the expected benefits of re-usability did not emerge in the construction of a large \nsecurities management system. Many of the opportu-nities for reuse were frustrated by the need for different \nsize/performance tradeoffs resulting from the use of common function in different settings. For example, \nthe size and performance demands of trading tools which use security objects are high, and are satisfied \nby a class that has just a name and price, but analysis tools have complex time-projection capabilities \nand use a heavy-weight class for securities. Several approaches were in-vestigated for providing different \nviewpoints on the security: wrappers, containers, ENVY extensions and extrinsic views. Each of these \nhad several drawbacks. ENVY extensions, for example, can t multiply supply methods. Extrinsic views have \nproblems with identity, so that eventually the core had all the support for a mul- tiplicity of views. \nThe frequently suggested approach of using subclassing and mix-ins causes a combinatorial explosion in \nthe class hierarchy. Michael Vanhilst described his experience building an astronomical viewer. The original \ndesign had been pro- cedural and was suffering from many problems in making enhancements. He had tried \nto re-build it using 00 technology without promising results. The classes be- came too big, and useful \nfunctionality had to be removed because the 00 model made it too difficult to implement. An example is \nthe many-to-many mapping of windows to images. He is now trying to use subjective approaches to solve \nsome of these problems. One significant issue he has identified is that when aggregates of objects are \nused, the initialization order of visiting objects might have to depend on the subjects involved. He \nhas found a number of features of subject-composition helpful: composing aggregates, augmenting the attributes, \nchang- ing the behavior of methods by adding implementations, and class composition with partial mappings. \n 2.3. Models and Implementations Harold Ossher discussed the prototype he is building to support subjectivity \nand subject composition. This pro-totype emphasizes the use of subjects as a packaging construct and \nthe ability to compose binary subjects ob-tained from multiple sources. In WASP (the WAtson Subject-composition \nPrototype), a C++ program is com- piled by a tool called the C++ Subjectifier, to produce a binary subject. \nSubjectifiers can also be written for other languages. Binary subjects are put together using a tool \ncalled a Compositor. The compositor is language-independent and is responsible for the interchange and \ncomposition of binary subjects produced from multiple source languages. Different compositors can be \nwritten to support a wide variety rules for how composition is performed. To aid both the human developer \nand the compositor in composing subjects, each binary subject has a human-readable label that describes \nhow the bi- nary code in the subject is used to implement various interfaces on objects. It has several \nelements, including interface and class definitions, constraints on which classes this subject requires \nto support which interfaces (even though some of that support may come from other subjects), and a mapping \nspecifying which operation calls resolve to which (multiple) implementations in the binary code. Craig \nChambers described the ways in which Cecil con-tains support for subjectivity. Cecil is a pure 00 lan-guage \nwith multi-methods. The multi-methods are typically declared within scopes, but outside of the classes \nthemselves. Other aspects may also be declared separately, e.g. attributes. The scoping and multi-method \nmechanisms are introduced to localize extensions to individual libraries for purposes of encapsulation \nand simplicity. The concept of module is added to the language as packaging principle to define scopes. \nSym-bols can be explicitly imported from other modules using private declarations. An important issues \nis the visi- bility of a declaration. Visibility could be determined statically for type-checking or \ndynamically for method lookup. An important additional goal was to allow sub- classing to extend the \nsupport for a class without im-pacting its clients.  3. Afternoon Discussion Groups In the afternoon, \nthe participants selected four areas for discussion and separated into groups for that purpose. The four \ntopic areas were characterized as: Concepts and Terminology, Invariants, Models, and Models Meet Ap- \nplications. 3.1. Concepts and Terminology The discussion of Concepts and Terminology began by trying \nto clarify the differences in emphasis among two aspects of subjectivity addressed by the participants. \nOne aspect emphasizes the fact that the subjective result of a message send is determined by the perspective \nadopted by a client. The client adopts a perspective, and the be- havior depends only on its perspective. \nThe other aspect emphasizes the fact that the subjective result depends not only on the perspective adopted \nby a client, but on some composition of all the other perspectives which are ap-plied to the object at \nthat time. [Although not developed during the discussion, we will use the terms client subjectivity and \nparticipant subjectivity for these two aspects of subjectivity.] Some time was spent discussing the use \nof the term subject to stand for an orchestrated collection of per- spectives on many classes of objects. \nAlthough it is na- tural to see the term as reflecting subject as a domain of interest (e.g. the subject \nof physical modeling . . . ) its other common natural use as the object of interest (e.g. Lee was the \nsubject of several investigations . . . ) leads to confusion. It was explained that the term was originally \nchosen as a packaging term, not for single classes or objects, but as an alternative to tool or ap- plication \nwhich coordinate behavior on many objects. Subject connotes the perceiver of a subjective reality (in \nthe sense used by philosophers like Burke and Hume) rather than the object in an objective reality (in \nthe Platonic or Aristotelean sense). A second issue discussed was that of completeness. In client subjectivity, \na perspective is complete -all of the support needed for the behavior is present through the perspective. \nThe layers of a perspective are incomplete, but do not actually exist without their underlying layers. \nIn participant subjectivity, a perspective is complete with respect to definitions, but not implementations. \nIn other words, the subject defines a complete view of the world, but does not necessarily implement \nall of it; other sub-jects might supply essential and/or additional implemen-tations. A third issue \ndiscussed was whether subjectivity applies to individual instances or to whole classes. Client subjectivity \ntends emphasize support for subjectivity for individual objects while participant subjectivity empha-sizes \nclass-wide characterizations. A fourth issue is whether to embed the constructs in a programming language \n(like Us or Cecil) or in a module-interconnection language (like the Subject Label language). Discussion \nconcluded with the question of a litmus test to determine if a system provided real subjectivity. * Such \na test might have the form If I have an object and I send a message to it, is the message and object \nidentity enough to know the behavior? * As a sample point, a system was proposed in which a single application \nderives two different behaviors by being linked (composed) with either of two libraries. Although some \nfelt that the example wasn t even object-oriented, it could be viewed as a use of subjectivity because \nthe behavior is not determined solely by the objects involved, but also the provider-subjective libraries \nthat implement the function. 3.2. Invariants When working with a subjective model, an invariant be-ing \nmaintained by one perspective may not be maintained by another. For example, consider two perspectives \non a list in which one (#l) employs a count which always equals the number of objects in the list while \nthe other (#2) simply keeps the list itself. There are two imple-mentations of the method for adding \nto the list. In #l it also updates the count while in #2, the method has no awareness of the count. The \ninvariant problem arises from the client aspect of subjectivity, because the behavior of the object varies \nby client. Participant subjectivity attempts to remedy this by allowing the mere presence of a subject \nto cause in-vocation of that subject s behavior. This provides the hooks needed for a subject to maintain \nits invariants ir-respective of the client s subject. The invariant problem then arises only when the \ncomposition rules used exclude subjects that maintain invariants; this is the responsibility of the person \nperforming the composition, who is sup- posed to have a more global view of things. Two problems emerge \nwith respect to invariants: how to know there is a problem, and how to fix the problem. One approach \nto detecting a problem is to observe that any invariants involving instance variables present in only \none of the perspectives/subjects is problem-free, as are invariants present in all of the perspectives/subjects. \nHowever, potential problems can be flagged when an in- variant mentioning instance variables manipulated \nin se- veral perspectives/subjects is not present in all perspectives/subjects that have those variables. \nOne way to repair the invariant failure is to create a (#3) subject which merely updates the count when \nelement- adds are performed. The #3 subject is merged into the #2 subject using provider-subjective support, \nso that the required invariant is now true in the resulting composi- tion.  3.3. Models Four models \n(Us, Subject-Composition, Cecil, and Groups) were compared in three respects. With respect to problems \nand issues in construction, Us raises issues in the difficulty of interpreting the meaning of cloning \nwith respect to the object s pieces that are not in the perspective where the cloning is being performed. \nSubject-composition raises issues in initializing instance variables and in the meaning of deferred initialization. \nCecil also raises constructor issues, preferring default in- itial values to C++ constructors (as does \nsubject-composition). Finally, the group model performs initialization lazily because the group starts \nout empty by declaring its existence and then letting members join at leisure. With respect to the first-classness \nof perspectives, Us and Groups treat the sender s perspective as an element manipulated by the applications, \nwhile Cecil and Subject-composition are intended to have the existence of other subjects be transparent \nto the clients. Perspective shifts can be orchestrated by re-composing the subjects, but, generally, \nthis sort of computation would be outside the domain of most method implementations. Finally, with respect \nto how a message send is expressed, Us employs a dispatch to one target with the dispatch based on perspective \nand object. Subject-composition dispatches to many targets formed by method combina-tion with multi-method \ndispatch that might (but often does not) select based on the (implicit) client subject. In Cecil, dispatch \nis to one method with multi-method dis-patch based on scoping. In group models, messages sent to the \ngroup are multicast to all members of that group.  3.4. Models Meet Applications Much controversy was \nsparked by the summary which posed the question: Did any of the applications need Us s ability to compute \nwith perspectives as first-class elements, or is SELF enough? and the answer None of the applications \nseemed to need more than one object with many perspectives, so is any of this really needed? Several \npeople voiced the view that participant subjectivity answered their need for separate, decentral-ized \ndevelopment of applications that share objects. They reflected application domains including software \nrepre-sentation and communications system design. Although the original question was posed from the point-of-view \nof the run-time execution, issues of support for packaging and reconstruction were seen to be very important \nas well.  4. Issues The subfield of subjectivity in object-oriented systems is relatively new. A major \ngoal of the workshop was to identify issues that require further examination, even if there was not time \nfor solution or even discussion of all of them. The following is a list of such issues, presented here \nwithout discussion in the hope of sparking further interest, discussion and research. Concepts . What \nmakes a system truly subjective? . What is the difference between subjectivity and multiple views? . \nWhere are the objects behavior, state and identity? In the objects or in the observer? Where are the \n views? . Extensions of extensions? Perspectives of perspec- tives? . Client versus participant subjectivity \n(see above) . Instance versus class-based subjectivity Other kinds of subjectivity? Use/Requirements \n. Real-world, practical examples . Does/how does subjectivity allow enhanced reuse? . Different performance \nrequirements in different sit- uations can require radically different treatments of the same objects. \nIt is not always viable merely to merge functionality. . How can subjectivity be used to support the \nfollow- ing development needs: . decentralized definition of state and behavior . packaging of just needed \nclasses, methods and state . How can subjectivity be used to support the follow- ing structures: . multiple \naggregation hierarchies . windows with window-manager-dependent preferences structure . Granularity \nof perspectives: object; layer, module or scope; entire program? . Peer perspectives versus hierarchies \nof perspectives . Is there always one right hierarchy for a system? . Bundling of state and behavior \nMethodology . Notational devices for subjectivity . Analysis and design issues Semantics . Static versus \ndynamic definition of perspectives and their contents . Static versus dynamic composition . Invariants \nand consistency . Contracts and subjective viewpoints . Privacy/encapsulation . Are perspectives first-class? \nIf so, how should they be controlled? . If not, what are the limits? . Creation, initialization and copying \nof objects . Which perspective to use during evaluation . When to change perspectives . Static type checking \nof subjective code . Method combination across perspectives, including details ordering and handling \nof return values. . Managing name clashes across perspectives . Flexible mapping of instances across \nmultiple sub-jects: partial, many-many. . Implementation issues Relationship to Related Areas . Relationship \nbetween subjectivity and reflection . Can an object itself and the class that describes it s structure \nbe considered just different perspectives of the object? . Relationship between multi-methods and subjectivity \n. What can be learned about subjectivity in 00 from group models in distributed computing?  References \nGerard Boudier, Ferdinand0 Gallo, Regis Minot, and Ian Thomas. An Overview of PCIE and PCT E+. ln Proceedings \nof the ACM SIGSOFTISIGPLAN Sofhvare Engieering Symposium of Practical Soft-ware Development Environments, \npages 248-257. Boston, November 1988. ACM. PI David Garlan. Views for Tools in Integrated Envi-ronments. \nPhD thesis, Carnegie-Mellon University, 1987. [31I. P. Goldstein and D. G. Bobrow. An experimental description-based \nprogramming environment: Four reports. Techincal Report CSL-81-3, Xerox Palo Alto Research Center, March \n1981. [41Brent Hailpem and Harold Ossher. Extending ob-jects to support multiple interfaces and access \ncon-trol. IEEE Transactions on Software Engineering 16(11), pages 1247-1257, November 1990. PI William \nHarrison and Harold Ossher. Subject-oriented programming (a critique of pure objects). In Proceedings \nof the Conference on Object-Oriented Programming Systems, Languages and Ap- plications (OOPSLA 93), pages \n411-428, Washington, D.C., September 1993. ACM. Fl Object Management Group. Object Management Architecture. \nGuide, second edition, September 1992. OMG TC Document 92.11.1. 171John J. Shilling and Peter F. Sweeney. \nThree steps to views: Extending the object-oriented paradigm. In Proceedings of the Conference on Object-Oriented \nProgramming: Systems, Languages, and Applications, (New Orleans), pages 353-361, Octo-ber 1989. ACM. \nPI Randall B. Smith and David Ungar. A simple and unifying approach to subjective objects. Self Group \nTechnical Report, Sun Microsystems Laboratories, Inc.. 1994. \n\t\t\t", "proc_id": "260028", "abstract": "", "authors": [{"name": "William Harrison", "author_profile_id": "81385594269", "affiliation": "IBM Thomas J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY", "person_id": "PP74022713", "email_address": "", "orcid_id": ""}, {"name": "Harold Ossher", "author_profile_id": "81100333974", "affiliation": "IBM Thomas J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY", "person_id": "PP39038143", "email_address": "", "orcid_id": ""}, {"name": "Randall B. Smith", "author_profile_id": "81406594842", "affiliation": "Sun MicroSystems Laboratories, Inc., 2550 Garcia Ave, Mountain View, CA", "person_id": "PP79024540", "email_address": "", "orcid_id": ""}, {"name": "David Ungar", "author_profile_id": "81100365263", "affiliation": "Sun MicroSystems Laboratories, Inc., 2550 Garcia Ave, Mountain View, CA", "person_id": "P64183", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260028.260179", "year": "1994", "article_id": "260179", "conference": "OOPSLA", "title": "Subjectivity in object-oriented systems", "url": "http://dl.acm.org/citation.cfm?id=260179"}