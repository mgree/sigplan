{"article_publication_date": "10-01-1994", "fulltext": "\n Composition of Before/After Metaclasses in SOM Ira R. Forman Scott Danforth Hari Madduri IBM Object \nTechnology Products 11400 Burnet Road Austin, Texas 78758 Abstract In SOM, the IBM System Object Model, \na class is arun- time object that defines the behavior of its instances by creating an instance method \ntable. Because classes are objects, their behavior is defined by other classes (called metaclasses). \nFor example, a Before/After Metaclass can be used to define the implementation of classes that, by suitable \nconstruction of their instance method tables, arrange for each invocation of a method to be preceded \nby execution of a before method and followed by execution of an after method. This paper introduces and \nsolves the problem of composing different Before/ After Metaclasses in the context of SOM. An enabling \nelement in the solution is SOM s concept of detived me-tuclasses, i.e., at run-time a SOM system derives \nthe ap- propriate metaclass of a class based on the classes of its parents and an optional metaclass \nconstraint. Introduction One interpretation of the history of programming is that progress is made by \nproviding abstractions to ever larger entities and by ensuring the composability of those ab- stractions. \nIn the beginning, assembly language instruc- tions were gathered into control structures. Subsequent-ly, \ncontrol structures were gathered into procedures, and this was followed by the gathering of procedures \ninto ab- stract data types. Now we have arrived at Object-Ori- Permission to copy without fee all or \npart of this material is granted provided that the copies are not made or distributed for direct commercial \nadvantage, the ACM copyright notice and the trtle of the publication and Its date appear, and notice \nis given that copying is by permission of the Association of Computing Machinery. To copy otherwise, \nor to republish, requires a fee and/or specific permission. OOPSLA 94- lo/94 Portland, Ore on USA @ 1994 \nO-89791 -688-3194 0010..$3.50 ACM 7 ented Programming, where abstract data types are gath- ered into \nan inheritance hierarchy. This paper addresses a further abstraction, Before/After Metaclasses, and solves \nthe problem of their composi- tion. A Before/After Metaclass has a before method and an ufrer method \nthat are executed before and after the methods of the instances of its instances (an instance of a metaclass \nis a class, which in turn has instances). Ap-plications for Before/After Me&#38;classes abound, e.g., \nmethod tracing, invariant checking, path expression checking, object locking, etc. Given these opportunities, \nit is imperative that Before/After Metaclasses compose. This paper solves the Before/After Metaclass \nComposi- tion Problem in the context of the IBM System Object Model (SOM). SOM is an objectoriented model \n[7,17,22,23]. The SOM runtime supports the model and allows programs written in arbitrary languages to \nuse the model via the SOM API. A binding is code that facili- tates the use of a class or the implementation \nof a class. The SOMobjects Toolkit [24] provides both usage and implementation bindings for C and C++; \nalso, language vendors for Smalltalk (Digitalk), Cob01 (Mircofocus), and C++ (IBM, Metaware, and Borland) \nhave an-nounced support for SOM in their products.  The SOM Model In SOM, classes are objects whose \nclasses are calledme- taclasses. A class is different from an ordinary object be- cause a class has (in \nits instance data) an instance method table defining the methods to which instances of the class respond. \nDuring the initialization of a class object, a method is invoked on it that informs the class of its \npar- ents. This allows the class to build an initial instance Figure 1 method table. Once this is done, \nother methods are in- voked on the class to override inherited methods or add new instance methods. When \ndiagramming class hierarchies, this paper uses the convention that metaclasses are drawn with three con-centric \ncircles, ordinary classes (i.e., classes that are not metaclasses) are drawn with two concentric circles, \nand ordinary objects (i.e., objects that are not classes) are drawn with a single circle. The initial \nstate of an example SOM program is depicted in Figure 1. There are four ob- jects SOMObject (a class), \nSOMClass (a metaclass), Dog (an ordinary class), and Rover (an ordinary object). There are two relations \namong objects that one must un- derstand. First, there is the instance ofrelation between objects and \nclasses depictedby the dashed arrow from an object to its class. When convenient the inverse relation, \ncEass of, is alsoused. SOMObject is aninstance of SOMClass and 0 ordinary class object J SOMClass is \nthe class of itself. An object s class is im- portant because an object responds only to the methods \nthat are supported by its class (that is, the methods that the class introduces or inherits). Second, \nthere is a relation between classes called the sub- class of relation, which is depicted by the solid \narrow from a class to each of its parents. SOMClass is a sub- class of SOMObject . SOMObject has no parents. \nSOMObject introduces the methods to which all SOM objects respond. In particular, SOMObject introduces \nthe somDispatch method. This method provides a single, general dynamic dispatch mechanism for execut- \ning method calls on objects. Furthermore, a class can ar- range its instance method table so that all \nmethod calls are routed through somDispatch. As a result, it is sim- ple for SOM metaclass programmers \nto arrange for com- pletely arbitrary processing in connection with method invocations on SOM objects. \nAs a subclass of SOMObject, SOMClass is an object but in addition introduces the methods to which all \nclasses respond. For example, SOMClass introduces the somNew method, which creates instances of aclass. \nAlso, the methods responsible for creating and modify- ing instance method tables are introduced. All \nmeta- classes in SOM are ultimately derived from SOMClass. (Similar arrangements of classes is also used \nin CLOS[12], ObjVlisp[S], Dylan[2], and Proteus[21].) With the SOM API, one can create new abstractions \nby programming metaclasses. In more general terms this has been referred to as a metaobject protocol \n[ 12,131 or computational reflection [ 151. The strength of this gener- al approach is that new abstractions \ncan be created after the object model is implemented. That is, the BeforelAf- ter Metaclasses are not \npart of the SOM kernel, rather they are part of a framework for programming meta-classes (see [9] for \nmore information) that is built with the SOM API. Thus, by providing ametaobjectprotocol, we were able \nto a new abstraction to SOM. Interfaces to SOM objects are described using IDL, an object interface definition \nlanguage defined by the Com- mon Object Request Broker Architecture (CORB A [ 161) standard of the Object \nManagement Group (OMG). SOM IDL is a CORBA-compliant version of IDL used to allow SOM class descriptions \nto be supplied in addi- tion to object interface definitions. (That is, the interface to a class is described \nby the IDL alone, SOM IDL allows additional information about the implementation to be added.) The SOMobjects \nToolkit has tools called emit- ters that translate SOM IDL into language-specific bind-ings for the corresponding \nclasses of SOM objects (e.g., for C programmers this means that emitters produce header files for both \nthe users of the class and the imple- mentor of the class). Below is the basic structure of an IDL definition \nfor an object interface named Dog. At the same time, it is a SOM IDL description of a class Dog that \nsupports this interface. The #ifdef and #endif (which, for simplicity, are omitted from subsequent examples) \nare part of the IDL language and are used to hide the SOM class imple- mentation section from non-SOM \nIDL compilers. interface Dog : SOMObject { method and attribute declarations here #ifdef -SOMlDL- implementation \n{ metaclass = SOMClass; instance variable declarations here 1. #kndif 1; In this example the interface \nDog inherits from the SO- MObject interface, and at the same time, the class Dog is declared to be a \nsubclass of SOMObject . CORBA and SOM support multiple inheritance; additional parents of Dog can be \nlisted alongside SOMObject in a comma- separated list. The actual methods and instance variables of Dog \nare not relevant to the current discussion. As illustrated here, the implementation section can ex- plicitly \nindicate a metaclass to be associated with the class of objects that support the interface being defined. \nThis association is not necessarily direct, however. For reasons that will become clear, the actual class \nof the class described by any given SOM IDL is, in general, a subclass of the indicated metaclass.  \nBefore/After Metaclasses A before method is a behavior that precedes the action of some program construct. \nAn after method is a behavior that succeeds the action of some program construct. Be-fore and after methods \nare familiar to users of CLOS [ 12,191, where the granularity of application is the indi- vidual method. \nIn the class-based object model SOM, the more natural granularity for before/after methods is the class, \nbecause there are many applications that fit this granularity (see next section). The SOMMBeforeAfter \nme&#38;lass therefore introduces two methods BeforeMe-thod and AfterMethod that its instances (classes) \nar-range to run respectively before and after each instance method. By default, these two methods do \nnothing -to define a specialized before/after behavior, one creates a subclass of SOMMBeforeAfter and \noverrides the Befo- reMethod andthe AfterMethod withthe desiredbehav- ior. interface BarkingDog : Dog \nsomDispatch ( self, primaryMethod, . . . ) { /* no method declarations */  implementation metaclass \n= Barking; /* no instance variables */ 1; I; SOM P BeforeAfter Dog P Figure 2 For example, consider the \narrangement in Figure 2. The Barking metaclass overrides BeforeMethod andAfter- Method with a method \nthat makes a woof sound when executed. As a result, all methods supported by the class BarkingDog (an \ninstance of Barking) have this before/ after behavior. That is, the object Lassie goes woof before and \nafter each method invoked on it runs, because it is an instance of BarkingDog. The IDL for the Bar- kingDog \nclass is given at the right of the figure. Note that the IDL is the only source code that needs to be \nwritten; the compiler of the SOMobjects Toolkit can generate from IDL all the necessary code to implement \nBarking-Dog (in either C or C++). The essence of the workings of SOMMBeforeAfteris a method that overrides \nthe method somDispatch introduced by SOMObject. 1 The new dispatcher looks like this: Those readers \nnot familiar with SOM may skip this note. Actually, BeforeMethod( class(self), self, primaryMethod, . \n. . ); retval := primatyMethod( self, . . . ); AfterMethod( class(self), self, primaryMethod, retval, \n. . . ); return retval; where primaryMethod is the methodbeing invokedon a target object (e.g., Lassie) \nfor which before/after behav- ior is desired. Note that in the psuedo-code used in this paper, the first \nparameter to a method invocation is al- ways the target object. The ellipses represent all the other \nactual parameters to the method. As noted earlier, the metaclass ofthe object Lassie supports BeforeMethod; \nthat is, the class BarkingDog responds to BeforeMe- thod. This is why, inthe abovepseudo-code, class(self) \nis the target object for the BeforeMethod and AfterMe- thod method invocations.  The Usefulness of Before/After \nMetaclasses Before attacking the problem of composition of Before/ After Metaclasses, let us pause to \nconsider their useful- ness. As mentioned earlier, CLOS has the notion of be- fore/after methods, but \nour experience indicates that the more useful granularity for a class-based object model is the class. \nFoote and Johnson [lo] advocate class-level granularity. So does Pascoe [20] (but his encapsulators apply \nto all method invocations on a class instance rather than a class). This is also the granularity used \nby the De- meter system [14] (which does the implementation by source code transformation). Software \nengineering of classes has many examples of usesof before/after methods. Method tracing is a prima- ry \nexample of a useful software engineering tool that fits naturally into the before/after paradigm at the \nclass gran- ularity. Another example is invariant checking; one for the sake of efficiency, methods in \nSOM are usually invoked directly and the somDispatch method is not generally called. In this scheme the \nSOMMBeforeAfter metaclass ar-ranges for somDispatch to be invoked by placing stubs in the method table \nto call somDispatch (this capability is part of the SOM API). The SOMMBeforeAfter metaclass also arranges \nthat the contents of the original method table be saved so that somDispatch can invoke the primary method. \nIn addition, the SOMMBeforeAfter metaclass ensures that somDispatch does not dispatch itself (which would \ncause a dispatch loop). The details of how this is done are very specific to the SOM AI 1 and beyond \nthe scope of this paper. More information on the SOM AI 1 may be found in [24]. SOMMBeforeAfter SOMMTraced \nFigure 3 could imagine a metaclass which checks the invariant supplied by the class programmer as a method \non the class. In addition to its reusability, such a metaclass would have the advantage of ensuring that \nthe invariant is checked when new methods are added to the class. Other types of verification and monitoring \nare also feasi- ble (for example, path expressions [4] or behavioral ex-pressions [ 11). Concurrency \nyields other opportunities to use Before/ After Metaclasses. For example, one can factor atomic- ity \ninto a metaclass; the before method acquires a sema- phore and the after method releases the same semaphore. \nIn addition, we have found that Before/After Meta-classes provides a convenient way to offer framework \ncapabilities to customers. The SOMObjects Toolkit con- tains a framework for creating replicated objects \n[24]; this framework has a set of rules for conveying the repli- cated property to a class. Basically \nthe rules require the locking a set of replicas prior to an update, followed by the propagation and unlock \nafter the update (the objec- tive is to ensure one-copy serializability). The majority of the work required \nby this set of rules can done by a Be- fore/After Metaclass. We have used SOMMBeforeAf-ter to construct \nmetaclasses for both tracing and replica- tion (Figure 3). We have seen that other frameworks in the \ntoolkit could similarly be aided. Elsewhere, a detailed example of how to use a metaclass in CLOS to \nmake a class persistent is given in [18]. Suppose one wishes to provide a class li- brary that has n \nclasses. In addition, suppose there are p properties that must be included in all combinations for Fierce \nBarking FierceDog BarkingDog w w Figure 4 all classes. Potentially, the library must have n2Pclasses. \nLet us hypothesize that (fortunately) all these properties can be captured by before/after metaclasses, \nthe size of the library is n+p. The user of the library need only pro- duce those combinations necessary \nfor his applications. This problem is one faced by users of some object-ori- ented databases and has \narisen in the design of the OMG Persistence Standard [6]. When one considers this situa- tion, one obvious \nconclusion is unavoidable: Before/Af- ter Metaclasses are not useful unless they compose, be- cause if \nnot, the use of one Before/After Metaclass would preclude the use of others. (Of what good is a trace \nmeta- class, if it cannot be used to debug instances of the repli- cable metaclass?)  The Composition \nProblem Now, consider Figure 4 in which there are before/after metaclasses Barking (as before) and Fierce, \nwhichhas a BeforeMethod and AfterMethod that both growl. That is, both make a grrrr sound when executed. \nIt should be clear that we can now create a FierceDog or a Bar-kingDog, but we have not yet addressed \nthe question of how to compose the properties of fierce and barking. Composability means having the ability \nto easily create a FierceBarkingDog that goes grrr woof woof grrr when it responds to a method call, \nor a BarkingFierce-Dog that goes woof grrr grrr woof when it responds to a method call. The problem of \ncomposing the properties of fierce and barking is complicated by the fact that there are several ways \nin which one might express such compositions. instance of this new me&#38;class (that is, FE1 ) should \nbe a Figure 5 depicts three techniques in which such a com- FierceBarkingDog (if Dog is a parent). position \nmight naturally be indicated by a programmer. In Technique 2, a new class is created that has parents \nThese are labelled Technique 1, Technique 2, and Tech- that are instances of Fierce and Barking respectively; \nnique 3, which create the FierceBarkingDog classes that is, FB-2 should be a FierceBarkingDog too (as- \nnamed FB-1, FB-2, and FB-3, respectively. The SOM suming FierceDog and BarkingDog do not further spe- \nIDL for each of these classes is given above a diagram cialize Dog). that depicts the context in which \nthe class description is given. In Technique 3, FB-3, which should alsobe a Fierce-In Technique 1, a \nnew metaclass (FierceBarking) is Barking Dog, is created by a declaring that its parent is a created \nwith both Fierce and Barking as parents; an BarkingDog and that its explicit (syntactically de- Techniaue \n1 Techniaue 2 Techniaue 3 interface FB-1 : Dog interface FB-2 : FierceDog, interface FB-3 : Barking-1 \nBarkingDog Dog /* no method declarations 1 { */ /^ no method declarations /* no method declarations implementation \n*/ ^/ i implementation implementation metaclass = FierceBark- { 1 ing; /* no instance variables ^/ metaclass \n= Fierce; I* no instance variables *l 1; /* no instance variables */ 1; 1; 1; SOMMBeforeAfter SOMMBeforeAfter \nSOMMBeforeAfter Fierce Barking Fierce Barking Fierce Barking Y z: Y Dog I I . . . . \\ 0Dog FierceBarking \nv . .. . . . . . \\ . . . . \\ . . . \\ 2 BarkingDog F&#38;l FierceDog Barkingbog a Figure 5 clared) \nmetaclass (drawn with the light dashed arrow) is Fierce. Looking at Figure 5, we ask the question: should \nthe three techniques produce the same result? That is, should FB-1, F&#38;2, and FB-3 be equivalent classes \n(that is, behave the same and have instances that behave the same)? The answer must be YES because com-position \nof metaclasses must be easily understood by the programmer. Non-equivalence of these three tech-niques \nwould certainly lead to a system in which pro- gramming is complex and error-prone. This conclusion leads \nus to ask what common property these techniques have upon which an equivalence may be based. There is \nsuch a property, and, as described in the following sec-tion, SOM provides special support for it. The \nDerived Metaclass in SOM SOM allows and encourages the definition and explicit use of metaclasses. At \nthe same time, however, SOM re- lieves programmers of the responsibility for getting the metuclass right \nwhen defining a new class. At first glance, this might seem to be merely a useful (though very important) \nconvenience. But, in fact, it is absolutely essential in SOM. This is because SOM is predicated on binary \ncompatibility with respect to changes in class im- plementations. Even though aprogrammer might, at one \ntime, know the metaclasses of all classes above a new interface B:A { implementation { metaclass= BMeta; \n subclass, and, as a result, be able to explicitly derive an appropriate metaclass for the new class, \nSOM must guar- antee that this new class still executes correctly when any of its ancestor class s implementations \nare changed (and this could include a choice of different me&#38;classes). Thus, a SOM programmer never \nneeds to consider a newly defmed class s ancestors metaclasses. Instead, explicit metaclasses should \nonly be used to add in de-sired behavior for anew class. Anything else that is need- ed is done automatically \n[12]. To understand this better, consider the simple single-in- heritance example illustrated by Figure \n6. In this figure, A is an instance of AMeta; we assume that AMeta sup-ports a method bar and that A \nsupports a method foo that uses the expression bar( class( self ) ). That is, the method foo invokes \na method on the class of the object on which foo is operating. Now consider what happens when A is subclassed \nby B, a class that has an explicit metaclass declared in its SOM IDL as in Figure 6. If the class hierarchy \nwere to be formed as in Figure 6, then an invocation of foe on an instance of B would fail because BMeta \ndoes not support bar. This situationis referred to the as metaclass incompatibility. SOM does not allow \nhierarchies with metaclass incompatibilities. Instead, SOM builds derived metaclasses that prevent this \nprob- lem from occurring. The actual SOM class hierarchy that results for B is depicted in Figure 7, \nwhere SOM has Figure 6 Figure 7 automatically built the me&#38;class DerivedMetaclass; this ensures \nthat the invocation of foo on instances of B do not fail. This example shows that the metaclass state- \nment in the SOM IDL is treated as a constraint on the ac- tual metaclass. The derived metaclass can be \nviewed as the minimal metaclass supporting the constraints of me- taclass compatibility. Several papers \n[3,1 l] have called this situation the me- taclass compatibility problem, but none go beyond a characterization \nof the compatibility condition required on the metaclass statement. In SOM there is no such problem; \nin a situation where the explicitly declared dAe- &#38;class is not compatible with the parents of the \nclass, an appropriate metaclass is constructed -this is the derived metaclass. Because class construction \nis a dy- namic activity in SOM, this derivation is actually accom- plished at run-time with no need for \nprior description in IDL. 2  The Composition Solution We now return to an examination of the techniques \nin Figure 5. Here, the derived metaclass constructed by SOM for FB-3 will be FierceBarking, not Fierce \nas indicated in the SOM IDL. Now look at the diagram for Technique 2 of Figure 5; here also, although \nthe meta- class of FE2 is not explicitly declared, the derived me- taclass providedby SOM for FE2 will \nbe FierceBark-ing. Figure 8 combines the diagrams in Figure 5 and shows the actual class relationships \n(which are established when the class objects are instantiated). Note that the ex- plicit metaclass in \nthe SOM IDL of FB-1 is its derived class FierceBarking; the derived me&#38;class of FB-2 is also FierceBarking. \nHowever, the derived metaclass of FB-3 is not the explicit metaclass in the SOM IDL, rath- er it too \nis FierceBarking. The solution to the composi- tion problem jumps out at us. The common element among \nthe three techniques for expressing before/after composition is the metaclass FierceBarking, which is \ntheclassofFB-l,FB-2,andFE3(inthecaseofF&#38;l the relationship is explicit and in the cases of FB-2 and \nFB-3 the relationship is derived). Therefore we con- clude: composition can be based on the completed \nme-taclass hierarchy that results from the use of derived me- taclasses in SOM. Now that the general \nnature of a common solution has been presented, it remains to discuss the details of this solution. By \nthe nature of before/after, the main dispatch function is changed to look like this: somDispatch ( self, \nprimaryMethod, . . . ) BeforeMethodDispatch( class( class ( self )), self, . . . ); retval := primaryMethod( \nself, . . . ); AfterMethodDispatch( class( class ( self )), self, . . . ); return retval; where primaryMethod \nis the identifier of the method being invoked by the application and acquiring before/ after behavior. \nTo produce an appropriate composed or-der of before method invocations, BeforeMethodDis-patch does a \npreorder traversal of the metaclass hierar- chy towards SOMClass looking for the first metaclass oneachpaththatdeflnes \nBeforeMethod;eachsuch Be- foreMethod is then invoked on the client object. The BeforeMethodDispatch implementation \nthus looks like this: BeforeMethodDispatch( aMetaclass, clientobject, . . . ) if aMetaclass defines BeforeMethod \nBeforeMethod( clientobject, . . . ) else for all parents of aMetaclass that support BeforeMethod BeforeMethodDispatch( \naParent, clientobject, . . . ) The search restriction to met&#38;asses that support Befo-reMethod is \nbased on the fact that a before/after meta-class may have parents that are not before/after meta-classes \n(i.e., parents that are not descendents of SOMM-BeforeAfter). Note that if the metaclass of the client \nob- 2 CLOS does not allow the construction of me&#38;lass incompatibilities. When a class is constructed \nvalidate-superclasses is called to ensure that all superclasses have the same metaclass as the class \nbeing constructed (see [19] page 84 or [12] pages 240-241); if this condition is not true, an error is \nsignalled. 434 Figure ject defines a BeforeMethod, the search succeeds and only one BeforeMethod is \ncalled. The rationale for this is simple: the creator of a before/after metaclass knows the parents of \nthis metaclass, and, when overriding Befo-reMethod, can be expected to explicitly invoke any in- herited \nfunctionality that is necessary (using parent method calls). l%e AfterDispatchMethod is quite similar \nexcept that the parents are traversed in the reversed order. The Af-terDispatchMethod implementation \nlooks like this: AfterMethodDispatch( ahnetaclass, clientobject, . . . ) if aMetaclass defines AfterMethod \nAfterMethod( clientobject, . . . ) else for all parents of aMetaclass that support AfterMethod (in reverse \norder) AfterMethodDispatch( aParent, clientobject, . . . ) BeforGAfter Figure 9 One final issue remains \nto be addressed: What class introduces the methods BeforeMethodDispatch and AfterMethodDispatch? These \nare methods to which all subclasses of SOMMBeforeAfter respond 3 ; thus the answer is that they must \nbelong to the class of SOMM-BeforeAfter. Therefore, as shown in Figure 9, the class of SOMMBeforeAfter \nbecomes the metaclass SOMM-BeforeAfterDispatcher. One might call SOMMBefo-reAfterDispatcher a metemetuclass \nbecause its instances are metaclasses. Figure 9 thus replaces Figure 3, in terms of an overall class \ndesign. Loose Ends The facility described in this paper has been available in- side of IBM since August, \n1993; for example, the traced metaclass is used in parts of the SOMobjects lbolkit (version 2.0). The \nfacility will have general availability as part of SOMobjects Toolkit (version 2.1). Before con- cluding, \nthere are several issues to address, which for the sake of ease of presentation have been ignored until \nthis point. First, our solution to the composition of Before/After Metaclasses has a pleasant property; \ncomposition is associative. Figure 10 shows three Before/After Meta-classes A, B, and C that introduce \nthree before methods respectively (Before1 , Before2, and Before3). Meta-class F represents the composition \n(AB)C and G repre-sents the composition A( BC) .Both compositions lead to the same sequence of before \nmethod invocations (that is, Before1 ;Before2;Before3). Of course, compositionis not commutative, e.g., \na FierceBarkingDog is not the same as BarkingFierceDog (which goes woof grrrgrrr woof ). The order of \nthe metaclasses depends on the search order which is determined by the order of the par- ents. SO tdP \nBeforeAfter Before3 Figure 10 Second, there is the issue of exempting a method from the before/after \nbehavior. We have seen situations for different before/after methods that range from exempt- ing a particular \nprimary method to exempting a particu- lar kind of method (e.g., read-only methods) to exempt- 3 We \nsay that an object responds to a method. Thus, all objects respond to the methods supported by its class. \nIf the object is a class, the class inherits the methods supported by its parents, but responds to the \nmethods supported by its metaclass. ing all methods inherited from a particular parent. We have found \nthat the simplest solution is to have the de- signer of the particular Before/After Metaclass deter- \nmine the scheme for method exemptions. Usually this comprises of the introduction (by the metaclass design- \ner) of a predicate method to be called by the BeforeMe- thod and the AfterMethod; if the predicate returns \ntrue, both wrapper methods return without doing anything. Third, for the sake of simplicity of discourse, \nthe before (after) dispatch method (presented above) does not check whether the before (after) method \nhas already been executed during the search of the metaclass hierar- chy. (For example, if in Figure \n10 one adds an H as a sub- class of both F and G, all the before methods are executed twice.) There are \na number of techniques to solve this problem. So far, no case has arisen where it is desirable to have \nmultiple executions of before/after methods. Another issue is having the before method determine that \nthe primary method should not be run. To handle this case, the before method is extended to return a \nboolean to the dispatcher, which contains true if the primary method is to be run. If the primary method \nis not run, neither is the corresponding after method. Because the before and after methods belong to \nthe same metaclass, the before method can do any tidying up the after method might have been required \nto perform (this obviates the need to communicate to the after method that the primary meth- od was not \ninvoked).  Before/After Metaclasses in CLOS Although CLOS has multi-methods (and is not a language \nin which classes are thought of as containing methods), a comparison is instructive. The language- defined \ngranularity of application for before/after behav- ior in CLOS is the method. That is, one may define \na method with a qualifier (either :before or :after); such qualified methods are invoked before and after \nprimary methods of similar applicability. This granularity has its uses, but does not qualify as de- \nfining an operation on classes, which is one of the objec- tives of this paper. Our position is that \nbefore/after meth- ods come in pairs that are applied over all methods of a class. Of course, this comparison \nis too superficial, be- cause the advantage of having a metaobject protocol in CLOS lies in the ability \nto define a similar operation to the one we have defined here using SOM. The two fea- tures of CLOS that \nare most relevant are the call-next- method method and the apply-methods function. In CLOS, all ancestor \nclasses are kept on a list, called the classprecedence list. One uses call-next-meth- od to invoke the \nmethod with the same name (as the currently executing method) from the next entry in the class precedence \nlist. This is the approach used by CLOS for calling parent methods in a multiple inheri- tance model. \nThe well-known problem with this is that the ordering of the class precedence list is fixed even though \ndifferent methods may require different execution orderings for parent s implementations. In SOM, much \nas in C++, the programmer identifies the specific parent(s) whose code should be invoked. In the CLOS \nmetaobject protocol, all method invoca- tions are dispatched by the apply-methods function (see [12]page43). \nThisfunctioninvokesthe :before methods, then the primary methods, and finally the :aftermethods. Here \n:before and:afterarethemeth-od qualifiers that indicate the position of the method in the dispatch order \nwith respect to the primary methods. Note that there is one apply-methods function for the entire program \n(where as in SOM, each class has its own somDispatch method). These differences between SOM and CLOS \nmean that the natural solutions to implementing before/after class behavior in CLOS looks different than \nthe natural solu- tion for SOM that is presented in this paper. One CLOS-natural approach to having before/after \nclass behavior might look as follows. . At class instantiation time, one could use the cur- rent mechanism \nof CLOS to apply the class s before/after method to all primary methods of the class. This leaves open \nthe problem of how the class-level before/after methods should be speci- fled, but let s not worry about \nit. Composition is achieved if the before/after pairs are applied in the same order, because one of the \nCLOS functions that controls method dispatch (apply-methods) reverses the order of execution of the after \nmeth- ods. If one desires to have preemption (as de- scribed in the previous section), apply-methods \nwould have to be further modified. An additional design issue in this solution concept is that of en- \nsuring that dynamically-added methods (methods added after class instantiation) receive the before/ after \nmethods. Two other possible CLOS approaches suggest them-selves. . Because all method invocations in \nCLOS are dis- patched through apply-methods , before/after methods for classes could be implemented in \nCLOS by changing apply-methods to invoke the BeforeMethodDispatch before apply-methods and the AfterMethodDispatch \nafterwards. Of course, this requires that derived metaclasses be adopted by CLOS in order to use the \nmetaclass hierarchy to determine the before/after behavior. . Because of the way call-next-method works \nin CLOS, another scheme is possible. Suppose for the moment that each CLOS class has a dispatch meth- \nod, CLOSDispatch, i.e., all method invocations for a class first call the CLOSDispatch method which in \nturn invokes the primary method. This could alsobe effected with a change to apply-methods to call CLOSDispatch \nto invoke the pri- mary method. Based on this change, one could im- plement composition of Before/After \nMetaclasses in CLOS by overriding CLOSDispatch with (defun CLOSDispatch ( . . . ) (BeforeMethod . ..) \n(call-next-method) (AfterMethod . ..)) This scheme allows the before/after behavior to be inherited from \nclasses that override CLOS Dis- patch; composition is attained from the way call-next-method chains its \nway up the class hierar- chy. This approach has the disadvantage of not allowing the overriding of either \nbefore methods or after methods. Although neither of these approaches could be called CLOS-natural (because \nthey adopt CLOS to use fea- tures of SOM), they isolate two ways in which the SOM solution differs from \na CLOS solution. Conclusions The central issue addressed by this paper is raising the level of programming \nby composing metaclasses. The standard notion of inheritance-based subclassing repre- sents aunion-like \noperation for composition of class im- plementations. There is no reason to believe that one such operation \nis sufficient for all the possible composi- tions that need to be performed. With the approach de- scribed \nhere, we believe that significant object properties can be implemented using before/after metaclasses \nand that these properties can be subsequently composed. Linguistically, a property is often represented \nby an ad- jective while a class is represented by a noun. Composi-tion of metaclasses should be as easy \nas putting a se- quence of adjectives in front of a noun when we speak. Acknowledgements Mike Conner \nand Larry Raper are the designers of the SOM model and API; their insight in providing SOM with metaclasses \nprovides the basis upon which we worked. We wish to thankLiane Acker, Gregor Kiczales, and Harold Ossher \nfor their comments on earlier drafts of this paper. In addition, the comments of the OOPSLA referees \nwere very valuable and greatly appreciated. References 1. Atkinson, C. Object-Oriented Reuse, Concur-rency \nand Distribution: An Ada-based Ap-proach Addison-Wesley (1991). 2. Apple Computer DyEan: An object-oriented \ndy- namic language (1992).  3. Briot, J.-P and Cointe, P. Programming with Explicit Metaclasses in Smalltalk- \nOOPSLA 89 Conference Proceedings (October 1-6, 1989) 419431. 4. Campbell, R.H. and Habermann, A.N. The \nSpecification of Process Synchronisation by Path Expressions Lecture Notes in Computer Science Volume \n16, Springer-Verlag (1974) pp. 89-102. 5. Cointe, P Metaclasses are First Class: the Obj- Vlisp Model \nOOPSL.4 87 Conference Proceed- ings (October 4-8, 1987) 156-165.  6. Copeland, G. private communication \n1994. 16. 7. Danforth, S. A Bird s Eye View of SOM IBM OS/2 Developer (Winter 1992). 8. Danforth, S. \nand Forman, I.R. Derived Meta- classes in SOM Proceedings ofthe I994 Confer- 17. ence on Technology of \nObject-Oriented Lan- guages and Systems Versailles, France (April 1994) 18. 9. Danforth, S. and Forman, \nI.R. Reflections on Metaclass Programming in SOM OOPSLA 94 Conference Proceedings (October 23-27, 19. \n1994). 10. Foote, B. and Johnson, R.E. Reflective Facili- ties in Smalltalk- OOPSLA 89 Conference 20. \nProceedings (October l-6, 1989) 327-335. 11. Graube, N. Metaclass Compatibility OOPSLA 89 Conference \nProceedings (October l-6, 1989) 305-316. 21. 12. Kiczales, G., des Rivieres, J., and Bobrow, D. G. The \nArt of the Metaobject Protocol The MIT Press, Cambridge, Massachusetts (199 1). 13. Kiczales, G. andpaepcke, \nA. Open Implementa- tions and Metaobject Protocols The MIT Press, 22. Cambridge, Massachusetts (1994). \n14. Lieberherr, K.J. and Xiao, C. Object-Oriented Software Evolution IEEE Trans. on Software 23. Engineering \n19(4) (April 1993) 313-343. 15. Maes, P. Concepts and Experiments in Com- 24. putational Reflection OOPSLA \n87 Conference Proceedings (October 4-8, 1987) 147-155. Object Management Group The Common Ob- ject Request \nBroker: Architecture and Specifica- tion OMG Document Number 91.12.1 Revision 1.1. OS/2 Technical Library \nSystem Object Model Guide and Reference Document SlOG6309, IBM Corp., Armor&#38;, N.Y. (1991). Paepcke, \nA. PCLOS: A Critical Review OOPS- LA 89 Conference Proceedings (October l-6, 1989) 221-237. Paepcke, \nA. (ed.) Object-Oriented Program- ming: The CLOS Perspective The MIT Press, Cambridge, Massachusetts \n(1993). Pascoe, G.A. Encapsulators: A New Software Paradigm in Smalltalk- OOPSLA 86 Con- ference Proceedings \n(September 29 -October 2, 1986) 341-346. Russinoff, D.M. Proteus: A Frame-Based Non- montonic Inference \nSystem Object-Oriented Concepts, Databases, and Applications Kim, W. and Lochovsky, F.H. (ed.) ACM Press, \nNew York (1989) 127-150. Sessions, R. and Coskun, N. Object-Oriented Programming in OS/2 2.0 IBM PersonaE \nSys- tems Developer (Winter 1992). Sessions, R. and Coskun, N. Class Objects in SOM IBM OS/2 Developer \n(Summer 1992). SOMobjects Developers Toolkit - User s Guide and Reference Manual IBM Corp., Armor&#38;, \nN.Y. (1993). \n\t\t\t", "proc_id": "191080", "abstract": "<p>In SOM, the IBM System Object Model, a class is a run-time object that defines the behavior of its instances by creating an instance method table. Because classes are objects, their behavior is defined by other classes (called metaclasses). For example, a &#8220;Before/After Metaclass&#8221; can be used to define the implementation of classes that, by suitable construction of their instance method tables, arrange for each invocation of a method to be preceded by execution of a &#8220;before method&#8221; and followed by execution of an &#8220;after method&#8221;. This paper introduces and solves the problem of composing different Before/After Metaclasses in the context of SOM. An enabling element in the solution is SOM's concept of <italic>derived metaclasses</italic>, i.e., at  run-time a SOM system derives the appropriate metaclass of a class based on the classes of its parents and an optional metaclass constraint.</p>", "authors": [{"name": "Ira R. Forman", "author_profile_id": "81100212249", "affiliation": "IBM Object Technology Products, 11400 Burnet Road, Austin, Texas", "person_id": "P116725", "email_address": "", "orcid_id": ""}, {"name": "Scott Danforth", "author_profile_id": "81100337977", "affiliation": "IBM Object Technology Products, 11400 Burnet Road, Austin, Texas", "person_id": "PP39038338", "email_address": "", "orcid_id": ""}, {"name": "Hari Madduri", "author_profile_id": "81100078739", "affiliation": "IBM Object Technology Products, 11400 Burnet Road, Austin, Texas", "person_id": "P107468", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/191080.191148", "year": "1994", "article_id": "191148", "conference": "OOPSLA", "title": "Composition of before/after metaclasses in SOM", "url": "http://dl.acm.org/citation.cfm?id=191148"}