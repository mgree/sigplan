{"article_publication_date": "10-01-1994", "fulltext": "\n Managing an Object-Oriented Project Using an Iterative Approach Perry Rotella Pharmaceutical Industry \nPractice American Management Systems (703)267-2266 perry~rotella@maiI.amsinc.com Abstract Managing large \nsystems development projects has never been easy. Object technology projects face the difficulties of \ntraditional projects, plus some new challenges of their own. Many of the new challenges come from object \ntechnology s emphasis on iterative development rather than the traditional waterfall model. Others come \nfrom object technology s emphasis on component reuse throughout all levels of the system-from infrastructure, \nto business rules, to user interface. This paper describes a milestone delivery approach that one AMS \nteam used to control the iterative development of a large object project. The approach divides the development \ninto milestone releases every two to three months. Each milestone delivered a working system to the client. \nEarly milestones delivered infrastructure and basic functionality while later ones delivered a more complete \nsystem. A layered object architecture provided a framework for extending functionality over successive \nmilestones. The team also used several tactics for managing reuse development. First, the team organized \nto support reuse. Second, standards and conventions provided control for a large group of programmers. \nThird, mini-releases kept the whole team marching forward together. Finally, regression testing ensured \nthat objects worked consistently throughout development. Large Systems Development Problem Large systems \ndevelopment has always been complex and difficult. A large project team typically must sort through a \nmaze of complicated business requirements, implementation options, and technical hurdles. In our project \nexample, a large health care provider contracted with AMS to develop a financial system to support order \nentry, billing, claims production, accounts receivable, and customer service applications. We partnered \nwith our client to organize a team of over fifty people to develop this system in a client server architecture \nusing C++ as the primary development tool. The initial estimate for complete system delivery was about \nthree years. This type of large-scale systems development is not easy to manage. The development team \nneeded an approach to make the problem more manageable.  Milestone Delivery Solution First, we divided \nthe system scope into several twelve month phases. lhis allowed the team to reduce risk by shortening \nthe development lifecycle. We could also deliver some benefits earlier than would be possible with a \nwaterfall approach. Earlier delivery also builds business support for the effort. Second, the team adopted \na milestone approach to system delivery. The first phase consisted of a twelve month development effort \nthat contained four milestones. Each milestone took two to three months to complete. This allowed the \nteam to further reduce the development effort into smaller, more manageable releases and receive valuable \nclient feedback earlier. Early milestones provided basic functionality. Later ones represented a more \ncomplete system. For example, we developed an order entry application. In the first milestone the application \nconsisted of basic data entry that saved and retrieved orders. We added order validation during the second \nmilestone. During the third milestone, we extended the application to support entry of clinical information \nsuch as the patient diagnosis. At the end of the last milestone, we had a polished application. Objects \nProvide a Framework Objects provided an excellent framework for milestone development because they can \nbe extended easily. The project team developed a three-layered object architecture as described in figure \n1. Presentation Business Data Access  Layer Layer Layer Figure 1. Layered Object Architecture The bottom \nlevel is the data access layer that consists of objects that interact with the database. In our case, \nwe developed classes that interacted with Sybase stored procedures. The next level is the business layer. \nThese objects provided the application data and business logic. The top level was the presentation layer \nthat consisted of the Windows applications and forms that presented information and function to users. \nThe layers provided the capability to further break the development problem into smaller, structured \ncomponents. Developers could extend functionality easily throughout each layer of the object architecture. \nFor example, during one milestone, the team added patient diagnosis to the order entry system. We could \nadd methods to the data access layer to invoke Sybase stored procedures to insert and update diagnosis \ninformation. Then we could add business object methods to support diagnosis functionality. Finally, we \ncould add GUI controls to the presentation objects to provide the interface functionality to users. \n Keys to Success The milestone approach has three keys to success. First, we spent time at the start \nof the project defining the entire system scope in terms of a general design and high-level architecture. \nThe main purpose of this is to &#38;fine a complete vision of the system. This ensures that the individual \nmilestones fit together to match the entire system vision in the end. We then scheduled the delivery \nof each scope requirement in a particular milestone. Second, you must develop your architecture in early \nmilestones to reduce costly revisions later in the development cycle. Architecture enables functional \ncapabilities. For example, we used state transition to model the health care application. Therefore, \nit was important to build a state processor during the first milestone. Otherwise, we would need to retrofit \nstate processing later which would be undesirable. Finally, the team needed a way to control the iterative \ndevelopment. We accomplished this by defining steps to milestone delivery. Milestone Steps Figure 2 presents \nthe development steps that the team took during each milestone. The team s objective was to iterate within \neach step to avoid going back to a previously completed step. Like a staircase, going back several steps \ncan be a drain on resources. ild Business Layer Figure 2. Milestone Steps The first step in a milestone \nis to review the scope for each application to determine the functionality needed for the current milestone. \nOne way the team managed the scope was through the user expectations document, which the client prepared \nto describe each scope function in detail. Next, the developer creates a prototype of the application \nand designs the current functionality. Once the client signs off on the design, the developers make database \nchanges and modify the business objects. Next, applications can be assembled from the business object \ncode. Finally, the team integrates the applications and delivers them to the client. The next milestone \ntakes the same classes and starts the process over from the first step.  Challenge of Reuse Milestone \ndelivery alone does not ensure the success of an object technology project. The emphasis on reuse creates \nunique challenges for the development team. The promise of reuse lies in the image of many well- tested, \nreusable objects sitting on the shelf of the project s class library. However, today s reality is that \ndevelopers must build rather than buy reusable components. On our project, we developed on top of the \nMicrosoft Foundation Classes (MFC). The MFC provided acceptable Windows functionality, but the team needed \nto build frameworks to support the type of online transaction processing that the application required. \nDeveloping reuse is hard to do for several reasons. Reuse development creates substantial dependencies. \nAlso, synchronizing common objects that are developed by a large team is difficult. Reuse Creates Dependencies \nThe challenges of managing reuse vary based on the following: 1. the type of reuse; 2. the complexity \nof the object s behavior; 3. the layer in the object architecture.  Reuse from contained objects is \nprimarily a matter of defining simple, stable interfaces, and communicating within the team. In contrast, \nreuse from inheritance requires continual, iterative analysis in order to abstract common behavior to \nthe right level of the hierarchy. Derived classes are also directly dependent on the proper functioning \nof their base class. Reuse of objects with limited or focused behavior (such as GUI controls, dates, \netc.) is usually straightforward compared to complex business objects. Business objects usually have \na wide range of process-specific behavior that the team must accept as a standard if reuse is to work. \nReuse at the presentation level often affects only a subset of the system s business functions and can \nbe managed within a specific team. In contrast, reuse at the lower levels of the architecture can impact \nthe entire system-forcing a focus on early definition of stable interfaces, tight control across the \nentire team, and major regression testing requirements. Synchronization is Hard Having a good deal of \ncommon code presents another new responsibility; when you have a large team developing common code, you \nneed to make sure that everyone s code is synchronized. The dependency network in Figure 3 illustrates \nthe problem. Five developers are working on various components of the system, but are dependent on each \nother for pieces. Addendum to the Proceedings OOPSLA 94 As development moves forward, each person is \nworking on outdated code while enhancing their own classes. When all points come together, the results \ncan be surprising due to the many potential points of failure. Figure 3. Object Development Interdependencies \nAnother significant synchronization point is the database. During the course of development, the database \nschema grows. The development team adds attributes to the schema. They also need to reflect these same \nattributes in the system s objects. For example, suppose the physician class needs to support a new requirement \nto state the physician s medical school degree on a claim form. The physician class developer needs to \ndo three things to support the new requirement: 1. add the new attribute to the schema;  2. add methods \nto the physician class to retrieve; 3. set the attribute, and test the changes.  To accomplish this, \nthe developer needs a database against which to test this change while other developers are working without \nthis addition. A second developer who is making a change to the patient class compounds this problem. \nThe last thing a project manager needs is a situation where every developer has their own version of \nthe database schema!  Tactics for Managing Reuse Development The project team used four tactics for \nkeeping object reuse development under control: + Project Organization + Standards and Conventions \n+ Mini-Releases + Regression Testing  Project Organization When structuring your development team, \nyou need to define strong senior roles for planning and controlling functional and technical reuse across \nthe system. Figure 4 illustrates the structure for the project team: Figure 4. Project Organization The \napplication architect leads the Reuse Team and is responsible for coordinating all business object definition \nand database releases. During the project the reuse team built the applications to maintain the primary \nbusiness objects. The technical architect leads the Technical Architecture Committee, which consists \nof members from each application team. This team is responsible for developing standards and conventions, \naddressing implementation issues, and ensuring the consistent use of classes. The Application Teams, \nwhich were organized along functional lines, interfaced with users and developed application functionality. \nEach development team included people possessing expertise in each layer of development. For example, \nthe Windows expert develops the Windows application while the Sybase expert writes the underlying stored \nprocedures to retrieve data from Sybase. The application teams also owned the business objects that were \nclosely related to their applications. The Quality Assurance (QA) Team is responsible for standards \nand testing the applications. An important note is that QA is a peer with development, so the QA group \nhas adequate independence to monitor application development. Standards and Conventions Standards are \ncritical to the success of any large development project. Reuse makes this even more true for object \ntechnology systems since developers rely so heavily on objects developed by others. Naming conventions \nfor objects and methods help developers find the reusable component they need. Consistent coding conventions \nmake it easier for developers to understand reusable objects and find the specific behavior they need \nto use or change. For example, when a developer initializes a particular business object, it is beneficial \nthat the initialization proceeds in the same way as for all other business objects. Graphical user interface \n(GUI) standards not only perform the traditional role of ensuring a consistent interface to the users, \nbut also support development of reusable screen controls and overall structures for view objects. This \nmakes it easier for developers to assemble screens from reusable components. Finally, table and data \naccess standards and conventions make it easier for developers to translate between the object structure \nof the application a relational database. Mid-Releases We managed the synchronization problem by bringing \ndevelopers together frequently with mini- releases. The mini-release consisted of the current system \nversion number (from PVCS, a version control system) and a system build in which all of development comes \ntogether. We scheduled system builds twice per week (Figure 5). The system build was complete when all \nregression tests were successful. October 1994 I 30 31 Figure 5. Frequent mini-releases keep the project \nsynchronized Each feature in the system would have a target mini- release. If a developer missed a particular \nsystem build, the feature would simply be incorporated during a future release. This allowed sufficient \ntime for a developer to thoroughly test out changes before rolling them out to the whole team. Coordination \nis key to keeping the development team synchronized. The technical architecture committee cleared and \nscheduled all changes to base classes and common classes. Also, a special mini-release is scheduled for \nthe entire development team to move up to a new database schema. Database changes involved a three step \nprocess. First the team made minimal changes to the data access (stored procedures) so that the rest \nof the team could implement the schema change. For example, the medical degree attribute is added to \nthe physician table. The team changes the physician stored procedure to insert a valid physician. Next \nthe team does a system build to insure that the application continues to work with the modified database. \n Addendum to the Proceedings OOF SLA 94 Finally, the team can update the objects to support management \nchanges and hard work to achieve the new database features. success. It is not easy, but it can be managed \nwith the right approach and project organization. The Regression testing resulting benefits make it worth \nthe effort. Mini-releases are not enough to ensure stability throughout development. Developers are constantly \nenhancing the same objects each milestone. They need a method by which to insure that the Milestone 1 \nfunctionality still works with the Milestone 3 classes. The way to make sure this happens is through \nrepeatable, automated regression testing. The project team must develop regression tests for component \nclasses all the way up to the Windows applications. The development team should also work closely with \nthe QA team. As developers add functionality to objects, the QA team adds regression test suites. Figure \n6 illustrates the addition of test suites as methods are completed. Figure 6. Regression test suites \nare over time. Automated tools can assist in this area, but testing is still challenging. For instance, \nthe team used tools such as SQA Team Test for GUI regression testing. We still found it difficult to \nautomate Windows application testing early in development since the interface changed frequently. The \nteam also developed a tool in C++ to test business objects.   Conclusion The project team has experienced \nbenefits from object technology development and reuse. Object technology shows great promise as the technology \nand our approach mature and as our reuse libraries grow. However, it is a technology that requires some \n \n\t\t\t", "proc_id": "260028", "abstract": "", "authors": [{"name": "Perry Rotella", "author_profile_id": "81332524523", "affiliation": "Pharmaceutical Industry Practice, American Management Systems", "person_id": "P223407", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260028.260093", "year": "1994", "article_id": "260093", "conference": "OOPSLA", "title": "Managing an object-oriented project using an iterative approach", "url": "http://dl.acm.org/citation.cfm?id=260093"}