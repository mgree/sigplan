{"article_publication_date": "10-01-1994", "fulltext": "\n The Object Engine: Foundation for Next Generation Architectures Workshop Organizers Fred Cummins Roman \nCunis cummins@ae.eds.com rc@ maz-hh.de EDS Artificial Intelligence Services MAZ GmbH 5555 New Ring Street \nHarburger Schlossstrasse 6- 12 Troy, Michigan 48098 D-2 1079 Hamburg, Germany (810) 696-2016 +49-40-76629-2641 \nFAX: (810) 696-2325 FAX: ++49-40-76629-199  Introduction At the OOPSLA 93 workshop on next generation \nlanguages, participants recognized the need for a system architecture with a common object engine on \nwhich multiple paradigms could be built as extensions. This object engine would provide the core facilities \nof an extended object paradigm. The goal of this OOPSLA 94 workshop was to define the scope, functionality \nand interface of the object engine. The challenge is to achieve a proper balance between the functionality \nof the object engine and the flexibility needed to support and evolve multiple paradigms. In the following \nsections, this report will describe the motivation for this work, highlights of the workshop discussion, \nand the results. Motivation There is a growing interest in open-ended, extensible, and adaptable systems \nand architectures in the object-oriented and artificial intelligence (AI) communities. Object-oriented \ntechnology raises the potential for large-scale, seamless integration of diverse functionality, including \nAI. As we have applied object-oriented technology to larger and more complex systems, we have realized \nthe need for capabilities not readily supported by current object-oriented programming environments. \nDepending upon the language, some capabilities can be developed as application components or language \nextensions. However, other capabilities may be difficult to implement, they may add undesirable overhead, \nand ad hoc approaches may conflict with integration and sharing of independently developed components \nor applications. The concept of the object engine is to provide an object-oriented environment in which \nto integrate different problem-solving paradigms (e.g., procedural, logic-based, rule -based, constraint- \nbased) and provide or incorporate support October 23-27, 1994 Current Reality: Suggested Readings Ineffective \nAspects of 00 Teams Gerald Weinberg: Psychology of Computer . . . . . . . . . . . . . . . . . . . . . \n. . . . . . . . . . . . asking a te&#38; to implement something cold attempting to substitute formality \nfor trust customer versus us mentality defining software by schedule and cost, not by content failing \nto indoctrinate management with 00 knowledge failure to manage expectations (of team/management) failure \nto provide private office space false consensus feeling compelled to remain with a dysfunctional team \nfocused on fancy tools imposing functional decomposition on an object model interfacing with firnction-oriented \nmanagement management second-guessing technical mandated teams (membership, direction, schedule, . . \n.) no analysis no clear boundaries and/or scope no domain analyses no professional managers no project \nplan not being able to disband a team organizational issues (accountability, schedule . . .) over the \nwall mentality people concerns (lack of training, teams too large...) plug-compatible staff (people are \nlogs) nremature solidification of design ;)rocess issues (micro-management, formal process . . .) rewarding \nmediocrity schedule versus quality (sacrificing quality) solving people problems with technology team \nmembers have private and/or different agendas tryryeto make reuse work independent of uninformed dictation \nof business practices by customer uninformed management Programming; Machiavelli: The Prince; Sun Tzu: \nThe Art of War; Tom DeMarco and Tim Lister: Peopleware; Tom Peters: Are Your Lights On?; Jim Coplien: \nObject Sociology; Fred Brooks: The Mythical Man Month; Lany Constantine: Four Team Paradigms (CACM 10/93); \nPeter Senge: The Fifth Discipline; and Katz and Kahn: Social Psychology of Organizations.  Workshop \nParticipants Josef Altmann University of Linz Gary Anderson Boeing Computer Services Frank Armour American \nManagement Services Mark Baker DomainWorks Tim Born AT&#38;T Bell Labs Andrew Bnmett Anderson Consulting \nBill Castor CW Teny Cheny Bell Northern Research Paul Chishohn AT&#38;T Bell Labs James Coplien AT&#38;T \nBell Labs John Cunningham Object Technology Ward Cunningham Cunningham and CUllllillgham Kevin Dahl Glenayre \nElectronics Chi-hoi Duong AT&#38;T Network Systems David Dweller Steven Fraser Bell Northern Research \nWilliam Gage WilTel ATG Dan Lesage Object Technology International Michael Lindner AT&#38;T Bell Labs \nReinhold Ploesch University of Linz LoAnn Reiling AT&#38;T Bell Labs Paula Richards BM AS/400 Division \nSuzanne Skublics Object Technology International Brett Stutz Xilinx Malyzajac AT&#38;T Bell Labs  mechanisms \nsuch as persistence, garbage collection, testing tools and distributed, concurrent processing. The environment \nshould enable integration that is incremental, dynamic, transparent to existing applications, and even \ntransparent to on-going computations. Standardization of object-engine facilities could lead to development \nof hardware support to improve performance.  Discussion Ihe workshop agenda consisted of presentations \nby a number of the participants along with questions and discussions. In a concluding discussion we attempted \nto better define the nature, scope and features of the object engine. The following paragraphs present \nhighlights of the presentations. Roman Cunis presented general considerations for object engine requirements. \nFundamental to these requirements were support for extensions to provide multiparadigm integration and \nmultidimensional modularity--the ability of objects to act on other objects. The ability of objects to \nact on other objects can be seen as computational reflection, but it is important to focus on the computational \naspects rather than the philosophical aspects of reflection. Roman outlined open system properties and \nthen translated them into the following object engine requirements: . There must be a bottleneck of \nintegration, a single or small set of actions for access to all objects. The minimal would be message- \nsending. . It must incorporate a mechanism referred to as daemons, traps or meta-objects which can be \nattached to objects at run time to modify their behavior and attach side effects. . It must be possible \nto assign metaclasses to individual objects at run time to alter their structure and behavior. . Support \nmust be provided for hidden data which would support an object s metaclass protocol. Roger Burkhart described \nthe Swarm system for simulating concurrent, distributed artificial worlds. The Swarm system focuses on \nthe need to simulate massively parallel natural systems in which extremely large numbers of objects interact. \nThe model must be able to represent concurrency and interactions of domains in a timely fashion. The \nstrategy is to partition the system into swarms where a collection of objects interact in the context \nof a local schedule. Interactions between swarms are less frequent than within swarms. A hierarchy of \nswarms interact to produce global dynamics from local interactions. The implications to an object engine \nare Objects should be able to be active when they want to be--massively autonomous. . Synchronization \nof clocks between swarms would allow windows in which higher-level clocks would allow lower-level clocks \nto get ahead. The system must be reconfigurable at run time. Declarative services must provide ad hoc, \nrnntime queries and constraints on the state and actions of the system. . Run-time compilation must \nbe supported at various levels of granularity. Bob Fraley presented issues and concerns from work on \ndistributed objects systems: Should provide flexibility in the use of features, e.g., don t use virtual \nmethods (re: C++) if they are not needed. Need a consistent way of communicating with remote objects. \nNeed global naming/object id mechanism. . Should be able to multicast [or broadcast] a message, for \nexample, to send a request to all active printers. . Must be able to interface to current/legacy applications. \nGail Harris described her experiences developing applications that required the integration of AI and \nobject-oriented programming. She would like to be able to integrate logic programming into an object- \noriented environment. She discussed several approaches she has seen and described an approach she is \nexploring. The goal is to implement a natural extension that provides pattern matching and unification \nwith sound and consistent inferencing. Philippe Collet described work focusing on persistency, evolution \nmanagement, interoperability and CAD using Eiffel. His team implemented an Eiffel interpreter in Eiffel. \nThis enabled work in the evolution of classes, reification by necessity and automatic transaction management, \nHe identified several requirements of an object engine: . Must be efficient on current machines . Must \nreconcile static [interpreted] and dynamic [compiled] approaches . Must be compatible with persistent, \nparallel, reactive and network distributed objects . Must allow behavior description in an imperative \nor declarative way . Must consider semantic controls such as particular constraints, driven either by \npersons or by rules. Dongwook Shin described a project to implement concurrent, distributed, large-grained \nobjects. This focused attention on distributed computing issues, particularly load balancing and the \nneed to analyze processing activity. Joachim Thomas described the knowledge query facilities implemented \nin KRISIS, a knowledge base management system. He described KRISIS query processing and optimization. \nA goal is to implement constraint processing that is consistent with the knowledge and query processing. \nFuture work will also focus on additional query optimization techniques. Zhixue Wu described insights \ngained from the development of PC++, a persistent programming language for writing multimedia applications--an \nextension of C++. Wu described how reflection would allow diverse application requirements to be addressed \nthrough transparent, meta-level control. From experiences with PC++, applications should be able to use \nfine or coarse-grained objects, process or data migration and optimistic or pessimistic concurrency control. \nReflection is viewed as a critical element in providing the needed open system capabilities and to address \nthe diverse requirements of applications. Fred Cummins presented a proposed set of object engine requirements \ndrawn from work on the development of KSL and application development in KSL and Smalltalk. The following \nwere highlighted: . Instance-level control of message resolution . Full encapsulation of aspects (attributes \nand relationships) . Executable instructions implemented as objects . Instantiation by cloning . Textual \nrepresentation of object structures . Ad hoc reflection . Object representation of the processing stack \n. Reflective interception of exceptions Portland, OR October 23-27,1994 Conclusions Drawing on the \nabove presentations and related discussions, the participants refined the object engine concept. The \nobject engine is defined as An execution platform/environment . The implementation of a common base \nobject paradigm A language syntax independent implementation A machine independent implementation An \nopen, extensible system A participant in concurrent processing The object engine must support multi-paradigm \nintegration, distributed processing, reflection and development tools (e.g., debuggers, browsers, tracers,...). \nA number of potential object-engine requirements were discussed. The participants reached consensus that \nthe following requirements should be included: Encapsulated aspects. This concept, presented by Fred \nCummins, involves the specification of aspects for implementation of attributes and relationships. An \naspect would provide accessor methods and notification facilities and conceal the implementation of the \nattribute or relationship which could be stored or computed. A uniform change notification mechanism, \nNotification is key to implementation of display facilities, constraint processing, rule-based systems \nand other capabilities. The mechanism must be consistent so that applications can be easily integrated \nand extended, particularly on an ad hoc basis. Instance specialization. It should be possible to add \nand override behaviors and add instance variables to individual instances on an ad hoc basis. This facility \nis needed to support adaptive and analytical processes. Automatic memory management. Automatic memory \nmanagement is essential to achieve encapsulation and minimize interdependence of components in large-scale \nsystems. Everything an object. Elementary data, classes and methods must all be implemented as objects. \nTextual representation of objects. Similar to LISP, all object structures could be expressed and reconstructed \nfrom textual expressions. This is useful for editing, external storage and as an intermediate form for \ntransfer of objects from one environment to another. Language expression objects. The object engine \nmust have a standard intermediate language implemented as executable objects (i.e., interpreted). The \nexpression set should be extensible and the objects should be compilable. Various programming languages \nwould be compiled to the common expression-objects form for execution or compilation in the object engine \nenvironment. Ad hoc interpretation. It should be possibIe to revert to the object expressions form of \nprogram blocks (typically methods) on a selective, ad hoc basis to execute in interpretive mode. Context \nobjects. The processing stack should be accessible as objects for operations on the stack.  Dynamic, \nincremental compile-link. It should be possible to dynamically create or revise blocks of expressions \nas objects and selectively compile and link these blocks during run time. Reflective exception handling. \nException facilities coupled with the stack objects should support sophisticated programmatic resolution \nof exception conditions. Concurrency control. Specialized message resolution mechanisms should provide \nfor coordination of concurrent processes.  Future Work There was a general sense among participants \nthat the workshop had produced good ideas, but that the discussion was just getting under way when time \nran out. Some of the above requirements should be refined. The following requirements were considered \nin the general discussion, but not resolved: The ability to alter the message resolution mechanism on \nan individual object. Encapsulated aspects that maintain bidirectional relationships. Provisions for \nhidden instance data for capture of meta-information. Special variable types for definition of search \nspace and return of solution bindings. A query resolution mechanism. There was strong interest in resuming \nthe discussion in another workshop next year. The list of requirements needs further consideration and \nother assumptions should be identified. Information on the workshop was presented in a poster session \nand drew considerable interest. Sixty people requested additional information. Participants Roger Burkhart, \nDeere &#38; Co., Santa Fe Institute, roger @ ci.deere.com Henry Chang, IBM Watson Research, hychang @ \nwatson.ibm.com Philippe Collet, 13S-University of Nice, France, collet@tigre.unice.fr Fred Cummins, Electronic \nData Systems, cummins @ ae.eds.com Roman Cunis, MAZ GmbH, Germany, rc@maz-hh.de Bob Fraley, Hewlett-Packard, \nfraley@nsa.hp.com Gail Harris, RES Policy Research Inc., Ottawa, Canada, gail@instantiated.on.ca Thomas \nKuehnel, Arizona State University, kuehnel@enws202.eas.asu.edu Donald Liib, Royal Institute of Technology, \nSweden, donald@it.kth.se Bob Marcus, Boeing, rmarcus@atc.boeing.com Kim Rochat, IBM Object Technology \nProducts, kimrochat@acm.org Dongwook Shin, University of Chungnam, South Korea, shin@camars.kaist.ackr \nJoachim Thomas, University of Kaiserslautern, Germany, thomas@informatik.uni-kl.de Zhixue Wu, University \nof Newcastle, UK, zhixue.wu@ncl.ac.uk Portland, OR October 23-27,1994 \n\t\t\t", "proc_id": "260028", "abstract": "", "authors": [{"name": "Fred Cummins", "author_profile_id": "81100067090", "affiliation": "EDS Artificial Intelligence Services, 5555 New Ring Street, Troy, Michigan", "person_id": "PP14033878", "email_address": "", "orcid_id": ""}, {"name": "Roman Cunis", "author_profile_id": "81100240841", "affiliation": "MAZ GmbH, Harburger Schlossstrasse 6-12, D-21079 Hamburg, Germany", "person_id": "P248517", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260028.260158", "year": "1994", "article_id": "260158", "conference": "OOPSLA", "title": "The object engine: foundation for next generation architectures", "url": "http://dl.acm.org/citation.cfm?id=260158"}