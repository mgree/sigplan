{"article_publication_date": "10-01-1994", "fulltext": "\n TAKING AN OBJECT-ORIENTED METHODOLOGY INTO THE REAL WORLD Martha Hartman, Frederick W. Jewell, Colin \nScott, Deborah Thornton Andersen Consulting 100 S. Wacker Drive Chicago, Illinois 60606 Abstract Commercial \norganizations embarking upon an object-oriented software development must choose between a number of \ncompeting methodologies and their associated tools. While many of these are appropriate to small-scale \ndevelopments, full-scale commercial software systems place additional demands on their capabilities. \nThis paper analyzes the experience of Andersen Consulting s Eagle project when the Object-oriented Software \napplying Engineering methodology. It highlights a number of areas in which this methodology (and others) \ncould be enhanced to deal to meet the demands of commercial users.  Introduction This paper describes \nthe experience of Andersen Consulting s Eagle Technology Advanced Development Project when applying an \noff-the-shelf object-oriented analysis and design methodology to the development of software to meet \nbusiness requirements and standards. The purpose of the Eagle project was to evaluate new ways of delivering \nsoftware which would take advantage of such advanced features as: Re-use Integrated Performance SupportTM \nIn order to support these features, the following architectural approach was taken: . Customizable \nand Tailorable Systems . Distributed Architectures . Design for Maintainability Development primarily \nin ParcPlace Smalltalk . Early focus on usability and performance support Component-based architecture \nFlexible distribution architecture The Eagle team was made up of a small number of experienced object-oriented \ndevelopers and managers (some of whom had already completed a major object-oriented project) and a much \nlarger number of inexperienced developers and managers. The Eagle project is currently approaching the \nend of the third phase of four phases. The objective of the third phase of work is to develop a commercial-quality \napplication that would prove and demonstrate the concepts behind the Eagle approach. As part of this \napplication development Eagle has: . Developed and put in place an internal training program for the \nintroduction of 00 techniques based on large scale development techniques and the experiences of Eagle \ndevelopers . Developed a distributed object architecture which is capable of supporting the integration \n94 25 of various object-oriented and non-object-oriented/legacy environments . Developed tools for use \nby application developers enabling them to make full use of the techniques developed on Eagle . Developed \na new methodology for the development of distributed object-oriented systems   Experiences The Eagle \nproject attempted to apply a buy-rather-than-build philosophy for all aspects of the development and \ndelivery environment. Thus Eagle selected an off-the-shelf object-oriented software development methodology \nand tool. The methodology chosen as a starting point was Ivar Jacobson s Object-Oriented Software Engineering \n[1], and the project was supported by use of the associated tool, Objectory. We were attracted to this \nparticular methodology by the focus placed on use cases as a method for progressing from requirements \ngathering to the final system with a high degree of traceability between models. It was our intention \nto study the approach in detail and then apply each stage in turn, documenting what did (or did not) \nwork, and refining ideas where necessary. The outcome was to be a methodology that could be used throughout \nAndersen Consulting. The Eagle methodology (process) model that emerged has three major areas of evolution \nand innovation compared with the original approach: Design: The design evolutions comprise innovations \nin the areas of Business Process Driven Analysis and User Centered Design. Development: The development \nevolutions center around innovations for developing distributed objects and Framework based design. Organizational \nand People Model: This will not be discussed in this paper. These innovations are explained in the following \nsections. Together these enhancements yield a methodology which supports the construction of component-based \nsoftware solutions from distributable re-usable components. Business Process-Driven Analysis Our first \nobservation while using the Jacobson approach was the technique (in common with nearly all others) assumed \nthat a clear statement of requirements was available: The first transformation made is porn the requirements \nspecification to the requirements model [2] In OOSE, a major part of this requirements model is the use-case \nmodel which documents the supported dialogs between users and the system being modeled. Our experience \nis that we often have to derive such requirements from interviews and discussions with domain or subject \nmatter experts and individual users. When we observed our functional analysts at work, there seemed to \nbe a significant pre-use case phase which focused on their developing an understanding of the functionality, \nscope, and types of interaction that would be incorporated in the required system. We, therefore, developed \na pre-requirements model stage based on Business Process Models. Business Process Models describe the \nentire business in a purely functional manner by progressive decomposition from the enterprise to the \ndepartment level. These models represent how a business chooses to operate. That is to say, there may \nbe many different ways of implementing (from a process perspective) the functions (e.g. purchasing, inventory) \nthat make up a business. At this stage in the analysis, opportunities for re-engineering can be identified \nand exploited. Once the desired Business Process Models have been agreed upon, the business objects are \nidentified. This tends to follow naturally from the description of the Business Process Models and corresponds \nto the Jacobson notion of object candidates or concepts. The final step we call Solution Strategy. This \nstep involves encapsulating business objects and associated logic in components based on the functional \nknowledge gained through the Business Modeling exercise. The objective of this stage is to identify component \ncandidates. Each ensuing component has a well-defined interface and, potentially, may be distributed \nacross LAN s or WAN s. In common with Jacobson, we found that effective use cases tend to abstract from \nindividual situations and represent a generalized model of a class of interactions with the proposed \nsystem However this level of abstraction caused a major problem. Both the functional architects and end-users \ntended to think in concrete terms and, as a consequence, the abstract use-cases were poorly understood. \nOur first attempt at a solution to this problem was to develop the concept of a concrete use case or \nscenario. A scenario, although similar to a use case, does not attempt to represent multiple control \nflows or interactions. Rather it describes a single case with no optional paths (e.g. selects only one \nbranch of a conditional) which could be directly related to what a user might do in a specific situation. \nWe found that scenarios were still appropriate for identifying business objects, the next step in the \nprocess. Once identified a scenario is broken down into activities and tasks. Eagle s goal was to enable \nreuse to the lowest level feasible. Therefore activities and tasks, or smaller encapsulated portions \nof a scenario, are identified and encapsulated. An activity is the largest block of a process from which \na system is built. It is important that an activity be small enough to handle variability, but not so \nsmall that they become unmanageable. Lastly, each activity is associated with a subject object, but can \nbe reused across different subject objects. A subject object is the driving object for an activity, for \nexample, customer in the customer edit activity. Tasks are the building blocks for an activity. They \nare organized as task trees. Lower level tasks respond to individual events from frameworks. Higher tasks \nserve as grouping mechanisms of lower tasks. The identification of both activities and tasks starts the \nmigration from a purely functional representation of the system toward an object based representation. \nAt this point the identification of process spedpcations begins. Process specifications manage the activation \nof activities. Each activity is guarded by pre- and post conditions. These conditions are coded into \nthe process specification and allow for the event-driven activation of the activity. To support the definition \nof pre-and post-conditions, we also added the notion of state into the use cases. We believe that most \nbusiness solutions are loosely-coupled and are fundamentally event-driven, That is to say, changes of \nstate in one object drive activities which, in turn, imply changes of state in another. For example, \nthe approval of a purchase order request might initiate the associated actions to purchasing the items. \nIn this case, the Purchase Order object would have a state Approved (which might be entered at the completion \nof an Approval activity) and one of the pre-conditions for the associated purchasing activity would be \nApproved(Purchase Order) . Once an initial set of scenarios has been developed, application architects \nand process developers then apply generalizations to the scenarios to produce the use cases. This involves \nthe normalization of activity or task descriptions across scenarios. The process of creating the use-cases \nthemselves can often point to new scenarios or identify areas of functionality that have not been addressed. \nThese are referred back to the domain experts and users for validation, and an iterative process begins \nwhich continues until further iteration would yield no significant the object model and the associated \ninterface are improvements. synonymous with the map.  User Centered Design Another aspect missing from \ntypical methodologies relates to addressing the usability of the final system. The first principle of \nusability is Know the user. This implies that the system should be designed to fit the user, not the \nreverse, hence the notion of a user-centered design. We found that scenarios provide a useful starting \npoint for the usability work due to the focus on user interactions with the system that are specialized \nto specific instances rather than generalized concepts. Our approach to user-centered design is sub-divided \nas follows: . User Analysis -Describes the user population in detail. . Task Analysis -Describes in detail, \nthe true job activities of a user. . User Interaction Design -Visualizes the user interface and defines \nthe human-computer interaction. . Usability Assurance -Tests the design, during its development, to \nassure that it is meeting the users need . Integrated Performance Support -when good interaction design \nis not enough and some help on top is required The above usability tasks help the developers to walk \nthe terrain of the application. A map of an area can only give the reader so much information about the \narea being depicted. Until the map reader actually walks the terrain of the map, he/she will not understand \nunique aspects of the area. For example a road may actually be unpaved and unpassable in spring due to \nmud. The same idea holds true for systems development. Until a developer actually sits down and tries \nto have the user execute job tasks, The mechanism that allows the developer and the user to walk the \nterrain early in the object model development is known as low fidelity prototyping. Low fidelity prototyping \nis a method of paper-and-pencil prototyping that effectively iterates through multiple versions of the \ninterface quickly and efficiently. Low fidelity prototyping effectively: . Accelerates user interface \ndesign . Reduces the cost of improving GUI design . Expands creativity by lowering barriers to including \nnew UI concepts . Teaches green screen developers to develop GUI interfaces that fit user needs The \nlast aspect of the advanced usability model that we concentrate on as part of User Centered Design is \nIntegrated Performance Support? The goal set of this tasks is to determine when supportive information \nis needed, what information best fills the need, and how the user will interact with the support. This \ndevelopment uses the information developed during User Analysis, Performance Analysis and Task Analysis \nto design the supportive application. The tasks completed as part of the design process are categorized \nas Interaction Protocol Design and Information Design. The goal of Information Design is to create an \naccurate mapping between the information modeled by the system and the user s mental model. Providing \na rich structure to the information will help to achieve this goal by allowing for multiple presentation \nstrategies and multiple navigational paths. The goal of Protocol Design is to design performance support \nuser interface prototypes. That is, a design is developed for delivering the support information identified \nand structured during Information Design. Framework-Based Development One of the original driving requirements \nof the Eagle project was to prove the ability to develop large-scale industrial applications based on \nobject-oriented concepts and currently available technology. Framework-Based Development is Eagle s approach \nfor maintaining a reasonable learning curve which is essential to meeting our productivity, quality, \nconsistency, time to market and cost reduction objectives. Framework-Based development provides an environment \nfor solution design, implementation, deployment and evolution. Each framework is essentially a pattern \ninstantiated into an encapsulated reusable component. Additionally, each framework has a corresponding \neditor. The editor maintains a table of parameters which customize and tailor the framework for a particular \nimplementation. Examples of customization and tailoring parameters include: viewer alternatives, rules \nfor activation of an activity or task, validation, etc. The frameworks that Eagle has developed fall \nalong two axis. The first, the horizontal axis, represents framework kernels. Examples of framework kernels \nare: dynamic properties, instance inheritance, security, validation and persistence. The second axis, \nthe vertical axis, represents Application Frameworks. Examples of Application Frameworks include: edit \nan object, edit a list, process an event, view and work flow mail. This approach has significantly impacted \nthe traditional application layered architectural model. The present model consists of an operating system, \ntechnical architecture, application architecture and application specific layer. The Eagle approach increases \nthe magnitude of each of the three bottom layers: middleware &#38; operating system, technical architecture \nand - . application architecture/frameworks. This increase in scope of each of these layers reflects \nthe notion that more functionality can be isolated away from the application specific layer allowing \nthe application developer to focus on the functionality. Additionally, the model grows in the new areas \nit is able to address. New development areas include: Integrated Performance SupportTM, globalization, \nand user tailorable business processes. It is currently estimated that 80% of the entire system code \nwill reside in the application architecture, technical architecture and middleware &#38; operating system \nlayers. This leaves a very small (comparatively) 20% of the code to be developed as part of the application \nspecific layer. It is anticipated that this breakdown will translate into significant maintenance savings \nover time. Distribution Eagle has stressed the concept of component-based solutions since the project \ns inception. The idea behind this was that we wished to focus not simply on reuse at the object level, \nbecause we believe that this will occur naturally if 00 techniques have been properly taught, but rather \nat the component level. At this level, we re-use modules that have a specific business purpose. The rationale \nbehind this is that a business component-based system enables the functions of a business to evolve over \ntime without significantly impacting the implementation. New versions of components, as long as they \nsupport the same interface, can be added seamlessly. We also believe that such an approach focuses on \ncomponents that become the unit of development, testing, configuration, maintenance, and distribution \nin a system . From a distribution point of view, it is important to note that the term component does \nnot correspond to However, this has a significant impact on the process. Some methodologies suggest that \nthis partitioning of the system should be driven primarily by performance issues and should occur late(r) \nin the development process. Our experience is that, while such considerations are valid, the over-riding \nconcern is how to come up with a component model which matches the business process models. This has \nto be done early -immediately after the process models have been developed. A key aspect of this activity \nis the definition of component interfaces that are likely to be stable throughout the life of a given \nsystem. Eagle solutions aim to allow variability within a component, but attempt to minimize the variability \nthat is visible to clients of a component by means of its interface. Since this is directly related to \nthe evolution of the business processes, it is natural to involve the domain experts at this stage. From \na development perspective, this partitioning is enforced by the extensive use of design-by-contract [3] \ntechniques at the component level. That is to say, each component guarantees to fulfill a specific contract \nwith respect to its clients, and subsequent versions of the component will also support that contract. \nAnother feature of this approach is the increased use of indirect messaging models to support the interaction \nbetween components. We have developed a publish/subscribe model [4] which allows components to publish \nsignificant events (typically state changes in business objects) for receipt by other components that \nhave subscribed to events of that type. This matches closely to common business models where multiple \nequivalent clients may process a business event (e.g. order processing components process incoming orders). \nhardware node . A component may span more than one node, and more than one component may be present on \na single node. Conclusions In a number of key aspects, most current object-oriented methodologies and \ntools do not yet provide a suitable level of coverage and support for the construction of large-scale \nbusiness systems. In particular: The ability to drive the process from the business models and NOT from \nrequirements statements The usability aspects of a system need to be addressed from the very beginning \nof object model development Given the event-driven loosely coupled nature of these system, state, state \ntransition, and publish/subscribe models need to be widely supported Contract definitions need to be \naddressed throughout the development Lastly, the incorporation of frameworks into a methodology are \nnot well understood. Research and applications using frameworks need to developed and integrated into \nthe presently available design and analysis methodologies. References [I] Object-Oriented Software Engineering, \nIvar Jacobson, Magnus Christerson, Patrik Jonsson, and Gunnar Overgaard. Addison-Wesley 1992. [2] Ibid. \n[3] Meyer, B. Design by Contract, Advances in Object-Oriented Software Engineering, Prentice Hall, 1992 \n[4] X. Li, K. Steffen, P. Jatkowski, C. Scott. A Publish-Subscribe Model for Enterprise Computing. TOOLS \n14 Prentice-Hall 1994. Portland, OR October 23-27,1994 \n\t\t\t", "proc_id": "260028", "abstract": "", "authors": [{"name": "Martha Hartman", "author_profile_id": "81100088275", "affiliation": "Andersen Consulting, 100 S. Wacker Drive, Chicago, Illinois", "person_id": "P191861", "email_address": "", "orcid_id": ""}, {"name": "Frederick W. Jewell", "author_profile_id": "81100373316", "affiliation": "Andersen Consulting, 100 S. Wacker Drive, Chicago, Illinois", "person_id": "P86887", "email_address": "", "orcid_id": ""}, {"name": "Colin Scott", "author_profile_id": "81100544312", "affiliation": "Andersen Consulting, 100 S. Wacker Drive, Chicago, Illinois", "person_id": "PP14189111", "email_address": "", "orcid_id": ""}, {"name": "Deborah Thornton", "author_profile_id": "81100417921", "affiliation": "Andersen Consulting, 100 S. Wacker Drive, Chicago, Illinois", "person_id": "P65097", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260028.260090", "year": "1994", "article_id": "260090", "conference": "OOPSLA", "title": "Taking an object-oriented methodology into the real world", "url": "http://dl.acm.org/citation.cfm?id=260090"}