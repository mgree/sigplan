{"article_publication_date": "10-01-1994", "fulltext": "\n 00 Compilation-What are the Objects? Chris Clark Digital Equipment Corporation MS MR04-l/H16 4 Results \nWay Marlboro, MA 01752-3011 clark@zk3 .dec.com The goal of the 00 Compilation workshop was to problem \nbeing solved played an equal role in determine the current state of applying object-determining which \nobject oriented techniques oriented techniques to the compilation problem and were successful. to discover \nwhich object-oriented techniques were Both the diversity and the commonality in the ap- successful and \nwhich weren t. The position papers proaches became evident at the workshop. The di-contain much of that \ninformation. I would heartily versity came from the problems attacked and ap- recommend reading them. \nThe papers can be ob-proaches used, and is reflected in the third bullet tained by anonymous ftp from: \nabove. The commonality came from the consensus everest.ee.umn.edu:pub/oopsla on compiler architecture \nand from the object-oriented viewpoint. Several key lessons were learned at the workshop: This point \nis worth stressing. The general architec- Object-oriented compiler writers have not aban- ture for a \ncompiler is fairly well defined and welldoned the traditional models nor technology, but accepted. However, \nobject-orientation brings ahave supplemented it with object-oriented tech-unique emphasis to viewing \nthe compilation proc-nology. ess. That emphasis focuses attention on the seman-The main goals behind \napplying object-oriented tic representation and how it is manipulated. Thus, technology were increasing \nreuse, opening up the object-oriented viewpoint created a commonal-the implementation, and increasing \nfunctional-ity itself, as many of the participants viewed their ity. diverse problems from the shared \nperspective of, Many of the efforts were directed toward the How should I represent this so that I can \nmanipu- semantic model, either how to represent the se- late it? mantics or how to traverse and process \nthe se- mantic representation. Papers Discussed Another major emphasis was the adding of ob- The next \nfour sections of the paper give brief sum-ject-oriented features to compiler-compilers. maries of the \nposition papers, including some in-There was the realization that the implementa- formation that came \nup during the discussions. The tion language, the culture surrounding it, and the categories and the \ngrouping of the position papers are somewhat arbitrary and several of the papers could have easily been \nmoved. [An asterisk after an author s name indicates the author was present at the workshop.] Addendum \nto the Proceedings OOPSLA 94 Class Hierarchies to Represent Programs in Intermediate Forms Papers in \nthis session generally presented a frame-work or class hierarchy that captured either the structure of \nthe compilation process or the semantics of the program being compiled or both. An Object-Oriented Compiler \nConstruction Tool Kit Timothy A. Budd*-budd@cs.orst.edu Timothy P. Justice*-justict@cs.orst.edu A class \nhierarchy capturing the entire compilation process designed for teaching purposes. Object-oriented ASTs \nand the coercive generality model were successful in capturing type evaluation for this project. C++ \nObjects for Representing and Manipulat- ing Program Trees in the Sage++ System Beata Winnicka*-bfatyga@cs.indiana.edu \nDennis Gannon*-gannon@cs.indiana.edu Francois Bodin-bodin@irisa.fr A class hierarchy concentrating on \nsource-to-source translators for C++ and FORTRAN programs. The hierarchy simplifies the users interface \nto the un-derlying system. Certain features were motivated by the desire to reproduce the original source \nas closely as possible when the transformer introduces no changes. CodeStore: Infrastructure for C++ \nKnowl- edgeable Tools John Barton*-jjb@watson.ibm.com Yi-Min Chee*-ymchee@watson.ibm.com Michael Karasick*-msk@watson.ibm.com \nPhilippe Charles+harles@watson.ibm.com Derek Lieber-derek@watson.ibm.com Lee Nackman-lm@watson.ibm.com \n A class hierarchy focusing on representing the entire C++ language and facilitating change analysis. \nClass hierarchy provides API to system that parses C++ and builds the representation objects quickly. \nSystem designed to be complete, where users ma-nipulate objects through API, rather than extensible where \nusers customize implementation through in-heritance. Experiences with Building Incremental Compilers \nusing Objects Graham Roberts*-G.Roberts@cs.ucl.ac.uk A class hierarchy used in a couple of parallelizing \ncompilers. The hierarchy provides an environment of objects, with a tree editor for parse trees. Worked \nwell for small language (Solve) providing a very nice environment and worth pursuing. Also pres-ents \nsome of the complexities of applying to C++ that caused them to switch to an approach more like the Sage++ \nsystem. Object Oriented Compiler Technology Rick van Rein*-vanrein@cs.utwente.nl A design for a class \nhierarchy based upon composi-tion filters. An early look at an approach to com-piler design that may \nbe able to mix both union and intersection models of semantic representation. The Object Design of a \nSmalltalk Compiler Allen Wirfs-Brock*-allen@digitalk.com A class hierarchy used in a commercial Smalltalk \ncompiler. Illustrates how breaking a monolithic class down into cooperating objects can allow greater \nreuse and flexibility. Towards A Framework For Modular Lan-guage Design And Implementation Guruduth \nBanavar*-banavar@cs.utah.edu Gary Lindstrom-lindstrom@cs.utah.edu A class hierarchy focusing on module \ncompilation issues. The system extends the module concept to cover linking of object files and shows \nhow the con-cepts of inheritance, encapsulation, and type check-ing apply in that domain. Viewing Compilation \nas an Object-Oriented Process Jawahar Malhotra*-malhotra@acm.org A class hierarchy based upon principles \nused in Beta and SML compilers. Provides an overview of the AST model of semantic representations and \noverall structure of compiler using that model. Includes a suggestion for how to simplify the hierarchy \nwhen generating the class hierarchy by hand.  Compile Time Metaobject Protocols Papers in this session \ntook advantage of metaobject protocols in their compiler designs. Metaobjects make the compilation process \nmore open, allowing the user to improve the quality of the generated code by directing the compilation \nprocess. Compilation Strategies as Objects Anurag Mendhekar*-anurag@cs.indiana.edu Gregor Kiczales*-gregor@parc.xerox.com \nJohn Lamping-lamping@parc.xerox.com Using metaobject protocols to open the implemen-tation of a compiler \nto user customization. This is a manifestation of Kiczales OOPSLA 94 keynote ad-dress. The goal was a \ncompiler for a high-level lan-guage where users could enjoy the benefits of a high level of abstraction \nwithout paying the traditional performance, interoperability, and functionality costs. Compiling Dylan \nwith Dylan and Compile- Time Metaobjects Jonathan Bachrach*-jonathan@harlequin.co.uk Tony Mann*-tony@harlequin.co.uk \nKeith Playford*-keith@harlequin.co.uk How metaobject protocol, multi-methods, and other Dylan features \nwere used in the design of a Dylan compiler. Shows how multi-methods allowed structuring the compiler \nas passes without losing class specific customizations. Also shows how features of the compiler were \nfrozen to permit more optimization.  Automatic Parser Generators Which Output Classes The papers in \nthis session presented object-oriented extensions to compiler-compilers. All the parser generators generated \nclasses and provided some form of inheritance in the grammar. Custom Intermediate Forms and Attributes \nUsing Yacc++ and the Language Objects Li- brary Chris Clark*-clark@zk3.dec.com Automatic generation of \nsemantic representation class hierarchies. Presents the sequence of features that progress from defining \nsimple AST representa-tions to complex intermediate language frameworks. Shows how simple grammar annotations \ncan gener-ate custom class hierarchies. Object Lifecycles in C++ Boris Burshteyn*-bburshte@us.oracle.com \nHow to use compiler technology to implement co-operating state machines. Concentrates on how parser generation \ncan be used to define the state ma-chines that make up objects in a system. The result- ing state machines \ncan then be composed to create a working system with precisely defined semantics. Object-Oriented ANTLR \nParsers Present and Future Russell W. Quong*-quong@ecn.purdue.edu Terence J. Parr-parrt@acm.org Automatic \ngeneration of classes to perform LL(k) recursive descent parsing. Presents some of the new features inspired \nby adding object-orientation. Also shows syntactic and semantic predicates. Object-Orientation in the \nCocktail Toolbox Josef Grosch*-grosch@cocolab.sub.com Inheritance applied to attribute grammars and tree-transformers. \nPresents how various parts of the toolbox have been augmented in object-oriented ways, The same inheritance \ntree is used in the dif-ferent parts and provides a model that relates ab-stract syntax to concrete syntax. \n Yacc++ and the Language Objects Library A Plug-and-Play Parsing Framework Barbara Zino*-bz@world.std.com \nA framework connected with automatic class and table generation. Shows how users customize the framework \nfor their applications using grammar inheritance, inheritance from library base classes, substitution \nof interchangeable parts, and automatic class generation. Also shows how the framework evolved to permit \nthis customization.  Code Generation Techniques Papers in this session focused on traversing and processing \nthe semantic representation and in par- Addendum to the Proceedings OOPSLA 94 titular how to implement \ncode generation and op-timization. Delayed Code Generation-an Object- Oriented Approach to Generating \nEfficient  Code Ian Piumarta*-ikp@cs.man.ac.uk A method for improving the quality of code gener-ated \nby a recursive traversal. Passes objects around the traversal and defers code generation decisions. Shows \nhow to achieve good code and machine inde-pendence within a simple model. Iterators for Abstract-Syntax \nTrees or Recursion over Trees Considered Harmful Arch D. Robison*-robison@kai.com Discusses why iterators \nwere preferred to recursive tree-traversal routines in a class library oriented to-ward performing optimizations. \nCovers how to process a semantic representation when adding member functions to the underlying classes \nis not possible. The RTL System Ralph Johnson*-johnson@cs.uiuc.edu A framework for implementing optimization \nand code generation. These classes were used in the typed Smalltalk compiler. System implements the traditional \noptimizations and is based on static-single-assignment form register-transfer language.  Discussion \nThe following sections give insights gained during the discussions at the workshop. Compiler Frameworks \nSeveral projects presented the frameworks of their system. The traditional design of a compiler was evident \nin the frameworks. However, the develop-ers had taken advantage of the substitutability of objects to \nallow the systems to be more flexible. Several implementors noted that as the class hierar-chies evolved \nthe classes tended to become smaller, with monolithic classes replaced by cooperating collections of \nsmaller, interchangeable classes,  Semantic Representation A wide variety of semantic models were presented. \nThere were two major threads of how the semantics were represented. Some projects used abstract syn-tax \ntrees (ASTs) while others used a form that was purely semantic, such as a register transfer language \nor lambda expressions. The distinction was not al-ways precise as some AST approaches were more semantic \nthan syntactic. Syntactic or Semantic Form The key issue in deciding what form to use was usually the \nprocessing to be performed. If the proc- essing was heavily syntax oriented or was otherwise amenable \nto ASTs, then ASTs were used. If the project had extensive processing that could be most efficiently \ndone on a different form, the AST was translated into that form (or that form was created directly). \nIn projects that used ASTs, one key point that was often reiterated was the design was tailored to what \nmade sense to the intended users. Often this fol-lowed a model of the language being processed, and the \nclass design could be read like a reference man-ual for the language. However, the developers did not \nworry when the design diverged from the refer- ence manual, when diverging made sense. In gen- eral, \nit was felt that the class hierarchy users had no trouble understanding the structures of the class hi-erarchies. \nAnother issue discussed with the semantic represen-tation designs was the union versus intersection model \nchoice. The intersection model attempts to model the semantics with a minimal set of primi-tives. The \nprimitives are used as building blocks to create more complex items. The union model at-tempts to model \nthe semantics with a rich set of primitives which provide all the desired features. The intersection \nmodel often suffers from throwing away information that was known in the source code, but cannot be represented \nin the model, and must be recreated. The union model suffers when new features are added as new extensions \nto the model must be added when the factoring is not right. There is one point worth mentioning here. \nFor proj- ects handling languages with simple or straight-forward syntax and semantics, the design of \na se-mantic form was not a major concern. The problem was mainly an issue for projects that were trying \nto handle C++ or multiple languages.  Size Issues Another issue that was a concern for some groups designing \nsemantic representations was the space used to store the representation. Again, this was particularly \nrelevant to groups representing the complexity of C++. It was also relevant to groups when the system \nhad to fit into small implementa-tions or where the semantic representation would be stored for an extended \nperiod of time. The main solution to this problem was determining what should be recomputed rather than \nstored. A related technique is storing only the top level ob-jects and then recreating the lower level \nones. For example, the Digitalk Smalltalk system keeps only the function level objects around and re-parses \nthe functions to recreate the AST objects when needed. It was also noted that sometimes there is no choice \nwhether something should be stored, as it is too complex to recompute each time its value is needed. \nCaching was mentioned as a partial solution for the recomputation problem.  Semantic Traversals Another \nissue that received a lot of attention was semantic traversals. Several different approaches were represented. \nRecursive traversals by adding member functions to the objects were one of the fundamental methods described. \nRecursive traversals are easy to imple-ment and are well understood. For example, the recursive traversal \ntranslations of both inherited and synthesized attributes are common idioms. How-ever, adding recursive \nmember functions in each client to express each semantic traversal may not be the best solution. The \nworkshop brought up four issues to evaluate when considering recursive traversals: . Adding member functions \nto a class may not be desirable. (For example, adding member func-tions to base classes in a C++ class \nlibrary re-quires recompilation of the library.) . Naive recursive traversals cannot always gen-erate \noptimal code. . A recursive traversal may not be the natural formulation of the solution. . The recursive \ntraversal solution may not be ef- ficient. Several alternatives were discussed for either aug-menting \nor replacing recursive traversals. . Using visitor objects. . Additional objects to influence the recursive \ntraversal. . Replacing the recursive traversal with an itera- tor construct. . Using multi-methods in \nplace of recursive tra- versals. The iterator solution was discussed in depth. It was noted that some \niterators are easier to write than others. In addition, some problems are easier to formulate as iterations \nthan others. This is partially mitigated by the fact that the iterators can be written as library classes. \nThe iterator with a cursor was mentioned as a particularly useful idiom as it can traverse two trees \nin parallel.  Acknowledgments The success of this workshop truly rested on the efforts of the participants. \nAs such I would like to thank everyone who contributed to the workshop. would also like to express particular \ngratitude to my co-sponsors, without whom the workshop would never have happened nor run so smoothly. \nMy co-sponsors were: Boris Burshteyn of Oracle, Ralph Johnson of the University of Illinois, Terence \nParr of the University of Minnesota, and Barbara Zino of Compiler Resources. Addendum to the Proceedings \nOOPSLA 94 \n\t\t\t", "proc_id": "260028", "abstract": "", "authors": [{"name": "Chris Clark", "author_profile_id": "81339494518", "affiliation": "Digital Equipment Corporation, MS MR04-1/H16, 4 Results Way, Marlboro, MA", "person_id": "PP14214362", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260028.260118", "year": "1994", "article_id": "260118", "conference": "OOPSLA", "title": "OO compilation&#8212;what are the objects?", "url": "http://dl.acm.org/citation.cfm?id=260118"}