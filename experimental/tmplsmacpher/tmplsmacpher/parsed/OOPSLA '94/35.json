{"article_publication_date": "10-01-1994", "fulltext": "\n Combining Contracts and Exemplar-Based Programming for Class Hiding and Customization * Victor B. Lortz \nKang G. Shin Real-Time Computing Laboratory Department of Electrical Engineering and Computer Science \nThe University of Michigan Ann Arbor, Michigan 48109-2122 { vbl, kgshin} @eecs. umich. edu Abstract \n1 Introduction For performance reasons, client applications often Traditionally, designers of software \nservices (lan-need to influence the implementation strategies of guages, libraries, operating systems, \netc.) define libraries whose services they use. If an object-abstract interfaces to the services and \nhide all im- oriented library contains multiple service classes customized for different usage patterns, \napplica-plementation details from the clients. However, tions can influence service implementations by \nin- this model has proven inadequate when imple-stantiating the customized classes that match their mentation \ndecisions bias the resulting server per-needs. However, with many similar service classes, formance in \nfavor of certain usage patterns and it can be difficult for applications to determine against others. \nFor example, an LRU paging strat- which classes to instantiate. Choosing the wrong egy for a virtual \nmemory system is optimal for class can result in very subtle errors since a cus-tomized class might use \noptimizations that work clients that exhibit locality of reference and sub-only over a restricted domain. \nIn this paper, optimal for those that do not. we show how client-side software contracts and Kiczales \nand Lamping call the problem of choos- exemplar-based class factories can be used to con-ing a service \nimplementation strategy a mapping struct customized server objects. By expressing dilemma [l]. Since \nthe service provider cannot priorities and requirements in contracts, clients can delegate service class \nselection to the library and control client usage patterns, successful resolution thereby avoid implicit \ndependencies on the library of mapping dilemmas requires prior knowledge of implementation. We have used \nthis approach in the client needs. In some cases, it is possible to collect implementation of a real-time \ndatabase system. historical usage patterns on a per-client basis and The work reported in this paper \nwas supported in use that data to predict future usage. However, a part by the Office of Naval Research \nunder grant NOOO14- more general solution is to allow clients to help re- 92-J-1080, by the National \nScience Foundation Indus solve mapping dilemmas through a meta-protocol. try/University Cooperative Research \nCenter at the Univ. of Michigan, and by the NSF under grant DDM-9313222. Kiczales and Lamping categorize \nmeta-protocols as either deckuratiue, in which clients choose among PenMSion to copy without fee all \nor part of this material is g!anted provided that the copies are not made or distributed for pre-defined \nservice implementations or imperative, direct commercial advantage, the ACM copyright notice and the \nin which clients are free to override part or all of title Of the publication and rts date appear, and \nnotice is given that cppying is by permission of the Association of Computing. the service implementations. \nWell-designed meta-Machwy. TO copy otherwise, or to republish, requires a fee protocols minimize the \neffort required to achieve and/or specific permission. OOPSIA 94- 1 O/94 Portland, Oregon USA @ 1994 \nACM O-89791 -688-3/94/0010..$3.6o acceptable server behavior. 2 Contracts In this paper, we describe \na technique for con-structing server objects that combines the advan-tages of declarative and imperative \nmeta-protocols. The declarative part of our meta-protocol consists of client-side contracts that determine \nwhich cus-tomized service classes will be used and configure server objects according to client needs. \nClient-side contracts expose the otherwise hidden assumptions that clients make about servers, and they \nindicate the client s willingness to abide by any semantic re-strictions required by the server. Furthermore, \nthe same contract language can be subsequently used by the client to extract meta-level information from \nthe server object. Therefore, our contract meta-protocol can support a dialogue between clients and servers \nregarding characteristics that are not captured in the base-interface to the service. Prior meta-protocols \ndo not support bidirectional meta information flow. The imperative part of our meta-protocol is the ability \nto derive new service classes and merge them with those of the original library through exemplar-based \nprogramming. This provides good incre-mentality since only those service methods that are being customized \nneed to be reimplemented. Exemplar-based server construction also improves encapsulation by hiding part \nof the library s inter-nal class hierarchy from applications. In our real-time database research [a], \nwe use this exemplar-based technique to customize database services ac-cording to the real-time and semantic \ncharacteris-tics of applications. The remainder of this paper is organized as fol-lows. Section 2 discusses \nour use of contracts to communicate semantic information needed for server construction. Section 3 explains \nour exemplar-based approach for selecting service classes and extending library functionality. Sec-tion \n4 presents a C++ implementation of our tech-nique. Section 5 discusses related work. Section 6 concludes \nand discusses future work. By analogy to contracts employed in civil law, a software contract metaphor \nis sometimes used to describe relationships between software entities. The software entities could be \ntwo interacting pro-cesses, an application and a software library, a server object and a client object \nor application, or a base class and a derived class. Wirfs-Brock et al. [3] and Meyer [4] consider software \ncontracts to be properties of server classes. Since the server defines the contract, there is no way \nfor an applica-tion to add clauses or establish its own contracts. With our technique, applications can \ncreate client-side contracts to specify requirements and commu-nicate application-dependent semantic \ninformation to servers. Our approach to software contracts is motivated by the following analogy with \ncontract law. When a legal contract is established between a service provider and a client, there is \nboth an express and an implied contract. The express contract consists of the specific clauses in a contract \ndocument. The implied contract consists of the reasonable and cus-tomary duties of that kind of service \nprovider. For example, a contract with a plumber might spec-ify the brand of faucet to install in a kitchen. \nIf the plumber installs the right type of faucet but the plumbing leaks, the plumber is liable for dam-ages \neven if the contract does not specifically men-tion leaks. This is because a plumber s profes-sional \nduties routinely include leak-free installation of plumbing. A leaky installation is a violation of the \nimplied contract. We consider the methods and any class invari-ants exported by a service class to constitute \nan implied contract between the service class and the application. By instantiating a server object from \na service class, an application establishes an implied contract with the server that covers most aspects \nof its subsequent use. However, just as in legal contracts, an applica-tion may want to specify explicit \nterms that must be fulfilled in addition to the implied terms. It may be that only certain specialized \nservice classes can satisfy the explicit terms. In this case, the con-tract can be used to select an \nacceptable class from the general population of service classes. In other cases, the explicit terms might \nrelax certain con-straints and thereby permit server objects to op-timize various aspects of their services. \nFor exam-ple, a server object that supports concurrent access could use simplified locking protocols \nif it knew the application would not perform concurrent update operations. This semantic constraint could \nbe sup- plied by the application in the contract. Therefore, explicit client-side software contracts \nare comple-mentary to implicit server-side contracts. In the remainder of this paper, we restrict our \ndiscussion to client-side software contracts, which we simply call contracts. Contracts are composed \nof clauses that contain either requirements or preferences. Requirements, such as persistent, are mandatory. \nPreferences, such as minimize-execution-time, can be used to decide between servers that meet the mandatory \nrequirements. If no service classes in the library can meet the requirements of the contract, then the \nlibrary can set an error flag or throw an exception. When contracts are used to select and con- figure \nthe implementations of server objects, the contract becomes a declarative meta-protocol for those services. \nSelecting servers through contracts resembles service specification and acquisition in distributed computing \nsystems [5, 61, except our server objects are much lighter-weight and are con- structed from local libraries \nrather than remote server processes. In the next section, we discuss how client-side contracts can help \ndetermine which customized service classes to use. 2.1 Contracts for Customization Through customization, \nobject-oriented program-ming can partially overcome the classic tradeoff between flexibility and efficiency \nin software li-braries. Instead of supporting a single, general-purpose implementation of a function \nor abstract data type, an object-oriented library can provide a variety of specialized classes that collectively \ncover the same domain but are individually more effi-cient than a general-purpose implementation. Spe-cialized \nclasses can be more efficient since the best implementation of a given service often depends on the patterns \nof use within the application. For example, a Set class that keeps members in a hash table would perform \nwell if a client mainly tests for set membership. However, a linked-list in-ternal representation might \nbe better if memory is scarce, the set contains few members, or the ap-plication adds members frequently \nand rarely tests for membership. Instead of using a single com-promise implementation, an object-oriented \nlibrary can contain multiple compatible classes, each opti-mized for certain operations. This example \nis re-alistic: the library of generic container classes sup-plied with the gnu C++ compiler includes \neleven customized Set classes, each using different under-lying data structures and algorithms. An applica-tion \nusing such a library can choose the customized class that best meets its needs. However, with the flexibility \nof choosing from a group of similar server classes comes the burden of understanding their subtle differences \nand mak-ing a good choice. As libraries become larger and more complex, this problem becomes increasingly \ndifficult. Furthermore, since many of the differ-ences between customized classes may reflect se-mantic \ndifferences that are not expressible in the syntax of the language, there is a danger of mis-match between \nthe semantics supported by a cus-tomized server class and its actual use in an appli-cation. For example, \na server object used in a mul- tithreaded environment might use a concurrency control protocol that supports \na single writer and multiple readers. If the single writer restriction is violated by the application, \nas could happen ac-cidentally since the restriction is only implicit in the service implementation, the \nobject is likely to become corrupted. Class browsing tools are often proposed to as-sist application \nwriters in selecting classes [7], but these tools expose the full complexity of the class hierarchy and \ndo not enforce any semantic restric-tions. Furthermore, applications that explicitly use concrete service \nclasses in a customized class hier-archy can become dependent on the internal class structure of the \nlibrary. Such dependencies make future reorganizations of the library classes difficult to accomplish \nwithout propagating changes to ex-isting applications. Therefore, applications should be kept as independent \nas possible from the struc-ture of a library s internal class hierarchy. Class browsing tools do not \naddress this need. The most common approach to choosing a customized class is to instantiate the class \nby name. The customized characteristics are usu-ally encoded in the class name. For example, the generic \ncontainer class library distributed with the gnu C++ compiler contains a base class and eleven customized \nclasses that implement sets with different data structures and algorithms: Set, AVLSet, OSLSet, VHSet, \nBSTSet, OXPSet, SkipSet, VOHSet, CHSet, SLSet, SplaySet, and XPSet. While this technique for specifying \ncustomization is easily understood, in practice it is unwieldy. As additional semantic attributes such \nas persistence or concurrency are added, the class names either become very long or very cryptic. It \nalso becomes difficult to remember the correct order for semantic attributes in class names. Worse yet, \neach combination of semantic at-tributes implies a unique class. Thus, the addition of new semantic attributes \nresults in an exponen-tial explosion in the number of classes. If persis-tence and two types of concurrency \ncontrol (e.g., single-writer and multiple-writer) were added to the gnu Set classes, the eleven subclasses \nwould be-come sixty-six (persistent and non-persistent ver-sions of the original classes plus persistent \nand non-persistent versions for each type of concurrency control). Figure 1 illustrates the class hierarchy \nfor the Set classes and how an application creates an instance of a Set class. Because selecting an appropriate \ncustomized ser- vice class is so dependent upon application seman- tics, software contracts specified \nby applications can aid in the selection process. Instead of using class names directly, applications \ncan use contracts to provide a mapping between application require- VHSelcinb application-set: //application \nmust explicitly choose the class Figure 1: Generic Set Classes. ments and service classes. With this \nmore flexible means of communicating semantic requirements, it is possible to avoid unnecessary proliferation \nof classes by supporting several combinations of se-mantic attributes in a single class. Exemplar-based \nprogramming, discussed in Section 3, can further reduce the number of distinct classes required to implement \ncustomized services. For instance, a single concurrent implementation of a class could support several \nlocking protocols for single-writer or multiple-writer semantics, each protocol repre-sented by a separate \nexemplar of that class. In our implementation, contracts are composed of constraint clauses encoded in \ncharacter strings. These contract strings are passed by applications to the service library at runtime \nduring server object initialization. The syntax of the con-tract language is implementation-specific. \nA typ- ical contract string might be: range-checked; lookup-time<=O(log n); . Using strings for con-tracts \nis simple, portable, convenient, and offers more flexibility than plausible alternatives such as defining \nlanguage extensions for processing con-tracts at compile time. An application may need to dynamically \ndetermine contract constraints at run-time, so compile-time contract processing is not al-ways possible. \nFurthermore, by leaving contract in-terpretation to class member functions rather than embedding it in \nthe compiler, we preserve the abil-ity to define new types of constraints with what-ever syntax is most \nconvenient in the context of a particular class. It is even possible to define new constraints in customized \nsubclasses without mod-ifying the base class. This provides great flexibil-ity and helps keep contract \nconstraints orthogonal to the class hierarchy. Another reason we chose to use character strings for contracts \nis that our real-time database performs remote object creation by passing contracts across the network \nusing re- mote procedure calls. Character strings are easy to transmit via RPC, whereas more complex \ncon-tract representations (i.e., contract objects) would be possible but more difficult to support. The \ncontract string is supplied as a parameter to an abstract service class constructor function. The abstract \nservice class is equivalent to the ab-stract factory of [8, 91. Multiple classes corre-sponding to concrete \nimplementations of the ab-stract service can exist within the library, but ap-plications need never know \nwhich concrete class will be used. The factory class constructor exam-ines the contract string during \nobject initialization and either creates a new object to meet the terms of the contract or rejects the \nconstruction request. We use exemplar-based programming to implement the class factory. Section 3 describes \nour use of ex- emplar objects in more detail. For example, an application might declare a per- sistent \narray object as follows: MdartsArray<int> parts-list( parts-list , persistent; range-checked; sparse; \nsize=lOOO\"); The prefix MDARTS is the acronym for our real- time database system [2]. In this case, \nthe abstract factory class MdartsArray is specified along with the database name of the object and its \ncontract string. Some constraints, such as persistent , might be supported only by specialized subclasses \nthat ac- cess a disk-based database system. Some, such as size , can be implemented in the MdartsArray \nbase class and be inherited by the subclasses. The map- ping of contract constraint clauses onto the \nsub- classes of the MdartsArray class is of no concern to the application. The library either will construct \na customized, correctly-configured server object or will signal an error (return NULL or raise an ex- \nception).  2.2 Advantages of Using Contracts for Customization There are many advantages to customization \nthrough software contracts. One advantage is that application-specific semantic attributes can be ex-plicitly \nstated in object declarations. This is espe- cially helpful when the attributes represent hints to server \nobjects that enable various optimizations. By declaring these hints, the application is express- ing \na willingness to abide by whatever restrictions are implicit in the hints. For example, single-writer \nconcurrency control protocols can reduce locking delays compared to more general concurrency control \nmethods [lo]. However, a server object cannot control application behavior to ensure that the single-writer \nrestriction is followed. With contracts, a single-writer service class would not be chosen unless the \napplication explicitly indicated in the contract that it would avoid concurrent updates (by specifying \na concur-rency constraint such as exclusive-update ). For software reliability and maintenance reasons, \nit is important that such restrictions be declared in the code itself rather than existing only in documenta- \ntion or in the memory of the application developer. Another important advantage of customization through \ncontracts is that it allows applications to maintain a simplified view of the library s class structure. \nWe call this class hiding because the class hierarchy beneath each abstract factory class is hidden from \napplications. The MdartsArray ex-ample discussed above illustrates this idea. There could be dozens of \ndifferent classes in the library that support the abstract interface defined in the MdartsArray base \nclass. Because the semantic at-tributes that determine which subclass to use are passed in the contract, \nthe application can safely ignore the underlying complexity and still be as-sured that a server customized \nto its needs will be created. If no server can be created, the library can signal an error condition \n(throw an exception).  2.3 Disadvantages of Contracts Naturally, there are also disadvantages to using \nclient-side contracts, and the technique should not be applied indiscriminately. Contracts add com-plexity \nto the library implementation, and they im-pose runtime overhead as they are evaluated during server \ninitialization. Contracts may not be worth- while for libraries with few customized class hier-archies. \nThe runtime overhead during initializa-tion is amortized over subsequent server use, so the efficiency \ngained through customization in server functions must exceed the initialization overhead for the method \nto be worthwhile. If an application wants to avoid the overhead of processing contracts during initialization, \nit always has the option of ex- plicitly specifying a service class. Doing so will lose the benefits \nof class hiding and semantic checks, but that decision can be left up to an application. In general, \ncontracts are best for server objects that will be used frequently by applications and that can achieve \nsignificant performance improve-ment through customization. However, even for cases in which efficiency \ngains through customiza-tion cannot justify the use of contracts, contracts may still prove useful for \nspecifying semantic con-straints to reduce errors in server usage. Another limitation of our contract \nimplementa-tion is that errors in contract strings are not de-tected until runtime. This problem is unavoidable \nif dynamic creation of contract strings is allowed. Finally, since it is unknown until runtime which \nservice classes will be used, application executa-bles might become very large as they incorporate all \nof the customized classes. We address this issue in Section 3. Although contracts are not necessar-ily \nuseful in all circumstances, a library need not support contracts for every service class hierarchy. \nIf one or more of the following criterion are met, contracts may be appropriate for that hierarchy: . \nMultiple service classes with similar function-ality are present in a hierarchy. . Server objects can \nachieve significantly better performance if they are implemented for spe-cial cases. . Server classes \ndepend on application us-age patterns such as no concurrency or re- stricted concurrency (e.g., single-writer, \nmul- tiple reader). . Server characteristics important to applica- tions are outside the language syntax \nor se- mantics (e.g., persistence, concurrency, mem- ory requirements and real-time performance). If \ncontracts are restricted to static values, it might be possible to do the contract processing at compile \ntime. This would detect errors in contract strings and eliminate the runtime overhead of se-lecting service \nclasses. If the compiler itself could not be modified, a preprocessor could determine which concrete \nservice classes should be used for each server object. The preprocessor could then re-place the factory \nconstruction call with an explicit call to the concrete class constructor. 2.4 Types of Constraints \nin Contracts An important design decision in implementing con-tracts for a class library is what types \nof constraint clauses will be supported. We do not believe it is appropriate to seek a universal taxonomy \nof con-straint types, because software designers should be free to evolve contracts and constraints to \nexpress whatever semantics a library or application domain needs. This philosophy in part motivated our \nde-cision to use character strings to implement con-tracts. Classes in a hierarchy can interpret the \ncon-straint strings using whatever technique is appro- priate, from simple string comparisons to parsing \nand interpreting some constraint language specific to that hierarchy. Nevertheless, it is illustrative \nto consider the constraints we have developed as part of our real-time database research. Our list of \nconstraints is still evolving, but thus far we have identified the following generic constraint types: \nconcurrency semantics: Specify whether multi-ple clients will share the server object and how many concurrent \nwriters are allowed. persistence: Indicate if persistence is required for this server object. staleness: \nSignal a problem if data accessed by a ever, the application might be able to relax its con- read transaction \nhas not been updated within the specified period. read and write transaction response times: Specify \ntime constraints on database transac-tions according to needs of real-time applica-tions. read-only or \nwrite access: Declare access re-strictions for particular database objects. Per-missions are checked \nduring initialization to reduce overhead during transaction process-ing. units for numeric values: Configure \nthe server object to scale numeric values of data it man-ages according to the units an application needs. \ntransaction priorities: Declare priority to use for this client in real-time transaction schedul-ing. \n type constraints for service classes: Specify that the server be of a particular class or sub-hierarchy \nin the library class hierarchy.  2.5 Meta-level Queries Thus far, we have described our contracts exclu-sively \nin terms of their use in choosing and con-structing suitable server objects. However, it is also possible \nto use the contract meta-protocol to extract information from the server object after it has been instantiated. \nIn most cases, an instanti-ated server object will exceed the specifications of the contract. It can \nbe useful for a client appli-cation to discover what the actual characteristics of the server object \nare once it is constructed. To support bidirectional meta-level information flow, the server class can \ninclude methods for directly querying for server characteristics. Once the code for contract processing \nduring object construction is written, relatively little effort is required to add support for direct \nmeta-level queries. For example, a contract in a real-time applica-tion might specify a timing constraint \nfor reading the state of a database object. If the database ob-ject is successfully constructed, the \napplication will know that the timing constraint will be met. How-straints on other objects if it knew \nthe extent to which this object exceeded the performance spec-ified in the contract. A real-time database \nclass could export a method called QueryTiming to per-mit such queries: Time readTime = dbArray.QueryTiming( \nread(element) ); The class of dbArray would already need to implement a method for computing response \ntimes to evaluate contract constraints such as read(element) <= 50usec; , so most of the work to add \nquery support would already be done. Query-Timing0 could call the same method and simply return the response \ntime instead of performing a comparison.  3 Exemplars and Customized Classes Exemplar-based programming, \nin which prototype objects play a role similar to that of classes, is often cited as an alternative to \nmore traditional object-oriented architectures. For example, the Self lan-guage uses exemplars and delegation \nto dispense with classes altogether [ll]. While exemplars in Self form the basis of a complete programming \nparadigm, exemplars can be useful in a class-based object-oriented context as well [la]. Coplien illus-trates \nthe use of exemplar-based programming in C++ [13]. In our implementation, we combine soft-ware contracts \nwith Coplien s autonomous generic exemplar idiom (in which exemplars register them-selves with a base \nclass and object construction re-quests iterate over the exemplars). Exemplars are special objects that \nare prototype representatives of an entire class. In general, a class can have multiple exemplars, but \noften only a single exemplar is used. Given an exemplar object, ap-plications can construct copies of \nthe exemplar by invoking a special clone0 method. Because exem-plars are objects, they can be stored \nin data struc-tures. In some object-oriented languages, classes are first-class objects, so class objects \ncould be used with our technique instead of exemplars. Rather than choosing a specific service class, \nan application chooses a base class and specifies the rest of its requirements in a contract string. \nThe base class is an abstract factory class that only de-fines the service interface. The contract is \npassed to the population of exemplars derived from that base class. The exemplars then bid on the contract \nto determine which class meets the application s requirements. The winner of the bidding process is cloned, \nand the clone object is returned to the application. If a given service class can be configured for a \nva- riety of usage patterns, an exemplar can be created for each configuration of that class. This reduces \nthe number of distinct classes needed to reflect a combination of service characteristics. One of the \nkey advantages of using exemplars for class selection is that the class factory does not need to know \nhow many concrete classes it contains. Users needing special-purpose concrete classes that were not supplied \nin the original li-brary can derive those classes from some point in the library hierarchy, override \nthe specific methods that need tuning, and reflect those differences in the exemplar s contract processing \ncode. Since the exemplar adds itself to the factory, this new class will automatically be considered \nas a candidate for future server creation with no changes required in the implementation of the abstract \nfactory class or existing application code. Without the exemplar mechanism, existing applications can \nbenefit from new service classes only if the application code is changed to specify the new classes or \nthe factory object-creation function is modified to include the new classes. The abstract factory approach \nalso allows the library implementer to restructure the internal hierarchy of concrete classes without \ndis-turbing existing application code. For example, a library might initially contain an array base class \nand two customized subclasses: one that supports concurrency and one that does not. Each of these subclasses \nwould contain vari-ous configuration options to support different com-binations of semantic attributes. \nSuppose applica-tions using this library are developed. Now sup-pose that the library developer decides \nto split the class that supports concurrency into three sepa-rate classes, each customized to support \na subset of the attributes supported by the original concurrent class. The developer may want to do this \nto im-prove efficiency. As long as applications use the ar-ray base class and specify semantic requirements \nin contracts, multithreaded applications whose con-tracts originally mapped to the single concurrent \nclass will now automatically use one of the new classes. No source code modifications in the appli- \ncations are required. The programs need only be relinked with the new library. Given exemplar-based \nobject construction, there are still numerous implementation issues to con-sider. For instance, how are \nthe exemplars orga-nized?, how is the bidding process accomplished?, how can applications avoid linking \nin unneeded ex-emplars?, etc. In the remainder of this section, we consider these issues. In Section \n4, we present an example C++ implementation of contracts and exemplar-based object construction. Since \nwe are interested in groups of exemplars derived from a common base class, the data struc-ture containing \nthe exemplars should belong to the base class. The simplest way to do this is to create a linked list \nfor each abstract factory class. Ex-emplars of classes derived from the factory class are added to the \nlist during exemplar initialization. Bidding can then proceed by iterating over the list and submitting \nthe contract to each exemplar in turn. Either the first exemplar to satisfy the con-tract is cloned or \nthe exemplar that best satisfies the contract is cloned. In the former case, the it-eration proceeds \nuntil one of the exemplars clones itself. In the latter case, each exemplar returns a bid value in response \nto the contract. The func-tion performing the exemplar iteration keeps track of the most attractive bid \nand clones that exemplar once all of the bids are examined. Clearly, if large numbers of exemplars are \nassoci-ated with each base class, iteration over all of them will be slow. If the first exemplar to satisfy \nthe contract is cloned, performance will be somewhat better. However, in this case the order of exem-plars \nin the list may influence which service class is constructed. Since applications might prioritize different \nservice characteristics, there may not be a single list ordering that is best for all applica-tions. \nNevertheless, the first bid wins approach does ensure that the server returned will satisfy the requirements \nspecified in the contract. To improve the performance of the bidding pro-cess, one could use more sophisticated \ntechniques than iteration over a linked list. The selection of a service class can be viewed as a search \nprocess over exemp!ars using the contract as the key. If the ex-emplars are organized during library \ninitialization into a classification network or a signature-based hash table, the search could be guided \nat runtime by the contract. If there are many exemplars, this could dramatically reduce the number of \nexemplars asked to bid on a contract. However, the value of complex algorithms must be weighed against \ntheir cost. More complex data structures require more memory and more complex search algorithms. Since \nthe library maintains mul-tiple exemplar lists, each attached to a different base class, most of the \nexemplars in the library are eliminated from consideration when the application specifies the base class. \nSince the exemplar bidding process is performed only during server object con-struction, it is unlikely \nto occur inside tight appli-cation loops where efficiency is crucial. The best technique for exemplar \nbidding ultimately depends upon the particular class hierarchy and expected patterns of use by applications. \nThis is an inter-esting research problem on its own. A naive implementation of contracts and exem- plars \nwould include all exemplars (and their asso- ciated code) in applications using the library. If most \nof these exemplars are never used (cloned) by an application, which is likely, this means lots of unused \ncode will be linked into the application. Furthermore, the presence of unused exemplars will slow the \nbidding process. Ideally, one would like to have each exemplar list contain only those exem- plars that \nwill be used by the application. Unfortu- nately, this information is not known until runtime. If the \ncontracts do not depend on runtime infor- Exemplar I&#38;t (instances of Set sutxlassea) /I note that \nwith contracts. applications d&#38;are their needs directly I/ in the contract rather than implicitiy \nthrough choosing a specific /I class from the lbmry. Figure 2: Generic Set Classes With Exemplars. mation, \nthis problem can be solved with the follow-ing technique. For each abstract factory class there is a \nheader file that causes all customized exemplars to be linked into an application. Applications dur-ing \ndevelopment and testing use this header file so all exemplars are included. If a certain mode is enabled \nduring testing, the base class keeps track of which exemplars are actually cloned in each ap-plication \nrun. As the application terminates, the base class exemplar (in its destructor) writes a new header file \nthat includes only the classes of cloned exemplars. Applications ready for produc-tion can use the new \nheader files and thereby avoid linking in unused exemplar code. With this tech-nique, the exemplar-based \napproach to customiza-tion does not necessarily lead to bloated code size. Another approach for eliminating \nunused exem-plars would be to process contracts at compile time or during a preprocessing stage. However, \nas mem-ory prices fall and operating systems add support for shared libraries, code size becomes less \nimpor- tant. Therefore, in the long run it may be unnec- essary to eliminate unused exemplars. Figure \n2 shows how exemplars and contracts could be used to simplify the application interface to the generic \nSet classes introduced previously. The object declaration below the diagram in Fig-ure 2 shows that applications \ndo not need to specify a particular service subclass if exemplars are used to create the servers. Instead, \nthe application can use the base template class, Set<T>. This exam-ple raises an interesting question: \nhow difficult is it to add support for contracts to an existing class li-brary? If one has access to \nthe library source code, it is possible to add constraint-checking methods and exemplar objects to the \nexisting classes. However, what if it is not feasible or not desir-able to modify the library source \ncode? Our basic contract and exemplar techniques would not work in this case, since the exemplars are \ninstances of the classes, and they must include constraint-checking methods to bid on contracts. There \nare two al- ternatives to modifying existing library code. One possibility is to create a new class \nhierarchy de-rived from the original library using multiple in-heritance to add the necessary methods. \nThis ap-proach is illustrated in Figure 3. The class MySet in Figure 3 contains the exemplar list and \nthe meth-ods for checking contracts and selecting exemplars. The new subclasses such as MyCHSet inherit \nthe constraint-checking interface from MySet and also inherit the Set functions from the original library \nclasses. Applications use the cloned exemplar ob-jects through the MySet interface. MySekint> application_set( \nspace=O(n):time=test~membership~=O(logn) ); Figure 3: Adding Contract Support via Inheri-tance. A second \napproach is to create shadow classes that simply encapsulate knowledge of the existing classes and do \nnot inherit from them. The exem-plars of the shadow hierarchy process the contracts and determine if \nthe classes they represent would satisfy them. When one of these shadow exemplars is chosen, it creates \na new instance of the original class it represents instead of cloning itself. Figure 4 illustrates this \napproach. Note that it is not actually necessary to create Set&#38;t> * application-set = //note that \nthe ap lication interface with a shadow hierarchy requires a different I/ syntax: an expl at will to \nMySet<int>::make() Is required, and a polnter to Pi II an original Set object is returned. Figure 4: \nAdding Contract Support via a Shadow Hierarchy. a complete shadow hierarchy corresponding to the original \nclass hierarchy. A shadow exemplar could contain knowledge of multiple classes in the original hierarchy \nand could represent all of those classes during server construction. Furthermore, it is pos- sible to \nadd new, application-defined service classes without modifying the original library by merging the exemplars \nof the new classes with shadow ex-emplar(s) in the abstract factory. 4 Example C++ Implementa-tion Although \nour approach to contracts and cus-tomization is not language-specific, our proto-type library includes \na C++ implementation of exemplar-based customization. In this section, we present this implementation. \nWe first dis-cuss support for constraint processing in the base class Md-Base. We next present two example \nservice classes: an abstract factory class called MdartsArray and a customized service class called RangeCheckedArray \nthat supports the semantic constraint range-checked . For brevity, part of the class hierarchy and some \nclass member func- tions are omitted. // The Constraint struct is used to store one (constraint, operator, \nvalue) // clause. struct Constraint { Constraint(int ct, char *c, char * o, char * v); &#38;onstraint(); \nint constraint-type; char * constraint; // constraint name char * oper; // operator string char * value; \n// value string class Exemplar { public: Exemplar(){} }; class Md-Base { protected: // ConstructServer() \nparses the constraints and / / tries to c/one an object that meets them. If // successful, returns server \nobject, else NULL. /I Md-Base * ConstructServer(const char * contract) { Md-Base t ex; // exemplar object \nptr Plist<Constraint> cl; MakeConstraintList(contract,cl); // find an exemplar that meets a// constraints \nPlist<Md-Base> &#38; elist = getExemplarList(); for (Pix p = elist.first(); p; elist.next(p)) { ex = \nelist(p); if ( ex-+checkAIIConstraints(cl) ) return ex+clone(); return 0; 1 // Pure virtual functions \nbelow. These must // be implemented by derived service classes. virtual void registerExemplar(MdBase \n* ptr) = 0; virtual int checkConstraint(const Constraint&#38; c) = 0; virtual void stageConstraintCheck() \n= 0; virtual Md-Base * clone0 = 0; virtual Plist<Md-Base>&#38; getExemplarList() = 0; 1; Code common \nto all exemplar-based class hierar-chies is factored into the abstract base class called Md-Base. This \nclass contains methods for pars-ing contract strings and cloning server objects from lists of exemplars. \nSince Md-Base declares pure virtual functions needed for exemplar-based object construction, derived \nclasses are forced to imple-ment the required functions. The Exemplar class is used as a dummy parame-ter \nto a special constructor in each derived service class that adds the exemplar to the base class ex-emplar \nlist. By declaring a static pointer to the ex-emplar in the service class, C++ static member ini-tialization \ncan be used to automatically construct and register exactly one exemplar per class. This technique is \nborrowed from Coplien [13]. class MdartsArray: public Md-Base { public: static MdartsArray + make{ const \nchar * contract) { return (MdartsArray *) ConstructServer(contract); 71 public MdartsArray methods here \n. . . protected :  // constructor for array object MdartsArray(int s) { sdatap = shared-memorymaIloc( \nsizeof(shared-data)+(s-l)*sizeof(int) ); sdatap+theSize = s; } // define basic constraints recognized \nby // MdartsArray classes. enum ConstraintType { unknown = -1, size, range-checked, expandable, sparse, \npersistent, concurrency }; // array representation: size and first element in // array stored together \nin shared memory. A // more realistic class wouid use templates struct shared-data { int thesize; int \ntheArray; // start of array 1; shared-data * sdatap; // list of derived exemplars -subclasses add // \ntheir own exemplars to this list by calling // registerExemplar(). static Plist<Md-Base> TheExemplarList; \nPlist<Md-Base> &#38; getExemplarList() { return TheExemplarList; } // Implementation of pure virtual \nfunctions // defined in class Md-Base. void registerExemplar(Md-Base * ob) { TheExemplarList.prepend(ob); \n} void stageConstraintCheck() { sdatap+theSize = 1; } // initialize state  // check a single constraint \nint checkConstraint(const Constraint&#38; c) { switch (c.constraint-type) { case size: sdatap+theSize \n= atoi(c.value); return 1; // success default: // only size supported by base return 0;  // definition \nof static (one per class) exemplar list Plist<Md-Base> MdartsArray::TheExemplarList; The constraint checking \nfunction in each service class consists of a switch statement over the enu-merated constraint type. This \ndesign permits rela-tively efficient processing of constraints. The con-tract string is parsed once and \nconverted to a list of Constraint structures. Once this is done, the constraint-checking methods of the \nexemplars can iterate over the Constraint list and need not per-form expensive string comparisons to \ndetermine the type of constraint to check. Note that class MdartsArray exports a pub-lic function called \nmake() that invokes the Md-Base::ConstructServer() function. This is the function used (directly or indirectly) \nby appli-cations to create customized server objects. A direct use of make0 by an application would look \nlike: MdartsArray<int> arrayob = Mdart-sArray::make( size=80,rangerhecked );. If make0 fails to create \na valid MdartsArray server object (as could happen if the contract contains constraints not supported \nby any of the exemplars), it returns NULL. If this object construction syntax is unde- sirable, it is \npossible to encapsulate the server ob-ject pointer and the make0 call in an envelope class that forwards \nserver functions to the internal ob-ject. The make0 function in each abstract factory class passes ConstructServer() \nthe contract string and the list of exemplars of derived classes. Con-structServer() parses the contract \nand converts it into a list of Constraint structs. It then submits the constraint list to each exemplar \nuntil one of them returns a clone (we use the simple first contractor to accept the contract wins bidding \ntechnique). The Md-Base pointer returned by ConstructServer() is cast to a pointer to an MdartsArray \nobject. This is a type-safe operation since all exemplars on the list belong to classes derived from \nMdartsArray. Each exemplar s stageConstraintCheck() function is invoked by the Md-Base::ConstructServer() \nfunc-tion before the constraints are checked. StageCon-straintCheck() is used to initialize the state \nof the exemplar to eliminate carryover from prior con-tracts. For example, if an exemplar derived from \nMdartsArray processes the constraint size=lOOO , it sets its internal theSize variable to 1000. This \nsize variable is used to determine how big the clone object s array will be. If a subsequent and com-pletely \ndifferent contract is processed that does not specify the MdartsArray size, we want theSize to de- fault \nto some constant value rather than retaining the value from the previous contract. It may be that state \nvariables must be ini-tialized at multiple points in the class hierarchy. Therefore, if derived classes \nimplement stagecon-straintCheck() t 0 initialize any state specific to that subclass, before returning \nthey should also invoke their base cla.ss(es) stageConstraintCheck() function(s). Once the exemplar state \nis initial-ized via stageConstraintCheck(), each constraint in the contract is evaluated by the exemplar \ns check-Constraint0 function. CheckConstraint() returns a boolean result to indicate whether the constraint \nis acceptable. class RangeCheckedArray: public MdartsArray { typedef inherited MdartsArray; protected: \n // constructors RangeCheckedArray(Exemplar) { registerExemplar(this); } RangeCheckedArray(int s) : MdartsArray(s) \n{ } static RangeCheckedArray * TheExemplar; Md-Base * clone0 { return new RangeCheckedArray(sdatap+theSize); \n} int checkConstraint(const Constraint&#38; c) { switch (c.constraint-type) { case range-checked: return \n1; default: // defer other constraints to base return inherited::checkConstraint(c); 1 > h // definition \nof static (one per class) data members RangeCheckedArray * RangeCheckedArray::TheExemplar = new RangeCheckedArray(Exemplar()); \nEach service class need only recognize a sub-set of the constraints defined by the abstract fac-tory \nclass. Like stageConstraintCheck(), checkcon-strainto chains up the inheritance hierarchy, de-ferring \nto its base class when unrecognized con-straints are encountered (see the default clause in the switch \nstatement of RangeCheckedArray s checkConstraint() function). Figure 5 illustrates the object creation \nsequence in our real-time database (called MDARTS). The r declaration of MDARTS obpct I MdarlsArraycPoinb \nobj( obj . constraints ); *,B 2. SDM finds exemplar list fa Md8rtiray<poin~. typ? and &#38;Led memory \n1ocali00 passes mfrainrs to exemplafs MdartsArray<Poinl> ob Figure 5: MDARTS Object Construction. application \ndeclares an object, and the constructor for that object forwards the type information of its class and \nthe object s name and contract string to an MDARTS database server. This server uses exemplar-based object \nconstruction to select and instantiate a server object that satisfies the con-tract.  5 Related Work \nThere has been considerable recent interest in al-lowing applications to influence implementation mapping \ndecisions of services in the domains of sys- tem software and languages. Mach allows users to implement \nand replace some of the basic services of the operating system [14]. In [153, Krueger et al. present \nan approach to application-specific virtual memory management. Jones discusses tools for re-placing system \nservices by redirecting system calls to user code [16]. Anderson argues that operat-ing systems should \nplace as much functionality as possible under application control [17]. The trend toward application \ncustomization can also be seen in the domains of compilers (e.g., Open C++ [18], parallelizing compilers \n[19], and Traces in Scheme [20]), and window systems (Silica [21]). Kiczales and Lamping examine the \ntrend toward service cus-tomization and identify the key themes of mapping dilemmas and meta-protocols \n[l]. The techniques we describe in this paper com-bine meta-protocols with class hiding through ab-stract \nclass factories. Gamma et al. [8, 91 dis-cuss using abstract class factories to hide concrete classes \nfrom applications. We expand on this idea by showing how exemplar-based server construc-tion allows applications \nto extend factories with-out modifying existing code. Furthermore, our declarative contract meta-protocol \nprovides a flex- ible means of communicating application require-ments and server characteristics that \nare not cap-tured in the abstract service interface.  Conclusion We have described a new approach to \nservice cus-tomization and specification based on client-side contract strings and exemplar-based server \ncon-struction. Our techniques permit the encapsu-lation of entire subtrees of classes in an object-oriented \nlibrary. Instead of exposing the applica-tion developer to many similar customized classes, the library \nimplementer can define a small set of abstract factory classes and hide the hierarchies of specialized \nconcrete service classes from applica-tions. Besides simplifying the application interface, this class \nhiding permits radical restructuring of the library implementation without breaking ex-isting applications. \nOur techniques should prove very useful for the development and management of large class libraries. \nAlthough our exemplar and client-side contract implementation requires class library implementers to \nfollow certain protocols, the price is not high compared with the benefits of software contracts and \nclass hiding. Much of the complexity of our technique is localized in the Md-Base class and in the abstract \nfactory class of each service hierar-chy. The additional support required in customized service classes \nis nominal. Nevertheless, in simple class libraries the additional complexity and over-head of our techniques \nmay not be justified. Li-brary designers can determine which service classes are sufficiently complex \nto benefit from our ap-preach. There are many ways our techniques could be extended. The runtime overheads \nassociated with class factories could be eliminated if the server selection were performed at compile \ntime. Fur-thermore, it would be interesting to develop more sophisticated techniques for organizing exemplars, \nconducting the bidding process, and negotiating constraints with exemplars if none of the exemplars were \nwilling to bid on the original contract. Acknowledgements We would like to thank Gregor Kiczales and \nthe other reviewers for their helpful feedback on an ear-lier draft of this paper. References G. Kiczales \nand J. Lamping, Operating sys- PI tems: Why object-oriented?, in Proc. of IWOOOS, pp. 25-30, October \n1993. V. B. Lortz, An Object-Oriented Real-Time PI Database System for Multiprocessors, PhD thesis, \nUniversity of Michigan, March 1994. R. Wirfs-Brock and B. Wilkerson, Object- PI oriented design: A responsibility-driven \nap-proach, in Proc. of OOPSLA, pp. 71-75, Oc-tober 1989. B. Meyer, Applying design by contract , PI \nIEEE Computer, vol. 25, no. 10, pp. 40-51, October 1992. R. N. Chang and C. V. Ravishankar, PI A service \nacquisition mechanism for the client/service model in Cygnus, in Proc. Int l Conf. on Distributed Computing \nSystems, pp. 90-97, May 1991. K. Ravindran and K. K. Ramakrishnan, A PI model for naming for fine-grained \nservice spec-ification in distributed systems, in Proc. Int l Conf. on Distributed Computing Systems, \npp. 98-105, May 1991. [7] R. Helm and Y. S. Maarek, Integrating in-formation retrieval and domain specific \nap-proaches for browsing and retrieval in object- oriented class libraries, in Proc. of OOPSLA, pp. 47-61, \nOctober 1991. WI T* Eggenschwiler and E. Gamma, ET++swapsmanager: Using object technology in the financial \nengineering domain, in Proc. of OOPSLA, pp. 166-177, 1992. [9] E. Gamma, R. Helm, R. Johnson, and J. \nVlis-sides, Design patterns: Abstraction and reuse of object-oriented design, in Proc. of ECOOP, pp. \n406-431, 1993. [lo] K. Vidyasankar, Concurrent reading while writing revisited, Distributed Computing, \npp. 81-85, 1990. [ll] D. Ungar and R. B. Smith, Self: The power of simplicity, in Proc. of OOPSLA, pp. \n227-242, October 1987. [12] W. R. LaLonde, D. A. Thomas, and J. R. Pugh, An exemplar based smalltalk, \nin Proc. of OOPSLA, pp. 322-330, September 1986. [13] J. 0. Coplien, Advanced C++ Programming Styles \nand Idioms, Addison Wesley, 1992. [14] M. Accetta, R. B aron, W. Bolosky, D. Goiub, R. Rashid, A. Tevanian, \nand M. Young, Mach: A new kernel foundation for UNIX de-velopment, in Proc. Summer 1986 USENIX Technical \nConference and Exhibition, June 1986. [15] K. Krueger, D. Loftesness, A. Vahdat, and T. Anderson, Tools \nfor the development of application-specific virtual memory manage-ment, in Proc. of OOPSLA, pp. 48-64, \n1993. [16] M. B. Jones, Transparently interposing user code at the system interface, in Workshop on Workstation \nOperating Systems, pp. 98-103, April 1992. [17] T. E. Anderson, The case for application- specific operating \nsystems, in Workshop on Workstation Operating Systems, pp. 92-94, April 1992. [18] S. Chiba and T. Masuda, \nDesigning an exten-sible distributed language with a meta-level architecture, in Proc. of ECOOP, pp. \n482-501, 1993. P93 L. H. R. Jr., A study on the viability of a production-quality metaobject protocol-based \nstatically parallelizing compiler, in Proc. of the Int ,I Workshop on New Models for Soft-ware Architecture, \npp. 107-112, November 1992. [20] G. Kiczales, Traces (a cut at the make isn t generic ) problem, in Proc. \nof the Int l Sym-posium on Object Technologies for Advanced Software, pp. 27-43, 1993. [21] R. Rao, Implementational \nreflection in sil-ica, in Proc. of ECOOP, pp. 251-267, 1991.  \n\t\t\t", "proc_id": "191080", "abstract": "<p>For performance reasons, client applications often need to influence the implementation strategies of libraries whose services they use. If an object-oriented library contains multiple service classes customized for different usage patterns, applications can influence service implementations by instantiating the customized classes that match their needs. However, with many similar service classes, it can be difficult for applications to determine which classes to instantiate. Choosing the wrong class can result in very subtle errors since a customized class might use optimizations that work only over a restricted domain. In this paper, we show how client-side software contracts and exemplar-based class factories can be used to construct customized server objects. By expressing  priorities and requirements in contracts, clients can delegate service class selection to the library and thereby avoid implicit dependencies on the library implementation. We have used this approach in the implementation of a real-time database system.</p>", "authors": [{"name": "Victor B. Lortz", "author_profile_id": "81407594591", "affiliation": "Real- Time Computing Laboratory, Department of Electrical Engineering and Computer Science, The University of Michigan, Ann Arbor, Michigan", "person_id": "P290809", "email_address": "", "orcid_id": ""}, {"name": "Kang G. Shin", "author_profile_id": "81100164227", "affiliation": "Real-Time Computing Laboratory, Department of Electrical Engineering and Computer Science, The University of Michigan, Ann Arbor, Michigan", "person_id": "PP14067785", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/191080.191150", "year": "1994", "article_id": "191150", "conference": "OOPSLA", "title": "Combining contracts and exemplar-based programming for class hiding and customization", "url": "http://dl.acm.org/citation.cfm?id=191150"}