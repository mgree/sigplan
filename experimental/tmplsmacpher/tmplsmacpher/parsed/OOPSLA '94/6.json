{"article_publication_date": "10-01-1994", "fulltext": "\n The Navigation Toolkit William F. Rich* Stephen W. Strom Flight Design and Dynamics Department Rockwell \nSpace Operations Company, 600 Gemini Ave., Houston, TX 77058 73062.1465@compuserve.com, *Current address: \nHC65 Box Abstract This report summarizes the experience of the au-thors in managing, designing, and implementing \nan object-oriented applications framework for orbital navigation analysis for the Flight Design and Dynamics \nDepartment of the Rockwell Space Operations Company in Houston, in support of the Mission Operations \nDirectorate of NASA s Johnson Space Center. The 8 person year project spanned 1.5 years and produced \n30,000 lines of C++ code, replacing 150,000 lines of Fortran/C. We believe that our experience is important \nbe-cause it represents a second project experience and generated teal production-quality code -it was \nnot a pilot. The project successfully demonstrated the use of continuous development or rapid prototyping \ntechniques. Use of formal methods and executable models contributed to the quality of the code. Keys \nto the success of the project were a strong architectural vision and highly skilled workers. This report \nfocuses on process and methodology, and not on a detailed design description of the product. But the \ntrue importance of the object-oriented paradigm is its liberation of the developer to focus on the problem \nrather than the means used to solve the problem. strom@acm.org 217A, Alpine, TX 79830 1. The problem \nNavigation is the process of taking measurements and using them to improve the knowledge of the position \nand velocity of one or more vehicles. The software system we were to build for analysis pur-poses had \nto be able to model the dynamics of physical systems, and simulate as well as process measurements from \nvarious sensors. The current system comprises 300,000 lines of mixed Fortran and C. In this first increment, \nwe decided to replace approximately half of this code with a completely re-engineered system written \nin C++.  2. Our solution There is no right way to do any particular project, and there is certainly \nno single way to do all projects. Indeed, the means must be determined by the end. However, we believe \nthe methodology and process we used have shown themselves to be highly successful in our domain, with \nour people. 2.1. Methodology At the outset. we were most heavily influenced by Booth, though we tried \nto remain goal-oriented and not become methodology slaves. The pri-mary changes we made were heavier \nuse of model- ing and formal methods.  2.1 .I. Language choices We chose C++ as the language to implement \nthe Addendum to the Proceedings final applications. Despite its general excellence, however, three problems \nplagued us: Strong typing, usually a blessing but sometimes causing us to write more code (possibly introducing \nmore errors than it prevented); programmer-supplied memory-management; and the lack of a good macro facility. \nWe also felt that a very-high-level language for modeling would be useful, primarily in support of requirements \ndevelopment. We chose Common Lisp, with the Common Lisp Object System (CLOS), as our modeling language \nfor several rea-sons: It supports many programming paradigms, including object-oriented programming; \nit is (relatively) efficient; the implementation of Common Lisp we used (Macintosh Common Lisp) had a \nremarkably small footprint, allowing it to run on the 4 MB PowerBook we used for much of our modeling \nwork; we had a long acquaintance and high comfort level with Lisp, particularly for object-oriented programming \n(Strom 1986); it is covered by an ANSI standard. 2.1.2. Domain analysis -steal but formalize We were \nable to reuse much of the documentation on the existing system, primarily because of the relatively clean \ndivision that was maintained between engineering and programming documentation. The more fundamental \nanalysis, however, was more difficult. This included the creation of classes describing space vehicles, \nthe forces acting on them, transformations between reference frames, etc. Most advanced textbooks on \nclassical mechanics (e.g., Goldstein 1980) take these concepts for granted. We therefore used a modem \nintroductory text (Hestenes 1986) as the foundation for this analysis. We used algebraic specification \ntechniques to capture the results of this domain analysis (as suggested in Srinivas 1990) and recorded \nthem in the software require-ments specification. 2.1.3. Rapid prototyping From the outset we were convinced \nof the need to verify the integrity of the architecture with work-ing prototypes. We were also convinced \nthat, if the change processes were controlled correctly, these prototypes did not have to be disposable. \nWe could achieve evolutionary development if all subprocesses contributed to the ease of rapid prototyping. \nFor example, configuration management facilitated the change process, rather than constricting it. We \ntracked, rather than restricted, the changes to our software. Rapid prototyping lowers the overall risk \nto the funding organization by providing almost imme-diate payback in the form of executable code. Here \nis a plot of the number of ultimately deliv-ered modules and lines of non-user interface code for our \nproject, as a function of time: . Non-GUI modules Non-GUI 2.1.4. The role of abstract dafa type uormal) \nspeci@c&#38; ons We previously worked in C with abstract data types. This experience led us to start \nthis new pro-ject by focusing on structure. This approach was insufficient to properly describe the desired \nbe- havior of a class, particularly under inheritance. For example, when we introduced forces, we wanted \nto be able to express the following design constraint: Structural descriptions could not do this. We \n turned, therefore, to abstract data type, or alge-braic, specifications. The power of formal specifi-cations \nto describe the interface (including behav-ior) of a class became immediately apparent. Here is part \nof the current interface to the classes Particle and Material-particle: class Particle { public: Vector \nposition_wrt(const Body&#38;); Vector velocity wrt(const Body&#38;); Vector acceleratio*_wrt(const Jkxiyh); \n protected: virtual Vector position(); virtual Vector velccity(); virtual Vector accelerationo; 1; \n class Materialgarticle : public Particle { public: Vector sum~of~forces(const Body&#38;); double mass(); \n protected: virtual vector accelerationo; // For all m in Materialmicle and // inertial reference frames \nb: // m.acceleration_wrt(b) = // m.sum of forces(b) / m.mass()  I We had worried that algebraic specifications \nmight be too abstract for users and developers. These fears proved to be unfounded.    2.1.5. A rigorous \ndefinition of sofbvare archi-tecture and detailed design Consider the following apparently plausible \ndesign for a Force class, based on Hestenes 1986 (we use Harrel s higraph extension of Venn diagrams, \nsee Harrel 1988): n Force ) Planet, as a subclass of Material-particle, can func-tion as an agent. When \nGravity is asked to com-pute the force on a material particle, it uses Newton s law of universal gravitation, \nthe mass of the material particle, and the gravitational parameter p stored in the agent (here a Planet). \nThere is only one problem with this design -It cannot be implemented in C++! Static typing prevents the \nGravity force from seeing the agent s I . This diagram should not be considered to be a bad design -it \nis simply not a design at all (for implementation in C++). (It could, however, be a design for a dynamically-typed \nlanguage such as Smalltalk, CLOS, or Dylan.) (A related problem is that other forces, e.g., drag, may \nrequire properties of the particle being acted upon besides mass.) The tendency to postpone the greatest \nrisk, namely, the software architecture, leads us to propose the following definition of software architecture \n-Software architecture is a description, in the implementation language, of the interfaces between the \nsoftware components. This definition has several advantages: the inter-face can be compiled, providing \na rigorous test for syntactic compatibility of the interfaces; it ad-dresses the greatest risk, i.e., \nimplementability of the software architecture, early in the project. The software detailed design is \nthe code. In accordance with IEEE Std 1016-1987, the design specification presents views of this design. \nRapid prototyping is increasingly detailed elucidation of the software design. Addendum ta the Proceedings \nOOPSLA 94 2.2. Process The process we created for development of the Navigation Toolkit was driven by \nthe problem we had to solve and the people we had to solve it. We held to the maxim that Processes don \nt write software -people write software. Our intent was to balance the need to give our people the freedom \nto develop good solutions against the need to continuously monitor the progress of the project. 2.2.1. \nTeam organization We organized the team along orthogonal Work-type (or W-type) and Application-type (or \nA-type) lines (Swanson and Beath, 1990). The W-type or-ganization followed Booth 1994, Brooks 1975, and \nStroustrup 1991. None of these roles was a full-time position. Instead, each team member was primarily \na programmer. Most of the classes to be developed required considerable technical expertise, requiring \nthe additional A-tY pe organization. Before initial delivery, the resulting team looked 2.2.2. Macro \nand micro models The macro process model we adopted is the spiral model (Boehm 1988). The spiral model \nis risk driven and incorporates prototyping as a funda-mental component. It provides a rich set of project \nmilestones and supporting documentation. We modeled the micro process with Meyer s cluster model, in \nwhich a set of staggered waterfalls de-scribes the development of clusters (groups of closely related \nclasses).  3. Assessment Time to look back, to assess (sometimes painfully) how well the project went. \n3.1. cost How well did we do in predicting the course of the project? Here is a comparison of our predictions \nand the delivered lines of non-U1 code: Class category Predicted Actual I SLOC SLOC I 1. Measurements \n3000 1473 2. Integrators 1000 762  3. Environment 4000 4434 4. Filter 4000 957 5. Utilities 2000 \n2389  6. Programs 5000 8148 Total 19000 18163 L We also estimated that there would be 11,000 lines of \nUI code, or 30,000 lines of source code in all. Simple COCOMO, organic mode (Boehm 1981), predicted 85 \nperson months of work. The actual cost of the project as a function of time is shown below: Actual Person \nMonths Estimated cost + unplanned work 1207 1;; We exceeded our cost estimates. Most of this is attributable \nto unplanned work in late 1993, associated with coordination with another com-pany project. We expended \n35 person months on this effort. Excluding this unplanned work, the cost of our project was extremely \nclose to our original projection. This implies that COCOMO is a reasonably valid cost model for object-oriented \nprojects. 3.2. Quality metrics Here is the cyclomatic complexity (metric 16 in IEEE Std 982.1-1988) of \nthe functions that comprise the Toolkit: Toolkit complexity 1 IO 100 Cyclomettc complexity There was \nno observable correlation between cy-clomatic complexity and defect density in our code. Halstead s complexity \nmetrics (metric 14 in IEEE Std 982.1-1988), derived from information-theo-retical concerns, appear to \nhave more utility for our code. Here is a histogram of the Halstead dif-ficulty of the Toolkit modules: \nToolkit Complexity Halstead dlffkulty The modules with higher Halstead difficulty turned out to be those \nwhich had been extensively optimized, and have exhibited a higher number of defects than modules with \nlower Halstead difficulty. Defects are usually tracked beginning with the completion of integration testing. \nWe began tracking defects following unit test to demonstrate that the code that emerged from unit testing \nwas of production quality. This contention is born out by the density of discovered defects (metric 2 \nin IEEE Std 982.1-1988): Discovered Defect Density It seems likely that the defect density will stabilize \nat well under 5 defects per KSLOC. Again, it must be emphasized that this is counting defects follow-ing \nunit rest. Rational has reported a defect density of 2.21 defects per KSLOC for the Beta 1 iteration \nof their Rose CASE tool (Walsh 1992). The qual-ity of our code, measured in defect density, is on a par \nwith the best industry standards. 4 Acknowledgments This work was performed under NASA contract NAS 9-18000. \nWe acknowledge the hard work and dedication of the following employees of Rockwell and Unisys who at \nvarious times were members of the Navigation Toolkit team: Gene Brownd, Kevin Buie, Francis Cerbins, \nMick Chang, Lynn Keller, Steve Labar, and Jigesh Saheba. We also thank the following users who were able \nto break our code in the most ingenious ways: Ed Brown and Addendum to the Proceedings OOPSLA 94 Carolyn \nPropst; interested colleagues from other areas who variously contributed time, ideas, valued criticism, \nencouragement, and equipment: Walt Pace, Matthew Verona, and George Wu; and the members of our management \nwho actually trusted us to do what we said we could do: Gene Brownd and Bill Heilman. 5. References Boehm, \nBarry W. 1981. Software engineering economics. Englewood Cliffs, New Jersey. Prentice-Hall. Boehm, Barry \nW. 1988. A spiral model of software development and enhancement. Computer 2 l(5): 61-72. Booth, Grady. \n1994. Object-oriented analysis and design with applications, 2d ed. Redwood City, California: Benjamin/Cummings. \nBrooks, Frederick P., Jr. The mythical man-month: essays on sofrware engineering. Reading, Massachusetts: \nAddison-Wesley. Btownd, J. E. 1992a. Post FADS software re-quirements for navigation. Flight Design and \nDynamics Department, Rockwell Space Operations Company. Brownd, J. E. 1992b. Navigation software status \nand actions, 1 l/6/92. Flight Design and Dynamics Department, Rockwell Space Operations Company. Goldstein, \nHerbert. 1980. Classical mechanics, 2d ed. Reading, Massachusetts: Addison-Wesley. Harrel, David. 1988. \nOn Visual Formalisms, Communications of the ACM 31, no. 5 (1988): 514-530. Henderson, Peter. 1993. Object-oriented \nspecifi-cation and design with C++. Maidenhead, Berkshire, England: McGraw-Hill. Hestenes, David. 1986. \nNew foundations for classi-cal mechanics. Dordrecht: Kluwer. IEEE Std 982.1-1988. IEEE standard dictionary \nof measures to produce reliable software. Piscataway, New Jersey: IEEE Press. IEEE Std 1016-1987. IEEE \nrecommended ptac- tice for software design descriptions. Piscataway, New Jersey: IEEE Press. Meyer, Bertrand. \n1988. Object-oriented software construction. Hemel Hempstead, Hertfordshire: Prentice-Hall. Prieto-Diaz, \nRuben and Guillermo Arango. 1991. Domain analysis and software systems modeling. Los Alamitos, California: \nIEEE Computer Society Press. Srinivas, Y. V. Algebraic specifications for do-mains. Technical report \nASE-RTP-102, Department of Information and Computer Science, University of California. Reprinted in Prieto-Diaz \nand Arango 1991. Strom, S. W. 1986. Object-Oriented Programming in Lisp. Houston: TRW Defense Systems \nGroup. Swanson, E. Burton and Cynthia Mathis Beath. 1990. Departmentalization in software develop-ment \nand maintenance. Communications of the ACM 33(6): 658-667. Walsh, James F. 1992. Preliminary defect data \nfrom the iterative development of a large C++ program. In OOPSLA 92 conference proceedings, edited by \nAndreas Paepcke. New York: ACM Press. 2.2. Process The process we created for development of the Navigation \nToolkit was driven by the problem we had to solve and the people we had to solve it. We held to the maxim \nthat Processes don t write software -people write software. Our intent was to balance the need to give \nour people the freedom to develop good solutions against the need to continuously monitor the progress \nof the project. 2.2.1. Team organization We organized the team along orthogonal Work-type (or W-type) \nand Application-type (or A-type) lines (Swanson and Beath, 1990). The W-type or-ganization followed Booth \n1994, Brooks 1975, and Stroustrup 1991. None of these roles was a full-time position. Instead, each team \nmember was primarily a programmer. Most of the classes to be developed required considerable technical \nexperti se, requiring the additional A-tY pe organization. Before initial delivery, the resulting team \nlooked Alplicalbn domain P-i%-cass 17 . ... 28 . . 21 ... 13 ... . . 8 . 5 . 4 . . . 2.2.2. Macro and \nmicro models The macro process model we adopted is the spiral model (Boehm 1988). The spiral model is \nrisk driven and incorporates prototyping as a funda-mental component. It provides a rich set of project \nmilestones and supporting documentation. We modeled the micro process with Meyer s cluster model, in \nwhich a set of staggered waterfalls de-scribes the development of clusters (groups of closely related \nclasses). 3. Assessment Time to look back, to assess (sometimes painfully) how well the project went. \n3.1. cost How well did we do in predicting the course of the project? Here is a comparison of our predictions \nand the delivered lines of non-U1 code: Class category Predicted Actual 1. Measurements 3000 1473 2. \nIntegrators 1000 762 3. Environment 4000 4434  4. Filter 4000 957 5. Utilities 2000 2389  6. Programs \n5000 8148 Total 19000 18163 We also estimated that there would be 11,000 lines of UI code, or 30,ooO \nlines of source code in all. Simple COCOMO, organic mode (Boehm 1981), predicted 85 person months of \nwork. The actual cost of the project as a function of time is shown below: Actual Person Months Estimated \ncost + unplanned work 1207 Portland, OR October 23-27, 1994 We exceeded our cost estimates. Most of \nthis is attributable to unplanned work in late 1993, associated with coordination with another com-pany \nproject. We expended 35 person months on this effort. Excluding this unplanned work the cost of our project \nwas extremely close to our original projection. This implies that COCOMO is a reasonably valid cost model \nfor object-oriented projects. 3.2. Quality metrics Here is the cyclomatic complexity (metric 16 in IEEE \nStd 982. I-1988) of the functions that comprise the Toolkit: Toolkit complexity 1 10 100 Cyclomstlc complexity \nThere was no observable correlation between cy-clomatic complexity and defect density in our code. Halstead \ns complexity metrics (metric 14 in IEEE Std 982.1-1988), derived from information-theo-retical concerns, \nappear to have more utility for our code. Here is a histogram of the Halstead dif-ficulty of the Toolkit \nmodules: Toolkit Comphaxlty The modules with higher Halstead difficulty turned out to be those which \nhad been extensively optimized, and have exhibited a higher number of defects than modules with lower \nHalstead difficulty. Defects are usually tracked beginning with the completion of integration testing. \nWe began tracking defects following unit test to demonstrate that the code that emerged from unit testing \nwas of production quality. This contention is born out by the density of discovered defects (metric 2 \nin IEEE Std 982.1-1988): Discovered Defect Density 01 : : : 1 : : f : : : : .4 ?~g?sa?~av~~ gs4:sp 2$2,p$ \na m z Q It seems likely that the defect density will stabilize at well under 5 defects per KSLOC. Again, \nit must be emphasized that this is counting defects follow-ing unit test. Rational has reported a defect \ndensity of 2.21 defects per KSLOC for the Beta 1 iteration of their Rose CASE tool (Walsh 1992). The \nqual-ity of our code, measured in defect density, is on a par with the best industry standards. 4 Acknowledgments \nThis work was performed under NASA contract NAS 9-18000. We acknowledge the hard work and dedication \nof the following employees of Rockwell and Unisys who at various times were members of the Navigation \nToolkit team: Gene Btownd, Kevin Buie, Francis Cerbins, Mick Chang, Lynn Keller, Steve Labar, and Jigesh \nSaheba. We also thank the following users who were able to break our code in the most ingenious ways: \nEd Brown and Addendum to the Proceedings OOPSLA 94 Carolyn Propst; interested colleagues from other \nareas who variously contributed time, ideas, valued criticism, encouragement, and equipment: Walt Pace, \nMatthew Verona, and George Wu; and the members of our management who actually trusted us to do what we \nsaid we could do: Gene Brownd and Bill Heilman. 5. References Boehm, Barry W. 1981. Software engineering \neconomics. Englewood Cliffs, New Jersey. Prentice-Hall. Boehm, Barry W. 1988. A spiral model of software \ndevelopment and enhancement. Computer 2 l(5): 61-72. Booth, Grady. 1994. Object-oriented analysis and \ndesign with applications, 2d ed. Redwood City, California: Benjamin/Cummings. Brooks, Frederick P., Jr. \nThe mythical man-month: essays on software engineering. Reading, Massachusetts: Addison-Wesley. Brownd, \nJ. E. 1992a. Post FADS software re-quirements for navigation. Flight Design and Dynamics Department, \nRockwell Space Operations Company. Btownd, J. E. 1992b. Navigation software status and actions, 1 l/6/92. \nFlight Design and Dynamics Department, Rockwell Space Operations Company. Goldstein, Herbert. 1980. Classical \nmechanics, 2d ed. Reading, Massachusetts: Addison-Wesley. Hart&#38; David. 1988. On Visual Formalisms, \nCommunications of the ACM 3 1, no. 5 (1988): 514-530. Henderson, Peter. 1993. Object-oriented spectfi-cation \nand design with C++. Maidenhead, Berkshire, England: McGraw-Hill. Hestenes, David. 1986. New foundations \nfor classi-cal mechanics. Dordrecht: Kluwer. IEEE Std 982. l- 1988. IEEE standard dictionary of measures \nto produce reliable software. Piscataway, New Jersey: IEEE Press. IEEE Std 1016-1987. IEEE recommended \nprac-tice for software design descriptions. Piscataway, New Jersey: IEEE Press. Meyer, Bertrand. 1988. \nObject-oriented sofhvare construction. Hemel Hempstead, Hertfordshire: Prentice-Hall. Prieto-Diaz, Ruben \nand Guillermo Arango. 1991. Domain analysis and sofhyare systems modeling. Los Alamitos, California: \nIEEE Computer Society Press. Srinivas, Y. V. Algebraic specifications for do-mains. Technical report \nASE-RTP-102, Department of information and Computer Science, University of California. Reprinted in Prieto-Diaz \nand Arango 199 1. Strom, S. W. 1986. Object-Oriented Programming in Lisp. Houston: TRW Defense Systems \nGroup. Swanson, E. Burton and Cynthia Mathis Beath. 1990. Departmentalization in software develop-ment \nand maintenance. Communications of the ACM 33(6): 658-667. Walsh, James F. 1992. Preliminary defect data \nfrom the iterative development of a large C++ program. In OOPSLA 92 conference proceedings, edited by \nAndreas Paepcke. New York: ACM Press.  \n\t\t\t", "proc_id": "260028", "abstract": "", "authors": [{"name": "William F. Rich", "author_profile_id": "81100311153", "affiliation": "HC65 Box 217A, Alpine, TX and Flight Design and Dynamics Department, Rockwell Space Operations Company, 600 Gemini Ave., Houston, TX", "person_id": "P299850", "email_address": "", "orcid_id": ""}, {"name": "Stephen W. Strom", "author_profile_id": "81100300686", "affiliation": "Flight Design and Dynamics Department, Rockwell Space Operations Company, 600 Gemini Ave., Houston, TX", "person_id": "P268900", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/260028.260097", "year": "1994", "article_id": "260097", "conference": "OOPSLA", "title": "The navigation toolkit", "url": "http://dl.acm.org/citation.cfm?id=260097"}