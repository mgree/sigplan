{"article_publication_date": "10-01-1994", "fulltext": "\n Semantic Locking in Object-Oriented Database Systems * Rodolfo F. Resende t Divyakant Agrawal Amr El \nAbbadi UFMG-ICEx-DCC Department of Computer Science Caixa Postal 702 University of California 30161-970, \nBelo Horizonte MG Santa Barbara, CA 93106 Brazil USA  Abstract Object-oriented databases are being increasingly \nused to model non-standard applications that em-phasize modularity, composition, and rapid proto-typing. \nA semantic locking protocol is presented for transaction management for such object-oriented databases. \nIn particular, the protocol incorporates the semantics of complex objects, nested executions and dynamic \nconflicts resulting from referentially shared objects. 1 Introduction Object-oriented databases are \nbeing increasingly used to model non-standard applications. These applications place new constraints \non databases de-sign. In particular, they emphasize modularity, composition, and rapid prototyping. Often \nbasic objects are defined, and more complex and ad-vanced objects are composed recursively in terms of \nthese basic objects. As a result, the traditional notion of conflict based on read and write opera-tions \nmay impose unnecessary constraints on the execution of transactions in such systems. To alle-viate this \nproblem, an appropriate approach is to *Supported in part by NSF grant numbers IRI-9117094. Supported \nby CNPq -Conselho National de Desenvolvi- mento Cientifico e Tecnol6gico. Permission to c y without \nfee all or part of this material is granted provided Tlt at the copies are not made or distributed for \ndirect commercial advantage, the ACM copyright notice and the title of the publication and Its date appear, \nand notice is given that copying is by permission of the Association of Computing Machinery. To copy \notherwise, or to republish, requires a fee and/or specific permission. OOPSIA 94- 1 O/94 Portland, Ore \non USA 0 1994 O-89791 -688-3194 0010..$3.50 ACM 7 use the semantics of higher level objects to ensure \ncorrect execution of transactions. Another aspect of an object-oriented database system is that an operation \ninvoked on a higher level object results in an entire execution hierarchy on lower level ob-jects, sometimes \nreferred to as composite objects. If traditional approaches such as strict two phase locking are used \nto manage composite objects, the execution hierarchies of two conflicting operations must be completely \ndisjoint from each other. This would be analogous to the approach of executing transactions serially \nin a shared database system. To remedy this problem, a protocol for executing transactions in object-oriented \ndatabases must al- low execution hierarchies of different transactions to be interleaved as long as \ntheir behavior is equiv- alent to an execution in which these hierarchies are disjoint. Finally, conflicts \namong execution hier-archies of transactions are often not known a pri-ori rather they are established \ndynamically during the execution. Protocols for transaction manage-ment in object-oriented databases \nneed to address all these issues, viz., higher level semantics, nested executions, and dynamic conflicts. \nIn relational databases, the data is passive and has a flat structure. Nested transactions have been \nproposed in that context but the motivation is mainly for modularity of application and pro-gram design. \nOn the other hand, in an object oriented databases, objects are active and have a nested structure. As \na result, nested executions is of fundamental concern for transaction management in object oriented databases. \nFurthermore, unlike relational databases where all interactions to the database are via read and write \noperations, objects have rich semantics associated with them. This se-mantics can potentially be used \nto increase concur-rency among concurrent transactions. In this pa-per, we present a locking protocol \nfor transaction management in an object oriented databases. This protocol is novel since it incorporates \nthe notion of semantics for executing nested transactions and is applicable for object oriented databases \nwith ref-erential sharing among disjoint objects. We believe this is an important property of object \noriented sys-tems since new objects are composed from existing objects, hence referential sharing among \nunrelated objects is unavoidable. Earlier work on transaction management in object oriented databases \nhas either ignored the issue of semantics [HH91], or have only used semantics partially [AE94], or do \nnot com-pletely deal with referential sharing [MRW+93]. The paper is organized as follows. The model \nis described in Section 3. We motivate the notion of using semantics for object oriented databases and \nthe protocol in Section 4. In Section 5, we describe the protocol which is based on the above design \ncri-terion. We conclude with a discussion in Section 6.   Related Work In traditional databases, the \nmost commonly adopted correctness criterion is serializability. Object-oriented database systems such \nas ORION [GK88, Kim901 and 02 [CF90, BDK92] ensure the serializable execution of transactions. Both of \nthese database systems employ a locking protocol based on multigranularity locking [Gra78]. Multigranu-larity \nlocking was developed to reduce locking over-head by organizing the database in the form of a hierarchy, \ne.g., the database is composed of files, and each file is composed of a set of records etc. By obtaining \na lock at a higher level, transactions implicitly lock entities at the lower levels. The de-signers of \nORION and 02 developed similar proto-cols replacing the database hierarchy by the class and object hierarchy \nin object oriented databases. However, their approach is based on the traditional notion of read and \nzurite locks and the strict two phase locking protocol. Thus, these approaches do not employ the semantics \nof higher level oper-ations available in object-oriented databases. Fur-thermore if an object is locked, \nevery descendant of that object in the hierarchy is also locked even if the transaction may only access \na small subset of that sub-hierarchy. In particular, a significant drawback with this approach is the \nfollowing. In object-oriented databases, a transaction execution begins by executing an operation or \na method on a higher level object which in turn invokes operations or methods on other objects resulting \nin a nested structure of the transaction execution. By using the standard two-phase protocol with multigranularity \nlocking, ORION and 02 do not exploit the nested behavior of transaction executions to increase con-currency. \nHowever, the major strength of these two systems, from the transaction management point of view, is that \nthey directly address the issue of schema evolution and extensibility. In particular, the proposed protocols \nallow concurrency between schema changes as well as user transactions. This approach was also applied \nto complex objects with pre-declaration of locks [HDK+90]. Moss [Mos85] introduced the notion of nested \ntransactions for modular composition of applica-tions and programs in database systems. He proposed the \nnested two phase locking protocol (N2PL) which is a generalization of the well-known two-phase locking \nprotocol for concurrency control [EGLT76]. Beeri, Bernstein and Goodman [BBG89] presented a description \nof nested transactions sys-tems, which includes a definition of serializability, and a set of basic techniques \nthat can be used for proving the serializability of nested computa-tions. Hadzilacos and Hadzilacos [HH91] \nsimplified the model proposed by [BBG89] and applied it to transaction executions in object-oriented \ndatabases. In particular, Hadzilacos and Hadzilacos explicitly model the nested execution of transactions \nand pro-pose a correctness criterion for such executions. They present a nested two phase locking protocol \nfor an object oriented database that is a generaliza-tion of the locking protocol for nested transactions \nproposed by Moss [Mos85]. In this protocol, locks are requested for the atomic operations, which cor-respond \nto the leaves in the nested execution. When a method execution terminates, its parent inherits its locks. \nA lock is granted only if there are no other conflicting locks. Locks are discarded only when the top-level \ntransaction terminates. The proposed mechanism, however, does not take advantage of the semantics of \nthe methods at the higher levels. Agrawal and El Abbadi [AE94] have proposed a concurrency control protocol \nfor providing transac-tional access to object-oriented databases. They provided a uniform treatment for \ndealing with both class and instance objects and extend the two phase locking protocol to objects with \narbitrary opera-tions. The novel aspect of this protocol is that conflicting operations may share locks \non the same objects, provided that the order between the oper-ations is preserved. This protocol is extended \nfor synchronizing nested executions of transactions on objects. Allowing updates to both classes and \nin-stances of these classes makes the proposed proto-col beneficial for extensibility and experimentation, \nwhich are needed for continuously evolving object oriented database applications. However, this pro-tocol \nalso does not exploit the semantics of higher level methods to increase concurrency. Muth et al. [MRW+93] \npresent a locking pro-tocol for object oriented databases. The authors adopt a notion of commutativity \nsimilar to the one in [BBG89] in which the conflicts between lower level operations or methods can be \nignored due to the commutativity of the corresponding higher level methods in the nested execution. However, \nthe pro-tocol cannot be used with object-oriented databases with referentially shared objects, i.e., \nnon-disjoint complex objects. This is a severe limitation since composition is one of the fundamental \nproperties of object-oriented databases as well as a necessary con-dition for modular design. Furthermore, \nsuch ref-erential sharing cannot be described statically since it may arise dynamically depending upon \nthe input parameters and the specific execution environment. This protocol requires locks not only for \nthe atomic operations but also for method executions. In par-ticular, the system designer has to derive \na conflict or commutativity table not only for the atomic op-erations of each class but also for all \nthe method executions of all the classes in the database. In this paper, we develop a locking-based concurrency \ncontrol protocol for object-oriented databases. Our protocol generalizes Moss s orig-inal nested transaction \nprotocol in that it incor-porates the rich semantic information available in object oriented databases. \nOur protocol incorpo-rates the notions of semantics of higher level ob-jects [BBG89, MRW+93], nested \nexecutions [HH91, AE94, MRW+93] and dynamic conflicts. In par-ticular, we address the issue of referentially \nshared objects where the referential sharing is determined dynamically during the execution. The correctness \nof our protocol is based on the theory of nested transactions proposed in [BBG89]. 3 The Model An object \noriented database is a collection of classes and instances of these classes. A class defines a set of \nattributes for its instances and methods or proce-dures that are used to manipulate these instances. \nWe assume that each class definition is physically represented as a class object and each instance is \nrepresented as an instance object. Thus, we use the generic term object to refer to both classes and \nin-stances of these classes. An object supports both atomic operations on its local state as well as \nmeth- ods to access both the local state as well as to access other objects. Users access objects by \nexecuting methods defined on objects or atomic operations associated with objects. A method execution \nis a partial order of method executions and atomic oper-ations [HH91]. Such a caller-calIee relationship \nbe-tween methods establishes a hierarchy that is known as nested transactions or nested method executions \n[Mos85]. We assume that the objects are ordered in a hierarchy and a method in one object can only call \nmethods on objects that are lower in the hierarchy. Figure 1 shows a database schema consisting of three \nclasses of objects: Customer, Item, and Order. This example is similar to the one in [MRW+93] but is \nextended to a more realistic setting that supports referentially shared objects. Each customer can have \nseveral orders and each or-der may mention one or more items. Furthermore, each item could have been \nmentioned by several or-ders. Note that a particular object of class Order class Customer class Item \ncustomerNo: integer itemNo: integer name: string name: string orders: set(Order) quantity: integer orders: \nset( Order) price: float Figure 1: Attributes of classes could be referentially shared among a customer \nand several items. Figure 2 illustrates the skeleton of two methods. The class Customer defines a method \nstatus-of-orderso which invokes method report-status() on each of the orders of the customer where the \nstatus of an order indicates whether the order is pending, processed, etc. The class Order computes the \ntotal value of the order by simply accessing the quantity and price of each tuple in the set items. It \nis possible for the price of some item to be different from the list price of that item, perhaps due \nto a discount. The method total-list-price() defined in the class Order computes the list-price for the \norder. In the class Order, the method report-status() is implemented with atomic operation read(status) \n. Similarly in class Item, report-price( ) is imple-mented with atomic operation read(price) . As in \n[HH91], we assume that user transactions are methods of a distinct object called environment. We will \nbe using the terms transaction and method execution interchangeably. We also assume the ex-istence of \na special method execution, To, in the en-vironment object that invokes the top-level method executions. \nFigure 3 shows an example of transac-tions causing nested calls of method executions in an object oriented \ndatabase whose objects are in-stances of the classes in Figure 1. The execution or-der is from left to \nright. Method executions are rep-resented by circles, and atomic operations are rep-resented by squares. \nTransaction Tr calls method status-of-orderso on Customer object John. The transaction Tr is invoked \nwith a key value such as a name or a customerNo and uses the select opera- class Order orderNo: integer \ncustomer: Customer status: integer itemset: set(tuple(item: Item, quantity: integer, price: float)) Customer, \nItem, and Order tion to retrieve the object-id of John. For the sake of simplicity, we omit such operations. \nJohn has two orders 01 and 02. Transaction 572 computes the total list price of two orders 02 and 03. \nOrder 02 is for two items gadget1 and gadget2 and 03 is for gadget2. Since there is one customer for \neach or-der, from the figure we can conclude that John is the customer of order 02 and has ordered gadget1 \nand gadget2. Standard tree terminology is used to refer to re-lationships among method executions. For \nexample method executions total-list-price() on objects 02 and 03 are chiZdren of T2 in Figure 3. Node \nzc is a de-scendent of y if z = y or 2 is a child of a descendent of y. Node z is a proper descendent \nof y if it is a de- scendent other than y itself. Ancestor relationship is defined analogously. Two method \ninvocations 2 and y on the same object commute if and only if the two possible sequential executions \nof 5 and y are indistinguishable for both z and y and for all possible sequences of methods that may \nbe invoked subsequently [CF90, HW91, MRW+93]. Table 1 il- lustrates the commutativity relationships between \nthe methods of class object Item (note that the en-try I indicates that the relationship is undefined). \nWe assume that the commutativity relationships between the operations are well-defined and can be derived \nbased on the semantics and the specifica-tions of the class and its methods. However, in a dy- namic \nobject oriented database system, methods on different objects may invoke methods on the same objects \nresulting in conflicts (specially when refer-ential sharing is allowed). Such a conflict cannot be determined \na priori based on the static analysis method status-of-orderso: . . . for each orders objectID objectID:report-status0 \nod . . . end met hod; do method total-list-price(): . . . for each itemID in itemset do . . . read(itemID.quantity \n) . . . itemID.item:report-price0 od end met hod; Figure 2: Examples of Methods --r--- \\ / ( f repofl-p~4 \n  f --- I -f . \\ Figure 3: Concurrent execution of two transactions decrease-percent0 report-price0 \nchange-price0 commute I I decrease-percent0 I I L report-price0 I I I change-price0 Table 1: Commutativity \nTable for Object Class Item 392 rather it materializes as the particular methods are executed. N2PL captures \nthese conflicts using lock inheritance, however, it fails to take advantage of any object semantics. \nOur approach extends N2PL to object-oriented databases and uses the additional semantic information to \nincrease concurrency. Beeri, Bernstein, and Goodman [BBG89] devel-oped a general theory to reason about \nnested ex-ecutions with semantics. They introduced two transformations that establish an equivalence \nre-lationship between executions: substitution and commutativity-based reversals. Substitution can be \nspecialized in terms of reduction and expansion. Us-ing sequences of these two transformations we can \nestablish the equivalence of some execution and its serial counterpart, proving serializability of nested \nexecutions. A transaction x is separated if no other operations of other transactions are interleaved \nwith its leaves. Consider a transaction x where all its children are leaves and it is separated. Reduction \nis a transformation that relates two nested execu-tions where the first one has a separated transac-tion \nz whose children are leaves and the second is the same as the first except that 2 was substituted by \nthe atomic operation corresponding to transac-tion 2. (The underlying assumption is the existence of \na correspondence between a transaction and an atomic operation, i.e., if the execution of a trans-action \nis atomic then there exists a corresponding atomic operation.) Expansion is the inverse of re-duction. \nThe transformation commutativity-based reversal relates two computations where the first has two consecutive \nleaves that commute and the second is the same as the first except that these two consecutive leaves \nare reversed. We call con-flict serializability the notion of serializability where all conflicts are \npreserved, and semantic serializ-ability the serializability where some conflicts can be ignored based \non the semantics of operations at higher level [BHG87, BBG89, MRW+93]. Mot ivat ion Locking is a mechanism \ncommonly used to solve the problem of synchronizing access to shared resources. Locks are place holders \nfor checking concurrency control predicates. Each atomic operation has a lock associated with it. Before \na method execution may execute an atomic operation, a lock must be requested and granted. We say that \na method that executes an atomic operation 2 holds lock lock(x). We say that Zock( x ) conflicts with \nlock(t), if atomic operation x conflicts with atomic operation t. When a method execution t terminates, \nits parent inherits all the locks t owns. A special case occurs when the terminating method execution \nis a top-level one. In this case the locks are released, i.e. they cease to exist. The locks that a method \nexecution x inherit from method executions that are its children are said to be retained by Z. This means \nthat there are two ways for a method execution to own a lock. Method execution x can own lock(x) in the \nsense of holding, meaning that atomic operation 2 is ex-ecuted directly by xl. Method execution x can \nown lock(x) in the sense of retaining, meaning that atomic operation z was executed by some proper descendent \nof x . In N2PL Zock(x) can be granted to method execution x , i.e. atomic operation z can be executed \nby x , iff no other method execution holds a conflicting lock, and all the retainers of a conflicting \nlock are ancestors of x . We summarize the nested two-phase locking (N LPL) rules adapted from [Mos85] \nas follows. 1. A method execution t can execute an atomic operation t, iff lock(t) is requested and is \ngranted (we say that the method execution t holds lock(t)). 2. A method execution cannot terminate (commit \nor abort) until all its children have terminated. When a method execution terminates: (a) It is not top-leveE \nand it commits: Its locks are inherited by its parent (we say that the parent retains the inherited locks). \n (b) It is not top-level and it aborts: Its locks (a) No other method execution holds a con-flicting \nlock, and  are discarded. (c) It is top-level: Its locks are discarded. 3. A lock ecution lock(x) iff \ncan be granted to a method ex- (b) All the retainers of a conflicting lock are ancestors of the requesting \nmethod execu-tion. It is shown in [BBG89, HH91] that N2PL ensures serializability. N2PL does not take \nadvantage of any knowledge about the semantics of the methods being executed. We now show an example \nof how N2PL can potentially take advantage of the seman-tics of method executions in order to ignore \ncertain conflicts and accept more executions. Suppose that the class Item of Figure 1 has a method decrease-percent() \n. This method de-creases the price of its corresponding item. Ob-serve that two instances of method decrease-percent() \ncommute since percentage operations commute. Figure 4 shows two transactions Tl and TX that execute methods \ndecrease-percent() concurrently on gadget1 and gadget2. Observe that method decrease-percent() is implemented \nusing two atomic operations read(price) and write(price) . In the traditional conflict serializ-ability \nthat does not take advantage of semantics of higher level operations in nested transactions, this execution \nwould be considered non-serializable. In this execution, transaction Tl must be serialized be-fore transaction \nTz because of the conflicts in gad- get1 and transaction Tz must be serialized before transaction 2 1 \nbecause of the conflicts in gadget2. However, if the semantics of decrease-percent() is taken into consideration \n(see Table l), two such operations commute and hence their relative order is not significant. Therefore, \nthis execution will be serializable and is equivalent to both Tl before Tz or vice-versa. Note that there \nare cases where seman-tic information cannot be used to ignore conflicts at the lower level. For example, \nconsider another execution of the same two transactions that is il- lustrated in Figure 5. In this execution \nwe can-not apply the commutativity information between the two decrease-percent() method executions on \ngadget2. This is because the commutativity of these two method executions is derived assuming the atomicity \nof the operations. In this execution the two method executions are not executed atom-ically with respect \nto each other. Using the theory described in [BBG89] we can establish the semantic serializability of \nthe execu-tion showed in Figure 4. We can reduce the com-putations rooted at method executions decrease-percent() \nsince these computations are separated. Now we can use the semantics of the Item object to apply commutativity-based \nreversals on the re-duced method executions decrease-percent() of gadget2. Basically nested two phase \nlocking does not have any mechanism that allows lower level con-flicts (such as read(price) , write(price) \nin Fig-ure 4) to be ignored by using the semantics at higher level methods (e.g., decrease-percent( In \nthe next section we present semantic locking, a proto-col that uses semantics to increase concurrency \nin object oriented databases. 5 Semantic Locking We start by describing some of the salient as-pects \nof object-oriented databases that are consid-ered in the design of our protocol. In general, in object-oriented \ndatabases, the conflicts and com-mutativity relations between methods are defined on a per class basis. \nMethods on different objects are generally assumed to commute with each other [GK88, CF90, HH91, MRW+93]. \nThis approach is reasonable for object-oriented databases with dis-joint complex objects. However, in \na system with referentially shared sub-objects, the commutativity relation needs to be redefined even \nfor methods that are executed on different objects. One approach could be to define these relations across \nobjects stat-ically, but this approach would be very conservative and defeats the goal of modularity \nand extensibil-ity in object-oriented databases. Furthermore, the referential sharing of objects may \noccur dynami-cally during execution. We assume that commu-tativity relations are defined for atomic operations. \nThis is the same assumption made by most pre-vious work in both nested transactions and object oriented \ndatabases [Mos85, HH91, FLWSO]. How-ever, we enrich this model by exploiting semantic information, i.e., \nby using commutativity relations that are derived from the semantics of methods of classes. The conflict \nand commutativity rela- /- Figure 4: A semantic serializable execution gadget1 / \\ write(price) ~z~read(price) \nwrit7 Figure 5: A nonserializable execution tions between methods that referentially share sub-objects \nare left unspecified and are determined dy-namically during the execution of such methods. Thus, tests \nfor conflicts are done only for methods executing at the same object. Methods in different objects will \nexecute concurrently and depending on their executions, the proposed protocol will capture the conflict \nrelations among such methods. 5.1 The protocol In semantic locking each atomic operation has a lock associated \nwith it. Before a method execution may execute an atomic operation, a lock must be re-quested and granted. \nThis is similar to [Mos85], locks are only required for the execution of atomic operations and contrasts \nwith [MRW+93] where locks are required for the execution of methods. Similar to [Mos85] when a method \nexecution ter-minates its parent inherits all its locks. The locks that a method execution z inherits \nfrom its chil-dren are said to be retained by 2. In semantic locking, locks can be granted to conflicting \nopera-tions if the corresponding operations have commut-ing ancestors. The important observation to make \nregarding semantic information is that two meth-ods, which are known to commute, commute only if both \nare executed atomically . Hence in Figure 4 a pair of decrease-percent() commute if the op-erations implementing \nthese methods do not inter-leave. Once all the operations implementing one decrease-percent () are executed \nthe operations of another decrease-percent() can execute. We im-plement this idea by allowing decrease-percent() \nof Tl to acquire the lock for read(price) only af-ter the locks on read(price) and write(price) are inherited \nby T2. In particular, a lock request lock(t) which conflicts with another lock, lock(x) can be granted \nusing semantic information only when lock(x) is inherited by a node whose descen-dent commutes with an \nancestor of lock(t). In this case, we say that the pair of commuting ancestors relieves the conflict \namong atomic operations. More formally assume that lock(t) is requested and it conflicts with Zock(x). \nIf lock(t) is granted while lock(x) is still retained by some method execution because there are commuting \nancestors x and t of nodes x and t respectively then we say that (z , t ) relieves conflict (x, t). We \nnow describe the protocol which is referred to as semantic locking. We introduce the following notation \nfor intervals of related nodes to simplify the presentation of the protocol. Let x be a method execution \nand let x be a descendent of z, [x . . -x ] represents the set {a 1 a E descendents(x) A a E ancestors( \nx )}. If we substitute [ or I by ( or ) the proper descendents/ancestors should be taken e.g. (x-..x \n] = [x.. mx ] - {x}. A method execution must observe the following semantic locking rules: 1. A method \nexecution t can execute an atomic operation t, iff lock(t) is requested and is granted (we say that the \nmethod execution t holds Eock( t)). 2. A method execution cannot terminate (commit or abort) until all \nits children have terminated. When a method execution terminates: (4It is not top-level and it commits: \nIts locks are inherited by its parent (we say that the parent retains the inherited locks). w It is not \ntop-level and it aborts: Its locks are discarded. (4It is top-level: Its locks are discarded. 3. A lock \nlock(t) can be granted to a method ex- ecution iff (a) No other method execution holds a con-flicting \nlock, and (b) For all other non-ancestor methods x that retain a conflicting lock(x), some el-ement \n2 of (2 - . -xl and some ancestor t of t commute ( (x , t ) relieves the conflict  (x7 w According \nto Rule 1, locks must be acquired only for the leaves (atomic operations). Rule 2 en- forces the strict \ntwo phase locking restriction for nested executions. Rule 3 relaxes the nested two phase locking constraint \nby using a possibly avail-able commutativity relation between method exe-cutions based on semantic information. \nIn nested two phase locking, a lock can be acquired provided: . No other method execution holds or retains \na conflicting lock; or . if there are conflicting locks, such locks are re-tained by the ancestors. Semantic \nlocking grants a lock in the above cases as well as in the following case: . If there are conflicting \nlocks retained by non-ancestors then one of the ancestors of the op-eration up to but not including its \nretainer and some ancestor of the requester commute. In this latter case semantic information is used \nby the locking protocol, hence the name semantic locking protocol.  5.2 Implementation issues We briefly \ndiscuss an implementation of the seman-tic locking protocol proposed in this paper. Our approach is to \ngeneralize the implementation pro-posed for nested two-phase locking protocol [Mos85] and we have chosen \na similar terminology to that in [MRW+93]. Ob viously semantic locking demands more implementation effort \nthan N2PL, but this extra demand does not add significant complex-ity. Objects have methods and atomic \noperations, and belong to a certain object class. The scheduler maintains for each object class: . A \nconflict table indexed by the atomic oper-ations. An entry in a conflict table indicates whether any \ntwo atomic operations conflict or not; . A commutativity table indexed by methods. An entry in a commutativity \ntable indicates whether two methods commute or that it is unknown that they commute. The scheduler also \nmaintains a lock table in each ob-ject that determines which atomic operations have locks requested and \ngranted. The following struc-ture adapted from [Mos85] illustrates some of the relevant fields of an \nentry in a lock table: Lock Record Format parent-id state-information ancestors The lock record entry \nparent-id identifies the transaction who currently holds/retains the lock on this object. The entry state-information \nis neces-sary for recovery purposes which is not dealt with in this paper. The entry mode indicates the \ntype or name of the atomic operation being executed on this object. The last entry contains additional \ninforma-tion that is needed primarily for semantic locking. In particular, the entry points to a list \nof ancestors of the transaction that initiated the atomic opera-tion. This information will be used by \nthe sched-uler to determine if a certain conflict at the atomic operation level can be relieved due to \ncommuting ancestors (Rule 3(b) in Section 4.1). Now we describe the scheduling actions enforced in the \nsemantic locking protocol. Methods can be called at any time and the scheduler keeps track of the hierarchy. \nWhen an atomic operation is invoked a lock must be obtained before the operation is ex- ecuted. We will \nrefer to the parent of the operation as the requester. The scheduler uses the conflict and lock tables \nto check if a lock can be granted. If the requested lock does not conflict with other locks or if there \nis a conflict and the correspond-ing operations have the same parent, an entry is created in the lock \ntable and the lock is granted, al-lowing the operation to execute. Otherwise, if the lock conflicts with \nother locks whose operations are not siblings, an entry is created in the lock table but the granting \nwill have to wait for the termina-tion of some method executions as follows. We must find for each operation \ncorresponding to a conflict-ing lock the lowest ancestor that commutes with any ancestor of the requester \n(or the corresponding child of their least common ancestor). In this case, we use the commutativity table \nto determine whether the methods commute. Assume that a lock was requested for operation p, and that \np.conflict-set denotes the set of operations that conflict with p, p.waits-for-set denotes the set of \nmethods that p has to wait for before its lock can be granted. Let p.object the object where p was invoked. \nFigure 6 illustrates the steps involved in acquiring locks. In 2PL, the wait-for-set of a conflicting \noperations con-sists of the top-level transactions that hold conflict-ing locks. In N2PL, this set consists \nof the least common ancestors of the holders/retainers of the conflicting lock and the lock requester. \nIn our case, on the other hand, the set may contain descedants of the least common ancestors if these \ndescendants commute with an ancestor of the requester. for each q in p.conflict-set do add to p.waitsfor-set \nthe lowest commuting ancestor of q with respect to the conflict between q and p, if they do not have \ncommuting ancestors then add the child of the least common ancestor of p and q that is an ancestor of \nq; od install an entry in lock table of p.object for lo&#38;(p) as requested; wait until the nodes in \np.waitsforset terminate; modify the entry in lock table for lock(p) as granted; grant lock(p) to the \nrequester; Figure 6: Pseudo-code for acquiring locks When a method execution terminates the sched-uler \nsignals the operations that are waiting. When a top-level transaction terminates all its locks are released \nand the information about the operations of this transaction can be thrown away. One way to implement \nthis is to maintain a reference to all objects that were visited by descendents of method executions. \nIf the information about commutativity of methods is not used our implementation is essen- tially the \nsame implementation as in N2PL [Mos85]. We use the example in Figure 7, to illustrate the dynamics of \nour design. Method execution T2 of the environment object is invoked and calls method execution Tz.decrease-percent0 \nof object gadget2. Method execution Tz.decrease-percent0 will need price) w-it ice) r cc) q P F r2 w2 \n1 Figure 7: How locks are granted in gadgetl. to acquire locks on atomic operations 9-2 and 202. Operation \nw2 conflicts with ~2 but both have the same requester. Hence, the lock corresponding to w2 can be granted \nto Tz.decrease-percent(). Now, the lock table of gadget2 has two entries corre- sponding to ~2 and 202. \nTI calls method execu- tion Ti.decrease-percent0 of gadget2, but Zock(rr) cannot be immediately granted \nsince ri conflicts with w2. The commutativity table of class Item indicates that decrease-percent0 methods \ncommute with each other, hence Tr.decrease-percent0 in gad- get2 waits until Tz.decrease-percent0 in \ngadget2 terminates. (Tz.decrease-percent0 is the lowest ancestor of w2 that commutes with some ances-tor \nof ~1, in this case Tr.decrease-percent()). Af-ter Tz.decrease-percent0 terminates and locL(ri) is granted \nthe lock table of gadget2 has three entries corresponding to ~2, w2 and ~1. Similarly loclc(wr) cannot \nbe immediately granted since wi conflicts with ~2 and w2 (it also conflicts with ~1 but they have the \nsame requester). The lowest ancestors of r2 and w2 that commute with an ancestor of w2 are the same node \ni.e. Tz.decrease-percent(). Since it is terminated, EocL(wi) is granted. Observe that if there are no \nancestors that commute, e.g., decrease-percent0 methods in the example, a con-flicting node will have \nto wait for the termination of the corresponding top-level transaction. 5.3 Analysis We underscore the \ndistinction between nested two phase locking and semantic locking with the help of an example. In particular, \nrecall the execution illus-trated in Figure 4. Nested two phase locking cannot derive this execution. \nIn particular, Tl is blocked by T2 at the level of gadget2. Method execution decrease-percent () of \ntransaction Tl is blocked trying to acquire a lock on method read(price) (it conflicts with the lock \non method write(price) held by decrease-percent() of transaction T2). Similarly, T2 is blocked by Tl \nat the level of gadget 1. Method execution decrease-percent() of transac-tion T2 is blocked trying to \nacquire a lock on method read(price) and hence deadlocked. When seman-tic locking is used for this execution \nthere will be no deadlock. Consider for example the method execu-tions of TI and T2 on the Item gadget2. \nWhen Tl ex-ecutes its read(price) on gadget2, it conflicts with the write(price) executed by T2. However, \nthe semantic locking rule permits decrease-percent() of Tl to acquire a lock for executing read(price) \non gadget2 after decrease-percent() of T2 termi-nates and the lock corresponding write(price) on gadget2 \nis retained by T2. Since commutativity of decrease-percent() is defined for completed opera-tions, the \ndecrease-percent() executed by Tl must wait until the decrease-percent{) executed by T2 has completed \nfor the commutativity property to hold. This explains the reason for excluding the retainer z in the \nexpression (z - - -2 1 of Rule 3 in the protocol. However, note that even with seman-tic locking, deadlocks \nare possible. For example, in Figure 5, semantic locking results in a deadlock. This occurs since both \nTl and T2 are both blocked when trying to obtain locks on gadget2. To reason about the correctness of \nsemantic lock-ing we use the two transformations described in [BBG89]. We illustrate the use of these \ntwo trans-formations in Figure 8 using the example of Fig-ure 4. Since each decrease-percent() in execu-tion \n(a) is separated we can reduce them. We can go from execution (a) to execution (b) by us-ing four reductions. \nEven though we maintain the labels decrease-percent () , in execution (b) these nodes are actually substituted \nby the corresponding atomic operations. In execution (b) we can apply commutativity-based reversal in \norder to separate Tl, coincidentally we also separate T2 and we ob-tain execution (c). In execution (c), \nsince TI and T2 are separated we can use two reductions to ob-tain execution (d) which is a serial execution. \nWe now use the bottom-up proof paradigm of [BBG89] to informally argue about the correctness of semantic \nlocking. The goal is to create a sequence of equivalent executions starting from an execution, Co, resulting \nfrom semantic locking and terminat-ing with a serial execution, Cserial, consisting of top-level transactions. \nThe proof paradigm is to establish a sequence of equivalent executions and the intermediate executions \nin this sequence are re-ferred to as Ci. We choose a node, separate it us-ing as many commutativity-based \nreversals as nec-essary, and then reduce it. We repeat this separa-tion and reduction process until only \nthe top-level method executions are left. With this we establish the equivalence of the execution produced \nby se-mantic locking with a serial execution consisting of only the operations corresponding to the top-level \nmethod executions. In each iteration we choose for the separation and reduction the node 2 whose rightmost \nchild is the leftmost among nodes that have only leaves as chil-dren. We have to prove that it is always \npossible to separate z. We say that an operation interleaves within 2 if there are children of 5 at the \nleft as well as the right of this operation. Our proof obligation is to show that in spite of such interleavings, \nthere always exists such an z that can be separated. For Ce no operation t that conflicts with a child \nof z in- terleaves within 2. This is the case since from rule 3 of the protocol t must wait at least \nuntil z has terminated. We now need to argue that this sepa-ration and reduction can be performed when \nwe are dealing with any intermediate execution C;. For the sake of contradiction assume that in Ci we \ncannot separate z whose rightmost child is the leftmost among nodes that have only leaves as chil-dren. \nThis may be because xl, a child of z, conflicts with and precedes y and that y conflicts with and precedes \nxr, another child of x as shown in Fig-ure 9. Since xl conflicts with y there exist descen- gadget1 \ngadget1 decrease-cent0 fi<waa Figure 8: Using commutativity-based reversals and reduction Figure 9: \nA hypothetical blocked x. dents xi and y of xl and y respectively in Ce, such that x conflicts with and \nprecedes y . Assume that this conflict was not relieved. Then y must have waited until the lock on xi \nwas released or inher-ited by an ancestor of y . In both cases, and due to the choice of x, all descendants \nof x must have terminated before y was executed. Hence, y could not have been interleaved within the \nchildren of x. Next assume the conflict was relieved by a pair: an-cestor of xi, ancestor(xi), and a \nproper ancestor of y, ancestor(y), as shown in the figure. Since com-mutativity is defined on a per object \nbasis, both ancestor(x;) and ancestor(y) must be methods of the same object. Since ancestor(xi) is an \nancestor of xi and ancestor(y) is a proper ancestor of y, then by our assumption of hierarchy of objects, \nxl must be a method executed on an object higher in the object hierarchy than the object on which y was \nexecuted. A similar argument can be used to show that if y conflicts and precedes x,., y is a method \nex-ecution higher in the object hierarchy than method execution x. Since x is a parent of xl this violates \nour assumption that method executions are always called from a higher level to a lower level in the ob-ject \nhierarchy. This argument can be extended to the general case when a sequence of nodes ~1, . . . , yn \nare interleaved within z [Res94]. We conclude this section by noting that the pro-tocol depends crucially \non the assumption that ob-jects are modularly designed and that they are hi-erarchically organized in \na static manner. Although this is a desirable property, in practice, object ori-ented databases may be \ndesigned in such a way as to violate this restriction. In this case, Rule 3 of the protocol needs to \nbe modified so as to dynam-ically capture any violations of this ordering in a particular execution. \nFor example, a pair (p,q) of commuting methods may not be used to relieve a conflict if another pair \n(z, t), where q is a proper descendant oft and p is a proper ancestor of x, was already used to relieve \na conflict. In general, this restriction must be enforced not only in a pairwise manner rather transitively \nin an execution. By en-forcing this restriction dynamically we can ensure that no incorrect executions \noccur without impos- ing a static hierarchy on the objects. The details of the implementation and correctness \nproof of this approach appear in [Res94].   6 Conclusion In this paper, we presented a semantic locking \npro-tocol for transaction management in object-oriented databases. Unlike traditional locking protocols, \nour approach serializes transactions at the level of method executions, i.e., the protocol takes into \ncon-sideration the semantics of methods executions. In addition, our protocol is novel in the sense that \nit supports referentially shared objects as well as con-flicts that arise dynamically during execution. \n References [AE94] D. Agrawal and A. El Abbadi. A Non- restrictive Concurrency Control Proto-col for \nObject Oriented Databases. Dis-tributed and Parallel Databases, An In-ternational JournuE, 2( 1):7-31, \nJanuary 1994. [BBG89] C. Beeri, P. A. Bernstein, and N. Good- man. A Model for Concurrency in Nested \nTransactions Systems. Jownal of the ACM, 36(2):230-269, April 1989. [BDK92] F. B ancilhon, C. Dolobel, \nand P. Kanel- lakis, editors. Building an Object- Oriented database System: The story of ence on Extending \nData Base Technol- 02. Morgan Kaufmann, 1992. ogy, Springer-Verlug, LNCS 416, pages 219-237, March 1990. \n[BHG87] P. A. Bernstein, V. Hadzilacos, and N. Goodman. Concurrency Control and [HH91] T. Hadzilacos \nand V. Hadzilacos. Recovery in Database Systems. Addison Transaction Synchronization in Object Wesley, \nReading, Massachusetts, 1987. Bases. Journal of Computer and Sys-tem Sciences, 43( 1):2-24, August 1991. \n[CF90] M. Cart and J. Ferrid. Integrating Special issue on the 7th Annual ACM Concurrency Control into \nan Object-SIGACT-SIGMOD Symposium on the Oriented Database System. In Pro-Principles of Database Systems, \nMarch ceedings of the International Confer- 21-23, 1988. ence on Extending Data Base Technol-ogy, Springer-Verlag, \nLNCS 416, pages [HW91] M. P. HerIihy and W. E. Weihl. Hy-363-376,199O. brid Concurrency Control for Abstract \nData Types. Journal of Computer and [EGLT76] K. P. Eswaran, J. N. Gray, R. A. Lo-System Sciences, 43(1):25-61, \nAugust rie, and I. L. Traiger. The Notions 1991. Special issue on the 7th An- of Consistency and Predicate \nLocks in nual ACM SIGACT-SIGMOD Sympo- a Database System. Communications sium on the Principles of Database \nSys- of the ACM, 19( 11):624-633, November tems, March 21-23, 1988. 1976. [KimSO] Won Kim. Introduction \nto Object-[FLWSO] A. Fekete, N. Lynch, and W. Weihl. Oriented Databases. The MIT Press, A Serialization \nGraph Construction for 1990. Nested Transactions. In Proceedings of the Ninth ACM Symposium on Prin-[Mos85] \nJ. E. B. Moss. Nested Transactions: An ciples of Database Systems, pages 94-Approach to Reliable Distributed \nCom-108, April 1990. puting. MIT Press, Cambridge, Mas-sachusetts, 1985. [GK88] J. F. Garza and W. Kim. \nTransac-tion Management in an Object-oriented [MRW+93] P. Muth, T. C. Rakow, G. Weikum, P. Brossler, \nand C. Hasse. Seman- Data Model. In Proceedings of the tic Concurrency Control in Object- ACM SIGMOD \nInternational Confer-ence on Management of Data, pages Oriented Database Systems. In Pro- 37-55, June \n88. ceedings of the 9th IEEE International Conference on Data Engineering, pages [Gra78] J. N. Gray. \nNotes on database sys- 233-242, April 1993. tems. In R. Bayer, R. M. Graham, and [Res94] R. Resende. \nSynchronization in Nested G. SeegmuIIer, editors, Operating Sys-transactions. PhD thesis, Department \ntems: An Advanced Course, volume 60 of Computer Science, University of Cal- of Lecture Notes in Computer \nScience, ifornia at Santa Barbara, 1994. pages 393-481. Springer-Verlag, 1978. [HDK+SO] U. Herrmann, \nP. Dadam, K. Kuspert, E. Roman, and G. Schl ageter. A Lock Technique for Disjoint and Non- Disjoint Complex \nObjects. In Pro- ceedings of the International Conjer-  \n\t\t\t", "proc_id": "191080", "abstract": "<p>Object-oriented databases are being increasingly used to model non-standard applications that emphasize modularity, composition, and rapid prototyping. A semantic locking protocol is presented for transaction management for such object-oriented databases. In particular, the protocol incorporates the semantics of complex objects, nested executions and dynamic conflicts resulting from referentially shared objects.</p>", "authors": [{"name": "Rodolfo F. Resende", "author_profile_id": "81100417226", "affiliation": "UFMG-ICEx-DCC, Caixa Postal 702, 30161-970, Belo Horizonte MG, Brazil", "person_id": "PP31091492", "email_address": "", "orcid_id": ""}, {"name": "Divyakant Agrawal", "author_profile_id": "81350572364", "affiliation": "Department of Computer Science, University of California, Santa Barbara, CA", "person_id": "PP15028386", "email_address": "", "orcid_id": ""}, {"name": "Amr El Abbadi", "author_profile_id": "81100403960", "affiliation": "Department of Computer Science, University of California, Santa Barbara, CA", "person_id": "PP40026896", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/191080.191144", "year": "1994", "article_id": "191144", "conference": "OOPSLA", "title": "Semantic locking in object-oriented database systems", "url": "http://dl.acm.org/citation.cfm?id=191144"}