{"article_publication_date": "10-01-1994", "fulltext": "\n Reflections on Metaclass Programming in SOM Scott Danforth Ira R. Forman IBM Object Technology Products \n11400 Burnet Road Austin, TX 78758 Abstract. This paper reports on the evolution of metaclass programming \nin SOM (the IBM System Object Model). Initially, SOM s use of explicit men&#38;asses introduced metaclass \nincompatibilities. This was cured by having SOM dynamically derive an appropriate metaclass by interpreting \nthe metaclass declaration as a constraint. In effect, inheritance is given a new dimension, because the \nconstraint is also inherited. The derived metaclass is the least solution to all these constraints. Subsequently, \nthis cure led to the possibility of metaclasses conflicting over the need to assign meaning to a method. \nThe cure for this problem is a framework that facilitates the programming of metaclasses that cooperate \non the assignment of meaning to methods. Introduction The term procedural reflection was introduced by \nSmith [ 18,191 to describe a general theory and mechanism allowing computational systems to reason about \ntheir own operations and structures. Reflective capabilities have now been studied within a variety of \ndifferent computational systems (CommonLoops [ 11. 3KRS [16], Scheme [9,21], LISP [6], ObjVLisp [5,11], \nABCL/R [22], Rosette [20], and CLOS [3,15]). This paper discusses some of the ways reflective capabilities \nare useful and important to SOM metaclass programmers. In a more general sense, the word reflection seems \nappropriate for describing the overall purpose of this paper, a thoughtful overview of the origin and \nhistorical development of mechanisms supporting metaclass programming in SOM. Permission to copy without \nfee all or part of this material is granted provided that the copies are not made or distributed for \ndirect commercial advantage, the ACM copyright notice and the title of the publication and its date appear, \nand notice is given that copying is by permission of the Association of Computing Machinery. To copy \notherwise, or to republish, requires a fee and/or specific permission. OOPSLA 94- lo/94 Portland, Or \non USA 0 1994 O-89791 -688-3194 0010..$3.50 ACM 7  First Principles The benefits of using OOP for system-level \nsupport of component software development in systems like Smalltalk-and NextStep (based on Objective-C) \nare by now well-known and accepted. SOM s objective is to allow binary class libraries to provide these \nbenefits independent of programming languages and compilers. To provide language-neutrality, SOM defines \na runtime API that is based on a few external procedures and simple data structures. This API is used \nby programmers (or by language bindings or by DirectI oSOM compilers) to create and use SOM objects according \nto a traditional object-oriented model of computation. Within this context, SOM has two fundamental guiding \nprinciples: 1. If changes to the implementation of a class don t require changes to client source code \n(i.e., code that subclasses or uses instances of the class), it should be possible to replace the class \ns implementation (in a binary library) without requiring recompilation of client co&#38;. 2. The SOM \nAPI should be expressed as an object-oriented system composed of SOM objects available to the programmer. \n  The main reason for the first principle is to support component software. Once application binaries \nare delivered to users, any need for recompilation of source is best avoided --even when aspects of the \nsupporting system are reorganized or reimplemented. The first principle thus maximizes the flexibility \navailable for supporting system evolution when OOP is used to implement and publish system interfaces. \nThis issue cannot be taken lightly. Evolution of an OOP system often suggests refactorings of its class \nFigure 1 -- Relationships between the SOM Kernel Obiects d hierarchy, even though this may not require \nsource level changes in client code. From the perspective of metaclass programming, however, this principle \nrepresents a serious challenge [7]. The section on SOM-derived metaclasses, below, explains the unique \nmechanism provided by SOM for answering this challenge. The second principle results in implementing \nclasses as objects, which creates the very possibility of metaclass programming in SOM (if classes are \nobjects, they must be instances of other classes called metaclasses). The second principle also relates \ndirectly to a fundamental requirement for reflection explained by [19]: reflection requires a model within \nwhich to express the operations, structures, and overall protocols that are used to organize and control \ncomputation. The SOM abstract machine expresses such a model for OOP, and a bootstrap procedure creates \na concrete embodiment of this model as the initial SOM runtime environment. In particular, the second \nprinciple results in a model of the operations, objects, and protocols used for implementing object-oriented \ncomputation --i.e., for subclassing, inheriting methods, adding new methods, overriding inherited methods, \nand dispatching methods. Thus, in SOM, the fundamental requirement of reflection is met as a result of \nfirst principles --the operations and objects used to implement OOP computation are reflected in concrete \nSOM objects immediately available to executing code. The SOM capabilities based on these principles enable \nits users to program at a higher level. As this paper explains, the ability to program at a higher level \nunfolded in several stages. First was SOM s adoption I I of metaclass programming as its metaobject protocol. \nSecond was the invention of the derived metaclass. Third was a framework that allows metaclasses to cooperate \non the definition of method implementations. The result is that rather than merely programming classes \nanew or as extensions of previously written classes, SOM users will be able to factor functionality in \nnew ways, which in turn leads to achieving programming goals by composing classes. Thus, SOM users can \nprogram at a higher level (as can any programmer with an available metaobject protocol).  The SOM Abstract \nMachine The SOM abstract machine has changed in many ways since the introduction of SOM in OS/2 2.0, \nwhere SOM was used to implement the Workplace Shell (a class framework representing aspects of the OS/2 \n2.0 system). But, the top-level structure of the SOM machine remains the same. When the SOM runtime environment \nis created, the objects illustrated in Figure 1 are created and made available to the SOM user Figure \n1 contains the two primitive classes that are the basis for all subsequent classes: . SOMObject - the \nroot ancestor for all SOM classes . SOMClass -the root ancestor of all SOM meta- classes. All SOM objects \nare an instance of a SOM class, and all SOM classes are ultimately derived by subclassing from SOMObject. \nThus, all SOM objects can execute the methods introduced by SOMObject. In a similar manner, all SOM classes \nare an instance of a SOM metaclass, and all SOM metaclasses are ultimately de- rived from SOMClass. \nThus, all classes can execute the methods introduced by SOMClass. Both SOMOb-ject and SOMClass are instances \nof SOMClass. In addition to SOMObject and SOMClass, the SOM kernel includes the class SOMClassMgr which \nimple- ments a runtime class registry. This allows use of dy- namically loaded libraries (DLLs) to define \nSOM classes. As illustrated in Figure 1, the SOM nmtime en-vironment initially contains the above three \nclasses and a class manager (i.e., an object that is an instance of SOMClassMgr). In SOM the class of \nan object defines its implementation. Therefore, in SOM, reflective code is method code that follows \nthe instance-of link from self (the object on which the method is invoked), because SOM provides the \nmethod somGetClass for this purpose. Operational use of the SOM API Although Figure 1 shows the primitive \nobjects used to implement SOM, an understanding of SOM includes knowing how these objects are used. For \nexample, to create a new class in SOM, the following steps are followed: . Choose a me&#38;class object \n(either SOMClass or some class derived from SOMClass) and create a new instance of the metaclass -- this \nwill be the new class. SOMClass introduces a number of different methods for creating new objects, and, \nat this stage the new class we are creating is simply a new object that happens to be an instance of \na metaclass. . Inform the new class object of its parents by using the somInitMIClass method. Whenaclass \nexe-cutes this method, it creates an initial instance method table by inheriting the contents of its \npar- ents instance method tables. The instance method table of a class determines the behavior of its \ninstances. . Add new methods to the class and override inherited methods by using the methods provided \nby SOM-Class for this purpose. These methods, when applied to the new class object, modify the class \ns instance method table that was created in the previous step. . Use somClassReady to inform the class \nthat its construction is complete. This method registers the new class with the SOMClassMgrObject, so \nthat client code can access the class for further subclass- ing or instance creation. Language bindings \nor DirectToSOM compilers automatically provide code that does the above steps according to static information \nprovided by a class designer, thus removing these considerations from the direct concern of the programmer. \nBut it is important to understand that all classes in SOM are runtime objects created by invoking methods \non other objects as explained above. In general, SOM programmers can create classes according to dynamically \ncomputed requirements. This is of crucial importance, because supporting static class definition in SOM \nhas required the dynamic derivation of metaclasses. To understand this surprising fact, it helps to review \nhow metaclasses appear and are used in OIDL, the object interface definition language of SOM 1 .O Metaclasses \nin SOM 1.0 The original version of SOM was supported and implemented using C language bindings generated \n(by the SOM compiler) from class declarations expressed using OIDL (Object Interface Definition Language). \nOIDL provided two different ways of statically indicating the information necessary to create new metaclasses. \nAccordingly, metaclasses were either explicit or implicit metaclasses. An explicit metaclass is declared \nby explicit subclassing from some other metaclass (perhaps from SOMClass). Here is an example. class: \nCounted; parent: SOMClass; data: long instancecount; methods: long getInstanceCount(); overrides: \n somInit; somInitMIClass; somNew;  Instances of the above metaclass include (in addition to inherited \nclass variables) a class variable to record the number of instances of the class and (in addition to \nthe inherited class methods) a class method to allow users to access the current instance count. The \nnew metaclass overrides the method somInit (introduced by SOMObject) and overrides the methods somInitMIClass \nand somNew (both introduced by SOMClass). The implementation of Counted must therefore provide four method \nprocedures: one to execute the new method, getInstanceCount, and three others for the overridden methods. \nIn OIDL, a class designer explicit metaclass when illustrated here. indicates declaring the a use class, \nof an as class: ClassExample; parent: SOMObject; metaclass: Counted; On the other hand, an implicit \nmetaclass is declared implicitly when declaring the class intended to be its instance, as illustrated \nby the following OIDL: class: ClassImplicitExample; parent: SOMObject; data: long instancecount, class: \nmethods: long getInstanceCOunt(), class; overrides: somInit, class; somInitMIClass, class; somNew, \nclass; The above OIDL explicitly declares a class named ClassImplicitExample and also implicitly declares \na metaclass that has the same fundamental characteristics as Counted, declared above. This is done by \nusing the class modifier to indicate that either data or methods are to be attributes of the class being \ndeclared (as opposed to being attributes of instances of the class). But there is an important difference \n--the implicit metaclass has no name. The functionality it provides, while generally useful, is available \nonly on ClassImplicitExample and its descendants. In contrast, the functionality packaged by Counted \nis available, by name, to any class. Implicit metaclasses can know and make use of the methods inherited \nand introduced by their instances. A class (for example Y in Figure 2) might implement an instance method \nby invoking a class method on itself (reached by first using somGe tC1 as s on the target instance), \npassing the target instance as an argument to the class method, and then use an implicit metaclass I \nto implement the class method using instance methods introduced by Y. In contrast, an explicit metaclass \nis normally designed to be of use to any class, and therefore doesn t make any assumptions concerning \nthe methods inherited or introduced by its instances (other than that these inherited methods must include \nthose introduced by SOMObject). It would probably seem more reasonable to package functionality for providing \ninstance counts using an explicit metaclass such as Counted. Note that Smalltalk was the first language \nto have class as objects [ 141, but it provides only implicit metaclasses.  @ . . . . . . . ..I. @ \n. . . . ..I.. @ 8 , @ . . . . . . . . ), . Q $ 8 8 Figure 2 --Semantics of Implicit Metaclasses Areas \nof Concern for SOM 1.0 How, specifically, are implicit metaclasses derived? What are their parents, and \nof which classes are they instances? Figure 2 illustrates the general situation for SOM 1.0 implicit \nmetaclasses. The class Y has been derived by subclassing X, and the class I is the implicit metaclass \ndeclared by Y s designer. I is derived by subclassing from MX (X s class) and is created as an instance \nof MMX (MX s class). This semantics supports SOM classes as polymorphic objects useful through the interfaces \nof all ancestor classes. For example, recall the example scenario suggested above for reflective programming \nwith implicit metaclasses. It is imperative that class methods introduced by MX be available on Y, because \nthe implementation of Y s methods is inherited from X, and these methods may access the class of the \ninstance target and invoke methods introduced by MX on this class. The above derivation of I guarantees \nthis Figure 3 --The Problem with Explicit Metaclasses in SOM 1.0 result in general, for all implicit \nmetaclasses. Unfortunately, SOM 1.0 does not provide a similarly pleasing result in the case of explicit \nmetaclasses. For example, using the explicit metaclass Counted declared earlier, it is possible to construct \nthe following example, in which the class of Y does not support an appropriate interface: class: X; parent: \nSOMObject metaclass: Counted; class Y; parent: X; metaclass: SOMClass;  Figure 3 illustrates the semantics \nof these declarations in SOM 1.0, and the following code, expressed using the C bindings of SOM 1.0, \nillustrates the problem with the class Y in Figure 3. Execution of this code creates a method resolution \nerror because the class of Y, SOMClass, doesn t support the method rumInstances 0nY. #include <Y.h> \nvoid printCount(X *x) {/* This code is typesafe on Xs */ printf(\"%d\\n*, -numInstances(-somGetClass(x))); \nI main0 {Y *yInstance = YNew(); /* But this call with a subclass instance fails */ _printCount(yInstance); \nI This kind of situation was identified by Nicolas Graube [ 121, who characterized the problem in terms \nof metuclass compatibility. Put simply, SOMClass is not compatible with the requirements placed on Y \ns class to support the Counted interface. However, SOM 2.0 doesn t construct class hierarchies with metaclass \nincompatibilities. Instead, SOM 2.0 automatically builds new metaclasses that are compatible with their \nrequirements, dynamically subclassing from existing metaclasses whenever this is necessary. Metaclasses \nin SOM 2.0 While supporting previously existing binaries, SOM 2.0 added multiple inheritance and complete \nsupport for OMG s CORBA (Common Object Request Broker Architecture) [ 171. Although OIDL is still supported \nby the SOM compiler, the preferred language used to declare SOM classes is now CORBA IDL. The following \nis an IDL declaration for the metaclass Counted: interface Counted : SOMClass { readonly attribute \nlong instancecount; #ifdef -SOMIDL- implementation ( somInit: override: somInitMIClass: override; \n somNew: override; 1. iendif 1; CORBA IDL was designed to support interfaces to objects, not their \nimplementations. The SOM IDL implementation section (guarded with an #i f def) provides additional information \nused by the SOM compiler to create language bindings that assist in implementing SOM classes whose objects \nsupport the declared interface. For brevity, the # i f de f is omitted in following illustrations. Here \nis the IDL for X and Y of the previous example: interface X : SOMObject ( implementation { metaclass \n= Counted;}; 1; interface Y : X { implementation ( metaclass= SOMClass;}; 1; IDL doesn t provide implicit \nmetaclasses, but explicit . . . ..{I. Figure 4 -- SOM 2.0 supports classes as polymorphic objects metaclasses \ncan serve the same purposes. A close coupling between the implementations of a metaclass and its instances \nis supported from IDL by using the IDL pre-processor to make such metaclasses statically visible only \nto a restricted set of class declarations (normally, a single class). Details of this are not important \nto this paper. But, the fact that all metaclasses in IDL are explicit underscores the importance of providing \nan improved semantics for explicit metaclasses in SOM 2.0.  SOM-derived Metaclasses In SOM 2.0, if a \nmetaclass is indicated in a class declaration, the new class is constructed (at runtime) either as an \ninstance of the indicated metaclass or as an instance of some class derived from the indicated metaclass. \nIn the second case, there are two possibilities: the metaclass may already exist as a user-defined metaclass, \nor, if necessary, SOM will derive it dynamically in the process of creating the new class object. Why \nisn t a SOM 2.0 class always simply an instance of the metaclass indicated in its declaration (as was \nthe case in SOM l.O)? The answer is that SOM allows unconstrained class declarations --even those such \nas illustrated by the problematic class Y in the above example --while also supporting classes as polymorphic \nobjects. For example, Figure 4 illustrates the SOM 2.0 semantics of the above problematic OIDL and IDL \ndeclarations. As shown, SOM 2.0 simply uses Counted as the class of Y. An example Figure 5 --Of what \nclass should C be an instance? Figure 6 - The solution: C s metaclass must be derived from A s and B \ns metaclasses that requires SOM to actually derive a new metaclass is provided by Figure 5. In Figure \n5, a new class C is declared using multiple inheritance from two other classes, A and B, whose classes \nare, respectively, MA and MB. The question in Figure 5: What should be the class of C? The solution must \nguarantee that C (i.e., the class object itself) responds to the interfaces of both the A and B class \nobjects. As illustrated in Figure 6, SOM guarantees this by deriving the class of C (named DMC, for Derived \nMetaclass ) from the classes of C s parents. Of course, a general solution must deal with any number \nof parents and an explicit metaclass (when one is indicated) Figure 7 presents the general case using \nIDL and illustrates the resulting SOM-derived metaclass, DMC. This shows how SOM uses multiple inheritance \nto derive a new metaclass whose instance s interfaces are compatible with both (1) the requirements indicated \nby the programmer that indicates a metaclass when subclassing and (2) the requirements implied by the \nneed to support the newly-defined class as a polymorphic object with respect the class of each parent. \nThis has the effect of treating the metaclass as a constraint rather than an  interface C : PI, Pz, \n. . . . PN 1implementation { me&#38;lass = MC; }; 1; Figure 7-A General Solution for Interface Compatibility \nimperative declaration. In effect, inheritance is given a . SOMObject::somUninit  new dimension, because \nthe metaclass constraint is free allocated resources also inherited. The derived metaclass is the least \nIn general, a metaclass designer overrides each ofsolution to all these constraints. these methods to \nperform class-specific initialization Dealing with Object State (or uninitialization). And, each of the \nresulting method The approach illustrated in Figure 7 guarantees procedures used by a metaclass implementation \nmetaclass compatibility by assuring the existence of normally makes parent method calls to cooperatively \nthe necessary interfaces and class variables. But class invoke similar functionality implemented by the \nvariables must be initialized. In SOM, a class s state parents of the metaclass. To correctly initialize \n(uninitialize) all the variables containing a class s includes: state, then, a SOM-derived metaclass \noverrides the . an instance method table (introduced by SOMClass) above methods with code that makes \nthe necessary . a variety of other class variables (often introduced parent method calls on all of its \nmetaclass parents. by subclasses of SOMClass-- i.e., other meta- This assures that all appropriate initialization \ncode is classes) executed. This is done only for these four, special And, of course, a class state must \nbe initialized before initialization methods. Further details are provided the class is used. As suggested \nearlier, the SOM API elsewhere [7]. provides methods whose purpose is to provide for ini- It is interesting \nto note the conditions under which the tialization (and uninitialization): problem solved by derived \nmetaclasses can arise. SOMObject::somInit  Metaclass incompatibility can arise in the case of default \nvariable initialization single inheritance models that allow explicit *SOMClass::somInitMIClass metaclasses \nand in the case of multiple inheritance create and initialize instance method table models (with either \nexplicit or implicit metaclasses). Smalltalk has implicit metaclasses but doesn t support SOMClass::somClassReady \n multiple inheritance. C++ allows multiple inheritanceregister class but doesn t allow metaclasses. \nThus, neither of these object models needs to worry about metaclass incompatibility. On the other hand, \nobject models such as ObjVLisp [4] and CLOS [2] can encounter the problem [12]. None of these systems \nprovide the benefits offered by SOM-derived metaclasses. SOM is unique in that it relieves programmers \nof the responsibility for avoiding metaclass incompatibility when defining a new class. At first glance, \nthis might seem to be merely a useful convenience. But, in fact, it is essential because SOM must provide \nbackwards binary compatibility with respect to changes in class implementations. A programmer might, \nat one point in time, know the classes of all the ancestor classes of a new subclass (and so on, recursively), \nand, as result, be able to explicitly derive an appropriate class for a new subclass using the approach \nwe have described above. But, we doubt that a system based on requiring this would ever be successful. \nAnd, in any case, SOM must guarantee that a class implementation continues to execute and function correctly \nwhen its ancestor class s implementations are changed without retracting existing interfaces. This includes \nspecifying different parents or different metaclasses, so requiring a static solution (on the part of \neither a programmer or a compiler) is simply not acceptable in SOM. SOM-derived metaclasses enable functionality \npackaged as SOM classes to be combined into a large number of different configurations, thus supporting \ncode reuse. Software reuse is one promise of OOP technology, and it has been gratifying to find that \nmany useful kinds of functionality are automatically composed by SOM-derived metaclasses. Examples include \naspects of DSOM (a SOM class framework allowing transparent distribution of objects according to the \nCORBA model [lo]), Replication (a SOM class framework providing single-copy serializability for distributed, \nreplicated objects [lo]), and before/after metaclasses [8]. Another example is provided by the metaclass \ncooperation framework, described in the following section.  Metaclasses in SOM 2.1 SOM-derived metaclasses \ndo not solve all the problems encountered by SOM metaclass programmers. In particular, the dynamic behavior \nof different metaclasses combined into a derived metaclass may result in interference between these metaclasses. \nThis problem does not manifest itself as a lack of polymorphism (the problem identified in [ 12]), but \nas an operational conflict between different metaclasses behavior. For example, this problem could arise \nwhen two unrelated metaclasses combined into a derived metaclass want different method procedures to \nexecute when a new object is created with som~ew. If the two metaclasses both use their somInitMIClass \ncode to override the object creation method som~ew, then the last override to execute wins, interfering \nwith the other metaclass, whose method procedure not execute. Ihe question is how to cooperatively associate \na multiplicity of method procedures with a single method. When method procedures are contributed by classes \nrelated by inheritance, parent method calls serve this purpose. But, when a method procedure is contributed \nby a metaclass, parent method calls cannot do the job of enabling cooperation. Remember that SOM-derived \nmetaclasses are determined dynamically; those metaclasses combined into a SOM-derived metaclass do not \nhave any static inheritance relations among themselves (otherwise there would be no reason to derive \na new metaclass). We address this problem with a metaclass cooperation framework. This provides a programming \nmodel in which metaclasses achieve their objectives cooperatively by combining different method procedures \ninto a cooperation chain. Interference (when it would otherwise occur) is identified as conflicting requirements \nfor ordering method procedures in this chain. This maximizes the opportunity for cooperation between \nmetaclasses (because, for most purposes, ordering doesn t matter) and it guarantees that metaclasses \nnever mysteriously cease to operate correctly as a result of interference with other metaclasses. Next \nwe re-implement Counted to provide supporting details. The following examples are expressed according \nto the cooperation framework provided by ESOM, a current research prototype for SOM 2.1. ESOM is not \na product, so these examples are for illustration only. The APIs provided by the SOM 2.1 product may \nvary from those shown here. We start with a metaclass that implements an instance count without using \nthe cooperation framework, and then we show how the same objective can be achieved with the framework. \nThe IDL for an uncooperative metaclass might appear as follows. interface Counted : SOMClass ( readonly \nattribute long instancecount; implementation ( somMethodProc* doFree; // a class variable explained \nbelow somInit: override; // to initialize instancecount somNew : override; // to increment instancecount \nsomInitMIClass: ovefiide; // explained below 1; 1; First note the above Counted cannot be reliably combined \ninto a SOM-derived metaclass with any other metaclasses that overrides somNew. As explained above, if \nsome other metaclass overrides somNew, and this metaclass (call it MC) and Counted happen to be automatically \ncombined into a SOM-derived metaclass during subclassing, then it would use either MC s sort-New or Counted \ns. Despite this potential problem, below is an implementation for Counted using DirectToSOM C++ (i.e., \nC++ compiled to the SOM API, as provided by the MetaWare AIX and OS/2 C++ compilers). The file Counted \n. hh is a C++ header file produced from Counted . id1 by a SOMObjects Toolkit compiler Although the above \nsolution is not cooperative (due to its override of somNew) the handling of the instance method table \nentry for SomFree is similar to the way that the cooperation framework is designed. #include <Counted.hh> \n Counted::Counted() {instancecount = 0; ) Counted: : somNew ( )  {instanceCount++; return SOMClass::somNew(); \n} void somFree(SOMObject&#38; obj) // a function used below i obj.somGetClass().instanceCount--; obj.doFree(); \n/* doFree is set in somInitMIClass, below */ I Counted. .:somInitMIClass(long inherit-vars, string className, \nSOMClassSequence* parentclasses, long datasize, long dataAlignment, long maxStaticMethods, long majorversion, \nlong minorversion) /* Do parent method call to chain somInitMIClass upwards.*/ SOMClass::somInitMIClass(...); \n/* Record instance mtab entry for somFree in a class variable.*/ doFree = somClassResolve(this,SOMObjectClassData.somFree); \n/* Replace original somFree entry with the above function. */ somOverrideSMethod( \"SOMObject::somFree\", \nsom.Pree ); Counted::somInitMIClass remembers the initial content of the somFree entry of the instance \nmethod table, and this is later called by the locally- registered routine for somFree, after decrementing \nthe class s instance count. This is very similar to a parent method call, but is not based directly on \ninheritance. Rather, it is simply based on whatever the content of the instance method table is when \nCounted::somInitMICl ass saves the somFree entry. If the technique illustrated above for somFree were \nall that a metaclass programmer needed to avoid interference, then there would be little need for a cooperation \nframework. Metaclass programmers could simply use this technique to achieve the desired results. But, \ncomplications arise from providing control over the cooperation chain ordering and, also, from handling \nparent method calls correctly. As a result, the methods introduced by the cooperation framework are extremely \nimportant --they solve a number of difficult problems and they offer a simple- to-use interface for metaclass \nprogrammers. These methods are now described using IDL. somMethodProc** sommAddCooperativeInstanceMethod( \n in somId methodId, in somMethodProc* coopProc);  This method installs a cooperative override in the \nreceiver s instance method table and is the cooperation framework analogy to the technique illustrated \nin the above example for handling somFree.The returned result is the location of the method procedure \npointer that must be invoked by coopProc to continue the cooperation chain. This location is maintained \nand used by a class to support cooperation chain ordering. sonOIethodProc** somtnAddCooperativeClassMethod( \n in somId methodId, in somMethodProc* coopProc);  This method installs a cooperative override in the \ninstance method table of its receiver s class. In other words, this method allows a class to change its \nown behavior (as opposed to the behavior of its instances) by modifying the instance method table of \nthe class of which it is an instance. This is how cooperation on class methods (such as somNew) is achieved, \nand provides an interesting use of reflection within the cooperation framework. The above two methods \ncan be used by metaclasses without any possibility of interference. In contrast, metaclasses using methods \nthat request a particular position in the cooperation chain (specifically, the first or last position) \nmay interfere with each other. This possibility is handled by allowing each metaclass to build up a request \nblock by making requests, and then asking to have the request block satisfied. boolean somm.SatisfyRequests(); \n When this method is invoked, the class s current request block is checked to see if any new requests \nconflict with previously-granted requests. If so, none of the new requests are granted and FALSE is returned. \nOtherwise all the new requests are granted. Instead of returning a result, the request methods themselves \nall accept an extra output argument that is the address of a variable that the caller wants loaded with \nthe location of its cooperation chain method pointer (if the request is satisfied upon later use of sommSatisfyRequests). \n void sommRequestFirstCooperativeInstanceMethodCall( in somId methodId, in somMethodProc* coopProc, \n out sorr&#38;lethodProc** ChainProcAddrAddr);  This method is similar to sommAddCooperativeInstanceMethod, \nbut requests that coopProc be the first cooperation chain method procedure that is called when the indicated \nmethod is invoked on an instance of the class being initialized.. void sonunRequestFi.rstCooperativeClassMethodCall( \n in somId methodId, in somMethodProc* coopProc, out somMethodProc** ChainProcAddrAddr);  This method \nis similar to sommAddCooperativeClassMethod, but requests that coopProc be the first cooperation chain \nmethod procedure that is called when the indicated method is invoked on the class being initialized. \nvoid sommRequestFinalClassMethodCall( in somId methodId, in somMethodProc* methodproc); This method \nrequests that the indicated methodproc be called to provide the final semantics for the indicated class \nmethod. Note that no output argument is used to support cooperation -- the final method simply returns \na result. The last two methods are both reflective --a class object invokes these methods on itself in \norder to change its future behavior. The notion of a method name corresponding to a set of implementations \nis also employed in Subject Oriented Programming [13].  Using the Cooperation Framework Using the methods \ndescribed above, a metaclass CoopCounted can cooperate on the class method somNew and the instance method \nsomFree as illustrated below. Note that no special ordering of cooperation chain methods is required. \ninterface CoopCounted : SOMMCooperative { readonly attribute long instancecount; implementation ( somMethodProc** \ndoFree; somMethodProc** doNew; somInit: override; // to initialize instancecount somInitMIClass: override \n// to register cooperation 1: 1; #include -zCoopCounted.hh> Counted::Counted() {instancecount = 0; \n) CC-somFree(SOMObject&#38; obj) obj.somGetClass().instanceCount--; *doFree(obj); /*cooperate on somFree*/ \n CC-somNew(CoopCounted&#38; somself) 1 somSelf.instanceCount++; return *doNew(somSelf); /*cooperate \non somNew*/ CoopCounted: :somInitMIClass(...) {SOMClass: :somInitMIClass(...); doFree = soxmnAddCooperativeInstanceMethod( \n\"SOMObject::somFree\",CC_somFree); doNew = sommAddCooperativeClassMethod( \"SOMClass::somNew\",CC_somNew); \n The above example provides a simple illustration of ideas and techniques used for metaclass programming \nin ESOM.  Comparison with CLOS In comparison with many other OOP models, SOM 2.0 provides enhanced opportunities \nfor using classes to encapsulate useful functionality, and therefore enhances code reuse. To guarantee \nmetaclass compatibility, the SOM 2.0 runtime uses multiple inheritance to derive me&#38;lasses from which \npolymorphic class objects can be instantiated. Due to the complexity of correctly supporting classes \nas polymorphic objects, it seems unlikely that the power of explicit metaclasses would be generally useful \nwithout this support. Finally, to aid in preventing interference between different metaclasses combined \ninto a derived metaclass, ESOM provides a metaclass cooperation framework that allows metaclasses to \nachieve their objectives cooperatively by creating cooperation chains for both instance and class methods. \n It is interesting ask to whether CLOS could also do these things, and, if so, how. By default, CLOS \nrequires a subclass to have the same metaclass as its parent(s). While this prevents metaclass incompatibility, \nit also removes most of the benefit of explicit me&#38;classes. But, experienced CLOS users have indicated \nto the authors that this policy could be changed on a per-application basis by suitable use of the CLOS \nMetaobject Protocol, and that derived metaclasses could thereby be integrated into the overall semantics \nof CLOS class definition by automatically creating appropriate metaclasses (as in SOM) whenever necessary. \nIn CLOS, multiple inheritance is supported by linearizing ancestor classes into a class precedence Eist. \nOne uses call-next-method to invoke the method with the same name (as the currently executing method) \nfrom the next entry in the class precedence list. This would allow the necessary method chaining as required \nfor initialization of derived metaclass instances state --likely via the CLOS initialize-instance method. \n Creation and use of cooperation chains for methods also seems possible in CLOS. However, just as the \nparent-method call paradigm in SOM is too limited in flexibility, so too would be use of call -next -method \nthrough the class precedence list. The right way to view the cooperation chain for a method is that it \nis orthogonal to parent calls. For each different method, the chain is built up dynamically, as different \nclasses initialization code (defined by the different metaclasses combined into a derived metaclass) \nis executed. Arranging for appropriate interaction between parent calls for a method and the calls contained \nwithin a cooperation chain for the method presented a challenge in SOM, and the solution was encapsulated \nusing classes (two public metaclasses make up the cooperation framework). It seems likely that CLOS could \nalso create and encapsulate a similar solution. This might be done using the CLOS ability to support \nmultiple primary methods. In between invocation of :before and : after methods in CLOS, the apply-methods \nfunction orders the execution of any number of primary methods. As a result, metaclasses in CLOS might \nsimply be able to add new primary methods. A remaining detail to consider would be the need for a metaclass \nto request a particular position among the primary methods. Clearly, the mechanisms provided by CLOS \nand SOM are somewhat different. Yet it seems clear that the ideas incorporated in SOM for support of \nexplicit metaclasses have general applicability for other systems in which classes are first class objects \nand explicit metaclasses are available.  Conclusion SOM 1 .O allowed explicit metaclasses, but really \nonly provided reliable support for implicit metaclasses. SOM 2.0 added a unique form of support for explicit \nme&#38;lasses that enables their reliable use in evolving OOP systems. SOM version 2.1 then builds on \nthis foundation to provide a metaclass cooperation framework. Experience has shown the necessity for \nevolution in software systems, and, clearly, SOM has been no exception. Yet, while offering greatly enhanced \ncapabilities in comparison with the original SOM 1.0, current versions of SOM continue to support the \noriginal Workplace Shell and all its associated applications. Thus, although SOM s objective was to support \nevolution ofclass libraries in general, the second principle (which used SOM to implement SOM) has resulted \nin similar support for SOM s evolution. This report focused on aspects of SOM s evolution that relate \nto metaclass programming. This evolution has been influenced by our experiences constructing useful metaclasses \n(a few of which were mentioned here), and by the addition of multiple inheritance. There are a host ofother \nareas in which SOM has evolved, but these are topics for other papers.  Acknowledgments Mike Conner \nand Larry Raper are the designers of the SOM model and API; their insight in providing SOM with metaclasses \nprovides the basis upon which we worked. We wish to thank Gregor Kiczales, Ralph Johnson, and the anonymous \nOOPSLA referees for their valuable and greatly appreciated comments. References 1. Bobrow, D.G., Kahn, \nK., Kiczales, G., Masiner, L., Stefik, M., and Zdybel, F. CommonLoops ---Merging Lisp and Object-Oriented \nProgram- ming, OOPSLA 86 Conference Proceedings, 1986. 2. Bobrow. D. G. and KiczaIes, G. The Common \nLisp Object System Metaobject Kernel: A Status Report, Proceedings ACM Conference on Lisp and Functional \nProgramming, July, 1988. 3. Bobrow, D.G., DeMichiel, L.G., Gabriel, RI?, Keene, SE., Kiczales, G. and \nMoon, D.A., Common Lisp Object System Specification Sigplan Notices,Vol. 23 (September 1988). 4. Briot, \nJ.-P and Cointe, P. A Uniform Model for Object-Oriented Languages Using the Class Abstraction, ZJCAZVol. \n1, August, 1987. 5. Cointe, P. The ObjVlisp Kernel: A Reflexive Lisp Architecture to Define a Uniform \nObject- Oriented System, in Meta-Level Architectures and Reflection Pattie Maes and Daniele Nardi (ed.)North-Holland, \n1987. 6. Danvy, 0. and Malmkjaer, K.. Intentions and Extensions in a Reflective Tower, Proceedings ACM \nLisp and FP Conference, 1988. 7. Danforth, S. and Forman, I.R. Derived Meta- classes in SOM, Proceedings \nTOOLS Europe 94, 1994. 8. Forman, I.R., Danforth, S. and Madduri, H. Composition of Before/After Metaclasses \nin SOM, OOPSLA 94 Conference Proceedings, 1994. 9. Friedman, D. and Wand, M. Reification: Reflec- tion \nwithout Metaphysics, Proceedings ACM Lisp and FP Conference, 1994.  10. SOMObjects Developer ToolKit, \nUsers Guide, IBM, June, 1993. 11. Graube, N. Reflexive Architecture: From ObjV- Lisp to CLOS, Proceedings \nECOOP 88, Springer Verlag LNCS Vol. 322, 1988. 12. Graube, N. Metaclass Compatibility, OOPSLA 89 Conference \nProceedings, 1989. 13. Harrison, W. and Ossher, H. Subject-Oriented Programming (A Critique of Pure \nObjects) OOPSLA 93 Conference Proceedings, 1993 14. Ingalls H.H. The Evolution of the Smalltalk Vir- \ntual Machine, in Smalltalk-Bits of Wisdom Words of Advice G. Kramer (ed.) Addison-Wes- ley 1983. 15. \nKiczales, G., des Rivieres, J. and Bobrow, D. G. The Art of the Metaobject Protocol,.MIT Press, Cambridge \nMA, 1991. 16. Maes, l?Computational Reflection Ph. D. Thesis, Artificial Intelligence Laboratory, Vrije \nUniver- siteit, Brussel, 1987 17. The Common Object Request Broker: Architec- ture and Spec$cation, \nRevision 1.1, Object Man- agement Group and X/Open, 1993. 18. Smith, B.C. Reflection and Semantics in \na Proce- dural Language Ph.D.Thesis, Laboratory for Computer Science, MIT, 1982. 19. Smith, B. Reflection \nand Semantics in Lisp, Proceedings ACM Lisp and FP Conference, 1993 20. Tomlinson, C. and Singh, V. \nInheritance and Synchronization with Enabled Sets, OOPSLA 89 Conference Proceedings, 1989. 21. Wand, \nM. and Friedman, D. The Mystery of the Tower Revealed, Proceedings ACM Lisp and FP Conference, 1986. \n 22. Watanabe. T. and Yonezawa, A. Reflection in an Object-Oriented Concurrent Language, OOP-SLA 88 Conference \nProceedings, 1988.  \n\t\t\t", "proc_id": "191080", "abstract": "<p>This paper reports on the evolution of metaclass programming in SOM (the IBM System Object Model). Initially, SOM's use of explicit metaclasses introduced metaclass incompatibilities. This was cured by having SOM dynamically derive an appropriate metaclass by interpreting the &#8220;metaclass declaration&#8221; as a constraint. In effect, inheritance is given a new dimension, because the constraint is also inherited. The derived metaclass is the least solution to all these constraints. Subsequently, this cure led to the possibility of metaclasses conflicting over the need to assign meaning to a method. The cure for this problem is a framework that facilitates the programming of metaclasses that cooperate on the assignment of meaning to methods.</p>", "authors": [{"name": "Scott Danforth", "author_profile_id": "81100337977", "affiliation": "IBM Object Technology Products, 11400 Burnet Road, Austin, TX", "person_id": "PP39038338", "email_address": "", "orcid_id": ""}, {"name": "Ira R. Forman", "author_profile_id": "81100212249", "affiliation": "IBM Object Technology Products, 11400 Burnet Road, Austin, TX", "person_id": "P116725", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/191080.191149", "year": "1994", "article_id": "191149", "conference": "OOPSLA", "title": "Reflections on metaclass programming in SOM", "url": "http://dl.acm.org/citation.cfm?id=191149"}