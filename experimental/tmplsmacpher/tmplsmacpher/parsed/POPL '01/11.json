{"article_publication_date": "01-01-2001", "fulltext": "\n Nomadic Pict: Correct Communication Infrastructure for Mobile Computation Asis Unyapoth and Peter Sewell* \nComputer Laboratory, University of Cambridge {Asis.Unyapoth,Peter.Sewell}@cl.cam.ac.uk Abstract This \npaper addresses the design and veri.cation of in\u00adfrastructure for mobile computation. In particular, \nwe study language primitives for communication between mo\u00adbile agents. They can be classi.ed into two \ngroups. At a low level there are location dependent primitives that require a programmer to know the \ncurrent site of a mobile agent in order to communicate with it. At a high level there are location independent \nprimitives that allow communication with a mobile agent irrespective of any migrations. Imple\u00admentation \nof the high level requires delicate distributed in\u00adfrastructure algorithms. In earlier work with Wojciechowski \nand Pierce we made the two levels precise as process cal\u00adculi, allowing such algorithms to be expressed \nas encodings of the high level into the low level; we built Nomadic Pict, a distributed programming language \nfor experimenting with such encodings. In this paper we turn to semantics, giving a de.nition of the \ncore language and proving correctness of an example infrastructure. This requires novel techniques: we \ndevelop equivalences that take migration into account, and reasoning principles for agents that are temporarily \nim\u00admobile (eg. waiting on a lock elsewhere in the system). Introduction Background: Mobility and Location \nIndependence Mo\u00adbile computations units of executing computation that can migrate between machines \nare predicted to be an im\u00adportant enabling technology for future distributed systems [Car97, CHK97]. \nTo write applications involving mobility one would like high-level location independent (LI) commu\u00adnication \nfacilities, allowing the parts of an application to in\u00adteract without explicitly tracking each other \ns movements. Such primitives have been provided by several languages, including Facile [TLK96], and Distributed \nJoin [FGL+96]. Standard network technologies, however, directly support * Supported by a Royal Thai Government \nScholarship and a Royal Society University Research Fellowship respectively. only location-dependent \n(LD) communication, so to provide location independence one needs a distributed infrastructure algorithm. \nThe languages cited above have particular algo\u00adrithms hard-coded into their implementations, but in the \nwide-area case this is problematic: infrastructure algorithm design must be application\u00adspeci.c any \ngiven one will only have satisfactory performance for some range of migration and communi\u00adcation behaviour; \nit should be matched to the expected properties (and robustness and security demands) of applications, \nand of the underlying network;  the algorithms needed are delicate and error-prone; they are hard to \nreason about.  To allow more .exibility, a wide-area programming language should provide a low-level \nabstraction that makes distribu\u00adtion and network communication clear; with higher levels including location \nindependence expressed using the mod\u00adularisation facilities of the language. Nomadic p and Pict Following \nthe above, in earlier work with Wojciechowski and Pierce [SWP98, Woj00], we de\u00adsigned Nomadic Pict, a \ndistributed programming language intended as a vehicle for exploring infrastructure for mobil\u00adity. It \nbuilds on the Pict language of Pierce and Turner [PT00], a concurrent, though not distributed, language \nbased on the asynchronous p-calculus [MPW92]. Pict sup\u00adports .ne-grain concurrency and the communication \nof asyn\u00adchronous messages. Low-level Nomadic Pict adds primi\u00adtives for programming mobile computations: \nagent creation, migration of agents between sites, and communication of location-dependent asynchronous \nmessages between agents. High-level Nomadic Pict adds location-independent commu\u00adnication; we can express \nan arbitrary infrastructure for im\u00adplementing this as a user-de.ned translation into the low\u00adlevel language. \nMobility allows infrastructures to be de\u00adployed dynamically. The language has been implemented by Wojciechowski \n[Woj00, WS00], and used for prototyping a wide range of infrastructures, from a simple centralised\u00adserver \nsolution to federated algorithms supporting discon\u00adnection, suited for di.erent applications. Our earlier \nwork showed how the two levels can be cleanly based on corre\u00adsponding high-and low-level process calculi. \nThe opera\u00adtional semantics of the calculi provided a clear informal un\u00adderstanding of the algorithms \nbehaviour, which aided our design work. Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor profit or commercial advantage and that copies bear this notice and the full citation on the first \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspecific permission and/or a fee. POPL '01 1/01 Londo, UK Copyright 2001 ACM 1-58113-336-7/01/0001 ... \n$5.00 Problem: Semantics and Veri.cation Our focus here is on developing semantics and proof techniques \nto allow formal correctness proofs for such infrastructure algorithms. If sys\u00adtems involving location \nindependence are widely deployed, the behaviour of these algorithms will be critical. They are highly \nconcurrent as we can attest, it is hard to ensure the absence of race conditions, deadlocks and other \nerrors. The algorithms are small enough, though, to make veri.cation plausible. New semantic technology \nis required, going beyond earlier work on p-calculi and distributed algorithms, both to deal with the \nnew entities sites and mobile agents and to capture the subtle reasons why the algorithms are correct. \nThis technology is worth developing in its own right: it is a step towards a semantically-founded view \nof richer wide-area distributed systems, where one wants proofs of robustness properties in the presence \nof failure and malicious attack. Outline In this paper we give the rigorous development of a fragment \nof Nomadic Pict, with semantics and proof techniques, that su.ces for veri.cation of an example al\u00adgorithm. \nFor lack of space many details are omitted; they will appear in the .rst author s forthcoming PhD thesis. \nWe begin in Sections 2 and 3 by introducing the language and a simple example infrastructure algorithm. \nThis recapitu\u00adlates material from [SWP98], adding a type system. In Sec\u00adtion 4 we discuss the operational \nsemantics, again building on [SWP98] (which gave only an untyped reduction seman\u00adtics) and in Section \n5 the techniques required for stating and proving correctness. We must: 1. extend the standard p-calculus \nreduction and la\u00adbelled transition semantics to deal with agent mobil\u00adity, location-dependent communication, \nand a rich type system; 2. consider translocating versions of behavioural equiva\u00adlences (bisimulation \n[MPW92] and expansion [SM92] relations) that are preserved by certain spontaneous migrations; 3. prove \ncongruence properties of some of these, to allow compositional reasoning; 4. deal with partially-committed \nchoices, and hence state the main correctness result in terms of coupled simula\u00adtion [PS92]; 5. identify \nproperties of agents that are temporarily im\u00admobile, waiting on a lock somewhere in the system; and, \n 6. as we are proving correctness of an encoding, we must analyse the possible reachable states of the \nencoding applied to an arbitrary high-level source program in\u00adtroducing an intermediate language for \nexpressing the key states, and factoring out as many house-keeping reduction steps as possible.  A correctness \nproof for our example is given in Section 6. Finally, Section 7 concludes with further discussion. Language \nIn this section we describe the language informally, begin\u00adning with an example program in the low-level \nlanguage showing how an applet server can be expressed. * getApplet? [as] . create m b = migrate to s \n. ((a@s')ack! b | B) in 0 It can receive (on the channel named getApplet) requests for an applet; the \nrequests contain a pair (bound to a and s) consisting of the name of the requesting agent and the name \nof the site for the applet to go to. When a request is received the server creates an applet agent with \na new name bound to b. This agent immediately migrates to site s. It then sends an acknowledgement to \nthe requesting agent a ' (which is assumed to be on site s) containing its name. In parallel, the body \nB of the applet commences execution. The example illustrates the main entities of the language: sites, \nagents and channels. Sites should be thought of as physical machines or, more accurately, as instantiations \nof the Nomadic Pict runtime system on machines; each site has a unique name. This paper does not explicitly \naddress ques\u00adtions of network failure and recon.guration, or of security. Sites are therefore unstructured; \nneither network topology nor administrative domains are represented in the language. Agents are units \nof executing code; an agent has a unique name and a body consisting of some Nomadic Pict process; at \nany moment it is located at a particular site. Channels support communication within agents, and also \nprovide tar\u00adgets for inter-agent communication an inter-agent message will be sent to a particular channel \nwithin the destination agent. New agents and channels can be created dynami\u00adcally. The language is built \nabove asynchronous messaging, both within and between sites; in the current implementa\u00adtion inter-site \nmessages are sent on TCP connections, cre\u00adated on demand, but our algorithms do not depend on the message \nordering that could be provided by TCP. The inter-agent message (a@s')ack! b is characteristic of the \nlow-level language. It is location-dependent if agent a is ' in fact on site sthen the message b will \nbe delivered, to channel ack in a; otherwise the message will be discarded. In the implementation at \nmost one inter-site message is sent. Types Typing infrastructure algorithms requires an ex\u00adpressive type \nsystem. We take types T ::= B base type | [T1 ...Tn] tuple | ^ I T channel name | {|X|} T existential \n| X type variable | Site site name | AgentZ agent name where B might be int, bool etc. Existentials are \nneeded as an infrastructure must be able to forward messages of any type (see the message and deliver \nchannels in Fig. 1). For more precise typing, and to aid reasoning, channel and agent types are re.ned \nby annotating them with capabilities, ranged over by I and Z respectively. As in [PS96], channels can \nbe used for input only r, output only w, or both rw; these induce a subtype order. In addition, agents \nare either static s, or mobile m [Sew98, CGG99]. Values and patterns Channels allow the communication \nof .rst-order values: names, constants t, tuples and existential packages. Patterns p are of similar \nshapes as value. v ::= t | x | [v1 ...vn] | {|T|} v p ::= | x | [p1 ...pn] | {|X|} p The value grammar \nis extended with some basic functions, including equality tests, to give expressions, ranged over by \nev. P ::= create a = P in Q Processes The syntax of the low-level language is as fol\u00ad lows. Z | migrate \nto s.P | iflocal (a)c! v then P else Q | 0 | P |Q | new c : ^ I T in P | c! v | c? p.P | * c? p.P p | \nif v then P else Q | let p = ev in P |(a)c! v |(a@s)c! v sugar Executing the construct create Z b = P \nin Q spawns a new agent (with mobility capability Z and body P ) on the current site. After the creation, \nQ commences execution, in parallel with the rest of of the body of the spawning agent. The new agent \nhas a unique name which may be referred to both in its body and in the spawning agent (b is binding in \nP and Q). Agents can migrate to named sites the execution of migrate to s.P as part of an agent results \nin the whole agent migrating to site s. After the migration, P commences execution in parallel with the \nrest of the body of the agent. The body of an agent may consist of many process terms in parallel, i.e. \nessentially of many threads. We include p\u00adcalculus style interaction primitives. Execution of new c : \n^ I T in P creates a new unique channel name for carrying values of type T (and accessible in I mode); \nc is binding in P . An output c! v (of value v on channel c) and an input c? p . P in the same agent \nmay synchronise, resulting in P with the appropriate parts of the value v bound to the formal parameters \nin the pattern p. Note that outputs do not have continuation processes this is an asynchronous calculus. \nA replicated input * c? p . P behaves similarly except that it persists after the synchronisation, and \nso might receive another value. In c? p . P , * c? p . P and let p = ev in P the names in p are binding \nin P . Finally, the low-level calculus includes a single primi\u00adtive for interaction between agents. The \nexecution of iflocal (a)c! v then P else Q in the body of agent b has two possible outcomes. If the agent \na is on the same site as agent b then the message c! v will be delivered to a (where it may later interact \nwith an input) and P will commence execution in parallel with the rest of the body of b; other\u00adwise the \nmessage will not be delivered and Q will execute as part of b. The construct is analogous to test-and-set \nop\u00aderations in shared memory systems delivering the message and starting P , or discarding it and starting \nQ, atomically. It can greatly simplify algorithms that involve communica\u00adtion with agents that may migrate \naway at any time, yet is still implementable locally, by the runtime systems on each site. We can express \ntwo other useful constructs in the lan\u00adguage introduced so far: (a)c! v and (a@s)c! v attempt to deliver \nc! v to agent a, on the current site and on s, respec\u00adtively. They fail silently if a is not where it \nis expected to be and so are usually used only where a is predictable. In the execution of iflocal a \nnew channel name can escape the agent where it was created, to be used elsewhere for output and/or input. \nSynchronisation of a local output c! v and an input c? x.P only occurs within an agent, however. Consider \nfor example the process below, executing as the body of an agent a. create m b = c? x. (x! 3|x? n.0 0) \nin d : ^ rw new int in iflocal (b)c! d then 0 else 0 | d! 7 It has a reduction for the creation of \nagent b, a reduction for the iflocal that delivers the output c! d to b, and then a local synchronisation \nof this output with the input on c. Agent a then has body d! 7 and agent b has body d! 3|d? n.0 0. Only \nthe latter output on d can synchronise with b s input d? n.0 0. For each channel name there is therefore \ne.ectively a p-calculus-style channel in each agent. The channels are distinct, in that outputs and inputs \ncan only interact if they are in the same agent. At .rst sight this semantics may seem counter-intuitive, \nbut it reconciles the con.icting re\u00adquirements of expressiveness and simplicity of the calculus. The \nhigh-level language P ::= ... (a@?)c! v is obtained by extending the low-level language with a single \nlocation-independent communication primitive (a@?)c! v, whose intended semantics is that its execution \nwill reliably deliver the message c! v to agent a, irrespective of the cur\u00adrent site of a and of any \nmigrations. The low-level com\u00admunication primitives are also available for interaction with application \nagents whose locations are predictable. Located Processes The basic process terms given above only allow \nthe source code of the body of a single agent to be expressed. During computation, this agent may evolve \ninto a system of many agents, distributed over many sites. To denote such systems, we de.ne located processes \nLP ::= @aP | LP |LQ | new x : T @s in LP Here the body of an agent a may be split into many parts, for \nexample written @aP1| ... |@aPn. The construct new x : T @s in LP declares a new name x (binding in LP \n); if this is an agent name, with T = AgentZ , we have an annotation @s giving the name s of the site \nwhere the agent is currently located. Channels, on the other hand, are not located if = ^ I ' TT then \nthe annotation is omitted. 3 An Example Infrastructure In this section we present an infrastructure algorithm, \nex\u00adpressed as a translation, based on the simplest algorithm Daemon def = * *message? {|X|} [a c v]. \nlock? m. lookup [Agents Site] a in m with found (s) .new dack : ^ rw [] in (a@s)deliver! {|X|} [c v \ndack] | dack? [] .lock! m notfound .0 | * *register? [b s rack]. lock? m.let [Agents Site] m ' = (m \nwith b . s) in lock! m ' | (b@s)rack! [] | * *migrating? [a mack]. lock? m. lookup [Agents Site] a in \nm with found (s) .new migrated : ^ rw [Site ^ w []] in  (a@s)mack! [migrated] ' ' ''' | migrated? \n[s ack].let m =(m with a . s ) in lock! m |(a@s )ack! [] notfound .0 def rws w rwsww w Faux = register \n: ^ [AgentSite ^ []], migrating : ^ [Agent^ [^ [Site ^ []]]], rw sw rwww message : ^ {|X|} [Agent^ XX], \ndeliver : ^ {|X|} [^ XX ^ []], s rws rw D : Agent@SD, lock : ^ Map[AgentSite], currentloc : ^ Site Figure \n1: The Central Server Daemon and the Interface Context from [SWP98]. It is a central-forwarding-server \nalgorithm, with a single daemon that keeps track of the current sites of all agents and forwards any \nlocation-independent messages to them. The original algorithm has been modi.ed in several ways to simplify \nthe correctness proof: type annotations have been added and checked with the Nomadic Pict type checker \n[Woj00] (although this does not check the static/mobile subtyping);  the algorithm is more serialised; \n fresh channels are used for transmitting acknowledge\u00adments, making such channels linear [KPT96]; and \n the translation is extended to arbitrary located pro\u00adcesses (not just source programs containing a \nsingle agent).  The daemon is itself implemented as a static agent; the translation CF [ LP ] of a located \nprocess LP = new . in @a1 P1 | ... | @an Pn (well-typed with respect to F) then consists roughly of the \ndaemon agent in parallel with a compositional translation [ Pi] ai of each source agent: def CF [ LP \n] = new ., Faux in @D(... |Daemon) @ | i.{1...n} @ai (... | [ Pi] ) ai (we omit various initialisation \ncode, and will often elide type contexts F). The body of the daemon and selected clauses of the compositional \ntranslation are shown in Figures 1 and 2. They interact using channels of an interface context Faux, \nalso de.ned in Figure 1, which in addition declares lock channels and the daemon name D. It uses a map \ntype con\u00adstructor, which (together with the map operations) can be translated into the core language. \nThe daemon consists of three replicated inputs, on the message, register, and migrating channels, ready \nto re\u00adceive messages from the encodings of agents. It is at a .xed site SD. Part of the initialisation \ncode places Daemon in parallel with an output on lock which carries a refer\u00adence to a site map: a .nite \nmap from agent names to site names, recording the current site of every agent. The single\u00adthreaded nature \nof the daemon is ensured by using lock to enforce mutual exclusion between the three replicated in\u00adputs \n each of them begins with an input on lock, thereby acquiring both the lock and the site map, and does \nnot re\u00adlinquish the lock until the daemon .nishes with the request. The code preserves the invariant \nthat at any time there is at most one output on lock. Turning to the compositional translation [ .] , \nit is de.ned by induction on type derivations.Only three clauses are non\u00adtrivial: for the location-independent \noutput, agent creation and agent migration primitives. For the rest, [ .] acts ho\u00admomorphically. We discuss \nonly LI output and creation; migration is similar. Location-Independent Output An LI output in an agent \na (of message c! v to agent b) is implemented simply by using a location-dependent output (b@?)c! v to \nsend the message to channel message at the daemon, as an existential package with a triple [bcv]. Reacting \nto this, the daemon acquires its lock and looks up b s site in the acquired site map. It then creates \na fresh channel dack and forwards the message in LD mode (together with dack) to the deliver channel \nof agent b. In each agent the deliver channel is handled by a Deliverer process, as in Figure 2. This \nreacts to deliver messages by emitting a local c! v message and acknowledg\u00ading the daemon (again using \nLD communication) via dack. Meanwhile no agent may migrate before the deliver mes\u00adsage arrives, since \nthe daemon is single-threaded and waits for such an acknowledgement before releasing lock. Note that \nthe notfound branch of the daemon s lookup will never be taken as the algorithm ensures that all agents \nregister before messages can be sent to them. Creation In order for the daemon s site map to be kept \nup to date, agents must register with the daemon, telling it def [ (b@?)c! v] = (D@SD)message! {|T|} \n[bcv] where c : ^ I T a create Z b = P in Q a def = currentloc? s.new pack : ^ rw [], rack : ^ rw [] \nin create Z b = where Deliverer def = (D@SD)register! [b s rack] | rack? []. iflocal (a)pack! [] then \ncurrentloc! s | [ P ] b in pack? [].currentloc! s | [ Q] a* *deliver? {|X|} [c v dack].((D@SD)dack! [] \n| c! v) | Deliverer else 0 [ migrate to s . P ] a def = currentloc? .new mack : ^ rw [^ w [Site ^ w \n[]]] in (D@SD)migrating! [a mack] | mack? [migrated]. migrate to s . new ack : ^ rw [] in (D@SD)migrated! \n[s ack] | ack? [] . currentloc! s | [ P ] a [ P |Q] a def = [ P ] a | [ Q] a Figure 2: The Compositional \nEncoding (selected clauses) their site, both when they are created and when they mi\u00adgrate. Each agent \nrecords its current site internally as an output on its currentloc channel. This channel is also used \nas a lock, to enforce mutual exclusion between the encod\u00adings of all agent creation and migration commands \nwithin the body of the agent. The encoding (in Figure 2) .rst acquires the local lock and current site \ns and then creates the new agent b, as well as channels pack and rack. The body of b sends a register \nmessage to the daemon, sup\u00adplying rack; the daemon uses rack to acknowledge that it has updated its site \nmap. After the acknowledgement is re\u00adceived from the daemon, b sends an acknowledgement to a using pack, \ninitialises the local lock of b with s, installs a Deliverer, and allows the encoding of the body P of \nb to proceed. Meanwhile, the local lock of a and the encoding of the continuation process Q are blocked \nuntil the acknowl\u00adedgement via pack is received. Semantic De.nition Type System We highlight only the \nnon-standard aspects of the type system. Firstly, we work with located type con\u00adtexts G, which include \ndata specifying the site where each declared agent is located; the operational semantics updates this \nwhen agents move. G ::= | G,X | G,x : AgentZ @s | G,x : T Z T= Agent A type context is closed if it declares \nno type variables or term variables of base type, and extensible if all term vari\u00adables are of agent \nor channel types, and therefore may be new-bound. The main judgements, for well-formedness of a basic \nprocess as part of agent a, and for located processes, have the forms G fa P and G f LP ; there is also \na judgement G f x@z giving the location z of x. Subtyping is as in [PS96] but with also Agents = Agentm \n; there is a standard subsumption rule G f e . S G f S = T G f e . T The most interesting rules are below. \n= b G f s . Site G,b : AgentZ fb P G fa P G,b : AgentZ fa Q G fa migrate to s.P G faZ b = P in Q G f \na . Agentm a create G f a, b . Agents G f s . Site G f c . ^ w T G f v . T G fz P G fa (b@s)c! v G f \n@z P Operational Semantics To capture our informal under\u00adstanding of the language in as lightweight a \nway as possible, we give a reduction semantics. It is de.ned with a struc\u00adtural congruence and reduction \naxioms, extending that for the p-calculus [Mil93]. Reductions are over con.gurations, which are pairs \nG LP of a located typing context G and a located process LP . The most interesting axioms for the low-level \nlanguage are given in Figure 3. Note that the only inter-site communication in an imple\u00admentation will \nbe for the migrate to reduction, in which the body of the migrating agent a must be sent from its current \nsite to site s. The high-level language has the addi\u00adtional axiom G @a(b@?)c! v -. G @bc! v G@acreate \nZ b = P in Q -. G new b : AgentZ @s in (@bP | @aQ) where G f a@s G@amigrate to s . P -. (G . a . s)@aP \nG@a (c! v|c? p .P ) -. G@amatch(p, v)P G@aiflocal (b)c! v then P else Q -. G@aP | @bc! v where G f a@s \n. G f b@s G@aiflocal (b)c! v then P else Q -. G@aQ where G f a@s . G f b@s ' . s = s ' Figure 3: Selected \nReduction Rules G f c . ^ r T G, . f v . T dom(.) . fv(v) . is extensible. c! vc? v G a c! v -. @a0 G \na c? p.P -. @amatch(p, v)P . G G a P c! v-. . LP G a Q c? v-. . LQ a P | Q t-. new . in LP | LQ (G, \nx : T ) a P c! v-. . LP x . fv(v) x = c G a new x : T in P c! v-. .,x:T LP (G, a : Agentm @s) LP @amigrate \nto s . -. LQ t migrate to s ' G a migrate to s . P -. @aP G new a : Agentm @s in LP -. new a : Agentm \n@s in LQ Figure 4: Selected LTS Rules for delivering location-independent messages to their desti\u00adnation \nagent. The reduction semantics describes only the internal be\u00adhaviour of processes for compositional \nreasoning we need also a typed labelled transition semantics, expressing how processes can interact with \ntheir environment. Transitions are de.ned inductively on process structure, without the structural congruence. \nThe transition relations have the fol\u00adlowing forms, for basic and located process: a\u00df G a P -. LP G LP \n-. LQ .. Here the unlocated labels a are of the following forms: t internal computation migrate to s \nmigrate to the site s c! v send value v along channel c c? v receive value v from channel c The located \nlabels \u00df are of the form t or @aa for a = t . Private names (together with their types, which may be \nan\u00adnotated with an agent s current site) may be exchanged in communication and are made explicit in the \ntransition rela\u00adtion by the extruded context .. Selected rules are given in Figure 4. Theorem 4.1 (Reduction/LTS \nCorrespondence) For any well-formed located type context G and located pro\u00adcess LP such that G f LP , \nwe have: G LP -. G ' LQ if and only if either t G LP -. LQ with G ' = G, or @amigrate to s G LP -. LQ \nwith G ' =G . a . s. Theorem 4.2 (Subject Reduction) For any well-formed closed located type context \nG, if \u00df G LP -. LQ then G, . f LQ. . 5 Semantic Techniques In this section we describe the tools used \nfor stating and proving correctness. We are expressing distributed infras\u00adtructure algorithms as encodings \nfrom a high-level language to its low-level fragment, so the behaviour of a source pro\u00adgram and its encoding \ncan be compared directly with some notion of operational equivalence our main theorem will be roughly \nof the form .P.P .C [ P ] ( ) where P ranges over well-typed programs of the high-level language (P may \nuse LI communication whereas C [ P ] will not). Now, what equivalence . should we take? The stronger \nit is, the more con.dence we gain that the encod\u00ading is correct. At .rst glance, one might take some \nform of weak bisimulation since (modulo divergence) it is .ner than most notions of testing [dH84, Sew97] \nand is easier to work with. However, as in Nestmann s work on choice encodings [NP96], ( ) would not \nhold, as the encoding C [ P ] involves partial commitment of some nondeterministic choices. An example \nis given in \u00a76. We therefore take . to be an adap\u00adtation of coupled simulation [PS92] to our language. \nThis is a slightly coarser relation, but it is expected to be .ner than any reasonable notion of observational \nequivalence for Nomadic p (modulo questions of divergence and fairness). Translocating Equivalences To \nprove ( ) we need compo\u00adsitional techniques, allowing separate parts of the protocols to be treated separately. \nIn particular, we need operational congruences (both equivalences and preorders) that are pre\u00adserved \nby program contexts involving parallel composition and new-binding. In Nomadic p the behaviour of LD \ncom\u00admunications depends on the relative location of agents: if a and b are at the same site then the \nLD message @b(a@s)c! v reduces to (and in fact is weakly equivalent to) the local out\u00adput @ac! v, whereas \nif they are at di.erent sites then the LD message is weakly equivalent to 0 0. A parallel context, eg. \n[.]|@amigrate to s, can migrate the agent a, so to obtain a congruence we need re.ned equivalences, taking \ninto ac\u00adcount the possibility of such changes of agent location caused by the environment. Allowing arbitrary \nrelocations would give too strong a notion, though. We introduce translocating relations that are parameterised \nby a set of agents that the environment may move. Channel communication introduces further problems since \nit allows extrusion of new agent names to and from the en\u00advironment. Consider an output of a new-bound \nagent name a to the environment. Other components in the environ\u00adment may then send messages to a, but \ncannot migrate it, so when checking a translocating equivalence we do not need to consider relocation \nof a. On the other hand, a new agent name received from the environment by an input process is the name \nof an agent created in the environment, so (if cre\u00adated with the mobile capability) it may be migrated \nat any time. We de.ne a translocating strong simulation S to be a relation over located processes, indexed \nby pairs of a type context G and a set of names M, with (LP, LQ) .SG M implying G f LP and G f LQ. \n M . movable(G).  \u00df For any d valid for (G,M), if Gd LP -. LP ' then for . \u00df ' some LQ ' we have Gd \nLQ -. LQ ' and (LP ,LQ ' ) . . M8\u00dfmovable(.) S . G(d.\u00df),. Here movable(G) is the set of names of type \nAgentm in G and a valid relocator d for (G,M ) is a partial function from M to the site names of G. We \nwrite Gd for the result of applying d to G. The set M \u00df S is M . S whenever \u00df is an input and is M otherwise. \nA symmetric strong translocating bisimulation, denoted ~., and weak version can be de.ned analogously. \nWe prove congruence results for both strong and weak translocating bisimulation, stating the result only \nfor the strong. It uses a further auxiliary de.nition: the set mayMove(LP ) is the set of agents in LP \nsyntactically con\u00adtaining migrate to . Theorem 5.1 (Translocating Congruence) Given a closed located \ntype context G, T with T extensible, if ~MP ' MQ LP .LP and LQ ~.LQ ' , and G,TG,T mayMove(LQ, LQ ' ) \n. MP and mayMove(LP, LP ' ) . MQ, and def M = MP n MQ n agentIn(G) then ~M '' new T in (LP | LQ).G new \nT in LP | LQ . ~MP Intuitively, the .rst premise (LP .G,T LP ' ) of the theorem must allow all the potential \nagent movements of LQ and LQ ' , and symmetrically. Expansion To construct the coupled simulation, we \nuse an expansion relation c.[NP96] and the up to technique of [SM92], adapted with translocation, to \nallow elimination of target processes that are in intermediate/housekeeping stages. The de.nitions are \nomitted. We depend on a con\u00adgruence result, analogous to that above, for expansion. Temporary Immobility \nAt many points in the execution of an encoded program, it is intuitively clear that an agent cannot migrate \n while waiting for an acknowledgement from the daemon, or for either currentloc or lock to be released \nin the agent or daemon. To capture such an intuition, we consider derivatives of a process LP if an \ninput action on a lock channel l always precedes any (observable) migration action then LP can be said \nto be temporarily immobile, blocked by l. Care must be taken, however, to ensure that the lock l is not \nreleased by the environment. This can be made precise by the following de.nitions. As in the case of \ntranslocating equivalences, we need to con\u00adsider the possibility of agents being moved by the environ\u00adment. \nDe.nition 5.1 (Translocating Path) A translocating path of LP0 wrt (G,M) is a sequence \u00df1\u00dfn -. ... -. \n.1 .n for which there exist LP1,... ,LPn and d0,... ,dn-1 such that for each i . 0 ...n - 1: di is a \nvalid relocator for (G ,M ), where def G=G, .1,... , .i def M = M \u00df1 movable(.1) ... \u00dfi movable(.i), \nand \u00dfi+1 ((Gd0, .1)d1\u00df1, .2 ...\u00dfi, .i)di LPi -. LPi+1. .i+1 De.nition 5.2 (Temporary Immobility) Given \na closed located type context G, a located process LP with G f LP , and a translocating index M . agentIn(G), \nLP is temporarily immobile under lock l wrt (G,M) if, for all translocating paths \u00df1\u00dfn -. ... -. .1 .n \nof LP wrt (G,M) which do not contain an input action \u00dfi =@ac? v with l . fv(c, v), the following hold \nfor all i = n, b, c, v and s: \u00dfi =@bc! v implies l . fv(\u00dfi); and \u00dfi =@bmigrate to s. Consider for example \nthe process below. def LQ = new Oaux in @DDaemon | @a([[P ] |currentloc! s|Deliverer) a Here agent a \ncannot migrate until the daemon lock lock is successfully acquired, so LQ is temporarily immobile under \nlock with respect to any type-correct (G,M) that does not admit environmental relocation of a, ie. with \na . M. As\u00adsume further that a is at s and that the daemon is forwarding an LI message to a, ie. the above \nis in parallel with def LP =@D(a@s)deliver! [cv ack] This parallel composition, with a surrounding new-binder \nfor lock, expands to new lock : ^ rw Map[Agents Site] in LQ | @adeliver! [cv ack] The proof of this expansion \nrelies on the fact that the re\u00adductions of LP cannot release lock, so a cannot migrate, and hence the \nreductions of LP are deterministic, success\u00adfully delivering the message to a at s. It uses the following \nlemma. Lemma 5.1 Given that LQ is temporarily immobile under l with re\u00adspect to G, . and M, with . extensible \nand l . dom(.), if det G, . LP1 -. LP2 then M Mndom(G) . new . in LP1 | LQ cG new . in LP2 | LQ where \nLP1 t-deterministically reduces to LP2 wrt (G,M), det written G LP -. LP1, if it has a reduction and, \nfor any M \u00df valid relocator d for (G,M), Gd LP -. LP1 ' implies \u00df = t . ~M ' and LP1 .G LP1. Proofs of \ntemporary immobility can be hard, since they in\u00advolve quanti.cation over derivatives. However we may \napply up to techniques to simplify processes under transitions. Finite maps and functional computation \nWe also prove the correctness of the encoding of .nite maps (and so can omit maps from the basic calculus), \nand use uniform receptiveness [San99] to derive expansions from computation steps that are essentially \nfunctional. Coupled Simulation Coupled simulation [PS92] relaxes the bisimulation clauses somewhat. A \npair (S1, S2), of type\u00adcontext-indexed relations, is a coupled simulation if: S1 and (S2)-1 are weak \nsimulations (not translocat\u00ading).  if (LP, LQ) . (S1)G then there exists LQ ' such that G LQ =t. LQ \n' and (LP, LQ ' ) . (S2)G.  if (LP, LQ) . (S2)G then there exists LP ' such that ' G LP =t. LP ' and \n(LP ,LQ) . (S1)G. Two processes LP, LQ are coupled similar wrt G, written LP .G LQ, if they are related \nby both components of some coupled simulation. Intuitively LQ coupled simulates LP means that LQ is \nat most as committed as LP with respect to internal choices and that LQ may internally evolve to a state \nLQ ' where it is at least as committed as LP , i.e. where LP coupled simulates LQ ' . In this paper, \ncoupled simulation will be used for relating whole systems, which cannot be placed in any program con\u00adtext. \nFor this reason, we do not need to incorporate translo\u00adcation into the de.nition above. 6 Correctness \nof the Infrastructure This section outlines the strategies taken in order to prove the correctness of \nthe example encoding, using the tech\u00adniques from \u00a75. Partial Commitment Our example infrastructure intro\u00adduces \nmany t steps, each of which induces an intermediate state a target level term which is not a literal \ntranslation of any source level term. Some of these steps are determinis\u00adtic house-keeping steps; they \ncan be reduced to (and related by expansions to) normal forms. Some, however (migration steps and acquisitions \nof the daemon lock or of local agent locks), are partial commitment steps. They involve nonde\u00adterministic \ninternal choices and lead to partially committed states target level terms which are not bisimilar to \nany source level term, but must be related to them by coupled simulation. As an example, consider the \nencoding C [ LP ] of an agent a which sends message c! v to agent b at the current site of a, and in \nparallel visits the sites s1 and s2 (in any order). def LP =@a (a)c! v | migrate to s1 | migrate to s2 \nAssume a and b are initially at the same site. If the migrate to s1 process in C [ LP ] successfully \nacquires the local lock (a partial commitment step) the resulting state does not correspond exactly to \nany state of LP we know that a will eventually end up in s2, yet, as the .rst migration has not taken \nplace, the message from a will reach b. Intermediate Language We factor the construction of the main \ncoupled simulation (between source program and its encoding) by introducing an intermediate language \nIL, with states ranged over by Sys. This helps us manage the com\u00adplexity of the state-space of the encoding, \nby: 1. reducing the size of the coupled simulation relations, omitting states which reduce by house-keeping \nsteps to certain normal forms (which have no house-keeping steps); and 2. dealing with states in which \nmany agents may be par\u00adtially committed simultaneously; and  npLD,LI LP t . LQ L L IL \u00b7 t . \u00b7 t . \n\u00b7 U U U register currentloc create m .. .. .. . npLD \u00b7\u00b7 . \u00b7 . \u00b7 .. \u00b7 lock .. \u00b7 . \u00b7 . \u00b7 rack \u00b7 t \u00b7 \npack \u00b7 where LP =@acreate m b = P in Q and LQ = new b in @aQ|@bP . Figure 5: Relationships Between Source, \nIntermediate, and Target 3. capturing some invariants, eg. that the daemon s site\u00admap is correct, in \na type system for IL. The cost is that the typing and labelled transition rules for IL must be de.ned; \nfor lack of space we shall only outline some of the details. Each term of the intermediate language therefore \nrepresents a normal form of target-level derivatives, possibly in a par\u00adtially committed state. It describes \nthe state of the daemon as well as that of the encoded agent. The syntax is: Sys ::= eProg(.; D; A) Each \nterm eProg(.; D; A) is parameterised by ., a located type context corresponding to all names dynamically \ncre\u00adated during the execution of the program, and D and A, the state of the daemon and of the agents. \n. is binding in eProg(.; D; A) and is therefore subject to alpha-conversion. The latter two parameters \nare described in more detail be\u00adlow: The state D of the daemon is described by the following Each daemon \nstate [map mesgQ] consists of a site map map, expressed as a list of pairs, and an unordered queue of \nmessage forwarding requests mesgQ. A mes\u00adsage forwarding request mesgReq({|T|} [acv]) requires the daemon \nto forward c! v to the agent a, where T is the type of v.  The state A of the agents is a partial function \nmap\u00adping agent names to agent states. Each agent state, represented as [P E], consists of a main body \nP and a pending state E. The syntax of E is given below:  syntax: D ::= [map mesgQ]@ mesgQ ::= i.I mesgReq({|Ti|} \n[ai ci vi]) E ::= FreeA(s) | RegA(bZsP Q) | MtingA(sP ) | MtedA(sP ) If an agent a has pending state \nFreeA(s), the local lock of a is free and is ready to initiate a create or migrate to process from its \nmain body. Otherwise, a is in a partially committed state, with a pending execution of create Z b = P \nin Q (when its state is RegA(bZsP Q)) or migrate to s . P (when its state is MtingA(sP ) or MtedA(sP \n)). In FreeA(s) and RegA(bZsP Q), s denotes the current site of a, in\u00adternally recorded and maintained \nby the agent itself. In RegA(bZsP Q), the name b is bound in P and Q and is subject to alpha-conversion. \nInformally, each transition of a system originates either from an agent or the daemon. A process from \nthe main body of an agent may be executed immediately if it is either an iflocal , if , let or a pair \nof an output and a (replicated) input on the same channel. The result of such an execution (governed \nby npLD,LI LTS rules) is placed in parallel with other processes in the main body, except for execution \nof an LI output (b)c! v, which results in the message forwarding re\u00adquest mesgReq({|T|} [bcv]) being \nadded to the message queue of the daemon (T is the type of v). These steps correspond exactly to those \ntaken by source-and target-level terms. A process create Z b = P in Q or migrate to s.P from the main \nbody of a may proceed (in fact initiate) if the local lock is free, ie. the pending state is FreeA(s \n' ). The result of such initiation turns the pending state to RegA(bZs ' PQ) or MtingA(sP ) respectively. \nTranslating into target-level terms, an agent in such a state has successfully acquired its local lock \nand sent a registration or migrating request to the daemon. A system with registration request RegA(bZsP \nQ) is exe\u00adcuted in a single reduction step, corresponding in the target\u00adlevel to acquiring the daemon \nlock, updating the site map and sending the acknowledgement to b. After completion, the declaration b \n: AgentZ @s is placed at the top level and, at the same time, the site map is extended with the new entry \n(b, s). The new agent b with state [P FreeA(s)] now commences its execution, and so does its parent. \nFigure 5 gives the correspondences between steps in the source, in\u00adtermediate and the target languages \nin the creation case. In the .gure, some t communication steps are annotated with the command or the \nname of the channel involved. Likewise, a system with a message forwarding request mesgReq({|T|} [bcv]) \nis executed in a single reduction step, corresponding in the target-level to acquiring the daemon lock, \nlooking up the site of b, delivering the message, and receiving an acknowledgement from b. After completion, \nthe message c! v is added to the main body of b. Serving a migrating request MtingA(sP ) from an agent \na, however, involves two steps. The .rst step acquires the dae\u00admon lock, initialising the request and \nturning the pending state of a to MtedA(sP ). In the second step, the agent a migrates to s (hence changes \nthe top-level declaration) and the site map updates a with the entry (a, s). The .rst step corresponds \nin the target-level to acquiring the daemon lock, looking up the site of a in the site map, and sending \nan ac\u00adknowledgement, permitting a to migrate. The second step corresponds to a migrating to s and sending \nan acknowl\u00adedgement back to the daemon, which updates its site map and then sends the .nal acknowledgement \nto a, allowing it to proceed. Factoring the proof The infrastructure encoding is fac\u00adtored into the composition \nof a loading encoding L, mapping source terms to corresponding systems in the intermediate language, \nand an unloading encoding U, mapping systems in the intermediate language to their corresponding target \nterms. L[ \u00b7] . npLD,LI IL  ] C[ \u00b7] U [ \u00b7 t npLD Note that our encoding is not uniform [Pal97], \nas it intro\u00adduces a centralised daemon at top level. This means that our reasoning must largely be about \nthe whole system, dealing with interactions between encoded agents and the daemon. We cannot use simple \ninduction on source program syntax. We prove the coupled simulation over programs which are well-typed \nwith respect to a valid system context: a type context in which all agents are declared as static (in \norder to use the standard de.nition of coupled simulation) and channels are not used for sending or receiving \nagent names (in order to make sure the daemon has a record of all agents in the system). Dynamically \ncreated new-bound agents may be mobile, of course. We use two functions mapping intermediate language \nstates back into the source language. The undo and commit de\u00adcoding functions, Db and D. respectively, \nundo and com\u00adplete partially committed migrations (it su.ces to have both functions commit creations \nand LI messages, as these are somewhat con.uent). D'[ \u00b7] 4 4 npLD,LI IL D.[ \u00b7] The main lemmas can \nnow be stated. Lemma 6.1 (Syntactic Factorisation) For any LP well-typed wrt a valid system context F \nCF [ LP ] =U [ LF [ LP ]]]], and LP =Db [ LF [ LP ]]]] =D. [ LF [ LP ]]]].  Lemma 6.2 (Semantic Correctness \nof IL) For any Sys well-formed wrt F, U [ Sys] c.F\u00d8 Sys. The proof of this uses expansion up to expansion \nto relate each well-formed term in the intermediate language with its corresponding target term. Here \nwe heavily employ the congruence properties of translocating expansion for factor\u00ading out program contexts \nwhich are not involved in house\u00adkeeping reductions of the target terms. Temporary immobil\u00adity is used \nwhenever we need to guarantee that LD messages to partially-committed agents are safely delivered. The \nfollowing two lemmas relate intermediate language states to source terms, by weak simulation relations \nusing either the undo or commit decodings. Their proofs are rel\u00adatively straightforward. Lemma 6.3 (Db \nis a strict simulation) \u00df For any Sys well-formed wrt F, if F Sys -. Sys ' then . Db\u00df Db ' F[ Sys] -. \n[ Sys ]]. . Lemma 6.4 (D.-1 is a progressing simulation) \u00df For any Sys well-formed wrt F, if F D. [ Sys] \n-. LP . then there exists a well-formed state Sys ' such that LP = D. [ Sys ' ] and F Sys =\u00df . Sys ' \n. . These results are combined to give a direct relation between the source and the target terms (using \nweak simulation up to expansion), proving that a source term LP and its trans\u00adlation C [ LP ] are related \nby a coupled simulation. Theorem 6.1 (Encoding Correctness) For any LP well-formed wrt a valid system \ncontext F, LP .F CF [ LP ]]. The use of coupled simulation makes this a rather strong result, but it \ndoes not take the external I/O of a whole pro\u00adgram into account. That could be done by tuning a notion \nof testing [dH84] to this setting, generalising [Sew97] from Pict to the distributed case. 7 Conclusion \nRelated Work A wide range of other aspects of distributed and mobile computation have been studied via \nparticular process calculi, eg. in [FGL+96, CG98, RH98, Sew98, VC98] among others space prevents a detailed \ncomparison, but see [Sew00]. There is a large body of semantic work on concurrent and distributed algorithms. \nCrudely, it can be subdivided into work taking an automata-theoretic approach and work on encodings of \nhigh-level primitives. The former includes [AP98, JNW98], addressing Mobile IP, and [Mor99], which studies \nan infrastructure providing a similar abstraction to that of this paper. All involve more-or-less idealised \nmodels of algorithms rather than directly executable code. The lat\u00adter includes encodings of choice [NP96], \np/join communica\u00adtion [FG96], and authenticated communication [AFG00], all in terms of some code that \nin principle is executable. There is a trade-o. here: the idealised models can be expressed in a simpler \nformal framework, greatly simplifying correctness proofs, but they are further removed from implementation, \nincreasing the likelihood that important details have been abstracted away. This is discussed further \nin [Woj00]. Much of the latter work uses correctness results stated in terms of full abstraction wrt. \nsome barbed congruence. Here, as the target language is a sublanguage of the source, we could state a \nmore direct correspondence between the behaviour of source and target. Veri.cation of mobile communication \ninfrastructures has also been considered in the Mobile Unity setting [MR97]. Summary and Future Work \nWe have addressed the dis\u00adtributed infrastructure algorithms required for location\u00adindependent communication \nbetween mobile agents. We have developed semantics and proof techniques for prov\u00ading correctness of such \nalgorithms, expressed as translations from high-level to low-level Nomadic Pict. The techniques were \nillustrated by a proof that an example algorithm is cor\u00adrect wrt. coupled simulation. This algorithm, \nthough non\u00adtrivial, is one of the simplest possible. We believe that more sophisticated algorithms can \nbe dealt with using the same techniques, albeit with new intermediate languages (tailored to particular \nalgorithms). By expressing infrastructure algorithms as Nomadic Pict en\u00adcodings, we have descriptions \nof them that are: executable one can rapidly prototype both algorithms and applications written above \nthem in the high-level language; and  concise with the details of concurrency, locking, name-generation \netc. made clear; and  precise with a semantics that we can use for formal reasoning and that gives \na solid understanding of the primitives for informal reasoning.  More generally, the work is a step \ntowards a semantically\u00adfounded view of richer wide-area distributed systems here we dealt with the combination \nof migration and location\u00addependent communication; ultimately one must also simul\u00adtaneously address failure \nand malicious attack. References [ACM96] ACM. 23rd Annual Symposium on Principles of Programming Languages \n(POPL) (St. Petersburg Beach, Florida), 1996. [AFG00] Mart\u00b4in Abadi, C\u00b4edric Fournet, and Georges Gonthier. \nAuthentication primitives and their compilation. In Proceedings of POPL 00. ACM, 2000. [AP98] Roberto \nM. Amadio and Sanjiva Prasad. Mod\u00adelling IP mobility. In Proceedings of CON-CUR 98, volume 1466 of LNCS, \npages 301 316. Springer, September 1998. [Car97] Luca Cardelli. Global computation. ACM SIG-PLAN Notices, \n32(1):66 68, January 1997. [CG98] Luca Cardelli and Andrew D. Gordon. Mobile ambients. In Proceedings \nof FoSSaCS 98, volume 1378 of LNCS, pages 140 155. Springer, 1998. [CGG99] Luca Cardelli, Giorgio Ghelli, \nand Andrew D. Gordon. Mobility types for mobile ambients. In Proceedings of ICALP 99, volume 1644 of \nLNCS, pages 230 239. Springer, July 1999. [CHK97] D. Chess, C. G. Harrison, and A. Kershenbaum. Mobile \nagents: Are they a good idea? In Mo\u00adbile Object Systems -Towards the Programmable Internet, LNCS, pages \n25 47. Springer-Verlag, Berlin Germany, 1997. [CON96] CONCUR 96: Concurrency Theory, 7th Inter\u00adnational \nConference, volume 1119 of LNCS, Pisa, Italy, August 1996. Springer-Verlag. [dH84] R. de Nicola and M. \nC. B. Hennessy. Testing equivalences for processes. Theoretical Computer Science, 34(1-2):83 133, November \n1984. [FG96] C\u00b4edric Fournet and Georges Gonthier. The re\u00ad.exive chemical abstract machine and the join\u00adcalculus. \nIn Proceedings of POPL 96 [ACM96], pages 372 385. [FGL+96] C\u00b4edric Fournet, Georges Gonthier, Jean-Jacques \nL\u00b4evy, Luc Maranget, and Didier R\u00b4emy. A calcu\u00adlus of mobile agents. [CON96], pages 406 421. [JNW98] \nDaniel Jackson, Yuchung Ng, and Jeannette Wing. A Nitpick analysis of mobile IPv6. Tech\u00adnical Report \nCMU-CS-98-113, Computer Science Department, CMU, March 1998. [KPT96] Naoki Kobayashi, Benjamin C. Pierce, \nand David N. Turner. Linearity and the pi-calculus. In Proceedings of POPL 96 [ACM96], pages 358 371. \n[Mil93] Robin Milner. The polyadic p-calculus: A tuto\u00adrial. volume 94 of Series F: Computer and System \nSciences. Springer, 1993. Available as Techni\u00adcal Report ECS-LFCS-91-180, University of Ed\u00adinburgh, October \n1991. [Mor99] Luc Moreau. Distributed Directory Service and Message Router for Mobile Agents. Technical \nRe\u00adport ECSTR M99/3, University of Southampton, 1999. [MPW92] Robin Milner, Joachim Parrow, and David \nWalker. A calculus of mobile processes, part I/II. Information and Computation, 100:1 77, September 1992. \n[MR97] P. J. McCann and G.-C. Roman. Mobile UNITY coordination constructs applied to packet for\u00adwarding \nfor mobile hosts. In Proceedings of CO-ORDINATION 97, LNCS 1282, 1997. [NP96] Uwe Nestmann and Benjamin \nC. Pierce. Decod\u00ading choice encodings. [CON96], pages 179 194. [Pal97] Catuscia Palamidessi. Comparing \nthe expressive power of the synchronous and the asynchronous p-calculus. In Proceedings of POPL 97, pages \n256 265. ACM, January 1997. [PS92] J. Parrow and P. Sjodin. Multiway synchroniza\u00adtion veri.ed with coupled \nsimulation. In Proceed\u00adings CONCUR 92, LNCS 630, 1992. [PS96] Benjamin C. Pierce and Davide Sangiorgi. \nTyping and subtyping for mobile processes. Mathematical Structures in Computer Science, 6(5):409 454, \n1996. An extract appeared in Proc. LICS 93: 376 385. [PT00] Benjamin C. Pierce and David N. Turner. Pict: \nA programming language based on the pi\u00adcalculus. In Gordon Plotkin, Colin Stirling, and Mads Tofte, editors, \nProof, Language and Inter\u00adaction: Essays in Honour of Robin Milner. MIT press, May 2000. [RH98] James \nRiely and Matthew Hennessy. A typed language for distributed mobile processes. In Proceedings of POPL \n98, January 1998. [San99] Davide Sangiorgi. The name discipline of uni\u00adform receptiveness. Theoretical \nComputer Sci\u00adence, 221(1 2):457 493, 1999. An abstract ap\u00adpeared in the Proceedings of ICALP 97 , LNCS \n1256. [Sew97] Peter Sewell. On implementations and seman\u00adtics of a concurrent programming language. In \nProceedings of CONCUR 97, LNCS 1243, pages 391 405, 1997. [Sew98] Peter Sewell. Global/local subtyping \nand capa\u00adbility inference for a distributed pi-calculus. In Proceedings of ICALP 98, volume 1443 of LNCS, \npages 695 706. Springer, July 1998. [Sew00] Peter Sewell. Applied p a brief tutorial. Tech\u00adnical Report \n498, Computer Laboratory, Univer\u00adsity of Cambridge, August 2000. [SM92] D. Sangiorgi and R. Milner. The \nproblem of weak bisimulation up to . In Proceedings CON-CUR 92, LNCS 630, 1992. [SWP98] Peter Sewell, \nPawe.l T. Wojciechowski, and Ben\u00adjamin C. Pierce. Location independence for mo\u00adbile agents. In Proceedings \nof the Workshop on Internet Programming Languages (Chicago), May 1998. Full version appeared in LNCS \n1686. [TLK96] Bent Thomsen, Lone Leth, and Tsung-Min Kuo. A Facile tutorial. [CON96], pages 278 298. \n[VC98] Jan Vitek and Giuseppe Castagna. Towards a calculus of secure mobile computations. In IEEE Workshop \non Internet Programming Languages, Chicago, Illinois, May 1998. Full version ap\u00adpeared in LNCS 1686. \n[Woj00] Pawe.l T. Wojciechowski. Nomadic Pict: Lan\u00adguage and Infrastructure Design for Mobile Com\u00adputation. \nPhD thesis, Computer Laboratory, University of Cambridge, 2000. Available as Technical Report 492, June \n2000. [WS00] Pawe.l T. Wojciechowski and Peter Sewell. No\u00admadic Pict: Language and infrastructure design \nfor mobile agents. IEEE Concurrency, 8(2):42 52, April June 2000. \n\t\t\t", "proc_id": "360204", "abstract": "This paper addresses the design and verification of infrastructure for mobile computation. In particular, we study language primitives for communication between mobile agents. They can be classi ed into two groups. At a low level there are <i>location dependent</i> primitives that require a programmer to know the current site of a mobile agent in order to communicate with it. At a high level there are <i>location independent</i> primitives that allow communication with a mobile agent irrespective of any migrations. Implementation of the high level requires delicate distributed infrastructure algorithms. In earlier work with Wojciechowski and Pierce we made the two levels precise as process calculi, allowing such algorithms to be expressed as encodings of the high level into the low level; we built NOMADIC PICT, a distributed programming language for experimenting with such encodings. In this paper we turn to semantics, giving a de nition of the core language and proving correctness of an example infrastructure. This requires novel techniques: we develop equivalences that take migration into account, and reasoning principles for agents that are temporarily immobile (eg. waiting on a lock elsewhere in the system).", "authors": [{"name": "Asis Unyapoth", "author_profile_id": "81100426784", "affiliation": "Computer Laboratory, University of Cambridge", "person_id": "P22635", "email_address": "", "orcid_id": ""}, {"name": "Peter Sewell", "author_profile_id": "81100511814", "affiliation": "Computer Laboratory, University of Cambridge", "person_id": "PP14177906", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/360204.360214", "year": "2001", "article_id": "360214", "conference": "POPL", "title": "Nomadic pict: correct communication infrastructure for mobile computation", "url": "http://dl.acm.org/citation.cfm?id=360214"}