{"article_publication_date": "01-01-2001", "fulltext": "\n Typing a Multi-Language Intermediate Code Andrew D. Gordon and Don Syme Microsoft Research Abstract \nThe Microsoft .NET Framework is a new computing ar\u00adchitecture designed to support a variety of distributed \nap\u00adplications and web-based services. .NET software compo\u00adnents are typically distributed in an object-oriented \ninter\u00admediate language, Microsoft IL, executed by the Microsoft Common Language Runtime. To allow convenient \nmulti\u00adlanguage working, IL supports a wide variety of high-level language constructs, including class-based \nobjects, inheri\u00adtance, garbage collection, and a security mechanism based on type safe execution. This \npaper precisely describes the type system for a sub\u00adstantial fragment of IL that includes several novel \nfeatures: certain objects may be allocated either on the heap or on the stack; those on the stack may \nbe boxed onto the heap, and those on the heap may be unboxed onto the stack; methods may receive arguments \nand return results via typed point\u00aders, which can reference both the stack and the heap, includ\u00ading the \ninteriors of objects on the heap. We present a for\u00admal semantics for the fragment. Our typing rules determine \nwell-typed IL instruction sequences that can be assembled and executed. Of particular interest are rules \nto ensure no pointer into the stack outlives its target. Our main theo\u00adrem asserts type safety, that \nwell-typed programs in our IL fragment do not lead to untrapped execution errors. Our main theorem does \nnot directly apply to the prod\u00aduct. Still, the formal system of this paper is an abstraction of informal \nand executable speci.cations we wrote for the full product during its development. Our informal spec\u00adi.cation \nbecame the basis of the product team s working speci.cation of type-checking. The process of writing \nthis speci.cation, deploying the executable speci.cation as a test oracle, and applying theorem proving \ntechniques, helped us identify several security critical bugs during development. Introduction This paper \ndescribes typing and evaluation rules, and a type safety theorem, for a substantial fragment of the intermedi- \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior specific permission and/or a fee. POPL \n'01 1/01 Londo, UK Copyright 2001 ACM 1-58113-336-7/01/0001 ... $5.00  ate language (IL) executed by \nMicrosoft s Common Lan\u00adguage Runtime. The rules are valuable because they suc\u00adcinctly and precisely account \nfor some unusual and subtle features of the type system. Background: IL The Common Language Runtime is \na new execution environment with a rich object-oriented class li\u00adbrary through which software components \nwritten in diverse languages may interoperate. Using the Visual Studio .NET development environment, \n.NET components can be writ\u00adten in the new object-oriented language C# [HW00], as well as Visual Basic, \nVisual C++, and the scripting languages VBScript and JScript. Furthermore, prototype .NET com\u00adpilers \nexist for COBOL, Component Pascal, Ei.el, Haskell, Mercury, Oberon, Ocaml, and Standard ML. Type-checking \nof .NET components implemented in IL has already proved useful for .nding code generation bugs. Moreover, \nthe .NET security model assumes type-safe be\u00adhaviour; type-checking is therefore useful for handling \nun\u00adtrusted components. Given these and other applications, the IL type system is worthy of formal speci.cation. \nBackground: Executable Speci.cations This paper is one outcome of a research project to evaluate and \ndevelop formal speci.cation techniques for describing and analyzing type\u00adcheckers in general. Speci.cally, \nwe applied these techniques to the study of IL. We began by writing a detailed speci.ca\u00adtion of type-checking \nmethod bodies. This was an informal document in the style of most language references. Eventu\u00adally, this \ndocument was adopted by the product team as the basis of their detailed speci.cation of type-checking. \nIn par\u00adallel, following a methodology advocated by Syme [Sym98], we wrote formal speci.cations for various \nIL subsets suitable for comparative testing and formal proof. The executable part of these speci.cations \nis in a functional fragment of ML, the rest in higher order logic (HOL). We can compile and run the executable \npart as an IL type-checker. Since it is purely functional code, we may also interpret it as HOL and use \nit for theorem proving in DECLARE [Sym98]. In principle, this strategy allows the same source code to \nserve both as an oracle for testing actual implementations and as a model for formal validation. So far, \nwe have built an ML type-checker for a largely complete subset of the IL type system, but have formally \nveri.ed only a rather smaller fragment. As is well known [Coh89], even formal proof cannot guar\u00adantee \nthe absence of implementation defects, simply because one has to abstract from details of the environment \nwhen writing formal models. We found that developing a test suite that used our formal model as an oracle \nwas an important way of making our model consistent with the runtime. Our suite included about 30,000 \nautomatically generated tests. Our experience was that testing remains the only viable way of relating \na speci.cation to software of the complexity we were considering. One of our slogans: if you specify, \nyou must test. Writing a formal speci.cation without generat\u00ading tests may be viable once a design has \nbeen frozen, but is simply not e.ective during the design of a new system. Eventually, we handed over \nour suite to the test team, who maintain it, and who have found bugs using it. This Paper: An IL Fragment \nThe main part of the pa\u00adper concerns an IL fragment based on reference, value, and pointer types. At \nits core, the fragment is a class-based object-oriented language with .eld update and simple imperative \ncontrol structures. This core is comparable to the imperative object calculus [AC96, GHL99] and to various \nfragments of Java [DE97, IPW99]. An item of a reference type is a pointer to a heap-allocated object. \nMoreover, our fragment includes value and pointer types: An item of a value type is a sequence of machine \nwords representing the .elds of the type. Value types support the compilation of C-style structs, for \ninstance. Value types may be stack-allocated and passed by value. A box instruction turns a value type \ninto a heap-allocated object by copying, and an unbox instruction performs the inverse coercion. Hence, \nwhen convenient, value types may be treated as ordinary heap-allocated ob\u00adjects.  An item of pointer \ntype is a machine address referring either to a heap-allocated object or to a variable in the call stack \nor to an interior .eld of one of these. The main purpose of pointer types is to allow methods to receive \narguments or return results by reference.  We selected these types because they are new constructs not \npreviously described by formal typing rules, and because their use needs to be carefully limited to avoid \ntype loop\u00adholes. In particular, we must take care that stack pointers do not outlive their targets. For \nthe sake of clarity, our presentation of the semantics di.ers from the ML code in our executable speci.cations \nin two signi.cant ways: First, we adopt the standard strategy of presenting the type system as logical \ninference rules. Such rules are succinct, but not directly executable; we found it better to write executable \nML when we initially wrote our speci.cations in order to help with testing. Still, typing rules are better \nthan code for presenting a type system and for manual proof.  Second, we adopt a new, non-standard strategy \nof as\u00adsuming that each method body has been parsed into a tree-structured applicative expression. Each \nexpres\u00adsion consists of an IL instruction applied to the subex\u00adpressions that need to be evaluated to \ncompute the instruction s arguments. This technique allows us to concentrate on specifying the typing \nconditions for each instruction, and to suppress the algorithmic details of how a type-checker would \ncompute the types of the  arguments to each instruction. These algorithmic de\u00adtails are important in \nany implementation, but they are largely irrelevant to specifying type safety. Finally, in the spirit \nof writing speci.cations to support testing, our applicative expressions use the standard IL as\u00adsembler \nsyntax. Hence, any method body that is well-typed according to our typing rules can be assembled and \ntested on the running system. In summary, the principal technical contributions made by this paper are \nthe following: New typing and evaluation rules for value and pointer types, together with a type safety \nresult, Theorem 1.  The idea that the essence of a low-level intermediate language can be presented \nin an applicative notation.  Future Challenges: As we have discussed, this project is a successful \ndemonstration of the value of writing executable, formal speci.cations during product development. On \nthe other hand, the main theorem of this paper does not apply to the full product; type safety bugs may \nwell be discovered. An unful.lled ambition of ours is to prove soundness of the typing rules for the \nfull language through mechanized theorem-proving. So a future challenge is to further develop scalable \nand maintainable techniques for mechanized reasoning. A soundness proof for the whole of IL would be \nan impressive achievement. To apply theorem proving during product development, scalability and main\u00adtainability \nof proof scripts are important. Scripts should be scalable in the sense that human e.ort is roughly linear \nin the size of the speci.cation (with a reasonable constant factor), or else proof construction cannot \nkeep up with new features as they are added. Scripts should be maintainable in the sense that they are \nrobust in the face of minor changes to the speci.cation, or else proof construction cannot keep up with \nthe inevitable revisions of the design. In the meantime, another challenge is to develop system\u00adatic \ntechniques for test case generation. A third challenge is to integrate executable speci.ca\u00adtions, such \nas our ML type-checker, into the product it\u00adself. The .NET Framework, like other component models, itself \ncontributes to this goal, in that its support for multi\u00adlanguage working would easily allow a critical \ncomponent to be written in ML, say, even if the rest of the product is not. The remainder of the paper \nproceeds as follows. Sec\u00adtion 2 presents the typing and evaluation rules for our IL fragment, and states \nour main theorem. Section 3 explains a potentially useful liberalisation of the type system. Section \n4 summarizes the omissions from our IL fragment. Section 5 discusses related work. Section 6 concludes. \nProofs omitted from this conference paper appear in a technical report [GS00]. 2 A Formal Analysis of \nBIL, a Baby IL This section makes the main technical contributions of the paper. We present a substantial \nfragment of IL that includes enough detail to allow a formal analysis of reference, value, and pointer \ntypes, but omits many features not related to these. We name this fragment Baby IL, or BIL for short. \nSection 2.1 describes the type structure of BIL. In Sec\u00adtion 2.2, we specify the instructions that may \nappear in method bodies of BIL, and explain their informal seman\u00adtics. In Section 2.3, we specify a formal \nmemory model for BIL, and a formal semantics for the evaluation of method bodies. In Section 2.4, we \nspecify a formal type system for type-checking method bodies. Section 2.5 introduces confor\u00admance relations \nthat express when intermediate states aris\u00ading during evaluation are type-correct. Finally, Section 2.6 \nconcludes this analysis by stating our Type Safety Theorem. 2.1 Type Structure and Class Hierarchy All \nBIL methods run in an execution environment that con\u00adtains a .xed set of classes. Each class speci.es \ntypes for a set of .eld variables, and signatures for a set of methods. Each object belongs to a class. \nThe memory occupied by each object consists of values for each .eld speci.ed by its class. Methods are \nshared between all objects of a class (and possibly other classes). Objects of all classes may be stored \nboxed in a heap, addressed by heap references. Objects of certain classes known as value classes may \nadditionally be stored unboxed in the stack or as .elds embedded in other objects. Formally, we assume \nthree sets, Class, Field, and Meth, the sets of class, .eld, and method names, respectively, and a set \nValueClass . Class of value class names. We as\u00adsume a distinguished class name System.Object such that \nSystem.Object ./ValueClass. Classes, Fields, Methods: c . Class class name vc . ValueClass . Class value \nclass name System.Object . Class - ValueClass root of hierarchy f . Field .eld name . . Meth method name \nTypes describe objects, the .elds of objects, the argu\u00adments and results of methods, and the intermediate \nresults arising during evaluation of method bodies. Types: A, B . Type ::= type void no bits int32 32 \nbit signed integer class c boxed object value class vc unboxed object A&#38; pointer to A The type void \ndescribes the absence of data, no bits; void is only used for the results of methods or parts of method \nbodies that return no actual result. The type int32 describes a 32 bit integer; BIL uses inte\u00adgers to \nrepresent predicates for conditionals and while-loops but includes no primitive arithmetic operations. \n(IL features a rich selection of numeric types and arithmetic operations.) A reference type class c describes \na pointer to a boxed object (heap-allocated, subject to garbage collection). A value type value class \nvc describes an unboxed object a sequence of words representing the .elds of the value class vc, akin \nto a C struct. The associated refer\u00adence type, class vc describes a pointer to a boxed object a heap-allocated \nrepresentation of the .elds. Finally, a pointer type A&#38; describes a pointer to data of type A, which \nmay be stored either in the heap or the stack. To avoid dangling pointers pointers that outlive their \ntargets our type system restricts pointers as follows. An important use for pointers in IL is to allow \narguments and results to be passed by reference. The following are su.\u00adcient conditions to type-check \nthis motivating usage while preventing dangling pointers. The following are not neces\u00adsary conditions; \nwe explain a useful and safe liberalisation in Section 3. BIL Pointer Con.nement Policy: (1) No .eld \nmay hold a pointer. (2) No method may return a pointer. (3) No pointer may be stored indirectly via \nanother pointer.  (IL itself follows a slightly stricter policy that bans point\u00aders to pointers altogether.) \nEach of the conditions prevents a way of creating a dangling pointer. If a .eld could hold a pointer, \na method could store a pointer into its stack frame in an object boxed on the heap. If a method could \nreturn a pointer, a method could simply return a pointer into its stack frame. If a pointer could be \nstored indirectly, a method could store a pointer into its stack frame through a pointer to an object \nboxed on the heap or to an earlier stack frame. In each case, the pointer would outlive its target as \nsoon as the method had returned. The following predicate identi.es types containing no pointers. Whether \na Type Contains No Pointer: pointerFree(A) .\u00ac(A = B&#38; for some B) Next, a method signature Be(A1,...,An) \nrefers to a method named . that expects a vector of arguments with types A1, ..., An, and whose result \nhas type B. No two methods in a given class may share the same signature, though they may share the same \nmethod name. Method signature: sig . Sig ::= Be(A1,...,An) method signature We assume the execution environment \norganises classes into an inheritance hierarchy. We write c inherits c. to mean that c inherits from \nc'. We induce a subtype relation, A<: B, from the inheritance hierarchy. Our type system supports subsumption: \nif A<: B an item of type A may be used in a context expecting an item of type B. The only non-trivial \nsubtyping is between reference types. The subtype relation is the least to satisfy the following rules. \nSubtype Relation: A<: B (Sub Re.) (Sub Class) c inherits c A<: A class c<: class c We assume that the \nrelation c inherits c. is transitive, and therefore so is the relation A<: B. The IL assembler recognises \na fairly standard notation for single inheritance that allows a class to inherit methods and .elds from \na single superclass. One might de.ne the inheritance relation by formalizing such a syntax and type\u00adchecking \nrules. Instead, since our focus is type-checking the BIL instruction set, it is easier and more concise \nto simply axiomatize the intended properties of the hierarchy. (Al\u00adthough the IL syntax disallows multiple \ninheritance, it hap\u00adpens that our axioms allow a class to inherit from two super\u00adclasses that are incomparable \naccording to the inheritance relation.) Formally, we assume there is an execution environment consisting \nof three components a function .elds(c), a func\u00ad ' tion methods(c), and an inheritance relation c inherits \nc that satisfy the following axioms: Execution Environment: (.elds, methods, inherits) .n .elds . Class \n. (Field . Type) .elds of a class .n methods . Class . (Sig . Body) methods of a class inherits . Class \n\u00d7 Class class hierarchy c inherits c (Hi Re.) c inherits c' . (Hi Trans) '' c' inherits c'' . c inherits \nc '' c inherits c. c' inherits c . c = c(Hi Antisymm) c inherits System.Object (Hi Root) c inherits \nd . f . dom(.elds(d)) . (Hi .elds) f . dom(.elds(c)) . .elds(c)(f)= .elds(d)(f) c inherits d . (Hi methods) \ndom(methods(d)) . dom(methods(c)) c inherits vc . c = vc (Hi Val) pointerFree(.elds(c)(f)) (Good .elds) \nBe(A1,...,An) . dom(methods(c)) (Good methods) . pointerFree(B) .n For any class c, .elds(c) . Field \n. Type, the set of .nite i. 1..n maps from .eld names to types. If .elds(c)= fi . Ai , the class c has \nexactly the set of .elds named f1,..., fn with types A1, ..., An, respectively. i. 1..n (The notation \nfi . Ai exempli.es our notation i. 1..n) for .nite maps in general. We let dom(fi . Ai = {f1,...,fn}. \nWe assume that the fi are distinct. Let (fi . Aii. 1..n)(f)= Ai if f = fi for some i . 1..n, and otherwise \nbe unde.ned.) .n For any class c, methods(c) . Sig . Body, the set of .\u00adnite maps from method signatures \nto method bodies. We de\u00ad.ne the set Body of method bodies instruction sequences in the next section. \nIf methods(c)= sigi . bii. 1..n, the class c has exactly methods with signatures sig1, ..., sign, implemented \nby the bodies b1, ..., bn, respectively. A binary relation on classes, inherits, formalizes the in\u00adheritance \nhierarchy. Axioms (Hi Re.) and (Hi Trans) guar\u00adantee it is re.exive and transitive. (Hi Antisymm) asserts \nit is anti-symmetric, that is, there are no cycles in the hi\u00aderarchy. According to (Hi Root), every class \ninherits from System.Object, the root of the hierarchy. Suppose that c is a subclass of d, that is, c \ninherits d. By subsumption, an object of the subclass c may be used in a context expecting an object \nof the superclass d. Accord\u00adingly, (Hi .elds) asserts that every .eld speci.ed by d is also present in \nthe subclass c. The axiom (Hi methods) asserts that every method signature implemented by d is also im\u00adplemented \nby the subclass c, though not necessarily by the same method body. In order to implement a method invocation \non an object, we need to know the class of the object. In general, we cannot statically determine the \nclass of an object from its type, since by subsumption it may in fact be a subclass of the class named \nin its type. Therefore, each boxed object is tagged in our formal memory model with the name of its class. \nOn the other hand, for the sake of space e.ciency, unboxed objects include no type information. Therefore, \nwe must rely on statically determining the class of an unboxed object from its type. For this to be possible, \naxiom (Hi Val) prevents any other class from inheriting from a value class. So the actual class of any \nunboxed object is the same as the class named in its type. Axioms (Good .elds) and (Good methods) implement \npoints (1) and (2) of the Pointer Con.nement Policy. We end this section by exemplifying how value and \npointer types provide possibly more e.cient alternatives to reference types for returning multiple results. \nSuppose there is a class Point . ValueClass such that .elds(Point)= x . int32, y . int32, that is, a \nclass with two integer .elds. Here are three alternative signatures for returning a Point from a method \nnamed mouse: As a boxed object: class Point mouse ().  As an unboxed object: value class Point mouse \n().  In a pre-allocated unboxed object passed by reference: void mouse (value class Point&#38;).  \n2.2 Syntax of Method Bodies BIL is a deterministic, single-threaded, imperative, class\u00adbased object-oriented \nlanguage. For the sake of simplicity, we omit constructs for error or exception handling. This sec\u00adtion \nspeci.es the instruction set as tree-structured applica\u00adtive expressions, most of which represent an \napplication of an instruction to a sequence of argument expressions. Since each applicative expression \nis in a post.x notation, it can also be read as a sequence of atomic instructions. We have chosen our \nsyntax carefully so that, subject to very minor editing, this sequence of atomic instructions can be \nparsed by the IL assembler (as well as our own IL type-checker). We express the syntax of our conditional \nand iteration constructs using assembler labels, ranged over by L. A method reference Bc::e(A1,...,An) \nrefers to the method with signature Be(A1,...,An) in class c. Inspired by FJ [IPW99], we assume for simplicity \nthat each class has exactly one constructor, whose arguments are the initial values assumed by the .elds \nof the new ob\u00adject. The constructor reference for a class c takes the form void c::.ctor(A1,...,An). \nConstructors are only called to create a new object; .ctor ./Meth. Method and Constructor References: \nL assembler label M ::= Bc::e(A1,...,An) method reference K ::= void c::.ctor(A1,...,An) constructor \nreference Applicative Expressions for Method Bodies: i4 32 bit signed integer a, b . Body ::= method \nbody ldc.i4 i4 load integer a brtrue L1 b0 br L2 L1:b1 L2: conditional L1: a brfalse L2 b br L1 L2: while-loop \nab sequencing a ldind load indirect ab stind store indirect ldarga j load argument address a starg j \nstore into argument a1 \u00b7\u00b7\u00b7 an newobj K create new object a0 a1 \u00b7\u00b7\u00b7 an callvirt M call on boxed object \na0 a1 \u00b7\u00b7\u00b7 an call instance M call on unboxed object a ldflda Ac::f load .eld address ab stfld Ac::f store \ninto .eld a box vc copy value to heap a unbox vc fetch pointer to value Conditionals and while-loops \nare not primitive instruc\u00adtions in IL, but it is worthwhile to make them primitive in BIL to allow a \nsimple format for evaluation and typing rules. We have carefully chosen a syntax for these constructs \nby assembling suitable IL branch instructions and labels. We assume that the assembler labels in these \nexpressions do not appear in any of their subexpressions. The result is a syntax that is a little cryptic \nbut that does produce IL instruction sequences with the appropriate semantics. These abbrevia\u00adtions are \nmore readable: Abbreviations for Conditionals and While-Loops: . ab0 b1 cond = a brtrue L1 b0 br L2 L1:b1 \nL2: . ab while = L1: a brfalse L2 b br L1 L2: The technique of representing assembly language in an applicative \nsyntax works for this paper because it can ex\u00adpress all the operations on reference, value, and pointer \ntypes. We express structured control .ow like condition\u00adals or while-loops in this style by treating \nan assembly of IL branch instructions as a primitive BIL instruction. Still, the technique may not scale \nwell to express control .ow such as arbitrary branching within a method or exception handling. IL includes \nprimitive instructions ldfld and ldarg to load the contents of an object .eld or an argument. Instead \nof taking these as primitives in BIL, we can derive them as follows: Derived Instructions: . a ldfld \nAc::f = a ldflda Ac::f ldind . a ldarg j = a ldarga j ldind  2.3 Evaluating Method Bodies The memory \nmodel consists of a heap of objects and a stack of method invocation frames, each of which is a vector \nof arguments. Our semantics abstracts away from the details of evaluation stacks or registers. We assume \na collection of heap references, p, q, pointing to boxed objects in the heap. A pointer takes one of \nthree forms. A pointer p refers to the boxed object at p. A pointer (i, j) refers to argument j of stack \nframe i. A pointer ptr.f refers to .eld f of the object referred to by ptr. A result is either void 0, \nan integer i4 , a pointer ptr, or an unboxed object fi . uii.1..n, a .nite map consisting of a sequence \nof results u1, ..., un corresponding to the .elds f1, ..., fn, respectively. References, Pointers, Results: \np, q heap reference ptr ::= pointer p pointer to boxed object p (i, j) pointer to argument j of frame \ni ptr.f pointer to .eld f of object at ptr u, v ::= result 0 void i4 integer ptr pointer i.1..n fi . \nui value: unboxed object Next, we formalize our memory model. A heap is a .\u00adnite map from references \nto boxed objects, each taking the form c[fi . uii.1..n], where c is the class of the object, and fi . \nuii.1..n is its unboxed form. A frame, fr, is a vector of arguments writen as .args(u0,...,un): u0 is \nthe self param\u00adeter; u1,. . . ,un are the computed arguments. A stack, s, is a list of frames fr1 \u00b7\u00b7\u00b7 \nfrn. Finally, a store is a heap paired with a stack. Memory Model: i.1..n] o ::= c[fi . ui boxed object \ni.1..n h ::= pi . oi heap fr ::= .args(u0,...,un) frame: vector of arguments s ::= fr1 \u00b7\u00b7\u00b7 frstack (grows \nleft to right) s ::= (h, s) store n The example heap h = p . c[f1 . 0,f2 . (g . 1)] consists of a single \nboxed object c[f1 . 0,f2 . (g . 1)] at heap reference p. The boxed object is of class c and consists \nof .elds named f1 and f2. The .rst .eld contains the integer 0. The second .eld contains the unboxed \nobject g . 1, which itself consists of a .eld named g containing the integer 1. The example stack s = \n.args(p, p.f2.g).args(p, (1, 1)) consists of two frames. The bottom of the stack is the frame .args(p, \np.f2.g), consisting of two arguments, a ref\u00aderence to the boxed object at p, and a pointer to .eld g \nof .eld f2 of the same object. The top of the stack is the frame .args(p, (1, 1)), consisting of two \narguments, a reference to the boxed object at p, and the pointer (1, 1), which refers to argument 1 of \nframe 1, that is, the pointer p.f2.g. We rely on two auxiliary partial functions for dereferenc\u00ading and \nupdating pointers in a store: Auxiliary Functions for Lookup and Update: lookup(s, ptr) lookup ptr in \nstore s update(s, ptr,v ' ) update store s at ptr with result v ' We explain the intended meaning of \nstore lookup and update by example. Let store s =(h, s) where h and s are the heap and stack examples \nintroduced above. Then lookup(s, (1, 0)) is the reference p stored in argument 0 of frame 1, and lookup(s, \np.f2.g) is the integer 1 stored in .eld g of the unboxed object stored in .eld f2 of the boxed object \nat p. The outcome of update(s, (2, 0), 1) is to update s by replacing the reference p in argument 0 of \nframe 2 with 1. Similarly, the outcome of update(s, p.f1.g, 0) is to update s by replacing the integer \n1 in .eld g of .eld f1 of the boxed object at p with the integer 0. A little functional programming su.ces \nto de.ne these two functions; we give the full de.nitions in the Appendix. Our operational semantics \nof method bodies is a formal judgment s f b . v \u00b7 s ' meaning that in an initial store s, the body b \nevaluates to the result v, leaving .nal store s ' . (A judgment is simply a predicate de.ned by a set \nof inference rules.) Evaluation Judgment: s f b . v \u00b7 s ' given s, body b returns v, leaving s ' Our \nsemantics takes the form of an interpreter. The rest of this section presents the formal rules for deriving \nevalua\u00adtion judgments, interspersed with informal explanations. Evaluation Rules for Control Flow: (Eval \nldc) (Eval Seq) s '' s f a . u \u00b7 s ' s ' f b . v \u00b7 s '' s f ldc.i4 i4 . i4 \u00b7 ss f ab . v \u00b7 (Eval Cond) \n(where j = 0 if i4 = 0, otherwise j = 1) s ' s '' s f a . i4 \u00b7 s ' f bj . v \u00b7 s '' s f ab0 b1 cond . \nv \u00b7 (Eval While 0) s f a . 0 \u00b7 s ' s f ab while . 0 \u00b7 s ' (Eval While 1) (where i4 .= 0) s '' s ''' \ns f a . i4 \u00b7 s ' s ' f b . v \u00b7 s '' f ab while . u \u00b7 s ''' s f ab while . u \u00b7 The expression ldc.i4 i4 \nevaluates to the integer i4 . The expression ab evaluates a, returning void (that is, nothing). The result \nof the whole expression is then the result of evaluating b. The expression ab0 b1 cond evaluates a to \nan integer i4 . The result of the whole conditional is then the result of evaluating b0 if i4 = 0, and \nevaluating b1 otherwise. The expression ab while evaluates a to an integer i4 . If i4 = 0 evaluation \nterminates, returning void. Otherwise, the body b is evaluated, returning void, and then evaluation of \nab while repeats. Evaluation Rules for Pointer Types: (Eval ldind) s f a . ptr \u00b7 s ' s f a ldind . lookup(s \n' , ptr) \u00b7 s ' (Eval stind) s ' s '' s f a . ptr \u00b7 s ' f b . v \u00b7 s f ab stind . 0 \u00b7 update(s '' , ptr,v) \nThe expression aldind evaluates a to a pointer, and then returns the outcome of dereferencing the pointer. \nThe expression ab stind evaluates a to a pointer, stores the result of evaluating b in the (heap or stack) \nlocation addressed by the pointer, and returns void. Evaluation Rules for Arguments: (Eval ldarga) s \n=(h, fr1 \u00b7\u00b7\u00b7 fri) s f ldarga j . (i, j) \u00b7 s (Eval starg) s f a . u \u00b7 s ' s ' =(h ' , fr1 \u00b7\u00b7\u00b7 fri) s f \na starg j . 0 \u00b7 update(s ' , (i, j),u) The expression ldarga j returns a pointer to argument j in the \ncurrent stack frame. The expression a starg i evaluates a, stores the result in argument i in the current \nstack frame, then returns void. Evaluation Rules for Reference Types Only: (Eval newobj) (where K = void \nc::.ctor(A ' 1,...,A ' )) m c/. ValueClass i.1..n .elds(c)= fi . Ai si f ai . vi \u00b7 si+1 .i . 1..n i.1..n] \nsn+1 =(h, s) p/. dom(h) h ' = h, p . c[fi . vi s1 f a1 \u00b7\u00b7\u00b7 an newobj K . p \u00b7 (h ' ,s) (Eval callvirt) \n(where M = Bc::e(A1,...,An)) i.1..m] s0 f a0 . p0 \u00b7 (h1,s1) h1(p0)= c ' [fi . ui (hi,si) f ai . vi \u00b7 \n(hi+1,si+1) .i . 1..n methods(c ' )(Be(A1,...,An)) = b (hn+1,sn+1.args(p0,v1,...,vn)) f b . v ' \u00b7 (h \n' ,s ' fr ' ) s0 f a0 a1 \u00b7\u00b7\u00b7 an callvirt M . v ' \u00b7 (h ' ,s ' ) The expression a1 \u00b7\u00b7\u00b7 an newobj K, where \nK is the con\u00adstructor for a class c/. ValueClass, allocates a boxed object whose .elds contain the results \nof evaluating a1, ..., an, and returns the new reference. The expression a0 a1 \u00b7\u00b7\u00b7 an callvirt M, where \nM refers to Be(A1,...,An) in class c, evaluates a0 to a reference to a boxed object of class c ' (expected \nto inherit from c), locates the method body for Be(A1,...,An) in class c ' , and returns the result of \nevaluating this method body in a new stack frame whose argument vector consists of the reference to the \nboxed object (the self pointer) together with the results of a1, ..., an. The result of this evaluation \nis the store (h ' ,s ' fr ' ), where fr ' is the .nal state of the new stack frame. Once evaluation of \nthe method is complete, the stack is popped, to leave (h ' ,s ' ) as the .nal store. Evaluation Rules \nfor Reference and Value Types: (Eval ldflda) s f a . ptr \u00b7 s ' s f a ldflda Ac::f . ptr.f \u00b7 s ' (Eval \nstfld) s ' s '' s f a . ptr \u00b7 s ' f b . v \u00b7 s f ab stfld Ac::f . 0 \u00b7 update(s '' , ptr.f, v) The expression \na ldflda Ac::f evaluates a to a pointer to a boxed or unboxed object, then returns a pointer to .eld \nf of this object. The expression ab stfld Ac::f evaluates a to a pointer to a boxed or unboxed object, \nupdates its .eld f with the result of evaluating b, and returns void. Evaluation Rules for Value Types \nOnly: (Eval newobj) (where K = void vc::.ctor(A ' 1,...,A ' )) mi.1..n .elds(vc)= fi . Ai si f ai . vi \n\u00b7 si+1 .i . 1..n i.1..n) \u00b7 s1 f a1 \u00b7\u00b7\u00b7 an newobj K . (fi . vi sn+1 (Eval call) (where M = B vc::e(A1,...,An)) \ns0 f a0 . ptr \u00b7 (h1,s1) (hi,si) f ai . vi \u00b7 (hi+1,si+1) .i . 1..n methods(vc)(Be(A1,...,An)) = b ' (h \n'' ) (hn+1,sn+1.args(ptr,v1,...,vn)) f b . v \u00b7 ,s ' fr s0 f a0 a1 \u00b7\u00b7\u00b7 an call instance M . v ' \u00b7 (h ' \n,s ' ) (Eval box) (where p/. dom(h ' )) i.1..n s f a . ptr \u00b7 (h ' ,s ' ) lookup((h ' ,s ' ), ptr)= fi \n. vi s f a box vc . p \u00b7 ((h ' ,p . vc[fi . vii.1..n]),s) (Eval unbox) s f a . p \u00b7 s ' s f a unbox vc \n. p \u00b7 s ' The expression a1 \u00b7\u00b7\u00b7 an newobj K, where K is the con\u00adstructor for a value class vc, returns \nan unboxed object whose .elds contain the results of evaluating a1, ..., an. The expression a0 a1 \u00b7\u00b7\u00b7 \nan call instance M where M refers to Be(A1,...,An) in value class vc, evaluates a0 to a pointer to an \nunboxed object (expected to be of class vc), locates the method body for Be(A1,...,An) in class vc, and \nreturns the result of evaluating this method body in a new stack frame whose argument vector consists \nof the pointer to the unboxed object (the self pointer) together with the results of a1, ..., an. The \nexpression a box c evaluates a to a pointer to an unboxed object, allocates it in boxed form in the heap, \nand returns the fresh heap reference. The expression a unbox c evaluates a to a heap reference to a boxed \nobject, and returns this reference as its result.  2.4 Typing Method Bodies This section describes a \ntype system for method bodies such that evaluation of well-typed method bodies cannot lead to an execution \nerror. What is perhaps most interesting here is the implementation of the Pointer Con.nement Policy of \nSection 2.1. Let a type frame, Fr, take the form .args(A0,...,An), a description of the types of the \nresults in the current (top) stack frame. Our typing judgment, Fr f b : B, means if the current stack \nframe matches Fr, the body b evaluates to a result of type B. Type Frames and Typing Judgment: Fr ::= \n.args(A0,...,An) frame: types of arguments Fr f b : B given Fr, body b returns type B We make the additional \nassumption about our execution environment that every method body (b below) conforms to its signature: \nAdditional Assumptions: c /. ValueClass . methods(c)(B e(A1, . . . , An)) = b . .args(class c, A1, . \n. . , An) f b : B vc . ValueClass . methods(vc)(B e(A1, . . . , An)) = b . (Ref methods) (Val methods) \n .args(value class vc&#38;,A1,...,An) f b : B Next, we give typing rules to de.ne Fr f b : B. Typing \nRule for Subsumption: (Body Subsum) Fr f b : B B<: B ' Fr f b : B ' This standard rule allows an expression \nof a subtype B to be used in a context expecting a supertype B ' . Typing Rules for Control Flow: (Body \nldc) (Body Seq) Fr f a : void Fr f b : B Fr f ldc.i4 i4 : int32 Fr f ab : B (Body Cond) Fr f a : int32 \nFr f b0 : B Fr f b1 : B Fr f ab0 b1 cond : B (Body While) Fr f a : int32 Fr f b : void Fr f ab while \n: void The rule (Body Seq) uses the type void to guarantee that the .rst part of a sequential composition \nreturns no results. The rules (Body Cond) and (Body While) use the type int32 to guarantee the predicate \nexpression a returns an integer. Typing Rules for Pointer Types: (Body ldind) (Body stind) (where pointerFree(A)) \nFr f a : A&#38; Fr f a1 : A&#38; Fr f a2 : A Fr f a ldind : A Fr f a1 a2 stind : void The rule (Body \nstind) implements rule (3) of the Pointer Con.nement Policy; without the condition pointerFree(A), stind \ncould copy a pointer to the current stack frame further back the stack. Typing Rules for Arguments: (Body \nldarga) j . 0..n .args(A0,...,An) f ldarga j : Aj&#38; (Body starg) .args(A0,...,An) f a : Aj j . 0..n \n.args(A0,...,An) f a starg j : void These rules check that the argument index j exists. Since starg only \nwrites within the current frame, we can safely allow Aj to be a pointer. Typing Rules for Reference Types: \n(Ref newobj) (where K = void c::.ctor(A1,...,An) i.1..n) and .elds(c)= fi . Ai Fr f ai : Ai .i . 1..n \nc/. ValueClass Fr f a1 \u00b7\u00b7\u00b7 an newobj K : class c (Ref callvirt) (where Be(A1,...,An) . dom(methods(c))) \nFr f a0 : class c Fr f ai : Ai .i . 1..n Fr f a0 a1 \u00b7\u00b7\u00b7 an callvirt Bc::e(A1,...,An): B i.1..n) (Ref \nldflda) (where .elds(c)= fi . Ai Fr f a : class cj . 1..n Fr f a ldflda Aj c::fj : Aj&#38; i.1..n (Ref \nstfld) (where .elds(c)= fi . Ai and pointerFree(Aj)) Fr f a : class c Fr f b : Aj j . 1..n Fr f ab stfld \nAj c::fj : void These are fairly standard rules for operations on boxed objects. Recall that the axiom \n(Good .elds) guarantees ev\u00adery .eld is pointer-free. So the pointerFree(-) condition on the rule (Ref \nstfld) is redundant. Still, it is not redundant in a variation of our type system considered in Section \n3, that allows value classes to include pointers. Typing Rules for Value Types: (Val newobj) (where K \n= void vc::.ctor(A1,...,An) i.1..n) and .elds(vc)= fi . Ai Fr f ai : Ai .i . 1..n Fr f a1 \u00b7\u00b7\u00b7 an newobj \nK : value class vc (Val call) (where Be(A1,...,An) . dom(methods(vc))) Fr f a0 : value class vc&#38; \nFr f ai : Ai .i . 1..n Fr f a0 a1 \u00b7\u00b7\u00b7 an call instance B vc::e(A1,...,An): B i.1..n) (Val ldflda) (where \n.elds(vc)= fi . Ai Fr f a : value class vc&#38; j . 1..n Fr f a ldflda Aj vc::fj : Aj&#38; i.1..n (Val \nstfld) (where .elds(vc)= fi . Ai and pointerFree(Aj)) Fr f a : value class vc&#38; Fr f b : Aj j . 1..n \nFr f ab stfld Aj vc::fj : void (Val box) (where pointerFree(value class vc)) Fr f a : value class vc&#38; \nFr f a box vc : class vc (Val unbox) Fr f a : class vc Fr f a unbox vc : value class vc&#38; These are \nsimilar to the typing rules for operations on boxed objects, except we refer to the object via a pointer \ntype instead of a reference type. Like (Ref stfld), the rules (Val stfld) and (Val box) bear pointerFree(-) \nconditions that are redundant in the current system, but not in the system of Section 3.  2.5 Typing \nthe Memory Model In this section, we present predicates, known as conformance judgments, that confer \ntypes on our memory model. In the next, we show that these predicates are invariants of com\u00adputation, \nthat is, are preserved by method evaluation. We begin by introducing types for the components of our \ni.1..n memory model. A heap type pi . ci determines the actual class of each boxed object. A stack type \nFr1 \u00b7\u00b7\u00b7 Frn determines frame types for each frame in the stack. A store type S=(H, S) determines a heap \ntype H and stack type S. Heap, Stack, and Store Types: H ::= pi . ci i.1..n S ::= Fr1 \u00b7 \u00b7 \u00b7 Frn S ::= \n(H, S) heap type stack type store type Our .rst conformance judgment, S |= u : A, means that in a store \nmatching the store type S, the result u is well\u00adformed and has type A. We de.ne what it means for a store \nto match a store type through other conformance judgments, de.ned later. Conformance Judgment for Results \n(Including Pointers): S |= u : A in S, result u has type A Conformance Rules for References and Pointers: \n(Res Ref) (Ptr Ref) H(p)= cc inherits c ' H(p)= vc (H, S) |= p : class c ' (H, S) |= p : value class \nvc&#38; (Ptr Arg) i . 1..m Fri = .args(A0,...,An) j . 0..n (H, Fr1 \u00b7\u00b7\u00b7 Frm) |=(i, j): Aj&#38; (Ptr Field) \n(where A = class c or A = value class c&#38;) i.1..n S |= ptr : A .elds(c)= fi . Ai j . 1..n S |= ptr.fj \n: Aj&#38; The rule (Res Ref) assigns a reference type class c ' to a heap reference p, so long as c \n' is a superclass of the actual class of the object referred to by p. The rule (Ptr Ref) assigns a pointer \ntype to a heap ref\u00aderence p that refers to a value that is boxed on the heap. These two rules can assign \nboth a reference type and a pointer type to a heap reference to a value class. If H(p)= vc, then we have \n(H, S) |= p : class c by (Res Ref), but also (H, S) |= p : value class c&#38; by (Ptr Ref). We need (Res \nRef) to type references constructed by the box instruction. We need (Ptr Ref) to type pointers constructed \nby the unbox instruction. The rule (Ptr Arg) assigns a pointer type to a stack pointer (i, j) that refers \nto argument j of frame i. The rule (Ptr Field) assigns a pointer type to a pointer referring to the .eld \nfj of the object referred to by ptr. The base pointer ptr may either be of type class c or value class \nc&#38;. The .rst case is needed for a pointer to a .eld of a heap object that is not in a value class. \nThe second case is needed for a pointer to a .eld of a heap or stack object in a value class. Conformance \nRules for Other Results: (Res Void) (Res Int) S |= 0 : void S |= i4 : int32 (Res Value) i.1..n .elds(vc)= \nfi . Ai (H, S) |= vi : Ai .i . 1..n i.1..n (H, S) |= fi . vi : value class vc The rules (Res Void) and \n(Res Int) assign the void and int32 types to void and integer values, respectively. The rule (Res Value) \nassigns a value type value class vc to a value. By axiom (Hi Val), the inheritance hierarchy is .at for \nvalue types. So (Res Value), unlike (Res Ref), does not allow vc to be a proper superclass of the actual \nclass of the value. Other Conformance Judgments: H |= o : c in H, object o has class c H |= h heap h \nconforms to H S |= fr : Fr frame fr conforms to Fr S |= s store s conforms to S Conformance Rule for \nObjects: i.1..n) (Con Object) (where .elds(c)= fi . Ai (H, 0) |= vi : Ai .i . 1..n H |= c[fi . vii.1..n]: \nc This rule de.nes when a heap object c[fi . vii.1..n] is well-typed. The preconditions (H, 0) f vi : \nAi require that the .elds vi be typed with an empty stack type. It follows that no .eld vi contains a \nstack pointer, since the rule (Ptr Arg) for typing stack pointers assumes a non-empty stack type. Conformance \nRule for Heaps: i.1..n) (Con Heap) (where H = pi . ci H |= oi : ci .i . 1..n i.1..n H |= pi . oi This \nrule de.nes when a heap pi . oii.1..n conforms to i.1..nthe heap type pi . ci . The heap type contains \nthe actual class ci of each object oi. Conformance Rule for Frames: (Con Frame) S |= ui : Ai .i . 0..n \nS |= .args(u0,...,un): .args(A0,...,An) This rule de.nes when a frame conforms to a frame type. Conformance \nRule for Stores: (Con Store) H |= h (H, Fr1 \u00b7\u00b7\u00b7 Fri) |= fri : Fri .i . 1..n (H, Fr1 \u00b7\u00b7\u00b7 Frn) |=(h, fr1 \n\u00b7\u00b7\u00b7 fr) n This rule de.nes when a store (H, Fr1 \u00b7\u00b7\u00b7 Frn) conforms to a store type (h, fr1 \u00b7\u00b7\u00b7 frn). It \nasks that the heap h con\u00adform to the heap type H, and that each stack frame fri conform to the corresponding \nframe type Fri, but after re\u00admoving from the store type any higher shorter lived stack frames. Hence, \nthere may be pointers from a higher to a lower stack frame, but not the other way round.  2.6 Evaluation \nRespects Typing We use standard proof techniques to show the consistency of the BIL evaluation semantics \nwith its type system. The following is the main type safety result of the paper. If a program satis.es \nthe restrictions on type structure im\u00adposed in Section 2.1 and the typing rules for method bod\u00adies in \nSection 2.4 then its evaluation according to the rules in Section 2.3 can lead only to conformant intermediate \nstates as de.ned in Section 2.5. Let H = H ' mean that dom(H) . dom(H ' ) and H(p)= H ' (p) for all p \n. dom(H). Theorem 1 If (H, S Fr) |= s and Fr f b : B and s f b r v \u00b7 s then there exists a heap type \nH such that H = H and (H ,S Fr) |= v : B and (H ,S Fr) |= s . Proof By induction on the derivation of \ns f b r v \u00b7 s . We omit the details. See the Appendix for the main lemmas about the type system needed \nin the proof. As usual, such a theorem is vacuous if there is no s such that s f b r v \u00b7 s holds, which \nhappens either because the computation would diverge, or because it gets stuck (if there is no applicable \nevaluation rule). Stuck states correspond to execution errors, such as calling a non-existent method, \nor attempting to de-reference an integer or a dangling pointer. As discussed by Abadi and Cardelli [AC96], \nwe conjecture it would be straightforward to adapt the proof of Theorem 1 to show that no stuck state \nis reachable. 3 Variation: Allowing Pointers in Fields of Value Classes To avoid dangling pointers, the \nIL type system prevents the .elds of all objects, whether boxed on the heap or unboxed on the stack, \nfrom holding pointers. In fact, as pointed out by Fergus Henderson, a more liberal type system that allows \nunboxed objects to contain pointers is useful for compiling nested functions. When compiling a language \nwith nested functions (for example, Pascal or Ada), each invocation of a nested func\u00adtion needs access \nto the activation records (that is, the ar\u00adguments and local variables) of the lexically enclosing func\u00adtions. \nA standard technique is to pass the function a display [ASU86], an array of pointers to these activation \nrecords. One strategy is to implement an activation record (contain\u00ading those arguments and local variables \nreferred to by nested functions) as a value class on the stack, and to implement the display by pointers \nto the value classes representing the activation records. Since arguments may be passed by ref\u00aderence, \nthis scheme works only if we allow value classes to hold pointers. Otherwise, we need to pay the cost \nof boxing these activation records on the heap. If we allow .elds of value classes to hold pointers, \nthe following more liberal policy still avoids dangling pointers. A More Liberal Pointer Con.nement Policy: \n(1) No .eld of a boxed object may hold a pointer. (2) No method may return a result containing a pointer. \n (3) No result containing a pointer may be stored indirectly via another pointer.  Though this policy \nhelps compile nested functions, we lose the possibly useful fact that every value class may be boxed, \nand hence treated as a subtype of class System.Object. To formalize this policy, we amend BIL as follows. \n Change the de.nition of pointerFree(A) to hold if and only if (1) A is not itself a pointer type, and \n(2) if A is a value class then the type B of each .eld satis.es pointerFree(B). (The only change is the \ninsertion of clause (2).)  Change axiom (Good .elds) to read: c/. ValueClass . pointerFree(.elds(c)(f)). \n(The only change is the in\u00adsertion of the c/. ValueClass precondition.)  To see the e.ect of these \nchanges, recall there are four typing rules that mention the pointerFree(-) predicate: (Ref stfld), (Body \nstind), (Val stfld), and (Val box). Previously, any value could be stored via (Body stind), and the pointer-free \nconditions on the other three rules were redundant. Now, these rules prevent the export of values containing \npointers to the heap or further back the stack. Now, (Ref stfld) prevents a pointer being stored into \na boxed value class with a pointer .eld. In fact, no such boxed value classes can even be allocated, \ngiven the pointerFree(-) condition on (Val box). Our proof of Theorem 1, outlined in the Appendix, is \nin fact for this more liberal system. Type safety for the original system is a corollary of type safety \nfor this more liberal system, since any method body typed by the original system remains typable. Implementation \nof the new scheme remains future work. 4 IL Features Omitted From BIL To give a .avour of the full intermediate \nlanguage, we brie.y enumerate the main features omitted from BIL. The IL As\u00adsembly Programmer s Reference \nManual [Mic00] contains a complete informal description of IL. We omit all discussion of IL metadata, \nsuch as how classes, static data and method headers are described. We omit any discussion of the on-disk \nformat, the speci.cation of linkage information, and assemblies, the unit of software deployment. Our \nobject model omits null objects, global .elds and methods, static .elds and methods, non-virtual methods, \nsingle dimensional and multi-dimensional covariant arrays, and object interfaces. Our instruction set \nomits local vari\u00adables, arithmetic instructions, arbitrary branching, jumping, and tail calls. Tail calls \nrequire care, because the type sys\u00adtem must prevent pointers to the current stack frame being passed \nas arguments. The current IL policy is to prevent the passing of any pointers via a tail call. We omit \ndelegates (that is, built-in support for anony\u00admous method invocation), typed references (that is, a \npointer packaged with its type, required for Visual Basic), attributes, native code calling conventions, \ninteroperabil\u00adity with COM, remoting (object distribution) and multi\u00adthreading. We also omit exception \nhandling, a fairly elab\u00adorate model that permits a uni.ed view of exceptions in C++, C#, and other high-level \nlanguages. 5 Related Work The principle of formalizing type-checking via logical in\u00adference rules is \na long-standing topic in the study of progamming languages [Car97]. Formal typing rules have been developed \nfor several high-level languages, includ\u00ading SML [MTHM97], Haskell [PW92], and for subsets of Java [DE97, \nIPW99]. Formal typing rules have also been developed for several low-level languages, including TAL [MWCG99] \nand for subsets of the JVM [SA98, Qia99, Yel99, FM00]. The properties established by proof-carrying code \n[Nec97] can be viewed as typing derivations for na\u00adtive code. The idea of formalizing a type system via \nan executable type-checker has recently been advocated for Haskell [Jon99]. Our use of an executable \nspeci.cation as an oracle is an instance of the standard software en\u00adgineering principle of multi-version \nprototyping. Proofs of soundness of several programming language type sys\u00adtems have been partially mechanised \nin theorem provers [Van96, Nor98, Sym99, vN99]. Several compilers, such as GHC [PHH+93], TIL [TMC+96], \nFLINT [Sha97], and MARMOT [FKR+00], use a typed intermediate language internally. One [MWCG99] in particular \ntranslates all the way from System F, a polymorphic .-calculus, down to a typed assembly language, TAL. \nThe idea of writing a type-checker for a textual assembly format (like our type-checker for IL) appears \nin connection with TAL: the TALx86 type-checker accepts input in a typed form of the IA32 assembly language \nthat can also be processed by the standard MASM assembler. Reference types for heap-allocated data structures \nakin to the reference types of the type system of Section 2 appear in all of these intermediate languages. \nWhat is new about our type system is its inclusion of value and pointer types. Value types describe \nthe unboxed stack-allocated form of a class. The box and unbox instructions coerce between stack and \nheap forms of a class. Types for boxed and unboxed non-strict data structures [PL91] and automatic type-based \ncoercions between boxed and unboxed forms [Ler92] have been studied previously. Other approaches include \nregion analysis [TT97] and escape analysis [PG92]. Still, the idea and formal\u00adization of types to di.erentiate \nbetween unboxed and boxed forms of class-based objects appears to be new.  Pointer types describe pointers \nto either stack or heap allocated items. A risk with a stack pointer is that it may dangle, if its lifetime \nexceeds the lifetime of its target. The stack-based form of TAL [MCGW98] in\u00adcludes a type constructor \nfor describing pointers into the stack; the parameter to the type constructor is a stack type that ensures \nthe target is still live when the pointer is dereferenced. Instead, the Pointer Con.ne\u00adment Policy of \nSection 2 avoids dangling pointers via various syntactic restrictions. IL s pointer types are easier \nto integrate with high-level languages like Visual Basic with rather simple type systems than a more \nso\u00adphisticated solution using stack types, as found in TAL.  6 Conclusions One of the innovations in \nMicrosoft s Common Language Runtime is support for typed stack pointers, for passing ar\u00adguments and results \nby reference, for example. We presented formal typing rules and a type safety result for a substantial \nfragment of the Common Language Runtime intermediate language. Our treatment of value types and pointer \ntypes appears to be new. These rules were devised through our writing informal and executable speci.cations \nof the full in\u00adtermediate language. This e.ort clari.ed the design and helped .nd bugs, but further research \nis needed on machine support for formal reasoning and on test case generation. We exploited our formal \nmodel to validate a liberalisation of the IL policy that allows object .elds to contain stack pointers. \nAcknowledgements This paper is one outcome of a collab\u00adorative project between Microsoft Research Cambridge \nand the .NET Common Language Runtime product team. We thank the Common Language Runtime team, and especially \nS. Dasan, J. Forbes, J. Miller, and V. Morrison, for their help during our collaboration. We thank our \nresearch interns P. Hankin, J. Matthews, and C. Pitcher for their work on the project. M. Abadi, C.A.R. \nHoare, A. Je.rey, and C. Skalka suggested improvements to a draft of this paper. References [AC96] M. \nAbadi and L. Cardelli. A Theory of Objects. Springer Verlag, 1996. [ASU86] A.V. Aho, R. Sethi, and J.D. \nUllman. Com\u00adpilers: Principles, Techniques, and Tools. Addison-Wesley, 1986. [Car97] L. Cardelli. Type \nsystems. In A.B. Tucker, editor, The Computer Science and Engineering Handbook, chapter 103, pages 2208 \n2236. CRC Press, 1997. [Coh89] A. Cohn. The notion of proof in hardware veri.cation. Journal of Automated \nReasoning, 5(2):127 139, June 1989. [DE97] S. Drossopoulou and S. Eisenbach. Java is type safe probably. \nJune 1997. In Proceedings ECOOP 97, [FKR+00] R. Fitzgerald, T.B. Knoblock, E. Ruf, B. Steensgaard, and \nD. Tarditi. Marmot: An optimizing compiler for Java. Software: Prac\u00adtice and Experience, 30(3), 2000. \n[FM00] S. Freund and J.C. Mitchell. A type system for object initialization in the Java bytecode language. \nACM Transactions on Programming Languages and Systems, 2000. To appear. [GHL99] A.D. Gordon, P.D. Hankin, \nand S.B. Lassen. Compilation and equivalence of imperative ob\u00adjects. Journal of Functional Programming, \n9(4):373 426, 1999. [GS00] A.D. Gordon and D. Syme. Typing a multi\u00adlanguage intermediate code. Technical \nReport MSR TR 2000 106, Microsoft Research, 2000. [HW00] A. Hejlsberg and S. Wiltamuth. Language Reference. \nAvailable at /msdn.microsoft.com/vstudio/nextgen/ technology/csharpintro.asp, 2000. C# http:/ [IPW99] \nA. Igarashi, B. Pierce, and P. Wadler. Feather\u00adweight Java: A minimal core calculus for Java and GJ. \nIn Object Oriented Programming: Sys\u00adtems, Languages, and Applications (OOPSLA), October 1999. [Jon99] \nM.P. Jones. Typing Haskell in Haskell. In Pro\u00adceedings Haskell Workshop, Paris, 1999. Avail\u00adable at http://www.cse.ogi.edu/~mpj/thih. \n[Ler92] X. Leroy. Unboxed objects and polymorphic typing. In 19th ACM SIGPLAN SIGACT Symposium on Principles \nof Programming Lan\u00ad guages, pages 177 188. ACM Press, 1992. [MCGW98] G. Morrisett, K. Crary, N. Glew, \nand D. Walker. Stack-based typed assembly lan\u00adguage. In Workshop on Types in Compilation, volume 1473 \nof Lecture Notes in Computer Sci\u00adence, pages 28 52. Springer Verlag, 1998. [Mic00] Microsoft Corporation. \nMicrosoft IL Assem\u00adbly Programmer s Reference Manual, July 2000. Part of the .NET Framework Software \nDevelop\u00adment Kit, distributed on CD at the Microsoft Professional Developers Conference, Orlando, Florida, \nJuly 11 14, 2000. [MTHM97] R. Milner, M. Tofte, R. Harper, and D. Mac-Queen. The De.nition of Standard \nML (Re\u00advised). MIT Press, 1997. [MWCG99] G. Morrisett, D. Walker, K. Crary, and N. Glew. From System \nF to typed assembly language. ACM Transactions on Programming Languages and Systems, 21(3):528 569, 1999. \n [Nec97] G. Necula. Proof-carrying code. In 24th ACM SIGPLAN SIGACT Symposium on Principles of Programming \nLanguages, pages 106 119. ACM Press, 1997. [Nor98] M. Norrish. C formalised in HOL. PhD thesis, University \nof Cambridge, 1998. [PG92] Y.G. Park and B. Goldberg. Escape analysis on lists. In ACM SIGPLAN Conference \non Programming Language Design and Implemen\u00adtation, pages 116 127. ACM Press, 1992. [PHH+93] S. Peyton \nJones, C. Hall, K. Hammond, W. Partain, and P. Wadler. The Glasgow Haskell compiler: a technical overview. \nIn Pro\u00adceedings UK Joint Framework for Information Technology (JFIT) Technical Conference, pages 249 \n257. 1993. [PL91] S. Peyton Jones and J. Launchbury. Unboxed values as .rst class citizens. In Functional \nPro\u00adgramming Languages and Computer Architec\u00adture, volume 523 of Lecture Notes in Computer Science, pages \n636 666. Springer Verlag, 1991. [PW92] S. Peyton Jones and P. Wadler. A static semantics for Haskell. \nUnpublished draft, Department of Computing Science, University of Glasgow. Available at http:// research.microsoft.com/users/simonpj, \n1992. [Qia99] Z. Qian. A formal speci.cation of JavaTM vir\u00adtual machine instructions for objects, meth\u00adods \nand subroutines. In J. Alves-Foss, editor, Formal Syntax and Semantics of Java, volume 1532 of Lecture \nNotes in Computer Science, pages 271 312. Springer Verlag, 1999. [SA98] R. Stata and M. Abadi. A type \nsystem for Java bytecode subroutines. In Proceedings POPL 98, pages 149 160. ACM Press, 1998. [Sha97] \nZ. Shao. An overview of the FLINT/ML com\u00adpiler. In Proc. 1997 ACM SIGPLAN Work\u00adshop on Types in Compilation \n(TIC 97), Ams\u00adterdam, The Netherlands, June 1997. [Sym98] D. Syme. Declarative Theorem Proving for Op\u00aderational \nSemantics. PhD thesis, University of Cambridge, 1998. [Sym99] D. Syme. Proving Java type soundness. In \nJ. Alves-Foss, editor, Formal Syntax and Se\u00admantics of Java, volume 1532 of Lecture Notes in Computer \nScience, pages 83 119. Springer Verlag, 1999. [TMC+96] D. Tarditi, G. Morrisett, P. Cheng, C. Stone, \nR. Harper, and P. Lee. TIL: A type-directed optimizing compiler for ML. In Proc. PLDI 96, pages 181 192, \n1996. [TT97] M. Tofte and J.-P. Talpin. Region-based mem\u00adory management. Information and Computa\u00adtion, \n132(2):109 176, 1997. [Van96] M. VanInwegen. The Machine-Assisted Proof of Programming Language Properties. \nPhD thesis, Department of Computer and Information Sci\u00adence, University of Pennsylvania, May 1996. [vN99] \nD. von Oheimb and T. Nipkow. Machine\u00adchecking the Java speci.cation: Proving type\u00adsafety. In J. Alves-Foss, \neditor, Formal Syntax and Semantics of Java, volume 1532 of Lec\u00adture Notes in Computer Science, pages \n119 156. Springer Verlag, 1999. [Yel99] P.M. Yelland. A compositional account of the JavaTM Virtual Machine. \nIn 26th ACM SIGPLAN SIGACT Symposium on Principles of Programming Languages, pages 57 69. ACM Press, \n1999. A Facts Needed in the Proof of Theorem 1 This appendix encompasses the main lemmas needed in the \nproof of the main type safety theorem of the paper. Our proofs are for the de.nitions of (Good .elds) \nand pointerFree(-) described in Section 3. The proofs can triv\u00adially be adapted for the original de.nitions \nin Section 2. Appendix A.1 covers basic lemmas about the subtype and conformance relations. Appendix \nA.2 presents an alterna\u00adtive characterisation of the pointer conformance judgement S |= ptr : A&#38;. \nFinally, Appendix A.3 presents the de.ni\u00adtions and typing properties of the store lookup and update functions. \n A.1 Basic Lemmas We begin with two lemmas about the subtype relation. Sub\u00adtyping is trivial for all \ntypes except reference types. Only reference types can be supertypes of other reference types. Lemma \n1 Assume B .class c for all c. If A<: B or = B<: A then A = B. Lemma 2 If class c<: A then there exists \nc ' such that A = class c ' and c inherits c ' . Although a subsumption rule is not part of the de.nition \nof the result conformance relation S |= v : A, it is derivable. Lemma 3 If S |= v : A and A<: A ' then \nS |= v : A ' . The next three lemmas concern how varying the size of the stack a.ects conformance. Lemma \n4 states that a pointer-free result well-formed in a store type (H, S) is also well-formed in the store \ntype (H, 0). This justi.es moving pointer-free results from the current frame to the heap. Lemma 5 states \nthat any result well-formed in a store type (H, S) is also well-formed in the store type (H, S Fr). This \njusti.es passing results from the current frame into the frame of a called method. Lemma 6 states that \na pointer-free result well-formed in a store type (H, S Fr) is also well-formed in the store type (H, \nS). This justi.es returning pointer-free results from a called frame to the previous frame. Lemmas 4 \nand 6 do not apply to pointer results because if the result is a pointer into the top stack frame it \nis not well-formed in a smaller stack. Lemma 4 If (H, S) |= v : A and pointerFree(A) then (H, 0) |= v \n: A. Lemma 5 If (H, S) |= v : A then (H, S Fr) |= v : A. Lemma 6 If (H, S Fr) |= v : A and pointerFree(A) \nthen (H, S) |= v : A. Next, we have two lemmas concerned with method call and return. Lemma 7 says that \na frame is well-formed in the store (H, SFr) if it is well-formed in the store (H, S). This justi.es \npassing an argument frame to a called method. Lemma 8 says that a store (h, s) conforms to the store \ntype (H, S) if the store (h, s fr) conforms to a store type (H, S Fr). This justi.es returning from a \nmethod. The proof of Lemma 8 depends on showing that no pointer in the .nal store (h, s) refers to the \nframe fr. Lemma 7 If (H, S) |= fr : Fr then (H, S Fr) |= fr : Fr. Lemma 8 If (H, S Fr) |=(h, s fr) then \n(H, S) |=(h, s). Recall that we state Theorem 1 in terms of a relation H = H ' de.ned to mean that dom(H) \n. dom(H ' ) and H(p)= H ' (p) for all p . dom(H). We may call this the heap extension relation. Heap \nextension is a partial order. Lemma 9 The relation H = H ' is re.exive and transitive (that is, for all \nH, H ' , and H '' , H = H, and, if H = H ' and H ' = H '' then H = H '' ). The next two lemmas state \nthat heap extension preserves the conformance relations for results and objects. Lemma 10 If (H, S) |= \nv : A and H = H ' then (H ' ,S) |= v : A. Lemma 11 If H |= o : c and H = H ' then H ' |= o : c. The .nal \nlemma of this section justi.es boxing of results. If the heap h and the object o both conform to the \nheap type H, and p is a fresh reference, then the extended heap obtained by allocating o at p is well-formed. \nLemma 12 If H |= h and p/. dom(h) and H |= o : c then H, p . c |= h, p . o. A.2 Another Formulation \nof Pointer Conformance In the next section we present the recursive de.nitions of the lookup and update \nfunctions on pointers. To show properties of these functions, it is convenient to present in this section \na reformulation of the pointer conformance relation S |= ptr : A&#38;. Essentially, we show that every \nwell-formed pointer takes the form of either (1) a pointer to an argument in a frame, followed by a possibly \nempty path of .eld selections, or (2) a reference to a boxed object of a value class, followed by a possibly \nempty path of .eld selections, or (3) a reference to a boxed object (not necessarily of a value class) \nfollowed by a non-empty path of .eld selections. This reformulation begins with a notion of a path, a \npos\u00adsibly empty sequence of .eld names. Path Within an Object: f.::= f1 \u00b7\u00b7\u00b7 fn sequence of .elds (written \n. if n = 0) Next, we de.ne a relation A =f. B to mean that either the sequence f.is empty and A = B, \nor that A is a value class, and selecting the .elds in the series f.in order yields f the type B. This \nis de.ned in terms of A -. B, an auxiliary single step relation. ff Actions of Fields on Types: A -. \nB and A =. B f A -. B if and only if A = value class vc and i.1..n .elds(vc)= fi . Ai and f = fj and \nB = Aj. A =. B if and only if A = B. f1\u00b7\u00b7\u00b7fn f1fn A =. B if and only if A -. \u00b7 \u00b7 \u00b7 -. B (where n> 0). \nGiven these notations, we reformulate pointer confor\u00admance as follows. Lemma 13 The judgment S |= ptr \n: A&#38; holds if and only if either: (1) there exist (i, j), f., and B such that ptr =(i, j).f.and S \n|=(i, j): B&#38; and B =f. A, or (2) there exist p, f, and vc such that ptr = p.f.and S |= p : value \nclass vc&#38; and value class vc =f. A, or (3) there exist p, fj, f., and c such that ptr = p.fj.f.and \n S |= p : class c and Aj =f. A, where .elds(c)= fi . i.1..n Ai and j . 1..n. We use this lemma to prove \nthe typing properties of store lookup and update functions stated in the next section.  A.3 Facts about \nLookup and Update We omitted the de.nitions of functions for store lookup lookup(s, ptr) and store update \nupdate(s, ptr,v ' ) from the main body of the paper. The store lookup function is de.ned in terms of \nan aux\u00adiliary function, result lookup lookup(v, f1 \u00b7\u00b7\u00b7 fn), that given the result v, returns the outcome \nof applying each of the .eld selections f1, ..., fn in turn. Here is the de.nition of this auxiliary \nfunction, followed by a typing lemma. Result Lookup: lookup(v, f1 \u00b7\u00b7\u00b7 fn) . lookup(v, .)= v . lookup(fi \n. uii.1..n,fj f.)= lookup(uj, f.) where j . 1..n Lemma 14 If S |= v : A and A =f. B then S |= lookup(v, \nf.): B. Next, we present the de.nition of store lookup, followed by a typing lemma. Store Lookup via \nPointer: lookup(s, ptr) . i.1..n lookup((h, s), p. f.)= lookup(fi . ui , f.) i.1..n] where h(p)= c[fi \n. ui .. .  lookup((h, s), (i, j).f)= lookup(vj,f) where s = fr1 \u00b7\u00b7\u00b7 fri \u00b7\u00b7\u00b7 frm with i . 1..m, and fri \n= .args(v0,...,vn) with j . 0..n Lemma 15 If S |= s and S |= ptr : A&#38; then S |= lookup(s, ptr): \nA. The store update function is de.ned in terms of an aux\u00adiliary function, result update update(v, f1 \n\u00b7\u00b7\u00b7 fn,v ' ), that given the result v, returns the outcome of updating the .eld indicated by the .eld \nselections f1, ..., fn with the result v ' . Here is the de.nition, together with a typing lemma. Result \nUpdate: update(v, f1 \u00b7\u00b7\u00b7 fn,v ' ) . update(v, ., v ' )= v ' . i.1..n,fj . update(fi . ui f,v ' )= .i.(1..n)-{j}) \n(fj . update(uj,f,v ' ),fi . ui for j . 1..n Lemma 16 If S |= u : A and A =f. B and S |= v : B then \nS |= update(u, . f,v): A. Given the previous auxiliary function, here is the de.ni\u00adtion of store update. \nStore Update via Pointer: update(s, ptr,v ' ) update((h, s), p. .= f,v ' ) . i.1..n . (((h - p),p . c[update(fi \n. ui ,f,v ' )]),s) i.1..n] where h(p)= c[fi . ui ..  update((h, s), (i, j).f, v ' )= (h, fr1 \u00b7\u00b7\u00b7 .args(v0,..., \nupdate(vj,f,v ' ),...,vn) \u00b7\u00b7\u00b7 frm) where s = fr1 \u00b7\u00b7\u00b7 fri \u00b7\u00b7\u00b7 frm with i . 1..m, and fri = .args(v0,...,vn) \nwith j . 0..n Finally, we state two typing lemmas for store update. They are essential facts in the \nproof of type safety for BIL: the proof of Theorem 1 uses Lemma 17 and Lemma 18 to show that evaluations \nof stind and starg, respectively, are type safe. Lemma 17 If S |= s and S |= ptr : A&#38; and S |= v \n: A and pointerFree(A) then S |= update(s, ptr,v). Lemma 18 If S |= s and S |=(i, j): A&#38; and S |= \nv : A and s =(h, fr1 \u00b7\u00b7\u00b7 fri) then S |= update(s, (i, j),v). \n\t\t\t", "proc_id": "360204", "abstract": "The Microsoft .NET Framework is a new computing architecture designed to support a variety of distributed applications and web-based services. .NET software components are typically distributed in an object-oriented intermediate language, Microsoft IL, executed by the Microsoft Common Language Runtime. To allow convenient multi-language working, IL supports a wide variety of high-level language constructs, including class-based objects, inheritance, garbage collection, and a security mechanism based on type safe execution.This paper precisely describes the type system for a substantial fragment of IL that includes several novel features: certain objects may be allocated either on the heap or on the stack; those on the stack may be boxed onto the heap, and those on the heap may be unboxed onto the stack; methods may receive arguments and return results via typed pointers, which can reference both the stack and the heap, including the interiors of objects on the heap. We present a formal semantics for the fragment. Our typing rules determine well-typed IL instruction sequences that can be assembled and executed. Of particular interest are rules to ensure no pointer into the stack outlives its target. Our main theorem asserts type safety, that well-typed programs in our IL fragment do not lead to untrapped execution errors.Our main theorem does not directly apply to the product. Still, the formal system of this paper is an abstraction of informal and executable specifications we wrote for the full product during its development. Our informal specification became the basis of the product team's working specification of type-checking. The process of writing this specification, deploying the executable specification as a test oracle, and applying theorem proving techniques, helped us identify several security critical bugs during development.", "authors": [{"name": "Andrew D. Gordon", "author_profile_id": "81100037731", "affiliation": "Microsoft Research", "person_id": "PP15020291", "email_address": "", "orcid_id": ""}, {"name": "Don Syme", "author_profile_id": "81100612953", "affiliation": "Microsoft Research", "person_id": "P68181", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/360204.360228", "year": "2001", "article_id": "360228", "conference": "POPL", "title": "Typing a multi-language intermediate code", "url": "http://dl.acm.org/citation.cfm?id=360228"}