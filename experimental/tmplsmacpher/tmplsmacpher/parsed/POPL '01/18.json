{"article_publication_date": "01-01-2001", "fulltext": "\n What Packets May Come: Automata for Network Monitoring Karthikeyan Bhargavan Satish Chandra Peter J. \nMcCann University of Pennsylvania Bell Laboratories Bell Laboratories bkarthik@seas.upenn.edu schandra@bell-labs.com \nmccap@bell-labs.com Carl A. Gunter University of Pennsylvania gunter@cis.upenn.edu Abstract We consider \nthe problem of monitoring an interactive de\u00advice, such as an implementation of a network protocol, in \norder to check whether its execution is consistent with its speci.cation. At .rst glance, it appears \nthat a monitor could simply follow the input-output trace of the device and check it against the speci.cation. \nHowever, if the monitor is able to observe inputs and outputs only from a vantage point ex\u00adternal to \nthe device as is typically the case the problem becomes surprisingly di.cult. This is because events \nmay be bu.ered, and even lost, between the monitor and the de\u00advice, in which case, even for a correctly \nrunning device, the trace observed at the monitor could be inconsistent with the speci.cation. In this \npaper, we formulate the problem of external monitor\u00ading as a language recognition problem. Given a speci.cation \nthat accepts a certain language of input-output sequences, we de.ne another language that corresponds \nto input-output sequences observable externally. We also give an algorithm to check membership of a string \nin the derived language. It turns out that without any assumptions on the speci.ca\u00adtion, this algorithm \nmay take unbounded time and space. To address this problem, we de.ne a series of properties of device \nspeci.cations or protocols that can be exploited to construct e.cient language recognizers at the monitor. \nWe characterize these properties and provide complexity bounds for monitoring in each case. To illustrate \nour methodology, we describe properties of the Internet Transmission Control Protocol (TCP), and identify \nfeatures of the protocol that make it challenging to monitor e.ciently. Introduction Computer networking \nprotocols have always been appealing candidates for applications of automata theory. Not only are protocols \ncommonly speci.ed as .nite-state automata, much of the current technology of implementing and ver\u00adifying \nprotocols relies on application of automata theory. Examples include Spin/Promela [5], Verisoft [4], \nEsterel [1], etc. We consider the problem of monitoring the execution of net\u00adwork protocols. Suppose \na given piece of computer equip\u00adment claims to implement a certain network protocol through one of its \ncommunication interfaces. We seek to introduce a passive monitor outside this interface that can watch \nall the bits traveling to and from the device under test, and check them for some properties. Such a \nmonitor could give impor\u00adtant information about the proper running of the protocol. Monitoring is complementary \nboth to the implementation and to the veri.cation of network protocols. A passive monitor would essentially \nmimic the actions that the device is expected to take in response to the input that it receives, except \nit would not actually put any output on the wire. Rather, it would pick up the output generated by the \ndevice under test, and compare the output that it computed against the output it sni.ed from the wire. \nIn this role, a passive monitor is a language recognizer, where the language that it understands is the \ninput-output behavior of a given networking protocol. Passive monitors can observe many useful properties \nof real\u00adworld protocols. We give examples of such properties for the Internet protocol TCP in Section \n6. Such a capability can play a useful role in testing new implementations, and also in guarding against \nnetwork intrusion and other security violations. Several complications hamper our ability to construct \npas\u00adsive monitors accurately and e.ciently in the real world. The most important complication is the \n.delity of observa\u00adtion of tra.c by the monitor. In general, our monitor is not located exactly at the \ndevice, in the sense that it does not synchronously observe input and output actions of the automaton \ninside the device. Therefore, the monitor might fail to observe certain packets that the device sees, \nor might see certain packets that the device fails to see. Also, be\u00adcause of bu.ers at the input and \noutput ports of the device, the monitor might observe a sequence of events in a dif\u00adferent order than \nthe device. Another complication is that of under-speci.cation of protocols. For example, the TCP speci.cation \nallows certain leeway as to how often a receiver must generate an acknowledgment to a data packet. Because \nof these complications, the input-output language that the monitor must recognize could be signi.cantly \ndi.erent from the language that a given device processes, or claims to pro\u00adcess. Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for profit or commercial advantage and that copies bear \nthis notice and the full citation on the first page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior specific permission and/or a fee. POPL '01 1/01 Londo, UK \nCopyright 2001 ACM 1-58113-336-7/01/0001 ... $5.00 In this paper, we give a systematic presentation of \npassive monitoring as a language recognition problem, while incor\u00adporating these real-world complications \nto the extent possi\u00adble. Furthermore, the algorithms we present are suitable for on-line monitoring of \nprotocol execution, that is, we do not collect traces and analyze them separately. Thus, speed of monitoring \nis also an important concern. Most prior work in network monitoring either performs o.-line monitoring \n[11], or deals with real-world problems in ad hoc ways [12]. We believe an automata-theoretic approach \nhelps us achieve ro\u00adbust algorithms and also lets us understand the kind of prop\u00aderties that we can or \ncannot monitor e.ciently. In the general case, we could perform on-line monitoring using an expensive \nbrute-force search algorithm, which is essentially an ine.cient parser for the real world version of \nthe language. In some cases, there is not even any a priori upper bound on the amount of space this process \nmay take. However, for many kinds of properties that we may wish to check, it is possible to create faster \nlanguage recognizers. In this paper, we also give a systematic exploration of the space of properties \nthat lets us construct e.cient monitors. We draw an analogy to the problem on constructing parsers for \nthe syntax of programming languages. In general, a particular syntax could be a context-free grammar. \nHow\u00adever, parsers for general context-free grammars are expen\u00adsive: they may take O(n 3) time in the \nsize of the input. Thus, most real syntax speci.cations require restrictions on the grammar, such as \nthe language should be LL(k), LALR(1), etc. For grammars that obey such restrictions, fast parsers can \nbe constructed. We have de.ned an anal\u00adogous range of languages for monitoring. If the language of the \nprotocol obeys certain properties, e.cient monitor\u00ading programs can be created. These language characteris\u00adtics \ncould be used during the speci.cation process, to select properties that can be easily monitored at run-time, \nor even during the protocol design phase, if the designer is especially concerned that a protocol be \namenable to e.cient monitor\u00ading as might be the case with critical security protocols. The contributions \nof our work are the following: We de.ne automata suitable for network monitoring, taking into account \nreal-world complications such as bu.ering and packet loss.  We classify properties of network protocols \nthat let us construct e.cient monitors, and also point out cases in which monitoring would necessarily \nbe an intractable problem.  For an important real-world protocol, TCP, we identify properties that can \nbe e.ciently monitored based on the theory that we develop.  The rest of the paper is organized as follows: \nin Section 2, we give a description of the kinds of mismatches that can be ex\u00adpected between a trace \ncollected by a monitor and the trace actually seen by a device under test. In Section 3 we char\u00adacterize \nthese di.erences formally, and in Section 4, we give a brute-force approach to checking whether a given \ntrace collected at a monitor could have resulted from a correct execution. We proceed in Section 5 to \ngive special proper\u00adties of speci.cations that, when satis.ed, allow us to con\u00adstruct more e.cient on-line \nproperty monitors. In Section 6 we show how our techniques could be applied to monitor\u00ading real properties \nof TCP. Finally in Section 7 we discuss connections to related work and conclude. 2 Fidelity in Network \nMonitoring In the context of monitoring, the term .delity refers to the closeness with which the sequence \nof input and output events seen by the device under test matches the sequence of events observed by the \nmonitor. The extent of in.delity is deter\u00admined by the performance of the monitor and its placement in \nthe network. A perfect .delity monitor, one that sees ex\u00adactly the inputs and outputs of the device under \ntest, can be obtained by instrumenting the protocol stack on the device itself. Such a monitor is depicted \nas M1 in Figure 1. Such a co-located monitor observes input and output actions of the device synchronously \nwith the device it encounters no .delity problems. Such monitors are hard to deploy because of the need \nto put new software on the monitored system. An alternative is to place the monitor somewhere in the \nnetwork and observe inputs and outputs as they pass across the network links. While there are many possible \npoints at which a monitor could be placed (see Figure 1), a co\u00adnetworked monitor and a bottleneck monitor \nare particularly useful, as they are able to observe all tra.c between the device and the remote host. \nA co-networked monitor sits outside the device on the physical network to which its net\u00adwork interface \ncard (NIC) is attached, whereas a bottleneck monitor sits outside the NIC of the gateway of a local area \nnetwork. Of the two, a co-networked monitor can enjoy bet\u00adter .delity, as there is no network element \nbetween it and the device. We have conducted initial experiments to determine the ex\u00adtent and nature \nof in.delities for co-networked monitors. Our experiment consisted of taking a PC (400 MHz Pen\u00adtium II) \nrunning Linux and using it to monitor input to another similar Linux PC over 100 Mbps Ethernet. The monitor \naccepted tra.c o. an Ethernet hub that we intro\u00adduced between the device and the rest of the network. \nOur experiments show that with proper operating system engi\u00adneering, a co-networked monitor could easily \nkeep up with inter-packet arrival time of about 20 microseconds, assum\u00ading no expensive computation is \nperformed per packet. At these speeds, it is feasible to monitor typical TCP/IP pro\u00adtocol tra.c over \n100 Mbps Ethernet, without the monitor dropping any packets. Moreover, this is achieved using only stock \nhardware (desktop PC s and an Ethernet hub1); extra hardware support could handle heavier loads. Consequently, \nwe can assume the existence of a co-networked monitor that does not drop packets for this kind of host \nand network. The primary .delity challenges arise in dealing with bu.er\u00ading on the device itself. If \na protocol S is being run by the device, then the goal of the monitor M is to determine if S is properly \nimplemented. However, this must be done by observing behavior on the network, and there are input and \noutput bu.ers between the device and the network. The sit\u00aduation is depicted in Figure 2. The input and \noutput bu.ers may over-.ll and cause packet losses between the device and the network, thus introducing \nin.delities between the events observed at the device, and the co-networked mon\u00aditor M. Note that the \nover-.ll may be caused by packets from some other protocol that the device is engaged in; the monitor \nmay never even look at these packets. Our experi\u00adments showed that under heavy network loads this kind \nof in.delity was quite possible for input bu.ers. However, the 1In this sense it is not exactly co-networked \nas de.ned above, but we assume this hub repeats all tra.c to all ports. A truly co\u00adnetworked monitor \nwould need special hardware support.  Figure 1: Monitor Placement: Monitor M1 is co-located with the \ndevice under test (DUT); it is unfeasible to deploy without modifying DUT software. Monitor M2 is co-networked \nand monitor M4 is at a bottleneck location. Monitor M3 will not observe tra.c passing through network \nelement A. M5 is located at an Internet service provider (ISP), and M6 is located in another service \nprovider s network. Because the Internet Protocol may drop, duplicate, or re-order datagrams, M5 and \nM6 can experience signi.cant in.delities. Figure 2: Bu.ers in the DUT. M may observe inputs and outputs \nin a di.erent order than S. The second .gure shows one possible execution sequence at the DUT. kernel \nwill ordinarily throttle the protocol implementation to avoid loss in output bu.ers so we will assume \nin this paper that outputs are not lost at a device s output bu.er. Aside from input bu.er loss, the \nmajor in.delity between the device and a co-networked monitor M arises from di.erent perceptions of packet \narrival and dispatch caused by the input and output bu.ering. We describe this phenomena in some detail \nin the next section. To see the issue brie.y, note that it is impossible for M to tell in Figure 2 whether \noutput d of S was created by the device before or after the device observed a or b, or even whether b \nwas dropped before it reached S. 3 Model We assume that the device under test is a deterministic and \nreactive automaton, following a speci.cation S. At each step, either it consumes an input, or produces \nan output. Outputs may be produced in reaction to inputs, or in reac\u00adtion to events such as timer expirations, \nthat are not visible to the outside. Our model of S is similar to a determin\u00adistic I/O Automaton [9]; \nit is a machine with a (possibly in.nite) state space carrying out parameterized input and output actions. \nLet us denote input of a symbol a by the token ia and output of a symbol a by the token oa. S recognizes \ncertain .nite sequences of tokens, for example, ia ib od. Call the set of such .nite sequences LS . We \nintroduce a co-networked monitor M(S, m, n) with input and output bu.ers between it and the device under \ntest. The system now contains three components: S; I, which is an in\u00adput bu.er of size m; and O, which \nis an output bu.er of size n. For convenience, we will normally abbreviate M(S, m, n) to M. We introduce \nfour new tokens. iqa corresponds to enqueing of an input symbol a in queue I. ida corresponds to deletion \nof a from head of I and simultaneous input into device. oda corresponds to output of a from device and \nsimultaneous enqueuing into O. Finally, oqa corresponds to output of a from the head of queue O. Note \nthat M gets to see only tokens iq and oq. We also assume that observation of iqa at the monitor is simultaneous \nwith enqueing of a into I, and observation of oqa at the monitor is simultaneous with the dequeing of \na from O. An execution of this system can be represented by a se\u00adquence of such tokens. Consider the \nsequence iqa iqb iqc ida idb odd iqe oqd This sequence represents the following events: a, b, and c got \nenqueued in the input queue I; the device input a from the head of the queue; the device input b from \nthe head of the queue and then produced output d, which went on the output queue O; another symbol e \ncame into I; and, .nally, d left O. The monitor sees the sequence iqiqb iqiqoqd a ce and we will de.ne \nthe language recognized by the moni\u00adtor in terms such sequences. We .rst introduce a notion of admissible \nexecution sequences under the bu.ering restric\u00adtions. We are interested in the admissible executions \nthat are allowed by S. De.nition 1 (Admissibility) ., a string of iq, oq, id and od tokens, is said to \nbe an admissible execution sequence with respect to M(S, m, n), if the following are true: FIFO Input: \nthe sequence of id tokens in . is the same as the sequence of iq tokens, FIFO Output: the sequence of \noq tokens in . is the same as the sequence of od tokens, Causality: the k th id token can only occur \nafter the k th iq token, and the k th oq token can only occur after the k th od token, Input Bu.er Limit: \nin any pre.x of ., the number of iq tokens minus the number of id tokens must not exceed m, and Output \nBu.er Limit: in any pre.x of ., the number of od tokens minus the number of oq tokens must not ex\u00ad ceed \nn. Now we have a way of de.ning the language recognized by M. Essentially, a string t belongs to LM , \nif there is some ad\u00admissible sequence . whose iq/oq projection is t, and whose id/od projection belongs \nto LS . For each string s in LS , we can construct several t that must be in LM . Let us .rst construct \nan admissible sequence whose id/od projection is s. We take each input token ia in s and split it into \ntwo consecutive tokens iqa and ida. We split each output token into two consecutive tokens oda and oq. \nClearly, this is oaa an admissible sequence (no bu.ering is carried out). But we could also generate \nother sequences of tokens corresponding to this execution. We can move each iq token backwards, skipping \nover any number of tokens, as long as we do not violate relative orders of iq events, and we do not violate \ninput bu.ering limits. Likewise, we can move each oq token forward, as long as we do not violate relative \norders of oq events, and we do not violate output bu.ering limits. Every such sequence . yields a string \nt in the language recognized by M (LM ), simply by erasing out the id and od tokens. Example. Consider \nthe following string in S: ia ib oc id oe if ig We can arrive at the following admissible sequence (labeled \nA). We shall normally ignore particular symbols a, b, etc., and instead label the various tokens by order \nof their ap\u00adpearance in the string, using the notation idk for the k th occurrence of id. 1122 1 133 \n2 24455 A : iqidiqidodoq iqidodoq iqidiqid Now, let us allow an input bu.er of three elements and an \noutput bu.er of two elements. Here are some additional admissible strings: 1212 1 133 2 24455 B : iqiqididodoq \niqidodoq iqidiqid 12312 1 13 2 24455 C : iqiqiqididodoq idodoq iqidiqid 12312 13 2 1 24455 D : iqiqiqididodidodoq \noq iqidiqid 12312 1453 2 1 245 E : iqiqiqididodiqiqidodoq oq idid The following string is not admissible \nbecause the input queue cannot accommodate iq4. 123412 153 2 1 245 F : iqiqiqiqididodiqidodoq oq idid \nFor each admissible string given above (A-E), we can arrive at a string in LM by erasing the id and od \ntokens, as shown below. Not each admissible string gives a unique string in LM . Also, some non-admissible \nexecution sequences can yield the same string in LM , as an admissible sequence (e.g. E and F ). 12 13 \n245 A, B : iqiqoq iqoq iqiq 123 1 245 C, D : iqiqiqoq oq iqiq 12345 1 2 E,F : iqiqiqiqiqoq oq 3.1 Eliminating \nOutput Bu.ering In this section, we give a construction that lets us assume that the monitor M does not \nneed to consider an output bu.er, by suitably adjusting the size of the input bu.er. This simpli.cation \nis useful in reasoning about properties of protocols that permit e.cient monitoring. Theorem 1 LM(S,m,n) \n. LM(S,m+cU *n,0), where cU is a constant dependent on S: cU is the maximum number of input symbols without \nan intervening output symbol in any string in LS. We claim that a monitor similar to M, but that has \nan associated input bu.er of size m + cU * n and no output bu.er, can admit all the observable behaviors \nof M. That is, if a sequence of tokens t observed by M can be derived constructively for M using the \nprocedure described in the previous section from a string s . LS, then t can also be derived constructively \nfor this new monitor from the same s. We denote this new monitor M(S, m + cU * n, 0) by M'. In the monitoring \nprocess, we will make use of a consequence of this theorem that t ./LM, . t ./LM . By construction of \nLM , t ./LM implies that the device is not following S. Thus, by inferring t ./LM, , M ' can infer that \na cer\u00adtain input-output sequence it or M observes is de.nitely inconsistent with S. Sketch of Proof. \nThe theorem does not trivially hold, be\u00adcause a string in LM may be a result of output bu.ering, whereas \nthere is no output bu.er in M'. First assume that every input to S generates an output (cU = 1). Let \nt . LM . By construction, t is a result of erasing id and od tokens from some admissible execution . \nwith respect to M. . contains a unique execution s in LS . We now show a transformation on . that makes \nit ad\u00admissible with respect to M', while still containing the same s (id/od projection) and the same \nt (iq/oq projection) in it. Then, t . LM, , because we can obtain t from s by .rst constructing the transformed \n., which is admissible with respect to M', and then erasing id and od tokens from it. We perform the \nfollowing transformation on .. We start from the end of ., proceeding backwards. On encountering odk \n, the k th occurrence of od, if odk is not immediately followed by oq k , we move it forward some number \nof steps to make it so. In doing this, we might skip over other iq and oq tokens. Any id tokens in between \nodk and oq k are moved in k order after oq . No od tokens can occur in between because they must have \nalready been moved to their appropriate positions. By skipping over all the intermediate oq tokens, we \nreduce the output bu.ering requirement to zero. For every iq token that some id token skips over, we \nincrease the input bu.ering requirement by one. We argue that the maximum increase in the input bu.ering \nrequirement is n, the size of the output bu.er O. Consider the largest number of iq tokens between odk \nand oq k . Suppose that at the position after the odk , there are p elements in the input bu.er. There \nis at least one element in the output bu.er (the content of odk ). The .rst m - p iq tokens .ll up the \ninput bu.er. Every iq token after these must be preceded by some id token, which produces an od. Therefore, \nn - 1 such iq tokens will cause the output bu.er to be .lled up. One more id and iq can also appear in \nthat order for whom the output has not yet been produced by the device. No more iq s are allowed before \noq k . After the last such iq, the number of iq tokens minus the number of id tokens can be at most (m \n- p + n)+ p, since we pushed all the intermediate id tokens out. This will be admissible in a monitor \nwith input bu.er size m + n. In general, S need not expect an output for every input; the above transformation \nno longer works. However, suppose it is given that S cannot accept any more than cU inputs before it \nmust see an output. If we supply M ' with an input bu.er of size m + cU *n, the theorem still holds. \nTo see this, we need to modify our previous counting argument, as to how many iq tokens might occur between \nodk and oq k . The .rst m - p iq tokens .ll up the input bu.er. The next cU * n iq s must be preceded \nby cU * n id s, that produce n - 1 od s .lling up the output bu.er. No more iq s are possible. Example. \nLet m = 2 and n = 2. Consider the following ., where cU = 2. This string is admissible with respect to \nM. 3 4 5 612 iq1 iq2 od1 id1 iqid2 iqod2 id3 iqid4 iqoq oq After moving the od tokens, we arrive at the \nfollowing trans\u00adformed .. Note that the relative ordering of id, od tokens must be maintained, otherwise \nwe change the underlying input to S. 123456 iqiqiqiqiqiqod1 oq 1 id1 id2 od2 oq 2 id3 id4 This transformation \nincreases the maximum input bu.ering requirement to 6, which is admissible to M ' , which has an input \nbu.er of size 6 (2 + 2 * 2).  3.2 Dealing with Loss We now introduce into this model the possibility \nof losing a packet between the co-located monitor and the device, i.e., the monitor observes some input \npackets that the device does not. The model is as follows: we assume that the output from the input queue \nI could either be absorbed by a loss unit L, never to be seen again, or goes into the device as before. \nWe use token il to denote the loss event that consumes the head of the input queue. Example. Consider \nthe following sequence: iqa ila iqb iqc idb odd ilc oqd In this sequence, S executes the following string: \nib od Whereas, the monitor observes the following tokens: iqa iqb iqc oqd Inputs a and c are lost in \nthe loss unit. Note that the M to M ' conversion of the previous subsection would need to know about \nthe maximum e.ective number of inputs seen by the monitor before an output appears. This implies that \nwe must impose a limit on the number of il tokens that can appear in a sequence without an id token. \nIf there can be only less than cL il tokens between two id tokens, then M ' needs an input bu.er of size \nm + cL * cU * n to be able to eliminate the size n output bu.er. Corollary 1 If S cannot accept more \nthat cU id tokens without an intervening od token, and there must be less than cL il tokens between two \nid tokens, then, LM(S,m,n) . LM(S,m+cU *cL *n,0) For the remainder of the paper, we assume a monitor \nof the form M ' , appropriately parameterized with the values of m, n, cU and cL. Furthermore, we shall \nuse B to refer to the input bu.ering requirement (m+cU *cL *n). The admissible strings . may now also \ncontain il tokens (in addition to iq, id, od and oq), and their placement will follow conditions mentioned \nhere. We modify the de.nition of admissibility to take il tokens into account: the FIFO input, causality, \nand input bu.er limit clauses are updated appropriately, treating il tokens just like id tokens. In addition, \nwe have an Input Loss Limit condition: in any pre.x of ., the number of consecutive il s without an intervening \nid token is less than cL. Corollary 2 Consider a string admissible to M ' . Ignoring any intervening \nid or il tokens, the maximum number of iq tokens without an intervening od oq pair is bounded by B + \ncU * cL. The corollary holds because cU * cL id and iq pairs can ap\u00adpear in addition to B iq s, without \nincreasing the e.ective bu.ering requirement. (Another id must force an od.) The importance of this corollary \nwill become apparent in the al\u00adgorithms presented in Section 5. 4 Algorithm for Co-networked Monitoring \nIn general, we would like to check that a given device under test is a proper implementation of a speci.cation \nS, given a trace collected from a co-networked passive monitor. That is, given a trace t of iq and oq \nevents observed at a monitor that is separated from the device by a loss unit (L), input (I) and output \nbu.er (O) as speci.ed in Section 3, we would like to determine whether the device is behaving in accordance \nwith S. The device is not incorrect as long as t . LM, : we can exhibit a sequence . which is derived \nfrom t by the addition of id, il, and od events and which is consistent with the following set of conditions: \n. is admissible with respect to M ' , and the projection of . that includes only id and od tokens (denoted \n[.]id,od) is consistent with the speci.cation of S. Assume we have a function g that checks S on a sequence \na of id and od tokens and tells us whether the sequence is in LS ; g could be used directly as a co-located \nmonitor for S. We write the query to g in the form a . g. We assume that g is a safety property: it is \npre.x-closed, and can be checked over .nite traces. Our problem is to construct a function F (g, t ), \nthat given a trace t of iq and oq events collected by a co-networked monitor and a function g, tells \nus whether the trace corresponds to some proper execution with respect to S. A non-deterministic algorithm \nfor F is straight-forward. Given a t, guess a sequence . admissible with respect to M ' , such that [.]iq,oq \n= t. If[.]id,od satis.es g, t is OK. Otherwise, report failure. A naive determinization of the above \nalgorithm is brute\u00adforce search: simply construct all possible . s from t , check\u00ading each admissible \n. against g, until a match is found or all possibilities are exhausted. Additionally, we would like F \nto be computable on-line, meaning that it should make only one pass over the input t . We give such a \nbrute-force breadth-.rst-search algorithm in Figure 3. We call this al\u00adgorithm BF (g, t ). Data Type. \nO is a set of pairs (admissible string, string of input symbols). Initially, O = {(., .)} Event Handlers. \nOn receiving iqx: 1. .(., b) . O: delete (., b) from O; check-add (. :: iqx,b :: iqx) to O.  2. iterate \nuntil no more additions to O: .(., iqy :: b) . O:  check-add (. :: idy,b) to O; check-add (. :: ily,b) \nto O oqx: 1. .(., b) . O: delete (., b) from O; check-add (. :: odx :: oqx,b) to O.  2. iterate until \nno more additions to O: .(., iqy :: b) . O:  check-add (. :: idy,b) to O; check-add (. :: ily,b) to \nO where check-add adds (., b) to O if and only if: |b| <B, and  [.]id,od . g  in any pre.x of ., the \nnumber of consecutive il s without an intervening id token is less than cL.  If O = f after executing \neither event handler, .ag an error. Figure 3: Brute-Force Monitoring Algorithm Theorem 2 BF (g, t) produces \na set O containing all the strings . that satisfy the following: = t. C1 [.]iq,oq C2 [.]id,od . g. C3 \n. is admissible (with respect to M ' ). There are two sources of ine.ciencies in BF (g, t ). First, we \nmight maintain a large number of plausible sequences. Sec\u00adond, we need to examine the suitability of \neach candidate extension of each sequence with respect to the abstract spec\u00adi.cation. If there is no \nadditional information about g, then there is no bound on the amount of computation required at each \nevent. Suppose that Niq input and Noq output events have taken place. Then the amount of work done at \neach event is essentially the size of O at that point. The size of O is exponential in Niq + Noq, even \nin the absence of loss. To see this, notice that the number of placements of matching id tokens relative \nto a sequence of iq tokens is itself exponen\u00adtial in Niq; possibility of loss factors in another Niq \nbinary choices between id and il. Therefore, even in the absence of loss, the computation that needs \nto be performed at each event grows with the number of events that have occurred. For an e.ective online \nprocedure, we must arrive at a more e.cient monitor process that bounds this per-event com\u00adputation. \nWe shall exploit properties of g that allow us to achieve this optimization. 5 Property Based Optimization \nThe algorithm given in Figure 3 exhibits space and time complexity that is exponential in the number \nof inputs and outputs in the trace. Clearly, for a long trace t, the al\u00adgorithm will quickly become intractable. \nHowever, some as\u00adsumptions allow us to prune large sections of the brute-force search. In the following \nsubsections, we examine properties of g, and assumptions on the input-output traces that allow e.ective \nonline monitoring. A notable feature that is common to many (but not all) of the algorithms presented \nin this section is that they sim\u00adply bu.er iq tokens as they appear, and take interesting action only \nwhen oq tokens are observed. This is in contrast to the brute-force algorithm, in which an iteration \nis per\u00adformed after each iq event to consume the pending bu.er in all possible ways. If this iteration \nis not performed, up to B + cU * cL iq tokens must be bu.ered between outputs in the worst case, following \nCorollary 2. However, after an output, the maximum number of bu.ered iq tokens cannot be more than B. \n 5.1 No Loss Each of the following sub-sections describes a class of g s that can be e.ectively monitored \nif we assume there is no loss between the monitor and the device, i.e. cL = 1. This is an assumption \nof the network behavior, which when true, allows us to use very e.cient algorithms for monitoring. 5.1.1 \nP1: Counting Properties A very basic kind of property is a simple constraint on the number of inputs \nthat must be consumed before an output is produced. If g speci.es that every output must consume between \ncmin and cmax inputs without placing any additional constraints on the allowed sequences, then g satis.es: \n .a, \u00df, odx, ody : a . g . (a = . . a ends in some od) . \u00df has only id s :: a\u00df ody . g .. cmin =|\u00df|= \ncmax That is, a string is in g if and only if it is constructed from another string that is also in g, \nwhich is itself empty or ends in an output event, by adding between cmin and cmax input events. An algorithm \nfor checking such g s in the presence of bu.ers is shown in Figure 4. This algorithm maintains two integers, \nConstants. cmax,cmin are integers. Data Type. bufmin and bufmax are integers. e is a boolean. Initially, \nbufmin = bufmax = 0 and e = false. Event Handlers. On receiving iqx: buf= buf+ 1, bufmin = bufmin +1 \nmax max if (bufmin >B + cmax) then e = true else buf= min(buf,B + cmax) max max oqx: if (bufmax <cmin) \nthen e = true else buf= min(B, buf- cmin), max max bufmin = max(0, bufmin - cmax) If e is true after \nexecuting either event handler, .ag an error. Figure 4: Algorithm for checking P1 and buf, representing \nthe minimum and maximum number of inputs that are currently bu.ered between the monitor and the device \nunder test. If bufmin ever grows too large, it indicates that the particular iq, oq string seen so far \ncould not be a valid execution without additional bu.ering between the monitor and the device. That is, \ntoo few out\u00adputs have been seen to account for all the inputs seen so far. Similarly, if bufmax ever \nbecomes too small, it indicates that the particular iq, oq string seen so far could not re.ect a valid \nexecution because even if each output has consumed the minimum number of inputs, there have not been \nsuf\u00ad.cient inputs to account for every output given that each output must consume at least cmin inputs. \nIn each case an error .ag e is set. bufmin max To prove the correctness of this algorithm, we can do \na re\u00adduction from the brute-force algorithm of Figure 3 to the one in Figure 4. The reduction proceeds \nby de.ning a map\u00adping between the two state spaces and showing that it is maintained when each algorithm \ntakes a step in response to the same event. The proof is given in the appendix; we omit proofs of the \nremaining properties.  5.1.2 P2: Independent Inputs and Outputs If g checks a composition of two independent \nproperties, one of the input trace and the other of the output trace, then construction of the monitor \ncan be greatly simpli.ed. Formally, we say that: ([.]id . g . [.]od . g) . [.]id,od . g For example, \nsuppose we want to check that as long as there is no loss and all data is acked, the TCP sender we are \nmon\u00aditoring will keep pumping out new data. First we check that every output data segment has a sequence \nnumber strictly greater than that of the last output. However, this needs to be true only as long as \nall data is acked by the receiver. So in conjunction, we need to check that every input ack has a sequence \nnumber strictly greater than that of the last out\u00adput. As long as both of these are true, the sender \nis behaving correctly. If the second property fails, our assumption has been violated, and the sender \nis assumed correct by default. The monitoring algorithm for P2 simply needs to check that the sequence \nof idx events corresponding to the iqx events, as well as the sequence of odx events corresponding to \nthe oqx events, is acceptable according to g. In addition, if we wish to monitor more complex properties, \nthey can be checked independently, since P2 does not place any restrictions on the relative orderings \nof od s and id s. The procedure feeds one token to g at every event and needs to maintain no state extraneous \nto g. The algorithm is as shown in Figure 5. Data Type. .i is a string of id s. .o is a string of od \ns. e is a boolean. Initially, .i = .o = . and e = false. Event Handlers. On receiving iqx: .i = .i :: \nidx; if .i .. g then e = true; oqx: .o = .o :: odx; if .o .. g then e = true; If e is true after executing \neither event handler, .ag an error. Figure 5: Algorithm for checking P2  5.1.3 P3: Periodic Outputs \nSuppose the speci.cation requires that the device produces an output exactly every P inputs, we can have \nan e.cient algorithm to parse a trace; no other assumptions on g are required. The condition can be given \nas follows: .a, \u00df : \u00df consists only of inputs .|\u00df| > 0 . (a = . . a ends in some od) :: (a\u00df ody . g) \n.|\u00df| = P Many protocols have a periodic output behavior. For in\u00adstance, ICMP echo protocol has an output \nperiod (P ) of 1: every input must be responded to by an output. Some TCP implementations maintain a \nP of 2. P3 can be thought of a restricted counting property (cmin = cmax = P ) in conjunc\u00adtion with a \n(possibly) complex property. The algorithm we use is that any time an output event is seen by the monitor, \nit feeds exactly P bu.ered inputs to g, and then checks that the output is enabled at this point. The \nalgorithm is as shown in Figure 6. Constants. P is the number of inputs consumed by g before each output. \nData Type. . is a string of id s and od s. b is a string of iq s. e is a boolean. Initially, . = b = \n. and e = false. Event Handlers. On receiving iqx: b = b :: iqx; if |b| >B + P then e = true; oqx: if \n|b| <P then e = true; else 1. iterate P times: delete the .rst element iqy from b; . = . :: idy; 2. \n. = . :: odx; if . .. g then e = true;  If e is true after executing either event handler, .ag an error. \nFigure 6: Algorithm for checking P3  5.1.4 P4: Deterministic Placement of Outputs Suppose g has the \nproperty that the placement of outputs in a sequence of inputs has no leeway: there is exactly one position \nat which each output could be placed such that the resulting string is in g. Formally, the deterministic \noutput placement property can be given as follows: .a, \u00df : \u00df consists only of inputs .|\u00df| > 0 :: a odk \n. g . a\u00df odk .. g In practice, we only need that a\u00df odk .. g for |\u00df| <B.A property in P4 is checked by \nmaintaining a bu.er of uncon\u00adsumed inputs. On getting an output, we feed inputs from the bu.er to g until \nthe .rst point where the output is enabled, and then we feed the output to g. This works, because P4 \nguarantees that the output could not occur after any other input in the future. This algorithm maintains \nbu.er b of inputs of size (B + cU ). At each output we feed the .rst |b|- B inputs to g, followed by \nat most B strings (of length at most B). In general, .nite-state machines do not satisfy P4. However, \nsome do, and speci.c instances of other kinds of automata (PDA etc.) could satisfy P4 too. For example, \nthe following grammar obeys P4: G . . G . GG G . HoSTOP H . iA H . iLPAREN HiRPAREN 5.1.5 P5: Contiguously \nEnabled Commutative Outputs Sometimes, there is a range of positions in a bu.ered input stream where \none could reasonably place an output. Con\u00adsider the following two restrictions: the range of positions \nover which the output is enabled is contiguous, in the sense that the input is enabled at every point \nin the input stream between the .rst and last positions it is enabled. Also, we require that the output \ncommute with each of the inputs in this contiguous window, such that if the output is con\u00adsumed and then \nthe input, we arrive at a state which is in\u00addistinguishable from consuming the input .rst and then the \noutput. These two conditions are embodied in the following formula: .a, \u00df : \u00df consists only of inputs \n:: (a\u00df odx . g) . (a odx \u00df . g) . (.d1,d2 : d1 d2 = \u00df :: (a\u00df odx ~g ad1 odx d2)) where a ~g \u00df = (.. : \na. . g .. \u00df. . g) An example of such a speci.cation is TCP .ow control. If a TCP ack odx is allowed just \nbefore data segment idk and just after idk+p , then it must be allowed at all points in between, since \nnone of them matter to the ack. Moreover, the receiver s window is the same whether this ack occurs before \nor after any of these data segments in the window idk ... idk+p . For g in P5, we can work with a credit \nscheme. We always place output at the .rst place it is enabled, but remember the credit we get for not \nplacing it at a later place. If at some point in the future, the bu.er over.ows because we consumed too \nfew inputs, we can then use up this credit, i.e. eat up that many input tokens. The algorithm for P5 \n(Figure 7) maintains a bu.er of inputs of size (B + cU ), and one integer indicating the credit: the \nrange of positions where the last output could have taken place. At each output we feed the .rst |b|- \nB inputs to g, followed by at most B strings (of length at most B).  5.1.6 P6: Output-checkpointed Automata \nWe say that g is an output-checkpointed automaton if, start\u00ading from a state, for each output odx, there \nis at most one next state that g can be in. In terms of strings, if two strings a and \u00df are equivalent \nwith respect to g, and if they are concatenated with di.erent strings of inputs followed by the same \noutput odx, then the two strings ending in odx are still equivalent with respect to g. Formally, .a, \n\u00df : (a ~g \u00df) . (.odx,d1,d2 : d1,d2 consist only of inputs :: ((ad1 odx . g) . (\u00dfd2 odx . g)) . (ad1 odx \n~g \u00dfd2 odx)) An instance of P6 is a protocol in which each output gives complete information about the \nstate in which it is enabled. For example, some transport layer protocols have a notion of selective \nacknowledgments (sack s) where data receivers send information about all data received up to that point. \nAlthough we need to check if the sack was allowed, once it Data Type. ., . ' are strings. b, b ' are \nstrings of inputs. credit is an integer. e is a boolean. Initially, . = b = ., credit = 0 and e = false. \nEvent Handlers. On receiving iqx: b = b :: iqx; if (|b| > (B + cU ) . credit > 0) then delete the .rst \nelement iqy of b; . = . :: idy; credit = credit - 1; if (|b| > (B + cU ) . credit = 0) then e = true; \noqx: 1. repeat until ((|b|= B) . (. :: odx . g . b = .)): delete the .rst element iqy of b; . = . :: \nidy; 2. if b .  = . then b ' = b; delete the .rst element iqy of b ' ; . ' = . :: idy; credit = 0; \nrepeat until . ' :: odx .. g or b ' = .: credit = credit + 1; delete the .rst element iqy of b ' ; . \n' = . ' :: idy; 3. . = . :: odx; if . .. g then e = true; If e is true after executing either event \nhandler, .ag an error. Figure 7: Algorithm for checking P5 has happened, the state at the receiver is \ncompletely known to us. So we can carry out our analysis output to output, forgetting everything that \noccurred before the last output. The algorithm for monitoring P6 maintains just one admis\u00adsible string \n. because after an output occurs, all strings allowed by g must be equivalent; we just need to keep one \nof them, and we keep the one with the .rst possible placement of that output. In addition, we maintain \na bu.er b of inputs of size (B + cU ), and B bits indicating positions at which the last output could \nalso have happened. At each output, we need to concatenate every sub-string of bu.ered inputs, starting \nfrom these positions, to . and check if the output is allowed after this string. There may be up to B2 \nsuch input strings (of length at most (B + cU )) that need to be checked. This gives us a bound for the \nper-event computation, polynomial in the length of the bu.ers.  5.1.7 P7: Finite State Machines If g \nis known to be a .nite state machine with a set of states G, then there is a bound to which the brute-force \nsearch set O can grow. Suppose g = (S, G, d, s0, Err), where S consists of all id,od symbols, G is the \n.nite set of states, d is the de\u00adterministic transition relation, s0 is the initial state, and Err is \nthe set of error states. Each (., b) in O can be represented as (s, b) where s = d * (s0,.). Now, b must \ncontain some suf\u00ad.x of the iq elements in ., of length at most B. However, every . in O must contain \nthe same sub-sequence of iq s and oq s. Therefore, every b in O must be a su.x of the same B-element \nstring. This gives us a bound of |G|* B elements for O. This means that we may have to feed up to |G|* \nB2 elements to g at each output. The bound is polynomial in the number of states and the size of the \nbu.ers. Moreover, it gives us a way of executing the general brute-force algo\u00adrithm with an e.cient representation \nof the string . as the state s. The algorithm is as shown in Figure 8. Notice that, because we perform \nan iteration after an iq event, as in the brute-force algorithm, we cap the bu.ering requirement by B. \nConstants. g = (S, G, d, s0, Err). Data Type. O is a set of pairs (state, list of input sym\u00adbols). Initially, \nO = {(s0, [])} Event Handlers. On receiving iqx: 1. .(s, b) . O: delete (s, b) from O; check-add (s, \nb :: iqx) to O. 2. iterate until no more additions to O:  .(s, [iqy :: b]) . O: check-add (d(s, idy),b) \nto O; oqx: 1. .(s, b) . O: delete (s, b) from O; check-add (d(s, odx),b) to O. 2. iterate until no \nmore additions to O:  .(s, [iqy :: b]) . O: check-add (d(s, idy),b) to O; where check-add adds (s, b) \nto O if and only if: b obeys the bu.ering constraints (|b| <B), and  s is not an error state of g (s \n.. Err).  If O = f after executing either event handler, .ag an error. Figure 8: Algorithm for checking \nP7  5.2 Dealing with Loss Allowing loss of input events between the monitor and the device introduces \nadditional complexity to our search algo\u00adrithm. However, as before, we can derive e.cient algorithms \nfor some classes of g. In each of the following sub-sections, we describe a property of g that allows \nus to monitor it ef\u00adfectively even in the presence of loss. We will see that the classes of g that were \ne.ciently monitorable without loss, become less e.cient or even unfeasible when loss is allowed. 5.2.1 \nCounting Properties (P1 revisited) As mentioned before, properties based solely on the number of inputs \nand outputs consumed are often used to charac\u00adterize protocols. For such g, monitoring in the presence \nof loss is very similar to the loss-less case. Suppose that we know that no more than cL inputs can be \nlost in succession. Then in order to check that each output must consume be\u00adtween cmin and cmax inputs, \nwe follow the same procedure of maintaining buf, except that we allow buf max and bufminmax and bufmin \nto grow up to m + cmax * cL * (n + 1) during iq processing. We leave the oq processing unchanged. There \nis clearly a constant amount of work to be done at each event. 5.2.2 P2o: Independent Output Properties \nProperties about the output stream can be checked even in the presence of loss because by assumption \noutputs never get lost. The checking procedure simply involves checking g against the trace seen at M. \nNo bu.ering is needed. An example of a P2o property is output monotonicity: every output contains a sequence \nnumber that is strictly greater than that of the last output. This just involves storing an output and \ncomparing it with the next one. We feed g at most one token at every output.  5.2.3 P8: Insert-closed \nCommutative Outputs We describe a class of monitorable properties that are im\u00adpervious to the presence \nof input loss. Essentially, if a string ending in odx is acceptable, so is the string with an arbitrary \nstring of inputs d inserted before odx. Moreover, odx com\u00admutes with every input in d. In e.ect, this \nsays that if g enables odx at the end of the string a, it remains enabled forever, and it can be placed \nat any point after a with the same e.ect. (.a, odx : a odx . g . ((.idy : a idy odx . g). (.d1,d2 consisting \nonly of inputs : a odx d1 d2 ~g ad1 odx d2))) Note that P8 is really a special case of P5. The fact \nthat out\u00adputs once enabled are enabled forever implies the contiguously\u00adenabled property, in addition \nto which we already have com\u00admutativity of outputs. An instance of P8 is a containment property on outputs. \nFor example, a property could state that every output contains a .eld bytes-received that is less than \nthe sum of the sizes of inputs received. The algorithm for checking P8 is simple. Always assume that \nno inputs have been lost and place the output after the .rst input where it is enabled. To keep track \nof the suc\u00adceeding positions where the output could have occurred, we maintain a credit as in the algorithm \nfor P5. Suppose in reality, some of the inputs between two outputs were lost, then we have generated \na string that has some extra inputs inserted between these outputs. However, P8 tells us that inserting \nthese inputs still keeps the string in g. Next, sup\u00adpose that an output that we placed after an input \nidk in the input stream, did not in reality occur until idk+p. Here again, P8 assures us that the output \ncommutes with the in\u00adputs idk , idk+1 ..., idk+p . Finally, note that the string we construct is an admissible \nstring: one in which no losses oc\u00adcur. Therefore, as long as this string belongs to g, we must accept \nit. The algorithm is as shown in Figure 9. This al\u00adgorithm feeds g with at most (B + cU * cL) input tokens \nat each output. Data Type. . is a string. b is a strings of inputs. credit is an integer. e is a boolean. \nInitially, . = b = ., credit = 0 and e = false. Event Handlers. On receiving iqx: b = b :: iqx; if (|b| \n> (B + cU * cL) . credit > 0) then delete the .rst element iqy of b; . = . :: idy; credit = credit - \n1; if (|b| > (B + cU * cL) . credit = 0) then e = true; oqx: 1. repeat until ((|b|= B) . (. :: odx \n. g . b = .)): delete the .rst element iqy of b; . = . :: idy; 2. . = . :: odx; if . .. g then e = true; \n 3. credit = |b|;  If e is true after executing either event handler, .ag an error. Figure 9: Algorithm \nfor checking P8  5.2.4 Finite State Machines (P7 revisited) If g is an FSM, we can bound the amount \nof state that we need in order to model loss in the brute-force search strategy. In fact, the bound on \nO is exactly the same as in the absence of loss. There can be at most |G|* B elements in O. As before, \nthis bound means that we can e.ectively execute the brute force algorithm to monitor g. However, in this \ncase we have to consider all 2B lossy substrings of the bu.er at each event. Therefore, we may need to \nfeed as many as |G|* B2 * 2B-1 tokens to g at each event.  5.2.5 P9: Deterministic Stateless Transducers \nLet us assume that all the inputs that the monitor sees will be distinct. This restriction forbids the \nenvironment from producing duplicate inputs for the lifetime of the monitor. Under this assumption, we \ncan describe a g that speci.es a stateless transducing behavior. Suppose that an output ody can occur \nafter an input idx. Then, in every string allowed by g that contains ody, it must occur immediately after \nidx. Moreover, any string ending in an idx ody pair is equivalent to the string idx ody. This means that \ng is stateless: all it cares about are idx ody pairs. .a, idx, ody : a . g . (idx ody ~g a idx ody). \n(idx ody . g . (.idz .: idz = idx ody .. g). (ody .. g) The condition that each input is distinct is \na rather strong one. In practice, what we need to impose is that no input is repeated within a space \nof (B + cU * cL) iq tokens, which is the maximum number of inputs that the monitor needs to analyze at \na time. An example of P9 is the speci.cation of the ICMP (ping) protocol. In a ping session, all inputs \n(ICMP Requests) are unique because they have monotonically increasing sequence numbers. Given an ICMP \nReply, we can map it uniquely to an ICMP Request on the basis of the sequence number. Moreover, once \nwe have mapped the Reply to a request, there is nothing that we need to remember about the anal\u00adysis \nup to that point. P9 can be checked e.ciently even in the presence of loss. Essentially, each output \nody points to at most one input idx that triggered it and we do not need to check any other input. If \nidx is not in the bu.er, and ody cannot occur with\u00adout an input, then there is an error, otherwise, everything \nup to idx can be dropped from the bu.er. This algorithm feeds g at most (B + cU * cL) elements at every \noutput. The algorithm is as shown in Figure 10. Data Type. . is a string. b is a string of inputs. e \nis a boolean. Initially, . = b = . and e = false. Event Handlers. On receiving iqx: b = b :: iqx; if \n(|b| > (B + cU * cL)) then e = true; oqx: if b = . then e = true; else delete the .rst element iqy of \nb; repeat until ((|b|= B) . (idy :: odx . g . b = .)): delete the .rst element iqy of b; . = . :: idy \n:: odx; if . .. g then e = true; If e is true after executing either event handler, .ag an error. Figure \n10: Algorithm for checking P9  5.2.6 P10: Output-checkpointed Stateful Transducers In P9, the statelessness \nassumption allowed us to forget about the history of the monitoring, once an output had been placed in \nthe input stream. We can generalize this no\u00adtion, by taking a hint from output-checkpointed automata \n(P6). Instead of saying that the state of g after consuming a idy odx must be the same as the state after \nconsuming just idy odx, we say that starting from a state, if odx is allowed after some inputs then there \nis a unique state that g can be in after consuming odx. As before, all inputs in t must be distinct. \nFormally, g is expressed as a conjunction of P6 with a generalization of P9: .a, \u00df : (a ~g \u00df) . (.odx,d1,d2 \n: d1,d2 consist only of inputs :: ((ad1 odx . g) . (\u00dfd2 odx . g)) . (ad1 odx ~g \u00dfd2 odx)). .a, idx, ody,d1,d2 \n: d1,d2 consist only of inputs :: (ad1 idx ody . g) . (.idz .: ad2 idz ody .. g). = idx (a ody .. g) \n An example of such a g is a protocol in which there are two kinds of inputs: data inputs containing \nintegers and ack\u00adrequest inputs that contain unique magic numbers. The protocol is supposed to send an \noutput when it receives an ack-request, and the output contains the magic number of the request and a \nsum of all inputs seen since the last output. Clearly, every output has a unique input (the ack-request) \nafter which it can occur. Moreover, it contains information that is compatible only with some sub-sequences \nof inputs since the last output. The P6 part of P10 allows us to just maintain one state af\u00adter each \noutput. Moreover, the P9 part tells us that we can uniquely place the output in the input stream. In \nconjunc\u00adtion, this gives us a simple algorithm for checking P10. At each output, we place it in the sequence \nof bu.ered inputs as in P9. Once we have found a position, we must search for a lossy sub-sequence of \nthe inputs before that position that makes the string acceptable to g. If both these tests succeed, we \ncan proceed with a single next state and a single bu.er to monitor the rest of the string. The algorithm \nmaintains a input bu.er b of size (B + cU * cL). Then at each output, we may need to check g against \n2(B+cU *cL) input sequences. The maximum number of to\u00adkens to be fed to g is (B + cU * cL) * 2(B+cU *cL)-1 \n.  5.2.7 Output-checkpointed Automata (P6 revisited) P6 can be handled in the presence of loss by doing \nsome further exploration of bu.er strings. However, no explo\u00adration of g s state space needs to be done. \nWe maintain a set of positions in the bu.er where the last output could have happened. Then for the next \noutput, we need to .nd all sub-sequences starting from these positions that enable the output. We are \nguaranteed that all these sub-sequences will end in the same state, so we will just need to remem\u00adber \nthe positions where we can place the output and the common next state. If there is no position where \nwe can place the output, there is an error. This algorithm would require us to check a maximum of 2(B+cU \n*cL) input strings against g at each output, where (B + cU * cL) is the size of the input bu.er. We may \nhave to feed a maximum of (B + cU * cL) * 2(B+cU *cL)-1 tokens to g.  5.3 Property Relationships In \nthis section, we describe the relationships between all the classes of g that we have discussed in this \nsection. In Table 1, we summarize the complexities of the algorithms described for the various property \nclasses. We assume that g has been written in a way that allows us to feed it input and out\u00adput tokens \none by one, and it will take a constant amount of time to analyze each token. Then the complexity of \nthe monitoring is the number of tokens that need to be fed to g at any step. Note that most of the complexities \nare in terms of the size of the bu.er B. The value of B is dependent on the sizes of the input (m) and \noutput (n) bu.ers, protocol entities like the maximum number of inputs allowed between two outputs (cU \n), and environmental entities like the max\u00adimum number of inputs that can be lost in succession (cL), \nbetween the monitor and the system. We de.ne the bu.er size in the absence of loss as B = m + cU * n, \nand in the presence of loss as B = m + cU * cL * n. Table 1: Monitoring Complexities for Property Classes \nof g Property Without loss With loss All Unbounded Unbounded P7 G * B2 G * B2 * 2B P6 B3 B * 2B P5 B2 \nUnbounded P4 B2 Unbounded P8 B2 B2 P3 P Unbounded P10 B B * 2B P9 B B P2 1 Unbounded P2o 1 1 P1 1 (just \ncount) 1 As Table 1 shows, most of the properties described in this section belong to di.erent complexity \nclasses for monitoring. Many of the properties are in fact inclusions of each other. The inclusion relationships \nare as shown in Figure 11. How\u00adever, there are some other interesting relationships as well. In going \nfrom the no-loss to the lossy case, properties P3, P4 and P5 become very ine.cient to monitor. Therefore, \nwe need to pick .ner subsets of P5: P8, P9 and P10, that will still lend themselves to e.cient monitoring \nin the presence of loss. These subsets collapse to similar complexities as P3, P4 and P5 in the no-loss \ncase. Properties P5, P6, and P7 are three orthogonal ways of reigning in the unbounded size of O in the \nbrute-force search. It is possible to combine some of these properties to arrive at a property that relates \nto a real-world protocol. For ex\u00adample, we combine P6 and P7 in the next section to arrive at a TCP property. \nIt may also be possible to combine one of more of these properties with some protocol-speci.c knowledge \nto reduce the size of O. Therefore, if a protocol property that one wishes to monitor does not fall in \none of P5, P6, or P7, it does not immediately rule out an e.cient procedure, contrary to what seems to \nbe the case by looking at Figure 11 ( All category). Whether there are other use\u00adful protocol-independent \nproperties that are orthogonal to the three above, is an open question, one we hope to address in future \nwork. 6 Monitoring TCP We now show how to use the techniques described in the previous sections in order \nto monitor TCP [15] implemen\u00adtations. For reasons of space, we consider only the receiver\u00adside behavior. \nTCP implements a sliding window protocol to implement reliable, in-order delivery. To transfer a large \nbu.er of data, a TCP sender breaks it into small .xed-sized segments and sends each numbered segment \nin a separate message. Ini\u00adtially, the sender assumes that the receiver is ready for the .rst segment, \nand that the receiver can accept a certain count of segments in its window . It may send some of these \nsegments out on the network to the receiver. The re\u00adceiver acknowledges (acks) these messages, with a \nsequence number of the segment immediately after the contiguously received part of the bu.er. Thus, if \nsegments 1, 2, 4, and 5 have been received, where segment 3 was delayed or lost in transit, TCP receiver \nmay generate acks 2, 3, 3, and 3. The sender forms a judgment of which segments (e.g. 3) got lost in \ntransit, and resends them. If the receiver now receives segment 3, it generates an ack with sequence \nnumber 6, be\u00adcause segments 1-5 have been all received. Occasionally, the receiver also gives an indication \nof newly available capac\u00adity in its window, once some pre.x of the earlier contiguous packets are consumed \nby the receiving application. The TCP speci.cation prescribes the sequence number that must be contained \nin an ack, based on the state of the re\u00adceiver window as described above. It, however, allows a lee\u00adway \nthat receivers may generate an ack at least every two messages, so an implementation may decide to not \nack every single message. Typically, we may wish to monitor TCP properties such as the following: 1. \nThe implementation is generating an ack for at least every other message it receives. 2. Ack sequence \nnumbers are non-decreasing. 3. Acks always acknowledge exactly the contiguously re\u00adceived set of segments. \n  Each such property falls in a di.erent class of g, and hence entails di.erent complexities in the \nmonitoring process. Con\u00adsider data segments as input symbols and acks as output symbols. TCP property \n1 describes a g that is a counting prop\u00aderty, g . P 1, with cmin = 1 and cmax = 2. This property is easy \nto monitor both in the presence and absence of loss.  TCP property 2 describes a g in which inputs and \noutputs are independent. Since g . P 2o, even in the presence of loss this property is easy to check. \nMore\u00adover, property 2 can be checked independently of the other properties.  TCP property 3 describes \na g that falls in class P5. In the absence of loss between the monitor and device, we can check this \ne.ciently using the algorithm in Fig\u00adure 7. Interestingly, we can e.ciently check property 1 in conjunction \nwith property 3, because the algorithms for P1 and P5 compose well. Both de.ne ranges over which the \nlast output could have taken place, the al\u00adgorithm for the conjunction simply maintains the in\u00adtersection \nfor these ranges.  The algorithm described above does not work if there is loss between the monitor \nand device. However, prop\u00aderty 3 can also be expressed as the composition of an output-checkpointed property \n(P6) and a .nite state property (P7). In order to see this, note that the TCP monitor s state could be \nseen as a triple of the form (unacked-data, contig-recd, recv-window), where unacked-data is the number \nof unacknowledged data packets since the last ack, contig-recd is the largest se\u00adquence number in the \ncontiguously received data, and recv-window is the data that has been received in the window but is missing \nsome segments. Here (unacked\u00addata,contig-recd) is output-checkpointed: when you see an ack for sequence \nnumber s + 1, unacked-data must be 0, and contig-recd must be s. On the other hand, the recv-window is \n.nite-state, and its state space can be as large as 2W -1, where W is the win\u00addow size. So to monitor \nproperty 3 (together with property 1) we can compose the algorithms for P6 and P7. The complexity of \nsuch an algorithm is the sum of the complexities of the two algorithms as shown in Table 1, which is \nessentially the complexity of the P7 part (2W * B2 * 2B ).  Conclusions and Related Work This paper \nis most closely related to work on passive test\u00ading [7]. They also use on-line monitoring to test protocol \nim\u00adplementations, but do not address the problems of in.delity of traces. To our knowledge this paper \nis the .rst attempt to create an abstract model of the in.delities that can arise when monitoring a remote \ndevice under test, and to formally specify conditions under which e.cient correctness-checking algorithms \ncan be deployed. Paxson [13] gives a good empirical overview of sources and manifestations of in.delity, \nwith a focus on wide-area net\u00adworks. Our work concentrates on in.delity in a local-area network setting \nand is a more formal treatment. Most of the other literature devoted to network monitoring is targeted \ntoward network security concerns. Paxson s Bro system [12] and the Network Flight Recorder [14] are good \nexamples of practical monitoring tools that must deal with remote monitoring of trusted and untrusted \ndevices. These tools o.er high performance and customizability with the addition of new speci.cation \nscripts, but such scripts are developed in an ad-hoc manner and must take in.delity into account by hand. \nTesting of reactive systems from abstract speci.cations is also an area of active research. Bhargavan \net al. [3] give an overview of networking-related analysis techniques. Formal speci.cation and automatic \nveri.cation have also been used in the context of telecommunications systems [6, 4]. Our work di.ers \nfrom these in that we are not attempting to generate test cases but rather to monitor the correctness \nof an implementation during deployment. O Malley et al. [10] discuss the creation of property checking \nautomata from a graphical speci.cation notation. Event speci.cations [8] have been used for run-time \nproperty veri.cation, and the Verisim tool [2] applies this work to properties of network protocols. \nHowever, all of these systems assume a co-located style of speci.cation that is, they assume that the \ndevice under test can be directly instrumented and properties can be checked in a synchronous manner. \nIf the device under test cannot be directly instrumented then the speci.cations used must be transformed \nto take the resulting in.delity into account. This paper has been a systematic exploration of such transformations. \nReferences [1] G. Berry and G. Gonthier. The Esterel synchronous programming language: Design, semantics, \nimplemen\u00adtation. Science of Computer Programming, 19(2):87 152, November 1992. [2] Karthikeyan Bhargavan, \nCarl A. Gunter, Moonjoo Kim, Insup Lee, Davor Obradovic, Oleg Sokolsky, and Mahesh Viswanathan. Verisim: \nFormal analysis of net\u00adwork simulations, August 2000. To appear in: Interna\u00adtional Symposium on Software \nTesting and Analysis. [3] Karthikeyan Bhargavan, Carl A. Gunter, and Davor Obradovic. A taxonomy of logical \nnetwork analysis techniques. Technical Report MS-CIS-00-14, Univer\u00adsity of Pennsylvania, 2000. [4] Patrice \nGodefroid. Model checking for programming languages using VeriSoft. In Proceedings of the 24th ACM Symposium \non Principles of Programming Lan\u00adguages, pages 174 186, January 1997. [5] Gerard J. Holzmann. Design \nand Validation of Com\u00adputer Protocols. Prentice Hall, 1991. [6] L. J. Jagadeesan, A. Porter, C. Puchol, \nJ. C. Ram\u00adming, and L.G.Votta. Speci.cation-based testing of re\u00adactive software: Tools and experiments. \nIn Proceedings of the International Conference on Software Engineer\u00ading, May 1997. [7] D. Lee, K. Sabnani, \nA. Netravali, B. Sugla, and A. John. Passive testing and its applications to net\u00adwork management. In \nProceedings of the International Conference on Network Protocols, 1997. [8] I. Lee, S. Kannan, M. Kim, \nO. Sokolsky, and M.Viswanathan. Runtime assurance based on formal speci.cations. In Proceedings International \nConference on Parallel and Distributed Processing Techniques and Applications, 1999. [9] Nancy A. Lynch \nand Mark R. Tuttle. An introduction to input/output automata. CWI Quaterly, 2(3):219 246, 1989. [10] \nT.O. O Malley, D.J. Richardson, and L.K. Dillon. Ef\u00ad.cient speci.cation-based test oracles. In Second \nCali\u00adfornia Software Symposium (CSS 96), April 1996. [11] V. Paxson. Automated packet trace analysis \nof TCP implementations. Computer Communication Review, 27(4), October 1997. [12] V. Paxson. Bro: A system \nfor detecting network intrud\u00aders in real-time. Computer Networks, 31(23-24):2435 2463, December 1999. \n[13] V. Paxson. End-to-end internet packet dynamics. IEEE/ACM Transactions on Networking, 7(3):277 292, \nJune 1999. [14] M.J. Ranum, K. Land.eld, M. Stolarchuk, M. Sienkiewicz, A. Lambeth, and E. Wall. Implement\u00ading \na generalized tool for network monitoring. In Pro\u00adceedings of the Eleventh Systems Administration Con\u00adference \n(LISA XI), pages 1 8, 1997. [15] W. Richard Stevens. TCP/IP Illustrated, Volume 1: The Protocols. Addison-Wesley, \nReading, Mas\u00adsachusetts, 1994. Appendix: Proof for P1 De.nition 2 (iqtail) Let iqtail(.) equal the sequence \nof iq elements in . that are prior to the last oq element but which were not consumed before the oq, \nthat is, which do not have a corresponding id element before the oq, plus all iq s that appear after \nthe last oq element, regardless of whether the corresponding id is in .. If . does not contain any oq \ns, then iqtail(.) is just the sequence of iq s in .. De.nition 3 (idtail) Let idtail(.) equal the sequence \nof id elements in . that appear after the last od element. If . does not contain any od s, then idtail(.) \nis just the sequence of id s in .. State Space Mapping. The mapping is given by the fol\u00adlowing inductive \nhypothesis: \u00ac e =. (.i :: bufmin = i = bufmax .. (.(., b) . O :: |iqtail(.)| = i)) . e .. O= f Base \nCase. Initially, O contains only one element, which has a zero length . and a zero length b. The initial \ncon\u00additions for buf, and e are all consistent with the max, bufminstate space mapping. Inductive Step. \nConsider the input actions in each algo\u00adrithm corresponding to iq events. In Figure 3, this action deletes \neach member of O and adds a new member with the iq action added to both . and b, as long as . is admissible \nand its projection [.]id,od is in g. In Figure 4, an input event increments both bufmin and bufmax, checks \nfor an error condi\u00adtion, and then adjusts bufmax if necessary. We need to show that the state space mapping \nstill holds. First, note that if any (., b) . O has an . such that |iqtail(.)| >= B +cmax, it will be \ndeleted from O because the result of adding the iq to . will be inadmissible according to M ' , which \nrecall is equal to M(S, m+c*n, 0). In this case c = cmax and B = m+c*n. . will be inadmissible because \nat most cmax id s can appear after the last od, oq by way of property P1. The remaining B iq s .ll up \nthe bu.er and adding one more causes it to over.ow, removing the resulting string from consideration. \nIf bufmin >= B + cmax before the input action, this implies (by the inductive hypothesis) that every \n(., b) . O has a iqtail(.) whose size is at least B + cmax. When the iq event is added, all will be deleted \nand O will be empty. This corresponds to setting e to true in Figure 4. If bufmin < B + cmax before the \ninput action, then there is at least one (., b) . O such that |iqtail(.)| = i for every i between bufmin \nand bufmax. Each will be removed and replaced with an (., b) pair with exactly one iq event added to \neach of . and b, except for those that become inadmissible with respect to M ' . This corresponds exactly \nto bufmin and bufmax being incremented by one, and bufmax being capped at B + cmax in Figure 4. The iteration \nstep 2 in Figure 3 has no e.ect on the mapping because it only adds id events to . and does not modify \niqtail(.). Note, however, that this iteration guarantees that every pattern of idtail(.) such that 0 \n= |idtail(.)|= min(cmax, buf) will be generated. This is max because each element of the iqtail(.) will \nbe converted to an id and check-added to O. Those with more than cmax id s will be discarded, since they \nare not in g, but all others will be accepted due to property P1. The longest iqtail has length bufmax, \nleading to the upper bound. Next, consider the output actions in each algorithm corre\u00adsponding to the \noq events. In Figure 3, this action .rst deletes every element of O, replacing each with one that has \nthe od, oq event pair added. Then the same iteration dis\u00adcussed previously is repeated. Note that if \nany (., b) has an idtail(.) <cmin, it will be deleted because the result of adding the od will not be \nin g, according to P1. In Figure 4, if bufmax <cmin, then all idtail(.) must have length less than cmin, \nbecause idtail(.) < iqtail(.) < bufmax. O thus becomes empty after the .rst step. This corresponds to \nset\u00adting e to true in Figure 4. Otherwise, Figure 4 decrements bufby cmin, but caps bufat B because even \nthough max max iqtail can grow larger than B, the new iqtail will be at most B because it consists of \nonly the un-consumed iq events in ., of which there can be at most B. The algorithm also decrements bufmin \nby cmax, setting it to zero if it goes neg\u00adative. This corresponds to the fact that pairs (., b) will \nbe deleted from O if they violate the cmin and cmax limits given by g, which means that the new minimum \nand maximum values of iqtail(.) will be given when the maximum number of inputs are consumed from the \nminimum previous iqtail and the maximum number of inputs are consumed from the maximum previous iqtail. \nThese consumptions are justi.ed because we have a guarantee that every pattern idtail(.), such that 0 \n=|idtail(.)|= min(cmax, buf), will have been max generated at the end of the previous iq or oq event. \n  \n\t\t\t", "proc_id": "360204", "abstract": "We consider the problem of monitoring an interactive device, such as an implementation of a network protocol, in order to check whether its execution is consistent with its specification. At rst glance, it appears that a monitor could simply follow the input-output trace of the device and check it against the specification. However, if the monitor is able to observe inputs and outputs only from a vantage point <i>external</i> to the device---as is typically the case---the problem becomes surprisingly difficult. This is because events may be bu ered, and even lost, between the monitor and the device, in which case, even for a correctly running device, the trace observed at the monitor could be inconsistent with the specification.In this paper, we formulate the problem of external monitoring as a <i>language recognition problem</i>. Given a specification that accepts a certain language of input-output sequences, we de ne another language that corresponds to input-output sequences observable externally. We also give an algorithm to check membership of a string in the derived language. It turns out that without any assumptions on the specification, this algorithm may take unbounded time and space. To address this problem, we de ne a series of properties of device specifications or protocols that can be exploited to construct e cient language recognizers at the monitor. We characterize these properties and provide complexity bounds for monitoring in each case.To illustrate our methodology, we describe properties of the Internet Transmission Control Protocol (TCP), and identify features of the protocol that make it challenging to monitor e ciently.", "authors": [{"name": "Karthikeyan Bhargavan", "author_profile_id": "81100070918", "affiliation": "University of Pennsylvania", "person_id": "PP14035027", "email_address": "", "orcid_id": ""}, {"name": "Satish Chandra", "author_profile_id": "81100394237", "affiliation": "Bell Laboratories", "person_id": "PP39040833", "email_address": "", "orcid_id": ""}, {"name": "Peter J. McCann", "author_profile_id": "81100223402", "affiliation": "Bell Laboratories", "person_id": "P224758", "email_address": "", "orcid_id": ""}, {"name": "Carl A. Gunter", "author_profile_id": "81100274423", "affiliation": "University of Pennsylvania", "person_id": "PP14103244", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/360204.360221", "year": "2001", "article_id": "360221", "conference": "POPL", "title": "What packets may come: automata for network monitoring", "url": "http://dl.acm.org/citation.cfm?id=360221"}