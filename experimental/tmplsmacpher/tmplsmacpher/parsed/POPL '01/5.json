{"article_publication_date": "01-01-2001", "fulltext": "\n Type-Based Flow Analysis: From Polymorphic Subtyping to CFL-Reachability. Jakob Rehof Manuel F/ihndrich \n Microsoft Research One Microsoft Way, Redmond WA 98052 {rehof, mar }@microsoft. com Abstract We present \na novel approach to scalable implementation of type-based flow analysis with polymorphic subtyping. Using \na new presentation of polymorphic subtyping with instanti- ation constraints, we are able to apply context-free \nlanguage (CFL) reachability techniques to type-based flow analysis. We develop a CFL-based algorithm \nfor computing flow in- formation in time O(n3), where n is the size of the typed program. The algorithm \nsubstantially improves upon the best previously known algorithm for flow analysis based on 8 polymorphic \nsubtyping with complexity O(n ). Our tech- nique also yields the first demand-driven algorithm for poly- \nmorphic subtype-based flow-computation. It works directly on higher-order programs with structured data \nof finite type (unbounded data structures are incorporated via finite ap- proximations), supports context-sensitive, \nglobal flow sum- marization and includes polymorphic recursion. Introduction Type-based program analyses \nhave received much attention (see, e.g., [Hei95, PO95, Mos96, HM97, NNH99, FRD00b]). Attractive properties \nof such analyses include: they typ- ically work directly on higher-order programs with struc-tured datatypes, \nthey provide a natural separation between the specification (type system) and implementation of the analysis, \nand standard techniques from type theory are ap- plicable to reason about properties (e.g., soundness, \ncom-pleteness) of the analysis. Type-based flow analysis tracks the flow of values by an- notating type \nstructure with flow labels t, representing val- ues at specific program points (see, e.g., [Mos96, NNH99]). \nAnswering queries of the form \"Does any value at program point \u00a31 flow to program point ~2\" solves many \nstatic anal- ysis problems such as finding potential pointer aliases, de- termining possible targets \nof indirect function calls, and de- limiting storage escapement. This paper studies efficient techniques \nto answer such queries in the setting of type- based flow analysis with polymorphic subtyping. Based \non the polymorphic type structure of the program, our analysis Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nere not made or distributed for profit or commercial advan- tage and that copies bear this notice end \nthe full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior specific permission and/or a fee. POPL'01 1/01 London, UK &#38;#169; 2001 ACM \nISBN 1-58113-336-7/O1/0001 ... 65.00 is context-sensitive, i.e., it avoids spurious flow between dif- \nferent calling contexts. Subtyping further enhances analysis precision by modeling a directional (non-symmetric) \nnotion of value flow, see, e.g., [Hei95]. While each of the features -polymorphism and subtyp- ing -are \nestablished as practical components of type infer- ence systems, their simultaneous combination in polymor- \nphic subtyping is not: scaling up polymorphic subtype in- ference to even moderately realistic program \nsizes is an out- standing open problem. This paper presents a new attack on the scaling problem for subtyping-based \npolymorphic flow analysis. The main contributions of this paper are: A novel presentation of polymorphic \nsubtyping, us-ing instantiation constraints (also known as semi-unification constraints [Hen93]). Based \non this pre- sentation, we are able to apply Context-Free Language (CFL) Reachability [Yang0, RHS95, \nMR00] techniques to compute directional, context-sensitive flow informa- tion for higher-order programs \nin polymorphic subtyp- ing systems (including polymorphic recursion).  Our resulting algorithm improves \nthe asymptotic com- plexity of the best previously known algorithm [Mos96]  s 3 based on polymorphic \nsubtyping from O(n ) to O(n ), where n is the size of the typed program :Programs are explixitly typed, \nand n measures the size of the pro- gram and the size of the explicit types in the program. In theory, \nn can be exponential in program size but is close to program size in practice [Mit96]). Our results open \nthe door to new implementation tech- niques for flow computation with polymorphic subtyp- ing. First, \nby obviating the need to simplify and copy systems of subtyping constraints, our technique may circumvent \none of the main scaling inhibitors for such systems. Second, our algorithm leads to demand-driven techniques, \nwhich, to our knowledge, have not been ob- tained before with polymorphic subtyping. In a previous paper \n[FRD00b] we have presented a flow analysis in polymorphic type systems based on instantiation constraints \nbut without subtyping. The present paper pro- vides a substantial generalization of [FRD00b] through \nthe incorporation of subtyping. In order to keep the present paper within limits, some details and proofs \nare omitted. These can be found in [FRD00a]. In the remainder of this introduction we describe the language \nframework we use for our flow analysis. ~\" 6 Types T ::= int ]T--\u00f7T[T\u00d7T e 6 Terms e x I n I (el, e2) \n] A=T.e I el e2 I let / ffi el ine21/'[ letrec f:r = el in e2 J ifO eo then el else e2 I~rj e Figure \n1: Object language 6 Labels a 6 Labeled Types a ::= int~la--+~ala\u00d7to \" Figure 2: Annotated types  1.1 \nObject language Figure 1 shows the language we use to illustrate our flow analysis. It is a higher-order \nfunctional language containing integers (n), pairs, lambda-abstractions, conditionals (test- ing for \n0), recursive functions, and pair selection (~r/). Our language is typed using a standard monomorphic \ntype sys- tem. Monomorphic types are ranged over by v. The lan- guage distinguishes between A-bound variables \nx and let- or letrec-bound variables f. Our object language is explicitly typed, i.e., we assume that \nthe type structure of programs is given in the form of type annotations on A- and letrec- bound variables, \nwritten x : r and f : 7, respectively. Uses of let- and letrec-bound variables f* are annotated with \nan instantiation site i, distinguishing all occurrences of such variables. 1.2 Annotated types Since \nwe are interested in flow, we will annotate type con- structors with flow labels \u00a3, and we will allow \nlabels on ex- pressions, e t. Annotated types are written a and are defined in Figure 2. Annotated types \nwill be used as a technical device for performing flow analysis on programs of the ob- ject language \nshown in Figure 1, they do not belong to that language itself. Erasing all labels from an annotated type \nresults in a monomorphic type of the object language. The reader should think of the flow label annotations \nas being superimposed on the types of the object language, and flow analysis will be specified later \nusing a separate type system for assigning annotated types to programs. To distinguish between annotated \ntypes and the types of the object lan- guage, we sometimes refer to the latter as underlying types, and \nthe type system of the object language is called the underlying type system. The underlying types of \nlet- and letrec-bound variables are given monomorphic types in the underlying type system, but label \nannotations on types of let- and letrec-bound vari- ables will be treated polymorphically by our flow \nanalysis. We will allow polymorphic recursion [Myc84, Hen93] over flow labels, as found in [Mos96]. We \nwill also allow our flow analysis to exploit subtyping relations over flow labels, writ- ten \u00a31 _< $2, \nto represent the fact that a value identified by let id = Ax:int t* .x 12 in   ((id' OtS/4 (id ~ d5/6) \n,  end Figur e 3: Example program e label \u00a31 flows to the program point labeled ~2, in the style of \n[Hei95, Mos96]. As in the case of polymorphism, subtyping belongs to the flow analysis framework and \nis not part of the object language. Each of the features - polymorphism and subtyping over flow labels \n- enhance the precision of type-based flow anal- ysis [Hei95, Mos96], and when combined into one system \nwe arrive at flow analysis based on polymorphic subtyping as studied in this paper. The polymorphic treatment \nof flow labels will allow a certain form of context-sensitivity (values only flow interprocedurally through \nwell-matched call-return sequences of functions) and subtyping allows us to treat flow directionally \n(the fact that a value at \u00a31 flows to \u00a32 does not imply that a value at g2 flows to gl). The language- \nand analysis framework described above will be held fixed throughout most of the paper. However, in a \nlater section (Section 6) we will indicate how our tech- niques can be extended to a language whose underlying \ntype system is polymorphic. The remainder of this paper is organized as follows. Sec- tion 2 reviews \nproblems in combining polymorphism and subtyping and sketches our solution. Section 3 presents polymorphic \nsubtyping with instantiation constraints. Sec-tion 4 defines our flow relation based on CFL-reachability. \nSection 5 presents a cubic time algorithm for computing all flow queries. Section 6 shows that our techniques \nextend to polymorphic and recursive types in the underlying type structure. Section 7 discusses related \nwork, and Section 8 concludes. 2 Flow analysis with polymorphic subtyping Scaling up type inference for \npolymorphism combined with subtyping remains a challenging problem. In this section, we first identify \ntwo major problems with current imple-mentation techniques for flow analysis based on polymor-phic subtyping \n(Section 2.1 and Section 2.2). In Section 2.3 and Section 2.4 we then give an intuitive overview of our \nsolution. We illustrate our techniques with a very simple example program e, as shown in Figure 3. We \nare interested in track- ing the flow of constants 0 and 1 labeled with Is and \u00a35. We will do so by performing \ntype inference over the annotated types in the program (our explanation will be intuitive, and the type \nsystem used will be precisely defined later). 2.1 Problem 1: Constraint copying All previous work in \npolymorphic subtype inference is based on qualified polymorphic types. In our setting of flow analy- \nsis, a qualified polymorphic type has the form In this type, quantification occurs over flow labels, \nand a is an annotated type, which typically contains labels that are quantified. The component C is a \nset of captured subtyping constraints over flow labels of the form \u00a3 _< \u00a3', qualifying the type 0. Since \nC may contain quantified labels from [, such an approach gives rise to copies of the captured constraints \nat all instantiation sites for that type, as we will illustrate next A standard 1 polymorphic constrained \ntype (see, e.g., [Smi94, TS96, Mos96]) for our example function id of Fig- ure 3 is V\u00a3I\u00a32.{\u00a3i ~ \u00a32} ~ \nint tl ~ int t2 In this typing, the constraint set {gl _< \u00a32} captures the fact that any value (represented \nby \u00a31) passed as argument to id flows to the result of the function (represented by \u00a32). In a copy-based \nframework, program e is typed by copying the constraint set {\u00a31 _< \u00a32} associated with \u00b1d at each of \nthe instantiation sites id ~ and id j. At instantiation site i, the label \u00a31 on the domain type of id \ngets copied to the label \u00a33, because \u00a3~ labels the actual argument 0 at call site i. The label \u00a32 of \nthe range type of id gets copied to the label \u00a34, because \u00a34 labels the result of the call. Because the \ntype of id is constrained by \u00a31 <_ \u00a32, the constraint set as a whole gets copied into the set {\u00a3z _< \n\u00a34} at site i. By a similar argument, the constraint set {\u00a3a _< \u00a32} gets copied into {\u00a35 <_ \u00a36} at site \nj. After these steps we arrive at the standard polymorphic typing judgment for e {\u00a33 ~ \u00a34,\u00a35 ~ \u00a36};0 \nI'- e : int t4 x int ts (1) Such a typing has four components, from left to right: a set of subtype \n(or flow) constraints, a type environment (here empty), a term and a type. From this typing we can read \noff interesting flow relations. For example, because \u00a33 _< \u00a35 is a constraint in the type (1), we can \nconclude that the value 0 (\u00a33) flows to the first component of the resulting pair (\u00a34). Similarly, we \ncan see that the value 1 (\u00a35) flows to the second (gs), as indicated by the constraint g5 _< \u00a36 in (1). \nPolymorphism over labels, here implemented via con-straint copying, keeps the two instantiation sites \napart, matching up a call site (e.g., :Ld~0 is) with its proper return (\u00a34). This was achieved by making \ntwo distinct copies, dur- ing type inference, of the constraint set {\u00a31 _< \u00a32}, one copy at instantiation \nsite i, and another at site j. A monomorphic analysis, in contrast, typically predicts, imprecisely, \nthat ei- ther value (g3 or \u00a35) flows to either return point (\u00a34 or \u00a36). The seeming need to copy subtype \nconstraint sets at ev- ery distinct instantiation site has been identified as a ma- jor problem, making \nit very difficult to scale polymorphic subtyping to large programs. 2 In particular, the problem has \ngenerated a significant amount of research on constraint simplification, which aims at compacting constraint \nsets be- fore they are copied [FM89, Cur90, Kae92, Smi94, EST95, Mos96, Pot96, TS96, FA96, AWP97, l:teh97, \nFF97]. It is unlikely that constraint simplification techniques alone will solve this problem, and complete \nsimplification is a hard problem itself [Push98, FF97]. 2.2 Problem 2: Demand-driven flow computation \nConstraint copying methods for polymorphic subtyping sys- tems axe not demand-driven [Mos96]. For instance, \nif we 1Function id can be given a most general typing without any sub- typing constraints, but we choose \nthe present typing for illustrative purposes. 2The small size of the Constraint set in our toy example \nis illusory in practice, of course only ask for the flow between \u00a33 and \u00a34 in our example pro- gram \u00b1d, \ntraditional methods still copy. the constraint set {\u00a31 <_ \u00a32} into both call sites id ~ and id J , even \nthough only the former copy is necessary to answer the qnestion. A related, more subtle problem is that \nflow queries may originate at arbitrary program points. For example, we may ask which values globally \nflow into the formM parameter x of the function definition :i.d (in our example~ the answer is ga and \ngs, since 0 is an actual parameter to id at call site i, and 1 is an actual parameter to id at site j). \nBecause copy- ing does not keep track of the source of constraint copies, it does not represent the flow \nof values between a polymor- phie function and its instantiations. Recovering this infor- mation in the \ntraditional framework has proven to be non- trivial [Mos96, FFA00], both in terms of computational ex- \npense and correctness, because it requires the entire typing derivation rather than merely the final \ntyping judgement of the program. Furthermore, it is unclear how such techniques can naturally accommodate \ndemand-driven versions. 2.3 A new method based on instantiation con-straints Both of the problems mentioned \nin Section 2.1 and 2.2 in- hibit scalability of polymorphic subtype-based flow analysis. We tackle these \nproblems by introducing a new presenta-tion of polymorphic subtyping, based on instantiation con. strain,s. \nInstantiation constraints were used in [FRD00b] to support scalable context-sensitive flow analysis. \nHere, we generalize the approach by incorporating subtyping, and, as we will see, this will significantly \nchange the way flow com- putation is done. We refer to our system as POLYFLOWcFL. Instead of constrained \ntypes V[.C ~ a, POLYFLOWcFL uses standard quantified types of the form V[.a, which are given meaning \nin combination with a global set of con-straints. In POLYFLOWcFL, the term e from the example shown in \nFigure 3 receives a typing of the form   { ~1 \"~-\u00a33,\u00a32 .~\u00a34, } o\" {\u00a31 <\u00a32};01-e (2) \u00a31 ~+ \u00a35, \u00a32 ~_ \ne~ ; - where ~ = int t4 x int ts. A judgment in POLYFLOWcFL has five components, from left to right: \na set of instantiati(~n constraints I, a set of flow constraints C, a type environment (here empty), \na term and a type. The instantiation constraints I explicitly represent the label substitutions ~ and \n~j given by and ~j = {\u00a31 ~ \u00a35,\u00a32 ~ \u00a36} These substitutions are used at instantiation sites i and j, \nrespectively, to produce instances of id's type int ll --+ int 2. In the constraint set I, the substitution \n~ is represented by the constraints \u00a31 ~. \u00a33,\u00a32 ~_~- \u00a34, and ~oj is represented by \u00a31 .~J+ \u00a35,\u00a32 _~J+ \n\u00a36. In a constraint copying framework, ~i and ~j are applied at sites i and j to copy the subtype constraint \nset {~1 <_ \u00a32} associated with \u00b1d, yielding {\u00a33 <_ \u00a34) at site i and {\u00a35 _< \u00a36} at site 3. In our instantiation \nconstraints, The indices i and j serve to keep substitutions at distinct instantiation sites apart. The \ncrucial difference of POLYFLOWcvL to copy-based systems is that we avoid constraint copying altogether: \n* Instead of explicitly representing copies of the original constraint system ({ll < \u00a32}), only the substitutions \nnecessary to create them are represented. The con-straint copies are thereby implicitly given in terms \nof the original set ({gl _< g2}) and the instantiation con-straints. Having addressed the copy-problem \nfrom Section 2.1, we now show how the flow at all instantiation sites is recov-erable in a completely \ndemand-driven fashion through the combination of flow and instantiation constraints. Suppose that we \ndemand to know where g3 flows. Drawing flow con- straint {gl _< g2} as a directed edge from gl to g2 \nand draw- ing instantiation constraints gl _+-g/\u00a33,g2 ~- \u00a34 for site i as dotted edges, we recover the \nflow from \u00a33 to g4 at instanti- ation site i by completing the following diagram, the lower dashed edge \nrepresenting the \"recovered\" flow constraint: ~1 ~ g2 : --+ V V \u00a33 .. _ ~. g4 Label \u00a33 represents the \nactual argument at call-site i and g4 represents the result at call-site i. Intuitively, there is flow \nfrom \u00a33 to \u00a34 because the argument flows into the identity function id to the formal gl, within the identity \nfunction to the return value g2, and back out of the identity function to the result \u00a34 at call site \ni. The flow is valid because the in-flow + and out-flow + agree on the instantiation site i. Note how \nthe negative (+) instantiation edge gl ~-t3 represents the flow of an actual to a formal, and the positive \n(-t-) edge g2 -~-ga represents the flow of the result to the call-site i. The polarities p E {+, +} on \ninstantiation edges indicate their flow direction (in-flow or out-flow). Negative + instantiation edges \nrepresent flow in the direction oppo- site the instantiation, whereas positive + instantiation edges \nrepresent flow in the direction of the instantiation. Polarities are assigned to instantiation constraints \nac-cording to the polarity of the \"source types\" of instantia- tions. In our example, \u00a31 occurs negatively, \n\u00a32 positively in the type int ~ --~ int ~ of id. Instantiation polarities were introduced in [FRD00b]. \nDisregarding polarities and interpreting instantiation constraints as bi-directional flow constraints \nresults in a complete loss of context-sensitivity. We have sketched how to recover the flow on-demand, \nusing only parts of the constraint systems needed for this query. This addresses the on-demand problem \nfrom Sec- tion 2.2. A further advantage of instantiation constraints, address- ing the second problem \nin Section 2.2, is that all flow is present in the constraint sets I and C obtained in a typ- ing judgment \nfor POLYFLOWcFL. Consider for example the flow of both value 0 (go) and 1 (t~) to formal parameter x \n(gl). We can recover such flow similarly to the flow above via gt ~+ g3 and gl ~_J+/5. As mentioned in \nSection 2.2, to recover such flow in copy-based systems, the entire typing derivation is required instead \nof merely the final judgment. 2.4 CFL-reachability How can we systematically recover global flow from \ninstan- tiation and flow constraints? As we will show in this pa- per, this is best formulated as Context-Free \nLanguage (CFL) [CI\"L<L I C, gl _< \u00a32 ~- gl _< \u00a32 [Id]  c ~ g < g [Refi] C~go<gl Ct-gl  <g2 [ ans] C \n~-go _< g2 Figure 4: Constraint relation teachability on a graph formed by flow and instantiation con- \nstraints (edges) and labels (nodes). Let us give the intuition behind this idea. We assume that in this \ngraph negative in- stantiation constraints are reversed and labeled with open- ing parentheses (i. Positive \ninstantiation edges are labeled closing parentheses )i, and flow edges with d. All flow paths in the \ngraph now spell words. For example, the path e3 &#38;gl &#38;g4 spells the word \"(id)i\". The invalid \nflow path ~3 &#38; ~1 --~ ~2 \"~'~')\" ~6 spells the word \"(id)j\" and corresponds to calling \u00b1d at in- \nstance i, but returning to instance j. Valid and invalid flow are distinguished by membership in a particular \nlanguage. For our example, the language contains the words (id)i and (jfl)j, but no others. In general, \nvalid flow paths are char- acterized by words with matching sets of parentheses. Spu- rious flow paths \nare simply not part of that language. Matched flow paths bear a close resemblance to the pre- cise interprocedural \nflow paths of matching call- and return sequences studied in [P~HS95] for the case of first order pro- \ngrams manipulating atomic data. In contrast to this work, our analysis allows context-sensitive tracking \nof the flow of values through any finite data-type, and it directly incor- porates finitely typed higher-order \nfunctions, since function types are just another kind of data-type in type-based anal- ysis. We note \nthat, in higher-order programs, a function symbol may occur in contexts that are not call sites and matched \nflow may not correspond to actual calls and re-turns. Well-matched paths are also used in [MR00], where \nan analysis is described for higher-order programs manipu- lating arbitrary structured data. However, \nthis analysis is context-insensitive, whereas the presence of polymorphism in our type system provides \nfor a form of context-sensitivity. On the other hand, we can only handle unbounded data- structures (such \nas lists) in an approximative way, as shown in Section 6. The reader is referred to Section 7 for more \ncomparisons with previous work. 3 Polymorphic subtyping with instantiation con-stralnts POLYFLOWcFL uses \npolymorphic types over labels of the form V~.a without qualifying constraints. Judgments have the form \nI;C;AI--CFL e:a C t- ,e~ _< .e2 [Int] C ~- int el < int t2 C~- a~ < a~ C ~- a2 < a' g _ _ 2 Ct-\u00a3< [Pair] \nC ~- a~ x~ a2 _< a~ x v o-~ C }- o'~ _< o'1 C e a2 _< a'~ C~-e_< g [~n] Figure 5: Subtype relation / \n~-~ ~ e' lint] I t- int t ~ int v 2 [Pair] I~-a~ x tcr2 L<~a~ x t'a~ ~p \u00a3 I ~ a~ ~ al I ~- ~r2 ~p 2 [Fun] \nFigure 6: Instantiation Relation shown in Figure 7. Here, I is a set of instantiation con-straints, \nC is a set of flow constraints on labels, and A is a type environment assigning types to free variables \nin term e. Such a judgment means that, under the assumptions con- tained in I, C and A, term e has labeled \ntype a. The subtyping rule [Sub] of Figure 7 uses standard logic, shown in Figure 4 and Figure 5, for \nflow judgments C ~ \u00a3 _< \u00a3' and subtyping judgments C I- a _< a', where C is a set of flow constraints \non labels, \u00a3 <_ \u00a3'. Type environment A contains two kinds of assumptions. One has the form A',f : (V/.a,~), \nwhere f is a let-or letrec-bound variable. Here, V/.a is the quantified type assumed for .f, and ~ is \na vector containing the labels that are free in X. The notation .fl(a) and fl(A) denotes the free labels \noccurring in a and A, respectively. The remaining type assumptions have the form A',x : a assigning (non- \nquantified) labeled types to A-bound variables. Rule [Let] binds a let-bound variable .f to a quantified \ntype, and rule [Rec] binds a letrec-bound variable .f to a quantified type. Notice that, in rule [Rec], \nthe quantified type is used in typing the term el in the letrec-binding, thereby allowing polymorphic \nrecursion over labels. In rule [Lam] and [Rec] we use the notation la[ to denote the un- derlying type \nthat arises from the annotated type a by eras- ing all label annotations from a. In rule [Lain] we require \nla[ = % i.e., a must have the same structure as r, and similarly in rule [Rec] for ax and v. An instantiation \nconstraint e ~ ~' states that \u00a3 instanti- ates to \u00a3' at site i with polarity p. Instantiation constraints \nrepresent substitutions at instantiation sites. A polarity p is either positive + or negative \u00f7, and \n~ negates the polarity of p. Sets of instantiation constraints are written I. Fig - ure 6 lifts instantiations \nto labeled types, where I ~ a ~ a' expresses that a instantiates to a' given I. Instaatiation constraints \nI must satisfy: for any partic- ular index i and any label \u00a3, one hasS: W'. e ~_~, ~' e I A e _~,, \u00a2' \n~ ; ~ e' = e\" (3) A constraint set I thus gives rise to a collection of substitu- tions ~i, indexed \nby instantiation site i, where ~o, (\u00a3) = \u00a3' if \u00a3 ~_~ g 6 I and the identity everywhere else. We use \nthe: notation to mean that given I, a instantiates to a ~ under ~ (i.e.,~(.) = ~'). Instantiation constraints \nare used in rule [Inst] in Fig- ure 7. From the assumption A, f : (Ve.a, \u00a3;) we derive the type a ~ for \nf at instantiation site i, provided that I~-a ~_ipa ' : ~ holds for some ~ with dora ~ = ~. Moreover, \nfor the labels \u00a3;, which are unquantifiable at the point of let- or letrec- binding, we require 4 I~-\u00a3; \n~. \u00a3; and I ~ ~ :<i+ ~; which have the effect that for all g in \u00a3;, there are constraints \u00a3' ~_ e' and \n\u00a3' ~. \u00a3' in I. In rule [Label], a[~] denotes the type a with top level label \u00a3. The rule allows a subterm \ne to be labeled with the top-level label of its type, so that flow queries on labels can refer to arbitrary \nsubterms in the program. The remaining rules of Figure 7 are standard type rules. 4 Flow relation This \nsection defines our flow relation and flow-graphs in- duced by typing derivations. The presence of instantiation \nconstraints in the subtyping system leads to a clean flow logic, which is implementable via CFL-reachability. \n4.1 Flow logic Given a derivation of I; C ~-CFL e : a, the flow graph G = (I, C, L) is defined by the \nset of labels L appearing in the derivation, along with the flow edges C and instantiation edges I. As \nwas explained in Section 1, we must recover flow from l~ to ~ in the following situation: \u00a31 ~2 ~i+ Y \nY e~ SThe reader familiar with semi-unification will note that this rule is enforced by the algorithm \nof [Hen93]. 4For ~ = l~ ..... t~ we write I b ~ ~ l \"7 as shorthand for I I- t i ! l$ ~--n tj, j = 1...n. \n   Ix; b; A t-CF ,: o-[ Base Rules I; C; A, x : a kCFt. x : a [Id] I; C; A FCFLn t : int t lint] I; \nC; A ~\u00a2FL el : a2 ._.~t o\"1 I; C; A &#38;CFL e2 : o'2 lapp] I; C; A }-CFL el e2 : O'1 I; C; A, x : a \n~-CFL e : a' Jo'[ = r,_ I; C; A t-CFL el : al I; C; A t-CFL e2 : a2 [Pair] ely T ;7 I; C; A }\"CFL e : \nal \u00d7~ a2 [Proj j = 1, 2] I; C; A KCFL r/ e : aj I; C; A }-CFL eo : int ~ I; C; A b'CFL el : a I; C; A \n}-CFL e: : q [Cond] I;C;A ~-CFL if eo then el else e2 : o\" I; C; A KCFL e : a C ~-a < ~' I; C; A KCFL \ne : a[\u00a3] [Label] I; C; A ~CFL e : o\" --[Sub] I;C;AKcFLe ~:a Polymorphic Rules I; C; A KCF L el : al \nI; C; A, / : (VZal, ~ FCFL e2 : o'2 [---- gen(A, al) t' = fl(A) [Let] I;C;A ~CFL let f = el in e2 : \no'2 I; C; A, / : (V[.al, ~7) }-CFL el : al I; O; A, f : (VZal, ~) ~CFL e2 : 0\"2 [= gen(A, al) ~ = fl(A) \nI(711= T [Rec]I;C; A ~CFLlesrec f:r = el in e2 : O\"2 i; C; A, f: (V[.a, ~) b-CFL /i: a' gen(A,a) = fi(a) \n\\ fl(A) Figure 7: CFL-Based System POLYFLOWcFL [I;CKcFLt~t] C ~ ~1 ~ ~2 2 [Levell I; C ~-tl ~-~p I, \nIi ~ t2; C b- tl \"-~,+ 12 [Out] I,&#38; ~_~+ 12; C ~-t2 \"~+ &#38; [In] I; C }- to ~p &#38; I; C F tl \n~p 12 [Trans ] I; C ~ to ~p t2 I; C F go ~p tz [Match] I; C }- go ~'~+ tl I; C }- gl \"~'+ t2 [Stage] \np---- -I-, +, m Figure 8: Flow relation for POLYFLOWcFL Our solution is given in Figure 8 axiomatizing \njudgments I; C PCFL ~1 ~ \u00a3~. This judgment means that, under con- straints I and C, there is valid flow \nfrom label el to \u00a32. Some flow paths only involve flow constraints in C and are deduced directly from \nC via rule [Level], i.e., if C ~-\u00a31 .~ \u00a3u is derivable, then we deduce flow from \u00a31 to e2. Internally, \nthe rules use auxiliary judgments of the form I; C I- ~1 *~'~+ e2, I; C b- \u00a31 \"~'~+ \u00a32 and I; C ~ \u00a31 \n\"~-~m \u00a32, which define posi-tive, negative and matched flow, respectively. Rules with an occurrence of \np are actually rule schemes for all rules ob- tained by selecting +,+ or m for p. Rule [Trails] encodes \ntransitivity for all auxiliary relations. Rule [Match] introduces matched flow, of the form I; C l- e* \n~'~m \u00a32, capturing that the sequence of instantiation edges traversed along a matched flow path forms \na well-parenthesized string, where ~ matches ~_. Matched flow allows us to recover, on demand, the flow \nrepresented by copies of constraint systems in constraint copying frarne- works. Matched flow avoids \nspurious flow paths that in-volve negative and positive instantiation edges from distinct instantiations. \nIn the first-order case, such paths correspond to spurious flow from one call site of a function ff to \nanother call site of f. The remaining rules [In], [Out], and [Stage] encode that some flow paths may \ncontain unmatched initial closing parentheses and unmatched final open parentheses. The un- matched parentheses \narise because a flow path may start and end in scopes other than the top-level scope of the program. \n4.2 CFL formulation We now formulate flow queries as a context-free language reachability problem (see \nfor example [MR97]). Given a flow graph G = (I, C, L), construct the graph GCFL with nodes L, and the \nfollowing labeled edges: tl ~ t2 if\u00a31~_\u00a32EI \u00a31 -~ \u00a32 \u00a32 --~ \u00a31 iftz_~ezElt2 ~ \u00a31 gl--~\u00a32 if ez <g2EC \n Edges with labels p (n) correspond to positive (negative) instantiation edges used in the [Out] ([In]) \nrule of the flow relation. Edges with labels (~ and )i correspond to the in- stantiation edges used in \nthe [Match] rule, and d-edges rep- resent flow constraints. A flow relation I; C bCFL \u00a31 ~ e2 is derivable \nvia rules of Figure 8 if and only if there exists a path in GCFL where the sequence of labels along the \npath from \u00a31 to \u00a32 is accepted by the following grammar with start symbol S: Productions for P accept \npaths that corresponds to positive S ~ PN P ~-- MP I PP N ~-- MN I nN M ~ (i M)i I MM I d I e flow I; \nC }- \u00a31 -~-~+ t2, productions for N produce negative flow paths, and productions for M produce matched \nflow paths. In practice, the graph GCFL need not be computed explic- itly. Instead, the graph closure \ncan be computed directly on the set of constraints C and I. 4.3 Examples Figure 9 shows the flow graph \nand the CFL-graph for an example program. Function idpa\u00b1r is the identity on integer pairs. It is instantiated \nat site i within f, which in turn is instantiated at site j. The top contains the flow graph G with flow \nand instan- tiation edges. The bottom contains the corresponding CFL graph GC~L where we omit the d labels \non flow edges. There is a flow path from b to z: where the flow from \u00a3b to \u00a31 forms a matched flow path \nthat is explicit in a system based on constraint copying. One advantage of using the type-based approach \nto flow analysis presented here is that it deals directly with higher- order programs. The type-theoretic \nnotions of polarity and contra-variance are essential here, and are exploited in our annotation of polarities \non instantiation edges. Appendix A contains an example (Figure 13) of a higher-order flow graph and its \nflow interpretation. Interestingly, the flow relation of [FRD00b] without sub- typing emerges by collapsing \nall M-productions to e, cor- responding to an equational interpretation of the subtype relation. The \nflow relation thereby becomes regular, and flow queries become linear time in the size of the flow graph. \nOur present results show that the addition of subtyping cor- responds to a passage from regular to context-free \nflow. 4.4 Soundness Soundness of our flow relation I; C ~CFL \u00a31 ~ \u00a32 is non- obvious and requires proof, \nwhich we provide in our tech- nical report [FRD00a]. To prove soundness we use a la-beled polymorphic \nsubtyping system called POLYFLOWccpy (we refer the reader to [FRD00a] for the definition). This system \nis similar to a standard copy-based system studied by Mossin in [Mos96]. It induces a flow relation, \ndenoted I-cp, which arises from the relation FCFL (Figure 8) by removing rule [Match]. The soundness \ntheorem states that our flow relation ~-CFL is a sound approximation to the relation ~\u00a2p. Since soundness \nhas been established for copy-based systems by Mossin [Mos96], soundness of our notion of flow follows. \nTechnically, we show Theorem 4.1 (Soundness) For every judgment I; C; A }-CFL e : a derivable in POLYFLOWcFL \nthere exist Co, Io, Ao such that the judgment Co; Io; Co; Ao ~ e : o\" is derivable in POLYFLOWcopyand \nsuch that, for all labels \u00a3 and ~' occurring in e one has Io; Co Pep ~ ~ t' ~ I; C ~c~L ~ ~ ~' let idpair \n= Ax:int x int.x in let f = Ay:int.idpair~ (ala,b \u00a3b) in let z = (~2 (fJ 0)) l\" X X y : y ~+ x ii =d \n+ ~ x ,/\\  t. ~b Y x i_% Flow graph G X X ~  p.. )~ . . . . :: :: ~y n X (i n P ).i X P \" )i .iV \n\\i/ ~a \u00a3b .~ //i\\iip i )j tl :.: : : P ::)j X Pi i)J CFL Graph GEFL Figure 9: POLYFLOWcFLexample  \nS +-- PN P e-- MP [ PP N ~ MN [ nN K~ +- M )~ M +- (iKi [ MM I d Figure 10: Grammar for CFL queries. \nThis theorem implies that, for any program typable in POLYFLOWcFL, the induced flow logic FCFL over-approximates \nthe induced relation ~cp of PO/YFLOWcopy. A core step in the proof consists in showing that our no- tion \nof CFL-based flow recovers all implicit substitutions ~o~ on constraint systems needed in copy-based \nderivations, as explained in Section 2.3. The presence of polymorphic re- cursion is a complicating factor \nfor the proof, and our proof uses ideas introduced in [Mos96]. Conversely, by turning label substitutions \ninto instanti- ation constraints, it is easy (tedious, but not difficult) to see that any typing in POLYFLOWeopygives \nrise to a typ- ing in POLYFLOWcFL such that the induced flow relation of POLYFLOWcFL is soundly approximated \nby the induced flow relation of POLYFLOWcopy. 5 Algorithm Let e be an explicitly typed program, and let \nn denote its textual size. Thus, n measures the size of the program text together with the type annotations. \nFurthermore, let m de- note the textual size of the type erasure of e (the type erasure of e arises from \ne by deleting all type annotations from e). Thus, m measures the size of e when type annotations are \ndisregarded. We show how to compute flow queries for a term e of type-erasure size m, and with type-annotated \nsize n. Our algorithm takes O(n 3) time for computing individual or all queries. In the worst case, the \nsize n is exponentially larger than m, although n will typically be close to m in practice [Mit96]. 5.1 \nConstraint derivation The type rules in Figure 7 directly serve as constraint in- ference rules. As is \nstandard for inference systems, the use of the subsumption rule [Sub] is restricted to the argument derivation \nin [App], the branches in [Cond], and the binding in [Rec]. Constraints are inferred at rules [Inst] \nand [Sub] by using the rules of Figures 6 and 4 in reverse, i.e., to obtain the conclusion, we generate \nthe constraints required by the antecedents. To guarantee the well-formedness of instantia- tion constraints, \nrule (3) must be enforced. After constraint derivation we produce the graph GCFL according to the description \ngiven in Section 4.2. W = edges of GCFL Go = for each production A e-e and node e add ~-~\u00a3 to W; while \nW not empty  remove edge e----\u00a31 -~\u00a32 from W;  (i) if e not in Go do add e to Go; for each rule r of \nthe form A~--B (2) add \u00a31 -~\u00a32 to W; for each rule r of the form A ~--B C add \u00a31 to predr(g2); for \neach \u00a33 in sucer(\u00a32)  (3) add \u00a31 ~\u00a3s to W;  end end for each rule r of the form A ~-C B add \u00a32 to SUCCr(\u00a31); \nfor each \u00a3o in predr(\u00a31 ) (4) add \u00a30 ~\u00a32 to W; end end endif end Figure 11: CFL algorithm 5.2 Cubic \ntime algorithm We follow [MR97, MR00] and normalize the grammar for the CFL problem such that the right \nhand sides of productions contain at most two symbols (terminals or non-terminais), resulting in the \ngrammar shown in Figure 10. The generic CFL-algorithm in [Ml:t97, MI~00] has worst case complexity O(]~13n3), \nwhere E is the set of terminals and non-terminais used. Our grammar has I~l = O(m). As is observed in \n[MR97, MR00], the generic upper bound of O([Elan 3) can be substantially improved in spe- cific applications \nby exploiting the properties of the gram- mars that arise. Thus, we can improve the upper bound O(mSn \na) by using the generic algorithm of Figure 11 and taking advantage of specific properties of our grammar. \nWe show that the algorithm runs in time O(n a) for the grammar in Figure 10. The proof of the following \ntheorem is given in Appendix B. Theorem 5.1 Given I, C, \u00a3, \u00a3', answering a flow query I; C FCFL \u00a3 ~ ~' \nis decidable in time O(n3). Moreover, the entire flow relation derivable from I and C is computable in \ntime O(nS). This result improves the best previously known algo- 8 3 rithm, given by Mossin [Mos96], \nfrom O(n ) to O(n ), when polymorphic recursion is included and from O(n r) to O(n 3) when it is not. \nThe gain is in both cases realized by avoiding repeated copies and simplifications of constraint sets, \nand also by avoiding iterating the inference to obtain ffixpoints for the polymorphic recursive type \nschemes. On termination, the algorithm produces a graph Go con- taining all possible edges labeled by \nnon-terminals of the (i :n p :! )~ \u00d7 X \u00a3a \u00a3b p i )i \u00a31 .:~ : ~:. \u00a3z Figure 12: Type polymorphic example \n grammar. To answer a query for flow from gl to \u00a32 we sim- ply need to inspect Go for an S-edge from \n\u00a31 to \u00a32. 5.3 Demand-driven algorithm Although the algorithm in Figure 11 is not directly demand- driven, \nthe CFL-formulation allows straight-forward adapta- tion of the technique in [HRS95, Rep98], yielding \na demand- driven algorithm. 6 Polymorphic and recursive type structure In this section we show that our \ntechniques remain effective, when the underlying types axe polymorphic and recursive. 6.1 Polymorphic \ntype structure POLYFLOWcFL type derivations are polymorphic in labels but not in the underlying type \nstructure. Extending poly- morphism to the underlying type structure results in more complicated flow \nqueries. Since type variables are instanti- ated to arbitrary labeled types at instances, flow paths \nthat traverse a type polymorphic function may involve travers- ing type constructor edges from child \nto parent and back. Consider the example from Figure 9, but with idpair being the polymorphic identity \nfunction, instead of the identity on integer pairs. The resulting type instantiation graph is shown in \nFigure 12. We use h ~ for labels annotating type variable c~. The flow path from \u00a3b to \u00a3z has the form \n\u00a3b [x2> ]x2> x -~2+ h? ---4 h~ ~ \u00d7 \u00a31 -2+\u00a3z and involves traversing constructor edges between pair types \nand their right child. We label constructor edges with the constructor c and the child index j. Traversing \nsuch an edge from child to parent corresponds to an opening paren- thesis It#, and traversing from parent \nto child corresponds to a closing parenthesis ]c#. At first sight, the resulting flow queries appear \nto involve interleaved matchings of instanti- ation parentheses and constructor parentheses. In general, \nin the presence of unbounded data structures such as lists, interleaved matchings define the intersection \nof two context free languages, and flow-relations induced from them be- come undecidable by a recent \nresult of l:teps [Rep00]. In the absence of recursive types however, polymorphic type structure is bounded \nand guarantees that there always ex- ists a flow path where the two matchings are perfectly nested (this \nfollows abstractly from the fact that the intersection of context-free language and a regular language \nis context- free). As a result, the path is given by a single context-free grammar, and all flow queries \nremain computable in O(n 3) time. Our observations above show that bounded type struc- ture can generally \nbe exploited to eliminate the interleaved matching problem. This may, however, come at the cost of approximating \nthe flow relation when unbounded data structures are present, as we will discuss next. 6.2 Recursive \ntypes l:tecursive types represent regular infinite type structure. The most general labeling of such \nstructures involves in- finitely many distinct labels. The undecidability result of Keps [Rep00] suggests \nthat there exists no partial labeling without loss of precision. However, we can use regular la-belings \nof recursive types, where labels repeat in recursive unfoldings. Such labelings introduce spurious flow \nbetween unrelated parts of the recursive type but enable us to com- pute a finite and sound approximation \nof the interprocedural flow. This technique again amounts to exploiting bounded type structure (which \nin the case of recursive types is im- posed by approximation) to eliminate the interleaved match- ing \nproblem. Our report [FRD00a] has more details. 77 Related work Mossin [Mos96] studies the problem of \ninterprocedural flow computation with polymorphic subtyping including poly- morphic recursion. His system \nis based on constraint copy- ing and simplification. Our techniques improve the asymp- totic complexity \nof flow computations and obviates the need to copy and simplify constraints during inference. We prove \nsoundness by reduction to the soundness of the system stud- ied by Mossin. In [Mos98], Mossin describes \ntype-based, higher-order value flow graps. In this work, it is noted that it would be desirable if type-based \nflow graphs could be used to express well-matched flow paths in the style of [l:tHS95] (see below). Our \nwork shows that, indeed, this is possible. Our use of instantiation constraints draws on Henglein's work \non semi-unification [Hen93]. Dussart et. al. [DHM95a] present a copy-based algorithm for binding time \nanalysis us- ing subtyping and polymorphic recursion. The unpublished work [DHM95b] seeks a solution \nin terms of semi-unification. Our work shares motivation with [DHM95b] but our main results on matched \nflow and CFL-reachability are new. The work of Reps, Horwitz and Sagiv [1~HS95, MR00] provided the connection \nbetween CFL-reachability problems and interprocedural, context-sensitive analysis. The work [RHS95] concerns \ncontext-sensitive (interprocedurally pre- cise) analysis of first order programs manipulating atomic \ndata. Well-matched paths are used to select interproce- durally valid call-return sequences. The work \n[MR00] con- tains a higher-order but context-insensitive analysis. Well- matched paths are used for data-dependence \nanalysis, i.e., to model cancellation properties of data constructors and de- structors to track the \nflow of data through data-structures. Reps [l~ep00] has shown that the combination of the two techniques \n-context-sensitive data-dependence analysis -results in an uncomputable analysis problem. In contrast, \nour type-based techniques concern context-sensitive (in the sense of type polymorphism) analysis of higher-order \npro- grams manipulating possibly structured data of finite type. Unbounded data-structures can be incorporated \nvia finite approximation using recursive types. The techniques of [HKS95, Rep98] for answering flow queries \non demand trans- fer to our setting via our CFL-reachability formulation. By incorporating subtyping, \nthe present paper provides a substantial generalization of [FRD00b], where we describe a flow analysis \nwith instantiation constraints but without subtyping. In this setting, CFL-reachability specializes to \nlinear-time graph teachability. In Lackwit [OJ97], O'Callahan and Jackson define a re- lation called \ncompatibility. Compatibility is undirected and can be understood as a special case of our flow relation, \nsimilar to the one in [FRD00b]. Heintze and McAllester [HM97] present a demand-driven, type-based flow-analysis \nfor ML. Like ours, their analysis traces flow paths on type graphs, but flow paths are not context-sensitive. \nGustavsson and Svenningsson [GS00] have recently de- veloped a usage analysis with polymorphic subtyping \nus-ing constraint abstractions to succinctly represent constraint systems. It is possible that their \nconstraint abstractions could be used to obtain flow analysis with properties similar to ours. 8 Conclusion \nWe have presented an O(n ~) algorithm for computing context-sensitive, directional flow information for \nhigher- order programs (n is the size of the typed program). This substantially improves on the best \npreviously known )(n s) algorithm. Our technique is based on a novel presentation of polymorphic subtyping \nwith instantiatiou constraints. We thereby applied CFL-reachability techniques to the setting of type-based \nand higher-order flow analysis with structured data of finite type. Unbounded data-structures can be \nin- corporated via finite approximation using recursive types. A novel aspect of our techniques is that \nthey obviate the need to copy constraint systems globally, and they support demand-driven flow computation \nover a clean, graph-based abstraction. This may turn out to be a major benefit of our approach in practice. \nAcknowledgements We would like to thank David Melski and Tom Reps for valuable discussions concerning \ncontext-free language reach- ability. We would also like to thank Fritz Henglein for dis- cussions on \npolymorphic recursion. Finally, we would like to thank our reviewers for their detailed comments on this \npaper.  References [AWP97] A. Aiken, E.L. Wimmers, and J. Palsberg. Op- timal representations of polymorphic \ntypes with subtyping. In Proceedings Theoretical Aspects of Computer Software, pages 47-77. LNCS 1281, \n1997. [Curg0] [DHM95a] [DHM95b] [EST95] [FA96] [FF971 [FFA00] [FM89] [FRD00a] [FRD00b] [GS00] [Hei951 \nP. Curtis. Constrained quantification in poly- morphic type analysis. Technical Report CSL- 90-1, Xerox \nParc, 1990. Dirk Dussart, Fritz Henglein, and Christian Mossin. Polymorphic recursion and subtype qualifications: \nPolymorphic binding-time analy- sis in polynomial time. In Proc. 2nd Int'l Static Analysis Symposium \n(SAS), LNCS 983, 1995. Dirk Dussart, Fritz Henglein, and Christian Mossin. Polymorphic recursion and \nsubtype qualifications: Polymorphic binding-time analy- sis in polynomial time. Unpublished draft, May \n1995. J. Eifrig, S. Smith, and V. Trifonov. Sound poly- morphic type inference for objects. In Proceed-ings \nOOPSLA '95, 1995. M. F~hndrich and A. Aiken. Making set-constraint program analyses scale. In Workshop \non Set Constraints, Cambridge MA, 1996. C. Flanagan and M. Felleisen. Componential set-based analysis. \nIn Programming Language Design and Implementation, June 1997. Jeffrey S. Foster, Manuel F~hndrich, and \nAlexander Aiken. Polymorphic versus monomor- phic flow-insensitive points-to analysis for c. In Proceedings \nof the 7th International Static Anal- ysis Symposium, June 2000. Y. Fuh and P. Mishra. Polymorphic subtype \ninference: Closing the theory-practice gap. In Proc. Int'l J't Conf. on Theory and Practice of Software \nDevelopment, pages 167-183, March 1989. M. F~hndrich, J. Rehof, and M. Das. From polymorphic subtyping \nto CFL reachability: Context-sensitive flow analysis using instan-tiation constraints. Technical Report \nMSR-TR-99-84, Microsoft Research, 2000. Available at http://research.microsoft.com/~rehof/pub - lications.html. \nM. F~ihndrich, J. Rehof, and M. Das. Scalable context-sensitive flow analysis using instantia- tion constraints. \nIn Programming Language De- sign and Implementation, June 2000. J. Gustavsson and J. Svenningsson. A \nusage analysis with bounded usage polymorphism and subtyping. In Proceedings of the 12th Inter- national \nWorkshop on Implementation of Func- tional Languages, number AIB-00-7 in Aach-ener Informatik Berichte, \npages 279-294. RWTH Aachen, 2000. N. Heintze. Control-flow analysis and type sys- tems. In Proceedings \nSAS '95, Second Inter- national Static Analysis Symposium, Glasgow, Scotland, pages 189-206. Springer \nLecture Notes in Computer Science, vol. 983, September 1995. [Hen93] [HM97] [HRS951 [Kae92] [Mit96] [Mos96] \n[Mos98] [MR97] [MR00] [Myc84] [NNH99] [OJ97] [PO95] [Pot96] [Reh97] Fritz Henglein. Type inference with \npolymorphic recursion. ACM Transactions on Programming Languages and Systems, 15(2):253-289, 1993. Nevin \nHeintze and David McAllester. Linear-time subtransitive control flow analysis. In Pro-ceedings of the \n1997 A CM SIGPLA N Conference on Programming Language Design and Imple- mentation, number 32:6 in SIGPLAN \nnotices, pages 261-272, June 1997. Susan Horwitz, Thomas Reps, mad Mooly Sa- giv. Demand interprocedural \ndat~ow analysis. In ACM SIGSOFT Symposium on the Founda- tions of Software Engineering, ACM SIGSOFT Software \nEngineering Notes P0, 4, pages 104- 115, 1995. S. Kaes. Type inference in the presence of over- loading, \nsubtyping and recursive types. In Proc. Conf. on LISP and Functional Programming, 1992. J.C. Mitchell. \nFoundations for Programming Languages. MIT Press, 1996. Christian Mossin. Flow Analysis of Typed Higher-Order \nPrograms. PhD thesis, DIKU, De- partment of Computer Science, University of Copenhagen, 1996. Christian \nMossin. Higher-order value flow graphs. Nordic Journal of Computing, 5:214-234, 1998. David Melski and \nThomas Reps. Interconvert-ibility of set constraints and context-free lan- guage reachability. In Proceedings \nPEPM, pages 74-89, 1997. David Melski and Thomas Reps. Interconvert-ibility of set constraints and context-free \nlan- guage reachability. Theoretical Computer Sci- ence, 248, 2000. To appear. A. Mycroft. Polymorphic \ntype schemes and re- cursive definitions. In Proceedings of the 6th In- ternational Symposium on Programming, \npages 217-228, 1984. F. Nielson, H. Nielson, and C. Hankin. Princi-ples of Program Analysis. Springer, \n1999. Robert O'Callahan and Daniel Jackson. Lack-wit: A program understanding tool based on type inference. \nIn International Conference on Software Engineering, May 1997. Jens Palsberg and Patrick O'Keefe. A type \nsystem equivalent to flow analysis. Transac-tions on Programming Languages and Systems, 17(4):576-599, \nJuly 1995. F. Pottier. Simplifying subtyping constraints. In International Conference on Functional Pro- \ngramming, 1996. J. Rehof. Minimal typings in atomic subtyp- ing. In Symposium on Principles of Program- \nming Languages, 1997. [Reh98] J. Rehof. The Complexity of Simple Subtypin9 Systems. PhD thesis, Dept. \nof Computer Sci-ence, University of Copenhagen, Denmark, April 1998. [Rep98] Thomas Reps. Program analysis \nvia graph reachability. Information and Software Technol-ogy, 40 (11-12):701-726, 1998. [Rep00] Thomas \nReps. Undecidability of context-sensitive data-dependence analysis. Transac-tions on Programming Languages \nand Systems, 2000. to appear. [RHS95] Thomas Reps, Susan Horwitz, and Mooly Sa- giv. Precise interprocedural \ndataflow analysis via graph teachability. In Symposium on Prin- ciples of Programming Languages (POPL), \nSan Francisco, California, pages 49-61, 1995. [Smi94] G. S. Smith. Principal type schemes for func- tional \nprograms with overloading and subtyping. Science of Computer Programming, 23:197-226, 1994. [TS96] V. \nTrifonov and S. Smith. Subtyping constrained types. In Proceedings Static Analysis Sympo- sium, Aachen, \nGermany, 1996. LNCS 1145. IVan903 Mihalis Yannakakis. Graph-theoretic methods in database theory. In \nProceedings of the 9th A CM Symposium on Principles of Database Systems, pages 230-242, 1990. Higher-order \nexample Figure 13 shows a higher-order example. The app function takes a function f as an argument and \nreturns a function (labeled g~) that in turn takes a parameter x and applies :f to The figure shows the \nflow graph resulting from applying app at instance i to the identity function \u00b1d (instance j) and value \nb. We have used boxes around labels annotating function types to make the type structure more readable. \nFirst note that we can determine what functions are called indirectly within app, by observing what labels \nflow to g/. There is a path showing that the identity function (labeled ~d) flOWS to e/. The flow edges \nconnecting the types labeled by \u00a3s and g9 arise from the subtype relation between the instance of \u00b1d \n(the argument) and the domain of the instance of app. The reversed edge gl _< \u00a32 arises through contra-variance \nof the subtype relation for function domains. Edge \u00a3x _< g0 represents the argument passing of x to f \nwithin app, and similarly, g6 _< \u00a37 represents the flow of the result of this application to the result \nof the function labeled g~. The flow path connecting b with w is then as follows: Observe how the path \nenters app through instance i and then emerges back along the edge go -~ i1 The polarity of this edge \nwas determined to be positive, because the polarity of the argument type g f within the type of app is \nitself negative. The path then traverses \u00b1d on instance j and reenters app at instance i through before \nfinally emerging along the edge \u00a37 -h+ The example shows that in the higher-order case, the traver- \nsal of an instantiation edge does not correspond directly to an argument passing or return step as in \nthe first-order case. In this example the path traverses app twice through instance i. B Complexity proof \nConstraint generation produces a flow constraint set C of size O(n), and an instantiation constraint \nset of size O(mn). The m factor in the size of I is a direct result of the extra instantiation constraints \nadded on free labels at rule [Inst]. Without these, we generate only O(n) instantiation con-straints. \nOur technical report [FRD00a] shows a variant of the algorithm presented here, producing only O(n) con-straints. \nConstraint generation can be implemented in time pro- portional to the number of derived constraints. \nThe only non-obvious steps are in rules [Let] and [Rec], where we avoid using gen(A, crl) to find the \nquantifiable labels and avoid recomputing the vector ~ = fl(A). The first problem is solved with an extra \nsubsumption step on al _< a~ guar- anteeing that all labels in a~ are fresh. Binding this type in place \nof al allows instantiation of all labels occurring in a~ at all instances. As for the second problem, \nlabels ~ can be accumulated incrementally in the abstraction rule [Lam] once and for all. The details \nof this are standard and can be found in [FRD00a]. Grammar 10 has m terminals (~,)i and m non-terminals \nKi, since the number of distinct instantiations i is linear in the program size and independent of the \ntype size. Theorem 5.1 Given I, C, g, g', answering a flow query I; C FCFL g ~ g is decidable in time \nO(na). Moreover, the entire flow relation derivable from I and C is computable in time O(na). PROOF: \nThe proof is in two steps. We first give a suboptimal bound to show that the generic algorithm in Figure \n11 com- putes all derivable paths in time O(en + un 2 + bna). Here e is the number of epsilon productions, \nu is the number of dis- tinct unary grammar productions of the form A +- B, and b is the number of distinct \nbinary grammar productions of the form A ~ B C. Applied to our particular CFL problem (grammar of Figure \n10) where e = 3, u = 1, and b ---- 2m, we obtain an initial complexity of O(mn 3) for computing all pairs \nreachability. In the second step we tighten the com-plexity to O(n 3) by exploiting the particular structure \nof constraints generated by POLYFLOWcFL. let app = (Af.(Ax. f x)L~) t\"pp in let id = (Ay.y) rid in let \nw = ((app~ idJ) t'~ bib) t~' to g~ g= 7 gv i g3 ! A ! A i : : ~ ~P (~ )~ Figure 13: Higher-order example \n(only relevant edges shown) We assume that given an edge labeled B, we can index through B the rules \nr that apply in the for-loops without looking at rules that don't apply. The algorithm uses a work list \nW and adds edges to the result graph Go. For each node g and each production r of the form A ~ B C of \nthe grammar, we use two sets pred~ (g) and suecr(\u00a3 ) containing the predecessors of g reachable via an \nedge labeled B, and the successors of g reachable via an edge labeled C. Step 1. To see that the bound \nO(en + un 2 + bn 3) holds, consider that the number of steps needed to add all edges for epsilon-productions \nis en. Now consider the statement labeled (2) in the algorithm. For a fixed unary rule r and node gl, \nthis statement is executed at most n times, since the test at (1) guarantees that we see each edge at \nmost once. There are u rules and n nodes gl, thus the overall number of executions of statement (2) is \nun 2 times. Next consider the statement labeled (3) in the algorithm dealing with productions of the \nform A ~ B C. For a particular node g2 and particular binary production r, this statement is executed \nat most n 2 times, because there are at most n distinct predecessors in pred,(g2) and n distinct successors \nin succr(g2) that can be paired up. The test at (1) guar- antees that we never add a node twice to a \nbucket predr or suce~. Since there are b distinct productions and n distinct nodes g2, we obtain the \nbound O(bn3). The argument for productions of the form A ~ C B is analogous. The overall complexity bound \nof the algorithm is thus O(en+un 2 +bn3). Step 2. The complexity bound given above can be tight- ened \nby considering t~ and b to be the average number of grammar rules that apply at any particular node. \nIn that case it doesn't matter what the number of overall distinct grammar rules are. The complexity \nis solely determined by the average number of rules that apply at each node. The overall complexity improves \nin the case where u and b axe constant at each node, but the productions are drawn from a non-constant \nset of distinct productions (in our case, there are 2m distinct productions). As an example consider \nthe family of O(m) productions of the form M ~-(i Ki. If we can bound the average number of edges labeled \n(i on all nodes in our initial flow graph by a constant, then on average only a const~mt number of productions \nof the form M ~-(i Ki apply at any node. This hinges on the fact that the algorithm does not add any \nnew edges labeled with terminals (i. If we discount the instantiation self-loops of the form .<i g \"P> \ng added through rule [Inst] for the moment, we ob- tain the desired bounds on b. On average at any label, \nonly a constant number of productions apply. However, the num- ber of self-loops added through rule [Inst] \nis O(m) per label in the worst case. Fortunately, the complexity analysis for general binary rules given \nabove can be tightened due to the self-loop. Consider rule M +- (i Ki, when applied to a self-loop. The \nsituation is as follows: ..--~ K i '.,,., For a fixed g and fixed i, the number of times this rule triggers \nis at most n, since there are at most n labels g' connected to g via an edge Ki. Since there are at most \nm such self-loops on g and n distinct labels g, the number of executions of line 3 in the CFL algorithm \ninvolving self- loops is bounded by O(mn2). The same argument applies to K~ +- M )i, thereby proving \nthe cubic bound of the theorem. []    \n\t\t\t", "proc_id": "360204", "abstract": "We present a novel approach to scalable implementation of type-based flow analysis with polymorphic subtyping. Using a new presentation of polymorphic subytping with instantiation constraints, we are able to apply context-free language (CFL) reachability techniques to type-based flow analysis. We develop a CFL-based algorithm for computing flow-information in time O(<i>n</i>&amp;sup3;), where <i>n</i> is the size of the typed program. The algorithm substantially improves upon the best previously known algorithm for flow analysis based on polymorphic subtyping with complexity O(<i>n</i><sup>8</sup>). Our technique also yields the first demand-driven algorithm for polymorphic subtype-based flow-computation. It works directly on higher-order programs with structured data of finite type (unbounded data structures are incorporated via finite approximations), supports context-sensitive, global flow summariztion and includes polymorphic recursion.", "authors": [{"name": "Jakob Rehof", "author_profile_id": "81100614854", "affiliation": "Microsoft Research, One Microsoft Way, Redmond, WA", "person_id": "P131488", "email_address": "", "orcid_id": ""}, {"name": "Manuel F&#228;hndrich", "author_profile_id": "81100288438", "affiliation": "Microsoft Research, One Microsoft Way, Redmond, WA", "person_id": "P187043", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/360204.360208", "year": "2001", "article_id": "360208", "conference": "POPL", "title": "Type-base flow analysis: from polymorphic subtyping to CFL-reachability", "url": "http://dl.acm.org/citation.cfm?id=360208"}