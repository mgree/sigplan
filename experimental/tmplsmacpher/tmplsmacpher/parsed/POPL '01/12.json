{"article_publication_date": "01-01-2001", "fulltext": "\n A Generic Type System for the Pi-Calculus Atsushi Igarashi Naoki Kobayashi Department of Graphics and \nComputer Science Department of Information Science Graduate School of Arts and Sciences Graduate School \nof Science University of Tokyo University of Tokyo email:igarashi@graco.c.u-tokyo.ac.jp email:koba@is.s.u-tokyo.ac.jp \nAbstract We propose a general, powerful framework of type systems for the ~r-caiculus, and show that \nwe can obtain as its in- stances a variety of type systems guaranteeing non-trivial properties like deadlock-freedom \nand race-freedom. A key idea is to express types and type environments as abstract processes: We can \ncheck various properties of a process by checking the corresponding properties of its type environ- ment. \nThe framework clarifies the essence of recent complex type systems, and it also enables sharing of a \nlarge amount of work such as a proof of type preservation, making it easy to develop new type systems. \n1 Introduction 1.1 Motivation Static guarantee of the correctness of concurrent programs is important: \nBecause concurrent programs are more complex than sequential programs (due to non-determinism, dead- \nlock, etc.), it is hard for programmers to debug concurrent programs or reason about their behavior. \nA number of advanced type systems have recently been proposed to analyze various properties of concurrent \npro- grams, such as input/output modes [27], multiplicities (how often each channel is used) [17], race \nconditions [4, 6], dead- lock [14, 18, 30, 38], livelock [16], and information flow [8, 10]. Unfortunately, \nhowever, there has been no satisfactorily general framework of type systems for concurrent program- ming \nlanguages: Most type systems have been designed in a rather ad hoc manner for guaranteeing certain specific \nproperties. The lack of a general framework kept it difficult to compare, integrate, or extend the existing \ntype systems. Also, a lot of tasks (such as proving type soundness) had to be repeated for each type \nsystem. This situation stands in contrast with that of type systems for functional program- ming languages, \nwhere a number of useful analyses (such as side-effect analysis, region inference [36], and exception \nanalysis [3, 26]) can be obtained as instances of the effect analysis [34, 35]. Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for profit or commercial advan-tage and that copies bear this \nnotice and the 'lull citation on the first page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior specific permission and/or a fee. POPL '01 1/01 London, UK \n&#38;#169; 2001 ACM ISBN 1-58113-336-7/0110001 ...$5.00 The goal of this paper is therefore to establish \na gen-eral framework of type systems for concurrent processes, so that various advanced type systems \ncan be derived as its instances. As in many other type systems, we use the ~r-calculus as a target language: \nIt is simple yet expressive enough to model modern concurrent/distributed program- ming languages.  \n1.2 Main Ideas A main idea of the present work is to express types and type environments as abstract \nprocesses. So, a type judg- ment F ~ P, which is normally read as \"The process P is well-typed under \nthe type environment F,\" means that the abstract process F is a correct abstraction of the process P, \nin the sense that P satisfies a certain property (like race- freedom and deadlock-freedom) if its abstraction \nF satisfies the corresponding property. (In this sense, our type system may be regarded as a kind of \nabstract interpretation [2].) We define such a relation F ~ P by using typing rules. Because we use a \nmuch simpler process calculus to express type envi- ronments than the r-calculus, it is easier to check \nproperties of F than to check those of P directly. To see how type environments can be expressed as abstract \nprocesses, let us review the ideas of our pre-vious type systems for deadlock/livelock-freedom [16, 18, \n33]. Let x![yl,...,y,@P be a process that sends the tu-pie [yz,..., y~] along the channel x and then \nbehaves like P, and z?[yl,... ,y~]. Q be a process that receives a tuple [zz,..., zn] along x, binds \nyz,..., y,~ to zz,..., z,~, and then behaves like Q. Let us write P[Q for a parallel execution of P and \nQ, and 0 for inaction. In our previous type sys- tems [18, 33], the process P --x![z][x?[y], y![] [ z?[]. \nz?[]. 0 is roughly typed as follows: x: [[]/o]/(Ol/), z: []/(OlZ.O P Types of the form [rl ..... Tn]/U \nare channel types: The part It1,..., rn] means that the channel is used for commu- nicating a tuple of \nvalues of types 7\"1,..., ~'n, and the part U (called a usage) expresses how channels are used for in- \nput/output. For example, the part O[I.I of the type of z means that z is used for output (denoted by \nO) and for two successive inputs (denoted by I.I) in parallel. By focusing on the usage parts, we can \nview the above type environment as a collection of abstract processes, each of which performs a pair \nof co-actions I and O on each channel. Indeed, we can reduce the type environment by canceling I and \nO of the usage of x and obtain x: [[]/O]/O,z: []/(0[I.I), which is a type environment of the process \nz![] I z?[]. z?[]. O, obtained by reducing P. By further reducing the type environment, we obtain x: \n[[]/O]/0, z: []/I, which indicates that an in-put on z may remain after P is fully reduced. Based on \nthis idea, we developed type systems for deadlock/livelock- freedom [16, 18, 33]. We push the above \n\"type environments as abstract processes\" view further, and express type environments as CCS-like processes \n(unlike in CCS [22], however, we have no operator for hiding or creating channels). The type environment \nof the above process P is expressed as X![T]. z![r']{x? M. 0 I z?[~' ]. Z?[T']. 0. It represents not \nonly how each channel is used, but also the order of communica- tions on different channels, such as \nthe fact that an out-put on z occurs only after an output on x succeeds (as indicated by the part x! \n[r]. z! [~\"]). The parts enclosed by square brackets abstract the usage of values transmitted through \nchannels. Thanks to this generalization, we can rea- son about not only deadlock-freedom but also other \nprop- erties such as race conditions within a single framework. The new type system can also guarantee \ndeadlock-freedom of more processes, such as that of concurrent objects with non-uniform service availability \n[30, 31].   1.3 Contributions Contributions of this paper are summarized as follows: We develop a \ngeneral framework of type systems, which we call a generic type system -- just as a generic func- tion \nis parametrized by types and can be instantiated to functions on various arguments by changing the types, \nthe generic type system is parameterized by a subtyp- ing relation and a consistency condition of types \nand it can be instantiated to a variety of type systems by changing the subtyping relation and the consistency \ncondition.  We prove that the general type system satisfies several important properties (such as subject \nreduction), inde- pendently of a choice of the subtyping relation and the consistency condition. Therefore, \nthere is no need to prove them for each type system.  We show that a variety of non-trivial type systems \n(such as those ensuring deadlock-freedom and race-freedom) can indeed be derived as instances of the \ngen- eral type system, and prove their correctness.  1.4 The Rest of This Paper Section 2 introduces \nthe syntax and the operational se-mantics of our target process calculus. Section 3 presents our generic \ntype system and shows its properties. As its instances, Section 4 derives a variety of type systems and \nproves their correctness. To further demonstrate the strength of our framework, Section 5 shows that \ndeadlock and race conditions of concurrent objects can also be ana- lyzed within our generic type system. \nSection 6 describes preliminary results of our ongoing studies on the power of our generic type system. \nSection 7 discusses limitations and extensions of our generic type system. Section 8 discusses related \nwork and Section 9 concludes this paper. For the space restriction, we omit some technical details in \nthis ex- tended abstract. They are found in the full paper [11]. 1 2 Target Language 2.1 Syntax Our calculus \nis basically a subset of the polyadic 7r-calculus [23]. To state properties of a process, we annotate \neach input or output operation with a label. Definition 2.1.1 [processes]: The set of processes is de- \nfined by the following syntax. P (processes) ::= OlOl+.\"+a= I(PIQ) I (vxl .... , z.) P { ,P G (guarded \nprocesses)  ::= xrt[yl, ...,y~]. el x?t[yl,.. ,y,]. f Here, x, y, and z range over a countably infinite \nset Var of variables, t ranges over a countably infinite set T of labels called events. We assume that \nVat n T = O. Notation 2.1.2: We write .~ for a (possibly empty) se-quence xz,..., x,~, and 11.~1[ for \nthe length n of the sequence ~. (v\u00a31) '\" (u\u00a3~) P is abbreviated to (T~z..~) P or (~) P. As usual, ~ in \nx?[~]. P and .~ in (v~) P are called bound vari- ables. The other variables are called free variables. \nWe as- sume that a-conversions are implicitly applied so that bound variables are always different from \neach other and from free variables. The expression [zz/~l,..., z~/x~]P, abbreviated to [~/~]P, denotes \na process obtained from P by replacing all free occurrences ofxt,..., x~ with zl,  , zn. We often omit \nthe inaction 0 and write zlt[~] for x!t[.~]. 0. When events are not important, we omit them and just \nwrite ~el [~]. P and x?[~]. P for x!t[~]. P and x?t[~]. P respectively. We give a higher precedence to \n+ and (v:~) than to 1. The meanings of 0, x!t[~]. P, x?t[~]. P, and P IQ have already been explained. \nG1 + \" + G~ (where Gz,..., G,~ are input or output processes) denotes an external choice: It behaves \nlike one of G1,..., G,~ depending on enabled com- munications. (u~)P creates fresh channels ~ and then \nex- ecutes p.2 .p denotes infinitely many copies of P running in parallel. 2.2 Operational Semantics \nAs usual [23], we define a reduction semantics by using a structural relation and a reduction relation. \nFor technical convenience, we do not require the structural relation to be symmetric. The reduction relation \nP ----+ Q is annotated with a term of the form z t't' or e t'\u00a2. The term records on which channel and \nevents the reduction is performed: It is used to state properties of a process in Section 4. Definition \n2.2.1: The structural preorder -5 is the least re- flexive and transitive relation closed under the rules \nin Fig-  ure 1 (P --- Q denotes (P .5 0) ^ (Q -5 P)). Definition 2.2.2: The reduction relation ~ is \nthe least relation closed under the rules in Figure 2. 1 Available from ht~p://www,yl. is. s. u-tokyo, \nae. j p/'koba/publica~ioas .html. 2This is operationally the same as (vxl) \". (uz~) P, but we dis- tinguish \nthem in the type system given in Section 3.  PIO-=P (SPCONG-ZERO) (v~) P IQ _~ (v~) (P] Q)(if &#38; \naxe not free in Q) (SPCoNG-NEw PIQ=-QIP (SPCoNG-COMMUT) P .5_ P' Q ~ Q' P ] Q ..~ P' I Q' (SPCoNG-PARPI(Q] \nR)_= (PIQ) IR (SPCONG-ASSOC) (SPCoNG-CNEw(v~) P :< (v~) Q  19 ~ *PIP (SPCONG-REP) P_~Q  Figure 1: Structural \nPreorder . p--~-~Q PIR--L+QIR t,t I P ~ Q y e (~} ~t,t t (v~) P ------4 (v~) Q . . . . . +~!~[~].P+ I. \n(R-PAR) (R-NEwl) .~- Ii~? t~ ~ . . . z t't~ . [y].Q+ ----~PI[~/$]Q t I P--L-rQ (l=et'\u00a2')Y(l=y t' Ay\u00a2 \nP ~_P' (v~) P ~ (v$) Q p, '>Q, Q'~Q p _L.~ Q {~}) (R-COM) (R-NEw2) (R-SPCONG) Figure 2: Reduction Relation \n Notation 2.2.3: We write P ) Q if P --J-r Q for some I. Notation 2.2.4: When 7~1,7~2 are binary relations \non a set S, we write 7~ for the reflexive and transitive closure of 7~1, and 7~1T~2 for the composition \nof 7~1 and 7~e. 3 Generic Type System 3.1 Types As explained in Section 1, we extend ordinary type \nenviron- ments and express them as abstract processes. In the rest of this paper, we call them process \ntypes (or, just types in short). For most of the process constructors introduced in the previous section, \nthere are the corresponding construc- tors for process types. We use the same symbols for them to clarify \nthe correspondence. Definition 3.1.1 [types]: The sets of tuple types and pro- cess types are defined \nby the following syntax. -r (tuple types) ::= (xl,...,x,)r F (process types) ::= o I ~ I~1 +--\" + 7. \nI (r, Its) I r~r: I ~.r ::= x!~[~], r I x?~[~], r I t.r Here, the metavariable oL ranges over the set \nof type vari- ables. Notation 3.1.2: The tuple type (:~)F binds the variables in F. We assume that a-conversions \nare implicitly applied so that bound variables are always different from each other and free variables. \nIn this paper, we restrict the syntax of tuple types so that (~)F does not contain any free variables \nor free type variables. (It is possible to remove this restric- tion: See Section 7.) We write [~/~]r \nfor a process type obtained by substituting .~ for all free occurrences of :~ in F. We write *F for/zo~.(r \nI o0. We often omit 0 and write xlt[7 \"] and x?t[~ -] for xlt[~']. 0 and X?t[T]. 0 respectively. We also \nabbreviate x[*[( )0]. r and x?t[( )0]. F to xlt[]. F and x?t []. F respectively. We assume that #a.r \nbinds a in F. We write [F/a] for the capture-avoiding substitution of F for a. We write Null(F) if F \ndoes not contain a process type of the form x?t[T], rl or Mt[~-]. rl. When .r = (:~)r, we call [1~[[ \nthe arity of T and write [Ir[I. The tuple type (xl,... ,x,~)F is the type of an n-tuple, whose elements \nxl,..., xn should be used according to F. 0 is the type of the inaction, xIt[~']. F is the type of a \nprocess that uses x for sending a tuple of type r, and then behaves according to r. The output on x must \nbe tagged with t. Similarly, x?tM. F is the type of a process that uses x for receiving a tuple of type \nT, and then behaves according to F. For example, if a process should have type x? tl []. y!*2[]. 0, then \nx? tl []. yltz [] is allowed but neither y!t2 []. x?~l[]. 0 nor x? tl[]. 0 1 ylt2[] is. In this way, \nwe can express more precise information on the usage of channels than previous type sys- tems [17, 18, \n27]. t.F is the type of a process that behaves according to r after some action annotated with t (which \nis an input or an output action on some channel) occurs. 3 F1 I F2 is the type of a process that behaves \naccording to F1 and r2 in parallel. The type 3'1 + \"\" + 7, represents an external choice: A process of \nthat type must behave ac- cording to one of 71,..., %~, depending on the communica- tions provided by \nthe environment. On the other hand, the type Fi&#38;F2 represents an internal choice: A process of that \ntype can behave according to either F1 or r2, irrespectively of what communications are provided by the \nenvironment. For example, the process type xIt[], y!t' [ ]~,:y!t' []. :r,!t [] means that x and y can \nbe used sequentially for output in any or- der; So, both xlt []. ylt'[] and ylt'[], xlt[] can have this \ntype. 4 3Instead of t.F, we could introduce process types t?.r and tl.F to distinguish between input \nand output actions. We do not do so in this paper for simplicity. 4So, rl&#38;r2 is similar to an intersection \ntype F1 A r2. The differ-ence is that a value of type Fi~F2 can be used only once according to either \nF1 or r2. We use the standard notation #a.F for recursive types. For example, #c~.(x?tH. a) is the type \nof a process that uses x for receiving a tuple of type r repeatedly. Notice that, unlike the ~r-calculus \nprocesses in Sec-tion 2, the process types contain no operators for creating fresh channels or passing \nchannels through other channels. Thanks to this, we can check properties of types (as abstract processes) \nmore easily than those of the Ir-cMculus processes. Instead, we have some operators that do not have \ntheir coun- terparts in processes. A process type of the form t.F plays an important role in guaranteeing \ncomplex properties like deadlock-freedom. For example, we can express the type of (vz) (x? tt []. y!t2 \n[] [ y?ta []. O) as t l.y!t2 [] ] y?t3 [], which im- plies that the output on y is not performed until \nan action labelled with tt succeeds. Since actually it never succeeds, we know that the input from y \nis kept waiting forever. 3.2 Subtyping We introduce a subtyping relation Pl _< F2, meaning that a process \nof type Pl may behave like that of type F2. For example, Fi&#38;F2 < F1 should hold. The subtyping relation \ndepends on the property we want to guarantee: For example, if we are only concerned with arity-mismatch \nerrors [7, 37], we may identify t.r with F, and x!t[r]. F with ,!*[,11 r, but we cannot do so if we are \nconcerned with more complex properties like deadlock-freedom. Therefore, we state here only necessary \nconditions that should be satisfied by the subtyping relations of all instances of our type system. We \nneed some auxiliary operations. Definition 3.2.1: Let S be a subset of Var. Unary opera- tions F$ s and \nFJ\" s on process types are defined by: OSs = 0 O@S = O~ { =?'[~1. (r,s) ifxES (z?'[r]. r),~ s = t.(P,~s) \notherwise { ~!~[-1. (r,l.s) ifxE S   (~!*[~]. r),l.s = t.(FSs) otherwise (t.r)$s = t.(r+s) (71 +-.. \n+'r,).l.s = ('n.l.s) +'.\" + ('r,..l.s) (rl [P=),t.s = (rl,s) l(r=,s) (rl~r~)J,s = (rl,s)~(r2,~s) o~.r)$s \n= t,~.(r.l.s) P'l's = PSv.~\\s F$s extracts from r information on the usage of only the channels in S, \nwhile FTs extracts information on the usage of the channels not in S. Example 3.2.2: Let F = y?t[r']. \nM\u00a2[r']. O. Then r.~{~} = t.x!\u00a2[r]. 0 and FJ'(~} = y?t[r], t'.0. Definition 3.2.3 [subtyping]: A preorder \n< on process types is a proper subtyping relation if it satisfies the rules given in Figure 3 (F1 '~ \nF2 denotes F1 <_ F2 A F2 _< F1). In the rest of this paper, we assume that _< always de- notes a proper \nsubtyping relation. We extend _< to a sub- typing relation on tuple types by: rl < r2 if and only if \nthere exist ff:,F1, and F2 such that rl = (.~)F1, r2 = (:~)F2, and Fx < F2. The axiom FSslFts <_ F allows \nus to forget in-formation on dependencies between some channels. For example, if F = y?t It,]. x!t' [-r']. \nO, then F J,(=} [ FT(=} = t.M\u00a2[r].Oly?t[T].t'.0 is a subtype of F. Notice that F$(~} I FJ'{~} expresses \na more liberal usage of x, y than F: WhiIe F means that z is used for output only after y is used for \ninput, F${~} I FT{~} only says that z is used for output after some event t, not necessarily an input \nfrom y. 3.3 Reduction of Process Types We want to reason about the behavior of a process by in- specting \nthe behavior of its abstraction, i.e., process type. We therefore define reduction of process types, \nso that each reduction step of a process is matched by a reduction step of its process type. For example, \nthe reduction of a process is matched by: for 7- = (z)z!t2[]. As is the case for reductions of processes, \nwe annotate each reduction with information on which chan- nel and events are involved in the reduction. \nDefinition 3.3.1: A reduction relation F1 ---+ F2 on pro- cess types (where L C TO{x t''t2 I (x e Var)A(tl, \nt2 e T)}) is the least relation closed under the rules in Figure 4. We write F ---4 F' when F ~ F' for \nsome L. 3.4 Consistency of Process Types If a process type is a correct abstraction of a process, we \ncan verify a property of the process by verifying the corre- sponding property of the process type. When \na process type satisfies such a property, we say that the process type is con-sistent. The consistency \ncondition depends on the property we require for processes. So, we state here only necessary conditions \nthat every consistency condition should satisfy. Consistency conditions for specific instances are given \nin Section 4. Definition 3.4.1 [well-formedness]: A process type P is well-formed, written WFF(F), if \nthere exist no x, rl, r2, tl, t2, rl, F2, and F3 that satisfy the following conditions:  L r-# ...+~!*ltrll.rl+... \nI ...+~?\"[r2l.r~+... Iv3. 2. rl ~ rz. Remark 3.4.2: We could replace the first condition with \"F contains \nX!tx[Tx] and x?t2[r2], \" which can be checked more easily. We do not do so, however, to allow maximal \nflexibility of type systems. Under the above condition, we can allow process types like x? t' [ri]. x! \nt~ [r2]l x! t3 [ri]. x? ta [r2], which allows x to be used for first communicating a value of type rx, \nand then for com- municating a value of type r2. Definition 3.4.3 [consistency]: A predicate ok on pro-cess \ntypes is a proper consistency predicate if it satisfies the following conditions: rl0-~r rz I P~ ~ F2IF1 \n r~ I(r: Ira) ~ (r, I r~) I r~ ,~.r _~ [,~.r/~]r F<F' *F < *F' (SuB-EMPTY) (SuB-COMMUT) (SUB-ASSOC) (SuB-REc) \n(SuB-ICHOICE) (SuB-REP) Pl Ira _< rl ItS ~ _< ~ for each i e {1,..., ~} -y~ +...+~, _< v~ +... +,/ F<F' \nPSs -< P'$s r<_r' [y/~]r < [y/~lr'  (r~s [rrs) _< r Figure 3: Necessary Conditions on Subtyping Relation \nrz <r2 .. + =!~,[~]. r, +... I. + =?'~[~]. r~ +... (=-52) r~ Its rl L,> p~ r2 --~ r~ r ~ r (TER-SKIP) \nr, [r~ ~'~= rl ItS (SuB-PAR) (SuB-CHOICE) (SuB-RESTRICT) (SuB-SUBST)   (SuB-DIVIDE) (TER-CoM)  (TER-PAR) \n .. + t.P +... {t}> r (TER-Ev) Fz < rl rl L > r~ r~ _< r= (TER-SuB) F1 L> I'2 Figure 4: Reduction \nof Process Types 1. If ok(F), then WF(F). 2. If ok(F) and F > F', then ok(F'). 3. If ok(Fz) and Null(r~), \nthen ok(Fz IF2)  In the rest of this paper, we assume that ok always refers to a proper consistency \npredicate. Because process types form a much simpler process cal- culus than the 7r-calculus, we expect \nthat the predicate ok is normally much easier to verify than the corresponding property of a process. \nThe actual procedure to verify ok, however, depends on the definition of the subtyping relation <_ : \nIf we are not interested in linearity information [17], we can introduce the rule F [ F ~ F so that the \nreductions of a process type can be reduced to a finite-state machine. But if we take _< to be the least \nproper subtyping relation, we need to use a more complex system like Petri nets, as is the case for our \nprevious type system for deadlock-freedom [18]. 3.5 Typing A type judgment is of the form F~P, where \nF is a closed (i.e., containing no free type variables) process type. It means that P behaves as specified \nby F. Typing rules are given in Figure 5. The rules (T-PAR), (T-CHOICE), and (T-REP) say that an abstraction \nof a pro- cess constructed by using a process constructor [, +, or * can be obtained by composing abstractions \nof its subpro- cesses with the corresponding constructor of process types. The key rules are (T-OuT), \n(T-IN), and (T-NEw). Note that channels can be dynamically created and passed through other channels \nin the process calculus, while in the calculus of process types, there are no corresponding mech- anisms. \nSo, we must somehow approximate the behavior of a process in those rules. In the rule (T-OuT), we cannot \nexpress information that [~] is passed through x at the type level. Instead, we put [~/~]F2, which expresses \nhow the channels ~ are used by a receiver, into the continuation of the output action. In the rule (T-IN), \ninformation on how received chan- nels .~ are used is put into the tuple type (9)(F${~t). Be-cause we \nwant to keep only information on the usage of .~, we apply \"${~9} to remove information on the usage \nof the other variables. Information on the usage of the other vari- ables is kept in the continuation \nFt{uz ..... u~t of the input ac- tion. For example, consider a process x? tl [y]. y?t2 []. z!tS []. Its \nsubprocess y?t2 []. z!ta[] is typed under the process type y?t2 []. z!t3 []. 0. By applying (T-IN), we \nobtain the following type judgment: x?tZ [(y)y?t~ []. t3.01, t2.z! t3 [1' 0 > x?t~ M\" Y?'~ []' z!~3 [] \nNotice that the parameter type (y)y?t2 []. ta.0 of the channel x carries only information that some event \nt3 occurs after y is used for input, not that z is used for output. On the other hand, the continuation \npart t2.z!ta[]. 0 says just that z is used for output only after some event t2 occurs. In the rule (T-NEw), \nwe check by the condition ok(F$(~}) that ~ are used in a consistent manner, and forget inform-at-ion \non the use of ~ by \"T(~}.  3.6 Properties of the Type System The general type system given above is \nparameterized by the subtyping relation <_ and the consistency predicate ok, OttO F i ~ P~ F 2 ~, P~ \nr~ Ir~ ~-Ol I~ Ft>P *F ~ *P F't~P F < F ~ F~P (T-ZERO) (T-PAR) (T-REP) (T-SuB) 7i t~ Gi for each i \nE {1,... ,n} 7a +\"\" +% ~G1 +... +G,~ F1 c,P ~t[(#)V~]. (V, I [~/.~]r2) ~ ~*[~]. P Ft~P z?t[(fi)(r~(~})].(r?~})~z?t[~].P \n  r>P ok(r$(~}) (T-CHoICE) (T-OUT) (T-IN) (T-NEw) Figure 5: Typing Rules which determine the exact \nproperties of each instance of the type system. As we show below, however, several impor- tant properties \ncan be proved independently of a choice of the subtyping relation and the consistency predicate. In particular, \nwe can prove that if F > P holds, F is a correct abstraction of P in the sense that P satisfies a certain \nin- variant property if F satisfies the corresponding property (Theorem 3.6.2). Type Preservation We \ndefine a mapping l # from labels of process reductions to labels of type reductions by: (xt1't2) # ~-(X \ntl't2} and (etl ,t2 )# = {tl, t2 }. The following theorem guarantees that if F t~ P holds, for every \nreduction of P, there is a corre-sponding reduction of F. Theorem 3.6.1 [subject reduction]: If F~ P \nand P _L+ Q with WF(F), then there exists F ~ such that F -~+ F' and r'~Q. As a corollary, it follows \nthat a process satisfies a certain invariant condition p if the process type of P satisfies the corresponding \nconsistency condition. Theorem 3.6.2: Suppose p(P) holds for any F such that F ~. P and ok(F). If F ~ \nP and ok(F), then p(Q) holds for every Q such that P --+* Q. Proof: By mathematical induction on the \nlength of the reduction sequence P ~ ... ~ Q, using Theorem 3.6.1 and the fact that ok is preserved by \nreduction. D  Normalization of Type Derivation The normal derivation theorem given below is useful for \nstudying a relationship between a process and its process type, and also for developing type-check/reconstruction \nal- gorithrns. We write P t~v P if F > P is derivable by using (T-SuB) only immediately before (T-IN) \nor (T-OuT). Theorem 3.6.3 [normal derivation]: If Ft~P, then F~N P for some F ~ such that F < F *. Proof: \nThis follows from the fact that each application of the rule (T-SuB) above a rule except for (T-IN) and \n(T-OUT) can be permuted downwards. [] As a corollary, it follows that if a process is trying to perform \nan input action, its process type is also trying to perform the corresponding action. (A similar property \nholds also for output.) Corollary 3.e.4: Ifr~(~l..k) (...+y?t[~]. p+... ]Q) and ok(F), then the following \nconditions hold. 1. If y \u00a2 {\u00a3t,...,:~k}, then F _< ... + y?t[~.].F1 +... [ F2 for some %F1, and Fz. \n2. If y e (:~l,...,:fk}, then F < .-. + t.r~ +... Ir2 for some Ft and F2.  Conversely, if a process \ntype obtained by normal deriva- tion is trying to perform some action, the process is also trying to \nperform the corresponding action. Theorem 3.6.5: 1. If \"\" + t.F1 + \"\" IF2 ~lv P, then P --~ (~l..k)(y?t[~].QIR) \nor P -'4 (~x..~)(y!t[~].Q[R~, with y e (:f~,..., :fk}. 2. If ... + y?t[r].F1 + ... IF2 tan P, then P \n(~l..k) (y?.t [~]. Q iR) with y \u00a2 {nil ...., ~k}.  Proof: Trivial by the definition of F t~N P. O Type \nCheck/Reconstruction By using Theorem 3.6.3, we can also formalize a common part of type-check/reconstruction \nalgorithms: By reading the typing rules in a bottom-up manner, we can develop an algorithm that inputs \na process expression and outputs a set of subtype constraints and consistency conditions on process types \n(see Appendix A). A process is typable if and only if the set of constraints output by the algorithm \nis satisfiable. Thus, to develop a type-check/reconstruction algorithm for each instance of our type \nsystem, it suffices to develop an algorithm to solve constraints on process types. Such algorithms have \nalready been developed for specific type systems [12, 18]. 4 Applications We show that a variety of type \nsystems --those for arity- mismatch check, race detection, deadlock detection, and static garbage-channel \ncollection -- can indeed be obtained as instances of the generic type system. Thanks to the com- mon \nproperties in Section 3.6, only a small amount of extra work is necessary to define each instance and \nprove its cor- rectness. The invariant properties of well-typed processes that the type systems should \nguarantee are shown in Table 1. The condition pl (P) means that no arity-mismatch error occurs immediately. \n(So, if Pl is an invariant condition, no arity- mismatch error occurs during reduction of P.) pz(P) means \nthat P is not in a race condition on any output actions annotated with t. p3(P) means that P is not deadlocked \non any actions annotated with t in the sense that when- ever P is trying to perform an action annotated \nwith t, P can be further reduced, p4(P) means that after a channel has been used for an input action \nannotated with t, it is no longer used. So, it is safe to deallocate the channel af- ter the action annotated \nwith t. For example, the process (~,z) (x! t~ [] [x!t~[] [ x?t3[], x?t[]. 0) satisfies this property. \nTable 2 shows the consistency condition for each type system, ok2(F) means that no race occurs on output \nactions annotated with t during reductions of the abstract process F. okz(F) means that whenever F is \nreduced to a process type trying to perform an action annotated with an event t ~ less than or equal \nto t, F can be further reduced on some channel or on an event less than t ~. (Here, we assume that is \nsome well-founded relation on events, and t ~ t ~ means t -.~ t' or t = tl.) ok4(F) means that, after \nF has been reduced on an action involving a channel x and the event t, the reduced process type no longer \nperforms an input or output action on the same channel. Let _< be the least proper subtyping relation. \nWe can prove the following type-soundness theorem for all of the above type systems. By Theorem 3.6.2, \nit suffices to show that F~P and oki(F) imply pi(P) for each i, by using The- orems 3.6.3-3.6.5 (see \nAppendix B.2). Theorem 4.1: Let ok be ok~ (i E {1,2,3,4}). If FoP and ok(F), then pi(Q) holds for every \nQ such that P >* Q. Actually, < can be any proper subtyping relation ex- cept for the case i = 3. Choosing \nan appropriate subtyping relation for each type system would simplify type-checking or type-reconstruction. \nFor example, in the above type sys- tems, we can identify t.F with F by the rule t.F ~ P, except for \nthe case i = 3. For a naive arity-mismatch check [7, 37], we can ignore the order of communications by \nintroducing rules like x?t[r], r ~_~?t[.] I r. The following examples indicate that our framework not \nonly subsumes many of the existing type systems but also provides more powerful type systems than them \n(see also Section 5). Example 4.2: The process x?[y], z?[]. 0 [x![w]. x![] is well typed in the first \n(i = 1) type system. So, unlike in ear- lier type systems [7, 37] for arity-mismatch check, the same \nchannel can be used for communicating values of different types. 5 Example 4.3: The second type system \nguarantees that the process (ul,:~) (l!t\u00b0[]l*l?t'[].x!t[]. lira[]Ix?t4[/. 0) is race-free on the channel \nx. So, unlike the linear r-calculus [17], our type system can guarantee lack of race conditions even \non channels that are used more than once. 6 5Yoshida's type system [38] also allows such use of channels. \n6Flanagan and Abadi's type system [4] also gives such a guarantee. Because their target calculus has \nlocks as primitives, the problem is a little simpler. Example 4.4: The third type system rejects the \npro- tess P = (w)(~U)(~?~[].U!~[llY~*=[].~!~[l). The type of the sub-process x? [].y!'[]ly?t2[].x!t3[] \nis x?t[].y!t'[] [y?t2[].x!ta[]. So, in order for P to be well- typed, the following constraints must \nbe satisfied: Oks(X.Tt[].tl.0lt2.x!t3[])  oks(t.y! ~* [] I y?~ []. t3.0) The former constraint requires \nthat t2 -~ t (because the in- put from x succeeds only after the event t~ succeeds), while the latter \nrequires that t ~ t2, hence a contradiction. Remark 4.5: A type environment in a usual type sys-tem corresponds \nto the equivalence class of a process type with respect to the relation ~ derived from an appropri-ate \nsubtyping relation. (Recall that F1 ~ F2 is defined as F1 _< F2 A Fz < F1.) For example, the type environment \nz: [[]/0]/(010 , z: []/(OlI.I ) given in Section 1 corresponds to the equivalence class of a process \ntype  z!t[(y)y!t[]l lz?t[(y)y!t[]l lz!t[] lz?t[], z?t[], with respect to ~ that satisfy the rules x!t[r]. \nI ~ ~ x! t' [~-]. F, =V[~].r _~ =?\"[~].r, t.r _~ r, and (rss Iris) ~ r. The last rule removes information \non the order of communica- tions between different channels. A type environment of the linear 7r-calculus \n[17] is obtained by further removing infor- mation on channel usage, by adding the rules x!t[~-]. F .~ \nx!t[~']l F, x?t[~'].F -~ x?~[~'] IF, and rlr ~ .r. A type en- vironment of the input-only/output-only \nchannel type sys- tem [27] is obtained by further adding the rule *F ~ F. 5 Further Applications: Analysis \nof Race and Deadlock of Concurrent Objects The type systems for race- and deadlock-freedom, presented \nin the last section, are indeed powerful enough to guarantee some useful properties about concurrent \nobjects. In essence, a concurrent object is regarded as a set of processes that provides a collection \nof services (e.g., methods) [13, 19, 29], just as a sequential object is a set of functions. Clients \nrefer to an object through a record of channels that represent locations of those services. Hence, by \ngiving an appropriate type to the record, we can enforce a certain protocol that clients should respect. \nSince our type system can capture, in particular, temporal dependency on the utilized services, it is \npossible to guarantee race-freedom of accesses to methods, studied by Abadi, Flanagan and Freund [4, \n6], and deadlock- freedom for objects with non-uniform service availability, studied by Puntigam [30]. \nNote that, so far, these properties have been discussed only for languages with primitive notion of objects. \nThis section demonstrates how our type system can guarantee these properties. We first describe race-free \naccesses to methods. For ex- ample, the following process waits for a request on newob, and upon receiving \na request, creates an object with a lock l, a method m to print out the string \"Hello, \" appended to \na given string, and a channel r to receive a reply from the method, and exports its interface [l, m, \nr/through the reply channel r r. *newob? [r']. (ul, m, r) ( l!t' [] I .mr e [s]. ~i~t! ~' [\" Hello, \"]. \nr~i~t! ~' [s]. r!e[] There exist no ~1 ..... Zk, x, ~, ~, t, t', Qi, Q2, and Qs such that P _~ (~l..k) \n('\" +x!t[}]. Q~ +'\" I '\" \"+ pl(P) x?t,[z~].Q 2 +\"\" ]Qs) with I]~H # IIz~]l. There exist no x, dl, ..., \n~,~, z, w, t', Q1, Q2, Q3 such that pz(P) p ~ (~x.., 0 (... +z!t[~].Q~ +... [ \"'\" + ~clt'[~] .Q2 +\"\" \n[Qs). If there exist ~,...,/,~, y, ~, Q_,Rp such that, ~ [R) or P (~1..,0 (\"' Pp_ (~L.,~) (\"\" +y?t[~].Q+\"\" \n~ +ps(P) y!t[~]. Q +... [ R), then P ..> for some ------~-----+* Q, then there exist Q1,Q2 such that \nQ ~ (~d) (... + x?[.~]. Q1 +... [Q2) or Q ~ (~) (... + xl[~]. Q1 +'\" I Q2). p4(P) For any t', x, w~, \n.. ., uT,~, P', and Q, if P --~*~ (~l..n)P' and P' ~\u00a2'* no Table 1: Properties of Processes okl(r) WF(r) \nWF(F), and there exist no x, t', ~'1, ~'2, F1, F2, F3 such that F .... ~* \"\" \u00f7x!t [~-1]. F1 +\"' I\"\" \u00f7 \n~c!t' [~'2]. F2 + ok2(r) ... [rs. wF(r), and ift' ~ t, F ---~* F' and F' is ... + y?t'[~'].F1 + .-. \nIts or... + y!~'[~].rl + ... Ir~ for some oks(r) y, ~', t', Fi, F2, then F' ---+ F\" for some L and F\" \nsuch that (i) L = {x t''t2 } or (ii) L = {t'} and t\" ~ t'. WF(F), and for any z, t', and F', if F ----+*-----\u00a2. \nF', then there exist no T, F t, F2 such that F' ----\u00a2-* ok4(r) .. + x?\u00a2'[~l.rx +... I r2 or r' ---~* \n... + x!t\"[~].ra +... IF2. Table 2: Consistency Conditions Since the method m should not be invoked simultaneously, \nr clients should acquire and release the lock l before and after the invocation of m, respectively. Indeed \nby using ok2, it is guaranteed that there are no simultaneous outputs to m: The exported interface [l, \nm, r] (through which clients access to the object) can be given a type: t I t I (L, m, r) * ~?t' []. \nm!t[st~g], r? []. l! [], where *F abbreviates/zc~. (O&#38;(F I c0), meaning that the tuple can be used \naccording to F by arbitrarily many processes. (Here, we assume that the subtyping relation <_ satisfies \nt.F ~ F.) Then, a client /?t' []. ralt [,, Atsushi\"]. r?t' []. l! t' [] I/?t' []. m! t [\" Naoki\"]. r?t'[]./!t' \n[] is well typed, but m!t[\"Atsushi\"].r?t'[]..., is not. The above type of the interface roughly corresponds \nto the object type [m : ~(l)String --+ Unit. {/}. +] of Abadi and Flana- gan's type system [4], which \nmeans that the method m can be invoked only after the lock on the object is acquired. Similarly, we can \nexpress non-uniform service availability in our type system. For example, this is a process that creates \na one-place buffer: newbuf? [r]. (vput, get, b) ( b![] I *b?[]. put?[x], get?[r']. (r'![x] l b![]) It! \n[put, get]) Now, two methods put and get are provided but they are available only alternately. By using \noks, we can guaran-tee that invocations of the methods put and get never get deadlocked. The interface \n[put, get] can be given a type: (put, get)~.(0&#38;(p~t! t [~] I ~.get! t [(r)r! ~[~]1. ~.~)), which \nsays that an output to put must come in paral-lel to or before an output to get. (Here, \u00a2x~.F abbrevi- \nates #c~. (F&#38;tl .c~&#38;... &#38;t,~.c~) where {tl,..., t,~} is the set of 7We do not want an output \nlike \"Hello Hello \" events occurring in the program. It means that it is allowed to wait for arbitrary \nevents before using the value according to F.) Then, both put!t[v]l(vr) get!tit], r?[x]. - and put! \nt [v]. (vr) get! t [r]. r?[z].... are well-typed (and hence never get deadlocked on put! and get!) while \n(vr')geW[r']. r'?[x], putlt[v]..., is not. 6 Towards a General Type Soundness Theorem In Section 3.6, \nwe have shown that a process satisfies a cer- tain property p if its process type satisfies the corresponding \nconsistency condition ok. However, it was left to the de-signer of a specific type system to find a consistency \ncondi- tion that corresponds to a process property of interest and prove that the correspondence is indeed \ncorrect. In fact, in Section 4, we had to find a suitable consistency condition on process types and \nprove its correctness (Theorem 4.1) for each type system. Also, there remains a general ques- tion about \nthe power of our generic type system: What kind of type system can be obtained as an instance? Clearly, \nnot all properties can be verified in our type system: For exam- ple, the property \"a process can create \nat most n channels\" cannot be verified, because process types contain no infor-mation on channel creation. \nThis section gives a partial answer to those questions: For a certain class of properties of processes, \nthere is indeed a systematic way for obtain- ing the corresponding consistency condition ok on process \ntypes, so that the instantiated type system is sound. For lack of space, details are omitted: They are \nfound in the full paper [11]. We first introduce logical formulas [1,32] to formally state properties \nof processes and types. Definition 6.1: The set Prop of formulas is given by the following syntax (i, \nj denote variables ranging over the set Nat of non-negative integers and n denotes a non-negative integer \nor a variable ranging over Nat): A ::= tt Ix!tnlx?tnl (AIB) I (l)AI ev(A) C ::= I -,A I AV B I 3x.A I \nBt.A I 3i: C.A {i~#j~,...,i~#jk} A formula A describes a property of both processes and types. Intuitively, \nx!tn means that some sub-process is ready to output an n-tuple on the channel x and that the output is \ntagged with t. Similarly, x.Ytn means that some sub-process is ready to input an n-tuple. The formula \nA [ B means that the process is parallel composition of a process satisfying A and another process satisfying \nB. (l)A means that the process can be reduced in one step to a process satisfying A and that the reduction \nis labelled with l. ev(A) means that the process can be reduced to a process satisfy- ing A in a finite \nnumber of steps, s As a property of processes, the formal semantics [Alp r of each formula (i.e., the \nset of processes satisfying the formula) is defined by (Proc is the set of processes and FV(A) is the \nset of free variables in A): 9 [tt]p r = Proc ~X]t'n']pr : {P I P ~ (~'~L.k) (\"' + x!t[~]. Q +'\" I R), \n= \u00a2 {~,,..., ~}, IlYll = ~} [x?tn]pr = {P I P ~ (~l..k) ('\" + x?t[~]. Q +\"-I R), [A I B]pr = {P ] P ~ \n(~l..k) (QI R), Q [A]p~, R [B]p,, {:~,..., :Ek} N FV(A IB) = O} [(/)A]p,={Pl P Z~Q,Q ~A]p~} [ev(A)] \nm. = {PIP )* Q, Q ~A]pr} ~-,A]pr = Proc\\Hp~ Similarly, a formula can be regarded also as a property \nof process types (Type is the set of process types): ~ttLy = Type ~!:~]t, = {r I r < ... + ~!t[~]. zx~ \n+... la~, IM = ~} EAIB]t~={r I r <_-(a~ la=),a~ [Airy,a2 [B]ty} I(l)A]ty = {r I r ~ l # &#38;,A [d]t \n} [ev(m)]ty = {F [ F ----~* a, a lAity } [~A]ty = Type\\lAity We can show that for any negative formula \nA defined below, a process P satisfies A (i.e., P [A]pr) if its process type F satisfies the same formula \nA. Our type system is there- fore sound at least for properties described using negative formulas. Definition \n6.2 [positive/negative formulas]: The set .~+ (~-, resp.) of positive (negative, resp.) formulas are \n81nstead, we could introduce a general fixed-point operator [32]. 9Formally, [Alp r is parameterized \nby an assignment of variables to non-negative integers: See the full paper [11]. the least set satisfying \nthe following rules: tt ~+ f7.) r- x!t n, x.Tt n .~+ A,B Y r+ A IB, A V B, (1)A, ev(A),3x.A, 3t.A,3i:C.A \n Y:+ A, B Y:- ~ A V B, 3x.A, 3t.A, 3i : C.A yr- A yr+ ~ -~A yr - A yr-~-,A yr + Theorem 6.3: Suppose \nF t> P and WF(F). If A E .T'- and F lAity , then P [Alp r holds. Conversely, if A .T \"+ and P ~A]pr, \nthen F lAity holds. Proof sketch: This follows by induction on the structure of A. The cases for (1)A \nand ev(A) follow from Theo- rem 3.6.1 and the cases for x!tn, x.Tt?z, and A I B follow from Theorem 3.6.3 \nand Corollary 3.6.4. The other cases follow immediately from the definitions of [Alp r and lAity. [] \nCorollary 6.4 [type soundness]: Let A E .T'-and P be a closed process. Suppose that ok(F) implies F E \nlAity. Suppose also that F ~ P and ok(F). Then, if P ----4\" (~) (v~) Q, then (~) Q e ~A]pr. Intuitively, \nthe last sentence of the above corollary means that all the channels created during reductions of P are \nused according to A. The corollary implies that, in order to guarantee that property, it suffices to \ndefine the consis- tency condition ok by ok(P) ~ WF(P) A inv(A) (where inv( A ) = -,ev(-,A ) ). The type \nsystems for lack of arity mismatch, race detec- tion, garbage-channel collection discussed in Section \n4 can be automatically obtained by using the above corollary: For example, in the case of arity-mismatch \ncheck, we can let A be -~ev(3x.3t, t'.3i, j : { i ~ j}.(x!t i l x?t'j)). In the case of race detection, \nwe can let A be -,ev(3x.St'.Si, j:O.(x!tilx!t'j)). We can also obtain a variant of the linear channel \ntype sys- tem [17]. Let m be -,3x.3tz, t2, ta.3n.ev((x t''t2)ev(x!t3n V x?t3n)); Then it is guaranteed \nthat every channel is used ~t most once. Note that our type system is sound also for some non- negative \nformulas: Indeed, the deadlock-free property is not described as a non-negative formula, but our type \nsystem is still sound as proved in Appendix B.2. It is left for future work to identify a larger class \nof properties for which our type system is sound, and obtain a general type soundness theorem (like Corollary \n6.4 above) for that class. 7 Limitations and Extensions Although a variety of type systems can be obtained \nas its instances, our generic type system is of course not general enough to obtain all kinds of type \nsystems. There are two major sources of limitations of our type system: One is the way in which processes \nare abstracted, and the other is the way the consistency condition ok on types is formalized. Limitations \ncaused by abstraction Because information on channel creation is lost in process types (recall the rule \n(T- NEW)), we cannot obtain type systems to guarantee proper- ties like \"at most n channels are created.\" \nWe can overcome that limitation to some extent, by introducing a process type new~.F, which means that \nthe process behaves like F after creating k channels. Some information is also lost in the rule (T-IN): \nBecause information on the usage of bound channels (expressed by F.I.{.~} ) is put into the continuation \nof an output process and that on the usage of free channels (expressed by FJ\" ~7 ) is () put into the \ncontinuation of the input process, the causal- ity information between communications on bound channels \nand those on free channels is lost. We can improve the type system by removing the restriction that tuple \ntypes can-not contain free variables (Notation 3.1.2) and changing the rule (T-IN) into the following \nrule, to allow an arbitrary de- composition of information on the usage of bound and free channels: P~P \nF1 I C~ _< r Fv(r2) n {~9) = \u00a2 This kind of extension is necessary to account for some exist- ing type \nsystems like Abadi and Flanagan's type system for race detection [4]. In fact, the analysis of race discussed \nin Section 5 works only when the lock l and the other interfaces m and r are created simultaneously and \npassed together; Otherwise, dependencies between the usage of l, m and r are lost. To get rid of such \nrestriction, the above extension of the rule (T-IN) and an extension of the rule (T-NEw) discussed in \nthe next paragraph is necessary. Limitations caused by the formalization of ok To obtain common properties \nuseful for proving type soundness (in Sections 3.6 and 6), we required that the consistency con- dition \nok must be an invariant condition (recall Defini- tion 3.4.3). This requirement is, however, sometimes \ntoo strong. For example, suppose that we want to guarantee a property \"Before a channel x is used for \noutput, y must be used for input.\" (This kind of requirement arises, for exam- ple, in ensuring safe \nlocking [5].) Note that this property is not an invariant condition: Once y is used for input, x can \nbe used immediately. One way to overcome this limitation would be to annotate each channel creation (u:~) \nwith the history of reductions, and parameterize ok with the history. Another limitation comes from the \nside condition ok(FJ.{~}) of the rule (T-NEw): Because of the opera-tion ${~}, only the causality between \nsimultaneously cre- ated channels can be directly controlled. We can overcome this limitation by parameterizing \nthe condition ok with a set of channels of interest, and replacing ok(F${~}) with ok(r, {~}). Other extensions \nThere are many other useful extensions. Combining our type system with polymorphism, existential types, \netc. would be useful. We expect that polymorphism can be introduced in a similar manner to Pierce and \nSan- giorgi's polymorphic r-calculus [28]. The type system for deadiock-freedom in Section 4 is ac- tually \nnaive. More special treatment of event tags t is nec- essary to obtain a sophisticated type system for \ndeadlock- freedom [14] (see the full paper [11]). Besides type-soundness proofs and type inference issues \nstudied in this paper, it would be interesting to formalize other aspects of type systems through our \ngeneric type sys- tem. Typed process equivalence would be especially impor- tant, because it is hard \neven for specific type systems [17, 27,281. Another interesting extension is generalization of the tar- \nget language. If we can replace the at-calculus with a more abstract process calculus like Milner's action \ncalculi [24], type systems for other process calculi can also be discussed uniformly. 8 Related Work \nGeneral framework of type systems Previous proposals of a general framework [9, 20, 21] are (i) so abstract \n(e.g., [9, 20]) that only a limited amount of work can be shared for developing concrete type systems, \nand/or (ii) not gen- eral (e.g., [20, 21]) enough to account for recent advanced type systems. Honda's \nframework [9] is more abstract than ours. Moreover, his framework only deal with what he call additive \nsystems, where the composability of processes are determined solely by channel-wise compatibility: So, \nit can- not deal with properties like deadlock-freedom, for which inter-channel dependency is important. \nOn the other hand, his framework can deal with a wide range of process cal- culi as target languages, \nnot only the 7r-calculus. In KSnig's type system based on hypergraphs [20], type environments do not \nchange during reduction of a process. So, it cannot deal with dynamically changing properties like linearity \n[17]. Moreover, the target calculus is less expressive than the 7r- calculus, our target calculus: It \ncannot express dynamic cre- ation of channels. Other type systems viewing types as processes Some pre- \nvious type systems also use process-like structures to ex-press types. Yoshida's type system [38] (which \nguarantees a certain deadlock-freedom property) uses graphs to express the order of communications. Her \ntype system is, however, specialized for a particular property, and the condition cor- responding to \nour consistency condition seems too strong, even for guaranteeing deadlock-freedom. Nielson and Nielson \n[25] also use CCS-like process terms to express the behavior of CML programs. Because their analysis \napproximates a set of channels by using an abstract channel called a region, it is not suitable for analyses \nof deadlock-freedom (see [14] for the reason), race detection, linearity analysis, etc, where the identify \nof a channel is important. Process-like terms have been used as types also in type systems for deadlock-freedom \n[30] and related properties [31] of concurrent objects. As briefly outlined in Section 5, our type system \ncan guarantee such properties without having concurrent objects as primitives. Abstract interpretation \nAs mentioned in Section 1, our generic type system can be viewed as a kind of abstract interpretation \nframework [2], in the sense that properties of programs are verified by reasoning about abstract versions \nof those programs. From this viewpoint, our contribution is a novel formalization of a specific subclass \nof abstract interpretation for the 7r-calculus (for which no satisfactory general abstract interpretation \nframework has been devel- oped to the authors' knowledge) as a type system. Another novelty seems to \nbe that while conventional abstract inter- pretation often uses a denotational semantics to claim the \nsoundness of an analysis, our type system uses an opera-tional semantics, which seems to be more convenient \nfor analyses of concurrent processes. Non-standard type systems for functional languages Un-like standard \ntype systems for functional languages, our type system keeps track of not only the shape of each value \nbut also information on how each value is accessed. In this re- spect, there seems to be some connection \nbetween our type system and non-standard type systems for functional lan- guages, especially those for \nmemory management [15, 36]. It would be interesting to study whether they can be encoded into some extension \nof our generic type system. Conclusion We have proposed a general type system for concurrent pro- cesses, \nwhere types are expressed as abstract processes. We have shown that a variety of non-trivial type systems \ncan be obtained as its instances, and that their correctness can be proved in a uniform manner. Future \nwork includes a study of a more general version of the type soundness theo- rem in Section 6, and extensions \nof our generic type system discussed in Section 7, to give a complete account of the existing type systems \nfor the v-calculus. Acknowledgment We would like to thank Andrew Gordon, Eijiro Sumii, and anonymous \nreferees for useful discussions and comments. References [1] L. Cardelli and A. D. Gordon. Anytime, anywhere: \nModal logics for mobile ambients. In Proceedings of A CM SIGPLAN/SIGA CT Symposium on Principles of Programming \nLanguages, pages 365-377, 2000. [2] P. Cousot and R. Cousot. Abstract interpretation: A unified lattice \nmodel for static analysis of programs by construction or approximation of fixpoints. In Proceed-ings \nof ACM SIGPLAN/SIGACT Symposium on Prin- ciples of Programming Languages, pages 238-252, 1977. [3] M. \nF/ihndrich and A. Aiken. Program analysis us-ing mixed term and set constraints. In Proceedings of SAS'97, \nLNCS 1302, pages 114-126. Springer-Verlag, 1997. [4] C. Flanagan and M. Abadi. Object types against races. \nIn CONCUR'99, LNCS 1664, pages 288-303. Springer- Verlag, 1999. [5] C. Flanagan and M. Abadi. Types for \nsafe locking. In Proceedings of ESOP 1999, LNCS 1576, pages 91-108, 1999. [6] C. Flanagan and S. N. Freund. \nType-based race de-tection for Java. In Proceedings of ACM SIGPLAN Conference on Programming Language \nDesign and Im- plementation, pages 219-232, 2000. [7] S. J. Gay. A sort inference algorithm for the polyadic \n7r- calculus. In Proceedings of A CM SIGPLAN/SIGA CT Symposium on Principles of Programming Languages, \npages 429-438, 1993. [8] M. Hennessy and J. Riely. Information flow vs. resource access in the information \nasynchronous pi-calculus. In Proceedings of ICALP 2000, LNCS 1853. Springer-Verlag, 2000. [9] [lO] [11] \n [12] [13] [14] [151 [16] [17] [18] [19]  [20] [21] [22] [23] K. Honda. Composing processes. In Proceedings \nof A CM SIGPLAN/SIGA CT Symposium on Principles of Programming Languages, pages 344-357, 1996. K. Honda, \nV. Vasconcelos, and N. Yoshida. Secure information flow as typed process behaviour. In Proc. of European \nSymposium on Programming (ESOP) 2000, LNCS 1782. Springer-Verlag, 2000. A. Igarashi and N. Kobayashi. \nA generic type system for the pi-calculus. Tech. rep., Department of Informa- tion Science, University \nof Tokyo, 2000. to appear. A. Igarashi and N. Kobayashi. Type reconstruction for linear pi-calculus with \nI/O subtyping. Information and Computation, 161:1-44, 2000. C. B. Jones. A pi-calculus semantics for \nan object-based design notation. In Proceedings of CONCUR '93, LNCS, pages 158-172. Springer-Verlag, \n1993. N. Kobayashi. A partially deadlock-free typed pro-cess calculus. A CM Transactions on Programming \nLan- guages and Systems, 20(2):436-482, 1998. N. Kobayashi. Quasi-linear types. In Proceedings of ACM \nSIGPLAN/SIGACT Symposium on Principles of Programming Languages, pages 29-42, 1999. N. Kobayashi. Type \nsystems for concurrent pro-cesses: From deadlock-freedom to livelock-freedom, time-boundedness. In Proceedings \nof IFIP Interna- tional Conference on Theoretical Computer Science (TCS2000), LNCS 1872, pages 365-389, \n2000. N. Kobayashi, B. C. Pierce, and D. N. Turner. Linearity and the pi-cMculus. A CM Transactions on \nProgram- ming Languages and Systems, 21(5):914-947, 1999. N. Kobayashi, E. Sumii, and S. Saito. An implicitly- \ntyped deadlock-free process calculus. In Proceedings of CONCUR2000, LNCS 1877, pages 489-503. Springer- \nVerlag, 2000. N. Kobayashi and A. Yonezawa. Towards foundations for concurrent object-oriented programming \n-types and language design. Theory and Practice of Object Systems, 1(4):243-268, 1995. B. KSnig. Generating \ntype systems for process graphs. In Proceedings of CONCUR '99, LNCS 1664, pages 352- 367. Springer-Verlag, \n1999. B. KSnig. Analysing input/output-capabilities of mo- bile processes with a generic type system. \nIn Proceed-ings ofICALPZO00, LNCS 1853. Springer-Verlag, 2000. R. Milner. Communication and Concurrency. \nPrentice Hall, 1989. R. Milner. The polyadic v-calculus: a tutorial. In F. L. Bauer, W. Brauer, and H. \nSchwichtenberg, editors, Logic and Algebra of Specification. Springer-Verlag, 1993. [24] R. Milner. Calculi \nfor interaction. Acta Informatica, 33(8):707-737, 1996. [25] H. R. Nielson and F. Nielson. Higher-order \nconcur-rent programs with finite communication topology. In Proceedings of A CM SIGPLAN/SIGA CT Symposium \non Principles of Programming Languages, pages 84-97, 1994. [26] F. Pessaux and X. Leroy. Type-based analysis \nof uncaught exceptions. In Proceedings of A CM SIG- PLAN/SIGA CT Symposium on Principles of Program- \nming Languages, pages 276-290, 1999. [27] B. Pierce and D. Sangiorgi. Typing and subtyping for mobile \nprocesses. Mathematical Structures in Computer Science, 6(5):409-454, 1996. [28] B. Pierce and D. Sangiorgi. \nBehavioral equivalence in the polymorphic pi-calculus. Journal of the Associa- tion for Computing Machinery \n(JA CM), 47(5):531-584, 2000. [29] B. C. Pierce and D. N. Turner. Concurrent objects in a process calculus. \nIn Theory and Practice of Paral- lel Programming (TPPP), Sendal, Japan (Nov. 199~), LNCS 907, pages 187-215. \nSpringer-Verlag, 1995. [30] F. Puntigam and C. Peter. Changeable interfaces and promised messages for \nconcurrent components. In Pro-ceedings of the 1999 A CM Symposium on Applied Com- puting, pages 141-145, \n1999. [31] A. Ravara and V. Vasconcelos. Typing non-uniform concurrent objects. In Proceedings of CONCUR2000, \nLNCS 1877, pages 474-488, 2000. [32] C. Stifling. Modal and temporal logics for processes. In Logics \nfor Concurrency, LNCS 1043, pages 149-237, 1996. [33] E. Sumii and N. Kobayashi. A generalized deadlock-free \nprocess calculus. In Proc. of Workshop on High-Level Concurrent Language (HLCL '98), ENTCS 16(3), pages \n55-77, 1998. [34] J.-P. Talpin and P. Jouvelot. Polymorphic type, region and effect inference. Journal \nof Functional Program- ming, 2(3):245-271, 1992. [35] J.-P. Talpin and P. Jouvelot. The type and effect \ndisci- pline. In Proceedings of IEEE Symposium on Logic in Computer Science, pages 162-173, 1992. [36] \nM. Tofte and J.-P. Talpin. Implementation of the call- by-value lambda-calculus using a stack of regions. \nIn Proceedings of ACM SIGPLAN/SIGACT Symposium on Principles off Programming Languages, pages 188- 201, \n1994. [37] V. T. Vaseoncelos and K. Honda. Principal typing schemes in a polyadic 7r-calculus. In CONCUR'93, \nLNCS 715, pages 524-538. Springer-Verlag, 1993. [38] N. Yoshida. Graph types for monadic mobile processes. \nIn FST/TCS'16, LNCS 1180, pages 371-387. Springer- Verlag, 1996. Appendix A Type Reconstruction The type \nreconstruction algorithm PT given below takes a process expression as input and outputs a pair of a type \nenvironment (extended with expressions like ~J's and C~$s ) and a set of constraints on variables in \nthe type environment. Each constraint is of the form either ok(F) or ~ _< F. The obtained pair gives \na principal typing of the input in the sense that all the possible type environments, under which the \nprocess expression is well typed, are obtained from the type environment in the pair, by replacing free \nvariables in the constraint so that the constraint is satisfied. PT(P) = (F,C): PT(O) = (0, 0) PT(x!t[~I \n P0) = let (r0,c0) = PT(Po) i. (~'[(~)..]. (. 15.), Co u {~ < r0}) (where a and ors are fresh) PT(x?t[~]. \nPo) = let (Fo,C0) = PT(Po) in (x?t[(~)a,~(9}]. (a~(#)),C0 U (c~ < F0}) (where c~ is fresh) PT(P~ [P2) \n= let (F1,C1) = PT(P1) (F2, C2) = PT(P2) in (rl iF2, Cl U C2) PT(P~ +'.. + P,) = let (F1,Ci) = PT(P1) \n (F,~, C,) = PT(P,~) in (F1 +\"- + F,,,, C1U-.. UC,~) PT(*Po) = let (F0, Co) = PT(Po) in (*Fo, Co) PT( \n(uY~) Po) = let (r0, Co) = PT(Po)  in (rot{~}, Co u {ok(ro.l.{~))}) B Proofs of Theorems B.1 Proof \nof Subject Reduction Theorem (Theo-rem 3.6.1) Lemma B.I.I: (r~s z)Ts2 ----(r~'s2)~'sl = r~'slus2. Proof: \nBy induction on the structure of F. [] Lenlma B.1.2 [inversion]: Suppose F ~ P. 1. If P = P1 [ P2, then \nthere exist F1 and F2 such that Fi~Pi for i= 1,2 and F < Fi[F2. 2. If P ---- P1 q- \"\" + Pn, then there \nexist F1,... ,Fn such thatri~Pi fori=l,...,nandP _< Fl+...+rn. 3. If P = x!t [.~]. Po, then there exist \nFo and I~ such that  r0 t> P0 and r < ~!t[(,~)r.]. (r0 iv,). ?t 4. If P -x. [~]. Po, then there exists \nF0 such that F0c> P0 and r _<~?'[(9)r0+~]. (r0t~). 5. If P = (v~) P0, then there exists r0 such that \nF0 ~, P0 Case: P = (uS0 P1 I P2 Q = (v~) (P1 I P2) and r < F0J'(~} with ok(FJ,(~}). are not free in Pz \n 6. If P = *P0, then there exists F0 such that Fo ~ P0 and r < .r0.  Proof: Immediate from the fact \nthat a type derivation of Ft> P must end with an application of the rule corresponding to the form of \nP, followed by zero or more applications of the rule T-SuB. S ~ Lemma B.1.3: If r ~ r', then FT(~} --+ \nP'j'(~} where S' is the least set that satisfies the following conditions: 1. x~tl't2 ~ S implies x i \ntl't2 \u00a2 S' and {tl,t2} C S~; 2. t ~ S implies t ~ S'; and 3. ytx,t2 ~ S and y ~ {.~} imply ytx,t2 ~ \nSt.  Proof: By induction on the derivation of F ~ r' with a case analysis on the last rule used. We \nshow only the main base case below; the other cases are easy. Case TER-CoM: r .... + y!t~ [71]. F1 +... \nI ' + v?'~[~2] r~ +... r'=r,[r~ s=(y',,'~} Ti<~2 We have two subcases according to whether y ~ {~} \nor not. We will show the subcase where y = x~; the other subcase is easy.. . SinceFJ'{ }~ .... +ti.Fx~( \n}~ +... [ ...+t2.F2~'(~}+-.., ~t ~s easy to show that rT(~} ('.~:2..~} rll-(~} I r21\"(~} finishing the \nsubcase. 0 Lemma B.1.4: If WF(r.~s) and WF(rts), then WF(F). Proof: Suppose WF(F) does not hold. Then, \nthere exist x, ~-1, T2, tl, t2, F~, F2, and F3 such that r--~* ... +x!t,[~,].r, +... I'-- + =?'=[~=].r2 \n+... Ira and T1 ~ T2. By using Lemma B.1.3 repeatedly, either rl\"s --\u00a2 .. + =!~'[~1]. (r,ts) +... .. \n+ =?'~[~]. (rats) +... Irsts or r.l.s >\" ... + =!\" [*1]. (rl.l.s) +... I \"'\" + =?~[~=]. (r=,l,s) +... \nI r~a,s, contradicting the assumption WF(FJ, s) and wF(rts). [] Lemma B.1.5 [substitution]: If F ~ P, \nthen [y/x]F[v/=]P. Proof: By straightforward induction on the derivation of F~P. Lemma B.1.6: If r ~ \nP and P ~. Q, then r ~ Q. Proof: By structural induction on the derivation of P ~ Q with a case analysis \nof the last rule used. We show a few interesting cases below; the other cases are easy. By Lemma B.1.2, \nthere exist F1, F~, and r2 such that Fi t> Pi for i E {1,2} and r <_ F~IF2 and r~ < r~j,(~} with ok(F~$(~}). \nBy the rule T-PAR, r~ I Fz t> P~ ] P2. Without loss of generality, we can assume ~ are not free in P2 \nso that F2T{~} = r2 and Null(r2$(~}). Then, (F1 [F2)~'(~} = Fi~'(~} I F2 and, by the third condition \nin Definition 3.4.3, o~((r~ I r~)4(~). Thus, r~t(~) I r2 ~ (~) (P~ I P~) by the rule T-NEw. Finally, \nit is easy to show F _< F~J'($} I F2, and so, by the rule T-SuB, F ~ Q. Case: P = *Po Q = *PolPo By \nLemma B.1.2, we have F0 ~ P0 and F < *F0. Then, by the rule T-PAR, F0 ]*F0~P0 ]*P0. Since *F0 < F0 I,F0, \nby using the rule T-SuB, r ~ Q. [] Proof of Theorem 3.6.1: By induction on the deriva- tion of P ~ \nQ with a case analysis on the last rule used. We show only main cases below. Case R-CoM: P .... + x!t[z]. \nP0 +\"\" I \"\" + =?~'[.~].Qo +\"\" Q = PoI[U~9]Qo l = x t,e By Lemma B.1.2 and the subtyping rules, there \nexist F~, F2, and Fa such that r < ... + x!t[(~)r3]. (r~ Ir3) +... I .\" + =?~' [(~)r2.~(~]. (r~-(~}) \nr, ~ Po r2 ~ Qo. Then, since WF(r), it mustbe the case that (~)r3 <_ (9)r~$(~, that is, rs < [~/~1r25(~}. \nWe can show t,t e r (~--:~ r~ I [s/~]r~ by the following calculation: t t I F {= ' >1 F~ I r~ I r2T(~} \n< rl I [~/.~]r2,t(~} I r2\"r(~} = F1 < rl I[U.~]r2 (SuB-DwmE and SuB-SuBsT) By Lemma B.I.S, [~/~9]r2 ~ \n[~/~]qo. Finally, by the rule T-PAR, r, I [~/~lr~ ~ so I [~/~]Oo, finishing the case. Case R-PAR: P = \nP0 I R Po ~ Q0 q = Q01 R By Lemma B.1.2, there exist F1 and F2 such that r _< rl]r2 Fl~P0 F2~R To use \nthe induction hypothesis, we show WF(F1) by contradiction. Suppose WF(F1) does not hold. Then, WF(FilF2) \ndoes not hold, either; it means WF(F) does not hold. Thus, WF(F1). By the induction hypothesis, there \nexists F~ such that rl ~ F~ and r~ ~ Q0. By the rules TER-SKIP, TER- PAR, and TER-SuB, F l#) F~iF2. By \nthe rule T-PAR, F~ IF2 ~ Qo I R, finishing the case. By Lemma B.I.1, we have Case R-NEwl: P = (vh~)P0 \nPovt'*) Q0 y e (.~} Q = (Y~) Q0 I = ~ t'tl rs.l.~,~,(~,co)(~i~..s-~)(,~+~..,,)(...+u. H.Q+\"\" IR) By \nLemma B.1.2, there exists F0 such that F0t>P0 F < PoJ'(~} ok(F0$(~}). To use the induction hypothesis, \nwe will show WF(F0). Since WF(r0$(~)and WF(F0J'(~}) from the assumptions, we have WF(F0) by Lemma B.1.4. \nBy the induction hypothesis, there exists F~ such that t t ~ F0 {~S-+ } F~ and F~ t> Q0. By Lemma B.1.3, \nF0j'(~} (~) F~y(~} and FoJ,(~) (LL~ } F~$(~}. Then, ok(F~.l.(~}) and, by the rule T-NEw, F~(~) t> (u~) \nQ0, finishing the case. [] B.2 Proof of Theorem 4.1 Lemma B.2.7: Let < be any proper subtyping relation \nand ok be ok~. If F r, P and ok(F), then p~(P) holds. Proof: Suppose that F~ P and ok(F) hold but p~ \n(P) does not hold. By the definition of p~, there exist Q~ and Q2 such that P ~ (~--)(... + ~!~[~].Q1 \n+... I '\"+~?e[~].Qu+'\" IQa) with II~ll ~ II~ll. By Theorem 3.6.3, it must be the case that r~u...+~!t[~].Q~+... \nI ...+x?t'[~].Q~+-- I Qa ok~(ri${~,}) for each i ~ {1,...,k} Fi-1 = FiT(\u00a2&#38; for each i ~ {1,...,k} \nF<Fo F _< F0 and ok~(F) imply ok~(F0). By the typing rules, F~ must be of the form... + x!t [0\"]. A~ \n+ ...... [ + x!* [~-']. Ax~ + .. [~xa with [1~'[1 = [1~1[ \u00a2 [lff~[] = IIT'[[. This con-tradicts with \nthe facts okl(Po) and ok~(Fi$(~)) for each e (i,...,~}. Lemma B.2.8: Let < be any proper subtyping relation \nand ok be ok~. If F ~ P and ok(F), then p2(P) holds. []Proof: Similar to the proof of Lemma B.2.7. Lemma \nB.2.9: Let < be the least proper subtyping re- lation, and let ok be oka. If F t~ P and ok(F), then pa(P) \nholds. Proof: The proof proceeds by induction on t. Suppose F t> P, ok(F), and P ----~* P' = (~1..~) \n('\" .+y?t[~].Q+... i R). (The case where P ----~* P' = (~1..,~) (\"' + y!t[~].Q + .. JR) is similar.) \nWithout loss of generality, we can assume that y is free in P'. Otherwise, by Theorem 3.6.3, we have \nr, ~,... + v? ~[~]. Q +... I R Pi-1 = F~?(~ A for i = 1,...,n ok(F~$(\u00a2&#38;) for i = 1,...,n F<F0 y E \n{:~j} for some j and ok(rs$~)). By Theorem 3.6.1 and the definition of ok, there exists such that A ~, \nP' and F ----~* A. By Theorem 3.6.3, there exists T, Fx, and F2 such that A < ...+y?eN.rl+... I r~ .- \n+ y?\u00a2[r].rl +\"\" Ir2t'u P' Because ok(F) holds, it must be the case that F' ~ F\" for some L such that \n(i) L = (x tl't2} or (ii) L = (t') and t\" -~ t'. So, by the typing rules, one of the following conditions \nmust hold (c.f. Lemma 3.6.5): 1. P' _~ (~4Lm)('\" + w?t\"[~].Q1 + \"\" IQ2) with w e (,z,..., \u00a2,,,}. 2. \nP' ~ (~1..,~) ('\" + w! t''[\u00a3l.Q1 +'\" [Q2) with w e {a~,..., ~-~). 3. p' .~ (~m) ('''+~!~[~]. Q,+'\" I \n\"\"+~?~[~]\" Q~+  \"\" I Q~). In the first and second cases, P' ----+ follows by induction hypothesis. In \nthe third case, P' ~ follows immediately. [] Lemma B.2.10: Let < be any proper subtyping relation and \nok be ok4. If F r, P and ok(F), then p4(P) holds. Proof: Suppose that F t> P and ok4(F) hold. Suppose \n---~---~* (~) (... + also that P ----+*~ (ff~)P' and P' /'t x?[~].Q1 + \"\" I Q2). Without loss of generality \n(c.f. the proof of Lemma B.2.9), we can assume that x is free in P. So, we have p >* > .. . /'~ ~* (~)(~)(. \n+~? tt n [9].Q1 +.. I Q~). ~t ! ,t By Theorem 3.6.1, there exists F' such that F -------+* ) ---+* . \n7 tll - r' andr'~(~)(~)(..+x. [y].Qi+'\" IQ2). SyCorol- lary 3.6.4, it must be the case that F' _< --. \n+ x? t'' [r]. F~ + .., Ir !2. This contradicts with the assumption ok4(F). The case for output is similar. \n[] Proof of Theorem 4.1: This follows immediately from Lemmas B.2.7-B.2.10 and Theorem 3.6.2.    \n\t\t\t", "proc_id": "360204", "abstract": "We propose a general, powerful framework of type systems for the &amp;pi;-calculus, and show that we can obtain as its instances a variety of type systems guaranteeing non-trivial properties like deadlock-freedom and race-freedom. A key idea is to express types and type environments as abstract processes: We can check various properties of a process by checking the corresponding properties of its type environment. The framework clarifies the essence of recent complex type systems, and it also enables sharing of a large amount of work such as a proof of type preservation, making it easy to develop new type systems.", "authors": [{"name": "Atsushi Igarashi", "author_profile_id": "81100444415", "affiliation": "Department of Graphics and Computer Science, Graduate School of Arts and Sciences, University of Tokyo", "person_id": "PP39073523", "email_address": "", "orcid_id": ""}, {"name": "Naoki Kobayashi", "author_profile_id": "81100603931", "affiliation": "Department of Information Science, Graduate School of Science, University of Tokyo", "person_id": "PP39074471", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/360204.360215", "year": "2001", "article_id": "360215", "conference": "POPL", "title": "A generic type system for the Pi-calculus", "url": "http://dl.acm.org/citation.cfm?id=360215"}