{"article_publication_date": "01-01-2001", "fulltext": "\n Type-Preserving Garbage Collectors* Daniel C. Wang Andrew W. Appel Department of Computer Science Princeton \nUniversity Princeton, NJ 08544 USA Abstract By combining existing type systems with standard type\u00adbased \ncompilation techniques, we describe how to write strongly typed programs that include a function that \nacts as a tracing garbage collector for the program. Since the garbage collector is an explicit function, \nwe do not need to provide a trusted garbage collector as a runtime service to manage memory. Since our \nlanguage is strongly typed, the standard type soundness guarantee Well typed programs do not go wrong \nis extended to include the collector. Our type safety guarantee is non-trivial since not only does it \nguarantee the type safety of the garbage collector, but it guarantees that the collector preservers the \ntype safety of the program be\u00ading garbage collected. We describe the technique in detail and report performance \nmeasurements for a few microbench\u00admarks as well as sketch the proofs of type soundness for our system. \nIntroduction We outline an approach, based on ideas from existing type systems, to build a type-preserving \ngarbage collector. We can guarantee that the collector preserves the types of the mutator s data-structures. \nTraditionally a collector is prim\u00aditive runtime service outside the model of the programming language, \nthe type safety of running programs depends on the assumption that the collector does not violate any \ntyp\u00ading invariants. However, no realistic system provides a proof of this assumption. Our primary contribution \nis to demon\u00adstrate how to construct tracing garbage collectors so that one can formally and mechanically \nverify, through static type checking, that the collector does not violate any typing invariants of the \nmutator. Our approach is simple: make the collector a well typed function written in the same typed intermediate \nlanguage used by the compiler of the mutator s source language. * This research was supported in part \nby DARPA award F30602\u00ad99-1-0519 and by the IBM University Partnership Program.   Traditional Our Approach \nVerified Code Verified Code Mutator Collector Primitives Mutator Collector Primitives  Trusted Trusted \nComputing Base Computing Base Figure 1: Reduced Trusted Computing Base Garbage collection is no longer \na primitive runtime service, uses no unsafe primitives, and is part of our model of the programming language. \nSince the collector and mutator are both well typed, we appeal to the fact that Well typed pro\u00adgrams \ndo not go wrong. Our language uses a region based type system [27] for safe primitive memory management. \nThe collector is built on top of these safe region primitives. Regions are used to implement the semi-spaces \nof a tradi\u00adtional copying collector. The region type system allows us to verify that it is safe for the \ncollector to deallocate a semi\u00adspace that contains only garbage. Comparison to region inference. Our \ncollector dynami\u00adcally traces values at runtime, allowing for more .ne-grain and e.cient memory management \nthan systems that use re\u00adgion inference, which may take asymptotically more space than a simple tracing \ngarbage collector. From a di.erent perspective, our collector is merely a particular way of writ\u00ading \nprograms in a language that uses regions as the primary memory management mechanism; with this perspective \nour work is simply a more e.cient way of utilizing existing safe region-based memory management primitives, \nsimilar to the double copying technique used to make certain region pro\u00adgrams more e.cient [26]. Our \napproach suggests how to cleanly integrate compile-time memory management tech\u00adniques with traditional \nruntime techniques to gain the bene\u00ad.ts of both approaches. We consider this to be an important secondary \ncontribution. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for profit or commercial \nadvantage and that copies bear this notice and the full citation on the first page. To copy otherwise, \nto republish, to post on servers or to redistribute to lists, requires prior specific permission and/or \na fee. POPL '01 1/01 Londo, UK Copyright 2001 ACM 1-58113-336-7/01/0001 ... $5.00 Comparison to proof-carrying \ncode. Safety architectures such as Java byte-code veri.cation and proof-carrying code statically verify \nsafety properties of code provided by an un\u00adtrusted code producer [21, 13]. These systems rely on a trusted \ngarbage collector to safely handle memory deallo\u00adcation. Our approach allows us to verify the safety \nof the mutator and collector, placing the collector outside of the trusted computing base (TCB). Our \ntype-preserving collec\u00adtor relies on a few new low-level runtime primitives, but the total size of the \nTCB is smaller1 (see Figure 1). Since our TCB is smaller we are able to provide a stronger guarantee \nof safety. Although we verify programs through static type checking, existing proof-carrying code systems \ncan adapt our techniques to reduce the TCB in the same way. Even if we are willing to trust that a particular \ngarbage collector is correctly implemented, formalizing the invariants needed to properly interface a \nmutator with the collector will complicate the safety policy in a proof-carrying code system. Also we \nmust trust that the more complex safety policy is su.cient to guarantee safety. Even conservative garbage \ncollectors, which have simpler interfaces by conservatively inferring needed type information at runtime, \nrequire the compiler to preserve subtle invariants [8]. Formal treatment of collector interfaces. Another \nimpor\u00adtant contribution of our work is the ability to think about garbage collector interfaces in a statically \ncheckable way. We can check that the mutator uses the interface properly, and more importantly that the \ninterface is su.cient for the col\u00adlector to preserve the type safety of the mutator. Many of the bit-level \ndetails of garbage collector interfaces can be de\u00adscribed in a high-level and type-safe way, using simple \nand standard typing constructs. In particular we describe one way to implement stack walking [11] without \nan explicit table that maps the return address of a function to a stack frame layout. We are able to \ndo this by encoding the table implicitly and in a checkable way. Statically catching these bugs makes \nthe system more secure, easier to debug, more .exible, and potentially more e.cient. We can catch interface \nbugs, such as the failure to include a live value in the root set or providing incorrect type information, \nat compile time. Since the collector is not a .xed trusted piece of the system, individual programs can \nprovide a specialized collector which may improve program performance. A traditional copying collector. \nFigure 2 illustrates a sim\u00adple two-space stop-and-copy collector. When the collector is invoked it is \npassed three variables from, k, and roots, which are the current allocation space, the current contin\u00aduation, \nand the set of live roots respectively. Heap values are allocated in the current allocation space. The \ncurrent continuation represents the rest of the program and takes as arguments an allocation space and \nthe live roots which point to all the currently reachable heap data the program may wish to use. All \nthe data reachable from the live roots is allocated in the current allocation space. The collector uses \nsome heuristic to determine whether a garbage collection should occur. If so, the collector creates a \nfresh allocation space (to) then makes a deep copy of the live roots into the to-space. All the data \nreachable from the 1The primitives in our prototype system are implemented in ap\u00adproximately 200 lines \nof C code while a realistic garbage collector is in the range of 3000 lines of C. new roots (roots ) \nshould live in the to-space. The collec\u00adtor can now safely free the old from-space and resume the program \nwith the new allocation space and new live roots. Traditionally this operation is called a .ip because \nonce the from-space is deallocated its storage can immediately be reused as the next to-space, so the \nroles of the from-space and to-space are reversed. In order to guarantee that the from-space can be safely \ndeallocated, we must be certain that the rest of the pro\u00adgram never accesses values allocated in the \nfrom-space. If our program is written in continuation passing style, we can easily enforce this invariant \nby assigning a static type to k so that it cannot access values in the from-space. We can easily formalize \nthis intuition into a relatively simple type system. Technical challenges. Building a type-preserving \ncollector does not rely on a single key technical advance, but results from the combination of several \nadvances in typed compila\u00adtion. The key issues that need to be addressed are: 1. Copying 2. Source language \nabstractions 3. Deallocation 4. Pointer sharing  If the static type of every object is known at compile \ntime, it is easy to write a well typed function that produces a copy of the object with the same type. \nHowever, when the type is not known at compile time, because of polymorphism or issues of separate compilation, \nthis task becomes more challenging. Fortunately work in the area of intensional type analysis [14, 10] \nand other forms of ad-hoc polymorphism that use dictionary passing [30] provide clean solutions to this \nproblem. Traditional collectors violate data-abstraction guaran\u00adtees that are present in the source language. \nThe private .elds of an object in Java or private environment of a closure in ML cannot remain private \nto the garbage collec\u00adtor. We must decided if we wish to preserve these abstrac\u00adtion guarantees or violate \ndata-abstraction when performing garbage collection. For example there are several well known techniques \nfor type-preserving closure conversion. [16, 20, 28] Many of the schemes provide strong guarantees that \nthey preserve source level abstractions. In practice many compilers still must provide extra type information \nthat describes the layout of abstract objects for the garbage collector, so claims of ab\u00adstraction preservation \nbreak down at the level of the garbage collector. Other closure conversion techniques for .rst-order \ntarget languages [28] provide much weaker abstraction\u00adpreservation guarantees and make the layout of \nclosures ex\u00adplicit during translation. Intensional type analysis formal\u00adizes the passing of extra type \ninformation (typically pro\u00advided by the compiler for the garbage collector) in a fully type-safe way \n[10]. We touch on some of the tradeo.s of these approaches in Section 2. Collectors must use some primitive \nmemory management service to allocate and deallocate the from-space and the to\u00adspace. We must verify \nthat the service used by the collector is safe. The work on type and e.ect systems done by Tofte and \nTalpin and re.ned by others, provides type-safe explicit from to fun gc(from, k, roots) = if(need_gc(from)) \nthen let to = new_space() in let roots = copy(from, to, roots) in free_space(from) ; k(to, roots ) else \nk(from, roots) Figure 2: Traditional Garbage Collector memory management [27, 1, 9, 7]. We can use \nthe mem\u00adory management primitives provided by a region system to guarantee that it is safe to deallocate \nthe from-space after the garbage collector has copied all the live data into the to-space. Pointer sharing \nis preserved by the use of forwarding pointers which provide an e.cient way to implement a map from pointers \nin the from-space to pointers in the to-space. This map is needed to copy an arbitrary graph of heap \nob\u00adjects from one space to the other. Any map, such as a hash table, can be used in place of forwarding \npointers. Deal\u00ading with forwarding pointers complicates reasoning about safety, but we outline one approach \nfor dealing with for\u00adwarding pointers in a safe way. Or approach requires some inelegant ad-hoc reasoning, \nbut our technique is as e.cient as current unsafe techniques and can be formally proven sound. In Section \n2 we informally describe the language we will use to build our type-preserving collector. In Section \n3 we demonstrate our technique applied on a simple program. In Section 4 we discuss how to provide forwarding \npointers in a type-safe way. Finally we present some preliminary performance numbers for a few microbenchmarks \nin Section 5. 2 A Language for Type-Preserving Garbage Collectors Each technical challenge can be solved \nwith several di.erent techniques. To simplify our presentation we will choose the simplest solution for \neach challenge, and discuss more com\u00adplex alternatives. We only consider a .rst-order language where \nall types are known at compile time. There exist whole-program compilers for ML and Scheme that trans\u00adlate \nhigher-order languages into a .rst-order language, so this restriction does not restrict the generality \nof our ap\u00adproach [17, 23]. Under these assumptions we can generate a copy function for each type of object. \nWe could avoid the need for a .rst-order compilation approach and also support separate compilation better \nif we used the technically more sophisticated techniques of intensional type analysis. These assumptions \nallow us to focus more of our attention on the underlying approach and some of the more problematic is\u00adsues \nsuch as forwarding pointers. A Simple Region Type System. The .rst-order assumption simpli.es the region \nsystem by allowing us to ignore latent e.ects. For our purposes the region type system need not be particularly \nadvanced. We do not need to separate read and write e.ects, support e.ect polymorphism, account for latent \ne.ects (since our language is .rst order), or allow for dangling pointers. All of these features are \nincluded in the original Tofte-Talpin region calculus [27]. However, one feature that our region calculus \nmust sup\u00adport, but is not provided by the original Tofte-Taplin sys\u00adtem, is early deallocation. The region \nsystem of Crary, Walker, et al [9] supports early deallocation. It is su.cient for our purposes but is \nstill more complex then needed be\u00adcause of their static approach to handling issues of region aliasing. \nA simple region type system suitable for our pur\u00adposes that supports early deallocation and handles region \naliasing through a simple runtime check is described in [32]. We will use this system in the description \nof our work, be\u00adcause of its simplicity. Violations of Abstraction. The .rst-order restriction forces \nus to turn higher-order objects such as closures, which are normally abstract, into concrete values with \nan explicit rep\u00adresentation. This has the advantage that our collector can now check if two closures \nhave the same pointer address, and perform other operations that would typically violate abstractions \nin higher-order languages. While these abstraction violations are troubling, they merely re.ect the fact \nthat existing garbage collection tech\u00adniques tend to violate abstraction. However, we believe this violation \nof abstraction is not fundamental and that one can easily develop techniques that are not only type-preserving \nbut also-abstraction preserving. However, it is not clear if these abstraction preserving techniques \nare as e.cient as the current known techniques that violate abstraction, and e.ciency is an important \nconcern when developing garbage collectors. In the next section, to make these issues concrete, we describe \nhow to apply our technique to a simple program, it\u00aderative list reverse, written in our calculus using \na explicitly typed .rst-order ML-like language with regions and early deallocation. The type system is \nnot particularly novel so we will discuss it only informally. 3 Example: itrev Source program. Figure \n3 contains a program that reverses a list of integers. The function itrev takes two arguments l and acc \nboth of type lst and returns a value of type lst. The argument l holds the list to be reversed while \nacc holds the intermediate results. The recursive call to itrev is a tail call, so we do not need to \nallocate a new stack frame for this call. Note when the program .rst calls itrev the call is not a tail \ncall, so we must allocate a trivial stack frame for this call. As the function recursively descends l \nthe previous list cells, contained in the dotted box in the .gure, are garbage type lst = Nil | Cons \n(int, lst) fun itrev(l:lst, acc:lst):lst = case l of Nil . acc | Cons(hd,tl) . let acc = Cons(hd, acc) \nin itrev(tl, Cons(hd, acc )  let l = Cons(1, Cons(2, ... )) in let rl = itrev(l, Nil) (* non-tail call \n*) in rl Figure 3: Iterative List Reverse l acc 1 2 3 4 l acc 1 1 2 3 4 l acc 1 2 2 1 3 4 and can be \nreclaimed. The function therefore, need only retain a constant amount of live data in addition to the \nlist itself. This simple reasoning cannot be applied in systems that use region inference to manage memory. \nRegion inference would not allow us to immediately free each list cell in l after we have traversed it. \nA region system would force us to hold onto all the cells of l until the function returns acc. Type systems \nbased on linear logic may give us more .ne-grain control over allocation and deallocation and allow us \nto capture our reasoning for this particular instance, but they are fragile in the presence of aliasing \n[4, 6, 24, 31]. We will convert the program in Figure 3 into an equiv\u00adalent program that includes a function \nto garbage-collect dead values and is still well typed. We will need to per\u00adform CPS and closure conversion \nto the program, to make our informal reasoning about the stack and live values ex\u00adplicit. Afterwards, \nwe perform a simple region annotation to the resulting program to make precise what values live on the \nheap and when they are allocated. Finally, with this CPS-converted, closure-converted, region-explicit \nprogram we can synthesize a function that acts as a garbage collector for the program. CPS and closure \nconversion. If we CPS convert our source program, reasoning about the control .ow of the program becomes \neasier. However, since our language is .rst-order we cannot use a standard CPS conversion algorithm, \nwhich requires higher-order functions. Instead we adapt a .rst\u00adorder closure conversion technique outlined \nby Tolmach with a standard CPS conversion. Figure 4 illustrates Tolmach s closure conversion technique. \nNotice that the types of any free variables are captured in the type of the closure [28]. Figure 5 is \nthe result of applying these both the CPS and closure conversion transformations on our example. Notice \nthe new type cont which is the type of return continuations for the function itrev. All functions have \na return type of Ans, which means they do not return. This type contains one data constructor Ret rl \nwhich is needed for our one non-tail call in the original program. In general each call site of itrev \nwill require one new data constructor to rep\u00adresent each distinct return continuation. Also note that \nwe implicitly assume we have access to the whole program at this point. Tagless garbage collection algorithms \nexamine the return address of a function stored in the stack frame in order to determine the layout of \nthe stack frames [11]. The trans\u00adformation we have performed allows us to perform a similar operation. \nThe tag of each data-constructor acts as the re\u00adturn address, the type of the data-constructor describes \nthe stack layout, which is empty in this case. So we can replace a low-level table of bitmaps with a \nset of high-level type declarations. The chief disadvantage of .rst-order closure conversion is that \nit makes separate compilation more di.cult.2 However, providing true separate compilation using standard \nhigher\u00adorder techniques that preserve abstraction and have better separate compilations properties is \nnot as simple as it may seem. Even these techniques must have a method of merg\u00ading type information at \nlink time or force all objects to be uniformly tagged, which is often undesirable. Region annotated. \nWe have been informally arguing about where and when objects are allocated. Figure 6 shows our program \nwith explicit region annotations. Notice that the type lst in .gure 5 becomes a type constructor lst[a] \npa\u00adrameterized by a region in which the list lives. Since we can represent both the empty list and return \ncontinuation as single machine words we do not need to allocate space for them. We need to allocate space \nonly when constructing list cells with the Cons data-constructor; this is re.ected in the type Cons(int, \nlst[a]) at a. Both the itrev and apply functions each take a single region parameter (aalloc), which \ncorresponds to the alloca\u00adtion pointer in a normal untyped system. When we allocate a new list cell we \nuse the notation lst[aheap].Cons(1,...) which instantiate the region parameter (a) of the type con\u00adstructor \nlst to aheap and indicates that the new list cell will be allocated in the region aheap. We have assigned \nregions to types so that values are allocated in one global region, which acts like a traditional heap. \nWhen we call itrev we instan\u00adtiate its region parameter aalloc to aheap. We could apply a more re.ned \nregion local analysis to avoid heap-allocating an object when the lifetime of the object is locally obvious. \nIf the return continuation captured some live variables we would heap-allocate the continuation. This \napproach sim\u00adpli.es the compilation of advanced control features such as exceptions and .rst class continuations \nas well as simplify\u00ading the reasoning of safety. However, heap-allocating return continuations could \nimpact performance in an undesirable way. A system extended with linear types, along with a 2 Tolmach \noutlines a separate compilation technique that requires special support from the linker. Higher-Order \nlet y=1 in let f= if e then (.x:int.x) else (.x:int.x+y) in f1 First-Order type clos = C1 | C2(int) \nfun apply (f, x) = case f of C1 . x | C2(y) . x+y let y=1 in let f= if e then C1 else C2(y) in apply \n(f, 1) Figure 4: First-order Closure Conversion type lst = Nil | Cons(int, lst) type cont = Ret_rl  \nfun itrev(k:cont, l:lst, acc:lst):Ans =(*B*) case l of Nil . apply(k, acc) (* B1 *) | Cons(hd, tl) . \n(* B2 *) let acc = Cons(hd, acc) in itrev(k, tl, acc ) and apply(k:cont, v:lst):Ans =(*C*) case k of \nRet_rl . (* C1 *) let rl=v(* bind return value rl *) in rl ; halt() (* exit program *) let l = Cons(1, \n...) in (*A*) let k = Ret_rl in itrev(k, l, Nil)  Figure 5: CPS-Converted and Closure-Converted Program \ntype lst[a] = Nil (* unboxed *) | Cons(int, lst[a]) at a (* boxed *) type cont[a] = Ret_rl (* unboxed \n*) fun itrev[aalloc](k:cont[aalloc], l:lst[aalloc], acc:lst[aalloc]):Ans = case l of Nil . apply(k, acc) \n| Cons(hd, tl) . let acc = lst[aalloc].Cons(hd, acc) in itrev(k, tl, acc )  and apply[aalloc](k:cont[aalloc], \nv:lst[aalloc]):Ans = ... letr aheap in (* initial program heap *) let l = lst[aheap].Cons(1, ...) in \n(* heap allocate list *) let k = cont[aheap].Ret_rl (* create return continuation *) in itrev[aheap](k, \nl, lst[aheap].Nil) Figure 6: Program itrev after Region Annotation set of simple syntactic restriction \nwould allow us to stack allocate return continuations. GC safe points. Part of the interface between \na garbage collector and the compiler is a description of safe points . These are locations during the \nexecution of the mutator where it is safe to invoke the garbage collector. At these safe points the compiler \nusually emits type information de\u00adscribing which values are live at the safe point. Compilers that do \noptimizations must also be careful not to perform certain optimizations across safe points. It is complicated \nto characterize precisely which optimizations are and are not allowed [11]. It requires that the compiler \nunderstand the special semantics of what happens at a garbage-collection safe point. In our framework \nall these issues are handled straightfor\u00adwardly: since the garbage collector is just a normal function, \nthe compiler does not need to be modi.ed to be aware of any special semantics. A garbage collector is \njust a function that takes some data value. Figure 7 shows such a safe point in our program. Depending \non some heuristic the code ei\u00adther continues executing or packages the set of current live roots into \na return continuation for the garbage collector, described by the type gc cont. With region types we \nare able to statically verify that the data value is actually the set of live roots for the entire program. \nIf a buggy compiler or optimizer did not include all possible roots we would catch this error at compile \ntime, since not including a root would result in a scoping error or a violation of the region type system. \nMore importantly, we would be able to easily where the error was by examining the code statically, which \nmakes debugging signi.cantly easier. Debugging these sorts of problems in a traditional unsafe system \nis considerably more di.cult, because being able to isolate a bug of this sort in a large program is \na serious challenge. Early deallocation and the only term. Figure 8 contains the code for the garbage \ncollector. It copies the roots into a new region (ato) then it implicitly deallocates the old region \n(afrom) and resumes the program with the new roots and new region. The term only ato in ... is a static \nassertion that the body of the expression does not return, i.e. has type Ans, and can be safely evaluated \nusing only the region dynamically bound to ato. In general the only expression takes an arbitrary set \nof region variables. At runtime we simply note what regions are dynamically bound to the region variables \npassed to the only expression and safely deallocate any other regions, since they are not needed to evaluate \nthe rest of the program. The cost of this deallocation operation is at worst linearly related to the \nnumber of live regions. Our safe garbage collector needs at most two live regions at any time, so in \npractice the cost of this dynamic approach is negligible. This dynamic approach to early deallocation \nof regions is a novel approach which is simpler than current static approaches to early deallocation \nand more expressive. Consider the program fun f[aa, ab](x:int at ab):Ans = free region aa in (get[ab](x) \n; halt()) letr a1, a2 in if e then f[a1, a2](put[a1](1)) else f[a1, a1](put[a1](1)) The expression put[a](1) \nstores the integer into the region a1 and returns a reference to the integer. The term get[ab](x) reads \nan integer from the region ab. Notice that if the pro\u00adgram executes the .rst branch of the conditional \nthen f behaves as expected. However, if we execute the second branch then at runtime the region variables \naa and ab are both bound to the same region and the program will attempt to access a region which we \nhave erroneously deallocated. To handle this situation correctly we can simply prevent pro\u00adgrams from \naliasing region variables through various typing disciplines [9]. The static approaches do not incur \nany run\u00adtime overhead, but are relatively complex systems and would disallow us from writing the program \nabove. Using our dynamic approach we write f as fun f[aa, ab](x:int at ab):Ans = only ab in (get[ab](x) \n; halt()) At runtime we can determine what regions are actually bound to aa and ab.If aa and ab are bound \nto the same region we will deallocate nothing. If aa and ab are bound to distinct regions then we know \nthat it is safe to deallo\u00adcate the region associated with aa since we do not need it to evaluate the \nrest of the computation. It is not hard to im\u00adplement such a system in practice. In our prototype system \nall of the region primitives are less than 200 lines of C. We also believe that we can integrate the \nexplicit deallocation techniques that use static typing to prevent region aliasing with our implicit \napproach to give us the bene.ts of both ap\u00adproaches, so that we resort to this dynamic approach when \nwe are unable statically determine aliasing relationships. This dynamic approach to region deallocation \nis similar to the work of Aiken and Gay [12]. However, they use a relatively weak region type system \nand a more expensive reference counting approach that requires updating a ref\u00aderence count for each interregion \nstore. Because our type system provides more guarantees we can safely deallocate regions without needing \nto maintain any reference counts. GC copy function. Figure 9 sketches the code for a naive copy function. \nThe type of the copy function guarantees that the function performs a deep copy. The copy function is \nnot written in continuation-passing style so it uses a stack while traversing the list. We could write \nthe copy function in continuation-passing style and heap-allocate all its tempo\u00adrary space in a third \nregion which we could reclaim after we are done. Alternatively if we extend our type system with enough \ntechnical machinery so that we can recycle the space used by the continuations we could implement what \nwould amount to the Deutsch-Schorr-Waite pointer reversal algo\u00adrithm [22, 29, 25, 31]. Note that the \nfunction copy cont per\u00adforms an operation equivalent to walking the stack . Since we have CPS converted \nour program the continuation, k, represents the current stack frame. It may be the case that we can adapt \nthe higher-order techniques to provide true abstraction and separate compilation in the presence of a \ngarbage collector by requiring each abstract object to pro\u00advide a method3 to copy or trace the object. \nIt is not clear what the software engineering and performance issues are 3A closure can be thought of \na an object with a single apply method. type lst[a] = Nil | Cons(int, lst[a]) at a type cont[a] = Ret_rl \ntype gc_cont[a] = Ret_itrev(cont[a], lst[a], lst[a]) at a fun itrev[aalloc](k:cont[aalloc], l:lst[aalloc], \nacc:lst[aalloc]):Ans = if need_gc[aalloc]() then (*** safe point ***) let roots = gc_cont[aalloc].Ret_itrev(k, \nl, acc) in gc[aalloc](roots) else ... (* body of original itrev *) and apply[aalloc](k:cont[aalloc], \nv:lst[aalloc]):Ans = ... and gc[afrom](roots:gc_cont[afrom]):Ans = ... ... Figure 7: Program itrev with \nSafe Point Inserted type lst[a] = Nil | Cons(int, lst[a]) at a type cont[a] = Ret_rl type gc_cont[a] \n= Ret_itrev(cont[a], lst[a], lst[a]) at a fun itrev[aalloc](...):Ans = ... and apply[aalloc](...):Ans \n= ... and gc[afrom](roots:gc_cont[afrom]):Ans = letr ato in let roots = copy_gc_cont[afrom][ato](roots) \nin only ato in (* deallocate afrom *) case roots of Ret_itrev(k, l, acc) . itrev[ato](k, l, acc) and \ncopy_gc_cont[afrom, ato](x:gc_cont[afrom]):gc_cont[ato] = ... ... Figure 8: Flipping from and to space \ntype lst[a] = Nil | Cons(int, lst[a]) at a type cont[a] = Ret_rl type gc_cont[a] = Ret_itrev(cont[a], \nlst[a], lst[a]) at a fun itrev[aalloc](...):Ans = ... and apply[aalloc](...):Ans = ... and gc[afrom](...):Ans \n= ... and copy_gc_cont[afrom, ato](x:gc_cont[afrom]):gc_cont[ato]= case x of Ret_itrev(k, l, acc) . \nlet k = copy_cont[afrom, ato](k) in (* walk the \"stack\" *) let l = copy_lst[afrom, ato](l) in let acc \n= copy_lst[afrom, ato](acc) in gc_cont[ato].Ret_itrev(k , l , acc ) and copy_lst[afrom, ato](x:lst[afrom):lst[ato] \n= ... and copy_cont[afrom, ato](x:cont[afrom]):cont[ato] = ... ... Figure 9: Copying roots for this technique \nso we consider it to be future work. A more serious problem with our copy function is that it does not \npreserve pointer sharing. Preserving Sharing. Consider the datastructure in the .rst half of Figure \n10. If we were to apply our garbage collection technique with a naive copy function it would convert \nthe originally shared list of lists into an unshared version which uses more space. In the presence of \ncyclic data structures our naive copy function would not terminate. Traditional garbage collectors use \nforwarding pointers to preserve shar\u00ading. However, forwarding pointers are not the only mecha\u00adnism by \nwhich to do this. Figure 11 outlines a copy function that uses an aux\u00adiliary hash table augmented with \none primitive to return the unique pointer address of an object. This approach, while ine.cient, demonstrates \nthat the underlying algo\u00adrithm needed to preserve sharing is not inherently di.cult to type. In the next \nsection we will outline how to encode forwarding pointers in a safe way. Forwarding Pointers The easiest \nway to understand how to encode forwarding pointers is to start by encoding as many of the garbage col\u00adlector \ninvariants as possible within the type system. We will discover that the type system outlined so far \ncan capture many important invariants, but is not su.ciently expres\u00adsive to capture them all precisely. \nHowever, if we examine our partial solution we will gain enough insight to come up with a full solution \nby extending our system with a single primitive. Figure 12 sketches one approach to forwarding pointers. \nSome garbage collectors may overwrite a .eld of the ob\u00adject, but to simplify our presentation we assume \nevery heap allocated object contains an extra word to hold a forward\u00ading pointer which is either NULL \nor a pointer to an object of the appropriate type in the to-space. Notice that we have two di.erent list \ntypes. The gc lst type describes the garbage collector s view of lists. From the garbage collec\u00adtor s \nstandpoint, lists are allocated in a from-space contain\u00ading forwarding pointers into objects in a to-space. \nIt must be the case that that lists allocated in the to-space have for\u00adwarding pointers which are always \nset to NULL.The lst type describes lists that the mutator operates on, and maintains the invariant that \nthe forwarding pointer is set to NULL.The fact that the forwarding pointer is a mutable .eld which the \ngarbage collector will mutate is captured by the use of the ref constructor. The function share copy \nlst takes objects of type gc lst and makes a copy of type lst which preserves the underlying pointer \nsharing in the original gc lst. This code handles only acyclic lists but can be extended to handle the \ncyclic case. At .rst glance this would seem to be a complete solution; unfortunately there is one thorny \nproblem. If the mutator operates on objects of type lst how did we get an object of type gc lst in the \n.rst place? Ideally, we would like to argue that there is a natural subtyping relationship that allows \nus to coerce objects of type lst into objects of type gc lst. For this to work we need the ref constructor \nto be covariant. However, it is well known that covariant references are unsound. However, Java adopts \nthis rule for arrays4 and achieves safety by requiring an extra runtime check for every array update. \nWe cannot adopt the approach used by Java. This runtime check would prevent our garbage collector from \nsetting any forwarding pointer to a non-null value. However, rather than disallowing unsafe updates to \nan object we can disallow unsafe dereferences, more impor\u00adtantly we can disallow unsafe dereferences \nin a way that does not require a runtime check for every access. Given a value of type lst, if after \ncasting it to a value of type gc lst our program never accesses any value of type lst this cast is safe. \nIf our program is written in continuation-passing style, we can enforce this guarantee by making sure \nthat after casting the value of type lst to a value of type gc lst we pass the newly cast value immediately \nto a continuation that never accesses any value of type lst. One way to guarantee this condition statically \nis to type the continuation that re\u00adceives the cast value in a typing context where the type lst is not \nbound. Denying access to values of type lst after the program has performed a cast, is too restrictive \nto be useful. How\u00adever, since both the lst and gc lst are region annotated types, we can achieve a similar \nsort of guarantee and still write useful programs by revoking the right to the access the region where \nthe type lst is allocated, using a similar scoping trick. We can do this because after our garbage collector \ncasts a lst value to a gc lst value it never needs to examine the original value as a value of type lst. \nAfter our garbage collector runs, the original lst value is garbage, so the mutator never needs to access \nthe region where the lst value was allocated. However, if we deny access to the type lst by denying access \nto the region it lives in, where is the value of type gc lst allocated? We solve this problem by introducing \na new fake region which is equivalent for the purposes of subtyping to the region we denied access to \nbut for all practical purposes appears to be a distinct fresh region. To do this we must introduce a \nnonstandard and ad-hoc form of subtyping on references. This allows for safe covari\u00adant references by \nusing region variables to control access to potentially unsafe pointer aliases. Given two types A and \nB where A is a subtype of B and a region a the type ref[a, A] is a subtype of ref[a.,B] (where a. is \na new fake re\u00adgion variable) provided that the rest of the program does not access any values in region \na. This rule is admittedly ad-hoc, but it is the only ad-hoc rule in our entire system. Our approach \nis based on the observation of Crary, Walker, 4A ref cell can be thought of as a one element array. \nprim objId : [.] . . int tycon tbl :: Rgn . Typ . Typ . Typ = ... fun newTbl[atbl, ., .](sz:int):tbl[atbl, \n., .] = ... fun inTbl[atbl, ., .](t:tbl[atbl, ., .], key:.):bool = ... fun getTbl[atbl, ., .](t:tbl[atbl, \n., .], key:.):. = ... fun addTbl[atbl, ., .](t:tbl[atbl, ., .], key:., val:.):unit = ... type lst[a] \n= Nil | Cons(int, lst[a]) at a type cont[a] = Ret_rl type gc_cont[a] = Ret_itrev(cont[a], lst[a], lst[a]) \nat a fun itrev[aalloc](...):Ans = ... ... and share_copy_lst[atbl, afrom, ato]  (t:tbl[atbl, lst[afrom], \nlst[ato]],x:lst[afrom]):lst[ato]= case x of Nil . lst[ato].Nil | Cons(hd, tl) . if inTbl[atbl, lst[afrom], \nlst[ato]](x) then (* is forwarded? *) getTbl[atbl, lst[afrom], lst[ato]](x) else let hd =hd in let tl \n= share_copy_lst[atbl, afrom, ato](t,tl) in let x = lst[ato].Cons(hd ,tl ) in addTbl[atbl, lst[afrom], \nlst[ato]](x,x ) ; (* set forwaded *) x ... Figure 11: Preserving Sharing with a Hash-Table tycon ref \n:: Rgn . Typ . Typ type gc_lst[afrom, ato] = Nil | Cons(ref[afrom,fwd_ptr[ato]], int, gc_lst[afrom, \nato]) at afrom and fwd_ptr[ato] = NULL | PTR(lst[ato]) and lst[ato] = Nil | Cons(ref[ato, fwd_null], \nint, lst[ato]) at ato and fwd_null = NULL fun itrev[aalloc](...):Ans = ... ... and share_copy_lst[afrom, \nato](x:gc_lst[afrom, ato]):lst[ato]= case x of Nil . lst[ato].Nil | Cons(f, hd, tl) .  (case deref[afrom](f) \nof NULL . let hd = hd in let tl = share_copy_lst[afrom, ato] in let l = lst[ato].Cons(mkref[ato](fwd_null.NULL), \nhd , tl ) in f:=l;l PTR(l) . l) Figure 12: Encoding Forwading Pointers et al [9] that region variables \nact like capabilities . We use Normalized Program Runtime this observation to revoke all old references \nto the object and allow access to the object only through references of the ob\u00ad ject s supertype. See \n[32] which sketches the soundness of the approach for a simpler core calculus. It is important to note \nthat we still must at run time check that a is not aliased by any other region variable, so that the \nnew region variable a. refers to a unique region. This extra alias check is need for this approach to \nbe completely sound, but all our alias checks would be unnecessary in the system of Crary, Walker, et \nal. Preliminary Performance Evaluation The approach we have outlined is asymptotically competi\u00adtive \nwith existing garbage collection algorithms. However we cannot neglect constant factors and other important \nprag\u00admatic issues, if we wish to build a practical system. One is\u00adsue is code size. Since we are generating \na new copy function for every unique type, code explosion is a serious concern. We can adapt the . - \nmain encoding technique [11] and other approaches to encourage sharing in our copy function to mitigate \nthe code explosion problem. In order to address this issue we intend to do a detailed study of the number \nof unique copy functions needed for real programs. If these techniques are not su.cient we can adopt \nthe techniques such as intensional type analysis [14] to avoid having a dis\u00adtinct copy function for every \nunique type. For our prelim\u00adinary evaluation we will ignore the issues of code size and just examine \ne.ciency of the currently described system. Input programs. For comparison we have chosen several programs \nseen in the previous literature on region based memory management. They are as follows: itrev Iterative \nlist reverse (n = 10,000) appel1 Program designed to demonstrate issues of space complexity (n = 1000) \n[27] inline Inline variant of appel1 (n = 1000) [27] appel2 Program designed to demonstrate issues of \nspace complexity (n = 1000) [27] ackermann Ackermann s function evaluated (n = 3, m = 6) [27] .b Recursive \nFibonacci (n = 33) hsum Sum the value in a heap allocated list (n = 1000) [27] quicksort Quicksort randomly \ngenerated list (n = 1000) [27] share-copy Reverse shared list of list (n = 10,000) sum Recursive sum \nof the .rst n integers (n = 1000) [27] These programs are not a representative workload. How\u00adever, they \nare su.cient for a preliminary evaluation. It is important to note that our safe collector for appel1, \nappel2, and inline uses asymptotically less space than a region-based approach. Our safe collector is \nalso more ro\u00adbust in that both appel1 and inline have similar space characteristics which is not the \ncase in the original Tofte-Talpin system. itrev appel1 inlineappel2 ackermannfib hsum quicksort share- \ncopy sum Figure 13: Relative Runtime Performance Compiler. We have modi.ed the back end of the MLton \n[17] to accept source programs that include a safe garbage collec\u00adtor. The MLton compiler emits C code \nthat is then processed by the system C compiler to produce a runnable program. MLton has a straightforward \nunsafe depth-.rst-search two\u00adspace precise copying collector. The compiler also stack\u00adallocates activation \nrecords. For each source programs we collect data for the follow\u00ading variants: orig Original program \npassed directly to MLton cps Program run through CPS transform and .rst-order closure conversion, run \nwith MLton s unsafe collector gc-fwd Same as cps using safe collector and forwarding pointers which require \nan extra word of space for each object gc-tbl Same as cps using safe collector with hash table to preserve \nsharing To better understand the impact of CPS conversion, we measure the runtime of programs using the \nunsafe collector before (orig) and after CPS conversion (cps). We .nally measure the performance of two \ndi.erent safe collectors, which di.er only in their approach to sharing preservation; one uses forwarding \npointers (gc-fwd), the other a hash\u00adtable (gc-tbl). In a production system we would synthesize a safe \ncollec\u00adtor after high-level optimizations, but because of the struc\u00adture of MLton it was more convenient \nto synthesize a collector before many high-level optimizations. However, this exper\u00adimental artifact \ndemonstrates that compiler backends can safely optimize our program after a garbage collector has been \nsynthesized without understanding any special seman\u00adtics. In this case there are two di.erent optimizing \ncom\u00adpilers: MLton, which is performing high-level optimizations such as inlining, record .attening, and \nunboxing; and the system C compiler (gcc). E.ect of CPS Conversion. Figure 13 shows the total wall\u00adclock \nrun time for each program and variant normalized by the performance of the unoptimized CPS-converted \npro\u00adgram. Immediately, one can see that the CPS conversion Normalized Word Allocated Cycle Costs Figure \n15: Relative Number of Words Garbage Collected can cause more than a factor of two performance degra\u00addation \nwhen compared to the original program, which is stack allocating activation records. We are using a sim\u00adple \n.at-closure representation; more advanced closure rep\u00adresentation techniques can signi.cantly reduce \nthe amount of allocation.[2, 3] Figure 14 shows that our CPS converted programs are allocating signi.cantly \nmore heap data5, which accounts for the performance di.erence. Also note that pro\u00adgrams using a safe \ncollector with a hash table are allocating less data than programs using a safe collector with forward\u00ading \npointers. This is because although our safe collectors are tagless, we are reserving an extra word to \nstore a forwarding pointer for each object. The unsafe collectors are paying a similar overhead for an \nextra tag word. The collector using a hash table is not incurring this extra space overhead for tagging \nor forwarding, but uses more auxiliary space during garbage collection.6 5Notice that some programs did \nnot allocate any heap data origi\u00adnally. 6The extra auxiliary space need for garbage collection is not \nac\u00adcounted for in the .gure. Figure 16: Per-word and per-object cycle costs Figure 14: Relative Number \nof Words Allocated Normalized Words Collected Unfortunately, synthesizing a garbage collector before \noptimizing prevents certain space-saving optimizations, but this is simply an artifact of our current \nexperimental setup. After we region-annotate our program, we make our alloca\u00adtion semantics explicit. \nMLton will not unbox objects which we have decided to box. This artifact most notably shows up in the \nincreased allocation of share-copy. If we compare the performance of programs using our safe collector \nwith the those using the standard unsafe col\u00ad lector, we see that in some instances programs using our \nsafe collector seem to outperform the same programs us\u00ad ing an unsafe collector even when the unsafe \nversion of the program is stack-allocating activation records. This naive comparison is misleading, because \nthe various programs al\u00adlocate di.erent amounts of data at di.erent times. Because each program s allocation \nbehavior is di.erent, the number of words actually garbage-collected varies. Figure 15 shows the relative \namount of data actually garbage-collected for each program. This explains why in the case of itrev our \nsafe collector, which uses a more costly hash table to preserve sharing, seems to outperform both the \nsafe collector using forwarding pointers and the unsafe collector. Since each heap object is smaller \nwhen we are using a hash table to preserve sharing, our collector will be invoked less frequently.7 In \nthis case the program using the safe collector with a hash table seems faster because it is just doing \nless work. We could perform an experiment where we control for this and force collections to occur at \nprecisely the same time for identical programs, but this would obscure the fact that a garbage collection \nscheme which may be less e.cient when comparing performance in terms of strict copying costs may in practice \nbe more e.cient because of secondary e.ects, such as reducing the object size overheads for the mutator. \nQuantitative Measurements. With the caveat that raw copying performance is not an accurate measure of \nthe per\u00adformance impact of a garbage collection scheme, we report the raw copying performance of our \ncollector, by assuming 7In the case of share-copy, which is allocating more data, because of our dynamic \nheap resizing policy it is being invoked at di.erent times when there is less live data to be collected. \nitrev appel1 inlineappel2 quicksort share- copy sum itrev appel1 inline appel2 ackermann fib hsum quicksort \nshare- copy sum unsafe gc- fwd gc- tbl the following: gc time = c1 \u00b7 objects collected + c2 \u00b7 words \ncollected This assumes that total garbage collection time is simply the sum of time spent collecting \neach object and that the time spent collecting each object is simply some constant factor plus the cost \ncollecting each word of the object. We have estimated the per-word and per-object costs by arti.cially \nvarying both the object size and number of objects collected for our set of programs and then performing \na least squares .t over the data. Figure 16 summarizes our results in terms of absolute machine cycles. \nWe omit numbers for the orig case since it is using exactly the same unsafe collector as cps. Since the \nunsafe collector is interpreting type tags at runtime it has a signi.cantly higher per-object cost. How\u00adever, \nit is using a system-optimized memcpy which allows it to have a much smaller per-word cost. Our tagless \nscheme allows us to avoid any tag-interpretation overhead. Our safe collector is copying objects with \na series of naive loads and stores. For small objects, however, our safe collector us\u00ading forwarding \npointers is signi.cantly more e.cient than the unsafe collector. We must add a caveat that with such \nsmall programs we are ignoring important caching e.ects in our analysis. Our experiments suggest that \nif we modify our frame\u00adwork so that we can stack allocate return continuations, and if caching-related \ne.ects can be addressed our safe collector should be competitive with traditional unsafe techniques. \n6 Conclusions and Future Work Although our approach as presented is not practical for general-purpose \nsystems, we believe practical systems can be built by extending our current work. The most impor\u00adtant \ninsights are that a general-purpose collector can be built on top of a set of much simpler primitives, \nand that when standard type systems are too weak, we can rely on run\u00adtime checking or simply add the \nright lemma and encode what amounts to a small proof sublanguage to establish im\u00adportant preconditions \nneeded for any ad-hoc reasoning that does not .t into a standard framework. At a high-level, garbage \ncollection algorithms move ob\u00adjects from one abstract set to another. Particular garbage collection algorithms \ndi.er in how these abstract sets of ob\u00adjects are implemented. In our type-preserving collector each abstract \nset of objects corresponds to a region. Our tech\u00adnique is not dependent on any particular implementation \nof the region primitives. In the past region have been implemented as contiguous allocation arenas. If \nwe implement regions as doubly-linked list of objects rather than contiguous allocation arenas, we can \nbuild a fake copying collector [33]. The fake copying scheme forms the basis for incremental techniques \nsuch as Bakers s Treadmill [5]. We maybe be able to use this obser\u00advation as the basis for building safe \nincremental collectors. The mark bits used in mark-sweep and mark-compact col\u00adlectors can also be seen \nas a simple set membership bit. We believe that with an appropriate implementation of the un\u00adderlying \nregion primitives, mark-sweep and mark-compact collection schemes could be implemented. We would like \nto investigate how to integrate purely static memory management techniques [24, 31] with our sys\u00adtem. \n[18] takes our basic approach and extends it to use the more sophisticated techniques of intensional \ntype anal\u00adysis, and outlines an approach for encoding a generational collector as well as presenting \nan alternative approach to forwading pointers. Garbage collectors are typically written in low-level \nun\u00adsafe languages such as C. Most garbage collector algorithms discuss details in terms of low-level \nbit and pointer manip\u00adulation operations. Morrisett, Felleisen et al [19] present a high-level semantics \nfor garbage collection algorithms, and prove the correctness of various well known algorithms. However, \nin their semantics garbage collection is still viewed as an abstract operation that lies outside of the \nunderly\u00ading language being garbage collected. This approach allows them to discuss the purely algorithmic \nissues without reveal\u00ading the underlying implementation details. Our semantics is su.ciently detailed \nthat one can use it as guide to directly implement a reasonably e.cient garbage collector on realis\u00adtic \nhardware. It also has the property that we establish the safety of our garbage collection algorithm by \nsimply relying on type soundness. Ideally we would like to have a spectrum of static and dynamic memory \nmanagement techniques so one can mix techniques in a clean, e.cient, and safe way. We would like to investigate \nin more detail the abstraction related issues we have mentioned. Although our technique is type-preserving \nit is still not abstraction-preserving. We believe research in this direction may lead to more modular \nmemory manage\u00adment techniques. References [1] Alexander Aiken, Manuel F\u00a8ahndrich, and Raph Levien. Better \nstatic memory management: Improving region\u00adbased analysis of higher-order languages. In Proceed\u00adings \nof SIGPLAN 95 Conference on Programming Lan\u00adguages Design and Implementation, volume 30 of ACM SIGPLAN \nNotices, pages 174 185, La Jolla, CA, June 1995. ACM Press. [2] Andrew W. Appel and Zhong Shao. Empirical \nand ana\u00adlytic study of stack versus heap cost for languages with closures. Journal of Functional Programming, \n6(1):47 74, January 1996. [3] Andrew W. Appel and Zhong Shao. E.cent and safe\u00adfor-space closure conversion. \nACM Transactions on Programming Languages and Systems, 22(1):129 161, January 2000. [4] Henry G. Baker. \nLively linear Lisp Look Ma, no garbage! . ACM SIGPLAN Notices, 27(9):89 98, Au\u00adgust 1992. [5] Henry \nG. Baker. The Treadmill, real-time garbage col\u00adlection without motion sickness. ACM SIGPLAN No\u00adtices, \n27(3):66 70, March 1992. [6] Henry G. Baker. The boyer benchmark meets linear logic. Lisp Pointers, 6(4):3 \n10, October 1993. [7] Anindya Banerjee, Nevin Heintze, and Jon G. Riecke. Region analysis and the polymorphic \nlambda calculus. In Proceedings, Fourteenth Annual IEEE Symposium on Logic in Computer Science, pages \n88 97, Trento, Italy, 2 5 July 1999. IEEE Computer Society Press. [8] Hans-Juergen Boehm. Simple garbage-collector \nsafety. In Proceedings of SIGPLAN 96 Conference on Pro\u00adgramming Languages Design and Implementation, \nACM SIGPLAN Notices, pages 89 98. ACM Press, 1996. [9] Karl Crary, David Walker, and Greg Morrisett. \nTyped memory management in a calculus of capabilities. In Conference Record of the Twenty-sixth Annual \nACM Symposium on Principles of Programming Languages, ACM SIGPLAN Notices, pages 262 275. ACM Press, \n1999. [10] Karl Crary, Stephanie Weirich, and Greg Morrisett. In\u00adtensional polymorphism in type-erasure \nsemantics. In ICFP [15], pages 301 312. [11] Amer Diwan, J. Eliot B. Moss, and Richard L. Hud\u00adson. Compiler \nsupport for garbage collection in a stat\u00adically typed language. In Proceedings of SIGPLAN 92 Conference \non Programming Languages Design and Im\u00adplementation, volume 27 of ACM SIGPLAN Notices, pages 273 282, \nSan Francisco, CA, June 1992. ACM Press. [12] David Gay and Alex Aiken. Memory management with explicit \nregions. In Proceedings of SIGPLAN 98 Con\u00adference on Programming Languages Design and Imple\u00admentation, \nACM SIGPLAN Notices, pages 313 323, Montreal, June 1998. ACM Press. [13] J. Gosling. Java intermediate \nbytecodes. ACM SIG-PLAN Notices, 30(3):111 118, March 1995. [14] Robert Harper and Greg Morrisett. Compiling \npoly\u00admorphism using intensional type analysis. In Confer\u00adence Record of the Twenty-second Annual ACM \nSympo\u00adsium on Principles of Programming Languages,ACM SIGPLAN Notices, pages 130 141. ACM Press, Jan\u00aduary \n1995. [15] Proceedings of Second International Conference on Functional Programming, Baltimore, MA, September \n1998. [16] Yasuhiko Minamide, Greg Morrisett, and Robert Harper. Typed closure conversion. In Conference \nRecord of the Twenty-third Annual ACM Symposium on Principles of Programming Languages, ACM SIG-PLAN \nNotices, pages 271 283. ACM Press, 1996. [17] MLton, a whole program optimizing compiler for Stan\u00addard \nML. http://www.neci.nj.nec.com/PLS/MLton/. [18] Stefan Monnier, Bratin Saha, and Zhong Shao. Prin\u00adcipled \nscavenging. Technical Report Yale/DCS/1205, Yale University, 2000. [19] Greg Morrisett, Matthias Felleisen, \nand Robert Harper. Abstract models of memory management. In Func\u00adtional Programming and Computer Architecture, \nSan Diego, 1995. [20] Greg Morrisett, David Walker, Karl Crary, and Neal Glew. From System F to typed \nassembly language. In Conference Record of the Twenty-.fth Annual ACM Symposium on Principles of Programming \nLanguages, ACM SIGPLAN Notices, pages 85 97. ACM Press, 1998. [21] George Necula. Proof-carrying code. \nIn Conference Record of the Twenty-fourth Annual ACM Symposium on Principles of Programming Languages, \nACM SIG-PLAN Notices, pages 106 119. ACM Press, 1997. [22] H. Schorr and W. Waite. An e.cient machine \ninde\u00adpendent procedure for garbage collection in various list structures. Communications of the ACM, \n10(8):501 506, August 1967. [23] Je.rey Mark Siskind. Flow-directed lightweight clo\u00adsure conversion. \nTechnical Report TR99 190R, NEC Reseaarch Institute, Inc., December 1999. in prepara\u00adtion. [24] Frederick \nSmith, David Walker, and Greg Morrisett. Alias types. In Gert Smolka, editor, Ninth European Symposium \non Programming, volume 1782 of Lecture Notes in Computer Science, pages 366 381, Berlin, April 2000. \nSpringer-Verlag. [25] Jonathan Sobel and Daniel P. Friedman. Recycling con\u00adtinuations. In ICFP [15], \npages 251 270. [26] Mads Tofte, Lars Birkedal, Martin Elsman, Neils Hal\u00adlenberg, Tommy H\u00f8jfeld Olesen, \nPeter Sestoft, and Pe\u00adter Bertelsen. Programming with reigons in the ML Kit (for version 3). Technical \nReport DIKU-TR-98/25, University of Copenhagen, December 1998. [27] Mads Tofte and Jean-Pierre Talpin. \nImplementation of the typed call-by-value .-calculus using a stack of re\u00adgions. In Conference Record \nof the Twenty-.rst Annual ACM Symposium on Principles of Programming Lan\u00adguages, ACM SIGPLAN Notices, \npages 188 201. ACM Press, January 1994. [28] Andrew Tolmach and Dino P. Oliva. From ML to Ada: Strongly-typed \nlanguage interoperability via source translation. Journal of Functional Programming, 8(4):367 412, July \n1998. [29] G. Veillon. Transformations de programmes recursifs. R.A.I.R.O. Informatique, 10(9):7 20, \nSeptember 1976. [30] Philip Wadler and Stephen Blott. How to make ad\u00adhoc polymorphism less ad-hoc. In \nConference Record of the Sixteenth Annual ACM Symposium on Principles of Programming Languages, ACM SIGPLAN \nNotices, pages 60 76. ACM Press, January 1989. [31] David Walker and Greg Morrisett. Alias types for \nre\u00adcursive data structures (extended version). Technical Report TR2000-1787, Cornell University, March \n2000. [32] Daniel C. Wang and Andrew W. Appel. Type\u00adpreserving garbage collectors (extend version). Tech\u00adnical \nReport TR-624-00, Princeton University, 2000. [33] Thomas Wang. The MM garbage collector for C++. Master \ns thesis, California State Polytechnic Univer\u00adsity, October 1989.  \n\t\t\t", "proc_id": "360204", "abstract": "By combining existing type systems with standard type-based compilation techniques, we describe how to write strongly typed programs that include a function that acts as a t racing garbage collector for the program. Since the garbage collector is an explicit function, we do not need to provide a t rusted garbage collector as a runtime service to manage memory.Since our language is strongly typed, the standard type soundness guarantee \"Well typed programs do not go wrong\" is extended to include the collector. Our type safety guarantee is non-trivial since not only does it guarantee the type safety of the garbage collector, but it guarantees that the collector preservers the type safety of the program being garbage collected. We describe the technique in detail and report performance measurements for a few microbench-marks as well as sketch the proofs of type soundness for our system.", "authors": [{"name": "Daniel C. Wang", "author_profile_id": "81100213288", "affiliation": "Department of Computer Science, Princeton University, Princeton, NJ", "person_id": "P59488", "email_address": "", "orcid_id": ""}, {"name": "Andrew W. Appel", "author_profile_id": "81100498630", "affiliation": "Department of Computer Science, Princeton University, Princeton, NJ", "person_id": "PP14174176", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/360204.360218", "year": "2001", "article_id": "360218", "conference": "POPL", "title": "Type-preserving garbage collectors", "url": "http://dl.acm.org/citation.cfm?id=360218"}