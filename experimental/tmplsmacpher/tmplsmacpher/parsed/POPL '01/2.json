{"article_publication_date": "01-01-2001", "fulltext": "\n BI as an Assertion Language for Mutable Data Structures Samin Ishtiaq Peter W. O Hearn Queen Mary &#38; \nWest.eld College, London ABSTRACT Reynolds has developed a logic for reasoning about muta\u00adble data structures \nin which the pre-and postconditions are written in an intuitionistic logic enriched with a spatial form \nof conjunction. We investigate the approach from the point of view of the logic BI of bunched implications \nof O Hearn and Pym. We begin by giving a model in which the law of the excluded middle holds, thus showing \nthat the approach is compatible with classical logic. The relationship between the intuitionistic and \nclassical versions of the system is es\u00adtablished by a translation, analogous to a translation from intuitionistic \nlogic into the modal logic S4. We also con\u00adsider the question of completeness of the axioms. BI s spa\u00adtial \nimplication is used to express weakest preconditions for object-component assignments, and an axiom for \nallocating a cons cell is shown to be complete under an interpretation of triples that allows a command \nto be applied to states with dangling pointers. We make this latter a feature, by incor\u00adporating an operation, \nand axiom, for disposing of memory. Finally, we describe a local character enjoyed by speci.ca\u00adtions \nin the logic, and show how this enables a class of frame axioms, which say what parts of the heap don \nt change, to be inferred automatically. 1. INTRODUCTION Pointers are an extremely powerful and .exible \nprogram\u00adming mechanism, useful for manipulating linked data struc\u00adtures and for providing structured \naccess to data in memory. They are also extremely dangerous. Pointer-manipulating programs are notoriously \ndi.cult to get right, and even lead to runtime safety violations (such as from dereferencing nil or a \ndisposed pointer) which lie beyond the range of conven\u00adtional type systems. An e.ective program-proving \nformal\u00adism for dealing with pointers would be most welcome. But pointers have also always been one of \nthe thorny patches of program proving. The most immediate issue to face is that the Hoare substitution-oriented \ntreatment of as- Permission to make digital or hard copies of all or part of this work for personal or \nclassroom use is granted without fee provided that copies are not made or distributed for profit or commercial \nadvantage and that copies bear this notice and the full citation on the first page. To copy otherwise, \nto republish, to post on servers or to redistribute to lists, requires prior specific permission and/or \na fee. POPL '01 1/01 Londo, UK Copyright 2001 ACM 1-58113-336-7/01/0001 ... $5.00 signment {P [E/x]}x \n:= E{P } does not cope with component assignments of the form E.i := E' (or E . i = E' in C syntax) that \nalter the heap. Other issues are raised by operations for allocating and, especially, disposing of memory. \nA number of researchers have devel\u00adoped program-proving formalisms for pointers (e.g., [16, 30, 23, 17, \n22, 3, 6]), but no de.nitive solution has emerged as of yet. Most importantly, lying behind technicalities \nwith axioms for assignment and storage management is a deeper di.culty, the complexity of pointer swing \n[15] that results from aliasing: there can be more than one pointer to a cell that is altered, in which \ncase assignment to the cell a.ects seemingly unrelated expressions. The real problem is to con\u00adtrol, \nor understand, this complexity, rather than simply to axiomatize it. A striking advance has been recently \nmade by Reynolds [35], building on early work of Burstall [5]. The main nov\u00adelty is the use of a spatial \nform of conjunction P * Q, that splits the heap into distinct portions that the di.erent con\u00adjuncts talk \nabout. In addition, there is a form of assertion, the points-to relation ., which is used to make statements \nabout the contents of heap cells. For instance, the spatial conjunction (x . 3,y) * (y . 4,x) says that \nx and y denote distinct locations, where the cdr of x is a pointer to y, the cdr of y is a pointer to \nx, and where the car s contain 3 and 4. x y  _ The combination of * and . leads to remarkably simple \naxioms. In particular, when an assertion of the form P * (x . a, b) holds prior to a component assignment \nx.1 := z we know that the assignment cannot a.ect P , and so P * (x . z, b) will hold on conclusion. \nThe logic of pointer swing is treated in a local way that mirrors the intuitive operational locality \nof assignment. In this paper we investigate the approach from the point of view of the logic BI of O \nHearn and Pym [25]. The most distinctive feature of BI is its joint treatment of two implica\u00adtion connectives. \nOne implication, ., is from standard intu\u00aditionistic or classical logic, while the other, -* , is the \nimpli\u00adcation for a basic substructural logic. Reynolds s assertion language is already substructural: \nit adds a Contraction-free conjunction, where P and P *P are not generally equivalent, to intuitionistic \nlogic: BI s -* is related to * by the deduc\u00adtion theorem, which states that a consequence A |= B-* C \nholds i. A * B |= C does. There is also a version of the de\u00adduction theorem which relates . and the usual \nconjunction .. The basic idea of BI s semantics is to allow statements to be made about the world using \nfamiliar connectives such as ., \u00ac and ., and then to combine these statements in a modular way using \n* and -* . The key to this is the resource interpretation of the connectives, where * decomposes the \ncurrent resource into pieces and -* talks about new or fresh resource [25, 26]. Substructural logics \nmay appear rather exotic beasts. But the pointer models we present provide a very concrete and, we believe, \nintuitive way of under\u00adstanding the connectives, quite apart from overtly logical concerns. With this \nas background, we now describe the main con\u00adtributions of the paper. These fall under three headings: \n(i) Classical versus Intuitionistic; (ii) Completeness Issues; (iii) Local Reasoning. Classical or Intuitionistic?. \nReynolds used an intuition\u00adistic interpretation of pre-and postconditions in his logic. This was presented \nin a possible worlds style, which treats negation and implication by quantifying over all extensions \nto the current heap [19], and gives rise to a monotonicity property where all propositions are invariant \nunder heap extension. Although the intuitionistic semantics is intu\u00aditive, it seemed to us reasonable \nto ask: might the law of the excluded middle be compatible with the axioms for as\u00adsignment and other \nstatements? Reynolds gave an exam\u00adple which indicates that his axioms are unsound under a straightforward \nclassical reading, but left open the ques\u00adtion of whether a di.erent classical semantics might be pos\u00adsible. \nWe answer by presenting a classical model, which is a possible worlds model of Boolean BI (where \u00ac and \n. are classical), and which validates all of the axioms for Hoare triples. In this model the worlds are \nheaps (collections of cons cells in storage), and the conjunction P * Q is true just when the current \nheap can be split into two components, one of which makes P true and the other of which makes Q true. \nThe implication P -* Q talks about new or fresh pieces of heap, disjoint from the current heap. It says \nthat, whenever we are given new heap that makes P true, the combined new and current heap will make Q \ntrue. The other connectives are interpreted pointwise in this model; for example \u00acP is true of a world \njust if P is not true of that world. Perhaps more signi.cant than excluded middle is that the classical \nsemantics is more expressive than the intuitionis\u00adtic one. In particular, it allows the speci.cation \nof exact properties of the heap, such as the heap is empty , which cannot be expressed in the intuitionistic \nsemantics because they are not invariant under heap extension. We work with the classical semantics for \nmost of the pa\u00adper, but consider the relation to the intuitionistic model in Section 9. We describe a \ntranslation from intuitionistic to classical which is similar to a standard translation from intuitionistic \nlogic to the modal logic S4, thereby showing that all intuitionistic properties can be expressed within \nthe classical setup. Completeness Issues. Although the treatment of assign\u00adment given by Reynolds, and \nby Burstall, is very elegant, at .rst sight its simplicity appears to come at the price of forc\u00ading assertions \nto be written in a stylized form, which would not allow certain programs to be veri.ed. This would per\u00adhaps \nbe a price worth paying, but we show that the weakest precondition can in fact be expressed. The crucial \npoint for this is an interesting interaction between the -* and * connectives. For example, we will explain \nin Section 3.1 how (x . 3, 5) * ((x . 7, 5)-* P ) says that x points to a cell holding (3, 5), but also \nthat if we update the car to 7 then P will be true. We would expect this to be a valid precondition for \na postcondition P with assignment statement x.1 := 7, where the indicated assignment sets the .rst component \nof (the cons cell denoted by) x to 7. We show how the weakest precondition for each atomic statement \ncan be expressed in the logic. The semantics used for this result is based on an interpretation of triples \nthat allows commands to be applied to states with dangling pointers. Dangling pointers also play an essential \nrole in the interpretations of -* and *. We make this a feature by con\u00adsidering an operation that disposes \nof memory (thereby cre\u00adating dangling pointers). Since disposing memory is such a devastatingly e.ective \nmethod of introducing programming errors, we were pleasantly surprised to .nd that the ap\u00adproach allows \nfor a simple axiom which enables programs with disposal to be proven. The semantics of triples we use \nis one that supports the slogan well-speci.ed programs don t go wrong, where going wrong could result \nfrom, say, deref\u00aderencing nil or a disposed pointer. The classical semantics presented in this paper \ncame after the intuitionistic semantics, and we must admit that it took some time to get used to. (The \nintuitionistic semantics was discovered independently by us, while we were working from an early version \nof [35].) Ultimately, the classical model seemed natural only after we had the courage to consider disposal, \nwhere it is essential to be able to specify mem\u00adory utilization exactly. Reynolds has since been braver \nstill, working with a generalization of the logic that encompasses pointer arithmetic [36]. Local Reasoning. \nAbove we mentioned the local way that pointer swing is treated. We examine the sense in which local reasoning \nextends to larger-scale operations. In fact, one of the most promising suggestions in the approach of \nReynolds and Burstall is that veri.cations might be done in a way that scales well, by localizing the \ne.ects of heap\u00adaltering commands to certain of the conjuncts in an assertion P1 *\u00b7 \u00b7\u00b7* Pn. We investigate \nthis idea by formulating a rule for auto\u00admatically inferring certain frame axioms, which describe in\u00advariants \nof the heap. Traditionally, an inordinate amount of e.ort needs to be spent specifying what a program \ndoesn t change, so much so that these frame axioms distract from the main concern what changes. In the \nabsence of point\u00aders what doesn t change can be succinctly summarized using modi.es clauses [14], which \nlist the program variables corre\u00adsponding to locations that can be altered by a program. But for pointers, \nwhich may include links to cells not named by variables in the program, the problem is much more acute; \nwe show how the conjunction * can be used to derive such axioms. The point is that this allows speci.cations \nto be kept small , where they describe only the area of the heap that a program actually acts on. Invariant \nproperties for other areas of the heap come for free. 2. COMMANDS AND BASIC DOMAINS The imperative language \nthat Reynolds deals with is a simple command language, with Lisp-like expressions for ac\u00adcessing and \ncreating cons cells. We will not give a full syntax of commands, as the treatment of conditionals and \nlooping statements is standard. Instead, we will concentrate on as\u00adsignment statements, which is where \nthe main novelty of the approach lies. The commands we consider are as follows. C ::= x := E | x := E.i \n| E.i := E ' | x := cons(E1,E2) . . | . i ::= 1 | 2 Here, each of the E s is a pure expression; that \nis, E does not contain a dot. In E.i the i is assumed to be one of the constants 1 or 2 (the extension \nto varying length records, or named alternatives, is straightforward). The second and third assignment \nstatements read and update the heap, re\u00adspectively. The fourth creates a new cons cell in the heap, and \nplaces a pointer to it in x. Notice that these commands do not directly handle double\u00addereferencing, \nsuch as x.1.2, where one looks more than one\u00addeep into the heap. One would have to break a use of such \nan expression, either on the left or right of :=, into several steps, possibly using auxiliary variables.1 \nAn expression can denote an integer, an atom, or a cons cell. E ::= x Variable |||| 42 nil a \u00b7 \u00b7 \u00b7 Integer \nnil atom We have not given a full expression syntax; the only con\u00adstraint is that an expression can \nbe interpreted in the se\u00admantic domain speci.ed below. We use the following semantic domains, which are \nas in [35] (except for our restriction to binary cells, which is not essential). V al = Int . Atoms . \nLoc S = Var -fin V al H = Loc -fin V al \u00d7 V al Here, Loc = {e, ...} is an in.nite set of locations, V \nar = {x, y, ...} is a set of variables, Atoms = {nil, a, ...} is the set of atoms, and -fin is for .nite \npartial functions. We call an element s . S a stack, and h . H a heap. There 1This restriction is similar \nto the form of assignment state\u00adments sometimes used in intermediate languages for static analysis of \npointer programs. is a deliberate distinction between the two: stack variables are maintained according \nto a stack discipline and are not allowed to alias one another; heap variables or pointers do not obey \na stack discipline. [We will not include an explicit operation for allocating stack variables.] We use \ndom(h) to denote the domain of de.nition of a heap h . H, and dom(s) to denote the domain of a stack \ns . S. An expression is interpreted as a heap-independent value [ E] s . V al where the dom(s) includes \nthe free variables of E. The commands are interpreted using a relation on con\u00ad.gurations, where the con.gurations \ninclude triples C, s, h and terminal con.gurations s, h, for s . S and h . H. We assume the semantics \nof expressions to specify . In the following rules we use r to range over elements of V al \u00d7 V al, pir \nfor the .rst or second projection, and (r | i . v) to indicate the pair like r except that the i th component \nis replaced with v. [ E] s = v x := E, s, h [s | x . v],h [ E] s = e . Loc h(e)= r x := E.i, s, h [s \n| x . pir],h [ E '' [ E] s = e . Loc h(e)= r ] s = v E.i := E ' , s, h s, [h | e . (r | i . v ' )] e \n. Loc e . dom(h)[ E1] s = v1 , [ E2] s = v2 x := cons(E1,E2), s, h [s | x . e], [h | e .(v1,v2)] The \nlocation e in the fourth case is not speci.ed uniquely, so a new location is chosen non-deterministically. \nWe can also include typical rules for sequencing, looping, etc. The rela\u00adtion is a one-step semantics, \nand these other constructs would give rise to non-terminal con.gurations. We say that C, s, h is stuck \nin case there is no con.guration K such that C, s, h K, and  C, s, h is safe in case C, s, h * K implies \nthat K is a terminal con.guration s ' ,h ' or is not stuck.  Being stuck is a kind of runtime error. \nFor instance, a com\u00admand can get stuck by an attempt to dereference nil or an integer. Note also that \nthe semantics allows dangling ref\u00aderences, as in the stack [x . e] with empty heap []. The assignment \nx.1 := 2 is stuck for this stack and heap. This de.nition of safety is formulated with partial correct\u00adness \nin mind: with loops C, s, h could fail to converge to a terminal con.guration without becoming stuck. \n 3. A MODEL OF BOOLEAN BI The pre-and postconditions for commands will be written using the following \nformulae. P, Q, R ::= a Atomic Formulae | false Falsity | P . Q Classical Implication | emp Empty Heap \n| P * Q Spatial Conjunction | P -* Q Spatial Implication |.x.P Existential Quanti.cation This syntax \ndi.ers from that of Reynolds in three ways. First, we consider the substructural implication -* and unit \nemp from BI. The unit was not needed in [35] because in the intuitionistic semantics the unit of * is \ntrue (this is because Weakening for * is present). Second, we use the BI symbol * instead of &#38; for \nthe spatial conjunction. Finally, because we are in a Boolean situation we can de.ne various other connectives \nas usual, rather than taking them as primitive: \u00acP = P . false; true = \u00ac(false); P . Q =(\u00acP ) . Q; P \n. Q = \u00ac(\u00acP .\u00acQ); .x. P = \u00ac.x. \u00acP . The set free(P ) of free variables of a formula is de.ned as usual, \nas is the capture-avoiding substitution P [E/x]. The atomic formulae include an equality relation and \nthe points-to relation. a ::= E = E ' Equality || E . E1, E2 \u00b7 \u00b7 \u00b7 Points to In practice, one would \nalso want atomic predicates describ\u00ading inductive properties of the heap, or a recursive facility which \nallows such properties to be de.ned. 3.1 Semantic Clauses The semantics of assertions is given by a forcing \nrelation of the form s, h |= P which asserts that P is true of stack s . S and heap h . H. It is required \nthat dom(s) . free(P ). The semantics is organized in a possible worlds style, where the heaps are the \nworlds. We use the following notation in formulating the semantics: h#h ' indicates that the domains \nof heaps h and h ' are disjoint;  h\u00b7h ' denotes the union of disjoint heaps (i.e., the union of functions \nwith disjoint domains).  Here are the semantic clauses. s, h |= E = E ' i. [ E] s =[ E ' ] s s, h |= \nE . E1,E2 i. {[ E] s} = dom(h) and h([[E] s)= ([ E1] s, [ E2] s) s, h |= emp i. h = [] is the empty heap \ns, h |= P * Q i. .h0,h1.h0#h1,h0 \u00b7 h1 = h, s, h0 |= P and s, h1 |= Q s, h |= P -* Q i. .h ' . if h ' \n#h and s, h ' |= P then s, h \u00b7 h ' |= Q s, h |= false never s, h |= P . Q i. if s, h |= P then s, h |= \nQ s, h |= .x.P i. .v . V al. [s | x . v],h |= P The points-to relation E . E1,E2 looks one-deep into \nthe heap. In the classical semantics it is interpreted exactly , by requiring that that E denotes the \nonly cell in the current heap. The semantics is .exible here, in allowing Ei in E . E1,E2 to denote a \nlocation that is not in the domain of h. For example, in [x . e, y . e ' ], [e .(2,e ' )] |=(x . 2,y) \nthe location e ' is dangling, which is to say that it is not in the domain of the heap. The conjunction \nP * Q is true just when the current heap can be decomposed into two constituents in a way that makes \nP true of one constituent and Q true of the other. With this de.nition, (x . 3,y) * (y . 4,x) corresponds \nto the box-and-pointer diagram from the Introduction. Notice the importance of dangling pointers here: \nthe store corre\u00adsponding to the left conjunct is x y  while that for the right is x  _ This model \ndi.ers from the one in [35] in three ways. First, the implication . is interpreted in a pointwise fash\u00adion, \nwhich results in a classical semantics. This is a seman\u00adtics which uses the boolean algebra structure \nof the powerset of H, rather than the 2-element boolean algebra. Second, we include emp and -* . And \nthird, the points-to relation is interpreted exactly, where s, h |= E . E1,E2 does not imply s, h ' |= \nE . E1,E2 whenever h ' is a bigger heap than h (bigger in the sense of inclusion of partial functions). \nWe can express an inexact variant of points-to as follows E . E1,E2 =(true * E . E1,E2). Generally, true \n* P says that P is true of some heap con\u00adtained in the current one. Conversely, if we were to take . \nas primitive then we could de.ne . in terms of it using the formula E . E1,E2 .\u00ac(\u00acemp) * (E . E1,E2). \nThe di.erent way that the two conjunctions * and . be\u00adhave is illustrated by the following examples. \n1. (x . 1, 2) * (x . 1, 2) is never true, because, however the heap is split up, x will be left dangling \nin one of the conjuncts. 2. (x . 1, 2).(x . 1, 2) is equivalent to x . 1, 2, and so is true in the singleton \nheap where x points to (1, 2). 3. (x . 1, 2) *\u00ac(x . 1, 2) can be true when x points to a cell holding \n(1, 2) in the current heap, because the heap can then be split into a singleton where (x . 1, 2) and \nanother heap where x is dangling, thus making \u00ac(x . 1, 2) true.  4. (x . 1, 2) .\u00ac(x . 1, 2) is never \ntrue. The di.erence between . and . shows up in the presence or absence of Weakening for *. 1. P * (x \n. 1, 2) . (x . 1, 2) is not always true, for instance when the antecedent is true of a heap with more \nthan one de.ned location. 2. P * (x . 1, 2) . (x . 1, 2) is always true.  A crucial ingredient in the \nsemantics of -* is the require\u00adment h ' #h, which has the e.ect of ensuring that h ' is a new or fresh \npiece of heap. That is, its domain of de.nition must be disjoint from the domain of the current heap \nh. We can now explain the example (x . 3, 5) * (x . 7, 5)-* P from the Introduction. We claim that this \nformula says that x denotes a cell which holds (3, 5) in the current heap, but also that if we update \nthe car to 7 then P will be true. To see why, .rst note that the semantics of * splits the heap, say, \nx Rest of  Heap _ into two portions, one where (x . 3, 5) holds and a second heap where the location \ndenoted by x is dangling: x Rest of Heap _ We have included a dangling pointer out of the rest of the \nheap here to emphasize that the location might be refer\u00adenced from within a heap cell, as well as from \nx. Because the association (x . 3, 5) has been, in a sense, retracted by deleting the association from \nthe heap in the right conjunct, this frees -* to extend the second heap with a di.erent con\u00adtents for \nthe location denoted by x. The semantics of -* and . then ensure that P must be true when this second \nheap is extended by binding x s location to (7, 5). x Rest of  Heap _ So, the intuitive description \nin terms of updating follows from several steps in the semantics, which add up to update as deletion \nfollowed by extension . (We stress that x denotes the same location at each step in this narrative , \neven when that location is dangling; the update expressed is to the heap, not the stack.)  3.2 Properties \nThe semantic consequence relation P |= Q between for\u00admulae is de.ned to hold i. for all s, h, if s, h \n|= P then s, h |= Q. This assumes that dom(s) . free(P ) . free(Q). Proposition 1. The usual rules of \nclassical logic are sound for |=, along with * is commutative and associative, with unit emp P ' |= PQ \n' |= Q P ' * Q ' |= P * Q R * P |= QR |= P -* QR ' |= P R |= P -* QR * R ' |= Q In particular, note that \ntwo versions of the deduction the\u00adorem hold at the same time: R |= P -* Q i. R * P |= Q R |= P . Q i. \nR . P |= Q. In [25], these properties were taken as the basis for a natural deduction presentation of \nBI, where contexts were bunches: trees built from two kinds of combining operator, one corresponding \nto * and the other to .. That presenta\u00adtion is (after we add reductio ad absurdum) equivalent, in terms \nof provability, to the bunch-free presentation stated in the proposition. The model in this section is \na possible worlds model for Boolean BI [25, 26]. Because we do not have Weakening (P * Q |= P ) or Con\u00adtraction \n(P |= P *P ) for *, we are in the territory of substruc\u00adtural logic. To see why Contraction fails, consider \nx . 2, 3. It can be satis.ed in a heap with a cons cell whose contents is (2, 3), but (x . 2, 3) * (x \n. 2, 3) is false for every heap. To see why Weakening fails, consider (x . 2, 3) * (y . 4, 5). For this \nto be true the current heap must have size two, and (x . 2, 3) cannot then hold because it requires the \ncurrent heap to have size one. The importance of restricting Contraction was brought to the fore by linear \nlogic [12, 13]. But it is important to realize that BI takes a very di.erent approach to the surrounding \nadditive connectives. To see this, consider that P -. Q |= P . Q always holds in linear logic, using \nthe decomposition P . Q =!P -. Q and the rule of Dereliction for !. But here, (x . 1, 2)-* false |=(x \n. 1, 2) . false because the antecedent can hold in a heap where x . 1, 2 while the consequent cannot. \nThis shows that there can be no ! which decomposes P . Q into !P -* Q in this model; this highlights \nthe di.erence between the joint treatment of -* and . in the model and the approach of linear logic. \nFurthermore, it is not unusual to use additive implications where . appears to the left. An example is \nwhen specifying that any de.ned location in the heap is reachable; such a speci.cation would be of the \nform .x. (.ab. x . a, b) . \u00b7\u00b7\u00b7 ) (where to .ll in the \u00b7\u00b7\u00b7 we could use an appropriate inductive de.nition). \nNext, we consider the notion of purity. Purity. We say that an assertion is syntactically pure if it \ndoes not contain . or I. Recall that we do not have terms of the form E.i for .eld selection within assertions: \n. is the only way that an as\u00adsertion might look into the heap. Proposition 2. Any synactically pure assertion \nis inde\u00adpendent of the heap: If P is a pure assertion then s, h |= P i. s, h ' |= P . As a result, pure \nassertions are completely additive: if P and Q are pure, then P * Q and P . Q are equivalent; P -* Q \nand P . Q are equivalent. The .rst of these properties indicates a formal similarity be\u00adtween purity \nand ! in linear logic [12]: we get Contraction P |= P * P and Weakening P * Q |= P for pure propositions. \n(This remark is independent of the issue of decomposing . into -* .) The second property shows a further \nsimilar\u00adity with passivity in syntactic control of interference [34], where additive and multiplicative \nfunction type constructs agree on passive types [28]. 3.3 Interpretation of Triples Hoare triples are \nof the form {P } C {Q}, where P and Q are assertions as above and C is a command. We adopt an interpretation \nwhich ensures that well-speci.ed commands do not get stuck. {P }C{Q} is true just when if s, h |= P then \nC, s, h is safe and if *' ' C,s,h s ,h ' then s ,h ' |= Q for all s, h where dom(s) . free(P ) . free(Q). \nThis is a partial correctness interpretation; with looping, it would not guarantee termination. However, \nthe safety re\u00adquirement rules out certain runtime errors and, as a result, we do not have that {true}C{true} \nholds for all commands. For example, {true}x := nil; x.1 := 3{true} fails. Gener\u00adally, if we can establish \n{P }C{true} then we will know that C is safe to execute in any state satisfying P .  4. THE REYNOLDS \nAXIOMS We start with standard Hoare rules for sequencing, con\u00adsequence and simple assignment. Sequencing \n{P }C{Q}{Q}C ' {R} {P }C; C ' {R} Consequence R ' P |= P ' {P ' }C{R ' }|= R {P }C{R} Simple Assignment \n{P [E/x]}x := E{P } In the Consequence rule, |= refers to the semantic conse\u00adquence relation for assertions. \n(Equivalently, we could re\u00adplace |= by ., and ask that the resulting implications hold in every state \nin which the stack component binds all vari\u00adables in the involved formulae.) The .rst heap-accessing \ncommand is the statement x := E.i, which can read from both the stack and the heap, but which only alters \nthe stack. Here there are two things to keep in mind. First, E will be a pure expression, which doesn \nt look into the heap. So, we will not consider an assignment statement like x := y.1.2, which would have \nto be broken into two steps. Second, we will expect E.i to be determined by an assertion of the form \nE . E1,E2, which lets us .nd its value. Object-component Lookup Suppose that the variables x1,x2 are \nnot free in E, and that x1 does not occur free in P . Then E .x1.P [x1/x] ..x2.E . x1,x2x := E.1 E P \nThe substitution in P [x1/x] is saying that P is true in the postcondition, similarly to the simple assignment \naxiom, but there is also additional information to make sure that xi is the proper value. The axiom for \nthe second selection E.2 is obtained by rearranging x1 and x2 in the precondition. We have used . in \nthis axiom, where Reynolds used .. In the intuitionistic semantics described later the two ver\u00adsions \nof the axiom are equivalent, but in the classical se\u00admantics the version with . is preferable. If we \nhad used . instead of . in the classical case then the heap in the precondition would be forced to be \na singleton. This would be sound, but not very useful. Next, Object-component Assignment Suppose that \nthe variables x1, ..., xm are not free in E or E ' . Then E .x1, ..., xm. (E . E1,E2) * P .1 := E ' E \n .x1, ..., xm. (E . E ' ,E2) * P The simplicity of this axiom is remarkable, and is where the e.ect of \n. and * is coming through. The idea is that we can simply slot E ' into the heap in the appropriate place. \nThe E.2 version has (E . E1,E ' ) in the postcondition. Finally, Cons Suppose that the variables x1, \n..., xm are not free in E1,E2, that x and x ' are distinct from each other and x1, ..., xm, that x ' \nis not free in E1,E2 or P . Let X ' denote the result of substituting x ' for x in expression or assertion \nX. Then E .x1, ..., xm.P x := cons(E1,E2) E '' .x ,x1, ..., xm.P * (x . E1' ,E2' ) Here, a new cell \nis created and a pointer to it is placed into x; the newness of this cell is why it can be separated \nfrom P ' using *. The following proof outline, for a piece of code for in\u00adserting a cell in the middle \nof a linked list, exempli.es the workings of the axioms for pointer swing and heap extension. {(x . a, \nz) * (y . c, w)} t := cons(b, y) {(x . a, z) * (y . c, w) * (t . b, y)} {(x . a, z) * (t . b, y) * (y \n. c, w)} x.2 := t {(x . a, t) * (t . b, y) * (y . c, w)} Proposition 3. The Reynolds axioms are true \nin the clas\u00adsical semantics. 5. COMPLETENESS ISSUES We begin by discussing the Component Assignment \nax\u00adiom. The way the axiom is formulated requires both the precondition and the postcondition to be of \na special shape, and this raises the question: can the axiom be applied gen\u00aderally, or does it restrict \nour reasoning to situations where the assertions are of a speci.c form? Before answering this question, \nwe formulate a backwards axiom with the help of the form of update that can be ex\u00adpressed using * and \n-* . Backwards Component Assignment Suppose that variables x and y are distinct and not free in E, E \n' , or P . Then E .xy. (E . x, y) * ((E . E ' ,y) -* P ) E.1 := E ' E P The E.2 version is similar. The \nbackwards version can ob\u00adviously be applied generally, since it works for any postcon\u00addition. In a draft \nversion of this paper (dated 10 March, 2000), we made the erroneous claim that the backwards axiom is \nstrictly stronger than Component Assignment, because of the latter s seemingly restricted form. However, \nReynolds has pointed out that the axioms are of equal strength, if we include the rule of consequence \nand consider an instance of Component Assignment with an occurrence of -* to the right of *, using again \nthe update as deletion followed by extension idea. E .xy. (E . x, y) * ((E . E ' ,y) -* P ) E.1 := E \n' E E .xy. (E . E ' ,y) * ((E . E ' ,y) -* P ) .xy. P E P The second-last step uses the consequence \nA * (A-* P ) |= P , and the fact that consequence is valid under .. The . can be eliminated in the .nal \nstep because x and y are not free in P . So, although the backwards form of the axiom expresses the weakest \nprecondition directly, the two versions are interderivable. We next discuss a curious point about the \ninterpretation of triples. We have allowed commands to be applied to states with dangling pointers, which \nare states that mention loca\u00adtions not in the domain of the current heap. In contrast, in [35] commands \nare only applied to states in which there are no dangling pointers; dangling pointers arise only during \nthe evaluation of assertions. The di.erence between these interpretations of triples is signi.cant in \nthe case of cons. For example, {true}x := cons(1, 2){\u00ac(x = y)} is true under a no-dangling interpretation \nof triples, but not under the interpretation we have adopted. The reason is that if there are no dangling \npointers then the operational rule for cons allocates a location that is not the contents of any stack \nvariable, but in the dangling case a location might be allocated that is already the contents of some \nstack variable. This indicates that the Cons axiom is not complete un\u00adder the no-dangling interpretation \nof triples. (This remark applies equally to the classical semantics and to the intu\u00aditionistic semantics \npresented later.) For, the example triple above is not derivable from the forwards Cons axiom, which \nsimply gives us {true}x := cons(1, 2){true * x . 1, 2} the postcondition of which is equivalent to x \n. 1, 2. One way to react to this incompleteness is to say that since dangling pointers never arise during \nprogram execution (for the programs considered so far), we should interpret the rule of consequence as \nan implication which holds in states where there is no dangling. That is, rule out dangling pointers \nat the top level, so to speak, but allow them when delving into subformulae involving * or -* . Another \nreaction, which we follow up on here, is to see dangling pointers as a natural characteristic of languages \nwhich allow memory to be ma\u00adnipulated on a low level; we elaborate on this point in the next section. \nTo describe a backwards axiom for cons, suppose we are given an arbitrary postcondition P . In the precondition \nwe would like to say that P will be true if we extend the heap with a new location, which is initialized \nappropriately. We can express this using . to quantify over locations, indicat\u00ading that any one will \ndo, together with -* for guaranteeing newness. Backwards Cons Suppose that x ' is not free in E1,E2 or \nP . Then E .x ' . (x ' . E1,E2)-* P [x ' /x] x := cons(E1,E2) E P In case x is not free in E1 or E2 we \ncan simply quantify over x in the above. For example, .x. (x . 1, 2)-* P is the precondition for x := \ncons(1, 2). If C is a command and Q a formula, then the weakest precondition is de.ned as follows. s, \nh . wp(C, Q) just when C, s, h is safe and if C, s, h * s ' ,h ' then s ' ,h ' |= Q We are not extending \nthe syntax of formulae here, but are simply de.ning wp(C, Q) as a set of stack-heap pairs. (With this \nde.nition we should perhaps speak of weakest liberal preconditions; but partial and total correctness \ncoincide for the basic commands that we are considering.) In the following result the backwards axioms \nare con\u00adsidered to be those from this section, along with Simple As\u00adsignment and Object-component Lookup. \nTheorem 4. The weakest precondition for each atomic statement is expressed by the corresponding backwards \nax\u00adiom. For a sequence C of assignment statements it follows that {P }C{Q} is derivable from the basic \naxioms (in either the Reynolds or backwards forms), Sequencing, and Consequence exactly when it is true. \n(Extending this result to loops would get us into the issue of expressiveness [10], which is outside \nthe scope of our concerns here.) The following notation will be convenient: if e . dom(h) then let h@e \ndenote the singleton heap in which e is mapped to h(e); also, let h - e denote the heap like h except \nthat it is unde.ned on e. It is evident that h =(h@e) \u00b7 (h - e) when e . dom(h). Proof. We only give \nthe proofs for the heap-altering com\u00admands E.i := E ' and x := cons(E1,E2). For soundness of Backwards \nComponent Assignment, as\u00adsume that s, h satis.es the precondition. The precondition ensures [ E] s = \ne . dom(h) is a de.ned location, and so the assignment statement does not get stuck. By the seman\u00adtics \nof E.i := E ' we need to show that s, h ' |= P , where h ' =[h | e .([ E ' ] s, v2)] and h(e)= (v1,v2). \nFrom the assumption and the semantics of . we get that s ' ,h |=(E . x, y) * ((E . E ' ,y)-* P ) for \nthe extension s ' of s which binds x to v1 and y to v2. Then, from the de.nitions of * and ., we get \nthat s ' ,h@e |=(E . x, y) s ' ,h - e |=(E . E ' ,y)-* P. The semantics of -* then implies that s ' , \n(h - e) \u00b7 [e . ([ E ' ] s, v2)] |= P and, since h ' =(h-e)\u00b7[e .([ E ' ] s, v2)], we get s ' ,h ' |= P. \nThe stack s ' can be replaced by s, because x and y are not free in P , and we are done. For completeness, \nassume that s, h . wp(E.i := E ' ,P ). From the safety part of wp we get that [ E] s = e . Loc for some \ne . dom(h). Suppose h(e)= (v1,v2). We claim that [s | x . v1,y . v2],h |=(E . x, y) * ((E . E ' ,y)-* \nP ) The singleton heap h@e makes the left conjunct true. That h-e satis.es the right conjunct follows \nfrom the wp assump\u00adtion, which implies that P is true if we update the original heap h by mapping the \n.rst component of e to [ E ' ] s. That is, the semantics of -* and of the instance of . to its left conspire \nto ensure that h-e satis.es the right conjunct. The clauses for . and * imply that s, h satis.es the \nprecondition. For soundness of Backwards Cons, assume that s, h satis\u00ad.es the precondition. By the operational \nrule for allocation we need to show [s | x . e], [h | e .(v1,v2)] |= P when e . dom(h), [ E1] s = v1, \nand [ E2] s = v2. We know that [s | x ' . e], [h | e .(v1,v2)] satis.es P [x ' /x], from the de.nitions \nof -* , . and .. The result then follows using standard lemmas about renaming variables and removing \nfrom a state those not appearing freely in an expression. For completeness, assume s, h . wp(x := cons(E1,E2),P \n). From the operational rule for cons, we obtain that [s | x . e], [h | e .([ E1] s, [ E2] s)] |= P for \nany location e . dom(h) (non-determinism of is being used here). That s, h satis.es the precondition \nthen follows immediately from this and the de.nitions. End of Proof  6. DISPOSE All of the axioms we \nhave considered so far are compatible with the presence of dangling pointers, and dangling point\u00aders \nplay an important role in the interpretations of * and -* . We might as well push this further and consider \na command dispose(E) which deallocates a location (thereby creates a dangling pointer). The semantics \nof dispose is a slippery subject, and what happens on subsequent attempts to dereference a disposed location \ntends to be unde.ned by programming language de.nitions. Operationally, we take the position that dispose \nsimply removes a location from the heap. e . Loc e . dom(h)[ E] s = e dispose(E),s,h s, (h - e) Recall \nthat h - e is h with e removed. We do not wish to enter into a controversy over how well this models \nunde.ned . Indeed, there may be no de.nitive operational semantics of dispose, and it is perhaps better \ntreated from an axiomatic perspective. Dispose Suppose that a, b are not free in E. Then, E P *.ab. (E \n. a, b) dispose(E) E P This axiom takes the view that you simply shouldn t depend on what contents the \ndisposed location might or might not have in the postcondition. Reasoning backwards from true we can \n.nd circumstances under which a program is safe to execute. For a double dis\u00adpose we obtain false as \nthe precondition as expected, indi\u00adcating that the program is not safe to execute for any start state. \n{false} {true *.ab. (x . a, b) *.cd. (x . c, d)} dispose(x) {true *.ab. (x . a, b)} dispose(x) {true} \nProposition 5. The Dispose axiom expresses the weak\u00adest precondition. Proof. For soundness, assume the \nprecondition holds for s, h. The precondition ensures [ E] s = e . dom(h) is a de.ned location, so the \ncommand does not get stuck. The result of the dispose statement is the pair s, h - e, and we need to \nshow that s, h - e |= P . This follows using the de.nitions of ., * and ., For completeness, assume s, \nh . wp(dispose(E),P ). From the operational rule and the de.nition of wp, which requires safety, we obtain \nthat [ E] s = e . dom(h) is a location that points to something, say (v1,v2), and that s, h - e |= P \n. It is clear that [s | x . v1,y . v2],h@e |= E . x, y so, by the semantics of . and *, and the assumption \nthat x, y . free(P ), we obtain that s, h satis.es the precondition as required. End of Proof 7. A SMALL \nEXAMPLE We give a small example: a program for disposing a list. To formulate the precondition, we use \nan inductive de.nition of a predicate rep nE, which says that E represents a list of size n. . rep 0 \nE .. E = nil . emp . rep n +1 E .. .xy. (E . x, y) * rep n y. Then E points to a non-circular linked \nlist when rep nE holds for some n, and we de.ne . nclist E .. .n. rep n E. Note that this de.nition just \nsays that E points to a list, and ignores head links; variations are possible.2 The speci.cation for \nthe program says that, if p points to a list to begin with, then the program will (assuming it terminates) \ndelete all the cells, resulting in the empty heap. (The presence of emp in the base case of the inductive \nde.nition is necessary for this.) {nclist p} while p = nil do q := p; p := p.2; dispose(q) {emp} Now, \nwe use the usual Hoare partial-correctness rule for while loops, where we choose the precondition as \nthe invari\u00adant. A proof outline for the body is {p = nil . nclist p} {.p0. .x. (p . x, p0) * nclist p0} \n{.p0..x. (p . x, p0) . (nclist p0) *.ab. (p . a, b) } q := p {.p0..x. (p . x, p0) . (nclist p0) *.ab. \n(q . a, b) } p := p.2 {(nclist p) *.ab. (q . a, b)} dispose(q) {nclist p} In the second line we have \nlisted an intermediate step used in applying the rule of consequence. To complete the proof, combining \nthe negation of p = nil with the invariant we obtain p = nil . nclist p as a valid postcondition for \nthe whole program. This im\u00adplies emp by the de.nition of rep and so, by the rule of consequence, we are \ndone. 8. LOCALITY OF SPECIFICATIONS AND REASONING Consider again the speci.cation of the program to \ndispose a list. 2We have not included recursive de.nitions in the formal syntax, but the intent should \nbe clear. In any case, we will be somewhat less formal here, and in particular use a .n for quantifying \nover natural numbers only. {nclist p} \u00b7 \u00b7\u00b7 {emp} The .rst thing to notice here is the exact nature of \nthe precondition: if nclist p is true then there can be no cells in the current heap other than those \nin the list pointed to by p. That is, nclist p holds of a structure p ..... nil but not of a heap with \nadditional nodes not in the list. It is possible for one of the head nodes to contain a pointer, but \nthat pointer must either be to one of the nodes in the list or be dangling. This exact nature comes about \nbecause of the use of emp in the base case of rep, and also because of the exact nature of .. In fact, \nsuch an exact speci.cation is necessary, because if there were junk cells , cells in the heap but not \nin the list, then we could not conclude emp on termination. Here junk is relative: it just means cells \nthat are not relevant to the correct operating of the program, not necessarily garbage cells. The second \nthing to note is that these junk cells have been avoided without talking about them explicitly in the \nde.nition of nclist p. Normally, one would have to include an auxiliary clause which says for all cells, \nif that cell is in the heap it is in the list . But we did not need to. However, there appears to be \na problem with the speci\u00ad.cation: what if we want to run the program when there are extra cells around? \nThe speci.cation appears not to be strong enough. Intuitively, however, we have veri.ed ex\u00adactly the \ncorrect property: the precondition mentions only those cells which are accessed by the program during \nexecu\u00adtion. Why should we have to mention others? This section explains why we don t have to. The basis \nfor our approach is a local property of speci.\u00adcations, which we state informally as follows. If {P }C{Q} \nholds, then execution of C in a state satisfying P can attempt to dereference only those heap cells guaranteed \nto exist by P . Conventionally, the assumption is that a pre/post speci.\u00adcation makes a positive statement \nabout alterations to the store that can be made, but additional changes are allowed: this leads to the \nneed for explicit frame axioms, which say what doesn t change. The formalism here turns the situa\u00adtion \naround, by restricting the alterations (to the heap) that can be made to be those speci.cally mandated \nby the spec\u00adi.cations. Explicit provision is then required to sanction changes, instead of to disallow \nthem. In this section we investigate these ideas by examining a rule, Frame Axiom Introduction. 8.1 Local/Global \nInteraction The discussion above is concerned exclusively with the heap. For all we know, if {x . 1, \n2}C{x . 3, 2} holds then C might change a stack variable z. For example, z := 7; x.1 := 3 satis.es the \nspeci.cation. So, in order to state the rule for frame axiom introduction, we need to keep track of stack \nvariables altered by a program. We do this with a syntactic condition. De.ne Modi.esOnly(C) to be the \nset of (free) variables appearing alone to the left of := in C. The quali.cation alone means, for example, \nthat the set Modi.esOnly(x.i := E) is empty: Modi.esOnly is concerned with modi.cations to stack variables \nonly here. Frame Axiom Introduction {P }C{Q} Modi.esOnly(C) n free(R)= \u00d8 {P * R}C{Q * R} It is important \nto see that we cannot use . instead of *, as the resulting rule is unsound. More positively, using this \nrule we can perform an inference {(x . 1, 2)}C{(x . 3, 2)} {(x . 1, 2) * (z . 7, 11)}C{(x . 3, 2) * (z \n. 7, 11)} as long as we know that C doesn t modify the stack variable z. We use * here to identify a \nportion of the heap that is not modi.ed. The soundness of Frame Axiom Introduction can be shown for assignment \nstatements, sequencing, looping, and condi\u00adtionals. A thorough theoretical account of this rule and its \nconsequences will be presented in a future paper [27]. 8.2 Framing Procedure Speci.cations Frame axioms \ntake on greater importance in the presence of procedures, where one wants to be able to specify a pro\u00adcedure \nwithout referring to its code [2]. We give a brief discussion of procedures in light of the above. Let \nus regard the program for disposing a list as a pro\u00adcedure, parametric in p, and where the auxiliary \nvariable q is local. To specify DisposeList we should give not only the precondition and postcondition, \nbut also a Modi.esOnly clause. {nclist p} DisposeList(p) {emp} Modi.esOnly(DisposeList(p)) = {p} We claim \nthat just using the local speci.cation, which only mentions those heap cells touched by the program, \nwe can infer properties of calls in wider contexts. A good example of this is when we chain two calls \nto DisposeList, to dispose of two di.erent lists. Then, using Frame Introduction together with Sequencing \nand Consequence, we can infer that the two calls work properly, as long as the input lists don t overlap. \nE E nclist p DisposeList(p) emp E E (nclist p) * (nclist q) DisposeList(p) emp * nclist q E E (nclist \np) * (nclist q) DisposeList(p) nclist q E E Then, the speci.cation nclist q DisposeList(q) emp to\u00adgether \nwith the usual Hoare rule for sequencing gives us E E (nclist p)*(nclist q) DisposeList(p); DisposeList(q) \nemp as desired. Conventionally, an explicit frame axiom would be needed to sanction a conclusion of this \nsort, because oth\u00aderwise we would have no way of knowing that DisposeList(p) doesn t alter the list pointed \nto by q. (For instance, if the .rst call were to incorrectly dispose of one of the nodes in q s list, \nthen we would get a safety violation in the second.) The same principle works when we chain together \ncalls to di.erent procedures, such as procedures for inserting into, deleting from, or copying lists. \nIt is important to realize that the use of * in the con\u00adjunction (nclist p) * (nclist q) is not simply \na reachability condition, which states, say, that the cells reachable from p and q are disjoint. For \ninstance, (nclist p) * (nclist q) holds of p ..... nil ..... nil q Here, it is certainly possible to \nreach one list from the other, by following head links, but this does not cause a runtime error in DisposeList(p); \nDisposeList(q). 9. THE INTUITIONISTIC SEMANTICS In this section we consider an intuitionistic semantics. \nAll assertions will satisfy the Monotonicity Condition: If s, h |= P and h . h ' then s, h ' |= P , where \nh . h ' indicates that the graph of h is a subset of the graph of h ' . Formally, the intuitionistic \nlanguage is obtained by omitting emp, adding clauses for intuitionistic connectives that cannot be de.ned \naway s, h |= P . Q i. s, h |= P and s, h |= Q s, h |= P . Q i. s, h |= P or s, h |= Q s, h |= .x.P i. \n.v . V al. [s | x . v],h |= P and making two rede.nitions: s, h |= E . E1,E2 i. [ E] s . dom(h) and h([[E] \ns)= ([ E1] s, [ E2] s) s, h |= P . Q i. .h ' . h. if s, h ' |= P then s, h ' |= Q. The other semantic \nclauses are as in Section 3.1.3 To see why the law of the excluded middle fails in this model, consider \n3Intuitionistic . usually quanti.es over future possible worlds, but in a .xed-domain semantics (where \nthe same individuals exist at each world) the pointwise de.nition re\u00admains adequate. Also, in the clause \nfor * one might have expected to see a condition h0 \u00b7 h1 . h instead of asking (x . 2, 2) .\u00ac(x . 2, 2), \nwhere \u00acP = P . false. If s is a stack with sx = e and [] is the empty heap, then s, [] |= x . 2, 2. But \nwe also have s, [] |= \u00ac(x . 2, 2), since there is an extension [e . 2, 2] of [] where s, [e . 2, 2] |= \nx . 2, 2. So s, [] |=(x . 2, 2) .\u00ac(x . 2, 2). The semantic consequence relation and interpretation of \ntriples are de.ned as before. Some of the basic properties of the logic are altered by the intuitionistic \nsemantics. Proposition 6. Propositions 1 and 2 go through for the intuitionistic semantic of this section, \nwith the following changes: The semantics validates intuitionistic rather than clas\u00adsical logic, so \nthat excluded middle fails generally;  true is the unit of *;  Weakening for * holds: A * B |= A; \n Excluded middle holds for pure assertions;  P *Q and P .Q are equivalent if P is pure, even when Q \nis not.  A useful observation is that the classical and intuitionis\u00adtic interpretations behave similarly \nwhen . appears as an immediate constituent of *. To formulate this, recall that if e . dom(h) then we \nuse h@e to denote the singleton heap in which e is mapped to h(e). Lemma 7. [Exactness Lemma] s, h |=(E \n. E1,E2) * P in the intuitionistic semantics i. there is some e . dom(h) such that s, h@e |=(E . E1,E2), \nand s, h - e |= P . Thus, even though the intuitionistic semantics uses an in\u00adexact interpretation of \n., we can get away with the exact interpretation when looking at one occurrence of . in an argument to \n*. This explains why it is possible to use ei\u00adther of the intuitionistic or classical semantics for the \nsame program-proving axioms. Theorem 8. The weakest precondition results hold for the intuitionistic \nsemantics. Of course, this result has a di.erent import than the previ\u00adous ones, because it refers exclusively \nto intuitionistic propo\u00adsitions, that are invariant under heap extension. The only alterations to the \nprevious proofs involve an appeal to the Exactness Lemma in several places, and appeals to mono\u00adtonicity \nin some situations where it was not needed in the argument for classical semantics (the completeness \nparts of Backwards Cons and Backwards Object-component Assign\u00adment). We can compare the two semantics \nby noting that we can translate from the intuitionistic language into the classical one using a modal \ntranslation. We do not actually need to extend the classical language with an explicit modality to do \nthis, because we can already express the necessity modality for heap extension. That is, for equality: \nbut the monotonicity condition, together with the fact (true of the particular model here) that h0 \u00b7 \nh1 . h when h bounds each, implies that the two de.nitions are equivalent. s, h |= true-* P i. .h ' . \nh. s, h ' |= P holds in the classical semantics. The Modal Translation. The translation (\u00b7). sends E \n. E1,E2 to E . E1,E2 P . Q to true-* (P . . Q.) and everything else (inductively) to itself.4 Proposition \n9. s, h |= P in the intuitionistic semantics i. s, h |= P . in the classical semantics. So, the classical \nsemantics is, in this sense, the more ex\u00adpressive of the two. More to the point, the intuitionistic semantics \nhas an additional condition, monotonicity, and we should ask whether there are any properties of interest \nthat do not satisfy it. It turns out that many natural pre-and postconditions for pointer algorithms \ndo satisfy monotonicity. Often, one makes a positive statement to the e.ect that a collection of cells \nin the heap represents some abstract data structure, and these cells continue to represent the structure \nwhen more cells are added. Still, there are some natural prop\u00aderties that do not satisfy monotonicity. \nAn example is given by the rep and nclist predicates from Section 7. There, the use of emp in the base \ncase of rep has the e.ect of limiting a heap satisfying nclist E to exactly those cells reachable, by \nfollowing tail links, from E; this was essential for showing that all of the cells were de-allocated. \nOther typical prop\u00aderties of this sort are that there is a unique pointer (in the heap) to cons cell \nx, or that the heap has exactly 4 cons cells. Generally, non-monotone properties are useful in situations \nwhere one is concerned with close control over memory us\u00adage, such as when ensuring that there are no \nspace leaks. We conclude this section by contrasting the two semantics using a subtle example from [35], \nthe following instance of the Cons axiom: E \u00ac.x. x . 1, 2 y := cons(1, 2) E (\u00ac.x. x . 1, 2) * (y . 1, \n2) . At .rst sight it looks as if the triple should be false, because the postcondition appears to be \ninconsistent. The intuition\u00adistic semantics saves the situation by making the precon\u00addition inconsistent \nas well. To see why, consider any s, h. We can extend h with a location e . dom(h), and obtain [h | e \n.(1, 2)]. Since this heap extends h, the intuitionis\u00adtic negation quanti.es over it. And in this extended \nheap, .x. x . 1, 2 is true. The same triple holds as well in the classical semantics, but the reason \nnow is not that the precondition is false, but rather that the postcondition is not inconsistent. That \nis, \u00ac.x. x . 1, 2 may be true of a small world but false at a bigger one, and the * in the postcondition \nlets us pick this smaller world out without incurring falsity at the big world. For example, in the singleton \nheap where the a location denoted by x has contents (1, 2) the empty heap can be 4This translation uses \nthe induced modality less often than one might have expected. Normally, one would use the modality with \n. as well, and a backwards modality in the case of *. It is speci.c properties of the model (constant \ndomain, bounding properties of \u00b7) that justify the simpler translation. selected for \u00ac.x. x . 1, 2 and \nthe singleton heap itself for x . 1, 2. The absence of Weakening in the classical semantics is signi.cant \nhere. For, if we had (\u00ac.x. x . 1, 2) * (y . 1, 2) |= \u00ac.x. x . 1, 2, and (\u00ac.x. x . 1, 2) * (y . 1, 2) \n|= y . 1, 2 then we could obtain (\u00ac.x. x . 1, 2) * (y . 1, 2) |=(\u00ac.x. x . 1, 2) . (y . 1, 2), the consequent \nof which is contradictory. 10. SUMMARY AND RELATED WORK The most relevant related work is contained in \nthe two main precursors, the papers of Burstall and Reynolds [5, 35]. To summarize our additions to [35], \nwe have: (i) provided a classical model, and investigated the relation between classi\u00adcal and intuitionistic \nvariants; (ii) added BI s spatial impli\u00adcation -* to the assertion language, and used it to express weakest \npreconditions; (iii) given a treatment of dispose; and (iv) further explicated the form of local reasoning \nmade possible by the spatial approach to pointer logic. There have been a number of papers on program-proving \nfor pointers ([16, 30, 23, 17, 22, 11, 3, 6] is a partial list). What sets the approach of Reynolds and \nBurstall apart is its local treatment of assignment. In other approaches as\u00adsignment in the presence \nof aliasing tends to be dealt with using global store parameters, or several global parameters, or with \naxioms that involve major surgery on formulae. In contrast, in {P * (x . a, b)}x.1 := z{P * (x . z, b)} \nthe op\u00aderationally local nature of assignment is mirrored beautifully in the logic. There has been growing \ninterest in using program logic for pointers in static analysis and related problems, and some excellent \nresults have been obtained [18, 24, 37, 40]. The work here appears to be largely complementary. Indeed, \nal\u00adthough the devil is in the detail, it would be conceivable to combine one of these assertion languages \nwith a substruc\u00adtural logic, in the style of BI. The main question is whether such a combination would \ngive rise to local reasoning or speci.cations, in a way that does not interfere with the al\u00adready successful \nproperties of these languages. We described the local character of speci.cations in the logic, and began \nan exploration of its consequences by con\u00adsideration of the rule for introducing frame axioms. There \nare many vaguely related ideas in dozens of papers in the AI, modal and temporal logic of processes, \nand program speci.\u00adcation literatures; we cannot do justice to these literatures in this short space \n(we mention only one from each strand: [33, 20, 1]). The main point, however, is the implicit and succinct \nway that behind-the-scenes dependencies, which arise from pointers that are not directly named by program \nvariables, are dealt with using *. We are not aware of a previous ap\u00adproach that deals with these dependencies \nin a comparable manner. That being said, there is much more to be learnt about local reasoning; some \nfurther developments will be presented in a followup paper [27]. In addition, it would be interesting \nto attempt to apply these ideas in related situa\u00adtions where aliasing is prevalent, such as p-calculus \nor object calculi. In the linear logic literature there have been numerous hints, suggesting that substructural \nlogic can be used to specify and reason about actions locally (e.g. [13, 21]). While this proposal was \ntantalyzing, it has not subsequently been developed very far, certainly not as far as a program logic \nfor pointers. (Encodings of the semantics of impera\u00adtive languages, e.g. [9], are important and useful, \nbut fall well short of program logic.) The results of this paper might be interpreted as o.ering fresh \njusti.cation for those early hints, and in the demanding territory of pointers, albeit for a logic that \nis di.erent from linear logic in key respects. A feature of BI is that it o.ers a simple-minded treatment \nof additive connectives (based on classical or intuitionistic logic) alongside substructural ones; there \nis no ! , and no need to stay within a constructive setup. This comparative simplicity, as illustrated \nby the pointer model, is a key to applications. There are two other closely related pieces of work to \nreport on. The .rst is work of Cardelli and Gordon on Ambient Logic [8], a logic for mobile ambients. \nTheir logic can be seen as an extension of Boolean BI; on the common connec\u00adtives, the semantic models \nof Ambient Logic that have been presented are instances of the possible worlds semantics of BI .rst presented \nin [25] and further developed in [26, 32]. Ambient logic also has a connective, the ambient match , which \ninteracts with * in a way that leads to pleasantly compact and intuitive speci.cations of certain properties \nof mobile processes. In an interesting further development, Cardelli and Ghelli have proposed a labelled \ntree model as a basis for a query language for semi-structured data [7]. The tree model is similar to \nthe pointer model of BI, but for two main di.er\u00adences: the model here allows for circular structures \nas well as trees; and, the combining operation here is partial, where in the labelled tree model it is \ntotal. Partiality enables us to ensure that subheaps are disjoint, and this is essential for the soundness \nof the Hoare triple axioms. We speculate that the ideas in this paper, especially those involving the \ninteraction between * and -* , might be adapted to account for update or recon.guration of semi-structured \ndata. The second closely related work is that of Smith, Walker, and Morrisett on Alias types [38, 39]. \nAlias types use type\u00adtheoretic cousins of the conjunction * and points-to relation . to state properties \nof data structures. The resulting typ\u00ading rule for component assignment is very close to (a CPS version \nof) Reynolds s axiom, and their treatment of mem\u00adory disposal is very near to that here. Of course, the \nbene.t of a type system is that it is static, while conversely logic is more expressive. In any case, \nthe remarkable convergence of ideas in spatial pointer logic and in Alias types might per\u00adhaps be taken \nas a positive indication, of the naturalness of the approach. Acknowledgements We are grateful to David \nPym, Uday Reddy and John Reynolds for advice and comments that helped to improve the material in this \npaper. This research was supported by a grant from the EPSRC. 11. REFERENCES [1] Alur, R., and Grosu, \nR. Modular re.nement of hierarchic reactive machines. In POPL [31]. [2] Borgida, A., Mylopoulos, J., \nand Reiter, R. On the frame problem in procedure speci.cations. IEEE Transactions of Software Engineering \n21 (1995), 809 838. [3] Bornat, R. Proving pointer programs in Hoare logic. In Fifth Internationsl Conference \non Mathematics of Program Construction, LNCS 1837, Ponte de Lima, Portugal, 2000. [4] Brookes, S., Main, \nM., Melton, A., and Mislove, M., Eds. Mathematical Foundations of Programming Semantics, Eleventh Annual \nConference (Tulane University, New Orleans, Louisiana, March 29 April 1 1995), vol. 1 of Electronic Notes \nin Theoretical Computer Science, Elsevier Science. [5] Burstall, R. Some techniques for proving correctness \nof programs which alter data structures. Machine Intelligence 7 (1972), 23 50. [6] Calcagno, C., Ishtiaq, \nS., and O Hearn, P. Semantic analysis of pointer aliasing, allocation and disposal in Hoare logic. Proceedings \nof the 2nd international ACM SIGPLAN conference on on Principles and practice of declarative programming, \n2000. [7] Cardelli, L., and Ghelli, G. A query language for semistructured data based on the ambient \nlogic. Manuscript, 4 April 2000. [8] Cardelli, L., and Gordon, A. D. Anytime, anywhere. modal logics \nfor mobile ambients. In POPL [31]. [9] Cervesato, I., and Pfenning, F. A linear logical framework. In \nProceedings of the Eleventh Annual Symposium on Logic in Computer Science LICS 96 (27 30 July 1996), \nIEEE Computer Society Press, pp. 264 275. [10] Cook, S. A. Soundness and completeness of an axiomatic \nsystem for program veri.cation. SIAM J. on Computing 7 (1978), 70 90. [11] de Boer, F. A WP calculus \nfor OO. In Proceedings of FOSSACS 99 (1999). [12] Girard, J.-Y. Linear logic. Theoretical Computer Science \n(1987), 1 102. [13] Girard, J.-Y. Towards a geometry of interaction. In Categories in Computer Science \nand Logic (1989), American Mathematical Society, pp. 69 108. Contemporary Mathematics Volume 92. [14] \nGuttag, J., Horning, J., and Wing, J. Larch in .ve easy pieces. TR 5, DEC Systems Research Center, 1985. \n[15] Hoare, C., and He, J. A trace model for pointers and objects. In ECCOP 99 -Object-Oriented Programming, \n13th European Conference (1999), R. Guerraoui, Ed., pp. 1 17. Lecture Notes in Computer Science, Vol. \n1628, Springer. [16] Hoare, C. A. R., and Wirth, N. An axiomatic de.nition of the programming language \nPascal. Acta Informatica 2 (1973), 335 355. [17] Honsell, F., Mason, I. A., Smith, S., and Talcott, C. \nA variable typed logic of e.ects. Information and Computation 119, 1 (may 1995), 55 90. [18] Jenson, \nJ., Jorgensen, M., Klarkund, N., and Schwartzback, M. Automatic veri.cation of pointer programs using \nmonadic second-order logic. In Proceedings of the ACM SIGPLAN 97 Conference on Programming Language Design \nand Implementation (1997), pp. 225 236. SIGPLAN Notices 32(5). [19] Kripke, S. A. Semantical analysis \nof intuitionistic logic I. In Formal Systems and Recursive Functions, J. N. Crossley and M. A. E. Dummett, \nEds. North-Holland, Amsterdam, 1965, pp. 92 130. [20] Leino, K. Toward Reliable Modular Programs. Ph.D. \nthesis, California Institute of Technology, Pasadena, California, 1995. [21] Miller, D. Observations \nabout using logic as a speci.cation language. In GULP-PRODE 95 Joint Conference on Declarative Programming \n(Marina de Vietri, Salerno, Italy, September 1995). [22] Moller, B. Calculating with pointer structures. \nIn Proceedings of Mathematics for Software Construction, (1997), Chapman and Hall, pp. 24 48. [23] Morris, \nJ. A general axiom of assignment. Assignment and linked data structure. A proof of the Schorr-Waite algorithm. \nIn Theoretical Foundations of Programming Methodology (1982), M. Broy and G. Schmidt, Eds., Reidel, pp. \n25 51. [24] Necula, G. Proof-carrying code. In In Proceedings of the 24th Annual ACM SIGPLAN-SIGACT Symposium \non Principles of Programming Langauges (POPL 97) (1997). [25] O Hearn, P., and Pym, D. The logic of bunched \nimplications. Bulletin of Symbolic Logic 5, 2 (June 99), 215 244. [26] O Hearn, P., Pym, D., and Yang, \nH. Possible worlds and resources: The semantics of BI. Submitted, October 2000. [27] O Hearn, P., and \nYang, H. Local reasoning about pointer programs using bunched implications. In Preparation, 2000. [28] \nO Hearn, P. W., Power, A. J., Takeyama, M., and Tennent, R. D. Syntactic control of interference revisited. \nTheoretical Computer Science 228, 1-2 (October 1999), 211 252. Preliminary version in [4] and in [29], \nvol 2. [29] O Hearn, P. W., and Tennent, R. D., Eds. Algol-like Languages. Two volumes, Birkhauser, Boston, \n1997. [30] Oppen, D. C., and Cook, S. A. Proving assertions about programs that manipulate data structures. \nIn Conference Record of Seventh Annual ACM Symposium on Theory of Computation (Albuquerque, New Mexico, \n5 7 May 1975), pp. 107 116. [31] Conference Record of the 27th Annual ACM SIGPLAN-SIGACT Symposium on \nPrinciples of Programming Languages (2000), ACM, New York. [32] Pym, D. The semantics and proof theory \nof the logic of bunched implications. Monograph in Preparation, 2000. See http://www.dcs.qmw.ac.uk/ \npym. [33] Reiter, R. The frame problem in the situation calculus: a simple solution (sometimes) and a \ncompleteness result for goal regression. In V. Lifschitz, editor, Arti.cial Intelligence and Mathematical \nTheory of Computation: Papers in Honor of John McCarthy, pages 359 380. Academic Press, 1991. [34] Reynolds, \nJ. C. Syntactic control of interference. In Conference Record of the Fifth Annual ACM Symposium on Principles \nof Programming Languages (Tucson, Arizona, January 1978), ACM, New York, pp. 39 46. Also in [29], vol \n1. [35] Reynolds, J. C. Intuitionistic reasoning about shared mutable data structure. In Millenial Perspectives \nin Computer Science, Palgrove, 2000. [36] Reynolds, J. C. Lectures on reasoning about shared mutable \ndata structure. IFIP Working Group 2.3 School/Seminar on State-of-the-Art Program Design Using Logic. \nTandil, Argentina, September 2000. [37] Sagiv, M., Reps, T., and Wilhelm, R. Parametric shape analysis \nvia 3valued logic. In POPL 99. [38] Smith, F., Walker, D., and Morrisett, G. Alias types. Proceedings \nof ESOP 99. [39] Walker, D., and Morrisett, G. Alias types for recursive data structures. Manuscript, \nApril 2000. [40] Xu, Z., Miller, B., and Reps, T. Safety checking of machine code. In PLDI 00.   \n\t\t\t", "proc_id": "360204", "abstract": "Reynolds has developed a logic for reasoning about mutable data structures in which the pre- and postconditions are written in an intuitionistic logic enriched with a spatial form of conjunction. We investigate the approach from the point of view of the logic BI of bunched implications of O'Hearnand Pym. We begin by giving a model in which the law of the excluded middleholds, thus showing that the approach is compatible with classical logic. The relationship between the intuitionistic and classical versions of the system is established by a translation, analogous to a translation from intuitionistic logic into the modal logic S4. We also consider the question of completeness of the axioms. BI's spatial implication is used to express weakest preconditions for object-component assignments, and an axiom for allocating a cons cell is shown to be complete under an interpretation of triplesthat allows a command to be applied to states with dangling pointers. We make this latter a feature, by incorporating an operation, and axiom, for disposing of memory. Finally, we describe a local character enjoyed by specifications in the logic, and show how this enables a class of frame axioms, which say what parts of the heap don't change, to be inferred automatically.", "authors": [{"name": "Samin S. Ishtiaq", "author_profile_id": "81100570936", "affiliation": "Queen Mary &amp; Westfield College, London, UK", "person_id": "P325873", "email_address": "", "orcid_id": ""}, {"name": "Peter W. O'Hearn", "author_profile_id": "81332519314", "affiliation": "Queen Mary &amp; Westfield College, London, UK", "person_id": "PP43122327", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/360204.375719", "year": "2001", "article_id": "375719", "conference": "POPL", "title": "BI as an assertion language for mutable data structures", "url": "http://dl.acm.org/citation.cfm?id=375719"}