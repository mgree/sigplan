{"article_publication_date": "01-01-2001", "fulltext": "\n Avoiding Exponential Explosion: Generating Compact Verification Conditions Cormac Flanagan James B. \nSaxe Compaq Systems Research Center 130 Lytton Ave. Palo Alto, CA 94301 Abstract Current verification \ncondition (VC) generation al- gorithms, such as weakest preconditions, yield a VC whose size may be exponential \nin the size of the code fragment being checked. This paper de- scribes a two-stage VC generation algorithm \nthat generates compact VCs whose size is worst-case quadratic in the size of the source fragment, and \nis close to linear in practice. This two-stage VC generation algorithm has been implemented as part of \nthe Extended Static Checker for Java. It has allowed us to check large and complex methods that would \notherwise be im- possible to check due to time and space constraints. Introduction Developing a reliable \nsoftware system is a challeng- ing task. A promising technique for ensuring soft- ware reliability is \nto verify statically the absence of as many errors as possible. Type systems have been successful at \nstatically detecting certain kinds of errors, for example, applying a function to an in- correct number \nof arguments. The goal of the Extended Static Checking project [DLNS98, LSS99, Ext] is to detect stati- \ncally additional errors that are normally detected only at run-time, if ever. Such errors include null \npointer dereferences, array bounds errors, division Permission to make digital or hard copies of all \nor part of this work personal or classroom use is granted without fee provided that copies are not made \nor distributed for profit or commercial advan- tage and that copies bear this notice and the full citation \non the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior specific permission and/or a fee. POPL '01 1101 London, UK &#38;#169; 2001 ACM ISBN 1-58113-336-7/01/0001 \n.-$5.00  by zero, and the violation of programmer-specified properties such as method preconditions, \nmethod postconditions, and object invariants. Performing this kind of checking requires detailed reasoning \nabout both the semantics of the program fragment being checked and the desired correctness property. \nA standard approach for performing this kind of analysis is to split the problem into two stages. The \nfirst stage, VC Generation, translates a program fragment and its correctness property into logical formula, \ncalled a verification condition (VC). The VC has the property that if it is valid then the program fragment \nsatisfies its correctness property. The second stage then uses an automatic decision procedure (see, \ne.g., [NelS1, DNS01]) to determine the validity of the VC. This approach works well for smaller or simpler \nprogram fragments. However, it is difficult to scale this approach to larger fragments that have more \ncomplex control flow, in part due to the extremely large size of the corresponding VCs produced by current \nVC generation algorithms. These algo-rithms can yield impractically large VCs for rou- tines that contain \nonly a few dozen lines of code. For example, the weakest precondition transla- tion [Dij76] produces \na VC that may be exponen- tial in the size of the original program fragment. Such large VCs are expensive \nto create, to store, and to verify. This exponential blow up is not only a theoretical concern; we have \nobserved this behav- ior in practice on several more complex methods that we have tried to check using \nthe Extended Static Checker for Java (ESC/Java). This situa- tion is unfortunate since these complex \nmethods would benefit most from automated techniques for software defect detection. Other VC generation \nalgorithms, such as strongest postconditions or symbolic execu-tion [NL98], also suffer from the potential \nfor ex- ponential blow up. This paper presents a new VC generation al- gorithm. The algorithm is based \non an investiga- tion into the cause of the exponential worst-case behavior of the weakest precondition \ntranslation. This investigation reveals that assignment state- ments are the primary cause of exponential \nbe- havior, both directly and through their interaction with control-flow merge points. Based on this \ninsight, we develop a two-stage VC generation algorithm. The first stage trans- lates a source fragment \ninto an assignment-free, or passive, intermediate form. The second stage uses a VC generation technique \nthat is optimized to exploit the assignment-free nature of the passive form. This two-stage VC generation \nalgorithm cre- ates a VC whose size is worst-case quadratic in the size of the source fragment, and in \npractice appears to be close to linear. The use of this two-stage VC generation algo- rithm has significantly \nimproved the performance of ESC/Java. As expected, the smaller VCs are cheaper to create and store. In \naddition, our automatic decision procedure, Simplify [DNS01], requires less time to verify the validity \nof these smaller VCs. The combination of these per-formance improvements has enabled us to check a number \nof large and complex methods using ESC/Java that we were previously unable to check. The presentation \nof our results proceeds as fol- lows: Section 2 reviews ESC/Java, which provides the context for this \nwork. Section 3 introduces the intermediate language that we use as the basis for our development. Section \n4 defines the seman- tics of that language using the weakest precondi- tion translation, and outlines \nthe problems with this translation. Section 5 describes the transla- tion of intermediate language statements \ninto pas- sive form, and Section 6 describes an optimized VC generation algorithm for passive statements. \nSec-tion 7 extends our development to handle loops and exceptions. Section 8 describes the performance \nbenefits of the two-stage VC generation algorithm in the context of ESC/Java. Section 9 describes related \nwork, and we offer some conclusions in Sec- tion 10. 2 Review of ESC/Java The Extended Static Checker \nfor Java is a tool for finding, by static analysis, common defects in Java programs that are not normally \ndetected un- til run-time, if ever [LSS99, LNS00]. ESC/Java is publicly available for research and educational \npurposes [Ext]. It takes as input a Java program, possibly including user annotations, and produces as \noutput a list of possible defects in the program. The annotations in the input program de-scribe program \nproperties such as method precon- ditions, method postconditions, and object invari- ants. These annotations \nallow ESC/Java to catch software defects using a modular, or method-local, analysis. During this analysis, \nESC/Java verifies that the annotations are consistent with the program, and it also uses the annotations \nto verify that each prim- itive operation (such as a dereference operation, an array access, or a type \ncast) will not raise a run-time exception (as might happen, for exam- ple, if a dereferenced pointer \nis null or if an array index is out-of-bounds). To perform this analy- sis, ESC/Java first translates \neach method and its correctness property into a verification condition, and then uses an automatic decision \nprocedure to determine the validity of the verification condition. Since the properties that it attempts \nto check are undecidable in the worst case, ESC/Java con- tains some degree of incompleteness and unsound- \nness by design. That is, it sometime issues spu- rious warnings and sometimes fails to detect gen- uine \nerrors. However, the aspects of ESC/Java's processing that give rise to unsoundness and in- completeness \nare orthogonal to this paper. Except for the loop desugaring briefly discussed in section 7.1, none of \nthe translations described below are unsound or incomplete. 3 Guarded Commands Deriving verification \nconditions for a large and realistic language such as Java is quite complex. To help structure and modularize \nthis translation, A,B,S E Stmt ::= asserte I assume e I [ I x:.~e A;B AOB e x e E Expr Vat (expressions) \n(variables) Figure 1: The guarded command language. ESC/Java first translates each method and its cor- \nrectness property into an intermediate representa- tion, known as a guarded command. This trans- lation \neliminates many of the complexities of the Java programming language and incorporates engi- neering compromises \ninvolving soundness and com- pleteness; it is outlined elsewhere [LSS99]. In this paper, we focus on \nthe subsequent trans- lation of the guarded command representation into a verification condition, and, \nin particular, on how to generate a verification condition that is compact and can be efficiently verified \nusing an automatic decision procedure. We base our development on the intermediate guarded command language \nshown in Figure 1. The language is a variation of Dijkstra's guarded commands [Dij76], together with \nsome more recent additions (see, e.g., [Ne189, BvW98]). The lan-guage includes assert and assume statements, \nas-signment statements, sequential composition, and demonic (indeterminate) choice. (By including as- \nsume statements, we no longer need the \"guards\" than originally gave the language its name.) The guarded \ncommand language used by ESC/Java is a small extension of this language with loops and exceptions; to \nclarify our presentation we defer dis- cussion of these constructs to Section 7. 3.1 Informal Semantics \nThe execution of a guarded command statement has two possible outcomes: it may terminate nor- mally (in \nsome program state) or it may \"go wrong\" due to a failed assertion. The execution of the statement assert \ne terminates normally if the predicate e evaluates to true in the current pro- gram state, and goes wrong \notherwise. The assume S wp.S.Q assert e e A Q assumee e ~ Q x := e Q(x := e) A ; B wp.A.(wp.B.Q) A D \nB wp.A.Q A wp.B.Q Figure 2: Weakest-precondition semantics. statement is partial: assume e terminates \nnor-mally if the predicate e evaluates to true, and sim- ply cannot be executed from a state where e \neval- uates to false. The assignment statement x := e updates the program state so that x is bound to \nthe current value of the expression e. The state- ment A ; B denotes the sequential composition of A \nand B. The execution of the choice statement A D B executes either A or B, but the choice be- tween the \ntwo is made arbitrarily. Expressions in the language are pure (side-effect free) and include at least \nthe boolean constants true and false. All variables have an arbitrary value in a program's initial state. \nThe indeterminism arising from choice state- ments and from the program's initial (arbitrary) state can \nbe tamed by assume statements: the se- mantics of a program considers only those execu- tions in which \nthe predicate of each executed as- sume statement evaluates to true. For example, the statement (assume \n0 _< x ;A) 0 (assume -1(0 _< x) ;B) is the deterministic statement commonly written as if 0 <_ x then \nA else B end Before going on, we introduce the notational conventions that we use in this paper. We use \na left-associative infix \".\" (binding more strongly than any other operator) to denote function appli- \ncation. For any function f, we use fix ~ y] to denote the function that is identical to f except that \nit maps x to y.  Weakest Precondition Semantics We define the semantics of the guarded command language \nusing the weakest precondition transla- tion wp : Strut -, Formula --~ Formula The set Formula of logical \nformulae is an exten-sion of expressions that includes (at least) the usual boolean operators ( A, V, \n-~, ~ , =) and quantifi- cation, and is closed under substitution of expres- sions for variables. We \nuse the notation Q(x := e) to denote the capture-free substitution of e for ev- ery free occurrence of \nx in a formula Q. The translation wp is defined in Figure 2. For any statement S and predicate Q on the \npost-state of S, wp.S.Q returns a formula characterizing the pre-states from which executions of S never \ngo wrong and terminate only in states satisfying Q. To illustrate the derivation of verification con- \nditions using the weakest precondition translation, consider the following method abs. This method returns \nthe absolute value of its argument and decrements a counter c provided c was initially positive. static \nint abs(int x) //&#38;#169; ensures \\result >= 0 { (x < 0) { X ---X; //&#38;#169; assert x > 0; \n} (c > 0) { C--; } return x; }  ESC/Java annotations are given as specially for- matted Java comments \nbeginning with an &#38;#169;-sign. This method contains two annotation: a postcon- dition \\result >= \n0 and an assertion x > 0. To verify these properties, ESC/Sava translates this method into the following \nguarded command Sabs: 1 ((assumex<0;x=-x;assertx>0) D(assume ~(x < 0))); ((assumec>0;c=c-1) I](assume \n-~(c > 0))); assert x > 0  This guarded command is subsequently translated into the VC wp.Sabs.true: \n2 c>O =-~ -x_> z<O A   (i 00)) Since this VC is valid, the method abs satisfies its postcondition \nand assertion. Although this VC is of moderate size, in general a computation wp.S.true may yield a verification \ncondition whose size is exponential in the size of S. An examination of the definition of wp reveals \nthat there are two situations where expressions or formulae are duplicated. The first case arises from \nthe translation of an assignment statement x :-- e. The weakest precon- dition of this statement with \nrespect to a postcon- dition Q is Q(x :-- e). Since the variable x may occur many times in Q, the substitution \noperation produces a precondition that contains that many copies of e. For example, the VC wp.Sabs.true \ncon-tains three copies of the expression -x. This duplication is particularly pronounced when assignment \nstatements are sequentially com- posed. To illustrate this problem, consider the statement: S_--( x 1 \n:= x 0 +x0; x2 :=Xl +Xl; x n :-~- Xn_ 1 Jr Xn_l) The weakest precondition wp.S.(xn > 0) has size exponential \nin n; in particular, it contains 2 n refer- ences to x0. We note that this precondition could ~This guarded \ncommand elides some details introduced by the ESC/Java translation that are unrelated to the current \ndiscussion. ~For clarity, the VCs in this paper have been simplified by per- forming peephole optimizations, \nsuch as replacing Q A true by Q, as is also done by ESC/Java. S passify. (o-, S) (_L, assert false) if \ne = false assert e (o-, assert o-.e) if e ~ false (.L, assume false) if e = false assume e (o-, assume \na.e) if e \u00a2 false := e (o-[x H xq, assume x' = where x ~ is a fresh variable A ; B (o-b, (A' ; B')) \nwhere (o-a, A') = passify.(o-, A)  (o-b,B') = passi/u.(o-a,B) A Q B (o-~, (A' ; Ra) ; (B' ; Rb))) where \n(o-a, A') = passify.(o-, A) (o-b, B') = passify. (o-, B)  (o-', Ra, Rb) = merge.(oa, o-b) Figure 3: \nTranslation into passive form. be represented in linear space as a directed acyclic graph (DAG). The \nsecond cause of duplication occurs in the translation of a choice statement A D B, whose weakest precondition \nwith respect to a postcondi- tion Q is wp.A.Q A wp.B.Q. Each conjunct con-tains a copy of Q (possibly \nmodified by substitu- tions corresponding to assignment statements in A and B). Thus the postcondition \nQ (or some variant of it) is duplicated in both conjuncts. For example, in the VC wp.Babs.true, there \nare four substitution instances of the assertion x > 0, one for each of the possible execution paths \nthrough the method abs. Again, the duplication is more pronounced when choice statements are sequentially \ncomposed; the size of the resulting weakest precondition may be exponential in the size of the statement \nsequence. Unlike in the previous case, this precondition may require exponential space even when using \na DAG representation, since the duplicated postconditions may not be exact copies of each other due to \nsub- stitutions arising from assignments. Translation into Passive Form The preceding discussion indicates \nthat assignment statements play a role in both sources of duplica- tion in the weakest precondition translation. \nBased merge. ( o-, J_ ) = (o-, skip, skip) merge. (_1_, a) = (a, skip, skip) merge. (o-a, Ob) ~-(o-',Ra,Rb) \nwhere D = {x E Var I o-a.x # o-b.x} e = map from D to fresh variables Ra ----;{assume o-a.x = O.x I x \nE D} Rb ----;{assume o-b.x = e.x ] x E D} x ~---~{ e.x if x E D O-a.X if x ~ D Figure 4: The function \nmerge. on this insight, we develop a two-stage VC genera- tion algorithm. The first stage transforms \na state- ment into an assignment-free, or passive, form. The second stage exploits the assignment-free \nna-ture of this passive form to create a compact veri- fication condition. To translate a source statement \nto passive form we need to remove each assignment statement. The basic idea is to replace each assignment \nstatement x:~e by an assumption assume x ~ = e where x ~ is a fresh variable, and to change subse- \nquent references to x to refer to x ~. We call x ~ a variant of x, and use 8ubst = (Vat Vat) U {_L} \nto denote the set of substitutions, or mappings from program variables to their current variants. The \nspecial substitution _L (\"bottom\") is used to indicate infeasible code paths as discussed below. We extend \nsubstitutions from variables to expres- sions and formulae in the usual manner, and for any expression \nor formula e, we define _l_.e to be e. The translation into passive form is performed by the function \npassify : Subst \u00d7 Strut -~ Subst \u00d7 PStmt defined in Figure 3, where PStmt C Strut denotes the set of \nassignment-free, or passive, statements. The function passify takes two arguments: an ini- tial substitution \na E Subst that specifies the cur- rent variant for each program variable, and a state- ment S E Stmt \nto be transformed, and returns a pair (aI, S~), where S ~ in a passive version of S, and where a ~ E \nSubst describes the current vari- ants after S ~ terminates. If S I is guaranteed never to terminate, \nthen a ~ may be _1_. The translation of an assert statement assert e into passive form is straightforward: \nwe simply ap- ply a to e. As an optimization, if e is false, we may indicate that the assertion will \nnever terminate by returning the special substitution \u00b1. The trans- lation of an assume statement proceeds \nin a simi- lar manner. To translate an assignment statement x := e into passive form, we choose a fresh \nvari- able x t, introduce the assumption that x ~ = a.e, and update a to record that x ~ is the current \nvari- ant of x. For a sequential composition, we simply translate each component in turn. The translation \nof a choice statement A D B is more complicated, since the passive forms of A and /3 may introduce different \nvariants, say Xa and Xb, of some program variable x. We handle this sit- uation by introducing a third \nvariant, say x t, of x; appending to the passive form of A the assump- tion that x ~ = xa; appending \nto the passive form of /3 the assumption that x ~ = Xb; and subsequently using x ~ as the current variant \nof x. This translation of choice statements relies on a helper function merge : Subst x Subst ~ Subst \nx PStmt \u00d7 PStmt shown in Figure 4. Given two substitutions aa and ab describing the current variants \nafter the passive forms of A and B terminate, the function invo- cation merge.(a~, ab) returns a triple \n(cr', R~, Rb), where R~ and Rb describe the additional assump- tions, or renamings, to be appended to \nthe passive forms of A and B, respectively, and a I is result- ing substitution. As an optimization, \nif one of the arguments to merge is .L, then no fresh variables or additional assumptions are necessary, \nbecause either A or B will never terminate. In the definition of merge, we use skip to ab- breviate assume \ntrue, and we use \";\" as an oper- ator applied to a set of statements to denote the sequential composition \nof those statements (in an arbitrary order). For the method abs from Section 4, the corre- sponding passive \nstatement S:b 8 is: ( (assume x < 0 ; assume Xl = -x ; assert xl > 0 ; assume x2 = Xl) ~(assume -~(x \n< 0) ;assume x2 = x)); ( (assumec>0;assumecl=c-1; assume c2 = el) D(assume -~(c > 0) ; assume c2 = c)) \n; assert x >_ 0 The additional assumptions introduced by the passify translation may produce an increase \nin the code size. Although this increase may be quadratic in the worst case, in practice it appears to \nbe closer to linear (see Section 8). The translation of a guarded command state- ment into passive form \npreserves the semantics of the statement, as described by the following theo- rem. Theorem 1 Let S E \nStmt, let a E Subst, let (\u00b0', S') = passify. (a, S) and let xl,...,xn be the additional variables in-troduced \nby the passify translation. Then for any predicate Q containing no free occurrences of Xl,  , Xn~ a.(wp.S.Q) \n= Vxl,...,x~ : wp.S'.(a'.Q) Proof: By structural induction on S. 6 VCs for Passive Statements It remains \nto transform the passive representation into a verification condition. The assignment-free nature of \nthe passive form allows us to perform this translation while avoiding the exponential blow up of the \nweakest precondition translation. The ab- sence of assignment statements means that the ex- ecution of \na passive statement cannot change the program state, and the only effect of such an execu- tion is to \nchoose among the two possible outcomes: normal termination and going wrong. Thus the se- mantics of a \npassive statement S can be completely captured by two outcome predicates: N.S, which S N.S W.S assert \ne e ~e assume e e false A ; B N.A A N.B W.A V (N.A A W.B) A O B N.A v N.B W.A V W.B Figure 5: Outcome \npredicates for passive stmts. describes the initial states from which the execu- tion of S may terminate \nnormally, and W.S, which describes states from which the execution of S may go wrong. The definition \nof the two outcome predicates N, W : PStmt ~ Formula is shown in Figure 5. An assert or assume state- \nment terminates normally if its predicate is true. An assert statement goes wrong if its predicate is \nfalse, whereas an assume statement never goes wrong. A sequential composition A ; B terminates normally \nonly if both components terminate nor- mally, and goes wrong if either A goes wrong, or if A terminates \nnormally and B goes wrong. A choice statement A 0 B may terminate normally if either component terminates \nnormally, and may go wrong if either component goes wrong. The relationship between the outcome predi-cates \nand the wp translation is described by the following theorem. Theorem 2 If S is in passive form then \nwp.S.Q =-,(W.S) A (N.S ~ Q) Proof: By structural induction on S. Hence, for any passive statement S, \nthe VCs wp.S.true and ~(W.S) are equivalent. The VC -~(W.S~abs) for the passive statement Stabs consid-ered \nearlier is: ( (x < O A xl = -X A \"(xl > O))) V (Q1 A Q2 A ~(x2 > 0)) where: (x<0Axl=--xAxl>0Ax2=xl)~ \nQ1 ~' v (-4= < o) A = ) (c>0Acl=c--1 Ac2=cl)~ Q2~i V (-~(C> 0) A C2 = C) ] Verifying the assertion \nexpressed by -~(xl > 0) in this VC is straightforward. To verify the post- condition expressed by -~(x2 \n>_ 0), a theorem prover would need to analyze separately the two disjuncts in Q1 (corresponding to the \ntwo paths through the first choice statement in S~bs). How-ever, the theorem prover need not analyze \nthe two disjuncts in Q2 (corresponding to the two paths through the second choice statement). Thus, un-der \nthe outcome predicate encoding of VCs, the analysis performed by a theorem prover when ver- ifying a \nproperty (such as an assertion or postcon- dition) need not correspond to an all-paths analy- sis of \nthe underlying method; the theorem prover can use various heuristics in an attempt to ignore disjunctions \narising from choice statements that do not affect the correctness of the property being ver- ified. The \nVCs generated by this approach are typi- cally significantly smaller than that generated by wp. In particular, \nfor a passive statement S, the VC -~(W.S) is at most quadratic in the size of S. Theorem 3 If S is in \npassive form then I. IN.SI is O(ISI) , and  2. I W.Sl is o(ISlD. Proof: By structural induction on S. \nThe VC -,(W.S) still contains a significant amount of duplication (and hence the quadratic as opposed \nto linear bound). For example, the VC -,(W.S~abs) contains two copies of the subformula x<0AXl =--x. \nSince the duplicated subformulae in a VC -1(W.S) are exact copies (and not substitution in- stances) \nof each other, it is straightforward to in- troduce a name for each duplicated subformula Q, for example, \nvia (3x : (x = Q) ~ ...), and to replace each occurrence of Q by a reference to the variable x. In the \ncontext of the Simplify theorem prover, for efficiency purposes we name each dupli- cated subformula \nQ via the nullary predicate def- inition (DEFPRED (x) Q), and then replace each occurrence of Q by the \npredicate application (x). Of course, if Q is small, it may not be worth naming it, due to the overhead \nof processing the resulting indirection in the theorem prover. Our implementation uses a cutoff K, and \nonly names a duplicated subformula if the formula is larger than K (where the size of a formula is the \nnumber of nodes in its representation). For any finite value of this cutoff, the size of the resulting \nVC is linear in the size of the passive statement, and hence at most quadratic in the size of the source \nprogram. Section 8 describes experimental results concerning the effect of K on both the size of VCs \nand on the time required to prove them. 7 Handling Loops and Exceptions ESC/Java uses an extended guarded \ncommand lan- guage that also incorporates loops and exceptions. This section outlines how to extend our \ndevelop- ment to handle these constructs. 7.1 Loops ESC/Java incorporates a variety of translations \nfor loops that provide different trade-offs between soundness, completeness, and annotation over-head. \nThese translations are outlined in a related paper [LSS99]. In this section, we sketch a sound but incomplete \ntranslation for while loops. This translation relies on the programmer to an- notate each loop with a \nloop invariant Q; this in- variant is required to hold at the beginning of each iteration of the loop. \nUsing this loop invariant, we desugar each while statement into a collection of more primitive guarded \ncommands. Under this desugaring, a while loop while {Q} e do S end becomes assert Q ; Xl:----Yl ; ... \n;xn:~Yn ; assume Q ; ( (assume e ; S ; assert Q ; assume false) O assume-~e) where Xl,...,x~ are the \nvariables assigned in S, and Yl,..., Yn are fresh variables that hold arbi- trary values (from the program's \ninitial state). The desugared code ensures the loop invari-ant holds initially, and then sets the variables \nFigure 6: Weakest preconditions with exceptions. s wp.S.<Q, R> assert e e A Q assumee e ~ Q x := e Q(x \n:= e) A ; B wp.A.(wp.S.(Q, R), R) A C] B wp.A.(Q,R) A wp.B.(Q,R) raise R A ! B wp.A.(Q, wp.B.(Q, R)) \n xl,..., Xn to arbitrary values that satisfy the loop invariant. The code then checks that if e is true, \nthen the loop invariant still holds after executing S; if e is false, then the desugared loop terminates. \n 7.2 Exceptions ESC/Java's guarded command language includes two additional constructs for raising and \ncatching exceptions:  S :: .... ] raise I A ! B The statement raise simply raises an exception. The \nguarded command language does not distin- guish different types of exceptions; this is accom- plished \nin ESC/Java by using an auxiliary program variable. ESC/Java uses guarded command excep- tions not only \nto model the behavior of Java excep- tions, but also to model other forms of \"escaping\" control flow, \nsuch as break and return statements. In the catch statement $1 ! $2, the statement $2 is the exception \nhandler for any exception raised (and not caught) in $1. If $1 terminates normally, then $2 is not executed. \nThe weakest precondition translation for the ex- tended language wp : Strut ~ (Formula x Formula) ~ Formula \n now takes as arguments a statement S and two postconditions, Q and R, which describe properties that \nshould hold whenever S terminates normally or exceptionally, respectively. If the precondition wp.S.(Q, \nR) holds a particular state, then any ex- ecution of S from the state can never go wrong, S pass@. (a, \nS) (_I_,_L, assert false) if e = false assert e (a, 1, assert a.e) if e # false (\u00b1, _l_, assume false) \nif e = false assume e (a, .L, assume a.e) if e \u00a2 false X:~e (a[x ~ xq, _k, assume z t = o.e) where x \nt is a fresh variable A;B (abn,Cr~, (A' ! (Rax ; raise)) ; (B' ! (Rbz ;raise))) where (aan, ao~, A') \n= passify.(A, a) (abn, abe, B') = passify.(B, aan) = mewe.(a~::, abE) ADB (an, a~, ((A';R~=)! (Rax ; \nraise)) ; ((B' ; Rb,) ! (Rb~ ;raise))) where (o~, o~, A') = passify.(A, a) (OVbn, abx, B t) = passify.(B,o') \n(R~,~, Rb,~, an) = merge.(a~,Crbn) = merge.(aax,abx) raise (.l_, a, raise) A!B (an, abx, (A';Ra ) ! (B' \n; Rbn)) where (~ran, O'ax, A t) = passify.(A, a> ( bn, B') = passify.(B, aaz) = merge.(aan , abn) Figure \n7: Translation into passive form for statements with exceptions. S N.S X.S W.S assert e e false -~e assume \ne e false false A ; B N.A A N.B X.A V (N.A A X.B) W.A v (N.A A W.B) A D B N.A V N.B X.A v X.B W.A V W.B \nraise false true false A ! B N.A V ( X.A A N.B ) X.A A X.B W.A V ( X.A A W.B ) Figure 8: Outcome predicates \nfor passive statements with exceptions. can terminate normally only in states satisfying Q, and can terminate \nexceptionally only in states satisfying R. The new translation is described in Figure 6. Since statements \ncan now terminate exception- ally, we update the passify translation to return a triple (an, at, St), \nwhere S I is a passive state-ment, an describes the current variants after S t terminates normally, and \ncrx describes the current variants after S ~ terminates exceptionally. When translating a sequential \ncomposition A ; B, we need to merge the substitutions corresponding to the exceptional terminations of \nA and B. Hence, we append to the passive forms of A and B code that catches any thrown exception, performs \nthe appropriate renaming, and then re-raises the ex-ception. Conversely, for a catch statement A ! B, \nwe need to merge the substitutions corresponding to the normal terminations of A and B. For a choice \nstatement, we need to merge substitutions 201 corresponding to both normal and exceptional ter- minations. \nThe definition of the new passify translation is shown in Figure 7. The infeasible path optimiza- tion \n(using L) is particularly important in the pres- ence of exceptions (see Section 7.2) because many statements \nwill never terminate exceptionally. Finally, we introduce a third outcome predi- cate, X.S, which describes \nthe pre-states of S from which exceptional termination is possible. The ap- propriate definition of the \nthree outcome predi- cates N, X, W : PStmt --~ Formula for passive statements with exceptions is shown \nin Figure 8. Note that because of additional control flow paths introduced by exceptions, the size of \na VC -~(W.S) may now be exponential in the size of S. To illustrate this, consider the application of \nthe outcome predicate N to the code fragment (A ; B) ! C, which yields the formula N.((A ; B) ! C) =- \nN.(A ; B) V (X.(A ; B) A N.C) = (N.A A N.B) V ((X.A V (N.A A X.B)) A N.C) containing two occurrences \nof the subformula N.A. However, by naming shared subformulae as de- scribed in Section 6, we can still \nrepresent the VC --1(W.S) as a formula whose size is linear in the size of S. Experimental Results We \nhave implemented, as part of ESC/Java, both VC generation algorithms described in this paper. This section \npresents experimental results com-paring five VC-generation options: the standard wp-based translation, \nand the two-stage transla- tion based on with four different values (0, 10, 30, c~) for the cutoff size \nK above which to introduce names for duplicated outcome predicates. These experiments were performed \non a 667Mhz ES40 Alpha workstation containing 4Gb of mem- ory running Tru64 UNIX. ESC/Java is written \nin Java, and was run on the Compaq Fast VM. The Simplify theorem prover is written in Modula-3, and runs \nas a separate process. The two processes communicate via Unix pipes. The benchmark we used for these \nexperiments is ESC/Java's front-end, which we have annotated with appropriate specifications. This front-end \nconsists of 2292 routines (methods and construc- tors) totMing over 20,000 lines of code. We have divided \nthe routines in the benchmark into three categories according to their worst per- formance under any \nof the five options. The first category contMns the ten \"hardest\" routines. The verification of each \nof these routines either ex-hausted a 1Gb heap or required more than five minutes under at least one \nof the options. The second category of routines contains the 17 rou- tines that required at least 100 \nseconds under some option, but no more than 300 seconds under any option. The third category contains \nthe 2184 rou- tines in the benchmark that were successfully veri- fied in under 100 seconds regardless \nof the VC gen- eration option chosen. The remaining 81 routines in the front end are routines for which \nESC/Java performs no VC generation (for example, methods declared in interfaces); these routines are \nnot in- cluded in the benchmark. Figure 9 describes the performance of the five VC generation options \non the routines in the benchmark, with results for the ten \"hardest\" rou- tines given individually, and \nsummed results for the other two categories. The columns of the table identify: the routine name (or \nsummed category);  the size of the abstract syntax tree for the rou- tine (number of nodes);  the size \nof the guarded command (number of nodes);  the size of the VC under the urp translation (number of nodes); \n the time required to check this routine under the wp translation (seconds);  the size of the passive \nversion of the guarded command (number of nodes and percentage of original guarded command);  the cutoff \nK for naming duplicated outcome predicates (number of nodes);  Routine name AST GC wp translation VC \ntime POC I % [ New translation K VC 1% time [ % BinaryExpr. 420 1805 too big 1545 86 0 5758 1.4 pos~Check \n10 4840 0.6 30 4700 0.6 c~ 5513 1.0 LiteralExpr. 423 1417 too big 1608 113 0 5735 1.5 poetCheek 10 5023 \n1.3 30 5141 1.3 co 5765 1.3 finishFloating 653 3464 too big 7927 229 0 13134 69.5 PointLiteral 10 10616 \n8.9 30 10583 10.7 c~ 20416 73.9 scanCharOr 812 3896 too big 23904 614 0 33502 49.8 String 10 29851 18.1 \n30 29924 17.1 co 51357 16.3 scanNumber 1030 4170 too big 12383 297 0 19080 34.6 10 15334 23.0 30 15204 \n14.6 co 29093 10.7 scanPunc~ua~ion 509 314 0 15525 0 26.0 7 10 13748 0 12.9 4 30 13816 0 12.0 3 co 17972 \n0 6.8 2 parseNew 794 [I],\"~| iitil'(lI ~illii -- -~j ill 385 0 38186 37 530.1 688 Expression 10 36116 \n35 432.0 561 30 35749 35 419.0 544 co 83659 81 339.2 440 checkExpr 3945 17448 2798672 > 2000.0 35491 \n203 0 61813 2 750.4 < 30 i0 53779 2 401.5 < 16 30 51874 2 347.8 < 14 co 90646 3 169.4 < 7 checkS~m~ 2883 \n~|| 276 0 67915 7 457.5 148 10 61382 6 251.1 81 30 57726 6 145.4 47 co 105297 10 151.9 49 visltMethodDecl \n479 5270 122 0 12423 1 10.2 3 10 11430 1 8.7 2 30 11581 1 8.7 2 co 12544 1 8.8 2 sum of 17 other 14735 \n251 0 489529 4 1777.8 113 routines needing 10 461027 4 1048.0 67 > 100 seconds in 30 450090 4 900.7 57 \nsome run oo 955276 8 676.8 43 sum of remaining 148168 [:t.ti[~| ii[,~,~:K)|l il[,'JI\u00a2|ll I'~t~]r~ 129 \n0 7471786 64 2473.1 153 2184 routines 10 7095724 61 1662.8 103 30 6998342 60 1508.5 93 co 7530778 65 \n1564.1 97 Figure 9: Experimental results. the size of the VC under the two-stage trans- lation (number \nof nodes and percentage of the   up VC); the time required to verify this routine under the two-stage \ntranslation (seconds and per-centage of time using wp) The times in this table include the time required \nto translate the Java abstract syntax tree represen- tation into a guarded command, the time required \nto translate the guarded command into a VC (in- cluding translation into the intermediate passive representation, \nif necessary), and time required to check the VC. For the summed categories, the en- tries in the percentage \ncolumns tell how big one summed quantity is as a percentage of another. The results indicate that all \nthe VC generation algorithms work well on the simpler routines in the third category. The two-stage translation \nproduces smaller VCs that are slightly easier to prove for K = 30 or K = c~. Choosing K = 0 results in \nthe theorem prover performing significant extra work to process the resulting indirections. The wp translation \nhas difficulty scaling to the larger or more complex routines; for five of the routines in this benchmark \nthe wp translation ex- 203 hausted a 1Gb heap limit. The two-stage translation performs much bet- ter \non these complex routines; the resulting VCs are significantly smaller, and can easily fit in the heap. \nAgain, choosing K = 0 results in larger proof times. For K > 0, the two-stage translation yields VCs \nthat require significantly less time to prove (sometimes by an order of magnitude) than the VCs produced \nby the wp translation. The routine parseNewExpression requires sig- nificantly more time to verify under \nthe two-stage translation than under wp. In general, the time required by Simplify to verify a formula \nis highly dependent on the order in which Simplify chooses to perform various case-splits, and the case-split \norder is determined by a variety of heuristics. For this routine, we suspect that these heuristics are \nmisled in some manner by the VC generated by the two-stage translation. Overall, the two-stage translation \nperform sig- nificantly better than the wp translation. It en-ables ESC/Java to check all of the routines \nin this benchmark due to the smaller space require- ments, and is significantly faster. Excluding the \nsix routines that could not be checked using the wp translation, checking the entire benchmark us- ing \nwp required 4305 seconds, whereas using the two-stage translation requires only 2994 seconds (for K = \n30), or 2748 seconds (for K\" = oo). Related Work The VC-generation technique described in this paper \nis the result of joint work by the au-thors with Greg Nelson as part of the ESC/Java project [Ext]. It \nis related to an earlier (unpub- lished) VC-generation technique developed by one of the authors (Saxe), \nNelson, mad David Detlefs as part of an extended static checker for Modula- 3 [DLNS98]. The earlier technique \nproduced simi- larly compact and efficiently provable VCs, but was based on intermixing weakest-precondition \ncompu- tations with strongest-postcondition computations rather than on translation of statements to \npassive form. An alternative approach for VC generation is based on all-paths symbolic forward execution. \nThis approach is well-suited for handling unstruc- tured or assembly-level code. It has been used in \nproof-carrying code systems [NL98] and in com-piler validation techniques [Nec00]. However, this approach \nalso suffers from the same causes of po- tential exponential blow up as the wp translation, namely, the \nhandling of assignments and control- flow merge points. The passive intermediate representation de-scribed \nin this paper is similar to the static single assignment (SSA) representation used in optimiz- ing compilers \n[AWZ88, CFR+89]. Both intermedi- ate representations are designed to facilitate later analysis stages. \nThe renamings introduced by the passify translation at control flow merge points are analogous to the \nphi-functions used in the SSA rep- resentation. 10 Conclusions Verification conditions provide a clean \nway to rea- son about program behavior and correctness. We have shown that the size of VCs need not be \nexpo- nential in the size on the program fragment being checked, and we have presented a two-stage VC \ngeneration algorithm, based on a passive interme- diate representation, that generates compact VCs. The \nsize of these VCs is worst-case quadratic in the size of the source fragment, and is close to linear \nin practice. The new algorithm has resulted in significant performance benefits in ESC/Java; we can now \ncheck many large and complex methods that we previously could not check due to time or space constraints. \nSome other possible applications for our VC generation algorithm may include proof-carrying code [NL98], \nsoftware model checking [BR00], com- piler validation [Nec00], and full program verifica- tion. Acknowledgments: \nThe authors thank our cur- rent and previous colleagues on the extended static checking project, including \nDavid Detlefs, Rustan Leino, Mark Lillibridge, Greg Nelson, and Raymie Stata for their part in building \nthe framework that allowed us to carry out the research reported here. Greg Nelson and David Detlefs \nmade particularly relevant contributions, as described in section 9. References user's manual. Compaq \nSystems  [AWZS8] [BR00] [BvW981 [CFR+Sg] [Dij76] [DLNS98] [DNS01]  [Ext] [LNS00] Bowen Alpern, Mark \nN. Wegman, and F. Kenneth Zadeck. Detecting Equality of Variables in Programs. In 15th ACM Symposium \non Principles of Program- ming Languages, pages 1-11, January 1988. Thomas Ball and Sriram K. Rajamani. \nBoolean programs: A model and pro- cess for software analysis. Technical Re- port 2000-14, Microsoft \nResearch, 2000. Ralph-Johan Back and Joakim von Wright. Refinement Calculus: A Sys- tematic Introduction. \nGraduate Texts in Computer Science. Springer-Verlag, 1998. Ron Cytron, Jeanne Ferrante, Barry K. Rosen, \nMark N. Wegman, and F. Ken- neth Zadeck. An Efficient Method of Computing Static Single Assignment Form. \nIn 16th Annual ACM Sym-posium on Principles of Programming Languages, pages 25-35, January 1989. Edsger \nW. Dijkstra. A Discipline of Programming. Prentice Hall, Engle-wood Cliffs, N J, 1976. David L. Detlefs, \nK. Rustan M. Leino, Greg Nelson, and James B. Saxe. Extended static checking. Re-search Report 159, Compaq \nSystems Research Center, December 1998. Available from research, compaq. com/SRC/publications. David \nL. Detlefs, Greg Nelson, and James B. Saxe. An automatic theorem- prover for program checking, to appear \n 2001. Extended Static Checking web page, Compaq Systems Re-search Center. On the Web at research, compaq, \ncom/SRC/esc/.  K. Rustan M. Leino, Greg Nelson, and James B. Saxe. ESC/Java  [LSS99] [Nec00] [Nel81] \n[Ne189] [NL98] Research Center Technical Note 2000-002, October 2000. Available from research, compaq, \ncora/SRC/ publications. K. Rustan M. Leino, James B. Saxe, and Raymie Stata. Checking Java programs \nvia guarded commands. In Bart Jacobs, Gary T. Leavens, Peter Mfiller, and Arnd Poetzsch-Heffter, editors, \nFormal Techniques for Java Programs, Technical Report 251. Fernuniversit\u00a3t Hagen, May 1999. Also available \nas Compaq Systems Research Center Technical Note 1999-002, from research, compaq. com/SRC/publicat ions. \n George C. Necula. Translation vali- dation for an optimizing compiler. In Proceedings of the ACM SIGPLAN'98 \nConference on Programming Language Design and Implementation, pages 83- 94, June 2000. Greg Nelson. Techniques \nfor program verification. Technical Report CSL-81- 10, Xerox Pale Alto Research Center, 1981. Greg Nelson. \nA generalization of Dijk- stra's calculus. A CM Transactions on Programming Languages and Systems, 11(4):517-561, \n1989. George C. Necula and Peter Lee. The design and implementation of a certify- ing compiler. In Proceedings \nof the A CM SIGPLAN'O0 Conference on Program- ming Language Design and Implemen- tation, pages 333-344, \nJune 1998.  \n\t\t\t", "proc_id": "360204", "abstract": "Current verification condition (VC) generation algorithms, such as weakest preconditions, yield a VC whose size may be exponential in the size of the code fragment being checked. This paper describes a two-stage VC generation algorithm that generates compact VCs whose size is worst-case quadratic in the size of the source fragment, and is close to linear in practice.This two-stage VC generation algorithm has been implemented as part of the Extended Static Checker for Java. It has allowed us to check large and complex methods that would otherwise be impossible to check due to time and space constraints.", "authors": [{"name": "Cormac Flanagan", "author_profile_id": "81100538763", "affiliation": "Compaq Systems Research Center, 130 Lytton Ave., Palo Alto, CA", "person_id": "PP14187273", "email_address": "", "orcid_id": ""}, {"name": "James B. Saxe", "author_profile_id": "81100392578", "affiliation": "Compaq Systems Research Center, 130 Lytton Ave., Palo Alto, CA", "person_id": "P133439", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/360204.360220", "year": "2001", "article_id": "360220", "conference": "POPL", "title": "Avoiding exponential explosion: generating compact verification conditions", "url": "http://dl.acm.org/citation.cfm?id=360220"}