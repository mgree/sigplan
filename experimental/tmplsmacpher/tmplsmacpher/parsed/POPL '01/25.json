{"article_publication_date": "01-01-2001", "fulltext": "\n Some text in this electronic article is rendered in Type 3 or bitmapped fonts, and may display poorly \non screen in Adobe Acrobat v. 4.0 and later. However, printouts of this file are unaffected by this problem. \nWe recommend that you print the file for best legibility. Combining subsumption and binary methods: An \nobject calculus with views J\u00b4er ome Vouillon Department of Computer and Information Science* University \nof Pennsylvania vouillon@saul.cis.upenn.edu ABSTRACT Wepresentanobject-orientedcalculuswhichallowsarbi\u00adtraryhidingofmethodsinprototypes,eveninthepres\u00adenceofbinarymethodsandfriendfunctions.Thiscombi\u00adnationoffeaturespermitscompletecontroloftheinterface \naclassexposestotheremainderofaprogram(whichisof keyimportanceforprogramreadability,securityandease ofmaintenance),whilestillallowingcomplexinteractions \nwithotherclassesbelongingtothesamemoduleorsoftware component. Thisresultismadepossiblebytheuseofviews.Aview \nisanamethatspecifesaninterfacetoanobject.Aset ofviewsisattachedtoeachobjectandamethodcanbe invokedeitherdirectlyorviaaviewoftheobject. \n 1. INTRODUCTION Informationhidingisofkeyimportanceformakingpro\u00adgramsmorereadable,secureandmaintainable.Inparticu\u00adlar,forabstractionpurposes,onewouldexpecttobeableto \nspecifyfreelywhatmethodsofaclassareexportedfroma package(oramodule)totheremainderofaprogram.Fur\u00adthermore,abstractionshouldnotbeimpededbytheneedfor \ncomplexinteractionbetweenobjects.Forinstance,ifobjects fromtwodiferentclassesaretointeractwithoneother,it \nshouldstillbepossibletohidethemethodsinvolvedinthe interaction.Thismeansthattheobjectsmustbeableto communicateviamethodsnotpresentintheinterfacesex\u00adportedbytheclassestotherestoftheprogram.(Aclassor \nafunctionhavingsuchaprivilegedaccesstoanotherclass iscommonlynamedafriend). Astructuralsubtypingsetting,wheremethodsareaccessed \nbynameandmethodnamesarenotlexicallyscoped,does notprovidesuchfreedom[10].Indeed,ifamethodisneces\u00adsaryfortheinteractionbetweentwoclasses,itmustremain \n1ThisworkwassupportedinpartbytheUniversityofPenn\u00adsylvania'sInstituteforResearchinCognitiveScience Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for profit or commercial advantage and that copies \nbear this notice and the full citation on the first page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior specific permission and/or a fee. POPL '01 1/01 Londo, \nUK Copyright 2001 ACM 1-58113-336-7/01/0001 ... $5.00 intheinterfaceoftheclassitbelongsto(eventhoughits \naccessmaybepreventedusingexistentialtypes[2,15]). Ontheotherhand,thisproblemdoesnotexistinlanguages suchasC++orJava,whereanexplicitlydeclaredinheri\u00adtancehierarchydefnesthesubtypingrelationbetweenob\u00adjects.Thereasonisthatinthissettingamethodisselected \naccordingtobothitsnameandthestatictypeoftheob\u00adject.Then,anewmethodinaclasswillnotconfictwitha methodofthesamenameinasuperclass.Furthermore,it \nisalsopossibletoexposetotheremainderoftheprogram thefactthatanobjectbelongstoasubclassofagivenclass withouthavingtoexportanyofthemethodsofthisclass. \nThen,afriendfunctionissimplyafunctionwhichhasac\u00adcesstosomenon-exportedmethodsofaclass.Typesafety isachievedbyensuringthatthefunctionisonlyappliedto \nobjectsofthisclass(oroneofitssubclasses). However,suchlanguagesusuallydonotsupportsomead\u00advancedfeaturesoftenfoundinlanguagesusingstructural \nsubtyping,suchasselftypeandbinarymethods[3].We presentinthispaperacalculusthataimsatcombiningthe bestofbothworlds:itprovidesthesetwofeatureswhile \nstillallowingarbitrarymethodhiding.Ratherthanhaving classes,itusesmoreatomicconstructions:itisprototype\u00adbased,andthenotionthatanobjectbelongstoagiven \nclassisexpressedbythefactthatitpossessesagivenview. Aviewissimplyaname(correspondingtoaclassname) givingaccesstoanalternateinterfacetoanobject. \nSeveralcalculidealingwithsimilarissueshavebeenpro\u00adposedpreviously.RieckeandStone[18]presentedacalcu\u00adlusallowingarbitraryhidingofmethods.Thiscalculusonly \nusesstructuralsubtypinganddoesnothavebinarymeth\u00adods.Morerecently,FisherandReppy[10]proposedacalcu\u00adluswithsupportforinheritance-basedsubtyping.However, \nthiscalculusisfrst-order(thatis,itdoesnothavetheno\u00adtionofselftype). ForthesakeofclaritywefrstpresentinSection2a \n,simpli\u00adfedversionofthecalculus,introducingmostfeaturesofthe fullcalculus.Then,inSection3,wepresentthefullcalculus \nanddemonstratehowitcanproperlytypebinarymethods andfriendfunctions.Typecheckingandtinference ypeare discussedinsection3.4.Section4exposessomelimitations \nofthecalculus.Finally,relatedworksarepresentedinsec\u00adtion5. Notations Wewritef;(i=e)todenotethepartialfunctionthatbe\u00adhavesexactlyasfexceptformappingitoe.Thisnotation \nisnotstandard,butisveryconvenient,inparticularfor writingmethodtables.Wewritef.gtodenotethatthe functiongextendsthefunctionf,thatis,thegraphofgis \nasupersetofthegraphoff.  2. BASE CALCULUS 2.1 Examples Weintroducethecalculusthroughexamples.Letuscon\u00adsiderthefollowingobject1: \nx1::=\u00ab(x:a)[L1jL1] ' 1 where' 1::=(ten7!one;clone7!two) L1::=(one=10;two=x) L1::=(one:int;two:a) Itcontainstwomethods.Theexternalnamesofthesemeth\u00adods(thatis,thenameofthesemethodsviewedfromoutside \ntheobject)aretenandclone.Adictionary' 1(afnite partialfunctionfrommethodnamestomethodnames)is usedtomaptheseexternalnamestosomeinternalnames \noneandtwo.Theinternalnamesareusedasindicesinthe methodtableL1andinthemethodtypetableL1.Thefrst methodofthisobjectreturnstheinteger10anditstypeis \nint.Thesecondmethodreturnsself(thatis,theobject itself)whichisboundtoxatthebeginningoftheobject defnition.Thetypeofthemethodisa,thetypeofthe \nobject(alsocalledselftype),boundjustafterx. Thetypeoftheobjectx1is \u00ab(a)[ten:int;clone:a] Thetypesofthemethodsarethetranslationofthemethod \ntypetableL1usingthedictionary' 1.Moreprecisely,itis defnedasL10' 1.Thesetypesareagainparametrizedover \nselftypea,whichisboundatthebeginningoftheobject type. Themethodclonecanbeinvokedusingtheconstruction \nx1:clone.Duringtheevaluationofthisoperation,theex\u00adternalmethodnamecloneistranslatedintotheinternal methodname' \n1(clone)=two.Then,thecorresponding methodbodyL1(two)=xisextracted.Therestofthe evaluationisstandard:thetypevariableaisreplacedby \nthetypeoftheobjectinthemethodbody,andthevariable xisreplacedbytheobject.Theexpressionx1:clonethere\u00adforeevaluatesintox1.Itstypeisobtainedbyextractingthe \ntypeaofthemethodcloneandreplacingselftypebythe objecttypeitself:it'sthesameasthetypeofx1. Theobjectx1canactuallybeconsideredasaprototype,of \ntype \u00ab(a)[ten:int;clone:a]; Aprototypeisanobjectwhichispossiblynotyetfnished andcanstillbemodifed:itispossibletoaddamethod \ntoaprototype,tooverrideoneofitsmethodsandtohide oneofitsmethods.Contrarytoproperobjects,someofthe 1Weusethenotation::=tonameanexpression.Itisnot \npartofthecalculus methodsofaprototypemayhavebeengivenatypewith\u00adoutbeingdefnedyet.Suchamethodisnamedanabstract \nmethod.Theprototypex1hasnoabstractmethod,sothe setofitsabstractmethods,attheupperrightofitstype, isempty.Asinapreviouscalculuswithprototypedesigned \nbyFisherandMitchell[7],thereisnosyntacticdiference betweenaprototypeanda\"properobjects\":theyareonly distinguishedbytheirtypes. \nTheconstructionx1+(id:&#38;(a)(a!a))addsanabstract methodidoftypea!a(whereaisselftype)tothepro\u00adtotypex1.Moreprecisely,itevaluatesintoaprototypex2 \nwhichisacopyoftheprototypex1withspacereservedfor onemoremethodid: x2::=\u00ab(x:a)[L1jL2] ' 2 where' 2::=ten7!one;clone7!two;id7!three \nL1::=one=10;two=x L2::=one:int;two:a;three:a!a Thedictionaryhasbeenextendedandmapsthemethod nameidtoafreshmethodnamethreechosenduringthe \nreduction.Themethodtableoftheprototypeisunchanged, whilethemethodtypetablehasbeenextendedwiththe methodthree.Theprototypex2hastype \n\u00ab(a)[ten:int;clone:a;id:a!a]fidg Notethatthesetofabstractmethodsofthisprototypeis thesingletonfidg:nodefnitionisprovidedforthemethod \nidyet. Wecannowprovideadefnitiontothemethodid,usingthe constructionx2:id.:a)>(y:a)y.Inthisexpression, \n&#38;(xxstandsforselfandastandsforselftype.Theexpression evaluatesintoanewprototypex3.Thisprototypehasthe \nsamemethodtypetableL2anddictionary' 2asx2,but itsmethodtablecontainstheexpecteddefnitionforthe methodid: \nx3::=\u00ab(x:a)[L3jL2] ' 2 where' 2::=ten7!one;clone7!two;id7!three L3::=one=10;two=x;three=>(y:a)y L2::=one:int;two:a;three:a!a \n Thetypeoftheprototypex3isthesameasthetypeofthe prototypex2exceptthereisnoabstractmethod: \u00ab(a)[ten:int;clone:a;id:a!a]; \n Thesameconstructioncanbeusedtooverrideamethod defnition:ifthemethodisalreadydefned,itsbodyisre\u00adplacedbythenewvalue. \nFinally,itispossibletohideamethodofaprototypeifthis methodisdefned:theexpressionx3ntenevaluatesinto acopyoftheprototypex3wherethemethodtenisnot \naccessibleanymorefromoutsidetheobject:itisremoved fromthedictionary' 4. x4::=\u00ab(x:a)[L3jL2] ' 4 where' \n4::=clone7!two;id7!three L3::=one=10;two=x;three=>(y:a)y L2::=one:int;two:a;three:a!a Thetypeofthisprototypeisthesameastheprototypex3 \nexceptforthemethodten. \u00ab(a)[clone:a;id:a!a]; a::=x Variable j>(x:7)a Abstraction ja(a 0) Application \nj\u00ab(x:a)[LjL] ' Object ja+(l:&#38;(a)7)Methodaddition janl Methodhiding ja:l&#38;(x:a)a 0 Methodoverride \nja:l Methodinvocation 7::=a Typevariable j7!70 Functiontype j\u00ab(a)[L] Objecttype j\u00ab(a)[L]A Prototypetype \nL::=;jL;(l=a)Methodtable L::=;jL;(l:7)Methodtypetable '::=;j';(l7!l)Dictionary Figure1:Syntax(basecalculus) \nFinally,asubtypingrelation:isdefnedontypes.Aproto\u00adtypecanbeviewedasanobject,providedthatallitsmeth\u00adodsaredefned,bysubtyping.Forinstance,thefollowing \nrelationholds: \u00ab(a)[ten:int;clone:a]; : \u00ab(a)[ten:int;clone:a] Onecanalsohidesomemethodsofanobjecttypebysub\u00adtyping.Forinstance: \n\u00ab(a)[ten:int;clone:a;id:a!a] : \u00ab(a)[ten:int;clone:a] Asusual,methodcanbehiddenthiswayonlyiftheresulting \ntypehasnobinarymethod.Thisisthemainreasonwhywe diferentiateprototypesfromproperobjects:wewouldlike theusualsubtypingrulestoholdforproperobjects,while \nwewouldliketobeabletohideanymethodinprototypes, whichareusedtodefneobjects.  2.2 Formalization 2.2.1 \nSyntax Thesyntaxofthecalculusispresentedinfgure1.Wehave alreadypresentedeachoftheconstructionsintheexamples \nabove.Itassumesthreeinfnitesets:variablesx,method namesl,andtypevariablesa.Werecallthatamethod tableLisafnitepartialfunctionfrommethodnamesl \ntoexpressionsa,amethodtypetableLisafnitepartial functionfrommethodnamestotypes7,andadictionary isafnitepartialfunctionfrommethodnamestomethod \nnames.  2.2.2 Static semantics (Var)(Abs) (x:7)2,,;(x:70)`a:7 ,`x:7,`>(x:70)a:70!7 (App)(Sub) 70070 \n:70 ,`a:!7,`a:,`a:7,`7,`a(a 0):7 ,`a:70 (Selection-Base) ,`a:77=\u00ab(a)[L] L(l)= 70 ,`a:l:70f7ag (Extension-Base) \n,`a:\u00ab(a)[L]A 7)]AUflg ,`a+(l:&#38;(a)7):\u00ab(a)[L;(l: (Override-Base) ,`a:\u00ab(a)[L]A ,;(a);(x:a)`a 0:L(l) \n0\u00ab(a)[L]Anflg ,`a:l&#38;(x:a)a: (Restriction-Base) ,`a:\u00ab(a)[L]Al2domLnA ,`anl:\u00ab(a)[LjdomLnflg]A (Proto-Base) \nL0 =L0' A=domL0 ndom(L0') ForalllindomL,,;(a);(x:a)`L(l):L(l) ,`\u00ab(x:a)[LjL] ' :\u00ab(a)[L0]A Figure2:Typingrules(basecalculus) \n(Sub-Arrow) (Sub-Refl) ,`71:72,`720:71 0 ,`7:7,`710!71:720!72 (Sub-Proto-Base)(Sub-Object-Base) ,`\u00ab(a)[L]:\u00ab(a)[L0]L0.LcoG(L0) \n,`\u00ab(a)[L];:\u00ab(a)[L0],`\u00ab(a)[L]:\u00ab(a)[L0] Figure3:Subtypingrules(basecalculus) Methodaddition(l062domLrange') \n0) \u00ab(x:a)[LjL] ' +(l:&#38;(a)7),!\u00ab(x:a)[Lj(L;(l0:7))] ';(l=l 'nflg Methodhiding\u00ab(x:a)[LjL] ' nl,!\u00ab(x:a)[LjL] \n'jdom Methodoverride\u00ab(x:a)[LjL] ' :l&#38;(x:a)a,!\u00ab(x:a)[L;('(l)=a)jL] ' Methodinvocation(v=\u00ab(x:a)[LjL] \n' and7=\u00ab(a)[L0']) v:l,!L('(l))f7agfvxg Application(>(x:7)a)(v),!afvxg Figure4:Reductionrules(basecalculus) \nThestaticsemanticsdefnesatypingjudgment,`a:7and 70 asubtypingjudgment,`7:,whereanenvironment, isasequenceofvaluebindingsandtypevariablebindings: \n,::=;j,;(x:7)j,;(a) Thetypingandsubtypingrulesaregiveninfgures2and3. Atype7oranexpressionaareclosedwithrespecttoan \nenvironment,ifalloftheirvariablesareboundinthisen\u00advironment.Anenvironment,isclosedifallofthetypes andviewtypesofitsrangeareclosedwithrespectto,. \nAtypingjudgment,`a:7isclosedif,isclosedanda and7areclosedwithrespectto,;asubtypingjudgment ,`7:isclosedif,isclosedand7andareclosed \n7070 withrespectto,.Weassumethatalljudgmentsunder discussionareclosed,andthatnovariablesareeverbound \ntwiceinanenvironment. Alltypingrulesaresimple,excepttheruleProto-Base. Inthisrule,thefrstcondition=L0'ensuresthatthe \nL0 L0methodtypetableLtranslatedbythedictionary'.The secondconditionA=domL0 ndom(L0')ensuresthatthe abstractmethodsAaretheexternalmethods(domainofL0) \nwhicharenotdefnedinthemethodtableL.Finally,each internalmethodistypedinanenvironmentwhereselftype aisanabstracttypeandselfxhastypea. \ntypeofthemethodsinthetypeoftheprototypeisthe TheobjectsubtypingruleSub-Object-Baserequiresthat selftypeaappearscovariantlyinthemethodtypesL0(which \nwenotecoG(L0)).Asusual,wesaythatthetypevariable aappearscovariantlyinatype7ifanyofthefollowingis true:aisnotfreein7;7isa;7is71!72andaappears \ncontravariantlyin71andcovariantlyin72.Similarly,the typevariableaappearscontravariantlyinatype7ifanyof \nthefollowingistrue:aisnotfreein7;7is71!72anda appearscovariantlyin71andcontravariantlyin72.  2.2.3 Dynamic \nsemantics Wegiveasmall-stepreductionsemanticstoourcalculus. Thelocalreductionrelation,!isdefnedinfgure4.The \nrulesdefningthisrelationmakeuseofthetwostandardsub\u00adstitutionoperationsonvalues(afvxg)andtypes(af7ag). \nl0 Formethodaddition,afreshinternalmethodnameis chosen.Itmustnotbeinthedomainofthemethodtype tableLsoasnottooverridethetypeofanothermethod.It \n mustnotbeintherangeofthedictionary'either.Indeed, l00'(l00l0 anymethodnamesuchthat)=wouldnotappear \ninthetypeoftheprototypebeforereductionandwouldbe giventype7afterreduction. Thetype\u00ab(a)[L0']isthemostgeneraltypeanobject\u00ab(x: \na)[LjL] ' canbegiven.Thistypeisthereforesubstitutedfor selftypeduringmethodinvocation. ThesemanticsisdefnedusinganevaluationcontextF: \nF ::= [] j F+(l:&#38;(a)7) j Fnl j F :l &#38;(x:a)a j F :l j F(a) j v(F) Thelocalreductionrelation,!isextendedtoaone-step \nevaluationrelation:a,!a 0ifthereareexpressionsa1and 0 000 a1suchthata=F[a1],a1,!a1anda=F[a1]. Valuesaredefnedbythefollowingsub-grammarofexpres\u00ad \nsions: v::=x j>(x:j\u00ab(x: 7)aa)[LjL] ' Variable Abstraction Object 2.3 Design choices Wepresentandjustifyheresomedesignchoicescommon \nwiththebasecalculusandthefullcalculuspresentedin nextsection.  2.3.1 Abstract methods Thecalculushasanotionofabstractmethods.Thisno\u00adtionisnotmandatory.However,inordertoensurethe \nsoundnessofacalculuswithmethodhidingandobjectex\u00adtension,methodoverridingandobjectextensionmustbe distinguished.Indeed,theyhaveanincompatiblesemantics \nwhentheyoperateonamethodthatalreadyexistsinthe object:withmethodoverriding,alreadyexistingmethods musthaveaccesstothenewdefnitionofthemethod;on \ntheotherhand,withobjectextension,anewmethodmust bedefned,diferentfromthepreviousmethodofthesame name,andthebehaviorofexistingmethodsshouldnotbe \naltered.Ratherthanhavingthesetwooperationsasprimi-tivesasintheworkofFisher,HonsellandMitchell[6],we havepreferredtodecomposeobjectextensionintothead\u00additionofanabstractmethodfollowedbytheoverridingof \nthismethod.Wefeelthattheselatterprimitivesaremore atomicandorthogonal.Furthermore,theyallowthedef\u00adnitionofmutuallyrecursivemethodswithoutresortingto \ntrickssuchasnon-terminatingmethods(anon-terminating methodbodycanhaveanytype,soitcanbeusedasa placeholder). \n 2.3.2 Depth subtyping Forthesakeofsimplicity,wehaveonlyconsideredwidth subtypingforobjectsinourcalculus.Wedon'texpect \nanydifcultywithdepthsubtyping.Indeed,wehavebeen carefulnottointroduceinthecalculusanyoperationsuch asmethodoverridinginobject,whichwouldbeunsound. \nDepthsubtypingwouldhowevermaketheproofssignif\u00adcantlylonger. Anunfortunateconsequenceofthisrestrictiontowidthsub\u00adtypingisthattypevariablesoccurringinanobjecttypeare \nnon-variant.Withdepth-subtyping,thedefnitionofcovari\u00adancecouldbeupdatedsoastogetridofthisrestriction. \n 2.3.3 Non-deterministic dynamic semantics Thesemanticswegiveisnotdeterministic.Indeed,whena methodisaddedtoaprototype,aninternalmethodname \ncanbearbitrarilychosenforthismethod.Itwouldbeeasy tomakethissemanticsdeterministicbyprovidingachoice \nfunction,associatinganewmethodnamestothesetofal\u00adreadyexistinginternalmethodnames(thisiswhatisdone intheworkofRieckeandStone[18],wherethemethods \narenumberedinaconsecutiveway).Alternatively,onecan noticethatinternalmethodnamescannotbeobservedfrom \noutsideanobject,inthesensethatthebehavioroftheobject isthesamewhatevermethodnamesarechosen.Itwould thereforebepossibletoidentifyobjectsmodulorenamingof \ntheirinternalmethodnames. 2.3.4 Typed dynamic semantics Thecalculusisexplicitlytyped,soastoeasetypechecking. \nForthesakeofsubjectreduction,typeannotationsmust thenbemanipulatedduringthereductionofanexpression. However,thedynamicsemanticsdoesnotdependontypes: \ntypescouldbeerasedbeforeevaluation.  2.4 Limitation of the calculus and its conse\u00adquences Thesimplifcationmadeinthebasecalculuswithrespect \ntothefullcalculusisessentiallythatnoattemptismade togiveaprecisetypetoselfinthebasecalculus:selftype \nissimplyconsideredasanabstracttypeinmethodbodies. Therefore,amethodcannotdoanythingwithselforany otherobjectofsametype,exceptignoringitorpassingit \naround.Inparticular,amethodcannotinvokesanother methodofthesameobject.Thislimitationhavediferent consequencesthatwepresentbelow. \n 2.4.1 Dictionaries Dictionariesarenotreallynecessaryforthiscalculus.In\u00addeed,amethodcannotbeinvokedanymoreoncehidden, \n andcouldthereforejustberemovedfromthemethodtable. However,wepreferredtointroducethisnon-trivialnotion \nonthesimplercalculus. 2.4.2 Covariance Thefollowingtypingrule,allowingtohidemethodsbysub\u00adtypingeveninpresenceofbinarymethods,wouldbesound. \nL0 .L ,`\u00ab(a)[L]:\u00ab(a)[L0] However,thistypingrulewouldmaketypecheckingsignif\u00adcantlymoredifcult.Indeed,consideranobjectxoftype: \n71::=\u00ab(a)[clone:a;id:a!a] Withthetypingruleabove,itwouldalsohavetype: 72::=\u00ab(a)[id:a!a] So,theexpressionx:idcanbegivenbothtype71!71 \nandtype72!72,eventhoughthesetypesdonothavea commonsupertype.Wehavethereforechosentoonlyallow methodhidingbysubtypingwhenselftypedoesnotappear \ncovariantlyintheobjecttype(ruleSub-Object-Base).We willdiscussthisinmoredetailsinSection3.4.  3. FULL \nCALCULUS 3.1 Informal presentation of the Calculus WefrstillustrateinSection3.1.1theproblemwithmethod \nhidingandbinarymethodsandsketchhowitcanbesolved usingviews.Wethendescribeinmoredetailsviewsand theirinteractionwithbinarymethodsinSection3.1.2.Fi\u00adnally,weprovidemoreexamplesinordertodescribethe \ndiferentfeaturesofthecalculusandshowitsexpressive\u00adness. 3.1.1 What is a Views? Letusconsideraprototypeofthefollowingtype: \n\u00ab(a)[val:int;compare:a!bool]; Supposethatwewouldlikethemethodcomparetocompare thevalueofitsargumentwiththevalueofself.Itsdefnition \nwouldbesomethinglike:&#38;(x:a)>(y:a)(x:val=y:val) Anobjectdirectlyderivedfromtheprototypewouldhave type: \n\u00ab(a)[val:int;compare:a!bool] Themethodvalcannotbehiddenbysubtyping,asadoes notoccurincovariantpositioninthetype.Asaconse\u00adquence,theargumentofthemethodcomparemustbean \nobjectwithamethodval,asexpectedbythemethod. Letusnowconsiderwhathappenswhenaprototypeisde\u00adrivedfromtheprototypeabovebyhidingthemethodval. \nThetypeofthenewprototypeis: \u00ab(a)[compare:a!bool]; Anobjectdirectlyderivedfromtheprototypehastype: \u00ab(a)[compare:a!bool] \n Accordingtothistype,themethodcomparecanbeapplied toanobjectthatmaynothaveamethodval.Thisisclearly unsound.So,inordertoallowsbothmethodhidingand \nbinarymethods,oneneedawaytokeeptrackinthetype thatanobjecthasagivenmethod,eventhoughthismethod isnotlistedanymoreinthetype.Forinstance,wecould \nattachatag,saycomparable,totheobjecttype,indicating thattheobjecthasamethodvaloftherighttype. \u00ab(a)[val:int;compare:a!bool]; \ncomparable Thetagwouldnotbeallowedtoberemovedaslongasthere isabinarymethod.Therefore,theobjecttypewouldalso \nhavethetag: \u00ab(a)[compare:a!bool]comparable Thenthemethodcomparecanonlybeappliedtoanobject whichhasamethodval,asthetypeofthisobjectisselftype \nwhichhasthetagcomparable. Butthisisnotsufcient.Indeed,themethodvalcould addedagainwithanothertype,diferentfromtheoneex\u00adpectedbythemethodcompare. \n\u00ab(a)[val:bool;compare:!comparable abool]; Theexpectedbehaviorwouldbethemethodcompareto invoketheoldmethod.Becauseofthis,thetagcannot \nbesimplyatypefeature.Itmustbepresentinsomeway inthedynamicsemanticsandmustprovideanaccessto somemethodswhichmaynotbeinthemaininterfaceof \ntheobject(thatis,whicharenotaccessibleviaamethod invocationa:l).Themainideaofthispaperistohavea collectionofalternativeinterfacestotheobjects,inaddition \ntoitsmaininterface.Analternativeinterfaceisselectedby anamek:a:kl.Wecallthesenamesviews.Anobjecttype \nholdsthesetofviewsthatcanbeusedontheobject.For instance: \u00ab(a)[compare:a!bool]fcomparableg Afxedtypeisassociatedtoeachview.Thistypede\u00adscribestheinterfaceitgivesaccessto.Thetypeoftheview \ncomparablecouldbe: \u00ab(a)[val:int;compare:a!bool] Thisviewthengivesaccesstoamethodvalandamethod compare.Themethodcomparecannowbedefnedsoas \nnottoaccessthemethodvaldirectly,butviatheview comparable. &#38;(x:a)>(y:a)(x:comparableval=y:comparableval) \nThen,comparewouldcontinuetoinvoketherightmethod evenwhenthemethodvalishiddenfromthemaininterface. \u00ab(a)[compare:a!bool]; \nfkg Ofcourse,viewscannotbehiddenwhenthereisabinary method.Onemaythereforethinkthatwewouldhavethe sameproblemwithviewsthatwithmethodnames.How\u00adever,contrarytomethodnames,viewsarelexicallyscoped \n:weusetheconstructionp(k:t)atodefneanewviewkof typetwithitsscopebeingtheexpressiona.Thisconstruc\u00adtionissimilartotheoneusedin[20]torepresentmemory \nlocationsortothevbinderofthe7-calculus[14].  3.1.2 Using views Inthisexample,weprogressivelycreateaprototypewith \nabinarymethodandanothermethodusedinthebinary method,thenhidethisothermethod.Wethenshowthat thebinarymethodcanstillbesafelyinvoked. \n Westartwithanemptyobject.Anobjectisdefnedasin thepreviouscalculusexceptfortheadditionofafunction <1mappingviewsktodictionaries'. \ny1::=\u00ab(x:a)[L1jL1] ':11 whereL1::=; L1::=; ' 1::=; <1::=; Thisobjectcanbeviewedasaprototypeoftype\u00ab(a)[L]A \nK whereallthecomponentsL,AandKareempty.Theset Kisthesetofviewsoftheprototype.Twomethodsare added: (y1+(compare:&#38;(a)a!bool))+(val:&#38;(a)int) \n Thisexpressionevaluatesintoaprototypey2: y2::=\u00ab(x:a)[L1jL2] ':21 whereL1::=; L2::=one:a!bool;two:int \n' 2::=compare7!one;val7!two <1::=; Thetypeofthisprototypeis fcompare;valg \u00ab(a)[compare:a!bool;val:int]; \n Wenowassumethattheenvironmentcontainsaviewkof type\u00ab(a)[compare:a!bool;val:int].Astheviewhas exactlythesamemethodsastheprototype,itcanbeadded \ntotheprototype:hy2ik.Thisexpressionevaluatesintoa prototypey3inwhichthecurrentdictionary' 2isassociated \ntotheviewk.Notethatthetypeoftheviewisindeedthe typeofthemethodsaccessibleviathisdictionary. y3::=\u00ab(x:a)[L1jL2] \n':23 whereL1::=; L2::=one:a!bool;two:int ' 2::=compare7!one;val7!two <3::=k7!(compare7!one;val7!two) \n Thetypeoftheprototypeisunchanged,exceptfortheview: fcompare;valg \u00ab(a)[compare:a!bool;val:int]fkg Whenamethodisdefnedoroverridden,thenewmethod \nbodyistypedassumingthatselftypeissometypeawhich hasatleasttheviewsK(herefkg)oftheprototype.So,we cannowdefneamethodcomparethatcomparesthevalue \nofthemethodsvaloftheobjectitselfandofanobjectof thesametype.Themethodvalwillbeinvokedviathe viewkthatbothobjectsareknowntopossess.Themethod \ndefnitioniswritten: y3:compare&#38;(x:a)>(y:a)x:kval=y:kval Itevaluatesintoaprototypey4: y4::=\u00ab(x:a)[L4jL2] \n':23 whereL4::=one=>(y:a)(x:kval=y:kval) L2::=one:a!bool;two:int ' 2::=compare7!one;val7!two <3::=k7!(compare7!one;val7!two) \nLetusfnishtheconstructionoftheprototypebythedef\u00adinitionofthemethodval,andthehidingofthismethod: (y4:val&#38;(x:a)5)nval.Thisexpressionevaluatesinto: \n' 5 y5::=\u00ab(x:a)[L5jL2]:3 whereL5::=one=>(y:a)(x:kval=y:kval); two=10 L2::=one:a!bool;two:int ' 5::=compare7!one \n<3::=k7!(compare7!one;val7!two) Bothmethodsarenowdefned,sotheprototypehastype: \u00ab(a)[compare:a!bool]; \nfkg Thereadermayobservethatthisincrementalconstruction ofaprototypesuggestsawayofencodingclassesinthis \ncalculus.Thetranslationofaclassdefnitionwouldstart fromthevalueoftheparentclass.First,allnewmethods wouldbeaddedasabstractmethods.Second,aviewwould \nbedefnedsothatmethodscaninvokeoneanother.Third, themethodswouldbedefned,oroverridden.Finally,the privatemethodswouldbehidden.(Moregenerally,aclass \nwouldbeencodedasafunctiontakingsomeinitialization argumentandbuildingaprototypethisway.) Letuscontinuetheexample.Asallitsmethodsaredefned, \ntheprototypey5canalsobeconsideredasanobject,oftype \u00ab(a)[compare:a!bool]fkg Wedefnetheobjecty6similarly,astheresultoftheevalu\u00adationoftheexpression(y4:val&#38;(x:a)7)nval. \nTheobjecty5hasamethodcompareoftypea!bool wherethetypeaisselftype.Theobjecty6ofsametype asy5canthereforebepassedasargumenttothismethod: \ntheexpressiony5:compare(y6)iswell-typed.Thetypeofthe objecty5ensuresthatbothobjectsy5andy6haveaview kasexpectedbythemethodcompare,sotheevaluationof \nthisexpressionwillnotgetstuck. Duringtheevaluationoftheexpressiony5:compare(y6),the expressiony5:kvalwillbealsoevaluated.Forthis,thedic\u00adtionary<3(k)correspondingtotheviewisfrstcomputed. \nTheexternalmethodnamevalistranslatedusingthisdic\u00adtionaryintheinternalmethodname<3(k)(val).Thisin\u00adternalmethodnameisusedtoextractthemethodbody \nL5(<3(k)(val)).Theevaluationthencontinuesasforadi\u00adrectmethodinvocation:theobjecttypeissubstitutedfor \nselftypeandtheobjectforselfinthemethodbody.  3.1.3 Abstract views Inthepreviousexample,themethodvalwashiddenfrom \nthemaininterfaceoftheprototype,butitcouldstillbe accessedviatheviewk.Soastomakethismethodreally private,weneedtofndawaytopreventtheuseoftheview \nk.Thesolutionweadoptistomaketheviewabstract,using amechanismsimilartotheoneforabstracttypes[5]. Westartfromthefunctionbelow,whichcouldbeusedto \ndefnethepreviousobjectsy5andy6. f::=>(z:int)((y4:val&#38;(x:a)z)nval) Thisfunctionhastype: int!\u00ab(a)[compare:a!bool]; \nfkg Wefrstcreateapackageoftype: 70=9(k0)(int!\u00ab(a)[compare:a!bool];fk0g) Notethattheviewkdoesnotappearinthistypeanymore. \nThepackageiscreatedbytheexpressionbelow: p::=packfas70hidingfkg Wethenopenthispackageintheremainderaofthepro\u00adgram: \nopenpas[k1;g]ina Intheexpressiona,thepackagedfunctionisnamedgand itstypeis: int!\u00ab(a)[compare:a!bool]; \nfk1g Inthistype,theviewk1isabstract:nomethodcanbe invokedviathisview.But,still,ifwedefnedtwoobjects \ny7::=g(5)andy8::=g(7),itispossibletoinvokethe methodcompareofy7withargumenty8:y7:compare(y8). Indeed,thisexpressioniswell-typed,andfurthermorethe \ncalculusensuresthatanyobjectofthesametypeasy7has aviewkasexpectedbythemethodcompare. Thereadermayhavenoticedthatthepackconstruction \ntakesasetofviewstobeabstracted,notjustoneview. Thisallowstohidethissetofviews,forinstanceinthetype ofaprototype.Indeed,thistypewouldotherwiserapidlybe \nclutteredbyviewsaseachtimeasetofmethodsisaddedto aprototype,aviewneedtobealsoaddedsothatthenew methodscaninvokeoneanother.Furthermore,allthese \nviewscouldpreventtomanipulateinauniformwayseveral prototypeswithadiferentorigin.Withthisconstruction, \nallprototypeswithaviewk0canbegivenatypeofthe form9(k)\u00ab(a)[L]A(forsomeLandA).Itwouldnot fk0;kg havebeenpossibletousesubtypinginsteadtohideaview \nofaprototypeinagenericway.Indeed,thiswouldnotbe safeinpresenceofbinarymethods:inaprototypeoftype \u00ab(a)[m:a!7;L]A \nK themethodmmayexpecttobeappliedtoanobjectthat hasatleastthesetofviewsK.Then,itisnotsoundto applyittoanobjectthatonlyhasasubsetoftheseviews. \n 3.1.4 Modeling instance variables Instancevariablecanbemodeledinthecalculususingtwo methods,asusual:themethodgetreturnsthevalueofthe \ninstancevariableandthemethodsetsetthisvalue: \u00ab(x:a)[LjL] ' : whereL::=one=5; 00 two=>(y:int)(x:kget&#38;(x:a)y) \nL::=one:int;two:int!a '::=get7!one;set7!two <::=k7!(get7!one;set7!two) Themethodsetexpectanargumentyandoverridethe \nbodyofthemethodget,viatheviewk,withanewbody returningthevalueofy.Thetypeofthisobjectis: \u00ab(a)[get:int;set:int!a]fkg \nThecalculusdoesnotincludeanyoperatorallowingtoover\u00adrideamethodviathemaininterfaceofanobject.One reasonforthisisthat,thoughsuchanoperationwouldbe \nsoundwiththecurrentsubtypingrules,itwouldbeunsound withdepthsubtyping.Ontheotherhand,overridingviaa viewwouldremainsafe,asaviewhasafxedtype. \n 3.1.5 Objects without binary methods Inthecalculus,viewsareneededfortypingbinarymeth\u00adods,andalsoinprototypesfordefningmutuallyrecursive \nmethods.But,lookingatthepreviousexamples,onemay thinkthatviewswouldpervasivelyclutterallobjecttypes evenwhentheyarenotneededanymoreformanipulating \ntheobject.However,thesubtypingrulesalwaysallowstore\u00admoveallviewsfromanobjecttypewithoutbinarymethod. \nSo,forinstance,thefollowingsubtypingrelationholds: \u00ab(a)[get:int;set:int!a]fkg : \u00ab(a)[get:int;set:int!a]; \nThesubtypingrulesforanobjectwithoutviewsisthesame asinthepreviouscalculusandarestandard. Itisdesirabletoconsiderselfasaregularobject,andin \nparticulartobeabletoapplyittoafunctiondefnedoutside amethodbody.However,selfisnotgivenanobjecttype, butratheritisonlyassumedthatitatleastagivensetof \nviews.So,itcannotbedirectlyappliedtoafunctionsuch astheonebelow: f::=>(y:\u00ab(a)[val:int];)y:val Thisisneverthelesspossibleinanindirectwaywhenthe \nobjecthasnobinarymethod.Forinstance,letusconsider theprototypebelow. z::=\u00ab(x:a)[LjL] ' : whereL::=one=5; \nL::=one:int;two:int '::=val7!one;use7!two <::=k7!(val7!one;use7!two) Weassumethattheviewkhastype \u00ab(a)[val:int;use:int] \nWewanttodefnethemethoduseoftheprototypezsothat itapplythefunctionftoself.Aswesaidjustabove,inside thebodyofthemethoduseweonlyknowthatselfhasa \nviewk,soitisnotpossibletodirectlyapplythefunctionto selfasfollows: z:use&#38;(x:a)f(x) Thiswouldactuallynotevenbesoundasthemethodval \ncouldbelatterhiddenfromthemaininterfaceoftheproto\u00adtype(andthereforewouldnotbeboundinthemaindictio\u00adnaryanymore).However,asubtypingruleallowstoconsider \nselfxashavingthetype\u00ab(a)[;]fkg.(Thisisonlypossible becauseselftypeonlyoccursincovariantpositioninthetype \noftheviewk.)Then,theconstructionxjkcanbeusedto replacethemaindictionaryoftheobjectxbythedictio\u00adnaryassociatedtotheviewk.Theexpressionxjkhastype \n\u00ab(a)[val:int;use:int]fkg.Bysubtyping,ithasalsotype \u00ab(a)[val:int];,andsowecanapplythefunctionftothis expression: \nz:use&#38;(x:a)f(xjk)  3.1.6 Friend Functions Afriendfunctionisafunctionthathasaprivilegedaccess toobjectsofaclass.Theexistenceofsuchprivilegedac\u00adcessisofparticularimportanceforprivacy.Indeed,iffor \ninstancetwoobjectsneededtointeractbetweeneachother, allmethodsnecessaryforthisinteractionwouldotherwise \nhavetoremainpublic.Theusualtricktoencodefriendfunc\u00adtionsinastructuraltypingsettingistouseamethodrepr \nthatreturnsthewholeinternalstateoftheobject[15].So thatonlyfriendfunctionscanaccessthisstate,thetypeof \nthismethodishiddenusinganabstracttype.However,this techniquedefeatsourgoalofbeingabletohidearbitrary \nmethods.Indeed,ifthemethodishiddeninasubclass, thefriendfunctionwillnotbeabletomanipulateobjectsof thissubclass.Anotherpossibilityistoembedtheclassand \nitsfriendfunctionsintoamodulethandoesnotexportthe class,butonlyaconstructorfortheobjectsoftheclass[9]. \nAnymethodoftheclasscanbehiddeninthetypeofthecon\u00adstructorbymakingitpartiallyabstract.However,thistech\u00adniqueprecludesanyfurthersubclassing.Thus,boththese \nsolutionsareunsatisfactory.Weshowhowpublicviewscan beusedtoimplementfriendfunctionswithoutanyofthese \nlimitations.Wehaveactuallypresentedallthenecessary ingredients.Wefrstdefneaclassctakinganinitialization \nargumentyandreturningaprototypewithamethodval whosevalueisthevalueoftheclassargument. c::=>(y:int) h\u00ab(x:a)[;j;];;+(val:&#38;(a)int)ik:val&#38;(x:a)y \n Theprototypeisdefnedusingthefollowingview: k:\u00ab(a)[val:int] Theclasshastype: int!\u00ab(a)[val:int];fkg \nWenowdefneafunctionfinvokingthemethodvalofits argumentviatheviewk. f::=>(x:\u00ab(a)[;]fkg)x:kval Wewanttopreventtheaccesstothemethodvalofthe \nclasscfromanywherebutthefunctionf. First,awrappertakescareofhidingthemethodvalfrom themaininterfaceoftheprototypereturnedbytheclassc. \n(Itisstillaccessibleviatheviewk.) c 0 ::=>(z:int)(c(z))nval Then,theclassandthefunctionarebothputinanobject \n(thisobjectcanbeviewedasarecord,oramodule). m::=(\u00ab(x:a)[;j;];; +(c:&#38;(a)(int!\u00ab(a)[;];fkg)) :c&#38;(x:a)c \n0) +(f:&#38;(a)(\u00ab(a)[;]fkg!int)) :f&#38;(x:a)f  Theviewisthenhiddenbyanabstractviewk0: p::=packmas70hidingfkg \n where 70::= 9(k0)\u00ab(a)[c:int!\u00ab(a)[;];fk0g;f:\u00ab(a)[;]fk0g!int]; a::=x Variable j>(x:7)a Abstraction ja(a \n0) Application j\u00ab(x:a)[LjL] ' Object : ja+(l:&#38;(a)7)Methodaddition janl Methodhiding ja:l Methodselection \nja:kl Methodselectioninview ja:l&#38;(x:a)a 0 Methodoverride ja:kl&#38;(x:a)a 0 Methodoverrideinview \njp(k:t)a Viewbinding jhaik Viewaddition jajk Viewreplacement jpackaas7hidingK Packing jopenaas[k;x]ina \n0 Unpacking 7::=a Typevariable j7!70 Functiontype jtK Objecttype A jtK Prototypetype j9(k)7 Viewabstraction \nt::=\u00ab(a)[L] Interfacetype L::=;jL;(l=a) Methodtable L::=;jL;(l:7)Methodtypetable '::=;j';(l7!l) Dictionary \n<::=;j<;(k7!')Dictionarytable K::=;jfk;:::;kg Viewset Figure5:Syntax Finally,theclassandthefunctionaremadeavailabletothe \nremainderaoftheprogram: openmas[k1;m1]ina Thetypeoftheclassm1:cis int!\u00ab(a)[;];fk1g Thetypeofthefunctionm1:fis \n\u00ab(a)[;]fk1g!int Thetypesystemensuresthatonlyobjectsderivedfromthe classcanhavetheviewk0.Asviewscannotberemoved \nfromobjects,alltheseobjecthaveaviewk,asexpectedby thefunctionm1:f,soitwouldbesoundtoapplythemto thisfunction. \n  3.2 Formalization (Sub-Arrow) (Sub-Refl) 7070 70 70 ,`71:72,`2:1 ,`7:7,`1!71:2!72 (Sub-Proto) ,`\u00ab(a)[L]K:\u00ab(a)[L0]K0 \n,`\u00ab(a)[L];:\u00ab(a)[L0 K]K0 (Sub-Object) L0.LcoG(L0)K0.K 0\u00ab(a)[L00coG(L00 8k2K.(k:])2,^) ,`\u00ab(a)[L]K:\u00ab(a)[L0]K0 \n(Sub-Match) ,`a..K 8k2K.(k:\u00ab(a)[L00])2,^coG(L00) ,`a:\u00ab(a 0)[;]K Figure7:Subtypingrules (Match-Var)(Match-Obj) \n(a..K)2,K0.KK0.K ,`a..K0 ,`\u00ab(a)[L]K..K0 Figure8:Matchingrules Thecalculusisanextensionofthecalculuspresentedinthe \nfrstsection.Theformalizationreusesthesamenotations. 3.2.1 Syntax Thesyntaxofthecalculusispresentedinfgure5.Itas\u00adsumesaninfnitesetofviewsk.Werecallthatadictionary \ntable<isafnitepartialfunctionfromviewsktodictionar\u00adies'. 3.2.2 Static semantics Thestaticsemanticsdefnesatypingjudgment,`a:7and \nasubtypingjudgment,`7:70 ,whereanenvironment, isasequenceofbindings.Anenvironmentcontainsboth valuebindingsandviewbindings.Italsocontainswhatwe \ncallmatchinghypothesis,thatisthehypothesisthatatype ahasatleastthesetofviewsK(thisisnotthesamenotion \nofmatchingastheoneintroducedbyKimBruce[4],but thetwonotionshavesimilarities:typesthatmatchagiven setofviewshaveasimilarshape,butarenotnecessarily \nsubtypesofasametype). ,::=; Emptyenvironment j,;(x:7)Valuebinding j,;(a..K)Matchinghypothesis j,;(k:t)Viewbinding \nj,;(k)Abstractviewbinding Thetypingrulesaregiveninfgures6,7,and8.Asinthe previouscalculus(Section2.2.2),alljudgmentareassumed \ntobeclosedandnovariableareeverboundtwiceinan environment. (Var)(Abs) 70 (x:7)2, ,;(x:)`a:7 ,`x:7 ,`>(x:70)a:70!7 \n(App)(Sub) 0 ,`a:70!7,`a:70 ,`a:7,`7:70 070 ,`a(a):7 ,`a: (Proto) L0 =L0'A=domL0 ndom(L0') K=dom<domL.domLrange' \nForalllindomL,,;(a..K);(x:a)`L(l):L(l) 8k2dom<.(k:\u00ab(a)[L00])2,^L00 =L0<(k) ,`\u00ab(x:a)[LjL] ' :\u00ab(a)[L0]A \n:K (Extension)(Restriction) ,`a:\u00ab(a)[L]A ,`a:\u00ab(a)[L]Al2domLnA KK AUflg ]A ,`a+(l:&#38;(a)7):\u00ab(a)[L;(l:7)]K \n,`anl:\u00ab(a)[LjdomLnflgK (View-Selection) (Selection) ,`a:7,`7..K ,`a:77=\u00ab(a)[L]K k2K(k:\u00ab(a)[L0])2, 70700 \n(l:)2L (l:)2L,`a:l:70f7ag ,`a:kl:70f7ag (View-Override) (Override) ,`a:7,`7..K ,`a:\u00ab(a)[L]A k2K(k:\u00ab(a)[L0])2, \nK 00L0 ,;(a..K);(x:a)`a:L(l),;(a..K);(x:a)`a:(l) Anflg0 ,`a:l&#38;(x:a)a 0:\u00ab(a)[L]K ,`a:kl&#38;(x:a)a:7 \n(View-Replace) (View-Capture) ,`a:\u00ab(a)[L]K (View-Abs) ,`a:\u00ab(a)[L]A k2K K ,;(k:t)`a:7 (k:\u00ab(a)[L])2,(k:\u00ab(a)[L0])2, \n,`p(k:t)a:7,`haik:\u00ab(a)[L]A ,`aj:\u00ab(a)[L0]K KUfkg k (Open) 0 (Pack) ,`a:9(k)70 ,`a:7fKkg ,;(k);(x:)`a:7 \n70 0 ,`packaas9(k)7hidingK:9(k)7,`openaas[k;x]ina:7 Figure6:Typingrules Methodaddition S (l062domLrange'range<(k)) \nk2dom: \u00ab(x:a)[LjL] ' +(l:&#38;(a)7),! :';(l=l0) \u00ab(x:a)[Lj(L;(:7))] l0: Methodhiding \u00ab(x:a)[LjL] ' :nl \n,! \u00ab(x:a)[LjL] 'jdom'nflg : Override \u00ab(x:a)[LjL] ' :l&#38;(x:a)a,! : \u00ab(x:a)[L;('(l)=a)jL] ' : \u00ab(x:a)[LjL] \n' :kl&#38;(x:a)a,! : \u00ab(x:a)[L;(<(k)(l)=a)jL] ' : Methodinvocation (v=\u00ab(x:a)[LjL] ' and7=\u00ab(a)[L0']dom:) \n: v:l,!L('(l))f7agfvxg v:kl,!L(<(k)(l))f7agfvxg Viewmanipulations h\u00ab(x:a)[LjL] ' ,!\u00ab(x:a)[LjL] ' :ik:;(k=') \n\u00ab(x:a)[LjL] ' j,!\u00ab(x:a)[LjL]:(k) :k : Application (>(x:7)a)(v),!afvxg Unpacking(v=packv 0 as9(k)7hidingK) \nopenvas[k;x]ina,!afKkgfv 0 xg Viewbindings(F=6[]) F[p(k:t)a],!p(k:t)F[a] Figure9:Reductionrules Weonlypresentthemostcomplexrules.Tobeableto \noverrideamethodlviaaviewkinanobjectaoftype 7(ruleView-Override),theobjectmusthaveatleast asetofviewKcontainingtheviewk,theviewmustbe \nboundintheenvironmenttoatype\u00ab(a)[L0]andthetype ofthemethodbody,assumingthatselfhasatleastthe methodK,mustbethetypeofthemethodkin.The \nL0 ruleView-SelectionismodeledafterruleView-Override (foraccessingthetypeoftheview)andruleSelection. \nIntheruleProto,thefrstcondition=L0'ensures L0 L0typeisthemethodtypetableLtranslatedbythedictionary '.ThesecondconditionA=domL0 \nndom(L0')asserts thattheabstractmethodsAaretheexternalmethods(do\u00admainof)whicharenotdefnedinthemethodtableL. \nthatthetypeofthemethodsinthetypeoftheproto- L0ThethirdconditionK=dom<assertsthattheviewsK oftheprototypearethedomainofthefunction<map\u00adpingviewstodictionaries.ThefourthconditiondomL. \ndomLrange'togetherwiththesecondconditionensures thattheequalitydomL=domLholdsforaproperob\u00adject(whereA=;).Thisthenensuresthatthedictionary \ncanbesoundlyreplacedinanobjectbyanyotherdictio\u00adnary(inruleView-Replace).Fifth,eachinternalmethod istypedinanenvironmentwhereselftypeaisanabstract \ntypeandselfxhastypea.Finally,allviewsofthepro\u00adtotypemustbedefnedintheenvironmentandtheirtype mustmatchtheinternaltypeoftheprototype,astranslated \n(L00 bythedictionaryassociatedtotheview=L0<(k)). Thislatterconditiontogetherwiththefourthconditionen\u00adsuresthatallmethodsthatcanbeaccessedviatheview \n(ruleView-Selection)areindeeddefned. TheruleSub-Objectallowsmethodandviewhidingin objecttypes,aslongasselftypeiscovariantintheresulting \nobjecttypeandinthetypesoftheviewsassociatedtothe objecttype.TheruleSub-Matchissimilarandformalizes theideathatanyobjecttypethathasatleastasetofviews \nKisalwaysasubtypeof\u00ab(a 0)[;]K,providedthatthislatter typesatisfesthesamerestrictionsastheresultingtypeof \nruleSub-Object. 3.2.3 Dynamic semantics Thelocalreductionrelation,!isdefnedinfgure9.In additiontothesubstitutionsonvaluesandtypes,therules \ndefningthisrelationmakeuseofathirdsubstitutionoper\u00adationthatreplacesaviewbyasetofviews.Thisoperation \nissuchthat: Kf K 0 kg = K n f kg K 0ifk2 K = Kotherwise. andisotherwisesimilartotheothersubstitutions. \nFormethodaddition,afreshinternalmethodnamelischo\u00adsen.Itmustnotbeinthedomainofthemethodtypetable Lsothatnottooverridethetypeofanothermethod,and \nitmustnotbeintherangeofthedictionary',oranyof thedictionaries<(k)sothatonlythemethodlbeadded tothemaininterface(andnotalsoallmethodswhoseim\u00adageby'isl),andsothatthealternativeinterfacesremain \nunchanged.TheruleforanexpressionF[p(k:t)a]pushes viewbindingsoutwards,allowingtheinteractionofofthe expressionawiththecontextF[]. \nThesemanticsisdefnedusingthecontextsEandF.The contextEliststheviewsintroducedduringtheevaluation whilethecontextFindicateswheretheevaluationtakes \nplace.E::=[]F::=[] jp(k:t)E jF+(l:&#38;(a)7) jFnl jF:l&#38;(x:a)a jF:kl&#38;(x:a)a jF:l jF:kl jhFik jFjk \njF(a) jv(F) jpackFas7hidingK jopenFas[k;x]ina EvaluationcontextsarecontextsoftheformE[F[]]:the localreductionrelation,!isextendedtoaone-stepeval\u00aduationrelation:a,!a \n0ifthereareexpressionsa1anda1 0  000 suchthata=E[F[a1]],a1,!a1anda=E[F[a1]]. Valuesaredefnedbythefollowingsub-grammarofexpres\u00adsions: \nv::=x Variable j>(x:7)a Abstraction j\u00ab(x:a)[LjL] ' Object : jpackvas7hidingKViewabstraction Inadditiontotheruleformethodaddition,therulepush\u00adingviewbindingsoutwardsintroducesanothersourceof \nnon-determinism,asseveralcontextsFmaybepossible(as in[20]).However,itiseasytoconvinceoneselfthatthe choiceofthecontextwillnotmodifytheresultoftheeval\u00aduation. \n  3.3 Soundness Weh aveprovedthefollowingsoundnessresults: Theorem1.Subjectreduction..If,`a:7and a,!a \n0 ,then,`a 0:7. Theorem2.Progress..If`a:7thenaisE[v]for somevaluevora,!a 0forsomeexpressiona 0 . Theproofsarestandard.Theproofofsubjectreductionis \nquitelengthy,asmostreductionrulesinvolveobjectsand thetypingruleforobjects(ruleProto)islarge.Butthere \nisnospecifcdifculty.  3.4 Typing issues 3.4.1 Subtyping Thecalculushasbeendesignedsoastomaketypechecking \nstraightforward.Aconsequenceofthisisthatthesubtyping ruleSub-Objectismorerestrictivethanwhattypesound\u00adnessalonewouldhaverequired.Indeed,whilethiswould \nbesound,theruledoesnotallowthehidingofmethods whenselftypeisnotcovariantinaviewoftheobject.Ifthis restrictionwasremoved,thecalculuswouldnothaveprin\u00adcipaltypes.Indeed,letusconsiderforinstanceanobjectx \noftype 70=\u00ab(a)[n:int]fkg wheretheviewk,hastype\u00ab(a)[m:a!a].Thenx:km hastype70!70.Ifsubtypingwereallowedinthiscase,x \nwouldalsohavetype 71=\u00ab(a)[]fkg: Then,x:kmwouldalsohavetype71!71,whichisnotcom\u00adparablewithtype70!70.Thisdifcultycouldbeavoided \nusinghigher-ordertypes:indeed,thetypeofx:kmcouldbe a!aforallasuchthat70:a:71.Hidingarbitrary methodinaproperobjectwithabinarymethodwouldalso \nbesafe,butraisesthesamedifculty,aspreviouslymen\u00adtionned. 3.4.2 Type inference Webelievethatthetypingrulescouldbeeasilyadapted \ninordertomaketypeinferencepossible,usingrowvari\u00adables[19]inasimilarwaytoObjectiveCaml[17,16].Of course,subtypingwouldhavetobeexplicit,butaccording \ntoourexperiencewithObjectiveCaml,thisisnotaprob\u00adleminpractice.Furthermore,thiswouldallowustogetrid oftherestrictionsexposeintheparagraphabove.Thetype \nofanobjectwouldbecomposedoftwopossiblyextensible rows:oneformethods,theotheroneforviews.Weexpect thatthetypingofselfwouldthennotrequireanyspecial \nrule.Indeed,selftypecouldbemodeledasanobjecttype withnomethodandanextensiblerowofviews.  4. PROBLEMS \nWITH MULTIPLE INHER-ITANCE Whilethiscalculuscanbeusedforaclass-basedlanguage withsingleinheritance,itunfortunatelyexhibitsananomaly \nthatmakesproblematicitsuseasabaseforalanguagewith multipleinheritance.Indeed,abstractioncanbebrokenun\u00addercertaincircumstance. \nIndeed,letusconsideranobjectwithaviewk.Thisview canbehiddenfromthetypeoftheobjectusinganabstract view.Onecouldthinkthatthereisthennowaytousethis \nviewoftheobjectfromoutsideanymore.Inparticular,one wouldexpectthatthemethodsthatcanonlybeaccessvia thisviewcannotberedefned,andthatthedictionaryassoci\u00adatedtothisviewintheobjectcannotbechanged.However, \niftheviewisstillavailableintheenvironment,nothingpre\u00adventusfromaddingitagaintotheobject.Thiswillchange \nthedictionaryassociatedtotheviewintheobject:itwill becomethesameasthedictionaryoftheprimaryinterface \noftheobject.Andmethodscanthenberedefnedusingthis view. Inalanguagewithsingleinheritance,thescopeoftheviews \ncanbecontrolledsoastoavoidthisproblem.Withmultiple inheritance,however,ifaclassinheritstwicefromanother \nclass(eitherdirectlyorindirectly),itwillinheritfromits viewstwice.So,ifaviewhavebeenhiddenononlyoneof \ntheinheritancepaths,itwillstillbevisibleintheclass. 5. RELATED WORK RieckeandStone[18]havedesignedanobjectcalculuswith \nobjectextensionwheremethodscanbearbitrarilyhidden. Thisisachievedusingsubsumptionandbyaprivilegedac\u00adcesstoothermethodsofselffromamethoddefnition.Their \ncalculusdoesnothandlebinarymethods.Ourcalculusis stronglyinspiredbythiswork.Indeed,wereusetheidea ofdictionariesfordecouplingtheinternalnamingfromthe \nexternalnamingofmethods.Apartfromitsstrongcon\u00adnection,thecalculiusecompletelydiferentmechanismsto achievetheirgoal. \nMoby[8]isanexperimentalobject-orientedlanguage.It aimsatprovidingagoodinteractionbetweenclassesand modules.Likeourlanguage,itallowsarbitrarymethodhid\u00adinginclasses.Itisbasedonavariantofthefrst-order \nversionofRieckeandStonecalculuswithstatefulobjects. Asaconsequence,itdoeshavethenotionofselftype.Anex\u00adtensionofMobywithinheritance-basedsubtypinghasbeen \nrecentlyproposedbyFisherandReppy[10].Thecalcu\u00adlustheyhavedevelopedtovalidatetheirdesign(XMOC)is class-based.Classesplayinthiscalculusarolesimilarto \nviewsinourcalculus.Theyproposeinthispaperasolution forfriendfunctions(writteninExtendedMoby)whichis veryclosetotheoneofSection3.1.6. \nSeveralcalculicombiningobjectextensionwithobjectsub\u00adsumptionhavebeenproposed,startingwiththeworkof FisherandMitchell[7].Theyensuresoundnessbyhaving \ntwokindofobjecttypes,prototypesandproperobjects,as ourcalculus.Theyusuallydonotallowmethodhidingin prototypes.Thisisthecaseforthecalculuspresentedby \nGianantonio,HonsellandLiquoriin[13],aswellastheone proposedbyBono,Bugliesi,LiquoriandDezani-Ciancaglini \nin[1].InthecalculuspresentedbyBonoandFisherin[2], itispossibletohidethetypeofanymethodsofaprototype. \nThisisachievedbywrappingprototypeswithinexistentials. Ourcalculususethesameideatohideviews(thisideais \ninitiallyduetoPierceandTurner[15]).However,themeth\u00adodsarenotcompletelyhidden:theirnamesremainvisible \nandtheprototypecannotbeextendedwithnewmethodsof thesamename. Aneedforcontext-dependentbehaviorofobjectshasemerged \ninthecontextofdatabaselanguages:dependingonthecon\u00adtext,anobjectwouldplaydiferentroles,whileretaining \nitsidentity.Thisnotionofroleshasbeenformalizedby GhelliandPalmerini[12].Theypresentafrst-ordercal\u00adculuswithroles.Itappearsthatviewsaresimilartoroles \nthoughtheyhavebeenintroducedforacompletelydiferent purpose.Contrarytoourcalculus,however,eachmethodof \nanobjectbelongstoexactlyonerole.Anotherdiferenceis thattherolesformahierarchy,andattheinvocationofa methodl,themethodselectedisthemethodassociatedto \nlintheminimumsuper-roleofthecurrentrole. Flatt,KrishnamurthiandFelleisen[11]makeuseofviews todefnepowerfulmixins(amixinisafunctionfromclasses \ntoclasses).However,theirmixinlanguagedoesnothave selftype.  6. CONCLUSION Thispaperpresentsanobject-orientedcalculusallowingar\u00adbitraryhidingofmethodsinprototypes.Thiscalculusalso \n hasbinarymethodsandcanbeusedtoencodefriendfunc\u00adtions.Webelievethatthisisthefrstcalculussmoothly combiningallthesefeatures.Thisdemonstratesthatgood \nmodularitypropertiesofanobject-orientedlanguagedoes notnecessarilycomeattheexpenseofitsexpressiveness. \nViewsareakeyingredientforthesoundnessofourcalculus. Theyarealsoaninterestingfeatureforanobject-oriented \nlanguage.Indeed,theybringmorefexibilitybyallowingan objecttosimultaneouslypossessseveraldistinctinterfaces. \nWethereforebelievethatthisnotioncouldbeusedfruitfully forotherpurposes. Ourcalculusdoesnotcurrentlyhandlemultipleinheritance. \nWehopethatmultipleinheritanceispossibleeventhough thismightrequiresasignifcantlydiferentsemantics.This \nisanotherimportantdirectionforfuturework. 7. REFERENCES [1]V.Bono,M.Bugliesi,L.Liquori,and M.Dezani-Ciancaglini.Subtypingconstraintfor \nincompleteobjects.InProceedingsof TAPSOFT/CAAP,number1214inLNCS,pages 465.477.Springer-Verlag,1997. \n[2]V.BonoandK.Fisher.Animperative,frst-order calculuswithobjectextension.InECOOP,pages 462.497,1998. \n [3]K.B.Bruce,L.Cardelli,G.Castagna,T.H.O. Group,G.T.Leavens,andB.Pierce.Onbinary methods.TheoryandPracticeofObjectSystems, \n1(3):221.242,1995. [4]K.B.Bruce,A.Fiech,andL.Petersen.Subtypingis notagood.match\"forobject-orientedlanguages.In \nECOOP,number1241inLNCS,pages104.127. Springer-Verlag,1997. [5]L.CardelliandP.Wegner.Onunderstandingtypes, \ndataabstractionandpolymorphism.ACMCS, 17(4):471.522,Dec.1985. [6]K.Fisher,F.Honsell,andJ.C.Mitchell.Alambda \ncalculusofobjectsandmethodspecialization.Nordic JournalofComputing,1(1):3.37,Spring1994. [7]K.FisherandJ.Mitchell.Adelegation-basedobject \ncalculuswithsubtyping.InFundamentalsof ComputationTheory(FCT'95),number965inLNCS, pages42.61.Springer-Verlag,1995. \n[8]K.FisherandJ.Reppy.FoundationsforMobyclasses. BellLabsTechnicalMemorandum,December1998. [9]K.FisherandJ.Reppy.Thedesignofaclass \nmechanismforMoby.InA.Press,editor,Conference onProgrammingLanguageDesignand Implementation,pages37.49,1999. \n [10]K.FisherandJ.Reppy.ExtendingMobywith inheritance-basedsubtyping.InECOOP,number1850 inLNCS,pages83.107.Springer-Verlag,2000. \n[11]M.Flatt,S.Krishnamurthi,andM.Felleisen.Classes andmixins.InConferenceRecordofPOPL'98:The 25thACMSIGPLAN-SIGACTSymposiumon \nPrinciplesofProgrammingLanguages,pages171.183, SanDiego,California,19.21Jan.1998. [12]G.GhelliandD.Palmerini.Foundationsforextensible \nobjectswithroles.PresentedattheFOOL'6 workshop,Jan.1999. [13]P.D.Gianantonio,F.Honsell,andL.Liquori.A \nlambdacalculusofobjectswithself-infictedextension. InA.S.Notices,editor,Proceedingsoftheconference onObject-orientedprogramming,systems,languages, \nandapplications,pages166.178,October1998. [14]R.Milner,J.Parrow,andD.Walker.Acalculusof mobileprocesses,I.InformationandComputation, \n100(1):1.40,Sept.1992. [15]B.C.PierceandD.N.Turner.Staticallytyped friendlyfunctionsviapartiallyabstracttypes. \nTechnicalReportECS-LFCS-93-256,Universityof Edinburgh,LFCS,Apr.1993.Alsoavailableas INRIA-RocquencourtRapportdeRechercheNo.1899. \n[16]D.R.emy.Typeinferenceforrecordsinanatural extensionofML.InC.A.GunterandJ.C.Mitchell, editors,TheoreticalAspectsOfObject-Oriented \nProgramming.Types,SemanticsandLanguageDesign. MITPress,1994. [17]D.R.emyandJ.Vouillon.ObjectiveML:Anefective \nobject-orientedextensiontoML.TheoryAndPractice ofObjectSystems,4(1):27.50,1998.Apreliminary versionappearedintheproceedingsofthe24thACM \nConferenceonPrinciplesofProgrammingLanguages, 1997. [18]J.G.RieckeandC.A.Stone.Privacyvia subsumption.InformationandComputation,2000.To \nappear. [19]M.Wand.Completetypeinferenceforsimpleobjects. InD.Gries,editor,SecondSymposiumonLogicIn ComputerScience,pages207.276,Ithaca,NewYork, \nJune1987.IEEEComputerSocietyPress. [20]A.K.WrightandM.Felleisen.Asyntacticapproach totypesoundness.TechnicalReportCOMP \nTR91-160,DepartmentofComputerScience,Rice University,Houston,Texas,Apr.1991.  \n\t\t\t", "proc_id": "360204", "abstract": "We presen t an object-oriented calculus whic hallows arbitrary hiding of methods in protot ypes, even in the presence of binary methods and friend functions. This combination of features permits complete control of the in terface a class exposes to the remainder of a program (which is of key importance for program readability, security and ease of maintenance), while still allowing complex in teractions with other classes belonging to the same module or softw are component.This result is made possible by the use of views. A view is a name that specifies an in terface to an object. A set of views is attached to each object and a method can be invoked either directly or via a view of the object.", "authors": [{"name": "J&#233;r&#244;me Vouillon", "author_profile_id": "81100141421", "affiliation": "Department of Computer and Information Science, University of Pennsylvania", "person_id": "P119290", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/360204.360233", "year": "2001", "article_id": "360233", "conference": "POPL", "title": "Combining subsumption and binary methods: an object calculus with views", "url": "http://dl.acm.org/citation.cfm?id=360233"}