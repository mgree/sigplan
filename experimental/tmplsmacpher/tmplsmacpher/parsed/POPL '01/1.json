{"article_publication_date": "01-01-2001", "fulltext": "\n Extensionality and Intensionality of the Ambient Logics Davide Sangiorgi INRIA Sophia-Antipolis, France \n davide, sangiorg\u00b1@sophia, inria, fr ABSTRACT The ambient logic has been proposed for expressing proper- \nties of process mobility in the calculus of Mobile Ambients (MA), and as a basis for query languages \non semistructured data. To understand the extensionality and the intensionality of the logic, the equivalence \non MA processes induced by the logic (=L) is compared with the standard MA behavioural equivalence and \nwith structural congruence (an intensional equivalence, used as an auxiliary relation in the definition \nof satisfaction of the logic). The main contributions include a co-inductive characterisation of =L as \na form of labelled bisimilarity, and axiomatisations of =L on the synchronous and asynchronous (finite) \ncalculus. The study shows that, surprisingly, the logic allows us to observe the internal structure of \nthe processes at a very fine- grained detail, much in the same way as structural congru- ence does. A \nspin-off of the study is a better understanding of behavioural equivalence in Ambient-like calculi. For \nin- stance, behavioural equivalence is shown to be insensitive to stuttering phenomena originated by \nprocesses that may repeatedly enter and exit an ambient. 1. INTRODUCTION The purpose of the calculus \nof Mobile Ambients, MA [5, 7], is to study process mobility, where mobility is thought of as modifications \nof spatial configurations over time. Lo-cations, called ambients, are named, and may be nested. A spatial \nconfiguration can therefore be represented as an edge-labelled tree in which the subtrees are the subambients \nand the labels of the edges are the ambient names. For in- stance, the MA process a[b[0]] [ c[0], formed \nby an empty ambient c in parallel with an ambient a containing an empty subambient b, has the following \ntree representation (drawing Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \nprofit or commercial advan- tage and that copies bear this notice and the full citation on the first \npage, To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspecific permission and/or s fee. POPL '01 1/01 London, UK &#38;#169; 2001 ACM ISBN 1-58113-336-7/0110001 \n...$5.00 only the edges):  a/\\o bl The trees are unordered: the order of the children of a node is \nnot important. An ambient may contain, besides other ambients, also lo- cal processes, which determine \nthe ambient movements and the communications. (In the tree representation, these lo- cal processes can \nbe thought of as the content of the nodes of a tree.) The primitives for movement allow: an ambient to \nenter a sibling ambient; an ambient to exit the parent ambient; a process to dissolve an ambient boundary. \nCom-munication is exchange of messages within an ambient; an example is a[{M}](x) PIb[Q]] 'a[p{M/x}lb[Q]] \nin which the message with content M is consumed by the abstraction (x) P. To express properties of mobility \nin MA, Cardelli and Gor- don have introduced a modal logic [8]. This is, intuitively, a logic of dynamically-evolving \nunordered edge-labelled trees. Indeed, the actual definition of satisfaction of the formu- las is given \non MA processes quotiented by a relation of structural congruence, --:, that equates processes with the \nsame tree representation. (Relation ~ follows the idea of the Chemical Abstract Machine [2l and Milner's \nstructural congruence for the ~r-calculus [13].) The logic has a connective that talks about time, that \nis, how processes can evolve: the formula O A is satisfied by those processes with a future in which \nA holds. The logic has also connectives that talk about space, that is, the shape of the edge-labelled \ntrees that describe process distributions: the formula n[ A] is satisfied by ambients named n whose content \nsatisfies A (read on trees: n[ A] is satisfied by the trees whose root has just a single edge n leading \nto a subtree that satisfies A); the formula A1 [ A2 is satisfied by the processes that can be decomposed \ninto parallel components P1 and P2 where each Pi satisfies A~ (read on trees: A1 [ A2 is satisfied by \nthe trees that are the juxtaposition of two trees that respectively satisfy the formulas A1 and A2); \nthe formula 0 is satisfied by the terminated process 0 (on trees: 0 is satisfied by the tree consisting \nof just the root node). The ambient logic has also been advocated as a foundation of query languages \nfor semistructured data [3, 4]. Here, the laws of the logic are used to describe query rewriting rules \nand query optimisations. This line of work exploits the similarities between dynamically-evolving edge-labelled \ntrees and the standard models of semistructured data. In this paper we study the extensionality and the \nintension- ality of the ambient logic. We discuss below the motivations for this topic, and what makes \nit technically challenging. A logic, defined on the terms of a calculus or of a model, is eztensional \nif it can only separate terms that have different behaviours: processes with the same behaviours satisfy \nthe same sets of formulas. (A stronger notion of extensionality is sometimes preferred, whereby the logic \nseparates all and only the terms with different behaviours.) The logic is inten-sional if it can separate \nterms on the basis of their internal structure, even though their behaviours are the same. In a process \ncalculus, the notions of 'behaviour' and 'behavioural equivalence' are best formalised operationally; \nfor instance, by means of a reduction relation and a contextually-defined equivalence such as may testing \n[9] or barbed congruence  [141. 'Extensionality and intensionality' is therefore a fundamen- tal question \nfor a logic: it tells us whether the logic fits the intended semantics of the calculus or model on which \nthe logic is defined. The question boils down to understanding the equivalence on terms induced by the \nlogic, whereby two terms are equated if they satisfy the same sets of formu- las. The topic is well-understood \nin standard modal logics. A well-known example, in CCS, is the characterisation of bisimilarity in terms \nof the Hennessy-Milner logic [10]. The ambient logic has however striking differences with stan- dard \nmodal logics. First, standard modal logics do not talk about space. Secondly, they have more precise \ntemporal con- nectives. The only temporal connective of the ambient logic talks about the evolution of \na system on its own. In standard modal logics, by contrast, the temporal connectives also talk about \nthe potential interactions between a process and its environment. For instance, in the Hennessy-Milner \nlogic the temporal modality (~/. A is satisfied by the processes that can perform the action Iz thus \nbecoming a process that sat- isfies A. The action ~ can be a reduction, but also an input or an output. \nThe lack of temporal connectives in the am- bient logic is particularly significant because in MA interac- \ntion between a process and its environment can take several forms, originated by the communication and \nthe movement primitives. (There are 9 such forms; they appear as labels of transitions in a purely SOS \nsemantics of MA [6, 12].) We are therefore led to comparing three relations on MA processes: the equivalence \ninduced by the ambient logic, =L; behavioural equivalence, ~ (as the logic is branching-time, is barbed \ncongruence, which is based on bisimulation); and structural congruence, ~. The comparison with ~ is important \nbecause =- is intensional and because it is used as an auxiliary relation in the definition of satisfaction \nin the logic. To begin with, we restrict ourselves to the finite processes, i.e., the processes without \nrecursion or replication. One of the reasons why finite processes are interesting is that on them we \ncan hope to axiomatise the differences among the equivalences. Afterwards, we discuss the addition of \nrecursion. Except for the inclusion ~C=L (which holds by definition of satisfaction), the relationship \nof =L with ~ and ,~ is far from obvious. It is not obvious whether =LC~ should hold because the potential \ninteractions of a process with the environment (communications and movements) are ob- servable in the \nbehavioural equivalence but, as mentioned above, the logic does not have primitive temporal connec- tives \nfor them. The opposite inclusion is not obvious either, because the logic allows us to intensionally \nlook into the par- allel structure of processes. Finally, it is not obvious that =LC~ should hold because \n~ is a very strong relation -a few axioms are the only difference with syntactic identity. We summarise \nour main contributions. We show that =L is strictly included in ~ and that, on the finite processes, \nthe only difference between =L and .~ is an axiom similar to the eta rule of the A-calculus. In MA, communication \nis asyn- chronous. We also show that =L is precisely ~ in the (finite) synchronous calculus. To obtain \nthe results we go through two coAnductive characterisations of =L, as forms of labelled bisimilarity. \nThe reason for having two such characterisa- tions is technical, and has to do with the well-known prob- \nlem of proving that bisimilarity is a congruence in higher- order process calculi. (MA is higher-order \nbecause terms may move during a computation.) The hardest part of the co-inductive characterisations \nis, however, the definition of the characteristic formulas for the messages, that is, the for- mulas \nthat separate the messages with a given content from the other processes. The study shows that, surprisingly, \nthe logic allows us to observe the internal structure of the processes at a very fine- grained detail, \nmuch in the same way as structural congru- ence does. A spin-off of the study is a better understanding \nof behavioural equivalence in MA-like calculi, something lit- tle explored so far. For instance, we have \ndiscovered that behavioural equivalence is insensitive to stuttering phenom-ena, originated by processes \nthat may repeatedly enter and exit an ambient. The characterisations in terms of _= plus eta and in terms \nof ~ give us axiomatisations of =L on asynchronous and synchronous finite MA. We are not aware of other \naxiomati- sations of semantic equivalences (defined by operational, de- notational, logical, or other \nmeans) in higher-order process calculi. As counterexamples to the inclusion ~C----L, we have found three \naxiom schemata. We do not know whether they are complete, that is, they exactly describe the difference \nbetween the two relations on finite MA. 2. BACKGROUND This section collects the necessary background: \nthe MA cal- culus, the ambient logic. Sections 3 to 6 will present our contributions. 2.1 Finite Ambients \nWe recall here the syntax of finite MA, briefly MA, from [5]. The adjective 'finite' indicates the omission \nof operators for representing infinite terms, such as recursion or repli- cation. Furthermore, only names, \nnot capabilities, can be communicated (this allows us to work in an untyped calcu- lus). As in [8, 3, \n4], the calculus has no restriction operators for creating new names. It is not clear how to best handle \nrestriction in the logic. The restriction-free calculus, how- ever, has a more direct correspondence \nwith edge-labelled trees and semistructured data. Table 1 shows the syntax. Letters n, m, h range over \nnames, x, y, z over variables; ~/ ranges over names and variables. Both the set of names and that of \nvariables are infinite. A closed process has no free variables. The expressions in7 b out ~/, and open~/are \nthe capabilities. Messages and abstrac- tions are the input/output (I/O) primitives. Processes with the \nsame internal structure are identified. This is expressed by means of the structural congruence re- lation, \n~, the smallest congruence such that: P]O ~ P PIQ -= QIP P](QIR) -= (PIQ) IR. The rules for the reduction \nrelation, ---% are reported in Table 2. The reflexive and transitive closure of , is written ===~. To \naccommodate the extensions of MA of Section 6, where also capabilities can be communicated, in Table \n2 (as well as in Definitions 3.1 and 3.2 below) we write M for the content of a generic message. Behavioural \nequivalence is defined on top of reduction and of observability predicates ~,~ that indicate whether \na process can liberate an ambient named n: formally, P ~ holds if there are P', P\" such that P ~ n[ P' \n] ] P\". DEFINITION 2.1 (BARBED CONGRUENCE, [14, 12]). Barbed bisimulation is the largest symmetric relation \n,~ on closed processes such that P ~ Q implies: 1. whenever P ~ P' then there exists Q' such that Q==~Q' \nand P' \"~ Q' ; 2. /or each name n, P ~,~ i~ Q ~.  Two processes P and Q are barbed congruent, written \nP ,~ Q, if C[P] .~ C[Q] for all closing contexts C.   2.2 The logic This is the set of the formulas \nof the logic: The propositional connectives, T, ~ A, AVE, and the univer- sal quantification on names, \nV x. A, have the standard log- ical interpretation. The temporal connective, O A, and the spatial connectives, \n0, A [ B, and ~/[A], have been briefly discussed in the Introduction. A t> B and A@~/ are the logical \nadjuncts of A I B and y[A], in the sense of being, roughly, their inverse. A formula is closed if it \ndoes not contain free variables. A,B ::= T (true) -~A (negation) AVB (disjunction) 0 (void) ,[AI (location) \nA1 [A2 (composition) Vx.A (universal name quantification) OA (sometime modality) A ~i (location adjunct) \nAmB (linear implication) DEFINITION 2.2. The satisfaction relation is defined on closed processes and \nclosed formulas: P ~ T de=f always true P ~ -~ A de/ not P ~ A P~=AVB d~=f P~AorP~B clef P~0 = P--=0 \nP ~ n[A] de.~ there is P' such that P ~ n[ P' ] and P' ~ A P ~ A1 I A2 dej there are P1,P2 such that \nP .~ P1 I P2 and Pi ~ A~, i=1,2 P ~ v x. A dod /or all n, P ~ A{n/x} P ~ \u00a2 A a,j there is P' such that \nP ~ P' and P' ~ A P~A@n a~d n[P]~A P ~ A ~> B ae__f /or all R such that R ~ A, we have R] P ~ B DEFINITION \n2.3 (PROCESS LOGICAL EQUIVALENCE). For closed processes P, Q, we write P =L Q if/or all closed formulas \nA it holds that P ~ A iff Q ~ A. We shall use the dual of some modalities. The dual of the lin- ear implication \n(A B), the dual of the sometime modality (OA), and the standard dual of the universal quantification, \n(9 x. A) and of the V-connective (A A B): de/ A B -----~(At>-~B) de/ QA -----~O -~A de/ Bx.A = \"~Vx.-~A \nde/ AAB = --~(-~AV-~B) Thus P ~ A B iff there is Q with Q ~ A and P I Q ~ B, and P ~ QA iff P' ~ A for \nall P' such that P ~ p,. We give V and A the least syntactic precedence, thus A I> BAC reads (A I> B) \nAC, and A I> (O BAO C) reads A t> ((O B) A (O C)). LEMMA 2.4. If P =-- Q and P ~ A then also Q ~ A. The \nambient logic in [8] has also a somewhere connective that holds of a process that contains, at some arbitrary \n Expressions Processes M, N ::~-fig (variable) P,Q,R ::= 0 (nil) t n (name) I PIQ (paralleO I in~ (enter) \nI M.P (prelUding) I out (exiO I ,7[PI (ambient) I open (open) I (,7} (message) I (x) P (abstraction) \n Table 1: The syntax of finite MA Red-In \u00b0pen n. P ln[Q] ~ P IQ Red-0pen  n[inm. P~ I P2]Im[Q] ---~m[n[P~ \n[ P2] I Q] Red-0ut Red-Com  m[n[outm. P~ I P~] I Q] ~ n[P~ I P2]lm[Q] (M} I (x) P ~ P{MIx} p.___~p, \np--+p' Red-Pax Red-Amb P]Q--*P'IQ n[P]--~n[P'] P ~_ p' p' ~ p\" p\" __- p\"' Red-Sir  p ----~p,,, Table \n2: The rules for reduction level of nesting of ambients, an ambient whose content sat- isfies A. We have \nomitted this connective here: its addition would not change the results in the paper. (Formally, this \nholds because the somewhere connective does not allow us to separate processes that are intensionally \nbisimilar, Defi- nition 3.2.) 3. INTENSIONAL BISIMILARITY We look for a co-inductive characterisation \nof =L, as a form of labelled bisimilarity. In this section we present the bisim- ilarity and prove that \nit is a congruence. In the next section we prove that it coincides with =L. First we have to define labelled \ntransitions. We also need relations of stuttering. Again, to accommodate the extensions of MA of Section \n6, in the two definitions below we use M as label of transitions also in places where, with the present \nthe syntax for MA, M can only be a name. DEFINITION 3.1. Let P be a closed process. We write: p M p,, \nwhere M is a capability, if P ~ M. Pz ] P2 and P' = P1 I P2. !M p, P --~ ifP~_{M}[P'. that is, {M} [ \nP should be a legal closed process (thus, with the syntax of Table 1, M can only be a name). P ~ P', \nwhere # is one of the above labels, ifP ~ P' (where ~ ~ ~ is relation composition). (stuttering) P (M1,M2)*,..pc \nif there is i _> 1 and processes Pz,...,P~ with P = Pz and P' = P~ such that P, ~ ~ Pr+z for all l < \nr < i. We show the definition of bisimilarity, then we comment it. DEFINITION 3.2. Intensional bisimilarity \nis the largest symmetric relation _~ on closed processes such that P _~ Q implies: 1. If P ~_ P1 I P2 \nthen there are Q1, Q2 such that Q _= Q1 I Q2 and Pi ~ Qi, for i = l, 2. 2. If P ~ O then Q _-- O. 3. \nIf P ~ P' then there is Q' such that Q ~ Q' and p' _~ Q'.  P ~ P' if P -(x) P~ ] P~ and P' -px(M/~} \n[ P2. 4. If P ~ P' then there is Qi such that ?M p, Q ~ (0.t ,~,i, =)* ;.Q, and P' ~_ Q'. All transitions \nP ~ are supposed to be well-typed, 7 5. If P ~ P' then there is Q' such that Q ~=~ (in ~,o~t,~)* :.Q, \nand P' _~ Q'.  6. If P op,n,~ p, then there is Q' such that Q \u00b0~:~:~'~ Q' and P' _~ Qi.  !M p, Q, \n7. If P .-, then there is such that Q ~ Q' and p' ~__ Q,. 8. If P ~ P' then there is Q' such that Q \n[ { M } ~ Q' and P' _~ Q'. 9. If P _---- n[ P'] then there is Q' such that Q _-- n[ Q'] and P' _~ Q'. \n  The definition of ~_ has (at least) two intensional clauses, namely (1) and (2), which allow us to \nobserve parallel com- positions and the terminated process. These clauses corre- spond to the intensional \nconnectives '1' and '0' of the logic. The clause (8) for abstraction is similar to the input clause of \nbisimilarity in asynchronous message-passing calculi [1]. This is so because communication in MA is asynchronous. \nThe most peculiar aspect of the definition of _~ is the use of the stuttering relations. Although they \ncould be avoided on the finite processes, they cannot in full calculus, as we discuss in Section 6. To \nconvey some intuition for the need of stuttering, here is a simple example using a sum operator la CCS; \nthe processes def P = in n. out n. in n. P' clef Q = P--I-inn. P' are extensionally equal (P ~ Q), and \nthey are also equal in the logic (P =L Q). But they would not be intensionally bisimilar (P ~_ Q) without \nthe stuttering relations. To see why the extra summand of Q does not affect its behaviour, consider a \nreduction produced by this summand: m[Q I R] I n[S ] ---~n[S I m[P' I R]] Process P can match it using \nthree reductions: rn[PIR]ln[S ] ~ n[S Im[outn. inn. P'lR]] m[inn. P' l R] l n[S ] -----~ n[S]m[P' I R]] \nBy contrast, stuttering does not show up in the Safe Ambi- ents [12], where movements are achieved by \nmeans of syn- chronisations between a capability and a co-capability. It is straightforward to prove \nthat ~_ is an equivalence re- lation. However, it is not obvious that _~ should be pre- served by all \noperators of the calculus, due to the fact that ~_ is, intrinsically, higher-order. Formally, _~ is not \nhigher- order, in that the labels of actions do not contain terms. 'Higher-orderness' is however hidden \nin clause (3), for a re- duction may involve movement of terms (for instance, if the reduction uses rules \nRed-In and Red-Out). This, as usual in higher-order forms of bisimilarity, complicates the proof that \nbisimilarity is preserved by parallel composition. Our proof of congruence makes use of a second bisimilarity, \n_~', that, by construction, is preserved by all operators of the calculus. By contrast, it is not obvious \nthat _~' is pre- served under reductions and, consequently, that it is transi- tive. This proof method, \nwhich exploits an auxiliary relation that it is manifestly preserved by the operators of the cal- culus \nbut that is not manifestly preserved under reductions, brings to mind Howe's proof technique for proving \ncongru- ence of bisimilarity in higher-order languages [11]. In our case, however, the problem is simpler \nbecause of the inten- sional clauses (1) and (2) of the bisimilarity and because MA is not a fully higher-order \ncalculus: terms may move during a computation, but may not be copied as a consequence of a movement. \nWe may say that MA is a linear higher-order calculus. The differences between the definitions of _~ and \n~_~ are the following. First, the structural congruence and the labelled transition in the hypothesis \nof each clause of _~ is replaced by syntactic indentity; for instance, clause (1) becomes \"if P = P1 \n[ P2 then...\", and clause (4) becomes \"if P = in n. P' then ...\". Secondly, clause (3) is removed. This \nimmediately gives us a relation with the desired property: LEMMA 3.3. If P _~' Q then C[P l ~' C[Q], \nfor all con-texts C. To prove that ~_ and \"-\" coincide, the main result we need is that _~' is preserved \nunder reductions: LEMMA 3.4. Suppose P ~_' Q and P --, P'. Then there is Q' such that Q ~ Q' and P' ~_' \nQ'. PROOF. First we prove a special form of transitivity for _~: ifP ~. P~ ~_~ P\", then P _~' P\". This \nallows us to derive _=_C_ We then prove the lemma by induction on the depth ~. of the derivation of P \n~ P'. D THEOREM 3.5. Relations _~ and_~ coincide, and are con- gruence relations.  4. CO-INDUCTIVE \nCHARACTERISATION We show that ~_ characterises =L. THEOREM 4.1. If P _~ Q then also P =L Q. PROOF. We \nprove that P ~ A iff Q ~ A, by induction on the depth of A. For the formulas B@n and A1 ~ A2 we need \nthe congruence of ~_. D The converse of Theorem 4.1 is the hard part of the char- acterisation. The crux \nof the proof is to find characteristic formulas for the capability and I/O primitives. Precisely, we \nlook for formulas (M). A (the capability formulas), where M is a capability, and (!n), (?n). A (the I/O \nformulas) with the following meaning: * P ~ (openn). A if[ there are P', P\" such that P _= openn. P', \nP' ~ P\", and P\" ~ A  P ~ (in n). A iff there are P', P\" such that (openn).A d~d Vx. (n[~[0]] c> <> \n(x[0][A))  P ~ inn. P', P' (out,,,,,~)*, p,,, and P\" ~ A A lcomp  P ~ (out n). A iff there are P', \nP\" such that  A~3x. x[T] P ~. out n.P', P' (i, ,,,out ,q* , p,,, and P\" ~ A   (out n).A deal Vx. \n((<> (x[A]ln[O]))@n@x) e ~ <!n) iff P ~ {n} A Icomp A -~ Et x. x[T] P ~ (?n). A iff there are P', P\" \nsuch that (in n).A d\u00b0d Vx. ((n[0]t>On[x[A]])@x)P ~ (x) P', {n} I (x) P' ===~ P\", and P\" ~ A A Icomp A-~3 \nx. x[T] These formulas represent the temporal modalities that are observable in the intensional bisimilarity \nbut are missing from the logic. With these formulas at hand, the converse of Theorem 4.1 will follow \nusing standard arguments for modal The following formula is true of the I/O processes, that is, logics. \nthe messages and the abstractions. A process P is non.trivial if not P ~ 0. Thus P is non- trivial iff \nnot P ~ 0. A process P is single if it does not have two non-trivial parallel components at the outermost \nlevel; i.e., P .~ P' for some P' whose outermost operator is not a parallel composition. We will often \nuse the characteristic formula of single processes: Icomp a\u00b0d -~ (-o I -1 o) To help understanding the \ndefinitions of the capability for- mulas, we first discuss some simpler formulas, which do not talk about \nthe process underneath the prefix. We define, for names n \u00a2 h: (openn) a,=f n[h[0]]C>O(h[0][T) A lcomp \nA-~3~. x[T] (out n) d'd (0 (h[T]ln[O]))@n@h  A icomp ^-~3x. x[T] It holds that P ~ (openn) iff P ~_ \nopenn. P', for some P'. We sketch the proof. The subformula Icomp A -~ 3 x. x[T] says that P is single \nand is not an ambient. Thus, modulo _=, process P can only be 0, openm. P' into. P', out m. P', (x) \nP', or {m}. The subformula n[h[0]] ~ 0 (hi0 ] I T) says that P ] n[ hi 0 ] ] can reduce to a process \nwith an empty ambient h at the outermost level. From these requirements, we conclude that P ~ openn. \nP', for some P'. Similarly we prove that P ~ (out n) iff P ~ out n. P', for some P'. By the subformula \nIcomp A -~3 x. x[T], process P is single and is not an ambient. By the subformula (O (hiT] I n[O]))@n@h, \nn[h[P]] ~ 0 (h[T] I hi0]) hence P ~ out n. P', for some P', otherwise hiP] could not exit n. To obtain \nthe full capability formulas, namely (open n). A and (out n). A, we add some quantification on names. \nSim- ilarly we define (in n). A. lcorara clef icomp A'~0 A ('-3 x. xIT]) A'~(3x. ( (openx).T v (out \nx). T v (in ~). T) ) The difficult part, however, is the definition of the I/O for- mulas, for separating \nmessages from abstractions, but also, within the messages and the abstractions, messages with dif- ferent \ncontents and abstractions with different behaviours. The capability formulas are easier to define than \nthe I/O formulas because capabilities act on ambients, and the logic has a connective, n[ A], for talking \nabout ambients. By con- trast, the I/O primitives act on themselves. We define the I/O formulas proceeding \nas follows. First, we define a formula, TestComm, that characterises the special abstraction (x)x[0]. \nThen we use TestComm to define the formulas for messages: (!n) d~dlco~ ^ (Z~tCo~ t> 0 n[o]) Finally, \nwe then use (!n) to define the formulas for abstrac- tions: (?n). A ~.4 f lco~ A (-~ 3 x. (!x)) A ((!n) \n~ 0 A) We are therefore left with the definition of TestCon. This formula will actually be satisfied \nnot only by (x)x[ 0 ], but by the set S of all abstractions that are beta*-convertible to (x) x[ 0], \nwhere beta*-conversion is the smallest congruence given by the axiom {M} [ (x) [P] =,[P]{M/x} (beta*) \nLet: 9 def TestComm : lcomm ^ lco~ ~ o((lco~ I leon) v 3 x. ~[0]) A lco~ 0 n[O] A lcomm O m[0] where \nn and mare different names LEMMA 4.2. It holds that P ~ Tes'CComm iff P q S and is closed. PROOF. (Sketch) \nWe consider the implication from left to right (the opposite is easier). Since P ~ lco~xa, process P \nmust be an I/O. Also, P cannot be a message, otherwise it would not satisfy the formula This because \na message in parallel with (x) 0 (that satisfies 1coma) can reduce to O, which does not satisfy (lcoma \nI 1con) v 3 x. x[o]. We conclude that P should be an abstraction, say (x) Q. Now, from the formula lcon \n O n[0] and the formula lcon O m[0], we get that there are nl and n2 such that {nl} I (x) Q P 0 n[0] \n  {~} I (~) Q ~ o m[o] Finally we prove that these properties plus the formula 1con p O((lcon I 1con) \nV g ~,. x[O]) only hold if (x) Q e $. O There is an obvious correspondence between the clauses of _~ \nand the derived logical connectives for prefixes and I/O obtained above plus the primitive connectives \nA I B, 0, n[ A ]. This correspondence allows to prove the completeness of the logic. The proof also uses \nthe n-th approximants _~ of the bisimilarity _~', (defined in the standard way from the definition of \n~_') and the fact that N~ ~-~ is the same as --~'. THEOREM 4.3. If P =L Q then P -~ Q. 5. BARBED CONGRUENCE \nAND STRUC-TURAL CONGRUENCE Exploiting the co-inductive characterisation, we can now carry out the comparisons \nof =L with ~ and =--. THEOREM 5.1. Relation =L is strictly included in ~. The inclusion is proved from \n----LC ~--(Theorem 4.3) and ~_C~ (essentially a consequence of the congruence of ~-). The strictness \nof the inclusion is proved by these laws, that are valid for ~ but not for =L: 1. M. P = M [ P, where \nM is a capability, if P is of the form M.....M. 0 2. (x) P-- (x) 0 [ P, if P is of the form (x) ...(x) \n0 3. (~) (~} = 0  The third axiom is typical of behavioural equivalences of calculi where communication \nis asynchronous. The first and second axiom schemata are not valid for =L because the logic allows us \nto intensionally observe parallel compositions. Here are two concrete examples of equalities derived \nfrom these axiom schemata: inn. inn ----innl inn   (~) (y) o = (~) o I (y) 0 We do not know whether \nthe laws (1-3) are all the laws that make ----L finer than ~. It turns out that =L is almost the same \nas --=. The only dif- ference is captured by the following axiom, the MA version of the familiar eta \nlaw of the A-calculus:  (x) ((~) P I (x}) = (~) P (eta) We write ~E, and call it normalised structural \ncongruence, for the relation defined with the rules of -: plus eta. A process P is eta-normalised if \nno process P' with P' ~ P contains an eta redex (x)((x)Q [ {x}). We write messages(R) for the number \nmessages in R, and pref(R) for the number of prefixes in R. LEMMA 5.2. Suppose that P ~. Q, and that \nboth P and Q are eta-normalised. Then 1. messages(P) = messages(Q), 2. pref(P) =pref(Q).  PROOF. The \nproofs of the two assertions are similar. We use the characterisation of '~ as -~'. For instance, for \n(1) we show that messages(P) > messages(Q) would lead to contradiction, proceeding by induction on the \nshape of P. o COROLLARY 5.3. Suppose that P ~_ Q, and that both P and Q are eta-normalised. If P .L P', \nthen there is Q' such that Q -L Q' ~. pi. Similarly, iJ P ~ P', then there is Q' such that Q ---+ Q' \n_~ pi. PROOF. If Q performed more than one actions then Q would consume one more prefix or message than \nP, which, by Lemma 5.2, would lead to a contradiction. E] LEMMA 5.4. Suppose h does not appear in P. \nThen we have p{h/x} ~ Q{h/x} iff P _= Q. LEMMA 5.5. Suppose that P _~ Q, and that both P and Q are eta-normalised. \nThen P ~ Q. l0 PROOF. By induction on the shape of P, and using the chaxacterisation of ~_ as .~'. We \nshow two example cases. P = openn. P'. By definition of '~', Q ~ openn. Q' and there is Q\" such that \nQ' ~ Q\" ~.' P'. By Corol- lary 5.3, it must be Q' = Q\", therefore by induction Q' _= P'. We conclude \nthat P _= Q.  P = (x) P'. Then Q =-(x) Q', for some Q'. Since _~' is a congruence, {h} [ P _~' {h} [ \n(x) Q'. We have {h} [ P , P'{h/x}, hence by Corollary 5.3,  {h} I (x)Q' -----~ Q'{h/x} ~' p'{h/x}. By \ninduction, P'{h/x} ~ Q'{h/x}, hence by Lemma 5.4, also P' =- Q', therefore also P ~ Q. [] enough: this \nformula is satisfied by in n. open m. 0 but also, for instance, by processes such as in n. ({M} [ (x) \nopen m), which has some additional I/O, or in n. out n. in n. open m. 0, which stutters. We therefore \nset linn. openm~ to be (the actual definition of ~inn. open m~ will be syntactically dif- ferent; the \nformula below is easier to read and semantically equivalent)  (~n ~). (open~). o A -~ (in n). m lcomp \nh ~inn. out n. T ^ -~ (in ~). (open ~). -~0 The second, third and fourth A-components take care of the \nproblems with I/O and stuttering mentioned above. Here is the complete definition of the formulas ~MD: \nTHEOKEM 5.6. On closed MA processes, relations =L and ~E coincide. PROOF. Proving that ~E coincides with \n_~. One inclusion is given by Theorem 4.3, the previous lemma and the validity of the eta law for _~. \nThe converse holds too because all axioms defining --=E are valid for _~. 0 6. EXTENSIONS OF THE CALCULUS \nWe consider some important extensions of MA. We do not change, however, the logic and the definition \nof satisfaction. We consider each feature separately. We have not studied combinations of the features; \nwe believe, however, that this does not introduce new problems. 6.1 Capabilities in messages In the original \nMA calculus [5], messages can also carry paths of capabilities. To accommodate this in the gram- max \nof Table 1, all occurrences of ~ axe replaced by M, and the path productions M ::= M1.M2 [ e, are added \nto those for expressions, where e stands for the empty path. Thus a capability can be a path, such as \nopen n. in m. open h. Also, the rules (M1.M2).P ~ M1.M2. P e.P ~ P are added to those of ~. Since messages \ncan now carry names or capabilities, a type system [7] avoids run-time er- rors. The results we have \npresented in the paper continue to hold under the extension. The most important modification is the definition \nof the characteristic formulas for messages car- rying capabilities, in the proof of Theorem 4.3. For \nthis, we need a formula TestCap, the analogous of the formula TestCorm of Section 4, satisfied by all \nabstractions that axe beta*-convertible to (x)m[ x. 0 ] where m is some fixed name. We also need a formula \n~M~, for any closed capability M, that identifies those processes that axe structurally congru- ent to \nM. 0. We first discuss an example, namely the for- mula ~inn. open mD. For this, (in n). (open m).0 is \nnot lopen n. MD de f (open ). ~M~ A -~(open n). (~lcomp V 3 x. x[T]) ~outn. M~ dej (out n).~M~ A -~(out \nn}. (-~lcomp V 3 x. x[T]) ^ -~(out n). (in n). (out n). IMp ~inn. g~ de=f (in n).~g~ ^ ~(in ~). (~lcomp \nV ~ ~. ~[r]) A;-~(in n). (out n/. (in n). ~M~ ~.MD doj ~MD def  ~oD = o In the definition of ~MD, the \nformula -~tcomp V B x. z[T] is used to control process reductions, see Lemma 6.1. LEMMA 6.1. Suppose \nP ~ P'. Then P ~ -~lcomp V B z. x[T]. LEMMA 6.2. Suppose M and P are closed. Then P ~M D iff P ~ M.O. \nPROOF. Induction on the depth of M. We now define TestCap: TestCap d__~f lcomm A lcomm t> O( (lcomm [ \nlcomm) v m[ l:o~p] ) A lcomm 0 m[~innD] ^ lcomm ~ 0 m[0] where n and m axe different names. The correctness \nof this definition is proved along the lines of that of TestCon~. The formula (!M/, where M is any closed \ncapability, is then ll  6.2 Synchronous Ambients Since the modal logic does not talk about the I/O \nprimitives, it is interesting to examine variations of these primitives, to see the effect on the equality \ninduced by the logic. In MA communication is asynchronous: since a message has no continuations, no process \nis blocked until the message is consumed. The most natural variation consists in making communication \nsynchronous. For this the production (17} for messages in the grammar of MA in Table 1 is replaced by \nthe production (t?}. P. Reduction rule Red-Corn becomes: Red-Com (M}. Q I (~) P ~ O I P(MIx} The communication \nact liberates, at the same time, both the continuation P of the abstraction and the continuation Q of \nthe message. We write MA \"y\"\u00a2 for the resulting synchronous calculus.  Synchrony leads to some important \nmodifications in the as- sertions and in the proofs of the results in the paper. In MA \"y\"\u00a2, the eta \nlaw fails and, surprisingly, the equality in- duced by the logic is precisely structural congruence: \nTHEOREM 6.3. On closed MA syn\u00a2 processes, relations =L and ~ coincide. The co-inductive characterisation \nin terms of _~ (that is, Theorems 4.1 and 4.3) remains true, provided that in the definition of the bisimilarity \nthe 'asynchronous' clause (8) for abstractions is replaced by the clause: If P ~ P' then there is Q' \nsuch that Q ~ Q' and p' = Q' The proof of the characterisation, however, is harder. In asynchronous \nMA, our separation of messages from abstrac- tions exploited their asymmetry: abstractions, but not mes- \nsages, have a continuation. In the synchronous case the asymmetry disappears, therefore we have to use \na different route for the proof. Again, the most delicate point is to find a replacement for the formula \nTestComm. We only quickly sketch how the new definition is obtained. We first define a formula, OnlyCom, \nthat is satisfied only by abstractions (x) P and messages (M}. P in which capability prefixes and ambients \ndo not appear in the continuation P and, moreover, no subterm of P contains more than two non-trivial \nparallel components: 0nlyCom de=f lcomm ~ ( D((lcomm I lcomm) V 0) AO0) Using OnlyCom we define a formula, \nComArab, that is satis- fied only by processes defined as those that satisfy Onlyqom except that the \ninnermost operator is an ambient ~7[Y[ O] ]: Comb %~ 3 ~. ( onlycom ~( ~( (lco~l 1co~) v x[~[ol]) A o \n=[,~[o]]) A 0nZyCom ~ o ~[m[0]]) where n and m are different names. We then define a formula that characterises \nthe abstraction (x) h[x[0]]; we write 3comm for 1colin I lcemm [ lcomm: Imluh d el Cora~ab A OnlyCom \n~ (0-~ lcomm A Q'~ 3comm) A 0nlyCom ~ O h[n[T]] A OnlyCom I~ 0 h[m[T]] where n and m are different names. \n Roughly, the first A-component implies that a process that satisfies Immh has an abstraction or a message \nas the outer- most operator, and an ambient v/Ix[0]] as the innermost. The second A-component, say A, \nensures that the process does not have any other operators; that is, the ambient ~?[x[0]] is reached \nimmediately after the initial communi- cation. For instance, the process R d,_f (M}. (x)h[x[0]] does \nnot satisfy A because R ] (x) 0 ~ (x) h[z[0]] and (x) h[x[0]] satisfies lcomm. Finally, the third and \nfourth A-components rule out the messages and the abstraction (x) x[x[0]]. Now we can define the formula: \n= (!n). A a,~ lcomm AVx. (Imm. D 0 (~[n[0]] I A)) LEMMA 6.4. SuppoSe P is a closed MA ~ync process. \nIt holds that P ~ (!n).A iff there are Q and Q' such that P_= {n}. Q, and Q ~ Q', and Q' ~ A. And finally \nwe can define the formulas for abstractions: def (?n). A = lcoim A-~3 x. (!x).T AVx. ((!n).x[0] t> O \n(x[0] I A)) LEMMA 6.5. Suppose P is a MA \"yac process. It holds that P ~ (?n). A iff there are P' and \nP\" such that P _-- (x) P', and P'{n/x} ~ P\", and P\" ~ A. 6.3 Recursion The final extension we consider \nis the addition of recursive definitions rec X. P to the process grammar. To avoid infi- nite nesting \nof ambients, in rec X. P the recursion variable 12 X is unboxed, i.e., it may not occur free inside an \nambient. To facilitate the analysis, we also require X to be guarded, i.e. X may occur free only underneath \na prefix or an abstrac- tion; we leave for future work whether this restriction can be lifted. (Using \nunguarded recursion, the full replication op- erator, bang(P), is definable thus: bang(P) d=~f rec X. \n(X I P).) In the operational semantics, the fold/unfold rule rec X. P -~ p{rec X. P/X} is added to those \nof structural congruence. We write MA r\"c for this extension of MA. The co-inductive characterisation, \nTheorems 4.1 and 4.3, remains true, under the condition that processes are image- finite. (An MA process \nis image-finite if it has only a finite number of different derivatives under each transition relation \n=~ and under the stuttering relations P ci ..... t .~* :.p~ and p (o,t n,ian)*,..p~. Image-finiteness \nis a standard condition for charazterisations of operational equivalences on infinite processes using \nfinitary logics.) 7. REFERENCES [1] It. Amadio, I. Castellani, and D. Sangiorgi. On bisimulations for \nthe asynchronous v-calculus. Theoretical Computer Science, 195:291-324, 1998. [2] G. Berry and G. Boudol. \nThe chemical abstract machine. Theoretical Computer Science, 96:217-248, 1992. [3] L. Cardelli. Semistructured \ncomputations. Proc. 7th Intl. workshop on Data Base Programming Languages (DBPL'99), invited talk (accompanying \npaper available from the author's web page), 1999. [4] L. Cardelli and G. Ghelli. A query language for \nsemistructured data based on the ambient logic. submitted, April 2000. [5] L. Cardelli and A.D. Gordon. \nMobile ambients. In Nivat. M., editor, Proc. FoSSaCS '98, volume 1378 of Lecture Notes in Computer Science, \npages 140-155. Springer Verlag, 1998. [6] L. Cardelli and A.D. Gordon. Technical annex to [5]. Unpublished \nnotes, 1998. THEOREM 6.6. On image-finite MA tee processes, relations ~_ and =L coincide. We have pointed \nout that the stuttering relations can be omitted from the definition of the bisimilarity ~_ in the fi- \nnite calculus of Table 1. We show why stuttering is needed in the calculus with recursion. These processes \nare behav- iourally equivalent, and are also equal in the logic, but are distinguished by ~_ without \nstuttering: p def = inn. ree X. ({M} I (x) (out n. inn. X)) Q d,=f inn. recX.(ou~n, inn.({M}l(x) X)) \nThe recursions in the processes implement a loop with an alternation between two I/O and the path out \nn. in n. There is a 1-cycle shift, however, between the two loops. Stuttering makes the shift irrelevant. \nAs a consequence of Theorem 6.6, we have: THEOREM 6.7. On image-finite MArec processes, =L is strictly \nincluded in ~. Having recursion, however, the intensionality of logic is stronger. Here are two examples \nof behavioural equalities that are not valid in the logic. We write bang(M) for the process rec X. M. \nX, and bang((z) P) for rec X. (x) (X [ P). bang(M1) I M2. M1 = bang(M1) I M2 hi(x) P] I bang((x) P) = \nn[o] I b~g((~) P) A challenging problem for future work is to find a proof system for =L in the calculus \nwith recursion, extending our axiomatisation of the finite calculus. [71 L. Cardelli and A.D. Gordon. \nTypes for mobile ambients. In Proc. 26th POPL, pages 79-92. ACM Press, 1999. [8] L. Cardelli and A.D. \nGordon. Anytime, anywhere: Modal logics for mobile ambients. In Proc. 27th POPL. ACM Press, 2000. [9] \nIt. De Nicola and It. Hennessy. Testing equivalences for processes. Theoretical Computer Science, 34:83-133, \n1984. [10] M. Hennessy and It. Milner. Algebraic laws for nondeterminism and concurrency. Journal off \nthe ACM, 32:137-161, 1985. [11] D. J. Howe. Proving congruence of bisimulation in functional programming \nlanguages. Information and Computation, 124(2):103-112, 1996. [12] F. Levi and D. Sangiorgi. Controlling \ninterference in ambients. To appear as a Technical Iteport. Short version appeared in Proc. $Tth POPL, \nACM Press, 2000. [13] It. Milner. The polyadic 7r-calculus: a tutorial. Technical Iteport ECS-LFCS-91-180, \nLFCS, Dept. of Comp. Sci., Edinburgh Univ., October 1991. Also in Logic and Algebra of Specification, \ned. F.L. Bauer, W. Brauer and H. Schwichtenberg, Springer Verlag, 1993. [14] It. Milner and D. Sangiorgi. \nBarbed bisimulation. In W. Kuich, editor, Proc. 19th ICALP, volume 623 of Lecture Notes in Computer \nScience, pages 685-695. Springer Verlag, 1992.  13   \n\t\t\t", "proc_id": "360204", "abstract": "The <i>ambient logic</i> has been proposed for expressing properties of process mobility in the calculus of Mobile Ambients (MA), and as a basis for query languages on semistructured data. To understand the extensionality and the intensionality of the logic, the equivalence on MA processes induced by the logic (=<inf><sc>L</sc></inf>) iscompared with the standard MA behavioural equivalence and with structural congruence (an intensional equivalence, used as an auxiliary relation in thedefinition of satisfaction of the logic). The main contributions include a co-inductive characterisation of <=<inf><sc>L</sc></inf> as a form of labelled bisimilarity, and axiomatisations of <=<inf><sc>L</sc></inf> on the synchronous and asynchronous (finite) calculus. The study shows that, surprisingly, the logic allows us to observe the internal structure of the processes at a very finegrained detail, much in the same way as structural congruence does. A spin-off of the study is a better understanding of behavioural equivalence in Ambient-like calculi. For instance, behavioural equivalence is shown to be insensitive to <i>stuttering</i> phenomena originated by processes that may repeatedly enter and exit an ambient.", "authors": [{"name": "Davide Sangiorgi", "author_profile_id": "81100628842", "affiliation": "", "person_id": "PP39078344", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/360204.375707", "year": "2001", "article_id": "375707", "conference": "POPL", "title": "Extensionality and intensionality of the ambient logics", "url": "http://dl.acm.org/citation.cfm?id=375707"}