{"article_publication_date": "01-01-2001", "fulltext": "\n Subtyping Arithmetical Types Joseph (Yossi) Gil *t Systems and Software Development Laboratory Department \nof Computer Science Technion--Israel Institute of Technology Haifa 32000, Israel Abstract We consider \nthe type system formed by a finite set of primitive types such as integer, character, real, etc., and \nthree type construc- tion operators: (i) Cartesian product, (ii) disjoint sum, and (iii) re- cursive \ntype definitions. Type equivalence is defined to obey the arithmetical rules: commutativity and associativity \nof product and sum and distributivity of product over sum. We offer a compact representation of the types \nin this system as multivariate algebraic functions. This type system admits two natural notions of subtyp- \ning: \"multiplicative\", which roughly corresponds to the notion of object-oriented subtyping, and \"additive\", \nwhich seems to be more appropriate in our context. Both kinds of subtyping can be effi- ciently computed \nif no recursive definitions are allowed. Our main result is that additive subtyping is undecidable in \nthe general case. Perhaps surprisingly, this undecidability result is by reduction from Hilbert's Tenth \nProblem (HIO): the solution of Diophantine equa- tions. Introduction Central to the object-oriented \n(OO) paradigm is the notion of subtyping. Central to many modem programming languages is the notion of \nrecursive data types. The combination of these two no- tions is a fascinating and difficult topic. Indeed, \nthe question of subtyping recursive types was open for many years until settled by the seminal work of \nAmadio and Cardelli [1] which gave the first algorithm for subtyping recursive types. Consequently, the \nrun time of this algorithm was improved from exponential to polynomial by Kozen, Palsberg and Sehwartzbach \n[26]. Subtyping of recursive types was used in type inference systems such as [40] and [14]. A theoretical \nfoundation was laid out by Brandt and Henglein [9] who presented a sound and complete axiomatization \nof the coinductive inference that these algorithms use. In this paper, we revisit this question, asking \nhow could it be married with the notion of structural equivalence, as opposed to *Work done in part while \nthe author was at the IBM T. J. Watson Research Center. t yogi@CS. Technion. CS. Ib  Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for profit or commercial advan- tage and that copies \nbear this notice and the full citation on the first page. To copy otherwise, to republish, to post on \nservers or tO redistribute to lists, requires prior specific permission and/or a fee. POPL'O1 1/01 London, \nUK &#38;#169; 2001 ACM ISBN 1o58113-336-7/Ol10001 ...$5.00 name equivalence, which is crucial to distributed \ncomputation, and more generally, structural subtyping. We use structural equivalence in its deepest sense, \nwhich includes application of commutative, associative and distributive rules on types. Thus, the problem \nthat this paper deals with can be labeled as distributive and commutative structural subtyping of recursive \ntypes. The research presented here is of a theoretical, foundational sort, aimed at a better understanding \nof the notion of subtyping and the possible variations of this concept. Nevertheless, the interest in \nthis problem is not merely a matter of academic curiosity. In fact, the problem was raised and brought \nto our attention in the course of implementing an IBM experimental product, nicknamed \"Mock- ingbird\" \n[5, 4]. Mockingbird is a prototype tool for developing inter-language and distributed applications. It \nfacilitates data exchange and com- munication between applications which may be written in different \nprogramming languages. The Mockingbird type compiler reads two type definitions, which may be user annotated, \nand tries to generate a stub to convert instances of one type into instances of the other. Thus, given \ntwo types, T1 and T2, the type compiler is concerned with the following classical questions: \"are T1 \nand T2 equivalent?\", \"is T1 a subtype of T2\" (if the answer to the previous question is negative), and \n\"how should a conversion between T1 and T2 be carried out?\" (if the answer to any one of the previous \nquestions is positive). These three questions are parameterized by the type system from which T1 and \nT2 are drawn and by the definition of equiv- alence and subtyping. Intuitively, saying that T1 is a subtype \nof T2 means that values of T~ can be used wherever values of T2 can be used. This leads to several distinct \nmeanings to the \"subtype\" term. Set inclusion If we consider types T1 and T2 as the set of all their \nvalues, saying that T1 is a subtype of T2 could mean that ev- ery value of T1 is also a value of T2. \nThis is the notion of subtyping in languages such as Ada [22]. Value coercion Yet another notion of subtyping \nis that every value of T/ can be coerced into a value ofT2. This is the typical case in OO databases \nin which a relation is considered a sub- type of another relation which has fewer columns. This is also \nthe definition of subtyping in many OO languages. The type Manager may have more attributes than its \nsupertype Em- ployee. By removing or ignoring these extra attributes, every \"manager\" can be considered \nto be an \"employee\". Interface extension In many OO languages the subtype notion is further extended \nto demand that the set of routines (functions and procedures) defined in a subtype, i.e., the interface \nof the subtype, is a superset of the interface of the supertype. In this paper we concentrate mostly \non the first two notions of subtyping. In the context of data interchange between applica- tions, it \nis more important to capture the structure of the informa- tion, rather than the behavior associated \nwith it internally in each application. Indeed, languages designed for that purpose, such as ASN. 1 [44], \nEDIFACT and Sun's XDR language for remote proce- dure call, do not associate behavior with data types, \njust like many non-tO languages. To use the C++ [41] terminology, data types in our system do not have \n\"function members\". It should be clear that this restriction does not invalidate the notion of subtyping. \nIndeed, ASN.1 has a notion of subtyping, albeit not as general as it could be. Yet another motivation \nfor structural equivalence comes from the use of types as search keys in software libraries [35]. The \ntype system used in that work is geared toward functional programming. As a result, ThlxT, the type system \nused there, includes the func- tion type operator, which renders it very different from ours. An important \nclass of examples motivating our type sys- tems comes from object oriented compiler compilers, such as \nStOP [17], YOOC and TROOPER [6, 7], which generate an tO type definition from a given BNF grammar, and \na parser that con- verts a word in the language defined by the BNF into an instantia- tion of this type \ndefinition. The correspondence between a BNF and a data type definition is based on the following principles. \nGram-mar terminals such as keywords, which can only occur in one form in the input, are ignored, while \nterminals such as numerical con- stants and identifiers are represented as primitive data types. Non- \nterminals correspond to composite data types, where concatenation in the body of a BNF production is \ninterpreted as a record deft- nition, while alternative productions are realized by a choice type operator. \nAgain, these data description languages lack behavior. We argue that a deeper understanding of the structural, \nnon-behavioral, subtyping is important also for the seemingly more general notion subtyping as used in \ncontemporary tO languages, which includes both the structural and the behavioral aspects of subtyping. \nFirst, an intractability result of structural subtyping, of the sort we provide here, also implies the \nintractability of any no- tion of subtyping which includes this kind of structural subtyping. Conversely, \nalgorithms for a particular kind of structural subtyping can be used as subroutines in algorithms for \nmore general subtyp- ing problems. Secondly, in this paper we develop a unique mathematical the- ory \nthat gives a representation in the form of generating functions and power series to a rather general \nfamily of types. The attempt to represent types as power series leads to a discovery of at least one \nfamily of degenerate types that might indicate programming errors, and can be detected automatically. \nWe call attention to the fact that interface extension in one of its forms is reduced again to structural \nsubtyping. Specifically, it is often the case that the correspondence between the routines in the supertype \nand those in the subtype is not required to be exact, and that every routine in the supertype must have \na compatible routine in the subtype. Compatibility traditionally means that the type of a routine in \nthe subtype is a subtype of the type of the correspond- ing routine in the supertype. Since the subtyping \nof routines is in its turn defined in terms of subtyping relations between the type of their arguments \n(and the return type in case of functions), difficult issues of recursive subtyping are raised. This \nsort of mutual recur- sion was the main challenge that Amadio and Cardelli met in their subtyping algorithm, \nand will not concern us as much here. (As we will see, even without the subtyping of routines, the subtyping \nproblem remains interesting, and as we show, becomes even more difficult, by the introduction of what \nmay be called arithmetical rules.) We may think of a different slant on interface extension, which might \nbe called the structural interface extension problem, in which it is required to match the signatures \nof routines in the subtype with the signatures of routines in the supertype, while al- lowing arbitrary \nrenaming of routines, their arguments as well as reordering of arguments. The thrust of this paper is \nthe definition of two type systems and type equivalence and subtyping relationships in these systems, \nand a study of the arithmetical rules in these systems. The type system 79 is formed by a finite set \nof primitive types such as integer, char- acter, real, etc., and two type construction operators: Record \nand Choice. Types in 79 will be encoded as multivariate polynomials. Hence, 79 is also called the set \nof polynomial types. The type system .,4 is the same as 79 except that it includes an operator for recursive \ntype definitions. Types in .,4 are especially suited for modeling data type definitions (DTD) in SGML \n[18], and its rapidly growing offspring XML [19], ASN.1 recursive types, as well as tO compiler compilers. \nTypes in ,,4 will be encoded as formal power series, which can also be thought of as multivariate algebraic \nfunctions. We consider two natural definitions of subtyping in these sys- tems: Multiplicative subtyping, \nwhich roughly corresponds to value coercion kind of subtyping, can be solved using polynomial divi- sion \nin 79 and using polynomial elimination and GCD in ,,4. The second variant, called additive subtyping, \ncorresponds to set inclusion. Although it is efficiently computable in 7 9 , it turns out to be undecidable \nin ,A. In fact, it is undecidable even in a type system T\u00a2, nicknamed the rational types, where 7 9 C \n7\u00a2 C ,,4. Perhaps surprisingly, this undecidability result is by reduction from Hilbert's Tenth Problem \n(H10): the solution of Diophantine equations. This work deals with the decision problem. The third question \nasked by the Mockingbird type compiler, namely the construction and the study of a type converter, is \nleft for future research, al- though we do provide a sketch here of how this might be done in an orderly \nfashion. Section 2 informally describes our type systems. The descrip- tion is continued in Section 3 \nwhich describes how values in this type system are structured, and provides intuition behind our def- \ninitions of type equivalence and subtyping. Section 4 presents the type system 79, and discusses the \nnotions of type equivalence and the two main notions of subtyping in it. Algebraic types and their representation \nas formal power series are discussed in Section 5. Formal definitions of ,,4 and 7\u00a2 are the subject of \nSection 6. Sec- tions 7 and 8 give the proof that subtyping in T\u00a2 is undecidable. Section 7 is the more \ntechnical one, and may be skipped in first reading. In contrast, the specimens of arithmetical types \npresented in Section 8 may be of independent interest. Section 9 concludes with some open problems. \n 2 Overview of the type system This section provides an informal overview of our type systems, concentrating \nin polynomial types, and in explaining the arithmeti- cal roles. Compare for example the Pascal [43] \ntype definition of Figure 1 with that of C [25] in Figure 2. To a human, it is obvious that both definitions \ndenote a binary tree with an integer data field in each node. To reach the same conclusion, the Mockingbird \ntype com- piler must ignore syntactical differences between languages (stan- dard practice in the study \nof type systems), the names of fields (as usual in structural equivalence), the order of definitions \nin a record, and assume that the corresponding primitive types in the two lan- guages are interchangeable \n(the working hypothesis of ASN.1 and other data interchange languages). It is tacitly assumed that there \nis no subtyping relationship between two distinct primitive types. TYPE T1 = ^Y; Y = Record left, \nright: TI; value: Xnteger end Figure 1: A binary tree node in Pascal. typedef struot X { int data; \n mtruct X *rchild; struot X *ichild; } *T2; Figure 2: A binary tree node in C. To facilitate comparison \nof types between different languages, we assume that the type system has a set of primitive types, and \nthat no two distinct primitive types are interchangeable. In comparing types we view all occurrences \nof a primitive type as being equiv- alent. When this is not the desired behavior, new primitive types \ncan be introduced, in a manner similar to branding in Modula-3. Mockingbird effectively implements branding \nby means of user an- notations, which may mark some of C's typedef's as being new primitive types. To \nmodel C's stz~ct, Pascal's Rec~ord, and other similar constructs, the type system will have a product \ntype construction operator. (We defer the introduction of notation for the type con- struction operators \nuntil Section 4.) As the example in figures 1 and 2 shows, there is a good reason to make product a commutative \noperation. This demand does not show in [1]. Associativity of product is also required to facilitate \ndeep comparisons. Our type system admits also the sum type construction op- erator, also known as choice, \nfor representing e.g., union in C, variant records in Pascal, or ML [34] constructors. Consider for example \nFigure 3, which represents the requirement of the BIBTEX [33, 28] bibliographic system that a book has \neither an au- thor or an editor, but never both. We tacitly assume that there is some kind of a mechanism \nof designating which option is selected in a choice. Since a pointer or reference to a data type X is \neither nil or it has a value of type X, we represent such a pointer as a choice between X and Unit, the \nempty product. It is always possible to determine for a pointer which of the options of it was selected. \nJust like in ASN.1, SGML, SOOP, etc., but also pure Lisp, we cannot represent data structures in which \nmore than one pointer may point to the same data item. Note that with the commutative and associative \nrules the prod- stz~ot { union { Stz~1ot Editor editor; struot Author author; } c; 8trllot Volume_Data \ndata; } Book;  union { stz%lot { mtz~tQt Author author; mtz~aot Volume_Data data; } with_author; \n at~ct { stzal~t Editor editor; mtzlaat Volume_Data data; } with_editor; } Book_Alternative; Figure \n4: An alternative definition of Figure 3. uct operator is nothing more than a multi-set of the types \non which it operates. An enumerated type is a choice between several of Units. Since field names are \ninsignificant, the names of enumerated values are insignificant as well: Two enumerated types of the \nsame length are considered equivalent. Branding can be used if this is not the desired effect. For the \nsake of completeness, we also introduce the type None, which can be thought of as an empty choice. This \ntype, sometimes called bottom type and denoted as ..L, has no legal values at all. It serves as the neutral \nelement of sum. Also, including None in any product will render the result None as well. Java [2], Eiffel \n[31] and many other OO languages do not in- elude a general purpose choice; choice there is restricted \nto point- ers and to enumerated types. It is further research to extend the undecidability result to \nsuch systems (see also Section 9 below). We assume that sum is commutative and associative. Thus, a choice \nbetween A and B is the same as a choice between B and A. Also, a choice between two given enumerated \ntypes is the same as an enumerated type whose number of values is the same as the sum of values in the \ngiven types. The distributive rule of product with sum also applies. Thus, the differences between the \ntypes defined in Figure 3 and in Fig- ure 4 are considered a matter of personal preferences that should \nbe overlooked in type comparisons. Let us use the term arithmetical rules as a collective term for as- \nsociativity and commutativity of sum and product and distributivity of product with sum. Arithmetical \nrules also include the existence of unit and None as neutral elements for product and sum, al- ternatively \ndefined as the corresponding compound types with zero arguments. It is also convenient to use the special \nbehavior of None in product. Types formed by the primitive types by means of sum and prod- uct, and where \nthe arithmetical rules apply are called the polyno-mial types. The algebraic types are the same as the \npolynomial types except that recursive definitions are allowed. A generic name for both type systems \nis arithmetical types. We should note that Mockingbird aspirations transcend arith- metical types. Beyond \nthese, [3] discusses function types, ports (which are a mechanisms to express call-by-reference) and \ndynamic types, (which are used to express OO polymorphism). It should also be mentioned that the polynomial \ntypes are a subset of what may be called Tarski's types, which extend the algebraic type-system with \nthe function type operator, obeying rules similar to that of exponen- tiation (see [16, Chap. 1.8.3]). \n 3 Values of Arithmetical Types Figure 3: An example of using sum (choice) type operator in C. Since \nthe arithmetical types are composed of primitive types, any instance (or value) of a compound arithmetical \ntype comprises value assignments to its primitive types components. In case com- position was by a product \ntype operator, the instance is simply a tuple of assignments to the operands. Exactly one choice must \nbe taken in each sum operator. Therefore, the value assignments to any primitive types can be represented \nsimply as a multi-set. A multi-set of this sort could include for example two integer values, three floating \nvalues and a value of an enumerated type which was designated as a primitive type by branding. We call \nthis multi-set, when the values are omitted and just the types remain, a configu-ration. A configuration \nis nothing but a product of primitive types, which, as we shall see below, will be encoded as a monomial. \nIt is important to stress at this stage that the level of abstraction imposed by the arithmetical rules \ndictates this unordered multi-set perspective. Consider for example a type U1 which is a product of two \nintegers. Then, a value of Ui is an unordered set of two integer values. The match between these two \nvalues and the fields of U1 is not part of our type system. As mentioned above, branding is an easy means \nto distinguish between occurrences of a primitive types. The type U1 however, is the data type of a multi-set \nof two integers. If the definition of an arithmetical type uses a choice, then the same configuration \ncan be obtained in several ways. A value there- fore must contain not only the values of a certain configuration, \nbut also a designation of a configuration among others. In presence of the arithmetical rules, and most \nspecifically, commutativity, the matter of designating one configuration among others takes some pondering. \nTo highlight the issue of commutativity of summation, consider a type U2 defined as a choice between \ntwo integers. Type U2 gives rise to two identical configurations, each with a single integer. A value \nof U2 is therefore an integer, marked with a tag drawn from the set (say) {1, 2}. This tagging is not \nused for matching this in- teger against a specific field in U2, since roughly speaking U2 has only one \nfield, which may take two different \"kinds\" of integers. Tagging is used however to make a distinction \nbetween values; in- tegers 531 and 532 are two distinct values of the single \"field\" of U2. In the same \nfashion, a value of the binary tree data type in Fig- ure 1 could be a multi-set of three integer values, \nwith marked with a tag drawn from a set of five elements which correspond to the five different binary \ntrees with three nodes. Still, the mapping between these three integers and the four nodes in a tree \nis not part of our type system. As can be seen from the binaly tree example, the number of different \nconfigurations can in general be infinite when reeursive type definitions are allowed. We will consider \ntwo types as being equivalent if they generate the same number of configurations of each kind. This definition \nis al- most a direct consequence of the structural equivalence demands that we have made. Similarly, \nwe consider a type T a subtype of another type T', if the (potentially infinite) multiset of configura- \ntions that T generates is contained in the multiset of configurations that T' generates. Let us describe \nnow an abstract device, a canonical configu- ration generator or CCG, which given an arithmetical type, \nwill produce all configurations of this type, together with their count. A CCG receives as input an abstract \nsyntax tree of a type definition prior to the application of the arithmetical rules, or a representation \nas a polynomial. This abstract syntax tree is ordered, which makes itpossible for the CCG to produce \nall occurrences of each possible configuration of a type by applying a breadth-first left-to-right scan \nof this tree. Thus, the CCG generates a stream of configurations, and the configuration matching can \nbe done by mapping the first occurrence of a certain configuration in T against the first occur- rence \nof the same configuration in T'. Furthermore, CCG is readily generalized to deal with a regu-lar infinite \nabstract tree, i.e., the abstract syntax tree of a recursive arithmetical type. It is plausible that \nthe canonical configuration or- dering produced by a CCG correlates with human intuition, since the working \nof a CCG can be thought of as retrace the process by which a human understands complicated type definitions. \nThe CCG imposes a deterministic matching between the con- figurations of one type and the configurations \nof another type. Thus, when one does a there is a unique, deterministic matching between the configurations \nof one type and the There are still a number of open questions regarding CCGs. For example, it is use- \nful to have an algorithm which would extract the i th occurrence of a certain configuration from a regular \ninfinite abstract syntax tree in an efficient manner, i.e., without applying the full scan. At this point, \na weary programmer might complain that is would not be intuitive to program in a system that provides \nall these arithmetical conversions. The answer is that as is, the type system is not usually used internally \nin a program, but rather for the pur- pose of producing an automatic conversion between foreign data \nrepresentations relying on user annotations. It should also be com- mented here that the FiSh programming \nlanguage [23] designed for combining high efficiency with high level abstraction makes a similar distinction \nbetween \"shape\" and \"content\". A requirement that came from Mockingbird users was to main- taln some \nkind of \"structured mapping\" between configurations of one type with configurations of another type. \nThe problem of satis- factorily defining what such a mapping may mean, while still main- taining the \narithmetical rules, appears to be illusive and difficult, and is left for further research. A natural \nquestion which arises here is what happens if we forgo the distinction between configurations of the \nsame structure. In other words, a value of a certain type will cease to carry the configuration tag. \nSuch a structure would add an idempotent sum- mation rule to our arithmetical rules. As it turns out, \nthe problems of subtyping and of type equivalence can be done in polynomial time [27, Chap. 9]. Similarly, \none may also wonder about type equivalence and subtype in a type system that does not admit com- mutativity \nof product. In this case, although type equivalence is still computable, subtyping is undecidable even \nif there are only two primitive types [38].  4 Polynomial Types 4.1 Notations and Conventions We will \nrefer to non-negative integers as natural numbers. Let N be the commutative semi-ring t of natural numbers. \nThe commu- tative semi-ring B of Boolean values, where 0=False, l=Truo, and OR as addition and AND as \nmultiplication will also be of interest. As before, types will usually be denoted using upper case let- \nters. An extensive use of formal variables will be made. These will usually be denoted by lower case \nletters. Sets of variables are de- noted by boldface letters: x, y, etc. Let x = {xl,..., xk} be a set \nof variables. Then, Ix] denotes the set of monomials of x, i.e., all expressions of the form k ' i=1 \nwhere ni E N. Note that monomials may not have coefficients. Still, 1 ~ o = H,=~ ~, ~ [~]- IA commutative \nsemi-ring is a set with constants 0 and I, addition and multiplica- tion operations which obey the usual \ncommutative, associative and distributive rules. A seml-ring does not necessarily have subtraction or \ndivision. For encoding a type system in which the commutative rule TYPE of multiplication does not apply, \nit is convenient to use pseudo-monomials which are nothing but the set of all finite strings of for- \nmal variables. The set of all pseudo-monomials over x is denoted by x*. Multiplication in x* is simply \nstring concatenation, which is non-commutative. Let A[x] denote the set of all formal polynomials over \nx with coefficients in A, i.e., finite linear combinations of the elements of Ix] with coefficients in \nA. For a polynomial p E A[x] and a monomial rn E [x], let [m]p E A denote the coefficient of m in p. \nAlso, let A[[x]] denote the set of formal pseudo-polynomials over x, which is finite linear combinations \nof x*. In carrying out computations in A[[x]] we allow members of A to commute with members of x*.  \n4.2 Polynomial Encoding Let Z = {zl,... ,z~} be a set of elements, which will be thought of as our primitive \ntypes. A type system which includes product and choice over Z and the special types unit and None is \ndefined by the following BNF: ~- ::= Unit ] None (2) ~- ::= choice(% 7-) I product(~-, ~-) Type equality \nis defined as the minimal symmetrical and tran- sitive relation obeying the following axioms None ~ None; \n~nit ~ Unit VzEZ*z~z choice(None, T) ~ ~'; product(Unit, 1\") ,~ 7\" product(None, r) ,~ None choice(v1, \nT2 ) ~ choice(r2, ~'1) product (rl, 72) ~ product (~-2, ~-1) choice(r1, choice(r2, rs ) ) ,~ choice( \nchoice( rl , rz), ~'1) product(7\"l, product(~'2, vs) ) ~ product(product(r1,7-z), ~'1) product ( ~\" l \n, choice ( ~-2 , ~'s ) ~ choice (product ( ~\" l , ~'2), product ( ~'l , ~'~ ) ). (3) Note some of the \nimplications of (3): a record which has None as one of its fields has no legal values. Similarly, a choice \nbetween None and any type ~- type is ~- since the None option can never be taken. We will encode the \npolynomial types as formal multivariate polynomials with coefficients in N. Each primitive type in Z \nis encoded as a distinct formal variable. The choice type construction operator is encoded as polynomial \naddition, while product is en- coded as polynomial multiplication. Unit is encoded as 1. Thus, a pointer \nto X is encoded as 1 + X, a pointer to a pointer to X is 2 + X, etc. As might be expected, None is encoded \nas the poly- nomial O. Let z be a set of formal variables that are used for encoding Z. Then, the set \nof polynomial types is the set ~, = 1~], (4) i.e., the set of all polynomials with natural coefficients \nover the set of formal variables z. The subscript z is omitted when it is clear from context. It is mundane \nto see that ~, has the same structure as the BNF (2), and that polynomial equality in it is isomorphic \nto the definition in (3). We have that the set of all possible configurations is [z]. Employee= Record \n id:Integer; name:String; isManager:Boolean; desc:Array [1..3] of Character; Case Integer of 0: yearly_salary:Real; \nI: hourly_salary:Integer; end end Figure 5: An employee record in Pascal. Example 4.1. Consider the \nPascal 2 employee record defined in Figure 5. This type can be encoded as the polynomial ZSBC3(R + I) \n(5) where I, S, B, C, and R are formal variables encoding the prim- itive types Integer, String, Boolean, \nCharacter, and Real (respectively). As the example indicates, arrays of fixed size are considered syntactic \nsugar for product. This is justified since field names are ignored. Henceforth, we will loosely refer \nto members of P both as poly- nomials and as types. 4.3 Type Equivalence in 79 We say that a polynomial \nis in an expanded form if it is written as sum of distinct monomials with coefficients. For algorithmic \npurposes, it is convenient to assume that the terms in the expanded form are sorted. Such a sort can \nbe by any monomial ordering. The expanded form is canonical in the sense that the coeff\u00c9cient of each \nmonomial is exactly the number of configurations of the sort of that monomial that the polynomial type \ngenerates. Since type equality of the system (2), (3) is tantamount to poly- nomial equality, it has \na straightforward implementation, provided the polynomials are given in an expanded form. However, as \nin Example 4.1, a type definition in a programming language does not directly yield this form. Expansion \nby applying the distributive rule and grouping monomials together may result in an exponential blowup \nof the size of the polynomial. The technique of Zero equiv-alence testing [45, Chap. 12] can be used \nto bring down the com- plexity of type equivalence in T > to randomized polynomial time in the size of \nthe non-expanded input. All other algorithms presented here assume an expanded form of the input, and \nhence are potentially exponential in the input size.  4.4 Additive Subtyping in 7 9 How should subtyping \nof arithmetical types be defined? When we say that type T is a subtype of T' we mean that every value \nof T can be viewed also as a value of T'. When T and T' are thought of as sets of instances, then a simple \nway of interpreting this de- mand is that T C T'. Recall that each value of T contains not only an assignment \nof primitive values to a specific configuration, but also some sort of designation of the way that configuration \nwas obtained in T. If this designation is specific to T, then it is unlikely 2we assume here a more modem \nversion of Pascal which has a primitive String type. that this value will also occur in T'. This is \nthe reason why we Definition 4.3. For types T, T' E 79, we say that T is a multiplica- have used a canonical \nenumeration of configurations for this desig- tire subtype ofT' and write T ~* T' if there exists a type \nT\" E 79 nation. Canonical enumeration naturally gives rise to the following such that T = TIT ''. definition \nof subtyping of polynomial types. Clearly, the ~* relation is a weak partial order. In fact, it is not \nDefinition 4.2. For types T, T' E 79, we say that T is a subtype so difficult to see that it is equivalent \nto the relation <* defined in ofT' and write T E T' if [m]T <_ [m]T' for all m E [z]. the system (2) \nand (3) by the following subtyping rules: Since Definition 4.2 means that for all types A and B, A __ \nA + B and no other subtyping occurs, we call the __ relation ad- ditive subtyping. The definition is \nalso (trivially) equivalent to the following three subtyping rules for < in the system defined by (2) \nand (3) n <_ choice(n, v2) (6) Additive subtyping means that in going from a subtype to the supertype, \nmore configurations can be added. In this process, the structure of any of the configurations of the \nsubtype is not allowed to change. Thus, a record with 10 integer fields is a subtype of an array of 10 \nintegers (these two types are in fact equivalent), which in turn is a subtype of a choice between an \narray of 10 integers and an array of 10 reals, which is a subtype of an array of 10 integers or reals. \nAlso, two enumerated types in which all emmaerated val- ues are branded, stand in a subtype relationship \nif and only if their sets of values stand in a containment relationship. With pointers we have that X \nis a subtype of a pointer to X, which in turn is a subtype of a pointer to a pointer to X, etc. When \nextended to recursive types, Definition 4.2 will mean that a list of integers is a subtype of a binary \ntree of integers. In general, additive subtyping captures very general and elaborate conversions, for \nexample, the embedding of a binary tree in a forest of general trees. According to Definition 4.2 each \noccurrence of a certain con- figuration of T can be matched against an occurrence of the same configuration \nof TI, although as a result of the commutativity of addition, it is not specified how this matching is \nmade. In the fi- nite case, i.e., when the type system is limited to polynomial types the problems of \nexistence of a configuration matching andfinding a specific one are easy. Applying Definition 4.2 algorithmically, \nwe can test for additive subtyping in linear time in the length of the expanded form of the input polynomials. \n(We are unaware of a more efficient procedure for this problem.) Definition 4.2 can also be used for \nenumerating all possible matchings between T and T ~. It will be interesting to compare the problems \nagain in the infinite case, i.e., when recursive types are allowed. Note that if is it proved that the \nsubtyping decision problem is undecidable, then it is clear that there is no algorithm which finds a \nconfiguration matching. Conversely, if T .~ T' was established, then it is possible to match the configurations \nin T with configura- tions in T' type in an orderly, deterministic fashion. 4.5 Multiplicative Subtyping \nin 7 9 Additive subtyping is a weak partial order on 7 9, which means that it is reflexive, transitive \nand anti-symmetric (excepting equal- ity). Let us now define another weak partial order subtyping rela- \ntionship on 79 which has these properties. In OO systems subtyping means that a type AB is a subtype \nof A for all types A and B. Let us write this as AB ~* A. The E* relation is formalized in the following \ndefinition. product(~'z, v2) <* vz (7)7\"1 ~ T2 7\"1 <* ~'2 r2 <* 7\"a T1 ~* T2 T1 .~* T3 Determining \nwhether two polynomial types stand in a multi- plicative subtyping relationship is simply a matter of \npolynomial division--a problem for which efficient algorithms are known [13]. Again, efficiency is contingent \non having the input in an expanded form. Using our terminology, the value assignment to a configuration \nis truncated when going from a type to its multiplicative supertype. Thus, one can view multiplicativ\u00a2 \nsubtyping and Definition 4.2 as being complementary. Multiplicative subtyping deals with the val- ues \naspect of an instance, while additive subtyping deals with the configuration designation aspect. 4.6 \nVariations The type system P with additive subtyping is the main type sys- tem we will deal with here. \nHowever, using similar mathematical machinery several other variations are possible. 1. The type system \nin which field ordering in a product is signif- icant (product is not commutative) is represented by \nN[[z]]. 2. The type system that does not admit multiple occurrences of the same configuration is represented \nby ~z]. In such a sys- tem, the type U2 = znt + znl: (Section 3) is equivalent to the primitive integer \ntype. 3. In a similar fashion, ~[z]] models a type system in which multiple occurrences of a configuration \nare considered one, but without commutativity of multiplication.  For each of these systems it is possible \nto apply the notion of addi- tive subtyping, by using Definition 4.2 with the necessary changes. On the \nother hand, multiplicative subtyping as defined in Defini- tion 4.3 only makes sense if multiplication \nis commutative. The systems N[[z]], ~z] and ~[[z]] are discussed briefly in Sec- tion 9. 5 Intuition \nbehind Algebraic Types This section is devoted to an informal presentation of algebraic types, which \nare obtained by augmenting polynomial types with re- cursive definitions. The discourse will follow a \nseries of examples highlighting some of their properties. Formal definitions are pro- vided in the next \nsection. A novel technique we present here is of solving recursive type equations using methods used \nin combina- torics for finding generating functions. Example 5.1. Considering the C type definition in \nFigure 6, we see that the type L is defined using itself. Using the conventions introduced in the previous \nsection, we may write this as an equation L = I(I+L) = I+IL. (8) typede\u00a3 struot L { \u00a3nt data; stz'uQt \nL *next; }; Figure 6: A C definition of a linked list node data type. One way of determining the meaning \nof the unknown type L from (8) is by directly solving (8) for L I L = 1---~-~. (9) Clearly, this solution \nmakes little sense in terms of types, since type division makes no sense at all, as does type subtraction. \nNeverthe- less, writing the Taylor expansion about zero of the above we obtain to L = ~ P. (10) i=1 In \nwords, (10) means that IL is either one :tat or two :l.nt's or three int's, etc. Yet another way of dealing \nwith (8) is of repeatedly substitut- ing L by its definition L = I+IL = I+I(I+IL) = I+I z +I2L = I+I \nz +I2(I+I z + I2L) = I + 12 + I a +/4 + 145 .... (11) oo = E1 i. i=1 Fortunately, both ways lead to the \nsame infinite power series. Example 5.2. Consider the binary search tree defined in Figure 2, which leads \nto the recursive definition equation X = I(1 + X) 2. (12) By moving terms we obtain IX 2 + (2I- 1)X + \nI = 0, (13) a quadratic equation with two solutions 1 -2I \u00b1 x/1 -41 X1,2 = 2I (14) Carrying on while \nignoring the senselessness of the extraction of the square root of types we see that the Taylor power \nseries of X1 contains terms with negative coefficients. Hence, this solution is meaningless for our purposes. \nThe expansion of the second solu- tion of (14) is more promising X2 = I+212+5IZ+14Ia+ ... . (15) In words, \nX2 is either one :tat or one of two configurations of two int:'s, or one of five configurations of three \n:tnt's, etc. Indeed, a binary tree has one configuration of one node, two configurations of two nodes, \nfive configurations of three nodes etc. It is a standard exercise in combinatorics to derive from (14) \nthat oo X2 = ~ CiI i, (16) i=1 where C,~ is the n th Catalan number, defined by 1 C,~ = ~ \\ n ]' (17) \nIt is well known that C,~ is the number of distinct binary trees with n nodes. Again, repeated substitutions \nstarting from (12) will eventually result in the same power series as (15): X = I(1 + 2X +X 2) = I(1 \n+ 21(1 + 2X + X 2) + I2(1 + 2X + X~) 2) = I + 21 + 4IX + 212X 2 + I s + 2X2I 2 + ... (18) Let us introduce \na notation for formal power series. The set of all power series, finite and infinite, of monomiais Ix] \nwith coefficients in A is denoted by A(x). Since 0 6 A we have A[x] _C A(x). For completeness of the \nnotation we let A((x)) denote the set of pseudo formal power series, i.e., the formal series with coefficients \nfrom A and pseudo monomials from x*. For a formal power series p 6 A(x) we let [ra]p denote again the \ncoeffi- cient of monomiai m in p. The same convention can be applied to pseudo formal power series. Since \nthe series are formal, we feel free to multiply and add them without concerning ourselves too much with \nquestions of con- vergence. Examples 5. I and 5.2 indicate that it might be possible to en- code recursive \ndata types with power series from N(z). The power series of a type, also called generating function of \nthe type, is uniquely defined by the demand that the coefficient of a certain monomial is the number \nof different ways the configuration asso- ciated with this monomial occurs in the type. We will make \nscant distinction between a recursive type and its power series. We do not assume an extensive background \nin generating func- tions and their applications in combinatorics. (The curious reader may want to consult \nstandard textbooks on the topic, e.g., [21, 39].) However, a few words are in place here to explain why \nsolving di- rectly for an unknown type yielded correct results, even though in- valid operations were \nused along the way. The standard technique for discovering an explicit representation of a generating \nfunction is to search for an equation which this function must satisfy. After solving this equation, \nwe look for the generating function among its, hopefully not too many, solutions. We have essentially \nrepeated this standard technique here, ex- cept that not much work was required to discover such an equation. \nThe recursive type equation is an equation which the generating function of the type must satisfy. Therefore, \nthe generating func- tion of the type must be found among the solutions of the type equation. There are \ncases in which a recursive type has no generating function since it has an infinite number of basic configurations. \nExample 5.3. Consider the type D defined by Figure 7, which gives rise to the type equation D = I+(l+D). \n(19) This equation has no solutions since it is equivalent to I = -1. Further, repeated substitutions \nfail to converge D=I+I+D=I+I+(I+I+D) .... = n(1 + I) + D (20)  As before, the subscript z is omitted \nwhenever it is clear from and context. Note that there are two kinds of players in (29): Formal Variables \nThese are the primitive types z. Unknowns These are the newly defined, mutually recursive types T1,..., \nT~. Eq. (29) defines the unknowns in term of the formal variables. We can say that the unknowns are a \nfunction of the formal variables. The term \"algebraic\" was coined for our recursive types since this \nfunction is algebraic in the algebraic geometry sense: Definition 6.2. Let x = (xl,...,x,~) and y = (yl,...,y,~). \nAn algebraic function is a multivariate multi-valued function f : -~ C '~ mapping x to y, defined by \na system of implicit poly- nomial equations Pa (x, y) = 0 : (30) P,(x,y) = 0 where Pi 6 C[x, y]. Clearly, \n(29) is an instance of (30). Therefore, each member of ~4 is also what is called a branch of an algebraic \nfunction. On the other hand, there are algebraic functions which are not algebraic types. For example, \nthe function 1 y=y(z)= l+z = ~(-1)'~ ' (31) ,=0 has only one branch which clearly does not correspond \nto a type. There are at least three strategies for finding the generating function of a type from its \ndefinition. The first is by a process of repeated substitutions. Even though this process is infinite, \nin some cases it is possible to infer about it and deduce the infinite power series. Such deduction is \ncomplicated by the fact that there are in- finitely many different ways of carrying out the substitutions. \nAt each substitution stage, one can choose any type T~, any definition for it (the original one, i.e., \nP~, or any alternative polynomial ob- tained from Pi through previous substitutions), and replace it \ninto the current definition of any other unknown Tj. The only restriction is that each one of T~ is selected \nan infinite number of times. A priori, it is not clear that these different ways will always re- sult \nin the same power series. It is necessary to develop specialized mathematical machinery to deal with \nthe notion of \"convergence\" into an infinite, multi-dimensional series. An excellent treatise of these \ntopics is provided in Kuich and Salomaa's book [27], and will not be repeated here. It is however not \ntoo difficult to show that if [1]P, \u00a2 0 [z~]P~ = 0 (32) for all 1 < i < n and all 1 _< j < k, then the \ntypes defined by (29) are not degenerate. The second strategy for finding the infinite power series of \na type is described in [27]: start from an initial approximation that Ti is 0 for all 1 < i < n. Then, \nthe (g+l) 'h approximation is obtained from the g,h approximation by substituting it into the system \n(29). This strategy can deal with equations such as Ta = T~, (33) T2 = zT2 + 2T2 (34) which do not define \ndegenerate types as defined in Definition 5.4, even though a repeated substitution process in them does \nnot ap- pear to \"converge\". Note that this strategy is similar to the familiar fixed point iteration \nmethod for finding the minimal solution (with respect to the additive subtyping partial order) in a system \nof equa- tions, as used in more traditional type theory. It is shown in [27] that if [lla = 0 [zAP~= \n0 (35) for all 1 < i < n and all 1 _< j < k (a proper set of equations) or if [ra]Pi = 0 (36) for all \n1 < i _< n and all m 6 [z] -1 (a weakly strict set of equations) then this successive approximation process \nconverges to a solution. The third strategy of deducing the power series is by solving the system (29) \nanalytically, then writing the Taylor series of all solutions, and selecting the one which corresponds \nto the sought generating function. However, since there is no analytic solution to quintic and higher \norder equations, this is impossible to do in the general case. The third strategy does not yield the \nsame results as the second for the type defined by (33). There are two branches to the analytic solution \nof (33), T1 = 0 and T1 = 1. Indeed, both unit= and None satisfy (33). In (34) on the other hand, the \nsecond and third strategies agree, while the first fails. There is an interesting family of types in \nwhich it is always pos- sible to find an analytic solution of (29). Regrettably, even in this family \nit is not in general possible to write an explicit expression for the coefficients of the sought power \nseries. Definition 6.3. The set R C ,,4 of rational types is defined by the following condition. Type \nT fi 7~ if and only if it can be defined by a system of equations T = PT + Q (37) where T is an (n x \n1) vector of unknowns, T 6 T, while P is an (n x n) matrix, Q is an (n x 1) vector, and the elements \nof P and Q are in N[z]. The system (37) is nothing but a system of linear equations in the unknown types. \nIt is therefore possible to employ Gaussian elimination and compute the type T as an explicit function \nof the coefficients in this system. Since all coefficients in (37) are poly- nomials it follows that \nthe generating function of T is given by T = P(z)/Q(z) (38) where P, Q 6 Z[z]. Eq. (38) explains why \nthis restricted family of algebraic types are called rational types) From a programmer standpoint, rational \ntypes are recursive types which have the prop- erty that no recursive type definition makes more than \na single use of each of the user defined types in each record. It is easy to verify from Definition 6.3 \nthat 7~ is closed under additions and multiplications. This observation will be used in the following \nsection. 3Rational types are not to be confused with rational trees, a mathematical device sometimes \nused in the study of re, cursive systems. Additive Subtyping in 7~ is Undecidable In this section we \nfocus our attention on additive subtyping (henceforth just subtyping). We will show that subtyping in \n7~ is undecidable. Of course, this implies that the more general problem of subtyping in ,A is undecidable \nas well. It is not clear however if the proof can be made any simpler by working in A, or whether there \nare interesting properties of .,4 which do not hold in 7~. The proof is carried out by reduction from \nHilbert's tenth prob- lem, the solution of polynomial Diophantine equations. We will see that for every \nsuch equation, there is a pair of rational types, which stand in a subtype relationship if and only if \nthe equation is solvable. Definition 7.1. Hilbert' s tenth problem ( H I O ): Instance: A multivariate \npolynomial Q(m,..., uk) E ~,1,...,,,~1. Question: Is there an assignment to u~,..., uk such that of rational \nnumbers Q(ul,... ,~k) = 0. (39) David Hilbert presented H10 in his now famous 1900 lecture before the \nsecond International Congress of Mathematicians, as part of the set of 23 problems, which he deemed as \nthe challenge left to the 20 th century mathematics by the 19 th. H10 was the only decision problem in \nthis set. In fact, it is the only one which can be thought of as a computer science problem. Surviving \nattacks by J. Robinson, M. Davis, H. Putnam and others, H10 finally yielded to Yuri Matiyasevich [29, \n36] 4 who pro- vided the missing step in the proof that it is undecidable. Fact 7.2. H10 is undecidable. \nIn this paper, we will be concerned only in the variant of H10 in which the coefficients of Q are restricted \nto be integers, i.e., Q E Z [u] and the sought solutions are restricted to be natural numbers instead \nof integers. The restriction does not lose any generality [30, Chap. 1], and the restricted form of H10 \nis undecidable as well. The proof of Fact 7.2 uses what is called in the literature a uni- versal Diophantine \nequation. Definition 7.3. Let U E Z[ex .... , el, ux .... , u~] be a polynomial with integer coefficients \nin the code parameters cl ,..., cz and the unknowns ul,..., u~. Suppose that for every given equation \nof the form (39), there is a setting of the code parameters such that the equation U(Cl,..., c,, ul ..... \nu~) = 0, (40) is solvable exactly when the given equation is solvable. Then, Eq. (40) is called a universal \nDiophantine equation. Note that each instance of (40) has r unknowns and that in gen- eral r \u00a2 k. The \nexistence of universal equations will allow us to carry out the reduction from a restricted set of instances \nof H10, rather than the whole range of those instances. We will employ a standard technique of using \na generating function to enumerate the values of a multivariate function of the natural numbers (such \na function can also be thought of as a multi- dimensional series). 4Several distinct transliterations \nof this famous Russian mathematician were used in the literature Definition 7.4. Given S(ul,..., uk), \na multivariate function of natural arguments, its enumerating generating function (or, for short, enumerating \nfunction) is Fs(z)= ~ ... S(ul .... ,uk)z~ 1...z~' (41) If S assumes only natural values, then its enumerating \nfunc- tion Fs is in N({zl,..., z~}) and therefore may correspond to an algebraic type. We call this type \nthe enumerating type of F. The following lemma is pertinent to our reduction. Lenuna 7.5. For all Q E \nN[u], the function TO, the enumerating function of Q, belongs to 7~. Lemma 7.5 can be used as a black-box \nin the reduction. We therefore postpone the presentation of its proof to Section 8 below. The following \nexample will help understand the lemma, as well as Definition 7.4. Example 7.6. Consider the polynomial \nQ(ul, us) = u~u2 + 1. (42) We can tabulate the values of Q on all natural assignments to ux and uz in \nan infinite two dimensional table as demonstrated in Ta- ble 1. 0 1 2 3 4 1 1 1 1 1 ... 1 2 5 10 17 ... \n~2 1 3 9 19 33 ... 1 4 13 28 49 ... : : : : '.. Table 1: The values of u~u2 + 1. We can summarize the \nenumeration of this two dimensional table using a generating function F(zl, zs). Reading the values along \nthe secondary diagonals of Table 1 we can write the first few terms of F: F(zl, z2) = 1 + (Zl + z2) + \n(z~ + 2zlz2 + z~) + (z~ + 5z~zs + 3~1~ + ~)+ 2 2 + (z~ + 10z~z2 + 9zlz2 +'\") +'\" (43) Notice that zl \nand z2 are formal variables used in enumerating the values that Q assumes, and therefore play an entirely \ndifferent role than that of Ul and u2. Variables zl and z2 typically range over C, while ul, u2 E N. \nExamining (43) we see that the coefficients of F increase at a polynomial rate, and therefore, F is well \ndefined in some neigh- borhood of the origin. Eq. (43) does not tell us much more about the nature and \nthe behavior of the function F. However, using Lemma 7.5 we can assert that F is a rational function. \nMoreover, it is a rational type. We are now ready to present the main result of this paper. Theorem 7.7. \nSubtyping in T~= is undecidable iflzl >_ 9. Proof. By reduction from H10. Given an arbitrary Diophantine \nequation O(ul, . . . , ~k ) = O. (44) we write the inequality 1- (Q(ul,..., uk)) 2 > 0. (45) Since the \ncoefficients of Q and ul,..., u~ are all integers, the val- ues that Q assumes are integers as well. \nIt follows that the set of solutions of (44) is the same as that of (45). By rearranging terms in (45) \nwe can rewrite it as Ql(Ul,... ,Uk) > Q2(ul ..... uk ), (46) where Q1 and Q2 are polynomials with natural \ncoefficients. Using Lemma 7.5 we now construct TQ~ and TO2, the enumer-ating types of Q~ and Q2. We argue \nthat TQx _E TO2 (47) if and only if there is no solution to (44). Suppose that (47) holds. Then, every \ncoefficient of TQ1 is no greater than the corresponding coefficient of TQ2, i.e., Q1 (ul,..., uk) _< \nQz (ul,..., u~) (48) for any setting of ul,..., uk. This implies that Ineq. (46) never holds, and therefore \nEq. (44) is unsolvable. The opposite direction is carried out similarly. Note that in this construction, \nk, the number of unknowns in (44) is exactly the same as the number of primitive types upon which types \nTQa and TQ2 are constructed. Fortunately, and thanks to the existence of universal equations, this does \nnot mean that the type system is required to have an unbounded number of primitive types. We only need \nto carry out the reduction for all instances of a universal equation of the form (40). Our proof is completed \nby noting that there exists a univer- sal equation with nine unknowns. (Such an equation is described \nin [24]). [] Proof of Lemma 7.5 In this section we will see how all polynomials can be enumer- ated by \ntypes in 7~, whereby proving Lemma 7.5, and completing the proof that subtyping in 7~ is undecidable. \nThe most difficult step is in showing that all univariate monomials have an enumerat- ing rational type. \nAfter doing so, we extend this claim to multivari- ate monomials and subsequently to multivariate polynomials. \nLet us use the convention that 0 \u00b0 = 1. Lemma 8.1. For all r > 0, there exists a rational type Mr such \nthat to Mr = 2rlz r, (49) i=0 Thus, Mo = 1 +z+z 2 +z 3 +... M1 = z + 2z 2 + 3z z +... M2 = z + 4z 2 + \n9z 3 + ... M3=z+8z 2+27z 3+... A few words of intuition are in place before we proceed to the proof. \nType Mo is the linked list of z's, which can be defined by Mo = 1 + zMo (50) Clearly, M0 is a rational \ntype and to Mo = Z zi\" (51) i=0 Using Mo we can define M1 by M1 = zM1 + zMo. (52) By unfolding we obtain \nM1 = z(zM1 + zMo) + z + z 2 +... = z(zM1 +z+z 2 +...) +z+z 2 +... = z2M1 + z + 2z 2 + 2z a +... (53) \nto = z2M1W z + 2zZ + 2 Z z i i=3 = z + 2z 2 + z2Ml + 2zaMo. Further unfolding of the terms z 2 Mi and \n2z ~ Mo will yield only z z and higher order terms. Therefore, the first two terms in the expan- sion \nof M1 must be z+2z 2. This argument establishes an induction base for a proof by induction that [z~]M1 \n= n (54) for all n > 0. To determine [z\"]Mx for n > 0, examine the right hand side of Eq. (52). By the \ninductive hypothesis we have that for the term zM1 [z'~]zM1 = n -1. On the other hand, [z~]Mo = 1. Thus \n[z\"]M1 = (n -1) + 1 = n. In a similar fashion, we can define the type M2 as M2 = zM2 + 2zMa + zMo. (55) \nThe induction step in this case can be carried out as follows. By the inductive hypothesis [zn]zM2 = \n(n-1) 2. (56) From (54) and (51) we have [zn]2zM1 = 2(n- 1) (57) and [z\"]zMo = 1. (58) Summing (56), \n(57) and (58), we obtain [z'~]M2 = (n -1) 2 + 2n + 1 = n 2. The proof of Lemma 8.1 is a generalization \nof these considerations. Proof of Lemma 8.1. Let the types Mr, r > 0 be defined by (50) and the system \nof mutually recursive equations: Mr = z ~ Mr-~ (59) i=0 Then, by means of simultaneous induction on n \nand r, we show that [z\"]Mr = n r (60) for all n > 0, r > 0. The base case r = 0, n >_ 0 trivially follows \nfrom the expan- sion of the linked list. Consider the case n = 0, r _> 0. It is clear from the defini- \ntion (59) that [z\u00b0]M~ = 0 for all r = 1, 2,.... In other words, only Mo has a constant term in its expansion. \nThe induction step is the case n > 0, r > 0. We use (59) and then the inductive hypothesis to obtain \n[znlMr = [z\"] E Mr-, i=0 = ((n--1)+l) r ,~. n r In order to show that all monomials can be enumerated \nby ratio- nal types we need the following lemma which shows how to enu- merate a product. Lenmaa 8.2. \nLet Sl(ul,... ,ul) and S2(uz+l,...,uk) be two multivariate functions of the naturals whose sets of formal \nargu- ments are disjoint. Let S be their product: S(ul, ... ,u~) = Sl(ux,...,uz)S2(ul+x,...,uk). Then, \nFs, the enumerating function of S, is Fs(zx,..., zk) = FSl (zl,. , zl)Fs2(zz+l,..., z~) where Fsx and \nFs2 are the enumerating functions of $1 and Sz. Proof. Considering Definition 7.4, we see that in multiplying \ntwo sums of the form (41), where all summation indices are disjoint, gives another sum of the form (41). \n[] Combining lemmas 8.1 and Lemma 8.2, we obtain that an enu- meration of all multivariate monomiais. \nCorollary 8.3. All m E [z] can be enumerated by a rational type. The missing step for the enumeration \nof all polynomials is the enumeration of addition: Lenmaa 8.4. Let Sl(ul,...,u~) and S2(ul,...,uk) be \ntwo multivariate functions of the naturals, and let S be their sunI: S('/gl,...,~k) = Sl(Ul,...,'//~k) \n+ ~2('U.l,...,'//,k). Then, Fs, the enumerating function of S, is Fs(Zl,... ,zk) = Fsl(zl,...,zk) + Fa2(Zl,...,Zk) \nwhere Fsl and Fs2 are the enumerating functions of $1 and $2. Proof. The proof follows immediately from \nDefinition 7.4. D The proof of Lemma 7.5 now follows from Lemma 8.4 and Corollary 8.3. In summary, we \nhave shown that the enumerating function of polynomials in N[u] is a rational type. It is not difficult \nto extend our proof to show that the encoding function of polynomials in Z [u] is a rational function. \nConversely, it follows from Matiyasevich's proof that all computable functions can be expressed as the \nvalues of polynomials in Z [u]. Since the coefficients of rational (and alge- braic) types can clearly \nbe computed, then, for any such type, there is a polynomial in Z[u] whose values span these coefficients. \nObviously, rational types cannot enumerate all polynomials in Z [u], since such polynomials may assume \nnegative values. The converse, namely whether polynomials in N[u] are sufficient for the enumeration \nof rational types is not clear. 9 Discussion and Open Problems Perhaps the most interesting definitional \nproblem that this paper leaves open is that of a notion of \"structured conversion\" between arithmetical \ntypes, beyond, or on top of, the abstract CCO mecha- nism. Such a notion may lead to a different definition \nof additive subtyping which might be decidable. As an indication that structured convertibility might \nbe easier than mere inclusion should serve the fact that containment of con- text free languages is undecidable, \nwhile there is an algorithm (al- beit complicated) for the structured version of this problem, namely \ncontainment of parenthesized grammars [37, Chap. VIII.3]. Other, more mathematically oriented problems \nand directions for further research are mentioned below. 9.1 The main result, extensions and improvements \nThe main result presented in this paper is that additive subtyp- ing is undecidable in N{z). Our undecidability \nresult required that the type system has 9 or more primitive types. The value 9 seems to be borderline. \nJava for example has 8 primitive types, while C (depending on the counting) has more than 9. Concrete \nsubtyping problems may use a fewer number of primitive types than those which exist in the host programming \nlanguage. Therefore it is in- teresting to try to reduce the number of primitive types required for the \nproof. Reducing the number of unknowns in a universal polynomial Diophantine seems difficult. The lower \nbound of 9 achieved by Jones [24] was not improved for almost twenty years. We believe that such a reduction \nis easier in our context. Support for this belief we find in the fact that there exists a universal exponential \nDio-phantine equation using only three unknowns [30, Chap. 7]. We observe that the expressive power of \nrational types is richer than polynomials, and includes e.g., exponentiation. The type Er = 1 + rzEr \ngives an encoding of the function r u for any integer r > 0. Using general algebraic types it is possible \nto encode even more interest- ing integer functions, such as the binomial values (Example 5.6), and in \nparticular Catalan numbers (Example 5.2). Unfortunately, unlike polynomials, the composition of such \ninteger functions is not so simple. Even a simple encoding in types of a function with doubly exponential \ngrowth rate does not seem possible. This makes the encoding the universal exponential equation with three \nunknowns using algebraic types an interesting challenge. The following fact states that without commutativity, \nadditive subtyping is undecidable with two primitive types or more. Fact 9.1. Additive subtyping in N({z)), \nIzl >_ 2 is undecidable. Proof. The proof is by giving a type theoretical interpretation to the corresponding \nresult in formal power series [38]. [] Fact 9.1 might be interpreted to gives another indication that \na reduction in the number of unknowns is possible. When there is only one primitive types, commutativity \nplays no role and we have that A((z)) = A(z) for any ring A. The most interesting case is A = N. It is \na \"celebrated\" 5 open problem to show that additive subtyping in N((z)), Izl --1 is undecidable, or find \nan algorithm for it. If choice is idempotent, specifically when A = B, then additive subtyping, and hence \nadditive inequality can be decided in polyno- mial time. 5A. Salomaa (private communication), and P Flajolet \n(private communication) 287 Fact 9.2. Additive subtyping in B(z) and in B((z)) can be decided in polynomial \ntime. Proof The proof is by using Parikh's theorem [32] to show the infinite set, with duplications removed, \nof configurations generated by an algebraic type is a regular set. Details can be found in [27, Chap. \n7]. [] Another research direction is to explore multiplicative subtyp- ing in B(z), in B((z)), and N((z)) \n9.2 Other problems in the A type system Given two systems of equations T1 = Pi(T1,... ,T,~,z) (61) T,~ \n= P~(T1,... ,T~,z) and Ti = Pi(T2,..., T',,-.) : (62) T,', = P,' (T~,...,r,',,~), the type equality \nproblem is to determine whether the Laurent power series expansion of the algebraic functions T1 = T1 \n(z) and T~ = T~ (z) are identical. A simple algorithm for this problem is by applying Tarski's theorem \n[42] which gives a quantifiers removal procedure and a checking algorithm for every first order predicate \nover the reals involving equality, addition and multiplication as well as the usual logical operators. \nIf two algebraic functions coincide in a non-empty neighborhood of the origin, then their Laurent ex- \npansion must be identical. This condition is readily written in a prenex form, and hence can be tested. \nTarski's original algorithm is highly inefficient [15]. More effi- cient (though still non-polynomial) \nimplementation of his theorem exist [10, 8, 11]. These algorithms use techniques related to Groeb- ner \nbases [13]. A natural question is therefore whether Groebner bases can be applied directly for checking \ntype equivalence. More generally, find a procedure for determining multiplicative subtyp- ing in .A (or \nshow that it undecidable). 9.3 Function types How should functions (in the programming sense) be incorpo- \nrated into the arithmetical types framework? The natural way of doing so is using exponentiation: a function \nmapping type zl into type z2 will be encoded as z~ 1 . Exponential encoding models well currying and \nother common operations on function types. We may use the term transcendental for a type system which \nincludes ad- dition, product and exponentiation. Our undecidability result triv- ially extends to transcendental \nrecursive type systems, and hence applies to traditional OO systems which admit functions as another \ntype operator. Exploring subtype and type equivalence issues in a non-recursive transcendental type system \nis interesting, but the parallels between the type system and the arithmetical encoding do not work as \nnicely: The encoding of a procedure type 7- : z ~ Un:l.l: as 1 z may lead to the false conclusion that \n~- = 1. Also, subtyping of function types obeys the contra-variance rule for arguments, which would be \nhard to model using arithmetic. 9.4 A Restricted Type System In the context of many contemporary OO \nlanguages, it is im- portant to investigate a type system variant in which the choice type operator is \nused solely for the representation of references. Such a type system will not include types such as zl \n+ z2. However, it will include types such as 1 + zl (a pointer to z), 2 + z (a pointer to a pointer to \nz) as well as (1 + zl)(2 + z~)za. This restriction roughly corresponds to languages such as Java and \nEiffel in which there are no choices, but references which can be, to use the Eiffel terminology, void. \nMore formally, we define the set Nix] C Nix] as follows. Definition 9.3. Given a finite set of primitive \nformal variables x, the set Nix] of pointer polynomials over x is defined by 1. x Nix], forallx x, \n 2. 1 + p N[x] for all p Nix], 3. plpz ~l[x] for ailpl,pz N[x], and 4. nothing else is in Nix]. \n  The system N[x] is somewhat weird since it is closed under multiplication and substitution but not \naddition. An open problem is to determine the complexity of subtyping of algebraic types if the type \nequations are restricted to polynomials drawn from Nix]. Acknowledgments The comments of Jens Palsberg \non a pre- liminary version of this paper are gratefully acknowledged. References [1] R. M. Amadio and \nL. Cardelli. Subtyping recursive types. ACM Transactions on Programming Languages and Systems, 15(4):575--631, \n1993. [2] K. Arnold and J. Gosling. The Java Programming Language. The Java Series. Addison-Wesley, 1996. \n[3] J. Auerbach. The #type system. Unpublished Manuscript, IBM T. J. Watson Research Center, P.O. Box \n704, Yorktown Heights, NY 10598, 1998. [4] J. Auerbach, C. Barton, M. Chu-Carroll, and M. Raghavachari. \nMockingbird: Flexible stub compila- tion from pairs of declarations. In M. G. Gouda, editor, The 19 th \nIEEE International Conference on Distributed Computing Systems (ICDCS), Austin, Texas, May-June 1999. \n[5] J. Auerbach and M. Chu-Carroll. The Mockingbird system: A compiler based approach to maximally interoperable \ndis- tributed programming. Technical Report RC20718, IBM T. J. Watson Research Center, EO. Box 704, Yorktown \nHeights, NY 10598, 1997. [6] J. Avotins, G. Maughan, and C. Mingins. Language proces- sor construction: \nThe case for YOOCC and TROOPER. In Proceedings of TOOLS USA'95, 1995. [7] J. Avotins, C. Mingins, and \nH. Schmidt. Yes! an object- oriented compiler compiler YOOCC. In Proceedings of TOOLS USA'95, 1995. \n[8] S. Basu and M.-E Roy. On the combinatorial and algebraic complexity of quantifier elimination. J. \nACM, 43(6):1002-1045, Nov. 1996. [9] M. Brandt and E Henglein. Coinductive axiomatization of recursive \ntype equality and subtyping. Fundamenta Informat- icae, 33(4):309-338, May 1998. [10] G. E. Collins. \nQuantifier elimination for real closed fields by cylindrical algebraic decomposition. In Proceeding of \nthe 2 nd GI Conference on Automata Theory and Formal Languages, pages 134--183, New York, 1975. Springer \nVerlag. [11] G.E. Collins. Quantifier elimination by cylindrical algebraic decomposition--twenty years \nof progress. In B. E Caviness and J. R. Johnson, editors, QuantO~er Elimination and Cylin- drical Algebraic \nDecomposition, pages 8-23. Springer Ver- lag, New York, 1998. [12] T.H. Cormen, C. E. Leiserson, and \nR. L. Rivest. Introduction to Algorithms. MIT Press, Cambridge, Massachusetts, 1990. [13] D. Cox, J. \nLittle, and D. O'Shea. Ideals, Varieties andAlgo- rithms. Undergraduate Texts in Mathematics. Springer \nVer- lag, second edition, 1996. [14] E Datum. Subtyping with union types, intersection types and recursive \ntypes. In Hagiya and Mitchell [20], pages 687-706. [15] J. Davenport and J. Heintz. Real quantifier elimination \nif dou- bly exponential. J. Symb. Comput., 5:29-35, 1988. [16] R. Di Cosmo. Isomorphisms of Types: from \nA-calculus to information retrieval and language design. Birkh~iuser, 1995. [17] J. Gil and D. H. Lorenz. \nSOOP - A synthesizer of an object- h oriented parser. In Proceedings of the 16 ~ International Con- ference \non Technology of Object-Oriented Languages and Systems, pages 81-96, Versailles, France, Mar. 6-10 1995. \nTOOLS 16 Europe Conference, Prentice-Hall. [18] C. F. Goldfarb. The SGML Handbook. Clarendon Press, Ox- \nford, 1990. [19] C. E Goldfarb and P. Prescod. The XML Handbook. Charles E Goldfarb Series. Prentice-Hall, \n1998. [20] M. Hagiya and J. C. Mitchell, editors. Proceedings of the 2 nd International Symposium on \nTheoretical Aspects of Computer Software, volume 789 of Lecture Notes in Computer Science, Sendai, Japan, \nApr. 1994. Springer Verlag. [21] M. Hofri. Probabilistic Analysis of Algorithms. Springer-Verlag New \nYork Inc., 1987. [22] J. Ichibia, editor. Ada Programming Language. ANSI/MIL-STD-1815A. Ada Joint Program \nOffice, Department of De- fense, Washington, DC, 1983. [23] C. B. Jay. The FISh programming definition. \nAvail-able as http: //www-sta f f.mcs .uts. edu. au/au/~cbj/- Publications/lastest_fish.ps. gz, Oct. \n1998. [24] J. E Jones. Universal Diophantine equation. Journal of Sym- bolic Logic, 47(3):547-571, 1982. \n[25] B. W. Kernighan and D. M. Ritchie. The C Programming Language. Software Series. Prentice-Hail, second \nedition, 1988. [26] D. Kozen, J. Palsberg, and M. Schwartzbach. Efficient re- cursive subtyping. Mathematical \nStructures in Computer Sci- ence, 5, 1995. [27] W. Kuich and A. Salomaa. Semirings, Automata, Languages, \nvolume 5 of EATCS Monographs on Theoretical Computer Science. Springer-Verlag, 1986. [28] L. Lamport. \nI~TEX: A Document Preparation System. Addison-Wesley, 1986. [29] J. V. Matijasevi~. Enumerable sets are \nDiophantine. Soviet Mathematics. Doklady, 11(2):354--358, 1970. This is an En- glish translation of the \noriginal paper in Russian (1970). [30] Y. V. Matiyasevich. Hilbert's tenth problem. MIT Press, 1993. \n[31] B. Meyer. Object-Oriented Software Construction. Prentice-Hail, second edition, 1997. [32] R. J. \nParikh. On context-free languages. J. ACM, 13(4):570-581, 1966. [33] O. Patashnik. BIBTL~fing, 8 Feb. \n1988. Documentation for general BIBTEX users. [34] L. C. Paulson. MLfor the Working Programmer. Cambridge \nUniversity Press, Cambridge, 1991. [35] M. Rittri. Using types as search keys in function libraries. \nJournal of Functional Programming, 1:71-89, 1991. [36] J. Robinson. Hilbert's tenth problem. In Proc. \nSyrup. Pure Math., 20, pages 191-194. Amer. Math. Soc., Providence, Rhode Island, 1971. [37] A. Salomaa. \nFormal Languages. Academic Press, New York and London, 1973. [38] A. Salomaa and M. Soittola. Automata-Theoretic \nAspects of Formal Power Series. Springer-Verlag, 1978. [39] R. Sedgewick and P. Flajolet. An Introduction \nto the Analysis of Algorithms. Addison-Wesley Publishing Company, Inc., 1996. [40] T. Sekiguchi and A. \nYonezawa. A complete type inference system for subtyped recursive types. In Hagiya and Mitchell [20], \npages 667--685. [41] B. Stroustrup. The C++ Programming Language. Addison-Wesley, third edition, 1997. \n[42] A. Tarski. A Decision Method for Elementary Algebra and Geometry. University of California Press, \nBerkeley, CA, sec- ond edition, 1951. [43] N. Wirth. The programming language Pascal. Acta Informat- \nica, 1:35--63, 1971. [44] Recommendation x.208: Speficiation of abstract syntax nota- tion one (ASN.1), \nMar. 1988. [45] R. E. Zippel. Effective Polynomial Computation. Kluwer Academic Publishers, Boston, Dordrecht, \nLondon, 1993.   \n\t\t\t", "proc_id": "360204", "abstract": "We consider the type system formed by a finite set of primitive types such as integer, character, real, etc., and three type construction operators: (i) Cartesian product, (ii) disjoint sum, and (iii) recursive type definitions. Type equivalence is defined to obey the arithmetical rules: commutativity and associativity of product and sum and distributivity of product over sum. We offer a compact representation of the types in this system as multivariate algebraic functions. This type system admits two natural notions of subtyping: \"multiplicative\", which roughly corresponds to the notion of object-oriented subtyping, and \"additive\", which seems to be more appropriate in our context. Both kinds of subtyping can be efficiently computed if no recursive definitions are allowed. Our main result is that additive subtyping is undecidable in the general case. Perhaps surprisingly, this undecidability result is by reduction from Hilbert's Tenth Problem (HIO): the solution of Diophantine equations.", "authors": [{"name": "Joseph (Yossi) Gil", "author_profile_id": "81100349003", "affiliation": "Systems and Software Development Laboratory, Department of Computer Science, Technion--Israel Institute of Technology, Haifa 32000, Israel", "person_id": "P148975", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/360204.360232", "year": "2001", "article_id": "360232", "conference": "POPL", "title": "Subtyping arithmetical types", "url": "http://dl.acm.org/citation.cfm?id=360232"}