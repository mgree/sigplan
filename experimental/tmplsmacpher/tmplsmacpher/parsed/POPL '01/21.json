{"article_publication_date": "01-01-2001", "fulltext": "\n Modules, Abstract Types, and Distributed Versioning Peter Sewell* Computer Laboratory, University of \nCambridge Abstract In a wide-area distributed system it is often impractical to synchronise software \nupdates, so one must deal with many coexisting versions. We study static typing support for mod\u00adular \nwide-area programming, modelling separate compila\u00adtion/linking and execution of programs that interact \nalong typed channels. Interaction may involve communication of values of abstract types; we provide the \ndeveloper with .ne\u00adgrain versioning control of these types to support interop\u00aderation of old and new \ncode. The system makes use of a second-class module system with singleton kinds; we give a novel operational \nsemantics for separate compilation/linking and execution and prove soundness. Introduction Background \nModule systems provide an important tool for structuring large programs, both to express their con\u00adceptual \nstructure and to support separate compilation and linking. They have been much studied most relevant \nto this paper is a line of work on ML-style modules [MTH90], with structures (collections of named types, \nvalues and sub\u00adstructures) and functors, which are parameterised struc\u00adtures. A key issue is the treatment \nof sharing equality for abstract types. The original ML static semantics in\u00advolved explicit generation \nof new type names; the translu\u00adcent sums/manifest types of Harper and Lillibridge [HL94] and Leroy [Ler94] \nshowed that more type-theoretic treat\u00adments were possible and could be expressed using the ma\u00adchinery \nof singleton kinds. These works treat separate compilation and linking either implicitly or as applications \nof higher-order functors. Cardelli [Car97] gives a more explicit model of linking, though without abstract \ntypes or parameterised modules. Various aspects of modularity and linking have been investigated more \nrecently, e.g. in [BA99, Dro00, Dug00, FF98, GM99, HWC00]. * Supported by a Royal Society University \nResearch Fellowship. Problem The works cited above focus on development of single sequential programs. \nIn this paper we address issues arising from wide-area distributed programming. There are two key di.erences: \n1. We must deal with whole programs that interact with each other at arbitrary interfaces, not simply \nprograms that interact with the outside world at the .xed types of library functions. 2. In wide-area \ndistributed systems it is often impractical to synchronise software updates, so we must deal with many \ncoexisting versions of programs that interact with each other.  Further, in a wide-area system it becomes \nparticularly im\u00adportant to detect errors early in the software development process; it is therefore worth \nusing static typing as far as possible and we would like to see how far. The language described here \ndoes not involve any run-time checks (save for the implicit equality testing of channel names that is \nintrinsic to channel-based interaction). Outline In the following two sections we develop a model language, \nequipped with static and dynamic semantics, that supports: 1. Separate compilation/linking and execution \nfor modu\u00adlar programs that interact along typed channels. 2. Interaction along channels carrying abstract \ntypes. 3. Version control of those abstract types, for interopera\u00adtion of old and new code.  It consists \nof a core expression language, a module system, and an imperative command-line language. The core lan\u00adguage \nis taken to be an asynchronous p-calculus, providing a concise form of typed interaction between whole \nprograms. The module system is based on a standard second-class sys\u00adtem, with .rst-order functors and \nusing singleton kinds. It is extended with new channel creation and with a novel type coercion for versioning. \nThe command-line language allows compiling and linking (here merged into a single step) of a module to \nan object .le, and executing such .les with main components. The semantics requires careful treat\u00adment \nof new name creation, both for channel names and type names in brief, abstract types must be compiled \nto manifest types with new-bound type names; these are used by the versioning coercion. Permission to \nmake digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for profit or commercial advantage and that copies \nbear this notice and the full citation on the first page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior specific permission and/or a fee. POPL '01 1/01 Londo, \nUK Copyright 2001 ACM 1-58113-336-7/01/0001 ... $5.00  def def def C = MAIN1 = MAIN2 = module module \nmodule export c : int chan import c : int chan import c : int chan begin export main : proc export main \n: proc newval c : int chan begin begin end val main : proc = c!27 val main : proc = c?x->(c!(x+1)) end \nend Figure 1: Flat modules with newval New type names arise in module reduction steps such as [T,e] \nas .X::Type.T . -. New Y::EQ(T) in [Y,e] as .X::EQ(Y).T . Here the .rst line is an existential package \nwith a hidden representation type T and an operation part e; the reduction creates a new name Y for the \nrepresentation type, recording it in both the term and signature parts of a manifestly-typed package. \nThe scope of the new type name must extrude to cover both compiled object code (as stored in .les) and \nthe running system. The versioning coercion allows the developer, when building a module expression m \nand assigning the result to a .lename B, to declare that abstract types provided by m should be made \ncompatible (if possible) with the previous version of the module stored in A. This is written B := (m \nwith! A). We prove subject reduction for both build-time and run\u00adtime semantics, show the absence of \nrun-time errors, and (in a simple case) relate monolithic and separately-compiled programs, giving a \ntight link between the singleton-kind sys\u00adtem and the type name generation occurring during module reduction. \nSection 4 concludes with discussion of related work and future directions. The full de.nitions of the \ntyping judgements, build-time semantics and run-time semantics for the language are omitted. They can \nbe found, together with proofs, in the technical report [Sew00]. The original motivation for this paper \narose from work with Pierce, Unyapoth and Wojciechowski on Nomadic Pict [SWP98, WS00, Woj00, US01], a \ndistributed programming language designed to express infrastructure algorithms for location-independent \ncommunication between mobile com\u00adputations. Nomadic Pict is based on a distributed process calculus (Nomadic \np) following the concurrent Pict lan\u00adguage of Pierce and Turner [PT00], based on the p-calculus [MPW92]. \nOur work on the language, and on distributed infrastructures expressed in it, has shown a clear need \nfor the support outlined above. The problems are more general, however similar issues would arise in \nmany other settings where programs interact and have long execution lifetimes (as compared with the development \ncycle). The exact form of interaction is more-or-less orthogonal to the typing issues. Nomadic Pict has \nasynchronous message passing to named channels at located agents, but typing would be similar for e.g. \nDistributed Join-style communication [FGL+96], inter\u00adaction via persistent references, or RPC mechanisms. \nFor simplicity we here adopt standard p-calculus communica\u00adtion, omitting explicit distribution from \nthe core language. This is not a realistic form of wide-area interaction, but it would be straightforward \nto extend the system with the Nomadic p distribution and mobility primitives, thereby al\u00adlowing modularisation \nof our distributed infrastructures. We are not here dealing with problems of numbered ver\u00adsions (some \nof which will be familiar to those who regularly encounter DLLs), but regard what we do as a necessary \npreliminary for a satisfactory treatment. We also do not ad\u00address dynamic linking [GM99, HWC00, Dro00, \nDug00] ex\u00adcept in the limited sense that a program might be replaced by another that interacts on an \noverlapping set of channels, nor do we consider hot code upgrade [AWWV95, HN00], in which new code is \ngiven access to the datastructures of that being replaced. These are clearly sometimes required, but \ninevitably lead to the possibility of late link-time or upgrade-time errors; we are exploring how far \none can go without them. 2 Informal Discussion This section discusses the issues and our solutions infor\u00admally, \nleaving rigorous development to \u00a73. 2.1 Interaction along typed channels We begin by discussing separate \ncompilation/linking for pro\u00adgrams that interact by message passing along channels car\u00adrying values of \nsimple types. The development is quite straightforward, but it is interesting to see how it must di\u00adverge \nfrom the single-program case (e.g. as in the .at mod\u00adules of [Car97]), and it is a necessary preliminary \nfor ad\u00addressing abstract types later. To introduce our core language, consider the monolithic p\u00adprocess \nnew c : int chan in (c!27 | c?x->(c!(x+1))) This declares a new channel c of type int chan (for mes\u00adsages \nof type int); it has an output c!27 of 27 along c in parallel with an input c?x->(c!(x+1)) that receives \nan inte\u00adger on c binding it to x and then outputs x+1. In a distributed system this process might be \nsplit, with the output c!27 in one program and the input c?x->(c!(x+1)) in another program that will \nbe executed concurrently, per\u00adhaps on a di.erent machine. This is expressed in Figure 1 in the simplest \n.at module system of [Car97], extended with a newval declaration for declaring new channels. The whole \nsystem would be built and run by compiling C, MAIN1 and MAIN2 to give some C . , MAIN1 . and MAIN2 ', \nlinking C . with each of the other two, and executing the two resulting com\u00adplete programs. To ensure \nstatically that communications on c are well-typed, even if some other program declares c to C := struct \nnewval c : int chan end MAIN1 := (functor(U: sig val c:int chan end) struct main = (U.c)!27 end) C MAIN2 \n:= (functor(U: sig val c:int chan end) struct main = (U.c)?x->((U.c)!(x+1)) end) C Figure 2: A sequence \nof build commands with newval be of type (say) (int*int*int) chan, a new internal chan\u00adnel identi.er \nmust be generated when C is compiled. This can be represented by taking C . to be module export c : int \nchan begin val c:intchan =z end where z is fresh (in a sense made precise below). At this level of abstraction \ncompilation is simply intra-module type checking and new channel name generation. Linking MAIN1 . and \nMAIN2 . with this will give outputs and inputs on z. Unfortunately, to keep soundness we can only generate \na new channel name when the type it will carry is known. To see this, suppose one compiled def D = module \nimport type t export val c : t chan begin newval c : t chan end to give D . def = module import type \nt export val c : t chan begin valc: tchan=z2 end with fresh z2. One could then successfully build two \npro\u00adgrams that attempt to interact on z2 but have a run-time error, as follows. Take def def T3 = T1 \n= module module export type t export type t begin begin type t=int*int*int type t = int end end and MAIN3 \nto be as MAIN1 but with an output of a triple. Write T3 . , T1 . and MAIN3 . for the results of compiling \nthese, then consider interaction between the two programs built by linking T3 . , D . , MAIN3 . and linking \nT1 . , D . , MAIN2 . . To avoid dealing with compilation and linking of such mod\u00adules that declare new \nchannels depending on unresolved imported types, we force a bottom-up build order. We take module expressions \nm including structures, functors and functor application. Compiling and linking are merged into build-time \nevaluation of such module expressions and as\u00adsignment of the resulting module values to .lenames. A module \nbeing built can refer only to .lenames of previously\u00adbuilt modules; it is typechecked with respect to \ntheir stored signatures (in examples we sometimes functorise to make signature constraints explicit). \nFigure 2 recasts the example into a sequence of three assignments, to .lenames C, MAIN1 and MAIN2. We \npun .lenames and free module identi.ers (both written in an upright font). Module expressions are reduced \ncall-by-value, with a structure def C2 = struct newval c : int chan end reducing to a value struct valc \n:intchan= z end for a fresh z. Now, in what sense must this z be fresh? It should be dis\u00adtinct from \nall channels generated earlier, either at build-time or at run-time, across the whole distributed system. \nIn an implementation a globally unique bitstring must be gener\u00adated. We represent this using name binding \nand scope ex\u00adtrusion, as in the p-calculus. To a .rst approximation, C2 above reduces to New z : int \nchan in struct valc:intchan=z (*) end In more detail, we idealise the state of the whole system, including \nboth the running computations and the module values stored in the various developers .lesystems produced \nby earlier builds, as a triple N,F,e which should be read as New N in (F,e). Here N is a type environment \nof new bindings such as z : int chan, the F models the union of all .lesystems1 as a .nite list of pairs \nof module ids and module values (with no repeated ids F will often be regarded as a partial function), \nand e is the running process expression. We take these triples up to alpha-renaming of the bindings in \nN. Now the e.ect of developers command-line build and load commands, and computation steps, can all be \nregarded as changes of system state. Executing a build command C := struct newval c : int chan end 1The \nsemantics uses a disjoint union of all .lesystems, implicitly extruding the New N of (*) to the outside, \nto reduce notational clutter. It would be straightforward to give an equivalent model with explicit extrusion \nthat would keep distinct .lesystems. T := struct type t=int val x=27 val i=.z.z end : TSIG C := (functor(T:TSIG) \nstruct newval c : T.t chan end) T MAIN1 := (functor(T:TSIG, C:CSIG(T.t)) struct main = (C.c)!(T.x) end) \nT C run MAIN1 wait 6 months T := struct type t=int*int val x=(27,3) val i=.(z,w).z end : TSIG MAIN2 \n:= (functor(T:TSIG, C:CSIG(T.t)) struct main = (C.c)?y-> ... (T.i)y ... end) T C run MAIN2 where we \nuse abbreviations def def TSIG = sig type t val x:t val i:t.int end CSIG(X) = sig valc:Xchanend Figure \n3: Attempted communication and use of elements of a changed abstract type (say) in the state N,F,e results \nin the new state N',F',e, where z . dom(N) and N' = N,z:int chan F' = F . (C . struct val c:int chan \n= z end) The new value of C in F' is obtained by module reduction. Note that for simplicity we are working \nas much as possible at the source language level, taking a single set of names rather than separate sets \nof program identi.ers and internal channel ids. The N binding ensures that code written after a build \ncommand cannot mention any of the newly generated names. Note also that N is kept to allow proof of soundness; \nin an implementation it can be discarded. For the load command, if U is a .lename referring to a mod\u00adule \nvalue struct val main : proc = e end then execut\u00ading the command run U in the state N,F,e results in \nthe new state N,F,e|e in which e is put in parallel with the existing running computation, allowing them \nto interact. The computation reductions of a state N,F,e are simply those of its process part e.  2.2 \nInteraction with Abstract Types We now address systems that interact by communicat\u00ading elements of abstract \ntypes. Similar new-name ma\u00adchinery will be required to ensure soundness, though now for type names rather \nthan channel names. We .rst re\u00adcall some aspects of ML-style type abstraction, particu\u00adlarly with translucent \nsums/manifest types in signatures [HL94, Ler94, Ler96, Ler00, Lil97] (for brevity the exam\u00adples will \nall be degenerate, without any operation parts or .eld dependencies). The module A = struct type t = \nint end : sig type t end provides a type A.t with representation int. It has an ex\u00adplicit signature \nin which no information about the repre\u00adsentation is visible, though, so from the outside the type is \nentirely abstract. In contrast, the module C = struct type t = int end : sig type t = int end reveals \nthat its representation type is int; the equality C.t=int may be used in typechecking the rest of the \npro\u00adgram. Such manifest types are particularly important in functor signatures. For example functor(U \n: sig type t end) struct type t2=U.t end : sig type t2=U.t end allows code using a structure, say D, \ncreated by applying this anonymous functor to A, to depend on the fact that D.t2 and A.t are equal types. \nTranslucent sums and manifest types were motivated partly by the need to re.ne SML modules to provide \nenough type equality information in signatures for separate compilation, partly by concerns of higher-order \nfunctors and .rst-class modules that we do not discuss here, and partly by a de\u00adsire to move from the \ngenerative SML static semantics to a more .exible type-theoretic style. Intuitively, instead of the SML \nsemantics use of new type names to distinguish be\u00adtween otherwise-identical abstract types, they use \nthe mod\u00adule identi.ers (or, more generally, paths) that occur in the source program. In our distributed \nsetting, we must reintroduce type name generation, albeit in a more controlled form. The broken example \nin Figure 3 shows why. Here we have two programs, MAIN1 and MAIN2, communicating elements of an abstract \ntype from module T, on a channel from C. Unfortunately T is re-built, with a changed representation type, \nbetween the builds of MAIN1 and MAIN2. There will be a run-time error. To prevent this we should detect \na build-time error when typechecking the functor application in the build of MAIN2, as the values of \nC and T there are not compatible. To make this lack of compatibility evident, we generate new type names \nwhen evaluating module expressions, reducing an abstract type to a type which is manifestly equal to \na fresh type name. For example, struct type t = int end (*) : sig type t end reduces to New X = int in \nstruct type t = X end : sig type t = X end and the body struct type t = X end : sig type t = X end of \nthis will be a module value whereas (*) will not. Nonethe\u00adless, we keep the type-theoretic style as much \nas possible type checking of a module expression in any individual build command will not involve new \nname generation. We need t=X both in the structure, so that it is correctly propagated during module \nsubstitution (when a functor is applied to this structure), and in the signature, so that there is enough \ntype sharing. The system of \u00a73 uses singleton kinds, due independently to Harper and Leroy, for expressing \nmanifest type declarations in signatures. There are kinds Type, of all types, and EQ(T) for any type \nT, of all types provably equal to T. In the example signatures above type t becomes type t::Type, and \ntype t=T becomes type t::EQ(T).  2.3 Abstract Type Versioning The semantics outlined in the previous \nsubsection guaran\u00adtees soundness but, because every rebuild gives incompatible executables, it would \nbe unusably rigid in practice. For ex\u00adample, one might initially build compatible MAIN1 and MAIN2 with \nthe .rst T command and the C, MAIN1 and MAIN2 com\u00admands of Figure 3. Rebuilding MAIN1 from the same source \ncode, i.e. with the C, .rst T and MAIN1 commands again, would give a version that could not interact \nwith copies of MAIN2 running elsewhere in the network. MAIN1 and MAIN2 would have di.erent versions of \nboth the type T.t and the channel C.c. The developer therefore needs a mechanism for forcing a rebuild \nof a module that provides an abstract type t or a channel c to produce the same abstract type or channel \nas before. We address only the (more interesting) type part of the problem; the channel part can be dealt \nwith using similar mechanisms. There are four cases: 1. The source code of the module (and all that it \ndepends upon) is syntactically unchanged. 2. The source code is changed, but the representation type \nof t is unchanged and the new code has the same im\u00adportant invariants as the old. 3. The representation \ntype is unchanged but the new code has changed invariants. 4. The representation type is changed.  \nNaively, one might allow a rebuild to produce the same type only in case 1. This could be entirely automatically \nchecked, but would be too in.exible we must allow for changed comments, performance improvements, minor \nbug .xes, and even some changes in functionality. On the other hand, in cases 3 and 4 a rebuild should \ncertainly produce a new type. Distinguishing between cases 2 and 3 clearly cannot be done automatically, \nso the developer must provide some annota\u00adtion for the new code, asserting that it has not changed any \nimportant invariant of the old abstract type, and hence that values produced by the old and new code \nwill be compat\u00adible. Such an annotation should force an automatic check that the representation type \nis unchanged. We envisage that large programs will require development environment support for managing \nthese annotations, allow\u00ading defaults such as always generate a new type , or always produce types compatible \nwith the previous build unless the code is syntactically changed , or always produce compati\u00adble types \nunless the representation type has changed all to be overridden locally as needed. There is an important \nprag\u00admatic question here, of what expressiveness is really neces\u00adsary or useful, but we do not investigate \nit in this paper. Instead, we introduce a minimal form of annotation, that might be generated by the \ndevelopment environment from higher-level defaults, and show how it can be given a sound semantics. In \nparticular, we allow module expressions containing coer\u00adcions, e.g. as in the right hand side of the \nbuild command A := m with! U (*) Suppose m is statically type-checkable with signature sig type t::Type \nval x:tops end, and that U is a .le\u00adname that refers to a previously-built module of similar shape. Executing \ncommand (*) will evaluate m to a struct, say struct type t=trep val x=e end : sig type t::Type val x:tops \nend check that its representation type trep is compatible with that of U, and .nally reduce it to a \nmodule value containing the same type name as U. In more detail, if the state in which (*) is executed \nhas an N component with X::EQ(trep2), and an F component mapping U to struct type t=X val x=e2 end : \nsig type t::EQ(X) val x:tops2 end then executing (*) will check trep and trep2 are equal and result in \na state with A mapped to struct type t=X val x=e end : sig type t::EQ(X) val x:tops end The notion of \ntype equality required is complicated by the fact that the representation types may themselves involve \nother abstract types. It is made precise in \u00a73, where it is also shown that it is not necessary to keep \nthe whole de\u00advelopment history in order to check it, but only modules actually referred to in coercions. \nNote that the coercion must involve a build-time check, dur\u00ading evaluation of module expressions, as \nm must be reduced to a structure to make its representation type available. 3 Formal Development In this \nsection the previous informal discussion is made pre\u00adcise by giving a language of interacting processes, \nmodules, and commands. It is equipped with build-time and run-time semantics, which are proven sound. \nThe full syntax is given in Figure 4. We begin by discussing the choice of constructs. Commands There \nare two command-line commands. Ex\u00adecuting the build command U:=m type-checks and evaluates the module \nexpression m and assigns the resulting module value to .lename U. Executing run U, where U is a .le\u00adname \nreferring to a previously-built main module, loads the process part of that module in parallel with the \nrest of the running system. The grammar includes also tau compu\u00adtation steps of the running system may \nbe interleaved with build and load commands. We have simpli.ed the system (in an unimportant way) by \nnot representing source code stored in .les, and (more signi.cantly) by not dealing with separate builds \nof module interfaces. Modules We take as simple a module language as possible: second class, with only \n.rst-order functors, without sub\u00adstructures, and with structures that have single type and term parts, \nnot general dependent records. We do include Commands Com ::=U:=m build run U load tau execute a step \n Structure signatures SS ::= [X::K,T] structure sig Module signatures S ::= SS .U:SS.S functor sig Kinds \nK ::= Type kind of all types EQ(T) kind of types equal to T Types T ::= X variable U.Type type part of \na structure [T..T]| int tuples and integers T chan | proc channels and processes Module expressions m \n::= U variable [T,e] as SS structure .U:SS.m:S functor mm application m:SS seal new x:T in m new channel \nm with! m version coercion Core expressions e ::= x variable U.term term part of a structure n integer \n[e .. e] tuple new x:T in e new channel 0 | e|e nil and parallel processes e!e | e?pat->e output and \ninput processes Core patterns pat ::= x | [pat .. pat] Typing environments E ::= empty | E,x:T | E,X::K \n| E,U:S U, X and x range over module, type and term variables re\u00adspectively. Module variables are also \nused as .lenames. The binding is as follows: in a structure sig X binds in T; ina functor sig U in S; \nin a functor U in m and S; in a new (module or core) x in m or e; and in an input the variables of pat \nin e . We work up to alpha conversion. Figure 4: Syntax singleton kinds, though both to allow non-trivial \nshar\u00ading between functor arguments and results, and so that the type equality check needed for with! \ncan be expressed. The structure [T,e] as [X::K,T2] is similar to our informal struct type t=T val x=e \nend : sig type t::K val x:T2 end It consists of a pair of a type T (of kind K) and a term e (loosely, \nof type {T/X}T2). The kind K here might be Type, making this a fully abstract structure with representation \ntype T hidden, or EQ(T ) for any T =T, revealing the rep\u00adresentation type. The type and term parts of \na structure variable U can be projected out by U.Type and U.term (if this can be given a type). The functor \n.U:SS.m:S is a dependent function taking structures of signature SS and returning modules of signature \nS, which may mention U. To these standard constructs we add a module-level new channel declaration and \nour with! coercion. The module\u00adlevel new allows uses of the newval of \u00a72.1 such as struct ... newval \nc : int chan end to be expressed as new c:int chan in ([..,c] as [..,int chan]) (this is a little awkward, \nhowever a channel carrying an abstract type must be declared in a di.erent structure than the type). \nThe module expression m with! m2, where m and m2 both have structure signatures, attempts to evaluate \nm and coerce it to provide an abstract type compatible with m2. Processes The core language is simply \nan asynchronous p-calculus with tuples, allowing communication on newly\u00adgenerable channels between parallel \noutputs and inputs. System States The state of the whole system is (exactly as in \u00a72.1) a triple N,F,e \nwhere N is a type environment of channel and type bindings (such as z : int chan and X::EQ(T)), F models \nthe union of all developers .lesystems as a .nite list of pairs of mod\u00adule ids and module values (with \nno repeated ids), and e is the running process expression. We take state triples up to alpha-renaming \nof the variables in dom(N). Module values are simply mval ::= [T1,e] as [X::EQ(T1 ),T2] .U:SS.m:S We \nwill never need to deal with mvals that have free mod\u00adule variables. Note that module variables and .lenames \nare punned. 3.1 Typing The type system for modules and processes is largely stan\u00addard, with judgements: \nE|-K E|-S sig K ' S ' E|-K <:: E|-S < sig K ' S ' E|-K == E|-S == sig E|-e:T E|-T::K E|-m:S E|-T == \nT ' :: K E|-ok E|-pat : T . E ' It includes subkinding, with EQ(T) <:: Type for wellformed types T, \na subsignature relation based on this that allows concrete type information to be forgotten, and a self-type \nrule for manipulating type equalities (expressed with single\u00adton kinds) in signatures. 3.1.1 Sharing \nWe .rst review the standard aspects of the type system the use of singleton kinds and subkinding to \nexpress ML\u00adstyle sharing; for further explanation we refer the reader to [HL94, Ler94, Ler96, Ler00, \nLil97]. The examples use alter\u00adnate notation T*T ' and (e,e ' ) for binary products [T,T ' ] and pairs \n[e,e ' ]. One can write structures that are either abstract or concrete: def A = [int,6] as [X::Type, \nX] |-A:[X::Type,X] def C = [int,6] as [X::EQ(int), X] |-C:[X::EQ(int),X] A here provides an abstract \ntype and a single value of that type; C is a pair of type int and value 6 of type int. To use a structure \nit must .rst be bound to a variable the language allows projections U.Type and U.term of the type and \nterm parts only of a structure variable U, not of an arbitrary module expression. If U has an abstract \nsignature, eg in the type environment U:[X::Type,X], then we know only U:[X::Type,X] |-U.Type :: Type \nU:[X::Type,X] |-U.term : U.Type This su.ces for typechecking a functor Fopaque that builds a new abstract \ntype: def Fopaque = .U:[X::Type,X]. [U.Type*U.Type, (U.term,U.term)] as [Y::Type,Y] |-Fopaque : .U:[X::Type,X].[Y::Type,Y] \n|-Fopaque A : [Y::Type,Y] Fopaque can also be applied to C, using the subsignature relation to ignore \nthe manifest type. |-Type <:: EQ(int) |-[X::Type,X] < [X::EQ(int),X] sig |-C : [X::Type, X] |-Fopaque \nC : [Y::Type,Y] A more interesting variant of Fopaque involves type shar\u00ading between argument and result \nwith a dependent functor signature, revealing that the type part of its result is the product of the \ntype part of its argument. def Ftrans = .U:[X::Type,X]. [U.Type*U.Type,(U.term,U.term)] as [Y::EQ(U.Type*U.Type),Y] \n |-Ftrans : .U:[X::Type,X].[Y::EQ(U.Type*U.Type),Y] Ftrans might be applied to a structure variable of \nan ab\u00adstract signature: U ' U ' :[X::Type,X] |-Ftrans : [Y::EQ(U ' .Type*U ' .Type),Y] or to a structure \nvariable of a manifest signature (here as\u00adsuming |-T::Type): U ' U ' :[X::EQ(T),X] |-Ftrans : [Y::EQ(T*T),Y] \nTo derive this one can .rst use the subsignature relation to make the argument signature of Ftrans match \nthe manifest signature of U ' |-Ftrans:.U:[X::EQ(T),X].[Y::EQ(U.Type*U.Type),Y] then make use of the \ntype equality U.Type == T in the result signature of Ftrans |-Ftrans : .U:[X::EQ(T),X].[Y::EQ(T*T),Y] \nOne can express binary functors that require their two ar\u00adguments to have equal type parts: def Fb = \n.U1:[X::Type,X]..U2:[Y::EQ(U1.Type),Y]. (U1.Type,U2.term) as [Z::Type,Z] so |-(.U:[X::Type,X].Fb U U) \nA : [Z::Type,Z] |-(.U:[X::Type,X].Fb U(Ftrans U)) A:[Z::Type,Z] |-/ Fb A A :S |-U(Fopaque U)) A :S /(.U:[X::Type,X].Fb \n More useful module examples quickly become rather ver\u00adbose, especially with our cut-down term language; \nwe do not include any here.  3.1.2 New, with!, and system states Turning now to the new aspects, the \nnew and with! module constructs have rules E,x : T chan|-m : SS - - - - - - - - - - - - - - - - - - \n- - - - - - - - - - m.new E|-new x: Tchaninm:SS E|-m :[X::K,T2] E|-m ' :[Y::EQ(T ' ),T2 ' ] - - - \n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - m.with E|-(m with! m ' ) : [X::EQ(T ' ),T2] \nThe .rst allows new channel declaration in a structure. The second allows m to be coerced to have the \nsame type part as m ' statically it always succeeds (if m ' is a value), leaving the build-time check \nto determine if the representation types are in fact compatible. Typing for a system state N,F,e requires \nthat (1) all module values in the .lesystem (which may have free channel or type names created earlier) \nhave the signature they claim; (2) the process e is a well-typed proc; and (3) N has only channel and \ntype names. . U . dom(F). N|-F(U) : sig(F(U)) N|-e : proc N atomic N has no module bindings - - - - - \n- - - - - - - - - - - - - - - - - - - - - - - - system |-N,F,e ok Here sig is the function that extracts \nthe signature of a module value, de.ned by sig( [T,e] as [X::K,T ' ] ) = [X::K,T ' ] sig( .U:SS.m:S ' \n)= .U:SS.S ' N|-(.U:SS1.m:S2) mval N|-[T1,e] as [X::EQ(T1 ' ),T2] N|-new x:T in m N|-[T1,e] as [X::Type,T2] \n (for Y . dom(N)) m =[T1,e ] as [X::Type, T2 ] m ' =[Z, e ' ] as [Y::EQ(Z),T2 ' ] N =N1,Z::EQ(TZ),N2 \ntypify(N)|-T1==TZ::Type : SS -. {mval/U}m -. [T1,e] as SS -. New x:T in m -. New Y::EQ(T1) in [Y,e] \nas [X::EQ(Y),T2] - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \nm.red.with! N|-m with! m ' -. [Z,e] as [X::EQ(Z),T2] Figure 5: Module reduction axioms m.red.beta m.red.seal \nm.red.new m.red.abstype and a type environment E is atomic if for all term variable bindings x:T in E \nthere exists T2 such that T=T2 chan.  3.2 Build and Run-Time Semantics The language semantics is expressed \nwith transitions Com' N,F,e -. N ' ,F ' ,e labelled by commands U:=m, run U, and tau, expressing how \nthe system state can change. The run-time semantics is straightforward, with transitions labelled by \ntau arising from p-calculus reductions e -.e ' . The build-time seman\u00adtics, for transitions labelled \nU:=m, is novel. It involves an auxiliary one-step reduction relation for module expressions, discussed \nin \u00a73.3, written N '' N|-m -. New inm ' N ' for m reducing to m with new channel or type names . Note \nthat the New here is part of the judgement, not N ' module syntax. Multistep reductions will be written \nwith the double arrow =.. In addition, we identify various error cases. Run-time errors are simply mismatched \ncommunica\u00adtions, e.g. x!3 | x?[y z]->e. Build-time errors arise when trying U:=m for a badly-typed m, \nor when the dynamic check of a with! coercion within m fails. Load-time errors arise when trying run \nU where U is not the .lename of a struc\u00adture containing a process. We omit details of the error cases, \nbut give the main transition rules: typify(N),env(F) |-m : S N |-F(m) =. New in mval N ' dom(N) disjoint \nfrom fv(m) and dom(N ' ) - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n- build U:=m N,F,e -. (N,N ' ),F . (U . mval),e F(U) = [T,e ' ] as [X::K,proc] - - - - - - - - - - - \n- - - - - - - - - - - - - - - - - - load run U N,F,e -. N,F,e|e ' e -. e ' - - - - - - - - - - - - - \n- - - - compute tau N,F,e -. N,F,e ' We discuss the key aspects of the build rule. Firstly, m is typechecked. \nIt may mention previously-built modules in dom(F), so this should be with respect to their signa\u00adtures. \nThese signatures may involve type variables in dom(N) previously generated for abstract types, but the \nrepresenta\u00adtions of those types should not be visible for typechecking. We write env(F) for the type \nenvironment mapping each U . dom(F) to sig(F(U)), and typify(N) for the type envi\u00adronment mapping each \nX . dom(N) to Type. Secondly, F(m) m with all .lenames replaced by the module values they refer to is \nreduced to mval. This may generate new type or channel names, which are propagated to the resulting state, \nand involves checking any coercions in m. Finally, the disjointness condition, and the fact that both \nthe N part of N,F,e and the N ' part of N |-F(m) =. New N ' in mval are treated as binders, ensure that \nall previously-generated names are alpha-converted away from the free names of m. 3.3 Module reduction \nModule reduction is de.ned by the axioms in Figure 5, with (roughly) evaluation contexts C ::= _|Cm2|mvalC|C:SS \n| C with! mval | m1 with! C and rule N '' N|-m -. New inm dom(N ' ) and fv(C) disjoint N|-C[m] -. New \nN ' in C[m ' ] The substitution in m.red.beta is nonstandard it also re\u00adduces any projections from structures \nthat are introduced by the substitution. Note the new type name generation of m.red.abstype, and the \ncheck in m.red.with! that the representation type T1 of m is provably equal to the repre\u00adsentation type \nTZ of the module m ' that m is being coerced to. As in build, this must be with respect to typify(N). \n(In fact, we have glossed over a subtlety m.red.abstype should not be used on the left of a with!; we \nensure this by splitting the reduction relation into two.) The dynamic check does require the representation \ntypes of any modules that are referred to to be stored (as part of a struct that is inaccessible except \nto the with! check), but as the equality check is wrt. typify(N) no other type equalities from the development \nhistory are needed. 3.4 Examples First, some examples of module reduction. For C as de.ned in \u00a73.1.1, \nthe structure [int, 6] as [X::EQ(int), X] is already a module value. For A there is a single reduction, \ncreating a new type id, to a module value: |-[int,6] as [X::Type,X] -. New Z::EQ(int) in [Z,6] as [X::EQ(Z),X] \nApplying Fopaque to C: |-Fopaque C -. {C/U}[U.Type*U.Type,[U.term,U.term]] as [Y::Type,Y] = [int*int,(6,6)] \nas [Y::Type,Y] -. New Z::EQ(int*int) in [Z,(6,6)] as [Y::EQ(Z),Y] Applying Fopaque to A, .rst A is reduced \n(creating a new type id), then there is a beta step, then another new type id is created. |-Fopaque A \n-. New Z::EQ(int) in Fopaque ([Z,6] as [X::EQ(Z),X]) -. New Z::EQ(int) in s([U.Type*U.Type,(U.term,U.term)] \nas [Y::Type,Y]) where s = {[Z,6] as [X::EQ(Z),X]/U} = New Z::EQ(int) in [Z*Z,(6,6)] as [Y::Type,Y] -. \nNew Z::EQ(int), W::EQ(Z*Z) in [W,(6,6)] as [Y::EQ(W),Y] Now consider the build commands C := C A := \nA (here C and A are module variables, used as .lenames, and C and A are, as above, abbreviations for \nmodule expressions). Executing these in the empty state New empty in (\u00d8,0) gives the state New Z::EQ(int) \nin (*) ({C.C,A . [Z,6] as [X::EQ(Z),X]},0) Subsequent build commands can then refer to the type and term \ncomponents of A and C, eg in B := [A.Type*C.Type,(A.term,C.term)] as [X::EQ(A.Type*C.Type),X] The module \nexpression on the right-hand side of this will be type checked in the environment Z::Type, C:[X::EQ(int),X], \nA:[X::EQ(Z),X] Rebuilding A will produce an abstract type that is di.erent from that of A executing \nA ' := A in the state (*) above results in New Z::EQ(int),Z ' ::EQ(int) in ({C.C,A . [Z,6] as [X::EQ(Z),X], \nA ' . [Z ' ,6] as [X::EQ(Z ' ),X]},0) A ' so executing U := Fb A will give a type checking error. On \nthe other hand, executing A ' := A with! A in the state (*) results in New Z::EQ(int) in ({C.C,A . [Z,6] \nas [X::EQ(Z),X], A ' . [Z,6] as [X::EQ(Z),X]},0) A ' and here U := Fb A will succeed. For a more interesting \nuse of with!, illustrating the fact that only the representa\u00adtion types must be equal, executing A ' \n:= [int,(7,8)] as [X::Type,X*X] with! A in the state (*) results in New Z::EQ(int) in ({C.C,A . [Z,6] \nas [X::EQ(Z),X], A ' . [Z,(7,8)] as [X::EQ(Z),X*X]},0) Finally, consider a module that provides an abstract \ntype, implementing it with a representation type that involves an abstract type from another module, \neg (again in state (*)) A2 := [A.Type*A.Type,(A.term,A.term)] as [X::Type,X] resulting in the state \nNew Z::EQ(int),W::EQ(Z*Z) in ({C.C,A . [Z,6] as [X::EQ(Z),X], A2 . [W,(6,6) as [X::EQ(W),X]},0) If one \nrebuilds A2 A2 ' := m with! A2 the m.red.with! rule checks that the representation type of m is equal \nto Z*Z, in an environment Z::Type,W::Type. Sim\u00adply checking that the representation type of m is equal \nto the underlying representation type int*int would be mistaken, as A may have been rebuilt, either with \nthe same invariants (and using with!) or changed (and not using with!). The examples above are arti.cial, \nwith useless abstract types, to illustrate the semantics. They should be enough to see how natural examples \n(which would be unfortunately lengthy) would go, however. 3.5 Soundness We state only the key lemmas \nand main soundness proper\u00adties of the semantics. Lemma 1 (module substitution) If E,U:S,E ' |-J for some \njudgement J, and E|-mval:S, then E,{mval/U}E ' |-{mval/U}J. Lemma 2 (term substitution) If E,E ' ,E '' \n|-e:T and E|-s:E ' , where s is a term substitution, then E,E '' |-se: T. Lemma 3 (module subject reduction) \nIf we have N|-m: S and N|-m =. New N ' in m ' and N,N ' disjoint then N,N ' |-m ' :S. Moreover if N atomic \nand has no module bindings then N,N ' is likewise. Lemma 4 (process subject reduction) If E is atomic \nand has no module bindings, E|-e:proc and e -.e ' then E|-e ' :proc. Com' Theorem 1 If |-N,F,e ok and \nN,F,e -. N ' ,F ' ,e then |-N ' ,F ' ,e ' ok. Theorem 2 If |-N,F,e ok then there is no transition tau \nN,F,e -. err(runtime error). There may of course be build-or load-time errors. 3.6 Relating separately-compiled \nand monolithic pro\u00adgrams A desirable property of systems for separate compilation is that splitting a \nprogram into separate compilation units is guaranteed not to change its type-correctness or behaviour. \nFor the language of this paper, a simple version of the prop\u00aderty is: Theorem 3 If m1 and m2 are structure \nexpressions m1 = [T1,e1] as [X::K1,T1 ' ] m2 = [T2,e2] as [X::K2,T2 ' ] and m2 ' = (.U1:SS1.m2:SS2) [T1,e1] \nas [X::EQ(T1),T1 ' ] where SSi is the signature of mi, then (. N,F,e. empty,\u00d8,0 U1:=m1-. U2:=m2-. N,F,e) \ni. ' (. N,F,e. empty,\u00d8,0 U2:=m2-. N,F,e) Note that one cannot take m2 ' to be simply (.U1:SS1.m2:SS2) \nm1, as if K1=Type and U1 is used in T2 ' this cannot generally be given a useful signature. Instead, \nthe abstraction is enforced solely by the argument signature of the functor. The interesting case of \nthe proof is the left-to-right direction for K1=Type taking also K2=/Type, the execution of U1:=m1 involves \nnew type name generation whereas the execution of U2:=m2 ' does not. We therefore have a tight link between \nthe generative view of abstract types, used in the separately-compiled version, and the singleton-kind \nview, in typechecking m2 ' . Intuitively, the two resulting module values F(U2) are syn\u00adtactically the \nsame modulo certain type equalities, but we do not make this precise here. One might also generalise \nthe result, giving translations between arbitrary module ex\u00adpressions and sequences of structure and \nfunctor build com\u00admands. This could then be contrasted to the result of Leroy [Ler96] relating the expressiveness \nof manifest-type\u00adbased and stamp-based static semantics for ML-style mod\u00adules. The latter involves new \nstamp generation during type\u00adchecking (elaboration) of a module expression. Conclusion In summary, we \nhave provided a solid basis for programming wide-area systems involving interaction at abstract types. \nIt required new constructs the versioning coercion and build\u00adtime channel generation and novel operational \nsemantics for module reduction and for build/load/compute-time sys\u00adtem state changes. We illustrated \nthese, demonstrating how they can be set up coherently, by giving a model language of processes, modules \nand commands, equipped with build\u00adand run-time semantics, and proving soundness. The work is a necessary \npreliminary for more re.ned treat\u00adments of numbered versions, and for extending traditional distributed \nsystems programming with communication of values of abstract types. Further Related Work We argued in \n\u00a72.3 that devel\u00adopers must in a limited way be able to break the ab\u00adstraction boundary of an abstract \ntype. The with! coercion does this, allowing new types to be made compatible with old, provided (a) their \nimmediate representation types are equal, and (b) the developer asserts no important invariants have \nchanged. The closest primitive in previous work seems to be the partial revelations of opaque types in \nModula 3 [CDG+89], allowing any opaque type to be made concrete (to a speci.ed subtype) within a scope. \nTurning to for\u00admal models, Cardelli [Car97] discusses linking and separate compilation in detail, but \nwithout module type components. The MTAL system of Glew and Morrisett [GM99] models linking for typed \nassembly language. It incorporates ab\u00adstract types, but has a .at namespace and does not deal with di.ering \nversions. There is therefore no need for ex\u00adplicit generation of type names. Other work on separate compilation, \nnotably [BA99, Dro00, Dug00, FF98, HWC00], focusses largely on name space and hierarchy issues, and on \ndynamic linking. Future Directions Firstly, it would be interesting to gen\u00aderalise the results of \u00a73.6, \nas indicated there, to arbitrary programs. The idea of the module reduction semantics may have other \napplications. In particular, it should permit a typed opera\u00adtional semantics for Cardelli and Leroy s \ndot-notation calculi [CL90]. Adding term-level annotations delimiting subterms that originated from abstract \ntypes, building on [ZGM99], may allow nice syntactic statements of abstractness proper\u00adties. One might \nhope to address .rst class modules [HL94, Lil97, Rus98]. Typed semantics for dot-notation would go some \nway towards this, but note that term-level execution here may involve distributed communication, which \nmay only make sense with respect to a local machine state. It is therefore desirable to be able to stratify \nexecution (in the extreme case of the language of this paper no core reduction is done at build time, \ntrivially preventing such distributed side-e.ects). As for extensions, for usability the system would \nhave to be extended to general dependent records and substructures, not simply binary translucent sums. \nDealing with named interfaces would allow more direct treatment of traditional IDLs, extended with abstract \ntypes. There are many prag\u00admatic issues of what development environment support is required to make the \nwith! coercion and its channel-name analogue usable; they will have to be investigated by exper\u00adiment. \nFinally, to address interface evolution and numbered versions, the system should be extended with subtyping, \nwith polarity on the types used for interaction (here these are the channel types, for which polarities \nhave been studied eg in [PS96, Ode95]), and with a type-level representation of a partial order. Acknowledgements \nI would like to thank Luca Cardelli, James Leifer, Benjamin Pierce, Claudio Russo, Keith Wans\u00adbrough, \nLucian Wischik, and Pawe.l Wojciechowski, for dis\u00adcussions and comments. References [AWWV95] J. L. Armstrong, \nM. C. Williams, C. Wikstr\u00a8om, and S. R. Virding. Concurrent Programming in Erlang. Prentice Hall, 2nd \nedition, 1995. [BA99] Matthias Blume and Andrew W. Appel. Hi\u00aderarchical modularity. ACM Transactions \non Programming Languages and Systems, 21(4):813 847, July 1999. [Car97] L. Cardelli. Program fragments, \nlinking, and modularization. In POPL 97, pages 266 277, January 1997. [CDG+89] Luca Cardelli, James \nDonahue, Lucille Glass\u00adman, Mick Jordan, Bill Kalsow, and Greg Nel\u00adson. Modula-3 report (revised). Technical \nre\u00adport, DEC SRC, September 1989. SRC-052. [CL90] L. Cardelli and X. Leroy. Abstract types and the dot \nnotation. In Programming Concepts and Methods, IFIP State of the Art Reports, pages 479 504. North Holland, \nMarch 1990. Also appeared as SRC Research Report 56. [Dro00] Sophia Drossopoulou. Towards an abstract \nmodel of Java dynamic linking and veri.\u00adcation. In Preliminary Proceedings of the Third Workshop on Types \nin Compilation (TIC 2000). CMU Technical Report CMU-CS-00\u00ad161, September 2000. [Dug00] Dominic Duggan. \nSharing in typed module as\u00adsembly language. In Preliminary Proceedings of the Third Workshop on Types \nin Compilation (TIC 2000). CMU Technical Report CMU-CS\u00ad00-161, September 2000. [FF98] M. Flatt and M. \nFelleisen. Units: Cool modules for hot languages. In PLDI 98, pages 236 248, 1998. [FGL+96] C\u00b4edric Fournet, \nGeorges Gonthier, Jean-Jacques L\u00b4evy, Luc Maranget, and Didier R\u00b4emy. A calculus of mobile agents. In \nProceedings of CONCUR 96. LNCS 1119, pages 406 421. Springer-Verlag, August 1996. [GM99] Neal Glew and \nGreg Morrisett. Type-safe linking and modular assembly language. In Conference Record of POPL 99: The \n26th ACM SIGPLAN-SIGACT Symposium on Prin\u00adciples of Programming Languages, San Anto\u00adnio, Texas, pages \n250 261, New York, NY, Jan\u00aduary 1999. ACM. [HL94] Robert Harper and Mark Lillibridge. A type\u00adtheoretic \napproach to higher-order modules with sharing. In Conference record of POPL 94: 21st ACM SIGPLAN-SIGACT \nSympo\u00adsium on Principles of Programming Languages, pages 123 137, January 1994. [HN00] Michael Hicks \nand Scott Nettles. Active net\u00adworking means evolution (or enhanced exten\u00adsibility required). In Proceedings \nof the Sec\u00adond International Working Conference on Ac\u00adtive Networks, October 2000. [HWC00] Michael Hicks, \nStephanie Weirich, and Karl Crary. Safe and .exible dynamic linking of native code. In Preliminary Proceedings \nof the Third Workshop on Types in Compilation (TIC 2000). CMU Technical Report CMU-CS\u00ad00-161, September \n2000. [Ler94] Xavier Leroy. Manifest types, modules, and separate compilation. In Conference Record of \nPOPL 94: 21ST ACM SIGPLAN-SIGACT Symposium on Principles of Programming Lan\u00adguages, Portland, Oregon, \npages 109 122, New York, NY, January 1994. ACM. [Ler96] Xavier Leroy. A syntactic theory of type gen\u00aderativity \nand sharing. Journal of Functional Programming, 6(5):667 698, 1996. [Ler00] Xavier Leroy. A modular module \nsystem. Jour\u00adnal of Functional Programming, 10(3):269 303, May 2000. [Lil97] Mark Lillibridge. Translucent \nSums: A Foun\u00addation for Higher-Order Module Systems. PhD thesis, CMU, 1997. CMU-CS-97-122. [MPW92] R. \nMilner, J. Parrow, and D. Walker. A calculus of mobile processes, Parts I + II. Information and Computation, \n100(1):1 77, 1992. [MTH90] Robin Milner, Mads Tofte, and Robert Harper. The De.nition of Standard ML. \nThe MIT Press, Cambridge, Mass., 1990. [Ode95] Martin Odersky. Polarized name passing. In Proceedings \nof FSTTCS 95. LNCS 1026, De\u00adcember 1995. [PS96] Benjamin Pierce and Davide Sangiorgi. Typing and subtyping \nfor mobile processes. Mathemat\u00adical Structures in Computer Science, 6(5):409 454, 1996. [PT00] Benjamin \nC. Pierce and David N. Turner. Pict: A programming language based on the pi\u00adcalculus. In Proof, Language \nand Interaction: Essays in Honour of Robin Milner. MIT Press, 2000. [Rus98] Claudio V. Russo. Types For \nModules. PhD thesis, University of Edinburgh, LFCS, 1998. ECS-LFCS-98-389. [Sew00] Peter Sewell. Modules, \nabstract types, and distributed versioning. Technical Report 506, University of Cambridge, 2000. Available \nfrom http://www.cl.cam.ac.uk/users/pes20/. [SWP98] Peter Sewell, Pawe.l T. Wojciechowski, and Benjamin \nC. Pierce. Location independence for mobile agents. In Proceedings of the Workshop on Internet Programming \nLanguages (Chicago), May 1998. Full version appeared in LNCS 1686. [US01] Asis Unyapoth and Peter Sewell. \nNomadic Pict: Correct communication infrastructure for mobile computation. In Proceedings of POPL 2001, \nJanuary 2001. To appear. [Woj00] Pawe.l T. Wojciechowski. Nomadic Pict: Lan\u00adguage and Infrastructure \nDesign for Mobile Computation. PhD thesis, Computer Labo\u00adratory, University of Cambridge, June 2000. \nAvailable as Technical Report 492. [WS00] Pawe.l T. Wojciechowski and Peter Sewell. No\u00admadic Pict: Language \nand infrastructure de\u00adsign for mobile agents. IEEE Concurrency, 8(2):42 52, April June 2000. Extended \nversion of a paper in ASA/MA 99. [ZGM99] Steve Zdancewic, Dan Grossman, and Greg Morrisett. Principals \nin programming lan\u00adguages: A syntactic proof technique. In Pro\u00adceedings of the Fourth ACM SIGPLAN Inter\u00adnational \nConference on Functional Program\u00adming (ICFP 99), volume 34.9 of ACM Sigplan Notices, pages 197 207, N.Y., \nSeptember 27 29 1999. ACM Press.   \n\t\t\t", "proc_id": "360204", "abstract": "In a wide-area distributed system it is often impractical to synchronise software updates, so one must deal with many coexisting versions. We study static typing support for modular wide-area programming, modelling separate compilation/linking and execution of programs that interact along typed channels. Interaction may involve communication of values of abstract types; we provide the developer with fine-grain versioning control of these types to support interoperation of old and new code. The system makes use of a second-class module system with singleton kinds; we give a novel operational semantics for separate compilation/linking and execution and prove soundness.", "authors": [{"name": "Peter Sewell", "author_profile_id": "81100511814", "affiliation": "Computer Laboratory, University of Cambridge", "person_id": "PP14177906", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/360204.360225", "year": "2001", "article_id": "360225", "conference": "POPL", "title": "Modules, abstract types, and distributed versioning", "url": "http://dl.acm.org/citation.cfm?id=360225"}