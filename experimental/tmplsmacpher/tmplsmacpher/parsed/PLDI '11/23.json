{"article_publication_date": "06-04-2011", "fulltext": "\n LeakChaser: Helping Programmers Narrow Down Causes of Memory Leaks GuoqingXu MichaelD.Bond FengQin \nAtanasRountev Department ofComputerScience andEngineering OhioStateUniversity {xug,mikebond,qin,rountev}@cse.ohio-state.edu \nAbstract In large programs written in managed languages such as Java and C#, holding unnecessary references \noften results in memory leaks and bloat, degrading signi.cantly their run-time performance and scalability. \nDespite the existence of many leak detectors for such languages, these detectors often target low-level \nobjects; as a re\u00adsult, their reports contain many false warnings and lack suf.cient semantic information \nto helpdiagnose problems. Thispaper intro\u00adduces a speci.cation-based technique called LeakChaser that \ncan not only capture precisely the unnecessary references leading to leaks,but also explain, withhigh-level \nsemantics, why these refer\u00adencesbecome unnecessary. At the heart of LeakChaser is a three-tier approach \nthat uses varying levels of abstraction to assist programmers with different skill levels and code familiarity \nto .nd leaks. At the highest tier of theapproach,theprogrammer only needstospecify thebound\u00adaries of \ncoarse-grained activities, referred to as transactions. The tool automatically infers liveness properties \nof these transactions, by monitoring the execution, in order to .nd unnecessary refer\u00adences.Diagnosis \natthistiercanbeperformedby anyprogrammer afterinspecting theAPIs andbasic modules of aprogram, without \nunderstanding of thedetailedimplementation of theseAPIs.Atthe middle tier, the programmer can introduce \napplication-speci.c se\u00admanticinformationby specifyingpropertiesforthetransactions.At the lowest tier \nof the approach is a liveness checker that does not rely onhigher-level semanticinformation,butrather \nallowsapro\u00adgrammer to assert lifetime relationships for pairs of objects. This task could only be performed \nby skillful programmers who have aclear understanding ofdatastructures and algorithmsinthepro\u00adgram. We \nhave implemented LeakChaser in Jikes RVM and used it to help us diagnose several real-world leaks. The \nimplementation incurs a reasonable overhead for debugging and tuning. Our case studiesindicatethattheimplementationispowerfulinguidingpro\u00adgrammers \nwith varying code familiarity to .nd the root causes of several memoryleaks even someone whohad not studied \naleak\u00ading program can quickly .nd the cause after using LeakChaser s iterativeprocessthatinfers andchecksproperties \nwithdifferentlev\u00adels of semanticinformation. Permission to make digital or hard copies of all or part \nof this work for personal or classroomuseisgranted withoutfeeprovided that copiesarenot madeordistributed \nforpro.tor commercial advantage andthat copiesbearthis notice andthefull citation onthe .rstpage.Tocopy \notherwise,torepublish,topostonservers ortoredistribute tolists, requiresprior speci.cpermission and/or \nafee. PLDI 11, June4 8,2011,SanJose,California,USA. Copyright c &#38;#169; 2011ACM978-1-4503-0663-8/11/06. \n. .$10.00 Categories and Subject Descriptors D.3.4 [Programming Lan\u00adguages]: Processors Memory management, \noptimization, run\u00adtimeenvironments; F.3.2[Logics and Meaning ofPrograms]:Se\u00admantics of Programming Languages \nProgram analysis; D.2.5 [SoftwareEngineering]:TestingandDebugging Debugging aids General Terms Language,Measurements, \nPerformance Keywords LeakChaser, memory leak detection, object lifetime assertions 1. Introduction A \nmemory leak in a managed language such as Java or C# occurs when references to some unused objects are \nunnecessarily held so thatthese objects cannotbegarbage collected.Memoryleaks crash programs when they \nexhaust the heap, and can frequently cause performanceissuesduetoincreasedgarbage collection(GC) runs \nand execution redundancies. Problem: lack of semantics in leak detection Memory leak detection inJava \nsoftware has recentlygained much interestin the programminglanguage andsystems communities[8,9,10,18,20, \n23,29,33,36].All existingdetectors except one[36] trackbehav\u00adiorsof arbitrary objects and reportproblems \nwhentracked objects become suspicious.One major category of work[8,9,10,18,33] considersobjects staleness(i.e.,timeelapsed \nsincetheprogram last used these objects) as an indicator of problematic behavior, while another category[20,23] \ntreats objects as suspiciousifin\u00adstances of their types exhibit sustained growth. Whileboth heuris\u00adtics \nare reasonable in many cases, they are not de.nitive evidence of leaking objects because many normal \nobjects can also exhibit suchbehaviors.For example,growing numbers ofinstances are not leaksiftheyare \nreclaimedlater.And someGUI widgets may never beused afterthey areinitialized,i.e.,theybecome very stale \nbut they are not necessarily leaks. In addition, these leak detectors at\u00adtempt to .nd root causes by \nstarting from the suspicious objects (i.e., the leak symptom) and traversing the object graph. Due to \nthe complexity of thegraph, this attemptis often aheuristics-based process that ends up reporting a sea \nof likely problems with the true causes being buried among them. Because a memory leak of\u00adten occurs \ndue to the inappropriate handling of certain events and these toolspro.le the wholeprogram execution \nwithout anyfocus, there is little hope that a completely automated tool can precisely pinpoint the problematic \narea(s) for large-scale Java applications. Whileprior work avoidsheuristicsbyfocusing on containers[36], \nthe root causes of many memory leaks are not containers, but in\u00adstead cached references that the programmer \nforgot to invalidate, as represented by the leak cases in SPECjbb2000 and Eclipse bug #115789(Section5). \nFor a more focused leak detector, itis necessary to take advan\u00adtage ofhumaninsights and useprogrammer \nspeci.cations toguide leakdetection. Whileprior workproposes heap assertions that can be checkedduringGC[3,5,30,35],theselow-levelassertions \nmay only be employed by programmers who have deep understanding of an application(e.g., algorithms,data \nstructures, etc.).This re\u00adquirement limits signi.cantly their usefulness inleakdetectionfor existing \nJava applications (i.e., because no prior assertions were writtenduringdevelopment), as veryfewperformance \nexpertshave suf.cient program knowledge to use these assertions during post\u00admortem tuning.  Insight \nAlmost all memory leaks we have studied are in regularly occurring program events: unnecessary references \ncan quicklyaccumulate and causethe memoryfootprinttogrowif each such eventforgets to clean up a small \nnumber of references. Thetechniquesproposedinthispaper arebased onthefollow\u00adingtwo observations aboutthesefrequentlyoccurring \ncode regions. First,in these regions there usually existimplicitinvariants among lifetimes of objects(e.g., \nobjects a and b must die together, or the old con.guration object must die before the new con.gura\u00adtion \nobjectis created ).When suchinvariants are violated, memory leaks result.Itisoften noteasytouse reachability-basedheap \nasser\u00adtions from prior work to express these lifetime relationships. Sec\u00adond,for each such region,there \noften exist objects that are strongly correlated with theliveness of the entire region.For example, con\u00adsider \na(web ordatabase) transaction in an enterprise Java applica\u00adtion.Atypicallifecycle consists of a sequence \nof events such asthe creation of the transaction object, the creation of all other objects usedin thistransaction, \nthedeallocation of these(other) objects, and thedeallocation ofthetransaction object.Forthislifecycle,the \ntransactionobjectisthe .rst onethatiscreated andthelast onethat is reclaimed, and it is thus the object \nthat controls the liveness of this entire transaction region. Our proposal We propose a three-tier approach \nthat exploits these insights to help a programmer quickly identify unnecessary references leading to \na memory leak. This approach can be used by both novices and experts to diagnose memory problems. The \nkey idea is to introduce high-level semantics by explicitly consid\u00adering coarse-grained events where \nleaks are observed. We refer to these events as transactions. As extensions of and inspired by enterprise \ntransaction models(e.g.,EJB transactions), our transac\u00adtions describe frequently executed code regions \nwith user-de.ned boundaries.Objects associatedwith atransactionfallintothree cat\u00adegories:(1) transactionidenti.er \nobject,(2) transaction-local ob\u00adjects, and(3)objects shared among transactions. The identi.er object \nof a transaction controls the lifetime of the transaction: all transaction-local objects shouldbe created \nafter this object is created and should die before it dies. Only shared objects are allowed to live after \nthe identi.er object dies. Next, we introduce the three tiers of our approach in descending order of \ntheir levels of abstraction, which is often the order in which a programmer uses our toolto solve a real-worldproblem. \nTier H (the high-level approach): At this highest level of the approach, our framework attempts to automatically \ninfer transaction-local and shared objects from the execution, while the programmer onlyneeds to specifytransactionboundaries \nandiden\u00adti.er objects. The tool starts to work in the inference mode, and once objects shared among transactions \nare identi.ed, it switches to check whether the(inferred) shared objects can actuallybe used in other \ntransactions.Violations are reportedifthese sharedobjects are not used for a certain period of time. \nThe programmer s task at thislevel is the easiest toperform: we found that even when we had not studied \na program before, we could quickly identify these (coarse-grained)eventsin order toperform thediagnosis. \nTier M (themedium-levelapproach): Inthistier,theuserneeds to specify not onlytheboundary of atransaction \nandthetransaction identi.er object, but also the objects shared across transactions, which the userdoes \nnot specifyin tierH. LeakChaser checks the given speci.cations, and reports viola\u00adtionsifthe speci.ed \ntransaction-local objectsin oneinstance ofthe transaction escape to another instance. While employing \nthis tier of the tool requires the user to have a deeper understanding of the program andthelikely cause \noftheproblem,it cangenerate a more precise report. Tier L (the low-level approach): This lowest level \nis essen\u00adtially an assertion framework that allows the user to specify life\u00adtimeinvariantsforfocused \nmemoryleakdetection.Theframework contains binary assertions that directly express object lifetime re\u00adlationships. \nForinstance, one important assertion is to specify that object a must die before object b. This assertion \nfails only when LeakChaser observes de.nitive evidence, e.g., b is dead while a is stilllive. Compared \nto reachability-based assertions [3, 5, 30, 35], our frameworkhas three advantages.First,passing/failing \nof our asser\u00adtionsdoes notdepend on whereGC runs are triggered and thus, as\u00adsertion checkingdoes notproducefalsepositives.Second,program \nlocationswhereour assertionsareplacedhavenoin.uence onthe evaluation of these assertions. For example, \nwe can assert that ob\u00adjecta diesbefore objectbimmediatelyafterthey are created, while a reachability-based \nassertion such as assertDead inprior workhas to beplaced in a location where the asserted object is about \nto be\u00adcome unreachable[3].Third,ourframework canbe used toassert arbitrary objects whose lifetimes are \ncorrelated due to some high\u00adlevel semantics(e.g., events), while a reachability-based assertion can work \nonly on objects that have low-level structural relation\u00adships(e.g., reachabilityin the objectgraph). \nOfcourse, usingthis assertionframework requires oneto under\u00adstand considerable design and implementation \ndetails of the pro\u00adgram such as how a data structure is constructed. However, per\u00adforming this level \nof diagnosis can give the user a very precise report. Hence, these assertions can be added by developers \ndur\u00ading coding, which may ease signi.cantly the diagnosis of mem\u00adory problems when performance degradation \nis observed. In fact, the transaction-basedpropertiesdescribedin the other two tiers are translated by \nour framework into these low-level assertions at run time.Section3presentsdetails about this translation. \nAs thelevel of abstractiondecreases(from tierH to tierL), the diagnosis becomes more focused. Figure \n1 illustrates the process of memoryleakdetection using thisframework.In our experience, LeakChaser is \nespecially useful to a performance expert who is unfamiliar with the program code, since he or she can \nfollow an iterative process that involves all these levels of diagnosis (i.e., from tier H down to tier \nL). The programmer starts with the tier Hanalysis withlittleprogramknowledge andinsight.By repeating \nahigher-level analysis afewtimes(with re.ned speci.cations) and inspectingitsreports,theprogrammergains \nadeeper understanding of the program as well as more insight into the problem, and then willbe ableto \nmove onto alower-level analysisfor a morefocused diagnosis. Very often, this process ends up narrowing \ndown the information to the exact cause of theleak. For large-scale applications, LeakChaser allows programmers \nto specify transactions at clients of these applications, without digging into application implementation \ndetails. For example, to diagnose problems in a large database system, the programmer only needs to create \ntransactions at client programs that perform database queries. We found that this feature of the tool \nis quite useful in simplifying the diagnostic task: all previous techniques require a programmer to understand \na fair amount of low-level details ofthe systembefore she can startthediagnosis.Thisburden is reduced \nsigni.cantlybyLeakChaser.   .  I a   L .  i . L Figure 1. Illustration ofthediagnosisprocess.Spirals \nateachlevel indicate that a user may need to run each tier multiple times with re.ned speci.cations(e.g., \nsmallertransaction regions, morepre\u00adcise shared object speci.cations, etc.)togain suf.cientknowledge \ntoproceed to alower tier. Implementation and experiments We implemented our ap\u00adproach in Jikes RVM 3.1.0 \n(http://jikesrvm.org ), a high\u00adperformance Java-in-Java virtual machine, and successfully ap\u00adpliedit \nto realleaksinlarge-scale applications such asEclipse and MySQL.Theimplementationtechniques arediscussedindetailin \nSection4.Section6 evaluates analysis expenses.We add one extra word in the header of each run-time object \nand this space is used to store the assertion information for the object. The overall space overhead \nof the tool is less than 10%, including both extra header space andmemoryusedto storethe metadata ofour \nanalysis.Using the optimizing compiler andtheImmixgarbage collector[6],the currentimplementationimposesanaverageslowdown \nof2.3\u00d7 for GConly and1.1\u00d7 for overall executionsfor theframeworkinfras\u00adtructure(i.e., no assertions added).Additionaloverheadisincurred \nfor checkingandinferringspeci.cations.For example, after adding assertions toSPECjbb2000,256,236 assertions \nwere executed, and overall slowdown was 5.5\u00d7. While the overhead is probably high forproduction runs, \nwefounditacceptableforperformance tuning and memoryleakdiagnosis. Section 5 presents six case studies \non real-world memory leak problems. Among these problems, four are true leaks and for the remaining two, \nprogrammers experienced high memory footprints but were not sure whether or not there were leaks. Using \nour tool, wehavequicklyidenti.edroot causesfor the trueleaks, andfound reasons that could explain the \nhigh memory consumption for the othertwo cases.InSPECjbb2000,in additiontothe already-known leak, we \nfound memory issues that have not been reported previ\u00adouslyandactuallycause more severeperformancedegradationthan \nthe already-known leak. Weobserved signi.cantperformanceimprovementsafter .xing theseproblems. The experimental \nresults stronglyindicate that the proposed three-tierdiagnosis methodology canbeadoptedinreal\u00adworld development \nand tuning to .nd and prevent memory leaks, andLeakChaseris usefulinhelpingaprogrammerquicklyidentify \nunnecessary references thatleadtoleaks andother memoryissues. The contributions of this work are: A \nthree-layer methodology that introduces different levels of abstraction to help both experts and novices \nunderstand and diagnose memoryleakproblems.  A new heap assertion framework that allows programmers \nto assert objectlivenesspropertiesinstead of usingreachabilityto approximateliveness.   An implementation \nof LeakChaser in Jikes RVM that piggy\u00adbacks ongarbage collection to check assertions.  Six case studiesdemonstratingthatLeakChaser \ncanhelpapro\u00adgrammer unfamiliar with the program source code to quickly .nd root causes of memoryleaks. \n 2. Overview We illustrate our technique using a simpli.ed version of a real\u00adworld memory leak(Eclipsebug \n#115789).Figure2(a)showsthe code that contains the leak. This bug can be easily reproduced on Eclipse \n3.1.2 when comparing the structures of two large JAR .les multiple times using an Eclipse built-in comparison \noption. Method runCompare implements a comparison operation(inplu\u00adginorg.eclipse.compare). Itisinvokedeverytime \nthe compar\u00adison option is chosen, and this information can be easily obtained fromtheEclipsepluginAPIs.Themethodtakes \naparameter oftype ISelection that containsinformationaboutthetwoselected .les tobe compared.A ResourceCompareInput \nobjectis .rst created usingthisparameter(line3).This objectisfairlyheavyweight asit cachesthecompletestructuresof \nthetwo .les.Thenamesof these .les are then recordedin alist visitedFiles (lines4and5), and this list \nmay be used by the workspace GUI upon receiving a user request to view thehistory. Next, openCompareEditorOnPage \nis invoked to open a com\u00adpare editor in the workspace GUI that shows the differences be\u00adtweenthetwo .les.The(simpli.ed)methodbodyisshownatlines \n11 17.Inthismethod,the newlycreatedResourceCompareInput object is cached in a NavigationHistoryInfo object \nretrieved from the current workbench page for future save or restore oper\u00adations(lines14 16).Caching \nthisheavyweightinput objectis ac\u00adtually the cause of the leak: the structures of the two .les keep being \ncreated and referenced. As a result, the memory footprint growsquickly, andEclipse runs outofmemory.Notethatinthe \nreal Eclipse code, this cache operation(atline16)andthe runCompare method are in two different plugins, \nwhich makes it particularly hard to diagnose the problem as these plugins are written by dif\u00adferentgroups \nofprogrammers.The twoplugins communicate only through public interfaces and it is unclear to programmers \nof one plugin what side effects the other plugin can have. It is inter\u00adesting to see that despite the \nfact that the developers of plugin org.eclipse.compare are aware that the input must be cleared afterthe \ncomparison(e.g.,infact,the comment atline8isfromthe real code), these references are still unnecessarilykept \nsomewhere out of their scope. While thesepluginshavebeen studiedinprevious work[8,20], we start with \nthe tier H approach to simulate what a programmer would do at the beginning of a diagnostic task. Hence, \nour experi\u00adence with this case, to a large degree, re.ects how a programmer unfamiliar with a program \ncan use the tool to diagnose memory leaks. We .rst need to identify a transaction and let the tool infer \nunnecessaryreferencesforthetransaction.Thisis easy: asthe com\u00adparison is the regularly occurring event \nleading to the leak, it is a natural idea to let the transaction cross the entire body of method runCompare, \nas showninFigure2(a).Atransaction creation(at line 2)takes two parameters: a transaction identi.er object \nand a modein which the transaction works.Theidenti.er object mustbe unique per transaction and must be \ncreated before the transaction starts.Here we choose s tobe theidenti.er object,because s refers to an \nISelection object thatis createdper comparison operation before runCompare runs. Constant INFER informs \nthe tool to run intheinference mode.Wefoundthattheidenti.er objectis usually easy to .nd for a transaction: \na transaction body often crosses a method thatisinvoked on an existing object.In many cases, either the \nreceiver object or a parameter object of the method can be se\u00ad  . . . 1 C 3     w  1 d 5 \n          (    3    C  w   5              w     (    31  \n          r w a  1 a v m 3  v     m Figure 2. Overview of the technique,illustrated \nusing a simpli.ed version ofEclipsebug#115789. lectedasthetransactionidenti.er object(aslongasitis createdper \n--> Type: Object[], created at: ArrayList: <init>(I), ln 119 transaction anddoes not cross multiple transactioninvocations). \n--> Type: NavigationHistoryEditorInfo, created at: NavigationHistory: createEntry(...), ln 553 For each \ntransaction, its spatial boundary is speci.ed by apair --> Type: ResourceCompareInput, created at: CompareAction: \nofcurlybrackets(i.e., {...})andits temporalboundary isde.ned runCompare(ISelection), ln 3 by the lifetime \nof its identi.er object. To .nd unnecessary refer\u00adences,wefocusonobjectscreated withinitsspatialboundary,and \nThisreferencepathmakesiteasytoexplainwhythis Resource check theirlifetimes againstits temporalboundary. \nInformally, the CompareInput object is shared: the reference path exists because semantics of a transaction \nis such that each transaction-local ob-theobjectiscached(transitively)by a NavigationHistory ob\u00ad ject \nmust die1 before the identi.er object, and only shared objects ject. However, this is not the only violation \nin the tier H report. canliveaftertheidenti.erobjectdies.Intheinferencemodewhere Thetwostringscreated \natlines4 and5(togetherwith many other aprogrammer does not explicitly specify local and shared objects, \nobjects)are also in the report as they are not used at all if there is ourtoolinfersshared objectsautomatically: \nobjectscreated within nouserrequesttoperformhistory-relatedoperations.Ittakessome thespatialboundaryaretreatedassharedobjectsiftheyarestilllive \ntimetoinspectthisreport,asitcontainsatotal of36 violations. atthetimetheidenti.erobjectdies.Onceanobjectismarked \nas Byrankingviolations(basedonfrequenciesandotherfactors),itis shared, the tool starts tracking its staleness \nand recordsaviolation nothardforustoeliminatemany of themthat areloweronthelist ifitisnotusedforagivenperiodoftime,basedontheintuitionthat \nand thatareobviously notleaks.Forexample,afterinspecting the objectsthat onetransactionintendstosharewithothertransactions \nwarnings,wedeterminethatthesesmall strings(and othersimilar shouldbeusedoutsidetheircreatingtransaction.Violationsareag-objects)arenotthemajorcauseof \ntheleak,becausethegrowth of gregatedand eventually reportedintheorderof theirfrequencies. used memory \nissosigni.cantthatitisunlikely tobeduetosmall Thefollowing exampleshowsatypical violationreportthatin-objects(especiallybecausetheirfrequenciesarenotsigni.cantly \ncludesinformationaboutthetransactionwheretheviolatingobject higher). iscreated,itscreationsite,violationtype,thenumberof \ntimesthis Asweobtainthisknowledge(regarding thesestringsand other violationoccurs,andthe(heap)referencepathsthatleadtothisob-irrelevantviolating \nobjects),wemovedowntotierMforamore jectatthetimeoftheviolation.Eachlineinareferencepathshows focused \nanalysis.InFigure2(b),weexplicitly markthesestrings theinformationof anobjectonthepath.Whileonly onereference \n(andotherscreatedby thetwo add calls)as shared(with a share pathisshownhere(forillustration)forthisviolation,multiplepaths \nregion)andletourtool runinchecking mode.Objectscreatedin wereactuallyreportedbythetool. thetransactionbutnotintheshareregionaremarked(implicitly) \nas transaction-local objects. Our tool then ignores objects marked Transaction specified at: as shared \nand reports violations only when transaction-local ob\u00ad2 CompareAction:runCompare(ISelection), ln jects \narefound live after the transaction identi.er objectdies.This Violating objects created at: gives us \na much cleaner report(with4 violations), and of course, CompareEditorInput:createOutlineContents (widgets.Composite), \nln 439 the violation shown earlier appears in the report, indicating the Violation type: ResourceCompareInput \nobject is referenced from somewhere Objects shared among transactions are not used else. Frequency: 4 \nAfterthese two rounds ofdiagnosis, wehavegainedimplemen- Reference paths: Type: ArrayList, created at: \nNavigationHistory: tationknowledge(e.g.,thegeneralprocedure ofperforminga com\u00ad<init>(WorkbenchPage), \nln 44 parison operation) and some insights into the problem (e.g., this leak might be caused by an unnecessary \nreference somewhere in 1In this paper, an object is considered to die immediately after it becomes NavigationHistory). \nDuringcode inspection, we become inter\u00adunreachableintheobjectgraph. estedinthecommentsinline8 ofthecode:thisstatementhasa \n clearpurpose of releasing theinput object,but whydid we seeitis still reachable inboth tierM and tierH \nreports? Having thisques\u00adtion in mind, we decide to perform a detailed (tier L) diagnosis using alifetime \nassertion(e.g., assertDB asserts a dies-before relationship), as shown in Figure 2(c). This single assertion \nfails, which con.rms our suspicions. After some code inspection(with thehelp of the referencepath associated \nwiththe violation), wefound that NavigationHistory allows a user to step backward and forward through \nbrowsed ed\u00aditor windows. It keeps a list of NavigationHistoryEntry ob\u00adjects, each of which points to \nan EditorInfo object that, in turn, points to a CompareEditorInput object, the root of a data structure \nthat holds the diff results. NavigationHistory uses a count to control the number of EditorInfo objects \nit caches, and removes an EditorInfo if the count drops to zero. However, NavigationHistory does not \ncorrectly decrement this count in some cases,leading to unnecessary references.objects. This example \nclearly shows the dif.culty of diagnosing real\u00adworld memory problems. The root cause of this bug is that \nthe NavigationHistory entries are cached and not getting removed due to reference-counting problems. \nThis occurs entirely on the UI side. The developers of the compare plugin may have never thought that \ncalling a general interface to open an UI editor can causeabig chunk of memory tobecached.Thecomplexity \nof the large-scale code base and the limited knowledge of each individ\u00adualdeveloper strongly callforLeakChaser \ns step-by-step approach. Such tool support can help a programmer who starts without in\u00adsights into the \nprogram or its leak, to systematically explore the leakybehaviorin order topinpointits cause. 3. Assertions \nand Transactions This sectionpresents aformalismtodescribe our analysis ofunnec\u00adessary references. The \npresentation proceeds in three steps. First, wede.ne a simplegarbage-collected language assert and its \nab\u00adstract syntax. We next give a semantics of this language by focus\u00ading on its traces.Each traceisasequence \nofbasicevents(e.g.,al\u00adloc,dealloc,and use) onobjects,transaction events(e.g.,startand end), and assertions. \nFinally, we formulate assertion checking and inference of unnecessary references asjudgments on traces(i.e., \ntrace validation). Note that in our implementation (discussed in Section4),checking andinferenceareperformedduringGC \nruns. Here the trace collection phase and the trace validation phase are separatedfor ease ofpresentation \nandformaldevelopment. Language assert The abstract syntax and the semantic do\u00admains for language assert \nare de.ned in Figure 3. The program has a .xed set of global reference-typed variables. An allocation \nsitehas theform a = new refo , where o standsfor an allocation site IDde.ned at compile time. There are \ntwo types of assertions: assertDB and assertDBA. assertDB(a, b)assertsthat object(pointedtoby) a must \ndie be\u00adfore(ortogether with) object(pointed toby) b. object a must die before a new object is created \nby object b s allocation site (i.e., it is short for Dies Before Allocation ). This assertion is useful \nto enforce a replaces relationship between two objects. For ex\u00adample,it canbe usedto enforcethat an old(invalid) \nscreen con\u00ad.guration is appropriately released before a new screen con.gura\u00adtion is created upon repainting \nof an interface in a GUI program. As another example, in Figure 2(c), instead of using assertDB, we can \nalso write assertDBA(fInput, fInput)to assert that the current ResourceCompareInput object must die before \nthe next ResourceCompareInput object (created by the same allocation site) is allocated. While our framework \nincludes a few other as\u00adsertions, they are not discussed because they can be implemented using these \ntwobasic assertions. Variables a, b . V Allocation sites o . O Instance .elds f . F Labels l . N Assertions \ne ::= assertDB(a, b)|assertDBA(a, b) Transactions t ::= transaction(a, m){tb } Transbodies tb ::= s ;tb \n|share {s }tb |o Trans modes m ::= CHECK|INFER Statements s ::= a = b |a = new refo |a = null |while \n... |a = b.f |a.f = b |e |gc|if ... |s ;s Program p ::= s ;p|t ;p|o (a) Labeled object o ::= o l . F \nEnvironment . . V . F .{.} Heap s . F\u00d7 F . F .{.} Operation t ::= (o ,A |D |U)o |(o , m,S |E)t |(S|E)s \n|(o a , o b ,DBA |DB)a Traces a ::= t , a |o (b) Figure 3. A simple assert language:(a) abstract syntax(b) \nse\u00admanticdomains. To easetheformaldevelopment, aGCrun can onlybetriggered by a gc statement, which traverses \nthe object graph to reclaim unreachable objects. Note that we do not allow the nesting of transactions. \nWhile this is easy to implement in our framework, wehave notfoundithelpfulforpinpointing memoryleak causes. \nEach run-time objectislabeled withits allocation site(e.g., o) and aninteger(e.g., l),denotingtheindexof \nthisobject among all created by the allocation site. Environment and heap are de.ned in standard ways. \nA trace is a sequence of operations. There are four types of operations, each of which is a tuple annotated \nwith a type symbol: o for object operation, t for transaction operation, s for share region operation, \nand a for assert operation. Each object operation is an object and event pair, where an event canbe either \nA(i.e.,Alloc), D(i.e.,Dealloc), or U(i.e.,Use). Each transaction operation is a triple containing its \nidenti.er object, the mode(i.e., CHECKorINFER), and whether this operation corresponds to the start of \nthe transaction(S) or its end(E).A share region operation has only a type that indicates whether it is \nthe start or the end of the region.Each assert operation contains twoinput objects and an assertiontype(DBAfor \nassertDBA andDBfor assertDB).While the language does not explicitly consider threads, our analysis is \nthread-safe as each transaction creation is a thread-local event. Different transaction instances created \nby different threads can exist simultaneously for the same transaction declaration. Trace collectionand \nvalidation arealsoperformed onaper-threadbasis. A special symbol . is added to the heap and the environment \nto represent a null value. Language semantics An operational semantics is given in Figure4.Ajudgmentoftheform \ns, ., s, a.. ' , s ' , a ' starts with a statement s, whichisfollowedby environment .,heap s, and trace \na.The execution of s terminates with a .nal environment . ' ,heap s ' , and trace a ' .Trace concatenationisdenoted \nby .. Rules NEW, ASSERTDB, ASSERTDBA, and COMP are de.ned as expected. In rules LOAD and STORE, trace \na is augmented with an object use event. In rule TRAN, for each transaction, the two transaction events \n(i.e., S and E) are added in the beginning and at the end of the trace for the execution of the sequence \nof statements in the transaction. The share region events are handled in a similar way (inruleSHAREREG).RuleGCremovesunreachable \nobjectsfrom theheap, and recordsdeallocation eventsfor themin the trace a. a ' o, A)o . :( o.allocsite \n) . p = a.( o1 o1 , o. allocsite = o = o.l newObjIndex(o) (NEW) a = new refo ,.,s,a . .[a . o ],s,a ' \na = b.f,.,s,a . .[a . s(.(b).f)],s,a .(.(b), U)o (LOAD) a.f = b,.,s,a . .,s[.(a).f . .(b)],a .(.(a), \nU)o (STORE) s,.,s,a .(.(a), m,S)t . . ' ,s ' ,a ' a '' = a ' .(.(a), m,E)t (TRAN) transaction(a, m){s},.,s,a \n. . ' ,s ' ,a '' a '' s,.,s,a .(S)s . . ' ,s ' ,a ' = a ' .(E)s (SHAREREG) share{s},.,s,a . . ' ,s ' \n,a '' assertDB(a,b),.,s,a . .,s,a.(.(a),.(b), DB)a (ASSERTDB) assertDBA(a,b),.,s,a . .,s,a.(.(a),.(b),DBA)a \n(ASSERTDBA) tr = o, D)o | s . . .{( o . o/reachable(.,s)} .(o, D)o . tr : o/. s ' a ' = a.tr (GC) gc,.,s,a \n. .,s ' ,a ' s1 ,.,s,a . . ' ,s ' ,a ' s2 ,. ' ,s ' ,a ' . . '' ,s '' ,a '' (COMP) . '' ,s '' ,a '' s1 \n; s2 ,.,s,a . Figure 4. Operational semantics. Trace validation Checking and inference of unnecessary \nref\u00aderences areformulated asjudgments .,.,p,. .a . . ' , . ' ,p ' ,. ' on traces.Here a is an execution \ntrace, . is a stack of transactions and share regions, . isa diesBefore mapinwhich eachpair(o a , o b \n)hasbeenasserted tohavea diesBefore relationship(i.e., o a must die before o b ),p is a diesBeforeAlloc \nmap which contains pairs(o a, o)where object o a has been asserted to die before allo\u00adcation site o creates \na new object, and . maps each object that has been marked shared(i.e.,ininference mode) toitsstaleness \nvalue (measuredin terms ofthe number oftransactions).As we currently do notsupport nestedtransactions, \n. can contain at most onetrans\u00adactionidenti.er object(and one .symbolindicating the execution isin a \nshare region).Transaction nestingcanbeimplemented easily by allowing . to contain multipleidenti.er objects. \nThe validation rules are given in Figure 5. Validity checks are underlined, and the remaining clauses(withoutunderlines) \narefor environment updates. Rule VALLOC .rst ensures that if an object o 1 hasbeen asserted todiebefore \nthis allocation site creates a new object(i.e.,dueto an assertDBA assertion), o 1 is notlive anymore. \nA violationis recorded if thereis such an object.If . is not empty (meaningthe executionis currentlyin \na transaction) and top(.)is not . (meaningwe arenotin ashare region), apair(o , top(.))is added to map \n. because, as mentioned earlier, all transaction-local objects are asserted to die before the transaction \nidenti.er object, and top(.)returns theidenti.er object of the current transaction. VDEALLOC removes \nall entries ( o, *) in the three maps upon the deallocation of o . If there is no running transaction, \nor the running transaction is in CHECK mode, this rule checks if there exists (o 1 ,o )...Ifthisisthe \ncase, a violationisreported,because o 1 is still live at the time o dies. If the running transaction \nis in INFER mode, such o 1 is marked as a shared object and the tool starts to trackits staleness: apair \n( o1 , 0) is added to map .. RuleVTRANS.rstpushesthetransactionidenti.erobjectonto stack ..Itthenaddsa \ndiesBeforeAlloc assertionontheidenti.er objectitself:adding apair( o.allocsite )indicatesthatthis current \no, instance o is asserted to die before allocation site cre\u00ad o.allocsite ates a new object. As the lifetimes \nof transaction identi.er objects ' . = . .( o,top(.)),if . = \u00d8.top(.) .= ' . = ., otherwise (VALLOC) \n.,.,p,. .(o, A)o .,. ' ,p,. ' . = .\\{( o,*)} p ' = p\\{( o,*)} .o 1 : ( o1 ,o ) . . . . ' = .\\{( o,*)},if \n. = \u00d8.MODE = CHECK . ' =(.\\{( o, *)}) .{( o1 ,0) |( o1 ,o ) . .}, otherwise .,.,p,. .( .,. (VDEALLOC) \no, D)o' ,p ' ,. ' . ' p ' p.( o.allocsite ) = . .o MODE = m = o, . ' = .[.p : p . .( p) + 1] (VTRANS) \n.,.,p,. .( . ' ,.,p,. ' o,m, S)t . = . ' .o .p . dom(.): .( p) < T (VTRANE) .,.,p,. .( . ' ,.,p,. o,m,E)t \n. ' = .\\{( o,*)} (VUSE) .,.,p,. .( .,.,p,. ' o, U)o.,.,p,. .(S)s . ..,.,p,. (VSHARES) . = .. . ' (VSHAREE) \n .,.,p,. .(E)s . ' ,.,p,. .,.,p,. .(o 1 ,o 2 ,DB)a .,. .{( o1 ,o 2 )},p,. (VDB) .,.,p,. .(o 1 ,o 2 ,DBA)a \n.,.,p .{( o1 ,o 2 .allocsite )},. (VDBA) .,.,p,. . t . ' ,. ' ,p ' ,. ' . ' ,. ' ,p ' ,. ' . a . '' ,. \n'' ,p '' ,. '' .,.,p,. . t,a . '' ,. '' ,p '' ,. '' (VTRACE) where . . Transaction stack: N . F.{.} \n. . diesBefore map: F . F p . diesBeforeAlloc map: F . O . . Staleness mapfor shared objects: F . N MODE: \nModeof transaction(CHECK orINFER) T: Threshold staleness value Figure 5. Checking andinferring of unnecessary \nreferences. areusedto specifytemporalboundaries oftransactions,they are not allowed to overlap. Lifetime \noverlapping can lead to ambiguity of transactionbehaviors.For each objectinferredtobe a shared object \n(i.e., p . dom(.)), its staleness value is incremented. An object s stalenessisde.ned as the number of \ntransactions since ithasbeen marked as shared. At the end of each transaction (rule VTRANE), this staleness \nvalue is checked against a user-de.ned threshold T. A violation is reported if a shared object s staleness \nexceeds this threshold. This rule also pops stack .. This stack becomes empty after this rule,indicating \nthat no transactionis currently running. VUSE removes from . an object marked as shared: its stal\u00adeness \nis no longer tracked because the object is used. Rules VSHARES/VSHAREEpush/pop . onto/from stack .. Having \n. on top of . means the execution is in a share region of a trans\u00adaction. Rule VTRACE speci.es the composition \nof two different traces. Our system allows one to specify transactions and assertions simultaneously \ninaprogram.Transactionproperties aretranslated into basic assertions, which are checked together with \nassertions speci.ed by programmers. For example, upon the allocation of each object o in a transaction \n(shown in VALLOC), o and the transactionidenti.er object(i.e.,top(.))are addedinto map ., and  .  \n  . ................ l m t  Figure 6. Assertiontableimplementationthat allowsquick asser\u00adtion checks. \nthis relationship is checked in exactly the same way as a normal assertDB assertion(showninVDB). 4. Implementation \nWe have implemented LeakChaser in Jikes RVM 3.1.0, a high\u00adperformance Java virtual machine [1]. LeakChaser \nis publicly available on theJikesRVMResearchArchive.2 Metadata and instrumentation LeakChaser adds one \nword to the header of each object that tracks the allocation site informa\u00adtion of the object. There are \ntwo dynamic compilers in Jikes that transform Java bytecode into native code. The baseline compiler compiles \neach method when it .rst executes. When a method be\u00adcomeshot(i.e., executedfrequently),the optimizing \ncompiler re\u00adcompiles it at increasing levels of optimizations. LeakChaser adds instrumentation to both \ncompilers. LeakChaser adds instrumenta\u00adtion at each allocation site that stores an identi.er for the \nsource codelocation(class, method, andline number) intothe allocated object s extraheader word. Garbage \ncollection LeakChaser performs assertion checks duringgarbage collection runs.It uses atable structure(discussed \nshortly) to represent the assertions, and scans this table toperform checks at the end of eachGC run. \nToimplementquick assertion checks, we create an assertion ta\u00adble, shown in Figure 6, to record asserted \ndiesBefore and dies-BeforeAlloc relationshipsduringthe execution.Once apair ofob\u00adjectsis asserted, we \ncreate an assertiontable entryfor eachofthem, and thenupdatetheLeakChaser-reservedheader wordineach ob\u00adject \nwiththe address of the object s corresponding assertion table entry.Thepointer to the source code information \nof the object ini\u00adtially storedinthisspaceismoved toa .eld of thistableentry. Foreach tableentry,weletits \nassertionelementpointer .eld pointto alinkedlistof assertion elements, each of which represents an object \nthat has been asserted together with this object. For example, for an assertion assertDB(a, b), we create \nan assertion element(DB, idb , null) and store its address in a s assertion table entry. Once a new assertion \nassertDBA(a, c) is executed, a new assertion element(DBA, idc , null) is created and appended to the \nlist(i.e.,nowthepreviouselement snext .eldpointstothisnew element). In this way, all objects that have \nbeen asserted through assert...(a,...) are in an assertion chain that is going to be checked when a s \nentry is traversed. We do not need to create an assertion element representing a and associateitwith \nband c stable entries, as this unnecessarily duplicatesinformation. The current implementation of LeakChaser \nsupports all non\u00adgenerationalgarbage collectors(e.g.,MarkSweep,MarkCompact, and Immix). At the end of \neach GC run, the assertion table is 2http://www.jikesrvm.org/Research+Archive scanned twice: the .rst \nscan marks entries that correspond to ob\u00adjectsthat are unreachableinthisGC(i.e.,dead objects), andthe \nsecond scan performs violation detection. Hence, in the second scan, all table entries represent live \nobjects. In order to slow down thegrowth of the assertion table, table entries corresponding to un\u00adreachable \nobjects are reclaimed and reassigned later to newly as\u00adserted objects.Our currentimplementationdoes not \nwork correctly in agenerationalgarbage collector, as a nurseryGCscans onlypart of the heap and thus may \ncause LeakChaser to report either false positives orfalse negatives. For each entry, its assertion element \nchain is traversed. For an element whose typeis DB,if the object represented by this element hasbeen \nreclaimed, we report a violation.Itis much moredif.cult to check a DBA assertion.We create aglobal array(per \nthread) and each entry in this array records the status of an allocation site. Once an assertDBA(a, b) \nassertion is executed, the array entry corresponding to b s allocation site is marked as ASSERTED . When \nthis allocation site creates a new object, the status of its array entryischanged to ALLOCATED .During \nthescanning of the assertion table,for an assertion element(DBA, i, *), a violation is reported if the \nentry of this global array corresponding to the allocation site of the object whose assertion table entry \nid is i is ALLOCATED , because it creates a new object before the asserted objectdies.Nofalseinformation \ncan resultfrom assertion failures reportedby the toolbecause the assertionsdirectly specify theliveness \nof objects(instead of reachability on the objectgraph) and report violations only whende.nitive evidenceis \nobserved. In thispaper, wefocus on the real-world utility ofLeakChaser, rather than its performance. \nHence, this assertion table is scanned during everyGC.Future work coulincorporate sampling to reduce \noverhead(i.e., scanthe assertiontablelessfrequently).To report the reference paths that lead to a violating \nobject, we modify the worklist-based algorithm used by the tracing collector in a way so thatwhen a reachable \nobjectis addedintothe worklist,its reference path(from which itis reached)is also added(to another worklist). \nThelength of thispath can be determined by the user. Wedevelop a technique that aggregates violations \nof objects that are createdby the same allocation sites and whose referencepaths match, sothat a violationis \nreported only afterits(aggregated)frequency exceeds a user-de.ned threshold value. LeakChaser .lters \nout violations that areassociated withVM objects.Futurework could consider more powerfulaggregation and \nrankingfunctions, such as a combination offrequency, staleness, andthe amount of memoryleaked.In order \nto make LeakChaser work for a generational GC, future work could perform the two assertion table scans \nseparately: the .rst scan(that marksdead objects) wouldbeperformed atthe end of everyGC, whilethe second \nscan(that checks assertions anddetects violations) would be performed only at the end of each full-heap \nGC. 5. Case Studies Wehave evaluatedLeakChaser on six real, reportedmemoryleaks. While our ultimate goal \nis to evaluate with enterprise-level appli\u00adcations such as application servers andprograms running on \ntop of them,JikesRVMfails to run somelarger server applications(such as trade in thelatestDaCapobenchmark \nset[7]). For these six cases, we also appliedSleigh[8], apublicly avail\u00adableresearch memoryleakdetectorforJava.Sleigh \n.ndsleaksby tracking the staleness of arbitrary objects and reporting allocation andlast-use sitesfor \nstale objects. For each case, we compared our report with the report gener\u00adatedbySleigh,andfound that \n.rst,forthesameamount of running time,information reportedby our(eventierH) approachis much more relevant \nthan that reported by Sleigh. Sleigh requires much more time to collectinformation andgenerate relativelyprecise \nre\u00ad  Case #Tran #TO #LO #SO #V #F    Diff 8 2048148 1707244 340904 36 14 Jbb 4346 256236 186752 \n69484 14 4 Editor 12 512471 506620 5851 2 13 WTP 20 2774556 2767237 7319 27 39 MySQL 10000 319529 170902 \n148627 11 0 Mckoi 100 2689366 2243888 445478 10 193 Table 1. Tier H statistics for transactions for the \ncase studies. Shown arethe number oftransaction runs(#Tran),thetotalnumber of objectstracked(#TO),the \nnumber oftransaction-local objects (#LO),the number ofshared objectsinferred(#SO),the number of violations \nreported after .ltering(#V), andthe number of violations .lteredby our .ltering system(#F). portsbecauseitisdesignedforproduction \nruns and uses only one bitper objectto encodeinformation statistically,whereasLeakCha\u00adsertracks much \nmoreinformationfordebugging andtuning(at a higher cost).Wedidnot runSleighfor as much time asin theprior \nwork[8],and thusSleigh results aredifferentfromthose reported earlier. Second, our iterative technique \nproduces more precise in\u00adformation ateachtier, which eventuallyguides ustothe root causes ofleaks. Experience \nsummary Wefound thatitisquite easy to specify transactionsinlargeprograms evenfor users whohave never \nstud\u00adied the programs before. From our experience using LeakChaser, we generalize an approach that can \nbe employed by performance experts to select transactions. All large-scale applications we have studied \ncan be classi.ed into two major categories: event-based systems(e.g., web servers andGUI applications) \nand transaction\u00adbasedsystems(e.g.,enterpriseJava applications anddatabases).An event-based system often \nuses a loop to deal with different events received and dispatch them to their corresponding handlers. \nFor such a system, our transaction can cross the body of the loop; that is,thehandling of each eventis \ntreated as a transaction.Each event object can be used as the identi.er object for the transaction. It \nis much easier todetermine a transactionfor a transaction-based sys\u00adtem, as each system transaction in \nthe original program can be naturally treated as a transactioninLeakChaser. Aparticularlyusefulfeature \nofLeakChaseristhatit allowspro\u00adgrammers to quickly specify transactions at a client that interacts with \na complex system, without digging into the system to under\u00adstanditsimplementationdetails.For example, \nwediagnoseEclipse frameworkbugsby specifying transactionsinplugins(i.e., clients) that trigger these \nbugs.Likewise,for databases such as MySQL and Mckoi, weonly need tocreatetransactions at clientprogramsthat \nperformdatabasequeries.Thisfeature allowsperformance experts like us (who are unfamiliar with these databases) \nto quickly get started with LeakChaser. If we could not put transactions around clients, it would be \nhard to even .nd a starting point in these sys\u00adtems thathave thousands of classes and millions oflines \nof code. Table 1 shows transaction and assertion statistics for all six cases. Despite the large number \nof assertions checked for each benchmark, LeakChaser reports a small number of warnings. We show statisticsfortierH \nonly, asitisthe coarsest-grained approach and thus runs the most assertions and reports the most violations. \nDiff (Eclipse bug #115789) We quickly found this bug using ourthree-tier approach andthedetaileddiagnosisprocessdiscussed \ninSection2. We have tried Sleigh on this program and the top four last-use sites(i.e.,where objects arelastused) \nreportedbySleigh arein class java.util.HashMap (e.g.,in methodsput and addEntry). In this case, the \nsitesleading to these HashMap operationspoint backto methodcreateContainer inclassorg.eclipse.compare \n.ZipFileStructureCreator, whichindicatesthatthestructures ofinput .lesarecachedbut not used.Atthispoint,itiscompletely \nup to the programmer to .nd out why these structures become stale and which objects reference them.Recallthat \neven a violation reportedby our tierH approach shows the violating objectis refer\u00adencedby a NavigationHistory \nobject, whichis actually the root cause of theleak(shown ininSection2).According to[8],Sleigh couldhave \nreported much morepreciseinformationif theprogram was run for signi.cantly more time. For example, LeakChaser \nre\u00adported the root cause after only 8 structure diffs were performed, while Sleigh may need more than \n1000 diffs to report relatively precise information regarding where the stale objects are created. In \naddition, as we observedin our experiments, reportingreference paths can be more helpful for .nding leak \nroot causes than report\u00ading program locations, which are usually far from where the true problem occurs. \nJbb SPECjbb2000 simulates an online trading system. It con\u00adtains aknown memoryleak thathasbeen studied \nmany times[3,8, 20, 36]. This bug is caused by unnecessary caching of Order ob\u00adjects. To investigate \nthe usefulness of LeakChaser in helping pro\u00adgrammers unfamiliar with the code, we attempt to simulate \nwhat theseprogrammers woulddo.First,weneed tounderstand theba\u00adsic modules and functions of the program \nso that we can identify regularly occurring events. This is not hard at all, as SPECjbb is a transaction-based \nsystem where a TransactionManager class runsdifferent transactions types, and the transaction-creating \nmethod is only a few calls away from method main. This method contains aloop that retrieves a commandfrom \naninput mapperit\u00aderation, and creates and runs a transaction whose type corresponds to the command received. \nThis was the knowledge we obtained quicklybefore tryingthe tierH approach. Problem 1: unused objects \nWe added a transaction that en\u00adcloses the mainJbb transaction-creating method.EachJbb transac\u00adtion object \nis used as the transaction identi.er object of its corre\u00adsponding transaction.We rantheprogram on our \nmodi.edVM and let LeakChaser infer unnecessary references. The tool reports 14 violations(detailed statistics \nare showninTable1).Most of the vi\u00adolating objects are String and History objects cached in orders, andthe \nrest are Order objectstransitively referencedby District objects.Weinspected the source code andfound \nthatthese String objects are created to representdistrictinformation or names of or\u00adderlines, andtheHistory \nobjects are usedto representhistories of orders madeby each company.These objects areindeed never used \nin the program. We modi.ed the program to eliminate these un\u00adused strings and History objects. The throughput \nimprovements are shown in Figure 7(a). We did not expect to .nd this problem, whichhad notbeen reportedbefore. \nProblem 2: mutual references It was unclear to us what to do about the Order objects reported above: \nwhile many are not used again, some are retrieved by subsequent transactions. We further inspect the \ncode in order to run a more focused diagnosis. The reference paths in our tier H report show that the \nunused Order objects are referenced by Customer objects and then by Company objects.Followingthis clue, \nweinspect all classes related to Company and Customer. One clear piece of information that we can take \nadvantage of is the ownership relationships among Company and Customer objects and objects referenced \nby them. For example, each customer has an order array that stores orders madebythat customer.Itis clearlyproblematicif \na customer object dies while an order madefromthis customeris stillalive.Usingthis information, we wrote \n72 diesBefore assertions to assert such relationships. We easily added these assertions in constructors, \nwherever an owned object is assigned to an owner object. Running this version of the program resulted \nin 4 violations, all of which are related to orders. By inspecting reference paths associated with these \nviola\u00ad  A    ov A   o   ov  A  ov -   o       o   m  i a S    f    \n l:i E  Figure 7. (a)Throughput improvements after .xing the memory problemsdetectedinSPECjbb;(b)Comparisonbetween \nthe mem\u00adoryfootprintsofMckoibeforeand after .xingtheleak. tions, wefound thefollowingthreeimportantproblems.(1)Order \nand Customer are mutually referenced, which explains thepersis\u00adtent increase in Order objects, even though \ncustomers frequently drop orders.(2)Customer objects are not released even after their container arrays \nin Company die. They are not released because Company holdsunnecessary referencestotheseobjects.(3)Order \nand Heap are mutually referenced, which prevents Heap objects frombeinggarbage collected.Fixingalloftheseproblems(includ\u00adingthe \nunused String and History objects)led toboth the elim\u00adination ofthequickgrowthofmemoryconsumption andan \noverall 12.7%throughputimprovement(from13,644to15,372 ops/sec). Previous workhas notreported alloftheseproblems \nthat wefound usingLeakChaser. An important last-use site reported by Sleigh is in method getObject ofaBTreedata \nstructure thatis usedto retrieve Order objectsfrom customers.The associated callingcontexts tellus that \nthis callis madetransitivelybyprocessLine.Whilethisisindeed amethod that needstobe .xed,thekey tounderstanding \ntheprob\u00adlemislearningaboutthe mutualreferences amongOrder andother classes. Without such reference information, \nit remains a daunting task toidentifytheroot causeanddevelop a .x. Editor (Eclipse bug #139465) This \nreported memory leak in Eclipse 3.2 occurs when opening a .outline .le using a customized editor and \nmaking selections on the outline page. Objects created while displaying the .le keep accumulating, and \nEclipse eventually crashes.Thisbugis stillopenbecause users can rarelyreproduce theleak.While we could \nnot observe the reported symptoms, we still ran the test case with LeakChaser. We wrote a pluginthatrepeats \nmultipletimestheprocess ofopeningthe editor, making selections, and closing the editor. We added a transaction \nin thisplugin that crosses each suchprocess(which manipulates the editor), and used the editor object \nas the transactionidenti.er. The tierHapproach reportedonlytwo violations even when we set a very small \nnumber (2) as the staleness threshold (see T in Figure 5). For each violation, we could not .nd any object \non its associated reference paths that is related to the editor of interest. Hence, we quickly concluded \nthat there were no unnecessary ref\u00aderences for this case in Eclipse 3.2 on the Linux platform where we \nran the experiment:had there existed aproblem with respect to a transaction, it should have been reported \nby the tier H approach, as the approach captures references to all objects that are shared but not used. \nFor this case, Sleigh reported four last-use sites, and we found it dif.cult to verify whether or not \nthese sites are rele\u00advant. The key is to understand how these objects are reachable in theheap,instead \nofwhere theyare usedin theprogram. WTP (Eclipse bug #155898) According to the bug report for this memory \nleak in the Eclipse Web Tool Platform (WTP), the memory footprint grows quickly when copying and pasting \nlarge text blocks in the JSP editor associated with the WTP framework. Thisbugis stillopenbecause it \ncannot alwaysbe reproduced. One developer suspected that the bug might have already been .xed by the \naddition of other features in a later version of WTP one year afteritwas reported.We reproduced theproblem \nand saw the memory footprint growth by writing a plugin that automatically copies and pastes texts several \ntimes. Similarly to the previous case, we added a transaction in the plugin and let it cross each iteration \nthat involves a pair of copy-and-paste operations. Our tier H approach reported a total of 26 violations, \namong which 11 seemed clearlyirrelevanttotheproblem(e.g.,regarding Eclipse s JavaDevelopmentTools and \notherplugins). To con.rm this observation, we use this plugin to perform the same copy-and-paste operations \nin a regular text editor in Eclipse, which does not have memory problems. These 11 violations also appearedin \nthegenerated report.Thus, theywere safelydiscarded. As this bug is caused by copying and pasting text, \nwe focus on string-related violations. Only one violation among the remaining 15is about String objects, \nshown asfollows: Transaction specified at: Quick_copy_pastePlugin:mouseUp(MouseEvent), ln 258 Violating \nobjects created at: StructuredTextUndoManager:createNewTextCommand(String, String), ln 302 Violation \ntype: objects shared among transactions are not used Frequency: 28 Reference paths: Type: StructuredTextViewerUndoManager, \ncreated at: StructuredTextViewerConfiguration : getUndoManager(ISourceViewer), ln 469 --> Type: StructuredTextUndoManager, \ncreated at: BasicStructuredDocument: getUndoManager(), ln 1823 --> Type: BasicCommandStack, created at: \nStructuredTextUndoManager : <init>(), ln 160 --> Type: ArrayList, created at: BasicCommandStack: <init>(), \nln 67 --> Type: Object[], created at: ArrayList: ensureCapacity(I), ln 176 This violation clearlyshows \nthat the strings are(transitively)refer\u00adencedbyatext undo manager.Thisinformationquicklydirectedus to \nclasses responsible for undo operations. The cause of the prob\u00adlem was clear to us almost immediately \nafter inspecting how an undo operationisperformed.In thisJSPeditor, allcommands(and their relateddata)are \ncached in a command stack,in case an undo isrequestedinthefuture.Thereisatradeoffbetween undoability \n(i.e.,how manycommands are cached)andperformance, especially whenthereisalargeamount ofdatabeing cached \nwith each com\u00admand.Inthis version ofWTP(WTP1.5 withEclipse3.2.0),this command stack cangrowtobeverydeep(itisnotcleared \neven when a save operation is performed), and thus, many strings can be cached, leading to signi.cant \nperformance degradation. A later versionhaslimited thedepth of this stack(for otherpurposes),im\u00adplicitly \n.xing this bug. For this case, we understood the problem even without moving to tier M. We did not manage \nto run Sleigh for this case, asSleigh wasdeveloped on top of an older version of JikesRVM(2.4.2), which \ncannot runEclipse3.2. MySQL leak This case is a simpli.ed version of a JDBC application that exhausts \nmemory if the application keeps using the same connection but different SQL statements to access the \ndatabase. Prior work reproduced this leak to evaluate tolerating leaks[9],but noprior work reports theleak \ncause.Theleak oc\u00adcursbecause theJDBClibrary caches already-executedSQL state\u00admentsin a container unless \nthe statements are explicitly closed.We create a transaction that crosses the creation and execution \nof each PreparedStatement (in aloop).We executed 100iterations, and thetierHapproach reported10 violations, \nall of which were related to PreparedStatement (i.e.,regarding eitherthe statement object itself, or \nobjects reachablefrom the statement). From the associated reference paths, it took only a few min\u00adutes \nfor us to identify the container that caches the statements: a HashMap created at line 1486 (in the constructor) \nof class com.mysql.jdbc.Connection. For this case, Sleigh reported warnings after the program ran for \n303 iterations, signi.cantly longer than for LeakChaser. Sleigh reported a few last-use sites where PrepareStatement \nobjects are last touched. We did not .nd the HashMap information in Sleigh s report, which is the key \nto trackingdown thisleakbug. Mckoi leak Mckoi is an open-source SQL database system written in Java (http://www.mckoi.com). \nIt contains a leak that previous work reproduced to evaluate leak survival tech\u00adniques [9, 10]. However, \nnone of the existing work has inves\u00adtigated the root cause of the leak. We reproduced the leak by writing \na clientthat repeatedly(100 times) establishes a connec\u00adtion, executes a few SQL queries, and closes \nthe connection. We started with our tier H approach and created a transaction that crosses each iteration \nof this process in the client. Our tool re\u00adported 10 warnings, all regarding objects that are reachable \nfrom a thread object of type DatabaseDispatcher. In all the warn\u00adings reported, this thread object references \na DatabaseSystem object, which transitively caches many other never-used objects. By inspecting only \nthe constructors of DatabaseSystem and DatabaseDispatcher, we found that they are mutually refer\u00adenced. \nThe creation of each DatabaseSystem object explicitly creates a DatabaseDispatcher object and runs this \nthread in the background. There are two majorproblems: (1)DatabaseDispatcher runsin a while(true) loop, \nwhich means no DatabaseSystem object can ever be garbage col\u00adlected even though its dispose method is \ninvoked. To address this problem, we broke this reference cycle when dispose is invoked on DatabaseSystem. \nNext, in DatabaseDispatcher, we modi.ed the while(true) loop to terminate if its referenced DatabaseSystem \nobjectbecomes null.This modi.cation resulted in a very slightimprovement inperformance, leading us tobelieve \nthere mustbe abiggerproblem. (2)ADatabaseSystem object canbe createdin two situations. (a)Anew database \nneeds tobe started(e.g., a connection is estab\u00adlished);(b) a method dbExists (that checks whether a database \ninstance has already been there) is called. In every iteration, two DatabaseSystem objects are created \nbut only one of them gets disposed. The one created by dbExists is never reclaimed, be\u00adcause dispose \nis not explicitly invoked on this object, which we quicklydiscoveredbyusing a callgraphgeneratedby anIDE \ntool. Thedeveloper tookitforgranted that this object wouldbegarbage collected,butitis referencedby alive \nthread.We added a call that invokes dispose at the end of method dbExists. For this case, all warnings \ngenerated by Sleigh are about ob\u00adjects cached (transitively) by DatabaseSystem, and they are far away \nfrom the leaking thread. It would be dif.cult to understand why these objects are not garbage collected \nwithout appropriate referencepaths, as reportedbyLeakChaser.The memoryfootprint of the database before \nand after the leak is .xed is shown in Fig\u00adure7(b).The original version of theprogram ran out of memory \nat the 106th iteration,whilethe modi.ed version raninde.nitely(as far as we could tell). These six case \nstudies demonstrate that developers do not need tohave muchimplementationknowledgein ordertodiagnoseleaks \nwithLeakChaser.LeakChasergenerates more relevant reports than Sleigh:itiseasierto .nd theroot causefromreferencechainsthat \ncache a violating object, thanfrom the allocation orlast-use site of the object. 6. Overhead We evaluated \ntheperformance of our technique using19programs from theSPECjvm98[34]andDaCapo[7]benchmarks, on adual\u00adcore \nmachine with an Intel Xeon 2.83GHZ processor, running Linux2.6.18.We ran eachprogram using thelarge workload. \nTable 2 reports the time and space overheads that our tracking infrastructure incurs on normal executions \n(without assertions or transactions written).The overhead measurements that we showin this section are \nobtained based on a(high-performance)FastAdap\u00adtiveImmix con.guration that uses the optimizing compiler \nand the state-of-the-artImmixgarbage collection algorithm[6]. TheLeakChaserinfrastructure slowsprogramsbylessthan10% \non average usingthe optimizing compiler and an advancedgarbage collector. Much of the overhead comes \nfrom extra operations dur\u00ading GC and the barrier inserted at each object reference read to check the \nuse of the object.Column(b) ofTable2 reportsthede\u00adtailed GC slowdown caused by our tool, which is 2.3\u00d7, \naveraged across the 19 programs. The space overheads, reported in column (c)of Table 2, are less than \n10%, primarily due to the extra word added to the header of each object. In some cases, the peak mem\u00adory \nconsumption for LeakChaser is even lower than that for the original run(i.e., OS is smaller than1),presumably \nbecause GCis triggered at adifferent set ofprogrampoints thathappens tohave a lower maximum reachable \nmemory size. The overhead of assertion checking andinferenceis reportedin Table3.The overall running \ntime measurements are available only for Jbb, MySQL, and Mckoi, as the other three cases are all based \non Eclipse IDE operations. Note that in a run with 4,346 transac\u00adtions and442,988 objects(showninTable1), \nour tool slows the program 6.6\u00d7 and 5.5\u00d7 overall for the two con.gurations. Simi\u00adlarly toTable2, the \noverhead canbelargerif we consider onlyGC time. For example, for Diff, a 2.8\u00d7 slowdown can be seen for \nGC time for FastAdaptiveImmix. Note that these overheads have not prevented usfrom collectingdatafrom \nany real-world application. In a production setting, run-time overhead can be effectively re\u00adducedby \nsampling(i.e.,the current sampling rateis100%).Future work could alsode.ne atradeoffframeworkbetweenthequality \nof the reportedinformation and thefrequency of assertion table scan\u00adning(similartoQVM[5]),and .nd anappropriatesampling \nrate that can enable the reporting of suf.cientinformation at acceptably low cost. 7. Related Work Whilethereexistsalargebody \nof work ondetectingJavamemory leaks,oursisthe .rst semantics-awareapproach that usesmultiple Bench (a)Overalltime \n(b)GCtime (c)Space T1 T2 OT G1 G2 OG S1 S2 OS check 0.033 0.068 2.1 0.016 0.033 2.0 11.4 10.3 0.9 compr \n9.4 9.5 1.0 0.016 0.033 2.0 17.9 18.0 1.0 jess 2.2 2.4 1.1 0.022 0.049 2.2 48.9 58.4 1.2 db 4.9 5.0 1.0 \n0.024 0.062 2.6 22.2 24.9 1.1 javac 2.1 2.4 1.1 0.030 0.064 2.1 98.1 99.0 1.0 mpeg 6.2 6.2 1.0 0.020 \n0.039 2.0 19.4 19.8 1.0 mtrt 1.6 1.6 1.0 0.031 0.081 2.6 46.5 43.6 0.9 jack 1.7 1.8 1.0 0.025 0.050 2.0 \n79.6 76.8 1.0 antlr 38.7 43.2 1.1 0.032 0.074 2.3 53.5 57.3 1.1 bloat 98.3 105.9 1.1 0.073 0.169 2.3 \n515.1 520.0 1.0 chart 19.7 21.4 1.1 0.084 0.232 2.8 367.4 479.4 1.3 eclipse 150.8 157.5 1.0 0.207 0.465 \n2.2 512.4 532.7 1.0 fop 1.4 1.8 1.3 0.064 0.15 2.3 107.6 102.2 0.9 hsqldb 9.3 16.4 1.8 0.331 1.21 3.7 \n420.5 432.6 1.0 jython 45.6 48.6 1.1 0.077 0.172 2.2 119.7 137.8 1.2 luindex 35.3 37.7 1.1 0.031 0.070 \n2.3 45.5 49.8 1.1 lusearch 7.8 8.1 1.0 0.038 0.088 2.3 105.0 129.5 1.2 pmd 22.9 23.6 1.0 0.055 0.127 \n2.3 115.3 157.5 1.4 xalan 32.3 39.5 1.2 0.066 0.145 2.2 214.2 209.0 1.0 GeoMean - - 1.1 - - 2.3 - - 1.1 \n Table 2. Time and space overheadsincurredby ourinfrastructurefortheFastAdaptiveImmix con.guration.Shownin \ncolumn(a) arethe original overall execution times(T1 )in seconds, the execution timesfor our modi.edJVM(T2 \n), and the overheads (OT)in times(\u00d7). Column(b) reports theGC times and overheads: G1 and G2 show the \naverage timesfor eachGC runin the originalRVM and our modi.ed RVM, respectively. OGreports theGC overheads \nas G2 /G1 .Memory consumption and overheads are shownin column(c): S1 and S2 are the maximum amounts \nof memory used during the executions in the original RVM and our RVM, respectively. OS reports the space \noverheads as S1 /S2 . Bench Diff - - - 0.27 0.75 2.8 534.2 534.4 1.0 Jbb 50.7* 9.2* 5.5 0.008 0.056 \n7.0 313.7 315.3 1.0 Editor - - - 0.15 0.41 2.7 300.5 367.2 1.2 WTP - - - 0.22 0.58 2.6 52.7 52.9 1.0 \nMySQL 6.8 14.0 2.1 0.045 0.108 2.4 17.1 17.7 1.0 Mckoi 165.6 172.2 1.0 0.046 0.154 3.3 129.2 144.2 1.1 \nGeoMean - - 2.3 - - 3.2 - - 1.0 (a)Overalltime T1 T2 OT (b)GCtime G1 G2 OG S1 (c)Space S2 OS Table \n3. Overheadsforthe casesthatwehave studied underFastAdaptiveImmix. *indicatesthatwemeasurethroughput(#operationsper \nsecond)instead of running time.ForbothMySQL andMckoi,a .xed numberofiterations(100) wasrunforthismeasurement. \nlayerstohelpprogrammers atdifferentlevels ofcodefamilaritiesto specify, check, andinfer unnecessary references.Related \nworkfalls intofour major categories:leak detection,bloat analysis, checking of unconventionalproperties, \nandGC assertions. Dynamic analysis for memory leak detection Dynamic anal\u00adysis[8,13,14,16,17,18,20,23,28,29]hastypicallybeen \nused to detect memory problems. As described in Sections 1 and 5, ex\u00adisting techniques have a number \nof de.ciencies. Commercial leak detectors such as[16,28]enable visualization ofheap objects of different \ntypes,but do notprovide the ability topinpoint the cause of a memory leak. Existing research detectors \nuse growing types [20,23](i.e.,types whosenumber ofinstancescontinuestogrow) or object staleness[8,18]toidentify \nsuspiciousdata structuresthat may contributeto a memory leak.However,ingeneral, amemory leak caused by \nredundant references is due to a complex interplay of memory growth and staleness and possibly other \nfactors. In ad\u00addition, these techniques are often unaware ofhigh-level semantics, andperform whole-programpro.ling; \nthisleadstoless relevantin\u00adformationin thegenerated reports.Xu and Rountev[36]introduce a technique that \npro.les container behaviors to detect containers that cachelarge numbers of unused objects.Novark et \nal..[27].nd memoryleaks andbloatinC/C++programsby segregating objects based ontheir allocationcontexts \nand staleness.Recent work[14] uses a tainting framework to propagate relevant information in or\u00adder toidentifyleaking \nobjectsforC/C++programs. Fundamentallydifferentfromthesetechniques,our workpresents an assertion framework \nthat allows programmers to explicitly ex\u00adpress their interests (i.e., related to high-level semantics), \nbased on the insight that developers knowledge is essential for a leak detector toproducehighly relevant \nreports. Software bloat analysis As a moregeneralproblem[26,40], softwarebloat analysis[4,21,22,25,32,36,37,38,39] \nattempts to .nd, remove, and prevent performance problems due to inef\u00ad.ciencies in the code execution \nand the use of memory. Prior work[22,24]proposes metricstoprovideperformance assessment of use ofdata \nstructures.Mitchell et al. [24]propose amanualap\u00adproach that detects bloat by structuring behavior according \nto the .ow ofinformation, and theirlater work[22] introduces a way to .nd data structures that consume \nexcessive amounts of memory. Workby Dufour et al. [15]uses ablended escape analysis to char\u00adacterize \nand .nd excessive use of temporary data structures. By approximating object lifetimes, the analysis has \nbeen shown to be usefulin classifying the usage of newly created objectsintheprob\u00adlematic areas. Shankar \net al. proposeJolt[32], an approach that makes aggressive methodinliningdecisionsbased ontheidenti.ca\u00adtion \nof regions that make extensive use of temporary objects.Work by Xu et al. [38] detects memory bloat by \npro.ling copy chains and copygraphs.Other work[31] dynamicallyidenti.esinappro\u00adpriately used Java collections \nand recommends to the user those that should really be used. The technique presented in our work canalsobeconsidered \nasabloat analysis,andit canbeusedto .nd a speci.c type ofbloat causedby unnecessary references. Asserting \nand inferring unconventional properties The Java Modeling Language [2] contains a few expressions (such \nas \\duration and \\space) that allow programmers to specify performance-relatedproperties ofaprogram.Burnim \nandSenpro\u00adpose an assertionframework[11] to specify that regions of apar\u00adallel program behave deterministically \ndespite non-deterministic thread interleavings. They later propose to dynamically infer de\u00adterministic \nspeci.cationsforparallelprogramsfrom the execution, given a setofinputs and schedules[12]. GC Assertions, \nQVM, and Merlin Closest to our work are heapproperty assertion frameworks such asGCAssertions[3,30] and \nQVM [5, 35]. For example, one can explicitly specify at a certain program point that an object should \nbe dead soon (i.e, assertDead), or that an object must be owned by another object in the objectgraph(i.e.,assertOwns).While \nsuchassertions canbe quite useful in helping diagnosis, they are limited in the following threeimportant \naspects related toleakdetection. First, reachability information is used to approximate the live\u00adness \nof objects, which may result in false positives. For example, assertOwns (a, b) asserts a reachability \nrelationship between ob\u00adjectsa and b, anditfails when b canbe reached in apath thatdoes not contain a \nin a certain GC run. However, it is possible that ob\u00adjectbbecomes unreachablefrom objectbin oneGC,whilelater \nbis ownedby a again.Second,because aGC assertionpredicts afuture heapstate(i.e.,the state atthe closestGC \nrun) andtheglobal reach\u00adability information evolves all the time, whether or not this asser\u00adtion willfaildepends \nsigni.cantly on when and where the nextGC occurs, which mayin turnbe affectedby manyfactors, such as \nthe initial and maximum heap sizes and speci.c GC implementation strategies. Third, these approaches \nare intended for programmers who have suf.ciently deep program knowledge and insights. In real-world \nsoftware development, only a handful of programmers canhave suchknowledge, especially when aperformanceproblem \noccursinprogram code thatis not writtenby themselves. Our work solves the .rst and second problems by \nallowing programmers to specify objects lifetime relationships instead of reachabilityproperties.In order \nto tackle the thirdproblem, we use a combination of assertion checking andtransactionpropertyinfer\u00adence \nto allow programmers with little application-speci.c knowl\u00adedge toquicklyidentify the cause of theproblem. \nTheGCAssertions[3]frameworkincludes ablock-structured assert-alldead assertion, which asserts that all \nobjects allocated in theblock mustbedeadby theend of theblock.Whileitisrelated to the transaction abstractions \nproposed in this paper, there are twoimportantdistinctionsbetweenthem.First,assert-alldead does not allow \nobjects in the speci.ed structure to escape the structure, while our approach allows checking and inferring \nshared objects, providing more .exibility for diagnosing problems. Second, our transaction abstraction \nseparates temporal and spatial scopes of the structure, while these scopes are combinedin this earlier \nwork. Merlin [19] is an ef.cient algorithm that can provide precise time-of-death statistics for heap \nobjects by computing when ob\u00adjectsdie usingcollected timestamps.LeakChaser couldpotentially exploit this \ntechnique in thefuture to capture assertionfailuresbe\u00adtweenGCs, as we currently report an assertionfailure \nonly whenit is actually witnessedduring aGC run. 8. Conclusions and Future Work This paper presents the \n.rst framework that allows programmers with little program knowledge to quickly .nd the root cause of \na memory leak, by bringing high-level program semantics into low\u00adlevel leak detection. The most signi.cant \nadvantages of this work over existing Java leak detection tools are that (1) the approach uses lightweight \nuser annotations to improve the relevance of the generatedreports, and canprovide semantics-relateddiagnosticin\u00adformation(e.g., \nwhich object escapes whichtransaction), and(2) it is designed in a multi-tier way so that programmers \nat differ\u00adent levels of skill and code familiarity can use it to identify per\u00adformanceproblems.Ourexperience \nshowsthatthethree-tiertech\u00adniqueisquite effective:thetool canhelp aprogrammeridentifythe root cause of \na leak after an iterative process of specifying, infer\u00adring, and checking object lifetime properties. \nFor the case studies we conducted, the toolprovided more relevantinformation than an existing memoryleakdetectorSleigh.For \nexample, using the tool, wequicklyfound the root causes of memoryissuesin the analyzed programs, including \nboth known memory leaks and problems that have notbeen reported before.WhileLeakChaser incurs relatively \nlarge overhead(2.9\u00d7 on average), we found it acceptable for de\u00adbugging andperformance tuning. The assertions \nand transaction constructs may be easily incor\u00adporated into the Java language so that they can be used \nin a pro\u00adduction JVM to help detect memory problems. Similarly to func\u00adtional speci.cations that are \nused widely in program testing and debugging, writingperformance speci.cations canhave signi.cant advantages. \nFor example, it could enable unit performance testing that can identify performance violations even before \ndegradation isobserved.Inaddition,performance speci.cations(similartothe onesdescribedin thispaper) mayhelpbridge \nthegapbetweenper\u00adformance analysis and the large body of work on model checking and veri.cation, so that \none maybe able toprove(statically) apro\u00adgramis bloat-free or bloat-bounded with respecttotheperfor\u00admance \nspeci.cationsprovided. A possible direction of future work would be to investigate such relationships \nin order to prevent small performance issues in the early stage of software development, before they \npile up and become signi.cant. Acknowledgments Wethank thePLDI reviewersfor their valuable and thorough \ncom\u00adments. The initial idea for this work was inspired by a conversa\u00adtion that Guoqing Xu had with Nick \nMitchell during an intern\u00adship with IBM T. J. Watson Research Center. This material is based upon work \nsupported by the National Science Foundation under CAREER grants CCF-0546040 and CCF-0953759, grant CCF-1017204, \nandby anIBMSoftwareQualityInnovationFac\u00adulty Award. Guoqing Xu was supported in part by an IBM Ph.D. \nFellowshipAward. References [1] The Jikes Research VirtualMachine,2011. http://jikesrvm.org. [2] JML \nReference Manual,2010. http://www.jmlspecs.org. [3] E.E.Aftandilian andS.Z.Guyer. GCAssertions:Using \nthegarbage collectorto checkheapproperties. In ACM SIGPLAN Conference on Programming Language Design \nand Implementation (PLDI), pages 235 244,2009. [4] E.Altman,M.Arnold,S.Fink,andN.Mitchell.Performanceanalysis \nof idle programs. In ACM SIGPLAN International Conference on Object-Oriented Programming,Systems,Languages, \nandApplications (OOPSLA),pages739 753,2010. [5] M. Arnold, M. Vechev, and E. Yahav. QVM: An ef.cient \nruntime for detecting defects in deployed systems. In ACM SIGPLAN Inter\u00adnational Conference onObject-Oriented \nProgramming,Systems,Lan\u00adguages, andApplications(OOPSLA),pages143 162,2008.  [6] S.M.Blackburn andK.S.McKinley. \nImmix: amark-regiongarbage collector with space ef.ciency, fast collection, and mutator perfor\u00admance. \nIn ACM SIGPLAN Conference on Programming Language Design and Implementation(PLDI),pages22 32,2008. [7] \nS.M.Blackburn,R.Garner,C.Hoffman,A.M.Khan,K.S.McKin\u00adley, R. Bentzur, A. Diwan, D. Feinberg, D. Frampton, \nS. Z. Guyer, M.Hirzel,A.Hosking,M.Jump,H.Lee,J.E.B.Moss,A.Phansalkar, D. Stefanovi\u00b4c, T. VanDrunen, \nD. von Dincklage, and B. Wieder\u00admann. The DaCapo benchmarks: Java benchmarking development and analysis. \nIn ACMSIGPLANInternationalConference onObject\u00adOrientedProgramming,Systems,Languages, andApplications(OOP\u00adSLA),pages169 \n190,2006.  [8] M. D. Bond and K. S. McKinley. Bell: Bit-encoding online memory leak detection. In International \nConference on Architectural Support forProgrammingLanguages andOperatingSystems(ASPLOS),pages 61 72,2006. \n[9] M. D. Bond and K. S. McKinley. Leak pruning. In International Conference on Architectural Support \nfor Programming Languages andOperating Systems(ASPLOS),pages277 288,2009. [10] M. D. Bond and K. S. McKinley. \nTolerating memory leaks. In ACM SIGPLAN International Conference on Object-Oriented Pro\u00adgramming, Systems, \nLanguages, and Applications (OOPSLA), pages 109 126,2008. [11] J. Burnim and K. Sen. Asserting and checking \ndeterminism for multithreaded programs. In ACMSIGSOFTInternational Symposium on theFoundations ofSoftwareEngineering(FSE),pages3 \n12,2009. [12] J. Burnim and K. Sen. Determin: Inferring likely deterministic spec\u00adi.cations of multithreaded \nprograms. In International Conference on Software Engineering(ICSE),pages415 424,2010. [13] CA Technologies. \nCA Wily Introscope LeakHunter. www.ca.com/ us/application-management.aspx. [14] J.Clause andA.Orso. Leakpoint:pinpointing \nthe causes of memory leaks. In InternationalConference onSoftwareEngineering(ICSE), pages515 224,2010. \n[15] B. Dufour, B. G. Ryder, and G. Sevitsky. A scalable technique for characterizing the usage of temporaries \nin framework-intensive Java applications. In ACM SIGSOFT International Symposium on the Foundations ofSoftwareEngineering(FSE),pages59 \n70,2008. [16] ej-technologies GmbH. JPro.ler. www.ej-technologies.com. [17] R. Hastings and B. Joyce. \nPurify: A tool for detecting memory leaks and access errors in C and C++ programs. In Winter 1992 USENIX \nConference,pages125 138,1992. [18] M.Hauswirth andT.M.Chilimbi.Low-overhead memoryleakdetec\u00adtion using \nadaptive statistical pro.ling. In International Conference onArchitecturalSupportforProgramming Languages \nandOperating Systems(ASPLOS),pages156 164,2004. [19] M. Hertz, S. M. Blackburn, J. E. B. Moss, K. S. \nMcKinley, and D.Stefanovi\u00b4c. Generating objectlifetimetraceswithMerlin. ACM Transactions onProgrammingLanguages \nandSystems(TOPLAS),28 (3):476 516,2006. [20] M.JumpandK.S.McKinley.Cork:Dynamicmemoryleakdetection forgarbage-collectedlanguages. \nIn ACM SIGPLAN-SIGACTSympo\u00adsium onPrinciples ofProgrammingLanguages(POPL),pages31 38, 2007. [21] N.Mitchell. \nTheruntimestructure of object ownership. In European Conference on Object-Oriented Programming (ECOOP), \npages 74 98,2006. [22] N.Mitchell andG.Sevitsky. Thecauses ofbloat,thelimits ofhealth. In ACMSIGPLANInternationalConference \nonObject-OrientedPro\u00adgramming, Systems, Languages, and Applications (OOPSLA), pages 245 260,2007. [23] \nN.Mitchell andG.Sevitsky. Leakbot:Anautomated andlightweight tool for diagnosing memory leaks in large \nJava applications. In European Conference on Object-Oriented Programming (ECOOP), pages351 377,2003. \n[24] N. Mitchell, G. Sevitsky, and H. Srinivasan. Modeling runtime be\u00adhavior in framework-based applications. \nIn European Conference on Object-Oriented Programming(ECOOP),pages429 451,2006. [25] N. Mitchell, E. \nSchonberg, and G. Sevitsky. Making sense of large heaps. In European Conference on Object-Oriented Programming \n(ECOOP),pages77 97,2009. [26] N. Mitchell, E. Schonberg, and G. Sevitsky. Four trends leading to Java \nruntimebloat. IEEESoftware,27(1):56 63, 2010. [27] G. Novark, E. D. Berger, and B. G. Zorn. Ef.ciently \nand precisely locating memory leaks and bloat. In ACM SIGPLAN Conference on Programming Language Design \nand Implementation (PLDI), pages 397 407,2009. [28] QuestSoftware. JProbe. www.quest.com/jprobe. [29] \nD. Rayside and L. Mendel. Object ownership pro.ling: A technique for .nding and .xing memory leaks. In \nInternational Conference on Automated SoftwareEngineering(ASE),pages194 203,2007. [30] C. Reichenbach, \nN. Immerman, Y. Smaragdakis, E. Aftandilian, and S. Z. Guyer. What can the GC compute ef.ciently? A language \nfor heap assertions at GC time. In ACM SIGPLAN International Conference on Object-Oriented Programming, \nSystems, Languages, and Applications(OOPSLA),pages256 269,2010. [31] O. Shacham, M. Vechev, and E. Yahav. \nChameleon: Adaptive selec\u00adtion of collections. In ACM SIGPLAN Conference on Programming LanguageDesign \nandImplementation(PLDI),pages408 418,2009. [32] A. Shankar, M. Arnold, and R. Bodik. Jolt: Lightweight \ndynamic analysis and removal of object churn. In ACMSIGPLANInternational Conference on Object-Oriented \nProgramming, Systems, Languages, and Applications(OOPSLA),pages127 142,2008. [33] Y.Tang,Q.Gao,andF.Qin. \nLeakSurvivor:Towardssafely tolerating memoryleaksforgarbage-collected languages. In TheUSENIXAnual Technical \nConference(USENIX),pages307 320,2008. [34] The Standard Performance Evaluation Corporation. SPECjvm98 \nBenchmark Set. http://www.spec.org/jvm98/. [35] M.Vechev,E.Yahav,andG.Yorsh.PHALANX:Parallel checking \nof expressive heap assertions. In International Symposium on Memory Management(ISMM),pages41 50,2010. \n[36] G. Xu and A. Rountev. Precise memory leak detection for Java software using container pro.ling. \nIn International Conference on Software Engineering(ICSE),pages151 160,2008. [37] G.XuandA.Rountev.Detectinginef.ciently-used \ncontainerstoavoid bloat. In ACM SIGPLAN Conference on Programming Language Design andImplementation(PLDI),pages160 \n173,2010. [38] G.Xu,M.Arnold,N.Mitchell,A.Rountev,andG.Sevitsky. Gowith the .ow: Pro.ling copies to .nd \nruntime bloat. In ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI),pages419 \n430,2009. [39] G.Xu,N.Mitchell,M.Arnold,A.Rountev,E.Schonberg,andG.Se\u00advitsky. Findinglow-utility data \nstructures. In ACMSIGPLANConfer\u00adence onProgramming LanguageDesign andImplementation(PLDI), pages174 186,2010. \n[40] G. Xu, N. Mitchell, M. Arnold, A. Rountev, and G. Sevitsky. Soft\u00adware bloat analysis: Finding, removing, \nand preventing performance problems in modern large-scale object-oriented applications. In ACM SIGSOFTFSE/SDPWorkshop \nontheFutureofSoftwareEngineering Research,2010. \n\t\t\t", "proc_id": "1993498", "abstract": "<p>In large programs written in managed languages such as Java and C#, holding unnecessary references often results in memory leaks and bloat, degrading significantly their run-time performance and scalability. Despite the existence of many leak detectors for such languages, these detectors often target low-level objects; as a result, their reports contain many false warnings and lack sufficient semantic information to help diagnose problems. This paper introduces a specification-based technique called LeakChaser that can not only capture precisely the unnecessary references leading to leaks, but also explain, with high-level semantics, why these references become unnecessary.</p> <p>At the heart of LeakChaser is a three-tier approach that uses varying levels of abstraction to assist programmers with different skill levels and code familiarity to find leaks. At the highest tier of the approach, the programmer only needs to specify the boundaries of coarse-grained activities, referred to as transactions. The tool automatically infers liveness properties of these transactions, by monitoring the execution, in order to find unnecessary references. Diagnosis at this tier can be performed by any programmer after inspecting the APIs and basic modules of a program, without understanding of the detailed implementation of these APIs. At the middle tier, the programmer can introduce application-specific semantic information by specifying properties for the transactions. At the lowest tier of the approach is a liveness checker that does not rely on higher-level semantic information, but rather allows a programmer to assert lifetime relationships for pairs of objects. This task could only be performed by skillful programmers who have a clear understanding of data structures and algorithms in the program.</p> <p>We have implemented LeakChaser in Jikes RVM and used it to help us diagnose several real-world leaks. The implementation incurs a reasonable overhead for debugging and tuning. Our case studies indicate that the implementation is powerful in guiding programmers with varying code familiarity to find the root causes of several memory leaks---even someone who had not studied a leaking program can quickly find the cause after using LeakChaser's iterative process that infers and checks properties with different levels of semantic information.</p>", "authors": [{"name": "Guoqing Xu", "author_profile_id": "81350590981", "affiliation": "Ohio State University, Columbus, OH, USA", "person_id": "P2690557", "email_address": "xug@cse.ohio-state.edu", "orcid_id": ""}, {"name": "Michael D. Bond", "author_profile_id": "81100148693", "affiliation": "Ohio State University, Columbus, OH, USA", "person_id": "P2690558", "email_address": "mikebond@cse.ohio-state.edu", "orcid_id": ""}, {"name": "Feng Qin", "author_profile_id": "81100549787", "affiliation": "Ohio State University, Columbus, OH, USA", "person_id": "P2690559", "email_address": "qin@cse.ohio-state.edu", "orcid_id": ""}, {"name": "Atanas Rountev", "author_profile_id": "81100162864", "affiliation": "Ohio State University, Columbus, OH, USA", "person_id": "P2690560", "email_address": "rountev@cse.ohio-state.edu", "orcid_id": ""}], "doi_number": "10.1145/1993498.1993530", "year": "2011", "article_id": "1993530", "conference": "PLDI", "title": "LeakChaser: helping programmers narrow down causes of memory leaks", "url": "http://dl.acm.org/citation.cfm?id=1993530"}