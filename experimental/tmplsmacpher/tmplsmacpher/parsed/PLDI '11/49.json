{"article_publication_date": "06-04-2011", "fulltext": "\n On Inter-Procedural Analysis of Programs with Lists and Data * Ahmed Bouajjani Cezara Dr.agoi Constantin \nEnea Mihaela Sighireanu LIAFA, University Paris Diderot &#38; CNRS {abou,cezarad,cenea,sighirea}@liafa.jussieu.fr \nAbstract 1 We address the problem of automatic synthesis of assertions on 2 sequential programs with \nsingly-linked lists containing data over 3 4 in.nite domains such as integers or reals. Our approach \nis based on 5 an accurate abstract inter-procedural analysis. Program con.gura-6 tions are represented \nby graphs where nodes represent list segments 7 without sharing. The data in these list segments are \ncharacterized 8 9 by constraints in abstract domains. We consider a domain where 10 constraints are in \na universally quanti.ed fragment of the .rst-order 11 logic over sequences, as well as a domain constraining \nthe multisets 12 of data in sequences. 13 14 Our analysis computes the effect of each procedure in a \nlocal 15 manner, by considering only the reachable part of the heap from its 16 actual parameters. In \norder to avoid losses of information, we intro-17 duce a mechanism based on unfolding/folding operations \nallowing 18 19 to strengthen the analysis in the domain of .rst-order formulas by the analysis in the \nmultisets domain. The same mechanism is used for strengthening the sound (but incomplete) entailment \noperator of the domain of .rst-order formu\u00adlas. We have implemented our techniques in a prototype tool \nand we have shown that our approach is powerful enough for automatic (1) generation of non-trivial procedure \nsummaries, (2) pre/post\u00adcondition reasoning, and (3) procedure equivalence checking. Categories and Subject \nDescriptors F.3.2. [Logics and Mean\u00adings of Programs]: Specifying and Verifying and Reasoning about Programs \nProgram analysis; F.3.1. [Logics and Mean\u00adings of Programs]: Specifying and Verifying and Reasoning about \nPrograms Invariants, Assertions; D.2.5. [Software En\u00adgineering]: Testing and Debugging Symbolic execution; \nE.2 [Data]: Data Storage Representations Linked representations General Terms Algorithms, Languages, \nTheory, Veri.cation Keywords interprocedural analysis, abstract interpretation, pointer analysis, shape \nanalysis, data constraints * This work has been supported by the French ANR project Veridyc. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 11, June 4 \n8, 2011, San Jose, California, USA. Copyright &#38;#169; 2011 ACM 978-1-4503-0663-8/11/06. . . $10.00 \nc typedef struct list { int data; struct list *next; } list ; list * quicksort(list *a){ list *left,*right,*pivot,*res,*start; \nint d; if (a == NULL || a->next == NULL) res = clone(a); else { d = a->data; pivot = create(1); // list \nof length 1 pivot->data = d; start = a->next; split(start,d,&#38;left,&#38;right); left = quicksort(left); \nright = quicksort(right); res = concat(left,pivot,right); } return res; } Figure 1. The quicksort algorithm \non singly-linked lists. 1. Introduction Automatic synthesis of valid assertions about programs, such \nas loop invariants or procedure summaries, is an important and highly challenging problem. In this paper, \nwe address this problem for se\u00adquential programs manipulating singly-linked lists with unbounded data \nsuch as integers or reals. These programs may contain proce\u00addure calls, and actually they are in many \ncases naturally written using recursive procedures. Assertions about these programs typically involve \nconstraints on the shape of the structures, their sizes, the data values con\u00adtained in the memory cells, \nthe multisets of their data, etc. Con\u00adsider for instance the algorithm quicksort in Figure 1 that sorts \nthe input list pointed to by the variable a (and where the call split(start,d,&#38;left,&#38;right) copies \nall the cells of the list pointed to by start which have data larger than d in the list right, and all \nthe other ones in the list left). The speci.cation of quicksort includes (1) the sortedness of the output \nlist pointed to by res, expressed by the formula: .y1,y2. 0 = y1 = y2 < len(res) . data(y1) = data(y2) \n(A) where y1 and y2 are interpreted as integers and used to refer to positions in the list pointed to \nby res, len(res) denotes the length of this list, and data(y1) denotes the integer stored in the element \nof res at position y1, and (2) the preservation property saying that the multiset of data of the input \nlist a is equal to the multiset of data of the output list res. This property is expressed by ms(a0)= \nms(res) (B) where ms(a0) (resp. ms(res)) denotes the multiset of integers stored in the list pointed \nto by a at the beginning of the procedure (resp. res at the end of the procedure).  We propose an approach \nfor automatic assertion synthesis based on inter-procedural analysis within the framework of abstract \nin\u00adterpretation [7], that is, we consider abstract domains for express\u00ading constraints on relations between \nprogram con.gurations, and we de.ne compositional techniques for computing procedure sum\u00admaries concerning \nvarious aspects such as shapes, sizes, and data. We build on the work by Bouajjani et al. in [2] where \nthey de.ne an accurate intra-procedural abstract analysis for synthesizing in\u00advariants of programs with \nlists and without procedure calls. In their approach, abstract domains are de.ned where elements are \npairs composed of a heap backbone and an abstract data constraint. The heap backbone is an abstraction \nof the heap graph (the graph rep\u00adresenting the allocated memory) where only a bounded number of nodes \nare kept, including all sharing nodes and all the nodes pointed to by program variables. An edge in the \nbackbone represents a path (without sharing nodes) relating the source and target nodes in the original \nheap. The data constraint is given as an element of some abstract domain and allows to specify properties \nof the data se\u00adquences represented by the edges of the heap backbone. The pro\u00advided analysis in that \npaper is based on (a) unfolding the structures in order to reveal the properties of some internal nodes \nin the lists, which makes necessary to introduce in the structures some nodes, called simple nodes, others \nthan the sharing nodes or those pointed to by variables, and then (b) folding the structures by eliminating \nthe simple nodes and in the same time collecting the informations on these nodes using a formula that \nspeaks about sequences of data. The analysis is iterated several times, which may lead to additional \nunfoldings and foldings. Then, widening techniques on numerical domains are used in order to force termination. \nSeveral abstract do\u00admains are de.ned for the analysis, and in particular, domains where elements are \n(1) formulas in a universally quanti.ed fragment of the .rst-order logic over data words, or (2) conjunctions \nof equal\u00adity constraints between unions of multisets of data in words. The formulas in the .rst abstract \ndomain contain a (quanti.ed) univer\u00adsal part which is a conjunction of formulas .y. (P . U), where y \nis a vector of variables interpreted as positions in the words, P is a constraint on the positions (seen \nas integers) associated with the y s, and U is a constraint on the data values at these positions. It \nis assumed that P is obtained from a .nite set of .xed patterns corre\u00adsponding to, e.g., order constraints \nor difference constraints. While the techniques presented in [2] are strong enough to generate com\u00adplex \ninvariants for iterative programs, they cannot be applied for compositional computation of procedure \nsummaries. In this paper, we propose an extension of the approach in [2] by de.ning new techniques for \naccurate inter-procedural abstract analysis. This extension is not trivial due to many delicate problems \nthat appear when addressing the compositionality issue. Indeed, in the spirit of [23], at each procedure \ncall, the callee has only access to the part of the heap that is reachable from its actual parameters. \nThe use of such local heaps is delicate due to the fact that there are relations between the elements \nof the local heap of the callee, and of the heaps of the procedures that are in the call stack. If these \nrelations are lost during the analysis, this one can be unsound in some cases, or very imprecise in others. \nHowever, it is not feasible to maintain explicitly these relations during the analysis. Let us examine \nthis crucial problem. This problem has been addressed in [23] in a framework where data are not considered. \nIn this case, the relations inter-local heaps are due to reachability: nodes in the local heap of the \ncallee can be reachable from the other heaps through paths that do not con\u00adtain nodes pointed to by the \nparameters of the procedure (the entry points of the local heap). If during the call these nodes become \nlocally unreachable and deleted, the analysis becomes unsound. The solution to this proposed in [23] \nconsists in maintaing along the calls the points, called cutpoints, where these (inter-local heap) caller \nheap Figure 2. Relation between caller and callee local heaps. paths enter local heaps. This is a tricky \nproblem since in general the number of cutpoints may be unbounded. However, there is a signi.cant class \nof programs for which cutpoints are never gener\u00adated during the analysis. The class of such cutpoint \nfree programs [24] includes programs such as sorting algorithms, traversal of lists, insertion, deletion, \netc. In this paper, we consider cutpoint free pro\u00adgrams and focus on the problems induced by data manipulation. \nIndeed, even for cutpoint free programs, the problem above persists when data constraints are considered \nas we do in our framework. The reason is that elements in the local heap of a procedure can be related \nto elements in the rest of the heap with data constraints such as equality, ordering, etc. This situation \nis depicted in Figure 2. Elements in the local heap of the callee are linked at the call point to external \nelements by some data relation, ., and the analysis generates a summary .sum of the procedure relating \nthe input heap with the output heap. Then, the problem is whether there is a link . between the elements \nin the callee output heap and the external elements in the caller heap. This problem depends on the accuracy \nof the used summarization technique. Consider for instance the quicksort procedure that takes the .rst \nelement d of the input list a as the pivot, splits the tail of the list a into two lists left and right \nwhere all the elements of left resp. right are smaller resp. greater than d, and then performs two recursive \ncalls on the lists left and right, before composing the results, together with d, into a sorted list. \nAfter the recursive call at line 16 on left, the information we obtain from the analysis with the domain \nof .rst-order formulas is that the output list left is sorted. Since we had already the information that \nthe elements of the input list left were all less than d, we must infer after the return from that call \nthat the elements of left are also less than d. But, since the link between d and the elements of left \nhas not been passed to the recursive call, this information cannot be computed. This is because the used \nabstract domain cannot express the fact that a list is a permutation of another list (which requires \nformulas beyond the universally quanti.ed fragment). Again, maintaining all the relations between the \nelements of the local heaps and the external elements is not feasible. Our solution to this problem is \nbased on strengthening the analysis in the domain of .rst-order formulas with the analysis in the domain \nof multiset constraints. Indeed, for the quicksort example, knowing that left and left have the same \nmultisets of elements should allow to infer from the fact that all elements of left are less than d, \nthat the same fact also holds about the elements of left . Another problem that must be addressed for \nthe design of com\u00adpositional analysis is due to the use of patterns P for left-hand sides of implications \nin the .rst-order formulas. Indeed, the analysis of different procedures may need the use of different \nsets of patterns, and therefore it is important to be able to localize the choice of these patterns to \neach procedure. Otherwise, it would be necessary to use a set of patterns including the union of all \nthe sets that are used during the whole analysis, and this would obviously make the analysis inef.cient. \nFor instance, the computation of the for\u00ad  call return call return  Figure 3. Compositional analysis \nwith patterns. mula (.y. 0 = y < len(left) . data(y) = d) . (.y. 0 = y < len(right) . data(y) > d) describing \nthe effect of the procedure split called by quicksort does not need the use of the pattern 0 = y1 = y2 \n< len(res) that is used for the generation of the sorted\u00adness property. Consequently, during the analysis, \nat procedure calls and returns, we need to switch from an abstract domain of formulas parametrized by \nsome set of patterns, say P, to an abstract domain parametrized by another set of patterns P1 or P2 as \nshown in Figure 3(AU(P) denotes the domain of .rst-order formulas parametrized by the set of patterns \nP). The two problems exposed above show that in order to de.ne a compositional and accurate inter-procedural \nanalysis, we need to de.ne an operation for composing abstract domains (e.g., .rst\u00adorder formulas with \nmultiset constraints, or .rst-order formulas of different types). We propose in this paper a mechanism \nwhich al\u00adlows to solve these problems. This mechanism is based on unfold\u00ading/folding operations which \ncan be used, at procedure calls and returns, to (1) compute an over-approximation of the intersection \nbetween a .rst-order formula and a multiset constraint and (2) to convert universal formulas de.ned over \na set of patterns P1 to for\u00admulas de.ned over a set of patterns P2. Beyond compositional summary computation, \nthe operation we de.ne for combining abstract domains allows to tackle two other interesting problems. \nFirst, it allows to de.ne an entailment opera\u00adtion on combined constraints of the form f . . . f1 where \nf and f1 are two universal .rst-order formulas (potentially over different sets of patterns), and . is \na multiset constraint. This provides a lightweight sound (but not complete) decision procedure for such \nkind of formulas, which is useful for carrying out pre-post condi\u00adtion reasoning. Furthermore, our techniques \nare accurate enough to be used for automatic procedure equivalence checking. It is easy to see that this \nproblem can be reduced to inter-procedural analysis, provided that it is possible to express equality \nbetween structures, and derive such properties. This is not trivial in general since rea\u00adsoning about \ncombined abstract domains is needed. For instance, to check that two sorting procedures P1 and P2 are \nequivalent, it is possible to call each of them on two identical input lists I1 and I2, and then assert \nthat the two outputs O1 and O2 are equal. As\u00adsuming that the summary of Pi is sorted(Oi) .ms(Ii)= ms(Oi), \nfor i .{1,2}, this amounts to check the validity of the formula: equal(I1, I2) . sorted(O1) . ms(I1)= \nms(O1) . sorted(O2) . ms(I2)= ms(O2)(C) . equal(O1, O2), where the predicates equal and sorted are expressed \nby .rst-order formulas. Our techniques are able to .nd that this formula is indeed valid. We have implemented \nour techniques and carried out several experiments showing the strength of our approach. 2. Programs \nLet PVar be a set of variables of type reference to a record type called list de.ned by a single reference \n.eld next and one data .eld data of integer type. We consider that PVar includes the constant NULL. Also, \nlet DVar be a set of variables interpreted as integers. The generalization to record types with several \ndata .elds and data .elds of different basic types is straightforward. Syntax: A program is de.ned by \na set of procedures, each of them represented by its intra-procedural control .ow graph (CFG, for short). \nFormally, a procedure P is a tuple (fpi, fpo,loc, G), where loc . PVar . DVar is the vector of local \nvariables, fpi . loc and fpo . loc are the vectors of formal input, resp. output, parameters, and G is \nits CFG. W.l.o.g., we suppose that the CFG of P contains a unique entry point sP and a unique exit point \neP. Its edges are labeled by (1) statements of the form p=new, p=q, p->next=q, p->data=dt, and y=Q(x), \nwhere p,q . PVar, dt is a term representing an integer (built over terms of the form d . DVar and p->data \nusing operations over Z), and y,x . PVar . DVar, (2) boolean conditions on data built using predicates \nover Z, (3) boolean conditions on pointers of the form p==q where p,q . PVar, or (4) statements of the \nform assert . and assume ., where . is a formula (see Section 4 for more details concerning the syntax \nof .). The semantics assumes a garbage collector and consequently, the statement free is useless. We \nassume a call-by-value semantics for the procedure parameters and that each procedure has its own set \nof local variables. We forbid pointers to procedures and pointer arithmetic. The inter-procedural control \n.ow graph (ICFG, for short) of a program is de.ned as usual by replacing edges labeled by proce\u00addure \ncalls with (1) a call to start edge labeled by (call y=Q(x)), and (2) an exit to return edge labeled \nby (ret y=Q(x)). Semantics: A program con.guration is a valuation of the vari\u00adables interpreted as integers \ntogether with a con.guration of the allocated memory. The latter is represented by a labeled directed \ngraph where nodes correspond to objects of type list and edges correspond to values of the reference \n.eld next. The nodes are labeled by the values of the .eld data and by the program pointer variables \nwhich are pointing to the corresponding objects. The con\u00adstant NULL is represented by a distinguished \nnode r. Such a repre\u00adsentation for a program con.guration is called a heap. DEFINITION 2.1 (Heap). A \nheap over PVar and DVar is a tuple H =(N, S,V,L,D) where: 1. N is a .nite set of nodes which contains \na distinguished node r, 2. S : N \u00d7N is a set of edges such that S contains at most one edge (n,n1), \nfor any n . N, and S does not contain an edge (r,n) with n . N, 3. V : PVar . N is a function associating \nnodes to pointer vari\u00adables s.t. V (NULL)= r, 4. L : N -Zis a partial function associating nodes to \nintegers s.t. only L(r) is unde.ned, and 5. D : DVar . Zis a valuation for the data variables.  DEFINITION \n2.2 (Simple/crucial node). A node which is labeled by a pointer variable or which has at least two predecessors \nis called a crucial node. Otherwise, it is called a simple node. For any procedure P =(fpi, fpo,loc, \nG) and any control point c in P, we consider relations between program con.gurations at the entry point \nof P and program con.gurations at c. These relations can be represented using a double vocabulary loc \n. loc0, where loc0 = {v0 | v . loc} denote the values of the variables in loc at the entry point of P. \nA relation associated to P at c is represented by a heap over loc . loc0 containing a valuation for the \ninteger variables in (loc n DVar) . (loc n DVar)0 together with a graph which is the union of two sub-graphs: \nG0 represents the heap at the entry point of P and G represents the heap at the control point c. For \nexample, a relation associated to quicksort at line 16 is represented by the  aq d0 suppose that local \ninteger variables are initialized to 0). The nodes which correspond to objects pointed to by program \nvariables are circled. The subgraph containing only nodes reachable from the node labeled by a 0 represents \nthe input con.guration while the rest of the graph represents the heap con.guration at line 16. valuation \n= 0, d = 6 and the labeled graph in Figure 4(a) (we 0 a 9 7 a0 649274 2  NULL r a r NULL a 4 9 2 \n7 left left 422 right right 97 7 pivot pivot (a) (b) 00 Universally quanti.ed formula: an a .c : hd(nl \n) = hd(np) . hd(nr ) > hd(np) NULL .len(na)= len(nl )+ len(nr )+ len(np) a ..y. y . tl(nl ) . nl [y] \n= hd(np) ..y. y . tl(nr ) . nr[y] > hd(np) 0 .d = hd(np) . eq.(na,n) . len(np)= 1, a left Multiset formula: \n.1 c : ms(na)= ms(nl ) . ms(nr) . ms(np) right pivot .ms(na0)= ms(na) (c) Figure 4. Relations between \nprogram con.gurations. The concrete semantics de.nes a mapping . which associates to each control point \nc in the CFG of a procedure P a set of heaps over loc . loc0. As usual, the mapping . is de.ned by a \nsystem of recursive equations [8, 28] of the form:  Rinit . .(sP) and .(c)= .(c) . post(St,.(c1)), (D) \nSt c1 - .c where (1) Rinit is a heap containing two copies of the initial con\u00ad.guration of some procedure \nP =(fpi,fpo, loc,G), one copy over St 1 loc0, and one copy over loc, (2) c- .c is an edge from the ICFG \nlabeled by St, and (3) post is the postcondition operator. For any statement, except for procedure calls \nand returns, post affects only the part of the heap reachable from nodes labeled by variables in loc. \nFor simplicity, we assume that (1) heaps don t con\u00adtain garbage, i.e., all the nodes are reachable from \nnodes labeled by pointer variables, and (2) each pointer assignment p->next=q, resp. p=q, is preceded \nby p->next=NULL, resp. p=NULL. The se\u00admantics of the procedure calls and returns is based on local heaps \n[23], i.e. heaps containing only objects reachable from the actual parameters. For example, in Figure \n4(a), the local heap for the pro\u00adcedure call quicksort(left) contains only the nodes reachable from the \nnode labeled by left. As we consider only cutpoint-free programs [24], the de.nition of this semantics \nis straightforward. 3. Abstractions of program relations In this section, we recall the abstract domains \nde.ned in [2]. Preliminaries on abstract interpretation: Let C =(C,.) and A =(A,C) be two lattices (., \nresp. C, are order relations on C, resp. A). The lattice A is an abstract domain for C [7, 10] if there \nexists a monotonic function . : A . C. In the following, an abstract domain A is denoted by A =(A,C,n,u,T,.), \nwhere n denotes its greatest lower bound (meet) operator, u denotes its lowest greater bound (join) operator, \nT its top element and . its bottom element. Moreover, as usual in the abstract interpretation framework, \n. represents the widening operator. Let FC be a set of concrete transformers, that is, of functions from \nC into C. If A is an abstract domain for C, the set of its abstract transformers, denoted FA #, contains \na function f #: A . A for each f . FC . The transformer f # is sound if f (.(a)) . .( f #(a)), for any \na . A.  3.1 Abstract domains for heaps The abstraction of a labeled graph H representing (relations \nbe\u00adtween) program con.gurations is de.ned starting from a decompo\u00adsition obtained by (1) keeping only \nsome nodes from H but at least all the crucial nodes (2) adding an edge between any two nodes which are \nreachable in the initial graph, and (3) labeling every node n with a word over Z which contains the integers \non the path from H between n and its successor in the new graph. For example, Fig\u00adure 4(b) gives a decomposition \nfor the graph in Figure 4(a). Abstractions of program relations can be de.ned by represent\u00ading the values \nof the integer program variables and the words over Z as formulas in some logic. The logics we use capture \nvarious aspects such as constraints on the sizes, the multisets of their let\u00adters, or the data at different \npositions of the words. For example, the graph and the formula .c in Figure 4(c) represent an abstrac\u00adtion \nof the program relation in Figure 4(a) obtained starting from the decomposition in Figure 4(b). The same \nholds for the graph and the multiset formula .1 in Figure 4(c). Such a pair between a graph c and a formula \nis called abstract heap. In the formula .c, na0, na, nl , nr, and np are variables interpreted as words \nover Z, hd(nl ) de\u00adnotes the .rst letter of the word denoted by nl , len(na) denotes the length of the \nword denoted by na, y is a variable interpreted as a position in some word (as usual, the positions of \na word a0 a1 ...an are the integers from 0 to n), y . tl(nl ) means that y belongs to the tail of nl \n(i.e., the suf.x starting with the second letter), and nl [y] is a term interpreted as the letter at \nthe position y of nl . The formula eq.(na,n0) states that the words denoted by na and n0 are identi\u00ad \naa cal. We distinguish the .rst letter of a word from its tail because programs assignments can update \nonly this .rst letter (the state\u00adment p->data=... updates the .rst letter of the word associated to the \nnode labeled by p). In the multiset formula, ms(na) denotes the multiset containing all the letters of \nna. Let Z+ denote the set of non-empty sequences over Z and let DWVar be a set of data word variables \ninterpreted as elements of Z+.A data words logic is a (possibly in.nite) set of formulas from a .rst \norder logic FO(DWVar,DVar,O,P) over the variables DWVar .DVar, where Ois a set of operation symbols and \nPis a set of predicate symbols. In order to express program transformations we suppose that O contains \nat least the concatenation operator \u00b7,a function symbol len : Z+ . Zwhich returns the length of the input \nsequence and the equality predicate between words eq. However, we do not require that these symbols are \nused in the set of formulas belonging to some data words logic. DEFINITION 3.1 (LDW-domain). A logical \ndata words abstract domain over DWVar and DVar (LDW-domain, for short) is a lattice AW = AW ,CW ,nW , \nuW , TW ,.W , where AW is a data words logic, which is an abstract domain for the lattice of sets of \npairs (L, D) with L : DWVar . Z+ and D : DVar . Z. Notice that CW is a sound approximation of the logical \nimpli\u00adcation . between formulas (i.e., if .1 CW .2 then .1 . .2).  DEFINITION 3.2 (Abstract heap). An \nabstract heap over PVar, DVar, and an LDW-domain AW is a tuple W H =(N,S,V,W ) where N,S,V are as in \nthe de.nition of heaps, and W is a formula in AW over the data word variables N \\{r} (we assume that \nfor each node in N there exists a data word variable with the same name) and the data variables DVar. \nA k-abstract heap is an abstract heap with at most k simple nodes. Two abstract heaps are isomorphic \nif their underlying graphs are isomorphic. Let CH denote the lattice of sets of heaps. We de\u00ad.ne AH(k,AW) \nan abstract domain for CH whose elements are k\u00adabstract heaps over AW s.t. (1) for any two isomorphic \nabstract heaps, the lattice operators are obtained by applying the corre\u00adsponding operators between the \nvalues from AW, and (2) the join and the widening (resp. meet) of two non-isomorphic abstract heaps is \nTH (resp. .H). Notice that .H is a widening operator be\u00adcause the heaps generated by the programs which \nmanipulate only singly-linked lists contain a bounded number of crucial nodes [19]. The domains used \nin the analysis are .nite powerset domains over AH(k,AW). Their elements are called k-abstract heap sets. \nDEFINITION 3.3 (Abstract heap set). Ak-abstract heap set over PVar, DVar, and an LDW-domain AW is a .nite \nset of non\u00adisomorphic k-abstract heaps over PVar, DVar, and AW. The ab\u00adstract domain of k-abstract heap \nsets is denoted by AHS(k,AW)= AHS(k,AW),CHS HS HS , THS ,.HS ,n,u, where AHS(k,AW) is the set of all \nk-abstract heap sets over PVar, DVar, and AW. The operators from AHS(k, AW) and the widening operator \nare obtained from those of AH(k,AW) as usual [9]. For example, the join of two abstract heap sets is \ncomputed by taking the union of these sets and by applying the join operator between any two isomorphic \nabstract heaps.  3.2 An LDW-domain with universally quanti.ed formulas UU We present the abstract domain \nAU = AU ,CU ,n,u,TU ,.U whose elements are .rst-order formulas with free variables in DWVar .DVar. This \ndomain is parametrized by a set of constraints on position variables (which are interpreted as positions \nin the words), called guard patterns. Guard patterns are conjunctions of: formulas that associate vectors \nof position variables with data word variables (y . tl(.) means that the position variables from the \nvector y are interpreted as positions in the tail of .),  formulas that impose a total order between \nthe values of the position variables associated with the same data word variable (y1 -1 y2 -2 ... -m \nym, where -i. {=,<,<1} with y <1 y1 iff  1 y= y + 1), and a linear constraint on the values of the position \nvariables which are the .rst in the order constraints considered above. Let V . DWVar and let P be a \nset of guard patterns. Also, let P(V ) be a set of formulas obtained from guard patterns in P by substituting \nall data word variables with variables from V . An element of AU is a formula of the form: W (V ) ::= \nE(V ) ..y. g(y) . Ug (E) g(y).P(V ) where E(V ) is a quanti.er-free arithmetical formula over DVar and \nterms hd(w), len(w) with w . V , g(y) is a guard over the vector of position variables y, and Ug is a \nquanti.er-free arithmetical formula over the terms in E(V ) together with w[y] and y, for any w . V and \ny . y. It is assumed that the term w[y] appears in Ug only if g(y) associates y with w. Also, E and Ug \nrepresent elements of some numerical abstract domain AZ = AZ ,CZ ,nZ ,uZ ,TZ ,.Z which is a parameter \nof AU. Lattice operators: The value TU (resp. .U) is de.ned by the formula in which E and all Ug are \nTZ (resp. .Z). Let W (V1)= E(V1) .g(y).P(V1) .y. (g(y) . Ug) and W 1(V2)= E1(V2) .g(y).P(V2) .y. (g(y) \n. U1 ). g Before applying any lattice operator we add to W (resp. W 1) univer\u00adsally quanti.ed formulas \n.y. g(y) .TZ, for any g(y) . P(V1) \\ P(V2) (resp. g(y) . P(V2) \\ P(V1)). Then, W CU W 1 iff (1) E CZ \nE1, and (2) for each guard g(y) . P(V1) .P(V2) which associates the vector of position variables yi with \nthe data word variable wi, for all 1 = i = n, the following holds: if E CZ len(wi) =|yi| + 1, for all1 \n= i = n, then E nZUg CZ Ug1 . Also, W uUW 1 is de.ned by  ZE1ZU1 E u..y. g(y) .Ug u g. g(y).P(V1).P(V2) \nThe operators nU and .U are de.ned in a similar way.  3.3 An LDW-domain with multiset formulas We present \nthe abstract domain AM = AM , CM ,nM , uM ,TM ,.M whose elements are multiset constraints with free variables \nin DWVar . DVar.A basic multiset term is u ::= mhd(n) | mtl(n) | d, where n . DWVar and d . DVar. The \nterm mhd(n) (resp. d) represents the singleton containing the .rst letter of the word associated to n \n(resp. the value of d). The term mtl(n) represents the multiset containing all the letters of the word \nassociated to n except for the .rst one. As a shorthand, ms(n) denotes the term mhd(n) . mtl(n). A multiset \nconstraint is a conjunction of formulas of the form u1 . u2 .\u00b7\u00b7\u00b7. us = v1 . v2 .\u00b7\u00b7\u00b7. vt , where s = 1, \nt = 1, and for all 1 = i = s and 1 = j = t, ui and vj are pairwise distinct basic multiset terms, and \n. is the usual union operator between multisets. Multiset constraints can be represented by a polyhedron \nwith a dimension for any basic term: a formula u1 . u2 . \u00b7\u00b7\u00b7. us = v1 . v2 .\u00b7\u00b7\u00b7. vt is represented by \nthe linear constraint u1 + u2 + \u00b7\u00b7\u00b7 + us = v1 + v2 + \u00b7\u00b7\u00b7 + vt . The entailment relation between the multiset \nconstraints is de.ned by the entailment relation between the corresponding polyhedra. The lattice of \nmultiset constraints is .nite (for .nite DWVar and DVar) and consequently, there is no need for a widening \noperator. 4. Abstract semantics The abstract semantics de.nes a mapping .#, which associates to each \ncontrol point of the program an abstract heap set. It is de.ned by the system of equations obtained from \nthe one de.ning the concrete semantics in (D), by replacing post with a sound abstract transformer post# \nover abstract heap sets. The termination of the .xpoint computation is guaranteed by applying the widening \noperator at the start of each intra-procedural loop and at the entry and exit point of each recursive \nprocedure. The analysis that we have implemented tabulates the input con\u00ad.gurations of the computed procedure \nsummaries. In this way, we avoid to compute twice the same procedure summary. For any label St of some \nICFG edge, we de.ne post# as follows: if St is different from assume, assert, procedure call and procedure \nreturn, we .rst de.ne the abstract transformer post# over abstract heaps. Then, post#(St,HS), where HS \nis some abstract heap set, is the join in AHS of post#(St, H ), for each H . HS; otherwise, we de.ne \npost# directly over abstract heap sets.  The statement p=NULL: The abstract transformer corresponding \nto this statement begins by moving the label p to the node r. It may happen that the obtained abstract \nheap contains more than k simple nodes. If it is the case, the transformer calls a procedure called fold# \nwhich, for any H . AH, returns an abstract heap H 1 with no simple nodes which over-approximates H (i.e., \nthe concretization of H 1 includes the concretization of H ). Let H =(N,S,V,W ) be an abstract heap and \nlet n1,...,nt be all W its simple nodes. For simplicity, suppose that they are on the same path between \ntwo crucial nodes n and m. We de.ne fold#(H )= (N1 ,S1 ,V,WW1), where (N1 ,S1) are obtained by removing \nthe nodes n1,..., nt and by adding the edge (n,m) and WW1 is a formula in AW which is an over-approximation \nof the following formula .n.n1 ....nt . n = n \u00b7 n1 \u00b7 ... \u00b7 nt .WW[n . n]. (F) The formula in (F) belongs \nto AW extended with quanti.cation over data word variables, and a concatenation operation symbol \u00b7 . \nIntuitively, (F) says that the word associated to n in fold#(H ) (denoted in (F) by n) is the concatenation \nof the words associated to n,n1,...,nt in H . The transformer concat# from [2] computes an over\u00adapproximation \nof (F) in AU. It is precise for domains AU parametrized by closed sets of patterns. Roughly, a set of \npatterns P is closed if whenever it contains a pattern P over the set of position variables y it also \ncontains all the projections of P (in Presburger arithmetics) on subsets of y. In AM, an over-approximation \nof (F) can be obtained by: updating in WW, mtl(n1) to mtl(n1) . mhd(n2) . mtl(n2) .\u00b7\u00b7\u00b7. mhd(nt ) . mtl(nt \n) removing all the constraints on the variables n2,...,nt . Statements involving reference .elds: For \na statement St of the form p->next=NULL (resp. q=p->next), the concrete post mod\u00adi.es the edge (resp. \nthe target of the edge) starting in the node labeled by p. The abstract transformer post#(St,H ), where \nH = (N,S,V,WW), can not directly modify this edge because it may cor\u00adrespond to a path of arbitrary length \nin the concrete heap. Thus, post#(St,H ) begins by calling a procedure unfold#(H , p) which returns two \nabstract heaps H 1 and H 2 such that the concretization of H is included in the union of the concretizations \nof H 1 and H 2. The abstract heap H 1 (resp. H 2) corresponds to the case when the length of the word \nassociated to the node n labeled by p in H is 1 (resp. strictly greater than 1). Thus, H 1 =(N,S,V,WW1) \nwhere WW1 is a formula in AW which over-approximates .1: WW. len(n)= 1 (i.e., .1 . WW1). Then, H 2 =(N1 \n, S1 ,V,WW11) corresponds to the case len(n) > 1, where (N1 ,S1) is obtained by adding a new node n1 \nbe\u00adtween n and its successor n11 in H and WW11 is a formula in AW that over-approximates the following \nformula (given in an extension of the logic of AW with quanti.cation over word variables and with a concatenation \noperation symbol \u00b7 ): .n. n = n \u00b7 n1. len(n)= 1 .WW. len(n) > 1 [n . n] (G) This formula says that the \nword associated to n in H 2 is only the .rst letter of the word associated to n in H and the word associated \nto n1 in H 2 is the tail of the word associated to n in H . The abstract transformer split# given in \n[2] computes this over-approximation in the domain of universal formulas. If WWis a multiset constraint \nin AM, an over-approximation for (G) can be obtained by substituting mhd(n) with mhd(n) . mhd(n1) . mtl(n1). \nThe statements assume and assert: The assertions . we con\u00adsider for these statements are disjunctions \nof formulas of the form .G ..W, where .G describes a unique graph (N,S,V ) as in the def\u00adinition of heaps \nand .W is a formula in the data words logic of AW over the data word variables N. For simplicity, we \nassume that .G is a separation logic formula [22] de.ned as a separating conjunction of atomic formulas \nof the form ls(n,n1), where n,n1 are variables interpreted as distinct nodes in the graph. A formula \nls(n, n1) is true in some abstract heap iff there exists an edge between the nodes represented by n and \nn1 (i.e a path connecting them in the concrete heap). We require that .G (1) contain at most one atomic \nformula ls(n, n1), for every n, and (2) induce a graph that does not contain simple nodes. Then, let \nAH be an abstract heap set from AH(AW) and let . be a formula .G . .W that describes an element A1 H \nfrom the same abstract domain AH(AW). Thus, post#(assume .,AH )= HSA1 AH nH . Also, post#(assert ., AH \n)= AH if fold#(AH ) CHS A1 H and post#(assert ., AH )= .HS, otherwise. The extension of this de.nition \nto disjunctions of such formulas is straightforward. Procedure calls: The abstract transformer corresponding \nto a call to start edge, call y = P(x), where P =(fpi,fpo,loc,G), com\u00adputes abstract heap sets over loc0 \n. loc. For any abstract heap R c =(Nc , Sc ,Vc ,Wc) from the input abstract heap set it returns an W \nW abstract heap R s =(Ns ,Ss ,Vs ,Ws), where: the local heap corresponding to the call P(x), denoted \nlocal(R c ,P(x)) = (Nx , Sx ,V x ,WWx), is de.ned by (1) (Nx ,Sx ,V x) is the sub-graph of R c containing \nonly nodes reach\u00ad able from the nodes labeled by variables in x in which actual pa\u00adrameters are replaced \nby the corresponding formal parameters and (2) WWx is an over-approximation of .(Nc \\ Nx). WWc(where \n.(Nc \\ Nx) denotes an existential quanti.cation over all the word variables in Nc \\ Nx).  the graph \n(Ns ,Ss ,Vs) contains two copies of (Nx ,Sx ,V x) (the nodes of one copy are labeled by variables in \nloc0) and WWs is an over-approximation in AW of the formula:  WW x W x . Wn . n0 | n . Nx. eq(n, n0), \nn0 . N0 , n . N n is acopyof n0 where eq(n,n0) is expressing the equality between the data of the words \ndenoted by n and n0. In AU, eq(n,n0) is expressed precisely by eq.(n,n0) : hd(n)= hd(n0) . len(n)= len(n0) \n(H) ..y1,y2. (y1 . tl(n0) . y2 . tl(n) . y1 = y2) . n0[y1]= n[y2] , while AM can represent only an over-approximation \nby eqm(n, n0) : mhd(n)= mhd(n0) . mtl(n)= mtl(n0). (I) Procedure returns: Consider now an exit to return \nedge, labeled by ret y = P(x), from the exit point of P =(fpi,fpo, loc,G), de\u00adnoted eP, to some control \npoint r in the CFG of a procedure Q. Let c be the call point associated to r and R c =(Nc ,Sc ,Vc ,WWc) \n. .#(c). The abstract transformer for ret y = P(x) computes an abstract heap set whose elements are denoted \nby R r =(Nr ,Sr ,Vr ,Wr). To W this, it uses the (pre) computed summary for this call of the pro\u00adcedure \nP, represented by an abstract heap set whose elements are denoted R e =(Ne ,Se ,Ve ,WWe). The summary \nmust satisfy the prop\u00aderty that its input con.guration Re in is implied by the constraints on the actual \nparameters, i.e. local(R c Re ,P(x)) CH in. To compute R r =(Nr ,Sr ,Vr ,WWr): we take the union between \nthe call graph (Ne ,Se ,Ve) and the ,Sout exit graph (Nout ,V out ) of the output con.guration in the \nsummary Re ,  we eliminate the input version of the parameters of P,  we de.ne WWr by (a) de.ning \nCombine(WWc ,WWe) which applies the conjunction between and Wafter it ensures that the  WWc We nodes \nin Nc belonging to the local heap of this call have the same name as the corresponding nodes in Ne representing \nthe input con.guration and (b) computing an over-approximation of .N0 . Combine(WWc ,WWe), where N0 is \nthe set of nodes in Ne representing the input con.guration. In AU and AM, over-approximations of existentially \nquanti.ed for\u00admulas can be de.ned by, roughly, removing sub-formulas contain\u00ading the existentially quanti.ed \ndata word variables. 5. Combining abstract domains Let us take a closer look to the analysis of the quicksort \nprocedure from Figure 1 with the domain of universally-quanti.ed formulas, AHS(AU), over the set of guard \npatterns y . tl(.), y1,y2 . tl(.) . y1 = y2, y1 . tl(.1) . y2 . tl(.2) . y1 = y2. The analysis manipulates \nuniversally-quanti.ed implications where the left part is one of the formulas above, where the . s are \ndata word variables. Typically, in the case of recursive proce\u00addures, the analysis starts by computing \nprocedure summaries for input lists of length 1 and then, for input lists of length 2, and so on until \nit reaches a .xpoint (to terminate it applies the widening operator). The analysis is able to compute \na procedure summary .U : sum 1 sorted(n) . len(nl ) = 2 for input lists of length at most 2, where o \n1 nrepresents the list pointed to by the output formal parameter o res of quicksort. In the next iteration, \nthe context of the .rst recursive call left=quicksort(left) is given by the graph and the formula .c \nin Figure 4(c). The abstract transformer for procedure return computes .nl . (.c . .U ). This projection \nwill sumremove all the constraints on nl which is the actual input parameter. The same holds for the \nlist pointed to by right and the second recursive call. The relation obtained after the two calls is \ngiven in Figure 5. We have lost the property that all the elements of left are less than the pivot. Consequently, \nafter calling concat, we can t obtain that the list pointed to by res is sorted. an 0 0 a . : d = hd(np) \n. len(np)= 1 . eq.(na,n0) aNULL .sorted(nl ) . len(nl ) = 3 a .sorted(nr) . len(nr) = 3, sorted(n) : \n.y. y . tl(n) . hd(n) = n[y] left ..y1, y2. ((y1, y2) . tl(n) . y1 = y2) . n[y1] = n[y2] right pivot \nFigure 5. The relation synthesized at line 17 of quicksort. Next, we give a solution for this problem \nbased on a combina\u00adtion of abstract analyses. Thus, at the return from the .rst recursive call, the abstract \ntransformer computes .nl . strengthenM .c . .U , (J) sum,.M sum 1 where .M : ms(n)= ms(nl ) is the summary \nfor quicksort com\u00ad sum o puted in AHS(AM) and strengthenM : AU\u00d7 AM . AU. The op\u00aderator strengthenM returns \n1 11 .c . .U . hd(n) = hd(np) ..y. y . tl(n) . n[y] = hd(np), sumooo and consequently, by eliminating \nthe constraints on nl (due to the existential quanti.cation), we preserve the fact that the elements \nof the list pointed to by left are smaller than the pivot. The function strengthenM is an instance of \na more general procedure denoted strengthenW. Given AW an LDW-domain, the de.nition of strengthenW uses \na procedure inferW which, for any two abstract values WWin . AU and WWaux . AW, returns an over-approximation \nof their con\u00ad junction expressed in AU. DEFINITION 5.1. Let AW be some LDW-domain and inferW : AU\u00d7 AW \n. AU such that WWin .WWaux . inferW(WWin,WWaux). The function strengthenW : AU\u00d7 AW . AU is de.ned by \nWW strengthenW(WWin,Waux)= WWin n UinferW(WWin,Waux). Before giving the formal de.nition of inferW let \nus consider two examples, one for computing inferM and one for computing inferU. Computing inferM: Consider \nthe application of strengthenM from (J). From its arguments, we should only remember the multi\u00ad 1 set \nconstraint ms(n)= ms(nl ) and the following formula: o .(nl ) : hd(nl ) = hd(np) ..y. y . tl(nl ) . nl \n[y] = hd(np) (K) which says that all the elements of the word nl are less than hd(np). The result of \nstrengthenM is computed using inferM applied on the same inputs. Roughly, to compute inferM (1) we unfold \na 1 bounded length pre.x p1, resp. p2, of the word no, resp. nl ; thus, 1 n= p1 \u00b7 s1 and nl = p2 \u00b7 s2, \nwhere \u00b7 denotes the concatenation of words, (2) we infer the properties of the nodes in p1 and p2 implied \nby the conjunction between the constraint in the domain of universally-quanti.ed formulas and the constraint \nin the multiset domain and (3) we fold the pre.xes p1 and p2 and collect the informations on these nodes \nusing a universally-quanti.ed formula. Then, we continue to apply the same transformations on the words \ns1 and s2 until we reach a .xpoint. This unfolding/folding mechanism reduces the initial problem (of \ninferring universally-quanti.ed constraints implied by the con\u00ad junction of the inputs) to the problem \nof inferring quanti.er-free constraints implied by the conjunction of the inputs. o {n1 [0], n1 [1]}. \nms(s1)= ms(nl ) {n1 [0], n1 [1]}. ms(s1)= ms(nl ) oooo 0 1 234 ... 0 1 234 ... n1 n1 o : o : sM 0 1 \n234 ... 0 1 234 ... nl : nl : (a) (b) fold 45 ... 0123 01 234 ... unfold n1 n1 o : o : 45 ... 0 \n1 234 ... 012 3 nl :nl : ms(p1) .{n1 [2], n1 [3]}. ms(s1 1)= ms(nl ) ms(p1) . ms(s1)= ms(nl ) oo (d) \n(c) Figure 6. Computing inferM. Some steps from the computation of inferM are given in Fig\u00adure 6. The \nunfolding of a pre.x of length 2 is given in Figure 6(a). Above each sub-word we give the positions from \nthe initial word it contains. The sub-words are colored if their elements satisfy the property from .(nl \n). At this step, only the sub-words of nl are col\u00ad  1 ored. In the multiset constraint, for any i = \n0, {n[i]} denotes the o 1 singleton multiset containing the element of nat position i. This o syntax \nis not exactly the one used in the formulas manipulated by our analysis but we use it for the sake of \nsimplicity. On this unfold\u00ading we apply a partial reduction operator [9], denoted sM, which deduces new \nproperties on the unfolded pre.x based on the multiset constraints. Here, it deduces that, for any 0 \n= i = 1, 11 n[i] . ms(nl ) . .(nl ) implies n[i] = hd(np). oo The result of applying sM is given in Figure \n6(b). Now, we can apply a folding operation in the two abstract domains whose result is given in Figure \n6(c). Then, we continue by unfolding another pre.x of length 2 from the sub-word of no that starts with \nposition 2 (this is pictured in Figure 6(d)). We repeat these steps until the .xpoint computation terminates. \nThe result will be: 1 inferM .c . .U = .c . .U . .(n). sum,.M sum sum o Computing inferU: Let AU1 , resp. \nAU2 , be a domain with uni\u00adversal formulas parametrized by a set of patterns P1, resp. P2. Us\u00ading a similar \nmechanism, we compute, for any WW. AU1 , an over\u00ad approximation of WWin AU2 , denoted convert(P1,P2)( \nWW). For ex\u00adample, let P1 = {y . tl(.), y1,y2 . tl(.) . y1 = y2}P2 = {y . tl(.) . y = 1, y . tl(.) . \ny = len(.) - 1, y1,y2 . tl(.) . y1 <1 y2}, and let WWbe the sortedness property sorted(n) in Figure 5. \nCom\u00adputing convert(P1,P2)( WW) allows us to prove that WWimplies .(n) : .y1,y2. (y1,y2 . tl(n) . y1 <1 \ny2) . n[y1] = n[y2] which can not be done using the entailment relation CU de.ned in AU 1 or AU2 . We \nstart with the formula WW1 : true and we apply a procedure inferU to strengthen it using the information \nfrom WW. Again, we unfold a bounded-length pre.x of n. For instance, if we unfold a pre.x of length 3, \nthe formula WW1 remains unchanged and the formula WWis transformed into a formula WW1 given by: n[0] \n= n[1] . n[1] = n[2] . n[2] = n[3] . sorted(n[3]), where sorted(n[3]) denotes the fact that the formula \nsorted is true starting from the third position of n. Then, we apply a partial reduction operator, sU, \nthat takes the existential part of WW1 and adds it to WW1. Afterwards, we apply a folding operation and \nthe word n is split into a word n1 containing only its .rst 3 elements and a word n11 containing all \nthe other elements. The formula in AU 2 becomes .y. (y . tl(n1) . y = 1) . hd(n1) = y ..y1,y2. (y1,y2 \n. tl(n1) . y1 <1 y2) . n1[y1] = n1[y2] 11). ..y. (y . tl(n1) . y = len(n1) - 1) . y = hd(n As in the \nprevious case, by iterating these two steps into a .x\u00adpoint computation that traverses all the elements \nof n, we obtain convert(P1,P2)( WW) which is given by .y. (y . tl(n) . y = 1) . hd(n) = y ..y1, y2. (y1, \ny2 . tl(n) . y1 <1 y2) . n[y1] = n[y2]. Clearly, convert(P1, P2)( WW) CU .(n) which .nishes our proof. \n 5.1 The procedure inferW The output of inferW is de.ned by the analysis of a program with\u00adout procedures \nwith an abstract domain which is a partially reduced product [9] between AHS(AU) and AHS(AW). The elements \nof this 1 while((zm!=NULL) &#38;&#38; 2 (zn!=NULL)) 3 { zm = zm->next; 4 zn = zn->next; } 5 while(zm!=NULL) \n6 zm = zm->next; 7 while(zn!=NULL) 8 zn = zn->next; Figure 7. A program for computing inferW. abstract \ndomain are pairs from AHS(AU) \u00d7 AHS(AW). The analy\u00adsis computes an invariant for the reachable program \ncon.gurations at each control point. Almost all the abstract transformers in this analysis are de.ned \nby: post# (St,(HSin,HSaux)) = (post# U(St, HSin),post# W(St,HSaux)), where post# U(St,HSin) is the abstract \ntransformer in AHS(AU) and post# W(St,HSaux) is the abstract transformer in AHS(AW). The only exception \nis the statement p=q->next whose ab\u00adstract transformer calls a a partial reduction operator [9] sW : \nAHS(AU) \u00d7 AHS(AW) . AHS(AU) \u00d7 AHS(AW). This operator propagates information between the two abstract \ndomains and its output should satisfy the following: for any AH . AHS(AU) and A1 H . AHS(AW), s1 H ) \nCHS AH , s2 H ) CHS A1 W(AH ,A1 W(AH ,A1 H , and .(s1 H )) . .(s2 H )) = .(AH ) . .(A1 W(AH ,A1 W(AH \n,A1 H ), where siH ) is the projection of sW(AH ,A1 W(AH ,A1 H ) on the ith component, for any 1 = i \n= 2. If St1: p=q->next then post#(St1 ,(HSin,HSaux)) = (L) sW(post# U(St1 ,HSin),post# W(St1 ,HSaux)). \nLet M denote the set of data word variables in WWaux. The pro\u00adgram that computes inferW depends on M. \nIn practice, we can heuristically choose to consider only some of the data word vari\u00adables in WWaux. \nThe result of inferW is still sound. For example, let M = {m,n}. The program used in inferW is given \nin Figure 7 and consists in while loops that traverse the lists represented by the nodes in M. The initial \ncon.guration of the program is a pair of abstract heaps (H in,H aux) which contain the same graph (N, \nS,V ) such that (1) the graphs contain one node for each data word variable in WWin or WWaux with an \nedge towards r, (2) each node n . N is labeled by at least two variables, one being zn, (3) H in =(N,S,V,WWin) \nand H aux =(N,S,V,WWaux). The .rst loop traverses simultaneously the two list segments. At each iteration, \nthe pointer variables zm and zn are advanced to the next element. Since the lists may not have the same \nlength, we add another two while loops to continue the traversing of the un.nished list starting from \nwhere the previous loop stopped. Let (AH ,A1 H ) . AHS(AU) \u00d7 AHS(AW) be the postcondition of this program \n(i.e, the pair of abstract heap sets associated to the last control point). Remark that fold#(AH )= {H \n} and fold#(A1 H )= {H 1}, where H and H 1 are abstract heaps that contain exactly the same graph as \nthe abstract heaps from the precondition. We de.ne inferW(WWin,WWaux)= WW, where WWis the AU formula \nfrom H projected on the variables from WWin. The partial reduction operator sW: The de.nition of sW over \nabstract heap sets uses a similar operator on abstract heaps which again, uses a similar operator on \nLDW-domains. The operator sW(AH ,A1 H ) on abstract heap sets takes the join of sW(H , H 1), for any \ntwo isomorphic abstract heaps H . AH and H . AH 1 . Then, let  mhd(n) . mtl(n1) and WWCU .y. y . n1. \n. mhd(n) . mhd(n1) .y. (.[n1[y] . hd(n))] hd(n)= hd(n1) Figure 8. Inference rules for s1 M. H =(N,S,V,WW) \n. AHS(AU) and H 1 =(N,S,V,WW1) . AHS(AW) be two isomorphic abstract heaps (we suppose that the nodes \nrelated by the isomorphism have the same name). We de.ne sW(H , N,S,V, s1 W , W, W( WWW1) H1)= W( WW \n1) N,S,V,s2 W ,. The procedure inferU: When AW is some abstract domain AU1 , we obtain an instantiation \nof inferW, denoted inferU. To de.ne inferU, we have to provide only the de.nition of the partial reduc\u00adtion \noperator sU : AU\u00d7 AU 1. AU\u00d7 AU1 . Thus, let WW, resp. WW1, be an abstract value in AU, resp. AU1 . We \nde.ne s1 W ,WW1)= WW. E1 , U( W where E1 is the quanti.er-free part of WW1, and s2 W ,WW1)= WW1 . U( \nW In the following, we will describe another instantiation of inferW, when AW is the domain of multiset \nconstraints.  5.2 Combining multiset constraints and universal formulas Let WW. AU and WW1. AM be two \nformulas over the set of data word variables N. The AU formula s1 W , W by M( WWW1) is obtained from \nWadding new constraints on the values of hd(n) with n . N based on the multiset constraint WW1. The AM \nformula s2 W , W M( WW 1) is obtained by adding to WW1 an equality mhd(n)= mhd(n1) for any equality hd(n)= \nhd(n1) implied by the .rst output. In the following, we describe the computation of s1 M(WW,WW1). To \nhelp the intuition, we start by an example. Let WW: .y. y . tl(n) . n[y] > 5 and WW1 : mhd(n1) . mtl(n2)= \nmtl(n). By an abuse of notation we can rewrite WWas .val. val . mtl(n). val < 5, where val is a variable \ninterpreted as an integer. Notice that WW1 implies that hd(n1) belongs to mtl(n) and conse\u00adquently we \nobtain that WW.WW1 implies hd(n1) < 5. This deduction can be done using the .rst inference rule in Figure \n8. In general, a multiset constraint induces multiple choices w.r.t. the multisets to which the singletons \nbelong to. For example if WW1 ::= mhd(n1) .mtl(n2)= mtl(n) .mtl(m) then WW1 implies that either hd(n1) \n. mtl(n) or hd(n1) . mtl(m). In each case, the property on hd(n1) added to the formula WWmight be different. \nHowever, there are a .nite number of choices. For each of them, we construct a strengthening of WWand \nthen we de.ne s1 W , M( WWW1) as the join of all of these strengthenings. Formally, the formula s1 M(WW,W \n1) is built as follows: W 1. we deduce the set of all conjunctions of the form . ::= mhd(n1) . bt1 . \n... . mhd(nk) . btk, (M) where bti is a basic multiset term, for any 1 = i = k, such that (1) WW1 implies \nthe disjunction of all formulas . as above (in the logic obtained from AM by adding the usual inclusion \noperator between multisets .) and (2) . contains exactly once all the terms of the form mhd(ni) from \nWW1. Note that if, for example, bt1 = mhd(n1) then the conjunction will not contain any other atomic \nformula over the term mhd(n1). 2. for every such conjunction, we use its atomic formulas to apply the \ninference rules in Figure 8 and deduce new facts on the values of hd(n) with n . N. These facts are conjuncted \nto WW. W 3. s1 M(WW,W 1) is the join of all abstract values in AU obtained in the previous step. 6. Applications \nIn this section, we describe several applications of the procedure strengthenW. 6.1 Changing the set \nof patterns To obtain a compositional analysis with the abstract domain AHS(AU), we need to transform \nan abstract value A1 in a domain AHS(AU1 ) over a set of patterns P1 into an abstract value A2 ina domain \nAHS(AU2 ) over a set of patterns P2= P1. Thus, we de.ne an operator convert(P1,P2) : AU 1 . A2 U parameterized \nby a pair of pattern sets (P1, P2), such that convert(P1,P2)(WW1) is an over-approximation of WW1 in \nthe do\u00admain AU2 . Intuitively, convert(P1,P2)(WW1) returns a formula WW2 which contains (1) constraints \nfrom WW1 using the patterns in P1 nP2 and (2) constraints using the patterns in P2 \\ P1 implied by WW1 \n(in FO(DWVar,DVar, O, P)). Thus, convert(P1,P2)(WW1)= strengthenU2 (TU2 ,WW1), where TU2 is the top element \nin AU2. The extension of convert to an operator on the AHS(AU) domains is done in a straightforward manner: \nthe graph is kept the same and only constraints associated to the graph are converted. This operator \nis the base ingredient for the following applications. 6.2 Computing procedure summaries In order to \nbe able to compute procedure summaries parametrized by different sets of guard patterns, we modify the \nde.nition of the abstract transformers corresponding to procedure calls and re\u00adturns as follows. Let \nQ1 be a procedure for which a set of patterns P1 has been .xed. Suppose that Q1 calls a procedure Q2 \nassoci\u00adated with the set of patterns P2. The transformer post#(call y = Q2(x),R c), where R c is over \nthe patterns P1, computes the local graph local(R c ,Q2(x)) (see Section 4) over patterns in P1 and then \napplies convert(P1, P2) to obtain an over-approximation of the local graph for Q2. Similarly, the transformer \npost#(ret y = Q2(x)) is modi.ed by applying convert(P2,P1) to the combina\u00adtion between the context of \nthe call and the summary for Q2. As shown for the quicksort example, the strengthenM oper\u00adator allows \nto increase the precision of the analysis in the AHS(AU) domains. For this, the analysis computes two \nover-approximations for the mapping . de.ning the semantics of a program: a map\u00adping .# M with val- U \nwith values in AHS(AU) and a mapping .# ues in AHS(AM). The abstract values at the initial control point \nof the CFG, c0, are such that .# M(c0) is an over-approximation in AHS(AM) of .# U and .# U(c0). The \nrecursive equations for .# M re\u00admain unchanged. The only difference is the de.nition of the ab\u00adstract \ntransformer in AHS(AU) corresponding to procedure returns. ret y=Q2(x) Consider the edge eQ2 - ------.r \nin the CFG of some procedure Q1. Also, let c be the call point associated to r. The abstract transformer \npost#(ret y = Q2(x),R e), where R e = WU(eQ2 (Ne ,Se ,Ve ,We) . .# ), is an abstract heap set obtained \nby composing any relation R c =(Nc ,Sc ,Vc ,WWc) . .U# (c) with R e and a relation aux = aux,Se aux, \naux). This R e (Ne WWe ) . .# aux,Ve M(eQ2 composition is applied only if the three relations correspond \nto the same call. If it is the case, the composition is an abstract heap R r =(Nr , Sr ,Vr ,WWr), where \n(Nr ,Sr ,Vr) is built as in Sec\u00adtion 4, and WWr is built by replacing Combine(WWc ,WWe) with strengthenM(Combine(WWc \n,WWe),WWaux).  6.3 Assertion checking Let A1 U) computed at H be the abstract value in a domain AHS(A1 \nthe control point of the statement assert ., where . describes an element A2 U). If P1 = P2, checking \nthat A1 H satis.es . is H . AHS(A2 H ) CHS done using the entailment operator of AHS, i.e. fold#(A1 A2 \nH . To improve the precision of this entailment checking, we H ,Aaux can apply strengthenM(A1 ), where \nAaux is the assertion HH  3 y1=P1(fpi1); 4 y2=P2(fpi2); 5 assert(equal(y1 ,y2)); Figure 9. Procedure \nequivalence checking. synthesized by AHS(AM) at the same control point, to obtain A1 H in H ) CHS A2 \nAHS(AU1 ) and then check that fold#(A1 H in AHS(AU1 ). When P1 = P2, we modify the abstract transformer \nof assert . such that, for any abstract heap set A1 U), H . AHS(A1 post#(assert .,A1 = A1 H if fold#(convert(P1,P2)(AH \n1 )) CHS H ) A2 H in H , i.e., the output of fold# for the over-approximation of A1 AHS(AU2 ) entails \nA2 H .  6.4 Equivalence checking Let P1 and P2 be two procedures having the same input and output formal \nparameters. Then, P1 and P2 are equivalent if they return exactly the same heap when they receive the \nsame input. We use the program in Figure 9 to obtain a sound procedure for equiva\u00adlence checking. In \nevery con.guration of this program, the heap contains two disjoint regions, each region representing \nthe heap con.guration of one of these procedures. Initially, the program as\u00adsumes that the heap contains \ntwo copies of the same input con\u00ad.guration. For that, we use the predicate equal(fpi1,fpi2) where fpi1 \nand fpi2 are two copies of the input parameters. We consider that equal(fpi1, fpi2) holds for an abstract \nheap if and only if it is formed of two sub-graphs G1 and G2 s.t. (1) G1, resp. G2, con\u00adtains only nodes \nreachable from pointer variables in fpi1, resp. fpi2, (2) G1 and G2 are isomorphic, and (3) for any two \nnodes re\u00adlated by the isomorphism, the integer sequences attached to them are equal. Equality of integer \nsequences can be expressed using the universally-quanti.ed formula eq. given by the equation (H) (page \n6). The two procedures are called on this input con.guration. Notice that the procedure P1 (resp. P2) \ncan modify only the graph G1 (resp. G2). The inter-procedural analysis applied to this pro\u00adgram computes \nan invariant I describing the con.gurations reach\u00adable after returning from the two procedures (line \n5). This invari\u00adant is formed of a set of abstract heaps. The two procedures are equivalent if for any \nabstract heap in I, the regions reachable from the output parameters of P1, y1, and from the output parameters \nof P2, y2, are equal. To express this equality we use the predicate equal(y1,y2). Notice that the program \nin Figure 9 can be used in the intra\u00adprocedural setting by inlining the procedures. However, the advan\u00adtage \nof the compositional inter-procedural analysis is that each pro\u00adcedure is analyzed independently (using \nthe local heap semantics). 7. Experimental results Implementation details: We have implemented our inter\u00adprocedural \nanalysis in a plugin called CELIA [5] of the FRAMA-C platform[4]for Cprogramanalysis. CELIA takesasinputtheICFG \nbuilt by FRAMA-C from the C program. The implementation of CELIA invokes/adapts (1) the heap abstract \ndomains AHS(AU) and AHS(AM) providedbythe CINV tool[2],(2)thenumericaldomains of the APRON platform [17], \nand (3) the generic module of .xpoint computation over control-.ow graphs due to B. Jeannet [16]. It \nhas been carried out by implementing in C the abstract transformers including the abstract domain combination/strengthening. \nBenchmark: We have applied CELIA to a benchmark of C pro\u00adgrams which is available on the web site of \nCELIA. The benchmark includes all the basic functions that are used in usual libraries on singly-linked \nlists, for example the GTK gslist library which is part of the Linux distribution. Table 1 gives a sample \nof functions in this benchmark, split in six classes. The class sll includes C func\u00adtions performing \nelementary operations on list: adding/deleting the f irst/last element, initializing a list of some length. \nThe classes map and map2 include C functions performing a traversal of one resp. two lists, without modifying \ntheir structures, but modifying their data. The classes fold and fold2 include C functions computing \nfrom one resp. two input lists some output parameters of type list or integer. Finally, the sort class \nincludes sorting algorithms on lists. The procedures in classes map* and fold* are tail recursive, thus \nwe consider for them both iterative and recursive versions. The third column of Table 1 speci.es the \nversions considered (itera\u00adtive/recursive) and the number of nested loops or recursive calls. The benchmark \nalso contains programs which do several calls of the above functions on lists. For example, we handle \nsome pro\u00adgrams manipulating chaining hash tables. For that, we use ab\u00adstraction techniques (slicing, \nunfolding .xed-size arrays) available through the Frama-C platform. Also, the benchmark includes pro\u00adgrams \nallowing to test the applications discussed in the previous section and which we detail in the following. \nComputing procedure summaries: Table 1 describes some of our experimental results on the synthesis of \nprocedure summaries. Column 5 indicates the set of patterns used for the analysis with AHS(AU). These \npatterns are: P=(x,x1) =.y1 . tl(x), y2 . tl(x1). y1 = y2, P1(x) =.y . tl(x), P2(x) =.y1, y2 . tl(x). \ny1 = y2 The pattern P= is used by default for each analysis since it is needed to capture the relation \nof equality between actual and formal function parameters. The choice of P1 and P2 is made according \nto a heuristics that is based on syntactical criteria such as the number of nested loops or the number \nof recursive calls in the body of the program. (These numbers are reported in column 3 of Table 1.) The \npattern P1 is used for programs with at least one loop (resp. recursive call) and one iteration variable \nover lists. The pattern P2 is used for nested loops, more than one recursive call, or two iteration variables. \nColumn 6 of Table 1 shows samples of procedure summaries that CELIA can synthesize. (We use the &#38; \nsign to denote, like in C, the output parameters.) Columns 4 5 provide the global running times for the \nanalysis, including calls to the APRON libraries. All experiments have been done on an Intel i3-370M \nwith 2.4 GHz and 2 GB of RAM. All examples in our benchmark corresponding to common func\u00adtions for list \nmanipulation (classes sll fold2 in Table 1, except the function merge) are analyzed in less than 1 second. \nDuring the anal\u00adysis of these programs, the manipulated relations are represented using at most 6 abstract \nheaps, each of them having at most 16 nodes. For the rest of the examples, these relations have at most \n18 abstract heaps. The sorting algorithms are time consuming due to (1) the use of widening operators \n(we have implemented) that are more accurate than the standard ones available in APRON, and (2) the frequent \nuse of the strengthen operation in examples such as quicksort. Besides dealing with recursion, compositional \ninter-procedural allows to have a much more scalable analysis. For instance, con\u00adsider a program that \ncalls the init(v) function on 10 different lists. Our analysis computes once the summary of this function \nand reuse it, while the analysis after inlining computes successively the effect of all the calls. Thus, \nthe inter-procedural analysis is ten times faster for this example than the intra-procedural analysis. \nCombination of abstract domains: The use of the strengthen operation is needed in many examples of programs \nwith procedure calls. For instance, as we have seen throughout the paper, the analysis of the recursive \nsorting algorithm quicksort requires  class fun nesting (loop,rec) AM t (s) P AU t (s) Examples of summaries \nsynthesized create (0,-) 0.013 P=,P1 0.021 addfst  0.003 P= 0.002 sll addlst (0, 1) 0.031 P= 0.033 .# \nU(create(&#38;x,e)) : hd(x) = 0 . len(x) = e . .y . tl(x) . x[y] = 0 delfst  0.001 P= 0.001 dellst (0, \n1) 0.034 P= 0.042 init(v) (0, 1) 0.024 P=,P1 0.034 .# U(init(v, x)) : len(x0) = len(x) . hd(x) = v . \n.y . tl(x). x[y] = v map initSeq add(v) (0, 1) (0, 1) 0.024 0.021 P=,P1 P= 0.034 0.032 .# U(add(v, x)) \n: len(x0) = len(x) . hd(x) = hd(x0) + v. .y1 . tl(x), y2 . tl(x0). y1 = y2 . x[y1] = x0[y2] + v map2 \nadd(v) (0, 1) 0.089 P= 0.517 .# U(add(v, x,z)) : len(x0) = len(x) . len(z0) = len(z) . eq.(x,x0). copy \n(0, 1) 0.063 P= 0.078 .y1 . tl(x), y2 . tl(z). y1 = y2 . x[y1] + v = z[y2] delPred (0, 1) 0.062 P=,P1 \n0.145 .# M(split(v, x,&#38;l,&#38;u)) : ms(x) = ms(x0) = ms(l) . ms(u) fold max (0, 1) 0.031 P=,P1 0.048 \n.# U(split(v, x,&#38;l,&#38;u)) : eq.(x, x0) . len(x) = len(l) + len(u). clone (0, 1) 0.071 P= 0.315 \nl[0] = v . .y . tl(l) . l[y] = v. split (0, 1) 0.245 P=,P1 0.871 u[0] > v . .y . tl(u) . u[y] > v equal \n(0, 1) 0.127 P= 0.261 .# M(merge(x,z, &#38;r)) : ms(x) . ms(z) = ms(r) . ms(x0) = ms(x) . ... fold2 concat \n(0, 1) 0.217 P=,P1,P2 0.806 .# U(merge(x,z, &#38;r)) : eq.(x,x0) . eq.(z,z0) . sorted(x0) . sorted(z0). \nmerge (0, 1) 1.014 P=,P1,P2 2.306 sorted(r) . len(x) + len(z) = len(r) sort bubble insert (1,-) (1,-) \n0.387 0.557 P=,P1,P2 P=,P1,P2 2.190 3.292 .# M(quicksort(x)) : ms(x) = ms(x0) = ms(res) quick (-, 2) \n1.541 P=,P1,P2 121.1 .# U(quicksort(x)) : eq.(x, x0) . sorted(res) merge (-, 2) 1.547 P=,P1,P2 95.94 \n Table 1. Experimental results for functions in our benchmark. combining universal formulas with multiset \nconstraints. Without this combination, the quicksort procedure must be transformed to have two parameters \n(the .rst and the last element of the list), like in [24]. Therefore, the pivot is given as a parameter \nwhich helps to recover at the return from the recursive calls the property that all elements are less/greater \nthan the pivot. Actually, the techniques of [24] cannot handle the version of quicksort given in Figure \n1, which is the standard implementation of the quicksort. Non-recursive programs may also need strengthening \nopera\u00adtions for their analysis due to the fact that different sets of pat\u00adterns may be used for different \nprocedure calls. To experiment that, we have considered programs performing multiple calls to proce\u00addures \ngiven in Table 1, taking {P=,P1,P2} as set of patterns for the analysis of the main procedure. For example, \nwe have considered a procedure that calls bubblesort on a list x, and then copies it in a variable y \nusing the procedure clone (the procedure bubblesort is analyzed using {P=,P1,P2} and the procedure clone \nusing {P=}). For the call to clone, we obtain that the two lists x and y are equal, but the sortedness \nproperty of x is not transferred to y. However, this property can be recovered at the return of clone \n(using the strengthen operation) from the fact that y is equal to x and that x is sorted. Equivalence \nchecking: We have experimented this approach for checking equivalence between sorting algorithms. The \nstrengthen operation plays an essential role. To explain this, con\u00adsider the example from introduction \nwhich considers the equiva\u00adlence checking of two sorting procedures P1 and P2 working on two input lists \nI1 and I2, and producing two outputs O1 and O2. The problem is reduced to checking the validity of the \nimplication (C) (page 3) because, for the template of Figure 9, we have that: equal(I1,I2) corresponds \nto the assume statement at line 1,  sorted(O1) (resp. ms(I1)= ms(O1)) is the summary of P1 in the AU \n(resp. AM) domain,  sorted(O2) (resp. ms(I2)= ms(O2)) is the summary of P2 in the AU (resp. AM) domain, \n equal(O1,O2) corresponds to the assert statement at line 5.  As explained in Section 6.4, the equal(I1,I2) \nannotation is trans\u00adlated in the AU domain into a eq. formula (equation H) and ap\u00adproximated in the AM \ndomain into the eqm formula (equation I). To check the validity of (C), we call strengthen(.U ,.M) where: \n.U : eq.(I1,I2) . sorted(O1) . sorted(O2) .M : ms(I1)= ms(I2) . ms(I1)= ms(O1) . ms(I2)= ms(O2), and \nobtain the universally quanti.ed formula .U. eq.(O1,O2). For all experiments, the time needed to check \nthe validity of (C) is negligible compared with the time to compute the procedure summaries. 8. Related \nwork Automatic synthesis of assertions about programs with dynamic data structures has been addressed \nusing different approaches in\u00adcluding abstract interpretation [2, 3, 6, 8, 11 13, 15, 20, 21, 23 27, \n29], constraint solving [1, 14], Craig interpolants [18]. In the intra-procedural case, several works \nconsider invariant synthesis for programs that manipulate dynamic data structures. The generated invariants \nare either universally-quanti.ed .rst\u00adorder formulas [2, 13, 15, 20] or multiset constraints [2, 21]. \nConcerning the approaches based on abstract interpretation which can handle procedure calls, most of \nthem [3, 8, 23, 25] focus on shape properties and do not consider constraints on sizes and data. The \napproach in [24] can synthesize procedure summaries that describe data if the instrumentation predicates \nwhich guide the abstraction speak about data. Providing patterns is simpler than providing instrumentation \npredicates on data because patterns con\u00adtain only constraints between (universally-quanti.ed) positions \n(in the left-hand-side of the implication) and no constraints on data. For example, in [24] the predicate \ndle(v,u) allows to synthesize the summary for a procedure that sorts in ascending order, but cannot be \nused for a procedure that sorts in descending order. However, using the pattern y1 = y2 allows with our \napproach to synthesize the summaries for both kind of procedures. The same pattern may also allow to \ndiscover other properties than sortedness. Actually, patterns are in many cases simple (ordering/equality \nconstraints) and can be discovered using natural heuristics based on the pro\u00adgram syntax or proposed/guessed \nby the user, whereas constraints on data can be more complex. Our approach allows to discover (maybe \nunpredictable) data constraints for given guard patterns. To establish the fact that a procedure preserves \nthe data values in the input list, the method used in [24] is based on reachability, that is, every cell \nin the input list remains reachable in the output list. This method can be applied only for programs \nthat never modify/per\u00admute the contents of data .elds. In our approach, using the multiset domain, we \ncan handle programs that can permute positions of cells in the list or modify/permute the contents of \ntheir data .elds.  The approach in [11] considers abstract domains where the el\u00adements are pairs formed \nof a graph and a constraint on data. The inter-procedural analysis based on these domains can not synthe\u00adsize \nconstraints in form of universally-quanti.ed formulas as our analysis can do. In [26], the authors introduce \ntrace partitioning abstract domains which start from a partition of the set of traces and compute an \ninvariant for each class. The partitioning can be static (usually based on the control structure of the \nprogram) or dynamic. From this point of view, the approach in [26] considers mainly statically-de.ned \npartitions. The abstract domain in our pa\u00adper, based on the unfolding/folding operations, can be seen \nas an instance of a trace partitioning abstract domain with a dynamic par\u00adtitioning. The corresponding \npartitioning puts in the same class all the traces for which the number of dereferences of the next pointer \n.eld is the same modulo some .xed constant k (which is a parame\u00adter of the analysis). The approach in \n[26] considers mainly numer\u00adical abstract domains and it is not faced to the dif.culties raised by a \ncompositional analysis on programs manipulating dynamic data structures. The analysis in [12] combines \na numerical abstract do\u00admain with a shape analysis. It is not restricted by the class of data structures \nbut it considers only properties related to the shape and to the size of the memory. 9. Conclusion We \nhave de.ned an accurate inter-procedural analysis for programs with lists and data. The key contribution \nof this paper is a technique for combining the analysis in different abstract domains and its use in \ncompositional analysis techniques that are able to infer non trivial procedure summaries. The combination \nmechanism we propose, based on an unfold\u00ading/folding technique combined with partial reduction operators, \ncould be applied for other abstract domains than those consid\u00adered in this paper. In particular, other \nabstract domains based on .rst-order formulas, e.g., the one de.ned in [13], can be used to strengthen \nthe analysis in our domain of universal formulas. Another interesting aspect of our work is that it allows \nto ma\u00adnipulate constraints without requirement of decidability, contrary to many works based on decision \nprocedures. Our abstract do\u00admains allow actually to express veri.cation conditions that appear in pre-post \ncondition reasoning. These conditions are typically im\u00adplications, and then, our entailment checking \ncan be used to check safely their validity. Therefore our framework allows to combine smoothly pre-post \ncondition reasoning with assertion synthesis. Future work includes the generalization of our framework \nto structures such as multi-linked lists, trees, and nested structures. References [1] D. Beyer, T.A. \nHenzinger, R. Majumdar, and A. Rybalchenko. In\u00advariant synthesis for combined theories. In VMCAI, volume \n4349 of LNCS, pages 378 394. Springer, 2007. [2] A. Bouajjani, C. Dr.agoi, C. Enea, A. Rezine, and M. \nSighireanu. Invariant synthesis for programs manipulating lists with unbounded data. In CAV, volume 6174 \nof LNCS, pages 72 88. Springer, 2010. [3] C. Calcagno, D. Distefano, P.W. O Hearn, and H. Yang. Composi\u00adtional \nshape analysis by means of bi-abduction. In POPL, pages 289 300. ACM, 2009. [4] CEA. Frama-C Platform. \nhtp://frama-c.com. [5] Celia plugin. http://www.liafa.jussieu.fr/celia. [6] B.-Y.E. Chang and X. Rival. \nRelational inductive shape analysis. In POPL, pages 247 260. ACM, 2008. [7] P. Cousot and R. Cousot. \nAbstract interpretation: A uni.ed lattice model for static analysis of programs by construction or approxima\u00adtion \nof .xpoints. In POPL, pages 238 252. ACM, 1977. [8] P. Cousot and R. Cousot. Static determination of \ndynamic properties of recursive procedures. In IFIP Conf. on Formal Description of Programming Concepts, \npages 237 277. North-Holland Publishing Company, 1977. [9] P. Cousot and R. Cousot. Systematic design \nof program analysis frameworks. In POPL, pages 269 282. ACM, 1979. [10] P. Cousot and R. Cousot. Abstract \ninterpretation frameworks. Journal of Logic and Computation, 2(4):511 547, 1992. [11] A. Deutsch. On \ndetermining lifetime and aliasing of dynamically allocated data in higher-order functional speci.cations. \nIn POPL, pages 157 168. ACM, 1990. [12] S. Gulwani, T. Lev-Ami, and S. Sagiv. A combination framework \nfor tracking partition sizes. In POPL, pages 239 251. ACM, 2009. [13] S. Gulwani, B. McCloskey, and A. \nTiwari. Lifting abstract interpreters to quanti.ed logical domains. In POPL, pages 235 246. ACM, 2008. \n[14] A. Gupta, R. Majumdar, and A. Rybalchenko. From tests to proofs. In TACAS, volume 5505 of LNCS, \npages 262 276. Springer, 2009. [15] N. Halbwachs and M. P\u00b4eron. Discovering properties about arrays in \nsimple programs. In PLDI, pages 339 348. ACM, 2008. [16] B. Jeannet. Fixpoint. http://gforge.inria.fr/. \n[17] B. Jeannet and A. Min\u00b4e. Apron: A library of numerical abstract domains for static analysis. In \nCAV, volume 5643 of LNCS, pages 661 667. Springer, 2009. [18] R. Jhala and K.L. McMillan. Array abstractions \nfrom proofs. In CAV, volume 4590 of LNCS, pages 193 206. Springer, 2007. [19] R. Manevich, E. Yahav, \nG. Ramalingam, and S. Sagiv. Predicate ab\u00adstraction and canonical abstraction for singly-linked lists. \nIn VMCAI, volume 3385 of LNCS, pages 181 198. Springer, 2005. [20] B. McCloskey, T.W. Reps, and S. Sagiv. \nStatically inferring complex heap, array, and numeric invariants. In SAS, volume 6337 of LNCS, pages \n71 99. Springer, 2010. [21] V. Perrelle and N. Halbwachs. An analysis of permutations in arrays. In VMCAI, \nvolume 5944 of LNCS, pages 279 294, 2010. [22] J. C. Reynolds. Separation logic: A logic for shared mutable \ndata structures. In LICS, pages 55 74. IEEE Computer Society, 2002. [23] N. Rinetzky, J. Bauer, T.W. \nReps, S. Sagiv, and R. Wilhelm. A semantics for procedure local heaps and its abstractions. In POPL, \npages 296 309. ACM, 2005. [24] N. Rinetzky, S. Sagiv, and E. Yahav. Interprocedural shape analysis for \ncutpoint-free programs. In SAS, volume 3672 of LNCS, pages 284 302. Springer, 2005. [25] X. Rival and \nB.-Y.E. Chang. Calling context abstraction with shapes. In POPL, pages 173 186. ACM, 2011. [26] X. Rival \nand L. Mauborgne. The trace partitioning abstract do\u00admain. ACM Transactions on Programming Languages \nand Systems, 29, 2007. [27] S. Sagiv, T.W. Reps, and R. Wilhelm. Parametric shape analysis via 3-valued \nlogic. ACM Transactions on Programming Languages and Systems, 24(3):217 298, 2002. [28] M. Sharir and \nA. Pnueli. Two approaches to interprocedural data .ow analysis. In Program Flow Analysis: Theory and \nApplications, pages 189 234. New York University, 1981. [29] V. Vafeiadis. Shape-value abstraction for \nverifying linearizability. In VMCAI, volume 5403 of LNCS, pages 335 348. Springer, 2009.   \n\t\t\t", "proc_id": "1993498", "abstract": "<p>We address the problem of automatic synthesis of assertions on sequential programs with singly-linked lists containing data over infinite domains such as integers or reals. Our approach is based on an accurate abstract inter-procedural analysis. Program configurations are represented by graphs where nodes represent list segments without sharing. The data in these list segments are characterized by constraints in abstract domains. We consider a domain where constraints are in a universally quantified fragment of the first-order logic over sequences, as well as a domain constraining the multisets of data in sequences.</p> <p>Our analysis computes the effect of each procedure in a local manner, by considering only the reachable part of the heap from its actual parameters. In order to avoid losses of information, we introduce a mechanism based on unfolding/folding operations allowing to strengthen the analysis in the domain of first-order formulas by the analysis in the multisets domain.</p> <p>The same mechanism is used for strengthening the sound (but incomplete) entailment operator of the domain of first-order formulas. We have implemented our techniques in a prototype tool and we have shown that our approach is powerful enough for automatic (1) generation of non-trivial procedure summaries, (2) pre/post-condition reasoning, and (3) procedure equivalence checking.</p>", "authors": [{"name": "Ahmed Bouajjani", "author_profile_id": "81100358502", "affiliation": "LIAFA, University Paris Diderot and CNRS, Paris, France", "person_id": "P2690657", "email_address": "abou@liafa.jussieu.fr", "orcid_id": ""}, {"name": "Cezara Dr&#259;goi", "author_profile_id": "81367595629", "affiliation": "LIAFA, University Paris Diderot and CNRS, Paris, France", "person_id": "P2690658", "email_address": "cezarad@liafa.jussieu.fr", "orcid_id": ""}, {"name": "Constantin Enea", "author_profile_id": "81384607518", "affiliation": "LIAFA, University Paris Diderot and CNRS, Paris, France", "person_id": "P2690659", "email_address": "cenea@liafa.jussieu.fr", "orcid_id": ""}, {"name": "Mihaela Sighireanu", "author_profile_id": "81100141763", "affiliation": "LIAFA, University Paris Diderot and CNRS, Paris, France", "person_id": "P2690660", "email_address": "sighirea@liafa.jussieu.fr", "orcid_id": ""}], "doi_number": "10.1145/1993498.1993566", "year": "2011", "article_id": "1993566", "conference": "PLDI", "title": "On inter-procedural analysis of programs with lists and data", "url": "http://dl.acm.org/citation.cfm?id=1993566"}