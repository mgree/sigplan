{"article_publication_date": "06-04-2011", "fulltext": "\n Predicate Abstraction and CEGAR for Higher-Order Model Checking Naoki Kobayashi Ryosuke Sato Hiroshi \nUnno Tohoku University Tohoku University Tohoku University koba@ecei.tohoku.ac.jp ryosuke@kb.ecei.tohoku.ac.jp \nuhiro@kb.ecei.tohoku.ac.jp Abstract Higher-order model checking (more precisely, the model check\u00ading \nof higher-order recursion schemes) has been extensively stud\u00adied recently, which can automatically decide \nproperties of pro\u00adgrams written in the simply-typed .-calculus with recursion and .nite data domains. \nThis paper formalizes predicate abstraction and counterexample-guided abstraction re.nement (CEGAR) for \nhigher-order model checking, enabling automatic veri.cation of programs that use in.nite data domains \nsuch as integers. A proto\u00adtype veri.er for higher-order functional programs based on the for\u00admalization \nhas been implemented and tested for several programs. Categories and Subject Descriptors D.2.4 [Software \nEngineer\u00ading]: Software/Program Veri.cation; F.3.1 [Logics and Meanings of Programs]: Specifying and \nVerifying and Reasoning about Pro\u00adgrams General Terms Languages, Reliability, Veri.cation Keywords Predicate \nAbstraction, CEGAR, Higher-Order Model Checking, Dependent Types 1. Introduction The model checking of \nhigher-order recursion schemes (recur\u00adsion schemes, for short) has been extensively studied [19, 24, \n28], and recently applied to veri.cation of functional programs [20, 22, 26]. Recursion schemes are grammars \nfor describing in.nite trees [19, 28], and the recursion scheme model checking is con\u00adcerned about whether \nthe tree generated by a recursion scheme satis.es a given property. It can be considered an extension \nof .\u00adnite state and pushdown model checking, where the model check\u00ading of order-0 and order-1 recursion \nschemes respectively corre\u00adspond to .nite state and pushdown model checking. From a pro\u00adgramming language \npoint of view, a recursion scheme is a term of the simply-typed, call-by-name .-calculus with recursion \nand tree constructors, which generates a single, possibly in.nite tree. Various veri.cation problems \nfor functional programs can be eas\u00adily reduced to recursion scheme model checking problems [20, 22, 26]. \nThanks to the decidability of recursion scheme model check\u00ading [28], the reduction yields a sound, complete, \nand automatic Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI \n11, June 4 8, 2011, San Jose, California, USA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0663-8/11/06. \n. . $10.00 veri.cation method for programs written in the simply-typed .\u00adcalculus with recursion and \n.nite data domains (such as booleans). There is, however, still a large gap between the programs han\u00addled \nby the above-mentioned method and real functional programs. One of the main limitations is that in.nite \ndata domains such as integers and lists cannot be handled by the recursion scheme model checking. To \novercome that limitation, this paper extends the tech\u00adniques of predicate abstraction [12] and counterexample-guided \nab\u00adstraction re.nement (CEGAR) [4, 8] for higher-order model check\u00ading (i.e., recursion scheme model \nchecking). The overall structure of our method is shown in Figure 1. Given a higher-order functional \nprogram, predicate abstraction is .rst ap\u00adplied to obtain a higher-order boolean program (Step 1 in Figure \n1). For example, consider the following program M1: letfxg= g(x+1) in let h y = assert(y>0) in letkn=ifn>0 \nthen f n h else () in k(randi()) Here, assert takes a boolean as an argument and is reduced to fail if \nthe argument is false. The function randi returns a non\u00addeterministic integer value. Using a predicate \n.x.x > 0, we obtain the following higher-order boolean program e1: letfbg=ifb then g(true) else g(randb()) \nin lethc= assert(c) in let k () = if randb() then f true h else () in k() Here, randb returns a non-deterministic \nboolean value. Note that the integer variables x and y have been replaced by the boolean variable b and \nc respectively, which represents whether the values of x and y are greater than 0.Inthe abstractversionof \nf, b being true means that x>0, which implies x+1>0,sothat true is passed to g in the then-part. In the \nelse-part, x<=0, hence x+1>0 may or may not hold, so that a non-deterministic boolean value is passed \nto g. The higher-order boolean program thus obtained is an abstraction of the source program; for any \nreduction sequence of the source program, there is a corresponding reduction sequence of the higher\u00adorder \nboolean program (but not vice versa). Thus, for example, if the abstract program does not cause an assertion \nfailure, neither does the source program. The higher-order boolean program is then represented as a re\u00adcursion \nscheme and model-checked by using an existing recursion scheme model checker [21, 22] (Step 2 in Figure \n1). If the higher\u00adorder boolean program satis.es a given safety property,1 the source program is also \nsafe. Otherwise, an error path of the boolean pro\u00adgram is inspected (Step 3 in Figure 1). If it is also \nan error path of the source program, then it is reported that the program is un\u00adsafe. Otherwise, new \npredicates are extracted from the error path, in order to re.ne predicate abstraction (Step 4 in Figure \n1). 1 For the sake of simplicity, throughout the paper, we only consider the reachability property. \n  infeasible NG feasible  safe unsafe Figure 1. Higher-Order Model Checking with Predicate Abstrac\u00adtion \nand CEGAR In the example above, we actually start predicate abstraction with the empty set of predicates, \nand obtain the following abstract program e0: letfg=g()in leth()= assert(randb()) in let k () = if randb() \nthen f h else () in k() The model checking of this program yields the following reduction sequence, leading \nto an assertion failure: k() -. if randb() then f h else () -. if true then f h else () -. fh -. h() \n-. assert (randb()) -. assert (false) -. fail \u00b7\u00b7\u00b7 (1) The corresponding reduction sequence in the source \nprogram M1 is: kn -. ifn>0thenfnh else () -.n>0 fnh -. h(n+1) -. assert (n+1>0) -.n+1<=0 fail \u00b7\u00b7\u00b7 (2) \nHere, n is some integer, and we have annotated the sequence with the conditions that should hold at each \nstep. As n>0 . n+1<=0 is unsatis.able, we know that the reduction sequence above is actually infeasible, \nso that the source program may not cause an assertion failure. From the unsatis.able constraint above, \nwe can learn that information about whether an integer is positive is useful. By using it, we get the \nre.ned abstract program shown earlier. As the new abstract program is safe (i.e. does not cause an assertion \nfailure), we can conclude that the source program is also safe. The idea sketched above is basically \nthe same as the techniques for predicate abstraction and CEGAR used already in .nite state and pushdown \nmodel checking [4, 8], except that models have been replaced by higher-order boolean programs (or recursion \nschemes). As discussed below, however, it turned out that there are many challenging problems in developing \neffective methods for predicate abstraction and CEGAR for higher-order model checking. First, for predicate \nabstraction, it is unreasonable to use the same set of predicates for all the integer variables. For \nexample, let us modify the program above into the following program M2: letfxg= g(x+1) in lethy= assert(y>0) \nin letkn=if n>=0 thenfnh else () in k(randi()) Then, the predicate .... = 0 should be used for x, while \n.... > 0 should be used for y. We should consistently use predicates; for ex\u00adample, with the choice of \nthe predicates above, g s argument should be abstracted by using .... > 0, rather than .... = 0.Weuse \ntypes (called abstraction types) to express which predicate should be used for each variable. For example, \nfor the above program, the following abstraction types are assigned to f, h,and k: f : int[.... = 0] \n. (int[.... > 0] . *) . * h : int[.... > 0] . *k : int[] . *  The type of f means that the .rst argument \nof f should be an integer abstracted by the predicate .... = 0, and the second argument be a function \nthat takes an integer abstracted by the predicate .... > 0 as an argument and returns a unit value.2 \nBy using these abstraction types, the problem of checking that predicates are consistently used boils \ndown to a type checking problem. For example, the standard rule for application: G f M : t1 . t2 G f \nN : t1 G f MN : t2 ensures that N is abstracted using the predicates expected by the function M ; there \nis no such case that an abstraction of function M expects a value abstracted by using the predicate .... \n> 0 but the actual argument N is abstracted by using .... = 0. A further twist is necessary to deal with \nmulti-ary predicates. For example, consider the following modi.ed version M3: letfxg= g(x+1) in let hzy= \nassert(y>z) in letkn=if n>=0thenf n(h n)else ()in k(randi()) The variable y should now be abstracted \nby using .... > z,which depends on the value of z. Thus, the above program should be abstracted by using \nthe following dependent abstraction types: f :(x : int[] . (w : int[.... >x] . *) . *) h :(z : int[] \n. y : int[.... >z] . *) k : int[] . * Here, please note that the types of the second arguments of f and \nh refer to the values of the .rst arguments. Thus, our type system for ensuring the consistency of predicates \nis actually a dependent one. A predicate abstraction algorithm is then formalized as a type\u00addirected \ntransformation relation G f M : t . e basedonthe dependent abstraction type system, where M is a source \nprogram and e is an abstract program.3 The predicate abstraction mentioned above is sound in the sense \nthat if an abstract program is safe (i.e., does not reach fail), so is the source program. Further, we \ncan show that it is relatively complete with respect to a dependent (re.nement) intersection type system \n[32]: If a source program is typable in the dependent inter\u00adsection type system, our predicate abstraction \ncan generate a safe abstract boolean program by using certain abstraction types. This means that, as \nlong as suitable predicates are provided (by a user or an automated method like the CEGAR discussed below), \nthe com\u00adbination of our predicate abstraction and higher-order model check\u00ading has at least the same \nveri.cation power as (and actually strictly more expressive than, as discussed later: see Remark 1 in \nSection 4) the dependent intersection type system. Here, note that we need only atomic predicates used \nin the dependent types; higher-order model checking can look for arbitrary boolean combinations of the \natomic predicates as candidates of dependent types. Thus, this part alone provides a good alternative \nto Liquid types [31], which also asks users to provide templates of predicates, and infers dependent \n2 Here, abstraction types should not be confused with re.nement types [35]; the abstraction type of a \nterm only tells how the term should be abstracted, not what are possible values of the term. For example, \ninteger 3 can have type int[.... < 0] (and it will be abstracted to the boolean value false). 3 To avoid \nthe confusion, we call dependent abstraction types just abstrac\u00adtion types below. We use the term dependent \ntypes to refer to ordinary dependent types used for expressing re.nement of simple types.  types. Thanks \nto the power of higher-order model checking, how\u00adever, our technique can infer dependent, intersection \ntypes unlike Liquid types. We now discuss the CEGAR part. Given an error path of an ab\u00adstract boolean \nprogram, we can .nd a corresponding (possibly in\u00adfeasible) error path of the source program. Whether \nthe error path is feasible in the source program can be easily decided by sym\u00adbolically executing the \nsource program along the error path, and checking whether all the branching conditions in the path are \nsatis\u00ad.able (recall the example given earlier). The main question is, if the error path turns out to \nbe infeasible, how to .nd a suitable re.ne\u00adment of abstraction types, so that the new abstraction types \nyield an abstract boolean program that does not contain the infeasible error path. This has been well \nstudied for .rst-order programs [2 4, 8, 13 15], but it is not clear how to lift those techniques to \ndeal with higher-order programs. Our approach to .nding suitable abstraction types is as follows. From \na source program and its infeasible error path, we .rst con\u00adstruct a straightline higher-order program \n(abbreviated to SHP) that exactly corresponds to the infeasible path, and contains nei\u00adther recursion \nnor conditional branches. In the case of the program M3 above, this is easily obtained, as follows: letf1xg= \ng(x+1) in let h1zy= assert(y>z) in let k1 n = assume(n>=0); f1 n (h1 n) in k1(c) Here, c is a constant, \nand assume(b) evaluates b, and proceeds to the next instruction only if b is true. (But unlike assert,itis \nnot reduced to fail even if b is false.) For general programs that contain recursions, the construction \nis more involved: see Section 5. For SHP, a standard dependent (re.nement) type system is sound and complete, \nin the sense that a program does not reach fail if and only if the program is typable in the type system. \nFurther, (a sub-procedure of) previous algorithms for inferring de\u00adpendent types based on interpolants \n[32, 33] is actually complete (modulo the assumption that the underlying logic is decidable and interpolants \ncan always be computed) for SHP. Thus, we can auto\u00admatically infer the dependent type of each function \nin the straight\u00adline program. For example, for the program above, we obtain: f1 :(x : int . (y : {. : \nint | .>x}. *) . *) h1 :(z : int . y : {. : int | .>z}. *) k1 :(z : int . *) Here, the type of h1 means \nthat given integers z and y such that y>z, h1 zy returns a unit value without reaching fail. (These dependent \ntypes should not be confused with abstraction types: the latter only provides information about how the \nsource program should be abstracted.) We then re.ne the abstraction type of each function in the source \nprogram with predicates occurring in the dependent types of the corresponding functions in the SHP. For \nexample, given the above dependent types, we get the following abstraction types: f :(x : int[] . (y \n: int[.... >x] . *) . *) h :(z : int[] . y : int[.... >z] . *) k : int[] . * We can show that the abstraction \ntypes inferred in this manner are precise enough, in that the abstract program obtained by using the \nnew abstraction types no longer has the infeasible error path. (Thus, the so-called progress property \nis guaranteed as in CEGAR meth\u00adods for .nite-state or pushdown model checking.) Based on the predicate \nabstraction and CEGAR techniques mentioned above, we have implemented a prototype veri.er for (simply-typed) \nhigher-order functional programs with recursion and integer base types, and tested it for several programs. \nOur contributions include: (i) the formalization of predicate abstraction for higher-order programs, \nbased on the novel notion of abstraction types, (ii) the formalization of CEGAR for higher\u00adorder programs, \nbased on the novel notion of SHP and reduction of the predicate discovery problem to dependent type inference, \n(iii) theoretical properties like the relative completeness of our method with respect to a dependent \nintersection type, the progress property, etc., and (iv) the implementation and preliminary experiments. \nThe rest of this paper is structured as follows. Section 2 intro\u00adduces the source language, and Section \n3 introduces a language of higher-order boolean programs, and reviews the result on higher\u00adorder model \nchecking. Sections 4 and 5 respectively formalize predicate abstraction and CEGAR for higher-order programs. \nSec\u00adtion 6 reports our prototype implementation and preliminary exper\u00adiments. Section 7 discusses related \nwork, and Section 8 concludes. For the space restriction, proofs are omitted, which are available in \na full version [25]. 2. Language This section introduces a simply-typed, higher-order functional language, \nwhich is used as the target of our veri.cation method. We assume a set B = {b1,...,bn} of data types, \nand a set [[bi]] of constants, ranged over by c, for each data type bi.Wealso assume that there are operators \nop : bi1 ,...,bik . bj ; we write [[op]] for the function denoted by op. We assume that the set of data \ntypes includes * with [[*]] = . ,and bool with [[bool]] = {true, false}, and that the set of operators \nincludes =: b, b . bool for every b . B, and boolean connectives such as . : bool, bool . bool. The syntax \nof the language is given by: D (program) ::= {f1 xe1 = e1,...,fm xem = em} e (expressions) ::= c | xve| \nfve| let x = e1 in e2 | op(ve) | fail | assume v; e | e1 e2 v (values) ::= c | x | fve Here, xeabbreviates \na (possibly empty) sequence x1,...,xn.In the de.nition fxe= e, we call the length of xethe arity of f.In \nthe de.nition of values, the length of vein fvemust be smaller than the arity of f. (In other words, \nfvemust be a partial application.) We assume that every function in D has a non-zero arity, and that \nD contains a distinguished function symbol main .{f1,...,fm}whose simple type is * . *. Most of the expressions \nare standard, except the following ones. The expression fail aborts the program and reports a failure. \nThe expression assume v; e evaluates e if v is true; otherwise it stops the program (without a failure). \nThe expression e1 e2 evaluates e1 or e2 in a non-deterministic manner. Note that a standard condi\u00adtional \nexpression if v then e1 else e2 can be expressed as: (assume v; e1) (let x = \u00acv in assume x; e2). We \ncan express the assertion assert v as if v then . else fail. The random number generator randi used in \nSection 1 is de.ned by: randi . =(randiFrom 1) (randiTo 0) randiFrom n = n (randiFrom (n +1)) randiTo \nn = n (randiTo (n - 1)) We assume that a program is well-typed in the standard simple type system, where \nthe set of types is given by: t ::= b1 | \u00b7\u00b7\u00b7 | bn | t1 . t2. Furthermore, we assume that the body of \neach de.nition has a data type bi, not a function type. This is not a limitation, as we can always use \nthe continuation-passing-style (CPS) transformation to transform a higher-order program to an equivalent \none that satis.es the restriction. We de.ne the set of evaluation contexts by: E ::= [] | let x = E in \ne. The reduction relation is given in Figure 2. We label the  f ex = e . D E[f ev] E-.D E[[ev/ex]e] \n(E-APP) E[let x = v in e] E-.D E[[v/x]e] (E-LET) E[op(ec)] E-.D E[[[op]](ec)] (E-OP) E[e0 e1] i-.D E[ei] \n(E-PAR) E[assume true; e] E-.D E[e] (E-ASSUME) E[fail] E-.D fail (E-FAIL) Figure 2. Call-by-Value Operational \nSemantics reduction relation with 0, 1,E to record which branch has been chosen by a non-deterministic \nexpression e1 e2;itwillbe used to relate reductions of a source program and an abstract program l1\u00b7\u00b7\u00b7ln \nlater in Sections 4 and 5. We write e1 =. D e2 if E* l1E* E* lnE* e1(-.D) -.D (-.D) \u00b7\u00b7\u00b7 (-.D) -.D (-.D) \ne2. We often omit the subscript D when it is clear from the context. The goal of our veri.cation method \nis to check whether s 4 main =.D fail. 3. Higher-Order Boolean Programs and Model Checking A source program \nis translated to a higher-order boolean program (abbreviated to HBP) by the predicate abstraction discussed \nin Section 4. The language of HBP is essentially the same as the source language in the previous section, \nexcept: The set of data types consists only of types of the form bool \u00d7\u00b7\u00b7\u00b7\u00d7 bool (which is identi.ed \nwith * when m =0,and | {z } m bool when m =1). We assume there are the following operators to construct \nor deconstruct tuples: .\u00b7,..., \u00b7 : bool,..., bool . bool \u00d7\u00b7\u00b7\u00b7\u00d7 bool i : bool \u00d7\u00b7\u00b7\u00b7\u00d7 bool . bool The set \nof expressions is extended with e1 \u00a8e2 and un\u00adnamed functions .x.e. The former is used for expressing \nthe non\u00addeterminism introduced by abstractions; it is the same as e1 e2, which is used to express the \nnon-determinism present in a source program, except that the reduction is labelled with E. This distinc\u00adtion \nis convenient for the CEGAR procedure discussed in Section 5 to .nd a corresponding execution path of \nthe source program from an execution path of the abstract program. Unnamed functions are used just for \ntechnical convenience for de.ning predicate abstrac\u00adtion; with .-lifting, we can easily get rid of .-abstractions. \n(The evaluation rules and evaluation contexts are accordingly extended with E[(.x.e)v] -. E[[v/x]e] and \nE ::= \u00b7\u00b7\u00b7 | Ee | vE.) The following theorem is the basis of our veri.cation method. It follows immediately \nfrom the decidability of the model checking of higher-order recursion schemes [28]. s Theorem 3.1. Let \nD be an HBP. The property .s.(main =.D fail) is decidable. 4 Thus, we consider the reachability problem \nfor a closed program. Note, however, that we can express unknown values by using non-determinism (recall \nrandi). It is also easy to extend our method to deal with more general veri.cation problems, such as \nresource usage veri.cation [22]. A2S(G),x : b fST .i : bool for each i .{1,...,n}G fwf b[.x..1,...,.x..n] \nG fwf s1 G,x : s1 fwf s2 fwf GG fwf s G fwf x : s1 . s2 fwf \u00d8fwf G,x : s Figure 3. Well-formed types \nand type environments We can use a recursion scheme model checker TRECS [21, 22] s to decide the above \nproperty.5 If .s.(main =.D fail) holds, the model checker generates an error path s. The knowledge about \nrecursion schemes is unnecessary for understanding the rest of this paper, but an interested reader may \nwish to consult [20, 22, 28]. 4. Predicate Abstraction This section formalizes predicate abstraction \nfor higher-order pro\u00adgrams. As explained in Section 1, we use abstraction types to ex\u00adpress which predicates \nshould be used for abstracting each sub\u00adexpression. The syntax of abstraction types is given by: s (abstraction \ntypes) ::= b1[Pe] | \u00b7\u00b7\u00b7 | bn[Pe] | x : s1 . s2 P, Q (predicates) ::= .x.. G (type environments) ::= \u00d8| \nG,f : s | G,x : s Here, the meta-variable . represents an expression of type bool (which is called aformula) \nthat is constructed only from variables of base types, constants, and primitive operations; we do not \nallow formulas that contain function applications, like y>f(x).The base type bi[Pe] describes values \nv of type bi that should be ab\u00adstracted to a tuple of booleans P1(v),...,Pn(v) . For example, the integer \n3 with the abstraction type int[.... > 0,.... < 2] is abstracted to true, false . We often abbreviate \nb[] to b.The dependent function type x:s1 . s2 describes functions that take a value v of type s1, and \nreturn a value of type [v/x]s2. The scope of x in the type x:s1 . s2 is s2.When x does not occur in s2,weof\u00adten \nwrite s1 . s2 for x : s1 . s2. As mentioned already, abstrac\u00adtion types only describe how each expression \nshould be abstracted, not the actual value. For example, 3 can have type int[.... < 0], and .x.x can \nhave type x : int[] . int[.... = x +1] (and abstracted to .x : *.false). We do not consider types whose \npredicates are ill-typed or violate a variable s scope, such as x:bool[] . int[.y.x +1 = y] and x : int[.x.y \n> x] . y : int[] . bool[]. (The former uses a boolean variable as an integer, and the latter refers to \nthe variable y outside its scope.) Figure 3 de.nes the well-formedness conditions for types and type \nenvironments. In the .gure, . fST e : t denotes the type judgment of the standard simple type system. \nWe write A2S(s) and A2S(G) respectively for the simple type and the simple type environment obtained \nby removing predicates. For example, A2S(f :(x : int[] . int[.y.y >x]),z : int[.z.z > 0]) = f : int . \nint,z : int. Figure 4 de.nes the predicate abstraction relation G f e1 : se2, which reads that an expression \ne1 (of the source lan\u00adguage in Section 2) can be abstracted to an expression e2 (of the HBP language \ngiven in Section 3) by using the abstraction type s, under the assumption that each free variable x of \ne1 has been abstracted using the abstraction type G(x).Inthe rules,it is implicitly assumed that all \nthe type environments and types are well-formed. We do not distinguish between function vari\u00ad 5 The gap \nbetween the operational semantics of our language and that of recursion schemes can be .lled by the CPS \ntransformation. Note also that .nite state or pushdown model checkers cannot be used, as higher-order \nprograms are in general strictly more expressive [10].  e is a constant, a variable or an expression \nof the form op(ev) A2S(G) fST e : b G f e : b[.... = e] true (A-BASE) ' G f e : b[Qe] e \u00df(G,x : b[Qe]) \nfST . : bool \u00df(G,x : b[Qe]) fST .' : bool |= P (x) . .(.) |= \u00acP (x) . .(.') G,x:b[Qe]G,x:b[Qe] e'' =(assume \n.; true) \u00a8(assume .'; false) ' '' G f e : b[ elet x = ex,e Q,P ] in (A-CADD) ' G f e : b[ e Q, Pe] e \n(A-CREM) ' G f e : b[Pe] let ey = ein y x, ee G(x)=(y1 : s1 . \u00b7\u00b7\u00b7 . yk : sk . s) G,y1 : s1,...,yi-1 : \nsi-1 f vi :[v1/y1,...,vi-1/yi-1]si ei (for each i .{1,...,k}) G f x ev :[ev/ey]s let y1 let yk = e1 \nin \u00b7\u00b7\u00b7 = ek in x ey (A-APP) G f e1 : s' e'1 G,x : s' f e2 : s e'2 G f let x = e1 in e2 : s let x = e'1 \nin e'2 (A-LET) \u00df(G) fST . : bool |= .G(.) G f fail : s assume .; fail (A-FAIL) G f v : bool[.x.x] e1 \nG,x : bool[.x.v] f e : s e2 G f assume v; e : s let x = e1 in assume x; e2 (A-ASM) G f e1 : s e ' 1 G \nf e2 : s G f e1 e2 : s e ' 1 e ' 2 e ' 2 (A-PAR) G f e :(x : s'1 . s'2) e' G,x : s1 f x : s'1 e'1 G,x \n: s1,x' : s'1,y : s'2 f y : s2 e'2 ' let f = ein '' G f e :(x : s1 . s2) .x.let x= e1 in ' let y = fx' \nin e2 (A-CFUN) ' fi :(xei : sei . si) . GG,xei : sei f ei : si ei (for each i .{1,...,m}) G(main)= *[] \n. *[] (A-PROG) f{f1 xe1 = e1,...,fm xem = em} :G {f1 xe1 = e'1,...,fm xem = e'm} Figure 4. Predicate \nAbstraction Rules ables and other variables (hence, A-APP applies also to a func\u00adtion variable f). In \nA-CADD, assume e1; e2 is a syntax sugar for let x1 = e1 in assume x1; e2. In A-CADD and A-FAIL, \u00df(s) \n(\u00df(G), resp.) represent the sim\u00adple type (simple type environment, resp.) obtained by replacing each \noccurrence of a base abstraction type b[P1,...,Pm] with bool \u00d7\u00b7\u00b7\u00b7\u00d7 bool. Intuitively, \u00df(G) represents \nthe type environ\u00ad | {z } m ment for the output program of the transformation. We explain the main rules. \nBase values are abstracted by using three rules A-BASE,A-CADD,and A-CREM. Before explaining those rules, \nlet us discuss the following simpli.ed version, special\u00adized for a single predicate: |= P (e) . .G(.) \n|= \u00acP (e) . .G(.') G f e : b[P ](assume .; true) \u00a8(assume .'; false) (A-BSIMP) Here, we assume that \ne is a constant, a variable, or an expression of the form op(ve) and has a base type b. . and .' are \nboolean formu\u00adlas that may contain variables in G.As e may contain variables, we need to take into account \ninformation about the values of the vari\u00adables, which is obtained by using the substitution .G,de.nedas: \n{x P1(x),...,Pm(x) .. | G(x)= b[P1,...,Pm]}.Forexam\u00adple, let G be x : int[.x.x > 0, .x.x < 0] and . be \n1(x) . 2(x). Then, .G(.)= x> 0 . x< 0. As in this example, the substi\u00adtution .G maps a boolean expression \nof an abstract program to the corresponding condition in the source program. In rule A-BSIMP above, |= \nP (e) . .G(.) means that P (e) is true only if .G(.) is true, i.e. the value of . in the abstract program \nis true. Thus, the abstract value of e may be true only if the value of . is true, hence the part assume \n.; true in the abstract program. Similarly, the abstract value of e may be false only if the value of \n.' is true, hence the part assume .'; false. For example, let e = x +1, P = .x = 0,and G = x : int[P \n]. Then, |= P (x +1) . true and |= \u00acP (x +1) .\u00acP (x),sothat e is abstracted to (assume true; true) \u00a8(assume \n\u00acx; false). Note that .G(\u00acx)=[P (x)/x]\u00acx = \u00acP (x). We need to generalize the above rule to the case for \nmultiple predicates. The following is a naive rule. G f e : b[Pi] ei (A-BCARTESIAN) G f e : b[P1,...,Pn] \ne1,...,en This produces a well-known cartesian abstraction, which is often too imprecise. The problem \nis that each boolean value of the ab\u00adstraction is computed separately, ignoring the correlation. For \nex\u00adample, let P1 = .x.x > 0 and P2 = .x.x = 0 with n =2. Then, a possible abstraction of an unknown integer \nshould be true, false and false, true , but the above rule would gen\u00aderate (true \u00a8false), (true \u00a8false) \n, which also contains true, true and false, false . The discussion above motivated us to introduce the \nthree rules A-BASE,A-CADD,and A-CREM. In order to abstract an expres\u00adsion e with b[P1,...,Pn],we.rstuse \nA-BASE to abstract e to true by using the abstraction type b[.... = e]; this is necessary to keep the \nexact information about e during the computation of ab\u00adstractions. A-CADD is then used to add predicates \nP1,...,Pn one by one, taking into account the correlation between the predicates. Note that in A-CADD, \nthe result of abstraction by the other pred\u00adicates is taken into account by the substitution .. Finally, \nG,x:b[Qe] A-CREM is used to remove the unnecessary predicate .... = e. See Example 4.1 for an application \nof these rules. Note that rule A-CADD is non-deterministic in the choice of conditions . and .', so that \nhow to compute the conditions is left unspeci.ed. We have intentionally made so, because depending on \nbase data types, the most precise conditions (the strongest condi\u00adtions entailed by P (x) and \u00acP (x)) \nmay not be computable or are too expensive to compute. For linear arithmetics, however, we can use off-the-shelf \nautomated theorem provers to obtain such condi\u00adtions. In rule A-APP, each argument vi is abstracted by \nusing the abstraction type si with y1,...,yi-1 being replaced by the actual arguments. Note that this \nrule applies also to the case where the sequence ev is empty (i.e. k =0). Thus, we can derive G f y : \ns y if G(y)= s. Note also that the boolean expression ei in A-APP can depend on y1,...,yi-1. In A-FAIL, \nthe assume statement is inserted for .ltering out an invalid combination of abstract values. For example, \nlet G be x : int[.x.x > 0, .x.x < 0]. Then, assume ( 1(x) . 2(x)); is inserted since x> 0 and x< 0 cannot \nbe true simultaneously. In A-ASM, we can use the fact that v is true in e for abstracting e.  Rule A-CFUN \nis used for changing the abstraction type of a function from x : s1 . s2 to x : s1 ' . s2' , which is \nanalogous to the usual rule for subtyping-based coercion. If a function f is used in different contexts \nwhich require different abstraction types of f,A-CFUN can be used to adjust the abstraction type of f \nto that required for each context. We can read the predicate abstraction rules for G f e : s e ' as an \nalgorithm that takes G,e and s as input, and outputs e ' as an abstraction of e, by (1) restricting applications \nof the rules for coercion (of names A-CXYZ) to the actual arguments of function applications, and (2) \n.xing an algorithm to .nd the boolean formulas . and . ' in A-CADD. (Note that in A-LET,the type s ' \ncan be obtained from G and e1.) The rule for f D :G D ' can then be interpreted as an algorithm that \ntakes D and G as input, and outputs an HBP D ' as an abstraction of D. Example 4.1. Recall the program \nM2 in Section 1. Let G be: x : int[.... = 0],g : int[.... > 0] . * The body of f is transformed as follows. \nx +1 is transformed by: A-BASE G f x +1: int[.... = x +1] true A-CADD G f x +1: int[.... = x +1,.... \n> 0] e1 A-CREM G f x +1: int[.... > 0] e2 Here, e1 = let y1 = true in y1,e3 and e2 = let y1,y2 = e1 in \ny2,with e3 = (assume true; true) \u00a8 (assume \u00ac(x . y1); false). Here, we used true and \u00ac(x.y1) as . and \n. ' respec\u00adtively, in A-CADD. (Note that P (y1) . .G,y1:int[....=x+1](.1), i.e., y1 = 0 .\u00ac(x = 0 . y1 \n= x +1) holds.) By simplify\u00ading e2,weget if x then true else true\u00a8false. Thus, the body g(x +1) of function \nf is transformed by using A-APP as follows: . . . G(g)= int[.... > 0] . * G f x +1: int[.... > 0] e2 \nlet y = if x then true G f g(x +1) : * else (true\u00a8false) in g(y) Our predicate abstraction rules are \napplicable to programs that use in.nite data domain other than integers. See [25] for an exam\u00adple of \nabstracting a list-processing program. We discuss properties of the predicate abstraction relation be\u00adlow. \nFirst, we show that if abstraction types are consistent, there is always a valid transformation. We write \nG fAT e : s for the type judgment relation obtained from the predicate abstraction rules by removing \nall the conditions on outputs: see [25]. Theorem 4.1. Suppose G fAT e : s. Then, A2S(G) fST e : A2S(s). \nFurthermore, there exists e ' such that G f e : se ' . Proof. Straightforward induction on the derivation \nof G fAT e : s. Note that in the rule for A-CADD, we can choose true as . and . ' . The following lemma \nguarantees that the output of the transfor\u00admation is well-typed. Lemma 4.2. If G f e1 : se2,then \u00df(G) \nfST e2 : \u00df(s). Proof. Straightforward induction on the derivation of G f e1 : se2. The theorem below \nstates that our predicate abstraction is sound in the sense that if a source program fails, so does its \nabstraction (see [25] for the proof). Thus, the safety of the abstract program (which is decidable by \nTheorem 3.1) is a suf.cient condition for the safety of the source program. s Theorem 4.3 (soundness). \nIf f D1 :G D2 and main =.D1 fail, then main =.sD2 fail. The theorem above says that the abstraction is \nsound but not how good the abstraction is. We compare below the veri.cation power of the combination \nof predicate abstraction and higher-order model checking with the dependent intersection type system \ngiven in [25], which is essentially equivalent to the one in [32]. We write B[.1,...,.k] for the set \nof formulas constructed from .1,...,.k and boolean operators (true, false, ., ., \u00ac). For an abstraction \ntype s,the set DepTy(s) of dependent types is: DepTy(b[P1,...,Pn]) = {{. : b | .}| . .B[P1(.),...,Pn(.)]}DepTy(x \n: s1 . s2)= {(x : d11 . d21) .\u00b7\u00b7\u00b7. (x : d1m . d2m) | d11,...,d1m . DepTy(s1),d21,...,d2m . DepTy(s2)} \nWe extend DepTy to a map from abstraction type environments to the powerset of dependent type environments \nby: DepTy({x1 : s1,...,xn : sn})= {{x1 : d1,...,xn : dn}| di . DepTy(si) for each i .{1,...,n}} The \nfollowing theorem says that our predicate abstraction (with higher-order model checking) has at least \nthe same veri.cation power as the dependent intersection type system. Theorem 4.4 (relative completeness). \nSuppose fDIT D :..If . . DepTy(G),thenthere exists D ' such that f D :G D ' and main =.D' fail. = Remark \n1. The converse of the above theorem does not hold: see [25]. Together with Theorem 4.4, this implies \nthat our combination of predicate abstraction and higher-order model checking is strictly more powerful \nthan the dependent intersection type system. Remark 2. The well-formedness condition for abstraction \ntypes is sometimes too restrictive to express a necessary predicate. For example, consider the following \nprogram. let applyfx=fxinlet gyz=assert(y=z)in letkn= apply (g n) n; k(n+1) in k(0) In order to verify \nthat the assertion failure does not occur, we need a correlation between the argument of f and x, which \ncannot be expressed by abstraction types. The problem can be avoided either by adding a dummy parameter \nto apply (as letapplyn fx = ...) and using the abstraction type n : int[] . (int[.... = n] . *) . int[.... \n= n] . *, or by swapping the parameters f and x. A more fundamental solution (which is left for future \nwork) would be to introduce polymorphic abstraction types, like .m : int.(int[.... = m] . *) . int[.... \n= m] . *,and extend the predicate abstraction rules accordingly. 5. Counterexample-Guided Abstraction \nRe.nement (CEGAR) This section describes a CEGAR procedure to discover new pred\u00adicates used for predicate \nabstraction when the higher-order model checker TRECS has reported an error path s of a boolean program. \n 5.1 Feasibility checking Givenanerrorpath s of an abstract program, we .rst check whether s is feasible \nin the source program D,i.e.whether main =.sD fail. This can be easily checked by actually executing \nthe source program along the path s, and checking whether all the branching conditions are true. (Here, \nwe assume that the program is closed. If we allow free variables for storing base values, we can just \nsymbolically execute the source program along the path, and check whether all the conditions are satis.able.) \nIf the source program indeed has the error path (i.e. main =.sD fail), then we report the error path \nas a counterexample.  5.2 Predicate discovery and re.nement of abstraction types =s If the error path \nis infeasible (i.e. main =.D fail), we .nd new predicates to re.ne predicate abstractions. In the case \nof the model checking of .rst-order programs, this is usually performed by, for each program point e \nin the error path, (i) computing the strongest condition C1 at e, (ii) computing the weakest condition \nC2 for reaching from e to the failure node, and (iii) using a theorem prover to .nd a condition C such \nthat C1 . C and C .\u00acC2. Then the predicates in C can be used for abstracting the state at the program \npoint. For example, in the reduction sequence (2) of M1 in Section 1, the condition C1 on the local variable \nx is n> 0.x = n, and the condition C2 is x+1 = 0. From them, we obtain C = x> 0 as a predicate for abstracting \nx. It is unclear, however, how to extend it to deal with higher\u00adorder functions. For example, in the \nexample above, how can we .nd a suitable abstraction type for functions f and g? To address this issue, \nas mentioned in Section 1, we use the following type\u00adbased approach. From an infeasible error path, we \n.rst construct a straightline higher-order program (abbreviated to SHP, which is straightline in the \nsense that it contains neither branches nor recursion and that each function is called at most once) \nthat has exactly one execution path, corresponding to the path s of the source program. We then infer \nthe dependent types of functions in the straightline program, and use the predicates occurring in the \ndependent types for re.ning abstraction types of the source program. We describe each step in more detail \nbelow. 5.2.1 Constructing SHP Given a source program and a path s, the corresponding SHP is obtained \nby (i) making a copy of each function for each call in the execution path, and (ii) for each copy, removing \nthe branches not taken in s. Example 5.1. Recall the program M3 in Section 1. main = km fxg = g(x +1) \nhzy =(assume y>z;) (assume \u00ac(y>z); fail) kn =(assume n = 0; fn (hn)) (assume \u00ac(n = 0); ) Here, we have \nrepresented conditionals and assert expressions in our language.6 Given the spurious error path 0 \u00b7 1, \nwe obtain the following SHP. main = km hzy = assume \u00ac(y>z); fail fxg = g(x +1) kn = assume n = 0; fn \n(hn) It has been obtained by removing irrelevant non-deterministic branches in h and k. The construction \nof an SHP generally requires duplication of function de.nitions and function parameters. For example, \ncon\u00adsider the following program: main = km twice fx = f(fx) gx = if x = 0 then 1 else 2+ g(x - 1) kn \n= let x = twice gn in assert (x> 0) (where m is some integer constant). The program calls the function \ng twice, and asserts that the result x is positive. Suppose that an infeasible path 0101 has been given, \nwhich represents the following 6 Here, for the sake of simplicity, we assume that m is some integer con\u00adstant. \nAs already mentioned, the random number generator randi can actu\u00adally be encoded in our language. (infeasible) \nexecution path: main -. km =. let x = g(gm) in \u00b7\u00b7\u00b7 01 =. let x = g(1) in \u00b7\u00b7\u00b7 =. let x =2+ g(0) in \u00b7\u00b7\u00b7 \n01 =. let x =2+1 in \u00b7\u00b7\u00b7 =. assert 3 > 0=. fail The path is infeasible because the .nal transition is \ninvalid. From the source program and the path above, we construct the following straightline program:7 \nf(1),f (2) x = f(2)(f(1) main = km twice x) (1) (3) gx = assume x = 0; 1 gx = assume x = 0; 1 (2) (3)(x \n- 1) gx = assume \u00ac(x = 0);2 + g (1)(2) kn = let x = twice g,gn in assume \u00ac(x> 0); fail As g is called \nthree times, we have prepared three copies g(1), g(2), g(3) of g, and eliminated unused non-deterministic \nbranches. Note that the function parameter f of twice has been replaced by a f(1),f (2) function pair \naccordingly. The general construction is given below. Consider a program normalized to the following \nform: D ::= {f1 xe1 = e10 e11,...,fm xem = em0 em1} e ::= assume v; a | let x =op(ve) in a a ::= | xve| \nfve| fail v ::= c | xve| fve Here, for the sake of simplicity, we have assumed that every func\u00adtion de.nition \nhas at most one (tail) function call, and the re\u00adturn value is ; this does not lose generality as the \nnormal form can be obtained by applying CPS transformation and .-lifting. Given a path s = b1 \u00b7\u00b7\u00b7 b\u00a3 \nof D (which means that the branch bi has been chosen at ith function call), the corresponding SHP D ' \n= SHP(D, s) is given by: D ' = {f(j) xei =[eibj ]j+1 | i .{1,...,m},j .{1,...,e}, i the target of the \njth function call is fi} .{f(j) xei = | i .{1,...,m},j .{1,...,e}, i the target of the jth function \ncall is not fi} .{main = main(1). } Here, [e]j is given by: [assume v; a]j = assume v;[a]j [let x =op(ev) \nin a]j = let x =op(ve) in [a]j []j =[fail]j = fail [x]j = x bj+1 bj+1 [xv1 \u00b7\u00b7\u00b7 vk]j = j (x) v1\u00b7\u00b7\u00b7 vk(k \n= 1) = f(j) bj+1 bj+1 [fv1 \u00b7\u00b7\u00b7 vk]j v1\u00b7\u00b7\u00b7 vk bj bj c= cx= x (if x is a base variable) bj bj ) (xve)= \n.e,...,.e, v\u00a3(x)(ey. y. j (x)(ebj ),..., v | {z } j-1 (if x is a function variable) bj bj ) (fve)= .e,...,.e,f(j)(ebj \n),...,f(\u00a3)(e y.y.vv | {z} j-1 Here, each function parameter has been replaced by a e-tuple of functions. \nThe SHP SHP(D, s), constructed from a source program D and a spurious error path s, contains neither \nrecursion nor non-deterministic branch, and is reduced to fail if and only if main =s.D fail. Furthermore, \neach function in the SHP is called at most once. 7 For clarity, we have extended our language with tuples \nof functions. If necessary, they can be removed by the currying transformation.  The generated straightline \nprogram satis.es the following prop\u00aderties. Lemma 5.1. Suppose D ' = SHP(D, s). Then: 1. D ' contains \nneither recursions nor non-deterministic branches e1 e2. s .D ' 2. main =.D fail if and only if main \n=fail. 3. Each function fi (j) in D ' is called at most once.   5.2.2 Typing SHP The next step is \nto infer dependent types for functions in SHP. Thanks to the properties that SHP contains neither recursion \nnor non-deterministic branch and that every function is linear, the stan\u00addard dependent type system is \nsound and complete for the safety of the program. Let us write fDT D if D is typable in the frag\u00adment \nof the dependent type system presented in Section 4 without intersection types (but extended with (non-dependent) \ntuple types). Lemma 5.2. Let D ' = SHP(D, s). Then, fDT D ' :. for some . if and only if main =.D ' =fail. \nProof sketch The only if part follows immediately from the soundness of the dependent type system. For \nthe if part, it suf.ces to observe that, as every function in D ' is linear, each variable x of base \ntype can be assigned a type {. : b | . = v},where v is the value that x is bound to. We can use existing \nalgorithms [32, 33] to infer dependent types: we .rst prepare a template of a dependent type for each \nfunction, generate constraints on predicate variables, and solve the constraints. We give below an overview \nof the dependent type inference procedure through an example; an interested reader may wish to consult \n[32, 33]. Example 5.2. Recall the straightline program in Example 5.1. We prepare the following templates \nof the types of functions f, h, k: f :(x : {. : int | P1(.)}. (y : {. : int | P2(., x)}. *) . *) h :(z \n: {. : int | P3(.)}. y : {. : int | P4(., z)}. *) k :(x : {. : int | P0(.)}. *) From the program, we \nobtain the following constraints on P0,...,P4: P0(m) .x.(P1(x) . P2(x +1,x)) .z, y.(P3(z) . P4(y, z) \n. y>z) .n, y.P0(n) . (n = 0 . (P1(n) . P3(n) . (P2(y, n) . P4(y, n)))) Each constraint has been obtained \nfrom the de.nitions of main,f, g, and k. They can be normalized to: ...(. = m . P0(.)) .n, ..(P0(n) . \nn = 0 . . = n . P1(.)) .x, ..(P1(x) . . = x +1 . P2(., x)) .n, ..(P0(n) . n = 0 . . = n . P3(.)) .n, \nz, ..(P0(n) . n = 0 . z = n . P2(., n) . P4(., z)) .z, y.(P3(z) . P4(y, z) . y>z) These constraints are \nacyclic in the sense that for each constraint of the form Ci . Pi(xe), Ci contains only (positive) occurrences \nof predicates Pj s such that j<i occur. Such constraints can be solved by using a sub-procedure of existing \nmethods for dependent type inference based on interpolants [32, 33], and the following predicates can \nbe obtained. (The inferred predicates depend on the underlying interpolating theorem prover.) P0(.) = \nP1(.) = P3(.) = true P2(., x) = P4(., x) = .>x Thus, we obtain the following types for f and h: f :(x \n: {. : int | true}. (y : {. : int | .>x}. *) . *) h :(z : {. : int | true}. y : {. : int | .>z}. *) \n 5.2.3 Re.ning abstraction types The .nal step is to re.ne the abstraction types of the source pro\u00adgram, \nbased on the dependent types inferred for the straightline program. Let df,j be the inferred dependent \ntype of f(j). Then, we can obtain an abstraction type sf,j such that undup(df,j ) . DepTy(sf,j ) (the \nchoice of such sf,j depends on what predicates are considered atomic), where undup(d) is de.ned by: undup({. \n: b | .})= {. : b | .} undup(x : d1 . d2)= x : undup(d1) . undup(d2) ^ undup(d1 \u00d7\u00b7\u00b7\u00b7\u00d7 dn)= undup(di) \ni.{1,...,n} The new abstraction type sf ' of f is given by: sf ' = sf sf,1 \u00b7\u00b7\u00b7 sf,\u00a3, where sf is the \nprevious abstraction type of f and s1 s2 is obtained by just merging the corresponding predicates: b[Pe] \nb[ eP, e Q]= b[ eQ] (x : s1 . s2) (x : s1 ' . s2' )= x :(s1 s1' ) . (s2 s2' ) We write Re.ne(G, .) for \nthe re.ned abstraction type environ\u00adment f1 : s ' ,...,fn : s ' . (There is a non-determinism coming \nf1 fn from the choice of sf,j , but that does not matter below.) Example 5.3. Recall Example 5.3. From \nthe dependent types of f and g, we obtain the following abstraction types: f :(x : int[] . (y : int[.... \n>x] . *) . *) h :(z : int[] . y : int[.... >z] . *) Suppose that the previous abstraction types were \nf :(x : int[] . (y : int[] . *) . *) h :(z : int[.... =0] . y : int[.... > 0] . *) Then, the re.ned abstraction \ntypes are: f :(x : int[] . (y : int[.... >x] . *) . *) h :(z : int[.... =0] . y : int[.... > 0,.... > \nz] . *)  5.3 Properties of the CEGAR algorithm We now discuss properties of the overall CEGAR algorithm. \nIf the re.ned abstraction type is obtained from an infeasible error path s, the new abstract boolean \nprogram no longer has the path s. This is the so called progress property known in the literature on \nCEGAR for the usual (i.e. .nite state or pushdown) model checking. Formally, we can prove the following \nproperty (see [25] for the proof): Theorem 5.3 (progress). Let D1 be a well-typed program and s be an \ninfeasible path of D1. Suppose D2 = SHP(D1,s) and fDIT D2 :. with G= Re.ne(G ' , .) for some G '. Then, \nthere s exists D3 such that f D1 :G D3, and main ==.D3 fail. The progress property above does not guarantee \nthat the veri.\u00adcation will eventually terminate: There is a case where the entire CEGAR loop does not \nterminate, .nding new spurious error paths forever (see Section 6). Indeed, we cannot expect to obtain \na sound and complete veri.cation algorithm, as the reachability is undecid\u00adable in general even if programs \nare restricted to those using only linear arithmetics. We can however modify our algorithm so that it \nis relatively complete with respect to the dependent intersection type system, in the sense that all \nthe programs typable in the dependent intersection type system can be veri.ed by our method. Let genP \nbe a total map from the set of integers to the set of predicates. (Such a total map exists, as the set \nof predicates is recursively enumerable.) Upon the i-th iteration of the CEGAR loop, add the predicate \ngenP(i) to each position of abstraction type, in addition to the predicates inferred from counterexamples. \nThen, if a program is well-typed under . in the dependent intersection type system, an abstraction type \nenvironment G such that . . DepTy(G) is eventually found, so that by Theorem 4.4, our veri.cation succeeds. \nOf course, this is impractical, but we may be able to adapt the technique of [18] to get a practical \nalgorithm.  6. Implementation and Preliminary Experiments Based on our method described so far, we have \nimplemented a prototype veri.er for a tiny subset of Objective Caml, having only booleans and integers \nas base types. Instead of the non\u00addeterministic choice (e1 e2), the system allows conditionals and free \nvariables (representing unknown integers). Our veri.er uses TRECS [21, 22] as the underlying higher-order \nmodel checker (for Step 2 in Figure 1), and uses CSIsat [6] for computing in\u00adterpolants to solve constraints \n(for Step 4). CVC3 [5] is used for feasibility checking (for Step 3) and computing abstract transi\u00adtions \n(i.e., to compute formulas . and . ' in rule A-CADD of Figure 4 for Step 1). As computing the precise \nabstract transi\u00adtions (i.e. the strongest formulas . and . ' in rule A-CADD) is expensive, we have adapted \nseveral optimizations described in Section 5.2 of [2] such as bounding the maximum number of predicates \ntaken into account for computing abstraction with a sacri.ce of the precision. The implementation can \nbe tested at http://www.kb.ecei.tohoku.ac.jp/~ryosuke/cegar/. The full version [25] contains more details \nabout the experiments. The results of preliminary experiments are shown in Table 1. The column S shows \nthe size of programs, measured in word counts. The column O shows the largest order of functions in the \nprogram (an order-1 function takes only base values as arguments, while an order-2 function takes order-1 \nfunctions as arguments).8 The column C shows the number of CEGAR cycles. The remain\u00ading columns show \nrunning times, measured in seconds. The column abst shows the time spent for computing abstract programs \n(from given programs and abstraction types). The column mc shows the time spent (by TRECS) for higher-order \nmodel checking. The column cegar shows the time spent for .nding new predicates (Step 4 in Figure 1). \nThe column total shows the total running time (machine spec.: 3GHz CPU with 8GB memory). The programs \nused in the experiment are as follows. Free vari\u00adables denote unknown integers. intro1, intro2,and intro3 \nare the three examples in Sec\u00adtion 1. sum and mult compute 1+ \u00b7\u00b7\u00b7 + n and n + \u00b7\u00b7\u00b7 + n respec\u00ad | {z } \nn tively, and asserts that the result is greater than or equal to n. Here is the code of sum. letrecsumn \n= if n<= 0then0elsen+sum(n-1) in assert (n <= sum n) max de.nes a higher-order function that takes a \nfunction that computes the maximum of two integers, and three integers as input, and returns the maximum \nof the three integers: letmaxmax2xyz=max2 (max2xy)zin letfxy=ifx>=y then xelsey in letm=maxfxyzin assert \n(fxm=m) The last line asserts that the return value of max is greater than or equal to x (with respect \nto the function f). 8Because of the restriction of the model checker TRECS, all the source programs are \nactually veri.ed after the CPS transformation. Thus, all the tested programs are actually higher-order, \ntaking continuation functions. mc91 is McCarthy 91 function. let rec mc91 x = if x > 100 then x -10 \nelse mc91(mc91(x + 11)) in if n <= 101 then assert (mc91n=91) The last line asserts that the result is \n91 if the argument is less than or equal to 101. ack de.nes Ackermann function ack and asserts ack(n) \n= n. repeat de.nes a higher-order function that takes a function f and integers n, s, then returns fn(s). \nlet rec repeatfns= ifn=0 thenselse f(repeatf(n-1)s)in letsuccx=x+1in assert (repeat succ n0=n) fhnhn \nis a program not typable in the dependent intersection type system but veri.able in our method (c.f. \nRemark 1): letfxy= assert (not (x()>0&#38;&#38;y()<0))in lethxy=xinletgn=f(hn)(hn)ingm hrec is a program \nthat creates in.nitely many function clo\u00adsures: letrecfgx= ifx>= 0theng xelsef (fg)(gx)in letsuccx=x+1in \nassert(fsuccn>= 0) neg is an example that needs nested intersection types: letgxy=xin let twicefxy=f(fx)yin \nletnegxy= -x() in if n >= 0 then assert(twice neg (g n) () >= 0) else () apply is the program discussed \nin Remark 2. a-prod, a-cppr,and a-init are programs manipulating arrays. A (functional) array has been \nencoded as a pair of the size and a function from indices to array contents. For example, the functions \nfor creating and updating arrays are de.ned as follows. let mk_arrayni= assert(0<=i &#38;&#38; i<n); \n0 let updateinax= a(i); let a j=ifi=j then x else a(i) in a For a-prod and a-cppr, it has been veri.ed \nthat there is no array boundary error. Program a-init initializes an array, and asserts the correctness \nof initialization. and a-max creates an array of size n whose i-th element is n-i, computes the maximum \nelement m,and asserts that m = n. These examples show an advantage of higher\u00adorder model checking; various \ndata structures can be encoded as higher-order functions, and their properties can be veri.ed in a uniform \nmanner. l-zipunzip and l-zipmap are taken from list-processing programs. We have manually abstracted \nlists to integers (represent\u00ading the list length), and then veri.ed the size properties of list func\u00adtions. \nFor example, the code for l-zipunizp is: letfgxy=g (x+1)(y+1) in let rec unzipxk= ifx=0thenk00 else unzip \n(x-1) (f k) in letreczipxy= if x=0 then if y=0 then 0 else fail() else if y=0 then fail() else 1+zip(x-1)(y-1) \nin unzip n zip hors encodes a model checking problem for higher-order recursion schemes extended with \nintegers (which cannot be handled by recursion scheme model checkers).  e-simpl and e-fact model programs \nthat use exceptions, where an exception handler is expressed as a continuation, and as\u00adsert that there \nare no uncaught exceptions. The idea of the encod\u00ading of exceptions is similar to [20], but unlike [20], \nexceptions can carry integer values.  r-lock and r-file model programs that use locks and .les, and \nassert that they are accessed in a correct manner. The encoding   is similar to [22], but (unlike [22]) \nthe programs control behaviors depend on integer values. A program of name xxx-e is a buggy version of \nthe program xxx . The above programs have been veri.ed (or rejected, for wrong programs) correctly, except \napply. As discussed in Remark 2, apply cannot be veri.ed because of the fundamental limitation of abstraction \ntypes. Our system continues to infer new (but too speci.c) abstraction types (int[.... = i] . *) . int[.... \n= i] . * for i =0, 1, 2,... forever and (necessarily) does not terminate. The program can however be \nveri.ed if the arguments of apply are swapped. The same problem has been observed for variations of some \nof the programs above: sometimes we had to add or swap arguments of functions. Another limitation revealed \nby the experiments is that for some variations of the programs, the system infers too speci.c predicates \nand does not terminate. For example, the veri.cation for a-max fails if we assert m = a(j) instead of \nm = n (where m is the maximal element computed, a is the array, and j is some index). Relaxing these \nlimitations seems necessary for veri.cation of larger programs, and we plan to do so by adding heuristics \nto generalize inferred abstraction types (e.g. by using widening techniques [9]). Apart from the limitations \nabove, our system is reasonably fast. This indicates that, although higher-order model checking has the \nextremely high worst-case complexity (n-EXPTIME com\u00adplete [28]), our overall approach works at least \nfor small programs as long as suitable predicates are found. See further discussions on the scalability \nin Section 8. 7. Related Work 7.1 Model Checking of Higher-Order Programs The model checking of higher-order \nrecursion schemes has been extensively studied [19, 24, 28]. Ong [28] proved the decidabil\u00adity of the \nmodal \u00b5-calculus model checking of recursion schemes. Kobayashi [22] then proposed a new framework of \nhigher-order program veri.cation based on the model checking of recursion schemes, already suggesting \na use of predicate abstraction and CE-GAR to deal with programs manipulating in.nite data domain. There \nwere two missing pieces in his framework, however. One was a practical model checking algorithm for recursion \nschemes (note that the model checking of recursion schemes is in general n\u00adEXPTIME-complete), and the \nother was a method to apply predi\u00adcate abstraction and CEGAR to higher-order programs. The former piece \nhas been supplied later by Kobayashi [20], and supplying the latter piece was the goal of the present \npaper. In parallel to the present work, Unno et al. [26, 34] and Ong and Ramsay [29] proposed applications \nof higher-order model checking to veri.cation of tree-processing programs. Their approaches are radically \ndifferent from ours. First, they use different abstraction techniques: tree data are abstracted using \neither tree automata [26, 34] or patterns [29], which cannot abstract values using binary predicates \n(such as 2 \u00d7 x = y). Secondly, The method of [26] applies only to programs that can be expressed in the \nform of (higher-order) tree transducers, and the extension in [34] requires user annotations. Ong and \nRamsay s method [29] applies to general functional programs and includes a CEGAR mechanism, but the precision \nof their method is heavily affected by that of a variable binding analysis, and their CEGAR is completely \ndifferent from ours. Their technique does not satisfy relative completeness like Theorem 4.4.  7.2 Dependent \nType Inference There have been studies on automatic or semi-automatic inference of dependent types [7, \n11, 16, 31 33]. There are similarities be\u00adtween the goals of those studies and that of our work. First, \none of the goals of dependent type inference is to prove the lack of asser\u00adtion failures, as in the present \nwork. Secondly, our technique can actually be used for inferring dependent types. Recursion scheme model \nchecker TRECS [20] is type-based, and produces type infor\u00admation as a certi.cate of successful veri.cation. \nFor example, for the abstraction of the last example in Section 1, it infers the type * . (true . *) \n. * for (the abstract version of) f. Combined with the abstraction type of f, we can recover the following \ndepen\u00addent type for f :(x : int . (y : {. : int | .>x}. *) . *). Though the goals are similar, the techniques \nare different. Ron\u00addon et al. s liquid types [31] requires users to specify predicates (or more precisely, \nshapes of predicates, called quali.ers)usedinde\u00adpendent types. Jhala et al. [16] proposed an automatic \nmethod for inferring quali.ers for liquid types. Their method extracts quali.ers from a proof that a \n.nite unfolding of a source program does not get stuck, and has some similarity to our method to infer \nabstrac\u00adtion types from an error path. Unno and Kobayashi [33] proposed an automatic method for inferring \ndependent types. They .rst pre\u00adpare templates of dependent types (that contain predicate variables) and \ngenerate (possibly recursive) constraints on predicate variables. They then solve the constraints by \nusing an interpolating theorem prover. Jhala et al. [17] also propose a similar method, where they reduce \nthe constraint solving in the last phase to model checking of imperative programs. These approaches [16, \n17, 31, 33] do sup\u00adport higher-order functions, but in a limited manner, in the sense that nested intersection \ntypes are not allowed. The difference be\u00adtween dependent types with/without intersections is like the \none between context (or .ow) sensitive/insensitive analyses. The for\u00admer is more precise though it can \nbe costly.9 In general, nested intersection types are necessary to verify a program when function parameters \nare used more than once in different contexts. Indeed, as discussed in [25], several of the programs \nin Section 6 (e.g. neg, where the .rst argument of twice is used in two different contexts) require nested \nintersection types, and almost all the examples given by Kobayashi [20, 22] call for nested intersection \ntypes. The limitation of our current prototype implementation is that the supported language features \nare limited. We believe that it is possible to extend our implementation to deal with data structures. \nIn fact, the predicate abstraction introduced in Section 4 applies to data structures given an appropriate \ntheorem prover. We expect the CEGAR part can also be extended, e.g. by restricting the properties on \ndata structures to size properties, by treating data constructors as uninterpreted function symbols, \netc. Technically, most closest to ours is Terauchi s work [32]. In his method, candidates for dependent \ntypes are inferred from a .nite unfolding of a source program, and then a .xedpoint computation algorithm \nis used to .lter out invalid types. If the source program is not typable with the candidates for dependent \ntypes, the pro\u00adgram is further unfolded and more candidates are collected. This cycle (which may diverge) \nis repeated until the source program is found to be well-typed or ill-typed. This is somewhat similar \nto the way our veri.cation method works: abstraction types are in\u00adferred from an error trace (instead \nof an unfolding of a program), and then higher-order model checking (which also involves a .xed\u00adpoint \ncomputation) is applied to verify the abstract program. If the veri.cation fails and an infeasible error \npath is found, the error path is used to infer more predicates, and this cycle is repeated. Thus, roughly \nspeaking, our CEGAR phase corresponds to that of Terauchi to .nd candidates for dependent types, and \nour phases for predicate abstraction and higher-order model checking corre\u00adsponds to Terauchi s .xedpoint \ncomputation phase. Advantages of 9 Our method is an extreme case of context/.ow sensitive analysis, which \nis sound and complete for programs with .nite data domains.  program S O C abst mc cegar total program \nS O C abst mc cegar total intro1 27 2 1 0.00 0.00 0.00 0.01 a-init 96 2 5 0.16 0.18 0.38 0.73 intro2 \n29 2 1 0.00 0.00 0.00 0.00 a-max 70 2 5 2.34 2.01 0.43 4.78 intro3 30 2 1 0.00 0.00 0.00 0.00 l-zipunzip \n81 2 3 0.03 0.08 0.02 0.12 sum 24 1 2 0.00 0.00 0.01 0.02 l-zipmap 65 2 4 0.07 0.09 0.03 0.20 mult 31 \n1 2 0.01 0.00 0.02 0.03 hors 64 2 2 0.00 0.00 0.00 0.01 max 42 2 1 0.00 0.00 0.03 0.03 e-simple 27 2 \n1 0.00 0.00 0.00 0.00 mc91 32 1 2 0.01 0.04 0.02 0.07 e-fact 55 2 2 0.00 0.01 0.00 0.01 ack 53 1 3 0.02 \n0.09 0.03 0.15 r-lock 54 1 5 0.01 0.02 0.02 0.04 repeat 37 2 3 0.01 0.02 0.12 0.15 r-.le 168 1 12 0.30 \n4.78 0.16 5.23 fhnhn 37 2 1 0.01 0.01 0.02 0.04 sum-e 26 1 0 0.00 0.00 0.00 0.00 hrec 34 2 2 0.00 0.01 \n0.02 0.03 mult-e 33 1 0 0.00 0.00 0.00 0.00 neg 47 2 1 0.01 0.01 0.01 0.03 mc91-e 32 1 0 0.00 0.00 0.00 \n0.00 apply 34 2 - - - - - repeat-e 35 2 0 0.00 0.00 0.00 0.00 a-prod 70 2 4 0.07 0.06 0.08 0.22 a-max-e \n70 2 2 0.01 0.06 0.06 0.13 a-cppr 149 2 6 0.32 2.82 0.26 3.40 r-lock-e 54 1 0 0.00 0.00 0.00 0.00 Table \n1. Results of preliminary experiments ours are: (i) our method can generate an error path as a counterex\u00adample; \nthere is no false alarm. On the other hand, a counterexample of Terauchi s method is an unfolding of \na program, which may ac\u00adtually be safe. (ii) We infer predicates from an error trace, rather than from \nan unfolding of a program; From the latter, too many constraints are generated, especially for programs \ncontaining non\u00adlinear recursions. (iii) Our method can .nd dependent types con\u00adstructed from arbitrary \nboolean combinations of the inferred predi\u00adcates, while Terauchi s method only looks for dependent types \ncon\u00adstructed from the formulas directly generated by an interpolating theorem prover; thus, the success \nof the latter more heavily relies on the quality or heuristics of the underlying interpolating theorem \nprover. (iv) Because of the point (iii) above, our method (predicate abstraction + higher-order model \nchecking) can also be used in a liquid type-like setting [31] where atomic predicates are given by a \nuser. (v) Because of the point discussed in Remark 1, the combina\u00adtion of our predicate abstraction and \nhigher-order model checking is strictly more powerful than Terauchi s approach (as long as suit\u00adable \npredicates are found). (vi) Our method can be extended to ver\u00adify more general properties (expressed \nby the modal \u00b5-calculus), by appealing to the results on higher-order model checking [24, 28].  7.3 \nTraditional Model Checking Predicate abstraction and CEGAR have been extensively studied in the context \nof .nite state or pushdown model checking [2 4, 8, 12 15]. Predicate abstraction has also been applied \nto the game-semantics-based model checking [1]. We are not, however, aware of previous work that applies \npredicate abstraction and CE-GAR to higher-order model checking. As discussed in Section 1, the extension \nof predicate abstraction and CEGAR to higher-order model checking is non-trivial. One may think that \ndefunctional\u00adization [30] can be used to eliminate higher-order functions and apply conventional model \nchecking. The defunctionalization how\u00adever uses recursive data structures to represent closures, so that \nthe resulting veri.cation method is too imprecise, unless a clever ab\u00adstraction technique for recursive \ndata structures is available. The three components of our veri.cation method, predicate ab\u00adstraction, \nhigher-order model checking (TRECS), and CEGAR, may be seen as higher-order counterparts of the three \ncomponents of SLAM [2 4]: C2BP,BEBOP,and NEWTON. Our use of depen\u00addency in abstraction types appears \nto subsume Ball et al. s poly\u00admorphic predicate abstraction [3]. For example, the id function in [3] \ncan be abstracted by using the abstraction type x : int[] . int[.y.y = x]. There are a lot of studies \nto optimize predicate abstraction (es\u00adpecially for optimizing or avoiding the costly computation of ab\u00adstract \ntransition functions) in the context of conventional model checking [2, 27]. We have already borrowed \nsome of the optimiza\u00adtion techniques as mentioned in Section 6, and plan to adapt more techniques.  \n7.4 Abstract Interpretation The combination of predicate abstraction and higher-order model checking \nmay be viewed as a kind of abstract interpretation [9]. The abstract domain used for each functional \nvalue is de.ned by ab\u00adstraction types, and predicate abstraction transforms a source pro\u00adgram into an \nHBP whose semantics corresponds to the abstract se\u00admantics of the source program. Higher-order model \nchecking then computes the abstract semantics. An advantage here is that thanks to the model checking \nalgorithm [20] for higher-order recursion schemes, the computation of the abstract semantics is often \nmuch faster than a naive .xed-point computation (which is extremely costly for higher-order function \nvalues). 8. Conclusion We have proposed predicate abstraction and CEGAR techniques for higher-order model \nchecking, and implemented a prototype ver\u00adi.er. We believe that this is a new promising approach to automatic \nveri.cation of higher-order functional programs. Optimization of the implementation and larger experiments \nare left for future work. We conclude the paper with discussions on the scalability of our method. The \ncurrent implementation is not scalable for large programs, but we expect that (after several years of \nefforts) we can eventually obtain a much more scalable veri.er based on our method, for several reasons. \nFirst, the complexity of the model checking of higher-order recursion schemes is n-EXPTIME com\u00adplete \n[28], but with certain parameters being .xed, the complexity is actually polynomial (linear, if restricted \nto safety properties) time in the size of a recursion scheme (or, the size of HBP). Furthermore, n-EXPTIME \ncompleteness is the worst-case complexity, and re\u00adcent model checking algorithms [20, 23] do not immediately \nsuffer from the n-EXPTIME bottleneck. Secondly, the implementation of the underlying higher-order model \nchecker TRECS is premature, and there is a good chance for improvement. Thirdly, the current implementation \nof predicate abstraction and CEGAR is also quite naive. For example, the current implementation computes \nabstract programs eagerly. We expect that a good speed-up is obtained by computing abstract programs \nlazily.  Acknowledgment We would like to thank members of our research group for dis\u00adcussion and comments. \nWe would also like to thank anonymous referees for useful comments. This work was partially supported \nby Kakenhi 20240001. References [1] A. Bakewell and D. R. Ghica. Compositional predicate abstraction \nfrom game semantics. In TACAS 09, pages 62 76. Springer, 2009. [2] T. Ball, R. Majumdar, T. Millstein, \nand S. K. Rajamani. Automatic predicate abstraction of C programs. In PLDI 01, pages 203 213. ACM, 2001. \n[3] T. Ball, T. Millstein, and S. K. Rajamani. Polymorphic predicate ab\u00adstraction. ACM Transactions on \nProgramming Languages and Sys\u00adtems, 27(2):314 343, 2005. [4] T. Ball and S. K. Rajamani. The SLAM project: \ndebugging system software via static analysis. In POPL 02, pages 1 3. ACM, 2002. [5] C. Barrett and C. \nTinelli. CVC3. In CAV 07, volume 4590 of LNCS, pages 298 302. Springer, July 2007. [6] D. Beyer, D. Zufferey, \nand R. Majumdar. CSIsat : Interpolation for LA+EUF (tool paper). In CAV 08, volume 5123 of LNCS, pages \n304 308, July 2008. [7] W.-N. Chin and S.-C. Khoo. Calculating sized types. Higher-Order and Symbolic \nComputation, 14(2-3):261 300, September 2001. [8] E. Clarke, O. Grumberg, S. Jha, Y. Lu, and H. Veith. \nCounterexample\u00adguided abstraction re.nement for symbolic model checking. Journal of the ACM, 50(5):752 \n794, 2003. [9] P. Cousot and N. Halbwachs. Automatic discovery of linear restraints among variables of \na program. In POPL 78, pages 84 96. ACM, 1978. [10] W. Damm. The IO-and OI-hierarchies. Theoretical Computer \nSci\u00adence, 20(2):95 207, 1982. [11] C. Flanagan. Hybrid type checking. In POPL 06, pages 245 256. ACM, \n2006. [12] S. Graf and H. Sa\u00a8idi. Construction of abstract state graphs with PVS. In CAV 97, volume 1254 \nof LNCS, pages 72 83. Springer, June 1997. [13] M. Heizmann, J. Hoenicke, and A. Podelski. Nested interpolants. \nIn POPL 10, pages 471 482. ACM, 2010. [14] T. A. Henzinger, R. Jhala, R. Majumdar, and K. L. McMillan. \nAb\u00adstractions from proofs. In POPL 04, pages 232 244. ACM, 2004. [15] T. A. Henzinger, R. Jhala, R. Majumdar, \nand G. Sutre. Lazy abstrac\u00adtion. In POPL 02, pages 58 70. ACM, 2002. [16] R. Jhala and R. Majumdar. Counterexample \nre.nement for functional programs. Manuscript, available from http://www.cs.ucla.edu/ ~rupak/Papers/CEGARFunctional.ps, \n2009. [17] R. Jhala, R. Majumdar, and A. Rybalchenko. Re.nement type infer\u00adence via abstract interpretation. \narXiv:1004.2884v1, 2010. [18] R. Jhala and K. L. McMillan. A practical and complete approach to predicate \nre.nement. In TACAS 06, volume 3920 of LNCS, pages 459 473. Springer, 2006. [19] T. Knapik, D. Niwinski, \nand P. Urzyczyn. Higher-order pushdown trees are easy. In FoSSaCS 02, volume 2303 of LNCS, pages 205 \n222. Springer, 2002. [20] N. Kobayashi. Model-checking higher-order functions. In PPDP 09, pages 25 36. \nACM, 2009. [21] N. Kobayashi. TRECS. http://www.kb.ecei.tohoku.ac.jp/ ~koba/trecs/, 2009. [22] N. Kobayashi. \nTypes and higher-order recursion schemes for veri.ca\u00adtion of higher-order programs. In POPL 09, pages \n416 428. ACM, 2009. [23] N. Kobayashi. A practical linear time algorithm for trivial automata model checking \nof higher-order recursion schemes. In FoSSaCS 11. Springer, 2011. [24] N. Kobayashi and C.-H. L. Ong. \nA type system equivalent to the modal mu-calculus model checking of higher-order recursion schemes. In \nLICS 09, pages 179 188. IEEE, 2009. [25] N. Kobayashi, R. Sato, and H. Unno. Predicate abstraction and \nCE-GAR for higher-order model checking. An extended version, available from http://www.kb.ecei.tohoku.ac.jp/~uhiro/, \n2011. [26] N. Kobayashi, N. Tabuchi, and H. Unno. Higher-order multi\u00adparameter tree transducers and recursion \nschemes for program veri\u00ad.cation. In POPL 10, pages 495 508. ACM, 2010. [27] K. L. McMillan. An interpolating \ntheorem prover. Theoretical Com\u00adputer Science, 345(1):101 121, 2005. [28] C.-H. L. Ong. On model-checking \ntrees generated by higher-order recursion schemes. In LICS 06, pages 81 90. IEEE, 2006. [29] C.-H. L. \nOng and S. J. Ramsay. Verifying higher-order functional programs with pattern-matching algebraic data \ntypes. In POPL 11, pages 587 598. ACM, 2011. [30] J. C. Reynolds. De.nitional interpreters for higher-order \nprogramming languages. In Proceedings of the ACM annual conference -Volume 2, pages 717 740. ACM, 1972. \n[31] P. Rondon, M. Kawaguchi, and R. Jhala. Liquid types. In PLDI 08. ACM, 2008. [32] T. Terauchi. Dependent \ntypes from counterexamples. In POPL 10, pages 119 130. ACM, 2010. [33] H. Unno and N. Kobayashi. Dependent \ntype inference with inter\u00adpolants. In PPDP 09, pages 277 288. ACM, 2009. [34] H. Unno, N. Tabuchi, and \nN. Kobayashi. Veri.cation of tree\u00adprocessing programs via higher-order model checking. In APLAS 10, volume \n6461 of LNCS, pages 312 327. Springer, October/December 2010. [35] H. Xi and F. Pfenning. Dependent types \nin practical programming. In POPL 99, pages 214 227. ACM, 1999.   \n\t\t\t", "proc_id": "1993498", "abstract": "<p>Higher-order model checking (more precisely, the model checking of higher-order recursion schemes) has been extensively studied recently, which can automatically decide properties of programs written in the simply-typed &#955;-calculus with recursion and <i>finite</i> data domains. This paper formalizes predicate abstraction and counterexample-guided abstraction refinement (CEGAR) for higher-order model checking, enabling automatic verification of programs that use <i>infinite</i> data domains such as integers. A prototype verifier for higher-order functional programs based on the formalization has been implemented and tested for several programs.</p>", "authors": [{"name": "Naoki Kobayashi", "author_profile_id": "81100603931", "affiliation": "Tohoku University, Sendai, Japan", "person_id": "P2690547", "email_address": "koba@ecei.tohoku.ac.jp", "orcid_id": ""}, {"name": "Ryosuke Sato", "author_profile_id": "81485642280", "affiliation": "Tohoku University, Sendai, Japan", "person_id": "P2690548", "email_address": "ryosuke@kb.ecei.tohoku.ac.jp", "orcid_id": ""}, {"name": "Hiroshi Unno", "author_profile_id": "81100097133", "affiliation": "Tohoku University, Sendai, Japan", "person_id": "P2690549", "email_address": "uhiro@kb.ecei.tohoku.ac.jp", "orcid_id": ""}], "doi_number": "10.1145/1993498.1993525", "year": "2011", "article_id": "1993525", "conference": "PLDI", "title": "Predicate abstraction and CEGAR for higher-order model checking", "url": "http://dl.acm.org/citation.cfm?id=1993525"}