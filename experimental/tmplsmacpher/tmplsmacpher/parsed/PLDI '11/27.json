{"article_publication_date": "06-04-2011", "fulltext": "\n Spreadsheet Table Transformations from Examples William R. Harris * Sumit Gulwani Dept. of Computer \nSciences Microsoft Research University of Wisconsin, Madison Redmond, WA, USA Madison, WI, USA sumitg@microsoft.com \nwrharris@cs.wisc.edu Abstract Every day, millions of computer end-users need to perform tasks over large, \ntabular data, yet lack the programming knowledge to do such tasks automatically. In this work, we present \nan automatic technique that takes from a user an example of how the user needs to transform a table of \ndata, and provides to the user a program that implements the transformation described by the example. \nIn particular, we present a language of programs TableProg that can describe transformations that real \nusers require. We then present an algorithm ProgFromEx that takes an example input and output ta\u00adble, \nand infers a program in TableProg that implements the trans\u00adformation described by the example. When \nthe program is applied to the example input, it reproduces the example output. When the program is applied \nto another, potentially larger, table with a sim\u00adilar layout as the example input table, then the program \nproduces a corresponding table with a layout that is similar to the example output table. A user can \napply ProgFromEx interactively, provid\u00ading multiple small examples to obtain a program that implements \nthe transformation that the user desires. Moreover, ProgFromEx can help identify noisy examples that \ncontain errors. To evaluate the practicality of TableProg and ProgFromEx, we implemented ProgFromEx as \na module for the Microsoft Excel spreadsheet program. We applied the module to automati\u00adcally implement \nover 50 table transformations speci.ed by end\u00adusers through examples on online Excel help forums. In \nseconds, ProgFromEx found programs that satis.ed the examples and could be applied to larger input tables. \nThis experience demon\u00adstrates that TableProg and ProgFromEx can signi.cantly auto\u00admate the tasks over \ntabular data that users need to perform. Categories and Subject Descriptors D.1.2 [Programming Tech\u00adniques]: \nAutomatic Programming; I.2.2 [Arti.cial Intelligence]: Program Synthesis General Terms Languages, Algorithms, \nHuman Factors Keywords Program Synthesis, End-user Programming, Program\u00adming by Example, Spreadsheet \nProgramming, Table Manipulation, User Intent * This work was performed during an internship at Microsoft \nResearch, Redmond. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. PLDI 11, June 4 8, 2011, San Jose, California, USA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0663-8/11/06. \n. . $10.00 1. Introduction More and more end users now apply computers to perform com\u00adplex and critical \ntasks on digital data. While users often clearly understand the task that they need a computer to perform, \nthe tools that users may apply to communicate their task to a computer re\u00admain limited. At one extreme, \ngraphical user interfaces (GUI s) are highly accessible. However, GUI s typically do not allow users \nto customize or personalize their program such that the user can fully automate their task. Furthermore, \nas programs with GUI s support more and more features, users often struggle to discover the fea\u00adtures. \nOn the other extreme, general programming languages serve as a fully expressive medium for communicating \na task to a com\u00adputer. However, even the most accessible scripting language re\u00adquires an amount of time \nand energy that a typical user is not pre\u00adpared, and should not be expected, to invest. Unlike traditional \nprogramming, the techniques of end-user programming by demonstration or by example [3, 17] allow users \nto describe a computation via partial execution traces or .nal out\u00adputs resulting from a small set of \ninputs, without requiring the user to describe how to perform the computation in general. A tool based \non such techniques then produces for the user a general pro\u00adgram that, given the example inputs, produces \nthe corresponding outputs. Moreover, the program is de.ned for many more inputs than the examples, so \nusers can apply the program to other inputs to automatically obtain the outputs that they require. Programming \nby example is an attractive approach, as users often naturally use examples to express the tasks that \nthey need to perform. On help fo\u00adrums that we studied, novice users express tasks through examples so \nfrequently that it is practically a forum convention. Previous work in programming by example has focused \npri\u00admarily on inferring programs that transform strings of text [9, 15]. However, techniques based on \nthis work cannot yet be used directly by real end users, as in practice, users need to transform rich, \nsemi\u00adstructured data. In particular, millions of users every day need to transform tabular data stored \nin spreadsheets using of.ce programs such as Microsoft Excel [5] or OpenOf.ce [19]. Often, such trans\u00ad \nformations do not change the textual content of any cell, or only change the content in a simple way. \nHowever, the transformation rearranges the layout of the table, i.e. the manner in which cells are spatially \narranged or grouped. Existing techniques for program\u00adming by example cannot be applied to infer programs \nthat imple\u00adment such transformations. Inferring transformations over spreadsheet tables presents unique \nchallenges compared to the problem of inferring views over rela\u00adtional tables [4]. In particular, a spreadsheet \ntable is in general only a two-dimensional array of cells, where each cell contains a string. Unlike \nrelational tables, rows of a spreadsheet tables are ordered, different rows may contain data with different \nsemantic relation\u00adships, and the spreadsheet table may not provide names of column .elds. Spreadsheet \ntables also often have special layout or format\u00ad Example input table: Qual 1 Qual 2 Qual 3 Andrew 01.02.2003 \n27.06.2008 06.04.2007 Ben 31.08.2001 05.07.2004 Carl 18.04.2003 09.12.2009 Example output table: Andrew \nQual 1 01.02.2003 Andrew Qual 2 27.06.2008 Andrew Qual 3 06.04.2007 Ben Qual 1 31.08.2001 Ben Qual 3 \n05.07.2004 Carl Qual 2 18.04.2003 Carl Qual 3 09.12.2009 Figure 1. Example input and output tables from \nan online Excel help forum thread Using a macro to extract and rearrange data. ting attributes, such \nas sub-headers, footers, .ller cells (blank cells or cells with some special characters to aid visual \nreadability of table content) [1]. In this paper, we only consider the problem of inferring transformations \nover spreadsheet tables. All references to tables refer to spreadsheet tables, unless otherwise noted. \nExample 1. The tables in Fig. 1 are an example of a common table transformation that a user would like \nto perform automatically. The tables are from a real Excel help forum thread. 1 The thread was started \nby a novice user, who needed to transform a large table in a given layout into a table in a different \nlayout. To express their transformation, the user provided a small, representative input table, along \nwith the output table that should result from applying the transformation to the input table. Both tables \nare in Fig. 1. The example input table contains a set of dates on which tests where given, where each \ndate is in a row corresponding to the name of the test taker, and in a column corresponding to the name \nof the test. For every date, the user needs to produce a row in the output table containing the name \nof the test taker, the name of the test, and the date on which the test was taken. If a date cell in \nthe input table is empty, then no corresponding row should be produced in the output table. The rows \nshould be produced in the order that the dates are ordered in the input table by row-major order. In \nthe help thread, the novice user described their required transformation in a few paragraphs of English, \nbut the novice also included the example input and output tables in Fig. 1 (the output table has been \nsimpli.ed slightly for illustrative purposes; the full implementation of our technique can infer a program \nfor the original example). In about half an hour, an expert user responded with a link to an Excel macro \nthat the expert suspected would be useful for the novice. Twenty minutes after the expert responded, \nthe novice con.rmed that the macro implemented the transformation that he or she required. In this paper, \nwe describe a method for inferring table trans\u00adformations from examples by applying a general research \nmethod\u00adology for designing systems that support programming by exam\u00adple [8]. The steps of this general \nmethodology are: 1. Identify a domain of data on which a large class of users strug\u00adgle to perform repetitive \noperations that they can clearly de\u00adscribe with examples. 2. Design a programming language that describes \na large propor\u00adtion of operations that users need to perform on the data domain in practice.  1 http://www.excelforum.com/excel-programming/ \n698490-using-a-macro-to-extract-and-rearrange-data.html  3. Design an algorithm that ef.ciently infers \nprograms in the lan\u00adguage from example inputs and outputs. In previous work, we applied the above methodology \nto infer pro\u00adgrams that transform strings of text [9]. In this work, we apply the methodology to infer \nprograms that transform tables. In this paper, we .rst present a language of programs that implement \ntransformations over tables. While the language cannot describe all transformations over tables, we designed \nit by studying the transformations that users require in practice, and de.ning a language that can describe \ncombinations of the most common transformations. We then present an algorithm that takes an example input \nand output table and automatically infers in seconds a program in the language that implements a transformation \nthat satis.es the exam\u00adple. If the program is applied to the example input, then the program produces \nthe example output, and if the program is applied to an\u00adother table with a layout similar to that of \nthe example input, then the program produces a corresponding table with a layout similar to the example \noutput table. End users can apply our language and al\u00adgorithm to automatically obtain programs that transform \nmultiple, huge tables. To do so, they construct small, representative input and output example tables, \nand give the example tables to our inference algorithm. The inference algorithm then infers a program \nwhich the user can apply to their large input tables. The user in Ex. 1 can apply our algorithm to the \nexample tables in Fig. 1 and in seconds obtain a program that implements their desired table transformation. \nThe algorithm is highly scalable because it divides the problem of inferring a program that transforms \nan entire table into subprob\u00adlems of inferring programs that transform subtables of the original table. \nIt then infers simple programs that transform the subtables, and ef.ciently combines the simple programs \nto construct a pro\u00adgram that transforms the original table. On some examples, our algorithm may infer \na program that satis.es the input and output pair given by the user, but does not implement the general \ntransformation that the user requires. In this case, the user can re.ne the inferred program by providing \na larger, more descriptive input-output example that demonstrates the behavior on which the original \nprogram behaves incorrectly, or by providing multiple input and output examples that together describe \nthe required behavior. In this paper, we make the following contributions: 1. We present a language \nof programs, TableProg, that can ex\u00adpress a rich set of practical transformations over tabular data. \nTableProg is designed to express table transformations re\u00adquired by real users, but is conceptually simple \nand is described by a small semantics. 2. We present a novel algorithm, ProgFromEx, for inferring TableProg \nprograms from example input and output tables. We show the correctness of ProgFromEx, and analyze its \ncom\u00adplexity. 3. We report our experience using ProgFromEx. We imple\u00admented ProgFromEx as a plug-in module \nfor the Microsoft Excel spreadsheet program, and applied the module to auto\u00admatically infer TableProg \nprograms that implement over 50 transformations speci.ed by examples in online Excel help fo\u00adrums.  \nThe rest of this paper is organized as follows. In \u00a72, we use the example in Fig. 1 to illustrate the \nchallenges of inferring table transformations, the structure of programs in TableProg, and how ProgFromEx \ninfers a program that satis.es the example. In \u00a73, we present TableProg in detail, and in \u00a74, we present \nProgFromEx in detail. In \u00a75, we report our experience applying ProgFromEx to infer table programs from \nreal-world examples. In \u00a76 we discuss related work, and in \u00a77, we conclude. 2. Overview Users often \nneed to transform the layout of tables in non-trivial ways. In this section, we use the running example \nin Fig. 1 to observe in more detail the challenges in inferring a transformation from an example input \nand output. From these observations, we motivate the design of our language TableProg of table programs \nand our algorithm for inferring TableProg programs. 2.1 An Example Table Program Consider a program \nthat, given the example input table from Fig. 1, produces the example output table (i.e. a program that \nsatis.es the examples). One insight into a possible structure of such a program is guided by the following \nproperty of example tables, which we have observed to hold over almost all example tables given by real \nusers. Remark 1. Often, a subset of the cells in an output table (i.e. a substructure of the output table) \ncan be produced by treating the cells in the input table as a sequence ordered by row-major order, selecting \nsome cells in the sequence, and spatially rearranging the selected cells while preserving their row-major \norder. Guided by Remark 1, we initially suppose that a table program makes a series of passes over the \ninput table in row-major order. In each pass, the program selects a subset of cells in the input table, \nand produces cells in the output table that hold the same text as the selected cells, though they may \nbe produced in a different spatial arrangement. We call each pass a .lter program, and say that a .lter \nprogram reads the cells of the input table in row-major order, and checks if each cell satis.es a mapping \ncondition. If an input cell satis.es the mapping condition, then the .lter program produces a new cell \nin the output table that contains the same text as the input. The new cell is produced at the bottom \nof a column determined by an output sequencer. Example 2. Remark 1 can be applied to the tables in Fig. \n1 to derive a .lter program F that produces column 3 (we adopt the convention of most spreadsheet programs \nand describe tables using 1-based indexing). To produce column 3, a .lter program passes over the cells \nin the input table in row-major order, and checks each cell against the mapping condition that the cell \nis not in row 1, not in column 1, and is non-empty. If the input cell satis.es the mapping condition, \nthen the .lter program s output sequencer determines that .lter program should add the new cell to column \n3. Ex. 2 illustrates that .lter programs are often powerful enough to produce substructures of an output \ntable. However, Fig. 1 demon\u00ad strates that .lter programs on their own are often insuf.cient or im\u00adpractical \nfor producing an entire output table. First, to produce col\u00adumn 1 of the output table, a .lter program \nwould need to perform complex reasoning. When the .lter program would check the in\u00adput cell containing \nAndrew, it would add cells holding this text to column 1 of the output three times in sequence. However, \nwhen the .lter program would check the cells with texts Ben and Carl , it would only add cells to column \n1 of the output two times each. To produce column 2 of the output table, a .lter program would need to \napply different complex reasoning. Such a program would check the input cells containing the texts Qual \nk, and would pro\u00adduce column 2 of the output table by interleaving multiple cells with these texts. Intuitively, \nit seems dif.cult to derive a language of .lter programs that can perform such reasoning in a single \npass over the input table. To derive programs that can produce such sub\u00adstructures of the output, we \napply a new observation. Remark 2. Two cells in an output table that are in the same row or column often \nhold the same text as two cells in the input table that are in the same row or the same column. Example \n3. For Fig. 1, let cell c be any cell in column 1 of the output table, and let cell d be in column 3 \nof the same row as c. Then c and d hold the same text as cells in columns 1 and 3 of some row of the \ninput table. To apply Remark 2, we .rst enrich our notion of a .lter pro\u00ad gram. Above, we described a \n.lter program as taking a table as input and producing a substructure of a table as output. We now describe \na .lter program as taking a table as input, and computing a map from coordinates of cells in the input \ntable to the coordinates of cells that will be in the output table. In general, a map may be an arbitrary \nbinary relation pairing input and output coordinates; it need not be a function. A table program applies \na coordinate map to an input table to produce a substructure of the output table; for every entry (c, \nd) in the map, the table program produces a new cell in the output table at coordinate d, and .lls the \ncell with the text in the input table at c. If a coordinate map maps every cell that will be in a column \nk of an output table, then we say that the map maps to column k. Example 4. In Ex. 2, we described a \n.lter program F as producing column 3 of the output table. If we rede.ne F as computing a map mF from \ncoordinates of cells in the input table to coordinates of cells that will be in column 3 of the output \ntable, then mF for the example tables in Fig. 1 is the following set of pairs of input and output coordinates: \n89 < ((2, 2), (1, 3)), ((2, 3), (2, 3)), ((2, 4), (3, 3)), = mF = ((3, 2), (4, 3)), ((3, 4), (5, 3)), \n:; ((4, 3), (6, 3)), ((4, 4), (7, 3)) By de.ning .lter programs to compute maps between coordi\u00adnates, \nwe can build associative programs from .lter programs. Like a .lter program, an associative program computes \na map from co\u00adordinates of cells in the input table to coordinates of cells to be in the output table. \nHowever, to do so, an associative program uses a .lter program F to compute an initial map between coordinates, \nand then alters each pair of coordinates in the map to produce its own map. The associative program alters \nthe map computed by F by applying a relative function R1 to each input coordinate to ob\u00adtain a new input \ncoordinates, and applying another relative function R2 to each output coordinate to obtain new output \ncoordinates. We denote such an associative program as (F, R1, R2). Example 5. For Fig. 1, an associative \nprogram A1 maps to column 1 of the output table. A1 .rst uses F to compute the map mF from Ex. 4. A1 \nalters the input coordinates of mF by applying to each input coordinate a relative function RELCOL1 that \ncomputes the coordinate in the same row and in column 1. A1 alters the output coordinates of mF by applying \nRELCOL1 to each output coordinate. The resulting map mA1 maps coordinates in column 1 of the input table \nto coordinates of cells to be produced in column 1 of the output table: 89 < ((2, 1), (1, 1)), ((2, 1), \n(2, 1)), ((2, 1), (3, 1)), = mA1 = ((3, 1), (4, 1)), ((3, 1), (5, 1)), :; ((4, 1), (6, 1)), ((4, 1), \n(7, 1)) A second associative program A2 maps to column 2 of the output table. Like A1, A2 .rst uses \nF to compute mF. A2 alters each input coordinate in mF by applying a relative function RELROW1 that computes \nthe coordinate in the same column but in row 1. A2 alters each output coordinate in mF by applying a \nrelative function RELCOL2, where RELCOL2 is de.ned analogously to RELCOL1. The resulting map mA2 maps \ncoordinates in row 1 of the input to coordinates of cells to be produced in column 2 of the output: \n89 < ((1, 2), (1, 2)), ((1, 3), (2, 2)), ((1, 4), (3, 2)), = mA2 = ((1, 2), (4, 2)), ((1, 4), (5, 2)), \n:; ((1, 3), (6, 2)), ((1, 4), (7, 2)) An associative program may use a map computed by a .lter pro\u00ad gram, \nbut may in general also use a map computed by another asso\u00adciative program. This is because an associative \nprogram only uses a .lter program to compute a map over table coordinates, but asso\u00adciative programs \nthemselves compute maps over table coordinates. We thus refer to both .lter programs and associative \nprograms as component programs, and say that in general, an associative pro\u00adgram can be built from a \ncomponent program. A table program P built from .lter and associative programs can take the example input \ntable from Fig. 1 and produce the example output table. P computes the coordinate map of the .lter program \nF described in Ex. 4, the map of the associative program A1, and the map of A2 described in Ex. 5, and \nthen applies the coordinate maps to produce a table. When P is applied to the example input from Fig. \n1, it produces the example output. P is a program in the language TableProg, which is presented formally \nin \u00a73.  2.2 Inferring the Example Table Program The table program P described in \u00a72.1 satis.es the example \ntables from Fig. 1. The algorithm ProgFromEx, when given the exam\u00adple tables from Fig. 1, automatically \ninfers P. Like P, each table program is a set of two different types of component programs: .l\u00adter programs \nand associative programs. Thus ProgFromEx infers a table program in two steps, building component programs \nof a particular type in each step. In step 1), ProgFromEx builds a set of .lter programs. In step 2), \nProgFromEx iteratively builds asso\u00adciative programs from component programs that it has already built \nuntil it .nds a set of component programs that map to all cells in the example output table. In step \n1), ProgFromEx infers a set of .lter programs from a .xed set of candidate-map rules. Each candidate-map \nrule, given example input and output tables, produces a set of consistent maps between coordinates in \nthe example tables. A map is consistent for an example input and output if, when applied to the example \ninput, the map produces a substructure of the example output. Unlike a .lter program, candidate-map rules \ncannot compute a map from only an input table. They are applied to an example input and output to suggest \na map that a .lter program may compute when the program is applied to the example input. Thus we call \nsuch a map a candidate map. From a candidate map, ProgFromEx infers a general .lter program that computes \nthe candidate map when applied to the example input, but also computes analogous maps when applied to \nother input tables. Example 6. ProgFromEx uses a candidate-map rule to sug\u00adgest the coordinate map mF \nfrom Ex. 4. ProgFromEx is given candidate-map rules that specify: map a coordinate in the input table \nto a coordinate in column k of the output table if and only if the values at those coordinates are equal, \nwith one such rule for each column k in the example output table. The rule for k =3 gen\u00aderates a candidate \nmap from each coordinate holding a date in the input table to the coordinate in the output table holding \nthe same date. This map is mF. Given a candidate map, ProgFromEx attempts to infer a .lter program that \ncomputes the map when the program is applied to the example input. To infer a .lter program, ProgFromEx \nmust .rst infer the .lter program s mapping condition. For a .lter program to compute the candidate map, \nthe program s mapping condition must be satis.ed by every input cell mapped by the candidate map, and \nmust not satis.ed by any input cell that is not mapped by the candidate map. ProgFromEx infers the mapping \ncondition as a conjunction over a .xed set of atomic predicates and their negations using a greedy algorithm, \ndiscussed in \u00a74.1. Each atomic predicate describes some feature of a cell. Example 7. ProgFromEx infers \na .lter program to implement the candidate map mF suggested by a candidate-map rule in Ex. 6. To infer \na .lter program, ProgFromEx .rst infers the .lter program s mapping condition. The mapping condition \nmust be satis.ed by all of the cells in the example input that are mapped by mF, and must not be satis.ed \nby any of the cells in the example input that are not mapped by mF. Suppose that ProgFromEx is given \na predicate that decides if a cell is in row 1, a predicate that decides if a cell is empty, and for \neach column k in the example input table, a predicate that decides if a cell is in column k. Given these \npredicates, ProgFromEx infers the conjunctive mapping condition stated informally in Ex. 2. To infer \na .lter program that computes a candidate map, ProgFromEx must also infer an output sequencer for the \n.lter program. To infer an output sequencer, ProgFromEx orders the output coordinates in the candidate \nmap by the order in which the .lter program must map them; i.e., ProgFromEx orders the output coordinates \nby the row-major ordering of the input cells that map to them. ProgFromEx then checks if the ordered \nsequence of output coordinates matches the output coordinates described by some out\u00adput sequencer in \na .xed set of sequencers. If so, then ProgFromEx builds a .lter program by pairing the matching sequencer \nwith the corresponding mapping condition. Example 8. For ProgFromEx to infer a .lter program that com\u00adputes \nthe candidate map mF from Ex. 6, it must infer an output sequencer that describes the output coordinates \nmapped to by mF. To infer a sequencer, ProgFromEx orders the output coordinates mapped to by mF by the \nrow-major order of the input cells that map to them under mF. The output coordinates ordered in this \nway form column 3 of the example output table. ProgFromEx thus builds a .lter program that computes mF \nfrom a sequencer that maps to coordinates in column 3, as opposed to a sequencer that maps to coordinates \nin column 1 or 2. In step 1), ProgFromEx generates a set of candidate maps, and infers .lter programs \nthat implement the candidate maps; the in\u00adferred .lter programs serve as an initial set of component \nprograms for step 2) In step 2), ProgFromEx iteratively builds associative programs from the component \nprograms that it has already built. As described in \u00a72.1, an associative program is built from a compo\u00ad \nnent program and two relative functions. ProgFromEx thus builds associative programs by combining component \nprograms that it has already built with relative functions drawn from a .xed set. If the resulting associative \nprogram computes a map that is consistent for the example tables, then ProgFromEx retains the associative \npro\u00adgram as a component program from which to build more associa\u00adtive programs. Example 9. ProgFromEx \nbuilds the associative programs A1 and A2 described in Ex. 5 from the .lter program F described in Ex. \n2. ProgFromEx .nds A1 by combining .lter program F and relative functions RELCOL1 to build the associative \nprogram A1 =(F, RELCOL1, RELCOL1). A1 is consistent with the example input and output table, so ProgFromEx \nretains it as a component program. Similarly, ProgFromEx .nds A2 from Ex. 5 by combin\u00ad ing F and the \nrelative functions RELROW1 and RELCOL1 to build the associative program A2 =(F, RELROW1, RELCOL1). A2 \nis also consistent with the example tables, so ProgFromEx retains it as a component program. ProgFromEx \nmay also build other associative programs, such as (F, RELCOL1, RELCOL2) and (F, RELROW1, RELCOL1). However, \n TableProg :=TABPROG(CompProg1,..., CompProgn) CompProg :=FilterProg | AssocProg FilterProg :=FILTER(MapCond, \nSEQi,j,k) MapCond :=AND(MapPred1, MapPred2,..., MapPredn) MapPred :=ROWEQ(TERM1, TERM2) | COLEQ(TERM1, \nTERM2) | DATAEQ(TERM1, TERM2) | NOT(MapPred) AssocProg :=ASSOC(CompProg, RelFunc1, RelFunc2) RelFunc \n:=RELCOLi | RELROWi Figure 2. The syntax of TableProg. ProgFromEx determines that these associative programs \nare not consistent with the example input and output, and thus does not retain them as component programs. \nIn steps 1) and 2) described above, ProgFromEx infers com\u00adponent programs that map from coordinates of \nan example input to coordinates of an example output. ProgFromEx must determine when it has inferred \nenough component programs to produce a ta\u00adble program that satis.es the example. A table program is a \nset of component programs that map to coordinates of cells to be pro\u00adduced in the output table. A set \nof component programs forms a ta\u00adble program that satis.es an example if every component program in the \nset is consistent with the example, and for every coordinate in the example output table, some component \nprogram in the set maps to the coordinate. Example 10. ProgFromEx .nds a set of component programs that \nmap to all coordinates in the output table after executing step 1) and one iteration of step 2). In step \n1), ProgFromEx .nds the .lter program F described in Ex. 2, which maps to column 3 of the example output \ntable. In one iteration of step 2), ProgFromEx .nds the associative program A1 =(F, RELCOL1, RELCOL1), \nwhich maps to column 1 of the example output, and the associative pro\u00adgram A2 =(F, RELROW1, RELCOL2), \nwhich maps to column 2 of the example output. ProgFromEx combines F, A1, and A2 to build a table program \nthat maps to all cells of the example output, and thus satis.es the example. 3. A Language of Table Programs \nWe now present a language of table programs, TableProg, that can express table transformations required \nby real users. We .rst present the syntax of TableProg, and then de.ne the semantics of a program in \nTableProg as a function from an input table to an output table. 3.1 Syntax of Table Programs By the \nformal syntax for TableProg given in Fig. 2, a table pro\u00ad gram (TableProg) is a set of component programs \n(CompProg). A component program is either a .lter program (FilterProg) or an associative program (AssocProg). \nA .lter program makes a sin\u00adgle pass over an input table. During the pass, the .lter selects cer\u00adtain \ncells from the input table and maps them to a substructure of the output table. This is re.ected in the \nsyntax of a FilterProg as follows. A FilterProg consists of a mapping condition over states of a .lter \nprogram (MapCond) and an output coordinate se\u00adquencer (SEQi,j,k). The MapCond selects which input coordinates \nare mapped to the output table, and the SEQi,j,k for natural num\u00adbers i, j, and k de.nes the output coordinate \nto which the selected input cell maps. A MapCond is a conjunction of cell predicates (MapPred). Each \nMapPred is an equality (or disequality) predi\u00ad j. (c2,d) | (c1,d) . TI , S [TABPROG({Ci})] =.TI . (c1,c2) \n. i{[Ci](TI )} [FILTER(G, S)] =.TI . FilterIterG,S(InitState) n ^ [AND({Li})] =.s. [Pi](s) i=1 0 \u00ab1 .((r1,c2),d1), \n((r2,c2),d2). [ROWEQ(T1, T2)] =.s. @r1 = r2 A (s(T1),s(T2)) 01 if r <i then (i, j) [SEQi,j,k] =.(r, \nc). @ else if c <j then (r, c + 1) A else (r +1,j) j . ([R1](r1,c1), [R2](r2,c2)) | [ASSOC(C, R1, R2)] \n=.TI . ((r1,c1), (r2,c2)) . [C](TI ) [RELCOLi ] =.(r, c).(r,i) [RELROWi] =.(r, c).(i, c) \u00ab if [G](s) \nthen {(s(CurIn),s(CurOut))} else \u00d8 \u00ab FilterIterG,S(s)= if IsLastCell(s(CurIn)) then \u00d8 . else FilterIterG,S(IterUpdateS(s)) \n\u00bb CurIn . NextInCoord(s), IterUpdateS(s)=s CurOut . [S](s) Figure 3. The semantics of TableProg. cate \nover cell terms. Speci.cally, a MapPred is an equality predi\u00adcate either over the row, column, or data \nin cell TERM s. A cell TERM is either a variable bound to a particular cell (such as the input cell being \nchecked by the .lter program) or a constant cell value. An associative program AssocProg is built from \na component program CompProg and two relative functions RelFunc1, RelFunc2. A relative function can be \nRELCOLi or RELROWi, where i is a .xed natural number. 3.2 Semantics of Table Programs We now present \nthe semantics of TableProg. The semantics of TableProg is de.ned formally in Fig. 3 by the semantic function \n[\u00b7] that interprets syntactic forms of TableProg as semantic val\u00adues. The domain of semantic values is \nde.ned as follows. Let a coordinate (r, c) with r, c . Nbe an ordered pair built from a row and column \nnumber, and let a cell ((r, c),d) be an ordered pair built from a coordinate (r, c) and data string d. \nA table T is a set of cells. A table program P = TABPROG( {Ci}i) is a function from a table to a table. \nEach component program Ci is interpreted as a partial map from coordinates of cells in the input table \nto coordinates of cells that will be produced in the output table. For each cell ((r, c),d) in the input \ntable with (r, c) a coordinate in the domain of some map [Ci](r, c),d) in the output table. ], P produces \na cell ([Ci Every component program is either a .lter program or an asso\u00adciative program. A .lter program \nFILTER(G, S) maps coordinates of cells in the input table to output coordinates by checking each cell \nin the input table in a .xed order, such as row-major order. In Fig. 3, this order is de.ned by a constant \nInitState that de.nes the coordinate of the .rst input cell (e.g. (0, 0) in row-major or\u00adder), a predicate \nIsLastCell that decides if a coordinate is the last in the order, and a function NextInCoord from input \ncoordinates to input coordinates that takes an input coordinate and computes the next coordinate in the \norder. As the .lter program checks input cells, it maintains a state s, which distinguishes certain key \ncells, such as the current input cell (CurIn) and the current output cell (CurOut), by binding the cells \nto corresponding variables. When the .lter program checks each cell of the input table, it updates s \nso that the variable CurIn points to the cell to be checked. The .lter program then checks if s satis.es \nthe .lter s mapping condition, G = AND({Li}i). A state s satis.es G if and only if s satis.es ev\u00adery \nliteral Li. The semantics of each literal is standard; Fig. 3 gives the semantics of the predicate ROWEQ(TERM1, \nTERM2) as an exam\u00adple. Whether or not s satis.es a predicate is decided by the values in s of cell terms, \nsuch as the variables CurIn and CurOut. If s satis.es the mapping condition G, then the .lter program \nmaps the current input coordinate, which is bound to CurIn, to the current output coordinate, which is \nbound to CurOut. If the .lter program maps the current input coordinate, it up\u00addates the coordinate \nof the current output cell according to the .l\u00adter program s output sequencer S. Whenever an output sequencer \nS = SEQi,j,k is applied, it updates the current output coordinate to be the next coordinate in the output \ntable by row major order that is at or below row i and between columns j and k. Because j and k are .xed, \nsuch a sequencer can be applied by a .lter pro\u00adgram to produce columns with an unbounded number of rows, \nbut it cannot be applied to produce an unbounded number of columns. In this paper, we assume that an \nexample output table has the same, .xed number of columns as all tables that the user expects the ta\u00adble \nprogram to produce. However, we can extend TableProg to infer programs that produce an unbounded number \nof columns by extending the set of output sequencers. Like a .lter program, an associative program A \n= ASSOC(C, R1, R2) maps coordinates in the input table to coordinates of cells to be produced in the \noutput table. A maps coordinates by .rst computing the map mC of its component program C. From mC, A \ncomputes its own map by applying the relative function R1 to each input coordinate in mC, and by applying \nthe relative function R2 to each output coordinate in mC. A relative function RELCOLi takes a coordinate \nand computes the coordinate in the same row, but in column i, where i is a .xed constant. A relative \nfunction RELROWi takes a coordinate and computes the coordinate in the same column, but in row i. In \nthis way, an associative program A computes a coordinate map by altering the coordinate map of a component \nprogram C. Example 11. The table program P from Ex. 10 is represented for\u00ad mally as follows. Let CONSTCELLCOL(n) \nbe a cell at column n, let CONSTCELLROW(n) be a cell at row n, and let CONSTCELLDATA(d) be a cell with \ndata d. Let NOT(ROWEQ(CURCELL, CONSTCELLCOL(1))), 1A Input: example input table TI , example output table \nTO, Output: TableProg program InferredProg, where InferredProg(TI )= TO, or unmapped output table. /* \nStep 1): collect filter programs. */ 1 for CandMap . EnumCandMaps(TI , TO, CandRules) do 2 MapCond . \nCondFromMap(CandMap, StatePreds) ; 3 OutCoordSeq . SeqFromMap(CandMap, Seqs) ; 4 FilterProgram . FILTER(MapCond, \nOutCoordSeq) ; 5 FilterPrograms . AddDistMap(FilterPrograms, FilterProgram) ; 6 end /* Step 2): collect \nassociative programs. */ 7 Comps .\u00d8 ; 8 Worklist . FilterPrograms ; 9 while NewComps = \u00d8 do 10 CompProg \n. Choose( Worklist) ; 11 Worklist . Worklist \\{CompProg} ; 12 for Rel1, Rel2 . RelFuncs do 13 AssocPrg \n. ASSOC(CompProg, Rel1, Rel2) ; 14 if IsConsistent(AssocPrg,TI ,TO) and Map(AssocPrg) ./Maps( Comps . \nWorklist) then 15 Worklist . AddDistMap(Comps, AssocPrg) ; 16 end 17 end 18 end 19 if IsOnto(Maps(Comps)) \nthen 20 return TABPROG(Comps); 21 else 22 return UnmappedOutput(Comps) ; 23 end Figure 4. The inference \nalgorithm ProgFromEx. 4.1 An Inference Algorithm for TableProg ProgFromEx, given example input and output \ntables, infers a table program in TableProg that satis.es the example. ProgFromEx infers programs bottom-up, \nin that it iteratively collects a set of component programs that may be combined to form a table program. \nIf ProgFromEx .nds a set of component programs that form a table program that satis.es the example, then \nProgFromEx returns the table program. If ProgFromEx cannot .nd such a table program, then ProgFromEx \nprovides to the user the substructure of the output table to which no component program maps. G =AND \n0@ NOT(COLEQ(CURCELL, CONSTCELLROW(1))), ProgFromEx, given in Fig. 4, takes from the user an exam- NOT(DATAEQ(CURCELL, \nCONSTCELLDATA( ))) ple input table TI and example output table TO. ProgFromEx also is de.ned over four \n.xed sets of objects: a set CandRules F =FILTER(G, SEQ1,3,3) of candidate-map rules, a set StatePreds \nof predicates for map\u00adping conditions, a set Sequencers of output sequencers, and a set RelativeFuncs \nof relative functions. These sets are .xed, perhaps con.gured by an expert user or administrator. The \ntable program is then \u00ab TABPROG  F,ASSOC(F, RELCOL1, RELCOL1), ProgFromEx .nds a table program to satisfy \nthe example in ASSOC(F, RELROW0, RELCOL2) two steps. In step 1), ProgFromEx collects a set of .lter \nprograms that map to substructures of TO (Fig. 4, lines [4.1] [4.1]). To .nd a set of such .lter programs, \nProgFromEx applies CollectFilters (line [4.1]), which .rst collects a set of candidate maps over the \nexample tables by applying the candidate-map rules CandRules. 4. Inferring Table Programs from Examples \nWe now give an algorithm ProgFromEx that, given example input and output tables, infers a TableProg program \nthat satis.es the examples. We then claim that ProgFromEx is correct, and analyze its performance. De.nition \n1. A candidate map is a map from coordinates of cells in TI to coordinates of cells in TO. Each candidate \nmap satis.es the following conditions: 1. The candidate map maps input coordinates to output coordi\u00adnates \nwith equal data (i.e. the candidate map is consistent). For\u00admally, if the candidate map contains an entry \n((r1,c1), (r2,c2)) with ((r1,c1),d1) . TI and ((r2,c2),d2) . TO, then d1 = d2. 2. The candidate map \nmaps to coordinates described by an output sequencer. Formally, the candidate map maps to every coordi\u00adnate \nin TO at or below row i between columns j and k of the output table for some i, j, and k. 3. The candidate \nmap preserves row-major order. The sequence of pairs in the candidate map ordered by the row-major ordering \nof the input coordinates is equal to the sequence of entries ordered by the row-major ordering of the \noutput coordinates.  For each candidate map CandMap generated by CandRules, ProgFromEx attempts to infer \na .lter program that computes CandMap (lines [4.1] [4.1]). To infer such a .lter program, it must infer \na mapping condition (line [4.1]) and an output sequencer (line [4.1]). To infer a mapping condition, \nProgFromEx applies CondFromMap, which computes the states of a hypothetical .lter program as it reads, \nand potentially maps, each cell in the example input table. If in a given state, a .lter program reads \na cell that is mapped by the candidate map, then let this state be a read state of the .lter program. \nFor a set of read states RS, CondFromMap con\u00adstructs the following MapCond, which is the strongest condition \nthat is satis.ed by all read states: ! \\ AND {l | p . StatePreds,l .{p, NOT(p)},s(l)} s.RS Where s(l) \ndenotes that the literal l is satis.ed in s. CondFromMap then checks if any non-read state satis.es MapCond. \nIf so, then no conjunction of literals from StatePreds may act as a mapping con\u00addition for CandMap. If \nnot, then MapCond acts as a mapping condition for CandMap. For G, ProgFromEx can immediately infer an \noutput coordinate sequencer OutCoordSeq (line [4.1]) us\u00ad ing conditions (2) and (3) from Defn. 1. ProgFromEx \nthen pairs condition MapCond and sequencer OutCoordSeq to build a .lter program that computes CandMap \n(line [4.1]). In step 2) (lines [4.1] [4.1]), ProgFromEx uses the .lter pro\u00adgrams found in step 1) to \nbuild associative programs until it can use the set of .lter and associative programs to build a table \nprogram that satis.es TI and TO, or it determines that no such table program exists. ProgFromEx iteratively \nbuilds associative programs as fol\u00adlows. Over each iteration of the loop at line [4.1], ProgFromEx maintains \na worklist (Worklist) of component programs that it will use to build more associative programs, and \na set of component programs (Comps) from which it has already built associative pro\u00adgrams. At the beginning \nof the .rst iteration, Worklist is initialized to all of the .lter programs found in step 1) (line [4.1]), \nand Comps is initialized to be empty (line [4.1]). ProgFromEx executes an iteration of step 2) as follows. \nFirst, ProgFromEx chooses an element CompProg from its worklist (line [4.1]). ProgFromEx then builds \nassociative programs from CompProg. An associative program consists of a component pro\u00adgram and a pair \nof relative functions. Thus to build associative programs from a component program CompProg, ProgFromEx \nenumerates over all pairs of relative functions (line [4.1]). For relative functions RelFunc1 and RelFunc2, \nProgFromEx builds the corresponding associative program AssocProg (line [4.1]). ProgFromEx then decides \nif AssocProg computes a map that is consistent for TI and TO (line [4.1]). If so, and if the map computed \nby AssocProg is not computed by any component pro\u00adgram in Comps or Worklist, then ProgFromEx adds AssocProg \nto Worklist (line [4.1]). ProgFromEx iteratively builds associative programs until it determines either \nthat it has found a set of component programs that map to all cells in TO (i.e. a set that covers TO), \nor determines that it can .nd no such set of component programs (line [4.1]). To check if a set of component \nprograms covers TO, ProgFromEx checks if every coordinate c in TO is mapped to by some component program \nin the set. If ProgFromEx .nds such a set, then it builds a table program from the set and returns the \ntable program (line [4.1]). Otherwise, it returns the set of output cells to which no component program \nmaps (line [4.1]). The user can examine the output cells to understand why ProgFromEx could not infer \na program to satisfy the examples, perhaps .nding errors or noise in the example.  4.2 Correctness of \nProgFromEx We now present fundamental correctness properties of ProgFromEx. In particular, we de.ne notions \nof soundness and completeness for inferring programs in TableProg, and claim that ProgFromEx is both \nsound and complete. Theorem 1. An table program inference algorithm is sound if whenever it infers a \ntable program for an example input and output, then the program satis.es the examples. Formally, a table \ninference algorithm A is sound if for each input table TI and output table TO, if A(TI ,TO)= P , then \nP (TI )= TO. ProgFromEx is sound. Proof. See [11]. We now de.ne completeness for a table inference algorithm, \nand argue that ProgFromEx is complete. Theorem 2. A table inference algorithm A is de.ned for an exam\u00adple \ninput TI and example output TO only if when given the exam\u00adple, it infers a table program. A is complete \nfor a language of table programs if whenever some table program P in the language satis\u00ad.es TI and TO, \nthen A is de.ned on TI and TO. ProgFromEx is complete for TableProg. Proof. See [11]. ProgFromEx is complete \nfor inferring programs in TableProg. However, ProgFromEx cannot, in general, infer a table program for \nan arbitrary example input and output. Instead, TableProg and ProgFromEx can serve as a framework for \ntable program languages and inference algorithms. To obtain a more expressive language of table programs, \none can de.ne more expressive sets of candidate-map rules, predicates, output sequencers, and relative \nfunctions. We have extended TableProg in this way in our im\u00adplementation, and the resulting language \nis expressive enough to implement many transformations required by real users. 4.2.1 Correct for Examples \nvs. Correct for Expectations ProgFromEx is effective for .nding a table program that satis.es a given \nexample. However, multiple programs in TableProg may satisfy an example, yet in general, implement different \ntable trans\u00adformations. Thus a user may provide to ProgFromEx an example, ProgFromEx may provide to the \nuser a program that satis.es the example, and the user may then apply the inferred program to other tables \nonly to .nd that the program does not behave as expected. Yet there may be a different program in TableProg \nthat also satis\u00ad.es the user s examples and also behaves as the user expects when it is applied to other \ninputs. An inference algorithm can apply a variety of approaches to provide to the user the program that \nthe user requires. First, an in\u00adference algorithm can actively query the user about the program they \nrequire until the algorithm .nds a unique program that satis\u00ad.es the user s requirements. This approach \nis analogous to the one described in [13], and has several nice properties. In particular, if the approach \nproduces a program, then the program is unambigu\u00adously correct for all inputs. However, such an approach \nmay need to query the user a prohibitively large number of times. We leave as future work the problem \nof developing an inference algorithm that follows this approach, yet queries a user a small number of \ntimes. We instead developed ProgFromEx to apply a lazy approach. In a lazy approach, the inference algorithm \ntakes an example from the user, and infers some program that satis.es the example. The user applies the \ninferred program to other inputs; if on another input, the program produces an output that the user does \nnot expect, then the user provides the input and unexpected output to the inference algorithm as an example, \nand the algorithm infers a new program that satis.es both the original and new example. The user repeats \nthis process until the inference algorithm provides a program that behaves as the user expects for the \ninputs on which they apply it. Unlike an approach based on active querying, the lazy approach does not \nguarantee that if the inference algorithm infers a program, then the program is correct for all inputs. \nHowever, we have observed that in practice, users do not need to apply table programs to arbitrary input \ntables. Instead, users apply a table program to a set of tables that all satisfy a strong condition. \nRequiring users to specify a program s behavior for tables that do not satisfy this condition is unnecessary, \nand often causes users to refuse to use such a technology. We now describe two extensions of ProgFromEx \nthat allow users to apply it using a lazy approach to quickly infer the program that they require. If \na user applies ProgFromEx to a given example, obtains a program, and .nds that the program behaves incorrectly \non a different input, then the user can provide the second, different input, along with a corresponding \ncorrect output, as another example for ProgFromEx, and obtain a new program that better satis.es their \nrequirements. If the second input extends the .rst input, then the user may apply ProgFromEx solely to \nthe second input. However, even if the example inputs are incomparable, ProgFromEx can be extended to \ntake multiple examples from a user simultaneously. To take multiple examples, ProgFromEx as presented \nin Fig. 4 is extended to .nd .lter programs and associative programs that are consistent for a set of \nmultiple examples. To .nd .lter programs that are consistent for all examples, the loop at lines [4.1] \n[4.1] is changed to enumerate over the space of all tuples containing a candidate map for each example. \nFor each tuple of candidate maps, ProgFromEx attempts to infer a map condition that classi.es exactly \nthe cells mapped by each candidate map, and attempts to infer an output coordinate sequencer that describes \nthe sequence of output cells that are mapped to in each candidate map. To .nd an associative program \nthat is consistent for all examples, the check at line [4.1] is extended to determine if the associative \nprogram AssocProg is consistent with each example. Finally, the checks at lines [4.1] and [4.1] are extended \nso that ProgFromEx determines that it has found a satisfying table program only when it .nds a collection \nof component programs that map to every cell in all output example tables. ProgFromEx can also be extended \nso that it infers a program from a single example that is, in practice, more likely to behave as expected \nwhen applied to other tables. Step 2) of ProgFromEx halts when ProgFromEx .nds a set of component programs \nthat map to every cell in the example output table. However, the result\u00ading set may include multiple \ncomponent programs that are redun\u00addant, as a smaller set of programs would still map to the same cells. \nIn practice, the more component programs that form a table pro\u00adgram, the more likely the table program \nis to behave incorrectly when applied to other tables. This satis.es an informal notion of Occam s Razor: \nthe simplest table program is often the best. We have thus extended ProgFromEx so that at Fig. 4 line \n[4.1], it does not necessarily build a table program from all component pro\u00adgrams that it .nds. Instead, \nProgFromEx .rst applies a greedy algorithm to prune the set of all component programs found to a set \nthat still maps to all cells in the example output, but is locally mini\u00admal. The resulting program is \nintuitively simpler than the original program, and in practice more often behaves as expected on larger \nexamples.  4.3 Performance of ProgFromEx In principle, ProgFromEx does not scale well with the size \nof the tables given as examples. In the worst case, ProgFromEx may ex\u00adecute in time exponential in the \nsize of the example tables given. This is because the time that ProgFromEx takes to execute is pro\u00adportional \nto the number of component programs that it collects with distinct maps, and the number of distinct maps \nbetween example ta\u00adbles is exponential in the number of cells in the example tables. For a detailed analysis \nof the complexity of ProgFromEx, see [11]. If ProgFromEx performed close to its worst-case bound, then \nit would be highly impractical. Fortunately, real-world input and output examples have properties that \nallow ProgFromEx to exe\u00adcute quickly, or that allow for heuristics that greatly improve its performance. \nIn particular, the dominating factor in the high com\u00adplexity of ProgFromEx is the set of component programs \nwith distinct maps that ProgFromEx may collect. In practice, this set is quite small. This is because \nwhile many component programs may implement a large set of distinct maps according to the combina\u00adtorial \nbound, in practice only a small set of these maps are con\u00adsistent for the example tables. Thus candidate-map \nrules .nd few candidate maps that are consistent with the examples, and when ProgFromEx checks if an \nassociative program is consistent (Fig. 4 line [4.1]), the check rules out many potential associative \nprograms immediately. ProgFromEx as given in Fig. 4 can also be optimized by bias\u00ad ing the order in which \nit picks component programs to build new associative programs. In line [4.1] of Fig. 4, ProgFromEx non\u00addeterministically \nchooses a component program from its worklist, and builds new associative programs from the chosen component \nprogram. The chosen component program may mostly map to out\u00adput cells that are already mapped to by other \ncomponent programs in Comps, as may the associative programs built from the chosen component program. \nHowever, ProgFromEx can instead priori\u00adtize the elements in its worklist so that ProgFromEx .rst chooses \ncomponent programs from the worklist that map to many cells not mapped to by any component program in \nComps. This may allow ProgFromEx to more quickly .nd a set of component programs that cover the example \noutput table. 5. Experiments We implemented an interpreter for TableProg, implemented ProgFromEx, and \nexperimented with the implementations to de\u00adtermine if TableProg and ProgFromEx are useful in practice. \nThe experiments were designed to determine the following: 1. Is TableProg expressive enough to describe \ntable transforma\u00adtions that real end-users require? 2. When a program in TableProg implements the table \ntransfor\u00admation that a user requires, could ProgFromEx .nd the pro\u00adgram quickly? 3. If ProgFromEx .nds \na program that satis.es a user s initial examples, and the program is applied to other similar inputs, \ndoes the program produce the expected outputs? If not, how many additional examples does a user need \nto provide before ProgFromEx infers a program that behaves as expected?  We performed the experiments \nas follows. We searched two on\u00adline help forums2 for the Excel spreadsheet program to .nd table 2 http://www.excelforum.com \nand http://www.ozgrid.com/ forum/  Figure 5. Time for ProgFromEx to infer table transformation programs. \ntransformations that real users needed to perform, but could not accomplish using the built-in GUI features \nof Excel. Among the transformations, we picked 51 for which the user provided an ex\u00adample input and output. \nWe gave the input and output examples to ProgFromEx, which inferred a table program for each exam\u00adple. \nWe used the provided examples and the English description of the transformation to manually create a \nlarger input example, applied the inferred program to the larger input, and checked that the program \nproduced the output that we expected. If the program did not produce the expected output, then from the \nunexpected out\u00adput, we manually derived a more descriptive example, and applied ProgFromEx to the more \ndescriptive example. We repeated this process until ProgFromEx found a program that behaved as ex\u00adpected \nfor successively larger, different inputs. The experiments indicate that TableProg describes practi\u00adcal \nprograms, and that ProgFromEx .nds practical programs in TableProg ef.ciently. The times spent by ProgFromEx \nto infer programs for the 51 tests are presented in Fig. 5. For each of the 51 tests, ProgFromEx found \nin less than 10 seconds a program in TableProg that satis.ed the example. For a majority (31) of the \ntests, ProgFromEx found a program in less than a second. For a vast majority (48) of the tests, ProgFromEx \nfound a program in less than 5 seconds. If for a given test, ProgFromEx inferred a program that did not \nbehave as we expected when applied to other inputs, we manually found an input on which ProgFromEx misbehaved \nand reapplied ProgFromEx to the new input. We repeated this process until ProgFromEx inferred a program \nthat behaved as expected. The numbers of times that we needed to re.ne examples for the tests are presented \nin Fig. 6. Observe that for a vast majority (42) of the tests, ProgFromEx inferred the expected program \nfrom one example. For the four of the tests, ProgFromEx required two examples, and for .ve of the tests, \nit required three examples. The large number of different help-thread requests that were satis.ed by \nprograms in TableProg indicates that TableProg is expressive enough to describe transformations required \nby real end\u00adusers. Moreover, the transformations requested on the help threads are diverse. To illustrate \ntheir diversity, we discuss a selection of examples that are satis.ed by programs in TableProg. The examples \nare slightly simpli.ed from their original forms to ease presentation. For a complete list of help threads \ncontaining the original examples on which we experimented, see [6]. For detailed descriptions of the \ntests, see [11]. Figure 6. Number of examples required by ProgFromEx to infer programs. Example input \ntable: 55660 x1 $530.00 55660 x3 11/5/2007 $10.00 5 $2,130.00 90210 y1 $25.00 90210 y2 $25.00 90210 y3 \n11/18/2007 $25.00 13 $325.00 Example output table: 55660 11/5/2007 $10.00 $2,130.00 90210 11/18/2007 \n$25.00 $325.00  Figure 7. Example reproduced from an Excel help thread Copy Rows Where Column Cell Is \nNot Blank Filtering Key Information In many help requests, users need to transform a table to retain \na subset of the table s original informa\u00adtion. This subset is de.ned by key cells in the table, along \nwith cells that are spatially related to the key cell. In a help thread titled Copy Rows Where Column \nCell Is Not Blank, a novice user speci.ed a table transformation using an example reproduced in Fig. \n7. The user wanted to transform their input table into a new table that only contains the cells in columns \n1, 3, 4, and 6 of each summary row of the input table. According to the user s English description, a \nsum\u00admary row is any row in which column 6 is not empty. An expert user replied that a GUI feature partially \nautomates this transforma\u00adtion, but the novice replied that they would like to fully automate the transformation. \nThe expert replied with an Excel macro, which presumably satis.ed the novice. When we applied ProgFromEx \nto the example given by the novice, ProgFromEx automatically found a TableProg program that satis.es \nthe example in 0.5 sec\u00adonds. However, when we reapplied the program to other input ta\u00adbles, we found \nthat it placed cells from a row of the input table in the output table if and only if column 5 was empty. \nTo resolve this, we extended the input to have a row in which the column 5 was empty but column 6 was \nnon-empty, and extended the output to contain cells from the row. Using this example, ProgFromEx inferred \na program, again in 0.5 seconds, that behaved as expected when reapplied to other tables. The program \nconsists of a .lter pro\u00adgram which maps the non-empty cells in column 6 of the input to column 4 of the \noutput. For each of the other three columns in the output, an associative program built from the .lter \nprogram maps the column. Splitting and Partially Replicating Rows In many help requests, users need to \nsplit cells in a row into different rows, while replicat\u00ad Example output table: Example input table: \nName Colour Price Toyota White 2000 Nissan Red 4000 Toyota White Toyota 2000 Nissan Red Nissan 4000 \n Figure 8. Example reproduced from Excel help thread arranging data using VBA. Example input table: 3099 \n905 A4CA NO.14 NO.14 Full Copies 6.78 2 * * 0 3200 906 AHG 9-Jun 9-Jun Covers Only 4.74 1 * * 0 Example \noutput table: 3099 905 A4CA NO.14 Full Copies 6.78 2 3200 906 AHG 9-Jun Covers Only 4.74 1 Figure 9. \nExample reproduced from an Excel help thread arrange data. ing other cells in the original row. In a \nhelp forum post titled Ar\u00adranging Data Using VBA, a novice user requested a table trans\u00adformation by \nproviding only the example reproduced in Fig. 8. The user added that though they had provided a small \nexample, they needed to apply a transformation to a table that had thou\u00adsands of rows. After more than \nfour hours, an expert user provided an Excel macro that presumably satis.ed the novice s request. We \napplied ProgFromEx to the example from the help forum, and ProgFromEx automatically found in 2.3 seconds \na table program that satis.es the example. When we reapplied the program to larger, similar examples, \nit behaved as expected. The table program con\u00adsists of a .lter program that maps cells in columns 2 and \n3 of the input to column 2 of the output, and a single associative program built from the .lter program \nthat maps to column 1 of the output. Combining and Filtering Rows In many requests, users need to remove \nsome cells from rows while combining adjacent rows. In a help thread titled arrange data, a novice user \nrequested a table transformation by providing only the example reproduced in Fig. 9. The transformation \nconcatenates adjacent pairs of rows, .ltering out the cell in column 1 in the second row of each pair. \nIn twenty minutes, an expert user provided to the novice a macro that satis.ed the example, and the novice \nreported that they were satis.ed, although they did not understand the mechanics of the macro. When we \napplied ProgFromEx to the example in Fig. 9, it automatically found in 1.2 seconds a TableProg program \nthat implements the transformation requested by the user. When we reapplied the same program to larger, \nsimilar examples, it behaved as expected. The program is built from two .lter programs that map onto \ncolumns 6 and 7 of the output table, two associative programs built from the .lter programs that map \nonto columns 3 and 4 of the output table, a third associative program, built from the associative program \nthat maps onto column 4, that maps onto column 2, and .nally a fourth associative program built from \nthe third associative program, that maps onto column 1. This example demonstrates the bene.t to the iterative \napproach applied by ProgFromEx to .nd associative programs. Rearranging Groups In many requests, a user \nhas data organized in nested groups, and needs to preserve the grouping of the data while rearranging \nthe layout of the groups. In a help thread titled Transposing 3 columns into multiple columns, a novice \nuser requested a transformation by providing the example reproduced in Fig. 10. In the novice s input \ntable, grades are arranged vertically, grouped by student and then by subject. In the novice s output \ntable, Example input table: Alice Art&#38;Des B CreatArt A D&#38;T A English A Geo. A* Bob Art&#38;Des \nC CreatArt B D&#38;T C English C Geo. C Example output table: Art&#38;Des CreatArt D&#38;T English Geo. \nAlice B A A A A* Bob C B C C C  Figure 10. Example reproduced from an Excel help thread Trans\u00adposing \n3 columns into multiple columns. Example input table: PROJ CAT SPONSOR DEPT ELTS DUE SPEC OOH In.niti \nDesign elt 1 11/10 SPEC OOH In.niti Desing elt 2 SPEC Print Design elt 3 11/30 SPEC Print Design elt \n4 11/30 SPEC Print In.niti Design elt 5 11/30 Example output table: SPEC OOH In.niti Design elt 1 11/10 \nIn.niti Desing elt 2 Print Design elt 3 11/30 Design elt 4 11/30 In.niti Design elt 5 11/30 Figure 11. \nExample reproduced from Excel help thread printed sheet in different format than worksheet.  grades \nare arranged horizontally, grouped in a row per student, and a column per subject. After the novice posted \ntheir request, one expert user replied with a macro about 40 minutes later, and another expert replied \nwith a macro nearly six hours after the request was posted. When we applied ProgFromEx to the example \nin Fig. 10, it automatically found a TableProg program in 1.4 seconds that implements the requested transformation. \nWhen we reapplied the same program to larger, similar tables, the program behaved as expected. The table \nprogram includes a single .lter program that maps to all cells at or below row 2 between columns 2 and \n5. One associative program built from this .lter program maps onto all cells in column 1 of the output \ntable. A second associative program built from the .lter program maps onto all cells in row 1 of the \noutput table. In a help thread titled printed sheet in different format than worksheet, a novice user \nprovided the example reproduced in Fig. 11. In the novice s input table, each row of the table is a com\u00ad \nplete entry for an element of a project. The novice needed to group the elements so that the project \nand category (columns 1 and 2, respectively) of the element appear as headings and subheadings, followed \nby the elements that are under the heading and subhead\u00ading. Although the novice suspected that elements \ncould be grouped semi-automatically using built-in features of Excel, they did not know how to do so. \nNo expert user helped the novice with their request. When we applied ProgFromEx to the example in Fig. \n11, it automatically found a TableProg program in 4.4 seconds that im\u00adplements the required transformation. \nIn the TableProg program, a .lter program maps to column 3 of the output. A set of three as\u00adsociative \nprograms built from the .lter program map to columns 1, 2, and 4, with one associative program mapping \nto each column. We implemented the interpreter for TableProg and the infer\u00adence algorithm ProgFromEx \nas an Excel plug-in module. To use the module, a user selects in the Excel GUI a range of cells to act \nas the example input, selects a range of cells to act as the example output, selects a range of cells \nto act as a full input, selects a lo\u00adcation in the spreadsheet where they would like to place the output \ncorresponding to the full input, and pushes a button. The module then automatically infers a program \nthat satis.es the examples, ap\u00adplies the program to the full input, and places the resulting output at \nthe location speci.ed by the user. We plan to extend the inter\u00adface so that a user may supply only examples, \nand the module will provide a program that the user can add to a library. The user could then reapply \nprograms in the library whenever they wish. 6. Related Work The area of program synthesis is gaining \nrenewed interest [8], and this paper is a work in this direction. Program synthesis has tra\u00additionally \nbeen motivated by the need to synthesize non-trivial al\u00adgorithms [12, 22, 23] or to discover tricky code-snippets \n[10, 24]. In this paper, we apply program synthesis to discovering relatively simpler programs, but those \nthat are cared about by a much larger class of spreadsheet end-users, who often struggle with manipulat\u00ading \ntabular data in spreadsheets. There has been some work in the programming languages and the HCI community \nrelated to inferring table transformations. PADS [7] takes a large sample of unstructured data and infers \na format that describes the data. Users then manually de.ne tools for data in the format. Lenses [2] \nare a language of combinators that can be applied to solve the view update problem, which is related \nto but distinct from the problem of inferring a transformation over tables from examples. The Wrangler \ntool, developed in the HCI community, provides a nice visual programming-by-demonstration interface to \ntable transformations for data cleaning [14]. In con\u00ad trast, we provide an interface based on examples, \nwhich is more friendly to end users. Program sketching [21] may be applied to synthesize programs from \nexamples. In program sketching, a programmer supplies to a sketcher an incomplete version of a program \n(a sketch) and a speci.cation of correct behavior for the program, possibly as a set of input-output \nexamples. The sketcher then completes the program so that the program satis.es the speci.cation. We attempted \nto apply the SKETCH [20] program sketcher to a sketch of a table program and example tables. However, \nbecause SKETCH is a tool for synthesizing general programs, it could not take full advantage of the particular \nstructure of table programs. As a result, when we applied it to infer programs in TableProg, it typically \ntimed out after an hour. The problem of inferring transformations over tables is related to inferring \nqueries over relations from instances of the relations. These techniques cannot be directly applied to \ninfer transforma\u00adtions over tables, as users treat tables differently from relations; e.g., tables have \na notion of order over rows that does not hold by default for relations. In particular, in the view synthesis \nproblem [4], one takes a database relation and a view over the database and infers the general query \nthat produces the view. The technique pre\u00adsented in [4] only considers views that are a subset of the \noriginal database. Thus the technique cannot be applied to any of the ex\u00adamples given in this paper, \nor many of the other real-world cases that we studied. The problem of query by output [25] is similar \nto the view synthesis problem, but the technique presented in [25] in\u00ad fers select-project-join queries. \nOf the examples presented in this paper, such queries can only be applied to satisfy the example in Fig. \n7, and such queries cannot be applied to many of the other real\u00ad world cases that we studied. We leave \nas future work the problem of applying our techniques to learn richer queries from instances of databases \nand views. The work in [9, 15, 16, 18, 26] gives techniques that take tex\u00ad tual input-output examples \nand infer programs that transform text. However, these techniques only infer transformations over plain \ntext, or strings. Thus they cannot be directly applied to infer trans\u00adformations over tables. While the \ntechniques can, in principle, be applied by representing tables in plain text, it is then dif.cult to \nreason about the spatial relationships between cells in the original table. TableProg represents spatial \nrelationships directly, and the relationships are critical to TableProg s ability to express practi\u00adcal \ntable transformations. Furthermore, the techniques for textual transformations assume that it is easy \nto .nd a set of programs that satisfy an individual example of a transformation, and focus on combining \nsets of programs that satisfy different examples. How\u00adever, when searching for programs that transform \ntables, it is non\u00adtrivial in general to .nd a set of programs that satisfy even a single example of a \ntransformation. 7. Conclusion End users often need to transform semi-structured, tabular data in non-trivial \nways. We have presented a language TableProg of programs that implement table transformations that real \nusers require, and an algorithm ProgFromEx that from an example input and output, infers a TableProg \nprogram that implements the transformation speci.ed by the example. To demonstrate that TableProg and \nProgFromEx are practical, we applied them to infer programs for over 50 table transformations speci.ed \nas input\u00adoutput examples by real end users. References [1] R. Abraham and M. Erwig. Header and unit \ninference for spreadsheets through spatial analyses. In Proceedings of the 2004 IEEE Symposium on Visual \nLanguages -Human Centric Computing (VLHCC), pages 165 172, 2004. [2] D. M. Barbosa, J. Cretin, N. Foster, \nM. Greenberg, and B. C. Pierce. Matching lenses: alignment and view update. In ICFP 10, 2010. [3] A. \nCypher, editor. Watch What I Do Programming by Demonstra\u00adtion. MIT Press, Cambridge, MA, USA, 1993. \nFull text available at web.media.mit.edu/ lieber/PBE/. [4] A. Das Sarma, A. Parameswaran, H. Garcia-Molina, \nand J. Widom. Synthesizing view de.nitions from data. In ICDT 10, 2010. [5] Excel. Microsoft Excel, 2010. \nURL http://office.microsoft.com/en-us/excel.  [6] Excel Help Forums. Excel help forum threads, 2010. \nURL http://cs.wisc.edu/~wrharris/pldi2011/tests.html.  [7] K. Fisher, D. Walker, K. Q. Zhu, and P. White. \nFrom dirt to shovels: fully automatic tool generation from ad hoc data. In POPL 08, 2008. [8] S. Gulwani. \nDimensions in program synthesis (invited talk paper). In ACM Symposium on PPDP, 2010. [9] S. Gulwani. \nAutomating string processing in spreadsheets using input\u00adoutput examples. In POPL, pages 317 330, 2011. \n[10] S. Gulwani, S. K. Jha, A. Tiwari, and R. Venkatesan. Synthesis of loop-free programs. In PLDI, 2011. \n[11] W. R. Harris and S. Gulwani. Table Transformations from Examples. Technical Report MSR-TR-2011-34, \nMicrosoft Research, Redmond, March 2011. [12] S. Itzhaky, S. Gulwani, N. Immerman, and M. Sagiv. A simple \ninductive synthesis methodology and its applications. In OOPSLA, pages 36 46, 2010. [13] S. Jha, S. Gulwani, \nS. A. Seshia, and A. Tiwari. Oracle-guided component-based program synthesis. In ICSE 10, 2010. [14] \nS. Kandel, A. Paepcke, J. Hellerstein, and J. Heer. Wrangler: Interac\u00adtive visual speci.cation of data \ntransformation scripts. In ACM Human Factors in Computing Systems (CHI), 2011. [15] T. Lau, S. A. Wolfman, \nP. Domingos, and D. S. Weld. Programming by demonstration using version space algebra. Mach. Learn., \n53(1-2): 111 156, 2003. ISSN 0885-6125. [16] T. A. Lau, P. Domingos, and D. S. Weld. Version space algebra \nand its application to programming by demonstration. In ICML 00, 2000. [17] H. Lieberman, editor. Your \nwish is my command: programming by example. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, \n2001. ISBN 1-55860-688-2. [18] R. Nix. Editing by example. In POPL 84, 1984. [19] OpenOf.ce. Openof.ce.org, \n2010. URL http://www.openoffice.org/. [20] SKETCH. Sketch, 2010. URL https://bitbucket.org/gatoatigrado/sketch-frontend/ \nwiki/Home. [21] A. Solar-Lezama, G. Arnold, L. Tancau, R. Bodik, V. Saraswat, and S. Seshia. Sketching \nstencils. In PLDI 07, 2007. [22] S. Srivastava, S. Gulwani, and J. S. Foster. From program veri.cation \nto program synthesis. In POPL, pages 313 326, 2010. [23] S. Srivastava, S. Gulwani, S. Chaudhuri, and \nJ. Foster. Path-based inductive synthesis for program inversion. In PLDI, 2011. [24] A. Taly, S. Gulwani, \nand A. Tiwari. Synthesizing switching logic using constraint solving. In VMCAI, pages 305 319, 2009. \n[25] Q. T. Tran, C.-Y. Chan, and S. Parthasarathy. Query by output. In SIGMOD 09, 2009. [26] I. H. Witten \nand D. Mo. TELS: learning text editing tasks from examples, pages 183 203. MIT Press, 1993.   \n\t\t\t", "proc_id": "1993498", "abstract": "<p>Every day, millions of computer end-users need to perform tasks over large, tabular data, yet lack the programming knowledge to do such tasks automatically. In this work, we present an automatic technique that takes from a user an example of how the user needs to transform a table of data, and provides to the user a program that implements the transformation described by the example. In particular, we present a language of programs TableProg that can describe transformations that real users require.We then present an algorithm ProgFromEx that takes an example input and output table, and infers a program in TableProg that implements the transformation described by the example. When the program is applied to the example input, it reproduces the example output. When the program is applied to another, potentially larger, table with a 'similar' layout as the example input table, then the program produces a corresponding table with a layout that is similar to the example output table. A user can apply ProgFromEx interactively, providing multiple small examples to obtain a program that implements the transformation that the user desires. Moreover, ProgFromEx can help identify 'noisy' examples that contain errors.</p> <p>To evaluate the practicality of TableProg and ProgFromEx, we implemented ProgFromEx as a module for the Microsoft Excel spreadsheet program. We applied the module to automatically implement over 50 table transformations specified by endusers through examples on online Excel help forums. In seconds, ProgFromEx found programs that satisfied the examples and could be applied to larger input tables. This experience demonstrates that TableProg and ProgFromEx can significantly automate the tasks over tabular data that users need to perform.</p>", "authors": [{"name": "William R. Harris", "author_profile_id": "81100116515", "affiliation": "University of Wisconsin, Madison, Madison, WI, USA", "person_id": "P2690571", "email_address": "wrharris@cs.wisc.edu", "orcid_id": ""}, {"name": "Sumit Gulwani", "author_profile_id": "81100315615", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P2690572", "email_address": "sumitg@microsoft.com", "orcid_id": ""}], "doi_number": "10.1145/1993498.1993536", "year": "2011", "article_id": "1993536", "conference": "PLDI", "title": "Spreadsheet table transformations from examples", "url": "http://dl.acm.org/citation.cfm?id=1993536"}