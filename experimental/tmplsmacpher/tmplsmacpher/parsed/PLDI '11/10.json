{"article_publication_date": "06-04-2011", "fulltext": "\n Steno: Automatic Optimization of Declarative Queries Derek G. Murray Michael Isard Yuan Yu University \nof Cambridge Computer Laboratory Microsoft Research Silicon Valley Derek.Murray@cl.cam.ac.uk {misard, \nyuanbyu}@microsoft.com Abstract Declarative queries enable programmers to write data manipulation code \nwithout being aware of the underlying data structure imple\u00admentation. By increasing the level of abstraction \nover imperative code, they improve program readability and, crucially, create op\u00adportunities for automatic \nparallelization and optimization. For ex\u00adample, the Language Integrated Query (LINQ) extensions to C# \nallow the same declarative query to process in-memory collections, and datasets that are distributed \nacross a compute cluster. However, our experiments show that the serial performance of declarative code \nis several times slower than the equivalent hand-optimized code, because it is implemented using run-time \nabstractions such as iterators that incur overhead due to virtual function calls and super.uous instructions. \nTo address this problem, we have developed Steno, which uses a combination of novel and well-known techniques \nto generate code for declarative queries that is almost as ef.cient as hand\u00adoptimized code. Steno translates \na declarative LINQ query into type-specialized, inlined and loop-based imperative code. It elimi\u00adnates \nchains of iterators from query execution, and optimizes nested queries. We have implemented Steno for \nuniprocessor, multipro\u00adcessor and distributed computing platforms, and show that, for a real-world distributed \njob, it can almost double the speed of end\u00adto-end execution. Categories and Subject Descriptors D.3.4 \n[Programming Lan\u00adguages]: Processors Code generation, Optimization General Terms Design, Performance \nKeywords query optimization, abstract machines 1. Introduction The declarative style of programming has \nlong been proposed as a superior alternative to imperative programming. Recently, declara\u00adtive programming \nhas found an important application in data-center programming: systems such as MapReduce [10], DryadLINQ \n[32] and FlumeJava [7] allow users to compose a declarative speci.\u00adcation of an application s logic, \nand execute it across hundreds or thousands of machines. However, these systems are implemented in common \nimperative languages (C++, C# and Java), and simulat\u00ading the declarative style results in code that is \nless ef.cient than the equivalent imperative code. In this paper, we focus on one of these Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. PLDI 11, June 4 \n8, San Jose, California, USA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0663-8/11/06. . . $10.00 Execution \ntime 13.5% 13.6% LINQ .Sum() for loop Steno .Sum() Figure 1. Relative execution time for computing the \nsum of squares of 107 doubles using LINQ, an imperative loop, and a Steno-optimized query. Steno achieves \na 7.4\u00d7 speedup over LINQ. systems DryadLINQ and describe a technique for code gener\u00adation that signi.cantly \nimproves the end-to-end execution time of distributed jobs. DryadLINQ is a system that takes a query \nwritten in .NET Lan\u00adguage Integrated Query (LINQ) syntax, and generates a distributed query plan for \nexecuting the query across compute nodes in a data center [32]. The main advantage of DryadLINQ is that \nqueries can include user-de.ned types and functions, which allows the devel\u00adoper to use the full .NET \ntype system and class library. DryadLINQ divides the query into vertices in a Dryad [19] task dependency \ngraph: each vertex executes a portion of the query on a partition of the overall data. The generated \ncode itself uses LINQ queries to achieve multiprocessor parallelism within a single machine. How\u00adever, \nour experiments have shown that LINQ queries are far slower than the equivalent imperative code (Figure \n1), for four reasons: 1. LINQ queries are lazily evaluated, and use iterators to com\u00admunicate elements \nbetween stages of the query [2]. An iterator imposes the overhead of two virtual function calls per element \nper query operator. 2. LINQ queries may be nested, which involves each element .owing through multiple \niterators. The iterator overhead is therefore multiplied by the number of nesting levels. 3. The lazy \niterator implementation includes state machine logic to simulate coroutine behavior [22], which adds \nfurther per\u00adelement overhead. 4. An operator s behavior such as a predicate or transformation function \nis speci.ed as a function object, which incurs a fur\u00adther virtual call per element per operator.  To \naddress these overheads, we have implemented Steno: an optimizer for LINQ queries that generates the \nequivalent loop\u00adbased imperative code. Steno performs two optimizations: iterator fusion (Section 4), \nand nested loop generation (Section 5). Similar optimizers have been developed for functional languages \n[9, 31] and relational database query languages [15, 23]. However, Steno makes several contributions \nbeyond existing work:  Select iterator Where iterator Source MoveNext() MoveNext() MoveNext() Current \nCurrent Current Figure 2. Call graph in a chain of query operators. Virtual function calls are represented \nby bold arrows. Steno integrates with an existing object-oriented language (C#), and does not require \nchanges to the compiler or standard li\u00adbraries (Section 3).  Steno uses a novel automaton-based code \ngenerator to trans\u00adform a sequence of query operators into loop-based code (Sec\u00adtions 4 and 5).  Steno \nmay be combined with DryadLINQ to generate code that runs in parallel across a data center, and across \nmultiple processors on each machine (Section 6).  We evaluate the performance of Steno-optimized queries \nrun\u00adning on a single machine and on a distributed compute cluster (Section 7).  Steno generates loop-based \ncode, which is simple for a compiler to optimize and would be simple for a moderately-experienced programmer \nto write. The principal advantage of writing queries in a declarative style is that it is also possible \nto apply higher-level optimizations. In particular, DryadLINQ [32, 33], FlumeJava [7] and Pig [26] optimize \nmany operations, including aggregation, joins and sorting, by applying high-level transformations on \nthe query operator graph. The guiding principle in this work is that code should be written at the highest \npossible level, so that it can bene.t from multiple levels of optimization. Steno provides further incentive \nto write at a high level, because the resulting code is almost as ef.cient as low-level imperative code. \nOur evaluation shows that, even in a distributed setting, our optimizations can signi.cantly improve \nend-to-end execution times (Section 7). Though this paper focuses on query optimization for LINQ and \nDryadLINQ, the techniques can be applied to any system that uses iterators to process streaming data \nor simulate lazy evaluation. However, to motivate our speci.c implementation, we begin with a brief description \nof how LINQ is currently implemented. 2. From queries to iterators In this paper, we focus on the LINQ \nextensions that were added to .NET 3.5. LINQ extends C# with SQL-like query comprehension syntax, .rst-class \nlambda expressions, and a set of generic query operators that can be applied to any object implementing \nthe enu\u00admerable interface (IEnumerable<T>) [2]. The following is an example of a simple LINQ query: IEnumerable<int> \nxs = ...; var evenSquares = from x in xs wherex%2 ==0 select x * x; The compiler desugars that query \ninto the following C# expression: IEnumerable<int> evenSquares = xs.Where(x => x % 2 == 0) .Select(x \n=> x * x); The where and select clauses in the query comprehension are transformed into calls to the \nWhere() and Select() methods, which in this case operate on and return an IEnumerable<int>. LINQ de.nes \nmany other query operators, as we will describe in Sections 4 and 5. Enumerable objects expose a single \nmethod, GetEnumerator(), which returns an object of type IEnumerator<T>, with the following (simpli.ed) \ninterface: interface IEnumerator<T> { // Return the element at the current position. T Current { get; \n} // Advance to next element, returning false if no // more elements remain. bool MoveNext(); // [Reset() \nand Dispose() methods not shown.] } In this interface, Current is a read-only property, which is syntactic \nsugar that allows accessor methods to be written in the same form as instance .eld accesses. An enumerable \nobject can be traversed using the foreach(var x in xs) statement. Again, this statement is syntactic \nsugar for operations on an IEnumerable<T> object (xs), and it translates to: IEnumerator<T> enum = xs.GetEnumerator(); \nwhile (enum.MoveNext()) { T x = enum.Current; // foreach loop body... } enum.Dispose(); Note that since \nMoveNext() and Current are de.ned in an inter\u00adface, they are virtual functions, so each iteration of \nthe while loop involves at least two virtual calls. LINQ uses iterators to implement lazy query evaluation. \nAn iterator (IEnumerator<T>) object is typically implemented as a state machine that advances through \nthe collection upon calls to MoveNext(), which update the Current property. Composable LINQ operators \n(such as Select(), Where() and GroupBy()) are implemented as iterators that consume elements from an \nupstream iterator, and yield (possibly-transformed) elements to downstream operators (Figure 2). Aggregate \noperators which return a scalar (such as Sum(), Min() and Average()) are eagerly evaluated and contain \na foreach loop that consumes the upstream iterator. Due to the use of iterators, each LINQ operator makes \nat least two virtual calls for each element that it processes1. A further virtual call per element is \nincurred when evaluating the predicate or transformation function. As Krikellas et al. explain, virtual \ncalls impose a severe overhead on query execution because they are dif.cult to inline automatically [23]. \nAs a result, each call causes an indirect branch, which inhibits instruction pipelining. Furthermore, \niterators contain state machine logic in the MoveNext() function, which adds more instructions to the \nper-element overhead. Writing the equivalent hand-optimized C# code for this query would be straightforward \nfor most programmers: foreach (int x in xs) { if (x %2== 0) { yield return x * x; } } The iterators for \nthe Where and Select operators are fused, by storing the current element in the loop variable, x, and \nthe predicate and transformation expressions are inlined. Steno automatically performs these optimizations \non chains of query operators. 1 An alternative approach, as used in Java, combines the MoveNext() and \nCurrent operations into a single virtual call. However, this precludes the use of non-reference types \nor null elements in collections, because the combined method returns null to indicate that there are \nno more elements.  fromx in xs where x % 2 == 0 select x * x  Figure 3. Translation from LINQ query \nsyntax into AST form. 3. Outline of approach At a high level, Steno converts queries into ef.cient, loop-based \nimperative code. Our main contribution is a novel technique for generating the imperative code. In this \nsection, however, we .rst put this technique in context, by describing the main steps that comprise Steno \noptimization: 1. The query is transformed into an intermediate representation (QUIL) (\u00a73.1). 2. The \nquery AST is transformed into an equivalent C# AST (\u00a73.2; see also \u00a74 and \u00a75). 3. The C# AST is compiled, \nloaded and invoked (\u00a73.3).  Note that our implementation of Steno is a .NET library: it does not modify \nthe compiler or the .NET core library. To apply Steno to a query, the WithSteno() extension method is \napplied to the source collection, as follows: var evenSquares = from x in xs.WithSteno() wherex%2 ==0 \nselect x * x; Since the C# compiler already performs source-to-source transfor\u00admations on LINQ queries \n[2], Steno s optimizations could also be applied at compile-time. We speculate about how this approach \ncould be taken further in Section 9. 3.1 Query extraction The optimization process begins with a query \nexpression, which can be written in query comprehension syntax or as a sequence of LINQ method invocations. \nTo gain a usable representation of the query, we use the LINQ query provider facility, which recon\u00adstructs \nthe query AST at run-time. A similar technique is used in DryadLINQ, which uses the information to build \na distributed query graph [32]; and in LINQ-to-SQL, which turns a LINQ query into the equivalent SQL \ndatabase query [25]. The query AST represents each LINQ operator as a method\u00adcall expression, and the \noperator arguments as lambda expressions (Figure 3). To simplify the code generation process, Steno trans\u00adlates \nthis AST into a chain of operators, by post-order traversing the tree, and yielding a canonical2 operator \nfor each method-call expression. Steno also traverses the AST of the lambda expressions to identify nested \nqueries, as we discuss further in Section 5. 3.2 Optimized code generation The code generation process \ntakes a (possibly nested) chain of operators and transforms it into optimized imperative code. To 2 For \nexample, there are three overloaded versions of the Aggregate method, and eight overloaded versions of \nthe GroupBy method. achieve this, Steno uses an automaton-based approach. Steno tra\u00adverses the chain \nof operators (and any nested chains), and emits one or more symbols of Query Intermediate Language (QUIL) \nper operator. The code generator automaton recognizes any valid string of QUIL, and generates the appropriate \nC# code for each symbol. We introduce QUIL in Subsection 4.1. The code generator automaton performs two \nprincipal optimiza\u00adtions. First, it eliminates the iterators from chains of operators (\u00a74). It also identi.es \nnested queries, and transforms these into nested loops (\u00a75). As it parses a sequence of QUIL symbols, \nthe code gen\u00aderator builds a new C# class with a single method that implements the optimized query. It \nbuilds the class using the .NET CodeDOM library, which provides an object model for the C# (and other \n.NET languages ) AST. The automaton builds up the AST from loops, conditional statements, declarations \nand assignments, according to the QUIL symbols that it receives.  3.3 Final steps Once the query class \nhas been generated, it must be compiled and loaded in order to execute the query. This step invokes the \nC# compiler to build a dynamic link library (DLL) from the CodeDOM AST. Steno dynamically loads the resulting \nDLL, and instantiates a compiled query object using the re.ection API. Before the query is invoked, Steno \nmust resolve any object ref\u00aderences that were captured in the query. As a pre-processing step, Steno \nreplaces all captured object references in the query with placeholder instance variables. Once the generated \ncode has been loaded, Steno uses the re.ection API to set the relevant .elds of the compiled query object \nappropriately. Since using the dynamic load\u00ading and re.ection APIs incurs a relatively high constant \ncost (\u00a77.1), the query object may be cached between invocations. However, by integrating Steno with DryadLINQ, \nthis cost can be eliminated by performing Steno code generation in the initial DryadLINQ code generation \nprocess (\u00a76), and generating static code that sets the cap\u00adtured variables. 4. Iterator fusion Iterator \nfusion replaces a chain of iterators with a sequence of im\u00adperative statements in a loop body. To achieve \nthis, Steno generates type-specialized iteration code for the source collection, and inline element-processing \ncode for each operator in the query. Table 1 classi.es the LINQ operators according to their type, and \nmaps each to a symbol in our intermediate language, QUIL. In Subsection 4.1, we describe QUIL, and specify \na .nite state machine that can parse QUIL sentences. Then, in Subsection 4.2, we show how Steno uses \nthe state machine to generate optimized code without iterators. Finally, in Subsection 4.3, we show how \nSteno can use additional information from the operator graph to generate more-ef.cient specialized code. \n 4.1 Query Intermediate Language The Query Intermediate Language (QUIL) serves three main pur\u00adposes: \n It simpli.es query optimization by reducing the large number of LINQ operators to six fundamental QUIL \noperators.  It simpli.es the code generator by allowing it to be structured as an automaton that recognizes \nthe language.  It enables extensibility, by specifying the interface that each operator must provide. \n As Table 1 shows, we have de.ned six symbols, which comprise the QUIL alphabet and correspond to LINQ \noperators. In this subsection, we de.ne the behavior of each operator, and show how operators may be \ncombined to represent a LINQ query.  Operator class QUIL symbol LINQ operators Haskell equivalent Input \ntype Output type Source Src Range, Repeat List constructor  IEnumerable<T> Transform Trans Select map \nIEnumerable<T> IEnumerable<U> Predicate Pred Where, Take, Skip, etc. filter IEnumerable<T> IEnumerable<T> \nSink Sink GroupBy, OrderBy, etc. foldl IEnumerable<T> IEnumerable<U> Aggregate Agg Aggregate, Min, Sum, \netc. foldl IEnumerable<T> U Nested  SelectMany, Join concatMap IEnumerable<T> IEnumerable<U> Return \nRet  IEnumerable<T> or T Table 1. The LINQ operator classes map on to QUIL symbols (\u00a74.1). T and U \nare generic type variables. Nested operators map to multiple QUIL symbols, as explained in Section 5. \nA QUIL expression begins with a Src symbol, and ends with a Ret symbol. The Src symbol represents an \nenumerable source collection, and may be annotated with the collection s run-time type, which enables \nSteno to produce ef.cient iteration code for the collection. LINQ collection generators, such as Range(start, \ncount) are also represented by Src. The Ret symbol denotes the end of a query, and may appear after any \nother QUIL symbol. Therefore, a query may return either a collection or a scalar value. The other QUIL \noperators are analogous to LINQ operators: The Trans operator applies an element-wise transformation \nto each element in the input collection, yielding a new collection. Trans is parameterized with a function, \nf : T . U, that trans\u00adforms a single input element into an output element.  The Pred operator applies \na predicate to each element in the input collection, and yields an output collection containing only \nelements that match the predicate. Pred is parameterized with a function, f : T . B, that performs the \npredicate test on a single input element.  The Sink operator transforms the input collection into an \ninter\u00admediate collection that may be enumerated subsequently. Typ\u00adically, Sink builds up the intermediate \ncollection in memory. Sink is parameterized with two functions. The .rst function, f : () . IEnumerable<U>, \nconstructs an empty intermediate collection; and the second function, g : IEnumerable<U> \u00d7 T . IEnumerable<U>, \nupdates a collection with a new input ele\u00adment. Sink may also provide type-specialized iteration code \nfor the intermediate collection.  The Agg operator reduces elements into a single, scalar value. Agg \nis parameterized with two functions. The .rst function,  f : () . U, returns the identity scalar value; \nand the second function, g : U \u00d7 T . U, creates a new scalar value of type U from the current scalar \nvalue and a single input element. For each operator, the function parameters may be speci.ed as an appropriately-typed \nlambda expression, delegate function or functor object. Note that we can assume that the C# compiler \nhas already type-checked the query expression, so Steno does not perform additional type-checking. We \nnow de.ne QUIL by considering what constitutes a valid query. Every query begins with Src and ends with \nRet. The Trans, Pred and Sink symbols transform one enumerable collection into another collection. Therefore, \nit is possible to chain together an unbounded number of these operators in an arbitrary order. As we \nwill discuss in Section 5, a nested query may substitute for a Trans or Pred symbol. Finally, since Agg \nreturns a scalar value, its result can only be consumed by Ret, and Agg may only appear as the penultimate \nsymbol. These rules may be stated concisely using the following grammar: (query) ::= Src ( Trans | Pred \n| Sink |(query)) * Agg? Ret Trans, Pred Sink Trans, Pred Src start Sink  Agg Ret Ret Figure 4. State \nmachine used to perform iterator fusion in Steno. To simplify the explanation, we will defer the discussion \nof nested queries to Section 5. If we ignore the possibility of nested queries, QUIL is a regular language \nand can therefore be recognized by a .nite state machine (FSM). Steno uses the FSM shown in Figure 4 \nto perform iterator fusion on QUIL expressions. The QUIL FSM has .ve states. The initial Src symbol, \nand the element-wise Trans and Pred symbols cause a transition to the ITERATING state. The Agg symbol \ncauses a transition to the AGGREGATING state, and the Sink symbol causes a transition to the SINKING \nstate. Note that the SINKING and ITERATING states are separate, because the code generated on a transition \nfrom those states will differ (\u00a74.2). Finally, the Ret symbol causes a transition to the terminal RETURNING \nstate. In the following subsection, we show how these transitions can generate optimized code without \niterators.  4.2 Code generation Code generation is driven by transitions of the FSM shown in Figure \n4. In this subsection, we describe the overall structure of the generated code, and explain the code \nthat is emitted by each transition. All QUIL queries begin with a Src operator, which corresponds to \nan enumerable collection, and therefore intuitively causes a new loop to be generated. Figure 5 shows \nthe structure of the generated loop code: it contains a linked list of C# statements, with three internal \npointers to positions where statements may be inserted. Insertion point a is the loop prelude (i.e. the \nlist of statements immediately preceding the loop); \u00b5 is the loop body; and . is the loop postlude. The \nloop prelude contains aggregation and sink variable declarations, the loop body contains element-wise \noperations, and the loop postlude may contain return statements. The generated loop code depends on the \nrun-time type of the source collection. For example, if the source is an array or array\u00adbacked collection, \nit is more ef.cient to use indexed element access than an iterator to access an element. The generated \ncode is a loop  // Pre-loop initializers ... a // a1 for (...) {  // Loop body ... \u00b5 // \u00b51 } // \nPost-loop statements ... . // .1 Figure 5. The generated code is maintained as a linked list of statements. \nSteno maintains three insertion points: the loop prelude (a), the loop body (\u00b5), and the loop postlude \n(.). Select(x => f(x)) \".\u00b5 var elemi+1 = f(elemi); (a) Trans(f) Where(x => f(x)) \".\u00b5 if (!f(elemi)) continue; \n(b) Pred(f) Figure 6. Generated code fragments for element-wise operators. N.B. The \".\u00b5 symbol denotes \nthat code is inserted at the \u00b5 pointer. through the indices of the array, which also enables the compiler \nto hoist the array bounds check. Steno also provides Src implemen\u00adtations for the Range and Repeat operators, \nwhich generate new collections based on their parameters. The code generator uses local variables to \nstore intermediate values, such as the result of a transformation. There are three kinds of variable \nin the generated code: elemi A (possibly-transformed) element in a collection aggj The current scalar \nvalue of the jth Agg operator sinkk The current sink collection of the kth Sink operator The code generator \nmaintains the current names for each kind of variable as an integer index, which some transitions may \nincrement. In the remainder of the paper, varnamei is the current variable name, and varnamei+1 is the \nnext variable name. When the FSM is in the ITERATING state, the Trans and Pred element-wise operators \ninsert code in the current loop body at the \u00b5 pointer. Figure 6 shows the code that is inserted in each \ncase. Both operators operate on the current element (elemi), and Trans creates a new element variable \n(elemi+1). In addition, Steno inlines the transformation or predicate function, which eliminates the \noverhead of a virtual call on a function object per element. The Agg and Sink operators reduce the current \nelement into a scalar aggregate value or a sink collection, respectively. Therefore the code generator \nmust insert code both for declaring and updating the reduction variable. Figure 7 shows the code that \nis inserted for the Aggregate and GroupBy operators. In both cases, the declaration is inserted at the \na pointer before the loop, and the update statement is inserted at the \u00b5 pointer. Following a Sink operator, \nthe FSM is in the SINKING state, which behaves like the ITERATING state with one main excep\u00adtion: the \nfollowing operator is applied to the sink collection. For example, a common pattern is to follow a GroupBy \nSink operator with a Where Pred operator to .lter the groups (cf. the GROUP BY ...HAVING pattern in SQL). \nTo handle this, the code generator must insert a new loop that iterates through the sink collection. \nThe loop Aggregate(seed, (agg, elem) => g(agg, elem)) \".a var aggj+1 = seed; \".\u00b5 aggj+1 = g(aggj+1, elemi); \n (a) Agg(f) GroupBy(x => Key(x)) \".a Lookup<K, T> sinkk+1 = new Lookup<K, T>(); \".\u00b5 sinkk+1 = sinkk+1.Put(Key(elemi), \nelemi); (b) Sink Figure 7. Generated code fragments for aggregating and sinking operators. In (b), Lookup<K, \nT> is a utility class that maintains a key-value multi-map, implements the IEnumerable<IGrouping<K, T>> \ninterface, and provides a Put method that returns the updated collection. \".. return aggj ; \".. return \nsinkk; (a) AGGREGATING (b) SINKING \".\u00b5 yield return elemi; (c) ITERATING Figure 8. Generated code fragments \nfor the Ret operator, which depend on the current state. is inserted at the current . insertion point, \nand the insertion pointers are reset relative to the new loop. Finally, the Ret symbol causes a transition \nto the terminal RE-TURNING state, which generates code that returns one or more val\u00adues to the caller \n(Figure 8). If the FSM is in the SINKING or AG-GREGATING states, this inserts a return statement (with \nthe sinkk or aggj variable respectively) at the . insertion point. If it is in the ITERATING state, the \ntransition inserts a yield return statement at the \u00b5 pointer: this turns the optimized query into an \niterator, which enables the query to be lazily evaluated3.  4.3 Operator specialization By analysing \nthe intermediate query representation, Steno can make high-level optimizations that are not possible \nwhen dealing with abstract iterators. In this subsection, we consider one concrete example: the GroupBy-Aggregate \noptimization. The GroupBy operator (Figure 7(b)) is a Sink operator that builds a mapping from keys to \nbags of values, and is analogous to the GROUP BY clause in a SQL statement. LINQ provides several im\u00adplementations \nof GroupBy, including some that allow the caller to specify a result selector, which applies a function \nto each key and the collection of values associated with that key. The result selector is often used \nto aggregate or reduce the set of values associated with a key into a single scalar. Indeed, the reduce() \nfunction in MapReduce [10] has the same signature as the GroupBy result selector, and performs the equivalent \noperation [33]. If the result selector is an Agg operator (such as Aggregate, Sum or Min), we can save \nmemory by storing per-key partial aggregates instead of the group of values. To implement this optimization, \nSteno identi.es GroupBy oper\u00adators with an aggregating result selector when building the operator chain \n(\u00a73.1), and inserts a specialized GroupByAggregate Sink op\u00aderator in place of a conventional GroupBy. \nThe GroupByAggregate operator performs the aggregation as each element is processed, and updates an intermediate \nhashtable-based sink object. 3 It is often more ef.cient to store the elements in an array and return \nthis to the caller, but it is unsafe to do this for some queries where the collection may be very large \n(or unbounded). Therefore, the caller can use the explicit ToArray Sink operator to enable this optimization. \n The memory requirements can be decreased further (to O(1) keys and reduction variables) if it is known \nthat the collection is ordered by the same key as the grouping. DryadLINQ implements this optimization \nin order to aggregate key sets that are too large to .t in memory [33]. 5. Nested loop generation We \nnow consider the case where a QUIL expression may contain a nested query. As de.ned in Subsection 4.1, \na nested query may substitute for the transformation and predicate functions of Trans and Pred operators, \nrespectively. In this section, we explain how Steno generates ef.cient nested loops for nested queries. \nAt .rst, it might seem that nested queries can be trivially sup\u00adported by running a second instance of \nthe optimizer on the nested query, and inserting a call to the optimized subquery in the par\u00adent. In \nfact, this is an appropriate solution if the nested query has a scalar result (i.e. if it contains an \nAgg operator). However, if the nested query returns an enumerable collection, this solution is in\u00adef.cient, \nbecause the outer query obtains an opaque collection, and can only access the result elements through \nthe iterator interface, which incurs two virtual calls per element (\u00a72). The SelectMany operator illustrates \nthis point: int[] xs = ..., ys = ..., zs = ...; int result = xs.SelectMany(x => ys.SelectMany(y => zs.Select(z \n=> F(x, y, z))) .Sum(); This query computes the Cartesian product of three arrays xs, ys and zs applies \nF to each resulting element, and sums the results. The equivalent loop-based code is simple to write: \nint total = 0; for (int i = 0; i < xs.Length; ++i) { for (int j = 0; j < ys.Length; ++j) { for (int k \n= 0; k < zs.Length; ++k) { total += F(xs[i], ys[j], zs[k]); } } } However, a na\u00a8ive implementation using \nnested FSM-based opti\u00admizers would not generate this code, because the Sum operator is part of the outermost \nquery, yet it must inject code into the loop body of the innermost query. Without this ability, the Sum \nand nested SelectMany operators must consume from iterators, which limits the potential performance improvement. \nThe SelectMany operator .attens a collection of collections (one per original element) into a single \ncollection. It is a funda\u00admental operator in MapReduce, in which the map() function trans\u00adforms a single \nelement into zero or more key-value pairs [10]. DryadLINQ implements this functionality using SelectMany \n[32], and similar operators exist in FlumeJava [7] and Pig Latin [26], both of which execute on a MapReduce \ncluster. Furthermore, since it can implement the Cartesian product, SelectMany can also be used to implement \njoins across multiple collections: int[] xs = ..., ys = ...; var zs = xs.SelectMany(x => ys.Where(y => \nx == y)....); The above example shows an equi-join on two arrays of integers. However, in practice, this \nis an inef.cient way to implement joins on two large data sets, and partitioning or sorting is used to \nreduce the necessary amount of processing, I/O and/or memory [13, 32]. ai+1 ai ... // ai for (...) { \n...  \u00b5i+1 \u00b5i a .i+1 .i // ai+1 for (...) { ...  ... ... \u00b5 // \u00b5i+1 ... } . // .i+1,\u00b5i a\u00b5. } ... \n// .i Figure 9. In the nested case, insertion pointers are arranged in a stack, with the innermost nesting \nlevel at the top. The current (a, \u00b5, .) pointers are read from the top of the stack. Having motivated \nthe need for nested query support, we now discuss how Steno uses QUIL to support nested queries (\u00a75.1), \nand their effect on code generation (\u00a75.2). 5.1 Adding a stack Since a QUIL query can recursively contain \nanother query, the lan\u00adguage is context-free. Therefore, the FSM in Figure 4 is not pow\u00aderful enough \nto recognize all valid QUIL queries. To recognize the full context-free language, we must add a stack \nto the code gener\u00adator, making it a (deterministic) pushdown automaton. In order to reuse the iterator \nfusion optimization, the pushdown automaton is exactly equivalent to the FSM in the non-nested case. \nTherefore, in this subsection, we reintroduce the nested query transitions and how these manipulate the \nstack. Recall that the code generator has a, \u00b5 and . insertion pointers, which correspond to the current \nloop s prelude, body and postlude, respectively (Figure 5). Since all queries nested or otherwise involve \niterating through a collection, a nested query will create a new loop, with a different prelude, body \nand postlude. After exit\u00ading a nested query, it may be necessary to recover the outer query s insertion \npoints, so that code for subsequent operators may be in\u00adserted. Therefore, we de.ne the stack, S, as \ncontaining (ai,\u00b5j ,.k) triples, where i, j, k = 1 are the nesting levels of each insertion point. The \ncode generator uses the topmost triple as the current val\u00adues for a, \u00b5 and .. S is initially empty. When \na Src operator is encountered at nesting level i = length(S), a new loop is inserted at position \u00b5i, \nand insertion points (ai+1,\u00b5i+1,.i+1) are pushed onto the stack. Figure 9 shows the state of the stack \nand the generated AST after entering nesting level i +1.  5.2 Code generation Following a nested Src \noperator, the automaton is in the ITERAT-ING state. Subsequent Trans, Pred, Sink and Agg operators behave \nas in the non-nested case, though code is inserted at the nested in\u00adsertion points. In addition, the \nnested query may refer to the current element in the outer query, as in this example: xs.SelectMany(x \n=> ys.Select(G(x, y))); Therefore, before generating any code for the nested query, all occurrences of \nx in the nested query are rewritten with the current elemi variable name in the outer query. The behavior \non encountering a nested Ret operator depends on the current state of the automaton. The SINKING and \nAGGREGAT-ING cases are simpler. If the code generator is in either of these  \".. var elemi+1 = aggj \n; \".. var elemi+1 = sinkk; (a) AGGREGATING (b) SINKING  parallelizes as Figure 10. Generated code fragments \nfor the nested Ret operator, in the AGGREGATING and SINKING states. Src1 Trans Agg1  Src Trans Agg \nRet  Src Src2 Trans Agg2 Agg* Ret  Src3 Trans Agg3  ai+1 ai \u00b5i+1 \u00b5i .i+1 .i  states, it assigns \nthe current aggregation or sink variable to a new element variable in the nested loop postlude (Figure \n10), then pops the current insertion pointer triplet from the stack. If the code generator encounters \na nested Ret operator while in the ITERATING state, the stack management is slightly more complicated. \nRecall that, in the non-nested case (\u00a74.2), encounter\u00ading Ret while ITERATING causes a yield return statement \nto be emitted. In this case, we want the code for subsequent operators to be inserted in the current \nnested loop body. Therefore we pop two insertion pointer triples from the stack, and push back the triple \n(aouter,\u00b5nested,.outer) (Figure 11). This ensures that the element\u00adwise code for each operator (transformation, \npredicate testing and reduction variable updating) will be inserted in the nested loop, while any declarations \nor return statements will be placed in the outer scope. This formulation means that nested Select and \nSelectMany have the same representation in QUIL. In a Select operator, the nested query will typically \nend with an Agg operator and return a scalar value; by de.nition, a SelectMany operator will yield many \nvalues. However, instead of creating an iterator using a yield return statement, the Ret in a nested \nquery moves the insertion pointers so that subsequent operators consume the results of the nested query \ndirectly. 6. Optimizing parallel queries A principal advantage of expressing a computation as a LINQ \nquery is that it may be executed in parallel across multiple pro\u00adcessors [29] or multiple machines in \na data center [32]. However, the optimizations described above generate sequential code. In this section, \nwe explain how Steno can be combined with DryadLINQ in order to improve the performance of distributed \nqueries. To execute a query on a large data set, a common strategy is to divide the data set into partitions, \nand execute the query in parallel on each partition [12]. If the query operators are homomorphic (i.e. \napply to each element independently), the query may be applied to each partition in parallel, to yield \na new set of partitions. Trans, Pred and nested queries are homomorphic. However, if a query operator \nperforms an aggregation (Agg) or builds a sink collection (Sink), this requires coordination between \nthe partitions. To optimize a query that can execute in parallel, Steno traverses the QUIL representation \nof the query and identi.es the homomor\u00adphic operators. Contiguous subsequences of homomorphic opera\u00adtors \nare combined into subqueries, and the subqueries are optimized Figure 12. Parallel optimization of a \nSelect-Aggregate query. Steno applies optimization to the Srci -Trans-Aggi subquery, which executes in \nparallel on the partitions of the data. separately. Note that, if an associative Sink or Agg operator \nfollows a subquery, a partial Sinki or Aggi operator can be appended to the ith subquery, which reduces \nthe amount of coordination between partitions. For example, if the Agg operator represents Sum, the cor\u00adresponding \nAggi operator computes a partial sum for each parti\u00adtion. Figure 12 shows how a simple query is parallelized. \nIn that example, a special Agg* operator collects the partially-aggregated results from each partition. \nWe have integrated Steno with DryadLINQ, which executes queries in parallel across a compute cluster. \nDryadLINQ also iden\u00adti.es homomorphic query operators, and transforms a LINQ query into a directed acyclic \ngraph of query operators, which Dryad exe\u00adcutes as a collection of parallel tasks [19]. In addition, \nDryadLINQ performs various static and dynamic optimizations on the query be\u00adfore generating the code \nfor each task: for example, it transforms a OrderBy Sink operator into a distributed sort, which samples \nthe data to estimate an appropriate partitioning, range-partitions the data based on that estimate, and \nsorts each resulting partition in parallel [32]. DryadLINQ also optimizes distributed aggrega\u00adtion where \nthe aggregation function is commutative and associa\u00adtive [33]. After optimization, an individual task \nmay contain a se\u00adquence of query operators: our modi.ed version of DryadLINQ applies Steno-optimization \nto the subsequences of homomorphic operators in each task. DryadLINQ can also execute subqueries in parallel \nwithin a sin\u00adgle task. Previously, it used Parallel LINQ (PLINQ) to execute ho\u00admomorphic subqueries using \na thread-pool [29]. PLINQ provides the same operators as LINQ, but operates on a ParallelEnumerable collection, \nwhich uses a Partitioner object to assign elements to each thread. PLINQ uses iterators to compose query \noperators, and therefore suffers from similar virtual call overheads to sequen\u00adtial LINQ. To ameliorate \nthis, we created a new PLINQ operator, called HomomorphicApply, which maps a function across partitions \nin parallel (as opposed to each element), and returns a new set of partitions. Our modi.ed version of \nDryadLINQ invokes this oper\u00adator with the compiled query method, which allows the optimized code to execute \nin parallel. 7. Evaluation We now evaluate the performance improvement that Steno can achieve. We .rst \nevaluate a collection of single-machine mi\u00adcrobenchmarks, which operate on in-memory data (\u00a77.1). We \nthen evaluate the impact of applying Steno to a real-world application that uses DryadLINQ on a distributed \ncompute cluster (\u00a77.2). All experiments described in this paper were performed on our research cluster, \nfrom which we use up to 100 nodes. Each computer has two dual-core AMD Opteron 2218 HE processors running \nat 2.6 GHz, 16 GB of DDR2 RAM, and four 750 GB SATA hard drives in a RAID 0 (striped) con.guration. The \ncomputers are connected using gigabit Ethernet, in a three-level tree topology.  All computers run \nthe 64-bit version of Microsoft Windows Server 2003, and the 64-bit version of Microsoft .NET Framework \n3.54. 7.1 Sequential microbenchmarks We evaluated the performance of sequential Steno optimization using \nthe following four queries on in-memory arrays: Sum Calculate the sum of 10 million double values. SumSq \nCalculate the sum of squares of 10 million double values. Cart Calculate the Cartesian product of 10 \nmillion and 1000 double values, multiply together each pair, and sum. Group Randomly generate 10 million \ndouble values according to a one-dimensional mixture-of-Gaussians distribution, and compute a binned \nhistogram of the data. Figure 13 shows four quantities for each benchmark: LINQ, Steno including compilation, \nSteno excluding compilation, and hand\u00adoptimized. In order to allow comparison of different benchmarks, \nthe results are normalized to the LINQ execution time. For all of the microbenchmarks, the Steno-optimized \nquery is faster than the equivalent LINQ query. The speedup ranges from 3.32\u00d7 for Sum to 14.1\u00d7 for Group. \nAs expected, the nested queries (Cart and Group) yield a bigger speedup due to the LINQ code us\u00ading nested \niterators. Compared to the hand-optimized, loop-based code, the worst overhead is 53% for Sum, the simplest \nquery due to the .NET JIT compiler missing a possible temporary variable elimination in the Steno-generated \ncode, which leads to two extra\u00adneous movsd instructions in the loop body. For the other queries, the \noverhead (compared to hand-optimized) is less than 3%. However, Steno optimization carries a one-off \ncost per query, which is dominated by invoking the C# compiler and dynamically loading the optimized \nquery class. The compiled query object can then be cached by the application. In our experiments, this \ncost was 69 milliseconds on average. Therefore, if an application contains mostly short, infrequently-executed \nqueries, it is not worth invok\u00ading Steno at run-time. Summing 10 million doubles with LINQ takes approximately \n83 ms, whereas with Steno it takes 25 ms plus 69 ms for compilation. The break-even point is approximately \n12 million doubles. Note that, if the optimization were added to the C# compiler, this cost would be \npaid at compile-time. In addition, the optimized query object may be stored and reused in order to amor\u00adtize \nthe cost of compilation. In the current implementation, the user must explicitly instruct Steno to compile \na given expression, but a query caching approach (based on Nectar [18]) could be added. 4 The current \nversion of DryadLINQ is not compatible with .NET 4.0. Steno is compatible with .NET 3.5 and 4.0. We con.rmed \nthat microbenchmark performance is the same using both versions. Figure 14. Relative performance of unoptimized \nand Steno\u00adoptimized k-means algorithm, running on DryadLINQ. Each query is annotated with the absolute \nunoptimized execution time for one iteration, in seconds.  7.2 Distributed k-means We now evaluate the \nperformance of Steno-optimized code for a representative distributed query: k-means clustering. A distributed \ncluster is a more challenging environment for Steno: since data sets are often too large to .t in memory, \nthey must be read from disk, and network communication is required to coordinate between par\u00adtitions. \nBy contrast, the microbenchmarks use in-memory arrays. The k-means algorithm groups a set of data points \ninto k clus\u00adters by estimating the centroid of each cluster, and iteratively up\u00addating the centroids \nby averaging the points in each cluster. The main computational step involves computing the (e.g. Euclidean) \ndistance from each point to each centroid, and assigning each point to the cluster whose centroid is \nclosest. We implemented the algo\u00adrithm in DryadLINQ, and each iteration comprises two steps: 1. In parallel, \nfor each data point (nested Select), compute the distance to each centroid (Select), and choose the cluster \nwith the closest centroid (Aggregate). Then group these results by cluster ID (GroupBy) and compute partial \nsums of the points in each cluster (Aggregate). 2. Group the partial sums from each partition by cluster \nID (GroupBy), add them together (Aggregate), and compute the new cluster centroids by taking the mean \n(Select).  This query exploits iterator fusion (\u00a74), GroupBy-Aggregate spe\u00adcialization (\u00a74.3) and nested \nloop generation (\u00a75). The bene.ts from Steno-optimization are greatest when (i) a large number of elements \nare processed, and (ii) the amount of work that each operator performs is small. The k-means algorithm \noffers us the opportunity to vary both quantities, but (since k-means has O(n) complexity for n data \npoints) it is more meaningful to vary to amount of work per element. We achieve this by varying the number \nof dimensions in each point, which is directly proportional to the number of .oating-point operations \nin the Euclidean distance calculation. Figure 14 shows the effect of varying the dimension on the performance \nof unoptimized and Steno-optimized k-means. The overall size of the input data (number of points \u00d7 dimension) \nis held constant at 109 doubles( 8 GB). The most notable result is that Steno achieves substantial speed\u00adup \nover LINQ for dimensions less than 1000, which demonstrates that iterator overheads can have a large \neffect on the performance of distributed query execution. Larger speedups are achieved for smaller dimensions: \nfor example, 1.9\u00d7 for 10-dimensional points. However, as the dimension increases, Steno manages to speed \nup execution, and it achieves a 19% improvement for 100-dimensional data. Eventually, however, the execution \nconverges with the unop\u00adtimized case, as the fraction of time spent in the distance computa\u00adtion becomes \ncloser to 100%.  8. Related work There is a large volume of related work on the optimization of declarative \nprograms. Steno combines ideas from database systems, functional programming, XML processing and object\u00adoriented \nprogramming to optimize the execution of declarative data-parallel programs. In this section, we survey \nthe related work in each of these .elds, and compare it to Steno. 8.1 Relational databases The stated \naim of Codd s relational algebra was to hide details of how the data is organized in the machine (the \ninternal represen\u00adtation). [8] This set the precedent for database access using SQL, a declarative query \nlanguage, which in turn in.uenced the design of LINQ [2]. Query evaluation can be implemented using itera\u00adtors \n[3], which motivates use of IEnumerator objects to compose LINQ operators. Because relational databases \nare designed to hold large volumes of data, research into query ef.ciency has been car\u00adried out since \nthe earliest implementations of the relational model. IBM s System R implemented SEQUEL (a precursor \nof SQL) query evaluation by assembling fragments of System/370 machine code in a query-speci.c subroutine \n[6]. System R used a preproces\u00adsor to extract SEQUEL queries from COBOL or PL/1 source code, and replace \nthem with calls to the generated machine code. How\u00adever, the use of pre-de.ned code fragments led to \noverhead from procedure calls, and poor portability [15]. Freytag and Goodman re.ned this method by transforming \na query into iterative C or Pascal code, which is then compiled by an existing compiler [15, 16]. Their \nsystem compiles queries written in a dialect of SQL comprising operators for projection, .ltering, left-join \nand aggregation into iterative code, using rule\u00adbased transformations. Most recently, Krikellas et al. \nrevisited the problem of ef.\u00adcient query execution, and analysed the costs of the iterator model at the \ncomputer-architectural level [23]. They propose holistic query evaluation (HQE), which uses a code generator \nto turn SQL queries into C code, and then compiles it using an existing optimiz\u00ading compiler. Like System \nR, HQE relies on a library of templates to provide the generated code. It offers a restricted form of \nnested loop generation for table joins, but does not support arbitrarily\u00adnested query expressions such \nas those described in Section 5. The techniques for optimizing query execution are similar to Steno, \nin that they propose generating lower-level code, which can be compiled or executed directly. However, \nall of these techniques target SQL, which is less general than LINQ (it lacks a SelectMany operator), \nand does not at least, in the database systems described above integrate with user-de.ned code in a general-purpose \nlan\u00adguage. Furthermore, none of these techniques are shown to apply to nested queries. The automaton-based \napproach that we describe in this paper could be applied to SQL query optimization and may be useful \nin extending these systems with nested query support. 8.2 Functional programming The LINQ execution \nframework shares several features with lazily\u00adevaluated functional languages: in particular, the Select, \nWhere, Aggregate and SelectMany operators correspond to Haskell s map, filter, foldl and concatMap functions \n[25]. Therefore, techniques for ef.ciently compiling a lazy functional program are related to (and can \ninform) our technique for ef.ciently compiling a LINQ expression. Lazy evaluation can reduce the storage \ncost of some programs by only evaluating the values in a collection when they are needed by a consumer. \nHowever accessing the not-yet-evaluated portions of intermediate collections imposes a hidden cost that \nis analo\u00adgous to the iterator overhead in LINQ. Wadler developed the de\u00adforestation algorithm to eliminate \nintermediate lists (and trees) from programs written in a restrictive, .rst-order, lazy functional language \n[31]. However, deforestation is considered impractical because it restricts programs to a treeless form \nthat prohibits, amongst other things, intermediate data structures [17]. Practical versions of deforestation \ninclude build/foldr [17], destroy/unfoldr [28] and stream fusion [9]. These techniques use equational \ntransformations in Haskell to transform functions that produce and consume lists into fused code that \ndoes not use intermediate lazy lists. Of the three techniques, stream fusion is the most powerful, and \ncan optimize the nested concatMap function, which is analogous to SelectMany in LINQ. However, stream \nfu\u00adsion is not well-suited to deeply-nested list computations because the Glasgow Haskell Compiler s \noptimizer cannot always generate ef.cient code from the fused intermediate form [9]. By contrast, Steno \ngenerates simple nested for loops that the C# compiler can easily optimize. 8.3 XML processing The growing \npopularity of XML as a data interchange format has prompted research into ef.cient processing of XML \ndocuments and streams. XML query languages such as XQuery and XPath provide declarative syntax for computations \nover XML documents, and early query processing systems used an iterator-based approach for query evaluation \n[14]. Li and Agarwal developed a code generation technique called Generalized Nested Loops (GNLs), which \ncan be used to opti\u00admize the evaluation of XQuery expressions on large data sets [24]. Although super.cially \nsimilar to nested queries in QUIL (\u00a75), GNLs can only represent nested loops that perform an associa\u00adtive \naggregation function. Therefore, the GNL code generation technique could not be applied to nested queries \nthat .atten a col\u00adlection, such as SelectMany and Join. Reichenbach et al. have studied the optimization \nof XML\u00adprocessing computations that are embedded in the XJ imperative language, which is based on Java \n[27]. They developed a pro\u00adgram analysis that identi.es potential XPath queries that are latent in imperative \ncode, and exploits opportunities for sharing results between queries. By contrast, Steno attempts to \noptimize the exe\u00adcution of explicit queries. However, since XJ supports LINQ-like query syntax, it may \nbe possible to apply this analysis to C# pro\u00adgrams, and identify opportunities for common subexpression \neval\u00aduation between Steno-optimized queries.  8.4 Object-oriented programming In an object-oriented \nprogramming language, virtual calls are ex\u00adpensive because the compiler does not have enough information \nto generate inline code at the call site: the receiver method is only known at run-time. To solve this \nproblem, various devirtualization techniques have been proposed. Calder and Grunwald proposed a simple \ntransformation for C++ code that inlines the code for the most likely receiver of a virtual call, guarded \nby a run-time type check [5]. Since the guard code contains a simple branch instruction, hardware branch \nprediction can ameliorate the overhead of the type check. However, a LINQ operator may be used to consume \nfrom different iterator implementations at different points in the same program (or even in the same \nquery), so the receiver for a particular call site is not usually predictable. Dean et al. developed \nstatic class hierarchy analysis, which per\u00adforms static analysis on the inheritance hierarchy and intraproce\u00addural \ndata-.ow analysis to identify the precise type of an object (and hence potentially eliminate a virtual \ncall) [11]. This technique is less useful for C#, which allows dynamic classloading, though a just-in-time \napproach that revirtualizes methods as appropriate has been developed [20]. Furthermore, since the IEnumerator<T> \ninterface has many implementing classes, it is rarely possible to make a precise static judgement about \nthe run-time type of an iter\u00adator, without expensive interprocedural analysis.  Although devirtualization \ncould improve the performance of LINQ queries, it is not implemented in the current version of the .NET \nCommon Language Runtime (CLR). Furthermore, even if perfect devirtualization were achieved, the resulting \ninlined code would include the state machine logic from each iterator, which would be less ef.cient than \nthe simple for loops generated by Steno. We are not aware of a compiler that could eliminate this semantically \nredundant logic and yield code that is as ef.cient as a Steno-optimized query.  8.5 Data-parallel computing \nSteno was originally developed to optimize the performance of DryadLINQ programs, which run in parallel \non a distributed com\u00adpute cluster. The restrictions imposed by the declarative style of programming make \nit simple to parallelize a program written as a declarative query (\u00a76), and several systems use this \napproach to exploit the computational resources of large compute clusters. Dean and Ghemawat s MapReduce \nis an in.uential system for data-parallel programming [10]. In MapReduce, developers specify their computations \nby providing two functions: a mapper, which transforms input records into lists of key-value pairs (cf. \nSelectMany, \u00a75), and a reducer, which aggregates all of the val\u00adues corresponding to a single key (cf. \nGroupBy-Aggregate, \u00a74.3). MapReduce uses an iterator in the reducer to provide access to the values corresponding \nto a single key; the open-source Hadoop implementation of MapReduce uses iterators extensively in the \npro\u00adcessing of records [1]. We expect that generating specialized code to eliminate iterators would yield \na performance improvement sim\u00adilar to what Steno achieves. Chambers et al. described FlumeJava, which \n(like DryadLINQ) uses lazy evaluation to build a distributed execution plan from a graph of operators \n[7]. In FlumeJava, however, the execution engine is Google s MapReduce implementation. We note the similarity \nof FlumeJava s parallelDo(), groupByKey(), combineValues() and flatten() functions to LINQ s Select, \nGroupBy, Aggregate and SelectMany operators, respectively. The optimizations that we have developed in \nSteno apply equally to FlumeJava programs. How\u00adever, whereas LINQ uses Expression objects with an in-memory \nAST, FlumeJava uses classes that implement a functor interface to encapsulate operator behavior. This \nis less amenable to run-time optimization, and bytecode rewriting techniques would be neces\u00adsary to eliminate \nvirtual function calls from the optimized code. Two contemporary projects have performed static analysis \non (Hadoop) MapReduce programs in order to derive an optimized program. Manimal [4] and HadoopToSQL [21] \nanalyse the Java bytecode of MapReduce programs in order to generate an equiva\u00adlent relational algebra \nexpression. The expression is then converted to SQL, and passed to a cluster of SQL databases. The interme\u00addiate \nrepresentation bears some similarity to the LINQ expression tree that Steno uses. Therefore, the analyses \nthat these systems per\u00adform could be combined with Steno-style code generation in order to generate optimized \nquery execution code. Since Steno integrates into DryadLINQ, it can take advan\u00adtage of higher-level optimizations. \nFor example, Yu et al. added a transformation to DryadLINQ that optimizes distributed aggre\u00adgation (GroupBy-Aggregate) \nby partially performing associative and commutative aggregation functions before the communication step \n[33]. Gunda et al. developed a system called Nectar, which caches the results of previous DryadLINQ jobs, \nand uses the cached data to achieve common subexpression elimination across multiple DryadLINQ jobs [18]. \nSteno is applied after these transformations, which further improves the performance of DryadLINQ queries. \n9. Conclusions In this paper, we have presented Steno: an automatic optimizer for declarative queries \nthat generates ef.cient, loop-based, imperative code. Our automaton-based approach provides a useful \nabstraction for structuring the code generator, and made it straightforward to implement support for \nour two key optimizations: iterator fusion and nested loop generation. Though these optimizations generate \nsequential code, we have integrated Steno with DryadLINQ, which extends the optimization to code running \nin parallel on a distributed compute cluster. Our evaluation showed that, even in the challeng\u00ading distributed \ncase, Steno can almost double the performance of real-world DryadLINQ jobs. Our approach in developing \nSteno has been conservative. We did not modify the C# compiler or the .NET core libraries, and we faithfully \nreproduced the semantics of unoptimized LINQ. This leaves scope for further optimization. First, we can \napply such optimizations as common subexpression elimination only if it is possible to prove that the \nsubexpression has no side effects, and that materializing the subexpression does not exhaust memory. \nThe dif.culty of this problem suggests that there are opportunities for developer-guided optimization. \nAlso, we have hitherto only considered C# as the target language, but it may be possible to gain more \nef.ciency by directly generating bytecode, C or even native machine code. We note that many operators \ncould bene.t from vectorization, so SIMD execution using instruction-set extensions or GPGPUs would achieve \ngreater ef.ciency [30]. The implementation of Steno as a library is a mixed blessing. The main advantage \nis that Steno works with a standard .NET toolchain, but as we have shown in Section 7, invoking the C# \ncompiler at run-time introduces a one-off overhead of tens of mil\u00adliseconds. As a result, the developer \nmust be judicious in deciding when to optimize a query, by identifying frequently-executed or long-running \nqueries. This problem could be addressed by modi\u00adfying the C# compiler to perform Steno optimizations \nat compile\u00adtime. The compiler already desugars LINQ queries that are written in query comprehension syntax \n[2], and it would be conceptually straightforward to extend this compiler pass to use Steno. The current \nimplementation of Steno can only optimize the standard LINQ queries. Steno cannot optimize user-de.ned \nitera\u00adtors that are created with the yield return statement, because this statement is syntactic sugar \nthat is transformed into an iterator state machine at compile-time [22]. A typical user-de.ned iterator \ncon\u00adtains a loop over some internal data structure that yields one or more elements. If Steno were able \nto access the original syntax tree for the iterator method, it could perform more-aggressive iterator \nfusion and nested loop generation, which would further improve the performance of iterator-based programs. \nThe overall lesson that we draw from this work is that it is ad\u00advantageous to write in the declarative \nstyle wherever possible. The main bene.t is simpler code, which is easier to develop, and which systems \nlike PLINQ and DryadLINQ can automatically transform and optimize for parallel or distributed execution. \nPreviously, de\u00advelopers were forced to choose between ef.cient serial execution and access to these transformations. \nSteno demonstrates that this is a false dichotomy, by making the performance of declarative queries competitive \nwith hand-optimized code, while still exploit\u00ading higher-level transformations. Acknowledgments We wish \nto thank Frank McSherry, Mihai Budiu and the PLINQ team for helpful discussions during the development \nof Steno. We would also like to thank Steve Hand and the anonymous reviewers, whose comments on earlier \ndrafts of this paper have been invalu\u00adable for improving the presentation of this work.  References \n[1] Apache Hadoop. http://hadoop.apache.org/, accessed 18th March, 2011. [2] G. M. Bierman, E. Meijer, \nand M. Torgersen. Lost in translation: O Formalizing proposed extensions to C. In Proceedings of OOPSLA, \n2007. [3] P. Buneman, R. E. Frankel, and R. Nikhil. An implementation tech\u00adnique for database query languages. \nACM Trans. Database Syst., 7(2), 1982. [4] M. J. Cafarella and C. R\u00b4 e. Manimal: Relational optimization \nfor data\u00adintensive programs. In Proceedings of WebDB, 2010. [5] B. Calder and D. Grunwald. Reducing indirect \nfunction call overhead in C++ programs. In Proceedings of POPL, 1994. [6] D. D. Chamberlin, M. M. Astrahan, \nM. W. Blasgen, J. N. Gray, W. F. King, B. G. Lindsay, R. Lorie, J. W. Mehl, T. G. Price, F. Putzolu, \nP. G. Selinger, M. Schkolnick, D. R. Slutz, I. L. Traiger, B. W. Wade, and R. A. Yost. A history and \nevaluation of System R. Commun. ACM, 24 (10), 1981. [7] C. Chambers, A. Raniwala, F. Perry, S. Adams, \nR. R. Henry, R. Brad\u00adshaw, and N. Weizenbaum. FlumeJava: easy, ef.cient data-parallel pipelines. In Proceedings \nof PLDI, 2010. [8] E. F. Codd. A relational model of data for large shared data banks. Commun. ACM, 13(6), \n1970. [9] D. Coutts, R. Leshchinskiy, and D. Stewart. Stream fusion: from lists to streams to nothing \nat all. In Proceedings of ICFP, 2007. [10] J. Dean and S. Ghemawat. MapReduce: simpli.ed data processing \non large clusters. In Proceedings of OSDI, 2004. [11] J. Dean, D. Grove, and C. Chambers. Optimization \nof object-oriented programs using static class hierarchy analysis. In Proceedings of ECOOP, 1995. [12] \nD. J. DeWitt and J. Gray. Parallel database systems: the future of high performance database systems. \nCommun. ACM, 35(6), 1992. [13] D. J. DeWitt, R. H. Katz, F. Olken, L. D. Shapiro, M. R. Stone\u00adbraker, \nand D. A. Wood. Implementation techniques for main memory database systems. In Proceedings of SIGMOD, \n1984. [14] D. Florescu, C. Hillery, D. Kossmann, P. Lucas, F. Riccardi, T. West\u00admann, M. J. Carey, A. \nSundararajan, and G. Agrawal. The BEA/XQRL streaming XQuery processor. In Proceedings of VLDB, 2003. \n[15] J. C. Freytag and N. Goodman. On the translation of relational queries into iterative programs. \nACM Trans. Database Syst., 14(1), 1989. [16] J. C. Freytag and N. Goodman. Translating aggregate queries \ninto iterative programs. In Proceedings of VLDB, 1986. [17] A. Gill, J. Launchbury, and S. L. Peyton \nJones. A short cut to deforestation. In Proceedings of FPCA, 1993. [18] P. K. Gunda, L. Ravindranath, \nC. A. Thekkath, Y. Yu, and L. Zhuang. Nectar: Automatic Management of Data and Computation in Data Centers. \nIn Proceedings of OSDI, 2010. [19] M. Isard, M. Budiu, Y. Yu, A. Birrell, and D. Fetterly. Dryad: Dis\u00adtributed \ndata-parallel programs from sequential building blocks. In Proceedings of EuroSys, 2007. [20] K. Ishizaki, \nM. Kawahito, T. Yasue, H. Komatsu, and T. Nakatani. A study of devirtualization techniques for a Java \nJust-In-Time compiler. In Proceedings of OOPSLA, 2000. [21] M.-Y. Iu and W. Zwaenepoel. HadoopToSQL: \na MapReduce query optimizer. In Proceedings of EuroSys, 2010. [22] B. Jacobs, E. Meijer, F. Piessens, \nand W. Schulte. Iterators revisited: proof rules and implementation, 2005. [23] K. Krikellas, S. D. Viglas, \nand M. Cintra. Generating code for holistic query evaluation. In Proceedings of ICDE, 2010. [24] X. Li \nand G. Agrawal. Ef.cient evaluation of XQuery over streaming data. In Proceedings of VLDB, 2005. [25] \nE. Meijer. Confessions of a used programming language salesman. SIGPLAN Not., 42(10), 2007. [26] C. Olston, \nB. Reed, U. Srivastava, R. Kumar, and A. Tomkins. Pig Latin: a not-so-foreign language for data processing. \nIn Proceedings of SIGMOD, 2008. [27] C. Reichenbach, M. G. Burke, I. Peshansky, and M. Raghavachari. \nAnalysis of imperative XML programs. Information Systems, 34(7), 2009. [28] J. Svenningsson. Shortcut \nfusion for accumulating parameters &#38; zip\u00adlike functions. In Proceedings of ICFP, 2002. [29] R. Tan, \nP. Nagpal, and S. Miller. Automated black box testing tool for a parallel programming library. In Proceedings \nof ICST, 2009. [30] D. Tarditi, S. Puri, and J. Oglesby. Accelerator: using data parallelism to program \nGPUs for general-purpose uses. In Proceedings of ASP-LOS, 2006. [31] P. Wadler. Deforestation: transforming \nprograms to eliminate trees. In Proceedings of ESOP, 1988. \u00b4and J. Currey. DryadLINQ: a system for general-purpose \ndistributed data-parallel computing using a high-level language. In Proceedings of OSDI, 2008. [32] Y. \nYu, M. Isard, D. Fetterly, M. Budiu, U. Erlingsson, P. K. Gunda, [33] Y. Yu, P. K. Gunda, and M. Isard. \nDistributed aggregation for data\u00adparallel computing: interfaces and implementations. In Proceedings of \nSOSP, 2009.    \n\t\t\t", "proc_id": "1993498", "abstract": "<p>Declarative queries enable programmers to write data manipulation code without being aware of the underlying data structure implementation. By increasing the level of abstraction over imperative code, they improve program readability and, crucially, create opportunities for automatic parallelization and optimization. For example, the Language Integrated Query (LINQ) extensions to C# allow the same declarative query to process in-memory collections, and datasets that are distributed across a compute cluster. However, our experiments show that the <i>serial</i> performance of declarative code is several times slower than the equivalent hand-optimized code, because it is implemented using run-time abstractions---such as iterators---that incur overhead due to virtual function calls and superfluous instructions.</p> <p>To address this problem, we have developed Steno, which uses a combination of novel and well-known techniques to generate code for declarative queries that is almost as efficient as hand-optimized code. Steno translates a declarative LINQ query into type-specialized, inlined and loop-based imperative code. It eliminates chains of iterators from query execution, and optimizes nested queries. We have implemented Steno for uniprocessor, multiprocessor and distributed computing platforms, and show that, for a real-world distributed job, it can almost double the speed of end-to-end execution.</p>", "authors": [{"name": "Derek Gordon Murray", "author_profile_id": "81350567399", "affiliation": "University of Cambridge, Cambridge, United Kingdom", "person_id": "P2690506", "email_address": "Derek.Murray@cl.cam.ac.uk", "orcid_id": ""}, {"name": "Michael Isard", "author_profile_id": "81100309298", "affiliation": "Microsoft Research, Mountain View, CA, USA", "person_id": "P2690507", "email_address": "misard@microsoft.com", "orcid_id": ""}, {"name": "Yuan Yu", "author_profile_id": "81100472712", "affiliation": "Microsoft Research, Mountain View, CA, USA", "person_id": "P2690508", "email_address": "yuanbyu@microsoft.com", "orcid_id": ""}], "doi_number": "10.1145/1993498.1993513", "year": "2011", "article_id": "1993513", "conference": "PLDI", "title": "Steno: automatic optimization of declarative queries", "url": "http://dl.acm.org/citation.cfm?id=1993513"}