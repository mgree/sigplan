{"article_publication_date": "06-04-2011", "fulltext": "\n Automated Atomicity-Violation Fixing * Guoliang Jin Linhai Song Wei Zhang Shan Lu Ben Liblit University \nof Wisconsin Madison {aliang,songlh,wzh,shanlu,liblit}@cs.wisc.edu Abstract Fixing software bugs has \nalways been an important and time\u00adconsuming process in software development. Fixing concurrency bugs \nhas become especially critical in the multicore era. How\u00adever, .xing concurrency bugs is challenging, \nin part due to non\u00addeterministic failures and tricky parallel reasoning. Beyond correctly .xing the original \nproblem in the software, a good patch should also avoid introducing new bugs, degrading performance unnecessarily, \nor damaging software readability. Existing tools cannot automate the whole .xing process and provide \ngood-quality patches. We present AFix, a tool that automates the whole process of .xing one common type \nof concurrency bug: single-variable atomicity violations. AFix starts from the bug reports of existing \nbug\u00addetection tools. It augments these with static analysis to construct a suitable patch for each bug \nreport. It further tries to combine the patches of multiple bugs for better performance and code readability. \nFinally, AFix s run-time component provides testing customized for each patch. Our evaluation shows that \npatches automatically generated by AFix correctly eliminate six out of eight real-world bugs and signi.cantly \ndecrease the failure probability in the other two cases. AFix patches never introduce new bugs and usually \nhave similar performance to manually-designed patches. Categories and Subject Descriptors D.1.3 [Programming \nTech\u00adniques]: Concurrent Programming; D.2.5 [Software Engineering]: Testing and Debugging; D.4.1 [Operating \nSystems]: Process Man\u00adagement General Terms Algorithms, Experimentation, Languages, Mea\u00adsurement, Performance, \nReliability, Veri.cation Keywords atomicity violations, automated debugging, concur\u00adrency, critical regions, \ndeadlock, mutex locks, mutual exclusion, patching, static analysis * Supported in part by AFOSR grants \nFA9550-07-1-0210 and FA9550\u00ad09-1-0279; DoE contract DE-SC0002153; LLNL contract B580360; NSF grants CCF-0621487, \nCCF-0701957, CCF-0953478, CCF-1018180, and CNS-0720565; and a Claire Boothe Luce faculty fellowship. \nAny opinions, .ndings, and conclusions or recommendations expressed in this material are those of the \nauthors and do not necessarily re.ect the views of NSF or other institutions. Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. PLDI 11, June 4 8, 2011, San Jose, California, \nUSA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0663-8/11/06. . . $10.00 Thread 1 Thread 2 1 void buf \nwrite(... ) { void buf write(...) { 1 2 int tmp = buf len + str len; int tmp = buf len + str len; 2 3 \nif (tmp > MAX) if (tmp > MAX) 3 4 return; return; 4 5 5 6 memcpy(buf[buf len], memcpy(buf[buf len], 6 \n7 str, str len); str, str len); 7 8 buf len = tmp; buf len = tmp; 8 9 }} 9 Figure 1. Real-world concurrency \nbug from Apache. Interleaving could cause crash. Interleaving could corrupt the log. 1. Introduction \n 1.1 Motivation Bug .xing is an indispensable part of software development. It requires developers to \nunderstand a bug s root cause, design a patch, implement the patch, and .nally validate the patch. This \nprocess consumes a huge amount of resources, especially manual effort, during software development. Krebs \n[15] .nds that it frequently takes more than one month to .nish the .xing process for one bug. Meanwhile, \nthere are endless bugs waiting to be .xed. Software companies such as Microsoft face pressure to release \npatches monthly or even more frequently [24]. Furthermore, patches are error-prone. Even after consuming \nso many development resources, nearly 70% of patches are buggy in their .rst release [7, 31, 33], often \nat great .nancial cost [27]. Self-healing software that .xes its own bugs has long been desired but is \nyet unrealized [11]. The need for automatic repair techniques remains for concurrency bugs. Concurrency \nbugs are synchronization mistakes in multithreaded programs. They are widespread due to software developers \nse\u00adquential thinking habits. Concurrency bugs have already caused real-world disasters [29]. In the current \nmulti-core era, with mul\u00ad tithreaded software becoming pervasive, concurrency bugs are a growing threat \nto software reliability. Many advanced techniques have been proposed for bug detection, software testing, \nand veri.cation to help identify concurrency bugs [9, 25, 37]. However, software reliability does not \nimprove until detected bugs are actually .xed. Unfortunately, .xing concurrency bugs is not trivial and \ndevelopers are left to themselves to face the enormous pressure of .xing ever-so-many concurrency bugs. \nFigure 1 shows an example of a real-world concurrency bug. Ex\u00ad isting bug detectors [5, 25, 37] can accurately \nreport two problematic atomicity violations: (1) when lines 2 and 6 are interleaved ( ) by line 8, Apache \ncould crash; and (2) when lines 6 and 8 are inter\u00ad leaved ( ) by line 8, Apache could corrupt its log. \nUnfortunately, even with accurate bug detection, bug .xing is nontrivial:   To .x the .rst report, \nif we simply lock before line 2 and unlock after line 6, the program could deadlock after buf write exits \nat line 4.  To .x the second report, we should not simply put lines 6 8 and line 8 each into one critical \nregion. As line 8 is part of the critical region for lines 6 8, this would lead to deadlock again.  \nTwo patches that separately .x the above two atomicity viola\u00adtions could deadlock with each other: one \nthread acquires the .rst patch s lock at line 2 and waits for the second patch s lock before line 6; \na different thread acquires the second patch s lock at line 6 and waits for the .rst patch s lock before \nline 8.  Generally speaking, developers face several unique challenges to generate good patches for \nconcurrency bugs. First, concurrency bugs pose unique challenges in understanding their root causes. \nTheir non-determinism makes manual inspection dif.cult. In addition, understanding their root causes \ndemands non-local and parallel thinking. Even with the help of tools for bug detection [4, 12], failure \ndiagnosis [26], and failure replay [39, 42], it is still non\u00ad trivial to understand how to .x a bug s \nroot cause. As a result, it is common that patches released by developers fail to (completely) .x the \noriginal concurrency bug. This happened for two of the eight real-world concurrency bugs used in our \nexperimental evaluation. Second, patches to concurrency bugs often involve synchroniza\u00adtion operations \nthat have non-local impact. As a result, these patches can easily introduce additional bugs, such as \ndeadlocks and data races. As a notorious example, the patch to Mozilla concurrency bug #54743 led to \nnew concurrency bugs in the .eld. Patches for the latter caused further problems, which took more than \none year to .nally .x [14]. Third, patches to concurrency bugs often constrain program interleavings \nor introduce serialization bottlenecks, which could cause unexpected and unnecessary performance degradation. \nBecause of these challenges, long repair times and wrong patches are common for concurrency bugs [20]. \nFuture programming lan\u00ad guages may eventually help developers avoid some of these concur\u00adrency bugs. \nFor now, though, software developers are in great need of immediate support for automatic repair of concurrency \nbugs.  1.2 Contributions In this paper, we build a system, AFix, that automates the whole process of \n.xing one common type of concurrency bug: single\u00advariable atomicity violations [9, 19, 20, 25, 37]. AFix \nleverages existing techniques for bug detection and interleaving testing to bootstrap its .xing process. \nIt uses static analysis and static code transformation to automatically design and implement code patches. \nIt further incorporates run-time monitoring to help developers validate and evaluate each patch it generates. \nThe design of AFix focuses on the challenges encountered by developers in their manual patching process. \nSpeci.cally, AFix tries to .x the original bug without introducing new functionality problems, degrading \nperformance excessively, or harming code readability. Guided by these goals, AFix automates a developer \ns typical bug .xing process. The .rst step is bug understanding. AFix discovers single-variable atomicity \nviolations using CTrigger [25], an existing bug-detection and testing tool which we review further in \nSection 2. The second step is patching one bug. AFix maps the dynamically\u00adbased bug report to static \ncode structures. It conducts static analysis and static code transformation to .x one problem. Correctness \nissues are thoroughly analyzed in this step, which we discuss in Section 3. The third step is patch merging \nand optimization for a set of bugs. AFix collects the patches for each bug report together and statically \nidenti.es patches that can be merged or optimized for better performance or readability. This step is \naddressed in Section 4. The fourth step is patch testing. AFix conducts testing and run\u00adtime analysis \ncustomized for each patch. Testing checks whether the original problem has been .xed and looks for new \nproblems. The low-overhead run-time analysis targets correctness and performance properties that cannot \nbe statically guaranteed or optimized in preceding steps. It provides the developers an option to compare \nand re.ne patches. We discuss this step in detail in Section 5. Overall, this paper makes the following \ncontributions: AFix makes a .rst step in automating the whole process of .xing one common type of concurrency \nbug. AFix can save developers manual bug .xing effort by automatically generating patches or patch candidates \nfor concurrency bugs detected during in-house testing or for concurrency failures discovered during production \nruns. AFix can also help address some tough challenges that usually bother developers. For example, AFix \ncan avoid generating buggy patches. AFix s run-time analysis also helps developers conduct customized \npatch testing and evaluation.  Our experience of applying AFix discovers several limitations of state-of-art \nbug detectors regarding helping bug diagnosis and bug .xing, such as not grouping bugs with the same \nroot cause together and reporting incorrect root causes. We expect this experience to help guide future \nresearch in bug detection.  We evaluate AFix on eight real-world concurrency bugs, with promising results. \nAFix correctly .xes six out of eight reported bugs. For the remaining two bugs, where the root causes \nwere incorrectly reported by CTrigger, AFix patches signi.cantly decrease failure rates. AFix patches \nalso have good readability based on our manual inspection and do not introduce any new bugs. In comparison, \nna\u00a8ive patches cannot .x any of these bugs, and cause deadlocks in seven out of eight cases. Even the \noriginal developers made mistakes in .xing two of these eight bugs. AFix patches also show good performance. \nSoftware patched by AFix is less than 1% slower than the original buggy software for all but one case. \n 2. Background: Bug Detection Using CTrigger AFix is a bug .xer, not a bug .nder. It depends on problem \nreports from existing bug-detection tools to guide its repairs. The high-level ideas in AFix are general \nto all atomicity-violation detectors, but the lower-level details are tuned to the speci.c bug .nder \nused. This section brie.y describes CTrigger: the speci.c concurrency-bug detector and tester used by \nour current AFix implementation. 2.1 CTrigger General Operation CTrigger is an in-house concurrency-bug \ndetection and testing framework [25] that targets single-variable atomicity-violation bugs. As shown \nin Figure 2, when two consecutive accesses that read or write the same shared variable from the same \nthread are interleaved by another access from a different thread, their execution effect may be different \nfrom any serial execution, in which case a single\u00advariable atomicity-violation bug has occurred. An empirical \nstudy by Lu et al. [20] .nds that single-variable atomicity-violation bugs are one of the most common \ntypes of concurrency bug in real code. CTrigger includes a detection phase and a testing phase. Dur\u00ading \nits detection phase, CTrigger monitors a few executions of the concurrent program, predicts what single-variable \natomicity viola\u00adtions could happen in the future under the same input, and outputs the instruction counters \nfor the three instructions involved in each atomicity violation. These three instructions are referred \nto as p (preceding), c (current), and r (remote), as shown in Figure 2. In its testing phase, CTrigger \ntries to force each atomicity violation iden\u00adti.ed above by injecting delays at selected points. If an \natomicity  Thread 1 Thread 2 p : read x  r : write x c : read x  Thread 1 Thread 2 p : write x \n r : write x c : read x  Thread 1 Thread 2 p : read x  r : write x c : write x  Thread 1 Thread \n2 p : write x  r : read x c : write x  Figure 2. Types of atomicity violations that CTrigger detects. \nshows execution order. x is a shared memory location. violation occurs and the program execution fails, \nCTrigger reports the involved (p,c,r) triple. At the end, a list of atomicity violations that can truly \nharm the software are reported. In this project, we use CTrigger bug reports to drive AFix. We will discuss \nhow to extend AFix for general atomicity-violation bugs in Section 3.7. In remainder of this paper, when \nwe talk about atomicity violations, by default, we mean the type of single\u00advariable bugs reported by \nCTrigger. We continue to use p, c, and r to represent the three instructions involved in each atomicity \nviolation, as shown in Figure 2.  2.2 CTrigger Modi.cations and Limitations During the design and evaluation \nof AFix, we modi.ed two aspects of CTrigger to better drive automated bug .xing. First, the original \nCTrigger only reports one (p,c,r) triple for each distinct c instruc\u00adtion, to simplify its design. This \nis probably a good decision for bug detection, but not a good one for bug .xing, because it leads to \nincomplete patches. We modi.ed CTrigger to output all possible combinations. Second, the original CTrigger \nonly reports instruc\u00adtion counters for (p, c, r), which again is problematic in bug .xing, especially \nwhen p and c are inside different functions (discussed in Section 3). Therefore, we modi.ed CTrigger \nto report the complete call stack for each p, c, or r. AFix can be no wiser than the bug detector which \ndrives its .xes. Our CTrigger-based implementation of AFix, then, is affected by a few other features \nof CTrigger. For the most part these are not peculiar to CTrigger, though, but rather are shared with \nother concurrency-bug detection and testing tools. First, separate CTrigger bugs sometimes should not \nbe .xed by separate patches. We discuss this further in Section 4. Second, CTrigger might detect an atomicity \nviolation that is a side effect of another non-atomicity-violation bug. As a result, no matter how well \nAFix .xes the reported CTrigger bug, the software failure may still occur. We discuss this further in \nSection 6.  2.3 A Na\u00a8ive Fixing Scheme Given one CTrigger bug report, a na\u00a8ive patch is to acquire some \nlock before p and r, then release the same lock after c and r. As shown in Figure 1, for many real-world \nbugs, this na\u00a8ive patch would cause problems, such as introducing new bugs, introducing signi.cant and \nunnecessary performance degradation, and hurting code readability. We have implemented this na\u00a8ive .xing \nscheme and compare it with AFix using real-world bugs in Section 6. 3. Fixing One Bug Report This section \ndescribes how AFix .xes a single atomicity violation detected by CTrigger. The next section will discuss \nhow to .x multiple violations together. 3.1 Overview As discussed in Section 2.1, a single CTrigger bug \nreport identi.es an instruction r that may non-serializably interleave two other instructions p and c, \nthereby causing failure. Fixing this bug requires changing the code to ensure that the code region from \np to c is mutually exclusive with r. AFix performs this change in four steps: 1. Put p and c into a critical \nregion. The challenge here is to guarantee that p and c are inside one critical region under all possible \ncontrol .ows, without introducing new bugs. Potential new bugs to avoid include double lock, double unlock, \nunlock without lock, deadlocks, and others shown in Figure 3. We describe how AFix handles this step \nin Sections 3.2 to 3.4. 2. Put r into another critical region. This step can be easily done by adding \na lock-acquisition operation before r and a lock-release operation after r. 3. Make the above two regions \nmutually exclusive with respect to each other. This step involves more than just assigning the same lock \nto both critical sections. We discuss hidden traps and how to avoid them in Section 3.5. 4. Select or \nintroduce a lock to protect the two critical regions. Section 3.6 discusses how a lock is chosen.  \n 3.2 Single-Function Operation We start with an algorithm that decides where to acquire and release locks \nwhen p and c reside in the same function. We further assume that this function is not recursive. Under \nthese restrictions, the algorithm follows a natural strategy: .nd all nodes that are on any path from \np to c, and make sure a lock is held at exactly these nodes. To implement this strategy, AFix .rst analyzes \nthe control-.ow graph to get the set of CFG nodes that are on any intraprocedural path that starts from \np and ends at c without touching p or c in   lock; void foo() { while (...) { lock;  lock; ptr \n= aPtr; ptr = aPtr; if (...) foo(); puts(ptr); puts(ptr); unlock; }  unlock; }  (a) Unreleased \nlock; potential deadlock later (b) Potential double lock or unlock without (c) Potential double lock \nlock Figure 3. Traps in bug .xing. Lock and unlock operations have been placed before and after each \np and c node, respectively. lock; if (gPtr) {  void foo() { puts(gPtr);  lock;  reentrant lock; unlock; \n  while (...) { ptr = aPtr; } else { ptr = aPtr; if (...) foo(); unlock; } puts(ptr); ... puts(ptr); \n reentrant unlock; } unlock; } (a) Added unlock avoids unreleased lock (b) Moved lock avoids double \nlock or unlock (c) Reentrant lock avoids double lock without lock Figure 4. AFix s handling of traps \nfrom Figure 3. Shaded nodes comprise the p c critical region. between.1 We refer to this set of nodes \nas the protected nodes: these are the nodes which will be included in the critical region. The protected \nnodes may be computed as follows: 1. Search forward from p (either depth-or breadth-.rst) without ever \ncrossing beyond c. That is, temporarily treat c as having no successors for purposes of this search. \nCall this set of all forward-reachable nodes P. 2. Search backward from c (either depth-or breadth-.rst) \nwithout ever crossing beyond p. That is, temporarily treat p as having no predecessors for purposes of \nthis search. Call this set of all backward-reachable nodes C. 3. The protected nodes are P nC. This \nis the set of nodes that are reachable from p, and from which c can be reached, without additional crossings \nthrough p or c along the way.  It is not dif.cult to prove that this algorithm correctly identi.es the \nprotected nodes which must form a critical region. Any node in P must be reachable from p without crossing \nany successor edge of c. Conversely, any node in C must be able to reach c without crossing any predecessor \nedge of p. Therefore, any node in P nC must be along a p c path in which p and c respectively appear \nonly .rst and last, never as intermediate nodes. Each depth-or breadth-.rst search requires time at most \nlinear in the number of nodes and edges. Computing the intersection is 1 No p or c in between is because \nCTrigger is designed to report atomicity violations between two consecutive memory accesses to the same \nvariable. likewise at most linear in the number of nodes. Therefore the entire algorithm to identify \nprotected nodes is at most linear in the number of nodes and edges in the CFG for the function containing \np and c. Next, AFix inserts lock-acquisition operations on each edge that crosses from an unprotected \nnode to a protected node, and inserts lock-release operations on each edge that crosses from a protected \nnode to an unprotected one.2 Figure 4 shows the result of applying this approach to the traps from Figure \n3. AFix avoids the .rst trap by inserting a lock release operation for the else clause, and avoids the \nsecond one by moving the lock acquisition operation out of the loop. Handling the third trap requires \nadditional analysis (Section 3.3). AFix patches thus guarantee two important properties. First, the lock \nis not held at any unprotected nodes, because it is released whenever execution crosses from protected \nnodes to unprotected nodes. Second, the lock is held at every protected node, including p and c, because \nit is acquired whenever execution crosses from unprotected nodes to protected nodes. These two properties \nhelp us answer the following questions regarding the suitability of the above critical region as part \nof a bug .x: Are p and c inside the critical region on all paths? Yes, they are. Given any path that \ngoes from p to c, every node on that path must be in the protected node set. The lock is always held \nthroughout any execution along any such path. 2 In practice, to place code on an edge from x to y, create \na new node n and replace the x . y edge with two edges: x . n and n . y. Code intended to appear on the \noriginal x . y edge is placed in the newly-created node n.  Can the added code introduce double-lock \nbugs? No, it cannot. AFix only acquires locks on an edge that crosses from an unprotected node to a protected \nnode. Since the lock is not held at unprotected nodes, double-lock bugs never occur in AFix patches. \nBy contrast, the na\u00a8ive .x suggested in Section 2.3 would easily lead to double\u00ad lock problems, as shown \nin Figure 3b. Can the added code introduce double-unlock or unlock-before\u00adlock bugs? No, it cannot. AFix \nonly releases locks on an edge that crosses from a protected node to an unprotected node. Since the lock \nis held at protected nodes, double-unlock or unlock-before\u00adlock bugs never occur in AFix patches. By \ncontrast, the na\u00a8ive .x suggested in Section 2.3 would easily lead to problems in scenarios like Figure \n3b when the while-loop condition is initially false. Can the added code introduce new data races? No, \nit cannot. The patch does not introduce any new interleavings into the program. Possible thread schedules \nin the patched program must be a subset of those that were already possible in the original program. \nCan the added code introduce new deadlocks? This is a much tougher question to answer. In general, it \nis impractical to prove a C/C++ programs deadlock-free. We address this risk using a mixture of static \nanalysis (Section 3.3) and dynamic monitoring (Section 5.1). Is this the best policy? There could be \nother policies to decide where to add locks and unlocks in order to protect p and c. We have designed \nand implemented several other schemes. Some of them generate smaller critical regions than the current \nAFix does for some special control .ow structures. We prefer to use the current AFix algorithm presented \nabove, because it has a huge advantage in simplicity. It is far easier to reason about and has better \ncompos\u00adability in the interprocedural case than other schemes. The patches generated by it also always \nhave good readability. Furthermore, our experiments never observe any excessive performance degradation \ncaused by the current AFix algorithm.  3.3 Deadlock Analysis and Avoidance AFix statically analyzes \neach critical region to determine whether it includes any potentially-blocking operations. These operations \ninclude lock-acquisitions, condition-wait operations, barriers, thread join operations, and some ad-hoc \nsynchronizations like spin loops. The .rst few of these are easy to identify. To identify ad-hoc spin \nloops, AFix checks whether there is loop inside the critical region, and whether heap or global variables \nare accessed inside the loop. If any such loop exists, we conservatively assume that it might constitute \nan ad-hoc spin loop. This could be made more precise in the future [35, 41], but is suf.cient for AFix \ns current needs. If this analysis .nds no potentially-blocking operations within the critical region, \nthen there is no risk of deadlock and AFix uses standard pthread mutex lock calls to acquire locks. This \nis the case for AFix s handling of the .rst two traps as shown in Figures 4a and 4b. If potentially-blocking \noperations are found, then deadlock is a real risk. In this case, AFix instead acquires locks using pthread \nmutex timedlock: this will time out if it is unable to acquire the lock after some maximum delay. AFix \ns run-time system monitors each timed lock in the patch to identify when our attempted .x has actually \nintroduced a circular wait. This information can help developers re.ne AFix patches. We discuss this \nfurther in Section 5. Currently, we set the time-out delay to a relatively large value: ten seconds by \ndefault. The only disadvantage of long time-out limits is longer latency in discovering any deadlocks \nthat do arise. One subtle issue that is not covered above is recursion. As shown in Figure 3c, double \nlock/unlock and deadlocks could arise in the case of recursive calls. AFix identi.es all such cases using \na simple reachability analysis of the static call graph. When recursion Figure 5. Atomicity violation \nin MySQL. When r executes between p and c, the database log drops an insert log entry. void newlog() \n{ . . . void close() {... p: log = CLOSE; void insert() {.. . r: if (log == OPEN) close(); open(); } \nlogwrite(. . .); .. . . . . } void open() {... c: log = OPEN; } } is possible, we use reentrant (a.k.a. \ncounted or nested) locks. In all other cases, we use non-reentrant locks as these can be faster. AFix \nimplements reentrant locks by associating a mutex.count counter and a mutex.owner thread-ID with each \nreentrant lock mutex. mutex.owner records the thread-ID of the lock s current owner, and mutex.count \nrecords the current nesting level in the owner thread. AFix uses reentrant locks in all scenarios when \nan AFix-added critical region could be called by another AFix-added critical region using the same lock. \nFigure 4c shows how AFix handles the third trap using a reentrant lock. 3.4 Multiple-Function Operation \nAFix s task is more complicated when p and c come from different functions. This is not unusual; Figure \n5 shows one example taken from MySQL. We could use interprocedural analysis in computing the pro\u00adtected \nnode set. For example, context-free language reachability can describe the interprocedurally-valid paths \nfrom p to c with only non p-or-c nodes in between. However, it is generally considered taboo to put matched \nlock and unlock operations in distinct functions due to the poor composability of locks. Examination \nof manually\u00addesigned patches shows that programmers usually add each atomic region s lock acquire and \nrelease statements inside the same func\u00adtion. We comply with this practice by adopting an intraprocedural \napproach that starts and ends each newly-added atomic region inside one function. The extention to the \nbasic algorithm is inspired by the manual approach a developer might take: study the calling contexts \nof p and c, .nd a single common function through which both p and c are reached, and add the critical \nregion to this function. For example, for the bug shown in Figure 5, function newlog is a suitable home \nfor the p c critical region. To carry out the above design, we modify the original CTrigger bug detection \ntool to output the complete call stack for each atomicity violation. AFix compares the call stacks of \np and c, and identi.es the last (innermost) function f on the common pre.x of the two call-stack chains. \nIf p is not already directly in f , then we .nd the call node in f that eventually leads to p in the \nCTrigger bug report. We treat this call node as the p node to be protected. Similarly, we replace c with \nthe call node in f that eventually reaches c. After performing these substitutions, the new p and c must \nboth be contained within f , and AFix proceeds as described in Section 3.2.  3.5 Harmonizing Two Critical \nRegions The process described above yields a critical region protecting all paths from p to c, guarded \nby some lock. A second critical region is created by acquiring and releasing the same lock immediately \nbefore and after r. However, this alone is not enough: some additional analysis is needed to harmonize \nthese two critical regions so that they cooperate without introducing new bugs.  AFix .rst checks whether \nthese two critical regions overlap. Let f be the function containing both p and c, possibly after performing \nthe substitutions in Section 3.4. If f does not appear on CTrigger s call stack for r, then the two regions \ndo not overlap and no additional work is needed. If r appears directly within f , then the two regions \noverlap if r is actually in the set of protected nodes computed earlier. If r is not directly in f but \nf does appear in the call stack leading to r, then identify the speci.c call node in f that leads to \nr, and check whether this call node is in the protected set. Recursion can lead to multiple f on the \ncall chain. Handling this requires a minor extension that if any of the calls in f which lead to r are \nthemselves inside the p c critical region, then the lock operations protecting r are redundant and may \nbe removed. Recall that AFix is working with each speci.c dynamic stack trace reported by AFix s front\u00adend \nbug detector. Therefore, AFix knows the exact call instructions along the call chain, which makes the \nidenti.cation easy. In all cases, the effect is to determine whether reaching r in the stack con.guration \nreported by CTrigger necessarily implies already being inside the p c critical region. If it does, then \nthe lock operations around r are redundant, and may simply be removed. Otherwise, the lock operations \naround r are retained. For example, consider the (line 6, line 8, line 8) atomicity violation depicted \nin Figure 1. A na\u00a8ive patch will put lines 6 8 inside one critical region and line 8 inside another. \nAFix removes the redundant critical region around line 8. Note that we do not guarantee that there is \nno other way to reach r; we only promise to protect r when reached in the speci.c stack con.guration \nreported by CTrigger. If other routes to r avoid the p c critical region and thereby cause additional \nfailures, we assume that additional bug reports from CTrigger will eventually mark these as needing .xes \nas well.  3.6 Lock Selection and Reuse Lastly, AFix decides which lock to use. In our current implementa\u00adtion, \nwhen we only face one bug report, AFix simply creates a new global lock to use at the boundaries of the \np c and r critical regions. One might consider reusing an existing lock. This is especially appealing \nif p and c are already inside a critical region in the original program. Doing this requires identifying \nsome lock that is live and reachable at r and at every edge entering or leaving the p c critical region. \nThis is quite challenging in the general case of heap-allocated locks reached by traversing complex, \nlinked data structures. If r is not even in the same function as p and c, and therefore has access to \ndifferent local variables, the challenge is even greater. Global locks, however, have .xed names. This \nmakes them inviting targets for reuse. We have implemented a simple scheme that identi.es global locks \nthat protect the intended p c critical region in the same function. If some such global lock is identi.ed, \nAFix uses it instead of creating a new lock, and elides inserting additional lock acquire/release statements. \nFor example, when one p c critical region is already protected by a global lock, AFix does not insert \nadditional lock acquire/release statements to protect it. In practice, though, we never .nd any reusable \nglobal locks for the bugs used in our experimental evaluation.  3.7 Implementation Details and Discussion \nImplementation Details AFix implements these static analyses in LLVM [17]. After analysis, AFix changes \nthe target software s LLVM byte-code to apply the patch. In our current implementation, AFix uses locks \nprovided by the POSIX threads (pthread) library to enforce mutual exclusion. A subtle implementation \nissue is that CTrigger describes (p,c,r) triples in terms of executable instruction addresses. To aid \npatch readability, AFix maps each instruction back to source code lines. We never insert lock or unlock \noperations in the lock(L); p: array[1] = 2; for (i = 0; i < 2; i++) { ... p: array[1] = 2; c: array[i] \n= i; for (i=0;i < 2; i++) { unlock(L); ... ... c: array[i] = i; lock(L); ... } } unlock(L); (a) Original \ncode (b) AFix patched Figure 6. Made-up example for the rare case when AFix may fail middle of a source \ncode line, even if this requires slight expansion of critical regions. Assessing patch quality In terms \nof correctness, AFix guarantees not to introduce new bugs. In particular, AFix restricts possible interleavings, \nbut never allows any interleaving that was not already possible before patching. Note that AFix patches \ncould cause temporary circular wait, but thanks to timed locks these do not become deadlocks. AFix can \nsuccessfully .x bugs reported by CTrigger in all but two scenarios. One is that a lock inside an AFix \npatch may time out if AFix cannot statically prove deadlock-freedom, and atomicity is no longer guaranteed \nwhen the lock does time out. This case is captured by the AFix run time and feedback will be provided \nfor further patch re.nement. The other case is very rare. It occurs when p or c has more than one dynamic \ninstance and may access different memory locations. In this situation, the p c pair that requires protection \nmay not be the consecutive ones protected by AFix. This case is theoretically possible, but very rare \nin reality. Figure 6 shows one made-up example. In this example, p is followed by two dynamic instances \nof c. The .rst instance accesses a different variable from p, while the second instance accesses the \nsame variable as p. AFix puts p and the .rst dynamic instance of c into the critical region, as shown \nin Figure 6b, and the control .ow could leave the protected region between the two instances of c. However, \nwhat should be in the critical region is p and the second dynamic instance of c. In this extremely rare \nexample, AFix patch will mistakenly end the critical region before the second instance of c. In terms \nof performance, AFix patch strives to avoid introducing unnecessary performance degradation. AFix always \nends a critical region immediately when there is no hope to reach c. Of course, for speci.c bugs, there \ncould be faster patches by using lock-free data structures, reader-writer locks, etc. Crafting a general \nalgorithm for using these special tricks is left for future work. Extending AFix AFix focuses on locks, \nbecause they are the most commonly supported and used synchronization primitives in mul\u00adtithreaded programs. \nAFix could be easily extended to other prim\u00aditives that support atomicity. For example, if we use transactional \nmemory, then the analysis to determine where to lock and unlock is suitable for deciding where to begin \nand end transactions. Of course, some detailed concerns will be different. For example, concerns over \ndeadlocks and lock selection go away, while new concerns arise over live-lock and I/O inside transactions. \nAlthough our algorithm description and current AFix implemen\u00adtation is for CTrigger, the AFix algorithm \ncan be easily extended to work with other atomicity-violation bug detectors including those for multi-variable \natomicity-violation bugs. Bug reports from many atomicity-violation detectors can be generalized as code \nregion X needs to be mutually exclusive with code region Y . With this knowledge, a patch can be generated \nusing the AFix algorithms  lock(L1) p1 lock(L2) lock(L1) lock(L1) p2 p1 p1 c1 lock(L2) lock(L2) unlock(L1) \np2 p2 lock(L1) c2 c1 r1 unlock(L2) unlock(L1) unlock(L1) c1 c2 c2 unlock(L1) unlock(L2) unlock(L2) (a) \nEliminating (b) Improving readability (c) Avoiding deadlock redundant locks and performance Figure 7. \nScenarios where patches should or must be merged discussed above: select one function to add lock/unlock \noperations, determine where inside that function to add lock/unlock operations, analyze the necessity \nof reentrant and timed locks, harmonize two critical regions, etc. 4. Fixing Multiple Bug Reports Bug \ndetectors often report multiple bugs that should be .xed by one patch, such as the two atomicity violations \nin Figure 1 and the scenarios depicted in Figure 7. This section describes how AFix coordinates multiple \n.xes in order to improve patch quality. Provided with a set of bug reports, AFix .rst designs patches \nfor each bug independently. Before applying these patches to the software, AFix considers all patches \ntogether. If one patch subsumes another, as shown in Figure 7a, the redundant patch is discarded. If \ntwo patches have overlapping critical regions, as shown in Figures 7b and 7c, AFix will further analyze \nhow to merge the patches. 4.1 Removing Redundant Patches AFix creates two critical regions for each bug \ntriple (p,c,r): one containing p and c, and one containing r alone. Strictly speaking, a patch is completely \nredundant if both of its critical regions can be subsumed by another patch. Sometimes, a patch s p c \nregion is subsumed by another patch, but its r region is not. Since the r region is extremely short, \nAFix still chooses to discard the subsumed p c critical region in this situation. The lock used to protect \nr will be changed to the lock used in the subsuming patch. Under AFix s locking policy, a critical region \np c is subsumed ' by another critical region p c' if and only if the set of CFG nodes ' in p c critical \nregion is a subset of those in p c'. The reasoning ' is clear. The lock for p c' is held at every node \ninside its critical ' region. If all p c nodes are contained within p c', then the p c lock is redundant. \nThe above conditions are straightforward to check for two critical regions in the same function intraprocedurally. \nFor two regions in different functions, AFix extends the above subsuming conditions interprocedurally \nas follows. First, let f denote the function containing critical region p c, and let f ' denote the function \n' containing critical region p c'. Let n be the call node inside f' that eventually leads to f (and therefore \nto p c), if such a node exists. ' Then p c' subsumes p c if and only if 1. f' is in the common pre.x \nof p and c s call stacks, and '  2. n is inside the p c' critical region.  Notice that both f and f \n' are in the common pre.x of p and c s call stacks, and f is chosen by our critical region identi.cation \nalgorithm, so we know that f is closer to p and c than f ' on the common pre.x of p and c s call stacks. \nSince we have modi.ed CTrigger to provide the complete call\u00adstack information, the above analysis is \nnot dif.cult. Note that the simplicity of our interprocedural subsumption analysis bene.ts from AFix \ns policy requiring that each critical region s locks and unlocks appear within the same function. Overall, \nAFix compares each pair of patches and deletes the redundant ones.  4.2 Merging Related Patches The \ngeneral problem of patch merging can be described as follows. Given a set of critical regions, some guarded \nby the same lock and some by different locks, how can we adjust the lock variables and the critical-region \nboundaries to achieve the best balance of performance, readability, and correctness? This question rarely \nhas a provably-optimal answer, because performance is affected by many factors. These include but are \nnot limited to the length of each critical region, the cost of acquiring and releasing a lock, how many \nthreads will execute each critical region, and how much contention each lock-acquisition will face. Much \nof this cannot be decided statically. Facing this challenge, AFix uses a simple heuristic to decide when \nand how to merge critical regions. We should note that although we believe this scheme can achieve a \ngood balance between performance, readability, correctness, and analysis simplicity, there is no .rm \nguarantee of performance improvement going from non\u00admerged to merged patches. Developers can make informed \ndecisions based on AFix s run-time performance pro.ling results. Different merging policies can also \nbe plugged into AFix in the future. 4.2.1 When to Merge AFix merges patches when one patch s lock-protected \ncritical regions include the p, c, or r nodes of another patch. More formally, consider two sets of nodes \nfor any given patch i. Let Anchorsi represent the set of all nodes anchoring this patch. Initially this \nconsists of just {pi, ci,ri}: the set of nodes representing the original bug for which this patch was \ncreated. Let Criticali represent the set of all nodes contained in critical regions guarded by patch \ni s lock. Initially this will consist of ri (as a single-node critical region) along with pi, ci, and \nany other protected nodes along pi ci paths as computed in Section 3.2. For any two patches i, j, if \nAnchorsi nCritical j 0, then patches = /i and j should be merged. In other words, if the critical regions \nof one patch include any of the anchor nodes of another, then the two patches should be combined into \none. Let the Anchors and Critical sets of this merged patch be the unions of the corresponding sets for \nthe patches being merged. A single lock will guard all nodes in the combined Critical set. This merged \npatch is available for further merging; the process continues until the original patch collection has \nbeen collapsed into a (possibly) smaller one in which no patch s p, c, or r nodes are contained in the \nlock-guarded critical regions of any other.  4.2.2 Merging Two Critical Regions Once AFix decides to \nmerge, it enacts the merge in two steps: 1. Update the positions of lock and unlock operations. AFix \nputs an unlock operation on every edge that exits the merged Critical set, and a lock operation at every \nedge that enters the Critical set. This has the effect of removing all redundant lock and unlock operations \namong merged patches. 2. Unite lock variables. AFix arbitrarily chooses one lock variable to use and \nputs this variable into every lock and unlock operation performed by the merged patch.  For example, \nAFix merges the two critical regions in Figure 7b, and deletes unlock(L1) and lock(L2). Similarly, AFix \nalso merges the three critical regions in Figure 7c, and discards all but the .rst lock(L1) and the last \nunlock(L2), thereby eliminating the potential deadlock. For the bug shown in Figure 1, the .nal merged \npatch has just one lock operation inserted before line 2, and two unlock operations inserted before line \n4 and after line 8.  The above merging process is only used for critical regions in\u00adside the same function. \nActually, it covers the intraprocedural case of redundant patch removal from Section 4.1: if a patch \nis subsumed by another patch in the same function, they will be merged based on AFix s merging policy. \nCurrently, AFix .rst conducts interproce\u00addural redundant-patch removal and then conducts intraprocedural \npatch merging. If some other merging policy is adopted in the future, intraprocedural redundant-patch \nremoval may still be needed.  4.2.3 Bene.ts of Merging Merging patches as described above has several \nbene.cial effects on patch quality: Code readability is improved. In practice, it is common that many \natomicity violations are reported within few lines of code, such as the Apache case shown in Figure 1. \nUsing many different locks severely hurts code maintenance and readability.  Performance can usually \nimprove due to fewer lock and unlock operations without enlarging the critical region too much, such \nas in Figure 7. Of course, there is no guarantee of performance improvement, because merging can also \nreduce potential con\u00adcurrency in certain scenarios.  Correctness is either the same or improved, because \nwe have larger critical regions now. In fact, Section 6 reports that this helps AFix lower the failure \nrates of some real-world software bugs that were inaccurately reported by CTrigger.  Deadlock risk is \nreduced. It is easy to have one patch deadlock with another patch, as shown in Figure 7c. Merging solves \nthis problem. Under AFix s merging policy, holding one AFix lock and trying to acquire another AFix lock \nis impossible, because these two locks would have been merged.  5. Run-Time Monitoring and Feedback \nNot all properties can be guaranteed statically. AFix collects addi\u00adtional information at run time to \nhelp developers re.ne patches. 5.1 Deadlock and Performance Monitoring AFix uses time-outs for lock acquisitions \nthat cannot be guaranteed to be deadlock-free as discussed in Section 3.3. Therefore, deadlocks caused \nby AFix patches manifest as lock time-outs. Of course, a time-out could also occur without deadlock: \na lock may simply encounter too much contention and require a longer waiting period. AFix implements \ntwo run-time deadlock-detection algorithms, through LLVM byte-code rewriting, suitable for different \nusage scenarios. The .rst, suitable for in-house patch testing, reports whether a deadlock has occurred \nimmediately after a time-out. It has small overhead at each lock/unlock operation. The second deadlock \ndetector, suitable for production-run deployment, has nearly zero overhead if there is no AFix lock time-out. \nIt takes a little bit longer to complete deadlock diagnosis. In the .rst scheme, AFix follows the traditional \ndeadlock\u00addetection algorithm: it maintains a resource graph and looks for cycles when an AFix-added lock \ntimes out. To maintain a resource graph, AFix monitors every lock acquisition, lock release, and condition-variable \nsignal and wait, all from the beginning of execu\u00adtion. Its overhead, then, depends on the density of \nthese operations. In the second scheme, AFix starts its monitoring and analysis only after an AFix lock \ntimes out, a moment that we will refer to as T . AFix uses information collected after T to recover the \nresource graph at the moment of T , as follows. When some thread t releases a lock l, AFix checks whether \nit also saw t return from a lock(l) call. If not, then l must have been acquired by t sometime before \nT , and therefore was held by t at the moment of T . Right after a lock l is acquired by thread t, AFix \nchecks whether it has observed t begin a lock(l) call. If not, then t must already have been waiting \nfor l at the moment of T . Eventually, AFix will recover the whole resource graph and report whether \nthere was a deadlock. This post time-out monitoring ends when either a deadlock is identi.ed or the program \nexits. If the program encounters another AFix lock time-out, AFix will work on recovering multiple resource \ngraphs at the same time. Since AFix lock time-outs are rare after in-house patch testing, this scheme \nis well-suited to monitoring production runs. Of course, AFix s run-time system could miss a deadlock \nif the deadlock involves ad-hoc synchronization, such as spin loops. This is an open problem for all \ndeadlock detection tools. Currently, AFix relies on developers to re.ne the patch using its deadlock-detection \nresults. When a time-out is diagnosed as a non-deadlock, developers may want to extend the time-out threshold \nin related AFix locks. When the time-out is caused by deadlock, developers could discard this patch and \nchoose another, such as a patch that has some critical regions merged. AFix s run-time can also be combined \nwith previous deadlock-prevention systems [13] to automatically .x patch-induced deadlocks in the future. \nOther than deadlock monitoring, AFix also supports performance pro.ling during in-house testing. In pro.ling \nmode, AFix measures the waiting time and the number of time-outs for each lock acqui\u00adsition inside an \nAFix patch. If excessive waiting time or time-outs are observed at a critical region that merges multiple \nbug reports patches, developers may want to split this big critical region to reduce lock contention \nand improve performance.  5.2 Patch Testing Each patch generated by AFix undergoes two testing phases. \nThe .rst phase uses the existing CTrigger testing. CTrigger provides a noise injection scheme for each \nbug it reports. Through a binary instrumentation framework [22], CTrigger deterministically calls sleep \nbefore or after speci.c instructions: before c, after p, etc. We apply CTrigger testing to AFix-patched \nsoftware and see whether software failures could still occur. The second patch testing phase is a more \ngeneral interleaving test implemented by us. Before executing every instruction inside an AFix critical \nregion, a random number generator decides whether to sleep or not. Similar random delays are also inserted \nright before the locks and right after the unlocks added by AFix. The sleep probability and the length \nof the sleep are tunable knobs. This phase can help identify patches that fail to completely .x the bug \ndue to bug-detection limitations of CTrigger. 6. Experimental Results AFix is implemented using LLVM \nversion 2.7. Experiments are performed on an eight-core Intel Xeon machine running Red Hat Linux 5 with \nkernel version 2.6.18. We evaluated AFix on eight real-world bugs from six open\u00adsource applications. \nThese bugs were all initially reported by soft\u00adware users to each application s bug database or mailing \nlist. We apply CTrigger to these applications using the bug-triggering inputs described in the user bug \nreports. In each case, CTrigger detects one or more (p,c,r) triples. We have con.rmed that atomicity \nviolations described by each triple lead to failure symptoms matching users descriptions. Table 1 gives \nadditional information about these bugs, applications, and CTrigger detection results. For each bug listed \nin Table 1, AFix generates two versions of patched software: one with the patch-merging technique presented \nin Section 4 applied and one without. We refer to the former as Table 1. Bugs used in experimental evaluation. \nDeveloper .x time is the time between developers .rst response to a bug report and a correct patch checked \nin, if known. Mozilla-JS is the JavaScript Engine of Mozilla. *: incorrect patches were submitted during \nthis period. r: the bug was reported by developers who suggested a .xing strategy in the initial bug \nreport.  Developer # CTrigger Bug ID Application LoC Fix Time Reports FFT FFT 1.2K N/A 5 PBZIP2 PBZIP2 \n2.0K N/A 4 Apache Apache 333K 30 days 2 MySQL1 MySQL v4.0.12 681K 10 days 1 MySQL2 MySQL v4.0.19 693K \n13 days* 2 Mozilla1 Mozilla2 Cherokee Mozilla-JS v1.4.2 Mozilla-JS v1.5 Cherokee v0.9.2 87K 108K 83K \n12 days* > 3 daysr > 1 dayr 2 1 4 Bug ID na\u00a8ive unmerged merged manual FFT--? . PBZIP2---. Apache --.. \nMySQL1 -. .. MySQL2 -.. ? Mozilla1 -.. ? Mozilla2 -. .. Cherokee -. .. Table 2. Overall patch quality \nthe merged version and the latter as the unmerged version. We also compare AFix with two other versions \nof patched software: (1) the patch manually generated by developers, referred to as manual, and (2) the \nna\u00a8ive patch described in Section 2.3, referred to as na\u00a8ive. Our experiments also compare the above \npatched versions with the original buggy software, referred to as original. Our evaluation considers \nthree aspects of patch quality: Correctness. We use CTrigger testing and intensive random noise injection \nto check whether the bug has been .xed and whether new bugs are introduced. We report and compare the \nfailure rates of different versions of software. We also use the AFix run time to check whether timed-out \nlocks actually represent deadlocks. Performance. We measure the performance of different versions of \npatched or unpatched software. We also measure how long it takes AFix to perform its static analysis \nand patch insertion. Code readability. We manually compare AFix patches with the manual patch. We present \nresults through case studies. 6.1 Overall Results Table 2 presents a compact summary of patch quality. \n. indi\u00adcates that the original bug is .xed, no new bug is observed, and performance degradation is negligible. \n? indicates that the patch is incomplete, but decreases the failure rate without hurting perfor\u00admance. \n- marks cases where the .x introduces new bugs, does not signi.cantly reduce the failure rate, or imposes \nan intolerable performance de.ciency. For manual patches, ? means develop\u00aders submitted intermediate \npatches that are later determined to be incomplete by developers or testing groups (i.e., the original \nsoft\u00adware failure can still occur with the patch applied). . means that the .rst developer-submitted \npatch is complete. For the bugs in our study, developers submitted no patch that could introduce new \nBug ID original na\u00a8ive unmerged merged FFT 74% 73% 87% 30% PBZIP2 94% 100%* 66% 20% Apache 85% 100%* \n83% 0% MySQL1 41% 100%* 0% 0% MySQL2 53% 100%* 0% 0% Mozilla1 41% 100%* 0% 0% Mozilla2 48% 100%* 0% 0% \nCherokee 81% 100%* 0% 0% Table 3. Failure rates under interleaving testing. 100%* marks cases where the \ntest input deterministically causes deadlock. bugs or intolerable performance de.ciencies. We obtained \nthe above information from corresponding Bugzilla records. Patches generated with merging are highly \ncompetitive with manually-generated patches. AFix successfully .xes six out of eight bugs. In two cases, \nMySQL2 and Mozilla1, merged patches are even better than the .rst few patches generated by developers. \nFor FFT and PBZIP2, AFix is limited by CTrigger s inaccurate root-cause identi.cation. Even here, the \nmerged patches reduce (but cannot entirely eliminate) failures. Unmerged patches .x .ve out of eight \nbugs. Deadlock prevents this from .xing the Apache bug that merging does correctly .x. The na\u00a8ive approach \n.xes no bug. It causes deadlock in all but FFT, and fails to .x FFT due to CTrigger inaccuracy.  6.2 \nCorrectness Results Table 3 shows the failure rates of different versions of software under random noise-injection \ntesting (Section 5.2). We set up exactly the same noise injection environment for all versions of software \nfor each bug: the same program region to inject random noise, which is around the buggy code region; \nthe same sleep probability; and the same sleep length. We use slightly different sleep probabilities \nand sleep lengths for different bugs, because we want to make sure the testing is intensive enough to \nmake the original unpatched software fail frequently. This lets us effectively evaluate whether the patches \nare useful. We execute each version of software 100 times. Merged patches eliminate software failures \nfor six out of eight bugs in our testing. Merging provides incomplete patches for FFT and PBZIP2, but \ndrops failure rates from 74% to 30% in FFT and from 94% to 20% in PBZIP2. The failure rates do not drop \nto 0% because CTrigger s bug detection is inaccurate: atomicity violation is a side effect but not the \nroot-cause of these two bugs. Speci.cally, following a CTrigger report (p,c,r), merging correctly ensures \nthat r does not execute between p and c. However, the real problem in FFT is that r should not execute \nafter either p or c, while the problem in PBZIP2 is that r should execute after both p and c. Merging \ncan only partially .x these two problems. Unmerged patching behaves slightly worse than merged, elimi\u00adnating \nfailures for .ve out of eight bugs. It leads to non-deterministic deadlocks in Apache and PBZIP2 due \nto the reason depicted in Fig\u00adure 7c. Once the lock times out after a deadlock, atomicity violation and \nsubsequent failure can still occur. For FFT, unmerged patching has a much larger failure rate than merged \ndue to its smaller critical\u00adregion size. In FFT, the bug occurs when an instruction r executes after \nany one of a set of six instructions. Merging puts all six into one critical region, making the bug less \nlikely to occur. Na\u00a8ive patching is clearly a very bad choice, leading to deadlock in seven out of eight \nbugs. There are several different reasons for these deadlocks. For MySQL2 and PBZIP2, deadlocks are caused \ndue to intraprocedural control .ows, as depicted in Figure 3. For MySQL1 and Mozilla1, p and c are inside \ndifferent functions. Locking in one function and unlocking in another easily causes Bug ID na\u00a8ive unmerged \nmerged manual  FFT -0.02% -0.07% -0.02% 0.19% PBZIP2 N/A 89,132% 181.82% 0.20% Apache N/A 0.45% -0.97% \n-0.26% MySQL1 N/A 0.48% 0.48% 0.45% MySQL2 N/A -0.09% -0.09% 1.02% Mozilla1 N/A 0.49% 0.55% 0.12% Mozilla2 \nN/A -0.40% -0.40% -0.20% Cherokee N/A -1.02% -1.04% 0.39% deadlocks when the .rst function is called \ntwice without the second function in between. In Apache, Cherokee, and Mozilla2, na\u00a8ive double-lock bugs \narise because r is inside a p c region. Apache and PBZIP2 also deadlock among different locks added by \nthe patch. We also reapplied CTrigger to the patched code. According to CTrigger s de.nitions, both merged \nand unmerged patches success\u00adfully .x all eight bugs. We also manually checked all these patches. Our \n.ndings are consistent with the random testing results. In those cases with 0% failure rates, the bugs \nare all truly .xed. Overall, merging generates correct patches that not only .x the original bugs but \nalso introduce no new bugs, as long as its front-end bug detector provides a reasonably-accurate bug \nreport. Unmerged patching is also good, but is vulnerable to deadlock.  6.3 Performance Results Patched \napplication performance Table 4 shows that merged and unmerged AFix .xes provide good run-time performance, \nwith negligible difference between them. Note that overheads cannot be measured for most na\u00a8ive patches \nas these lead to deterministic deadlocks. In most cases, AFix patches impose no perceivable performance \ndegradation compared with correct manual patches or even the original buggy software. This is because \nthe relevant critical regions are usually small and off performance-critical paths. Only PBZIP2 suffers \nfrom signi.cant performance degradation under AFix. The PBZIP2 bug is caused by a parent thread occa\u00adsionally \ndestroying shared objects before worker threads .nish. The manual patch makes the main thread wait until \nall worker threads are done, which is correct and lightweight. Due to CTrigger inaccuracy, AFix mistakenly \ntreats this bug as an atomicity-violation bug, and .xes it by putting almost the whole worker thread \ninto a critical region, which causes huge overhead. The unmerged AFix patch is much slower than the merged \npatch for PBZIP2, because the former suffers from deadlock time-outs. Deadlock time-outs can also occur \nin the unmerged patch of Apache, but this never happens during performance evaluation without noise injection. \nAFix patch generation performance All of AFix s static analyses have been designed with scalability in \nmind. On every benchmark, AFix takes no more than one second to analyze the program, develop its patches, \nand inject them into the code. Clearly, AFix has the potential to signi.cantly speed up the bug-.xing \nprocess. 6.4 Readability Case Studies AFix s patch merging technique improves patch readability and \nmaintainability. For six out of eight bugs, CTrigger reports two to .ve atomicity violations related \nto each bug. The unmerged .x therefore adds two to .ve new locks and up to ten new critical regions into \nthe software. Merging simpli.es this to use just one lock in .ve out of six cases. Manual inspection \nshows that all merging decisions made by AFix improve readability. Taking the Cherokee bug as an example, \nCTrigger reports four atomicity violations in three different functions. The unmerged .x therefore adds \nfour global lock variables, six lock operations, and seven unlock operations into the software. AFix \n.nds some of these critical regions to be redundant and some to be mergeable. The .nal patch requires \nonly one lock, one lock operation, and one unlock operation, for excellent code readability and maintainability. \nIn fact, the merged patch closely resembles the manual patch.  6.5 Other Results AFix s run-time deadlock \ndetection gives accurate results for both merged and unmerged patches. For example, in PBZIP2, both merged \nand unmerged strategies encounter lock time-outs. The AFix run-time system correctly determines that \nthe time-outs in the unmerged patch are caused by deadlocks among patches, but that the time-outs in \nthe merged patch are not. Rather, merging simply has produced large critical regions with much lock contention, \nand therefore requires longer time-outs. AFix s post time-out deadlock-detection algorithm exhibits excellent \nperformance on all bugs. Its overhead is already included in the performance numbers measured in Table \n4. AFix s always-on deadlock detection has less than 5% overhead for all bugs except for Mozilla1 and \nMozilla2, where the always-on monitoring causes 300% and 97% overhead respectively. This is due to the \nfrequent lock/unlock operations in Mozilla s JavaScript Engine. 7. Related Work 7.1 Concurrency Bug \nDetection Many detection tools have been built to identify interleaving prob\u00adlems in multithreaded programs, \nsuch as races [4, 6, 10, 12, 32] and atomicity violations [9, 12, 19, 37]. These tools provide good starting \npoints for automated bug .xing. Of course, since these tools are designed to identify problems, not \nto .x problems, they still leave many challenges for bug .x\u00ading. For example, many bug detection tools \nhave false positives. Fixing false positives leads to over-synchronization and unnec\u00adessary performance \ndegradation. Many bug reports do not include complete run-time information, which could cause wrong or \nincom\u00adplete patches. Bug detectors seldom put bug reports that can be .xed by one patch together, which \ncan cause too many locks to be added, harming code maintainability. Furthermore, na\u00a8ive patches for accurately-described \nbug reports can easily introduce new bugs. AFix has considered and addressed the challenges above. In \nthe future, AFix can be extended to work with more concurrency-bug detectors to .x more bugs, which will \nalso help bug-detection tools to get more usage during software development.  7.2 Concurrent Program \nSynthesis Existing tools that automatically add synchronizations to software mostly have different goals \nfrom AFix, and hence different foci. Pro\u00adgram synthesis and sketching [8, 34, 38] use smart state-space \nsearch and veri.cation techniques to infer synchronization and make con\u00adcurrent programs satisfy certain \nspeci.cations. They are powerful in the sense that the speci.cation can be .exible. Unfortunately, the \nnature of the problem makes them hard to scale to large real-world C/C++ applications such as the ones \n.xed by AFix. Some tools [23, 37] encourage programmers to represent their synchronization intentions \nin non-lock language constructs, such as atomic sets and atomic blocks, and transparently translate these \nnon-lock constructs to lock/unlock operations. In these cases, the critical region boundaries are either \ndirectly speci.ed by developers or .xed at the entrances and exits of certain functions; the major challenge \nis lock assignment. AFix, by contrast, derives critical region boundaries with limited or no human intervention. \nTraceFinder [36] performs whole-program synchronization anal\u00ad ysis and pointer-alias analysis to identify \natomic-block boundaries that can guarantee con.ict-serializability for the whole software. TraceFinder \nhas a different goal from AFix. It cannot scale to large applications. It uses atomic blocks for synchronization, \nand does not worry about lock assignment or deadlocks.  AFix is unique in .xing bugs reported by automatic \nbug\u00addetectors. AFix does not face the scalability problems encountered by TraceFinder, because it does \nnot try to .gure out all the syn\u00adchronizations a program needs to use. Rather, AFix faces different challenges. \n 7.3 Hot-Patching Concurrency Bugs at Run Time Some proposed strategies for hot-patching software at \nrun time are not suitable for concurrency bugs [28]. Recent work by Wu et al. [40] provides a framework \nto deploy hot patches manually designed by developers. AFix can complement this framework by generating \npatches automatically, instead of completely relying on developers. Some run-time tools do not try to \npermanently .x concurrency bugs in the software. Rather, they steer the execution to make fail\u00adure less \nlikely. Some pay the cost of performance degradation or require non-existing hardware support [21]. Others \nassume that critical-region boundaries are known [16, 30]. Deterministic exe\u00ad cution systems [1 3] can \nmake some concurrency bugs determin\u00adistically happen and some other bugs never occur. This promising \napproach still faces many challenges, such as run-time overhead, in\u00adtegration with system non-determinism, \nlanguage design, etc. Even for software executed inside a deterministic run-time, .xing bugs still requires \nmanual intervention. In general, these tools look at different problems from AFix. AFix generates patches \nthat can com\u00adpletely .x bugs without unnecessary performance degradation. AFix and these tools can complement \neach other. Kivati [5] combines run-time bug detection with temporary patch generation based on hardware \nwatch-points. Its focus is to lower bug detection overheads. However, the limited watch-point resource \n(four per machine) prevents Kivati from managing many different critical regions at the same time. Kivati \ndoes not handle cases where p and c are inside different functions, such as the Cherokee and MySQL1 bugs \nin Section 6. It causes unnecessarily long critical regions when there are branches between p and c, \nas shown in Figure 3a. It also does not handle critical-region merging or deadlocks. Overall, Kivati \nlacks the off-line static analyses needed to generate high-quality, permanent .xes. AtomRace [16, 18] \ncombines run-time bug detection with run\u00ad time healing, with emphasis on bug detection. Its healer component \nassumes that critical-region entrances and exits are all provided as inputs. They do not address those \nchallenges faced by the na\u00a8ive patches discussed in our paper, and do not consider patch merging. 8. \nConclusion We have described AFix, a framework for automatically .xing a common type of concurrency bugs. \nWe have implemented the system and shown AFix to be effective at generating high-quality patches for \natomicity-violation bugs detected by an automated bug .nder in several large, real-world applications. \nAFix conducts thorough static analysis to reach a good balance among correctness, performance, and code \nreadability in its automatically generated patches. AFix s testing and monitoring run-time system also \nprovide useful feedback for further patch re.nement. In the future we plan to extend AFix to work with \nmore general synchronization primitives and more types of concurrency bug detectors. References [1] A. \nAviram, S.-C. Weng, S. Hu, and B. Ford. Ef.cient system-enforced deterministic parallelism. In OSDI, \n2010. [2] T. Bergan, N. Hunt, L. Ceze, and S. D. Gribble. Deterministic process groups in dOS. In OSDI, \n2010. [3] E. D. Berger, T. Yang, T. Liu, and G. Novark. Grace: safe multithreaded programming for C/C++. \nIn OOPSLA, 2009. [4] M. D. Bond, K. E. Coons, and K. S. McKinley. Pacer: Proportional detection of data \nraces. In PLDI, 2010. [5] L. Chew and D. Lie. Kivati: fast detection and prevention of atomicity violations. \nIn EuroSys, 2010. [6] J.-D. Choi, K. Lee, A. Loginov, R. O Callahan, V. Sarkar, and M. Srid\u00adharan. Ef.cient \nand precise datarace detection for multithreaded object\u00adoriented programs. In PLDI, 2002. [7] C. Cowan, \nH. Hinton, C. Pu, and J. Walpole. The cracker patch choice: An analysis of post hoc security techniques. \nIn In Proceedings of the National Information Systems Security Conference (NISSC), 2000. [8] J. Deshmukh, \nG. Ramalingam, V. P. Ranganath, and K. Vaswani. Logical concurrency control from sequential proofs. In \nEuropean Symposium on Programming, 2010. [9] C. Flanagan and S. N. Freund. Atomizer: a dynamic atomicity \nchecker for multithreaded programs. In POPL, 2004. [10] C. Flanagan and S. N. Freund. FastTrack: ef.cient \nand precise dynamic race detection. In PLDI, 2009. [11] M. Harman. Automated patching techniques: the \n.x is in: technical perspective. Commun. ACM, 53(5):108 108, 2010. ISSN 0001-0782. doi: http://doi.acm.org/10.1145/1735223.1735248. \n[12] G. Jin, A. Thakur, B. Liblit, and S. Lu. Instrumentation and sampling strategies for Cooperative \nConcurrency Bug Isolation. In OOPSLA, 2010. [13] H. Jula, D. Tralamazza, C. Zam.r, and G. Candea. Deadlock \nimmunity: Enabling systems to defend against deadlocks. In OSDI, 2008. [14] E. Kandrot and B. Eich. Our \nJavaScript is 3x slower than IE s, Sept. 2000. URL https://bugzilla.mozilla.org/show bug.cgi?id=54743. \n[15] B. Krebs. A time to patch II: Mozilla. The Washington Post Security Fix blog, Feb. 2006. URL http://voices.washingtonpost.com/security.x/ \n2006/02/a time to patch ii mozilla.html. [16] B. Krena, Z. Letko, R. Tzoref, S. Ur, and T. Vojnar. Healing \ndata races on-the-.y. In PADTAD, 2007. [17] C. Lattner and V. Adve. LLVM: A compilation framework for \nlifelong program analysis &#38; transformation. In CGO, 2004. [18] Z. Letko, T. Vojnar, and B. K.rena. \nAtomRace: data race and atomicity violation detector and healer. In PADTAD, 2008. [19] S. Lu, J. Tucek, \nF. Qin, and Y. Zhou. AVIO: Detecting atomicity violations via access-interleaving invariants. In ASPLOS, \n2006. [20] S. Lu, S. Park, E. Seo, and Y. Zhou. Learning from mistakes a comprehensive study of real \nworld concurrency bug characteristics. In ASPLOS, Mar. 2008. [21] B. Lucia, J. Devietti, L. Ceze, and \nK. Strauss. Atom-Aid: Detecting and surviving atomicity violations. IEEE Micro, 29(1), 2009. [22] C.-K. \nLuk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney, S. Wallace, V. J. Reddi, and K. Hazelwood. Pin: \nbuilding customized program analysis tools with dynamic instrumentation. In PLDI, 2005. [23] B. McCloskey, \nF. Zhou, D. Gay, and E. Brewer. Autolocker: synchro\u00adnization inference for atomic sections. In POPL, \n2006. [24] Microsoft. Revamping the microsoft security bulletin release process, Feb. 2005. URL http://www.microsoft.com/technet/security/bulletin/ \nrevsbwp.mspx. [25] S. Park, S. Lu, and Y. Zhou. CTrigger: exposing atomicity violation bugs from their \nhiding places. In ASPLOS, 2009. [26] S. Park, R. W. Vuduc, and M. J. Harrold. Falcon: fault localization \nin concurrent programs. In ICSE, 2010. [27] R. Pegoraro. Apple updates Leopard again. Washington Post, \nFeb. 2008.  [28] J. H. Perkins, S. Kim, S. Larsen, S. P. Amarasinghe, J. Bachrach, M. Carbin, C. Pacheco, \nF. Sherwood, S. Sidiroglou, G. Sullivan, W.-F. Wong, Y. Zibin, M. D. Ernst, and M. C. Rinard. Automatically \npatching errors in deployed software. In SOSP, 2009. [29] K. Poulsen. Software bug contributed to blackout. \nSecurityFocus, Feb. 2004. URL http://www.securityfocus.com/news/8016. [30] P. Ratanaworabhan, M. Burtscher, \nD. Kirovski, B. Zorn, R. Nagpal, and K. Pattabiraman. Detecting and tolerating asymmetric races. In PPoPP, \n2009. [31] E. Rescorla. Security holes . . . who cares? In USENIX Security Conference, 2003. [32] S. \nSavage, M. Burrows, G. Nelson, P. Sobalvarro, and T. Anderson. Eraser: A dynamic data race detector for \nmultithreaded programs. ACM Transactions on Computer Systems, 15, 1997. [33] S. Sidiroglou, S. Ioannidis, \nand A. D. Keromytis. Band-aid patching. In HotDep, 2007. [34] A. Solar-Lezama, C. G. Jones, and R. Bodik. \nSketching concurrent data structures. In PLDI, 2008. [35] C. Tian, V. Nagarajan, R. Gupta, and S. Tallam. \nDynamic recognition of synchronization operations for improved data race detection. In ISSTA, 2008. [36] \nG. Upadhyaya, S. P. Midkiff, and V. S. Pai. Automatic atomic region identi.cation in shared memory spmd \nprograms. In OOPSLA, 2010. [37] M. Vaziri, F. Tip, and J. Dolby. Associating synchronization constraints \nwith data in an object-oriented language. In POPL, 2006. [38] M. T. Vechev, E. Yahav, and G. Yorsh. Abstraction-guided \nsynthesis of synchronization. In POPL, 2010. [39] D. Weeratunge, X. Zhang, and S. Jagannathan. Analyzing \nmulticore dumps to facilitate concurrency bug reproduction. In ASPLOS, 2010. [40] J. Wu, H. Cui, and \nJ. Yang. Bypassing races in live applications with execution .lters. In OSDI, 2010. [41] W. Xiong, S. \nPark, J. Zhang, Y. Zhou, and Z. Ma. Ad hoc synchroniza\u00adtion considered harmful. In OSDI, 2010. [42] C. \nZam.r and G. Candea. Execution synthesis: A technique for automated software debugging. In EuroSys, 2010. \n     \n\t\t\t", "proc_id": "1993498", "abstract": "<p>Fixing software bugs has always been an important and time-consuming process in software development. Fixing concurrency bugs has become especially critical in the multicore era. However, fixing concurrency bugs is challenging, in part due to non-deterministic failures and tricky parallel reasoning. Beyond correctly fixing the original problem in the software, a good patch should also avoid introducing new bugs, degrading performance unnecessarily, or damaging software readability. Existing tools cannot automate the whole fixing process and provide good-quality patches.</p> <p>We present AFix, a tool that automates the whole process of fixing one common type of concurrency bug: single-variable atomicity violations. AFix starts from the bug reports of existing bug-detection tools. It augments these with static analysis to construct a suitable patch for each bug report. It further tries to combine the patches of multiple bugs for better performance and code readability. Finally, AFix's run-time component provides testing customized for each patch. Our evaluation shows that patches automatically generated by AFix correctly eliminate six out of eight real-world bugs and significantly decrease the failure probability in the other two cases. AFix patches never introduce new bugs and usually have similar performance to manually-designed patches.</p>", "authors": [{"name": "Guoliang Jin", "author_profile_id": "81470644031", "affiliation": "University of Wisconsin-Madison, Madison, WI, USA", "person_id": "P2690597", "email_address": "aliang@cs.wisc.edu", "orcid_id": ""}, {"name": "Linhai Song", "author_profile_id": "81485652652", "affiliation": "University of Wisconsin-Madison, Madison, WI, USA", "person_id": "P2690598", "email_address": "songlh@cs.wisc.edu", "orcid_id": ""}, {"name": "Wei Zhang", "author_profile_id": "81458642805", "affiliation": "University of Wisconsin-Madison, Madison, WI, USA", "person_id": "P2690599", "email_address": "wzh@cs.wisc.edu", "orcid_id": ""}, {"name": "Shan Lu", "author_profile_id": "81100052818", "affiliation": "University of Wisconsin-Madison, Madison, WI, USA", "person_id": "P2690600", "email_address": "shanlu@cs.wisc.edu", "orcid_id": ""}, {"name": "Ben Liblit", "author_profile_id": "81100555854", "affiliation": "University of Wisconsin-Madison, Madison, WI, USA", "person_id": "P2690601", "email_address": "liblit@cs.wisc.edu", "orcid_id": ""}], "doi_number": "10.1145/1993498.1993544", "year": "2011", "article_id": "1993544", "conference": "PLDI", "title": "Automated atomicity-violation fixing", "url": "http://dl.acm.org/citation.cfm?id=1993544"}