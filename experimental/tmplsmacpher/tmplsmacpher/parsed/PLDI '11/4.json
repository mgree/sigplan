{"article_publication_date": "06-04-2011", "fulltext": "\n Synthesizing Geometry Constructions Sumit Gulwani Vijay Anand Korthikanti * Ashish Tiwari Microsoft \nResearch UIUC SRI International Redmond, WA, USA Urbana Champaign, IL, USA Menlo Park, CA, USA sumitg@microsoft.com \nvkortho2@uiuc.edu tiwari@csl.sri.com Abstract In this paper, we study the problem of automatically solving \nruler/compass based geometry construction problems. We .rst in\u00adtroduce a logic and a programming language \nfor describing such constructions and then phrase the automation problem as a program synthesis problem. \nWe then describe a new program synthesis tech\u00adnique based on three key insights: (i) reduction of symbolic \nreason\u00ading to concrete reasoning (based on a deep theoretical result that re\u00adduces veri.cation to random \ntesting), (ii) extending the instruction set of the programming language with higher level primitives \n(rep\u00adresenting basic constructions found in textbook chapters, inspired by how humans use their experience \nand knowledge gained from chapters to perform complicated constructions), and (iii) pruning the forward \nexhaustive search using a goal-directed heuristic (sim\u00adulating backward reasoning performed by humans). \nOur tool can successfully synthesize constructions for various geometry prob\u00adlems picked up from high-school \ntextbooks and examination pa\u00adpers in a reasonable amount of time. This opens up an amazing set of possibilities \nin the context of making classroom teaching interactive. Categories and Subject Descriptors D.1.2 [Programming \nTech\u00adniques]: Automatic Programming; I.2.2 [Arti.cial Intelligence]: Program Synthesis; K.3.1 [Computers \nand Education]: Computer uses in Education General Terms Algorithms, Theory Keywords Program synthesis, \nRuler-Compass geometry con\u00adstructions, Abstraction, Forward and Backward Analysis 1. Introduction Program \nSynthesis is the task of automatically synthesizing a pro\u00adgram in some underlying language from a given \nspeci.cation using some search technique [12]. It has been used for a wide variety of applications targeted \ntowards various classes of users. Discovery of new algorithms for Algorithm Designers: Bit\u00advector algorithms \n[14], Mutual exclusion algorithms [3, 21], * Work done while visiting SRI International. Research supported \nin part by NSF grants CSR-EHCS-0834810, CSR\u00ad0917398 and SHF:CSR-1017483. Permission to make digital or \nhard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. PLDI 11, June 4 8, 2011, San Jose, California, \nUSA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0663-8/11/06. . . $10.00 Concurrent algorithms [34, 39], \nparameters of embedded sys\u00adtems [6, 37].  General purpose programming assistance for Software Develop\u00aders: \nPartial programming [4, 23, 33], Template based program\u00adming [35, 36], Automated debugging [40], Program \nunderstand\u00ading [18].  Automating repetitive tasks for End-users: Programming by Demonstration systems \n[9, 26], Programming by Example sys\u00adtems [13, 15], shell scripts [25].  However, we feel that the most \nrevolutionary application of pro\u00adgram synthesis technology can be in K-12 education. The potential impact \nsize of target population is simply mind boggling: billion students and teachers (compared to say ten \nthousand algorithmic designers, million software developers, and hundred million end\u00adusers). Program \nsynthesis technology can be applied to automating constructions for various domains in high-school curriculum. \nEx\u00adamples of such constructions include (i) ruler/compass based geo\u00admetric constructions in mathematics \n(ii) constructions of chemical compounds or biological proteins using (bio)chemical reactions un\u00adder \nappropriate conditions governed by catalysts, temperature and pressure in chemistry and biology, (iii) \nconstructions of electrical circuits using series and parallel composition of resistances and ca\u00adpacitances \nin physics, and so on. One might wonder what is the connection between program synthesis and automating \nconstructions. Programming languages allow us to formally describe these constructions. Take the example \nof geometric constructions that involve constructing a set of objects O with desired properties f2 from \nan initial set of objects I with certain properties f1 using a series of steps S, where each step involves \nusing ruler or compass to create new objects. The objects I and O are like program variables and S is \nthe program whose instruction set includes ruler/compass operations.1 The formulas f1 and f2 play the \nrole of precondition and postcondition respectively. Checking the correctness of a given geometric construction \nis like checking the validity of the Hoare triple (f1, S, f2), which is a program veri.cation problem. \nIn fact, this veri.cation problem has been studied intensively in the context of geometric constructions. \nSynthesizing the geometric construction S, given f1 and f2, is the program synthesis problem, which is \nwhat we address in this paper in the context of geometric constructions. We focus on automating geometry \nconstructions because ge\u00adometry is regarded to be one of the most dif.cult as well as im\u00adportant subjects \nin high-school curriculum. Geometry education is supposed to help exercise logical abilities of the left-brain, \nvisu\u00adalization abilities of the right-brain, and hence enables students to make the two connect and work \ntogether as one. Geometric con\u00ad 1 In fact, a programming language for drawing such geometric objects \nis used to motivate freshman and non-major students to take up programming lang. course at UCSD [29]. \n structions have a close connection to axiomatic logic. The skills needed to .gure out how to construct, \nsay, a square without a pro\u00adtractor, are closely related to the thinking skills needed to prove theorems \nabout squares [1]. The visual nature of geometry makes it initially more accessible than other parts \nof mathematics, such as algebra or number theory. Construction can reinforce proof and lend visual clarity \nto many geometric relationships. [30] They give the secondary school student, starved for a Piagetian \nconcrete\u00adoperational experience, something tangible. [28]. One might also wonder why we insist on high-school \ncurricu\u00adlum as opposed to undergraduate/graduate curriculum for our suc\u00adcess metric. We want to build \ntools that are scalable, predictive in their power and can have a real practical impact. Given scalabil\u00adity \nlimitations of program synthesis techniques in terms of being able to automatically synthesize only relatively \nsmall snippets of code in a reasonable amount of time, high-school problem solving (where solution size \nis relatively small enough and are less involved compared to undergraduate/graduate problems) is an excellent \n.t. We present a new program synthesis technique for automating geometry constructions. Our program synthesis \ntechnique is based on exhaustive search, but exploits three key ideas, inspired by human experience and \nintelligence, to make it scalable. Idea 1: Reducing symbolic reasoning to concrete First, we re\u00adduce \nthe problem of symbolic reasoning to concrete reasoning. We reduce the problem of obtaining a construction \nthat can transform input objects I with precondition f1 to output objects O with post\u00adcondition f2 to \nthat of obtaining a construction that can perform the transformation on a randomly chosen concrete model \nfor I and O that satis.es constraints f1 and f2 . In our implementation, we generate such a random model \nusing a numerical (multivariate) function minimization procedure. The probabilistic soundness of this \nreduction relies on a deep theoretical result that is an exten\u00adsion of randomized polynomial identity \ntesting theorem. (This re\u00adsult is analogous to reducing veri.cation of a straight-line program to testing \non a random input.) This reduction is critically important because symbolic reasoning would not scale \n-it would make our technique multiple orders of magnitude slower, and hence useless in an interactive \nsetting. This reduction is inspired by how humans also work out geometric constructions by visually working \nout the construction on a randomly chosen con.guration. Idea 2: Using extended set of common constructions \nWhen hu\u00admans typically solve a construction problem, they don t attempt to construct everything from \n.rst principles. They think in terms of some key higher level abstractions, where they exploit their \nknowl\u00adedge of how to perform some key multi-step constructions. Our technique, which is based on exhaustive \nsearch, exploits this obser\u00advation by working with an extended set of common constructions found in textbook \nchapters (Table 2) as opposed to simply working with a basic minimal set of constructions (Table 1). \nThis can also be thought of as giving preference to certain combinations of basic construction steps, \nwhich is related to the notion of using priors in the machine learning community. This allows for transforming \nthe search process with small width and large depth to one with large width and small depth. Idea 3: \nPerforming goal-directed search We prune our forward exhaustive search by applying a construction (from \nthe extended set of constructions) only when the goodness measure function sug\u00adgests that it may be useful \nto apply that construction. For example, the goodness measure function might suggest that if a construction \nresults in a line L1 that passes through a given output point P , then it may be useful to apply that \nconstruction (since we might be able to construct another line L2 in the future that also passes through \nP , and hence intersection of L1 and L2 can yield desired point P ). This is inspired by backward reasoning \nperformed by humans in doing such constructions. This can also be thought of as pruning the forward search \nby integrating it with backward search. Based on these ideas, we built a tool for automating geometry \nconstructions. Our tool could solve most standard geometry con\u00adstruction problems in less than a second. \nSurprisingly, it could also solve some nontrivial problems whose solution is not immediately clear, such \nas, constructing a square whose (extended) sides pass through four given points. While our focus is on \nsynthesizing ge\u00adometry constructions, the basic concepts used here could be appli\u00adcable in other domains \nas well.2 Another interesting application of our algorithm is in the con\u00adtext of dynamic geometry, or \ncreating animations. Suppose we can .nd a model for declarative constraints using numerical methods in \n1 second, and it takes 5 seconds to synthesize an equivalent con\u00adstruction for the declarative problem \nspeci.cation. The importance of having the construction (besides education purposes) is that run\u00adning \nthat construction will take micro-seconds. So, if the goal is to quickly re-compute coordinates of various \npoints after assigning a new value to the free variables, running the construction will be faster by \norders of magnitude compared to using numerical meth\u00adods. This paper makes the following key contributions. \n Using the speci.c example of geometry constructions, the paper points out the role that programming \nlanguages, logic, and program synthesis can play in the area of building automated tutoring systems, \nwhich is traditionally considered to be a sub\u00ad.eld of AI.  We present a novel search algorithm that \ncombines three key ideas picked up from different research areas: property testing (theoretical computer \nscience), higher-level abstractions (pro\u00adgramming languages), and goal-directed reasoning (AI). We believe \nthat the principles underlying our search algorithm are general enough to be applicable to other automated \nproblem solving domains, and other program synthesis applications.  We report on a successful experimental \nprototype thereby es\u00adtablishing the feasibility of building automated tutoring sys\u00adtems around the important \nhigh-school subject of ruler-compass based geometry constructions.  2. Overview of our Approach Consider \nthe problem: Construct a triangle, given its base, a base angle and sum of the other two sides. We wish \nto synthesize a program S that performs the above construction using ruler and compass instructions. \nBefore we can discover S, we .rst need to formally state its inputs I6, output 6 O, its precondition \nfpre and its postcondition fpost. The inputs I6consist of a line segment (points p1, p2, and a line L \n= Line(p1,p2)) that de.nes the base of the desired triangle, a length r and an angle a.3 The desired \noutput 6 O consists of a single point p. The precondition fpre arises from the triangle inequality as \nr> Length(p1,p2) (1) 2 The idea of representing knowledge as a library and then constructing new structures \nby composing elements of the library can be viewed as one way of interpreting (Turing award winner) Ed \nFeigenbaum s recent remarks in an interview in ACM Communications, where he calls out for having a way \nfor computer to read books and learn to solve problems after that, as opposed to building domain speci.c \ntools [32]. 3 In our formalization of geometry constructions, we distinguish between the cases when we \nhave just two points on a plane versus when we also have the line segment connecting those two points \nexplicitly drawn on the plane. The postcondition fpost can be stated as, Angle(p, p1,p2)= a . Length(p, \np1)+ Length(p, p2)= r (2) After we have a formal description of the inputs I6, outputs O6, precondition \nfpre and postcondition fpost, we next .nd a (ran\u00addom) concrete input-output pair that is consistent with \nthe pre/post speci.cation (Idea 1). In other words, we need to .nd coordinates of the input points p1,p2, \nthe distance r, the angle a, and the coor\u00addinates of the output point p such that the conditions in Equation \n1 and Equation 2 are satis.ed. These conditions are (multivariate) nonlinear constraints over the reals. \nWe translate these nonlinear constraints into a multivariate nonlinear optimization problem (as described \nin Section 6.2) and then use a (numerical) multivariate nonlinear optimization routine to .nd a concrete \ninput-output pair. During this process, we ensure that the concrete input-output pair is picked suf.ciently \nrandomly. Let us say that we .nd the following concrete input-output pair: L = Line((81.62, 99.62), (99.62, \n83.62)) r = 88.07 a =0.81 radians p = (131.72, 103.59) Let (I6c, O6c) denote these concrete input-output \nobjects. (Here all numerals are truncated to 2 digits after decimal, but the implemen\u00adtation uses a much \nhigher precision). Now we have a concrete input-output pair, (I6c, O6c), for the problem. The geometry \nsynthesis problem is also given an exe\u00adcutable library of functions that should be used to synthesize \nS. For example, assume we have a library that implements the ruler\u00adcompass functions in Table 1 (the \nfunctions take concrete inputs and output concrete objects). Our tool now searches for a program S that \nworks correctly on this one input-output pair (I6c, O6c). It searches for S by enumerat\u00ading programs \nup to a certain length. However, to reduce the size of the search space, rather than using the basic \nlibrary in Table 1, we use an extended library that additionally implements functions in Table 2 (Idea \n2). Furthermore, we use a heuristic goodness metric to make the search for S goal-directed (Idea 3). \nWhen searching for S, we generate several partial programs. These partial programs will, when given the \ninput I6c, generate dif\u00adferent geometric objects like points, lines and circles -all of which are represented \nusing points. Figure 1 shows all these intermediate points in two different settings. On the left, we \nshow the points gen\u00aderated when we use the goodness metric to prune the search space, and on the right, \nwe show the points generated when we do not use the goodness metric. It is clearly evident that when \nwe do not use a goodness metric to prune the search space, then the approach does not scale. Once we \n.nd a program S that works on input I6c, we return it if it also works correctly on a second randomly \nsampled concrete input. The program synthesized by our tool for the above problem (using the extended \nlibrary in Table 2) is: Test10(p1,p2,L,r,a): L1 := ConstructLineGivenAngleLinePoint(L,a,p1); C1 := ConstructCircleGivenPointLength(p1,r); \n(p3,p4) := LineCircleIntersection(L1,C1); L2 := PerpendicularBisector2Points(p2,p3); p5 := LineLineIntersection(L1,L2); \nreturn p5; The line L1 is good because the output point p lies on it. The circle C1 is good because it \nintersects an existing object (namely, line L1) at a good point p3: p3 is good because it is equidistant \nfrom the output point p and the input point p2. Similarly, we can establish goodness of all the other \nintermediate objects. Without using goodness, the search for S fails to terminate in allocated time. \nFig. 1(right) shows the points constructed during a truncated search. The above program was synthesized \nin 3.5 seconds. When rewritten in terms of the basic library, the above program expands to a program \nwith 17 instructions. We remark that our implementa\u00adtion distinguishes between lines and rays, but we \ndo not show this distinction here for simplicity. 3. Geometry Programming Language We describe a programming \nlanguage for geometric constructions. We will later synthesize programs in this programming language \nstarting from a given speci.cation. Traditional (imperative) programming languages manipulate values \nof variables. These values are typically integers, .oats, Booleans, or addresses (pointers). The entities \nthat our program\u00adming language for geometry manipulates are objects, such as points, lines and circles. \nSpeci.cally, our programming language for geometry has the following set of object types: Point. A point \nis a primitive object in our language. It is repre\u00adsented using Cartesian coordinates. In this paper, \nwe restrict ourselves to 2-dimensional geometry and a point is represented using its x-and y-coordinates \nthat remain hidden. Line. A line is represented by a pair of two distinct points that lie on it. The \nconstructor Line(p1,p2) returns a line object that is de.ned by the points p1 and p2. Angle. An angle \nis a number in the range [0, 2 * p). An angle is represented using three points. The function ExplodeAngle \nreturns these three points. Length. A length is a number in the range [0, 8). The constructor Length(p1 \n, p2 ) returns a length object denoting the distance between points p1 and p2. Circle. A circle is represented \nas a pair of a point and a length. For a point p and length l, the constructor Circle(p, l) returns the \ncircle with center p and radius l. The radius of a circle is always a nonzero positive number. Program \nvariables are typed and are given one of the .ve types de.ned above. A program takes some objects as \ninputs, and using a prede.ned library Lib of functions F1,...,Fk, it constructs new objects and outputs \none or more of these objects. Thus, a program takes as input I6and uses (tuples of) temporary variables \n6ti to compute the output O6as follows: geoProgram(I6): 6t1 := Fp1 (V61); . . . 6tn := Fpn (V6n); O6:= \nV6n+1; 6 return O; where each variable in V6i is either an input variable from I6, or a temporary variable \nfrom 6tj such that j<i, and  1 = pi = k.  3.1 The Expression Language There is only one kind of expression \nin our geometry programming language, namely a function call Fi(V6), where Fi is a function from a given \nlibrary. The library for ruler-and-compass construc\u00adtions is shown in Table 1. It consists of functions \nfor constructing lines, circles, and lengths from points, and functions for construct\u00ading points from \nline-line intersection, line-circle intersection, and Figure 1. Points visited in a goal-directed search \n(left) and a brute-force search (right). The concrete inputs and output were picked independently in \nthe two runs. The output point was not reached in the brute-force search and the search had to be truncated. \n Function Description L = Line(p1,p2) C = Circle(p,r) r = Length(p1,p2) p = LineLineXn(L1,L2) pp = LineCircleXn(L1,C1) \npp = CircleCircleXn(C1,C2) pp = ExplodeAngle(a) L is the line joining p1 and p2 (provided p1 = p2). \nC is the circle with center p and radius r. r is the length of the segment from p1 to p2 (provided p1 \n= p2). p is the point that lies at the intersection of L1 and L2 (provided L1, L2 are not parallel). \npp is the vector containing (1 or 2) points that lie on both L1, C1 (provided they intersect). pp is \nthe vector containing (1 or 2) points that lie on both C1, C2 (provided they intersect). pp is the vector \nof (three) points that de.ne angle a. Table 1. Library functions in the geometry programming language: \nthe type of p1,p2,... is Point, p6is a vector of points, L is a line, C a circle, a an angle, and r a \nlength. circle-circle intersection. It also consists of a function to expose points that de.ne a given \nangle. It is not dif.cult to observe that programs in our geometry programming language correspond di\u00adrectly \nto ruler-and-compass constructions on paper. However, the library shown in Table 1 contains only the \nprimi\u00adtive ruler-and-compass operations. It can be extended by includ\u00ading new (derived) functions such \nas those in Table 2. We later show that such an extension enables synthesis of nontrivial geometry pro\u00adgrams. \n 3.2 The Speci.cation Language The speci.cation language is used to write the precondition and the postcondition \nof a geometry program. A speci.cation is given as a conjunction of atomic facts. An atomic fact is an \nequality or inequality between two arithmetic expressions. An arithmetic expression is built using the \nstandard arithmetic operations, +, -, *, applied on numeral objects, the Length and Angle functions, \nand the functions: distL(p,L) returns distance between point p and line L.  slope(L) returns the slope \nof line L. We found that these functions were suf.cient to describe almost all high-school geometry problems. \nFor example, note that we can  specify that point p lies on line joining points p1 and p2 as an equality \nbetween two slopes, and we can specify that Line(p1,p2) and Line(p3,p4) are perpen\u00addicular as an equality \nbetween arithmetic expressions: slope(p1,p2) * slope(p3,p4)= -1 4. Problem De.nition Our goal is to \nsynthesize programs in our geometry programming language given their speci.cation in the form of precondition \nand postcondition. Here we will formally de.ne the synthesis problem for the geometry domain. The synthesis \nproblem is given the speci.cation of the desired program and also the executable code implementing a \ngiven library. The goal of the geometry synthesis problem is to discover a pro\u00adgram in the geometry programming \nlanguage that correctly imple\u00adments the speci.cation. Formally, the geometry synthesis problem requires \nthe user to provide the following: A speci.cation (6O,fpre (I6),fpost(6O)) of the desired I, 6I, 6 program, \nwhich includes a tuple of typed input variables I6and output variables O6.  a formula fpre(I6) that \nspeci.es the precondition and a formula fpost(6O) that speci.es the postcondition.  I, 6 A library \nof executable speci.cations 6 Lib := {(I6i,Oi,Fi(I6i))| i =1,...,k}, where Fi is an executable implementation \nof the i-th library slope(p, p1)= slope(p1,p2), function. The geometry program synthesis problem seeks \nto synthesize a geometry program S a composition of the primitive operations from Lib that implements \nthe given speci.cation; that is, the following correctness criterion holds: .6I) . O6= fS (6I, 6 I, O6:(fpre(6I)) \n. fpost(6O) (3) where fS is the function computed by the program S. We note here that the problem de.nition \nabove does not require a formal speci.cation of the library functions, but only an exe\u00adcutable speci.cation. \nThis is one important point that distinguishes our work from other work on synthesis; see also Section \n7. The synthesis procedure needs to .nd a program from the huge space of all possible programs that works \ncorrectly for all concrete inputs. 5. The Synthesis Procedure In this section, we present our synthesis \napproach for automatically discovering geometry programs that meet some given speci.cation. As a .rst \napproach, one can perform an exhaustive search on the space of all possible programs (of some .xed length). \nIn other words, one could enumerate all possible compositions of library functions and then verify if \nany one implements the given speci\u00ad.cation. This is, however, not feasible for two reasons. First, the \nnumber of possible programs (even of a .xed depth) is huge, and expensive to exhaustively enumerate. \nSecond, verifying whether a program implements a given speci.cation is a hard geometry the\u00adorem proving \nproblem. Speci.cally, it involves checking the valid\u00adity of a nonlinear formula in the theory of reals. \nWhile this theory is decidable [38], decision procedures are not practical in our set\u00adting since solving \na single synthesis problem will involve making a large number of veri.cation queries. We use a new and \ndifferent approach for synthesis that com\u00adpletely avoids all symbolic reasoning and signi.cantly prunes \nthe search space of all programs. Figure 2 presents the pseudocode of our synthesis procedure. The program \nGeoSynth takes two inputs: a speci.cation (fpre,fpost) of the desired program and a library Lib of available \nfunctions. It .rst generates a concrete input-output pair (I6c, O6c) that satis.es the given speci.cation. \nIt then calls the recursive function GeoSynthRec with the arguments I6c, O6c, Lib and an empty program \nP . If the concrete output objects O6c are al\u00adready contained in the available objects I6c, then there \nis nothing to synthesize and the function GeoSynthRec returns the program P (after checking that it works \non a second concrete input-output pair). If not, then the synthesis procedure generates new objects from \nthe available objects and adds them to the set of available ob\u00adjects if they are new and good, and recursively \ncalls itself. The procedure in Figure 2 for synthesis completely avoids all symbolic reasoning and signi.cantly \nprunes the search space of all programs. It achieves this using three key ideas: Concretization: From \nSymbolic to Numeric We discover the pro\u00ad gram by .nding a program that works for a concrete input\u00ad output \npair. By using a concrete input-output pair, we avoid doing any symbolic reasoning on nonlinear constraints. \nHow\u00ad ever, we still need to solve symbolic nonlinear constraints to generate a concrete input-output \npair. This we do by using nu\u00ad merical techniques for nonlinear optimization. Acceleration: Using Extended \nLibrary While searching for the correct program, we use a library of high-level functions. Each high-level \nfunction can be implemented using the basic func\u00ad tions in the given library. A high-level function performs \na frequently-used subtask. A few calls to high-level functions of\u00ad ten suf.ce to achieve what many calls \nto basic functions can achieve. This helps in reducing the search space of programs. GeoSynth(fspec \n, Lib): // Input fspec := (fpre,fpost) is the specification // Input Lib:= ((Fi)i=1,2,...), where Fi \nimplements the i-th library function // Output: A program or \"Failure\" 6 Ic := Random concrete objects \ns.t. fpre(I6c) holds 66 Oc := Concrete objects s.t. fpost(I6c,Oc) holds return GeoSynthRec(I6c, O6c, \nLib, E, fspec ); 6 GeoSynthRec(I6c, Oc, Lib, P, fspec): 6 // Input Ic, concrete objects we have constructed \n// Input O6c, concrete objects we wish to construct // Input P , the program (so far) 6 if (O6c are contained \nin Ic) return(Verify(P, fspec )); forall functions Fi . Lib {forall possible choices of arguments args \nfor Fi 6 picked from Ic { newObj := Fi(args); if (newObj is Good and 6 newObj is not already present \nin Ic) {newP := (P ;6t := Fi(args)); 6 newI := Ic .{newObj}; result := GeoSynthRec(newI,O6c,Lib,newP,fspec); \nif (result= \"Failure\") return(result); }}} return \"Failure\" Verify(P , fspec): // Check if P works correctly \non a second input 6 Ic := Random concrete objects s.t. fpre(I6c) holds O6c := fP (I6c); 6 if (fpost (I6c,Oc) \n== true) return(P ); else return \"Failure\"; Figure 2. GeoSynthesizer s Synthesis procedure. Goal-Directed \nSearch: Goodness Measure A naive search for the correct program based on enumerating all programs is \nblind to the goal. We can make the search goal-directed by develop\u00ading a measure for the progress toward \nthe goal. For any newly created object (using the basic/high-level library), the good\u00adness function returns \na measure of its goodness with respect to (achieving) the goal. We provide more details on these three \ntechniques below. 5.1 Concretization: Symbolic to Numeric Recall that the goal is to synthesize a program \nP that works for all inputs; that is, it meets the given correctness criterion in For\u00admula 3. The problem \nof even verifying that a given program sat\u00adis.es the given correctness criterion is not easy. First, \nthe set of all possible inputs is unbounded. The traditional solution is to rea\u00adson about one arbitrary \nsymbolic input. Formula 3 is a nonlinear formula in the theory of reals. For example, the atomic formula \nLength(p1,p2)=Length(p1,p3), when expanded using coordinates (xi,yi) for pi, takes the form (x2 - x1)2 \n+(y2 - y1)2 =(x3 - x1)2 +(y3 - y1)2 which is a quadratic formula over 6 real variables. Nonlinear for\u00admulas \nare hard to decide symbolically. There are some symbolic geometry theorem proving tools that can automatically \nprove For\u00admula 3, but in a synthesis procedure, one requires to check For\u00admula 3 not once, but several \ntimes, while searching for the correct P . Hence, symbolic techniques are unlikely to scale for synthesis. \nGeoSynth avoids all symbolic manipulation by synthesiz\u00ading programs that work for some concrete input-output \npairs. GeoSynth assumes that the library functions are provided as exe\u00adcutable code that compute the \nconcrete output objects given con\u00adcrete input objects. From the descriptions of the functions in Ta\u00adble \n1, the implementation should be immediately clear. For exam\u00adple, the function LineLineXn(L1,L2) computes \nthe x-and y\u00adcoordinates of the unique point, if any, that lies on the intersection of concrete lines \nL1= Line(p1,p2) and L2= Line(p3,p4) as follows: x = [(x1y2 - y1x2)(x3 - x4) - (x1 - x2)(x3y4 - y3x4)]/D \ny = [(x1y2 - y1x2)(y3 - y4) - (y1 - y2)(x3y4 - y3x4)]/D where D =(x1-x2)(y3-y4)-(y1-y2)(x3-x4), p1=(x1,y1), \np2=(x2,y2), p3=(x3,y3), and p4=(x4,y4). Similarly, we can get algebraic expression that implement the \nother functions. The functions are implemented using .oating point representation for the reals. By using \nexecutable code for the library functions, GeoSynth synthesizes a program that works for one concrete \ninput. How do we argue that the synthesized program also works for all other inputs? The key observation \nhere is that if a geometry construction is correct for a concrete input that is randomly chosen from \nthe space of all valid inputs (inputs that satisfy the precondition), then, with very high probability, \nit is correct for all valid inputs. The only assumption required is that the postcondition fpost(6O) \nI, 6be such that for any concrete input I6c, there is at most one (more generally, a constant fraction \nof the input space) output O6c such 6 that fpost (I6c,Oc) holds. THEOREM 1. Let P be a geometry program \nconstructed using the library Lib from Table 1 and let fP denote the function P computes. Let (fpre(6I, \nO6)) be a speci.cation, where I),fpost(6the number of inputs, |I6|, is n. Let I6c be a concrete input \npoint obtained by sampling uniformly at random the subspace {6c . Rn | fpre(6c)} that represents all \nnon-degenerate inputs. If O6c = 6 fP (I6c) and if fpost(I6c,Oc) also holds, then with probability one \nit is the case that .6O :(fpre(6O = fP (6. fpost(6O)I, 6I) . 6I)) I, 6 PROOF: (Sketch) Assume the speci.cation \nis deterministic so that there is a function fspec that computes, for any given valid (non-degenerate) \ninput, the output that is consistent with the speci.cation fpost; that is, fspec has the property that \n.I6c : fpre(I6c) . fpost(I6c,fspec(I6c)) Consider the functions fP and fspec. It is well-known property \nof ruler-and-compass constructions that these two functions can be described using compositions of the \narithmetic +, -, *,/ operations and the square-root operation, and hence we can argue that they are analytic \nover the domain of valid (non-degenerate) inputs (analytic with respect to each variable). Now consider \nthe function fP - fspec. It is analytic too. Hence, unless it is identically zero, the space of zeros \nof this function has measure zero in the space of all inputs. Hence, for a random (valid non\u00addegenerate) \ninput I6c, since we have fP (I6c) - fspec(I6c)=0, it follows that, with probability one, fP - fspec is \nidentically zero and hence, the claim holds. D The theorem is a generalization of a similar result for \npoly\u00adnomial identity testing [31]. Similar results have been folklore in geometry theorem proving where \nit has been noted that geometry theorems can be proved by testing them on one random concrete in\u00adstance \n[43]. The probability one claim in Theorem 1 assumes that exact computation on the reals is performed \nand we sample the real space. However, this is not possible and the implementation only uses .nite precision \n.oating point representation and samples over .oating point numbers. These issues will slightly increase \nthe prob\u00adability of our procedure giving wrong answers, but, as one would expect, the probability will \ncontinue to remain very low. Theorem 1 states that the probability of returning a speci.c wrong program \nP is very low. But the space of programs is large, and these probabilities could add up so that the probability \nof re\u00adturning some wrong program from the space of all programs could become substantial. Hence, GeoSynth \nuses one concrete input\u00adoutput pair to synthesize the program, and then another randomly sampled input-output \npair to check it again (see the Verify func\u00adtion in the pseudocode). Therefore, GeoSynth can return a \nwrong answer only if the speci.c program P (that is synthesized using one concrete input-output pair) \ndoes not match the speci.cation on a randomly sampled input. By Theorem 1, we know this is very low, \nand this establishes the probabilistic soundness of GeoSynth. In fact, in our experiments (reported in \nSection 6), the Verify func\u00adtion never returned Failure . If Verify fails, note that the pseu\u00addocode \ncontinues its search for the correct program. 5.2 Acceleration: Extended Library Discovering a geometry \nprogram that works correctly on even a single concrete input is not easy. This is because the search \nspace of all possible programs is huge. We need ways to ef.ciently search this large state space. We \nuse ideas from program analysis forward and backward analysis to signi.cantly prune the search space. \nWe argue that this is also the way that humans perform the search. Consider the size of the search space \nof all programs. If the li\u00adbrary has M functions that take, say, two arguments each, then the state space \nof all programs of length N that can be constructed using the library functions is O((M(N + |I6|)2)N \n). This is super\u00adexponential in N. This shows that we can not search for very long programs. Unfortunately, \neven for performing simple tasks, geom\u00adetry programs P that are built using the library shown in Table \n1 can be very long. GeoSynth works on an extended library. Apart from the prim\u00aditive functions listed \nin Table 1, the extended library also contains the functions listed in Table 2. Each new library function \ncan be implemented using the primitive functions. Using the extended li\u00adbrary, however, we can .nd much \nshorter programs P that meet the given speci.cation. Hence, we can discover the correct P by searching \nfor shorter programs using the extended library, rather than searching for long programs using the primitive \nlibrary. Table 2 lists the new functions in the extended library. For ex\u00adample, consider the function \nPerpendicularBisector2Points. Constructing the perpendicular bisector of two points will require at least \nthree steps using the functions provided in the primitive library in Table 1. However, it is a commonly \nused subroutine when performing geometry constructions and it is useful to add such a function in the \nextended library, as it will likely reduce the length of the program P we are trying to discover by at \nleast three. The use of extended library for discovering the correct pro\u00adgram matches the way humans \nsynthesize programs. Rather than working with low-level primitives, complex systems are built by composing \nhigher-level components. In geometry programs, the extended library contains high-level constructions \nthat encode the knowledge the student is taught to solve more complex geometry Function Name Description \nL = PerpendicularBisector2Points(p1,p2) L is the perpendicular bisector of line joining p1 and p2. p \n= MirrorPointLine(p1,L) p is the re.ection of p1 about line L. 6C = CircleGivenChordAngle(L,a) 6C is \na vector of (1 or 2) circles C s.t. L is a chord of C subtending angle a. L = ConstructLineGivenAngleLinePoint(L1,a,p) \nL is at an angle a with L1 at point p (on L1). C = ConcentricCircle(C1,r) C is concentric to C1 and at \ndistance r away from it. L = PerpendicularToLineThruPoint(p,L1) L is perpendicular to L1 and passes through \np. 6L = AngularBisectorLines(L1,L2) 6L is the tuple of (two) lines that are angular bisectors of L1 and \nL2. p = MidpointGiven2points(p1,p2) p is the midpoint between p1 and p2. 6L = TangentPointToCircle(p,C) \n6L is the vector of (two) lines that are tangent to C and pass through p. L = ParallelLine(p,L1) L is \nthe line parallel to L1 and passing through p. 6L = ParallelLineGivenLength(L1,r) 6L is the vector of \n(two) lines that are parallel to L1 and distance r away from it. Table 2. Extended Library construction \nexercises. In fact, GeoSynth takes the library as an in\u00adput, and hence, as the student learns more concepts, \nthe library can be extended too, which will then enable GeoSynth to synthesize more complex geometry \nconstructions. In the experimental results in Section 6, we show the impact of using extended library \nby comparing it against the use of primitive library. The use of extended library also has its analogue \nin the .eld of program analysis. It corresponds to using forward search (forward propagation) to see \nwhat search space is reachable in a few steps. The technique of acceleration in program analysis [5] \nexplicitly computes high-level (multi-step transition) functions that are com\u00adpositions of low-level \n(one-step transition) functions. Besides ef.ciency, the idea of using library functions may pro\u00advide \nanother important bene.t. By changing the library functions, the tool can be forced to be .nd constructions \nthat use a particular primitive construction step. It is fairly common that exercises at the end of textbook \nchapters are framed so that their solution requires students to use the concepts introduced in that chapter. \nUsing our tool, the same effect can be achieved. Teachers could re-inforce the learning of constructions \ntaught in a certain chapter by just manip\u00adulating the library.  5.3 Goal-Directed Search: Goodness Measure \nIntroduction of an extended library reduces the depth of the pro\u00adgrams that we need to search for .nding \nthe correct program. De\u00adspite this reduction, exhaustive enumeration of all possible pro\u00adgrams remains \ninfeasible. We use the third key idea using back\u00adward analysis to enable a more goal-directed search \nfor the cor\u00adrect program. GeoSynth performs a goal-directed search for the correct pro\u00adgram by using \na heuristic goodness measure that determines if an intermediate object could be useful in .nally constructing \nthe out\u00adput objects. How to compute the goodness measure? Ideally, an in\u00adtermediate object is good if \nan output object can be constructed us\u00ading the intermediate object and the other existing objects. How \ncan we ef.ciently check an intermediate object is good without contin\u00aduing with the forward search? We \ncan do so by performing some backward analysis starting from the output objects. Performing exact backward \nanalysis is challenging. Consider, for example, the case when the output object is a point p. Now consider \none of the library functions, for example, the func\u00adtion CircleCircleXn(C1,C2). There are in.nitely many \ncircles (C1,C2) whose intersection could give p, so backward analysis would involve representing all \nthese cases. However, if we .x C1 to be an existing circle and we also .x the center of C2 to be an existing \npoint, then this .xes the circle C2. This way of performing partial backward analysis can make backward \nanalysis feasible. Rather than explicitly performing partial backward analysis, GeoSynth directly tests \nif an intermediate object is backward reachable from the goal using multiple partial backward steps. \nThese tests are coded using a goodness function. Speci.cally, the Good function takes as argument the \nset currObjs of objects we have already constructed, the set O6of objects we need to construct, the object \n6t whose goodness we are trying to evaluate, and the li\u00adbrary Lib of available functions. Good returns \na Boolean answer indicating if 6t is possibly useful for eventually constructing O6. Depending on the \ntype of the object 6t, Good performs different checks. A point 6t is good if either  6t is an output \npoint in O6.  6t is on an output line or circle.  6t lies on a line joining an existing point in currObjs \nwith an output point in O6.  6t lies on a circle de.ned by a combination of some existing point(s) and \noutput point(s).   A line 6t := Line(p1,p2) is good if either  6t is an output line in O6.  an output \npoint in O6lies on 6t.  6t is parallel or perpendicular to a line de.ned by output objects O6and existing \nobjects currObjs.  the intersection of the line 6t with an existing line or circle object in currObjs \ngives a good point.   A circle 6t := Circle(p, r) is good if either  6t is an output circle in O6. \n some output point in O6lies on 6t or is the center of 6t.  the intersection of the circle 6t with \nan existing line or circle object in currObjs gives a good point.   These rules for goodness clearly \nmeasure the progress 6t makes toward the goal O6. The rules essentially test if 6t lies in the set of \nobjects obtained from the goal O6objects using a few selected partial backward steps. The extended library \nencodes the facts a student is taught in a chapter, and the goodness function attempts to encode the \nintuition (search strategy) the student is expected to apply (in conjunction with the facts in the extended \nlibrary) to solve the exercises at the end of the chapter. GeoSynth uses the function Good to prune its \nsearch space. In the pseudocode in Figure 2, Good is used in the condition guarding the recursive call. \nA newly created object 6t is added to the set of currently available objects only if it is Good. GeoSynth \nallows the user to turn-off goodness checking. In Section 6 we will compare 1. Find the circumcenter \nof a triangle. 2. Find the incenter of a triangle. 3. Find the orthocenter of a triangle. 4. Construct \na regular hexagon inside a circle. 5. Construct length a+b given lengths a and b. 6. Construct a triangle \ngiven length of its 3 sides. 7. Construct a triangle given two sides and an included angle. 8. Construct \na triangle given two angles and an included side. 9. Construct a L given two sides and the angle opposite \none.  10. Construct a triangle, given its base, a base angle and sum of other two sides. 11. Construct \na triangle, given its base, a base angle and difference of other two sides. 12. Construct a L, given \nits perimeter and its two base angles. 13. Draw a pair of tangents to a circle that make an angle of \n60. with each other. 14. Construct a triangle given a side and two altitudes. 15. Construct a triangle \ngiven one angle, the side opposite this angle, and the length of altitude to that side. 16. Construct \na 0 that is inscribed in a given quadrant of a 0. 17. Given point A, line L not passing through A, and \npoint B on L, construct a 0 passing through A that is tangent to L at B. 18. Given points A and B on \nthe same side of a line L, .nd point C on L such that AC and BC make the same angle with L 19. Find \nthe centroid of a triangle. 20. Given non-parallel lines L1 and L2 and a radius r, construct a circle \nof radius r that is tangent to both L1 and L2. 21. Draw arcs of radius r that are tangent to a given \nline and to a given circle. 22. Draw arcs of radius r that are tangent to two given circles. 23. Construct \na square whose extended sides pass through 4 given points. 24. Construct a right L given one acute angle \nand sum of legs. 25. Given a circle and points D and E in its interior, construct an inscribed right \ntriangle such that one leg contains D and other leg contains E.  Table 3. Informal description (in English) \nof the 25 benchmarks used to report results in this paper. the effect of turning on-and-off the goodness \ncheck when synthe\u00adsizing geometry programs. 6. Experimental Results We implemented GeoSynth and tested \nit on a variety of high\u00adschool geometry construction exercises obtained from books and examination papers. \nTable 4 reports details of the runs of GeoSynth on selected 25 examples. As Column 4 indicates, GeoSynth \nsuc\u00adcessfully solved all the problems in a few seconds: 18 problems were solved in less than a second \nand only 3 problems required more than 10 seconds. We experimentally evaluated the ef.cacy of our two \nkey ideas using an extended library (E vs B) and using goal-directed search (G vs N) by varying the \ninputs and command-line .ags of GeoSynth. Speci.cally, Table 4 provides values of the following functions \nfor the 25 examples: T EG: time when using Extended library and Goodness T EN: time when using Extended \nlibrary and No goodness T BG: time when using Basic library and Goodness T BN: time when using Basic \nlibrary and No goodness 6.1 Benchmarks GeoSynth works off a fairly intuitive front-end language for \nwrit\u00ading the speci.cation formulas describing the desired geometry con\u00adstruction: GIVEN ( list of input \nobjects I6) that satisfy fpre(I6) CONSTRUCT ( list of output objects O6) that satisfy I, O6) fpost(6The \nformula fpre(I6) speci.es the constraints on the input objects, and the formula fpost(6O) speci.es the \nrelationship I, 6between the input and output objects. The language of the formulas was described in \nSection 3.2. In the selected benchmarks used for experimental study, Test1 Test9 and Test19 are standard \nproblems in geometry, Test10 Test13 were taken from a Mathematics textbook for high-school students4, \nand the rest were taken from course webpages and other websites devoted to such problems5. An informal \ndescription of the 25 examples is given in Table 3. As an example of the speci.cation of a benchmark \nin the above front-end language, consider our running example: Construct a triangle given its base, base \nangle, and the sum of its other two sides. This is presented to GeoSynth as: GIVEN Segment(p1,p2), Length(p3,p4), \nAngle(p5,p6,p7) that satisfy Length(p3,p4) > Length(p1,p2) CONSTRUCT Point(p) that satisfy Length(p,p1) \n+ Length(p,p2) = Length(p3,p4) and Angle(p,p1,p2) = Angle(p5,p6,p7) We note that the English text speci.cation \nof a geometry construc\u00adtion problem is often ambiguous. In the example above, the English speci.cation \ndoes not tell us how the sum of the two side is given or how the angle is given. The formal speci.cation \nneeds to elimi\u00adnate this ambiguity. In the example above, the formal speci.cation has assumed that the \nsum of the two sides is given as the distance between two new points p3 and p4, as opposed to, say, by \npoint(s) that lies on the line extending the triangle s base. 6.2 Multivariate Optimizers GeoSynth .nds \na (random) concrete input-output pair that satis.es the given precondition and postcondition using a \nnumerical multi\u00advariate optimizer. GeoSynth currently uses an off-the-shelf imple\u00admentation of such a \nfunction. Recall that the precondition and the postcondition is a conjunc\u00adtion of nonlinear constraints. \nThese constraints are dif.cult to solve symbolically. We instead use numerical techniques to get a feasi\u00adble \nsolution. First, we transform all inequalities, say p> 0, where p is a multivariate polynomial, to an \nequality constraint, namely p - u 2 =0, where u is a new real-valued variable. Next, we trans\u00adform a \nconjunction of equality constraints, say p =0 . q =0, into a function minimization problem: minimize \n(p 2 + q 2). The minimum value is zero iff the nonlinear constraints have a solution. Thus, using a multivariate \nfunction minimizer, GeoSynth .nds a concrete input-output (I6c, O6c) that satis.es the given speci.cation. \nRecall that we also have to ensure that the concrete input-output pair is chosen at random. We achieve \nthis by using heuristics to partition the set of unknowns into independent and dependent vari\u00adables. \nThen, we randomly pick concrete values for the independent variables and .x them. We use the multivariate \noptimizer to .nd 4 http://ncertbooks.prashanthellina.com/class_9. Mathematics.Mathematics/chap-11\\%20(02-12-2005).pdf \n5 Test14 Test15 from http://www-math.cudenver.edu/~wcherowi/ courses/m3210/lecchap5.pdf, Test16 Test18, \nTest20 Test22 from www.geometer.org/mathcircles/construct.pdf, Test23 from http://puhep1.princeton.edu/~mcdonald/examples/4point. \npdf and Test24 Test25 from http://www.misterhoffman.com/ downloads/SpringProblemSets.pdf Test (1) LoCE \n(2) Extended Library d,w Time(T EG) (3) (4) T EN (5) LoCB (6) Basic Library #Makes T BG (7) (8) T BN \n(9) Numerical Solving Mean Min. (10) (11) Test1 3 2,2 0.131 0.147 7 6 NoSol 0.146 0.24 0.004 Test2 3 \n2,2 0.194 3.290 21 8 NoSol Timeout 0.61 0.003 Test3 3 2,2 0.331 2.569 13 8 NoSol Timeout 0.75 0.009 Test4 \n2 2,1 0.095 0.078 4 3 0.114 1.010 0.04 0.005 Test5 3 3,1 0.123 0.180 3 1 0.101 0.960 0.04 0.009 Test6 \n4 3,2 0.132 3.018 4 2 0.122 0.134 0.04 0.003 Test7 4 3,2 0.179 3.074 13 5 NoSol Timeout 0.03 0.004 Test8 \n3 2,2 0.144 0.193 21 8 NoSol Timeout 0.03 0.004 Test9 4 3,2 0.176 3.357 13 5 NoSol Timeout 0.15 0.006 \nTest10 6 6,1 3.149 Timeout 17 8 NoSol Timeout 0.28 0.006 Test11 6 6,1 3.550 Timeout 17 8 NoSol Timeout \n0.06 0.019 Test12 7 5,2 63.028 Timeout 45 19 NoSol Timeout 3.91 0.555 Test13 3 3,1 0.121 0.093 4 2 0.118 \n0.100 1.84 0.157 Test14 5 4,2 13.684 44.198 22 14 NoSol Timeout 0.11 0.019 Test15 4 3,2 0.150 4.185 32 \n20 NoSol Timeout 1.54 0.030 Test16 6 6,1 82.613 Timeout 26 11 NoSol Timeout 0.06 0.011 Test17 3 2,1 0.128 \n0.390 10 7 NoSol Timeout 0.07 0.010 Test18 3 3,1 0.139 1.966 8 5 NoSol Timeout 1.35 0.021 Test19 5 3,2 \n0.203 1.902 13 10 NoSol Timeout 0.16 0.029 Test20 3 2,2 0.189 2.528 25 13 NoSol Timeout 0.90 0.002 Test21 \n4 3,2 0.148 570.550 23 12 NoSol Timeout 0.03 0.004 Test22 4 3,2 0.130 211.220 14 6 NoSol Timeout 0.04 \n0.004 Test23 13 8,2 1.929 Timeout 25 17 NoSol Timeout 20.35 2.616 Test24 6 6,1 2.301 Timeout 29 13 NoSol \nTimeout 0.33 0.086 Test25 4 4,1 0.125 212.359 8 5 NoSol Timeout 0.27 0.044 Table 4. Experimental results \nfor 25 construction exercises. Column 2 5 report results when using the extended library: Column 2 is \nthe length of program constructed; Column 3 gives the depth(d) and width(w) of this program; Column 4-5 \ngive the time (in sec.) taken to synthesize the program when using goodness (Col. 4) and when not using \ngoodness (Col. 5). Column 6 9 report results when using the basic library: Column 6 is the length of \nprogram; Column 7 is the number of constructor calls in this program; Column 8-9 give the time (in sec.) \nfor synthesizing the program with (Col. 8) and without (Col. 9) using goodness. Column 10 11 report time \ntaken for .nding one concrete input-output pair using nonlinear optimization: Column 10 is the mean and \nColumn 11 is the minimum (both in sec.) of 15 runs. NoSol indicates procedure terminated but failed to \n.nd a solution . Timeout indicates procedure did not terminate in 10 min. . values only for the dependent \nvariables, having randomly .xed the values for the independent variables. To illustrate the approach, \nconsider the precondition and post\u00adcondition from the example in Section 2. r> Length(p1,p2) Angle(p, \np1,p2)= a Length(p, p1)+ Length(p, p2)= r Let x1,y1 (respectively x2,y2 and x, y) denote the coordinates \nof point p1 (respectively point p2 and point p). Thus, the above con\u00adstraint has 8 variables. We identify \nx1,y1,x2,y2,a as the indepen\u00addent variables and we pick values for them randomly. We determine the values \nfor the other three variables, x, y and r, by solving the above constraint. We .nd x, y, r by minimizing \nthe following non\u00adlinear function over these three variables and the auxiliary variable u: (r - Length(p1,p2) \n- u 2)2 +(Angle(p, p1,p2) - a)2 + (Length(p, p1)+ Length(p, p2) - r)2 The time taken by the minimization \nroutine varies across differ\u00adent runs, and hence, in Table 4, we report the average (Column 10) and minimum \n(Column 11) time spent on .nding a concrete input\u00adoutput pair for each benchmark. (We performed 15 different \nruns for this purpose.) The time spent is proportional to the complexity of the postcondition constraint; \nin particular, the number of output objects. (Test23 seeks to construct a square, and hence the output \nhas 4 points, which is 8 variables.)  6.3 Extended Library vs. Basic Library We compared the performance \nof GeoSynth when it was given the basic library with its performance when it was given the extended library. \nThere are two cases to consider depending on whether or not we use the goodness heuristic. First, consider \nthe case when we do not use the goodness heuristic for pruning the search space. When using the basic \nlibrary, GeoSynth fails to .nd the correct program in 10 minutes of allo\u00adcated time (Col. 9). In contrast, \nwhen using the extended library, GeoSynth successfully .nds the correct solution in 19 out of the 25 \nexamples (Col. 5). Second, consider the case when we do use the goodness heuristic. When it is given \nthe basic library, GeoSynth terminates without .nding the solution in 21 examples (Col. 8). This is be\u00adcause \nthe goodness measure (incorrectly) pruned the branches that had solutions. Note that goodness heuristic \nperforms only a few backward steps, and the objects created by the basic li\u00adbrary functions fail to be \ngood . In contrast, the extended library can quickly (in a few steps) create good objects. As shown in \nCol. 4, when using extended library, all examples were successfully solved. Why is using the extended \nlibrary better? The reason is that when we use the extended library, we .nd small correct solutions. \n Comparing Column 2 with Column 6, we note program lengths (lines of code) varied between 2 and 13 for \nthe 25 benchmarks when using the extended library (Col. 2), whereas its range was 3 45 for basic library \n(Col. 6). Smaller programs translated to smaller search space and hence, better timing, for synthesizing \nthe programs.  6.4 Goodness vs. No Goodness Let us now compare the effect of using goodness. Without \ngood\u00adness, GeoSynth performs a brute-force search, whereas with good\u00adness, it performs a goal-directed \nsearch. There are two cases depending on whether we use the basic library or the extended library. The \ncase when we use the basic library is uninteresting: with goodness, the search is pruned too aggressively \n(Col 8), without goodness, the search explodes and seldom terminates (Col 9). When we use the extended \nlibrary, the use of goodness (Col. 4) signi.cantly improves the runtime of GeoSynth over the case when \nwe do not use goodness (Col. 5). The reason is clear: goal-directed search explores much fewer paths \nthan an exhaustive search (see Figure 1).  6.5 Variations in T EG Looking at Column 4 of Table 4, we \nnotice that GeoSynth solves 18 of the examples in less than a second, and takes more than 10 seconds \non only 3 examples. Without goodness (Col. 5), GeoSynth fails to terminate on 6 examples. To understand \nthe reason for this variation, we also provide the depth (d) and width (w) of the solution in Column \n3. (Intuitively, whereas lines of code (LoC) is the sequential complexity, depth (d) is the parallel \ncomplexity, and width (w) is the number of parallel processors required.) The ability to .nd the correct \nsolution when performing exhaustive search (Col. 5) is directly correlated with the depth of the solution. \nExhaustive search fails when depth of the solution is 5 or higher. However, the depth does not explain \nthe variation in Column 4. Certain property of Test12, Test14 and Test16 interferes with the goodness \nmeasure making it less effective in pruning the search space. 7. Related Work Program Synthesis using \nBrute-force Search [12] provides a good survey of various program synthesis techniques: brute-force search, \nlogical reasoning, probabilistic inference, and version\u00adspace algebras. Our algorithm is closely related \nto the brute-force search strategy. There have been few success stories of using brute\u00adforce search for \nprogram synthesis. It has been used to discover new algorithms (mutual-exclusion algorithms [3] and bitvector \nal\u00adgorithms [11]). It has been used to search for desired small func\u00adtional programs by generating a \nsequence of type-correct programs in a systematic and exhaustive manner and evaluating them against given \nspeci.cations [20]. In comparison, our algorithm leverages some sophisticated novel concepts, essential \nfor it to scale: ob\u00adviating need for symbolic reasoning, performing a goal-directed search, and transforming \nthe search space to one with larger width but smaller depth. Program Synthesis using Input-Output Examples \nThere is a lot of work on inductive program synthesis where the speci.cation from the user comes in the \nform of multiple input-output examples: string manipulation macros [13], table manipulation programs \n[15], bit-vector algorithms [18], graph algorithms [16]. In contrast, our system accepts logical speci.cations, \nbut for scalability reasons, in\u00adternally transforms the logical speci.cation into a (probabilistically \nequivalent) input-output example based speci.cation. Existing inductive program synthesis techniques \nare based on version space algebras [13, 15] or combinatorial search using SAT/SMT solvers [16, 18]. \nIn case of geometry, the mathematical semantics of the operators involves higher order algebraic equa\u00adtions: \nany symbolic reasoning (including reduction to SAT using bit-vector blasting) would be prohibitively \nexpensive, and it is noto clear how to use version space algebras in this context. Interactive Geometry \nSystems There are several dynamic geom\u00adetry systems such as Geometer s sketchpad [17] and Cabri Geome\u00adter \n[24] that allow users/students to create geometric constructions, invent conjectures, and check facts. \nRecent systems also permit one to build proofs (e.g., [2]), or to check facts using an automated theorem \nprover (e.g., Geometry Expert [10], Cinderella [22], and Geometry Explorer [41]). Automated geometry \ntheorem proving (consisting of several techniques such as Wu s method [42], Grob\u00adner basis method [19], \nand angle method [7]) is one of the most successful areas of automated reasoning. In contrast, we address \na technically harder problem of synthesizing constructions, as op\u00adposed to the problem of producing correctness \nproof of a given con\u00adstruction. Our scalable solution relies on a novel approach of using randomness \nto avoid performing symbolic reasoning. Also, another useful advantage of our framework is that teachers \ncan con.gure the extended library to ensure that the tool generates small solu\u00adtions that emphasize use \nof certain concepts (e.g., ones taught in an earlier chapter). Existing automated geometry theorem proving \nsystems tend to produce arbitrary proofs in the underlying logical domain that may not be readable and \nmay be beyond the vocabulary taught in the class. GRAMY [27] is an interesting system for proving theorems \nthat in its search for a proof, performs some constructions to enable the application of certain postulates. \nAll computations in GRAMY are symbolic, whereas our search is completely numeric. Our tool dis\u00adcovers \na construction, but does not output any symbolic proof of its correctness. GRAMY can only discover proofs \nthat do not in\u00advolve arithmetic operations. For example, it can not .nd proofs that involve inequalities, \nratios, and coincident intersections. Our tool can generate constructions whose correctness relies on \narithmetic reasoning; several of our benchmark examples have this feature. GRAMY uses an exhaustive forward \nsymbolic search, followed by a symbolic backward step to suggest a construction. The backward step enables \nnew forward steps, and the process repeats. Unlike GRAMY, in our case, forward search is non-terminating \nand nu\u00admeric. Our backward goal-directed strategy is also numeric, and it is used to prune, and not expand, \nthe forward search. Chou et. al. [8] also consider the problem of discovering ge\u00adometry constructions. \nHowever, there are several differences: (i) A necessary condition for their approach to work is that \nthe locus of every intermediate point should be a point, line or circle. We do not require this condition. \nFor example, given points A,B, the loci of point C s.t. AC+CB=1 is an ellipse, and hence this paper can \nnot handle such constraints (which we can handle). This severely lim\u00adits the kind of examples (from highschool \ntextbooks) that their ap\u00adproach can handle. (ii) Their approach does not use any backward goal-directed \nstrategy. As we have demonstrated, forward search needs to be pruned by backward reasoning both for handling \nlarge examples, and also to make the tool more useful for pedagogical purposes. (iii) Their approach \nuses symbolic reasoning (theorem proving), and not numeric computation, to solve the problem. This can \naffect scalability by orders of magnitude. (iv) Our system is better suited for pedagogical purposes, \nas we can generate speci.c kinds of solutions that involve using certain concepts taught in a certain \nchapter of a certain textbook for a certain grade (by sim\u00adply changing the library used by our synthesizer). \nThis is in line with the kind of solution that the teacher expects the students to produce. Our system \ncan also extend a partial solution of a student to produce the nearest correct solution as opposed to \nproducing an arbitrary solution. 8. Conclusion and Future Work We presented a novel synthesis algorithm \nbased on combining nu\u00admerical methods with symbolic methods, and apply it to synthesiz\u00ading ruler-compass \nbased geometry constructions. It may be tempting to question the relevance of plane geometry constructions. \nHere one should note that plane geometry provides a good platform for teaching logical reasoning abilities \nwhile keep\u00ading it simple, visual, and fun. They are just the rules of a game mathematicians play. There \nare many other ways to do construc\u00adtions, but the compass and straightedge were chosen as one set of \ntools that make a construction challenging, by limiting what you are allowed to do, just as sports restrict \nwhat you can do (e.g. touch\u00ading but not tackling, or tackling but no nuclear weapons) in order to keep \na game interesting. Other tools could have been chosen instead; for example, geometric constructions \ncan be done using origami. [1] This paper is the .rst in the planned series of works on automat\u00ading high-school \neducation, and in particular, high-school geometry education. We have taken the .rst step towards this \ngoal and we are in the process of building an end-to-end system that can interact with users in natural \nlanguage. There is ongoing work on build\u00ading a natural language front-end for our system that will translate \nEnglish description of geometry problems to the logical problem representation described in this paper. \nThere is also ongoing work on building a paraphrasing back-end for our system that will trans\u00adlate the \nconstruction in the programming language described in this paper to natural language. The technology \nproposed in this paper forms the foundation for the following technical problems that we plan to tackle \nnext, which will help take this technology to classrooms. The work done in software engineering community \ncan play a big role in addressing some of these problems. Provide hints to students instead of the entire \nsolution.  Point out bugs in an incorrect solution of a student (taking inspiration from the work on \nbug localization techniques in the programming languages and software engineering community), and suggest \n.xes to an incorrect solution of student (perhaps using ideas from automated bug .xing techniques [40]), \n Quantify dif.culty level of a given problem (by correlating various metrics of a problem, its solution, \nand scores of students, using ideas from work on software metrics)  Generate problems of a measured \ndif.culty level. Solutions to these problems would help in realizing the goal of personalized learning \nor making teaching interactive. However, this is just a short-term goal. The real prize for investing \ninto synthesizers for such domains lies in enabling building of an ultra\u00ad  intelligent computer, and \nalso a complete model of how the human mind works [32]. References [1] http://mathforum.org/library/drmath/view/61335.html. \n[2] J. R. Anderson, C. F. Boyle, and G. Yost. The geometry tutor. In IJCAI, pages 1 7, 1985. [3] Y. Bar-David \nand G. Taubenfeld. Automatic discovery of mutual exclusion algorithms. In DISC, 2003. [4] S. Barmany, \nR. Bodik, S. Chandra, J. Galensony, D. Kimelman, C. Ro\u00addarmory, and N. Tungy. Programming with angelic \nnondeterm. In POPL, 2010. [5] B. Boigelot. On iterating linear transformations over recognizable sets \nof integers. TCS, 309(2), 2003. [6] S. Chaudhuri and A. Solar-Lezama. Smooth interpretation. In PLDI, \npages 279 291, 2010. [7] S. Chou, X. Gao, and J. Zhang. Machine Proofs in Geometry Automated Production \nof Readable Proofs for Geometric Theorems. World Scienti.c, 1994. [8] S.-C. Chou, X.-S. Gao, and J.-Z. \nZhang. Automated generation of construction steps for geometric constraint problems. In Automated reasoning \nand its applications: Essays in honor of Larry Wos, pages 49 69. 1997. [9] A. Cypher, D. C. Halbert, \nD. Kurlander, H. Lieberman, D. Maulsby, B. A. Myers, and A. Turransky. Watch what I do: programming by \ndemonstration. MIT Press, 1993. [10] X.-S. Gao and Q. Lin. Mmp/geometer: A software package for auto. \ngeometric reasoning. In Automated Deduction in Geometry, volume 2930 of LNCS. 2004. [11] T. Granlund \nand R. Kenner. Eliminating branches using a superopti\u00admizer and the gnu c compiler. In PLDI, 1992. [12] \nS. Gulwani. Dimensions in program synthesis (invited talk paper). In ACM Symposium on PPDP, 2010. [13] \nS. Gulwani. Automating string processing in spreadsheets using input\u00adoutput examples. In POPL, 2011. \n[14] S. Gulwani, S. K. Jha, A. Tiwari, and R. Venkatesan. Synthesis of loop-free programs. In PLDI, 2011. \n[15] B. Harris and S. Gulwani. Spreadsheet table transformations from examples. In PLDI, 2011. [16] S. \nItzhaky, S. Gulwani, N. Immerman, and M. Sagiv. A simple inductive synthesis methodology and its applications. \nIn OOPSLA, pages 36 46, 2010. [17] N. Jackiw. The geometer s sketchpad. Key Curriculum Press, Berke\u00adley, \n1991-1995, http://www.keypress.com. [18] S. Jha, S. Gulwani, S. Seshia, and A. Tiwari. Oracle-guided \ncomponent-based program synthesis. In ICSE, 2010. [19] D. Kapur. Using Gr\u00a8obner bases to reason about \ngeometry problems. J. Symb. Comput., 2(4), 1986. [20] S. Katayama. Systematic search for lambda expressions. \nIn Trends in Func. Programming, 2005. [21] G. Katz and D. Peled. Genetic programming and model checking: \nSynthesizing new mutual exclusion algorithms. In ATVA, pages 33 47, 2008. [22] U. Kortenkamp and J. Richter-gebert. \nUsing auto. theorem proving to improve the usability of geometry software. In Mathematical User Interfaces, \n2004. [23] V. Kuncak, M. Mayer, R. Piskac, and P. Suter. Complete functional synthesis. In PLDI, 2010. \n[24] J.-M. Laborde and F. Bellemain. Cabri-geometry ii. http://www. cabri.net (1993-1998). [25] T. Lau, \nL. Bergman, V. Castelli, and D. Oblinger. Programming shell scripts by demonstration. In Workshop on \nSupervisory Control of Learning and Adaptive Systems, AAAI, 2004. [26] T. A. Lau, P. Domingos, and D. \nS. Weld. Version space algebra and its application to programming by demonstration. In ICML, pages 527 \n534, 2000. [27] N. Matsuda and K. Vanlehn. Gramy: A geometry theorem prover capable of construction. \nJ. Autom. Reason., 32:3 33, January 2004. [28] J. M. Robertson. Geometric Constructions Using Hinged \nMirrors, pages 380 386. May 1996. [29] P. Rondon. Programming lang. or how to sweet talk a computer, \n2010. cseweb.ucsd.edu/~prondon/talks/plintro.pdf. [30] C. V. Sanders. Sharing Teaching Ideas: Geometric \nConstructions: Visualizing and Understanding Geometry, pages 554 556. October 1998. [31] J. T. Schwartz. \nFast probabilistic algorithms for veri.cation of poly\u00adnomial identities. J. ACM, 27(4):701 717, 1980. \n[32] L. Shustek. An interview with Ed Feigenbaum. Commun. ACM, 53(6):41 45, 2010. [33] A. Solar-Lezama. \nProgram Synthesis by Sketching. PhD thesis, University of California, Berkeley, 2008. [34] A. Solar-Lezama, \nC. G. Jones, and R. Bod\u00b4ik. Sketching concurrent data structures. In PLDI, 2008. [35] S. Srivastava, \nS. Gulwani, S. Chaudhuri, and J. Foster. Path-based inductive synthesis for program inversion. In PLDI, \n2011. [36] S. Srivastava, S. Gulwani, and J. S. Foster. From program veri.cation to program synthesis. \nIn POPL, pages 313 326, 2010. [37] A. Taly, S. Gulwani, and A. Tiwari. Synthesizing switching logic using \nconstraint solving. In VMCAI, pages 305 319, 2009. [38] A. Tarski. A Decision Method for Elementary Algebra \nand Geometry. University of California Press, 1948. [39] M. T. Vechev and E. Yahav. Deriving linearizable \n.ne-grained con\u00adcurrent objects. In PLDI, 2008. [40] W. Weimer, T. Nguyen, C. L. Goues, and S. Forrest. \nAutomatically .nding patches using genetic programming. In ICSE, pages 364 374, 2009. [41] S. Wilson \nand J. D. Fleuriot. Combining dynamic geometry, auto\u00admated geometry theorem proving and diagrammatic \nproofs. In UITP, 2005. [42] W.-T. Wu. Basic principles of mechanical theorem proving in elemen\u00adtary geometrics. \nJ. Autom. Reason., 2(3), 1987. [43] J. Zhang, L. Yang, and M. Deng. The parallel numerical method of \nmechanical theorem proving. Theor. Comp. Sci., 74:253 271, 1990.   \n\t\t\t", "proc_id": "1993498", "abstract": "<p>In this paper, we study the problem of automatically solving ruler/compass based geometry construction problems. We first introduce a logic and a programming language for describing such constructions and then phrase the automation problem as a program synthesis problem. We then describe a new program synthesis technique based on three key insights: (i) reduction of symbolic reasoning to concrete reasoning (based on a deep theoretical result that reduces verification to random testing), (ii) extending the instruction set of the programming language with higher level primitives (representing basic constructions found in textbook chapters, inspired by how humans use their experience and knowledge gained from chapters to perform complicated constructions), and (iii) pruning the forward exhaustive search using a goal-directed heuristic (simulating backward reasoning performed by humans). Our tool can successfully synthesize constructions for various geometry problems picked up from high-school textbooks and examination papers in a reasonable amount of time. This opens up an amazing set of possibilities in the context of making classroom teaching interactive.</p>", "authors": [{"name": "Sumit Gulwani", "author_profile_id": "81100315615", "affiliation": "Microsoft Research, Redmond, WA, USA", "person_id": "P2690477", "email_address": "sumitg@microsoft.com", "orcid_id": ""}, {"name": "Vijay Anand Korthikanti", "author_profile_id": "81453654960", "affiliation": "University of Illinois at Urbana-Champaign, Urbana Champaign, USA", "person_id": "P2690478", "email_address": "vkortho2@uiuc.edu", "orcid_id": ""}, {"name": "Ashish Tiwari", "author_profile_id": "81100398928", "affiliation": "SRI International, Menlo Park, USA", "person_id": "P2690479", "email_address": "tiwari@csl.sri.com", "orcid_id": ""}], "doi_number": "10.1145/1993498.1993505", "year": "2011", "article_id": "1993505", "conference": "PLDI", "title": "Synthesizing geometry constructions", "url": "http://dl.acm.org/citation.cfm?id=1993505"}