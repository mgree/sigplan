{"article_publication_date": "06-04-2011", "fulltext": "\n Directed Incremental Symbolic Execution Suzette Person Guowei Yang Neha Rungta NASA Langley Research \nCenter University of Texas at Austin NASA Ames Research Center suzette.person@nasa.gov gyang@ece.utexas.edu \nneha.s.rungta@nasa.gov Sarfraz Khurshid University of Texas at Austin khurshid@ece.utexas.edu Abstract \nThe last few years have seen a resurgence of interest in the use of symbolic execution a program analysis \ntechnique developed more than three decades ago to analyze program execution paths. Scaling symbolic \nexecution and other path-sensitive analysis techniques to large systems remains challenging despite recent \nalgorithmic and technological advances. An alternative to solving the problem of scalability is to reduce \nthe scope of the analysis. One approach that is widely studied in the context of regression analysis \nis to analyze the differences between two related program versions. While such an approach is intuitive \nin theory, .nding ef.cient and precise ways to identify program differences, and characterize their effects \non how the program executes has proved challenging in practice. In this paper, we present Directed Incremental \nSymbolic Exe\u00adcution (DiSE), a novel technique for detecting and characterizing the effects of program \nchanges. The novelty of DiSE is to combine the ef.ciencies of static analysis techniques to compute program \ndifference information with the precision of symbolic execution to explore program execution paths and \ngenerate path conditions af\u00adfected by the differences. DiSE is a complementary technique to other reduction \nor bounding techniques developed to improve sym\u00adbolic execution. Furthermore, DiSE does not require analysis \nre\u00adsults to be carried forward as the software evolves only the source code for two related program versions \nis required. A case-study of our implementation of DiSE illustrates its effectiveness at detecting and \ncharacterizing the effects of program changes. Categories and Subject Descriptors D.2.5 [Software Engineer\u00ading]: \nTesting and Debugging Symbolic execution General Terms Veri.cation, Algorithms Keywords Program Differencing, \nSymbolic Execution, Software Evolution Copyright 2011 Association for Computing Machinery. ACM acknowledges \nthat this contribution was authored or co-authored by a contractor or af.liate of the U.S. Government. \nAs such, the Government retains a nonexclusive, royalty-free right to publish or reproduce this article, \nor to allow others to do so, for Government purposes only. PLDI 11 June 4 8, San Jose, California, USA \nCopyright c &#38;#169; 2011 ACM 978-1-4503-0663-8/11/06. . . $10.00 1. Introduction Over the last three \ndecades, symbolic execution [7, 22] a program analysis technique for systematic exploration of program \nexecu\u00adtion paths using symbolic input values has provided a basis for various software testing and veri.cation \ntechniques. For each path it explores, symbolic execution builds a path condition, i.e., con\u00adstraints \non the symbolic inputs, that characterizes the program ex\u00adecution path. During symbolic execution, satis.ability \nchecks are performed each time a constraint is added to the path condition to determine the feasibility \nof the path; if a path condition becomes unsatis.able, it represents an infeasible path and symbolic \nexecu\u00adtion does not consider any other paths that contain the known infea\u00adsible path as its pre.x. The \nset of path conditions computed by sym\u00adbolic execution can be used to perform various analyses of program \nbehavior, for example, to check conformance of code to rich behav\u00adioral speci.cations using automated \ntest input generation [10, 19]. Initial work on symbolic execution largely focused on checking properties \nof programs with primitive types, such as integers and booleans [7, 22]. Several recent projects generalized \nthe core ideas of symbolic execution which enabled it to be applied to programs with more general types, \nincluding references and arrays [4, 10, 12, 19, 32]. These generalizations have been complimented by \nrecent advances in constraint solving, which is the key supporting technology that affects the effectiveness \nof symbolic execution checking path conditions for satis.ability relies heavily on the capabilities of \nthe underlying constraint solvers. During the last few years, not only has raw computing power increased, \nenabling more ef.cient constraint solving, but basic constraint solving technology has also advanced \nconsiderably, speci.cally in leveraging multiple decision procedures in synergy, for example, as in Satis.ability \nModulo Theory (SMT) solvers [9]. Scaling symbolic execution, as with other path-sensitive anal\u00adyses, \nremains challenging because of the large number of execu\u00adtion paths generated during the symbolic analysis. \nThis is known as the path explosion problem, and despite recent advances in re\u00adduction and abstraction \ntechniques, remains a fundamental chal\u00adlenge to path-sensitive analysis techniques. A large body of work \nhas been dedicated to developing techniques that try to achieve bet\u00adter scalability [1, 3, 11, 20]. One \nalternative approach to solving the problem of scalability is to reduce the scope of the analysis to \nonly certain parts of the program. Regression analysis is a well known example where the differ\u00adences \nbetween program versions serve as the basis to reduce the scope of the analysis [14, 35, 38]. Analyses \nbased on program differences are attractive and have considerable potential bene.ts since most software \nis developed following an evolutionary pro\u00adcess. And, with the recent push toward agile development, \ndiffer\u00adences between two program versions tend to be small and local\u00adized. The challenge, however, lies \nin determining precisely which program execution behaviors are affected by the program changes. Techniques \nto identify modi.ed parts of the program can be broadly classi.ed into two categories: syntactic and \nsemantic. Syntactic techniques consider differences in the program source code or some other static representation \nof the source and can be computed ef.\u00adciently. Semantic techniques are typically more expensive, but \nalso compute generally more precise differences by considering the dif\u00adferences in the execution behaviors \nof the program.  In Directed Incremental Symbolic Execution (DiSE), our insight is to combine the ef.ciencies \nof static analysis techniques that com\u00adpute program difference information with the precision of symbolic \nexecution. The path conditions computed by DiSE then charac\u00adterize the differences between two related \nprogram versions. The essence of symbolic execution is that it abstracts the semantics of program behaviors \nby generating constraints on the program inputs. The constraints for a given program execution behavior \n(path), re\u00adferred to as a path condition, encode the input values that will cause execution to follow \nthat path. The goal of this work is to direct symbolic execution on a modi.ed program version to explore \npath conditions that may be affected by the changes. Consider a set of concrete (actual) input values \nthat generate paths p and p' in the original and modi.ed versions of the program respectively. If sym\u00adbolic \nexecution of p and p' result in different path conditions, then the path condition generated along p' \nis termed as affected. Affected path conditions can be solved to generate values for the variables which, \nwhen used to execute the program, exhibit the affected program behaviors. The results of DiSE can then \nbe used by subsequent program analysis techniques to focus on only the program behaviors that are affected \nby the changes to the program. DiSE enables other program analysis techniques to ef.ciently per\u00adform \nsoftware evolution tasks such as program documentation, re\u00adgression testing, fault localization and program \nsummarization. The novelty of DiSE is to leverage the state-of-the-art in sym\u00adbolic execution and apply \nstatic analyses in synergy to enable more ef.cient symbolic execution of programs as they evolve. Static \nanalysis and symbolic execution form the two phases in DiSE. Pro\u00adgram instructions whose execution may \nlead to the generation of affected path conditions are termed as affected locations or affected instructions. \nThe goal of the .rst phase is to generate the set of af\u00adfected program instructions. The static analysis \ntechniques in the .rst phase are based on intra-procedural data and control .ow de\u00adpendences. The dependence \nanalyses are used to identify instruc\u00adtions in the source code that de.ne program variables relevant \nto changes in the program. Conditional branch instructions that use those variables, or are themselves \naffected by the changes, are also identi.ed as affected. In the second phase, the information gener\u00adated \nby the static analysis is used to direct symbolic execution to ex\u00adplore only the parts of the programs \naffected by the changes, poten\u00adtially avoiding a large number of unaffected execution paths. DiSE generates, \nas output, path conditions only on conditional branch in\u00adstructions that use variables affected by the \nchange or are otherwise affected by the changes. In this work, we develop a conceptual framework for \nDiSE, implement a prototype of our framework in the Java PathFinder symbolic execution framework [26, \n28, 36], present a case-study to demonstrate the effectiveness of our approach, and demonstrate, as a \nproof of concept, how the framework enables incremental pro\u00adgram analysis to perform software evolution \nrelated tasks. For the examples used in our case-study, DiSE consistently explores fewer states and takes \nless time to generate fewer path conditions com\u00adpared to standard symbolic execution when the changes \naffect only a subset of the program execution paths. This demonstrates the ef\u00adfectiveness of DiSE in \nterms of reducing the cost of symbolic ex\u00adecution of evolving software. Furthermore, we apply the results \nof our analysis to test case selection and augmentation to demonstrate the utility of such an analysis. \nWe make the following contributions: A novel incremental analysis that leverages the state-of-the-art \nin symbolic execution and applies a static analysis in synergy to enable ef.cient symbolic execution \nof programs as they un\u00addergo changes.  A technique for characterizing program differences by generat\u00ading \npath conditions affected by the changes.  A case-study that demonstrates the effectiveness of DiSE in \nre\u00adducing the cost of performing symbolic execution and illus\u00adtrates how DiSE results can be used to \nsupport software evo\u00adlution tasks.  2. Background and Motivation We begin with a brief explanation of \nsymbolic execution, the un\u00adderlying algorithm used in DiSE. Next, we present an example to demonstrate \nthe motivation for the development of DiSE. 2.1 Symbolic Execution Symbolic execution is a program analysis \ntechnique for systemati\u00adcally exploring a large number of program execution paths [7, 22]. It uses symbolic \nvalues in place of concrete (actual) values as pro\u00adgram inputs. The resulting output values are computed \nas expres\u00adsions de.ned over constants and symbolic input values, using a speci.ed set of operators. A \nsymbolic execution tree characterizes all execution paths ex\u00adplored during symbolic execution. Each node \nin the tree represents a symbolic program state, and each edge represents a transition be\u00adtween two states. \nA symbolic program state contains a unique pro\u00adgram location identi.er (Loc), symbolic expressions for \nthe sym\u00adbolic input variables, and a path condition (PC). During symbolic execution, the path condition \nis used to collect constraints on the program expressions, and describes the current path through the \nsymbolic execution tree. Path conditions are checked for satis.a\u00adbility during symbolic execution; when \na path condition is infea\u00adsible, symbolic execution stops exploration of that path and back\u00adtracks. In \nprograms with loops and recursion, in.nitely long exe\u00adcution paths may be generated. In order to guarantee \ntermination of the execution in such cases, a user-speci.ed depth bound is pro\u00advided as input to symbolic \nexecution. We illustrate symbolic execution with the following example: int y; ... int testX(int x){ \n 1: if(x>0) 2: y=y+x; 3: else 4: y=y-x; 5: } This code fragment introduces two symbolic variables: Y \n, the sym\u00adbolic representation of the integer .eld y, and X, the symbolic rep\u00adresentation of the integer \nargument x to procedure testX. For this example, symbolic execution explores the two feasible behaviors \nshown in the symbolic execution tree in Figure 1. When program execution begins, the path condition is \nset to true. When X> 0 evaluates to TRUE at line 1 in the source code, the expression Y +X  Figure \n1. Symbolic execution tree for testX() is computed and stored as the value of y. When !(X> 0), the expression \nY - X is computed and stored as the value of y.A symbolic summary for procedure testX is made up of path \ncon\u00additions that represent the feasible execution paths in testX. The path conditions in the symbolic \nsummary can be used as input to a subsequent analysis, e.g., the solved path conditions can be used as \nregression test case inputs.  2.2 Motivating Example We use the example in Fig. 2 to illustrate how \nDiSE lever\u00adages information about program changes to direct symbolic exe\u00adcution and generate path conditions \naffected by the changes. Con\u00adsider the source code for method update(int PedalPos, int BSwitch, int PedalCmd) \nshown in Fig. 2(a). The update pro\u00adcedure sets the value of two global variables, AltPress and Meter, \nbased on the input values of its arguments. Assume a change was made to the update method at line 2 in \nFig. 2(a) where the compar\u00adison operator is changed from == to <=, as shown in the modi.ed version of \nupdate presented in Fig. 2(a). Using full symbolic ex\u00adecution to validate this change results in 21 path \nconditions, each of which represents a program execution path of the modi.ed ver\u00adsion of update. As expected, \nthe results of full symbolic execution include all execution paths for update, and no distinction is \nmade between affected and unaffected program paths. And, as a result, any validation technique which \nuses these results may unneces\u00adsarily analyze unaffected program behaviors. For a small example such \nas this, a full analysis may be feasible; however, for larger methods or when complex constraints are \ninvolved, a full analysis may be infeasible. To characterize the effects of the change to update using \nDiSE, we .rst compute the set of affected program locations. Consider the CFG computed for the modi.ed \nversion of update shown in Fig. 2(b). Each node corresponds to a program location in the source code; \nwe use the node label to identify the corresponding code statement(s), and a node identi.er appears in \nitalics just out\u00adside the node, e.g., n1, n2, etc. Edges between the nodes represent possible .ow of \nexecution between the nodes. Nodes in the CFG that correspond to affected and changed program instructions \nare termed as affected and changed nodes respectively. DiSE uses the results of a lightweight source \n.le differential analysis to identify n0 as having a direct correspondence to the change at line 2. The \nresults of the static analysis computing af\u00adfected locations indicate that nodes n1, n3, n4, n5, n11, \nn13, and n14 are affected write nodes nodes that because of the change at line 2, may affect subsequent \nexecution of a control node. Nodes n0, n2, n10, and n12 are affected control nodes nodes that may be \naffected by the change and that may affect the path condition. The information about affected locations \nis used to direct symbolic 1: int AltPress := 0; int Meter := 2 /* Global Vars */ procedure update(int \nPedalPos, int BSwitch, int PedalCmd) 2: if PedalPos <=0/* changed conditional */ then 3: PedalCmd = PedalCmd \n+1 4: else if PedalPos == 1 then 5: PedalCmd = PedalCmd +2 6: else PedalCmd = PedalPos 7: 8: PedalCmd \n= PedalCmd +1 9: 10: if BSwitch == 0 then 11: Meter =1 12: else if BSwitch == 1 then 13: Meter =2 14: \n15: if PedalCmd == 2 then 16: AltPress =0 17: else if PedalCmd == 3 then 18: AltPress =1/4 19: else AltPress \n=1/2 (a) nbegin n0 : changed conditional 2: PedalPos <=0 true false 3: PedalCmd = PedalCmd +1 4: PedalPos \n== 1 n2 n1 true false 5: PedalCmd = PedalCmd +2 6: PedalCmd = PedalPos n3 n4 8: PedalCmd = PedalCmd \n+1 n5 10 : BSwitch == 0 n6 true false 11 : Meter =1 12: BSwitch == 1 n8 n7 13 : Meter =2 n9 15 : PedalCmd \n== 2 n10 true false 16 : AltPress =0 17: PedalCmd == 3 n12 true n11 false 18 : AltPress =1/4 19: AltPress \n=1/2 n14 n13 nend (b) Figure 2. A simpli.ed version of a Wheel Brake System. (a) Example program. (b) \nControl .ow graph. execution of the modi.ed version of update to explore only the program behaviors affected \nby the change. Pruning. To illustrate how DiSE prunes symbolic execution using the set of affected locations, \nconsider a feasible execution path, p0 := (n0,n1,n5,n6,n7,n10,n11), generated during di\u00adrected symbolic \nexecution. The path p0 contains the sequence of affected nodes, (n0,n1,n5,n10,n11), and the sequence \nof un\u00adaffected nodes, (n6,n7). However, another feasible path, p1 := (n0,n1,n5,n6,n8,n9,n10,n11), is \npruned during symbolic exe\u00adcution because the sequence of affected nodes is already covered by p0. The \nonly difference between p0 and p1 is the sequence of un\u00adaffected nodes p1 contains (n6,n8,n9) as the \nsequence of unaf\u00adfected nodes. DiSE applies the same pruning technique throughout symbolic execution \nto generate a total of seven path conditions for update, versus the 21 path conditions generated by full \nsymbolic execution. Each path condition generated by DiSE characterizes a program execution path that \nis affected by the change to update.  3. Directed Incremental Symbolic Execution In this section we \n.rst provide a high level overview of our DiSE technique. We then present the two main algorithms of \nDiSE that compute the set of affected path conditions. 3.1 Overview Inputs to DiSE. The inputs to DiSE \nare the control .ow graphs (CFGs) for two versions of a procedure, base and mod, and the results of a \nlightweight differential (diff ) analysis (e.g., source line or abstract syntax tree diff ) comparing \nthe two versions of the procedure. The results of the diff analysis identify the locations of the differences \nin the source code between base and mod. During a pre-processing step, DiSE maps the change information \nto the corresponding nodes in each CFG. The CFG for the base version, CFGbase , has nodes marked as removed, \nchanged, or unchanged with respect to the CFG of the modi.ed version, CFGmod . The nodes in CFGmod are \nmarked as added, changed, or unchanged with respect to CFGbase . The results of the diff analysis are \nalso used to compute a map (di.Map) that stores information relating nodes in CFGbase to their corresponding \nnodes in CFGmod . Computing Affected Locations. DiSE begins by performing a conservative, intra-procedural \nanalysis to compute the set of nodes in CFGmod that may be affected by the removed nodes in CFGbase or \nby the changed and added nodes in CFGmod . This static anal\u00adysis uses control dependence and data .ow \ninformation to gener\u00adate the set of affected CFG nodes in CFGmod . These nodes corre\u00adspond to conditional \nbranch statements and to write statements in the modi.ed version of the program that either in.uence, \nor may be in.uenced by the modi.cations made to the procedure, and as a result, may affect the path conditions \ncomputed by symbolic exe\u00adcution. Affected conditional branch nodes directly lead to the gen\u00aderation of \naffected path conditions. Affected write nodes indirectly lead to the generation of affected path condition \nthey either de.ne a variable that may be subsequently read at an affected branch node, or the reachability \nof the affected write nodes is control dependent on an affected conditional branch node. Directed Symbolic \nExecution. During this step, DiSE per\u00adforms a form of incremental symbolic execution on the modi.ed version \nof the procedure, leveraging the information computed dur\u00ading the previous step to explore only the parts \nof the program that are changed with respect to the base version of the procedure. The affected nodes \ninformation directs DiSE to explore only (feasible) paths where one or more affected nodes in CFGmod \nare reachable on that path, and that sequence of affected nodes has not yet been explored. If either \nof these conditions is not met, then symbolic execution backtracks. By effectively pruning paths that \ngenerate unaffected path conditions, DiSE avoids the cost of exploring exe\u00adcution paths in the modi.ed \nprogram version that are not affected by the change(s) to the program. The resulting set of path condi\u00adtions \ncomputed by DiSE then characterizes the set of program ex\u00adecution behaviors in the modi.ed version of \nthe procedure that are affected by the change(s). Each (directly or indirectly) affected con\u00additional \nbranch node on the path is represented by a constraint in the path condition; conditional branch nodes \nthat are not affected by the changes are represented by a constraint that represents a fea\u00adsible path \nthrough the unaffected parts of the program.  3.2 Computing Affected Locations The set of affected program \nlocations is computed using conserva\u00adtive static analyses based on control and data dependences. The \nanalysis is performed at an intra-procedural (per-method) level. The corresponding rami.cation is that \nDiSE does not generate af\u00adfected path conditions arising from changes at the inter-procedural (sequence \nof methods) level. Extending the technique for inter\u00adprocedural system level analysis is part of our \nfuture work. We .rst present background de.nitions related to control .ow graphs, con\u00adtrol dependence, \nand data .ow in order to de.ne the rules DiSE uses to generate the affected locations sets. De.nition \n3.1. A Control .ow graph (CFG) of a procedure in the program is a directed-graph represented formally \nby a tuple (N, E). N is the set of nodes, where each node is labeled with a unique program location identi.er. \nThe edges, E . N \u00d7 N, represent possible .ow of execution between the nodes in the CFG. Each CFG has \na single begin, nbegin , and end, nend , node. All the nodes in the CFG are reachable from the nbegin \nand the nend node is reachable from all nodes in the CFG. De.nition 3.2. (Check for a CFG Path) is a \nmap IsCFGPath : N \u00d7 N .{T,F } that returns true for a pair of nodes (ni,nj ) if there exists a sequence \nof nodes p := (n0,n1,...) such that (nk,nk+1) . E for 0 = k =|p|- 1 and n0 = ni, n|p|-1 = nj ; otherwise \nit returns false. De.nition 3.3. Vars is the set of variable names that are either read or written to \nin a procedure. De.nition 3.4. Cond is the set of nodes Cond . N where n . Cond is a conditional branch \ninstruction. De.nition 3.5. Write is the set of nodes Write . N where n . Write is a write instruction. \nDe.nition 3.6. (Variable De.nitions) is a map Def : N . Vars . {.} that returns a variable v . Vars if \nthe variable, v, is de.ned at node n . N; otherwise returns .. De.nition 3.7. (Variable Uses) is a map \nUse : N . 2Vars . {.} that returns a set of variables V . Vars where v . V is a variable being read at \nnode n; otherwise returns .. De.nition 3.8. (Post Dominance) is a map postDom : N \u00d7 N . {T,F } that returns \ntrue for an input pair of nodes (ni,nj ) if, for each CFG path from ni to nend , p := (ni,...,nend ), \nthere exists a k such that nj = nk where i = k =|p|- 1 (nj post dominates ni); otherwise it returns false. \nDe.nition 3.9. (Control Dependence) is a map controlD : N \u00d7 N .{T,F } that returns true for an input \npair of nodes (ni,nj ) if node ni has two successors nk and nl such that (ni,nk), (ni,nl) . E, nk nl, \npostDom(nk,nj ) == T , and = postDom(nl,nj ) == F ; otherwise it returns false. We provide intuitive \ndescriptions for some de.nitions above us\u00ading the example in Fig. 2. The set of Vars contains variables \nAltPress, PedalPos, PedalCmd, BSwitch, and Meter. Def(n9) returns the variable Meter which is de.ned \nat line 13. Similarly the map Uses(n10) returns PedalCmd, the variable being used at line 15. The map \npostDom(n0,n5) returns true because all paths from node n0 to nend have to go through n5; an example \npath is (n0,n1,n3,n5,...,nend ). Finally, node n1 is control de\u00adpendent n0. The node n0 has two successors \nn1 and n2, where postDom(n1,n1) is true and postDom(n1,n2) is false. Approach. Two sets of affected nodes \nare computed and used by DiSE the set of affected conditional (branch) nodes, ACN , and the set of affected \nwrite nodes, AWN . These sets contain nodes in CFGmod that are marked as changed or added by the source \nline diff analysis. (Handling changes arising from remove nodes in CFGbase is described later in this \nsection.) The ACN and AWN sets are updated by applying the rules speci.ed in Fig. 3 until the sets reach \na .xed-point. The analysis is guaranteed to terminate since the ACN and AWN sets contain nodes in a CFG \n even nodes that are part of a loop are added at most once to these sets. The rules in Fig. 3 specify \nthe conditions under which DiSE adds nodes from CFGmod to the affected sets based on the con\u00adFigure 3. \nUpdating affected sets based on control and data .ow dependence.  if ni . ACN . nj . Cond . controlD(ni, \nnj ) then ACN := ACN . {nj }if ni . ACN . nj . Write . controlD(ni, nj ) (1) then AWN := AWN . {nj }if \nni . AWN . nj . Cond . Def(ni) . Use(nj ) (2) . Def(ni) = . . IsCFGPath(ni, nj ) then ACN := ACN . {nj \n} (3) if ni . Write . (nj . AWN . nj . ACN ) . Def(ni) . Use(nj ) . Def(ni)= . . IsCFGPath(ni,nj ) then \nAWN := AWN .{ni} (4) Figure 4. Updating AWN set based on reaching de.nitions. trol dependence relation \nand the resulting data .ow information. The .rst two rules Eq. (1) and Eq. (2) in Fig. 3 specify that \ncon\u00additional branches and write statements that are control dependent on a changed or added node in the \nCFGmod , are added to the af\u00adfected set. Other nodes are added to the affected sets by repeatedly applying \nthe rules that, in essence compute the transitive closure on the control dependences between the nodes. \nEq. (1) states that if there exists a node ni in ACN , and a conditional node nj such that nj is control \ndependent on ni, then nj is added to the set ACN . Similarly in Eq. (2) if nj is a write statement that \nis control depen\u00addent on ni, an element in ACN , then nj is added to AWN . Eq. (3) intuitively speci.es \nthat conditional branches that use variables de\u00ad.ned in the affected write set are added to the affected \nconditional set. If the de.nition of a variable in a write statement, ni, in AWN is used in a conditional \nbranch statement, nj , and there is a path in the CFG from ni to nj , then nj is added to ACN . The rules \nare iteratively applied until the sizes of ACN and AWN do not change. Eq. (4) in Fig. 4 is applied to \nupdate AWN based on the de.nitions of variables that reach the nodes in the affected sets, after the \nanalysis in Fig. 3 reaches a .xed-point. Eq. (4) speci.es that if a variable is de.ned at a write statement \nni that is used at node nj such that nj is in one of the affected sets, and there exists a CFG path from \nni to nj then ni is added to the AWN set. The rule speci.ed in Eq. (4) is also guaranteed to reach a \n.xed-point and terminate since the rule is applied to the nodes in the CFG. Handling Removed Instructions. \nWhen there are nodes marked as removed in CFGbase , it indicates that the corresponding node does not \nexist in CFGmod . The removed node may, however, af\u00adfect the execution of other nodes in CFGmod . The \nalgorithm to compute the effects of the removed nodes is shown in Fig. 5(a). The removeNodes algorithm \nin Fig. 5 computes the con\u00adtrol and data dependence .ow information on CFGbase . The af\u00adfected sets are \ninitialized to removed nodes, and after applying the rules in Fig. 3 and Fig. 4, the affected sets contain \nall the nodes in CFGbase that are in.uenced by the remove nodes (lines 1-3 in Fig. 5(a)). Next, for each \nof the CFGbase nodes in the affected sets the corresponding node mapping to CFGmod found in the procedure \nremoveNodes(CFGbase , di.Map) 1: ACN := getRemovedConditionalNodes(CFGbase ) 2: AWN := getRemovedWriteNodes(CFGbase \n) 3: Apply rules in Fig. 3 and Fig. 4 4: ACN := updateSets(ACN, di.Map) 5: AWN := updateSets(AW N, di.Map) \nprocedure updateSets(AN , di.Map) 6: ModN := {} 7: for each n . AN do 8: ModN := ModN .{di.Map.get(n)} \n9: return ModN (a) ACN AWN ni nj Rule {n0} {}{n0,n2} {} n0 n2 Eq. (1) {n0,n2}{n1} n0 n1 Eq. (2) {n0,n2}{n1,n3} \nn2 n3 Eq. (2) {n0,n2}{n1,n3,n4} n2 n4 Eq. (2) {n0,n2,n10}{n1,n3,n4} n1 n10 Eq. (3) {n0,n2,n10}{n1,n3,n4,n11} \nn10 n11 Eq. (2) {n0,n2,n10,n12}{n1,n3,n4,n11} n1 n12 Eq. (3) {n0,n2,n10,n12}{n1,n3,n4,n11,n13} n12 n13 \nEq. (2) {n0,n2,n10,n12}{n1,n3,n4,n11,n13,n14} n12 n14 Eq. (2) {n0,n2,n10,n12}{n1,n3,n4,n5,n11,n13,n14} \nn5 n10 Eq. (4) (b) Figure 5. Computing affected nodes. (a) Algorithm to compute af\u00adfected nodes resulting \nfrom removing certain program instructions. (b) Demonstration of the computation of affected node set \nfor the example in Fig. 2. di.Map is used to replace the elements in the affected sets (lines 4-9 in \nFig. 5(a)). Recall that the source line differential analysis provides di.Map that maps unchanged and \nchanged nodes cor\u00adresponding from CFGbase to CFGmod . For the nodes marked as removed in CFGbase the \nget method on di.Map returns the empty set. The removeNodes algorithm in Fig. 5(a) generates all nodes \naffected by program instructions removed from the base version. Finally, the affected set is updated \nwith any other changed or added nodes present in CFGmod and the computing affected set algorithm as presented \nearlier is applied to generate the .nal affected sets. Example. To illustrate how affected sets are generated, \nconsider the example in Fig. 2. Suppose, the conditional branch at line 2 has the predicate PedalPos \n== 0 in the base program version that is modi.ed to PedalPos <=0 as shown in Fig. 2. The CFG node corresponding \nto line 2 in Fig. 2(a) is n0 in Fig. 2(b). The ACN set is initialized to the lone element n0 (a changed \nnode) and the AWN set is initialized as empty. The sets are updated based on the rules in Fig. 3 as shown \nin Fig. 5(b). Node n2 in Fig. 2(b) is a conditional branch statement that is control dependent on n0 \ncausing n2 to be added to ACN . The write statements at nodes n1, n3, and n4 are added since they are \ncontrol dependent on nodes n0 or n2. Nodes n10 and n12 are added to ACN since they use the variable PedalCmd \nthat is de.ned in nodes n1, n3, and n4 contained in AWN . The write statement at node n11 is control \ndependent on n10, while the write statements at nodes n13 and n14 are control dependent on n12; hence \nnodes n11, n13, and n14 are added to AWN . Finally, when the sets ACN and AWN reach a .xed-point after \napplying the rules in Fig. 3, the Eq. (4) in Fig. 4 is applied. Applying the Eq. (4) rule adds the write \nstatement at node n5 that de.nes the variable PedalCmd and is also used at nodes n10 and n12. The affected \nsets are used to direct the symbolic execution in the next phase of DiSE.  3.3 Directed Symbolic Execution \nThe directed symbolic execution technique executes the feasible paths that contain sequences of affected \nnodes generated in the static analysis. The analysis generates path conditions that contain constraints \nrelated to the modi.cations in the program. All feasible path conditions related to the affected nodes \nare generated during the analysis. Each path condition contains a feasible instance of the conditions \ngenerated from the unchanged parts of the code. As a result, the directed symbolic execution process \ngenerates fully formed path conditions, while at the same time avoids generating many path conditions \narising from sequences of unaffected nodes in the program. This enables directed symbolic execution to \nnot only explore all branches in the symbolic execution tree in.uenced by the affected nodes but, also \nto prune the paths related to the unaffected parts of the code. The algorithm for directed symbolic execution \nis shown in Fig. 6. The inputs to the algorithm are the affected sets ACN and AWN , and a user-speci.ed \ndepth bound for the symbolic execution. The DiSE procedure is invoked with the initial symbolic state \nof the program. Recall that the symbolic state contains a current pro\u00adgram location, a symbolic representation \nof the variables, and a path condition. There are four global sets initialized on lines 3 and 4 in Fig. \n6. The sets ExCond and ExWrite track which of the affected nodes have been explored during symbolic execution \nwhile the sets UnExCond and UnExWrite track those nodes that are unexplored and still need to be explored. \nHence, ExCond and ExWrite are initialized as empty whereas UnExCond and UnExWrite are initialized to \nthe ACN and AWN sets respec\u00adtively. The DiSE procedure in Fig. 6 provides the basic search strategy. \nAt line 5, if the current state is at a depth bound greater than the user-speci.ed depth bound or the \nstate is an error, then the search returns to explore an alternate path; otherwise exploration contin\u00adues \nalong the same path. The getCFGNode method on line 6 takes as input the symbolic state, s, and returns \nthe corresponding CFG node, n. Note that the current program location of the symbolic state is used to \nmap a symbolic state to its CFG node. The proce\u00addure UpdateExploredSet is invoked with CFG node n. For \neach successor state of s that the procedure AffectedLocIsReachable returns true the DiSE procedure is \ninvoked with the corresponding successor state, exploring the relevant states in a depth-.rst manner. \nThe procedure UpdateExploredSet checks whether the input node n is contained in one of the unexplored \nsets (UnExWrite or UnExCond) in order to track the affected nodes explored dur\u00ading symbolic execution \n(lines 30 35). If the node n is contained in the unexplored write set, UnExWrite, then n is removed from \nUnExWrite and added to the explored write set, ExWrite. Sim\u00adilarly, a corresponding update is performed \non UnExCond and ExCond when n is contained within UnExCond. The procedure ResetUnExploredSet, shown at \nlines 37 42, does the reverse; removes the input node from the explored sets and adds it to the respective \nunexplored set. The AffectedLocIsReachable returns true if the CFG node, ni, corresponding to the input \nsymbolic state, si, can reach a node in the set of unexplored affected nodes to indicate that exploration \nshould continue along the path that contains si; else, it returns false indicating that the path containing \nsi is not in.uenced by the mod\u00adi.cations to the program and should be pruned. The CheckLoops procedure \nis invoked to handle generating sequences of affected nodes through loops at line 15. A temporary set \nUnExplored is initialized with the nodes in UnExWrite and UnExCond, while Explored is initialized with \nnodes from ExWrite and ExCond at lines 16 and 17. Next, when an affected node in UnExplored, nj , is \nreachable from ni; .rst, the variable isReachable is set to true, and procedure init()/* Input := ACN \n; AWN ; bound */ 1: DiSE(getInitState()) 2: 3: /* ExCond := \u00d8; ExWrite := \u00d8*/ 4: /* UnExCond := ACN ; \nUnExWrite := AWN */ procedure DiSE(s) 5: if GetDepth(s) > bound . error(s) then return 6: n := GetCFGNode(s) \n7: UpdateExploredSet(n) 8: for each si . GetSuccessors(s) do 9: if AffectedLocIsReachable(si) then 10: \nDiSE(si) 11: return 12: procedure AffectedLocIsReachable(si) 13: IsReachable := false 14: ni := getCFGNode(si) \n15: CheckLoops(ni) 16: UnExplored := UnExWrite . UnExCond 17: Explored := ExWrite . ExCond 18: for each \nnj . UnExplored do 19: if \u00acIsCFGPath(ni,nj) then continue 20: IsReachable := true 21: for each nk . Explored \ndo 22: if \u00acIsCFGPath(nj,nk) then continue 23: ResetUnExploredSet(nk) 24: return IsReachable 25: procedure \nCheckLoops(n) 26: if IsLoopEntryNode(ni) then ' 27: for each n . GetSCC(n) do ' 28: ResetUnExploredSet(n \n) 29: procedure UpdateExploredSet(n) 30: if n . UnExWrite then 31: ExWrite := ExWrite .{n} 32: UnExWrite \n:= UnExWrite \\{n} 33: if n . UnExCond then 34: ExCond := ExCond .{n} 35: UnExCond := UnExCond \\{n} 36: \nprocedure ResetUnExploredSet(n) 37: if n . ExWrite then 38: UnExWrite := UnExWrite .{n} 39: ExWrite \n:= ExWrite \\{n} 40: if n . ExCond then 41: UnExCond := UnExCond .{n} 42: ExCond := ExCond \\{n} Figure \n6. Pseudocode for the directed symbolic execution algo\u00adrithm using affected sets. second the nodes in \nthe explored sets that are reachable from unex\u00adplored sets along the execution path containing ni are \nmoved back to the unexplored set (by invoking the ResetUnExploredSet pro\u00adcedure). Resetting the unexplored \nsets enables directed symbolic execution to explore all sequences of affected nodes that lie along feasible \nexecution paths. The CheckLoops procedure allows DiSE to explore sequences of affected nodes that are \ncontained within loops. If the input node, n to CheckLoops is the entry node to a loop (line 26), then \nfor all the nodes that are part of loop (strongly connected component con\u00adtaining n GetSCC(n)) are added \nto the unexplored set if they have been previously explored by invoking the ResetUnExploredSet. A strongly \nconnected component is a set of nodes where each node can be reached from all of the other nodes, and \na strongly connected component has a single entry and a single exit point. Example. In Table 1 we show \npart of the directed symbolic exe\u00adcution performed for the example in Fig. 2. For brevity, we refer to \n CFG Node for symbolic states ExWrite ExCond UnExWrite UnExCond 1 2 3 4 5 6 7 8 9 10 11 ()(n0)(n0, n1)(n0, \nn1, n5)(n0, n1, n5, n6, n7, n10)(n0, n1, n5, n6, n7, n10, n11)(n0, n1, n5, n6, n7, n10, n12)(n0, n1, \nn5, n6, n7, n10, n12, n13)(n0, n1, n5, n6, n7, n10, n12, n14)(n0, n1, n5, n6, n8(no path)) {}{}{n1}{n1, \nn5}{n1, n5}{n1, n5, n11}{n1, n5, n11}{n1, n5, n11, n13}{n1, n5, n11, n13, n14}{n1, n5, n11, n13, n14} \n{}{n0}{n0}{n0}{n0, n10}{n0, n10}{n0, n10, n12}{n0, n10, n12}{n0, n10, n12}{n0, n10, n12} {n1, n3, n4, \nn5, n11, n13, n14}{n1, n3, n4, n5, n11, n13, n14}{n3, n4, n5, n11, n13, n14}{n3, n4, , n11, n13, n14}{n3, \nn4, n11, n13, n14}{n3, n4, n13, n14}{n3, n4}{n3, n4, n14}{n3, n4}{n3, n4} {n0, n2, n10, n12}{n2, n10, \nn12}{n2, n10, n12}{n2, n10, n12}{n2, n12}{n2, n12}{n2}{n2}{n2}{n2} (n0,n2) {n1} CFG nodes corresponding \nto symbolic states when describing the execution and sequence of states. For example the second column \nin Table 1 shows a sequence of CFG nodes corresponding to the sequence of symbolic states generated during \nsymbolic execution. The ExWrite and ExCond are initialized to the empty set, while the UnExWrite and \nUnExCond are initialized to the respective affected sets. At n0, an affected conditional node is moved \nfrom UnExCond to ExCond at line 2 in Table 1; similar updates oc\u00adcur at lines 3, 4, 5, and 7. At lines \n4 and 5 in Table 1, execution continues along the successor states since a node in an unexplored set \nis reachable from the last node in the sequence. For example, at line 4, node n10 in UnExCond is reachable \nfrom n5 at the end of the sequence (n0,n1,n5). There is no path to any nodes in the unexplored sets at \nline 10 in Table 1 from n8. In Table 1, at line 11, nodes are moved from explored to the unexplored set. \nThe explored conditional branches n10 and n12 are reachable from node n2, and the explored write instructions \nn5, n11, n13, and n14 are reachable from n2 as seen in Fig. 2(b); as node n2 is added to explored set, \nnodes n5, n10, n11, n12, n13, and n14 are added back to the unexplored sets in order for DiSE to explore \ndifferent sequences of affected nodes and generate corresponding feasible execution paths (if possible). \nTheorem 3.10. For any sequence of affected nodes that lie on some feasible execution path within the \nspeci.ed depth bound, DiSE explores one execution path containing that sequence of nodes. Proof Sketch. \nBy contradiction. There are two cases to consider: I) There exists a feasible path (within the speci.ed \ndepth bound) that contains a sequence of affected nodes, which DiSE does not explore and II) DiSE explores \nmore than one feasible execution path for some sequence of affected nodes (within the speci.ed depth \nbound). Case I Let q := (n1,...,nk) be a sequence of affected nodes, which is not explored by DiSE but \nis contained in a feasible ex\u00adecution path. By construction, DiSE must explore n1, since it is an affected \nnode that is added to UnExWrite or UnExCond during initialization. Assume ni is the .rst node in q such \nthat DiSE explores a feasible path, p, that contains the sub-sequence (n1,...,ni-1) but does not explore \nan execution path that con\u00adtains the sub-sequence (n1,...,ni). Consider DiSE s exploration of p when \nit processes node ni-1. Since ni is reachable from ni-1 and is an affected node, ni must be contained \nin UnExWrite or UnExCond (line 23). Hence DiSE will explore a path that con\u00adtains the sub-sequence (n1,...,ni). \nContradiction. Case II Assume for a sequence of affected nodes that lie on path p explored by DiSE, it \nexplores another path p ' containing the same sequence of affected nodes. Let n be the last affected \nnode on path p such that the p and p ' have the exact same sub\u00adsequence of affected and unaffected nodes \nup to and including n. Let q := (n, n1 ...nk,m) be the sub-sequence of nodes on p {n0,n2} {n3,n4,n5,n11,n13,n14} \nTable 1. Part of the directed symbolic execution performed on the example in Fig. 2. {n10,n12} such that \neach ni is an unaffected node and m is an affected node. ' '' Let q := (n, n 1 ...n j ,m) be the corresponding \nsub-sequence of nodes on p ' . By the construction of the algorithm in Fig. 6, when DiSE considers the \naffected node n, it only explores one path and prunes the others by controlling the unexplored and unexplored \nsets in the UpdateExploredSets and ResetUnExploredSet until the next affected node, which in this case \nis m. Hence, q and q ' are identical. Contradiction. 4. Evaluation In this section we evaluate the effectiveness \nof DiSE at generating affected path conditions relative to the path conditions generated by full symbolic \nexecution of the changed methods in evolving software. To perform our evaluation, we implemented DiSE \nand performed a case-study on three Java applications, comparing the results of DiSE with full, traditional \nsymbolic execution of the changed versions of the method. We begin this section with a description of \nour implementation of DiSE. 4.1 Tool Support We implemented DiSE in Symbolic PathFinder (SPF) [26, 28], \na symbolic execution extension to the Java PathFinder model checker a Java bytecode analysis framework \n[36]. SPF is an open source execution engine that symbolically executes Java bytecode. SPF supports a \nvariety of constraint solvers/decision procedures for solving path conditions; in this work we use the \nChoco constraint solver [6]. In general, state matching is undecidable when states represent path conditions \non unbounded input data. Hence, SPF does not perform any state matching and explores the symbolic execution \ntree using a stateless search. Furthermore, if the solver is unable to determine the satis.ability of \nthe path condition within a certain time bound, SPF treats the path condition as unsatis.\u00adable. While \nthis situation does not occur for any of the artifacts in our study, this limitation of constraint solvers \ncould affect DiSE, causing it to miss generating affected path conditions in the mod\u00adi.ed program. Loops \nand recursion can be bounded by placing a depth limit on the search depth in SPF or by limiting the number \nof constraints encoded for any given path; SPF indicates when one of these bounds has been reached during \nsymbolic execution. There are no loops or recursive calls in the artifacts used in our empirical study, \nhence, we do not specify a depth bound. DiSE extends SPF by implementing custom data and control de\u00adpendence \nanalyses that compute a conservative approximation of the the affected locations for a changed method. \nDiSE performs these analyses when the the modi.ed method is invoked during symbolic execution, and then \nuses the information about the af\u00adfected locations to direct symbolic execution within SPF.  4.2 Case-Study \nThe goal of our technique is to direct symbolic execution on a modi.ed program version to explore only \nprogram conditions that are affected by the changes to the source code. We evaluate the cost and effectiveness \nof DiSE relative to full symbolic execution on the changed methods by considering the following research \nquestions: RQ1: How does the cost of applying DiSE compare to full sym\u00adbolic execution on the changed \nmethod? RQ2: How does the number of affected path conditions generated by DiSE compare with the number \nof path conditions generated by full symbolic execution? 4.2.1 Artifacts To evaluate DiSE we compared \nmethod versions from three Java artifacts. The .rst program, the Wheel Brake System (WBS), is a synchronous \nreactive component from the automotive domain. The Java model is based on a Simulink model derived from \nthe WBS case example found in ARP 4761 [17, 30]. We use the update(int PedalPos, boolean AutoBrake, boolean \nSkid) method in WBS to evaluate DiSE. This method determines how much braking pressure to apply based \non the environment. The Simulink model was translated to C using tools developed at Rockwell Collins \nand manually translated to Java. It consists of one class and 231 source lines of code. Our second artifact \nis a version of the Java program used to model NASA s On-board Abort Executive (OAE) . The OAE mod\u00adels \nthe Crew Exploration Vehicle s prototype ascent abort handling software, receiving its inputs from sensors \nand other software com\u00adponents. The inputs are analyzed to determine the status of the as\u00adcent .ight \nrules and to evaluate which ascent abort modes are feasi\u00adble. Once a .ight rule is broken and an abort \nmode is selected, it is relayed to the rest of the system for initiation. The version of OAE evaluated \nfor this work consists of .ve classes. The method under analysis consists of approximately 150 source \nlines of code. The third artifact we used to evaluate DiSE is the Altitude Switch (ASW) application. \nThis program is a synchronous reactive component from the avionics domain. It turns power on to a Device \nOf Interest (DOI) when the aircraft descends below a threshold al\u00adtitude above ground level (AGL). It \nwas developed as a Simulink model, and was automatically translated to Java using tools devel\u00adoped at \nVanderbilt University [34]. To evaluate DiSE in an empirical study we required multiple versions of each \nmethod being analyzed. Because multiple versions of these artifacts were not available, we generated \nversions by manually creating mutants of the base version (v0) of the method under analysis. When creating \nmutants, we considered a broad range of changes that can be applied to the code: change location, change \ntype and number of changes. We introduced changes at the beginning, middle and end of each method. We \nalso considered the control structures in the code, and make changes at various depths in nested control \nstructures. Each mutant has one, two or three changed Java statements, resulting in up to nine changed \nnodes in the CFG for the changed version of a method as shown in Table 4.2.1. In the WBS example, versions \n1 6 contain a single changed Java source statement, versions 7 11 contain two changed state\u00adments and \nversions 12 16 contain three changed statements. For the ASW example, we made a single change to versions \n1 11, and two changes to versions 12 15. For the OAE example, a single change was made to versions 1 \n6, two changes are made to ver\u00adsions 7 and 8, and version 9 contains three changed Java source statements. \nThe versions that contain multiple changes were cre\u00adated by combining the individual mutations made to \nversions with a single change. For example, version 12 of the WBS example con\u00adtains the same individual \nchanges as versions 1, 4, and 5. Each change involved the addition, removal or modi.cation of a state\u00adment. \nControl statements were modi.ed by mutating the compari\u00adson operator, e.g., from < to <=, or the operand, \ne.g., mutating the program variables involved in the comparison. Non-control state\u00adments were modi.ed \nby changing the value assigned to a program variable. 4.2.2 Variables and Measures The independent variable \nin our study is the symbolic execution al\u00adgorithm used in our empirical study. We use the DiSE algorithm, \nand as a control, we use full (traditional) symbolic execution as im\u00adplemented in the SPF framework. \nFor our study, we selected three dependent variables and measures: 1) time, 2) states explored, and 3) \nnumber of path conditions generated. Time is measured as the to\u00adtal elapsed time reported by SPF. It \nincludes the time spent comput\u00ading the affected program locations and the time spent performing symbolic \nexecution. States explored provides a count of the num\u00adber of symbolic states generated during symbolic \nexecution. Num\u00adber of path conditions generated provides a count of the number of program execution paths \ngenerated by a given technique. Time and states explored are used to relate the cost of DiSE to the cost \nof full symbolic execution of the changed method (RQ1), while number of path conditions generated is \nused to judge the effectiveness of DiSE relative to full symbolic execution (RQ2). 4.2.3 Experiment \nSetup To perform our study, we compiled all of our artifacts using Java version 1.6.0 22. We used a custom \nJava application to perform a lightweight diff analysis comparing the abstract syntax tree (AST) for \neach mutant with the AST for the base version of the program. We then analyzed each mutant version with \nDiSE, using the results of the AST diff. We also performed symbolic execution on each mutant using standard \nsymbolic execution in SPF (JPF v6). The study was performed on a MacBook Pro running at 2.26 GHz with \n2 GB of memory and running Mac OS X version 10.5.8.  4.2.4 Threats to Validity The primary threats to \nexternal validity for our study are (1) the use of SPF within which we implemented our technique, (2) \nthe use of Choco as the underlying constraint solver, (3) the selection of arti\u00adfacts used to evaluate \nDiSE, and (4) the changes applied to create the mutants. Implementing DiSE in another framework or using \nanother constraint solver/decision procedure could produce differ\u00adent results; however, replicated studies \nwith other tool frameworks would address this threat. The artifacts selected for our study are control \napplications that are amenable to symbolic execution. The artifacts are comparable in structure and complexity \nto other arti\u00adfacts that we are aware of that are used to evaluate symbolic execu\u00adtion techniques. The \nmutant versions we used to perform our study were created manually, and may or may not re.ect actual \nprogram changes; however, the mutations were developed in a systematic way that considered program location, \nchange type, and number of changes. Further evaluation of DiSE on a broader range of program types and \non programs with actual version histories would address this threat. The primary threats to internal \nvalidity are the potential faults in the implementation of our algorithms and in SPF. We controlled for \nthis threat by testing our algorithms on examples that we can manually verify. With respect to threats \nto construct validity, the metrics we selected to evaluate the cost of DiSE are commonly used to measure \nthe cost of symbolic execution.  Version CFG Nodes Changed Affected Time (mm:ss) DiSE Full Symbc States \nExplored DiSE Full Symbc Path Conditions DiSE Full Symbc v1 0 0 00:19 17:19 23 3,948,476 0 1,728 v2 1 \n1 00:22 16:49 564 3,948,476 0 1,728 v3 1 16 00:21 17:03 30 3,948,476 1 1,728 v4 4 18 00:20 18:07 34 3,948,476 \n1 1,728 v5 4 18 00:20 17:56 34 3,948,476 1 1,728 v6 1 26 00:32 16:49 24,036 3,948,476 381 1,728 v7 5 \n12 00:29 16:37 37 3,957,692 2 1,728 v8 4 12 00:30 16:33 44 3,948,476 3 1,728 v9 4 3 00:32 16:22 23 3,948,476 \n0 1,728 v10 1 13 00:28 20:15 38 3,948,476 3 1,728 v11 1 0 00:31 22:14 23 3,948,476 0 1,728 v12 4 3 00:32 \n20:21 23 3,948,476 0 1,728 v13 1 0 00:31 17:13 23 3,948,476 0 1,728 v14 9 18 00:30 18:50 41 3,957,692 \n2 1,728 v15 5 30 00:47 18:36 24,148 3,948,476 383 1,728 (a) ASW Example Version CFG Nodes Changed Affected \nTime (mm:ss) DiSE Full Symbc States Explored DiSE Full Symbc Path Conditions DiSE Full Symbc v1 1 39 \n03:19 02:30 677,976 677,976 24 24 v2 1 7 00:08 02:22 93 677,976 17 24 v3 1 3 00:27 02:41 65,976 677,976 \n12 24 v4 1 0 00:08 02:44 17 677,976 1 24 v5 7 56 00:23 03:44 59,610 1,317,048 14 24 v6 1 1 00:08 02:44 \n17 677,976 1 24 v7 1 39 03:07 02:51 677,976 677,976 24 24 v8 8 57 00:29 03:45 59,610 1,317,048 14 24 \nv9 2 4 00:33 02:41 65,976 677,976 12 24 v10 2 39 03:40 02:51 677,976 677,976 24 24 v11 7 56 00:28 03:43 \n59,610 1,317,048 14 24 v12 8 65 00:31 03:54 70,129 1,317,048 6 24 v13 9 57 00:29 03:44 59,610 1,317,048 \n14 24 v14 3 39 03:39 02:51 677,976 677,976 24 24 v15 3 42 03:37 02:51 677,976 677,976 24 24 v16 8 56 \n00:28 03:43 59,610 1,317,048 14 24 (b) WBS Example Version CFG Nodes Changed Affected Time (mm:ss) DiSE \nFull Symbc States Explored DiSE Full Symbc Path Conditions DiSE Full Symbc v1 1 41 00:30 08:34 81,737 \n264,885 13,082 130,820 v2 1 2 00:04 08:34 23 264,885 2 130,820 v3 2 2 00:15 08:41 33,341 264,885 3,926 \n130,820 v4 2 2 00:04 08:39 56 264,882 3 130,820 v5 2 2 00:03 08:41 36 264,885 2 130,820 v6 3 7 00:57 \n10:27 134,065 264,885 26,164 130,820 v7 2 43 00:53 09:32 107,901 264,885 26,164 130,820 v8 3 4 00:17 \n10:32 41,193 264,885 7,852 130,820 v9 4 43 00:53 10:31 107,901 264,885 26,164 130,820 (c) OAE Example \nTable 2. DiSE and Symbolic Execution Results 4.2.5 Results and Analysis In this section, we present \nthe results of our case-study, and an\u00adalyze the results with respect to our two research questions. In \nTables 4.2.1(a) (c) we list the results of running DiSE and full symbolic execution on each version of \neach Java artifact. For each mutant version of the method, we list the number of CFG nodes changed (Changed), \nthe number of CFG nodes affected by the changes (Affected), and the metrics described in Section 4.2.2 \n the time to perform DiSE and the time to perform traditional symbolic execution of the mutant version \nas reported by SPF, the number of states explored during execution of each technique, and the num\u00adber \nof path conditions generated by each technique in the resulting method summary. The results for DiSE \nare listed under the sub\u00adheading DiSE and the results for traditional symbolic execution are listed under \nthe subheading Full Symbc. RQ1 (Cost). In Tables 4.2.1(a) (c), we can see that for all versions of the \nASW and OAE examples, and for the majority of versions in the WBS example, DiSE takes considerably less \ntime than full symbolic execution. In many cases, the differences in time is several orders of magnitude. \nFor all of the examples, when the changes to the program do not affect all path conditions (program paths), \nDiSE takes at most 20% of the time taken by full symbolic execution. For the .ve versions of the WBS \nexample (v1, v7, v10, v14, and v15) where DiSE explores the same number of states as full symbolic execution, \nthe time taken by DiSE is 9% 30% longer than symbolic execution. This extra execution time accounts for \nthe overhead of computing the affected locations and supporting data structures. For all of our examples, \nthere is considerable variation in the number of states explored by DiSE; our intuition is that other \nfactors beyond the number of changes, e.g., location and nature  Version v1 v2 v3 v4 v5 v6 v7 v8 v9 \nv10 v11 v12 v13 v14 v15 # Changes 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 Selected 0 0 0 1 0 59 2 2 0 3 0 0 0 2 \n60 Added 0 0 1 0 1 0 0 0 0 0 0 0 0 0 0 Total Tests 0 0 1 1 1 59 2 2 0 3 0 0 0 2 60 (a) ASW Example \n(b) WBS Example (c) OAE Example  Version v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15 v16 # Changes \n1 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3 Selected 20 17 12 1 14 1 20 14 12 20 14 5 14 20 20 14 Added 4 0 0 0 0 \n0 4 0 0 4 0 1 0 4 4 0 Total Tests 24 17 12 1 14 1 24 14 12 24 14 6 14 24 24 14 Version v1 v2 v3 v4 v5 \nv6 v7 v8 v9 # Changes 1 1 1 1 1 1 2 2 3 Selected 1 0 89 2 2 2 178 2 584 Added 291 2 0 0 0 582 0 582 0 \nTotal Tests 292 2 89 2 2 584 178 584 584 Table 3. Regression Testing Results of the change, also have \na considerable effect on the reductions that can be achieved by DiSE (or any other technique that can \ncharacterize the effects of program changes). We also conjecture that program structure, particularly \nwith regard to the number and complexity of the constraints generated during symbolic execution contributes \nto the differences in execution time for each technique. RQ2 (Effectiveness). The number of path conditions \ncomputed by DiSE varies greatly between versions for all three examples as shown in Tables 4.2.1(a) (c). \nFor the 15 versions analyzed in the ASW example, DiSE computes between zero and three path con\u00additions \nfor 13 versions. For the other two versions, DiSE computes approximately 22% of the path conditions generated \nby full sym\u00adbolic execution (381 and 383 path conditions). In v1 of the ASW example, no CFG nodes are \nchanged due to a compiler optimiza\u00adtion that effectively masks the change, and for the remaining ver\u00adsions \nwhere no path conditions are generated, one or more CFG nodes was affected, however, the changes do not \naffect the path conditions generated by DiSE. While none of the changes require DiSE to explore all paths \nin the ASW or OAE examples, in .ve of the 16 versions of the WBS example, DiSE generate the same number \nof path conditions as full symbolic execution. For these .ve versions, the number of changed CFG nodes \nranges from one to three (out of 100 CFG nodes), and the number of affected CFG nodes ranges from 39 \nto 42. On the other hand, in v12 of the WBS example where only six path conditions are generated by DiSE \n(compared with 24 by full symbolic execution), eight CFG nodes are changed and 65 nodes are affected. \nIn the OAE example, the change made to v6 affects seven CFG nodes (10%) and generates 26,164 path conditions \n 20% of the path conditions computed by full symbolic execution. In v7, the changes affect 43 CFG nodes \n(62%) and yet the same number of of path conditions is generated. Based on our analysis of the mutants \ncreated for these examples, there does not appear to be any correlation between the number or percentage \nof affected nodes and the number of affected path conditions. Overall, our study demonstrates that for \nthe examples used in this study, DiSE has potential application for detecting and characterizing affected \nprogram behaviors in evolving software. In the artifacts used in our evaluation, DiSE was able to correctly \nidentify and characterize the subset of path conditions computed by full symbolic execution as affected. \nIn some instances, the change affected only a small percentage of path conditions, and in others, the \nchange(s) had a much greater impact. When only a subset of the path conditions were affected by the changes, \nDiSE was able to consistently compute the affected path conditions in less time often several orders \nof magnitude than full symbolic execution; when all of the path conditions were affected by the changes, \nthe overhead incurred by DiSE was between nine and 30% for these examples. 5. Discussion The goal of \nDiSE is to enable more ef.cient symbolic execution by focusing it on generating affected path conditions. \nDiSE uses a con\u00adservative analysis to identify affected program locations. Thus, in principle, DiSE may \ngenerate some path conditions that represent unchanged paths. However, as experimental results demonstrate, \nDiSE is effective at focusing symbolic execution on affected pro\u00adgram behaviors and enables ef.cient \nincremental symbolic execu\u00adtion. 5.1 Bug .nding using DiSE DiSE can handle programs with assertions when \nthe assert state\u00adments are de-sugared into if and throw statements. In Java programs, this de-sugaring \ntakes place when assert statements in Java source are compiled into Java byte code. Since DiSE performs \nsymbolic execution on Java byte code, DiSE will not miss detect\u00ading a failed assertion violation caused \nby a program change. Thus, DiSE supports .nding bugs when assertions are present and asser\u00adtion failures \ncharacterize bugs. If the assertions were written in a language other than the underlying programming \nlanguage (e.g., Alloy [16] assertions in Java programs), our technique would work with the assertions \ntranslated to Java (e.g., from Alloy).  5.2 Software evolution The results of DiSE can be used to support \nvarious software evo\u00adlution tasks. We present one such application regression testing as it relates to \ntest case selection and augmentation. We note that our goal is not to demonstrate the effectiveness of \ntest case selec\u00adtion and augmentation, but, rather to demonstrate one application of DiSE results to \nsupport software evolution tasks. SPF outputs values that can be used for the method arguments (test \ninputs) based on the generated path conditions. The test inputs are produced by solving the constraints \nin the path condition and using the resulting values to generate a call to the method under analysis. \nThe results are output in string format. Our implementa\u00adtion of test case selection and augmentation \nis trivial in its approach it simply performs a string comparison of the test cases generated for the \noriginal version (by full symbolic execution) with the tests generated by DiSE. Tests generated for the \noriginal version of the method represent an existing test suite. Tests generated by DiSE that are also \nfound in the tests generated for the original version are marked as selected, while the other tests are \nconsidered tests to be added to augment the test suite. The results of using DiSE to perform test case \nselection and test case augmentation for our three examples are shown in Tables 3(a) (c). The combination \nof selected and added tests execute all of the branches in the program that are in some way affected \nby the changes made to the method under analysis. Full symbolic execution on the original version of \nASW generates 256 tests, while full symbolic execution on the WBS and OAE examples generates 24 tests \nand 2,920 tests respectively. Note that the number of test cases generated by symbolic execution and \nby DiSE differs from the number of path conditions generated by each technique; this is due to the fact \nthat the current implementation of the test generation tool computes input values only for the method \narguments, i.e., a partial state. As a result, when .elds are represented by symbolic values, multiple \npath conditions generated by a given technique may map to a single set of concrete inputs to the method \nunder analysis. For all of the artifacts in our study, the results of DiSE can be used to identify test \ncases that can be re-used, and the test cases that exercise affected path conditions for which test cases \nmust be generated. For the ASW and WBS examples, DiSE results show that only a small number of test cases \nis necessary to augment the test suite for the new version of the program. For the OAE exam\u00adple, the \nresults of DiSE indicate that for some changes, e.g., v3, it is unnecessary to generate any new test \ncases. For versions v6 and v8, however, only two of the existing test cases are valid for the new version \nof the program and 584 test cases are necessary to test the program behaviors identi.ed as affected by \nDiSE. When only a subset of the path conditions is affected by the changes to a program, using DiSE results \nfor test case selection and augmenta\u00adtion of the artifacts in our study would result in executing between \n20% and 70% of the test cases that would be run in a re-test all approach, reducing the time necessary \nfor regression testing of the new version of the program.  The requirements for soundness and completeness \nof an analy\u00adsis are driven by the needs of the speci.c evolution task that uses the results of the analysis. \nFor example, the test selection and aug\u00admentation application considered here covers all the branches \nin the method that are affected by the change. However, it does not necessarily provide full (bounded) \npath coverage. To achieve full path coverage, additional information could potentially be recorded from \na previous run, and combined with DiSE results. As future work, we plan to investigate the use of DiSE \nfor other software evolution tasks. 6. Related Work Recent years have seen a signi.cant growth in research \nprojects based on symbolic execution, .rst introduced in the 1970 s by Clarke [7] and King [22]. These \nprojects have pursued three pri\u00admary research directions to enhance traditional symbolic execution: (1) \nto improve its effectiveness [4, 10, 12, 19, 32]; (2) to improve its ef.ciency [1, 3, 5, 11, 20, 31, \n37]; and (3) to improve its appli\u00adcability [8, 18, 27, 33]. The novelty of DiSE is to leverage state-of\u00adthe-art \nsymbolic execution techniques and apply a static analysis in synergy to enable symbolic execution to \nperform more ef.ciently as a program undergoes changes. The projects to enhance the effectiveness of \nsymbolic execution have focused on two areas. First, is to enable symbolic execution to handle programs \nwritten in commonly used languages, such as Java and C/C++, by providing support for symbolic execution \nover the core types used in these languages [4, 10, 12, 19, 32]. The second area of focus is to enable \nsymbolic execution to work around the traditional limitation of undecidability of path conditions through \nthe use of mixed symbolic/concrete execution to attempt to prevent the path conditions from becoming \ntoo complex [12, 32]. Research to enhance the ef.ciency of symbolic execution has followed three basic \ndirections. One, to use abstraction with sym\u00adbolic execution to reduce the space of exploration [1, 20]. \nTwo, to perform compositional symbolic execution, where summaries of parts of code are used in place \nof an actual implementation to enable the underlying constraint solvers to perform more ef.\u00adciently [3, \n11]. Three, to enable symbolic execution to .nd bugs faster through the use of heuristics, e.g., genetic \nalgorithms [37], that directly control the symbolic exploration and focus it on parts that are more likely \nto contain bugs. Static analysis has also been used effectively for guiding sym\u00adbolic execution. Chang \ns recent doctoral dissertation [5] uses a def\u00aduse analysis based on user-provided control points of interest, \nand applies a program transformation that incorporates boundary con\u00additions on program inputs into the \nprogram logic to enable more ef\u00ad.cient bug .nding. Santelices and Harrold [31] use control and data dependencies \nto symbolically execute groups of paths, rather than individual paths to enable scalability. The key \ndifference between DiSE and previous work is the ability of DiSE to utilize informa\u00adtion about program \ndifferences for ef.cient symbolic execution as code undergoes changes. While several projects have made \nsigni.cant advances in apply\u00ading symbolic execution to test input generation and program veri.\u00adcation \n two traditional applications of symbolic execution recent projects have used it as an enabling technology \nfor various novel applications, including program differencing [27], data structure re\u00adpair [18], dynamic \ndiscovery of invariants [8], as well as estimation of energy consumption on hardware devices with limited \nbattery capacity [33]. An application of symbolic execution with a focus on program differences is regression \ntesting [14, 15, 25]. Several recent projects use symbolic execution as a basis of test case selection \nand aug\u00admentation [29, 35, 38]. DiSE differs from these projects in its focus on the core symbolic execution \ntechnique to enable a variety of software evolution tasks not only regression testing. Program differencing, \nin general, is a well-studied research area with several techniques for computing differences [2, 21, \n27] as well as leveraging them to enable various software evolution tasks [23]. Research in utilizing \ndifferences to speed-up symbolic execution by focusing it on code changes has only recently begun. Godefroid \net al. [13] consider the problem of statically validating symbolic test summaries against changes, speci.cally \nfor compo\u00adsitional dynamic test generation. Our approach is complementary since it uses change impact \ninformation to explore only the paths of the symbolic execution tree that are affected by the change, \nthereby reducing the cost of recomputing symbolic summaries. The Java PathFinder model checker [36] has \npreviously been used for incremental checking of programs that undergo changes [24, 39]. Incremental \nstate-space exploration (ISSE) [24] focuses on evolving programs and stores the explored state space \ngraph to use it for checking a subsequent version of the program, and re\u00adduces the time necessary for \nstate-space exploration by avoiding the execution of some transitions and related computations that are \nnot necessary. Regression model checking (RMC) [39] presents a complementary approach to ISSE and uses \nthe difference between two versions to drive the pruning of the state space when model checking the new \nversion. RMC computes reachable program cov\u00aderage elements, e.g., basic blocks, for each program state \nduring a recording mode run of RMC on the original version. Impact anal\u00adysis is then used to calculate \ndangerous elements whose behavior may now differ because of changes. This is done by comparing the bytecodes \nand control-.ow graphs for the two program ver\u00adsions. The dangerous elements information is then combined \nwith the reachable elements information to prune safe sub-state spaces during a pruning mode run of RMC \non the modi.ed version of the program. DiSE takes inspiration from RMC and supports incre\u00admental symbolic \nexecution, which is not addressed by RMC and ISSE. Moreover, a key difference between DiSE and previous \nwork is that to analyze the current program version DiSE does not require the availability of the internal \nstates of the previous analysis run ISSE requires the state-space graph and RMC requires the dynamic \nreachability information for program coverage elements. 7. Conclusions and Future Work In this paper, \nwe introduced Directed Incremental Symbolic Execu\u00adtion (DiSE), a novel technique that leverages program \ndifferences to guide symbolic execution to explore and characterize the effects of program changes. We \nimplemented DiSE in the symbolic ex\u00adecution extension of the Java PathFinder veri.cation framework, and \nevaluated its cost and effectiveness on methods from three Java applications. The results of our case-study \ndemonstrate that DiSE ef.ciently generates the set of path conditions affected by the change(s) to a \nprogram. We demonstrate the utility of our technique by using DiSE results to perform test case selection \nand test input generation for the examples in our study. DiSE is an intra-procedural, incremental analysis \ntechnique that generates and characterizes method-level differences. DiSE does not generate affected \npath conditions arising from the control and data .ow between various methods. As a result, DiSE does \nnot con\u00adsider the effects of the return value of a changed method .owing back to its calling context, \nnor does DiSE capture the effects of changes to the global state if whatever change is causing the effect \ndoes not also affect the path condition. We plan to extend DiSE to use an inter-procedural analysis to \ngenerate affected path condi\u00adtions over the entire system as part of our future work.  We observed from \nour study that the number of changes is only one factor affecting which (and how many) path conditions \nare changed; program structure and the nature of the change also appear to have a considerable effect. \nWe expect these factors to also affect the number of path conditions that are changed when we evaluate \nDiSE on a more diverse set of programs. In future work, we plan to conduct a more comprehensive evaluation \nof our DiSE technique. Acknowledgments The authors gratefully acknowledge the contributions of Matt Dwyer \nand Gregg Rothermel to early work on DiSE. The authors also thank Eric Mercer for the helpful comments \nto improve the paper. The work of Yang and Khurshid was supported in part by the NSF under Grant Nos. \nIIS-0438967 and CCF-0845628, and AFOSR grant FA9550-09-1-0351. References [1] S. Anand, C. S. Pasareanu, \nand W. Visser. Symbolic execution with abstraction. International Journal on Software Tools for Technology \nTransfer (STTT), 11:53 67, January 2009. [2] T. Apiwattanapong, A. Orso, and M. J. Harrold. Jdiff: A \ndifferencing technique and tool for object-oriented programs. Automated Software Engineering, 14(1):3 \n36, 2007. [3] W. R. Bush, J. D. Pincus, and D. J. Sielaff. A static analyzer for .nding dynamic programming \nerrors. Software: Practice and Experience, 30(7):775 802, 2000. [4] C. Cadar and D. R. Engler. Execution \ngenerated test cases: How to make systems code crash itself. In SPIN, pages 2 23, 2005. [5] W. C. Chang. \nImproving Dynamic Analysis with Data Flow Analysis. PhD thesis, University of Texas at Austin, 2010. \n[6] Choco. Main page Choco. http://www.emn.fr/z-info/ choco-solver/, 2010. [7] L. A. Clarke. A program \ntesting system. In Proceedings of the 1976 annual conference, ACM 76, pages 488 491, 1976. [8] C. Csallner, \nN. Tillmann, and Y. Smaragdakis. Dysy: Dynamic sym\u00adbolic execution for invariant inference. In ICSE, \npages 281 290, 2008. [9] L. de Moura and N. Bj\u00f8rner. Z3: An ef.cient SMT solver. In TACAS, pages 337 \n340, 2008. [10] X. Deng, Robby, and J. Hatcliff. Kiasan/KUnit: Automatic test case generation and analysis \nfeedback for open object-oriented systems. In TAICPART-MUTATION, pages 3 12, 2007. [11] P. Godefroid. \nCompositional dynamic test generation. In POPL, pages 47 54, 2007. [12] P. Godefroid, N. Klarlund, and \nK. Sen. DART: Directed automated random testing. In PLDI, pages 213 223, 2005. [13] P. Godefroid, S. \nK. Lahiri, and C. Rubio-Gonzalez. Incremental compositional dynamic test generation. Technical Report \nMSR-TR\u00ad2010-11, Microsoft Research, 2010. [14] T. L. Graves, M. J. Harrold, J.-M. Kim, A. Porter, and \nG. Rothermel. An empirical study of regression test selection techniques. ACM Transactions Software Engineering \nand Methodology, 10(2):184 208, 2001. [15] M. J. Harrold, J. A. Jones, T. Li, D. Liang, A. Orso, M. Pennings, \nS. Sinha, S. A. Spoon, and A. Gujarathi. Regression test selection for java software. In OOPSLA, pages \n312 326, 2001. [16] D. Jackson. Software Abstractions: Logic, Language, and Analysis. The MIT Press, \nCambridge, MA, 2006. [17] A. Joshi and M. Heimdahl. Model-Based Safety Analysis of Simulink Models Using \nSCADE Design Veri.er. In SAFECOMP, volume 3688 of LNCS, pages 122 135, September 2005. [18] S. Khurshid, \nI. Garc\u00b4ia, and Y. L. Suen. Repairing structurally complex data. In SPIN, pages 123 138, 2005. [19] S. \nKhurshid, C. S. P.as.areanu, and W. Visser. Generalized symbolic execution for model checking and testing. \nIn TACAS, pages 553 568, 2003. [20] S. Khurshid and Y. L. Suen. Generalizing symbolic execution to library \nclasses. In PASTE, pages 103 110, 2005. [21] M. Kim, D. Notkin, and D. Grossman. Automatic inference \nof struc\u00adtural changes for matching across program versions. In ICSE, pages 333 343, 2007. [22] J. C. \nKing. Symbolic execution and program testing. Communications of the ACM, 19(7):385 394, 1976. [23] S. \nK. Lahiri, K. Vaswani, and T. Hoare. Differential static analysis: Opportunities, applications, and challenges. \nIn FoSER, pages 201 204, 2010. [24] S. Lauterburg, A. Sobeih, D. Marinov, and M. Viswanathan. Incremen\u00adtal \nstate-space exploration for programs with dynamically allocated data. In ICSE, pages 291 300, 2008. [25] \nH. Leung and L. White. Insights into regression testing. In ICSM, pages 60 69, 1989. [26] C. P.as.areanu \nand N. Rungta. Symbolic PathFinder: symbolic execu\u00adtion of Java bytecode. In ASE, pages 179 180, 2010. \n[27] S. Person, M. B. Dwyer, S. Elbaum, and C. S. P.areanu. Differential as.symbolic execution. In FSE, \npages 226 237, 2008. [28] C. S. P.as.areanu, P. C. Mehlitz, D. H. Bushnell, K. Gundy-Burlet, M. Lowry, \nS. Person, and M. Pape. Combining unit-level symbolic execution and system-level concrete execution for \ntesting NASA soft\u00adware. In ISSTA, pages 15 25, 2008.  [29] D. Qi, A. Roychoudhury, and Z. Liang. Test \ngeneration to expose changes in evolving programs. In ASE, pages 397 406, 2010. [30] SAE-ARP4761. Guidelines \nand Methods for Conducting the Safety Assessment Process on Civil Airborne Systems and Equipment. SAE \nInternational, December 1996. [31] R. Santelices and M. J. Harrold. Exploiting program dependencies for \nscalable multiple-path symbolic execution. In ISSTA, pages 195 206, 2010. [32] K. Sen, D. Marinov, and \nG. Agha. CUTE: a concolic unit testing engine for c. In ESEC/FSE, pages 263 272, 2005. [33] C. Seo, S. \nMalek, and N. Medvidovic. An energy consumption frame\u00adwork for distributed Java-based software systems. \nTechnical Report USC-CSE-2006-604, University of Southern California, 2006. [34] J. Sztipanovits and \nG. Karsai. Generative programming for embedded systems. In GPCE, pages 32 49, 2002. [35] K. Taneja, T. \nXie, N. Tillmann, J. de Halleux, and W. Schulte. Guided path exploration for regression test generation. \nIn ICSE, New Ideas and Emerging Results, pages 311 314, 2009. [36] W. Visser, K. Havelund, G. P. Brat, \nS. Park, and F. Lerda. Model checking programs. Automated Software Engineering, 10(2):203 232, 2003. \n[37] Z. Xu, M. B. Cohen, and G. Rothermel. Factors affecting the use of genetic algorithms in test suite \naugmentation. In GECCO, pages 1365 1372, 2010. [38] Z. Xu and G. Rothermel. Directed test suite augmentation. \nIn APSEC, pages 406 413, 2009. [39] G. Yang, M. B. Dwyer, and G. Rothermel. Regression model checking. \nIn ICSM, pages 115 124, 2009.    \n\t\t\t", "proc_id": "1993498", "abstract": "<p>The last few years have seen a resurgence of interest in the use of symbolic execution -- a program analysis technique developed more than three decades ago to analyze program execution paths. Scaling symbolic execution and other path-sensitive analysis techniques to large systems remains challenging despite recent algorithmic and technological advances. An alternative to solving the problem of scalability is to <i>reduce</i> the scope of the analysis. One approach that is widely studied in the context of regression analysis is to analyze the <i>differences</i> between two related program versions. While such an approach is intuitive in theory, finding efficient and precise ways to identify program differences, and characterize their effects on how the program executes has proved challenging in practice.</p> <p>In this paper, we present <i>Directed Incremental Symbolic Execution</i> (DiSE), a novel technique for detecting and characterizing the effects of program changes. The novelty of DiSE is to combine the <i>efficiencies</i> of static analysis techniques to compute program difference information with the <i>precision</i> of symbolic execution to explore program execution paths and generate path conditions affected by the differences. DiSE is a complementary technique to other reduction or bounding techniques developed to improve symbolic execution. Furthermore, DiSE does not require analysis results to be carried forward as the software evolves -- only the source code for two related program versions is required. A case-study of our implementation of DiSE illustrates its effectiveness at detecting and characterizing the effects of program changes.</p>", "authors": [{"name": "Suzette Person", "author_profile_id": "81100404456", "affiliation": "NASA Langley Research Center, Hampton, VA, USA", "person_id": "P2690635", "email_address": "suzette.person@nasa.gov", "orcid_id": ""}, {"name": "Guowei Yang", "author_profile_id": "81485650041", "affiliation": "University of Texas at Austin, Austin, TX, USA", "person_id": "P2690636", "email_address": "gyang@ece.utexas.edu", "orcid_id": ""}, {"name": "Neha Rungta", "author_profile_id": "81309496713", "affiliation": "NASA Ames Research Center, Mountain View, CA, USA", "person_id": "P2690637", "email_address": "neha.s.rungta@nasa.gov", "orcid_id": ""}, {"name": "Sarfraz Khurshid", "author_profile_id": "81100052115", "affiliation": "University of Texas at Austin, Austin, TX, USA", "person_id": "P2690638", "email_address": "khurshid@ece.utexas.edu", "orcid_id": ""}], "doi_number": "10.1145/1993498.1993558", "year": "2011", "article_id": "1993558", "conference": "PLDI", "title": "Directed incremental symbolic execution", "url": "http://dl.acm.org/citation.cfm?id=1993558"}