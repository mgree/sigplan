{"article_publication_date": "06-04-2011", "fulltext": "\n * Taming Wildcards in Java s Type System Ross Tate Alan Leung Sorin Lerner University of California, \nSan Diego University of California, San Diego University of California, San Diego rtate@cs.ucsd.edu aleung@cs.ucsd.edu \nlerner@cs.ucsd.edu Abstract Wildcards have become an important part of Java s type system since their \nintroduction 7 years ago. Yet there are still many open problems with Java s wildcards. For example, \nthere are no known sound and complete algorithms for subtyping (and consequently type checking) Java \nwildcards, and in fact subtyping is suspected to be undecidable because wildcards are a form of bounded \nexis\u00adtential types. Furthermore, some Java types with wildcards have no joins, making inference of type \narguments for generic methods par\u00adticularly dif.cult. Although there has been progress on these fronts, \nwe have identi.ed signi.cant shortcomings of the current state of the art, along with new problems that \nhave not been addressed. In this paper, we illustrate how these shortcomings re.ect the subtle complexity \nof the problem domain, and then present major improvements to the current algorithms for wildcards by \nmaking slight restrictions on the usage of wildcards. Our survey of existing Java programs suggests that \nrealistic code should already satisfy our restrictions without any modi.cations. We present a simple \nal\u00adgorithm for subtyping which is both sound and complete with our restrictions, an algorithm for lazily \njoining types with wildcards which addresses some of the shortcomings of prior work, and tech\u00adniques \nfor improving the Java type system as a whole. Lastly, we describe various extensions to wildcards that \nwould be compatible with our algorithms. Categories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: \nFormal De.nitions and Theory; D.3.2 [Programming Lan\u00adguages]: Language Classi.cations Java; D.3.3 [Programming \nLan\u00adguages]: Language Constructs and Features Polymorphism General Terms Algorithms, Design, Languages, \nTheory Keywords Wildcards, Subtyping, Existential types, Parametric types, Joins, Type inference, Single-instantiation \ninheritance 1. Introduction Java 5, released in 2004, introduced a variety of features to the Java programming \nlanguage, most notably a major overhaul of the type system for the purposes of supporting generics. Although \nJava has undergone several revisions since, Java generics have remained unchanged since they were originally \nintroduced into the language. * This work was supported by NSF grant CCF-0644306 and a Microsoft Research \nPhD Fellowship. When we refer to javac we mean version 1.6.0 22. Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. PLDI 11, June 4 8, 2011, San Jose, California, \nUSA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0663-8/11/06. . . $10.00 Java generics were a long-awaited \nimprovement to Java and have been tremendously useful, leading to a signi.cant reduction in the amount \nof unsafe type casts found in Java code. However, while Java generics improved the language, they also \nmade type checking extremely complex. In particular, Java generics came with wildcards, a sophisticated \ntype feature designed to address the limitations of plain parametric polymorphism [18]. Wildcards are \na simple form of existential types. For exam\u00adple, List<?> represents a list of unknowns , namely a list \nof ob\u00adjects, all of which have the same unknown static type. Similarly, List<? extends Number> is a list \nof objects of some unknown static type, but this unknown static type must be a subtype of Number. Wildcards \nare a very powerful feature that is used pervasively in Java. They can be used to encode use-site variance \nof paramet\u00adric types [6, 16 18], and have been used to safely type check large parts of the standard \nlibrary without using type casts. Un\u00adfortunately, the addition of wildcards makes Java s type system \nex\u00adtremely complex. In this paper we illustrate and address three issues of wildcards: subtyping, type-argument \ninference, and inconsisten\u00adcies in the design of the type system. Subtyping with wildcards is surprisingly \nchallenging. In fact, there are no known sound and complete subtyping algorithms for Java, soundness \nmeaning the algorithm accepts only subtypings permitted by Java and completeness meaning the algorithm \nalways terminates and accepts all subtypings permitted by Java. Subtyping with wildcards is even suspected \nto be undecidable, being closely related to the undecidable problem of subtyping with bounded ex\u00adistential \ntypes [20]. In Section 3 we will illustrate this challenge, including examples of programs which make \njavac suffer a stack over.ow. In Section 4 we will present our simple subtyping algo\u00adrithm which is sound \nand complete given certain restrictions. Java also includes type-argument inference for generic meth\u00adods, \nwhich again is particularly challenging with wildcards. With\u00adout type-argument inference, a programmer \nwould have to provide type arguments each time a generic method is used. Thus, to make generic methods \nconvenient, Java infers type arguments at method\u00adinvocation sites. Furthermore, Java can infer types \nnot expressible by users, so that explicit annotation is not always an option. Un\u00adfortunately, there \nis no known sound and complete type-argument inference algorithm. Plus, type-argument inference can even \naffect the semantics of a program. We illustrate these issues in Section 5 and present our improvements \non the state of the art in Section 6. Wildcards also introduce a variety of complications to Java s type \nsystem as a whole. While Java attempts to address these com\u00adplications, there are yet many to be resolved. \nIn some cases Java is overly restrictive, while in others Java is overly relaxed. In fact, the type-checking \nalgorithm used by javac is non-deterministic from the user s perspective due to wildcards. In Section \n7 we will illus\u00adtrate these issues, and in Section 8 we will present our solutions. A few of our solutions \ninvolve imposing restrictions on the Java language. Naturally one wonders whether these restrictions \nare practical. As such, we have analyzed 9.2 million lines of open\u00adsource Java code and determined that \nnone of our restrictions are violated. We present our .ndings in Section 9, along with a number of interesting \nstatistics on how wildcards are used in practice.  Java is an evolving language, and ideally our algorithms \ncan evolve with it. In Section 10 we present a variety of extensions to Java which preliminary investigations \nindicate would be compat\u00adible with our algorithms. These extensions also suggest that our algorithms \ncould apply to other languages such as C# and Scala. Many of the above dif.culties of wildcards are by \nno means new and have been discussed in a variety of papers [2, 8, 13, 20]. In re\u00adsponse to these challenges, \nresearchers have explored several ways of .xing wildcards. The work by Smith and Cartwright [13] in par\u00adticular \nmade signi.cant progress on improving algorithms for type checking Java. Throughout this paper we will \nidentify the many contributions of these works. However, we will also identify their shortcomings, motivating \nthe need for our improvements. Although this paper does not solve all the problems with type checking \nJava, it does signi.cantly improve the state of the art, providing concrete solutions to many of the \nopen issues with wildcards. 2. Background In early proposals for adding parametric polymorphism to Java, \nnamely GJ [1], one could operate on List<String> or on List<Number>, yet operating on arbitrary lists \nwas inconvenient because there was no form of variance. One had to de.ne a method with a polymorphic \nvariable P and a parameter of type List<P>, which seems natural except that this had to be done even \nwhen the type of the list contents did not matter. That is, there was no way no refer to all lists regardless \nof their elements. This can be especially limiting for parametric classes such as Class<P> for which \nthe type parameter is not central to its usage. Thus, Java wanted a type system beyond standard parametric \npolymorphism to address these limitations. 2.1 Wildcards Wildcards were introduced as a solution to the \nabove problem among others [18]. List<?> stands for a list whose elements have an arbitrary unknown static \ntype. Types such as List<String>, List<Number>, and List<List<String>> can all be used as a List<?>. \nThe ? is called a wildcard since it can stand for any type and the user has to handle it regardless of \nwhat type it stands for. One can operate on a List<?> as they would any list so long as they make no \nassumptions about the type of its elements. One can get its length, clear its contents, and even get \nObjects from it since in Java all in\u00adstances belong to Object. As such, one might mistake a List<?> for \na List<Object>; however, unlike List<Object>, one cannot add arbitrary Objects to a List<?> since it \nmight represent a List<String> which only accepts Strings or a List<Number> which only accepts Numbers. \nWildcards can also be constrained in order to convey restricted use of the type. For example, the type \nList<? extends Number> is often used to indicate read-only lists of Numbers. This is because one can \nget elements of the list and statically know they are Numbers, but one cannot add Numbers to the list \nsince the list may actually represent a List<Integer> which does not accept arbitrary Numbers. Similarly, \nList<? super Number> is often used to indicate write-only lists. This time, one cannot get Numbers from \nthe list since it may actually be a List<Object>, but one can add Numbers to the list. Note, though, \nthat this read-only/write-only usage is only convention and not actually enforced by the type system. \nOne can mutate a List<? extends Number> via the clear method and one can read a List<? super Number> \nvia the length method since neither method uses the type parameter for List. Java s subtyping for types \nwith wildcards is very .exible. Not only can a List<Error> be used as a List<? extends Error>, but a \nList<? extends Error> can even be used as a List<? extends Throwable> since Error is a subclass of Throwable. \nSimilarly, a List<Throwable> can be used as a List<? super Throwable> which can be used as a List<? super \nError>. Thus by constraining wildcards above one gets covariant subtyping, and by constraining wildcards \nbelow one gets contravariant subtyping. This is known as use-site variance [16] and is one of the basic \nchallenges of subtyping with wildcards. How\u00adever, it is only the beginning of the dif.culties for subtyping, \nas we will demonstrate in Section 3. Before that, we discuss the connec\u00adtion between wildcards and existential \ntypes as it is useful for un\u00adderstanding and formalizing the many subtleties within wildcards. 2.2 Existential \nTypes Since their inception, wildcards have been recognized as a form of existential types [2, 3, 6, \n8, 17, 18, 20]. The wildcard ? rep\u00adresents an existentially quanti.ed type variable, so that List<?> \nis shorthand for the existentially quanti.ed type .X. List<X>. Existen\u00adtial quanti.cation is dual to \nuniversal quanti.cation; a .X. List<X> can be used as a List<String> by instantiating X to String, and \ndu\u00adally a List<String> can be used as an .X. List<X> by instantiating X to String. In particular, any \nlist can be used as an .X. List<X>, just like List<?>. The conversion from concrete instantiation to \nexisten\u00adtial quanti.cation is often done with an explicit pack operation, but in this setting all packs \nare implicit in the subtype system. Bounded wildcards are represented using bounded quanti.ca\u00adtion. The \nwildcard type List<? extends Number> is represented by .X extends Number. List<X>. A list belongs to \nthis existential type if its element type is a subtype of Number. Examples are List<Integer> and List<Double>, \nwhich also belong to List<? extends Number> as ex\u00adpected. Once again this is dual to bounded universal \nquanti.cation. Even subtyping of wildcards can be formalized by existential subsumption (dual to universal \nsubsumption [7, 9, 10]). For exam\u00adple, .X extends Error. List<X> subsumes .Y extends Throwable. List<Y> \nbecause the type variable Y can be instantiated to the type X which is a subtype of Throwable because \nX is constrained to be a subtype of Error which is a subclass of Throwable. Often this subsumption relation \nis accomplished by explicit open and pack operations. The left side is opened, moving its variables and \ntheir constraints into the general context, and then the types in the opened left side are packed into \nthe variables bound in the right side and the constraints are checked to hold for those packed types. \nIn the context of wild\u00adcards, the opening process is called wildcard capture [5, 18] and is actually \npart of the speci.cation for subtyping [5: Chapter 4.10.2].  2.3 Implicit Constraints While users can \nexplicitly constrain wildcards via the extends and super clauses, Java also imposes implicit constraints \non wildcards to make them more convenient. For example, consider the following interfaces specializing \nList via F-bounded polymorphism [4]: interface Numbers<P extends Number> extends List<P> {} interface \nErrors<P extends Error> extends List<P> {} If a user uses the type Numbers<?>, Java implicitly constrains \nthe wildcard to be a subtype of Number [5: Chapter 5.1.10], saving the user the effort of expressing \na constraint that always holds. The same is done for Errors<?>, so that Errors<?> is a subtype of List<? \nextends Error> [5: Chapter 4.10.2]. (Note that we will reuse these interfaces throughout this paper.) \nImplicit constraints on wildcards are more than just a syntactic convenience though; they can express \nconstraints that users cannot express explicitly. Consider the following interface declaration: interface \nSortedList<P extends Comparable<P>> extends List<P> {} If one uses the type SortedList<?>, Java implicitly \nconstrains the wildcard, call it X, so that X is a subtype of Comparable<X> [5: Chap\u00adter 5.1.10]. However, \nit is impossible to state this constraint ex\u00adplicitly on the wildcard argument to SortedList. This is \nbecause the  class C implements List<List<? super C>> {} Is C a subtype of List<? super C>? Step 0) \nC <?: List<? super C> Step 1) List<List<? super C>> <?: List<? super C> (inheritance) Step 2) C <?: List<? \nsuper C> (checking wildcard ? super C) Step . . . (cycle forever) Figure 1. Example of cyclic dependency \nin subtyping [8] explicit constraint would need to make a recursive reference to the wildcard, but wildcards \nare unnamed so there is no way to reference a wildcard in its own constraint. One might be tempted to \nencode the constraint explicitly as SortedList<? extends Comparable<?>>, but this does not have the intended \nsemantics because Java will not cor\u00adrelate the wildcard for Comparable with the one for SortedList. This \nmeans that implicit constraints offer more than just conve\u00adnience; they actually increase the expressiveness \nof wildcards, pro\u00adducing a compromise between the friendly syntax of wildcards and the expressive power \nof bounded existential types. However, this expressiveness comes at the cost of complexity and is the \nsource of many of the subtleties behind wildcards.  2.4 Notation For traditional existential types in \nwhich all constraints are explicit, we will use the syntax .G:..t . The set G is the set of bound variables, \nand the set . is all constraints on those variables. Con\u00adstraints in . have the form v<:: t ' analogous \nto extends and v ::>t ' analogous to super. Thus we denote the traditional ex\u00adistential type for the \nwildcard type SortedList<? super Integer> as .X :X ::> Integer, X <:: Comparable<X>. SortedList<X>. For \nan example with multiple bound variables, consider the following class declaration that we will use throughout \nthis paper: class Super<P, Q extends P> {} We denote the traditional existential type for the wildcard \ntype Super<?,?> as .X, Y : Y <:: X. Super<X,Y>. 3. Non-Termination in Subtyping The major challenge of \nsubtyping wildcards is non-termination. In particular, with wildcards it is possible for a subtyping \nalgorithm to always be making progress and yet still run forever. This is because there are many sources \nof in.nity in Java s type system, none of which are apparent at .rst glance. These sources arise from \nthe fact that wildcards are, in terms of existential types, impredicative. That is, List<?> is itself \na type and can be used in nearly every location a type without wildcards could be used. For example, \nthe type List<List<?>> stands for List<.X. List<X>>, whereas it would represent simply .X. List<List<X>> \nin a predicative system. We have identi.ed three sources of in.nity due to impredica\u00adtivity of wildcards, \nin particular due to wildcards in the inheritance hierarchy and in type-parameter constraints. The .rst \nsource is in\u00ad.nite proofs of subtyping. The second source is wildcard types that represent in.nite traditional \nexistential types. The third source is proofs that are .nite when expressed using wildcards but in.nite \nusing traditional existential types. Here we illustrate each of these challenges for creating a terminating \nsubtyping algorithm. 3.1 In.nite Proofs Kennedy and Pierce provide excellent simple examples illustrating \nsome basic dif.culties with wildcards [8] caused by the fact that wildcards can be used in the inheritance \nhierarchy. In particular, their examples demonstrate that with wildcards it is quite possible class C<P> \nimplements List<List<? super C<C<P>>>> {} Is C<Byte> a subtype of List<? super C<Byte>>? Step 0) C<Byte> \n<?: List<? super C<Byte>> Step 1) List<List<? super C<C<Byte>>>> <?: List<? super C<Byte>> Step 2) C<Byte> \n<?: List<? super C<C<Byte>>> Step 3) List<List<? super C<C<Byte>>>> <?: List<? super C<C<Byte>>> Step \n4) C<C<Byte>> <?: List<? super C<C<Byte>>> Step . . . (expand forever) Figure 2. Example of acyclic \nproofs in subtyping [8] for the question of whether t is a subtype of t' to recursively depend on whether \nt is a subtype of t ' in a non-trivial way. Consider the program in Figure 1 and the question Is C is \nsubtype of List<? super C>? . The bottom part of the .gure contains the steps in a potential proof for \nanswering this question. We start with the goal of showing that C is a subtype of List<? super C>. For \nthis goal to hold, C s superclass List<List<? super C>> must be a subtype of List<? super C> (Step 1). \nFor this to hold, List<List<? super C>> must be List of some supertype of C, so C must be a subtype of \nList<? super C> (Step 2). This was our original question, though, so whether C is a subtype of List<? \nsuper C> actually depends on itself non-trivially. This means that we can actually prove C is a subtype \nof List<? super C> provided we use an in.nite proof. The proof for Figure 1 repeats itself, but there \nare even subtyp\u00ading proofs that expand forever without ever repeating themselves. For example, consider \nthe program in Figure 2, which is a simple modi.cation of the program in Figure 1. The major difference \nis that C now has a type parameter P and in the superclass the type argument to C is C<P> (which could \njust as easily be List<P> or Set<P> without affecting the structure of the proof). This is known as ex\u00adpansive \ninheritance [8, 19] since the type parameter P expands to the type argument C<P> corresponding to that \nsame type parame\u00adter P. Because of this expansion, the proof repeats itself every four steps except with \nan extra C<-> layer so that the proof is acyclic. Java rejects all in.nite proofs [5: Chapter 4.10], \nand javac at\u00adtempts to enforce this decision, rejecting the program in Figure 1 but suffering a stack \nover.ow on the program in Figure 2. Thus, neither of the subtypings in Figures 1 and 2 hold according \nto Java. Although this seems natural, as induction is generally preferred over coinduction, it seems \nthat for Java this is actually an inconsis\u00adtent choice for reasons we will illustrate in Section 3.3. \nIn our type system, in.nite proofs are not even possible, avoiding the need to choose whether to accept \nor reject in.nite proofs. Our simple re\u00adcursive subtyping algorithm terminates because of this.  3.2 \nImplicitly In.nite Types Wehr and Thiemann proved that subtyping of bounded impredica\u00adtive existential \ntypes is undecidable [20]. Wildcards are a restricted form of existential types though, so their proof \ndoes not imply that subtyping of wildcards is undecidable. However, we have deter\u00admined that there are \nwildcard types that actually cannot be ex\u00adpressed by Wehr and Thiemann s type system. In particular, \nWehr and Thiemann use .nite existential types in which all constraints are explicit, but making all implicit \nconstraints on wildcards ex\u00adplicit can actually result in an in.nite traditional existential type. Consider \nthe following class declaration: class Infinite<P extends Infinite<?>> {} The wildcard type Infinite<?> \ntranslates to an in.nite traditional ex\u00adistential type because its implicit constraints must be made \nexplicit. In one step it translates to .X : X <:: Infinite<?>. Infinite<X>, but then the nested Infinite<?> \nneeds to be recursively translated which  Java Wildcards class C extends Super<Super<?,?>,C> {} Is C \na subtype of Super<?,?>? Steps of Proof C <?: Super<?,?> Super<Super<?,?>,C> <?: Super<?,?> (inheritance) \n(completes) Traditional Existential Types class C extends Super<.X, Y :Y <:: X. Super<X,Y>,C> {} Is \nC a subtype of .X ' , Y ' : Y ' <:: X ' . Super<X ' ,Y ' >? Steps of Proof C <?: .X ' , Y ' :Y ' <:: \nX ' . Super<X ' ,Y ' > Super<.X, Y :Y <:: X. Super<X,Y>,C> <?: .X ' , Y ' : Y ' <:: X ' . Super<X ' ,Y \n' > C <?: .X, Y : Y <:: X. Super<X,Y> (repeats forever) Figure 3. Example of an implicitly in.nite \nsubtyping proof repeats ad in.nitum. Thus Infinite<?> is implicitly in.nite. Inter\u00adestingly, this type \nis actually inhabitable by the following class: class Omega extends Infinite<Omega> {} This means that \nwildcards are even more challenging than had been believed so far. In fact, a modi.cation like the one \nfor Figure 2 can be applied to get a wildcard type which implicitly represents an acyclically in.nite \ntype. Because of implicitly in.nite types, one cannot expect structural recursion using implicit constraints \nto terminate, severely limiting techniques for a terminating subtyping algorithm. Our example illustrating \nthis problem is complex, so we leave it until Section 4.4. Nonetheless, we were able to surmount this \nchallenge by extracting implicit constraints lazily and relying only on .niteness of the explicit type. \n 3.3 Implicitly In.nite Proofs Possibly the most interesting aspect of Java s wildcards is that .nite \nproofs of subtyping wildcards can actually express in.nite proofs of subtyping traditional existential \ntypes. This means that subtyping with wildcards is actually more powerful than traditional systems for \nsubtyping with existential types because traditional systems only permit .nite proofs. Like before, implicitly \nin.nite proofs can exist because of implicit constraints on wildcards. To witness how implicitly in.nite \nproofs arise, consider the pro\u00adgrams and proofs in Figure 3. On the left, we provide the program and \nproof in terms of wildcards. On the right, we provide the trans\u00adlation of that program and proof to traditional \nexistential types. The left proof is .nite, whereas the right proof is in.nite. The key dif\u00adference stems \nfrom the fact that Java does not check implicit con\u00adstraints on wildcards when they are instantiated, \nwhereas these con\u00adstraints are made explicit in the translation to traditional existential types and \nso need to be checked, leading to an in.nite proof. To understand why this happens, we need to discuss \nimplicit constraints more. Unlike explicit constraints, implicit constraints on wildcards do not need \nto be checked after instantiation in order to ensure soundness because those implicit constraints must \nalready hold provided the subtype is a valid type (meaning its type argu\u00adments satisfy the criteria for \nthe type parameters). However, while determining whether a type is valid Java uses subtyping which im\u00adplicitly \nassumes all types involved are valid, potentially leading to an implicitly in.nite proof. In Figure 3, \nSuper<Super<?,?>,C> is a valid type provided C is a subtype of Super<?,?>. By inheritance, this reduces \nto whether Super<Super<?,?>,C> is a subtype of Super<?,?>. The implicit constraints on the wildcards \nin Super<?,?> are not checked because Java implicitly assumes Super<Super<?,?>,C> is a valid type. Thus \nthe proof that Super<Super<?,?>,C> is valid implic\u00aditly assumes that Super<Super<?,?>,C> is valid, which \nis the source of in.nity after translation. This example can be modi.ed similarly to Figure 2 to produce \na proof that is implicitly acyclically in.nite. Implicitly in.nite proofs are the reason why Java s rejection \nof in.nite proofs is an inconsistent choice. The programs and proofs class C<P extends List<? super C<D>>> \nimplements List<P> {}Decl. 1) class D implements List<C<?>> {}Decl. 2) class D implements List<C<? extends \nList<? super C<D>>>> {} Is C<D> a valid type? Using Declaration 1 D <?: List<? super C<D>> (check constraint \non P) List<C<?>> <?: List<? super C<D>> (inheritance) C<D> <?: C<?> (check wildcard ? super C<D>) Accepted \n(implicitly assumes C<D> is valid) Using Declaration 2 D <?: List<? super C<D>> List<C<? extends List<? \nsuper C<D>>>> <?: List<? super C<D>> C<D> <?: C<? extends List<? super C<D>>> D <?: List<? super C<D>> \n Rejected (implicit assumption above is explicit here) Figure 4. Example of the inconsistency of rejecting \nin.nite proofs in Figure 4 are a concrete example illustrating the inconsistency. We provide two declarations \nfor class D which differ only in that the constraint on the wildcard is implicit in the .rst declaration \nand explicit in the second declaration. Thus, one would expect these two programs to be equivalent in \nthat one would be valid if and only if the other is valid. However, this is not the case in Java because \nJava rejects in.nite proofs. The .rst program is accepted because the proof that C<D> is a valid type \nis .nite. However, the second program is rejected because the proof that C<D> is a valid type is in.nite. \nIn fact, javac accepts the .rst program but suffers a stack over.ow on the second program. Thus Java \ns choice to reject in.nite proofs is inconsistent with its use of implicit constraints. Interestingly, \nwhen expressed using traditional existential types, the (in.nite) proof for the .rst program is exactly \nthe same as the (in.nite) proof for the second program as one would expect given that they only differ \nsyntactically, af.rming that existential types are a suitable formalization of wildcards. Note that none \nof the wildcard types in Figures 3 and 4 are im\u00adplicitly in.nite. This means that, even if one were to \nprevent proofs that are in.nite using subtyping rules for wildcards and prevent im\u00adplicitly in.nite wildcard \ntypes so that one could translate to tradi\u00adtional existential types, a subtyping algorithm can still \nalways make progress and yet run forever. Our algorithm avoids these problems by not translating to traditional \nor even .nite existential types. 4. Improved Subtyping Now that we have presented the many non-termination \nchallenges in subtyping wildcards, we present our subtyping rules with a sim\u00adple sound and complete subtyping \nalgorithm which always termi\u00ad  class C<P extends Number> extends ArrayList<P> {}t.:= v |.G:.(.).C<t., \n..., t.> List<? extends List<? extends Number>> cast(List<C<?>> list) G := \u00d8 | G,v .:.. {return list;} \n= \u00d8 | .,v <:: t | .,v ::>t Figure 5. Example of subtyping incorrectly rejected by javac Figure 6. Grammar \nof our existential types (coinductive) SUB-EXISTS SUB-VAR .. \u00af C<P1, ..., Pm> is a subclass of D<t \u00af1, \n..., t n> : f v<: v  \u00d8.... , G .- G ' f D<t \u00af1, ..., t \u00afn>[P1 .t.1,...,Pm .t.m] . D<t 1' , ..., t \nn' > .tm= .'  .. : f t<: t ' for all i in 1 to n, , G: , . f t \u00afi[P1 .t.1,...,Pm ..] ~ti[.] v<:: t.in \n. . . ' : for all v<:: t in .\u00b7 , , G: , . f .(v) <: t [.]  f v< : t ' . ' . .. for all v ::>t in \n.\u00b7 ,, G: , . f t [.] <: .(v) v ::>t ' in ' .f t<: t :  . .... '' ' : f t<: v : f.G:.(.\u00b7 ).C<t 1, \n..., t m> <: .G ' :. ' (.\u00b7 ).D<t 1, ..., t n> Figure 7. Subtyping rules for our existential types (inductive \nand coinductive de.nitions coincide given restrictions) nates even when the wildcard types and proofs \ninvolved are im\u00adplicitly in.nite. We impose two simple restrictions, which in Sec\u00adtion 9 we demonstrate \nalready hold in existing code bases. With these restrictions, our subtype system has the property that \nall pos\u00adsible proofs are .nite, although they may still translate to in.nite proofs using subtyping rules \nfor traditional existential types. Even without restrictions, our algorithm improves on the existing \nsubtyp\u00ading algorithm since javac fails to type check the simple program in Figure 5 that our algorithm \ndetermines is valid. Here we pro\u00advide the core aspects of our subtyping rules and algorithms; the full \ndetails can be found in our technical report [15]. 4.1 Existential Formalization We formalize wildcards \nusing existential types. However, we do not use traditional existential types. Our insight is to use \na variant that bridges the gap between wildcards, where constraints can be implicit, and traditional \nexistential types, where all constraints must be explicit. We provide the grammar for our existential \ntypes, represented by t., in Figure 6. Note that there are two sets of constraints so that we denote \nour existential types as .G : .(.\u00b7 ).t.. The constraints . are the constraints corresponding to traditional \nexistential types, combin\u00ading both the implicit and explicit constraints on wildcards. The con\u00adstraints \n.\u00b7 are those corresponding to explicit constraints on wild\u00adcards, with the parenthetical indicating that \nonly those constraints need to be checked during subtyping. Our types are a mix of inductive and coinductive \nstructures, meaning .nite and in.nite. Most components are inductive so that we may do structural recursion \nand still have termination. How\u00adever, the combined constraints . are coinductive. This essentially means \nthat they are constructed on demand rather than all ahead of time. This corresponds to only performing \nwildcard capture when it is absolutely necessary. In this way we can handle wildcards rep\u00adresenting implicitly \nin.nite types as in Section 3.2. 4.2 Existential Subtyping We provide the subtyping rules for our existential \ntypes in Figure 7 (for sake of simplicity, throughout this paper we assume all prob\u00adlems with name hiding \nare taken care of implicitly). The judgement .... : '' f t<: t means that t is a subtype of t in the \ncontext of type variables  with constraints . The subtyping rules are syn\u00adtax directed and so are easily \nadapted into an algorithm. Further\u00admore, given the restrictions we impose in Section 4.4, the inductive \nand coinductive de.nitions coincide, meaning there is no distinc\u00adtion between .nite and in.nite proofs. \nFrom this, we deduce that our algorithm terminates since all proofs are .nite.  The bulk of our algorithm \nlies in SUB-EXISTS, since SUB-VAR just applies assumed constraints on the type variable at hand. The \n.rst premise of SUB-EXISTS examines the inheritance hierarchy to determine which, if any, invocations \nof D that C is a subclass or subinterface of (including re.exivity and transitivity). For Java this invocation \nis always unique, although this is not necessary for our algorithm. The second premise adapts uni.cation \nto existential types permitting equivalence and including the prevention of escap\u00ading type variables. \nThe third premise checks that each pair of corre\u00adsponding type arguments are equivalent for some chosen \nde.nition of equivalence such as simple syntactic equality or more powerful de.nitions as discussed in \nSections 7.3 and 8.3. The fourth and .fth premises recursively check that the explicit constraints in \nthe super\u00adtype hold after instantiation. Note that only the explicit constraints .\u00b7 ' in the supertype \nare checked, whereas the combined implicit and explicit constraints . in the subtype are assumed. This \nsepara\u00adtion is what enables termination and completeness. We have no rule indicating that all types are \nsubtypes of Object. This is because our existential type system is designed so that such a rule arises \nas a consequence of other properties. In this case, it arises from the fact Object is a superclass of \nall classes and interfaces in Java and the fact that all variables in Java are implicitly constrained \nabove by Object. In general, the separation of implicit and explicit constraints enables our existential \ntype system to adapt to new settings, including settings outside of Java. General re.exivity and transitivity \nare also consequences of our rules. In fact, the omission of transitivity is actually a key reason that \nthe inductive and coinductive de.nitions coincide. Although we do not need the full generality of our \nexistential types and proofs to handle wildcards, this generality informs which variations of wildcards \nand existential types would still ensure our algorithm terminates. In Section 10, we will present a few \nsuch extensions compatible with our existential types and proofs.  4.3 Wildcard Subtyping While the \nexistential formalization is useful for understanding and generalizing wildcards, we can specialize the \nalgorithm to wild\u00adcards for a more direct solution. We present this specialization of our algorithm in \nFigure 8, with t representing a Java type and t?representing a Java type argument which may be a (con\u00adstrained) \nwildcard. The function explicit takes a list of type argu\u00adments that may be (explicitly bound) wildcards, \nconverts wildcards to type variables, and outputs the list of fresh type variables, ex\u00adplicit bounds \non those type variables, and the possibly converted type arguments. For example, explicit(Numbers<? super \nInteger>) re\u00adturns (X; X ::> Integer; Numbers<X> . The function implicit takes a list  SUB-EXISTS C<P1, \n..., Pm> is a subclass of D<t\u00af1, ..., t\u00afn> explicit(t?1,..., t?m)= (G; .\u00b7 ; t1,...,tm ?' ?' ''' explicit(t1,..., \nt n)= (G ' ;.\u00b7 ; t1,...,t n implicit(G; C; t1,...,tm)=. . for all i in 1 to n, t\u00afi[P1.t1,...,Pm.tm]= \nti ' [.] for all v<:: t in .\u00b7 ' , , G: , .\u00b7f .(v) <: t . , . for all v ::>t in .\u00b7 ' ,, G: , .\u00b7f . , \n.t<: .(v) ???' ?' : f C<t 1, ..., t m> <: D<t 1, ..., t n> SUB-VAR : f v<: v '' ' v<:: t in : f \nt<: tv ::>t in : f t<: t : f t<: v : f v<: t ' Figure 8. Subtyping rules specialized for wildcards \nof constrainable type variables, a class or interface name C, and a list of type arguments, and outputs \nthe constraints on those type ar\u00adguments that are constrainable type variables as prescribed by the requirements \nof the corresponding type parameters of C, constrain\u00ading a type variable by Object if there are no other \nconstraints. For example, implicit(X; Numbers; X) returns X <:: Number. Thus, applying explicit and then \nimplicit accomplishes wildcard capture. Note that for the most part .and .combined act as . does in Figure \n7. .\u00b7  4.4 Termination Unfortunately, our algorithm does not terminate without imposing restrictions \non the Java language. Fortunately, the restrictions we impose are simple, as well as practical as we \nwill demonstrate in Section 9. Our .rst restriction is on the inheritance hierarchy. Inheritance Restriction \nFor every declaration of a direct superclass or superinterface t of a class or interface, the syntax \n? super must not occur within t . Note that the programs leading to in.nite proofs in Section 3.1 (and \nin the upcoming Section 4.5) violate our inheritance restric\u00adtion. This restriction is most similar to \na signi.cant relaxation of the contravariance restriction that Kennedy and Pierce showed en\u00adables decidable \nsubtyping for declaration-site variance [8]. Their restriction prohibits contravariance altogether, whereas \nwe only re\u00adstrict its usage. Furthermore, as Kennedy and Pierce mention [8], wildcards are a more expressive \ndomain than declaration-site vari\u00adance. We will discuss these connections more in Section 10.1. Constraints \non type parameters also pose problems for termi\u00adnation. The constraint context can simulate inheritance, \nso by con\u00adstraining a type parameter P to extend List<List<? super P>> we en\u00adcounter the same problem \nas in Figure 1 but this time expressed in terms of type-parameter constraints. Constraints can also pro\u00adduce \nimplicitly in.nite types that enable in.nite proofs even when our inheritance restriction is satis.ed, \nsuch as in Figure 9 (which again causes javac to suffer a stack over.ow). To prevent prob\u00adlematic forms \nof constraint contexts and implicitly in.nite types, we restrict the constraints that can be placed on \ntype parameters. Parameter Restriction For every parameterization <P1 extends t1, ..., Pn extends tn>, \nevery syntactic occurrence in ti of a type C<..., ? super t , ...> must be at a covariant location in \nti. Note that our parameter restriction still allows type parameters to be constrained to extend types \nsuch as Comparable<? super P>,a well known design pattern. Also note that the inheritance restriction \nclass C<P extends List<List<? extends List<? super C<?>>>>> implements List<P> {} Is C<?> a subtype of \nList<? extends List<? super C<?>>>? Steps of Proof C<?> <?: List<? extends List<? super C<?>>> C<?> . \nC<X> with X <:: List<List<? extends List<? super C<?>>>> C<X> <?: List<? extends List<? super C<?>>> \nX <?: List<? super C<?>> List<List<? extends List<? super C<?>>>> <?: List<? super C<?>> C<?> <?: List<? \nextends List<? super C<?>>> (repeats forever) Figure 9. Example of in.nite proof due to implicitly in.nite \ntypes is actually the conjunction of the parameter restriction and Java s restriction that no direct \nsuperclass or superinterface may have a wildcard as a type argument [5: Chapters 8.1.4 and 8.1.5]. With \nthese restrictions we can .nally state our key theorem. Subtyping Theorem. Given the inheritance and \nparameter re\u00adstrictions, the algorithm prescribed by the rules in Figure 8 always terminates. Furthermore \nit is a sound and complete implementation of the subtyping rules in the Java language speci.cation [5: \nChap\u00adter 4.10.2] provided all types are valid according to the Java lan\u00adguage speci.cation [5: Chapter \n4.5]. Proof. Here we only discuss the reasons for our restrictions; the full proofs can be found in our \ntechnical report [15]. The .rst thing to notice is that, for the most part, the supertype shrinks through \nthe recursive calls. There are only two ways in which it can grow: applying a lower-bound constraint \non a type variable via SUB-VAR, and checking an explicit lower bound on a wildcard via SUB-EXISTS. The \nformer does not cause problems because of the limited ways a type variable can get a lower bound. The \nlatter is the key challenge because it essentially swaps the subtype and super\u00adtype which, if unrestricted, \ncan cause non-termination. However, we determined that there are only two ways to increase the num\u00adber \nof swaps that can happen: inheritance, and constraints on type variables. Our inheritance and parameter \nrestrictions prevent this, capping the number of swaps that can happen from the beginning and guaranteeing \ntermination.  4.5 Expansive Inheritance Smith and Cartwright conjectured that prohibiting expansive \ninher\u00aditance as de.ned by Kennedy and Pierce [8] would provide a sound and complete subtyping algorithm \n[13]. This is because Kennedy and Pierce built off the work by Viroli [19] to prove that, by pro\u00adhibiting \nexpansive inheritance, any in.nite proof of subtyping in their setting would have to repeat itself; thus \na sound and complete algorithm could be de.ned by detecting repetitions. Unfortunately, we have determined \nthat prohibiting expansive inheritance as de.ned by Kennedy and Pierce does not imply that all in.nite \nproofs repeat. Thus, their algorithm adapted to wildcards does not terminate. The problem is that implicit \nconstraints can cause an indirect form of expansion that is unaccounted for. Consider the class declaration \nin Figure 10. According to the de.nition by Kennedy and Pierce [8], this is not expansive inheri\u00adtance \nsince List<Q> is the type argument corresponding to P rather than to Q. However, the proof in Figure \n10 never repeats itself. The key observation to make is that the context, which would be .xed in Kennedy \nand Pierce s setting, is continually expanding in this See Section 7.4 for a clari.cation on type validity. \n class C<P, Q extends P> implements List<List<? super C<List<Q>,?>>> {} Is C<?,?> a subtype of List<? \nsuper C<?,?>>? Constraints Subtyping (wildcard capture done automatically) X1 <:: X0 C<X0,X1> <?: List<? \nsuper C<?,?>> Y1 <:: Y0 C<Y0,Y1> <?: List<? super C<List<X1>,?>> X2 <:: List<X1> C<List<X1>,X2> <?: List<? \nsuper C<List<Y1>,?>> Y2 <:: List<Y1> C<List<Y1>,Y2> <?: List<? super C<List<X2>,?>> X3 <:: List<X2> C<List<X2>,X3> \n<?: List<? super C<List<Y2>,?>> Y3 <:: List<Y2> C<List<Y2>,Y3> <?: List<? super C<List<X3>,?>> X4 <:: \nList<X3> C<List<X3>,X4> <?: List<? super C<List<Y3>,?>> (continue forever) Figure 10. Example of expansion \nthrough implicit constraints class Var { boolean mValue; void addTo(List<? super Var> trues, List<? super \nVar> falses) {(mValue ? trues : falses).add(this);}} Figure 11. Example of valid code erroneously rejected \nby javac setting. In the last step we display, the second type argument of C is a subtype of List<? extends \nList<? extends List<?>>>, which will keep growing as the proof continues. Thus Smith and Cartwright s \nconjecture for a terminating subtyping algorithm does not hold. In our technical report we identify syntactic \nrestrictions that would be necessary (although possibly still not suf.cient) to adapt Kennedy and Pierce \ns algorithm to wildcards [15]. However, these restric\u00adtions are signi.cantly more complex than ours, \nand the adapted al\u00adgorithm would be strictly more complex than ours. 5. Challenges of Type-Argument Inference \nSo far we have discussed only one major challenge of wildcards, subtyping, and our solution to this challenge. \nNow we present another major challenge of wildcards, inference of type arguments for generic methods, \nwith our techniques to follow in Section 6. 5.1 Joins Java has the expression cond? t : f which evaluates \nto t if cond evaluates to true, and to f otherwise. In order to determine the type of this expression, \nit is useful to be able to combine the types determined for t and f using a join(t, t ' ) function which \nreturns the most precise common supertype of t and t ' . Un\u00adfortunately, not all pairs of types with \nwildcards have a join (even if we allow intersection types). For example, consider the types List<String> \nand List<Integer>, where String implements Comparable<String> and Integer implements Comparable<Integer>. \nBoth List<String> and List<Integer> are a List of something, call it X, and in both cases that X is a \nsubtype of Comparable<X>. So while both List<String> and List<Integer> are subtypes of simply List<?>, \nthey are also subtypes of List<? extends Comparable<?>> and of List<? extends Comparable<? extends Comparable<?>>> \nand so on. Thus their join using only wildcards is the undesirable in.nite type List<? extends Comparable<? \nextends Comparable<? extends ...>>>. javac addresses this by using an algorithm for .nding some common \nsupertype of t and t ' which is not necessarily the most precise. This strategy is incomplete, as we \neven saw in the class\u00adroom when it failed to type check the code in Figure 11. This sim\u00adple program fails \nto type check because javac determines that the type of (mValue ? trues : falses) is List<?> rather than \nthe obvious <P> P getFirst(List<P> list) {return list.get(0);}Number getFirstNumber(List<? extends Number> \nnums) {return getFirst(nums);}Object getFirstNonEmpty(List<String> strs, List<Object> obs) {return getFirst(!strs.isEmpty() \n? strs : obs);} Object getFirstNonEmpty2(List<String> strs, List<Integer> ints) {return getFirst(!strs.isEmpty() \n? strs : ints);} Figure 12. Examples of capture conversion List<? super Var>. In particular, javac s \nalgorithm may even fail to return t when both arguments are the same type t. Smith and Cartwright take \na different approach to joining types. They extend the type system with union types [13]. That is, the \njoin of List<String> and List<Integer> is just List<String> | List<Integer> in their system. t | t ' \nis de.ned to be a supertype of both t and t ' and a subtype of all common supertypes of t and t '. Thus, \nit is by de.nition the join of t and t ' in their extended type system. This works for the code in Figure \n11, but in Section 5.2 we will demonstrate the limitations of this solution. Another direction would \nbe to .nd a form of existential types beyond wildcards for which joins always exist. For example, using \ntraditional existential types the join of List<String> and List<Integer> is just .X : X <:: Comparable<X>. \nList<X>. However, our investigations suggest that it may be impossible for an existen\u00adtial type system \nto have both joins and decidable subtyping while being expressive enough to handle common Java code. \nTherefore, our solution will differ from all of the above.  5.2 Capture Conversion Java has generic \nmethods as well as generic classes [5: Chap\u00adter 8.4.4]. For example, the method getFirst in Figure 12 \nis generic with respect to P. Java attempts to infer type arguments for invoca\u00adtions of generic methods \n[5: Chapter 15.12.2.7], hence the uses of getFirst inside the various methods in Figure 12 do not need \nto be annotated with the appropriate instantiation of P. Interestingly, this enables Java to infer type \narguments that cannot be expressed by the user. Consider getFirstNumber. This method is accepted by javac; \nP is instantiated to the type variable for the wildcard ? extends Number, an instantiation of P that \nthe programmer cannot explicitly annotate because the programmer cannot explicitly name the wildcard. \nThus, Java is implicitly opening the existential type List<? extends Number> to List<X> with X <:: Number \nand then instantiating P as X so that the return type is X which is a subtype of Number. This ability \nto im\u00adplicitly capture wildcards, known as capture conversion [5: Chap\u00adter 5.1.10], is important to working \nwith wildcards but means type inference has to determine when to open a wildcard type. Smith and Cartwright \ndeveloped an algorithm for type-argument inference intended to improve upon javac [13]. Before going \ninto their algorithm and showing some of its limitations, let us .rst go back to Figure 11. Notice that \nthe example there, although origi\u00adnally presented as a join example, can be thought of as an infer\u00adence \nexample by considering the ?: operator to be like a generic method. In fact, Smith and Cartwright have \nalready shown that type-argument inference inherently requires .nding common su\u00adpertypes of two types \n[13], a process that is often performed using joins. Thus the ability to join types is closely intertwined \nwith the ability to do type-argument inference. Smith and Cartwright s ap\u00adproach for type-argument inference \nis based on their union types, which we explained in Section 5.1. Their approach to type infer\u00adence would \nsucceed on the example from Figure 11, because they use a union type, whereas javac incorrectly rejects \nthat program. Although Smith and Cartwright s approach to type-argument in\u00adference improves on Java s \napproach, their approach is not strictly  <P> List<P> singleton(P elem) {return null;} <Q extends Comparable<?>> \nQ foo(List<? super Q> list) {return null;} String typeName(Comparable<?> c) {return \"Comparable\";} String \ntypeName(String s) {return \"String\";} String typeName(Integer i) {return \"Integer\";} String typeName(Calendar \nc) {return \"Calendar\";} boolean ignore() {...}; String ambiguous() { return typeName(foo(singleton(ignore() \n? \"Blah\" : 1))); } Figure 13. Example of ambiguous typing affecting semantics better than Java s. Consider \nthe method getFirstNonEmpty in Fig\u00adure 12. javac accepts getFirstNonEmpty, combining List<String> and \nList<Object> into List<?> and then instantiating P to the captured wildcard. Smith and Cartwright s technique, \non the other hand, fails to type check getFirstNonEmpty. They combine List<String> and List<Object> into \nList<String> | List<Object>. However, there is no instantiation of P so that List<P> is a supertype of \nthe union type List<String> | List<Object>, so they reject the code. What their tech\u00adnique fails to incorporate \nin this situation is the capture conversion permitted by Java. For the same reason, they also fail to \naccept getFirstNonEmpty2, although javac also fails on this program for rea\u00adsons that are unclear given \nthe error message. The approach we will present is able to type check all of these examples.  5.3 Ambiguous \nTypes and Semantics In Java, the type of an expression can affect the semantics of the program, primarily \ndue to various forms of overloading. This is particularly problematic when combining wildcards and type\u00adargument \ninference. Consider the program in Figure 13. Notice that the value returned by ambiguous depends solely \non the type of the argument to typeName, which is the return type of foo which depends on the inferred \ntype arguments for the generic methods foo and singleton. Using javac s typing algorithms, ambiguous \nreturns \"Comparable\". Using Smith and Cartwright s typing algorithms [13], ambiguous returns either \"String\" \nor \"Integer\" depending on how the types are (arbitrarily) ordered internally. In fact, the answers provided \nby javac and by Smith and Cartwright are not the only possible answers. One could just as well instantiate \nP to Object and Q to Calendar to get ambiguous to return \"Calendar\", even though a Calendar instance \nis not even present in the method. The above discussion shows that, in fact, all four values are plausible, \nand which is returned depends on the results of type\u00adargument inference. Unfortunately, the Java speci.cation \ndoes not provide clear guidance on what should be done if there are multiple valid type arguments. It \ndoes however state the following [5: Chap\u00adter 15.12.2.7]: The type-inference algorithm should be viewed \nas a heuristic, designed to perform well in practice. This would lead one to believe that, given multiple \nvalid type arguments, an imple\u00admentation can heuristically pick amongst them, which would actu\u00adally make \nany of the four returned values a correct implementation of ambiguous. This is not only surprising, but \nalso leads to the un\u00adfortunate situation that by providing javac with smarter static typ\u00ading algorithms \none may actually change the semantics of existing programs. This in turn makes improving the typing algorithms \nin existing implementations a risky proposition. 6. Improving Type-Argument Inference Here we present \nan algorithm for joining wildcards as existential types which addresses the limitations of union types \nand which is complete provided the construction is used in restricted settings. We also describe preliminary \ntechniques for preventing ambiguity due to type-argument inference as discussed in Section 5.3. 6.1 \nLazily Joining Wildcards As we mentioned in Section 5.1, it seems unlikely that there is an existential \ntype system for wildcards with both joins and decid\u00adable subtyping. Fortunately, we have determined a \nway to extend our type system with a lazy existential type that solves many of our problems. Given a \npotential constraint on the variables bound in a lazy existential type we can determine whether that \nconstraint holds. However, we cannot enumerate the constraints on the vari\u00adables bound in a lazy existential \ntype, so lazy existential types must be used in a restricted manner. In particular, for any use of t<: \nt ', lazy existential types may only be used in covariant lo\u00adcations in t and contravariant locations \nin t '. Maintaining this in\u00advariant means that t ' will never be a lazy existential type. This is important \nbecause applying SUB-EXISTS requires checking all of the constraints of t ', but we have no means of \nenumerating these constraints for a lazy existential type. Fortunately, cond? t: f as well as unambiguous \ntype-argument inference only need a join for covariant locations of the return type, satisfying our requirement. \nSo suppose we want to construct the join (U) of captured wild\u00adcard types .G:..C<t1, ..., tm> and .G ' \n:. ' .D<t1' , ..., tn' >. Let {Ei}i in 1 to k be the set of minimal raw superclasses and super\u00adinterfaces \ncommon to C and D. Let each Ei<t\u00af1i , ..., t\u00af1ii > be the superclass of C<P1, ..., Pm>, and each Ei<t \n1i , ..., t 1ii > the su\u00adperclass of D<P1' , ..., Pn' >. Compute the anti-uni.cation [11, 12] '' '' of \nall t\u00afji[P1.t1,...,Pm.tm] with all t ji[P1.t1,...,P n.tn], resulting in t\u00a5ji with fresh variables Gu \nand assignments . and . ' such that each t\u00a5ji[.] equals t\u00afji[P1.t1,...,Pm.tm] and each t\u00a5i ti '' '' j \n[. ' ] equals j [P1 . t1,...,P . t ]. For example, the anti\u00ad nn uni.cation of the types Map<String,String> \nand Map<Integer,Integer> is Map<v,v> with assignments v . String and v . Integer. The join, then, is \nthe lazy existential type .Gu : (. . G : .; . ' . G ' :. ' . \u00a5\u00a5\u00a5\u00a5 E1<t11 , ..., t111 >&#38; ...&#38; \nEk<t1 k , ..., t1kk > The lazy constraint (. . G : .; . ' . G ' :. ' indicates that the constraints on \nGu are the constraints that hold in context G:. after substituting with . and in context G ' :. ' after \nsubstituting with . ' . Thus the total set of constraints is not computed, but there is a way to determine \nwhether a constraint is in this set. Note that this is the join because Java ensures the t\u00afand t types \nwill be unique. Capture conversion can be applied to a lazy existential type, addressing the key limitation \nof union types that we identi.ed in Section 5.2. The lazy constraint (. . G :.; . ' . G ' :. ' is simply \nadded to the context. The same is done when SUB-EXISTS applies with a lazy existential type as the subtype. \nWhen SUB-VAR applies for v<: t ' with v constrained by a lazy constraint rather than standard constraints, \none checks that both .(v) <: t ' [.] holds and . ' (v) <: t ' [. ' ] holds, applying the substitutions \nto relevant constraints in the context as well. A similar adaptation is also made for t<: v. This extended \nalgorithm is still guaranteed to terminate. With this technique, we can type check the code in Figure \n11 that javac incorrectly rejects as well as the code in Figure 12 in\u00adcluding the methods that Smith \nand Cartwright s algorithm incor\u00adrectly rejects. For example, for getFirstNonEmpty2 we would .rst join \nList<String> and List<Integer> as the lazy existential type .X : ({X . String} . \u00d8 : \u00d8; {X . Integer} \n. \u00d8 : \u00d8 . List<X> This type would then be capture converted so that the type param\u00adeter P of getFirst \nwould be instantiated with the lazily constrained type variable X. Although not necessary here, we would \nalso be able to determine that the constraint X <:: Comparable<X> holds for the lazily constrained type \nvariable.  Occasionally one has to join a type with a type variable. For this purpose, we introduce \na specialization of union types. This spe\u00adcialization looks like tu(v1 | ... | vn) or tu(t | v1 | ... \n| vn) where each vi is not lazily constrained and tu is a supertype of some wildcard capture of each \nupper bound of each type variable (and of t if present) with the property that any other non-variable \nt ' which is a supertype of each vi (and t ) is also a supertype of tu. A type t ' is a supertype of \nthis specialized union type if it is a supertype of tu or of each vi (and t ). Note that tu might not \nbe a supertype of any vi or of t and may instead be the join of the upper bounds of each vi (plus t ) \nafter opening the lazy existential type. This subtlety enables capture conversion to be applied unambigu\u00adously \nwhen called for. Unfortunately, we cannot join a type with a type variable that is lazily constrained \nbecause we cannot enumer\u00adate its upper bounds.  6.2 Inferring Unambiguous Types We believe that the \nJava language speci.cation should be changed to prevent type-argument inference from introducing ambiguity \ninto the semantics of programs. Since the inferred return type is what determines the semantics, one \nway to prevent ambiguity would be to permit type-argument inference only when a most precise return type \ncan be inferred, meaning the inferred return type is a subtype of all other return types that could arise \nfrom valid type arguments for the invocation at hand. Here we discuss how such a goal affects the design \nof type-argument inference. However, we do not present an actual algorithm since the techniques we present \nneed to be built upon further to produce an algorithm which prevents ambiguity but is also powerful enough \nto be practical. Typical inference algorithms work by collecting a set of con\u00adstraints and then attempting \nto determine a solution to those con\u00adstraints. If those constraints are not guaranteed to be suf.cient, \nthen any solution is veri.ed to be a correct typing of the expression (in this case the generic-method \ninvocation). Both javac [5: Chap\u00adters 15.12.2.7 and 15.12.2.8] and Smith and Cartwright [5] use this \napproach. Smith and Cartwright actually collect a set of sets of con\u00adstraints, with each set of constraints \nguaranteed to be suf.cient. However, to prevent ambiguity due to type-argument inference, necessity of \nconstraints is important rather than suf.ciency. For the ambiguous program in Figure 13, each of the \nsolutions we described in Section 5.3 was suf.cient; however, none of them were necessary, which was \nthe source of ambiguity. Unfortunately, Smith and Cartwright s algorithm is specialized to .nd suf.cient \nrather than necessary sets of constraints. This is why their algorithm results in two separate solutions \nfor Figure 13. However, their algo\u00adrithm could be altered to sacri.ce suf.ciency for sake of necessity \nby producing a less precise but necessary constraint at each point where they would currently introduce \na disjunction of constraints, which actually simpli.es the algorithm since it no longer has to propagate \ndisjunctions. After a necessary set of constraints has been determined, one then needs to determine a \nsolution. Some constraints will suggest that it is necessary for a type argument to be a speci.c type, \nin which case one just checks that the speci.c type satis.es the other constraints on that type argument. \nHowever, other type arguments will only be constrained above and/or below by other types so that there \ncan be many types satisfying the constraints. In order to prevent ambiguity, one cannot simply choose \nsolutions for these type arguments arbitrarily. For example, if the parameterized return type of the \nmethod is covariant (and not bivariant) with respect to a type parameter, then the solution for the corresponding \ntype argument must be the join of all its lower bounds, ensuring the inferred return type is the most \nprecise possible. Fortunately, since such joins would occur covariantly in the return type, it is safe \nto use the construction described in Section 6.1. Unfortunately, requiring the inferred return type to \nbe the most precise possible seems too restrictive to be practical. Consider the singleton method in \nFigure 13. Under this restriction, type\u00adargument inference would never be permitted for any invocation \nof singleton (without an expected return type) even though the inferred types of most such invocations \nwould not affect the semantics of the program. In light of this, we believe the unambiguous-inference \nchallenge should be addressed by combining the above techniques with an ability to determine when choices \ncan actually affect the semantics of the program. We have had promising .ndings on this front, but more \nthorough proofs and evaluations need to be done, so we leave this to future work.  6.3 Removing Intermediate \nTypes The processes above introduce new kinds of types, namely lazy ex\u00adistential types. Ideally these \ntypes need not be a part of the actual type system but rather just be an algorithmic intermediary. Fortu\u00adnately \nthis is the case for lazy existential types. By examining how the lazy existential type is used while \ntype checking the rest of the program, one can determine how to replace it with an existential type which \nmay be less precise but with which the program will still type check. This is done by tracking the pairs \nv<: t ' and t<: v, where v is lazily constrained, that are checked and found to hold using the modi.ed \nSUB-VAR rules. After type checking has completed, the lazy existential type can be replaced by an exis\u00adtential \ntype using only the tracked constraints (or slight variations thereof to prevent escaping variables). \nProof-tracking techniques can also be used to eliminate intersection types, important for ad\u00addressing \nthe non-determinism issues we will discuss in Section 7.2, as well as our specialized union types. 7. \nChallenges of Type Checking Wildcards pose dif.culties for type checking in addition to the subtyping \nand inference challenges we have discussed so far. Here we identify undesirable aspects of Java s type \nsystem caused by these dif.culties, and in Section 8 we present simple changes to create an improved \ntype system. 7.1 Inferring Implicit Constraints Java ensures that all types use type arguments satisfying \nthe criteria of the corresponding type parameters. Without wildcards, enforc\u00ading this requirement on \ntype arguments is fairly straightforward. Wildcards, however, complicate matters signi.cantly because \nthere may be a way to implicitly constrain wildcards so that the type ar\u00adguments satisfy their requirements. \nFor example, consider the fol\u00adlowing interface declaration: interface SubList<P extends List<? extends \nQ>, Q> {} Java accepts the type SubList<?,Number> because the wildcard can be implicitly constrained \nto be a subtype of List<? extends Number> with which the requirements of the type parameters are satis.ed. \nHowever, Java rejects the type SubList<List<Integer>,?> even though the wildcard can be implicitly constrained \nto be a supertype of Integer with which the requirements of the type parameters are satis.ed (in our \ntechnical report we formalize when a wildcard can be implicitly constrained [15]). Thus, Java s implicit-constraint \ninference is incomplete and as a consequence types that could be valid are nonetheless rejected by Java. \nThis raises the possibility of extending Java to use complete implicit-constraint inference (assuming \nthe problem is decidable). However, we have determined that this would cause signi.cant al\u00adgorithmic \nproblems (in addition to making it dif.cult for users to predict which types will be accepted or rejected \nas illustrated in our technical report [15]). In particular, complete implicit-constraint in\u00adference \nwould enable users to express types that have an implicitly in.nite body rather than just implicitly \nin.nite constraints. Con\u00adsider the following class declaration:  class C<P extends List<Q>, Q> extends \nList<C<C<?,?>,?>> {} For the type C<C<?,?>,?> to be valid, C<?,?> must be a subtype of List<X> where \nX is the last wildcard of C<C<?,?>,?>. Since C<?,?> is a subtype of List<C<C<?,?>,?>>, this implies X \nmust be equal to C<C<?,?>,?>, and with this implicit constraint the type arguments sat\u00adisfy the requirements \nof the corresponding type parameters. Now, if we expand the implicit equality on the last wildcard in \nC<C<?,?>,?> we get the type C<C<?,?>,C<C<?,?>,?>>, which in turn contains the type C<C<?,?>,?> so that \nwe can continually expand to get the in.nite type C<C<?,?>,C<C<?,?>,...>>. As one might suspect, in.nite \ntypes of this form cause non-termination problems for many algorithms. In light of these observations, \nwe will propose using implicit\u00adconstraint inference slightly stronger than Java s in order to ad\u00address \na slight asymmetry in Java s algorithm while still being user friendly as well as compatible with all \nalgorithms in this paper.  7.2 Non-Deterministic Type Checking The type checker in javac is currently \nnon-deterministic from the user s perspective. Consider the following interface declaration: interface \nMaps<P extends Map<?,String>> extends List<P> {} javac allows one to declare a program variable m to \nhave type Maps<? extends Map<String,?>>. The type of m, then, has a wildcard which is constrained to \nbe a subtype of both Map<?,String> and Map<String,?>. This means that m.get(0).entrySet() has two types, \nes\u00adsentially .X. Set<Entry<X,String>> and .Y. Set<Entry<String,Y>>, nei\u00adther of which is a subtype of \nthe other. However, the type-checking algorithm for javac is designed under the assumption that this \nwill never happen, and as such javac only checks whether one of the two options is suf.cient for type \nchecking the rest of the program, which is the source of non-determinism. javac makes this assumption \nbecause Java imposes single\u00adinstantiation inheritance, meaning a class (or interface) can ex\u00adtend C<t1, \n..., tn> and C<t1' , ..., tn' > only if each ti equals ti ' [5: Chapter 8.1.5] (in other words, prohibiting \nmultiple-in\u00adstantiation inheritance [8]). However, it is not clear what single\u00adinstantiation inheritance \nshould mean in the presence of wild\u00adcards. The Java language speci.cation is ambiguous in this re\u00adgard \n[5: Chapter 4.4], and javac s enforcement is too weak for the assumptions made by its algorithms, as \ndemonstrated above. Thus, we need to reconsider single-instantiation inheritance in detail with wildcards \nin mind. There are two ways to address this: restrict types in some way, or infer from two constraints \na stronger constraint that is consistent with single-instantiation inheritance. We consider the latter \n.rst since it is the more expressive option. Knowing that the wildcard in m s type above is a subtype \nof both Map<?,String> and Map<String,?>, single-instantiation in\u00adheritance suggests that the wildcard \nis actually a subtype of Map<String,String>. With this more precise constraint, we can deter\u00admine that \nthe type of m.get(0).entrySet() is Set<Entry<String,String>>, which is a subtype of the two alternatives \nmentioned earlier. For this strategy to work, given two upper bounds on a wildcard we have to be able \nto determine their meet: the most general common subtype consistent with single-instantiation inheritance. \nInterestingly, the meet of two types may not be expressible by the user. For example, the meet of List<?> \nand Set<?> is .X. List<X> &#38; Set<X>. Unfortunately, meets encounter many of the same problems of complete \nimplicit-constraint inference that we discussed in Sec\u00adtion 7.1. Assuming meets can always be computed, \npredicting when two types have a meet can be quite challenging. Furthermore, meets pose algorithmic challenges, \nsuch as for equivalence check\u00ading since with them Maps<? extends Map<String,?>> is equivalent to class \nC implements List<D<? extends List<D<? extends C>>>> {}class D<P extends C> {} Is D<? extends List<D<? \nextends C>>> equivalent to D<? extends C>? Key Steps of Proof ~? D<? extends List<D<? extends C>>> = \nD<? extends C> (Checking :>) D<? extends C> <?: D<? extends List<D<? extends C>>> C <?: List<D<? extends \nC>> List<D<? extends List<D<? extends C>>>> <?: List<D<? extends C>> ~ D<? extends List<D<? extends \nC>>> = ?D<? extends C> (repeat forever) Figure 14. Example of in.nite proofs due to equivalence Maps<? \nextends Map<String,String>> even though neither explicit con\u00adstraint is redundant. This problem is not \nspeci.c to combining implicit and explicit constraints on wildcards. Java allows type parameters to be \ncon\u00adstrained by intersections of types: <P extends t1 &#38; ... &#38; tn>. Al\u00adthough Java imposes restrictions \non these intersections [5: Chap\u00adter 4.4], when wildcards are involved the same problems arise as with \ncombining implicit and explicit constraints. So, while javac rejects the intersection Map<?,String> &#38; \nMap<String,?>, javac does permit the intersection Numbers<?> &#38; Errors<?>. Should P be con\u00adstrained \nby this intersection, then due to the implicit constraints on the wildcards P is a subtype of both List<? \nextends Number> and List<? extends Error>, which once again introduces non-determin\u00adism into javac s \ntype checking. As a more severe alternative, one might consider throwing out single-instantiation inheritance \naltogether and redesigning the type checker for multiple-instantiation inheritance, especially if Java \ndecided to also throw out type erasure. However, multiple\u00adinstantiation inheritance in the presence of \nwildcards can actually lead to ambiguity in program semantics. Suppose an object has an implementation \nof both List<String> and List<Integer>. That ob\u00adject can be passed as a List<?>, but which List implementation \nis passed depends on whether the wildcard was instantiated with String or Integer. Thus an invocation \nof get(0) to get an Object from the List<?> (which is valid since the wildcard implicitly extends Object) \nwould return different results depending on the subtyping proof that was constructed (non-deterministically \nfrom the user s perspective). Thus a language with wildcards would either need to use single-instantiation \ninheritance or statically determine when subtyping can ambiguously affect semantics. After careful consideration, \nour solution will be to restrict inter\u00adsections and explicit constraints on wildcards so that they are \ncon\u00adsistent with single-instantiation inheritance adapted to wildcards.  7.3 Equivalence Numbers<?> \nis equivalent to Numbers<? extends Number> because of the implicit constraint on the wildcard. As such, \none would expect List<Numbers<?>> to be equivalent to List<Numbers<? extends Number>>. However, this \nis not the case according to the Java language spec\u00adi.cation [5: Chapters 4.5.1.1 and 4.10.2] and the \nformalization by Torgersen et al. [17] referenced therein (although javac makes some attempts to support \nthis). The reason is that Java uses syn\u00adtactic equality when comparing type arguments, re.ected in our \nSUB-EXISTS rule by the use of = in the .fth premise. Ideally equivalent types could be used interchangeably. \nThus, during subtyping Java should only require type arguments to be equivalent rather than strictly \nsyntactically identical. The obvi\u00adous way to implement this is to simply check that the type ar\u00ad  ' \n?' ''' 1,..., t n)= (G ' ;.\u00b7 ; t1,...,t t?1,..., ?t? explicit( explicit( \u00b7 ; t1,...,tm .. .. n t m)= \n(G; .C<P1,...,Pm> is a subclass of E<t\u00af1,...,t\u00afk> ''' '' for all and and i in 1 to k, t\u00afi[P1.t1,...,Pm.tm]= \nt\u00afi [P1.t1,...,P .t ] nn . . '' '' D<P1,...,Pn> is a subclass of E<t\u00af1,...,t\u00afk>  ???' ?' : f C<t 1, \n..., t m> r\u00b7 D<t 1, ..., t n> Figure 15. De.nition of when two types intersect monomorphically guments \nare subtypes of each other, as proposed by Smith and Cartwright [13]. Yet, to our surprise, this introduces \nanother source of in.nite proofs and potential for non-termination. We give one such example in Figure \n14, and, as with prior examples, this ex\u00adample can be modi.ed so that the in.nite proof is acyclic. This \nexample is particularly problematic since it satis.es both our inher\u00aditance and parameter restrictions. \nWe will address this problem by canonicalizing types prior to syntactic comparison.  7.4 Inheritance \nConsistency Lastly, for sake of completeness we discuss a problem which, al\u00adthough not of.cially addressed \nby the Java language speci.cation, appears to already be addressed by javac. In particular, the type \nNumbers<? super String> poses an interesting problem. The wildcard is constrained explicitly below by \nString and implicitly above by Number. Should this type be opened, then transitivity would imply that \nString is a subtype of Number, which is inconsistent with the inheritance hierarchy. One might argue \nthat this is sound because we are opening an uninhabitable type and so the code is unreach\u00adable anyways. \nHowever, this type is inhabitable because Java al\u00adlows null to have any type. Fortunately, javac appears \nto already prohibit such types, preventing unsoundness in the language. Com\u00adpleteness of our subtyping \nalgorithm actually assumes such types are rejected; we did not state this as an explicit requirement \nof our theorem because it already holds for Java as it exists in practice. 8. Improved Type System Here \nwe present a variety of slight changes to Java s type system regarding wildcards in order to rid it of \nthe undesirable properties discussed in Section 7. 8.1 Implicit Lower Bounds Although we showed in Section \n7.1 that using complete implicit\u00adconstraint inference is problematic, we still believe Java should use \na slightly stronger algorithm. In particular, consider the types Super<Number,?> and Super<?,Integer>. \nThe former is accepted by Java whereas the latter is rejected. However, should Java permit type parameters \nto have lower-bound requirements, then the class Super might also be declared as class Super<P super \nQ, Q> {} Using Java s completely syntactic approach to implicit-constraint inference, under this declaration \nnow Super<Number,?> would be re\u00adjected and Super<?,Integer> would be accepted. This is the oppo\u00adsite \nof before, even though the two class declarations are conceptu\u00adally equivalent. In light of this, implicit-constraint \ninference should also infer implicit lower-bound constraints for any wildcard corre\u00adsponding to a type \nparameter P with another type parameter Q con\u00adstrained to extend P . This slight strengthening addresses \nthe asym\u00admetry in Java s syntactic approach while still having predictable behavior from a user s perspective \nand also being compatible with our algorithms even with the language extensions in Section 10.  8.2 \nSingle-Instantiation Inheritance We have determined an adaptation of single-instantiation inheri\u00adtance \nto existential types, and consequently wildcards, which ad\u00addresses the non-determinism issues raised \nin Section 7.2: For all types t and class or interface names C, if t has a supertype of the form .G:..C<...>, \nthen t has a most precise supertype of that form. Should this be ensured, whenever a variable of type \nt is used as an instance of C the type checker can use the most precise supertype of t with the appropriate \nform without having to worry about any alternative supertypes. Java only ensures single-instantiation \ninheritance with wild\u00adcards when t is a class or interface type, but not when t is a type variable. Type \nvariables can either be type parameters or captured wildcards, so we need to ensure single-instantiation \ninheritance in both cases. In order to do this, we introduce a concept we call monomorphically intersecting \ntypes, de.ned in Figure 15. Conceptually, two types intersect monomorphically if they have no wildcards \nin common. More formally, for any common super\u00adclass or superinterface C, there is a most precise common \nsupertype of the form C<t1, ..., tn> that is monomorphic, meaning none of ti is a wildcard type argument. \nFor Java speci.cally, we should impose additional requirements in Figure 15: C or D must be an interface \nto re.ect single inheritance of classes [5: Chapter 8.1.4], and C and D cannot have any common methods \nwith the same sig\u00adnature but different return types (after erasure) to re.ect the fact that no class \nwould be able to extend or implement both C and D [5: Chapter 8.1.5]. Using this new concept, we say \nthat two types validly inter\u00adsect each other if either is a subtype of the other or they inter\u00adsect monomorphically. \nWith this, we can impose our restriction ensuring single-instantiation inheritance for type parameters \nand captured wildcard type variables so that single-instantiation inheri\u00adtance holds for the entire type \nsystem. Intersection Restriction For every syntactically occurring intersection t1 &#38; ... &#38; tn, \nevery ti must validly intersect with every other tj . For every explicit upper bound t on a wildcard, \nt must validly inter\u00adsect with all other upper bounds on that wildcard. This restriction has an ancillary \nbene.t as well. Monomor\u00adphically intersecting types have the property that their meet, as discussed in \nSection 7.2, is simply the intersection of the types. This is not the case for List<?> with Set<?>, whose \nmeet is .X. List<X> &#38; Set<X>. Our intersection restriction then implies that all intersections coincide \nwith their meet, and so intersection types are actually unnecessary in our system. That is, the syntax \nP extends t1 &#38; ... &#38; tn can simply be interpreted as P extends ti for each i in1 to n without \nintroducing an actual type t1 &#38; ... &#38; tn. Thus our solution addresses the non-determinism issues \ndiscussed in Section 7.2 and simpli.es the formal type system.  f t . \u00aft f t ' . \u00aft ' : f t ~= t ' \u00aft \n= \u00aft ' explicit(t?1,..., t?n)= (G; .\u00b7 ; t1,...,tn implicit(G; C; t1,...,tn)=. . {v<:: t in .| for no \nv<:: ' in .t ' \u00b7 \u00b7 <:: \u00b7 t . , f <t } =.{v ::>t in .| for no v ::> ' in .t<t ' \u00b7 ::> \u00b7 t . , f \u00b7 } =.for \nall i in 1 to n, f ti. ti ' {v<:: t ' | v<:: t in .\u00b7 <:: and f t . t ' } =.\u00b7 ' <:: {v ::>t ' | v ::>t \nin .\u00b7 ::> and f t . t ' } =.\u00b7 ' ::> ''' ' ?' ?' (G; .\u00b7 <::, .\u00b7 ::>; t1,...,t n = explicit(t 1,..., tn) \n???' ?' f C<t 1, ..., t n>. C<t 1, ..., t n> f v. v explicit(t?1,..., t?n)= (G; .\u00b7 ; t1,...,tn ?' ?' \n''' explicit(t1,..., t n)= (G ' ;.\u00b7 ; t1,...,t n for all i in 1 to n, if ti ' in G ' then ti = ti ' [.] \nelse ti not in G implicit(G; C; t1,...,tn)=. . '' ' . , . for all v<:: t in .\u00b7 ,.(v) <:: t in .\u00b7 with \nf t <\u00b7 t '' ' for all v ::>t in .,.(v) ::> in .\u00b7 t<t\u00b7 t . , .with f \u00b7 ???' ?' f C<t1, ..., tn> <\u00b7 C<t \n1, ..., t n> f v<\u00b7 v Figure 16. Rules for equivalence via canonicalization 8.3 Canonicalization In order \nto support interchangeability of equivalent types we can apply canonicalization prior to all checks for \nsyntactic equality. To enable this approach, we impose one last restriction. Equivalence Restriction \nFor every explicit upper bound t on a wildcard, t must not be a strict supertype of any other upper bound \non that wildcard. For every explicit lower bound t on a wildcard, t must be a supertype of every other \nlower bound on that wildcard. With this restriction, we can canonicalize wildcard types by re\u00admoving \nredundant explicit constraints under the assumption that the type is valid. By assuming type validity, \nwe do not have to check equivalence of type arguments, enabling us to avoid the full challenges that \nsubtyping faces. This means that the type valida\u00adtor must check original types rather than canonicalized \ntypes. Sub\u00adtyping may be used inside these validity checks which may in turn use canonicalization possibly \nassuming type validity of the type be\u00ading checked, but such indirect recursive assumptions are acceptable \nsince our formalization permits implicitly in.nite proofs. Our canonicalization algorithm is formalized \nas the. opera\u00ad tion in Figure 16. Its basic strategy is to identify and remove all redundant constraints. \nThe primary tool is the <\u00b7 relation, an im\u00adplementation of subtyping specialized to be sound and complete \nbetween class and interface types only if t is a supertype of t ' or they intersect monomorphically. \nEquivalence Theorem. Given the parameter restriction, the algo\u00adrithm prescribed by the rules in Figure \n16 terminates. Given the intersection and equivalence restrictions, the algorithm is further\u00admore a sound \nand nearly complete implementation of type equiva\u00adlence provided all types are valid according to the \nJava language speci.cation [5: Chapter 4.5]. Proof. Here we only discuss how our restrictions enable \nsoundness and completeness; the full proofs can be found in our technical re\u00adport [15]. The equivalence \nrestriction provides soundness and near completeness by ensuring the assumptions made by the <\u00b7 relation \nhold. The intersection restriction provides completeness by ensur\u00ading that non-redundant explicit bounds \nare unique up to equivalence so that syntactic equality after recursively removing all redundant constraints \nis a complete means for determining equivalence. We say our algorithm is nearly complete because it is \ncom\u00adplete on class and interface types but not on type variables. Our algorithm will only determine that \na type variable is equivalent to itself. While type parameters can only be equivalent to them\u00adselves, \ncaptured wildcard type variables can be equivalent to other types. Consider the type Numbers<? super \nNumber> in which the wild\u00adcard is constrained explicitly below by Number and implicitly above by Number \nso that the wildcard is equivalent to Number. Using our al\u00adgorithm, Numbers<? super Number> is not a \nsubtype of Numbers<Number>, which would be subtypes should one use a complete equivalence algorithm. \nWhile from a theoretical perspective this seems to be a weakness, as Summers et al. have argued [14], \nfrom a practical perspective it is a strength since it forces programmers to use the more precise type \nwhenever they actually rely on that extra preci\u00adsion rather than obscure it through implicit equivalences. \nPlus, our weaker notion of equivalence is still strong enough to achieve our goal of allowing equivalent \ntypes to be used interchangeably (pro\u00advided they satisfy all applicable restrictions). As such, we consider \nour nearly complete equivalence algorithm to be suf.cient and even preferable to a totally complete algorithm. \n9. Evaluation of Restrictions One might consider many of the examples in this paper to be con\u00adtrived. \nIndeed, a signi.cant contribution of our work is identifying restrictions that reject such contrived \nexamples but still permit the Java code that actually occurs in practice. Before imposing our re\u00adstrictions \non Java, it is important to ensure that they are actually compatible with existing code bases and design \npatterns. To this end, we conducted a large survey of open-source Java code. We examined a total of 10 \nprojects, including NetBeans (3.9 MLOC), Eclipse (2.3 MLOC), OpenJDK 6 (2.1 MLOC), and Google Web Toolkit \n(0.4 MLOC). As one of these projects we in\u00adcluded our own Java code from a prior research project because \nit made heavy use of generics and rather complex use of wildcards. Altogether the projects totalled 9.2 \nmillion lines of Java code with 3,041 generic classes and interfaces out of 94,781 total (ignoring anonymous \nclasses). To examine our benchmark suite, we aug\u00admented the OpenJDK 6 compiler to collect statistics \non the code it compiled. Here we present our .ndings. To evaluate our inheritance restriction, we analyzed \nall decla\u00adrations of direct superclasses and superinterfaces that occurred in our suite. In Figure 17, \nwe present in logarithmic scale how many of the 118,918 declared superclasses and superinterfaces had \ntype arguments and used wildcards and with what kind of constraints. If a class or interface declared \nmultiple direct superclasses and super\u00adinterfaces, we counted each declaration separately. Out of all \nthese declarations, none of them violated our inheritance restriction. To evaluate our parameter restriction, \nwe analyzed all con\u00adstraints on type parameters for classes, interfaces, and methods that occurred in \nour suite. In Figure 18, we break down how the 2,003 parameter constraints used type arguments, wildcards, \nand con\u00adstrained wildcards. Only 36 type-parameter constraints contained the syntax ? super. We manually \ninspected these 36 cases and de\u00adtermined that out of all type-parameter constraints, none of them violated \nour parameter restriction. Interestingly, we found no case where the type with a ? super type argument \nwas nested inside the constraint; only the constraint itself ever had such a type argument.  To evaluate \nthe .rst half of our intersection restriction, we examined all constraints on type parameters for classes, \ninterfaces, and methods that occurred in our suite. In Figure 19 we indicate in logarithmic scale how \nmany type parameters had no constraints, one constraint, or multiple constraints by using intersections. \nIn our entire suite there were only 61 intersections. We manually inspected these 61 intersections and \ndetermined that, out of all these intersections, none of them violated our intersection restriction. \nTo evaluate the second half of our intersection restriction as well as our equivalence restriction, we \nexamined all wildcards that occurred in our suite. In Figure 20 we break down the various ways the 19,018 \nwildcards were constrained. Only 3.5% of wildcards had both an implicit and an explicit upper bound. \nIn all of those cases, the explicit upper bound was actually a subtype of the implicit upper bound (interestingly, \nthough, for 35% of these cases the two bounds were actually equivalent). Thus out of all explicit bounds, \nnone of them violated either our intersection restriction or our equivalence restriction. Also, in the \nentire suite there were only 2 wildcards that had both an explicit lower bound and an implicit upper \nbound, and in both cases the explicit lower bound was a strict subtype of the implicit upper bound. In \nsummary, none of our constraints were ever violated in our entire suite. This leads us to believe that \nthe restrictions we impose will most likely have little negative impact on programmers. We also manually \ninvestigated for implicitly in.nite types, tak\u00ading advantage of the syntactic classi.cation of implicitly \nin.nite types described in our technical report [15]. We encountered only one example of an implicitly \nin.nite type. It was actually the same as class Infinite in Section 3.2; however, we investigated this \nfur\u00adther and determined this was actually an error which we easily cor\u00adrected [15]. We also did a manual \ninvestigation for implicitly in.\u00adnite proofs and found none. These .ndings are signi.cant because Cameron \net al. proved soundness of wildcards assuming all wild\u00adcards and subtyping proofs translate to .nite \ntraditional existential types and subtyping proofs [3], and Summers et al. gave semantics to wildcards \nunder the same assumptions [14], so although we have determined these assumptions do not hold theoretically \nour survey demonstrates that they do hold in practice. Nonetheless, we expect that Cameron et al. and \nSummers et al. would be able to adapt their work to implicitly in.nite types and proofs now that the \nproblem has been identi.ed. 10. Extensions Although in this paper we have focused on wildcards, our formal\u00adism \nand proofs are all phrased in terms of more general existential types [15]. This generality provides \nopportunity for extensions to the language. Here we offer a few such extensions which prelimi\u00adnary investigations \nsuggest are compatible with our algorithms, al\u00adthough full proofs have not yet been developed. Figure \n19. Number of con-Figure 20. Distribution of con\u00adstraints per type parameter straints on wildcards 10.1 \nDeclaration-Site Variance As Kennedy and Pierce mention [8], there is a simple translation from declaration-site \nvariance to use-site variance which preserves and re.ects subtyping. In short, except for a few cases, \ntype argu\u00adments t to covariant type parameters are translated to ? extends t , and type arguments t to \ncontravariant type parameters are trans\u00adlated to ? super t . Our restrictions on ? super then translate \nto re\u00adstrictions on contravariant type parameters. For example, our re\u00adstrictions would require that, \nin each declared direct superclass and superinterface, only types at covariant locations can use classes \nor interfaces with contravariant type parameters. Interestingly, this re\u00adstriction does not coincide \nwith any of the restrictions presented by Kennedy and Pierce. Thus, we have found a new termination re\u00adsult \nfor nominal subtyping with variance. It would be interesting to investigate existing code bases with \ndeclaration-site variance to de\u00adtermine if our restrictions might be more practical than prohibiting \nexpansive inheritance. Because declaration-site variance can be translated to wildcards, Java could use \nboth forms of variance. A wildcard should not be used as a type argument for a variant type parameter \nsince it is unclear what this would mean, although Java might consider interpreting the wildcard syntax \nslightly differently for variant type parameters for the sake of backwards compatibility. 10.2 Existential \nTypes The intersection restriction has the unfortunate consequence that constraints such as List<?> &#38; \nSet<?> are not allowed. We can ad\u00address this by allowing users to use existential types should they wish \nto. Then the user could express the constraint above using exists X. List<X> &#38; Set<X>, which satis.es \nthe intersection restric\u00adtion. Users could also express potentially useful types such as exists X. Pair<X,X> \nand exists X. List<List<X>>. Besides existentially quanti.ed type variables, we have taken into consideration \nconstraints, both explicit and implicit, and how to restrict them so that termination of subtyping is \nstill guaranteed since the general case is known to be undecidable [20]. While all bound variables must \noccur somewhere in the body of the existen\u00adtial type, they cannot occur inside an explicit constraint \noccurring in the body. This both prevents troublesome implicit constraints and permits the join technique \nin Section 6.1. As for the explicit constraints on the variables, lower bounds cannot reference bound \nvariables and upper bounds cannot have bound variables at covari\u00adant locations or in types at contravariant \nlocations. This allows po\u00adtentially useful types such as exists X extends Enum<X>. List<X>. As for implicit \nconstraints, since a bound variable could be used in many locations, the implicit constraints on that \nvariable are the ac\u00adcumulation of the implicit constraints for each location it occurs at. All upper \nbounds on a bound variable would have to validly inter\u00adsect with each other, and each bound variable \nwith multiple lower bounds would have to have a most general lower bound.  10.3 Lower-Bounded Type Parameters \nSmith and Cartwright propose allowing type parameters to have lower-bound requirements (i.e. super clauses) \n[13], providing a simple application of this feature which we duplicate here. <P super Integer> List<P> \nsequence(int n) { List<P> res = new LinkedList<P>(); for (int i =1; i <= n;i++) res.add(i); return res; \n} Our algorithms can support this feature provided lower-bound re\u00adquirements do not have explicitly bound \nwildcard type arguments. Also, they should not be other type parameters in the same param\u00adeterization \nsince that is better expressed by upper bounds on those type parameters. 10.4 Universal Types Another \nextension that could be compatible with our algorithms is a restricted form of predicative universal \ntypes like forall X. List<X>. Although this extension is mostly speculative, we mention it here as a \ndirection for future research since preliminary investigations suggest it is possible. Universal types \nwould ful.ll the main role that raw types play in Java besides convenience and backwards compatibility. \nIn particular, for something like an immutable empty list one typically produces one instance of an anonymous \nclass implementing raw List and then uses that instance as a List of any type they want. This way one \navoids wastefully allocating a new empty list for each type. Adding universal types would eliminate this \nneed for the back door provided by raw types. 11. Conclusion Despite their conceptual simplicity, wildcards \nare formally com\u00adplex, with impredicativity and implicit constraints being the pri\u00admary causes. Although \nmost often used in practice for use-site variance [6, 16 18], wildcards are best formalized as existential \ntypes [2, 3, 6, 8, 17, 18, 20], and more precisely as coinductive ex\u00adistential types with coinductive \nsubtyping proofs [15], which is a new .nding to the best of our knowledge. In this paper we have addressed \nthe problem of subtyping of wildcards, a problem suspected to be undecidable in its current form [8, \n20]. Our solution imposes simple restrictions, which a sur\u00advey of 9.2 million lines of open-source Java \ncode demonstrates are already compatible with existing code. Furthermore, our restric\u00adtions are all local, \nallowing for informative user-friendly error mes\u00adsages should they ever be violated. Because our formalization \nand proofs are in terms of a general\u00adpurpose variant of existential types [15], we have identi.ed a num\u00adber \nof extensions to Java that should be compatible with our al\u00adgorithms. Amongst these are declaration-site \nvariance and user\u00adexpressible existential types, which suggests that our algorithms and restrictions \nmay be suited for Scala as well, for which subtyp\u00ading is also suspected to be undecidable [8, 20]. Furthermore, \nit may be possible to support some form of universal types, which would remove a signi.cant practical \napplication of raw types so that they may be unnecessary should Java ever discard backwards compati\u00adbility \nas forebode in the language speci.cation [5: Chapter 4.8]. While we have addressed subtyping, joins, \nand a number of other subtleties with wildcards, there is still plenty of opportunity for research to \nbe done on wildcards. In particular, although we have provided techniques for improving type-argument \ninference, we believe it is important to identify a type-argument inference al\u00adgorithm which is both \ncomplete in practice and provides guarantees regarding ambiguity of program semantics. Furthermore, an \ninfer\u00adence system would ideally inform users at declaration-site how in\u00adferable their method signature \nis, rather than having users .nd out at each use-site. We hope our explanation of the challenges helps \nguide future research on wildcards towards solving such problems. Acknowledgements We would like to thank \nNicholas Cameron, Sophia Drossopoulou, Erik Ernst, Suresh Jagannathan, Andrew Kennedy, Jens Palsberg, \nPat Rondon, and the anonymous reviewers for their many insightful suggestions and intriguing discussions. \nReferences [1] Gilad Bracha, Martin Odersky, David Stoutamire, and Philip Wadler. Making the future safe \nfor the past: Adding genericity to the Java programming language. In OOPSLA, 1998. [2] Nicholas Cameron \nand Sophia Drossopoulou. On subtyping, wild\u00adcards, and existential types. In FTfJP, 2009. [3] Nicholas \nCameron, Sophia Drossopoulou, and Erik Ernst. A model for Java with wildcards. In ECOOP, 2008. [4] Peter \nCanning, William Cook, Walter Hill, Walter Olthoff, and John C. Mitchell. F-bounded polymorphism for \nobject-oriented programming. In FPCA, 1989. [5] James Gosling, Bill Joy, Guy Steel, and Gilad Bracha. \nThe JavaTM Language Speci.cation. Addison-Wesley Professional, third edition, June 2005. [6] Atsushi \nIgarashi and Mirko Viroli. On variance-based subtyping for parametric types. In ECOOP, 2002. [7] Simon \nPeyton Jones, Dimitrios Vytiniotis, Stephanie Weirich, and Mark Shields. Practical type inference for \narbitrary-rank types. Jour\u00adnal of Functional Programming, 17:1 82, January 2007. [8] Andrew Kennedy and \nBenjamin Pierce. On decidability of nominal subtyping with variance. In FOOL, 2007. [9] Daan Leijen. \nHMF: Simple type inference for .rst-class polymor\u00adphism. In ICFP, 2008. [10] Martin Odersky and Konstantin \nL\u00a8aufer. Putting type annotations to work. In POPL, 1996. [11] Gordon D. Plotkin. A note on inductive \ngeneralization. In Machine Intelligence, volume 5, pages 153 163. Edinburgh University Press, 1969. [12] \nJohn C. Reynolds. Transformational systems and the algebraic struc\u00adture of atomic formulas. In Machine \nIntelligence, volume 5, pages 135 151. Edinburgh University Press, 1969. [13] Daniel Smith and Robert \nCartwright. Java type inference is broken: Can we .x it? In OOPSLA, 2008. [14] Alexander J. Summers, \nNicholas Cameron, Mariangiola Dezani-Ciancaglini, and Sophia Drossopoulou. Towards a semantic model for \nJava wildcards. In FTfJP, 2010. [15] Ross Tate, Alan Leung, and Sorin Lerner. Taming wildcards in Java \ns type system. Technical report, University of California, San Diego, March 2011. [16] Kresten Krab Thorup \nand Mads Torgersen. Unifying genericity \u00adcombining the bene.ts of virtual types and parameterized classes. \nIn ECOOP, 1999. [17] Mads Torgersen, Erik Ernst, and Christian Plesner Hansen. Wild FJ. In FOOL, 2005. \n[18] Mads Torgersen, Christian Plesner Hansen, Erik Ernst, Peter von der Ah\u00b4e, Gilad Bracha, and Neal \nGafter. Adding wildcards to the Java programming language. In SAC, 2004. [19] Mirko Viroli. On the recursive \ngeneration of parametric types. Tech\u00adnical Report DEIS-LIA-00-002, Universit`a di Bologna, September \n2000. [20] Stefan Wehr and Peter Thiemann. On the decidability of subtyping with bounded existential \ntypes. In APLAS, 2009.      \n\t\t\t", "proc_id": "1993498", "abstract": "<p>Wildcards have become an important part of Java's type system since their introduction 7 years ago. Yet there are still many open problems with Java's wildcards. For example, there are no known sound and complete algorithms for subtyping (and consequently type checking) Java wildcards, and in fact subtyping is suspected to be undecidable because wildcards are a form of bounded existential types. Furthermore, some Java types with wildcards have no joins, making inference of type arguments for generic methods particularly difficult. Although there has been progress on these fronts, we have identified significant shortcomings of the current state of the art, along with new problems that have not been addressed.</p> <p>In this paper, we illustrate how these shortcomings reflect the subtle complexity of the problem domain, and then present major improvements to the current algorithms for wildcards by making slight restrictions on the usage of wildcards. Our survey of existing Java programs suggests that realistic code should already satisfy our restrictions without any modifications. We present a simple algorithm for subtyping which is both sound and complete with our restrictions, an algorithm for lazily joining types with wildcards which addresses some of the shortcomings of prior work, and techniques for improving the Java type system as a whole. Lastly, we describe various extensions to wildcards that would be compatible with our algorithms.</p>", "authors": [{"name": "Ross Tate", "author_profile_id": "81392610098", "affiliation": "University of California, San Diego, CA, USA", "person_id": "P2690667", "email_address": "rtate@cs.ucsd.edu", "orcid_id": ""}, {"name": "Alan Leung", "author_profile_id": "81442598931", "affiliation": "University of California, San Diego, CA, USA", "person_id": "P2690668", "email_address": "aleung@cs.ucsd.edu", "orcid_id": ""}, {"name": "Sorin Lerner", "author_profile_id": "81100399150", "affiliation": "University of California, San Diego, CA, USA", "person_id": "P2690669", "email_address": "lerner@cs.ucsd.edu", "orcid_id": ""}], "doi_number": "10.1145/1993498.1993570", "year": "2011", "article_id": "1993570", "conference": "PLDI", "title": "Taming wildcards in Java's type system", "url": "http://dl.acm.org/citation.cfm?id=1993570"}