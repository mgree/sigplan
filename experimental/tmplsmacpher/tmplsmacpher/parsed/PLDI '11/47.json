{"article_publication_date": "06-04-2011", "fulltext": "\n Separation Logic + Superposition Calculus = Heap Theorem Prover Juan Antonio Navarro P\u00b4erez Technische \nUniversit\u00a8unchen at M\u00a8 navarrop@in.tum.de Abstract Program analysis and veri.cation tools crucially \ndepend on the ability to symbolically describe and reason about sets of program behaviors. Separation \nlogic provides a promising foundation for dealing with heap manipulating programs, while the development \nof practical automated deduction/satis.ability checking tools for separation logic is a challenging problem. \nIn this paper, we present an ef.cient, sound and complete automated theorem prover for checking validity \nof entailments between separation logic formu\u00adlas with list segment predicates. Our theorem prover integrates \nsep\u00adaration logic inference rules that deal with list segments and a su\u00adperposition calculus to deal \nwith equality/aliasing between memory locations. The integration follows a modular combination approach \nthat allows one to directly incorporate existing advanced techniques for .rst-order reasoning with equality, \nas well as account for addi\u00adtional theories, e.g., linear arithmetic, using extensions of superpo\u00adsition. \nAn experimental evaluation of our entailment prover indi\u00adcates speedups of several orders of magnitude \nwith respect to the available state-of-the-art tools. Categories and Subject Descriptors D.2.4 [Software \nEngi\u00adneering]: Software/Program Veri.cation Formal methods; F.3.1 [Logics and Meanings of Programs]: \nSpecifying and Verify\u00ading and Reasoning about Programs Mechanical veri.cation; F.4.1 [Mathematical Logic \nand Formal Languages]: Mathematical Logic Mechanical theorem proving General Terms Veri.cation, Logic, \nReasoning Keywords Separation Logic, Superposition 1. Introduction Program analysis and veri.cation tools \ncrucially depend on the ability to symbolically describe and reason about program behav\u00adiors, e.g., using \nconstraints [21], logical formulas/predicates [1, 9, 20, 22, 34], types [25, 28], and abstract domains \n[8, 26]. Automated deduction techniques can deliver automation support for such rea\u00adsoning tasks. Today, \npropositional and Satis.ability Modulo The\u00adory (SMT) solvers are ubiquitous components of software analy\u00adsis, \nveri.cation, and debugging tools. These solvers can ef.ciently deal with practically relevant logical \ntheories of various scalar data Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. PLDI 11, June 4 8, 2011, San Jose, California, USA. Copyright c &#38;#169; \n2011 ACM 978-1-4503-0663-8/11/06. . . $10.00 Andrey Rybalchenko Technische Universit\u00a8unchen at M\u00a8 rybal@in.tum.de \ntypes, e.g., .xed length bit-vectors and numbers, as well as unin\u00adterpreted functions and arrays [2, \n10, 14, 19]. Dealing with programs that manipulate heap-allocated data structures using pointers imposes \nadditional challenges on sym\u00adbolic reasoning tools. Existing formalisms for tracking the shape of heap \ngraphs, e.g., three valued structures, separation logic, Boolean heaps, and monadic second-order logic \nof graph types [27, 31 33, 35], demonstrate the feasibility of automated reasoning about heap manipulating \nprograms while providing a wide spectrum of trade-offs w.r.t. automation, precision, ef.ciency, and applicability. \nSeparation logic provides a promising foundation for dealing with programs that manipulate the heap following \na certain dis\u00adcipline [33]. This discipline can be effectively exploited for man\u00adual/tool assisted proof \ndevelopment [18, 28, 37], extended static checking [6, 16], and automatic inference of heap shapes [7, \n12, 17, 38]. All these approaches depend on the ability to check logical entailment between separation \nlogic formulas, e.g., for validation of loop invariant candidates or .xpoint detection. Automation of \nseparation logic usually extended with re\u00adcursively de.ned shape predicates such as lists, trees, or \nnested containers relies on decidable sub-classes together with the cor\u00adresponding proof systems or heuristic \napproaches based on fold\u00ading/unfolding strategies for recursive shape de.nitions [6, 7, 11, 13, 23, 29, \n36, 38]. Development of practical entailment checking tools for separation logic is a challenging problem. \nSince the exist\u00ading proof systems pursue an intricate interplay between aliasing of memory locations \nand their occurrence in scope of the shape pred\u00adicates, the proof search becomes a complex procedure \nexposed to the non-determinism of the inference rule applications. Heuristic approaches require sophisticated \n(un)folding strategies, which are dif.cult to get right in a predictable and robust way. As a result, \nen\u00adtailment checkers for separation logic have not reached yet the level of applicability on par with \nstate-of-the-art SAT and SMT solvers. In this paper, we present an ef.cient, sound and complete auto\u00admated \ntheorem prover for checking validity of entailments between separation logic formulas with list segment \npredicates. In contrast to the existing tools, our approach puts to work the framework of paramodulation-based \ntheorem proving [30]. Instead of repre\u00adsenting proof rules as an axiom schema and performing a generic \ninference-based proof search, by applying the framework we obtain specialized inference rules together \nwith an adequate, optimized rule application strategy, without compromising either soundness or completeness. \nOur theorem prover relies on a combination of separation logic inference rules that deal with list segments \nand a superposition cal\u00adculus to deal with equality/aliasing between memory locations. Our separation \nlogic inference rules are obtained from an existing proof system for separation logic with list segments \n[4], which is a basis for various separation logic based tools [6, 11, 16, 36], by factoring out its \nbuilt-in equality reasoning. We use a standard superposition calculus for equality, and rely on its ability \nto generate (partial) models. The model generation ties together the equality and list segment reasoning. \nGiven an entailment to check, our prover .rst constructs a model for the equality predicates and then \nuses this model to disambiguate the heap shape for the subsequent treatment of the list segments. Since \nthe reasoning about the list segments can produce additional equalities, the entire process is repeated \nwith the updated model. By explicating the connection between the equality and sepa\u00adration logic inferences \nthrough the equality models, our theorem prover becomes more ef.cient than the original proof system. \nSince the equality model excludes certain heap shapes from considera\u00adtion, several non-deterministic \nproof search steps in the original proof system turn into deterministic ones and can be ef.ciently im\u00adplemented \nusing a rewriting process. An experimental evaluation of our entailment prover indicates speedups of \nseveral orders of magnitude with respect to the avail\u00adable state-of-the-art tools. Our implementation, \nwhich is written in Prolog to allow a declarative speci.cation of the inference rules of the proof system, \nis able to check thousands of entailments of increasing complexity in seconds rather than minutes. This \npaper makes the following contributions: 1. An effective factorization an important existing proof system \nfor separation logic into equality and separation reasoning; 2. An algorithm for proving entailments \nthat exploits this factor\u00adization; 3. Application of equality models for disambiguating heap shapes \nand thus eliminating the corresponding non-determinism from the proof search; 4. An ef.cient implementation \nof the theorem prover and its eval\u00aduation.  In summary, to the best of our knowledge we present to the \n.rst paramodulation-based automated theorem prover for separation logic with list segments. Our ultimate \ngoal is a theorem prover for an expressive frag\u00adment that combines separation logic with other theories \nuseful for program reasoning, including arithmetic and various data struc\u00adture shapes (such as trees). \nWe believe that building upon a well\u00adunderstood calculus, such as superposition, offers a viable start\u00ading \npoint. Existing extensions of superposition with linear arith\u00admetic [24] and SMT theories [3, 15] suggest \nimmediate steps for extending expressiveness of our current fragment. The increas\u00ading extensibility and \nprogrammability of state-of-the-art theorem provers, where Z3 is a prominent example, suggest that the \npre\u00adsented approach could be implemented within the existing tools. 2. Illustration We illustrate our \ntheorem proving algorithm using the following example. Assume we want to establish the validity of an \nentailment E given by c i e . lseg(a, b) * lseg(a, c) * next(c, d) * lseg(d, e) . lseg(b, c) * lseg(c, \ne) , where i is equality among program expressions, next(x, y) is a portion of the heap in the program \nstate where x points to y; lseg(x, y) is a portion of the heap (possibly empty if x = y) containing an \nacyclic path from x to y following the points to relation; and * is the union of disjoint portions of \nthe heap. The entailment itself states that any program state, composed of a stack and a heap, which \nsatis.es the conditions on the left-hand side of the formula, should also satisfy the right-hand side. \nThe .rst step of our approach is to build a clausal representa\u00adtion of the negation of the entailment, \ni.e. \u00acE. This set, denoted cnf(E), has the tree clauses: c i e . \u00d8 (1) \u00d8 . lseg(a, b) * lseg(a, c) * \nnext(c, d) * lseg(d, e) (2) lseg(b, c) * lseg(c, e) . \u00d8 (3) where \u00d8. F asserts a formula to be true, \nwhile F .\u00d8 asserts a formula as false. More generally, a clause such as A, B . C, D asserts that if all \nthe facts on the left-hand side are true, then at least one of the facts on the right should be true. \nFrom the clause (2), since lseg(a, b) * lseg(a, c) represents two disjoint portions of the heap, we know \nthat either a i b or a i c, i.e. one of these two segments should be empty. Thus we derive a new clause \n\u00d8. a i b, a i c . (4) Now we ask a superposition-based theorem prover to .nd for us a model for the pure \nclauses, those which only contain equalities, that have been computed so far, i.e. (1) and (4). Such \na prover could tell us that assuming a i c, and the rest of the variables distinct from each other, would \ndo. In particular a i c satis.es the clause (4). We apply this information and derive a new clause by \nsuperpo\u00adsition of (4) into (2) to obtain \u00d8. a i b, lseg(a, b) * next(a, d) * lseg(d, e) , (5) where c \nis replaced with a and a resulting empty list segment is removed. Note that a i b also appears in the \nclause, intuitively as a reminder that we have yet to try the other alternative. But let us continue \nby analyzing the heap described in clause (5). Now, from next(a, d), we know that a is de.nitely pointing \nto something in the heap; and thus the disjoint lseg(a, b) should be empty. So, in either case, a i b \nand we derive a new pure clause \u00d8. a i b . (6) We ask our superposition-based prover to .nd us a new \nmodel, and this time it tells us that, in fact, just setting a i b would do. This is enough to satisfy \nthe clause (6), as well as the previous two pure clauses. So we now try a superposition of (6) into (2) \nto obtain \u00d8. lseg(a, c) * next(c, d) * lseg(d, e) , (7) this time replacing b with a and removing the \nempty list segment. This description of a heap now looks all .ne, so let us apply a superposition of \n(6) into clause (3), which comes from the left-hand side of the entailment, to produce lseg(a, c) * lseg(c, \ne) .\u00d8 . (8) Now we see that it is possible to match and resolve away these two complementary heap formulas \nby unfolding the list segment lseg(c, e) into the disjoint union of next(c, d) * lseg(d, e). This is \nin fact possible if c i e; but if otherwise c i e then lseg(c, e) would be empty while next(c, d) * lseg(d, \ne) is de.nitely not (at least c is pointing to something). So we have to continue and consider the alternative \nwhen \u00d8. c i e . (9) But this time when we ask our superposition-based prover to .nd us a model for the \npure clauses, we are told that there are no models anymore! In fact the clauses (1) and (9) are contradictory \nand derive the empty clause. This exercise proves that the set of clauses cnf(E), equivalent to \u00acE, is \nnot satis.able and thus the original entailment must be valid. More than this, these inference steps \nactually constitute a proof of the validity of the entailment (c.f. Figure 4) which we describe later \nin detail in Section 5. 3. Preliminaries This section presents preliminary de.nitions. We introduce \nnota\u00adtion for dealing with relations and functions, separation logic, as well as equality reasoning using \nsuperposition. Relations We write x . y to denote the ordered pair (x, y) and, for a binary relation \nR, x .R y to denote x . y . R. The domain dom R of a relation is the projection of R on its .rst component, \ni.e. dom R = {x |.y : x .R y}. We write . * to denote the R re.exive and transitive closure of R; and \n. * for the symmetric, R re.exive, and transitive closure of R. An element y is irreducible by R if y \n./dom R. Furthermore, y is a normal form of x with respect to R if x . * R y and y is irreducible. A \nbinary relation R is well-founded if there is no in.nite se\u00adquence x1 .R x2 .R \u00b7\u00b7\u00b7 ; and con.uent if \nhaving x .R * y and x . * R z and y' . * R y' implies that there is a z such that y . * R z. A well-founded \nand con.uent relation is called convergent. Given a convergent relation R, every x has a unique normal \nform denoted by xR. Furthermore, we have that x . * R y if and only if xR = yR, i.e. two elements are \nequivalent with respect to R whenever their normal forms are identical. ' Functions A function f is a \nrelation where x .f y and x .f yimplies y = y'. If x . dom f we write f(x) to denote the (unique) element \ny such that x .f y. We say that f is a function from X to Y , denoted f : X . Y , if dom f = X and f(x) \n. Y for each x . X. In contrast, f is a partial function form X to Y , denoted f : X-Y , if dom f . X \nand f : dom f . Y . We write f[a . b] for a function update such that (f[a . b])(x)= b if x = a and (f[a.b])(x)= \nf(x) otherwise. Semicolons are used to compose function updates, i.e., f[a.b; c.d]=(f[a.b])[c.d]. Given \na pair of functions f and g, we write h = f * g when h = f . g and dom f n dom g = \u00d8, i.e. h is the union \nof two functions f and g with disjoint domains. Edges and paths A relation R is an edge from x to y, \ndenoted R : x . y, if R = {x . y}; and a relation R is a simple path from x to y, denoted R : x . * y, \nif R = {x1 . x2,...,xn-1 . xn}where x1 = x, xn = y, and xi = xj if i = j. Each simple path from x to \ny is acyclic, and y ./dom R. Edges and simple paths are functions. For example, R = {a . b, b . c, c \n. d} is a simple path and a function with dom R = {a, b, c}; and applying an update R[b . d; d . c]= \n{a . b, b . d, d . c, c . d}, the simple path property is invalidated. 3.1 Separation logic Separation \nlogic is used to reason about programs that manipulate pointer data structures [33]. The following is \nan abridged presenta\u00adtion of the considered fragment from Berdine et al. [5]. Syntax Let Var be a set \nof constant symbols together with a distinguished constant symbol nil such that nil ./Var. We use Var \nto represent program variables, and nil represents the null pointer. Let x and y be constant symbols. \nWe say that x i y is a pure atom, while next(x, y) and lseg(x, y) are basic spatial atoms. Then, we write \nf(x, y) for a basic spatial atom, where f is either next or f is lseg, and refer to x as the address \nof the atom. Given a multiset of basic spatial atoms that contains elements S1, ..., Sn, we say that \nS1 *\u00b7\u00b7\u00b7*Sn is a spatial atom; and emp denotes the empty multiset. A spatial atom S is well-formed if \n(1) no basic atom in S has a nil address, and (2) no two basic atoms in S share the same address. The \nset of separation logic formulas consists of pure atoms, spa\u00adcial atoms, and their boolean combinations \nobtained using conjunc\u00adtion ., disjunction ., and negation \u00ac.A literal is either an atom A or its negation \n\u00acA; an entailment F . G is a shorthand for \u00acF . G; and a logic equivalence F . G abbreviates the formula \nF . G . G . F . For a formula F , constant symbols x and y, the substitution F [y/x] replaces all occurrences \nof x in F with y. Semantics Let Loc bea setof memory locations and nil a spe\u00adcial location such that \nnil ./Loc. We de.ne Loc+ = Loc .{nil}. An interpretation (s, h) for a separation logic formula consists \nof a function stack s: Var . Loc+ and a partial function heap h : Loc -Loc+. Given a stack s, we de.ne \nthe evaluation func\u00adtion s : Var .{nil}. Loc+ as s = s[nil . nil]. Given an interpretation (s, h) and \nan atom A, we de.ne the satisfaction relation s, h |= A as follows: s, h |= x i y if s (x)= s (y) , s, \nh |= next(x, y) if h : s(x) . s (y) , s, h |= lseg(x, y) if h : s(x) . * s (y) , s, h |= S1 *\u00b7 \u00b7\u00b7* Sn \nif exist h1,...,hn such that h = h1 *\u00b7 \u00b7\u00b7* hn and s, hi |= Si for each 1 = i = n. From the above de.nition \nfollows that the empty spatial atom emp can only be satis.ed by an interpretation (s, \u00d8). We extend the \nsatisfaction relation |= to deal with logical connectives in a canonical way, i.e. s, h |= \u00acF if (s, \nh) does not satisfy F , while s, h |= F1 . \u00b7 \u00b7\u00b7 . Fn if (s, h) satis.es every conjunct Fi, and s, h |= \nF1 .\u00b7 \u00b7\u00b7. Fn if (s, h) satis.es some disjunct Fi. We also write s |= F when, for all heaps h, the pair \n(s, h) is a model of F . An interpretation that satis.es a formula is called a model;a formula is satis.able \nif it has a model; and a valid formula is satis.ed by every interpretation. Note that an entailment F \n. G is valid if every model of F satis.es G or, equivalently, if F .\u00acG is not satis.able. Program analysis \nand veri.cation tools often require checking the validity of entailments of the form . . S . .' . S' \nwhere . and .' are conjunctions of pure literals, while S and S' are spatial atoms. 3.2 Clausal normal \nform We use a clausal form to represent logic formulas. A clause is a disjunction of the form \u00acA1 .\u00b7 \n\u00b7\u00b7.\u00acAn . An+1 .\u00b7 \u00b7\u00b7. An+m where each Ai is an atom and at most one of them is a spatial atom. A set of \nclauses S represents the conjunction of its elements. Thus, an interpretation satis.es the set of clauses \nS if the interpretation satis.es every clause in S. For brevity, we write clauses in the form G . . , \nwhere the sets G= {A1,...,An} and .= {An+1,...,An+m}are, respectively, the sets of negative and positive \natoms in the clause. Commas are used in clauses to denote union and element inclusion, e.g. G, G',A . \n. stands for G . G' .{A}. .. The symbol D denotes the empty clause, i.e. the clause G . . where both \nG=.= \u00d8. A clause is pure if it contains only pure atoms, and is spatial otherwise. Given a set of clauses \nS we write Pure(S) to denote the subset of pure clauses contained in S. Let E be an entailment . . S \n. .' . S' such that .= P1 .\u00b7 \u00b7\u00b7. Pn .\u00acN1 .\u00b7 \u00b7\u00b7.\u00acNm , ''''' .= P1 .\u00b7 \u00b7\u00b7. PnI .\u00acN1 .\u00b7 \u00b7\u00b7.\u00acNmI . We de.ne \na clausal embedding function cnf (stands for clausal normal form) that takes an entailment E and returns \na representa\u00adtion of its negation \u00acE given by the set of clauses: cnf(E)= {\u00d8 . P1, ..., \u00d8. Pn, \u00d8. S N1 \n.\u00d8, ..., Nm .\u00d8, .'+, S' . .'-} ,  '' '' where the sets . ' + = {P1,...,P I } and . '- = {N1,...,N I \n} nm are, respectively, the sets of atoms occurring positively and nega\u00adtively in . '. Because the conjunction \nof clauses cnf(E) is logically equivalent to \u00acE, the entailment E is valid if and only if its clausal \nembedding cnf(E) is not satis.able. Since it is enough for our purposes, we assume that clauses have \nat most one spatial atom. Furthermore, in the following we assume that the symbols G and . represent \nsets of pure atoms, and a spatial atom occurring in a clause (if any) is written explicitly. Therefore \na clause can either be a pure clause, G ..,a positive spatial clause, G . S, ., or a negative spatial \nclause, G, S . ..  3.3 Superposition calculus for equality reasoning A key point of our approach is \nthat it allows the use of existing and well established techniques in automated deduction in order to \nreason about equality in the context of separation logic. A proof system which .ts our needs is that \nof the superposition calculus as presented, for example, by Nieuwenhuis and Rubio [30] (speci.\u00adcally \nthe system I de.ned for general clauses in their Section 3.5). This is a proof system with inference \nrules such as ' '' G . x i y, .G . x i y, . G, G '' , ., . ' . y i y where the clauses above the line \nare the premises of the rule and the clause below is its conclusion. Given a set of clauses S, if clauses \nmatching the premises of an inference rule are found in S, then we say that S derives the con\u00adclusion \nof the inference rule. In general we write SfX C if it is possible to derive a clause C from a set S \nby a successive applica\u00adtion of inference rules in X ; and write CnsX (S)= {C |SfX C}to denote the set \nof all consequences derived from S by inferences in the set X . A set of clauses S * is saturated, with \nrespect to the inferences X , if S * = CnsX (S * ). In the particular case of the proof system I, a number \nof super\u00adposition inference rules are de.ned which derive clauses that logi\u00adcally follow from S by interpreting \ni as an equality relation. To make the system useful in practice, inferences are constrained with respect \nto an appropriate order > over the terms of the language, and only maximal atoms are allowed to participate \nin inferences. For further details we refer the reader to [30]; in the following we only give a brief \nsummary of the concepts and de.nitions that are required to develop the work in this paper. The proof \nsystem I is refutation complete for pure clauses. This means that if S * = CnsI(S) is the saturation \nof a set S of pure clauses, then the empty clause D .S * if, and only if, the set S is not satis.able. \nCompleteness of the proof system is proved showing that if D /then it is possible to build a model, given \nby a .S * relation R, as a witness of the satis.ability of S. In this case R satis.es a pure atom x i \ny, denoted R * |i x i y, if x .R * y. Moreover, if R is a convergent relation, then R satis.es an atom \nx i y if, and only if, their normal forms xR = yR are identical. The relation R = Gen(S * ) is de.ned \nin terms of a generat\u00ading function Gen (see De.nition 3.8 in [30]) which selects some clauses C .S * \nand generates edges x .R y. For our purposes it is not important exactly how are clauses are selected \nfrom S * ; as we only rely on the following properties of such relation R. Lemma 3.1. Let S * be a set \nof pure clauses saturated with respect to I, and let R = Gen(S * ). The relation R is (1) convergent; \nand (2) if there is an edge x .R y then x > y, there is a clause G.xiy, . .S * which generated the edge \nand R * |i G.. (c.f. Lemma 3.9 in [30]). We will sometimes write (R, g) = Gen(S * ) to denote the fact \nthat the generating function provides both the relation R and a mapping g from each edge in R to its \ncorresponding generating clause in S * satisfying the conditions of item 2 in previous lemma. Completeness \nis established showing that, if the proof system I is unable to derive the empty clause, then R is indeed \na model of the set of pure clauses. Theorem 3.1. Let S be a set of pure clauses, let S * = CnsI (S) and \nlet R = Gen(S * ). If D /|i S. .S * then R * Observe that, in this context, models and interpretations \nfor pure clauses are de.ned in terms of a relation (w.r.t. |i) while, in the previous section, we used \na stack and a heap (w.r.t. |=). A simple result shows that, in fact, for a pure formula there is a one \nto one correspondence between its relation and stack models. For this we only need to make the assumption \nthat nil is a minimal element with respect to the order > used to generate the relation, i.e. x > nil \nfor every other constant symbol x in the logic. De.nition 3.1. Given a convergent relation R, the induced \nstack sR : Var . Loc+ is de.ned as sR(x)= nil if xR = nil, and sR(x)= .(xR) otherwise; where .: Var . \nLoc is an arbitrary, but .xed, injection that maps different program variables into different non-nil \nmemory locations. The condition asking nil to be a minimal element makes sure that if x . * R nil, then \nxR = nil and sR maps x to nil. Moreover, by de.nition s R(x)= s R(xR). In the following, to ease the \nnotation and if a suitable relation R clear by context, we simply write x as a shorthand for the memory \nlocation s R(x). Theorem 3.2. Let R be a convergent relation and let F be a pure formula. R * |i F if, \nand only if, sR |= F . Proof. Since the formula F is pure it is enough to consider the case of a pure \natom x i y and an arbitrary heap h. The result follows since, from the de.nition of sR, the normal forms \nare identical, i.e. xR = yR, if and only if the two symbols evaluate to the same memory location, i.e. \nx = y . D 4. Proof system for separation logic entailments In the previous section we described the superposition \ncalculus, the proof system I, which allows us to reason about equalities in the pure fragment of the \nlogic. We now focus on introducing the necessary inference rules to reason about the spatial component \nof our separation logic formulas. 4.1 Spatial reasoning The proof system SI is obtained by augmenting \nI with a number of additional inference rules shown in Figure 1. These rules are grouped into three main \ngroups of normalization, well-formedness, and unfolding inferences. N : The normalization inference N1 \nallows to use the information in a pure clause to rewrite the spatial atom occurring on a positive spatial \nclause; while the rule N2 discards trivial basic atoms of the form lseg(x, x). Rules N3 and N4 are their \nrespective counterparts for negative spatial clauses. W: The second group of well-formedness rules, W1 \nto W5, check for possible inconsistencies that could occur in positive spatial clauses. In particular \nthey make sure that nil is not used as an address in the heap, and that two disjoint parts of the heap \ndo not share a common address. U: Finally the unfolding inferences include the rules U1 to U5, which \nperform a one-step unfold of a basic atom lseg(x, z) in a negative spatial clause by using the information \ncontained in a positive spatial clause; and the rule SR of spatial resolu\u00ad  Normalization (N ): G . \nx i y, . , SG . ., lseg(x, x) * S G ' . . ' N1 N2 G, G ' . ., . ' , S[y/x]G . ., S G . x i y, .G ' , \nS . . ' G, lseg(x, x) * S . . N3 N4 G, G ' , S[y/x] . ., . ' G, S . . Well-formedness (W): G . ., next(nil,y) \n* SG . ., lseg(nil,y) * SG . ., next(x, y) * next(x, z) * S W1 W2W3 G . .G . y i nil, .G . . G . ., next(x, \ny) * lseg(x, z) * SG . ., lseg(x, y) * lseg(x, z) * S W4 W5 G . x i z, .G . x i y, x i z, . Unfolding \n(U): ''' ''' G . ., next(x, z) * SG , lseg(x, z) * S . .G . ., next(x, y) * SG , lseg(x, z) * S . . U1 \nU2 y = z ''' ''' G , next(x, z) * S . x i z, .G , next(x, y) * lseg(y, z) * S . x i z, . ' '' G . ., \nlseg(x, y) * SG , lseg(x, nil) * S . . U3 y = nil ' '' G , lseg(x, y) * lseg(y, nil) * S . . ' '' G \n. ., lseg(x, y) * next(z, w) * SG , lseg(x, z) * S . . U4 y = z ' '' G , lseg(x, y) * lseg(y, z) * S \n. . ' '' '' G . ., lseg(x, y) * lseg(z, w) * SG , lseg(x, z) * S . .G, S . .G . . , S U5 y = z SR G ' \n, lseg(x, y) * lseg(y, z) * S ' . z i w, . ' G, G ' . ., . ' Figure 1. Spatial inference rules of the \nSI proof system Well-formedness Unfolding W1: next(nil,y) * S .\u00d8 U1 : next(x, z) * S . x i z, lseg(x, \nz) * S W2: lseg(nil,y) * S . y i nil U2 : next(x, y) * lseg(y, z) * S . x i z, lseg(x, z) * S W3: next(x, \ny) * next(x, z) * S .\u00d8 U3 : lseg(x, y) * lseg(y, nil) * S . lseg(x, nil) * S W4: next(x, y) * lseg(x, \nz) * S . x i z U4 : lseg(x, y) * lseg(y, z) * next(z, w) * S . lseg(x, z) * next(z, w) * S W5: lseg(x, \ny) * lseg(x, z) * S . x i y, x i z U5 : lseg(x, y) * lseg(y, z) * lseg(z, w) * S . z i w, lseg(x, z) \n* lseg(z, w) * S Figure 2. Separation logic axiom schemas tion, which resolves away a common spatial \natom occurring in complementary spatial clauses. These inference rules, which can be thought of as coming \nfrom the separation logic axiom schemas in Figure 2, are a variation of the proof system for separation \nlogic entailments originally proposed by Berdine et al. [5]. The main difference between the two systems \nis that, while the proof system from Berdine et al. operates at the level of entailments; our inferences \nhave been rearranged in the form of clauses. This is key to the results presented in this paper, since \nit allows us to clearly separate the stages of pure equality and spatial reasoning, thus enabling the \ndirect application of a wide array of techniques from the theorem proving community into the context \nof separation logic. 4.2 Soundness It is easy to check that all inferences of the SI proof system are \nsound; namely if a pair (s, h) of a stack and a heap is a model of the premises of an inference rule, \nthen (s, h) is also a model of the conclusion of the rule. Theorem 4.1. Let E = . . S . . ' . S ' be \nan entailment, and let S * = CnsSI(cnf(E)). If D .S * then the entailment is valid. Proof. As all inferences \nin SI preserve models, any model of the clausal embedding cnf(E) would also be a model of the empty clause \nD. However, since the empty clause doesn t have any mod\u00adels, the set of clauses cnf(E) is unsatis.able \nand, by construction of the embedding, E is valid. D 4.3 Completeness by model generation The completeness \nof the SI proof system is proved by showing that, if the system is unable to derive the empty clause \nfrom the clausal embedding of an entailment, then it is possible to build a counterexample for the entailment. \nThe sketch of the proof is as follows: In section 3.3 we described a construction that generates a convergent \nrelation R as a model of a satis.able set of pure clauses and, furthermore, how this relation induces \na corresponding stack sR. What remains to be done is, after a suitable relation R is .xed, to build a \ncorresponding heap that is used to refute a given entailment. For this we introduce the notion of the \ngraph of a spatial atom S; in particular we show that if S is well-formed, then its graph grR S is actually \na heap. Given a spatial atom S, we also de.ne its normalization with respect to the relation R and prove \nthat normalization inferences are able to normalize the spatial atom. Then we prove that well\u00adformedness \ninferences make sure that the normalized SR is indeed well-formed. Finally we show that if unfolding \ninferences are able to successfully rewrite a spatial atom S ' into another SR, then R sR |=S . S '. \nOtherwise, if the unfolding fails, then it is possible to tweak the graph grR S into a counterexample \nshowing that sR,h |i S . S '; and thus allows us to refute entailments. Now that we have sketched the \nmain idea of the proof, we are ready to delve into its details. We start by de.ning, as promised, the \ngraph and the normalization of a spatial atom with respect to a given relation R. De.nition 4.1. The \ngraph of a basic spatial atom S with respect to a convergent relation R is grR S = {x . y } if either \n S = next(x, y), or  S = lseg(x, y) and x = y ;  and grR S = \u00d8 otherwise. The graph of S = S1 * \u00b7 \n\u00b7\u00b7 * Sn is de.ned as grR S = grR S1 .\u00b7 \u00b7\u00b7. grR Sn. De.nition 4.2. Given a spatial atom S and a convergent \nrelation R, the normal form of S with respect to R is the atom SR obtained by (1) replacing each constant \nsymbol x occurring in S with its normal form xR, and then (2) removing any trivial basic atoms of the \nform lseg(x, x). For example, given a relation R = {w . y} and an spatial atom S = lseg(x, y) * lseg(y, \nw) * lseg(y, z) * next(w, y), the normalized SR = lseg(x, y)*lseg(y, z) *next(y, y), and its graph is \ngiven by grR S= { y, z, y}. As the following x . y . y . lemma shows, this normal form is useful since \nit allows to quickly determine the relationships between an atom S, a relation R and its graph grR S. \nLemma 4.1. Given a spatial atom S and a convergent relation R: 1. grR S = grR SR and sR |=S . SR; 2. \nif two constants x = y occur in SR, then R * |i x i y; 3. if SR is well-formed, then h = grR S is a \nheap and sR,h |=S;  Proof. Both claims in the .rst item follow from the observation that the evaluation \nx = s R(x)= s R(xR) or, in other words, the stack sR cannot distinguish between a constant x and its \nnormal form xR. Furthermore, since trivial atoms the form lseg(x, x) have an empty graph and are only \nsatis.ed by the empty heap, they can be safely removed from SR. The second item trivially holds since \nthe constants x, y in SR are already in their normal forms and, if x = y, then R * |i x i y. For the \nlast item let SR = S1 *\u00b7 \u00b7\u00b7* Sn, and take hi = grR Si for each basic spatial atom in SR. Note that if \nxi is the address of the basic atom Si, and since there are no trivial atoms in SR, then necessarily \ndom hi = {x i}. Because SR is well-formed it follows that h = h1 *\u00b7 \u00b7\u00b7* hn is indeed a heap (i.e. nil \n./dom h and any two heaps hi, hj with i = j have disjoint domains). Moreover, by construction sR,hi |= \nSi and, therefore, sR,h |=SR. But, by de.nition, h = grR SR and, from the .rst item, it follows that \nboth h = grR S and sR,h |=S as well. D De.nition 4.3. Given a spatial clause C = G . ., S, a relation \nR is said to force the spatial atom S, denoted R, C .S, if R is not a model of the pure part of the clause, \ni.e. R * |i G . .. Similarly, for a clause C = G, S . ., we write R, C .\u00acS if R * |i G . .. Intuitively, \nif R, C . S (resp. \u00acS) then the model induced by R forces the spatial atom S to be true (resp. false) \nin order to satisfy the clause C. The following three lemmas are at the core of our main result, as they \nexplicate the role of normalization, well\u00adformedness and unfolding inference rules in the SI proof system. \nLemma 4.2 (Normalization). Let S * be a set of pure clauses saturated with respect to I, let R = Gen(S \n* ), and let C be a spatial clause. If R, C . S (resp. \u00acS) then there is a clause C ' such that S * ,C \nfN C ' and R, C ' . SR (resp. \u00acSR). Proof. More generally let (R, g) = Gen(S * ) be the generated relation \nand its selection function. By de.nition, if R, C . S for a clause C = G . ., S, then the relation R \n|i G . .. Now, if there is a constant symbol x occurring in S such that x = xR, there should be a rule \nx .R y for some y and, from Lemma 3.1, a clause D = g(x .R y)=G ' . x i y, . ' .S * such that R * |i \nG ' . . ' . An application of the normalization rule N1 between C and D yields a clause C1 such that \nS * ,C fN C1, also R, C1 . S[y/x] and the spatial atom is closer to its normal form. Iterating this process \nall constant symbols are rewritten to their normal form. Finally, trivial atoms are removed with the \nrule ' '' N2 to yield a clause C such that S, C fN C and R, C . SR. An analogous argument using normalization \nrules N3 and N4 shows that if R, C . \u00acS then a clause C ' is derived such that S, C fN C ' and R, C ' \n. \u00acSR. D As a result of this lemma, for a spatial clause C we allow our\u00adselves to write Norm((R, g); \nC) to denote any such clause C ' where the spatial atom S has been normalized to SR. Furthermore, from \nthe proof it follows that given the relation R and the clause selection function g, it is possible to \ncompute a normalized C ' in a straightforward way without requiring any search. The following lemma deals \nwith rules for well-formedness, and shows how they ensure that a normalized atom SR is indeed well\u00adformed. \nTo simplify the notation, we use PCnsX (S) as a shorthand for the set Pure(CnsX (S)) of pure clauses \nthat are derived from S with inferences in X . Lemma 4.3 (Well-formedness). Let S * be a set of pure \nclauses saturated with respect to I, let R = Gen(S * ), and let C be a spatial clause such that R, C \n. SR. If PCnsW ({C}) .S * and D / .S * then SR is well-formed. Proof. Since R, C . SR, the clause C \nis of the form G . ., SR and R * |i G . .. Moreover, since D / .S *, by Theorem 3.1 the relation R * \n|i S * and, by hypothesis, R * |i PCnsW ({C}). Now, if SR were not well-formed then one of the inference \nrules in W would apply either W1 or W2 if there is a nil address in SR, or one of W3, W4 or W5 if there \nare two basic spatial atoms with the same address to derive a pure clause D such that C fW D but R * \n|i D, and thus contradicting the fact that the relation R * |i PCnsW ({C}). For example, if there is \na basic atom lseg(nil,y) occurring in SR then nil = y, because the atom is not trivial, and by Lemma \n4.1 it follows that R * |i nil i y. Applying the rule W2 to C, a pure clause is derived such that R * \n|i G . nil i y, .. D Observe that there is no search involved in the computation of PCnsW ({C}), as it \nis enough to match C against the premises of rules in W to immediately compute its consequences. Finally, \nthe last of these lemmas formalzes the application of unfolding inferences in the proof system SI. Lemma \n4.4 (Unfolding). Let S * be a set of pure clauses satu\u00adrated with respect to I, let R = Gen(S * ), and \nlet C, C ' be spa\u00adtial clauses such that R, C SR ' \u00acS ' and R, C R. If the set PCnsU ({C, C ' }) .S * \n.S *, and SR , D /is well-formed, then there is an h such that sR,h |=S . S ' . Proof. Since the atom \nSR is well-formed, from Lemma 4.1, it follows that sR,h |=SR where h = grR SR. Now, if sR,h |=S ' R \nwe are done, as our h satis.es the conditions of the lemma. Assume that otherwise, sR,h |=S ' R. Now, \ntake the normalized atom S ' = S1 ' * \u00b7 \u00b7\u00b7 * S ' with no trivial basic atoms, it follows Rn that the \ngraph h = grR SR = h1 ' *\u00b7 \u00b7\u00b7* h ' for some non-empty S ' n heaps h ' i such that sR,h ' i |= i. In particular, \nsince grR SR is the separated union of graphs for basic atoms in SR, for each h ' i there is an atom \nTi occurring in SR for which h ' i = grR Ti and, moreover, the spatial atom SR = T1 *\u00b7 \u00b7\u00b7* Tn. We now \nshow that either: (a) unfolding inference rules are able '' '' to derive from {C, C ' } a clause C such \nthat R, C \u00acSR by rewriting each atom Si ' in S ' R into the corresponding Ti in SR or (b) h can be .xed \nto satisfy the statement of the theorem. Proceed for each Si ' as follows: Si ' = next(x, y). Then the \ngraph grR Ti : x . y is an edge and the spatial atom Ti = f(x, y). If the symbol f = next then, since \nSi ' = Ti, the atom Si has been rewritten into Ti. For the alternative, f = lseg, the case (b) holds \nsince then the pair (sR,h[ x . w; w . y ]), where w/. dom h, would be a model of S but not of S ' . \n Si ' = lseg(x, z). Then the graph grR Ti : x . * z is a simple path and the spatial atom Ti = f1(x1,x2) \n* \u00b7 \u00b7\u00b7 * fk(xk,z) where x1 = x. For each 1 = j = k, let  Ti,j = f1(x1,x2) *\u00b7 \u00b7\u00b7* fj-1(xj-1,xj ) * lseg(xj \n,z) , i.e. the .rst j - 1 basic spatial atoms from Ti followed by the atom lseg(xj ,z). Note that Ti,1 \n= Si', while Ti,k is identical to Ti except possibly for fk. For each 1 = j<k we will prove that if {C, \nC ' }fU Cj for a clause such that R, Cj \u00acSR[Ti,j /Si' ]; then a clause Cj+1 such that R, Cj+1 \u00acSR[Ti,j+1/Si' \n] can be derived by unfolding Si ' and walking over Ti according to the following two cases: fj = next. \nSince xj = z because the graph of Ti is a simple path, R * |i xj iz and the rule U2 rewrites Ti,j into \nTi,j+1. fj = lseg. If z = nil then the inference rule U3 does the rewrite, and if z is the address of \nan atom in SR then either U4 or U5 should apply. In the remaining case when the symbol y = nil, z is \nnot the address of any basic atom in SR and therefore z ./dom h again (b) holds since then the interpretation \n(sR,h[ yk1 . z ; z . y k]) is a model of S and not of S ' . So we have shown that it is possible to rewrite \nSi ' into Ti,k, which is identical to Ti except if fk = next. But in such case, since xk = z, the unfolding \nrule U1 rewrites Ti,k into Ti. From the previous argument if (b) is proved then again we are done, otherwise \nthe rewrite in (a) is successful and we derive a '' '' clause C such that R, C \u00acSR. But from hypothesis \nwe also had R, C SR and an application of the spatial resolution rule SR derives a pure clause D such \nthat R * |i D. However this is a contradiction, since by construction D . PCnsU ({C, C ' }) .S * , and \nthe relation R was supposed to be a model of D. D One more time, from the argument of the proof it follows \nthat there is no search required in order to compute the clauses, if any, in the set PCnsU ({C, C ' }). \nThis is a key property of our proof system: since R, C SR and SR is normalized, the basic atoms in SR \nguide the application of unfolding inferences in a 1: function prove(. . S . . ' . S ' ) 2: S := Pure(cnf(. \n. S . . ' . S ' )) 3: do 4: repeat 5: S * := CnsI(S) 6: if D .S * return valid 7: (R, g) := Gen(S * ) \n8: C := Norm((R, g); \u00d8. S) 9: S := S * . PCnsW ({C}) 10: until S = S * 11: if R |i . ' return c-example(S \n* ,C) 12: C ' := Norm((R, g);. ' +, S ' . . '-) 13: S := S * . PCnsU ({C, C ' }) 14: if S = S * return \nc-example(S * , C, C ' ) 15: loop Figure 3. Algorithm for entailment checking deterministic manner; \nthus eliminating the nondeterminism due to the associativity-commutativity of the separating conjunction. \nAfter having .nished the proofs of these lemmas, we are ready to show the completeness of our proof system \nSI. Theorem 4.2 (Completeness). Let E = . . S . . ' . S ' be an entailment, and let S * = .S * CnsSI(cnf(E)). \nIf D /then the entailment is not valid (i.e. there is a counterexample). Proof. Let S *= Pure(S * ) be \nthe subset of the pure clauses in the saturated set S *. Since D /then neither D /. and, by .S * .S *Theorem \n3.1, the relation R is a model of S * .. Moreover, from the de.nition of cnf(E), the relation R * |i \n.. Since the clause C = \u00d8. S . cnf(E), and R * |i D we have that R, C S. From Lemma 4.2, it follows that \nthere is a spatial clause Cn, derived by normalization inferences, such that R, Cn SR. Furthermore, since \nD ./. and S * is already S *saturated with respect to W rules, by Lemma 4.3 it follows that the spatial \natom SR is well-formed. Then, from Lemma 4.1, there is a heap h such that sR,h |=S. Also, since R * |i \n., from Theorem 3.2 we get that sR,h |=.. Indeed the pair (sR,h) is a model of . . S. Now, if R * |i \n. ' we are done since, also from Theorem 3.2, sR,h |= and we have found a counterexample. Otherwise, \nif . ' R * |i . ' then, equivalently, R * |i . ' + .. '- and, since the clause C ' = . ' +, S.. '- . \ncnf(E), we have that R, C ' \u00acS. Again by Lemma 4.2 there is a clause Cn ' derived from C ' by normalization \nrules such that R, C n ' \u00acSR' . In this case all the assumptions of Lemma 4.4 are satis.ed and a suitable \nh ' such that the pair (sR,h ' ) invalidates the entailment should therefore exist. D 5. Algorithm for \nentailment checking In the previous section we established the soundness and complete\u00adness of our proof \nsystem for the fragment of separation logic under consideration. We now turn our attention to use the \ninsight gained in the construction of such a proof, in order to build an ef.cient algorithm for proving \nthe validity of entailments. Along the lines of the proof of completeness, the algorithm for checking \nan entailment E = . . S . . ' . S ', which is given as pseudocode in Figure 3, emerges from a careful \ninterleaving of inferences using: superposition reasoning for pure clauses (line 5), normalization inferences \n(lines 8 and 12), well-formedness infer\u00adences (line 9), and unfolding inferences (line 13). The algorithm \nworks by incrementally building a set S with all the pure clauses that are derived from cnf(E). Initially \nS is set to the subset of pure clauses in the clausal embedding of E, i.e. S := {\u00d8 . A | A . .+}.{A .\u00d8| \nA . .-}.    The inner loop in lines 4 10 will .rst saturate the set S with superposition inferences \nusing the proof system I and, if the empty clause is derived in such process, the entailment is proved \nas valid. Otherwise the algorithm continues using the pair (R, g) generated from the saturated set S \n* to normalize the clause \u00d8. S . cnf(E) into a clause of the form C := G . SR, .. Finally S is updated \nwith the set of pure clauses that are derived from C using well\u00adformedness inference rules in W. The \nloop repeats until either the entailment is proved valid, or a .xpoint is reached when S = S * . Moreover, \nin the later case, we know that the spatial atom SR in C must be well-formed. If we exit the inner loop, \nthe clause . ' +, S ' . . '- . cnf(E) is then normalized to a clause of the form C ' := G ' , SR ' . \n. ' , and pure clauses derived from {C, C ' } using unfolding inference rules in U are added to S. If \nno new clauses are derived, then from Lemma 4.4 it is possible to build a counterexample for the entailment. \nOtherwise a new pure clause has been discovered and the main loop of the function iterates. Theorem 5.1. \nThe function prove(E) in Figure 3 terminates, is sound and complete. Proof. Soundness of the algorithm \nimmediately follows from the soundness of the SI proof system. And the algorithm terminates since the \ngrowing set S is bounded by PCnsSI(E), which is itself bounded by the .nite number of distinct pure clauses \nwhich can be written with the constant symbols occurring in E. Completeness follows from the following \ninvariants: The nor\u00admalized clause C computed in line 8 satis.es R, C SR (c.f. Lemma 4.2); after exiting \nthe inner loop in line 10 also R, C SR and SR is well-formed (c.f. Lemma 4.3). In particular, upon exiting \nthe loop, it is proved that . . S is satis.able by a model (sR,h); if at this point R * |i . ' we have \nfound a counterexample. Otherwise ' S ' the C computed in line 12 satis.es R, C R (c.f. Lemma 4.2); \nand if after line 13 a .x-point is detected, we have also found a counterexample (c.f. Lemma 4.4). D \nIn order to get a more concrete feeling of how the algorithm works, let us run again through the example \nfrom Section 2 to establish the validity of the entailment E given by c i e . lseg(a, b) * lseg(a, c) \n* next(c, d) * lseg(d, e) . lseg(b, c) * lseg(c, e) . The algorithm begins with S = {D1}, where D1 = \ncie.\u00d8 is the only pure clause in cnf(E). Then S * = CnsI(S)= S is trivially computed. No clauses are \nselected since R = Gen(S * )= \u00d8 is a model of S *; and normalization leaves the clause C := \u00d8. S, where \nS = lseg(a, b) * lseg(a, c) * next(c, d) * lseg(d, e), intact. Now the well-formedness rule W5 derives \nfrom C a new pure clause D2 = \u00d8. a i b, a i c. The inner loop iterates and the saturated set S * := CnsI({D1,D2}) \nis computed. Assume an order a -b -c and thus, D2 is selected to generate the relation R = Gen(S * )= \n{c . a}. Now normalization rewrites the input clause \u00d8. S into C := \u00d8. a i b, SR, where the spatial atom \nSR = lseg(a, b) * next(a, d) * lseg(d, e). This time, the inference rule W4 derives from C a third pure \nclause D3 = \u00d8. a i b. Another iteration of the inner loop now updates S * := CnsI({D1,D2,D3}), which \nare satis.ed by selecting D3 and producing R = Gen(S * )= {b . a}; while normalization rewrites the input \nclause \u00d8. S into C := \u00d8. SR where SR = lseg(a, c) * next(c, d) * lseg(d, e). At this point no more well-formedness \nrules in W apply, we have reached a .xpoint. Note that, indeed, SR is .nally a well\u00adformed atom. We exit \nthe inner loop and proceed to normalize the Table 1. Benchmarking 1000 random instances of F ... Time \n(secs.) Vars. Plseg P % Valid jStar Smallfoot SLP 10 0.10 0.20 54 300.08 13.46 1.02 11 12 13 14 15 16 \n17 18 19 20 0.09 0.09 0.08 0.07 0.06 0.05 0.05 0.04 0.04 0.04 0.15 0.11 0.11 0.11 0.12 0.17 0.13 0.20 \n0.15 0.11 50 54 55 53 52 50 54 49 50 52 (16%) (3%) (1%) (10%) (8%) (9%) (3%) (11%) (5%) (0%) 27.02 86.75 \n119.66 153.93 155.72 140.95 258.31 176.46 383.26 (90%) 1.06 1.46 1.48 1.74 1.73 1.59 2.15 1.88 2.15 2.65 \n Time (secs.) Vars. Pnext % Valid jStar Smallfoot SLP 10 11 12 13 14 15 16 17 18 19 20 0.70 0.69 0.69 \n0.70 0.69 0.69 0.69 0.71 0.70 0.70 0.70 53 53 53 53 53 52 49 53 49 53 49 (10%) (3%) (1%) (1%) (0%) (0%) \n(0%) (0%) (0%) (0%) (0%) 28.50 56.72 106.69 166.53 271.48 404.61 (80%) (79%) (49%) (30%) (19%) 1.29 1.24 \n1.49 1.82 2.19 2.49 2.68 3.06 3.60 3.65 3.87 Table 2. Benchmarking 1000 random instances of F . G. \nclause lseg(b, c) * lseg(c, e) .\u00d8 . cnf(E) into the corresponding clause C ' := S ' R = lseg(a, c) * \nlseg(c, e). Then R .\u00d8 where S ' the application of unfolding is successful since, from C and C ' , we \nderive the new pure clause D4 =\u00d8. e i c, add it to S, and start a new iteration of the main loop. However \nnow the set S * = CnsI (S) is inconsistent, since the clauses D1,D4 .S are contradictory and therefore \nD .S *. This proves that the original entailment E is indeed valid. Furthermore, from the run of this \nalgorithm it is possible to reconstruct a proof for the unsatis.ability of cnf(E), which is shown in \nFigure 4. The .gure shows how the empty clause D is derived from the set of input clauses cnf(E) using \nthe appropriate inference rules from the SI proof system. Each derived clause is numbered, and vertical \ndots are used to denote the reuse of a clause previously derived in the tree. The active part of each \nclause, on which the respective inference operates, is also highlighted with a frame box. 6. Experimental \nevaluation In order to empirically evaluate of the algorithm that we described in the previous section, \nwe implemented a theorem proving tool for separation logic entailments that we call SLP. The tool is \nimplemented in Prolog and consists of about a hundred lines of code to encode the logic of the algorithm \nin Figure 3 together with a declarative speci.cation of the inference rules of the SI proof system. The \npure model .nder is implemented in about .fty lines of code, and an additional four hundred lines are \nfor reading the program input, encoding into and manipulating internal data structures, as well as pretty \nprinting. Time (secs.) Copies jStar Smallfoot SLP 1 0.30 0.01 0.11 2 0.37 0.07 0.06 3 0.89 1.03 0.08 \n4 2.65 9.53 0.13 5 9.44 55.85 0.38 6 38.09 245.69 2.37 7 166.86 (64%) 20.83 8 (30%) (15%) 212.17 Table \n3. Benchmarking clones of Smallfoot examples. In a series of benchmarks, we compare the performance \nof our tool with two other available state-of-the-art veri.cation tools: Smallfoot [6], and jStar [16]. \nBoth of these tools take as input an\u00adnotated functions with pre-and post-conditions (respectively in \nC or in Java) and, through a process of symbolic execution, generate a number of veri.cation conditions \nthat have to be discharged in order to prove the validity of the program speci.cations. Each of this \nveri.cations conditions corresponds to an entail\u00adment check which could be alternatively discharged by \nour tool. Note that, currently, SLP does not perform veri.cation or sym\u00adbolic execution or programs. \nIndeed, what we want to compare is only the performance of SLP against the entailment checkers im\u00adplemented \nin Smallfoot and jStar. This is easily done with jStar, which provides a command run_logic with direct \naccess to the prover; while, in the case of Smallfoot, queries to the entailment checker can be faked \nwith minimal overhead by asking it to verify no-op functions of the form fun(vars)[F ]{}[G] which are \nvalid if, and only if, the entailment F . G holds. In order to benchmark these separation logic provers \non a wide class of formulas with increasing complexity, we .rst gener\u00adated some synthetic entailments \naccording to two different random distributions. The .rst of these distributions generates entailment \nchecks of the form . . S .., with n program variables from the set Var = {x1,...,xn}, as follows: if \ni = j, with probability Plseg include lseg(xi,xj ) in S; if i<j, with probability P include xi i xj \nin ..  Note that lseg edges, as well as pure inequalities, are chosen at ran\u00addom independently of each \nother. Furthermore, this kind of entail\u00adments can be proved (or refuted) by superposition, normalization \nand well-formedness rules only (i.e. the inner loop in the algorithm of Figure 3). Speci.cally: if these \nrules are able to prove that . .S is inconsistent, then the entailment is valid; conversely if these \nrules are enough to build a model for . . S, then the entailment has a counterexample. Moreover, note \nthat for .xed values of n and Plseg, we can use the parameter P to tune the proportion of generated entailments \nthat turn out to be valid. When P =0, then . is empty, there is a trivial model for S the one which makes \nall variables equal to nil and the entailment is invalid. Conversely, if P is high enough, adding inequalities \nbetween pairs of variables constrains the space of models for . . S to the point where, with high probability, \nit becomes empty and renders the entailment valid. We use this feature to calibrate the model so that, \nroughly, about half of the generated entailments are valid. Each row in Table 1 shows the time spent \nby each of the provers jStar, Smallfoot, and SLP to check 1000 randomly generated entailments with parameters \nranging from 10 to 20 vari\u00adables. Each time the provers were run with a single input .le con\u00adtaining \nall the entailments to check, so that we don t have to pay the time of starting up the process a thousand \ntimes. When a prover timed out after 10 minutes of execution, we show in parenthesis the percentage of \nthe instances that were successfully solved before hitting the time limit. SLP outperforms the other \nproves by several orders of magnitude, solving thousands of instances not in minutes but in a few seconds. \n Our second random distribution stresses the role of unfolding inferences in the entailment checks. Again \nwe assume a .xed set of n program variables Var = {x1,...,xn}, and we let p be a random permutation of \nthe indices of these variables such that p(i)= i. Then the spatial atom S= f(x1,xp(1)) *\u00b7 \u00b7\u00b7* f(xn,xp(n)) \n where each f is randomly selected as either next, with probability pnext, or lseg, with probability \n1 - pnext. Note that in this case, by construction, S is already well-formed. Now S ' starts as a copy \nof S, and then we randomly fold some paths in S '. For this we randomly pick a variable xi and, if it \nappears as the address of a basic atom that has not been folded yet, the longest path stating from xi \nby yet unfolded atoms is completely folded into an atom lseg(xi,x i * ), where xi * is the last variable \nreached through this path. This operation is repeated until all basic atoms have been folded. Finally \nwe ask to provers to check the validity of S . S ' . In this case the parameter pnext can be used to \ntune the propor\u00adtion of valid and invalid entailments. Table 2 shows the time spent by the provers checking \n1000 randomly generated entailments with parameters ranging from 10 to 20 variables. Again SLP outper\u00adforms \nthe other provers, which have trouble .guring out the correct unfolding required to prove/disprove each \nof these entailments. Our last set of benchmarks comes from the examples included in the Smallfoot distribution. \nThis includes some 18 real-life list manipulating programs, along with some speci.cations to prove. Note \nthat these also include some examples with arbitrary data .elds (other than a next pointer) which our \nimplementation can already handle. This involves slight modi.cations to the SI rules, not shown for brevity. \nFor the veri.cation of all of these programs, Smallfoot generates about 209 veri.cation conditions that \nhave to be discharged. These are actually some rather simple entailments to check, as all the three separation \nlogic provers are able to tackle them all in under a second.1 In order to create more challenging benchmarks, \nwhich still have some resemblance with those arising from real-life applications, we make use of a simple \ncloning tech\u00adnique. For each veri.cation condition . . S . . ' . S ' generated by Smallfoot, we generate \nthe equivalent but more challenging .1 .\u00b7 \u00b7\u00b7. .n . S1 *\u00b7 \u00b7\u00b7* Sn ' ''' . .1 .\u00b7 \u00b7\u00b7. .n . S1 *\u00b7 \u00b7\u00b7* Sn \nwhere each .i, Si, . ' i, and S ' i, is a copy of the formulas in the original entailment with their \nvariables renamed appart. Table 3 shows the running time spent by the provers trying to prove or refute \nthese 209 entailments. In this case, jStar seems to fare better than Smallfoot, however recall that jStar \nis incomplete and fails to prove 59 of the entailments which are actually valid. Nevertheless, SLP, which \nis both sound and complete, outperforms the other two provers in all of the cases. 1 With the caveat \nthat the logic rules provided with jStar are incomplete for the fragment of separation logic under consideration \n(personal communica\u00adtion with D. Distefano) and, therefore, unable to prove the validity of 59 of these \nentailments. 7. Conclusions In this paper we developed a proof system SI for proving the va\u00adlidity of \nseparation logic entailments with list predicates. A key result from this development is a separation \nfrom the reasoning re\u00adquired to deal with pure equality predicates, and the reasoning re\u00adquired to manipulate \nthe spatial information of such formulas. This enabled the design of an ef.cient, sound, and complete \nalgorithm for this kind of entailments, which leverages techniques that have been developed in the theorem \nproving community from the past three to four decades. The effectiveness of our proposed algorithm is \ndemonstrated by the implementation of a tool, SLP, which indi\u00adcates speedups of orders of magnitudes \nwith respect to the avail\u00adable state-of-the-art. We expect these ideas to prove fruitful in the further \ndevelopment and automation of program analysis and veri\u00ad.cation techniques for heap manipulating programs. \nReferences [1] T. Ball, R. Majumdar, T. D. Millstein, and S. K. Rajamani. Automatic predicate abstraction \nof c programs. In PLDI, pages 203 213, 2001. [2] C. Barrett and C. Tinelli. CVC3. In CAV, pages 298 302, \n2007. [3] P. Baumgartner and U. Waldmann. Superposition and model evolution combined. In CADE, pages \n17 34, 2009. [4] J. Berdine, C. Calcagno, and P. W. O Hearn. A decidable fragment of separation logic. \nIn FSTTCS, number 3328 in LNCS, pages 97 109, 2004. [5] J. Berdine, C. Calcagno, and P. W. O Hearn. Symbolic \nexecution with separation logic. In APLAS, pages 52 68, 2005. [6] J. Berdine, C. Calcagno, and P. W. \nO Hearn. Smallfoot: Modular automatic assertion checking with separation logic. In FMCO, 2006. [7] J. \nBerdine, C. Calcagno, B. Cook, D. Distefano, P. W. O Hearn, T. Wies, and H. Yang. Shape analysis for \ncomposite data structures. In CAV, pages 178 192, 2007. [8] B. Blanchet, P. Cousot, R. Cousot, J. Feret, \nL. Mauborgne, A. Min\u00b4e, D. Monniaux, and X. Rival. A static analyzer for large safety-critical software. \nIn PLDI, pages 196 207, 2003. [9] C. Bouillaguet, V. Kuncak, T. Wies, K. Zee, and M. C. Rinard. Using \n.rst-order theorem provers in the Jahob data structure veri.cation system. In VMCAI, pages 74 88, 2007. \n [10] R. Bruttomesso, A. Cimatti, A. Franz\u00b4en, A. Griggio, and R. Sebastiani. The MathSAT 4SMT solver. \nIn CAV, pages 299 303, 2008. [11] C. Calcagno, M. Parkinson, and V. Vafeiadis. SmallfootRG. In SAS, pages \n233 238, 2007. [12] C. Calcagno, D. Distefano, P. O Hearn, and H. Yang. Compositional shape analysis \nby means of bi-abduction. In POPL, pages 289 300, 2009. [13] B.-Y. E. Chang and X. Rival. Relational \ninductive shape analysis. In POPL, pages 247 260, 2008. [14] L. M. de Moura and N. Bj\u00f8rner. Z3: An ef.cient \nSMT solver. In TACAS, 2008. [15] L. M. de Moura and N. Bj\u00f8rner. Tapas theory combinations and practical \napplications. In FORMATS, 2009. [16] D. Distefano and M. Parkinson. jStar: Towards practical veri.cation \nfor Java. In OOPSLA, pages 213 226, 2008. [17] D. Distefano, P. W. O Hearn, and H. Yang. A local shape \nanalysis based on separation logic. In TACAS, pages 287 302, 2006. [18] R. Dockins, A. Hobor, and A. \nW. Appel. A fresh look at separation algebras and share accounting. In APLAS, pages 161 177, 2009. [19] \nB. Dutertre and L. D. Moura. The Yices SMT solver. Technical report, Computer Science Laboratory, SRI \nInternational, 2006. [20] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, and R. \nStata. Extended static checking for Java. In PLDI, pages 234 245, 2002.  [21] D. Gay and A. Aiken. Memory \nmanagement with explicit regions. In PLDI, pages 313 323, 1998. [22] T. A. Henzinger, R. Jhala, R. Majumdar, \nand G. Sutre. Lazy abstrac\u00adtion. In POPL, pages 58 70, 2002. [23] B. Jacobs and F. Piessens. The VeriFast \nprogram veri.er. Technical Report CW-520, Katholieke Universiteit Leuven, Belgium, 2008. [24] K. Korovin \nand A. Voronkov. Integrating linear arithmetic into su\u00adperposition calculus. In Computer Science Logic \n(CSL 07), volume 4646 of Lecture Notes in Computer Science, pages 223 237. Springer, 2007. [25] N. Marti \nand R. Affeldt. A certi.ed veri.er for a fragment of separa\u00adtion logic. Computer Software, 25(3):135 \n147, 2008. [26] M. M\u00b4endez-Lojo and M. V. Hermenegildo. Precise set sharing analysis for Java-style programs. \nIn VMCAI, pages 172 187, 2008. [27] A. M\u00f8ller and M. I. Schwartzbach. The pointer assertion logic engine. \nIn PLDI, pages 221 231, 2001. [28] A. Nanevski, G. Morrisett, A. Shinnar, P. Govereau, and L. Birkedal. \nYnot: Dependent types for imperative programs. In ICFP, pages 229 240, 2008. [29] H. H. Nguyen, V. Kuncak, \nand W.-N. Chin. Runtime checking for separation logic. In VMCAI, pages 203 217, 2008. [30] R. Nieuwenhuis \nand A. Rubio. Paramodulation-based theorem prov\u00ading. In J. A. Robinson and A. Voronkov, editors, Handbook \nof Auto\u00admated Reasoning, volume I, chapter 7, pages 371 443. Elsevier, 2001. [31] A. Podelski and T. \nWies. Boolean heaps. In SAS, pages 268 283, 2005. [32] A. Podelski and T. Wies. Counterexample-guided \nfocus. In POPL, pages 249 260, 2010. [33] J. Reynolds. Separation logic: A logic for shared mutable data \nstruc\u00adtures. In LICS, pages 55 74, 2002. [34] M. C. Rinard. Integrated reasoning and proof choice point \nselection in the Jahob system mechanisms for program survival. In CADE, pages 1 16, 2009. [35] S. Sagiv, \nT. W. Reps, and R. Wilhelm. Parametric shape analysis via 3-valued logic. ACM Trans. Program. Lang. Syst., \n24(3):217 298, 2002. \u00b4 Heap-Hop. In TACAS, pages 275 279, 2010.  [36] J. Villard, E. Lozes, and C. Calcagno. \nTracking heaps that hop with [37] H. Yang. An example of local reasoning in bi pointer logic: the schorr\u00adwaite \ngraph marking algorithm. In SPACE workshop, 2001. [38] H. Yang, O. Lee, J. Berdine, C. Calcagno, B. Cook, \nD. Distefano, and P. W. O Hearn. Scalable shape analysis for systems code. In CAV, pages 385 398, 2008. \n  \n\t\t\t", "proc_id": "1993498", "abstract": "<p>Program analysis and verification tools crucially depend on the ability to symbolically describe and reason about sets of program behaviors. Separation logic provides a promising foundation for dealing with heap manipulating programs, while the development of practical automated deduction/satisfiability checking tools for separation logic is a challenging problem. In this paper, we present an efficient, sound and complete automated theorem prover for checking validity of entailments between separation logic formulas with list segment predicates. Our theorem prover integrates separation logic inference rules that deal with list segments and a superposition calculus to deal with equality/aliasing between memory locations. The integration follows a modular combination approach that allows one to directly incorporate existing advanced techniques for first-order reasoning with equality, as well as account for additional theories, e.g., linear arithmetic, using extensions of superposition. An experimental evaluation of our entailment prover indicates speedups of several orders of magnitude with respect to the available state-of-the-art tools.</p>", "authors": [{"name": "Juan Antonio Navarro P&#233;rez", "author_profile_id": "81100113652", "affiliation": "Technische Universit&#228;t M&#252;nchen, M&#252;nchen, Germany", "person_id": "P2690650", "email_address": "navarrop@mail.in.tum.de", "orcid_id": ""}, {"name": "Andrey Rybalchenko", "author_profile_id": "81100483883", "affiliation": "Technische Universit&#228;t M&#252;nchen, M&#252;nchen, Germany", "person_id": "P2690651", "email_address": "rybal@in.tum.de", "orcid_id": ""}], "doi_number": "10.1145/1993498.1993563", "year": "2011", "article_id": "1993563", "conference": "PLDI", "title": "Separation logic + superposition calculus = heap theorem prover", "url": "http://dl.acm.org/citation.cfm?id=1993563"}