{"article_publication_date": "06-04-2011", "fulltext": "\n Probabilistic, Modular and Scalable Inference of Typestate Speci.cations Nels E. Beckman Aditya V. \nNori Carnegie Mellon University Microsoft Research India nbeckman@cs.cmu.edu adityan@microsoft.com Abstract \nStatic analysis tools aim to .nd bugs in software that correspond to violations of speci.cations. Unfortunately, \nfor large and com\u00adplex software, these speci.cations are usually either unavailable or sophisticated, \nand hard to write. This paper presents ANEK, a tool and accompanying methodol\u00adogy for inferring speci.cations \nuseful for modular typestate check\u00ading of programs. In particular, these speci.cations consist of pre \nand postconditions along with aliasing annotations known as access permissions. A novel feature of ANEK \nis that it can generate pro\u00adgram speci.cations even when the code under analysis gives rise to con.icting \nconstraints, a situation that typically occurs when there are bugs. The design of ANEK also makes it \neasy to add heuristic constraints that encode intuitions gleaned from several years of ex\u00adperience writing \nsuch speci.cations, and this allows it to infer spec\u00adi.cations that are better in a subjective sense. \nThe ANEK algorithm is based on a modular analysis that makes it fast and scalable, while producing reliable \nspeci.cations. All of these features are enabled by its underlying probabilistic analysis that produces \nspeci.cations that are very likely. Our implementation of ANEK infers access permissions spec\u00adi.cations \nused by the PLURAL [5] modular typestate checker for Java programs. We have run ANEK on a number of Java \nbench\u00admark programs, including one large open-source program (approx\u00adimately 38K lines of code), to infer \nspeci.cations that were then checked using PLURAL. The results for the large benchmark show that ANEK \ncan quickly infer speci.cations that are both accurate and qualitatively similar to those written by \nhand, and at 5% of the time taken to manually discover and hand-code the speci.cations. Categories and \nSubject Descriptors D.2.4 [Software/Program Veri.cation]: Statistical methods General Terms Algorithms, \nVeri.cation Keywords aliasing, inference, object protocol, ownership, per\u00admission, typestate, speci.cation \n1. Introduction Developing correct and reliable software is a hard problem, one that is supported by \nvarious analysis tools for improving software Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. PLDI 11, June 4 8, 2011, San Jose, California, USA. Copyright \nc &#38;#169; 2011 ACM 978-1-4503-0663-8/11/06. . . $10.00 Figure 1. The iterator protocol. quality and \nreliability. Even though these tools are largely auto\u00admated, many require user-provided speci.cations \nthat describe the property or protocol that the code under analysis is required to sat\u00adisfy [2, 5, 8, \n11] and this greatly limits their application in practice. However, writing good speci.cations is a hard \nand laborious task that also requires some degree of expertise on the codebase under analysis. In this \npaper we present ANEK1, a tool and an accompanying methodology for inferring speci.cations necessary \nfor modular typestate [18] checking. Given an API annotated with typestate speci.cations by its developers, \nANEK allows users of that API to quickly infer the speci.cations needed in their code in order to modularly \ncheck API conformance. Speci.cally, ANEK infers access permission speci.cations [5], speci.cations which, \nin addition to encoding abstract states of objects, also encode aliasing information, which allows for \nsound modular checking. Our inference algorithm is novel because it combines both the logical facts relating \nto permission creation and destruction as well as heuristics describing likely speci.cations, and does \nso using a scheme of probabilistic constraints. The result is an inference that is faster, generates \nbetter speci.cations and scales better than more traditional approaches. To illustrate our point, consider \nan example. A programmer wants to ensure correct use of Java s iterator API, modeled in Figure 1 and \nannotated by its developers with access permission speci.cations in Figure 2. Its speci.cation says that \nin order to call the next method, the receiver object must be known to be in the HASNEXT abstract state, \nwhich a client can be sure the object is in if the hasNext method returns true. The Collection interface \nis also speci.ed. It says that when the iterator method is called, a unique (unaliased) iterator will \nbe returned in the ALIVE state.2 Our hypothetical programmer wants to ensure that her simple spreadsheet \napplication, partially given in Figure 3, is always using 1 Anek is the Hindi word meaning plural. 2The \nALIVE state in the PLURAL methodology is the root of the state hierarchy, so this statement is equivalent \nto saying the iterator is not in any state of interest.  1 interface Iterator <T> { 2 @Spec(requires=\"full(this) \nin HASNEXT\", 3 ensures=\"full(this) in ALIVE\") 4 T next(); 5 6 @Spec(requires=\"pure(this) in ALIVE\", 7 \nensures =\"pure (this)\") 8 @TrueIndicates (\" HASNEXT\") 9 @FalseIndicates (\" END\")  10 boolean hasNext \n(); 11 } 12 13 interface Collection <T> extends Iterable <T> { 14 @Spec(ensures=\"unique(result) in ALIVE\") \n15 Iterator<T> iterator(); 16 // Continues... 17 } Figure 2. Iterator and collection interfaces annotated \nwith access permission speci.cations. the iterator API correctly, and wants to use the PLURAL modular \ntypestate checker [5] to do so, but does not want to spend time writing speci.cations. In this program, \na Row class acts as an abstraction of a spreadsheet row, and wraps an instance of the Collection class. \nNotably, the createColIter method on line 4 simply returns the result of the collection s iterator method. \nA number of uses of the column iterator in this program are similar to its use in the copy method, line \n12, where the iterator s next method is called in a loop, and only when calls to the hasNext method return \ntrue. However, one use of the column iterator occurs in a test method, testParseCSV on line 22, which \ntests the ability to input data in CSV format. In this use, the next method is immediately called on \niterator returned by the createColIter method (line 25). The reasoning is that, assuming the program \nis implemented correctly, the parseCSVRow method will return a non-empty row for the given inputs. Here, \nlet us concentrate on the speci.cation to be inferred for the return value of the createColIter method \n(line 4). Traditional approaches would have dif.culty inferring speci.cations here be\u00adcause different \nuses of the createColIter method give rise to con.icting constraints. The use of the method on line 25 \nimplies that the returned value must be in the HASNEXT state. At the same time, the existing speci.cation \nof the iterator method in\u00addicates that the iterator is returned in the ALIVE state, and this is consistent \nwith its use in copy and all of the similar uses not shown. A traditional analysis would generate two \nconstraints con\u00adtaining con.icting information, satisfaction of these constraints with a Boolean constraint \nsolver would be impossible, and no spec\u00adi.cation would be produced. In contrast, our approach builds \nlogical constraints on top of probabilities, so that con.icting facts can coexist. ANEK will generate \na constraint at line 25 saying that the return value of createColIter must be in the HASNEXT state with \nhigh prob\u00adability, and will generate constraints at line 5, line 16 and all similar sites saying that \nthe return value must be in the ALIVE state with high probability. The evidence for the HASNEXT state \nis out\u00adweighed by the evidence against it, and the ALIVE abstract state will be chosen for the return \nvalue. Such an inferred speci.cation may cause a typestate checker to issue a warning on line 25. While \nit may seem somewhat strange to infer speci.cations that are only mostly correct, and may indeed lead \nto analysis warnings, in practice [6] some number of false positives are inevitable when analyzing any \nlarge program, and practically-motivated program\u00admers still desire to verify as much of their code as \nis possible. Note 1 class Row { 2 Collection<Integer> entries; 3 4 Iterator<Integer> createColIter() \n{ 5 return entries . iterator (); 6 } 7 void add( int val){...} 8 // Continues ... 9 } 10 11 // Many \nsimilar uses of iterator exist 12 Row copy(Row original) { 13 Iterator <Integer > iter = 14 original \n. createColIter (); 15 Row result = new Row (); 16 while ( iter.hasNext() ) { 17 result .add( iter .next \n()); 18 } 19 } 20 21 @Test 22 void testParseCSV() { 23 Row r1 = parseCSVRow(\"1,2,3,4\"); 24 Row r2 = parseCSVRow(\"4,6,7,8\"); \n25 int sum = r1.createColIter().next() + 26 r2. createColIter ().next (); 27 assert(sum ,5); 28 } Figure \n3. An application using the iterator API for which speci.\u00adcations are needed. also that the PLURAL static \nanalysis is sound, so there are no safety concerns due to the approximative nature of the inference. \nAs a further bene.t, ANEK s system of probabilistic constraints allows us to easily incorporate heuristic \ninformation from a variety of sources, heuristics which can be used to guide the inference pro\u00adcess. \nThis issue is relevant for inferring the speci.cation on the re\u00adturned value of the createColIter method. \nEach call to the next method of the iterator requires a full aliasing permission, as indi\u00adcated by the \nspeci.cation in Figure 2. In the access permissions methodology, this indicates an exclusive modifying \npermission that can coexist with other read-only permissions. However, another permission, unique, which \nindicates an absence of any other ref\u00aderences and is returned by the iterator method of the collec\u00adtion, \nis stronger than full, and can be used to satisfy the precon\u00addition of the next method as well. The question \nbecomes, should the createColIter method be inferred to return a permission of type full or unique, in \nthe absence of any other constraints? ANEK includes the heuristic that all method names beginning with \ncre\u00adate return unique permissions with higher probability, since they are, in practice, often wrappers \nfor constructors. As returned per\u00admissions go, unique is the best choice whenever possible because it \ngives the strongest guarantees to callers. This heuristic applies to the createColIter method, and therefore \nis used to determine that the return permission speci.cation should be unique. In addition to encoding \nheuristics and allowing the generation of speci.cations in the face of con.icting constraints, probabilistic \nconstraints also enable ANEK to perform inference in a modular fashion. One problem with many existing \ninference algorithms is that they lack scalability, since the entire program must be analyzed at once. \nANEK, in contrast, is a modular algorithm that generates method summaries in the form of probabilities \nrepresenting likely method speci.cations, which can then be re.ned as methods are analyzed and reanalyzed \nin an iterative fashion. Since the analysis is approximate, it suf.ces to run the inference algorithm \nfor a .xed number of iterations without reaching a .xpoint (as is usually required by traditional iterative \nalgorithms). Varying the number of iterations allows for a trade-off between speci.cation accuracy and \nscalability.  ANEK infers speci.cations required by the PLURAL modular static typestate checker [3, \n5]; these are method pre and postcondi\u00adtions that describe both the abstract states parameters must inhabit \nand aliasing permissions. The probabilistic constraints encode: (a) logical rules which determine how \npermissions can be used, and (b) heuristic rules which encode the most common or best spec\u00adi.cations \nin various scenarios. These constraints form a model that represents a probabilistic view of the space \nof all possible speci.\u00adcations. A solution to this model results in speci.cations that are very likely. \nThis paper makes the following contributions: We have developed a probabilistic speci.cation inference \nalgo\u00adrithm that combines logical rules (that encode program invari\u00adants) with heuristic rules (that encode \nprogram intuitions) for generating typestate speci.cations that in practice is fast and generates good \nspeci.cations.  The algorithm generates probabilistic method summaries which enable a modular analysis \nthat can scale the inference to large programs.  We have evaluated ANEK on a number of small benchmark \npro\u00adgrams and one large open-source program containing 38,483 lines of code. The results for this large \nbenchmark show that ANEK can quickly infer speci.cations that are both accurate and qualitatively similar \nto those written by hand, and at 5% of the time taken to manually discover and hand-code the speci\u00ad.cation. \nAs a consequence, these programs can be veri.ed by PLURAL automatically, with no user provided speci.cations. \n This paper is organized as follows. Section 2 gives an overview of the problem and also some background \non the PLURAL system. Section 3 de.nes the abstraction and constraint system in ANEK together with the \ninference algorithms. Section 4 describes our em\u00adpirical evaluation of ANEK. And .nally, Sections 5 and \n6 describe the related work and conclusion respectively. 2. Background and Goals The purpose of ANEK \nis to infer typestate speci.cations, which are then fed to PLURAL [3, 5], a static modular typestate \nchecker for Java programs. With PLURAL, programs can be checked for correct protocol usage by examining \none method at a time with\u00adout ever having to reconsider methods previously analyzed (in a manner analogous \nto type-checking in most languages). In PLU-RAL, reference types are supplemented with speci.cations \nthat act as type re.nements. These re.nements are .ow-sensitive, so that they can change at each step \nof the program as objects change state (for example, as a .le might change from open to closed). These \nre.nements are called access permissions. An access permission includes information about the abstract \nstate of an object and a suc\u00adcinct description of which operations any existing aliases to that object \nare permitted to perform. The need for tracking the abstract state of the reference is mostly straightforward. \nAs a program ref\u00aderence transitions through the body of the method, PLURAL keeps track of the abstract \nstate of the object as methods are called and as .elds are read and assigned. When a method is called \nin the method currently under analysis, PLURAL will check the abstract states of each of the arguments \nand make sure they match the re\u00adquired states for each of the parameters to the method, as indicated \nby the method s speci.cation. But a modular checker also needs to know something about how objects might \nbe aliased if it is to perform a sound static analysis. In the absence of any aliasing information, a \nsound modular checker would be forced to conservatively assume that just about every method call may \nmodify the abstract states of all of the objects in the static context through other program references. \nThe aliasing summary contained in each access permission informs the analysis when it can be sure an \nobject is not being modi.ed through other aliases, and when it must assume the object is. Because the \naliasing summaries are checked for consistency, the entire process is sound. The aliasing summaries used \nby PLURAL are called permission kinds, and there are .ve of them. Each permission kind associated with \na reference determines whether or not modi.cation can be performed through that reference, and whether \nor not other aliases, if they exist, can read or modify. The .ve permission kinds are summarized in Figure \n4. Figure 4. The .ve permission kinds. At the point in code where an object is constructed, the new \nreference is associated with a unique permission. From that point forward, new aliases can be introduced \nthrough a process known as splitting. For example, from a reference with unique permission, a new modifying \nalias can be introduced by destroying the original unique permission and creating two new share permissions, \none for the original reference and one for the new reference. Alternatively, a single unique permission \ncould be exchanged for one full per\u00admission and multiple pure permissions. PLURAL makes sure that these \nsplits are done soundly, in a manner that respects the mean\u00ading of each permission introduced. Additionally, \npermissions are associated with fractional values which allow multiple weaker per\u00admissions to be combined \ninto stronger ones in a process known as merging. This feature comes from existing work on fractional \nper\u00admissions [7]. The most common way to use PLURAL is for framework and library designers to annotate \ntheir APIs with access permission speci.cations. API clients can run PLURAL on their code to ensure that \nthey are using the APIs correctly. If API objects are passed as method parameters or stored as .elds \nin a client s program, then she may need to add a speci.cation to her own program in order to inform \nthe analysis what permissions are available. Figure 2 shows a speci.cation for the Iterator interface \nusing access permissions. The next method requires an exclusive modi\u00adfying permission (full) to the receiver \nwhich it returns to the caller. Before the call, the receiver must be in the HASNEXT state. The hasNext \nmethod, which does not need to modify the iterator ob\u00adject, takes a pure permission, which it returns \nto the caller. 2.1 Goals for ANEK While the PLURAL approach is quite powerful, it has one ma\u00adjor drawback; \nit requires programmers to write speci.cations at method boundaries. This has the nice bene.t of enabling \nmodular checking, but places an additional burden on the programmer who merely wants to ensure correct \nprotocol usage. Therefore, ANEK has been designed to eliminate this burden by statically inferring the \naccess permission speci.cations. We envision programmers using ANEK and PLURAL in the following manner: \nFirst, developers of libraries and frameworks would continue to provide PLURAL annotations along with \ntheir APIs. This allows the most knowledgeable developers to build the abstractions speci.c to their \nAPIs, and formally de.ne the ways in which they must be used. Since an API is typically used by many \nclient programs, this effort is amortized over all the users of the API. When a client wishes to use \nan API (annotated with speci.ca\u00adtions), however, they start by running the ANEK inference tool over their \ncode. ANEK will see which API methods are being used and will infer appropriate PLURAL speci.cations \nin the client s code. With the new speci.cations, the programmer will then run PLU-RAL. Since PLURAL \nis a sound checker, if PLURAL passes the re\u00adsulting program with the newly inferred annotations, it constitutes \na guarantee that the programmer is using the API correctly, with little additional burden on the programmer \ns part.  ANEK s inference algorithm is probabilistic. In other words, it solves a number of probabilistic \nconstraints in order to determine what speci.cations are likely to be used (rather than what speci.\u00adcations \nmust be used). We have chosen to develop a probabilistic inference, as opposed to a more traditional, \nlogical inference, for a number of reasons. Probabilistic constraints allow us to easily include heuristics, \nencoding intuitions gleaned from several years of experience writing such speci.cations. The speci.cations \noutput by ANEK are therefore idiomatic, and in some sense are the most desirable speci.cations, rather \nthan being just one of many satis\u00adfying speci.cations. But additionally, even the logical constraints, \nwhich encode basic invariants of access permissions that should al\u00adways hold true, are encoded probabilistically. \nThis allows ANEK to determine a solution even in the face of con.icting constraints, such as when a bug \nexists in the program under inference. Because PLURAL is a sound checker and will be run on the resulting \nspeci\u00ad.cations, there is no danger due to the approximation. On the performance side, there are very \nreal bene.ts to using an approximate approach. First, it can perform better than an exact approach. But \nmore interestingly, such an approach allows us to infer speci.cations in a modular way. This is an important \ngoal for ANEK since it allows inference to scale to larger programs. In the approach, probabilistic speci.cation \nsummaries describing the current most likely speci.cation are placed at method boundaries. These summaries \nare re.ned and made more accurate over time, while still presenting an interface against which method \nbodies are locally inferred. The details of this algorithm are discussed in Section 3.4. 3. The ANEK \nsystem ANEK constructs a probabilistic constraint system that is based on logical and heuristic rules \nfrom an abstraction of the program under analysis. These constraints are solved in a modular fashion \nin order to compute the desired speci.cations. 3.1 Permissions Flow Graph The inference algorithm performs \ninference over an abstraction of the program called the Permissions Flow Graph (PFG). A PFG is a directed \ngraph of the .ow of permissions in each method of a program. Permission .ow itself is identical to a \ndata .ow except for two differences. First, at method call sites and .eld assignments, some amount of \npermission is retained in the calling or assigning context. Second, permission can .ow out of the arguments \nat a method call site after the called method returns, representing the manner in which permission is \nreturned to a calling argument at a call site. These are the only two differences. A PFG Gm for a method \nm is constructed as follows: For each method parameter, including the receiver for instance methods, \ntwo nodes are created. One represents the permission required at the precondition and the other represents \nthe permission returned at the postcondition. The .ow of permission that originates at a parameter precondition \nand is transformed as it passes through a method body is represented using nodes and edges. A control \n.ow graph is constructed in order to determine the .ow of the permission. Additionally, a local must-alias \nanalysis helps us track permission (which fundamentally are related to objects) even if those objects \nare reassigned to other local variables. If a variable is passed as 1 Row copy(Row original) { 2 Iterator \n<Integer > iter = 3 original . createColIter (); 4 Row result = new Row (); 5 while ( iter.hasNext() \n) { 6 result.add( iter.next() ); 7 } 8 } Figure 5. The copy method from Figure 3 whose representation \nis given in Figure 6 Figure 6. The PFG Gcopy generated for the method copy in Fig\u00adure 5. an argument \nto a method, then the graph will contain a directed edge from the previous node in the graph to a node \nrepresenting the precondition of the corresponding method argument and call site. The entire process \nis best explained with an example. Consider the method copy shown in Figure 5. This method gives rise \nto the PFG Gcopy shown in Figure 6. This .gure ignores portions of the graph related to the result variable \nfor simplicity. There are several interesting features worth pointing out. First, note the path of the \npermission relating to the original variable, which appears on the left-hand side of the .gure. This \nshows how methods calls are represented when there is no inter\u00adesting control .ow. The node PRE original \nis generated, which corresponds to the permission available to the original variable at the precondition \nof the copy method. This node is connected to a split node which itself has two successor nodes. The \n.rst successor is a node representing the precondition permission to the receiver of the createColIter \nmethod. The second successor is a permis\u00adsion merge node. The .rst edge represents the permission that \nis passed to the createColIter method, while the second edge rep\u00adresents the permission to the object \nthat is retained by the copy method for the duration of the call. If a permission split is going to occur \nbefore the call, where a strong permission is converted to multiple weaker permissions, such as the case \nwhen a unique per\u00admission is available but only a full permission is needed for a call, it will be manifest \nat this split node. Next, a node representing the permission to the receiver node returned from the createColIter \nmethod is generated. It is important to note that this node has noth\u00ading to do with the return value \nof the createColIter method. It merely represents permission to the receiver that is no longer used by \nthe method. The next node, the merge node, combines permis\u00adsion that was held at the call site with any \npermission returned by the method. Finally, the node POST original represents the per\u00admission available \nto the original object at the end of the method body.  The right-hand side of Figure 6, which represents \nthe permis\u00adsion returned to the return value of the createColIter method, is quite similar. It contains \ntwo method calls whose structure is similar to the call to the createColIter method. However, because \nthis method call occurs in a loop, there are additional edges to account for the possible control .ow \npaths. For example, an edge connect\u00ading the receiver postcondition of the hasNext method and the end \nof the method body exists, and represents the .ow of permission to the iterator when the hasNext method \nreturns false. 1 Object accessFields(C o) { 2 o.f = new Object (); 3 return o.f; 4 }  Figure 7. A permission \ngraph containing .eld accesses and the program from which it was generated. The dotted line represents \nthe reference a .eld access node maintains to its receiver. For each .eld read and each .eld assignment \nin a program, a corresponding node is generated in the permission .ow graph. Field read nodes will be \nconnected via edges to the variables to which they are assigned, and act as permission sources. Field \nassignments act as permission sinks. They never contain outgoing edges, but will have incoming edges \nleading from the nodes from which they are assigned. All instance .eld read and assignment nodes will \nseparately keep track of the receiver node from which they were accessed. In Figure 7, which illustrates \na graph generated from .eld accesses, the relationship with the receiver node is represented as a dotted \nline.  3.2 Random variables and prior probabilities Let Gm =(Vm,Em) be a PFG for a method m with node \nset Vm and edge set Em. We associate each node n . Vm with .ve Bernoulli random variables Xn full, Xn \nshare unique, Xn immutable, Xn and Xn , one for each permission kind. Each variable models pure the probability \nthat such a permission is available at the associated node. The variables are distributed according to \nB(p), a Bernoulli distribution with mean p. If, for instance, Xn unique is distributed according to B(0.1), \nthis means that node n has permission unique with probability 0.1. Additionally, for each abstract state \nin the hierarchy of the type with which the node is associated, we have a random variable associated \nwith that state. For instance, for a node associated with a parameter i where the parameter is an iterator, \nthat node would have three random variables Xi END,Xi HASNEXT ,Xi ALIV E , one for each of its abstract \nstates. Each random variable is given a prior distribution. This prior distribution models our initial \nbelief of how likely a given variable is to be true. For most of the variables ANEK creates, we have \nno information on their respective values (that is, true or false), since we are trying to infer the \nspeci.cations. For that reason, most vari\u00adables are given a prior distribution equal to B(0.5) representing \nthis lack of information. However, if a speci.cation already exists in the source program, this strengthens \nour prior beliefs on how the vari\u00adables are distributed. For example, consider the speci.cation for the \nreceiver parameter shown in Figure 8. Based on this speci.cation, 1 @Perm(requires=\"full(this) in HASNEXT\", \n2 ensures=\"full(this) in ALIVE\") 3 T next () {...} Figure 8. PLURAL speci.cation for the receiver parameter. \nANEK will set the prior distributions for the variables associated with the receiver pre and postcondition \nnodes. For the precondition node, it will set the prior distributions for both the full permission kind \nand the HASNEXT abstract state to the distribution B(0.9) denoting the fact that both the full permission \nand HASNEXT abstract state are high probability events. The remaining variables will be given a low prior \ndistribution of B(0.1). Therefore, the prior distributions for each of the random variables associated \nwith the precondition node are as follows. Random Variable Prior Distribution Xunique B(0.1) Xfull B(0.9) \nXimmutable B(0.1) Xshare B(0.1) Xpure B(0.1) XHASNEXT B(0.9) XEND B(0.1) XALIV E B(0.1) It is important \nto note that even though the speci.cation is given, we still say that the speci.cation permission is \nonly very likely to be true (i.e., true with a probability of 0.9). This allows for the possibility that \nthe original speci.cation was incorrect if the evidence against it (as inferred from the analysis) is \noverwhelming. Analogous to the nodes, each edge e . Em in the PFG is also associated with a similar set \nof random variables {Xke}, where k is either a permission kind or an abstract state. This allows the \ndistribution of one node to in.uence the distributions of adjacent nodes via the corresponding edge, \nas discussed in the next section.  3.3 The probabilistic constraint system Setting the prior probabilities \nfor the random variables in the PFG models our initial beliefs based on known speci.cations. Subse\u00adquently, \nwe add probabilistic constraints over these random vari\u00adables that are based on the features of the program \nitself. These constraints model dependencies that hold among the random vari\u00adables. A solution to the \nconstraints tells us for each node in PFG, which permission kind and which abstract state are most likely \nto be true. We broadly classify all of the constraints that are added as be\u00ading of one of two types, \nlogical constraints or heuristic constraints. Logical constraints encode basic permission rules which \nmust al\u00adways hold, such as those governing sound permission splitting [5]. Heuristic constraints, on \nthe other hand, encode features that are generally true of good PLURAL speci.cations. Importantly, even \nthough the logical rules must always be true in a program veri.ed by PLURAL, ANEK only dictates that \nthey be true with some high probability. It is precisely this feature which allows ANEK to infer speci.cations \neven in the face of buggy programs. In the next two sections, we will present each of the constraint \ngeneration rules in turn. Each constraint generation rule is parametrized by some prob\u00adability hn . [0, \n1] that represents high probability, and is given as input to the algorithm. Parametrization of these \nhigh probabilities allows us to tune the performance of inference.  3.3.1 Logical constraints ANEK encodes \nthe basic logic of access permissions through a series of logical constraints. The logical constraints \nlabeled L1,...,L3 are described below. L1: Outgoing Permissions At every node in the graph, the per\u00admission \nat the node must be related somehow to the permissions on its outgoing edges. If the node only has one \noutgoing edge, this is pretty easy. The edge and the node must have the exact same per\u00admission. So the \nfollowing constraint is applied on the permission and state random variables associated with that node \n(n) and edge (e), with high probability: Xn = Xe kk |h1 (1) k.{unique,full,immutable,share,pure}.states(n) \nHowever, if there are multiple outgoing edges, the story is a little more complicated. Nodes can have \nmultiple outgoing edges for one of two reasons. In some cases, it is because the permission at the node \nis being split into multiple permissions as new aliases are introduced. In other cases, the multiple \nedges are due to control .ow branches in the original program. Since permission splits can only occur \nbefore method calls and .eld reads, we can mark these nodes as such, and apply different rules for splitting \nand control .ow branches. At branches, we apply constraint 1 for each outgoing edge, mandating that the \npermission available at the node is equal to the permission available at each outgoing edge. For permission \nsplits, however, the permission on the outgoing edges generally cannot be identical. There are certain \nways in which an access permission can be soundly split. For example, a unique permission can be split \ninto two share permissions, two immutable permissions or two pure permissions. It cannot, however, be \nsplit into two full permissions or two unique permissions, as those two newly created permissions would \nviolate the assumptions made by one another. Therefore, at each node, constraints are placed on the corresponding \nrandom variables that will enforce sound permission splitting. The (long) series of constraints is as \nfollows: XV ((Xn Xe unique X. e.outgoingV(n) k.{unique,full,imm,share,pure} k ). (Xn Xke). full . Xe.outgoing(n) \nVk.{full,imm,share,pure} (Xn Xke). imm . Xe.outgoing(n) Vk.{imm,share,pure} (Xn Xe share .X e.outgoing(n) \nk.{share,pure} k ). (Xn . Xe )). pure e.outgoing(n) pure XX Xe \u00ac(Xe2 . Xe2 ) Xe.outgoing(n) Xunique \n. e2.outgoing(n)-e unique fullXe = Xn ss |h2 e.outgoing(n) s.states(n) (2) L2: Incoming Permissions When \na node has incoming edges, ANEK also adds constraints on the relationship between the incom\u00ading edge \npermissions and the node permission. Speci.cally, ANEK says that the permission associated with a node \nis equal to one of the permissions on the incoming edges with high probability. The following constraints \nare generated for a node n with incoming edges: VX Xn = Xe e.incoming(n) k.{unique,share,imm,share,pure}.states(n) \nkk |h3 (3) L3: Field Write For any .eld store node (i.e., .eld assignment), the associated receiver node \ncannot be associated with one of the read-only permissions, immutable or pure. This constraint then sets \nthe receiver to be immutable or pure with a very low prob\u00adability. A .eld cannot be modi.ed without writing \npermission to its receiver, so whenever we see a .eld store we know that we have writing permission to \nthe receiver object.  3.3.2 Heuristic Constraints For the random variables generated from a PFG, a series \nof addi\u00adtional heuristic constraints are also added. These constraints cor\u00adrespond to our intuitions \nabout what makes a good PLURAL speci\u00ad.cation. H1: Constructors Constructors generally return unique permis\u00adsion, \nso for the speci.cation for the object created by a constructor, we say that the variable Xunique is \nlikely to be true with elevated probability. This is merely a heuristic since constructors do not have \nto return unique permission. Aliases can be introduced and stored in various data structures before the \nconstructor returns. H2: Pre and Post For a given parameter of a method, the per\u00admission kind, but not \nthe state, of the pre and postcondition nodes are the same with high probability. This is again a heuristic \nas it is possible for methods to retain an input permission and return a different permission. H3: Factory \nMethods Methods whose names begin with the word create usually return a unique permission, much like \na con\u00adstructor. These methods in practice are often static factory methods. Therefore, in our analysis, \nthe return variable from such methods, Xunique, is true with elevated probability. H4: Setter Methods \nMethods whose names begin with the word set generally require a writing permission (i.e., unique, full \nor share) to their receiver, since they are often used to write to re\u00adceiver .elds. Therefore, when encountering \nsuch a method in the PFG, the variables Ximmutable and Xpure for the receiver pre and postcondition are \nconstrained to be true with low probability. H5: Thread-Shared Targets of synchronized blocks are of \nfull, share or pure permission with high probability. This heuristic is based on ideas developed in the \nconcurrent version of the PLURAL analysis [3]. The permissions full, share and pure are the three permission \nkinds that may indicate possible thread-shared objects.  3.4 Probabilistic model and inference In the \nprevious section, we described how logical constraints L1, L2, L3 and heuristic constraints H1, H2, H3, \nH4, H5 can be de\u00adrived from a PFG representation. We will now show how these con\u00adstraints can be looked \nupon as a probabilistic model, in particular, a joint probability distribution describing the whole space \nof spec\u00adi.cations. Let X1,...,Xn be n Bernoulli random variables where for each 1 = i = n, Xi takes values \nfrom the domain {0, 1}. Let p(X1,...,Xn) be a joint probability distribution function over these variables. \nAssociated with p(X1,...,XN ) are n marginal functions pi(Xi), 1 = i = n de.ned as: pi(Xi)= \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7p(X1,...,Xn) \nX1.{0,1} Xi-1.{0,1}Xi+1.{0,1} Xn.{0,1} (4) where the sum is over all variables except Xi. Intuitively, \nthe marginal function pi(Xi = a) corresponds to the probability of the variable Xi taking the value a \n.{0, 1}. Since there are an expo\u00adnential number of terms in the above equation, a na\u00a8ive algorithm for \ncomputing pi(Xi) is not tractable. Suppose that p(X1,...,Xn) can be written as a product of functions, \nwhere each function has some subset of {X1,...,Xn} as its arguments, that is:  p(X1,...,Xn)=fj (Zj \n) (5) j.J where J is a discrete index set, Zj .{X1,...,Xn} and fj (Zj ) is a function having the elements \nof Zj as arguments, with the interval (0, 1] as its range, and the product is the usual pointwise product \nof functions. Given this factorization, there are a number of machine learning techniques that ef.ciently \nestimate the marginal functions by exploiting the fact that every factor is a function of small number \nof variables [14]. In our setting, each of the functions fj (Zj ) in Equation 5 is a probabilistic constraint \nthat describes either a logical constraint or a heuristic constraint as de.ned in Section 3.3. For instance, \ncon\u00adsider the conjunct Xn = |h1 in Equation 1 (logical Xe share share constraint L1). This can be encoded \nas a probabilistic constraint as follows. f(Xn share,Xe share)= if (Xn = Xe h1 share share) (6)1 - h1 \notherwise The pointwise product of such probabilistic constraints represents the probability space over \nspeci.cations. The speci.cations are computed by sampling the marginal functions (de.ned by Equa\u00adtion \n4) for the joint probability distribution. The problem of infer\u00adring speci.cations can be formally de.ned \nas follows: De.nition 1. Let P be a program de.ned by a set of methods M, and let .m be the probabilistic \nmodel for a method m . M de.ned as follows. . . .m = Gm \u00b7 . PARAMARG(c). c.CALLSITES(m) where Gm denotes \nthe pointwise product of the logical and heuris\u00adtic constraints associated with method m, and PARAMARG(c) \nde\u00ad.nes a set of equality constraints that bind the method m s param\u00adeters to their respective arguments \nat a call site c. The probabilistic model .P for the program P is the product of the probabilistic models \nfor all its methods and de.ned as. .P = .m m.M Then, we are interested in computing marginal functions \nfor the probabilistic model .P . It is important to note that the speci.cations for the program can be \neasily derived from the marginal functions of .P via sampling. These marginal functions can be computed \nby using an off-the\u00adshelf machine learning algorithm. However, a serious drawback of such an approach \nis that it would not be modular, thus severely limiting scalability. We propose an inference procedure \nANEK-INFER that is a mod\u00adular analysis (shown in Figure 9). The set of all methods M in the program under \nanalysis is the input to this procedure. Xm is the set of all random variables for a method m as de.ned \nin Section 3.2. We denote the PFG for method m by Gm. The probabilistic con\u00adstraints system Gm is as \nde.ned in De.nition 1. In line 1, a worklist W of probabilistic models is initialized to the empty list. \nNext, in lines 2 6, for every method m: (a) The random variables in Xm are initialized (described in \nSec\u00adtion 3.2). (b) A probabilistic constraint system Gm is created by the proce\u00addure Model(Gm).  procedure \nANEK-INFER input: M: Set of all methods in the program vars: Xm: Set of all random variables for method \nm Gm: PFG for method m Gm: Probabilistic constraints for method m W : Worklist of probabilistic models \npm: Probabilistic summary for method m sm: A deterministic summary for method m output: s: Speci.cation \nthat maps every method to its deterministic summary 1: W := \u00d8 2: for each m . M do 3: INIT(Xm) 4: Gm \n:= MODEL(Gm) 5: W := W .{Gm} 6: end for 7: count := 0 8: while count = MaxIters do 9: count := count \n+1 10: Gm := CHOOSE(W ) 11: W := W \\{Gm} 12: for each c . CALLSITES(m) do 13: APPLYSUMMARY(Gm, pc)) 14: \nend for X old 15: := Xm m 16: Xm := SOLVE(Gm) = X old 17: if Xm m then 18: UPDATESUMMARY(pm, Xm) 19: \nW := W .{Gm} 20: end if 21: end while 22: for each m . M do 23: for each X . pm do 24: if p(X = true) \n>t then 25: sm(X) := true 26: end if 27: end for 28: s(m) := sm 29: end for 30: return s Figure 9. The \nannotation inference algorithm ANEK-INFER. (c) The worklist W is initialized to a list of probabilistic \nmodels for methods. ANEK-INFER is an iterative algorithm (lines 8 21). In lines 10 and 11, a model Gm \nfor method m is picked from the worklist W by the choice function CHOOSE(W ) and removed from W . In \nlines 12 14, for every call site corresponding to a method c,a probabilistic summary pc for that method \nis applied to the model Gm (where method m calls method c). A probabilistic summary pc for method c is \nthe set of all random variables associated with the precondition and postcondition nodes in its PFG Gc. \nDue to the initialization in line 3, all probabilistic summaries for methods are also appropriately initialized. \nA probabilistic summary maintains the current values of the random variables corresponding to the precondition \nand postcondition nodes for a method. The procedure Solve called in line 16 takes Gm as input and computes \napproximate marginal functions3 for the variables Xm. We use an off-the-shelf machine learning algorithm \nto ef.ciently implement Solve. If the distributions associated with the random variables in Xm have changed, \nthen the summary pm for method m is updated via the procedure UPDATESUMMARY (line 18) and the model Gm \nis added to the worklist W (line 19). It is important to note that summaries are computed by analyzing \neach method once at a time and it is via these summaries that analysis information is disseminated across \nmethods. This makes the ANEK-INFER algorithm a modular analysis.  The loop (8 21) is run MaxIters number \nof times (as opposed to computing a .xpoint) which is another source of approxima\u00adtion. Lines 22 27 compute \nthe speci.cation from the probabilis\u00adtic summaries for each procedure. If for each random variable X \nin the probabilistic summary pm for a method m, the probability p(X = true) is greater than a user-de.ned \nthreshold t . [0.5, 1), then the deterministic value of that variable is set to true and this information \nis stored in a map sm. This deterministic summary s for all methods forms the speci.cation that is returned \nby ANEK-INFER. It is interesting to note that the result computed by ANEK-INFER(M) at a .xpoint (corresponding \nto an exact computation) is identical to the result computed by SOLVE(.P ). 4. Evaluation In this section, \nwe describe our implementation and report the empiricalresultsofrunningthecombinationof ANEK and PLURAL \non a number of Java benchmark programs. All experiments were performed on a system with a 3.19 GHz Intel \nPentium 4 processor and 2 GB RAM running Microsoft Windows XP. 4.1 The ANEK Implementation The architecture \nof ANEK is shown in Figure 10. Each component of ANEK is organized into a pipeline. The .rst component, \nthe Eclipse Extractor, is a plugin to the Eclipse Java Development Tools (JDT), the Java IDE in Eclipse. \nIts job is to visit the Java AST generated by JDT for the program under inference and generate the abstract \nrepresentation. This representation is stored to disk in an intermediate, XML-based format. This component \nis also responsible for the user interface, the menus and action items in 3 Since we are only interested \nin estimating the likely values of the random variables and not their exact distributions, computing \napproximate marginal functions suf.ces for our purpose. Eclipse that allow users of PLURAL to run inference \nwithout ever leaving their IDE. Once ANEK has generated an XML representation of the pro\u00adgram, this representation \nis handed off to an F# program4. It be\u00adgins by generating a number of constraints based on the shape \nof the program (Deterministic Constraint Generator). These are the constraints described in Section 3.3. \nHowever, at this phase each of the constraints is deterministic; there are no probabilities involved. \nIt is in the next component, the Probabilistic Constraint Gen\u00aderator, that the deterministic constraints \nare transformed into prob\u00adabilistic ones and the ANEK-INFER algorithm is invoked. ANEK-INFER is implemented \nusing INFER.NET [16], a library that ex\u00adposes a number of abstractions, in the form of types and methods, \nwhich allow networks of probabilistic variables and constraints to be assembled and solved. If the most \nlikely permission kind and abstract state, as determined by ANEK-INFER, is greater than some threshold \nvalue, then a generated graph representation will contain this newly inferred speci.cation. Finally, \nin the last component, the newly generated representa\u00adtion is applied to the original Java program inside \nanother Eclipse plugin called the Eclipse Applier. This program walks through the AST of the original \nJava program and applies the new speci.cation.  4.2 Experiments In order to evaluate the utility of \nANEK, we performed a number of small experiments and one main experiment. The goal was to see if ANEK \nwould infer annotations that were correct and would not lead to a large number of false warnings when \nrunning the PLURAL tool. First, we developed a number of test benchmarks. Each of these benchmarks consisted \nof one or more classes, with one or more methods, some of which were annotated by us before running the \nANEK tool. Each experiment was designed to test some particular ANEK constraint or feature. During the \nexperiments we would run ANEK on the test suite, and ensure that correct annotations were in\u00adferred, \nand that after inference PLURAL would report no warnings. At issue is the evolution of ANEK in response \nto newly perceived problems. One of the great bene.ts of ANEK s architecture is that it is so easy to \nevolve it by adding new constraints. Over the course of its implementation we added new constraints or \nmodi.ed exist\u00ading constraints numerous times. However, we wanted to ensure that the new constraints, \nwhich may .x one particular problem, did not come at the expense of any previously-correct behavior. \nTherefore, our small experiment suite formed a regression suite of sorts and also as a training set to \n.ne-tune the parameters of the inference engine. Our primary experiment, though, was to use ANEK to infer \nannotations for the PMD static analysis framework (Table 1). In this experiment, the Java Iterator API \nwas annotated and then ANEK was used to infer annotations within the PMD application, which makes extensive \nuse of the API. PMD Lines of Source: 38,483 Number of Classes: 463 Number of Methods: 3,120 Calls to \nIterator.next(): 170 Table 1. Simple statistics for the PMD application. Speci.cally, PMD was used as \nthe client-side case study in Kevin Bierhoff s doctoral thesis [4]. In his experiment, Bierhoff took \nan annotated Iterator API, ran PLURAL on PMD, and added 4 http://research.microsoft.com/fsharp/fsharp.aspx \n appropriate annotations by hand to the program until there were as few remaining warnings as possible. \nOur goal was essentially to replicate this experiment by using ANEK instead of doing any speci.cation \nby hand. Method Annotations Warnings Time Taken Original 0 45 0 Bierho. 26 3 75min [4] Anek 31 4 3min \n47sec Anek Logical N/A N/A DNF Table 2. The results of running ANEK on PMD. Table 1 contains a number \nof basic statistics for the PMD ap\u00adplication. Of particular note is the number of calls to the method, \njava.util.Iterator.next. This is important because the next method is the most important for veri.cation \npurposes. It is the only method on the Iterator interface that requires the iterator instance to be in \na particular state when called. Table 2 shows the results of our experiments. We ran several experiments \nand recorded three statistics for each one. The .rst con.guration is Original, where we ran PLURAL on \nPMD with no annotations at all, in its original form. The point of this experiment is just to show that \nsome annotations must be inferred in the ap\u00adplication in order to verify correct use of the Iterator \nAPI. To that end, PLURAL reported 45 warnings when run on the unannotated program. The next con.guration, \nBierho., is PMD as annotated by Bierhoff for his thesis work. Manual annotation took 75 minutes as reported \nin [4]. PLURAL reported three warnings, all of which were false positives. In these three cases, the \nnext is called on an iterator without .rst calling the hasNext method to establish dynamically that the \niterator has subsequent elements. In all three cases, other program invariants not expressed in PLURAL \nguarantee that the call to next will not fail at run-time because the underlying collection is known \nto be non-empty. In fact, these cases were quite similar to, and the insipration for the testParseCSV \nmethod from Figure 3. The next experiment uses ANEK to infer annotations on PMD. The Anek con.guration \nis the standard con.guration. When run\u00adning PLURAL onPMDwiththeannotationsinferredby ANEK,four warnings \nare generated, and the inference process takes 3 minutes and 47 seconds. Of the four warnings, three \nare exactly the same warnings issued by PLURAL as in the Bierho. con.guration. The fourth warning, which \nis also a false-positive, can be attributed to a lack of branch-sensitivity. While the PLURAL static \nanalysis takes the result of conditional expressions into account, ANEK currently does not, and therefore \ncannot infer the correct speci.cation for a method that is only called in true branches of a conditional. \nAs is evident from the experiments, ANEK performs as well as with hand-coded annotations, and at approximately \n5% of the elapsed time and with no human involvement. Finally, in addition to comparing ANEK to manual \nannotation, we wanted to compare it to a more traditional speci.cation infer\u00adence approach, speci.cally, \napproaches that are built on top of log\u00adical constraint solvers. While such an inference tool currently \ndoes not exist for PLURAL, two experiments were performed in an at\u00adtempt to understand how such tools \nmight perform. First, we modi.ed ANEK to add an additional Logical mode. In this con.guration only logical \nconstraints are considered and solved deterministically, while all heuristic constraints are turned off. \nIn this experiment, Anek Logical was run on PMD in an attempt to infer speci.cations. When this was done, \nthe inference procedure ran out of memory before a .xed point was reached, and therefore no results could \nbe presented. Our second attempt to compare ANEK to a traditional infer\u00adence algorithm relies on PLURAL \ns own local permission inference. Inference Tool Time Taken Warnings ANEK 22 sec 0 Plural Local Inference \n181 sec 0 Table 3. The results of running ANEK on a test program to com\u00adpare performance again Plural \ns local inference While PLURAL requires annotations on method boundaries it uses a local permission inference \nso that programmers do not have to write annotations on local variables. This analysis is responsible \nfor determining which fractions of permissions are consumed and returned by different parts of a method \nbody, for .nding a satisfying assignment for all of the various permission constraints imposed by all \nof the called methods and returned permissions. The underlying algorithm relies upon Gaussian Elimination \nto .nd satisfying frac\u00adtional permission assignments [4, ch. 5]. The overall approach is comparable to \nother similar fractional inference algorithms [19]. In order to use PLURAL s local inference as a point \nof comparison, we took a small test program crafted for this experiment which con\u00adtained numerous short \nmethods and ran ANEK on it to infer method speci.cations. Then, in a second run, we inlined each method \nso that the resulting program consists of one single large method and ran PLURAL on this program. Both \ninference tools end up doing the same work, since by solving permission constraints for the en\u00adtire large \nmethod body, PLURAL is essentially inferring which per\u00admissions must be available at the same points \nas ANEK. Table 3 shows the results for this experiment. The program under inference is small (400 lines) \nbut contains numerous control .ow branches. ANEK performed well, doing the same inference task in roughly \none ninth of the time.  4.3 Discussion In this section, we will discuss the results of our experiment \nand their rami.cations. Overall, we were quite pleased with the results of the experiment. In approximately \n5% of the time it took to an\u00adnotate the program by hand, ANEK was able to infer speci.cations that were \nalmost as good, and with no human involvement. Specif\u00adically, the speci.cations inferred by ANEK lead \nto four warnings when the PLURAL tool was subsequently run on the result, versus three warnings from \nhand-written speci.cations. This difference of one warning is entirely due to ANEK s lack of path-sensitivity \nin its inference scheme, a feature PLURAL itself supports. Precision\u00adwise, ANEK does a very good job \nwith the annotations it infers. Moreover, when compared with other PLURAL case studies where annotations \nwere applied manually [6], the PMD case study went very quickly. Often it takes several hours to manually \nannotate a code base, so we expect to see even bigger time savings on future experiments. While our experiments \ncomparing ANEK to logical inference tools were somewhat rough, they suggest that ANEK can outper\u00adform \ntraditional-style inference tools. We largely attribute this to the use of approximation algorithms for \nprobabilistic constraint solving. We also claimed that our approach is a good idea because proba\u00adbilistic \npermissions enable reasoning in the face of con.icting con\u00adstraints. This feature was needed for our \nPMD experiment because of the three locations in which the next method was called with\u00adout a proceeding \ncall to hasNext. Just as in the example presented in the introduction, the con.icting constraints introduced \nby such calls were tolerated, and satisfactory speci.cations were still in\u00adferred rather than ANEK giving \nup. Given that the remaining 167 calls to the next() method were correctly veri.ed by PLURAL, the resulting \nspeci.cations are still quite useful to programmers.  Description Count Same ANEK Added Helpful Spec. \nANEK Added Constraining Spec. ANEK Removed Spec. ANEK Changed Spec., More Restrictive ANEK Changed Spec., \nWrong 14 6 1 3 6 3 Table 4. Comparison of by-hand annotations with Anek The quality of the speci.cations \ninferred by ANEK is generally good. Table 4 summarizes the annotations inferred. Speci.cally, these numbers \nare for the speci.cations inferred by ANEK with re\u00adspect to the hand-speci.ed version (Bierho.). 14 of \nthe speci.ca\u00adtions were exactly the same. ANEK inferred 6 speci.cations that were correct, potentially \nuseful in future versions of the application and imposed no additional proof burden. In one case ANEK \nadded a speci.cation that was not necessary and may, in the future, cause additional proof burdens. In \n3 cases, ANEK did not infer a speci.\u00adcation that was present in the hand-speci.ed version. All three \nof these were related to dynamic state test methods, which ANEK cur\u00adrently does not attempt to infer. \nThe removed speci.cations were immaterial because at all use sites, a super-type speci.cation took precedence. \nIn 6 places, ANEK changed an existing speci.cation to make it more restrictive, which, while not causing \nany additional errors now, may lead to additional proof burdens in future versions of the application. \nFinally, 3 speci.cations were wrong outright. One of these incorrect speci.cations led to the additional \nwarning. The other two did not affect veri.cation at all. One nice bene.t of creating an analysis based \non probabilistic constraints is the ease of design. It turned out to be quite easy to add new constraints. \nAs we went through our design iterations, we started with a basic suite of probabilistic constraints \nthat we thought would yield good results. However, on some of our small bench\u00admarks, we found that for \none reason or another these constraints were not quite yielding the expected results. Fortunately, it \nis quite easy to add new constraints. So, as we realized that one constraint was overly speci.c, or that \nanother, say, did not work in all situa\u00adtions, it was trivial to add a new constraint so that the results \nwould be more to our liking. 5. Related work Our work is related to MERLIN [15], a tool based on probabilistic \nanalysis for inferring security annotations useful for detecting in\u00adformation .ow vulnerabilities. In \ngeneral, the speci.cations ANEK infers are much more detailed and intricate behavioral properties than \nthose inferred by MERLIN. Furthermore, ANEK introduces a general framework that is based on the philosophy \nof combin\u00ading logical rules with heuristic rules. As such, ANEK must know much more about the details \nof each function s behavior. In con\u00adtrast, MERLIN s annotation inference is based on how functions are \nused in the implementation and does not rely on the function s actual behavior. Moreover, the inference \nin MERLIN is not modu\u00adlar and this limits its scalability. Additionally, with ANEK, we have the nice \nfeature that after speci.cations are inferred, a sound static analysis can be run, verifying the results \nof the inference and acting as a safety net. For MERLIN, such a tool was unavailable. Kremenek et al. \n[13] propose a technique for inferring owner\u00adship annotations that is also based on a probabilistic analysis. \nLike MERLIN, this analysis also infers less expressive speci.cation and is not modular. Dietl [9] developed \na global analysis for inferring Universe Type annotations using a SAT solver. Besides the fact that we \nare inferring typestate annotations, the primary difference between this work and ours is that it requires \nsatis.ability. If a program has bugs and therefore has no valid ownership type, the inference will fail \nwithunsatis.ableconstraints.Ontheotherhand, ANEK willalways produce the best possible speci.cation. Terauchi \n[19] proposed a global analysis for inferring fractional permissions in order to verify a lack of race \nconditions. While the methodology itself solves a problem that might be useful in our work, their underlying \nmethodology is much different, since they do not use probabilistic constraints. Presumably such an analysis \nwould have to give up when confronted with false positives of the sort we encountered in our case study. \nHoudini [10] is an annotation inference engine for the ESC/Java tool [12]. It .rst heuristically generates \na number of candidate annotations or invariants and subsequently, incorrect annotations are pruned away \nby invoking ESC/Java. This is similar to the manner in which the speci.cations inferred by ANEK are checked \nby PLURAL in order to ensure soundness of veri.cation. An important line of work has addressed the related \nbut dif\u00adferent problem of protocol inference. Such approaches have used static [1, 17, 20] and dynamic \n[21, 22] analysis to determine which classes in a program place restrictions on the ordering of their \nmethod calls, and attempt to infer a speci.cation for their correct usage. The dynamic approaches generally \nuse statistical methods to determine which sequences of method calls represent protocols, and which are \nmerely due to coincidence. While the problem of in\u00adferring protocols is different from the problem of \ninferring aliasing annotations, these approaches clearly complement our own, and in the future we plan \nto investigate their combination. 6. Conclusion In this paper we presented ANEK, a probabilistic speci.cation \ninference tool that can be used to infer access permissions for use in modular typestate checking. ANEK \nis novel in that it is modular and is built using probabilistic constraints. These constraints allow \nus as developers to easily encode into the analysis our understanding of what makes a good speci.cation. \nProbabilistic constraints also make ANEK robust to bugs in the program under inference and enable a modular \nanalysis. In order to evaluate our approach, we used ANEK to infer speci.cations for PMD, mimicking a \ncase study that was performed by Bierhoff [4] by hand as part of his Ph.D. thesis. The results were good \n in fact, the speci.cations inferred by ANEK were nearly as good as those written by hand and were obtained \nin approximately 5% of the time it took to manually discover them. Acknowledgments We thank G. Ramalingam \nfor suggesting the idea of classify\u00ading ANEK s constraints as logical and heuristic constraints. We also \nthank Jonathan Aldrich, Akash Lal and Sriram Rajamani for their invaluable comments. Thanks are also \ndue to John Winn for help with using the INFER.NET API. The .rst author was supported by several grants \nincluding DARPA grant #HR0011\u00ad0710019, NSF grant CCF-0811592, R&#38;D Project Aeminium CMU-PT/SE/0038/2008 \nin the CMUPortugal program, Army Re\u00adsearch Of.ce grant #DAAD19-02-1-0389 entitled Perpetually Available \nand Secure Information Systems, the Department of Defense, the Software Industry Center at CMU and its \nsponsors, especially the Alfred P. Sloan Foundation and a National Science Foundation Graduate Research \nFellowship (DGE-0234630).  References [1] R. Alur, P. .y, P. Madhusudan, and W. Nam. Synthesis of interface \nCern\u00b4speci.cations for java classes. In POPL 05: Principles of Program\u00adming Languages, pages 98 109, \n2005. [2] M. Barnett and K. R. M. Leino. Weakest-precondition of unstructured programs. In PASTE 05: \nProgram Analysis For Software Tools and Engineering, pages 82 87, 2005. [3] N. E. Beckman, K. Bierhoff, \nand J. Aldrich. Verifying correct usage of atomic blocks and typestate. In OOPSLA 08: Object Oriented \nProgramming Systems, Languages, and Applications, pages 227 244, 2007. [4] K. Bierhoff. API Protocol \nCompliance in Object-Oriented Software. PhD thesis, Carnegie Mellon University, April 2009. [5] K. Bierhoff \nand J. Aldrich. Modular typestate checking of aliased objects. In OOPSLA 07: Object Oriented Programming \nSystems, Languages and Applications, pages 301 320, 2007. [6] K. Bierhoff, N. E. Beckman, and J. Aldrich. \nPractical API protocol checking with access permissions. In ECOOP 09: European Confer\u00adence on Object-Oriented \nProgramming, pages 195 219, July 2009. [7] J. Boyland. Checking interference with fractional permissions. \nIn SAS 03: Static Analysis Symposium, pages 55 72. Springer, 2003. [8] J. Condit, B. Hackett, S. K. Lahiri, \nand S. Qadeer. Unifying type checking and property checking for low-level code. In POPL 09: Principles \nof Programming Languages, pages 302 314, 2009. [9] W. Dietl. Universe Types: Topology, Encapsulation, \nGenericity, and Tools. PhD thesis, ETH Zurich, December 2009. [10] C. Flanagan and K. R. M. Leino. Houdini, \nan annotation assistant for ESC/Java. In FME 01: International Symposium of Formal Methods Europe, pages \n500 517, 2001. [11] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, and R. Stata. \nExtended static checking for java. In PLDI 02: Programming Language Design and Implementation, pages \n234 245, 2002. [12] C. Flanagan, K. R. M. Leino, M. Lillibridge, G. Nelson, J. B. Saxe, and R. Stata. \nExtended static checking for Java. In PLDI 02: Programming Language Design and Implementation, pages \n234 245, 2002. [13] T. Kremenek, P. Twohey, G. Back, A. Ng, and D. Engler. From uncertainty to belief: \nInferring the speci.cation within. In OSDI 06: Operating Systems Design and Implementation, pages 161 \n176, 2006. [14] F. R. Kschischang, B. J. Frey, and H. A. Loeliger. Factor graphs and the sum-product \nalgorithm. IEEE Transactions on Information Theory, 2(47):498 519, 2001. [15] B. Livshits, A. V. Nori, \nS. K. Rajamani, and A. Banerjee. Merlin: speci.cation inference for explicit information .ow problems. \nIn PLDI 09: Programming Language Design and Implementation, pages 75 86, 2009. [16] T. Minka, J. Winn, \nJ. Guiver, and D. Knowles. In-fer.NET 2.4, 2010. Microsoft Research Cambridge. http://research.microsoft.com/infernet. \n[17] M. K. Ramanathan, A. Grama, and S. Jagannathan. Static speci.ca\u00adtion inference using predicate mining. \nIn PLDI 07: Programming Language Design and Implementation, pages 123 134, 2007. [18] R. E. Strom and \nS. Yemini. Typestate: A programming language concept for enhancing software reliability. IEEE Trans. \nSoftw. Eng., 12(1):157 171, 1986. [19] T. Terauchi. Checking race freedom via linear programming. In \nPLDI 08: Programming Language Design and Implementation, pages 1 10, 2008. [20] J. Whaley, , M. C. Martin, \n, and M. S. Lam. Automatic extraction of object-oriented component interfaces. In ISSTA 02: International \nSymposium on Software Testing and Analysis, pages 218 228, 2002. [21] J. Yang, D. Evans, D. Bhardwaj, \nT. Bhat, and M. Das. Perracotta: Mining temporal API rules from imperfect traces. In ICSE 06: International \nConference on Software engineering, pages 282 291, 2006. [22] H. Zhong, T. Xie, L. Zhang, J. Pei, and \nH. Mei. MAPO: Mining and recommending API usage patterns. In ECOOP 09: European Conference on Object-Oriented \nProgramming, pages 318 343, 2009.   \n\t\t\t", "proc_id": "1993498", "abstract": "<p>Static analysis tools aim to find bugs in software that correspond to violations of specifications. Unfortunately, for large and complex software, these specifications are usually either unavailable or sophisticated, and hard to write.</p> <p>This paper presents ANEK, a tool and accompanying methodology for inferring specifications useful for modular typestate checking of programs. In particular, these specifications consist of pre and postconditions along with aliasing annotations known as access permissions. A novel feature of ANEK is that it can generate program specifications even when the code under analysis gives rise to conflicting constraints, a situation that typically occurs when there are bugs. The design of ANEK also makes it easy to add heuristic constraints that encode intuitions gleaned from several years of experience writing such specifications, and this allows it to infer specifications that are better in a subjective sense. The ANEK algorithm is based on a modular analysis that makes it fast and scalable, while producing reliable specifications. All of these features are enabled by its underlying probabilistic analysis that produces specifications that are very <i>likely</i>.</p> <p>Our implementation of ANEK infers access permissions specifications used by the PLURAL [5] modular typestate checker for Java programs. We have run ANEK on a number of Java benchmark programs, including one large open-source program(approximately 38K lines of code), to infer specifications that were then checked using PLURAL. The results for the large benchmark show that ANEK can quickly infer specifications that are both accurate and qualitatively similar to those written by hand, and at 5% of the time taken to manually discover and hand-code the specifications.</p>", "authors": [{"name": "Nels E. Beckman", "author_profile_id": "81363604007", "affiliation": "Carnegie Mellon University, Pittsburgh, PA, USA", "person_id": "P2690545", "email_address": "nbeckman@cs.cmu.edu", "orcid_id": ""}, {"name": "Aditya V. Nori", "author_profile_id": "81320493380", "affiliation": "Microsoft Research India, Bangalore, India", "person_id": "P2690546", "email_address": "adityan@microsoft.com", "orcid_id": ""}], "doi_number": "10.1145/1993498.1993524", "year": "2011", "article_id": "1993524", "conference": "PLDI", "title": "Probabilistic, modular and scalable inference of typestate specifications", "url": "http://dl.acm.org/citation.cfm?id=1993524"}