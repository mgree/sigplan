{"article_publication_date": "01-15-2003", "fulltext": "\n Pure Patterns Type Systems Gilles Barthe and Horatiu Cirstea and Claude Kirchner and Luigi Liquori LORIA, \nINRIA &#38; University Nancy II: 54506 Vandoeuvre-l`es-Nancy BP 239 Cedex France INRIA: 06902 Sophia \nAntipolis BP 93 Cedex France [Gilles.Barthe,Horatiu.Cirstea,Claude.Kirchner,Luigi.Liquori]@inria.fr ABSTRACT \nWe introduce a new framework of algebraic pure type sys\u00adtems in which we consider rewrite rules as lambda \nterms with patterns and rewrite rule application as abstraction ap\u00adplication with built-in matching facilities. \nThis framework, that we call Pure Pattern Type Systems ,is particularly well-suited for the foundations \nof programming (meta)lan\u00adguages and proof assistants since it provides in a fully uni.ed setting higher-order \ncapabilities and pattern matching abil\u00adity together with powerful type systems. We prove some standard \nproperties like con.uence and subject reduction for the case of a syntactic theory and under a syntactical \nre\u00adstriction over the shape of patterns. We also conjecture the strong normalization of typable terms. \nThis work should be seen as a contribution to a formal connection between logics and rewriting, and a \nstep towards new proof engines based on the Curry-Howard isomorphism.  Categories and Subject Descriptors \nD.3.1 [Formal De.nitions and Theory]: [Syntax, Se\u00admantics]; D.3.2 [Language Classi.cations]: [Applicative \n(functional) languages, Constraint and logic languages]; F.4.1 [Mathematical Logic]: [Lambda calculus \nand re\u00adlated systems, Logic and constraint programming, Mechan\u00adical theorem proving] 1. INTRODUCTION \n.-calculus and term rewriting provide two fundamental computational paradigms that had a deep in.uence \non the development of programming and speci.cation languages, and on proof environments. Starting from \nKlop s ground\u00adbreaking work on higher-order rewriting [19], and because of their complementarity, many \nframeworks have been de\u00adsigned with a view to integrate these two formalisms. This integration has been \nhandled either by enriching .rst\u00adorder rewriting with higher-order capabilities or by adding to .-calculus \nalgebraic features. In the .rst case, we .nd Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 03, January 15 17, 2003, New Orleans, Louisiana, USA. Copyright \n2003 ACM 1-58113-628-5/03/0001 ...$5.00. the works on CRS [20] and other higher-order rewriting sys\u00adtems \n[30, 23], in the second case the works on combination of .-calculus with term rewriting [2, 7, 12, 17] \nto mention only a few. In some works, the .-calculus has been extended with pat\u00adtern abstractions that \ngeneralize .-abstractions by binding structured expressions instead of variables. Such pattern ab\u00adstractions \nare commonly used to compile case-expressions in functional programming languages [24] and to provide \nterm calculi for sequent calculi [18]. For example, the pattern abstractions .0.0and .succ(N).N are used \nto compile the predecessor function. In other works, like those on higher-order rewriting sys\u00adtems, such \npattern abstractions are extended to generalized abstractions by binding arbitrary expressions instead \nof pat\u00adterns. Apart their expressive power, generalized abstrac\u00adtions correspond to a form of higher-order \nnatural deduc\u00adtion, where (parts of) proof trees are discharged instead of assumptions. Although such \nextended abstractions are a .rmly groun\u00added artifact both in logic and in programming language design \nand implementation, they lack established founda\u00adtions. As a .rst step towards these foundations, we \nprovide a framework for studying (type systems for) extended ab\u00adstractions. Concretely, we start from \na term calculus with generalized abstractions, which provides a very rich compu\u00adtational model that goes \nfar beyond .-calculus, and endorse it with a parameterized type system as in Pure Type Sys\u00adtems. Pure \nType Systems (PTS) [4, 15] provide a concise and unifying view of many typed .-calculi and logics that \noccur in the literature, and o.er a generic framework for the study of typed .-calculi `Pure Type Systems \nhave alaChurch. a well-understood theory and enjoy good meta-theoretical properties, and hence o.er an \nappealing setting in which to specify the kernel of functional programming languages, see e.g. [1, 6, \n25, 28], and proof assistants based on the Curry-Howard isomorphism, see e.g. [4, 5]. In PurePatternType \nSystems (P2TS), the framework pre\u00adsented here, the usual .-abstraction of Pure Type Systems .X:A.B of \ntype .X:A.C is replaced by a generalized ab\u00adstraction .A:..B of type .A:..C,where A is an arbitrary term \n(in jargon a pattern) and . is a context in which are declared the bound variables of .A:..B. Adding \npatterns to PTSs may seem innocuous. However, de.ning a conservative extension of PTSs that provides \nsup\u00adport for patterns and enjoys basic meta-theoretical prop\u00aderties, like con.uence and subject reduction, \nturns out to be a laborious task. Indeed, both properties fail, even in a simply-typed setting, when \nno restrictions are imposed on the term formation nor on the reduction strategy, see Ex\u00adamples 4 and \n5. For con.uence, the problem was already remarked in [29], where con.uence is recovered by imposing \na so-called Rigid Pattern Condition on patterns. Such a condition is directly 2 applicable to PTSs, but \nrequires patterns to be linear. Lin\u00adearity of patterns is an overly strong assumption in an ex\u00adplicitly \ntyped language with polymorphism and dependent types. Indeed, many polymorphic functions, e.g. the func\u00adtion \n.cons(TX nil(T)):..X that returns the only element of a one-element list, involve non-linear patterns. \nHence van Oostrom s condition must be relaxed so that non-linear patterns are allowed. This is the .rst \nmajor hurdle with extending PTSsto P2TSs. Another problem is caused by the necessity to allow for free \nvariables in the pattern of an abstraction. For example, .cons(TX nil(T)):..X should be of type list(T) \nr T,and should have T as free variable. In order for reduction to be closed under substitution, and for \ntyping to be closed under substitution and reduction, we must therefore allow for pat\u00adterns that are \nnot in normal form and allow for reduction in patterns. Furthermore, matching should be modi.ed so that \nthe free variables of a pattern whose types are not de.ned in the context are considered as free in the \ncorresponding abstractions and handled as constants by the matching al\u00adgorithm. This is the second major \nhurdle with extending 2 PTSsto PTSs. Therefore, the main contributions of this paper are: to provide \nadequate notions of patterns, substitutions and matching that overcome the afore-mentioned hur\u00addles. \nOne technical tool used for this purpose is the no\u00adtion of delayed matching constraint, see Section 2, \nand the possibility for patterns in abstractions to evolve (by reduction or substitution) during execution; \non the basis of these de.nitions, to propose a well\u00adbehaved extension of PTSs that supports abstraction \nover patterns, and that enjoys many fundamental prop\u00aderties of PTSs, including con.uence, subject reduction, \nconservativity over PTSs and consistency for normal\u00adizing P2TSs. The remaining of the paper is organized \nas follows: Sec\u00adtion 2 presents the syntax of P2TS and related notions such as free variables and substitutions. \nMatching systems are also introduced together with a (syntactic) matching algo\u00adrithm. The dynamic semantics \nof P2TS and some examples of reductions are given in Section 3. The typing rules are presented in Section \n4 and exempli.ed by two type deriva\u00adtions. The meta-theory including some properties of the matching \nalgorithm, the conditions ensuring the con.uence and the preservation of types, as well as some other \nclassi\u00adcal type-related properties are stated and discussed in Sec\u00adtion 5. Finally, we conclude by conjecturing \nsome properties of (possible extensions of) P2TS and give some perspectives to this work.  2. SYNTAX \nThe syntax of the P2TS extends that of PTSswith struc\u00adtures and abstractions on patterns [10]. The contexts \nde.n\u00ading the types of the free variables of these patterns are given explicitly as part of the abstraction. \n2.1 Notations and Conventions. In this paper, we consider the meta-symbols . (function abstraction), \nand . (product, or type abstraction), and , (structure operator), and the (hidden)  (application op\u00aderator). \nWe assume that the application operator as\u00adsociates to the left, while the other operators associate \nto the right. The priority of  is higher than that of [ \u00ab]. which is higher than that of . and . which \nare, in turn, of higher priority than the , . The symbol .ranges over the set {..}, while the symbol \n9range over the set { ,}.The symbols A,B,C,... range over the set T of terms, the symbols X,Y,Z,... range \nover an in.nite set Vof variables, the symbols a,b,c,f,... range over a set Kof constants, the symbol \ns ranges over a set Sof sorts. The symbols a,\u00df,... range over Kand V.The symbols G,.,S range over the \nset Cof contexts. The sym\u00adbols s,t,.,... range over substitutions. All symbols can be indexed. As usual, \nwe work modulo the a-conversion and adopt Barendregt s hygiene-convention [3], i.e. free and bound variables \nhave di.erent names. 2.2 Pseudo-Terms. The de.nition of pseudo-terms and pseudo-contexts is pa\u00adrametrized \nby the set Kof constants, and Sof sorts (S.K), and Vof variables, and Pof patterns (V.P.T). C ::= \u00d8|C,V:T|C,K:T \nT ::= V|K|.P:C.T|.P:C.T|[P\u00abC T].T|T T|T,T Aterm ofthe form .A:..B is an abstraction (resp. product abstraction \n) with pattern A,body B and context .. The term [A \u00ab. C].B is a delayed matching constraint with pattern \nA,body B and argument C. A term of the form (A,B) is called a structure with elements A and B. In an \napplication (AB), the term A represents the func\u00adtion, while the term B represents the argument. The \nappli\u00adcation of a constant function, say f,to a term Awill be usu\u00adally denoted by f(A), following the \nalgebraic folklore ; this convention can be curry.ed in order to denote a function L taking multiple \narguments, e.g. f(A1 \u00b7\u00b7\u00b7An) = fA1 \u00b7\u00b7\u00b7An. If we set P=V, then we recover a syntax that is equivalent to \nPTS, see Theorem 5. 2 In PTS we need to recast the de.nition of free variables. Definition 1 (Free Variables). \nThe set Fv of free variables is inductively de.ned on terms (and pointwise ex\u00adtended to contexts) as \nfollows: L Fv(a) = \u00d8 L Fv(X) = {X} L Fv(.A:..B) = (Fv(A) .Fv(B) .Fv(.)) \\Dom(.) L Fv([A\u00ab. C].B) = Fv((.A:..B) \nC) L Fv(A9B) = Fv(A) .Fv(B) L Fv(\u00d8) = \u00d8 L Fv(.,a:A) = Fv(.) .Fv(A) Aterm A is closed if Fv(A)= \u00d8. Intuitively \nthe context . in .A:..B (resp. [A \u00ab. C].B) contains the type declarations of some (but not all) of the \nfree variables (not necessarily the type of constants) appear\u00ading in the pattern A, i.e. Dom(.) . Fv(A). \nThese vari\u00adables are bound in the (pattern and body of the) abstrac\u00adtion and the reduction of an abstraction \napplication strongly depends on them, all the other variables being handled as constants. The free variables \nof A notdeclaredin.are not bound in B but could be bound outside the scope of the abstraction itself. \nAs a simple example, in the abstraction .f(XY ):(X:i).g(XY ), the X variable is bound, while the Y variable \nis free. As in ordinary systems dealing with dependent types, we suppose that in G,a:A,the a does not \nappear free in G, and A.The set Bv of bound variables of a term is the comple\u00admentary of the set of free \nvariables w.r.t. the set of variables of therespectiveterm. Sincewework modulo a-conversion, we suppose \nthat all the bound variables of a term have dif\u00adferent names and therefore, the domains of all contexts \nare distinct. The following example presents some legal pseudo\u00adterms and their free variables according \nto De.nition 1. Example 1 (Some pseudo-terms). L (Cons 0) Let A = .cons(Xnil):..X, L with . = \u00d8.Then \nFv(A)= {X}. L (Cons 1) Let A = .cons(Xnil):..X, L with . = X:i.Then Fv(A)= \u00d8. L (PolyCons 0) Let A = \n.cons(TXnil(T )):..X, L with . = \u00d8.Then Fv(A)= {T,X}. L (PolyCons 1) Let A = .cons(TXnil(T )):..X, L \nwith . = X:T .Then Fv(A)= {T }. L (PolyCons 2) Let A = .cons(TXnil(T )):..X, L with . = T :*,X:T .Then \nFv(A)= \u00d8. L (.-Pattern) Let A = .(.X:G.X Y ):..Z, LLL with G = X:.Z:i.i,and . = Y :i.Then Fv(A) = {Z}. \n 2.3 Substitutions. We adapt the classical notion of simultaneous substitu\u00adtion application to deal with \nthe new forms of abstraction 2 introduced in the PTS. Definition 2 (Substitutions). A substitution s \nis of a .nite map {A1/X1 ...Am/Xm}. The application Bs of a substitution s toaterm B is de.ned as follows: \nL as = a Xis L = Ai if Xi . Dom(s) Xi otherwise (.A:..B)s L = .As:.s.Bs ([A \u00ab. B].C)s L = [As \u00ab.s Bs].Cs \n(A 9B)s L = As 9Bs \u00d8s L = \u00d8 (.,a:A)s L = .s, a:As We let Dom(s)= {X1,...,Xm} CoDom(.) = . Fv(Ai) i=1...m \nA substitution s is independent from ., written s 1.,if Dom(s) n Dom(.) = \u00d8 and CoDom(s) n Dom(.) = \u00d8.By \nabuse of language this notation can be used with a list of variables instead of a context.  2.4 Matching \nP2TSs feature pattern abstractions whose application re\u00adquires solving matching problems. For the purpose \nof this paper, we focus on syntactic matching. Definition 3 (Matching Systems). L 1. A matching system \nT = . Ai. S Bi is a conjunc\u00ad .i i=0...n tion of match equations, where . is idempotent, asso\u00adciative \nand commutative. 2. A matching system T is solved by the substitution s if Dom(s) . Dom(S) \\ Dom(.) and \nfor all i =0 ...n, Ais = Bi. 3. A matching system T is in solved form when it satis.es the following \nconditions: L (a) T = . Xi. S Ci . aj. S aj ; .i .j i=0...n j=0...m (b) for all h, k =0 ...n, Xh = Xk \nimplies Ch = Ck; (c) for all i =0 ...n, Xi . Dom(.i) or Xi . Dom(S) implies Xi = Ci; (d) for all i \n=0 ...n, Fv(Ci) n Dom(.i)  = \u00d8 implies Xi = Ci. The domain of the context S speci.es the variables con\u00adcerned \nby the matching; all the other variables of Ai are treated as constants. The domain of the context .i \nspeci\u00ad.es the variables that should not be considered (i.e. handled as constants) when solving the equation \nAi. S Bi.In the .i matching systems that should be solved in P2TSs the do\u00admains S and . are disjoint \nsince they de.ne the types of the bound variables of di.erent terms. Intuitively, the conditions can \nbe read as follows: (3a) imposes that a solved matching system should be a conjunction of equations of \nthe shape variable-term , or constant-constant ; (3b) checks for clashes due to a variable matching di.erent \nterms; (3c) checks that bound variables are not instantiated (s behaves as the identity on all variables \noccurring in Dom(.i)) and that only the variables explicitly spec\u00adi.ed as matchable (a.k.a. declared \nin the context of the abstraction) lead to useful replacements; (3d) checks that free variables are not \ninstantiated by bound variables. This condition is essential to guarantee that substitution does not \ncapture bound variables. Our matching algorithm is adapted from classical higher\u00adorder matching (and \nuni.cation) algorithms [13, 16, 21], in order to account for the speci.cities of P2TSs: syntactic matching \nthat does not involve the reduction calculus, ab\u00adstractions over patterns, and free variables in patterns. \n(.)(.A:..B)C .. [A \u00ab. C].B (Lbd/P rod)(.A1:..B1). S A2:..B2) G (.oA1. SG, .B2 (s)[A \u00ab. C].B .s Bs. . \nG, .A2 .B1. S (AC ) \u00d8 (d)(A, B) C .d AC,B C(Delay)[A1 \u00ab. C1].B1. S G [A2 \u00ab. C2].B2 oG, .A2 .B1. SG C2 \n A1. SG, .B2 .C1. S Figure 2: Top-level Rules of the P2TS (Appl/Struct) S (A1 9B1). G (A2 9B2) G A2 .B1. \nS  oA1. SG B2 7. [f(X) \u00abG f(Y )].X. .[f(X) \u00abG f(3)].X o. \u00d8 Figure 1: Matching Algorithm Alg Definition \n4 (Matching Algorithm Alg). The relation ois the compatible relation induced by the rules of Figure 1; \nthe relation o.is de.ned as the re.exive and tran\u00adsitive closure of o.If T o.T',with T' amatching system \nin solved form then, we say that the matching algorithm Alg (taking as input the system T) succeeds. \nThe matching algorithm is clearly terminating (since all rules decrease the size of terms) and deterministic \n(no criti\u00adcal pairs), and of course, it works modulo a-conversion and Barendregt s hygiene-convention. \nStarting form a given solved matching system of the form ... fY \u00d8 \u00d8 (solved by s = {3/Y }); The matching \nalgorithm Alg is sound and closed by substi\u00adtution, see Theorem 1 and Theorem 2.  3. DYNAMIC SEMANTICS \n3.1 Top-level Rules. The top-level rules are presented in Figure 2. The central idea of the (.) rule \nof the calculus is that the application of aterm .A:..B toaterm C, reduces to the delayed match\u00ading constraint \n[A \u00ab. C].B, while the application of the (s) rule consists in solving the matching equation A. .C,and \n\u00d8 f. .G X .X. . G f .X. .G X .f. . applying the obtained substitution (if it exists) to the the term \nB. One should notice that the subsequent matching concerns only the variables bound by the corresponding \ncon\u00ad text. If no solution exists, then the (s) rule cannot be .red L . S . S T = . Xi Ai . aj aj , the \ncorresponding sub\u00ad .i .j i =0...n j =0...m stitution {A1/X1 \u00b7\u00b7\u00b7An /Xn } is exhibited. By abuse of no\u00ad \nS S tation, if Alg succeeds on A. .B we write .s.Alg(A. .B) and the substitution s. S denotes the substitution \ncor\u00ad (A .B ) responding to the solved matching system computed by Alg with input A. S To ease the notation, \nS and . are omit\u00ad .B. ted if they are not essential when verifying (the conditions on the) the solved \nform of a matching system like, in par\u00adticular when . is empty or S contains all the free variables of \nthe left-hand sides of the matching equations. Example 2 (Runs of Alg). Let G= {X:i},and .= {Y :i},and \nT= {Z:i}, and an unspeci.ed context S. and therefore the term [A \u00ab. C].B is not reduced. The rule (d) \ndeals with the distributivity of the application on the structures built with the , constructor. It is \nimportant to remark that if A is a variable, then the subsequent combination of (.)and (s) rules corresponds \nexactly to the (\u00df) rule of the .-calculus, and variable ma\u00adnipulations in substitutions are handled externally, \nusing a\u00adconversion and Barendregt s hygiene convention if necessary.  3.2 (One/Many)-Step, Congruence. \nThe next de.nition introduces the classical notions of one\u00adstep, many-steps, and congruence relation \nof ..sd . Definition 5 (One/Many-Steps, Congruence). GG. .. ffX.\u00d8 \u00d8 G. 1. f(X) f(3) o\u00d8 Let Ctx[-] be \nany term T with a single hole inside, and (solved by s = {3/X}); let Ctx[A] be the result of .lling the \nhole with the term A; 3 \u00d8.. fX\u00d8 (not solvable since it does not satisfy condition 3c); inference rule, \nwhere ..sd =.. ..s ..d : \u00d8\u00d8 \u00d8\u00d8 2. f(X). f(3) o. f.  3 1. the one-step evaluation .sd . is de.ned by \nthe following \u00d8\u00d8 3. .X:G.X. S (not solvable since it does not satisfy condition 3c); (Ctx[-]) Ctx[A] \n.sd Ctx[B] . 4. .X:G.X. S G X .X. S .X:G.Y oX. SG Y A ..sd B X. S .3:G.3 oG X .X. S G 3 (not solvable \nsince it does not satisfy condition 3c); 2. the many-step evaluation . .sd and congruence relation =.sd \nare respectively de.ned as the re.exive-transitive \u00d8 \u00d8 5. .X:G.Y . S X. SG .Z:T.f(XZ) G X .Y . S  3.3 \nTwo Simple (Untyped) Examples (not solvable since it does not satisfy condition 3d); We present the reduction \nof two terms using di.erent eval\u00aduation strategies (outermost vs. innermost) and yielding in 6. .X:G.f(XY \n). . .X:G..Z:T.f(XZ) o and re.exive-symmetric-transitive closure of .sd . . .X:G.f(X 3) o. X. .G f .X. \n.G 3 G X .f. .G X .Y . . the .rst case a successful result (i.e. containing no delayed matching constraint) \nand in the second one an unsuccess\u00ad (solved by s = {3/Y }; all equations satisfy 3c, 3d); ful one. We \nunderline redexes to be reduced. Example 3 (Two Simple Evaluations in P2TS). A successful computation \n(.f(X).(.3.3)X) f(3). [f(X) \u00abf(3)].((.3.3) X)s . . L L ((.3.3) X){3/X}=(.3.3) 3. [3 \u00ab3].3.s 3{}=3 . (.f(X).(.3.3)X) \nf(3). (.f(X).[3 \u00abX].X) f(3).. . L [f(X) \u00abf(3)].([3 \u00abX].X)s 3/X}= .([3 \u00abX].X){ .=3 [3 \u00ab3].3s 3{}L An unsuccessful \ncomputation (.f(X).(.3.3)X) f(4). [f(X) \u00abf(4)].((.3.3) X)s . . ((.3.3) X){4/X}=(.3.3) 4. L .[3 \u00ab4].3 \n(.f(X).(.3.3)X) f(4). (.f(X).[3 \u00abX].3) f(4). . . L [f(X) \u00abf(4)].([3 \u00abX].3)s 4/X}= .([3 \u00abX].3){ [3 \u00ab4].3 \n It is worth noticing that the term [3 \u00ab4].3represents de facto a computation failure, which can be read \nas follows: The result would be 3 but at run-time the pro\u00ad gram triedtomatch 3 against 4, yielding the \n(dirty) result [3 \u00ab4].3 The capability of P2TS to record failures is directly inher\u00adited from previous \nversions of the rewriting-calculus, where a special symbol Null denoted computational failures (a.k.a. \nexceptions); di.erent mechanisms dealing with exception handling, such as e.g. try T catch [T\u00abT] with \nT,have been studied in [11, 14], in an untyped framework.  4. STATIC SEMANTICS 2 This section presents \nthe type system underneath PTS; as for PTSs, the formalism of P2TS is parameterized by a notion of speci.cation \n(S, A, R), where Sis a subset of Cand contains the sorts, A.S2 is aset of axioms,and R.S3 is a set of \nrules. We require all speci.cations to be functional [4], i.e.for every s1,s2,s2' ,s3,s3 ' .S, the following \nholds: (s1,s2) .A and (s1,s2' ) .A implies s2 =s ' 2 (s1,s2,s3) .R and (s1,s2,s3' ) .R implies s3 =s3' \n. Furthermore, we let ST denote the set of topsorts, i.e. T '' S= {s .S|.s .S. (s, s ) .A} and de.ne \na variant of delayed matching constraint as fol\u00adlows: { TB if B .ST [A \u00ab. C].B = [A \u00ab. C].B otherwise \n 4.1 A Guided Tour of Type Rules The notion of type derivation in P2TS involves a judgment of the shape: \nG fA : B The type system is de.ned by the rules of Figure 3. Some rules are inherited from PTSs but other \ndeserve a brief ex\u00adplanation, notably on how they di.er from their PTS coun\u00adterpart: The (Conv) rule \nis relaxed w.r.t. the usual one can .nd in usual PTS (where normally we have G fC : s); (s1,s2) .A (Axioms) \n\u00d8fs1 : s2 G fA : C G fB : C (Struct) G fA, B : C G fA : sa .Dom(G) (Start) G,a:A fa : A G fA : B G fC \n: sa .Dom(G) (Weak) G,a:C fA : B G fA : B G fC : DB= .sd C (Conv) G fA : C G, . fB : C G f.A:..C : s \n(Abs) G f.A:..B :.A:..C G fC : s1 (s1,s2,s3) .R G, . fA : C G, . fB : s2 (Prod) G f.A:..B : s3 G fA :.C:..D \nG, . fC : E G fB : E (Appl) G fAB :[C \u00ab. B].D G, . fA : E G, . fC : D G fB : D (Subst) G f[C \u00ab. B].A \n:[C \u00ab. B]T.E Figure 3: The Type Rules for P2TS The (Struct) rule says that a structure A, B,where A \n: C and B : C can be typed with type C,hence forcing all subterms to be of the same type; The (Abs) \nrule, which deals .-abstractions in which we bind over (non trivial) patterns, requires in partic\u00adular \nthat the pattern and body of the abstraction are typable in the extended context G, .;  Likewise the \n(Prod) rule, which deals with product types, requires that the pattern and codomain of the product is \ntypable in the extended context G, .;  The (Appl) rule, which deals with applications, im\u00adposes that \nthe resulting type in the conclusion features delayed matching. In case the delayed matching can be successfully \nsolved by a run of the matching algo\u00ad  . rithm Alg(C. \u00d8 B), one can recover the expected type by applying \nthe conversion rule; The (Subst) rule deals with terms in which a delayed matching constraint occurs \nhard-coded into the term (and its type); this rule is crucial to ensure the Subject Reduction property \nfor the top-level reduction rule (.). Observe that we require, as for the (Abs) rule, that the pattern \nand body of the delayed matching abstraction . . . G, . f(.3:\u00d8.3) : .3:\u00d8.i 5 (*, *, *) .R G f[Z \u00abS \nX].i : * G, . f[3 \u00ab\u00d8 X].i : * G, . f(.3:\u00d8.3) X :[3 \u00ab\u00d8 X].i G f.f(X):..[3 \u00ab\u00d8 X].i : *3 6 G f.f(X):..(.3:\u00d8.3)X \n:.f(X):..[3 \u00ab\u00d8 X].i 3 4 G f(.f(X):..(.3:\u00d8.3)X) f(3) : [f(X) \u00ab. f(3)].[3 \u00ab\u00d8 X].i 1 2 G f(.f(X):..(.3:\u00d8.3)X) \nf(3) : i L LL where 1 = [f(X) \u00ab. f(3)].[3 \u00ab\u00d8 X].i= .sd i,and 2 = G f i : *,and 3 = G, . f f(X):[Z \u00abS \nX].i,and LL [Z \u00abS 3].i,and 5 = G, . f X : i,and 6 = G, . f 3: i. Figure 4: A Typing Derivation . . \n. G, S, . fi : * 1 2 3 (*, *, *) .R G, S, . fX : i G, S f.P :..T : * G, S f.P :..X :.P :..T 4 G f(.T \n:S..P :..X):.T :S..P :..T 5 6 G f(.T :S.(.P :..X)) i :[T . Si]..P :..T 7 8 . . . . . . G f(.T :S.(.P \n:..X)) i :.Pi :.i .i G, .i fPi : list(i) G fP ' : list(i) 4 L = G f f(3) : ' G f(.T :S.(.P :..X)) iP \n:[Pi . P ' ].i .i 9 10 ' G f(.T :S.(.P :..X)) iP : i where 1 denotes G, S, . f P : list(T ), which can \nbe derived as follows: (we omit some simple derivations and we disregard simple applications of (Conv) \nrule after every application of an (Appl)rule). . . . G, S, . f.T :S.T r list(T ) r list(T ): *G, S, \n. fcons :.T :S.T r list(T ) r list(T ) 3 3 . . . G, S, . f.T :S.list(T ): * G, S, . fcons(T ): T r list(T \n) r list(T ) G, S, . fX : T G, S, . fnil :.T :S.list(T ) 3 G, S, . fcons(T ) X : list(T ) r list(T )G, \nS, . fnil(T ): list(T ) G, S, . fP : list(T ) L LL LL and 2 = G, S f list(T ): *,and 3 = G, S, . f T \n: *,and 4 = G f .T :S..P :..T : *,and 5 = G, S f T : *,and 6 = G f i : *, LL LL ' and 7 = G f .Pi :.i \n.i : *,and 8 = [T . Si]..P :..T = .sd .Pi :.i .i,9 = G f i : *,and 10 = [Pi . .i P ].i= .sd i. Figure \n5: Another Typing Derivation are typable in the extended context G, .. Note how .rst derivation (in Figure \n4) allows us to derive the term the variant of delayed matching is used in the type of the conclusion, \nas plain delayed matching would lead G f (.f(X):..(.3:\u00d8.3)X) f(3) : i to a failure of Subject Reduction \n(indeed one would L LL have f [X \u00ab. Y ].* :[X \u00ab. Y ].D but not f * : where G = i:*,f:.Z:S.i, 3:i, 4:i,and \n. = X:i,and S = Z:i. [X \u00ab. Y ].D). The second derivation (in Figure 5) was directly inspired by one of \nthe referees; it allows to type some basic polymor\u00adphic list operators, like car/cdr/head typable using \nhigher\u00ad 4.2 Two typing derivations order constructor types, like list(T )/cons(T )/null(T ), i.e. To \nbetter help the reader in the comprehension of P2TS, this subsection shows in extenso two typing derivations: \nthe G f (.T :S.(.P :..X)) iP ' : i L wherewelet A r B = .X:A.B when X .Fv(B), and L LL . = X:T and .i \n= X:i and S = T : * L G = i:*, 3:i, list: *r *,nil:.T :S.list(T ), cons:.T :S.T r list(T ) r list(T ) \nLL P = cons(T ) Xnil(T )and Pi = cons(i) Xnil(i) ' L P = cons(i)3 nil(i) denotes an applications of the \npolymorphic function (head) which takes as argument .rst the type i to instantiate into a list of integers, \nand then the singleton integer list (3) (denoted by the term P ) and produce as result the integer value \n3. Therefore, the polymorphic pattern P denotes the shape of a singleton polymorphic list. It easy to \nverify that (.T :S.(.P :..X)) iP ' . .sd 3, and that f(.P :..X)) P ' (i.e. the polymorphism need to be \ninstantiated .rst).  5. METATHEORY 2 This section collects all the meta-theory of PTS:more precisely, \nwe prove Con.uence, Subject Reduction, Conser\u00advativity over PTSs, and Consistency of normalizing P2TSs. \n5.1 Properties of the Matching Algorithm The matching algorithm Alg presented in Section 2.4 is sound, \nthat is, the substitution corresponding to the match\u00ading system in solved form computed by Alg solves \n(according to De.nition 3) the initial matching system. S Theorem 1 (Soundness of Alg). If .s.Alg(A. \n.B), then Dom(s) .Dom(S) \\Dom(.) and As =B. Proof. The .rstpropertyisobtainedimmediatelybycon\u00adstruction. \nFortheequivalence, theproofis donebyinduction on the structure of the term A. The classical syntactic \nmatching algorithms are obviously closed by substitutions containing no variables involved in the matching. \nIn P2TS some of the variables of the pattern can be free and consequently, the corresponding matching \nshould handle them as constants. Thus, we should ensure that the replacement of these variables by other \nterms does not a.ect the success of the matching algorithm. Never\u00adtheless, the substitutions that we \nconsider should not lead to variable capture and we impose the appropriate condi\u00adtions that are satis.ed \nwhen dealing with matching systems generated from well-formed P2TS terms. Theorem 2 (Alg is closed by \nsubstitution). S If .s.Alg(A. G B) and the substitution t is such that t 1S, St and t 1Bv(A),and t 1Dom(G) \nthen, ...Alg(At . Gt Bt ) and sSt =(sS )t . At . Bt A . Gt G B Proof. By induction on the structure \nof A.  5.2 Con.uence -The Rigid Pattern Condition When no restrictions are imposed either on the term \nfor\u00admation or on the reduction strategy, con.uence fails. There\u00adfore, a suitable condition Cond on Pshould \nbe used in order to ensure that P2TS are well-behaved extensions of plain PTS. The shape of patterns \nin P2TS abstractions is essential in order to avoid bizarre non-con.uent reductions and thus, in order \nto recover the good properties, Cond should ensure that these patterns satisfy certain properties. For \nthe scope of this paper we use a condition inspired from the Rigid Pattern Condition (RPC) that was .rst \nformalized in [29]. The RigidPattern Condition is su.cient for obtaining the diamond property of the \n(parallel) reduction and hence the con.uence of the reduction in P2TS. As explained in [29], this kind \nof rigid pattern condition does not character\u00adize the shape of patterns, but syntactic characterizations \nof the terms satisfying this condition can be given. We introduce the RPC which turns out to be su.cient \nto prove that the parallel reduction..sd (de.ned below) satis.es the diamond property. The condition \nwe present di.ers from the original one of [29], since it has been customized to better 2 .t for our \nPTS and, in particular, the possibility to reduce the patters that can possibly contain free variables. \nLet us .rst de.ne the notion of parallel reduction for our 2 PTS. Definition 6 (Parallel Reduction). \nThe parallel reduction, denoted by..sd, is inductively de.ned as follows: (Par1) a ..sd a (Par2) A1 9B1 \n..sd A2 9B2 if A1 ..sd A2,B1 ..sd B2, 9.{ , } (Par3) .A1:.1.B1 ..sd .A2:.2.B2 if A1 ..sd A2,B1 ..sd B2, \n.1 ..sd .2, ..{. .} (Par4)(.A1:.1.B1)C1 ..sd [A2 \u00ab.2 C2].B2 if A1 ..sd A2,B1 ..sd B2,C1 ..sd C2, .1 ..sd \n.2 (Par5)(A1,B1) C1 ..sd A2 C2,B2 C2 if A1 ..sd A2,B1 ..sd B2,C1 ..sd C2 (Par6)[A1 \u00ab.1 B1].C1 ..sd [A2 \n\u00ab.2 B2].C2 if A1 ..sd A2,B1 ..sd B2,C1 ..sd C2, .1 ..sd .2 (Par7)[A1 \u00ab.1 B1].C1 ..sd C2s .2 (A 2. B 2) \n\u00d8 if A1 ..sd A2,B1 ..sd B2,C1 ..sd C2, .1 ..sd .2, .s .2 (A 2. B 2) \u00d8 The rules (Par1),..., (Par3) indicate \nthat the relation ..sd < includes the identity on .-terms, i.e. A ..sd A holds for all A .T.Rules (Par4),..., \n(Par7) deal with reductions. Intuitively, A ..sd B means that B is obtained from A,by si\u00admultaneous contractions \nof some (.sd)-redexes possibly over\u00adlapping one each other. Definition 7. De.ne the mapping 0by induction: \nat L = a (A, B)t L = At,Bt (.A:..B)t L = .At:.t.Bt (AB)t L = AtBt if A is not abstraction or structure \n((.A:..B)C)t L = [At \u00ab.0 Ct].Bt ((A, B)C)t L = (AtCt), (BtCt) ([A \u00ab. B].C)t L = [At \u00ab.0 Bt].Ct if s(A \n0\u00ab.0 B 0) does not exist ([A \u00ab. B].C)t L = Cts(A 0\u00ab.0 B 0) The rules describing the parallel reduction \nand the map\u00adpings for contexts and substitutions are not presented since they are completely syntax dependent \nand naturally follow from the other rules. Using these two latter de.nitions we introduce the RPC and \nits extension ERPC. Intuitively, the RPC ensures that the form of a pattern is preserved by reduction \neven when some of its variables are instantiated. This means that the only redexes introduced when instantiating \nthe variables of a pattern by a term are the ones already present in the term. Definition 8 (Rigid Pattern \nCondition (RPC)). The term P satis.es RPC if for all A, B, s1 ..sd s2: 1. Ps1 ..sd B implies B =Ps2, \n 2. A ..sd Ps2 implies At =Ps1 t .  The RPC ensures not only that the form of patterns is pre\u00adserved \nbut also that if a term is reduced to the instantiation of a pattern then, its 0-mapping is also an instantiation \nof the same pattern. The RPC can be seen as a coherence condition between the reduction and the matching, \ni.e. if a given matching system involving rigid patterns has a solution then the system obtained by reducing \nthe terms of the initial one has a (corresponding) solution as well. Worthy to notice that V obviously \nsatis.es RPC, but T do not. Since in P2TS the variables that are not bound in a pat\u00adtern by the corresponding \ndomain are treated as constants (in the matching algorithm), the conditions imposed by RPC should not \nbe enforced on these variables. Therefore, we re\u00adlax this condition and introduce the Extended Rigid \nPattern Condition (ERPC) that is de.ned w.r.t. a given context. Definition 9 (Extended RPC, ERPC(.)). \nThe term E satis.es ERPC(.)ifthere exist P satisfying RPC and s1. such that E =Ps. The pattern A of P2TS \nabstractions of the form .A:..B and P2TS delayed matching constraints of the form [A \u00ab. C].B should satisfy \nERPC(.). In the examples and properties pre\u00adsented in this section we sometimes consider that all vari\u00adables \nof a pattern are bound in the corresponding abstrac\u00adtions since free variables are considered as constants \nin the matching algorithm. At this point of the paper, the RPC condition appears somewhat obscure, since \nit involves the de.nition of the parallel reduction. Nevertheless, to help the reader, we can (syntactically) \ncharacterize an honest subset Pof T which properly contains V and satis.es RPC. Definition 10 (Characterization \nof PRPC). Let Nf(.sd) be the set of terms that cannot be reduced by one 2 of the rules of PTS. De.ne \nL PRPC = {A .Nf(.sd) |A contains no subterms of the form (XB) s.t. X .Fv(A) andnosubterms ofthe form \n[B \u00ab. C].D,with Fv(A) n(Fv(B) .Fv(C)) = \u00d8} This characterization imposes that a pattern from the set \nP contains no so-called active variables that are free and that all patterns and arguments of its delayed \nmatching con\u00adstraints are closed. Starting from this characterization for RPC, we can also characterize \na set of terms L P= {Ps |P .PRPC and s1.} satisfying ERPC(.). One can notice that this latter characterization \nis closed by substitution (with a (co)domain containing no variables from the domain of .) and thus, \nis preserved by reduction in the patterns of P2TS abstractions. The following examples show that when \nconsidering pat\u00adterns that do not satisfy the above characterization, the con\u00ad.uence is lost. Example \n4. (All type annotations are omitted). 1. Patterns containing free active variables like X in the term \n(.(XY ).X)((.Z.Z)a) lead to a non-con.uent reductions: (.(XY ).X)((.Z.Z)a) ;; .sd;.sd ;;;;;;;;;; ; ;; \n [XY \u00ab(.Z.Z)a].X (.(XY ).X)([Z \u00aba].Z) .sd .sd (.Z.Z) (.(XY ).X)a 2. When a pattern containing free variables \nin the argu\u00adment of a delayed matching constraint is used, non\u00adcon.uent derivations can be obtained: \n(.([a \u00abY ].b).Y )([a \u00aba].b)  .sd .sd [[a \u00abY ].b \u00ab[a \u00aba].b].Y (.([a \u00abY ].b).Y )(b) .sd .sd  a [[a \n\u00abY ].b \u00abb].Y Worthy noticing that the original characterization of RPC of [29] forbids patterns that \nare non-linear , i.e. with multiple occurrences of free variables inside, (e.g.in f(XX)). The above characterization \ndoes not enforce this condition and this is suitable especially when dealing with terms typable with \npolymorphic and dependent types. Lemma 1. If P .PRPC then P satis.es RPC. Proof. We show that if P .PRPC \nthen, for all B, s1 ..sd s2 1. Ps1 ..sd B implies B =Ps2, 2. B ..sd Ps2 implies Bt =Ps1 t .  For the \n.rst point we should notice that a pattern should be in normal form and thus, the only redexes are introduced \nby the substitution. On the other hand, redexes that do not exist in s can be created only by instantiating \nfree active variables by a structure or an abstraction or by instantiating the variables of a delayed \nmatching constraint and making solvable a matching equation. None of these cases is possi\u00adble since P \ncontains no free active variables and no free variables in the pattern and argument of a delayed matching \n(Par4) and (Par5). We consider the .rst case, the other constraint and thus, the property holds. being \nsimilar. We have therefore, (.A1:.1.B1)C1 ..sd For the second point, we proceed by induction on the def-[A2 \n\u00ab.2 C2].B2,with A1 ..sd A2 and B1 ..sd B2 and inition of B ..sd Ps2. The case of (Par1) is trivial and \nall C1 ..sd C2 and .1 ..sd .2,and ((.A1:.1.B1)C1)t = [At 1 \u00ab. 0 1 C1 t].B1 t.By IH, A2 ..sd A1t ,and \nB2 ..sd B1 t , the other cases except for (Par7) follow easily by IH. For Ct .t 1 ,and .2 ..sd 1,and \nthus, we obtain(Par7) we have [A1 \u00ab.1 B1].C1 ..sd C2s with and C2 ..sd (A 2. .2 \u00d8 B 2) [A2 \u00ab.2 C2].B2 \n..sd [At 1 \u00ab. 0 1 C1 t].B1 t . A1,B1,C1 .PRPC. It can be shown easily that if A1 ..sd A2, and B1 ..sd \nB2,and .1 ..sd .2,and .s2.Alg(A2. .\u00d8 2 B2), . then .s1 t .Alg(At 1. \u00d8 0 1 B1 t) and s2 ..sd s1 t.Then,theproperty \n\u00d8 (Par7). We have [A1 \u00ab.1 B1].C1 ..sd C2s (A 2. .2 with B 2) A1 ..sd A2 and B1 ..sd B2 and C1 ..sd C2 \nand .1 ..sd follows by IH and Lemma 4. .2.Since A1 satis.es ERPC(.)then A1 = Ps1 with P satisfying RPC \nand s1 1.. Therefore, A2 = Ps2 with In order to prove the con.uence of the ..sd relation it is s1 ..sd \ns2 and since .t2.Alg(A2. .\u00d8 2 B2), without loss enough to prove the diamond property of the . relation. \n .sd of generality, we can consider that B2 = Ps2{ .X} D/ . We can prove this latter property directly \nor we can pro\u00ad with X . Dom(.2).Since s1 1X,by RPC,we ob\u00ad pose a relation whose transitive closure is \nthe . .sd relation 0 B1 t = Ps1 t{D.t/X.} and since A1 t = Pst . 1 and that satis.es the diamond property \nand obtain as an tain then, immediate consequence the diamond property for the . .sd .tt .Alg(At 1. \n B1].C1)t \u00d8 Bt 1 ).Thus, ([A1 \u00ab.1 = relation. In what follows we use the latter approach and chose as \ntarget relation the parallel reduction introduced in De.nition 6. Lemma 2 (Relations). ..sd ...sd .. \n.sd . Since the transitive closure of the parallel reduction is the . .sd relation, we should show that \n..sd satis.es the diamond property. For this, we state some auxiliary lemmas used for showing that ..sd \nsatis.es a strong diamond property and we obtain as a consequence the diamond property for ..sd. Lemma \n3 (Permutation). 1. If X . Fv(C),then A{B/X}{C/Y }= A{C/Y }{B{C/Y }/X}; 2. If A= .sd B,then A{C/X}= .sd \nB{C/X}. Proof. Byinductiononthe de.nitionof substitution and = .sd respectively. For the parallel reduction, \nthe following lemma holds. Lemma 4 (Parallel). If A ..sd B and C ..sd D,then As1 ..sd Bs2,with s1 = { \n.X},and s2 = { .X},and C/.D/.s1,s21Bv(A). = { .X}..sd { .X} = C1 ttt . On the other hand, t2 D/.Dt/.tt \nand, by IH, C2 ..sd C1 t . Therefore, by Lemma 4, we can conclude that C2t2 ..sd C1 ttt . Theorem 3 (Confluence). \nThe relation ..sd is con\u00ad.uent. Proof. By Lemmas 2 and 5. Corollary 1 (Key Lemma). If .A1:.1.B1 = .sd \n.A2:.2.B2,then A1= .sd A2,and .1= .sd .2,and B1= .sd B2. Proof. Immediate from con.uence.  5.3 Subject \nReduction Subject Reduction is a standard property of PTSsthat states that typing is preserved under \nreduction. As for con\u00ad 2 .uence, Subject Reduction for PTS fails if we do not impose any condition on \npatterns in applications. The following simply-typed example exhibits a typable term whose reduct is \nnot typable. Example 5 (Spoofer). Let Proof. By induction on the de.nition of ..sd. L . a1:*,a2:*,b:*,c:*,X1:a1 \nr b, Y1:a1 = Lemma 5 (Diamond Property for ..sd). If A ..sd B G L X2 : a2 r b, Y2 : a2,Z:a1 r c = and \nA ..sd C, then there exists D, such that B ..sd D,and C ..sd D. and consider thejudgment: G f (.(X1 Y1):.. \n(ZY1)) (X2 Y2): c Indeed, we can adapt, as below, the stronger statement from [27] to our P2TS and the \ndiamond property for ..sd follows Theabovejudgmentis derivablesince G, . f (ZY1): c and immediately. \nG, . f (X1 Y1): b, hence by the abstraction rule (Abst) we Lemma 6 (Strong Church-Rosser for ..sd). If \nA..sd B,then B ..sd At . Proof. By induction on the de.nition of A..sd B: (Par1). Trivial. (Par2) and \n(Par3) and (Par6). We consider .rst case, the others being similar. We have A1 9B1 ..sd A2 9B2 with A1 \n..sd A2,andB1 ..sd B2,and (A19B1)t = At 19B1 t.By IH, A2 ..sd At 1,and B2 ..sd B1 t ,and thus, A2 9B2 \n..sd At 1 9B1 t . get G f (.(X1 Y1):.. (ZY1)) : b r c. On the other hand G f (X2 Y2): b so we conclude \nby the application rule (Appl). Then (.(X1 Y1):.. (ZY1)) (X2 Y2) reduces to ZY2 which is not derivable \nin G. Interestingly, the above counter-example has the same origin as the counter-example to Con.uence, \nnamely the presence of free active variables in a pattern. In particular, the pat\u00adtern X1 Y1 does not \nsatisfy RPC w.r.t. .. Nevertheless, RPC does not immediately ensure that Subject Reduction holds for \nP2TSs, and we need to impose a suitable condition on P so that the solution of a well-typed matching \nproblem is a well-typed substitution. This requirement is captured by the Subject Reduction Condition \n(SRC) below. Together with ERPC which is required for the Key Lemma, SRC guar\u00adantees that Subject Reduction \nholds. Definition 11 (Subject Reduction Condition). Let . =X1:A1 ...Xn :An .The term P satis.es SRC(.) \nif: i =1...n . 1. If .{Ci /Xi }.Alg(P . C),and G, . f P : E, \u00d8 and G fC : E,then, for i =1 ...n, G fCi \n:Ai {C1/X1, ... ,Ci -1/Xi -1} 2. If G, . f P : B then for every P ' .P such that P = .sd P ' and G fP \n' : B ' , we have B= .sd B ' . 2 The pattern of an abstraction in PTS should satisfy the SRC condition \nw.r.t. the domain of this abstraction. At this point of the paper, the SRC condition appears somewhat \npuzzling. Nevertheless, we shall later prove that the subset P of T of De.nition 10 satis.es SRC. For \nnow, we focus on the proof of Subject Reduction. The proof proceeds as with for PTSs and relies upon \nthe following preliminary results. Lemma 7 (Thinning). If G fA : B and G .. and . legal, then . fA : \nB. Lemma 8 (Substitution). If G,X:D, . fA : B,and G fC : D,then G, .{C/X}fA{C/X}: B{C/X}. Lemma 9 (Generation). \n1. If G fs1 : A,then A=.sd s2 and s1 : s2 .A; 2. If G fa : A,then G =.,a:B, S,and A= .sd B; 3. If G \nf .A:..B : D,then G, . f B : C,and G f .A:..C : s,and D= .sd .A:..C; 4. If G f.A:..B : D,then G, . fA \n: C,and G fC : s1, and G, . fB : s2,and (s1,s2,s3) .R,and D= .sd s3; 5. If G fAB : F ,then G fA :.C:..D,and \nG fB : E, and G, . fC : E,and F = .sd [C \u00ab. B].D; 6. If G f [C \u00ab. B].A : F ,then G, . f C : D and G \nfB : D and G, . fA : E and F = .sd [C \u00ab. B]T.E; 7. If G fA, B : C,then G fA : D and G fB : D and C= \n.sd D;  Lemma 10 (Correctness of Types). If G f A : B then G fB : C or B .ST . The last result needed \nfor proving Subject Reduction is the Context Conversion Lemma, which states that convertible contexts \ntype the same judgments. Lemma 11 (Context Conversion). If G fA : B and . is legal and G=.sd . then . \nfA : B. Proof. One .rst prove by induction on the structure of derivations the following: if G fA : B \nand . fX : A for every (X:A) .G,then . fA : B. Then one proceeds by induction on the length of G. Theorem \n4 (Subject Reduction). If G fA : B,and A ..sd C,then G fC : B. Proof. By induction on the structure of \nA.We only treat the cases where A is a .-redex or s-redex; all other cases follow easily. (.) Assume \nthat (.A:..B) C .. [A \u00ab. C].B and that G f(.A:..B) C : D. By successive applications of Generation, G, \n. ' f A ' : F ' , and G fC : F ' ,and G, . fB:E,and G, . fA:F ,and G f F :s,and D=.sd [A ' \u00ab.' C].E ' \n,and .A:..E= .sd .A ' :. ' .E ' . By the Key Lemma, we have A=.sd A ' ,and .=.sd . ' ,and E= .sd E ' \n. ByContext Conversion, we have G, . fA ' :F ' ,and by SRC(2), we have F = .sd F ' .By (Conv), we have \nG fC:F . By (Subst), G f[A \u00ab. C].B:[A \u00ab. C]T.E.Furthermore E .ST,hence [A \u00ab. C]T.E =[A \u00ab. C].E,and by \nCor\u00adrectness of Types, we have G, . fE:G. Hence by (Subst), G f[A \u00ab. C].E:[A \u00ab. C]T.G, and hence by (Conv),we \nhave G f[A \u00ab. C].B:D as desired. (s) Assume that [A \u00ab. C].B .s Bs with .s.Alg(A. . \u00d8 C), and that G f[A \n\u00ab. C].B : D. By Generation, we have G, . f A : E,and G f C : E, and G, . fB : F ,and D=.sd [A \u00ab. C]T.F \n.By SRC(1), we have G f Bs : Fs. By Correctness of Types, G f F : G or F .ST . In the .rst case, we apply \n(Subst) to get G f [A \u00ab. C].F :[A \u00ab. C]T.G and we conclude by (Conv). In the second case, we get D= .sd \nF ,hence D . .sd F by Con.uence; therefore, F is a subterm of D.By a simple analysis of the typing rules, \nit follows that D =F and we are done. We now turn to the characterization of SRC. We start with a preliminary \nresult. Lemma 12 (Unicity of Typing). If G fA : B and G fA : C,then B= .sd C. Proof. By induction on \nthe structure of derivations, us\u00ading the functionality of speci.cations. Lemma 13 (Characterization of \nSRC(.)). If P .P and s1. then Ps satis.es SRC(.). Proof. By induction on P .  5.4 P2TS as logics Many \ntype systems and logics, including the systems of Barendregt s .-cube [4], can be cast in the framework \nof PTSs. In perfect symmetry, the framework of P2TSs allows us to formulate a matching-based version \nof many type sys\u00adtems. In the case of the .-cube, its matching-based coun\u00adterpart, which we call . < \n-cube with matching (. < -cube for short), is depicted in Figure 6, where S = {*, D},and A = {(*, D)};note \nthat we use (s1,s2) to denote rules of the form (s1,s2,s2). PTSs, and in particular the systems of the \n.-cube, have a well-understood logical theory via the Curry-Howard Iso\u00admorphism and the (impredicative) \nencoding of data-types in type systems, and are used as the foundations of proof\u00adassistants. A detailed \nanalysis of the logical status of P2TSs, including an extension of the Curry-Howard Isomorphism, is left \nfor future work, but we provide two elementary results that establish that P2TSs are logically sound. \nFirst, we show that P2TSs are a conservative extension of PTSs. Indeed, it is possible to embed every \nPTS into its .. / /  // 2 << . P. System Rules << . .P 2 < .. < . P. . < . (*,*) . < 2 (*,*) (D,*) \n. < . (*,*) (D,D) . < . (*,*) (*,D) (D,D) . < P (*,*) (*,D) . < P2 (*,*) (D,*) (*,D) . < P. (*,*) (*,D) \n(D,D) . < P. (*,*) (D,*) (*,D) (D,D) / / // < . . < .P < Figure 6: The . -cube corresponding P2TS \nusing the (trivial) translation matching modulo an equational theory, as in the re\u00ad 2 writing calculus \n[8, 9], upon which PTSs are built, L a = a L = (.X:A.B) .X:(X:A ).B and which takes as a parameter an \nequational theory modulo which matching is performed. In a similar L L = X (AB) A B X = 2 Theorem 5 (Conservativity). \nP2TSsare aconser\u00advative extension of PTSs in the sense that for every PTS pseudo-context G and PTS pseudo-terms \nA and B G f PTS A : B .. G f P2TS A : B Proof. The direct implication is trivial. For the reverse implication,weprovebyinductiononthestructureof \nderiva\u00adtions that G f P2TS A : C implies G f PTS A : B for some B such that = .sd C. B 2 Second, we show \nthat normalizing PTSsare consistent. The proof relies upon the following observation. Lemma 14 (Chaining). \nIf A, B, . are in normal form and G f ([A \u00ab . B].C) D : E,then . s.A lg(A. . \u00d8 B). Proof. Apply Generation \ntwice. Theorem 6 (Consistency in P2TS). Any norma\u00adlizing P2TS is logically consistent, i.e. for every \nsort s .S , X:s f A : X. Proof. Theprooffollows[4]:assumewithoutlossof gen\u00aderality that A is in normal \nform, and proceed by analysis on the shape of normal forms, using the Chaining Lemma to rule out the \ncase A = ([A1 \u00ab . A2].A3) A4 ... An .  6. CONCLUSION P2TSs provide a conservative extension of PTSswith \nma\u00adtching, and enjoy all elementary properties of PTSs. The next question on our agenda is to determine \nwhether P2TSs also enjoy non-elementary properties of PTSs: w.r.t. strong normalization, we conjecture \nthat stan\u00addard model construction techniques can be used to < vein, it would be interesting to study \nP TSswitha limited form of decidable higher-order uni.cation, in the style of .-Prolog [21, 22, 26]; \n encoding dependent case analysis, pattern-matching `a la Coquand and algebraic type systems. In view \nof the Chaining Lemma, P2TSs cannot code dependent case analysis, and hence cannot provide a foundation \nfor pattern matching in dependent type theory. It would be interesting to investigate whether endorsing \nmore powerful rules for structures and a subtyping calculus derived from matching would su.cetoencodedepen\u00addent \ncase analysis;  explicit substitutions. The extension is not trivial, be\u00adcause of delayed matching constraints, \nbut the result\u00ading formalism could serve as the core engine of a little type-checker underneath of a \npowerful proof assistant.  We conclude with a challenge for future work: Extending the Curry-Howard \nIsomorphism. The extension can be con\u00adsidered from the point of view of sequent calculi, deduc\u00adtion modulo, \nand natural deduction respectively. From the point of view of sequent calculi, it remains to investigate \nhow P2TSs can be used to extend previous results on term calculi for sequent calculi, and how their extension \nwith matching theories can be used to provide suitable term calculi for de\u00adduction modulo. From the point \nof view of natural deduc\u00adtion, P2TSs correspond to an extension of natural deduction where parts of proof \ntrees are discharged instead of assump\u00adtions. To our best knowledge, such an extended form of natural \ndeduction has not been considered previously, but it seems interesting to investigate whether such an \nextended natural deduction could .nd some applications in proof as\u00adsistants, e.g. for transforming and \noptimizing proofs. prove strong normalization of the . -cube; w.r.t. type checking/inference, we conjecture \nthat ex\u00adisting algorithms for PTSs adapt readily to P2TSs. Besides, we would like to enhance the expressive \nand com\u00ad 2 putational power of PTSs, so as to provide support for: handling failures/exceptions by introducing \na uniform notion of failure Null, which records failures but dis\u00adcards their explanation, and its corresponding \ncondi\u00adtional rewrite rule A Cond B implies [A \u00ab . B].C ..sd Null for some suitable condition Cond; Acknowledgments.. \nThe authors are sincerely grateful to all anonymous referees for their extremely useful comments, and \nto one particular referee for pointing out some subtleties in the interaction of patterns, dependent \ntypes and poly\u00admorphism. They also wish to thank Vincent van Oostrom, Pierre Courtieu, J\u00a8oelle Despeyroux, \nPhilippe de Groote for fruitful discussions and comments. Finally, Luigi would like to thank Simonetta \nRonchi della Rocca and Furio Honsell, for the time spent to teach to him the fundamentals and the insight \nof the cubes-stu. .  7. REFERENCES [1] L. Augustsson. Cayenne: A Language with Dependent Types. In Proc. \nof ICFP, pages 239 250. ACM Press, 1998. [2] F. Barbanera, M. Fern\u00b4andez, and H. Geuvers. Modularity \nof Strong Normalisation and Con.uence in the Algebraic .-Cube. Journal of Functional Programming, 7(6):613 \n660, 1997. [3] H. Barendregt. Lambda Calculus: its Syntax and Semantics. North Holland, 1984. [4] H. \nBarendregt. Lambda Calculi with Types. In Handbook of Logic in Computer Science,volume II, pages 118 \n310. Oxford University Press, 1992. [5] H. Barendregt and H. Geuvers. Proof Assistants Using Dependent \nType Systems. In Handbook of Automated Reasoning, volume II, chapter 18, pages 1149 1238. Elsevier Publishing, \n2001. [6] G. Barthe and T. Coquand. An Introduction to Dependent Type Theory. In Proc. of Applied Semantics \nSummer School, volume 2395 of LNCS. Springer-Verlag, 2002. [7] F. Blanqui. Type Theory and Rewriting.PhD \nthesis, Universit\u00b4e de Paris-Sud, 2001. [8] H. Cirstea and C. Kirchner. The Rewriting Calculus PartI \nand II. Logic Journal of the Interest Group in Pure and Applied Logics, 9(3):427 498, 2001. [9] H. Cirstea, \nC. Kirchner, and L. Liquori. Matching Power. In Proc. of RTA, volume 2051 of LNCS, pages 77 92. Springer-Verlag, \n2001. [10] H. Cirstea, C. Kirchner, and L. Liquori. The Rho Cube. In Proc. of FOSSACS, volume 2030 of \nLNCS, pages 166 180, 2001. [11] H. Cirstea, C. Kirchner, and L. Liquori. Rewriting Calculus with(out) \nTypes. In Proc. of WRLA, volume 71 of ENTCS, 2002. [12] T. Coquand. Pattern Matching with Dependent Types. \nIn Proc. of Logical Frameworks, pages 66 79, 1992. [13] G. Dowek, T. Hardin, C. Kirchner, and F. Pfenning. \nUni.cation via Explicit Substitutions: The Case of Higher-Order Patterns. In Proc.ofJICSLP.MIT Press, \n1996. [14] G. Faure and C. Kirchner. Exceptions in the Rewriting Calculus. In Proc. of RTA, volume 2378 \nof LNCS, pages 66 82. Springer-Verlag, 2002. [15] H. Geuvers and M.J. Nederhof. A Modular Proof of Strong \nNormalisation for the Calculus of Constructions. Journal of Functional Programming, 1(2):155 189, 1991. \n[16] G. Huet. R\u00b4esolution d Equations dans les Langages d Ordre 1,2, ...,..Th`ese de Doctorat d Etat, \nUniversit\u00b4e de Paris 7, 1976. [17] J.P. Jouannaud and M. Okada. Abstract Data Type Systems. Theoretical \nComputer Science, 173(2):349 391, 1997. [18] D. Kesner, L. Puel, and V. Tannen. A Typed Pattern Calculus. \nInformation and Computation, 124(1):32 61, 1996. [19] J.W. Klop. Combinatory Reduction Systems,volume \n127 of Mathematical Centre Tracts. CWI, 1980. PhD Thesis. [20] J.W. Klop, V. van Oostrom, and F. van \nRaamsdonk. Combinatory Reduction Systems: Introduction and Survey. Theoretical Computer Science, 121(1&#38;2):279 \n308, 1993. [21] D. Miller. A Logic Programming Language with Lambda-abstraction, Function Variables, \nand Simple Uni.cation. In Proc. of ELP, volume 475 of LNCS, pages 253 281. Springer-Verlag, 1991. [22] \nD. Miller, G. Nadathur, F. Pfenning, and A. Shedrov. Uniform Proofs as a Foundation for Logic Programming. \nAnnals of Pure and Applied Logics, 51(1-2):125 157, 1991. [23] T. Nipkow and C. Prehofer. Higher-order \nRewriting and Equational Reasoning. In Automated Deduction A Basis for Applications. Volume I: Foundations. \nKluwer, 1998. [24] S. Peyton Jones. The Implementation of Functional Programming Languages. Prentice \nHall, 1987. [25] S.L. Peyton Jones and E. Meijer. Henk: a Typed Intermediate Language. In Types in Compilation \nWorkshop, 1997. [26] C. Sch\u00a8urmann. Automating the Meta-Theory of Deductive Systems. Phd thesis, Carnegie-Mellon \nUniversity, 2000. [27] M. Takahashi. Parallel Reductions in .-calculus. Journal of Symbolic Computation, \n7(2):113 123, 1989. [28] S. van Bakel, L. Liquori, S. Ronchi della Rocca, and P. Urzyczyn. Comparing \nCubes of Typed and Type Assignment System. Annals of Pure and Applied Logics, 86(3):267 303, 1997. [29] \nV. van Oostrom. Lambda Calculus with Patterns. Technical Report IR-228, Faculteit der Wiskunde en Informatica, \nVrije Universiteit Amsterdam, 1990. [30] D. A. Wolfram. The Clausal Theory of Types, volume 21 of Cambridge \nTracts in Theoretical Computer Science. Cambridge University Press, 1993.  \n\t\t\t", "proc_id": "604131", "abstract": "We introduce a new framework of algebraic pure type systems in which we consider rewrite rules as lambda terms with patterns and rewrite rule application as abstraction application with built-in matching facilities. This framework, that we call \"<i>Pure Pattern Type Systems</i>\", is particularly well-suited for the foundations of programming (meta)languages and proof assistants since it provides in a fully unified setting higher-order capabilities and pattern matching ability together with powerful type systems. We prove some standard properties like confluence and subject reduction for the case of a syntactic theory and under a syntactical restriction over the shape of patterns. We also conjecture the strong normalization of typable terms. This work should be seen as a contribution to a formal connection between logics and rewriting, and a step towards new proof engines based on the Curry-Howard isomorphism.", "authors": [{"name": "Gilles Barthe", "author_profile_id": "81100111668", "affiliation": "LORIA, INRIA & University Nancy II, Cedex France", "person_id": "PP14049331", "email_address": "", "orcid_id": ""}, {"name": "Horatiu Cirstea", "author_profile_id": "81100360869", "affiliation": "LORIA, INRIA & University Nancy II, Cedex France", "person_id": "PP40026459", "email_address": "", "orcid_id": ""}, {"name": "Claude Kirchner", "author_profile_id": "81100351221", "affiliation": "LORIA, INRIA & University Nancy II, Cedex France", "person_id": "PP40026352", "email_address": "", "orcid_id": ""}, {"name": "Luigi Liquori", "author_profile_id": "81100343771", "affiliation": "LORIA, INRIA & University Nancy II, Cedex France", "person_id": "P174267", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/604131.604152", "year": "2003", "article_id": "604152", "conference": "POPL", "title": "Pure patterns type systems", "url": "http://dl.acm.org/citation.cfm?id=604152"}