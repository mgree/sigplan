{"article_publication_date": "01-15-2003", "fulltext": "\n Coercive Subtyping for the Calculus of Constructions (extended abstract) * Gang Chen Computer Science \nDepartment, Boston University Boston, MA 02215, USA gangchen@types.bu.edu ABSTRACT We present a coercive \nsubtyping system for the calculus of constructions. The proposed system .Cco is obtained es\u00ad = sentially \nby adding coercions and .-conversion to .C=[10], which is a subtyping extension to the calculus of construc\u00adtions \nwithout coercions. Following [17, 18], the coercive sub\u00adtyping c : A = B is understood as a special case \nof typing in arrow type c : A . B such that the term c behaves like an identity function. We prove that, \nwith respect to this seman\u00adtic interpretation, the proposed coercive subtyping system is sound and complete, \nand that this completeness leads to transitivity elimination (transitivity rule is admissible). In addition, \nwe establish the equivalence between .Cco and = CC\u00df., this fact implies that .Cco has con.uence, subject \n= reduction and strong normalization. We propose a formal\u00adization of coercion inference problem and present \na sound and complete coercion inference algorithm. Categories and Subject Descriptors D.3 [Software]: \nProgramming Languages  General Terms Languages  Keywords Subtyping, Coercion, Calculus of Constructions, \nSemantics of Coercions, Transitivity Elimination 1. INTRODUCTION The Calculus of Constructions (generally \nabbreviated as CC or .C) is a dependent type theory, in which types can depend on both terms and types, \nand terms can take terms and types as arguments. This calculus is highly expressive * Partially supported \nby the NSFGrant No. CCR-9988529 Permission to make digital or hard copies of all or part of this work \nfor personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. POPL 03, January 15 17, 2003, New Orleans, Louisiana, USA. Copyright \n2003 ACM 1-58113-628-5/03/0001 ...$5.00. and can be used as both a logic and as a programming lan\u00adguage. \nSeveral widely used proof assistants, e.g. Coq and LEGO, are basedonextensions of CC. Researchers have \nfound the need to use coercive subtyping in proof assistants in order to reuse de.nitions and proofs[3, \n21]. Coercion inference algorithms have been implemented in LEGO[2] and Coq[24]. But few formal studies \nexist for the moment, with the exception of the work of Alex Jones, Zhaohui Luo and Sergei Soloviev[15], \nwhich will be discussed later. The assertion that the type A can be coerced to the type B by the coercion \nc can be represented by the judgment: c : A = B The study of coercion concerns the following questions: \nQuestion 1. What is the meaning of such a coercive subtyping judgment? The term coercion has been used \nin somewhat di.erent senses by di.erent researchers. For example, c can be just an encoding of the derivation \nof A = B(e.g. [13]), or a term inhabited in A . B(e.g. [21]). In this paper, we follow [17, 18] and consider \nthe coercive subtyping as restricted linear implication . First of all, c should be a function from A \nto B; secondly, c should behave like an identity function. Formally, these requirements can be represented \nas: c : A . B . erase(c) . . .x.x (*) where erase is a function which erases the type information of \nc,and . . denotes zero or more steps of .-reduction. The right part of (*) formalizes the linearity of \nthe implication. Question 2. What is an ideal coercive subtyping system? First, the system should be \nsound, meaning that, any judgment derivable from the system should satisfy (*). Sec\u00adond, it should be \ncomplete, that is, any judgment satisfy\u00ading (*) should be derivable. Third, it should be coherent, that \nis, coercions should be unique. More precisely, if both c : A = B and d : A = B are derivable, then c, \nd should be equivalent in some sense. Fourth, it is preferable to for\u00admulate the subtyping system so \nthat it has the transitivity elimination property. Among other things, systems with such a property are \nsuitable for the meta-theoretical study. All the above points can be summarized as follows: 1. Subtyping \nas implication: G . c : A = B . G . c : A . B 2. Coercions erase to the identity: erase(c) . . .x.x \n 3. Completeness of coercive subtyping: G fc : A .B .erase(c) . . .x.x .G fc : A =B 4. Admissibility \nof transitivity  c : A =B .d : B =C ..e. e : A =C 5. Coherence of coercions: G fc : A =B .G fd : A =B \n.c =R d where =R is some notion of coercion equivalence. In [17, 18], it is shown that the subtyping \nsystem COl (an extension of System-Fwith coersive subtyping) has all the above properties, so we will \nrefer to this set of properties as the LMS framework , which provides guidance in building the coercive \nsubtyping system. Our work will follow this framework. Question 3. What is the coercion inference? The \nidea of coercion inference has been explored by sev\u00aderal authors [2, 24, 21] etc. under the notion of \nImplicit coercion . To understand it, consider a term, say f(c(a)), where c is a coercion. In most situations, \nusers prefer to write just the coercion-free term f(a); a coercion inference algorithm is expected for \ninserting the missing coercion c. In this work we give a formalization of this notion of co\u00adercion inference. \nRoughly speaking, the coercion inference problem is stated as, Given a context G and a term M,decideif \nthere are terms M',A such that the typing G fM' : A is derivable and M can be obtained by removing coercions \nfrom M'. A more formal presentation, which will be found in this pa\u00adper, will make clear the procedure \nof removing coercions . Such a formulation allows us to state and to prove the sound\u00adness and completeness \nof the coercion inference algorithm. In the rest of this section, we explain how to construct the coercive \nsubtyping system in order to achieve the 5 require\u00adments of the LMS framework. The formal system .Cco \nwill be presented in the next sec\u00ad = tion, followed by an example of an application of coercive subtyping \nin formalized mathematics (Sect. 3) . In Sect. 4, we show that the coercive subtyping system is sound \nwith respect to the semantics (*) and we establish the equiva\u00adlence between .Cco and CC\u00df., the latter \nis CC with \u00df.\u00ad = conversion[14]. From this equivalence, it follows that .Cco = has all the nice properties \nof CC\u00df. such as con.uence, sub\u00adject reduction, and strong normalization. In Sect. 5, we study the completeness \nof coercions, from which the tran\u00adsitivity elimination can be derived. In Sect. 6, we describe an algorithmic \ncoercive subtyping and typing system, and de.ne formally the problem of coercion inference. Then we give \na coercion inference algorithm and show that it is sound and complete. In Sect. 7, we describe the anti-symmetry \nof the subtyping relation, and the coherence of coercion. The proofs for these results are only sketched, \nthe detailed proofs can be found in [11]. Finally, we summarize this work and discuss the related works. \nNow we discuss the design decision for .Cco = . 1.1 Transitivity Elimination and .C= There are two purposes \nof this subsection. First, we ex\u00adplain how to construct a subtyping system in dependent type theory such \nthat it enjoys the transitivity elimination. Second, we brie.y recall the system .C=[10](or Part III \nof [11]) which is a subtyping extension to CC without coer\u00adcions. will be formed essentially by adding \ncoercions .Cco = to .C=. A notable obstacle to a proof theoretical study of a sub\u00adtyping extension to \na dependent type theory is the con.ict between type conversion and transitivity elimination. A de\u00adpendent \ntype (also called a type family) is actually a type\u00advalued function, it induces the \u00df-conversion between \ntypes. If two types are convertible, then intuitively they denote the same set of values and, in consequence, \neither type is a subtype of the other. This is usually represented by a conversion subtyping rule: A \n= \u00df B A =B Unfortunately, in the presence of this rule, in any non\u00adtrivial subtyping system1, the following \ntransitivity rule: A =CC =B A =B can not be eliminated2 . The explicit presence of such a transitivity \nrule makes it di.cult to check the subtyping relation. Furthermore, in a dependent type theory with subtyping, \nthis rule is an obsta\u00adcle to the proof of subject reduction. Our approach to re\u00adsolving the con.ict between \ntype conversion and transitivity elimination is to replace the conversion subtyping rule with two rules \nS-id and S-\u00df: S-id G fA =A A = \u00df B G fB =CC = \u00df D G fA, B, C, D : s S-\u00df G fA =D where G fA, B, C, D : \ns means that A, B, C, D are well\u00adformed and of the sort s. Such a treatment is independent of number \nof the \u00df-reductions. The remainder of this subsection completes the presenta\u00adtion of .C=. The primitive \nsubtyping declaration is intro\u00adduced into the context in the form: G,a =A :.x1:A1...xn:An.* where a is \na new variable, * is the sort intuitively denot\u00ading the class of all types, A is a dependent type of \nthe kind .x1:A1...xn:An.*, that is, it is a function taking n param\u00adeters and return a type. The whole \nsubtyping system consists of the above two sub\u00adtyping rules plus the rule S-. for subtyping between .-types \n1A subtyping system is a set of subtyping rules. A trivial subtyping system is a subtyping system in \nwhich A =B implies A = \u00df B. 2Assume that there are no redundant rules in the subtyping system. and the \nrule S-G for the application of primitive subtyping: G f A ' = A G,x : A ' f B = B ' S-. G f .x:A.B = \n.x:A ' .B ' G f PM1..Mn = Aa = P . G S-G G f aM1..Mn = A A subtyping checking algorithm is obtained by \nchanging S-\u00df to S-\u00df ' : A . \u00df B G f B = CC . \u00df D S-\u00df ' G f A = D This rule does not contain a sorting \ncondition because the well-formedness of A, D implies that of B and C.There\u00adfore, in the subsumption \nrule, the well-formedness condition will ensure that all types in a subtyping derivation are well\u00adformed. \nSince the algorithmic subtyping system does not have typing judgments in the assumptions, it is independent \nfrom the typing system. .C= enjoys many nice properties, including con.uence, subject reduction, strong \nnormalization and decidability of subtyping and typing(see [10] and Part III of [11]). .C= is suitable \nto model theory reuse and proof reuse in proof assistants. For example, one can formulate and prove the \nassertion that any monoid theorem is a group theorem whose proof is actually a program which transforms \nproofs of monoid theorems into those of the corresponding group theorems. Next we analyze how to add \ncoercions into .C=. 1.2 Coercion as Restricted Linear Implication In the previous subsection, we have \nexplained how to for\u00admulate the subtyping system so that it enjoys the transi\u00adtivity elimination and \nwe have presented .C=.Now, we want to analyze how to construct a coercive subtyping sys\u00adtem in which: \n1. coercive subtyping becomes a special case of typing with the arrow type; 2. coercions behave like \nthe identity function. This is also called coercion as restricted linear implication . First, the system \nshould be formulated in such a way that coercive subtyping corresponds to typing in arrow type: c : A \n= B . c : A . B To this aim, two problems needs special consideration: one is how to make coercive subtyping \nbetween .-types, another is how to introduce primitive coercive subtyping into contexts. 1.2.0.1 Coercive \nSubtyping for .-types. We begin by formulating a coercive subtyping rule for subtyping between arrow \ntypes, which is a special case of .-type. c : C = Ad : B = D .f:(A.B)..x:C.d(f(c(x))) : A . B = C . D \nIt is easy to verify that c : C . A . d : B . D . .f:(A.B)..x:C.d(f(c(x))) : (A.B).(C.D) A naive generalization \nfrom such a rule to a coercive sub\u00adtyping rule between .-types would be: G f c : C = A G,x : C f d : \nB = D G f .f:.x:A.B..x:C.d(f(c(x))) : .x:A.B = .x:C.D Unfortunately, the property of subtyping as arrow \ntype is lost: G f c : C . A . G,x : C f d : B . D . G,f :.x:A.B, x : C f f(c(x)) : B[x := c(x)] .G f \n.f:.x:A.B..x:C.d(f(c(x))) : .x:A.B..x:C.D . To solve this problem, we change the second assumption in \nthe rule. The rule becomes: G f c : C = A G,x : C f d : B[x := c(x)] = D G f .f:.x:A.B..x:C.d(f(c(x))) \n: .x:A.B = .x:C.D This is consistent with the subtyping as arrow type principle. 1.2.0.2 Primitive Coercive \nSubtyping. Now we study the problem of how to interpret the primi\u00adtive coercive subtyping. Recall that, \nin .C=, primitive subtyping is introduced into the context in the form a = A :.x1:A1..xn:An.* where a \nis a new variable. Primitive coercive subtyping can be formed by adding a new coercion variable to such \na declaration: c : a = A :.x1:A1..xn:An.*.In this declaration, a and A are type-valued functions, so \na = A can not be interpreted as arrow type: c : a = A .c : a . A . So can c still be interpreted as typable \nterm? Assume M1 : A1,M2 : A2[x1:=M1], .., Mn : An[x1:=M1, .., xn-1:=Mn-1], then aM1..Mn and AM1..Mn are \ntypes (terms of kind *). We have cM1..Mn : aM1..Mn . AM1..Mn This suggests that c can be typed as: c \n:.x1:A1..xn:An.(ax1..xn.Ax1..xn) Such a typing declaration establishes a relationship between the coercive \nsubtyping system .Cco and the original CC. In = order to make such a relation explicit, we introduce \na new rule Sub2Imp into the typing system: c : a = P :.x1:A1...xn:An.* . G G f c :.x1:A1...xn:An.(ax1..xn \n. Px1..xn) Thus, we can establish the equivalence between .Cco and = CC\u00df.. 1.2.0.3 .-conversion. If \n.-conversion is added to a subtyping system without coercions, such as .C=, then con.uence will be lost. \nBy comparison, a coercive subtyping system does not have this problem, see [21] for an example and discussions. \nFor a coercive subtyping system, .-conversion is also nec\u00adessary to ensure the coherence. Consider, for \nexample, the coercive subtyping judgment c :(A . B) = (A . B). It may be derived by using the rule S-id \nor S-.. Then c may be either idA.B or .f:A.B..x:A.idB (f(idAx)), where idA = .x:A.x etc. The two terms \nare not \u00df-convertible, but \u00df.-convertible. Thus, .Cco will be based on CC\u00df.[14]. Geuver has shown = that \nCC\u00df. has nice properties: con.uence, subject reduction and strong normalization. By the equivalence between \n.Cco = and CC\u00df., which will be proved later, these properties are inherited by .Cco = .   2. DEFINITION \nOF .CCO = First, types and terms of .Cco are the same as in CC\u00df.. = Definition 2.1 (Types and terms of \n.Cco = ). The set of pre-expressions of .Cco = , denoted by T, is de.ned as fol\u00adlows T ::= V|S|TT |.V:T.T|.V:T.T \nS ::= * |. where Vis the collection of variables, and where * and . are called sorts. Intuitively, * \nand . represent the set of types and kinds, respectively. Contexts of .Cco are as .C= except that primitive \ncoer\u00ad = cive subtyping declarations are added in the form c:x=A:K. Definition 2.2 (Context). A declaration \ntakes one of two forms: 1) x : A with A .T and x .V,and 2) c:x=A:K with A, K .T and c, x .V. In both \nforms of declarations, c, x are the subjects. c is the atomic coercion in c:x=A:K.A pre-context is a \n.nite linearly ordered list of declarations, all with distinct subjects. The empty context is denoted \nby <>. G is a well-formed context (or legal context) if G fA : B is derivable by the typing rules de.ned \nbelow (Def. 2.6). In the declaration c : x =A : K,both x and c are ac\u00adtually constants because they will \nnot be used as quanti.ed variables in, for example, .x:A.B or .x:A.M. Sometimes we will use a instead \nof x. Definition 2.3 (Judgments). There are two forms of judgments: G fA : B Typing judgment G fc : A \n=B Coercive subtyping judgment We use A, B, C.., M, N, .., a, b, ... for arbitrary pre-expressions (or \npre-terms), G, .... for precontexts, x, y, z, ... for arbitrary variables. Letters s, s1,s2,.. are sorts \nranging over {*, .}. Definition 2.4 (Reduction). The \u00df-reduction and .\u00adreduction on T are the compatible \nclosures of the following notions of reduction respectively: (.x:A.B)C .\u00df B[x:=C] .x:A.Mx .. M if x ..Fv(M) \n.\u00df. =.\u00df .... In the following, we will use . R and =R to denote re.exive, transitive closure of the reduction \n.R, .R ..R respec\u00adtively. Conventions and abbreviations are listed in the following. Notation 2.5. Suppose \nthat G is a pre-context, M, A, B, Ai, Bi, i =1..n are pre-expressions. G(a) = B if c : a =B .G Fv(A) \n= the set of free variables in A Domv (G) ={x |x : A .G} Domco(G) ={c |c : a =A : K .G} Dompt(G) ={a \n|c : a =A : K .G} Dom(G) = Domv (G) . Domco(G) .Dompt(G) x .G = x .Dom(G) c .G(n) . c : a =A :.x1:A1...xn:An.* \n.G x .M . x .Fv(M) nfR(M) = R normal form of M G fA : B : C . G fA : B . G fB : C G fA1, .., An : B . \nG fA1 : B . \u00b7\u00b7\u00b7 . G fAn : B G fc : A =B : s . G fc : A =B . G fA, B : s G fA = \u00df. B : C . A = \u00df. B . \nG fA, B : C Variables in a context G can be divided into three parts. Domv(G) are true variables which \nwill be used in quan\u00adti.cation; the set Dom(G) \\ Domv (G) is actually the set of constants. Domco(G) \nare primitive coercions, Dompt(G) are primitive subtypes. The .Cco typing rules are as the typing rules \nof CC\u00df.(CC = with \u00df.-reductions, [14]) except for start=, weakening=, subsumption and Sub2Imp, which \nwill be explained below.  Definition 2.6 (.Cco typing rules). Typing judgments = are de.ned by the following \nrules. Letters s, s1,s2 range over {*, .}. axiom <> f* : . G fA : s1 G,x : A fB : s2 (s1,s2) rule G \nf.x:A.B : s2 G fA : sx ..G start G,x : A fx : A G fA : K : . c, x ..G start= G,c : x =A : K fx : K G \nfA : B G fC : sc,x ..G weakening G,x : C fA : B G fA : B G fD : K : . x ..G weakening= G,c : x =D : K \nfA : B G fF :.x:A.B G fa : A application G fFa : B[x:=a] G,x : A fb : B G f.x:A.B : s abstraction G f.x:A.b \n:.x:A.B G fa : A G fc : A =B : s subsumption G fc(a): B G fa : A G fA = \u00df. B : s conversion G fa : B \nc : a =P :.x1:A1...xn:An.* .G Sub2Imp G fc :.x1:A1...xn:An.(ax1..xn .Px1..xn) start= and weakening= introduce \nthe primitive coercive subtyping into the context. The rule Sub2Imp explicitly gives the type for the \nprimitive coercion. Thus, the sub\u00adtyping declaration c : a = P :.x1:A1...xn:An.* can be viewed as two \ntyping declarations a :.x1:An...xn:An.* and c :.x1:A1...xn:An.(ax1..xn . Px1..xn), where c, a should \nbe taken as constants. Therefore, the contexts are essentially the same as those in CC\u00df. (with declarations \nof constants). In some coercion-free subtyping systems, e.g. .P=[1], ..= and .C= , the subsumption rule \nreplaces the conver\u00adsion rule. In the presence of coercions, the conversion rule can not be eliminated. \nConsider the following declaration: A = \u00df. B G fM : A G f.x:A.x : A =B subsumption G f(.x:A.x)M : B \nWithout the conversion rule, the judgement G fM : B is not provable and subject reduction will fail. \nNext, we present the coercive subtyping rules. Definition 2.7 (Coercive subtyping rules). G fc : A ' \n=A : s ' G,x : A fB : s S-.G,x : A ' fd : B[x:=c(x)] =B ' : s G f.f:.x:A.B..x:A ' .d(f(c(x))) : .x:A.B \n=.x:A ' .B ' G fc : PM1..Mn =A : *d : a =P .G S-GG faM1..Mn : * G f.x:(aM1..Mn).c((dM1..Mn)x): aM1..Mn \n=A G fA : s S-id G f.x:A.x : A =A G fA = \u00df. B : s G fc : B =C G fC = \u00df. D : s S-\u00df. G fc : A =D where \ns ranges over {*, .}. Observe that a coercion is always of the form: .x:A.M. Judgments of the form G \nf A : s are called sorting con\u00additions. The presence of these conditions in the subtyping rules ensures \nthat: G fA =B . G fA, B : s When it is clear from the context, the sorting conditions will be omitted. \nSome important admissible rules are: Re.exivity G fA, B : s . A =\u00df. B . G f.x:A.x : A =B Transitivity \nG fc : A =B . G fd : B =C . G fA, B, C : s ..e. e =\u00df. .x:A.d(c(x)) . G fe : A =C Application of primitive \ncoercive subtyping c :(a=A :.x1:A1...x1:An.*) . G . G fMi[x1 := M1, .., xi-1 := Mi-1]: Ai i =1..n ..e. \ne = \u00df. cM1..Mn G fe : aM1..Mn =AM1..Mn The .rst and the third property can be easily veri.ed. The admissibility \nof transitivity will be proved later. The system .Cco can be viewed as a reformulation of CC\u00df.. The precise \nrelation between the two will be pre\u00adsented in Section 4.1. =  3. EXAMPLE There is a growing interest \nin using subtyping in proof assistants. The objective is for theory and proof reuse[20, 21]. We present \nhere an example, adapted from Saibi[24], of using coercive subtyping for representing groups based on \nthe representation of monoids. A coercion free version of this example has been appeared in [10] and \n[11](Part III). Recall that a monoid has a carrier set, a binary opera\u00adtion, a unit element and three \naxioms. In CC, the monoid structure can be encoded as: M : * S : M.* Op :.M:M.S(M) .S(M) .S(M) E :.M:M.S(M) \nIdL :.M:M..x:S(M).Op(E(M),x)= x IdR : \u00b7\u00b7\u00b7 Assoc : \u00b7\u00b7\u00b7  where Mis the type of monoids (intuitively, \nit is the set of names of monoids). Given a monoid M : M, S(M)is the carrier set of M. Op(M)and E(M) \nare binary operation and the unit member of M respectively. Assoc, IdR, IdL are monoid axioms. The typing \nfor IdR and Assoc are omitted3 . The theorem that the multiplication of units is equal to the unit (e \n\u00b7e = e)is provable: G fp :.M:M.Op(M)(E(M),E(M)) = E(M) where p = .M:M.IdR(M)(E(M)). Similarly, the group \nstructure can be represented in CC by introducing the type G: * for groups and a corresponding set of \ndeclarations. For example, IdR should be adapted to: IdRG :.G:G..x:G. Op(G)(x, EG(G)) = x Obviously, \nthere is a signi.cant redundancy in this rep\u00adresentation. An alternative way is to de.ne group as the \nextension of monoid by certain components. In .C=,this can be realized as: G =M Inv :.G:G.S(G) .S(G) \n... Given a group G : G, S(G) is well typed and it denotes the carrier set of G. Monoid operators Op, \nE and axioms Assoc, IdR, IdL are all applicable to elements of G. Inv is the inverse operator, whose \naxioms are omitted. In .Cco = , the group structure can be represented as c : G=M Inv :.G:G.S(c(G)) .S(c(G)) \n... This representation is not as succinct as the previous one. But if we remove the coercions in the \nsecond representation, we get exactly the .rst representation. In practice, we can allow user to write \nexpressions without explicit use of coer\u00adcions, then apply a coercion inference procedure to derive the \ncorresponding expressions in the coercion system. Co\u00adercive subtyping systems have been used in LEGO \nand Coq because they do not need to modify the underlying theories. 3The construction of concrete monoids \ncan be implemented by using a constructor, whose arguments are of the types of the components of monoid \nand whose returned value is of the type M. The technique is the same as in [24]. The coercion inference \nproblem will be formalized in Sect. 6, where a coercion inference algorithm is presented along with the \nproofs of its soundness and completeness. In [10] and [11](Part III), we have also shown how to turn \nthe monoid theorem e \u00b7e = e to a group theorem and we prove a meta-theorem any monoid theorem is a group \nthe\u00adorem . These results can be easily adapted in this coercive subtyping system.  4. SOUNDNESS OF COERCION \nThe soundness of coercions has two aspects: 1. coercive subtyping should correspond to typing in arrow \ntype; 2. co\u00adercions should behave like the identity function. This section studies these two problems \nin .Cco For the former, we show = . a stronger result: .Cco is equivalent to CC\u00df. in typing. = 4.1 Equivalence \nbetween .Cco and CC\u00df. = In this subsection, we will establish the equivalence be\u00adtween .Cco and the variant \nof CC\u00df. with constants. The = set of constants, denoted by C, is a subset of variables: C .V, such that \nconstants are never used in quanti.ca\u00adtions. The intention is that the set C corresponds to the union \nof Domco(G) and Dompt(G) in .Cco Formally, this = . can be realized by the following modi.ed (s1,s2) \nrule and abstraction rule: G fA : s1 G,x : A fB : s2 x ..C (s1,s2)rule G f.x:A.B : s2 G,x : A fb : B \nG f.x:A.B : sx ..C abstraction G f.x:A.b :.x:A.B In the sequel we shall adopt the convention that CC\u00df. \nmeans CC with \u00df.-conversion and constants. Observe that, if c : a =P : K is a subtyping declaration in \nacontext, then K must be of the form .x1:A1...xn:An.*. The transformation function Ffrom contexts of \n.Cco to = those of CC\u00df. is de.ned as follows. Definition 4.1 (Transformation F). The function F which \ntransforms a .Cco context to a CC\u00df. context is re\u00ad = cursively de.ned as follows, let K =.x1:A1...xn:An.*: \nF(<>)= <> F(G,x : A)= F(G),x : A F(G,c : a =P : K)= F(G),a : K, c :.x1:A1...xn:An.(ax1..xn.Px1..xn) Let \nF(G) fC A : B denote the CC\u00df. judgment, in which elements of the set {c, a |c : a =P :.x1:A1...xn:An.* \n. G}are taken as constants. .Cco We will show that, under this transformation, = is equivalent to CC\u00df.. \nFirst, .Cco can be viewed as a subsystem of CC\u00df.. = Proposition 4.2 (.Cco into CC\u00df.). = G fc : A =B .F(G) \nfC c : A .B G fA : B .F(G) fC A : B Proof. Simultaneous induction on the derivation of G f c : A =B and \nG fA : B. On the other hand, it is obvious that F(G) fC A : B .G fA : B Thus we have the equivalence \nbetween .Cco and CC\u00df. = G fA : B .F(G) fC A : B It follows that, subtyping in .Cco is a special case \nof arrow = type G fc : A =B . G fc : A .B In his thesis[14], Geuvers has shown that CC\u00df. enjoys many \nnice properties. By means of the typing equivalence between .Cco and CC\u00df. and the natural correspondence \n= of \u00df.-reduction between the two systems, these properties are valid for .Cco The most important results \nconcerning = . \u00df.-reduction are: con.uence, subject reduction and strong normalization.  4.2 Coercion \nas identity function The intuition that coercions should behave like the iden\u00adtity function is usually \nformalized in the following way: 1. de.ne an erase function which, intuitively, removes all type information \nof a term; 2. show that the erasure of a coercion will be .-reduced to the type-free function .x.x. For \nthe .rst task, we de.ne an erase function. Its de.\u00adnition is based on the same principle as that of Col.One \ndi.erence is that, in Col, a term of form MA,where A is a type, will be erased to erase(M). In this system, \nit will only be erased to erase(M)erase(A). This is because there is actually no strict di.erence between \ntypes and terms in CC and types can have reductions. The de.nition of erase function in .Cco is thus \nde.ned as: = Notation 4.3 (Erase). Given a well-formed context G,a variable x, the function eraseG,x \n is inductively de\u00ad.ned as follows, eraseG,x(y)= y eraseG,x(dM1..MnN)= eraseG,x(N) G(n) if x ..Fv(M1, \n.., Mn) .d . eraseG,x(MN)= eraseG,x(M)eraseG,x(N) if MN is not of the above form eraseG,x(.y:A.M)= .y.eraseG,x(M) \nif x ..A .eraseG,y(M) .=. eraseG,x(M)= . otherwise where it is assumed that on the right sides of all \nequalities, we have eraseG,x(N) ... =.and eraseG,x(M)=. eraseG,x(M)=.implies that x appears in a type \nlabel or in a primitive subtyping. In such a case, M can not be considered as a legal coercion. The conditions \nx ..Mi and x ..A ensure that the erasure of M is essentially linear: Lemma 4.4 (Linearity of erasure). \neraseG,x(M) . . x . x .Fv(M) .x appears in M exactly once This property is essential in the proof of \nthe completeness of coercions. The erasure of a coercion in .Cco may not be .-reducible = to an identity \nfunction because coercions might contain \u00df\u00adredexes. Consider the following coercion derived by using \nS-.: .f:.x:A.B..x:A ' .(.y:A.y)f(.y:B.y):.x:A.B=.x:A.B The \u00df-redexes of the coercion are preserved in \nits erasure: .f..x.((.y.y)f)(.y.y), which can not be .-reduced to the identity term .f.f. However these \n\u00df-redexes are the only applications of the identity function. So we introduce id-reduction: (.x.x)N .id \nN The .id-reduction is de.ned as ..id = .. ..id.The erasure of a coercion can be .id-reduced to an identity4: \nProposition 4.5 (Coercion as identity function). G f.x:A ' .M : A =B .eraseG,x(M) . .id x  5. COMPLETENESS \nOF COERCIONS This section investigates the inverse of the previous result, that is, if G fc : A .B can \nbe derived, and the erasure of c is .-reducible to .x.x,then G fc : A =B is derivable. This result is \ncalled the completeness of coercions, intuitively it means that all semantically acceptable coercions \nare deriv\u00adable by the coercive subtyping rules. The whole proof of this fact is long, an outline of the \nproof is given below. We refer the interested reader to the Part IV of [11] for more details. One di.culty \nof studying the completeness of .Cco coer\u00ad = cionsisthat coercions maynot be in \u00df-normal form. So it \nis di.cult to analyze the form of a coercion. To get around of this problem, we change to the LMS style \ncoercion judgment and construct a corresponding coercion system. In [17, 18], a coercion judgment takes \nthe form: x : A fco M : B It reads: A is a subtype of B with coercion M. This judg\u00adment corresponds to \na .Cco subtyping judgment: = G fc : A =B s.t. c = \u00df. .x:A.M The advantage of a coercive subtyping system \nin LMS style is that a coercion term is almost in \u00df-normal form. This facilitates the proof of completeness \nof coercions. The proof of .Cco completeness proceeds in following steps: = 1. De.ne a LMS style coercion \nsystem 2. Show that it is equivalent to .Cco  = 3. Prove that it enjoys the completeness of coercion \n 4. Prove the completeness of .Cco coercion  = First, the LMS style coercive subtyping system for .Cco \n= is de.ned as: L-id G,x : A co x : A G,x : B co M : CC A = \u00df. B = \u00df. D L-\u00df. G,x : A co M : D co M : \nA G,x : A ' G,x : A ' ,y : B[x:=M] co N : B ' L-. G,f :.x:A.B co .x:A ' .N[y:=f(M)] : .x:A ' .B ' G,y \n: PM1..Mn co N : Ad . G(n) L-G G,x : aM1..Mn co N[y:=dM1..Mnx]: A 4Observe that a subtyping judgement \nis always of the form G f.x:A ' .M : A =B where A ' = \u00df. A. where sorting conditions are omitted. Coercions \nare almost in \u00df-normal form. More precisely, the only \u00df-redex in a coercion appears either in type labels \nG(n) or in terms of form cM1..Mn where c .. On the other hand, given a normalized term M in CC\u00df.,if its \nerasure is .-reduced to the identity then typically M will take the form: M =.y1:A1...yn:An.(cn(cn-1..(c1(c0x)M1)..Mn-1)Mn) \nG(k) where ci is of the form dN1..Nk .d .. This allows to prove the completeness of coercions for LMS \nstyle subtyping system: Lemma 5.1. G,x : A fM : B .eraseG,x(M) . . x .M =nf\u00df (M) .x ..Fv(B) co M : B \n. G,x : A f By means of the equivalence between .Cco and LMS style = system: G fc:A=B ..M. G,x:A fco \nM:B .c = \u00df. .x:A.M G,x:A fco M:B ..c. G fc:A =B .c = \u00df. .x:A.M we obtain the completeness of coercions \nfor .Cco = : = ). Theorem 5.2 (Completeness of coercions in .Cco G f.x:A ' .M : A .B .eraseG,x(M) . \n. x .M =nf\u00df (M) '' ' ..c. G fc : A =B ..x:A ' .M = \u00df. c By means of completeness, we can give an indirect \nproof of transitivity elimination. The idea is again from [17, 18]. Theorem 5.3 (Admissibility of transitivity). \nG fc:A=B:s .G fd:B=C:s ..e. G fe:A=C where e =\u00df. .x:A.d(c(x)).  6. COERCION INFERENCE One of the main \nobjectives of coercive subtyping is to al\u00adlow the user to write coercion-free terms so that the program \ncould be succinct. For example, given a function f : A .B, aterm a : A ' and a coercion from A ' to A: \nc : A ' =A,the user is allowed to write f(a). To type check this term, the coercion inference algorithm \nshould insert a coercion c into f(a)to get f(c(a)) : B. Intuitively, the coercion inference problem can \nbe stated as: GivenacontextG andaterm M, decide whether there exist terms M ' ,A such that the judgment \nG fM ' : A is derivable and M can be obtained by removing coercions from M ' . The fact that a well-formed \nterm M ' is obtained from M by inserting coercions is represented by the judgment: G fM<< M ' : A G We \nintroduce the coercion reduction .co which removes primitive coercion applications: G(n) dM1..MnN .co \nNwhere d .G The meaning of the Coercion Inference Judgment can be formally stated as: '' ' . G G fM<< \nM : A . M co M . G fM : A The Coercion Inference Problem is thus: Given G,M, .nd M ' ,A such that G fM<< \nM ' : A The .rst step of coercion inference is to check coercive subtyping, which is realized by the \nalgorithmic coercive sub\u00adtyping system. Similar to .C=,this system is formed by replacing in the subtyping \nsystem the S-\u00df. rule by: A . \u00df. B G fA c : B =CC . \u00df. D SA-\u00df. G fA c : A =D where G fA c : A = B denotes \nthe algorithmic coercive subtyping judgment. It is routine to verify that this algorithmic subtyping \nsys\u00adtem is sound and complete with respect to the subtyping system and it is terminating. The coercion \ninference algorithm is realized by a set of rules which derives the coercion inference judgment G f M<< \nM ' : A. This set of rules are modi.ed from typ\u00ading rules. A typical example of a coercion inference \nrule is the rule for the application term: G fF<< F ' : C G fd : C =.Lub .x:A.B I-App G fa<< a ' : A \n' G fA c : A ' =A '' ' G fFa<< d(F )(c(a )) : B[x:=c(a )] Given a coercion term Fa, we .rst derive the \ncoercion expansions of its two subterms F ' ,a ' and their types C, A ' , then, use the judgment =.Lub \nto .nd the least . type upper bound for C, which is assumed to be .x:A.B, and derive the coercion c : \nA ' =A. We obtain that the coercion expansion '' ' of Fa is d(F )(c(a )) and its type is B[x:=c(a )]. \nBecause of space limitation we do not present the whole coercive subtyping system and coercion inference \nsystem here; the interested readers are invited to consult[11]. The coercion inference system is sound \nand complete: Proposition 6.1 (Soundness). ' '' . G G fM<< M : A . G fM : A . M co M Theorem 6.2 (Completeness \nof coercion inference). G fM : A . M . G M ' co ..Aa,Ma,c s.t. G fM ' << Ma : Aa . G fc : Aa =A . cMa \n= \u00df. M The completeness implies that the result (M ' ) obtained from the coercion inference is minimal. \nProposition 6.3 (Decidability). Given M, G, the proposition .N, A s.t. G fM<< N : A is decidable.  7. \nCOHERENCE AND ANTI-SYMMETRY The coherence of coercion means the uniqueness of sub\u00adtyping derivation, \nformally, it asserts that all coercions for the same subtyping judgment A = B are \u00df.-convertible. The \nproof of this result is tricky and takes several pages, we only sketch the main steps here. We refer \nthe interested reader to the Part IV of [11] for more details. First, it is necessary to prove a special \ncase of coherence when A and B are convertible: A = \u00df. B .G fc : A =B . c = \u00df. .x:A.x The hard part of \nits proof is to show that any judgment of the following form can not be derived: G fc :G(a)M1..Mn =aM1..Mn \nTo prove this fact, we use the algorithmic coercive sub\u00adtyping system. First, we observe that a proof \nfor such a judgment could be characterized by a sequence: G(a)M1..Mn . \u00df. a1N11..Nk1 1 = G(a1)N11..Nk1 \n1 . \u00df. a2N12..Nk2 2 = \u00b7\u00b7\u00b7 =G(am)N1 m..Nkm m . \u00df. aM1..Mn That is, the derivation is started with S-id \nand followed by alternative applications of S-G and SA-\u00df.. Then, we show that there should be at least \none ai in this sequence such that ai occurs before a in the context G. Finally, by induction on the position \nof a in the context G, it is proved that such a sequence can never be constructed. Having proved the \ncoherence for convertible subtyping, the anti-symmetry and coherence can be established. Proposition \n7.1 (Anti-symmetry and coherence). G fe : A =B . G fe ' : B =A . A = \u00df. B G fe1 : A =B . G fe2 : A =B \n. e1 = \u00df. e2 8. RELATED WORKS 8.0.0.4 Coercions. The notion of coercion was .rst introduced in [5] as \nthe semantical interpretation of the subtyping relation in the PER model of Bounded Fun[7], a subtyping \nextension of second order lambda calculus. Intuitively, in their work, the meaning of A =B is an identity \nfunction (more precisely a morphism in PER) from the interpretation of A (a PER) to that of B. In [13] \ncoercions are used for proving the coherence of subtyping, that is, the uniqueness of subtyping derivation. \nAs coercions are used to encode subtyping derivation, so that the coherence is proved via the coercion \nconversions. This technique of proving coherence has been followed by several authors, for example, [8]. \nBy means of coercions, in [4], the meaning of terms in Bounded Fun is given by their translations in \nthe original second order lambda calculus (without subtyping). In their approach, the subtyping relation \nA = B is interpreted as the typing relation c : A .B where c is the coercion term. They have also proved \nthe uniqueness of the translation, that is, the uniqueness of coercions. [22] also considers coercions \nto be a kind of type manip\u00adulation operations, which do not change the functional be\u00adhavior of its argument. \nThis is characterized by an erase function such that erase(c) is the result of erasing all type information \nof c. c is a coercion is thus formally expressed as erase(c) .-reduces to untyped identity . The subtyping \nsystem Col in [17, 18] contains most essen\u00adtial coercion properties: subtyping as implication; coercion \nerasing to identity; completeness of coercions; transitivity elimination and coherence of coercions. \nThe adaptation of LMS framework to the present work is not straightforward due to the type conversions \nwhich are not present in system F. In particular, the proof of anti-symmetry requires new technique. \nAnother important issue which has not been ad\u00addressed in their work is the problem of coercion inference. \nWe have not only formalized this problem but given a sound and complete coercion inference algorithm. \nThe researches cited above concern only coercions in sec\u00adond order .-calculus. Motivated by the need \nof using coer\u00adcions in proof assistants, several authors have proposed to add coercions to dependent \ntype systems. [3] studied a form of coercions over PTS. [24] and [2] implemented coercions in Coq and \nLEGO respectively. Recently, signi.cant advance\u00adments have been achieved in the study of the the coercive \nsubtyping system for the Uni.ed Type Theory(UTT)[20, 21, 19, 25]. An important feature of this system \nis that it con\u00adtains inductive types. Many meta-theoretic properties, in\u00adcluding coherence and transitivity \nelimination, are proved. UTT[20, 21]. In a recent work, Alex Jones, Zhaohui Luo and Sergei Soloviev have \nproved a set of important meta\u00adtheoretical properties on a new version of such a system, including the \ncoherence of coercions and the soundness of a coercion inference algorithm[15]. A basic idea behind coer\u00adcive \nsubtyping in the sense of these authors is that subtyping provides a mechanism for notational abbreviation \nin type theory. Compared with their work, ours have, among oth\u00aders, two notable results: 1. the coercive \nsubtyping rules are semantically complete; 2. the coercion inference algorithm is complete. 8.0.0.5 \nTransitivity elimination. The importance of transitivity elimination has been dis\u00adcussed in Subsection \n1.1. Often, a subtyping system may contain several rules, which cause di.culty to the elimina\u00adtion of \nthe transitivity rule. An e.ective approach to over\u00adcome this problem is to reformulate an equivalent \nsubtyping system such that these culprit rules are replaced by some rules which do not prevent the elimination \nof transitivity. In [13], the rule of application of primitive subtyping has been reformulated. [17, \n18] proposed a rule to replace the rule .x:A.B = B[x := C]. In dependent type theory, there is a di.culty \ndue to subtyping between applications of depen\u00addent types. To overcome it, [23] has adapted the technique \nof [13] and realized a subtyping checking algorithm. [1] used the similar idea but they formulated a \nrule, which in.uenced the formulation of S-G in this work. Another culprit rule is what we called conversion \nsubtyping rule in Subsec\u00adtion 1.1. There has been two main approaches towards this problem. The .rst \nis to restrict the use of the transitivity rule, e.g.[3, 24, 16]. The second is to use an intermediate \nsubtyping system (often called algorithmic system) which are de.ned on types in normal forms, e.g. =[23, \n12] and F . .P=[1]. Such an approach needs to separate di.erent \u00df\u00adreduction, so the method is di.cult \nto extend to systems with more reductions, such as CC. [9] (or Part I of [11]) proposed a reformulation \nof .P=, named ..=. Among subtyping systems with dependent types, it is the .rst system de.ned on all \ntypes (not just on normalized types) such that the transitivity rule is not explicitly present but is \nadmissible. This work is extended in [10] and Part III of [11] where a subtyping extension to CC (.C=) \nis studied. As discussed in Subsection 1.1, in this system, the transitivity elimination is achieved \nby introduc\u00ading the rule S-\u00df. 8.0.0.6 Subtyping dependent types. There are a few subtyping extensions \nto dependent types without coercions. The idea of extending dependent type theory with subtyping has \n.rst appeared in [6]. with F . bounded quanti.cation has been studied in [23] and [12]. A subtyping extension \nto .rst order dependent type, called .P=, has been .rst proposed and investigated in [1]. Our system \nis in.uenced by their works in several aspects, no\u00adtably, the introduction of primitive subfamily relation, \nthe rule S-G (which contributes to the transitivity elimination for primitive subtyping), the derivation \nof .-type upper bound etc.  9. CONCLUSIONS AND FURTHER WORK Thecoercivesubtyping system .Cco is presented. \nWe = have investigated in the following aspects: 1. In the semantic aspect, coercive subtyping has been \ninterpreted as typing in arrow type and coercions be\u00adhave like identity function; By the formalization \npro\u00advided in this paper, .Cco is equivalent to CC\u00df. with = constants and the coercive subtyping system \nis seman\u00adtically sound and complete. .Cco 2. In the proof theoretic aspect, is shown to be = equivalent \nto CC\u00df. with constants. Therefore, .Cco = has nice properties like con.uence, subject reduction and strong \nnormalization. Besides, it enjoys properties speci.c to coercive subtyping: transitivity elimination, \nanti-symmetry and coherence. 3. In the algorithmic aspect, the notion of coercion infer\u00adence is .rst \nformalized and a coercion inference algo\u00adrithm is proposed. It is shown that the algorithm is sound, \ncomplete and terminating. This system provides a basis for using coercions in proof assistants to realize \ntheory reuse. We have not addressed the problem of bounded quanti.\u00adcation. For the application of subtyping \nin proof assistants, this feature does not seem to be necessary; but for the mod\u00adeling of object-oriented \nprogramming languages it is indis\u00adpensable. Another interesting line of investigation is to add inductive \ntypes to .Cco because proof assistants like LEGO = and Coq are based on extensions of CC with inductive \ntypes. Acknowledgment I am grateful to Zhaohui Luo for many helpful discussions, especially for his idea \nof de.nition reuse and proof reuse, and for his insight on the problem of .\u00adreduction. Thanks to Stefano \nBerardi for his comments on the formalization of the problem of coercion inference. Many thanks to anonymous \nreferees and to my wife Ping Hu. I am grateful to Paul Johnson at Berlitz for his help with my English. \nFinally, special thanks to my Ph.D supervisors Giuseppe Longo whose ideas on coercions provide the guid\u00adance \nof this work, and Giuseppe Castagna who has given me many helps during the preparation of my thesis, \nwhich contains the technical part of this work. 10. REFERENCES [1] D. Aspinall and A. Compagnoni. Subtyping \ndependent types. In Proc. 11th Annual Synposium on Logic in Computer Science, IEEE, pages 86 97, 1996. \n[2] A. Bailey. Lego with implicit coercions, 1996. draft. [3] G. Barthe. Implicit coercions in type systems. \nIn S. Berardi and M. Coppo, editors, Proceedings of Types 95, LNCS 1128, pp 1 15., 1995. [4] V. Breazu-Tannen, \nT. Coquand, C. Gunter, and A. Scedrov. Inheritance as implicit coercion. Information and Computation, \n93(1):172 221, July 1991.  [5] K. B. Bruce and G. Longo. A modest model of records, inheritance, and \nbounded quanti.cation. Information and Computation, 87:196 240, 1990. [6] L. Cardelli. Typechecking \ndependent types and subtypes. In Proc. of the Workshop on Foundations of Logic and Functional Programming, \nDecember 1987. [7] L. Cardelli and P. Wegner. On understanding types, data abstraction, and polymorphism. \nComputing Surveys, 17(4):471 522, December 1985. [8] G. Castagna. Object-Oriented Programming: A Uni.ed \nFoundation. Progress in Theoretical Computer Science. Birk\u00a8auser, Boston, 1997. ISBN 3-7643-3905-5. [9] \nG. Chen. Dependent type system with subtyping. Technical Report LIENS-96-27, Laboratoire d Informatique, \nEcole Normale Sup\u00b4erieure -Paris, 12 1996. Revised version in Journal of Computer Science and Technology, \nvol. 14, no. 1 (1999). [10] G. Chen. Subtyping calculus of construction, extended abstract. In The 22nd \nInternational Symposium on Mathematical Foundation of Computer Science, volume 1295. Springer-Verlag \nLNCS, August 1997. Bratislava, Slovakia. [11] G. Chen. Subtyping, type conversions and elimination of \ntransitivity. PhD thesis, Universit\u00b4e Paris 7, December 1998. [12] A. B. Compagnoni. Subtyping in F. \n. is decidable. Technical Report ECS-LFCS-94-281, LFCS University of Edinburgh, January 1994. and in \nCSL 94. [13] P.-L. Curien and G. Ghelli. Coherence of subsumption, minimum typing and the type checking \nin F=. Mathematical Structures in Computer Science, 2(1):55 91, 1992. [14] H. Geuvers. Logics and Type \nSystems.PhD thesis, University of Nijmegen, Netherlands, 1993. [15] A. Jones, Z. Luo, and S. Soloviev. \nSome algorithmic and proof-theoretical aspects of coercive subtyping. In Workshop on Subtyping, Inheritance \nand Modular Development of Proofs, September 1997. Durham, U.K. [16] M. Lillibridge. Translucent Sums: \nA Foundation for Higher-Order Module Systems.PhD thesis, CMU, May 1997. CMU-CS-97-122. [17] G. Longo, \nK. Milsted, and S. Soloviev. A Logic of Subtyping, extended abstract. In Logic in Computer Science (LICS), \npages 292 300. IEEE, 1995. San Diego, June 1995. [18] G. Longo, K. Milsted, and S. Soloviev. Coherence \nand transitivity of subtyping as entailment, 1998. Journal of Logic and Computation., vol. 10: 4, pp. \n493 526, August 2000. [19] Y. Luo and Z. Luo. Coherence and transitivity of subtyping in coercive subtyping. \nIn Proc.ofthe 8th Inter. Conf. on Logic for Programming, Ari.cial Intelligence and Reasoning (LPAR 01), \nHavana, Cuba., number 2250 in LNAI, 2001. [20] Z. Luo. Coercive subtyping in type theory. In CSL 96, \nthe 1996 Annual Conference of the European Association for Computer Science Logic, Utrecht, volume 1258 \nof LNCS, 1996. [21] Z. Luo. Coercive subtyping. Journal of Logic and Computation, 9(97-13), 1997. [22] \nJ. Mitchell. Polymorphic type inference and containment. Information and Computation, 76:211 249, 1988. \n[23] B. Pierce and M. Ste.en. Higher-order subtyping. In IFIP Working Conference on Programming Concepts, \nMethods and Calculi (PROCOMET), 1994. Full version in Theoretical Computer Science, vol. 176, no. 1 2, \npp. 235 282, 1997 (with a corrigendum in TCS vol. 184 (1997), p. 247). [24] A. Saibi. Typing algorithm \nin type theory with inheritance. In the 24th Annual SIGPLAN-SIGACT Symposium on principles of Programming \nLanguages, January 1997. Paris, France. [25] S. Soloviev and Z. Luo. Coercion completion and conservativity \nin coercive subtyping. Annalsof Pure and Applied Logic, 113(1-3):297 322, 2002.   \n\t\t\t", "proc_id": "604131", "abstract": "We present a coercive subtyping system for the calculus of constructions. The proposed system &#955;<i>C</i><sup><i>CO</i></sup>over&#8804; is obtained essentially by adding coercions and &#951;-conversion to &#955;<i>C</i><inf><i>&#8804;</i></inf>[10], which is a subtyping extension to the calculus of constructions without coercions. Following [17, 18], the coercive subtyping <i>c</i> : <i>A</i> &#951; <i>B</i> is understood as a special case of typing in arrow type <i>c</i> : <i>A</i> &#8594; <i>B</i> such that the term <i>c</i> behaves like an identity function. We prove that, with respect to this semantic interpretation, the proposed coercive subtyping system is sound and complete, and that this completeness leads to transitivity elimination (transitivity rule is admissible). In addition, we establish the equivalence between &#955;<i>C</i><sup><i>CO</i></sup>over&#8804; and <i>CC</i><inf><i>&#223;&#951;</i></inf>, this fact implies that &#955;<i>C</i><sup><i>CO</i></sup>over&#8804; has confluence, subject reduction and strong normalization. We propose a formalization of coercion inference problem and present a sound and complete coercion inference algorithm.", "authors": [{"name": "Gang Chen", "author_profile_id": "81100110827", "affiliation": "Boston University, Boston, MA", "person_id": "PP15022403", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/604131.604145", "year": "2003", "article_id": "604145", "conference": "POPL", "title": "Coercive subtyping for the calculus of constructions", "url": "http://dl.acm.org/citation.cfm?id=604145"}