{"article_publication_date": "01-15-2003", "fulltext": "\n Ef.cient Algorithms for Isomorphisms of Simple Types Yoav Zibin Joseph (Yossi) Gil Jeffrey Considine \nTechnion Israel Institute of Technion Israel Institute of Boston University Technology Technology zyoav@cs.technion.ac.il \nyogi@cs.technion.ac.il jconsidi@cs.bu.edu ABSTRACT The .rst order isomorphism problem is to decide whether \ntwo non\u00adrecursive types using product-and function-type constructors, are isomorphic under the axioms \nof commutative and associative prod\u00aducts, and currying and distributivity of functions over products. \nWe h BWwtson syow B h BWw B show that this problem can be solved in time and w space, where is the input \nsize. This result improves upon the h BWwyson hw Bh BWwyB time and space bounds of the best previous \nh BWw B algorithm. We also describe an time algorithm for the lin\u00adear isomorphism problem, which does \nnot include the distributive h BWwtson hw B axiom, whereby improving upon the time of the best previous \nalgorithm for this problem. Categories and Subject Descriptors F.4.1 [Mathematical Logic and Formal \nLanguages]: Mathemat\u00adical Logic Lambda calculus and related systems; F.3.3 [Logics and Meanings of Programs]: \nStudies of Program Constructs Type structure; D.3.3 [Programming Languages]: Language Con\u00adstructs and \nFeatures Data types and structures; G.4 [Mathematical Software]: Algorithm design and analysis General \nTerms Algorithms, Design, Languages, Theory  Keywords First order isomorphism, Linear isomorphism, Non-recursive \ntypes, Simple types, Type signature 1. Introduction It is a matter of basic high school algebra to prove \nthe equality BBB ab Bs bU ) rabbabbaab aba(1.1) Yet, as we shall see in this paper, a systematic and \nef.cient pro\u00adduction of such a proof is non-trivial. With the familiar perspec\u00adtive of viewing multiplication \nas product-types, exponentiation as Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. POPL 03, January 15 17, 2003, New Orleans, Louisiana, USA. Copyright \n2003 ACM 1-58113-628-5/03/0001 ...$5.00. function-types, and variables as primitive-types, (1.1) becomes \nan instance of a simple, i.e., non-recursive, type isomorphism prob\u00adlem. In its turn, type isomorphism \nhas close connections to cate\u00adgory theory [5] and intuitionistic logic [13]. The isomorphism variant \nwhich concerns us here is character\u00adized by commutativity and associativity of products, and currying \nand distributivity of functions over products. This variant has prac\u00adtical interest in the context of \nthe search for compatible functions in function libraries.1 (A detailed treatise of this application \ncan be found in Di Cosmo s book [9], which discusses also extensions to second order types and the ML \ntype theory.) More formally, we consider the set of .rst order isomorphisms holding in all models of \nthe lambda calculus with product-types (surjective pairing), function-types, and unit types, as de.ned \nby the following grammar g raAg A x A A where is the unit type,stands for an arbitrary primitive-type, \nx denotes a function-type, and denotes a product-type. These isomorphisms can be derived from the following \nseven axioms schemas.A AA rAxA r A AAA AAA AAx BrrBBxA (Commutative) AxBBBx BrABxABBx (Associative) \nABx BBAC rrBAABB)AC AB (Currying) ABBBx BA+BBxBA B A(Distributive) B (Here and henceforth, the range \nof variables , andis any type expression.) For a long time, the problem of deciding .rst order isomorphisms \nof simple types was thought to require exponential time [5]. It was recently shown [7] that the variant \nof our interest can be decided h BWw y son hw B h BWw yiBw in time and space, where is the length of \nsome standard representation of the two input types. The main con\u00adtribution of this paper is an improvement \nof this result to h BWwtson yw B h BWw B h BWw B time and space. We also give algorithms using time \nand space for important special cases. 1.1 Background The arithmetic version of these seven axioms (substituting \nmul- AxA tiplication, exponentiation, and the constant one, for , and ) was proved to be complete for \nthe Cartesian closed categories [5, w Besides being suf.cient for the proof of equations such as (1.1). \n18]. Since the models of the lambda calculus with unit, product\u00adand function-types are exactly the Cartesian \nclosed categories [5], the set is also complete for the type isomorphisms we examine. Through the Curry-Howard \nisomorphism [13], these isomorphisms are also equivalent to equational equality in positive intuitionistic \nlogic so the same axioms apply there too (again, with appropriate notational changes). Besides their \ntheoretical connections, type isomorphisms can be used as a means of searching large program libraries. \nSpeci.cally, the desired type of a function is used as a search key and functions with isomorphic types \nare returned as candidates. A famous ex\u00adample [17] shows that even the simple function, folding a list, \ncan be implemented with many different types, varying argument or\u00adder and the use of Curried style. Employing \ntype isomorphisms in the search will retrieve all compatible function implementations. Moreover, the \nisomorphism proof can often automatically generate bridge code converting the functions found to the \ndesired type. AAA Second order isomorphisms augment .rst order isomorphisms ABBBAB with universal quanti.ers, \nas in \\r\\. Uni\u00adversal quanti.ers make second order isomorphisms more effective in searching program libraries \nsince they are necessary to capture parametric polymorphism. While some of the issues of second order \nisomorphisms are similar (some of the space sharing tech\u00adniques are applicable), they are known to be \ngraph isomorphism complete [4, 9] and we do not attempt to decide them in this work. A different system \nof type isomorphisms is that of the core ML lan\u00adguage. It is known [8] that second order isomorphisms \nare insuf\u00ad.cient to describe these, although the addition of one more axiom suf.ces. More recently, the \nMockingbird project has renewed interest in such searches when using recursive types [3]. One challenge \nstill remaining is to .nd a consistent scheme, as the .rst one considered was later shown to be inconsistent \n[2, 15]. Other variants of the non-recursive type isomorphism problem were considered in the literature. \nFor example, Gil [11] describes how algorithms for polynomial equality can be used for decid\u00ading isomorphism \nin the polynomial type system , i.e., the system comprising union and product-types, as well as the arithmetical \nrules, i.e., commutative, associative rules for product and union, and distributivity of product over \nunion. The more general isomorphism problem, for a non-recursive type system which includes product, \nunion and function-types along with the arithmetical rules is equivalent to Tarski s high school al\u00adgebra \nproblem [19]. Such a system does not have a .nite and com\u00adplete set of axioms. Nonetheless, there exists \na (non-polynomial) algorithm for determining isomorphism [12]. There also exists a (non-polynomial) algorithm \nfor deciding isomorphism in the alge\u00adbraic type system , i.e., recursive types along with the arithmetical \nrules [11]. Finally, we should mention that adding empty and sum types breaks down the relationship between \nthe equational theory and type isomorphisms [10].  1.2 First Order Isomorphism and Variants In this \npaper, we concentrate on .rst order isomorphism (the fol\u00adlowing Def. 1.1) and two restricted variants \n(Def. 1.2 and Def. 1.3 below): DEFINITION 1.1 (FIRST ORDER ISOMORPHISM). The .rst order isomorphism problem \nis to decide whether two types are equal under a theory of equality plus the above seven axiom schemas. \nDeciding .rst order isomorphisms of simple types has been known to be decidable for over a decade [5]. \nThe theory describing these w isomorphisms is often referred to as T h[5,6,9]. Previous to this h BWw \ny son hw Bh BWw yiB work, the best known bound was time using h BWwtson syow B space [7]. Our main \nresult is in reducing the time to h BWw B time and the space to . DEFINITION 1.2 (PRODUCT ISOMORPHISM). \nThe product isomorphism problem is to decide whether two types are equal under a theory of equality plus \nthe .rst .ve axiom schemas above (that is, all but the Currying and Distributive laws). When the Commutative \nand Associative axioms apply, we write products without parenthesis, e.g., abracadabra (1.2) (Lower \ncase, sanserif letters denote here and henceforth primitive\u00adtypes. We shall use the arithmetical and \ntype notations interchange\u00adably. No confusion will arise.) An instance of this problem variant is to \ndetermine whether the above is isomorphic to carrabadaba (1.3) One may be tempted to attack the problem \nby bringing each product into a unique sorted normal form, which in this case is aaaaabbcdrr (1.4) In \nthis paper we show that (non-recursive) product isomorphism is decidable in linear time.2 This result \nis based on the observation that it can be determined that (1.2) and (1.3) are isomorphic without a super-linear \nsorting procedure, but rather an algorithm for multi\u00ad f set comparison. More generally, to determine \nwhether rrkfowAis BA isomorphic to r.kfowkthe multi-set comparison algorithm checks whether there exists \na permutation 7such that nf)is isomorphic Bf to . This product isomorphism variant was not considered \npreviously h BWw yiB as such in the literature. Palsberg and Zhao [15] gave an time algorithm for recursive \nproduct isomorphism, de.ned by the addition of a grammar rule r efB A B where is a type variable, and \nthe folding/unfolding axiom AAA hefBrefBngB BBAA hgB B (As usual, the notation Bstands for a the type \nexpression B where each occurrence of is replaced by .) Isomorphism be\u00adtween recursive product-types \nare de.ned in terms of their in.nite unfoldings which are regular trees. This result was later improved \nh BWwtson hw B to time [14] using a reduction to the problem of .nding size-stable partitions of a directed \ngraph. DEFINITION 1.3 (LINEAR ISOMORPHISM). The linear isomorphism problem is to decide whether two types \nare equal under a theory of equality plus the .rst six axiom schemas above (that is, all but the Distributive \nlaw). Polynomial time results for this problem were known before those of the .rst order problem. Linear \nisomorphism can be decided h BWwtson y w B in linear space and time [1]. Although not previ\u00adously mentioned, \nboth algorithms [7, 14] improve the running time h BWwtson hw B to . We show that linear isomorphism \nis also decidable in linear time. y Jha (personal communication, September 2002) reports on inde\u00adpendent \ndiscovery of an algorithm for the this sub-problem, with similar complexity bounds. Linear isomorphism \ncombined with the unfolding rule cannot be treated by algorithms for recursive type isomorphisms, since \nthe application of this rule may produce in.nite products, as in, e.g., efBBABB a  1.3 Reduction systems \nand Normal forms Isomorphism proofs are usually based upon reduction systems producing a normal form \nrepresentation of the input, which can be more easily compared. For example, the reduction system of \nRittri [17] has seven rulesA A A d xAA A A x d AA A AA A AAA (1.5) BB BB AxBBxAxABx AABB)ACB BAxABBAA \nBB BBBB ABBxA+BxAC Rules , i.e., those rules handling the unit type, are con.u\u00adent. Since the rules \nare trivially implemented in linear time, we as\u00adsume here and henceforth that they are applied in a pre-processing \nA stage, in which all occurrences of are eliminated. 3 After this stage, rulesandare repeatedly applied \nas long as it is possible to do so. (We assume that types use a standard expression-tree representation \nin memory, and that each rule appli\u00adcation is implemented as a transformation of this data structure.) \nNote that these rules can always simplify the structure of the right A operand of , unless it is a primitive-type. \nThe input is therefore brought to the normal form described by the following grammar r AAAxA (1.6) Next, \nruleis repeatedly applied to .atten product-types. Now we can write every product as . i) ) ) rBwxAyBxA \n() ) )xf) k rwhere f , . , is either a primitive-or function-type. We wkfwill refer to as the terms of \n, and we will sometime even write as rrkfowto emphasize the associative-commutative nature of product-types. \nAn algorithm for deciding .rst order isomorphism is to recur\u00adsively compare the resulting normal forms: \ntwo nodes are isomor\u00adphic if they are of the same kind (product or function) and their operands are isomorphic. \nIn function-nodes the comparison of ar\u00adguments is straightforward: the left (right) operand of one node \nmust be isomorphic to the left (right) operand of the other. In com\u00adparing product-nodes however we must \nsolve an instance of the product polymorphism problem to check whether the terms of one node is pair-wise \nisomorphic to some permutation of the terms of the other node. If this comparison is not done carefully \nit adds to the complexity of the problem. An even more serious inef.ciency factor is that the system \n(1.5) (speci.cally, the distributive rule) may introduce an exponen\u00ad tial blowup in the size of the \nrepresentation. Rules do not A increase the representation size. However, each application ofcreates \na duplicate copy of the subtree whose root is . Repeated applications may produce a very large normal \nform representation. rr In the sequence of types f e f, de.ned by o a and f c m e ff f (BbcB1for y r \n, we have that o b m 1c m e1 and In the degenerate case in which one or both of the inputs is re- A duced \nto A, the input types are isomorphic if and only if they both reduce to . r f successive applications \nof this rule to each occurrence of , w s , will lead to exponentially many copies of a in the normal \nform of o . If graphs, rather than trees, are used to represent types, then an A application of, can \nbe implemented by sharing the node rep\u00adresenting . This sharing can be thought of as an application of \na slightly different transformation A BBACBBBBACB A BBBxB g BrAx(1.7) B A where a newly introduced symbolic \nvariable is represented as a pointer to the data-structure representation of type . Rittri [16] observed \nthat using (1.7) ensures a polynomially sized representation of the normal form: Each application of \ntransforma\u00adtion (1.7) adds one edge to the graph. The application reduces the x nesting level of the \nnode, and this nesting level cannot be in\u00adcreased by the other rules. We obtain that the space of the \ngraph h BWw yiB w normal form is by noticing that initially there are at most product-nodes, and that \neven though additional product-nodes may  be created by, these nodes cannot take part in the other two \nrules. To see that the representation can indeed by quadratic, consider the following example (written \nusing the arithmetical notation): f a1 w wbaa b by) ) ) b yBb  B1ai) ) ))a(1.8) whose normal form \nis 1y 1) ) ) 1 1  1(1.9) a a a baw babawba This normal form consumes quadratic space if derived by \napply\u00ad  ingstarting at the inner most parenthesis. REMARK 1.4. Deriving (1.8) starting at the outer \nmost paren\u00adthesis, yields a linear space representation 1) ) ) b b w BrBrBr wwfffw where a, and a for \nw . Having bound the space explosion, Rittri stopped short of giv\u00ading a polynomial time algorithm for \nthe problem. By noticing that the graph representation is acyclic, and by using a variant of Rit\u00adtri \ns normal form, Considine [7] was able to reduce the runtime to polynomial. His algorithm partitions all \nnodes in the DAG repre\u00adsentation of the input types into equivalence classes, such that all nodes in \nthe same equivalence class are isomorphic. This parti\u00adtioning is built in a bottom-up traversal of the \nDAGs, while main\u00adtaining a hash table mapping each node into the unique identi.er of its equivalence \nclass. The most dif.cult task was to determine whether product-nodes4 are isomorphic. Two key properties \nmade h BWw y son hw Bh BWw B the time and space result possible: 1. Expansion of product-types. Considine \nshowed that his nor\u00admal form, which includes complete expansion of product\u00ad w types, is such that each \nproduct consists no more than terms.  We should note that Considine rules were different than Rittri \ns e r d A in that rulewas applied in the opposite direction. The result\u00ading normal form is such that \ninstead of , it uses the equiv\u00ad a C o A alent representation . Thus, strictly speaking, his nor\u00ad mal \nform did not use product-nodes, other than in the upper most level. However, the alternative representation \nmust still deal with the dif.culties of associativity and commutativity as in the more familiar representation \nof products. 2. Sorting product terms. Since the graph is acyclic, terms in product-types must have been \nvisited and classi.ed by the bottom up traversal before the product itself. Each product\u00adnode is .rst \nnormalized by sorting the identi.ers of the equiv\u00adalence classes of their terms. The fact that the order \nof terms is completely determined by this sorting makes it possible to employ a hash-consing technique \nto produce a unique identi\u00ad.er for each product-type, whereby partitioning product-type nodes into equivalence \nclasses. Our algorithm uses the same bottom-up classi.cation of nodes into h BWw B equivalence classes. \nHowever, the reduction of space to and h BWwtson y w B the time to are made possible breaking away from \nthe above principles. Speci.cally, the new algorithm is characterized by: 1. Application of to outer-most \nfunctions .rst. As demon\u00adstrated in Remark 1.4 the space is kept linear if the distribu\u00adtive rule is \napplied starting at the outer most parenthesis. 2. Unexpanded product-types. The expansion of product-types \nleads to quadratic time and space. Instead, we describe a graph based representation, which keeps the \nspace linear, and show that unexpanded products can still be ef.ciently com\u00adpared. 3. Unsorted product \nterms. Isomorphism of product-nodes is decided by a procedure which can be thought of as hashing or range \ncompaction, rather than sorting. A similar procedure is used to partition the multi-sets of products \nin each stage of the traversal into their equivalence classes.  Outline In Sec. 2 we develop a tool \nbox for various multi\u00adset partitioning problems, which we apply later for classifying un\u00adsorted product \nterms. The .rst such application is in Sec. 3 which describes our algorithms for the linear and product \nisomorphisms. Sec. 4 describes the normal form which we use for type compar\u00adisons, and shows that this \nnormal form can be ef.ciently generated g hc in a linear sized encoding, which we call the P-graph. More\u00ad \ng hc over, we show that the unexpanded products in the P-graph form a tree structure, such that each \nproduct inherits the terms of its parent. Sec. 5 uses the multi-set partitioning toolbox in a procedure \nfor comparing unexpanded products in this tree structure. Sec. 6 .ne\u00adtunes this procedure to its application \nin a bottom-up classi.cation g hc of the nodes of the P-graph. Finally, we present our main al\u00adgorithm \nfor deciding .rst order isomorphisms of simple types in Sec. 7. Sec. 8 lists some open questions.  \n2. Multi-set Partitioning Algorithms For the purpose of processing product-nodes in which the terms are \nunsorted, we need a linear time procedure for comparing multi\u00adsets. More generally, we develop in this \nsection an algorithm for partitioning a collection of multi-sets of integers into equivalence h BWw Bw \nclasses. This algorithm runs in time, where is the size of the input representation, while using temporary \n(uninitialized) storage whose size is the maximal input value. h DEFINITION 2.1 (COMPACT INTEGER PARTITIONING). \nwrw NG wf Given integers aai, where afor , the compact integer partitioning problem is to partition the \ninput into its equivalence classes, i.e., all equal integers will be in the same partition (and only \nthem). The output partitioning is presented with respect to the input: w Each equivalence class is produced \nas a list of indices, r) ) ) p , r such that af1afs . h BWw B LEMMA 2.2. Compact integer partitioning \ncan be solved in h BWw B time and space. w PROOF. Astandardbucketsortalgorithmusing bucketsachieves \nthese bounds. h More general than compact integer partitioning is the case that w the input range is \nnot restricted to the range . h DEFINITION 2.3 (BROAD INTEGER PARTITIONING). wfPnrw EG Given integers \naai, where afor , the broad integer partitioning problem is to partition the input into its equivalence \nclasses. To deal with this problem, we .rst reduce the input range. DEFINITION 2.4 (RENAMING). Let Ube \nan arbitrary domain rw Aw and let rN.TU, r. Then a partial function fUi1his a renaming of rif fis de.ned \non rand for any aNcGr, rcBBrBcB a ifaif h Alg. 1 .nds a renaming function for a sequence of integers \ndrawn Pn from the range . The algorithm uses the standard trick of in\u00ad h BB verse pointers to maintain \naccess time into a sparse uninitial\u00ad hh ized array of arbitrary size. Note that main loop invariant: \nAfter ofrfrfG h ff processing index , then faand Ua, for some NC . w h Algorithm 1 Rename(aai) wfRnrw \nG Given the sequence aai, where a,, Crwh h return (i) naaiand (ii) a renaming function repre\u00ad hRnf \n sented as an array f, such that fais a unique integer NC in the range . The values of the other entries \nof fare arbi\u00adtrary. 1: f .new int[U] // An uninitialized array of size 2: U .new int[n] // The inverse \nmapping of fn C h 3: .// Cis the current number of distinct values in the input 4: For rhfwdo // Compute \nfaf fh f 5: f.nfa// may be arbitrary if the value of ais new ;f;fr C f 6: IfandalsoUar then 7: next // \nNo new mapping since afa for some j < 8: else // Create a new mapping entry h C.CN5 9: // A new distinct \ninput value 10: fhaf.C// Store the mapping entry Cf 11: U. a// Record the inverse pointer Renaming \nmakes it possible to generalize Lemma 2.2. h BWw B LEMMA 2.5. Broad integer partitioning can be solved \nin h Bn25w B time and space. PROOF. After applying Alg. 1, we apply a renaming process, BBrw i.e., \nthe replacement af.nfaffor . The problem is then reduced to compact integer partitioning.  A more general \npartitioning problem is when the input consists of ordered pairs. h DEFINITION 2.6 (PAIRPARTITIONING). \nGivenacollection r ww oG of pairs of integers ((awNcRG((aiNcG, where afNcfPn rw for , the pair partitioning \nproblem is to partition r into its equivalence classes. h BWw B LEMMA 2.7. The pair partitioning problem \ncan be solved in h Bn25w B time and space. w PROOF. Apply broad integer partitioning .rst on aaito obtain \nan initial partitioning of r. Each of the resulting equivalence classes is then re.ned by broad integer \npartitioning with respect to cf the s. Renaming with pair partitioning is also easy. Each pair is re\u00adplaced \nby the index of its equivalence class. In fact, every parti\u00adtioning algorithm gives rise to a corresponding \nrenaming. Lemma 2.7 can be generalized further. LEMMA 2.8 (TUPLE PARTITIONING). Given a collection r \nwh of tuples of integers each, where each integer is drawn from Pn the range , it is possible to partition \nrinto its equivalence h BWwBh Bn25w B classes, in time and extra space. PROOF. Similar to Lemma 2.7, \nhowever, instead of two passes we now have passes. The input to the .rst pass is the entire collection \nr, and the output is a partitioning of raccording to the .rst element of each tuple. The output of pass \nis a partitioning of rsatisfying the following invariant: all elements in the same partition have an \nequal -pre.x, i.e., the same .rst integers in their tuples. Pass re.nes each partition by applying broad \ninteger partitioning according to the th element of each tuple. Since broad integer partitioning is performed \nin linear time, the running time of a pass is linear in the sum of wr+ partition sizes, which is exactly \nr. Thus the total running h BWwB time is . At the end of the th pass the tuple partitioning problem is \nsolved. h Bn25w B Broad integer partitioning requires (reusable) space. In h BWw B addition, only space \nis required for storing the current parti\u00adtioning of rin the form of indices to the input array. Notice \nthat the time requirement in the above is linear in the size of the input, not the number of tuples. \nAlso, observe that the algorithm for the tuple partitioning problem is in fact incremental in the sense \nthat in the th pass we only examine the th integer in each tuple. COROLLARY 2.9 (INCREMENTAL TUPLE PARTITIONING). \nwh Let rbe a collection of tuples of integers each, where each inte- Pn ger is drawn from the range . \nThen, it is possible to incremen\u00adtally partition rin passes where the th component of each tuple h BWw \nB h Bn5w B is speci.ed in the th pass, in time for each pass and extra space. A more challenging situation \noccurs in the case that the input consists of unordered tuples, rather than tuples. Next we will show \nthat multi-set partitioning can also be solved in time linear in the size of the input. h DEFINITION \n2.10 (MULTI-SET PARTITIONING). Given a col- Pn lection rof multi-sets of integers drawn from the range \n, the multi-set partitioning problem is to partition rinto its equivalence classes. h BWw B LEMMA 2.11. \nMulti-set partitioning can be solved in time h Bn25w Bw and space, where is the sum of sizes of all multi-sets. \nh PROOF. First, Alg. 1 is invoked to rename all integers in the w input to .t the range . Then each multi-set \nis sorted using bucket-sort. We stress that we do not perform sorting of the initial multi-sets; we sort \nthe renamed integers. (This sorting is possible in linear time since the renaming process is not order \npreserving.) Next, the ordered multi-sets are partitioned according to size. Each such partition is \na collection of ordered multi-sets of equal size; in other words, each partition is a collection of tuples \nof equal size. All that is left is to solve the tuple partitioning problem, em\u00adploying Lemma 2.8 in each \npartition.  3. Linear and Product Isomorphisms In this section we use the multi-set partitioning algorithm \nin de\u00adveloping algorithms for linear and product isomorphisms. We .rst h BWw B demonstrate how to decide \nproduct isomorphism in time and space. Then we show a linear time and space reduction of linear isomorphism \nto product isomorphism. After applying the unit-type pre-processing stage, product iso\u00admorphism has only \ntwo remaining axioms: AA AxABrBBxA (Commutative) xBBxBrBx BBx (Associative) Commutativity and associativity \nallow product components to be reordered until the two types match. We see that product isomor\u00adphism \nis in essence a series of multi-set partitioning problems. We use a .attened products normal form de.ned \nby the follow\u00ading grammar. r BB foIa w r BB(3.1) piw foIa AA a rpipi The start symbol denotes products \nof any number of terms, in\u00adcluding 0 and 1, whereas idenotes products of at least one term. Each term \nais a function-type. The symbol denotes primitive\u00adtypes. The .attened products normal form requires that \nthe terms of products are functions. This requirement can be obtained by ap\u00adplying the following simple \ntransformation: if a primitive-type is involved in a product, it must be rewritten as a function from \na unit type (i.e., empty product) to . Conversely, function-types must receive and return products; the \nonly exception being that the return type of a function can be a primitive-type. Also note that if this \nreturn type is a product then it must include at least one term. In other words, functions returning \nunity are not allowed in this normal form. This, and all other terms in the return type, must in turn \nbe function-types. We need the following two transformation rules: (i) if the type of the argument of \na function-type is a primitive-type , then must be rewritten BAAB as the singleton product , and (ii) \nif a function-type has an operand which is also a function-type, then these must be separated by a singleton \nproduct. Consider for example the following type, BxABABxxxBAxBB abc abcabc (3.2) Fig. 3.1 shows the \nabstract syntax tree of type (3.2) in the normal form (3.1). xA We see in the .gure for example that \nab c was rewritten as BAABxBAABA ab c The grammar (3.1) produces abstract syntax trees in which func\u00adtion \nand product-types occur alternately on the path from the root to any leaf. We can thus de.ne a height \nfor each tree node, so that all nodes of odd (even) height represent function (product) types.  DEFINITION \n3.1 (HEIGHT). Let be a type written in the BB normal form (3.1). Then, the height of a type, denoted \nh, is the length of the longest path from to any leaf, i.e., if r or is an empty product hBB r{5fkwhBB \nif rw) ) )x , +m a xofx 5BBBaBBBraAak +m a xhhif{ (3.3) Edges in Fig. 3.1 were stretched so that nodes \nof the same height are drawn at the same level. Observe that product-types always have even heights and \nfunction-types always have odd heights. This can be easily proved by induction on the grammar of (3.1). \nLEMMA 3.2. If two types in the normal form (3.1) are isomor\u00adphic, they have the same height. PROOF. Omitted. \n h BWw B THEOREM 3.3. Product isomorphism can be decided in time and space. PROOF. Considerthetypesrepresentedbyallofthenodesofthe \ntree representations of .attened products normal forms of the two h BWw B input types. We will label \neach of these types with an identi\u00ad h .er, such that two types are isomorphic iff they have the same \niden\u00ad dTw ti.er. These identi.ers are integers drawn from the range where Tis some .xed constant. Since \ntwo types cannot be equivalent unless their heights are the same, identi.ers may be assigned in ascending \norder of heights. Let Tbe the set of all types of height t. The set Tis the set mTr of primitive-types \nand empty products. The algorithm starts by passing Tdto the broad integer partitioning algorithm. A \nrenam\u00ading process then yields unique identi.ers for all basic types, plus an identi.er for the empty \nproduct. The processing of Ttdepends on whether t mT, is even or odd. If tTcorrespond to symbols in the \ngrammar is odd, then types in mT a of the normal form, i.e., function-types. Equivalence among these \nare discovered using pair partitioning algorithm. If however tT is even, then the types in iTare products, \ni.e., symbols. We apply the multi-set partitioning algorithm to .nd all equivalence classes among these. \nIn both even and odd levels, we apply a renaming process that assigns identi.ers to types in the current \nlevel, starting at the .rst unused identi.er. Each node is passed to a partitioning algorithm at most \ntwice, .rst in the partitioning of nodes in its height, and then as component of its parent. Therefore \nthe total input size in all invocations of partitioning algorithms is linear, and hence the total runtime \nof our algorithm is linear.  The above algorithm is applicable also in the case that types use a DAG \nrather than a tree representation. The runtime in this case is linear in the number of nodes and the \nnumber of edges of the graph. We now turn to the problem of linear isomorphism, which adds the currying \naxiom: AAx BrrBBxAA (Commutative) AxBBBxBrABxABBx (Associative) Bx BBACABB)ACB (Currying) The Currying \naxiom is no longer needed after exhaustively applying rule , [1]. Note that these applications do not \nincrease the size of the representation. We can now bring the input to a form similar to the .attened \nproducts normal form (3.1). More precisely, the linear normal form is rBB foIaw rBB pi foIaw(3.4) rBB \npii fowa AA rpipii a which is almost identical to (3.1), except that iimust have at least two terms. \nOnce in this normal form, only the axioms used for product-types are necessary. We therefore have h BWw \nB THEOREM 3.4. Linear isomorphisms can be decided in time and space. g hc  4. The P-graph To generalize \nthe linear isomorphism algorithm to deal with the .rst order isomorphism problem, we must take care of \ndistributiv\u00adity, which, as noted above, may lead to an exponential blow-up of the representation. Inspired \nby the example set by Remark 1.4, we describe an algorithm for applying the distributive rule more economically \nto produce a linear size representation in linear time. We assume that the input was .rst brought to \nthe form (3.4) h BWw B in time and space as described in the previous section. This input uses the standard \nexpression tree representation. Repeated applications of will then bring this input to the distributive \nnormal form de.ned by the following grammar rBB rfoa (4.1)A a The main difference between the two grammars \nis that the deriva\u00adtion A rpipii a does not occur in (4.1). In other words, all functions must return \na primitive-type. The transformation between (3.4) and (4.1) is car\u00adried out by invoking rule whenever \nthe return type of a function is not primitive. To maintain a linear size representation, rule is applied \nusing A (a multiple-terms version of) the distributive transformation (1.7): ) ) ) ABBwxxBB Consider \nan input node . Then, it follows k from the grammar (3.4) that this node must in fact be of the form \n) ) ) ABwAwBxxBAB (4.2) kk ww where and are products, while are either kk products-or primitive-types. \nApplying .rst the general version of (1.7) and then times , we obtain ) ) )B BBxwAwBxxBxAB (4.3) kkB \nwhere the term is represented as a pointer to the product . We B xf say that the product inherits all \nthe terms of the product . Speci.cally, types in the distributive normal form (4.1) are rep\u00adresented \nas graphs (instead of trees), in which P-nodes represent BB products. A P-node vhas a .eld .vstoring \nthe set of point\u00ad c ers to the terms of the product, which are all -nodes, i.e., nodes representing function-types. \nTo represent term inheritance, valso BB has a .eld parent vwhich is pointer to another P-node, from which \nvinherits additional terms. Let vbe the P-node of the product in (4.3). Then, each prod- BxffBfB uct \nis represented by a P-node v, such that .vstores the Bf terms in the product , while the shared term \nis represented by making the assignment BB parent vf.v c BB An -node uhas two main .elds: (i) arg u, \nwhich is a pointer BB to the P-node storing the function argument type, and (ii) ret u, which is a primitive-type \nspecifying the function return type. Although the representation breaks away from the standard ex\u00adpression \ntree representation, it is not arbitrarily general, in that shar\u00ading can only occur across parentedges. \nWe require that the these edges make a tree T, rooted at a dummy P-node, denoted P. P- P. nodes are therefore \ninitialized with their parent .eld pointing BB rrat PPhas no terms, i.e., .P. P.. Node P.P. g hc DEFINITION \n4.1. A Pc-graph is a rooted acyclic graph whose nodes are either P-nodes or -nodes. Alg. 2 and Alg. 3 \npresent two mutually recursive routines Nor\u00admalizeProductand FunctionIntoProduct. Together, the two describe \na single pass traversal of an abstract syntax tree of the g hc input grammar (3.4). The output is a P-graph \nof an isomorphic type in the distributive normal form. Algorithm 2 NormalizeProduct() Given an abstract \nsyntax tree of a type conforming to the gram\u00admar (3.4), return a P-node vof an isomorphic type in the \ngram\u00admar (4.1). r BBrBBr 1: vnew P-node // Initially parent vP, .v P. 2: Let and f , r., be such that \nrrfkowf r a.ra 3: For do // Normalized all terms in the product ffffAf 4: Let and be such that faBfB \n5: vNormalizeProduct BB ff 6: uFunctionIntoProduct v BBBBB ioB 7: .v..v.u// Collect terms of u 8: Return \nv The recursive process relies on the fact that products and function\u00adtypes occur alternately on a path \nfrom the root to any leaf. Ac\u00adcordingly, NormalizeProductbreaks the input product into its terms (line \n2), which must all be function-types (line 4). The recur\u00ad ff sive conversion of the function type is \ndone in two steps, which must occur in order: At .rst (line 5), the function argument type is normalized, \nand the resulting P-node product-node is stored in vf. Only then (line 6), the function ffcan be brought \ninto its normal form, which is a product of terms, where each such term may internally include pointers \nto the P-node vf . Algorithm 3 FunctionIntoProduct(u) Given a P-node uand an abstract syntax tree of \na type (which might be either a product-or a primitive-type) return v, a new P- A node describing a \ntype isomorphic to the function-type , where is the type represented by the P-node ru. r BBBB r 1: vnew \nP-node // Initially parent vP, .v P. 2: If is a primitive-type then 3: wnew -node BBcBB A 4: arg w.u; \nret w// wrepresents the type BB 5: .v{w 6: Return v 7: Let and f , r., be such that rrfkowf ra. a 8: \nFor do // Process all terms in the return type fffrfAf 9: Let and be such that ) ) ) AABBwAawBxxBA+BB \n// is fBfBkk 10: vNormalizeProduct BB 11: parent vf.u// Share the common argument BB ff 12: wFunctionIntoProduct \nv BBBBB ioB 13: .v..v.w 14: Return v Alg. 3 recursively traverses a function-type, returning an iso\u00admorphic \nP-node. Lines 2 6 terminate the recursion in the case that the function return type is primitive. In \nthis case, a singleton, non-inheriting product is returned. The remainder of this algorithm (lines 7 \n14) puts the transition between (4.2) and (4.3) in algorith\u00admic terms. Observe again that the recursive \ncall in line 12 is done only after the function argument type was processed. It is mundane to check that \nthese two algorithms run in linear time and produce a linear sized representation. Fig. 4.1 shows the \nresult of applying these algorithm on the tree of Fig. 3.1. In the process, the two function-types whose \nright operand was a product-type were eliminated. Figure 4.1: The P I F-graph of type (3.2) The edges \nof the product tree are depicted in bold in the .gure. We see in the .gure that these edges indeed do \nnot form a cycle. It is easy to show that this is no coincidence by proving induc\u00adtively that calls to \nFunctionIntoProductcreate edges which always lead from the second to the .rst argument of this function. \nDEFINITION 4.2 (EXPANDED TERMS). The expanded terms BB of a P-node v, denotedv, are the union of terms \nof its ancestors in the product tree, i.e., BBrBBBBB ioB vvparent v BBrr whereP. P. The following \nlemma shows that .rst order isomorphism of two g hc types can be decided by bringing each of these types \ninto their Prepresentation, and then traversing the two graphs in tandem, com\u00adparing at each stage the \nexpanded terms of the current nodes. g hc LEMMA 4.3. Two nodes uvin a P-graph represent iso\u00admorphic types \nif and only if one of the following holds: cBBrBBBB 1. uand vare both -nodes, ret uret vand arg u BB \n and arg v(recursively) represent isomorphic types. BBrBBrr 2. uand vare both P-nodes, anduv 3. uand \nvare both P-nodes, and there exists a bijection 7 BBBB BB G fromutov, such that every viu(recursively) \nBB represents a type isomorphic to 7vi. PROOF. Omitted. If the terms in P-nodes are expanded, then the \nsize of the rep\u00ad h BWw yB resentation may increase to (as in (1.9)). With this expan\u00adsion, the problem \nbecomes an instance of product isomorphisms, which, as explained in the previous section, can be solved \nin linear h BWwyB time. We can thus obtain a simple time and space algorithm for the .rst order isomorphism \nproblem, whereby improving upon h BWw y son hw B the best previous result. To obtain a more ef.cient \nalgorithm, we develop in the next sec\u00adtion the machinery for comparing unexpanded products.  5. Tree \nPartitioning In this section we further develop our partitioning algorithms to deal with the non-expanded \nrepresentation of products in the tree of P-nodes rooted at P. Formally, out interest lies with a variant \nP.of the multi-set partitioning problem, in which the multi-sets are organized in an inheritance tree. \nConsider a tree Tof w nodes such BB that a multi-set vof integers is associated with each node v T. The \nexpanded multi-set of a node vis the union of multi-sets of the ancestors of v, i.e.,  o a G BvBBuB \nu These expanded multi-sets will be in our applications the expanded terms (Def. 4.2) of P-nodes. DEFINITION \n5.1 (TREE PARTITIONING). The tree partition\u00ading problem is to solve the multi-set partitioning problem \nfor the BB G expanded multi-sets vvT. A solution for the tree partitioning problem is useful in our at\u00adtempt \nto partition the P-nodes into equivalence classes, such that two P-nodes are in the same class if and \nonly if they represent iso\u00admorphic types. Types are isomorphic precisely when the expanded terms of the \nrespective nodes are the same. Letdenote the total number of elements in multi-sets of this tree, i.e., \nBvB b u ) We can assume that the integers in the input to the problem are condensed so thath v BBr \n u ) (This condition can be ensured by a simple application of a renam\u00ading process.) a Fig. 5.1a shows \nan example of a tree with nodes with their associated multi-sets (only four of which are non-empty). \nIn r the example, distinct integers take part in these multi-sets. wr n r The total number of elements \nin these multi-sets is. { } {1,2,3} (a)(b) Figure 5.1: A small multi-set tree (a) and its tree partitioning \n(b) We have for nodes E and F, for instance, BBrr BEBr F BBr E BBr F Fig. 5.1b depicts the solution \nof the tree partitioning problem for the multi-set tree of Fig. 5.1a. We see that there are 5 partitions: \nA H BC DEG F (5.1) The callout attached to each partition shows the expanded multi\u00adset of all nodes in \nthis partition. For example, is the expanded multi-set of the partition DEG . The naive solution to the \ntree partitioning problem is by directly BBh computing the expanded multi-setsv. To do so, represent \nan hBB expanded multi-set vas an integer array h e m r BB such that h e m if integer occurs times in \nv. BB Arrayh e m can be easily computed from vand h e m , where uis v s parent. After having obtained \nthe arrays h e m , the tree partitioning problem becomes the partitioning problem of these arrays, viewed \nas -sized tuples. The total time for computing the expanded multi-sets in the above h BWw5B fashion is \n. We now present a more ef.cient algorithm which relies on the dual representation in which, instead \nof asso\u00adciating a multi-set of integers with each node, a multi-set of nodes is associated with each \ninteger. The performance gain is due to the fact that the multi-set of nodes in which a value participates \nis most often a subtree of T. With an implicit ordering of the tree nodes ob\u00adtained by 7, a pre-order \ntraversal of the tree, subtrees can be simply encoded as intervals. In our example, let the pre-order \ntraversal be rB B 7ABCDEFGH We see that the descendants of any given node form an interval. For instance, \ndd ddat BBr D DEFG r at BB B BCDEFG r f A family F, , is the multi-set of nodes whose BB multi-sets contain \n. More precisely, if occurs times in v, f then voccurs times in F. In our example, four such families \nare de.ned: rw FBFHH Fyr Br (5.2) ( FBF r FDF Each family Ffde.nes at most Ffdistinct intervals in 7, \none for each distinct node in Ff . These intervals partition 7into at most Ff5segments. This partitioning \nuniquely de.nes the number of occurrences of in each of the tree nodes: Consider any arbitrary such segment, \nand let vrange over the nodes of this BB segment. Then, the multiplicity of the value in vis the same. \nBB Instead of explicitly writing the multiplicity of in vfor ev\u00adery such node v, we associate the multiplicity \nwith the entire seg\u00adment. We shall even refer to this multiplicity as the segment id.A partitioning of \nthe pre-order traversal into segments and their iden\u00adti.ers is called a segment partitioning. The segment \npartitioning of a family Fis denoted V'F. Let ivbe the id of the segment of a f node vin V'F. Then, the \nessence of the dual representation is that h d BBr h d fBe m B ifv(5.3) We therefore have d BBBBw LEMMA \n5.2. The sequence ividvuniquely deter- BB mines v. Fig. 5.2 depicts the segment partitionings of the \nfamilies of (5.2). VF1 VF2 VF3 VF4 Figure 5.2: The segment partitionings of the families of Fig. 5.1a \nA000 B0 C 11 D 11 E F222 G111 H2000 ( We see in the .gure that F(for example) de.nes two intervals which \ninduce a partitioning of 7into four segments. The largest of these segments has nodes BCDE. The id of \nthis segment is 1, and indeed we can see in Fig. 5.1b the value occurs exactly the same number of times \n(i.e., 1) in the expanded multi-sets of each of these nodes. The id 1 is also given to the singleton \nsegment of G; this is because the value occurs once also in the expanded multi-set of G BB Also, note \nin the .gure that vcan be read by inspecting the segment id s in each of the partitionings. For example, \nreading the BB .rst row of the column headed F we see that occurs twice in F . The intersection of two \nsegment partitionings Pwand Pyis also a segment partitioning, written as PwxPy. It can be obtained by \nw intersecting each of the segments of Pwith each of the segment of Py. The identi.ers of the segments \nin PwxPyare the renamed pairs of identi.ers of the originating segments from Pwand Py. We can safely \nreuse the old identi.ers, i.e., the new identi.ers are allocated starting from 0. w Fig. 5.3 depicts \nthe intersection of the segment partitionings of V'Fand V'Fyfrom (5.2). F1 F2 F1 F2 A 0 0 00,0 B C \nD 1 1 1,1 1 E F G H renaming2 1 2 0 2 1 3 2,1 1,1 2,0 Figure 5.3: Computing the intersection of the two \nsegment partition\u00adings \\7Fwand \\7Fyde.ned by Fig. 5.1a.  The third row in the .gure shows the intermediate \nstage in which the segments in the intersection still use pairs of integers as identi\u00ad.ers. For example, \n(Gis the identi.er of the segment containing nodes B, C, D, and E. This identi.er was renamed to 1. Note \nthat the other segment (singleton with G) with the pair identi.er (G was also renamed to 1. We represent \nsegment partitionings as a sorted array of the seg\u00adment end-points with their associated identi.ers. \nThe intersection of two such partitionings whose sizes are 8wand 8yis carried out h B8w5Bw5 by merging \ntheir arrays in 8ytime into a single 88ysized array. Lemma 2.7 can then be employed to rename the pair\u00adidenti.ers \nin the merged array. It follows from Lemma 5.2 that the tree partitioning problem is solved by computing \n) ) ) wxx V'FV'F h BWw5sonBh BWw5B LEMMA 5.3. There is an time and space algorithm solving the tree \npartitioning problem. ) ) ) wxx PROOF. To compute V'FV'Fwe build a balanced w binary tree whose leaves \nare V'FV'F. In each internal node we compute the intersection of the two segment partitionings of its \ntwo children. The segment partitioning at the root of this tree is exactly the tree partitioning. Since \nall the partitionings propagate to the root, we have that the total size of all partitionings at each \ntree level, and thus the work h BB to generate the next level is . Since the number of levels is logarithmic, \nwe have that the total time for computing ) ) ) wxx V'FV'F h BsonB is . Fig. 5.4 depicts the balanced \nbinary tree of the families of (5.2). We see in the .gure that the segment partitioning at the root of \nwxyx(x this binary tree, i.e., V'FV'FV'FV'F, partitions the dd r ordering 7into 6 segments. The segment \nof types D and E has i . This is also the iof the segment of G. Together, these two segments represent \nthe partition DEG . We have thus obtained the desired partitioning (5.1) of the tree in Fig. 5.1a. 6. \nIncremental Tree Partitioning The tree partitioning problem (Def. 5.1) solved in the previous section \ndoes not capture in full the intricacies of the bottom up g hc classi.cation into isomorphism classes \nof the nodes of a P\u00adgraph. The dif.culty is that the terms of P-nodes in any given cc height are -nodes. \nThese -nodes must be classi.ed prior to the classi.cation of the P-nodes in this height. The algorithm \nbehind Lemma 5.3 however assumes that all multi-sets members are di\u00adrectly comparable. It is applicable \nonly in the case when all terms are basic types. In this section, we develop the algorithm which after \nhaving clas\u00adsi.ed all the P-nodes up to height t, will use this information to c5 classify the -nodes \nin height t. The identi.er found in the c classi.cation of these -nodes must take part in the classi.cation \nof the P-nodes at height t5 . To this end, this section deals with a more general variant of the tree \npartitioning problem, in which the multi-sets are supplied in a piecemeal fashion. In this variant, the \ndifferent possible values of the multi-sets in the tree nodes are exposed in iterations. The algorithm \nfor this variant will add another logarithmic factor to the time complexity. The requirements from a \ndata structure for the incremental tree partitioning problem are best de.ned in terms of the dual represen\u00adtation. \nGiven a tree T, this data structure must support two kinds of operations, which might be interleaved: \ninsertions of the sequence of families FwFyand classi.cations of a sequence of node sets TwTy In our \napplication, the multi-set of nodes Fis inserted after hav\u00ad c ing discovered that a certain collection \nof -nodes belong in the isomorphism class whose identi.er is j. (These identi.ers are al\u00adlocated consecutively.) \nThe set of nodes Tis classi.ed when we carry out the classi.cation of nodes whose height is j. Accordingly, \nthe sequence Tcannot be arbitrary. We demand that these sets are disjoint, that UTrTand that the data \nstruc\u00adture is never required to classify a node before its parent. The inter\u00adleaving of the two input \nsequences is also subject to restrictions. If a node was classi.ed then it can never appear again in \nany insertion. BB With these restrictions, we use the notation Tclassify T BB and Tinsert Fto describe \nthese operations. Our main ob\u00adjective is to minimize the resources for processing the entire inter\u00adleaved \nsequence of data structure operations. ... LEMMA 6.1. Incremental tree partitioning can be solved in \nh BWw5son5wson hwsonB h BWw5B time and space. PROOF. We use a lazy representation of an in.nite complete \nbi\u00adnary tree, similar to the binary tree of Lemma 5.3, The leaves of this tree are given by the in.nite \nsequence V'FwV'Fy Fig. 6.1 shows (part of) this tree, after families V'FwV'FFF have been inserted. F1 \n F4 F2 F3 F4 F5 F6 F7 Figure 6.1: An embedding of seven families into an in.nite balanced binary tree \nThis in.nite tree is used to guide the computation of the inter\u00adsection of the partitioning which were \ninserted so far: we delay the intersection of partitionings in an internal node until both its chil\u00addren \nexist. A temporary root is a node in which the partitioning was computed, but not in its parent. In the \n.gure the nodes at which partitionings were intersected are drawn with thicker lines. Speci.cally, at \nthis stage we have wx(xwxx(x computed xV'FV'Fy, V'FV'F, V'FV'FyV'FV'F, and V'FFFV'FFF. There are three \ntemporary roots in .gure, which are the nodes corresponding to V'FwxV'FyxV'F(xV'F, V'FFFx V'FFFand V'FFF \nAssume that a new family Fis inserted. We .rst calculate its FFsegment partitioning V'FFF, and proceed \nto compute the following three intersections: PwV'FFFxV'FFF xBxBPyPwV'FFFV'FFFBB (xwx) ) )x PPyV'FV'F \n After this insertion we will have a single temporary root. sonjl Note that after jfamilies were inserted, \nthere are at most Iyjtemporary roots. Also note that the total time for all the insertions is the same \nas in the non-incremental tree partitioning problem, h BWw5sonB i.e., . The classi.cation of a set Tis \ncarried out by consulting the list PwFP Pof the segment partitionings at the temporary roots. f Recall \nthat Pis represented as a sorted array. Since the size of this w h BWson hw B f array is bounded by \n, we can support searches in Pin time. For each vGT, we search for the id of the segment which contains \nv, in Pffor rce . Since e;Isonyl, the total h BWson son hw B time for these searches is . eG After \nobtaining an-tuple of ids for all vT, we apply a tuple partitioning algorithm to classify T. In order \nto keep the space lin\u00adear, we cannot actually store Ttuples of lengthe. Therefore, we will use the incremental \ntuple partitioning algorithm. Speci.cally, we will use Tmemory cells to .nd the .rst elements of the \ntuples, pass them to the tuple partitioning algorithm, and proceed to .nd the second elements of the \ntuples, etc. The total time for the clas\u00ad h Bsonson hw Bh BWw5B sify operation is T, while using space. \nSince every node vGTcan take part in a classi.cation opera\u00adtion at most once, the total time for all \nclassi.cations is h BWwson hwsonB The total time for insertion and classi.cation operations is h BWw5son5wson \nhwsonB h BWw5B while the total space used is .  7. Algorithm for First Order Isomorphism g hc Having \ndeveloped the algorithms for generating the linear size Prepresentation, and for ef.ciently comparing \nthe multi-sets with\u00adout actually creating them, we are ready to describe the main result of this paper: \nan ef.cient algorithm for deciding .rst order iso\u00admorphisms. In essence, the algorithm uses Lemma 4.3. \nA naive recursive application of the lemma may lead to an exponential run\u00adning time. To bound the time \ncomplexity, we instead traverse the graphs bottom-up, classifying the nodes into their isomorphisms equivalence \nclasses as we do so. The bottom-up traversal is guided by height, where all nodes of the same height \nare processed together. Height is de.ned as in Def. 3.1. Alg. 4 shows how heights can be computed in \nlinear time g hc even in the non-expanded, Prepresentation. BB Algorithm 4 Height v ghc BB Given a node \nvin a P-graph, ensure that hvistores the height BB of vifor all nodes vireachable from vand return hv. \n1: If vwas visited then BB 2: Return hv 3: mark vas visited 4: If vis an -node then BBc5BBBBBB 5: hvHeight \narg v; return hv rBBrr BBr 6: If vPP.then // vand parent vnil BBBB 7: hv; return hv// Recursion base \n// vmust be an ordinary P-node BB BB 8: hvHeight(parent v) BB G 9: For all uvdo // recurse on all (non-expanded) \nterms BBm a xBBB5BBB 10: hvhvHeight u BB 11: Return hv Given a node v, the algorithm uses a standard \nrecursive depth .rst search to visit, compute and store the height of every node vi reachable from v. \nLines 4 5 deal with the case that vis an -node. B BcBB The recursive call in this case is only on arg \nu, since ret vmust be a primitive-type. Another easy case is that vis the P. P.Since there are no terms \nin this product-node, its height is 0. Lines 8 11 deal with ordinaryP-nodes. The height of such nodes \nis one more than the maximum height of all expanded terms. The reason is that in line 8 we do not BB \nadd 1 to Height(parent v) is that the expanded terms include BBBBBB the terms parent v, and not parent \nvas a term. g hc Once the height of all nodes in P-graph is computed, Alg. 5 h can be invoked to partition \nthese nodes into equivalence classes. w We assume that unique identi.ers, drawn from the range , are \ngiven to all basic types. To process non-basic types, the algorithm relies on the fact that nodes cannot \nrepresent isomorphic types un\u00adless they are of the same kind and the same height. Accordingly, the nodes \nof .are processed by height. Algorithm 5 NodesPartitioning(.) g hc Given a P-graph .representing a \ntype in the distributive nor\u00admal form (4.1), return a partitioning .of all the nodes of .into equivalence \nclasses, such that two nodes are in the same class if and only if they represent isomorphic types. 1: \nLet Tbe an incremental tree partitioning data-structure for the tree of P-nodes of . 2: j// The identi.er \nof current isomorphism class 3: Let be the root of . eBeB 4: .Height 5: For tr.do // Process the nodes \nby height BBr 6: Let TmT{vG.hvt 7: If tis even then // TmTis a collection of P-nodes oBB 8: ...TclassifycT \nmT 9: else // mTTis a collection of -nodes 10: Partition TmTusing pair partitioning ) ) ) 11: Let the \nresulting partition be iTTroo ow wk 12: . 2... k // Update T r. 13: For do // Inserting a new family \n5 14: jj// Process a new isomorphism class j f 15: Let Fbe the multi-set of P-nodes with a term in \nB B 16: Tinsert F 17: Return . The main data-structure used by the algorithm is incremental tree partitioning \n(Lemma 6.1). Nodes at even height are P-nodes. The classi.cation of these nodes is carried out by querying \nthis data\u00adstructure. c Lines 10 16 in the algorithm take care of -nodes. Classi.ca\u00adtion of these nodes \nis carried out by a simple pair partitioning al\u00adgorithm. We then generate identi.ers for each of the \nisomorphism c classes. All c-nodes take parts as terms of P-nodes. We must make sure that two -nodes \nin the same isomorphism class are regarded as equal when comparing P-nodes in the next iteration. Line \n15 de\u00ad.nes the multi-set Fof P-nodes in which isomorphic c -nodes are terms. Note that Fis a multi-set \nsince a P-node may have several f terms belonging to . In line 16 the incremental tree partitioning \ndata structure is updated. wh BWw B LEMMA 7.1. If .has nodes and edges then, Alg. 5 h BWwtson y w B h \nBWw B runs in time and while consuming space. PROOF. We .rst note that computing the height as in Alg. \n4 requires linear time, since every node and every edge is visited at most once. The algorithm uses linear \nspace, since the two main procedures it invokes: incremental tree partitioning algorithm (lines 8 and \n16 and pair partitioning (line 10) use linear space. The running time of all the applications of the \npair partitioning h BWw B algorithm is (see Lemma 2.7). h BWw B The total number of families inserted \nis . Moreover, the h BWw B total size of those families is also , and all the sets of classi.ed nodes \nare disjoint. It follows therefore from Lemma 6.1 that the h BWwsonyw B total time of all the operations \nperformed on Tis .  The bottom-up node classi.cation of Alg. 5 can be used to solve the .rst order isomorphism \nproblem. To do so, we .rst create g hc the P-graphs of the two input types, and then merge these graphs, \nby e.g., making their roots descendants of a new PP -node. (The P. nodes of the respective graphs must \nbe uni.ed.) Alg. 5 is then in\u00advoked on the merged graph. The inputs are isomorphic if and only if these \ntwo roots are placed in the same equivalence class. THEOREM 7.2. First order isomorphism can be decided \nin h BWwtson yw B h BWw Bw time and space, where is the size of the input. g hc PROOF. As noted above \nthe P-graph representation uses lin\u00adear space. Moreover, bringing the input to this representation re\u00adquires \nlinear time. g hc The complexity of comparing inputs in the P-graph represen\u00adtation is given by Lemma \n7.1.  8. Open Problems Further research may take the following directions. 1. The only lower bound \nfor the .rst order isomorphism prob\u00adlem is the trivial information theoretic linear time. It would be \ninteresting to bridge this gap by either reducing the time complexity of our main algorithm even further, \nor obtaining better lower bounds. 2. Most programming language allow the user to de.ne types indirectly, \ni.e., by giving names to non-primitive-types, and then using these names in the de.nition of more complex \ntypes. We would like therefore to generalize our algorithm to deal with input represented as a graph \nrather than the stan\u00addard expression tree. 3. Perhaps the most important problem which this paper leaves \nopen is ef.cient algorithms for subtyping (of products, func\u00adtions, or both) which include the distributive \nand the currying axioms.   9. REFERENCES [1] A. Andreev and S. Soloviev. A deciding algorithm for linear \nh BWwsony BWw BB isomorphism of types with complexity . Lecture Notes in Computer Science, 1290:197ff, \n1997. [2] J. Auerbach, C. Barton, and M. Raghavachary. Type isomorphisms with recursive types. Technical \nReport RC 21247, IBM Research Division, Yorktown Heights, New York, August 1998. [3] J. Auerbach and \nM. C. Chu-Carroll. The mockingbird system: A compiler-based approach to maximally interoperable distributed \nprogramming. Technical Report RC 20178, IBM Research Division, Yorktown Heights, New York, February 1997. \n[4] D. A. Basin. Equality of terms containing associative-commutative functions and commutative binding \noperators is isomorphism complete. In 10th International Conference on Automated Deduction, pages 251 \n260. Springer-Verlag New York, Inc., 1990. [5] K. B. Bruce, R. D. Cosmo, and G. Longo. Provable isomorphisms \nof types. Mathematical Structures in Computer Science, 1:1 20, 1991. [6] K. B. Bruce and G. Longo. Provable \nisomorphisms and domain equations in models of typed languages. In Proc. of the 7th annual ACM symposium \non Theory of computing, pages 263 272. ACM Press, May 1985. [7] J. Considine. Deciding isomorphisms of \nsimple types in polynomial time. Technical report, CS Department, Boston University, April 2000. [8] \nR. D. Cosmo. Type isomorphisms in a type-assignment framework. In Proc. of the 19th ACM SIGPLAN-SIGACT \nsymposium on Principles of programming languages, pages 200 210. ACM Press, 1992. [9] R. Di Cosmo. Isomorphisms \nof types: from .-calculus to information retrieval and language design. Birkhauser, 1995. ISBN-0-8176-3763-X. \n [10] M. Fiore, R. D. Cosmo, and V. Balat. Remarks on isomorphisms in typed lambda calculi with empty \nand sum types. In Proc. of the 17th Annual IEEE Symposium on Logic in Computer Science (LICS 02), July \n2002. [11] J. Y. Gil. Subtyping arithmetical types. In 27th Symposium on Principles of Programming Languages, \nPOPL 01, pages 276 289, London, England, Jan.17 19 2001. ACM SIGPLAN SIGACT, ACM Press. [12] R. Gurevi.c. \nEquational theory of positive numbers with exponentiation. American Mathmatical Society, 94(1):135 141, \nMay 1985. [13] W. A. Howard. The formulaes-as-types notion of construction. In J. R. Hindley and J. P. \nSeldin, editors, To H. B. Curry: Essays on Combinatory Logic, Lambda Calculus, and Formalism, pages 479 \n490. Academic Press, 1980. [14] S. Jha, J. Palsberg, and T. Zhao. Ef.cient type matching. In Proc. of \nthe 5th Foundations of Software Science and Computation Structures, Grenoble, France, April 2002. [15] \nJ. Palsberg and T. Zhao. Ef.cient and .exible matching of recursive types. In Proc. of LICS 00, 15th \nAnnual IEEE Symposium on Logic in Computer Science, June 2000. [16] M. Rittri. Using types as search \nkeys in function libraries. Journal of Functional Programming, 1(1), 1989. [17] M. Rittri. Retrieving \nlibrary identi.ers via equational matching of types. In 10th International Conference on Automated Deduction, \npages 603 617, 1990. [18] S. V. Soloviev. The category of .nite sets and cartesian closed categories. \nJournal of Soviet Mathematics, 22(3):1387 1400, 1983. [19] A. Tarski. A Decision Method for Elementary \nAlgebra and Geometry. University of California Press, Berkeley, CA, 2nd edition, 1951. \n\t\t\t", "proc_id": "604131", "abstract": "The <i>first order isomorphism problem</i> is to decide whether two non-recursive types using product- and function-type constructors, are isomorphic under the axioms of commutative and associative products, and currying and distributivity of functions over products. We show that this problem can be solved in <i>O</i>(<i>n</i> log<sup>2</sup> <i>n</i>) time and <i>O</i>(<i>n</i>) space, where is <i>n</i> the input size. This result improves upon the <i>O</i>(<i>n</i> log<sup>2</sup> <i>n</i>) time and <i>O</i>(<i>n</i><sup>2</sup>) space bounds of the best previous algorithm. We also describe an <i>O</i>(<i>n</i>) time algorithm for the <i>linear isomorphism problem</i>, which does not include the distributive axiom, whereby improving upon the <i>O</i>(<i>n</i> log <i>n</i>) time of the best previous algorithm for this problem.", "authors": [{"name": "Yoav Zibin", "author_profile_id": "81100037778", "affiliation": "Technion---Israel Institute of Technology", "person_id": "PP36023074", "email_address": "", "orcid_id": ""}, {"name": "Joseph (Yossi) Gil", "author_profile_id": "81100349003", "affiliation": "Technion---Israel Institute of Technology", "person_id": "P149595", "email_address": "", "orcid_id": ""}, {"name": "Jeffrey Considine", "author_profile_id": "81100041358", "affiliation": "Boston University", "person_id": "P414184", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/604131.604146", "year": "2003", "article_id": "604146", "conference": "POPL", "title": "Efficient algorithms for isomorphisms of simple types", "url": "http://dl.acm.org/citation.cfm?id=604146"}