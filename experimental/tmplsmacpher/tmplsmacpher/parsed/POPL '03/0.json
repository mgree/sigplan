{"article_publication_date": "01-15-2003", "fulltext": "\n The Essence of XML J\u00b4er ome Sim\u00b4eon Philip Wadler Bell Laboratories Avaya Labs simeon@research.bell-labs.com \nwadler@avaya.com ABSTRACT The World-Wide Web Consortium (W3C) promotes XML and related standards, including \nXML Schema, XQuery, and XPath. This paper describes a formalization of XML Schema. A formal semantics \nbased on these ideas is part of the o.cial XQuery and XPath speci.cation, one of the .rst uses of formal \nmethods by a standards body. XML Schema features both named and structural types, with structure based \non tree grammars. While structural types and match\u00ading have been studied in other work (notably XDuce, \nRelax NG, and a previous formalization of XML Schema), this is the .rst work to study the relation between \nnamed types and structural types, and the relation between matching and validation. Categories and Subject \nDescriptors F.3.2 [Theory of Computation]: Logics and meanings of programs Semantics of Programming Languages \n General Terms Languages, Standardization, Theory Keywords XML, XML Schema, XPath, XQuery, validation \n1. INTRODUCTION XML is touted as an external format for representing data. This is not a hard problem. \nAll we require are two proper\u00adties: Self-describing From the external representation one should be able \nto derive the corresponding internal representation.  Round-tripping If one converts from an internal \nrep\u00adresentation to the external representation and back again, the new internal representation should \nequal the old.  Permission to make digital or hard copies of all or part of this work for personal or \nclassroom use is granted without fee provided that copies are not made or distributed for pro.t or commercial \nadvantage and that copies bear this notice and the full citation on the .rst page. To copy otherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. POPL 03, January 15 17, 2003, New Orleans, Louisiana, USA. Copyright 2003 ACM 1-58113-628-5/03/0001 \n...$5.00. Lisp S-expressions, for example, possess these properties. XML has neither property. It is \nnot always self-describing, since the internal format corresponding to an external XML description depends \ncrucially on the XML Schema that is used for validation (for instance, to tell whether data is an integer \nor a string). And it is not always round-tripping, since some pathological Schemas lack this property \n(for in\u00adstance, if there is a type union of integers and strings). So the essence of XML is this: the \nproblem it solves is not hard, and it does not solve the problem well. Nonetheless, XML and Schema are \nwidely used standards, and there is value in modeling these standards. Here we provide a model for the \ncore features of XML: XML values, XML types, and validation as described in XML Schema and used in XQuery \nand XPath. Our model di.ers from previous models it two ways. First, our model captures aspects of named \ntyping in XML Schema whereas previous models are purely structural. Second, Pre\u00advious models sought to \ncapture the notion of when a value matches a type. The model given here also captures how val\u00adidation \ntakes an external value into an internal value, and how erasure takes an internal value into an external \nvalue. XML Schema is a large and complex standard more than 300 pages in printed form. The main di.culty \nwas to understand that the essence of XML Schema lies in the way type names and structures interact. \nOur .rst surprise has been to realize that once we captured named typing and validation, most of the \nmyriad other features of XML Schema .t neatly into the simple framework presented here. We present a \ntheorem characterizing validation in terms of erasure and matching. Our second surprise has been to realize \nthat, despite XML Schema s complexity, the resulting theorem turns to be simple. Named and structural \ntypes. What s in a name? A Mon\u00adtague and a Capulet possess the same structure, and some would argue that \nis all that matters. Traditionally, there are two approaches to type systems, named and structural. The \nnamed approach is prevalent in most widely-used programming languages, including For\u00adtran, Cobol, Algol, \nPascal, C, Modula, Java, and others. The structural approach is prevalent in most theories of types, \nincluding theories of record and object types devised by Reynolds, Wand, Abadi and Cardelli, Kim, and \nothers [18, 19, 10, 1, 17]. As a simple example of the distinction between named and structural typing, \nconsider the following type declarations. type Feet = Integer type Miles = Integer In a language with \nnamed typing, this creates two new types, and one cannot pass a parameter of type Feet where a pa\u00adrameter \nof type Miles is expected. They are di.erent types because they have di.erent names. In a language with \nstruc\u00adtural typing, both Feet and Miles are synonyms for the type Integer. They are the same type because \nthey have the same structure. (Astronauts may prefer named typing. In a 1985 test for the Strategic Defense \nInitiative, a laser aimed from an observatory in Hawaii was to be bounced o. a mirror on the space shuttle. \nAn astronaut entered the height of the laser and the shuttle rolled over. The problem is that the astronaut \nentered a height of 10,023 feet (below the shuttle), which the software interpreted as 10,023 miles (above \nthe shuttle), hence the roll. [15].) The dichotomy between names and structures is not quite so stark \nas at .rst it might appear. Many languages use combinations of named and structural typing. For instance, \nin SML record types are purely structural, but two types declared with datatype are distinct, even if \nthey have the same structure. Further, relations between names always imply corresponding relations between \nstructures. For in\u00adstance, in Java if one class is declared to extend another then the .rst class always \nhas a structure that extends the sec\u00adond. Conversely, structural relations depend upon names. For instance, \nnames are used to identify the .elds of a record. Types and languages for XML. As types spread to new \nareas of computing, so too does the feud between names and structures. A case in point is XML, a standard \nfor describing documents promulgated by the World-Wide Web Consortium (W3C) [3]. There are a number of \ntype systems for XML, including: DTDs, part of the original W3C recommendation de.ning XML [3]; XML Schema, \na W3C recommendation which su\u00adpersedes DTDs [22]; Relax NG, an Oasis standard [7]; Re\u00adlax [13] and TREX \n[6], two ancestors of Relax NG; and the type systems of XDuce [11] and YATL [8]. All of these take a \nstructural approach to typing, with the exception of XML Schema, which takes a named approach, and the \npossible exception of DTDs, which are so restricted that the named and structural approaches might be \nconsidered to coincide. A type system without a programming language is like Juliet without Romeo unable \nto survive alone. The W3C is responsible for three programming languages connected with XML: XSLT, a \nlanguage for stylesheets [5, 12]; XQuery, an analogue of SQL for XML data [24]; and XPath, the common \ncore of XSLT and XQuery, which is jointly man\u00adaged by the working groups responsible for the other two \nlanguages [23]. All three of these are functional languages. XSLT 1.0 and XPath 1.0 became W3C recommendations \nin November 1999 they are untyped. XML Schema 1.0 be\u00adcame a recommendation in May 2001. XSLT 2.0, XQuery \n1.0, and XPath 2.0 are currently being designed they have type systems based on XML Schema. This paper \npresents a formalization of XML Schema, de\u00adveloped in conjunction with the XQuery and XPath working groups. \nThe paper presents a simpli.ed version, treating the essential constructs. The full version is being \ndeveloped as part of the XQuery and XPath Formal Semantics [25], one of the .rst industrial speci.cations \nto exploit formal methods. The full version treats not just XML Schema, but also the dynamic and static \nsemantics of the XQuery and XPath. XQuery has both a speci.cation in prose [24] and a formal semantics \n[25], each with parallel structure. Formal meth\u00adods are particularly helpful for typing the only complete \ndescription of the static type system of XQuery and XPath is in the formal speci.cation. However, keeping \ntwo speci.\u00adcations in sync has not always been easy. The act of preparing the formal semantics has uncovered \na number of errors or omissions in the prose speci.cation. In particular, developing the material on \nthe formal seman\u00adtics of named typing led to the formulation of ten issues for consideration by the XQuery \nworking group, each dealing with a point that was omitted in the prose speci.cation of XQuery [26]. An \nearlier formal speci.cation of XML Schema [4] was in.uenced by XDuce [11]; it ignored the named aspects \nof Schema and took a purely structural approach. The spec\u00adi.cation of Relax NG [7] also uses formal methods, \nalso is purely structural, and was in.uenced by the earlier work on XML Schema [4]. Matching and validation. \nTypes in XML di.er in some ways from types as used elsewhere in computing. Tradition\u00adally, a value matches \na type given a value and a type, either the value belongs to the type or it does not. In XML, a value \nvalidates against a type given an (external) value and a type, validation produces an (internal) value \nor it fails. For instance, consider the following XML Schema. <xs:simpleType name= feet > <xs:restriction \nbase= xs:integer /> </xs:simpleType> <xs:element name= height type= feet /> In our type system, this \nis written as follows. de.ne type feet restricts xs:integer de.ne element height of type feet Now consider \nthe following XML document. <height>10023</height> In our model, before validation this is represented \nas follows. <height>10023</height> . element height { 10023 } And after validation it is represent as \nfollows. validate as element height {<height>10023</height>} . element height of type feet { 10023 } \nValidation has annotated the element with its type, and converted the text 10023 into the corresponding \ninteger number 10023. Our model provides both validation and matching. Vali\u00addation attaches types to \nXML data. Unvalidated data may not match against a type. The following does not hold. element height \n{ 10023 } matches element height After validation, matching succeeds. The following does hold. element \nheight of type feet { 10023 } matches element height The inverse of validation is type erasure. element \nheight of type feet { 10023 } erases to element height { 10023 } The following theorem characterizes \nvalidation in terms of matching and erasure. Theorem 1. We have that validate as Type { UntypedValue \n} . Value if and only if Value matches Type Value erases to UntypedValue. (Here the stack of two judgments \nstands for their conjunc\u00adtion.) Perhaps this theorem looks obvious, but if so let us as\u00adsure you that \nit was not obvious to us when we began. It took some time to come to this formulation, and some tricky \nadjustments were required to ensure that it holds. One trick is that we model validation and erasure \nby re\u00adlations, not functions. Naively, one might expect validation to be a partial function and erasure \nto be a function. That is, for a given type each untyped value validates to yield at most one typed value, \nand each typed values erases to one untyped value. One subtlety of the system presented here is that \nvalidation and erasure are modeled by relations. For example, the strings 7 and 007 both validate to \nyield the integer 7, and hence we also have that the integer erases to yield either string. Relation \nof our model to Schema. Schema is a large and complex standard. In this paper, we attempt to model only \nthe most essential features. These include: simple types and complex types; named and anonymous types; \nglobal and local elements; atomic, list, and union simple types; and derivation by restriction and by \nextension. We model only two primitive datatypes, xs:integer and xs:string, while Schema has nineteen \nprimitive datatypes. Many features of Schema that are omitted here are dealt with in the formal semantics \nfor XQuery [25]. These in\u00adclude: namespaces; attributes; all groups (interleaving); text nodes; mixed \ncontent; substitution groups; xsi:nil attributes; and xsi:type attributes. There are other features of \nSchema that are not yet dealt with in the full formal semantics, but which we hope to model in future. \nThese include: abstract types; default and .xed values; skip, lax, and strict wild\u00adcards; and facets \nof simple types. Schema is normally written in an XML notation, but here we use a notation that is more \nreadable and compact. The mapping of XML notation into our notation is described in the XQuery formal \nsemantics. There are a few aspects in which our treatment diverges from Schema. First, we permit ambiguous \ncontent mod\u00adels, while Schema does not. We do this because it makes our model simpler, and because inferred \ntypes may be am\u00adbiguous (for instance, see the discussion of conditionals in Section 8). Second, we permit \none type to be a restriction of another whenever any value that matches against the .rst type also matches \nagainst the second, while Schema imposes ad hoc syntactic constraints. Again, we do this because it makes \nour model simpler, and because our more general model better supports type checking. Third, we only sup\u00adport \nthe occurrence operators ?, +, and *, while Schema supports arbitrary counts for minimum and maximum \noc\u00adcurrences. This is because arbitrary counts may lead to a blow-up in the size of the .nite-state automata \nwe use to check when one type is included in another. Shortcomings of XML and Schema. Our aim is to model \nXML and Schema as they exist we do not claim that these are the best possible designs. Indeed, we would \nargue that XML and Schema have several shortcomings. First, we would argue that a data representation \nshould explicitly distinguish, say, integers from strings, rather than to infer which is which by validation \nagainst a Schema. (This is one of the many ways in which Lisp S-expressions are superior to XML.) Second, \nwhile derivation by extension in Schema super\u00ad.cially resembles subclassing in object-oriented program\u00adming, \nin fact there are profound di.erences. In languages such as Java, one can typecheck code for a class \nwithout knowing all subclasses of that class (this supports separate compilation). But in XML Schema, \none cannot validate against a type without knowing all types that derive by ex\u00adtension from that type \n(and hence separate compilation is problematic). Nonetheless, XML and Schema are widely used standards, \nand there is value in modeling these standards. In partic\u00adular, such models may: (i) improve our understanding \nof exactly what is mandated by the standard, (ii) help imple\u00admentors create conforming implementations, \nand (iii) sug\u00adgest how to improve the standards. Related publications. A preliminary version of this \npa\u00adper was delivered as an invited talk at FLOPS 2002 [21]. This version has revised material in Sections \n1, 4, 6, and 7, entirely new material in Section 9, and numerous improve\u00adments throughout. Organization. \nThe remainder of this paper is organized as follows. Section 2 introduces XML Schema by example. Sec\u00adtion \n3 describes values and types. Section 4 describes four ancillary judgments. Section 5 describes matching. \nSec\u00adtion 6 describes erasure. Section 7 describes validation. Sec\u00adtion 8 presents the validation theorem \nand its application to roundtripping. Section 9 describes subtyping, constraints on sensible types, and \nand optimized matching. Section 10 concludes. 2. XML SCHEMA BY EXAMPLE XML Schema supports a wide range \nof features. These include simple types and complex types, anonymous types, global and local declarations, \nderivation by restriction, and derivation by extension. Simple and complex types. Here are declarations \nfor two elements of simple type, one element with a complex type, and one complex type. de.ne element \ntitle of type xs:string de.ne element author of type xs:string de.ne element paper of type paperType \nde.ne type paperType { element title , element author + } Schema speci.es nineteen primitive simple type \ntypes, in\u00adcluding xs:string and xs:integer. A type declaration associates a name and a structure. The \nstructure of a complex type is a regular expression over ele\u00adments. As usual, , denotes sequence, | denotes \nalternation, ? denotes an optional occurrence, + denotes one or more occurrences, and * denotes zero \nor more occurrences. Validating annotates each element with its type. validate as paper { <paper> <title>The \nEssence of Algol</title> <author>John Reynolds</author> </paper> } . element paper of type paperType \n{ element title of type string { The Essence of Algol } , element author of type string { John Reynolds \n} } Global and local declarations. Element declarations may be global at the top-level or local nested \nwithin a type declaration. Here is the above description rewritten, with paper declared globally, while \ntitle and author are de\u00adclared locally. de.ne element paper of type paperType de.ne type paperType { \nelement title of type xs:string , element author of type xs:string + } In this case, validation proceeds \nexactly as before. Allowing local declarations increases expressiveness, be\u00adcause now it is possible \nfor elements with the same name to be assigned di.erent types in di.erent places; see the con\u00ad.guration \nexample below. In XML Schema, the type of an element can be speci.ed inline, without giving it a name, \ncalled an anonymous type. In such cases, we presume that the translation to our no\u00adtation invents a suitable \nname. Thus every element has a named type, a property referred to in XQuery as pure named typing. The \ncombination of anonymous types and local types even further extends the power of the type system, so \nthat types must be characterized using tree automata [16, 9]. Because we use pure named typing, every \ntype has a global name and only traditional automata over words, not trees, are su.cient. Atomic, list, \nand union types. Every simple type is an atomic type, a list type, or a union type. The atomic types \nare the nineteen primitive types of Schema, such as xs:string and xs:integer, and the types derived from \nthem. List types are formed using the occurrence operators ?, +, and *, taken from regular expressions. \nUnion types are formed using the alternation operator |, also taken from regular expressions. Here is \nan example of a list type. de.ne element ints of type intList de.ne type intList { xs:integer+ } In \nXML notation, lists are written space-separated. validate as ints {<ints>123</ints>} . element ints of \ntype intsType { 1, 2, 3 } Some types may be ambiguous. XML Schema speci.es how to resolve this ambiguity: \nevery space is taken as a list sepa\u00adrator, and in case of a union the .rst alternative that works is \nchosen. de.ne element fact of type intOrStrList de.ne type intOrStrList { ( xs:integer | xs:string ) \n*} validate as fact {<fact>I saw 8 cats</fact>} . element fact of type intOrStrList I , saw , 8, cats \nAmbiguous types can be problematic; this will be further discussed in Section 8. Derivation by restriction \non simple types. New simple types may be derived by restriction. de.ne type miles restricts xs:integer \nde.ne type feet restricts xs:integer Here is an example where two height elements have di.erent types. \nde.ne element con.guration of type con.gurationType de.ne type con.gurationType { element shuttle of \ntype shuttleType element laser of type laserType } de.ne type shuttleType { element height of type miles \n } de.ne type laserType { element height of type miles } Validation annotates the di.erent height elements \nwith di.erent types. validate as element con.guration { <con.guration> <shuttle><height>120</height></shuttle> \n<laser><height>10023</height></laser> </con.guration> } . element con.guration of type con.gurationType \n{ element shuttle of type shuttleType { element height of type miles { 120 } } , element laser of type \nlaserType { element height of type feet { 10023 } } } Both miles and feet are subtypes of xs:integer, \nbut neither is a subtype of the other. The following function de.nition is legal. de.ne function laser-height \n( $c as element con.guration ) as element height of type feet { $c/laser/height } It would still be \nlegal if feet was replaced by xs:integer, but not if feet was replaced by miles. In this example, element \ncon.guration is the type of the formal parameter $c, and the XPath expression $c/laser/height extracts \nthe height child of the laser child of the con.guration element. Derivation by restriction on complex \ntypes. New com\u00adplex types may also be derived by restriction. The following example is a simpli.ed form \nof the information that may occur in a bibliographic database, such as that used by Bib-TeX. de.ne type \npublicationType { element author * , element title ? , element journal ? , element year ? } de.ne type \narticleType restricts publicationType { element author + , element title , element journal , element \nyear } de.ne type bookType restricts publicationType { element author + , element title , element year \n } de.ne element book of type bookType de.ne element article of type articleType A publication may have \nany number of authors, a manda\u00adtory title, and a optional journal and year. An article must have at least \none author, and a mandatory title, journal, and year. A book must have at least one author, a mandatory \ntitle and year, and no journal. Derivation by restriction declares a relationship between two types. \nThis relation depends on both names and struc\u00adtures, in the sense that one name may be derived by restric\u00adtion \nfrom another name only if every value that matches the structure of the .rst also matches the structure \nof the second. When one type is derived from another by restriction, it is .ne to pass the restricted \ntype where the base type is expected. For example, consider the following function. de.ne function getTitle \n( $p as element of type publicationType ) as element title { $p/title } Here it is acceptable to pass \neither an article or book element to the function getTitle(). There is a type xs:anyType from which all \nother types are derived. If a type de.nition does not specify otherwise, it is considered a restriction \nof xs:anyType. There is also a type xs:anySimpleType that is derived from xs:anyType and from which all \nother simple types are derived. Derivation by extension. New complex types may also be derived by extension. \nde.ne type color restricts xs:string de.ne type pointType { element x of type xs:integer , element y \nof type xs:integer } de.ne type colorPointType extends pointType { element c of type color } de.ne element \npoint of type pointType de.ne element colorPoint of type colorPointType When one type restricts another, \none must check that the proper relation holds between the types. When one type ex\u00adtends another, the \nrelation holds automatically, since values of the new type are de.ned to consist of the concatenation \nof values of the base type with values of the extension. Again, when one type is derived from another \nby exten\u00adsion, it is .ne to pass the extended type where the base type is expected. Unlike with restriction, \nthis can lead to surprising consequences. Consider the following. de.ne function countChildren ( $p as \nelement of type pointType ) as xs:integer { count($p/*) } This function counts the number of children \nof the element $p, which will be 2 or 3, depending on whether $p is an element of type point or colorPoint. \nIn XQuery, type checking requires that one knows all the types that can be derived from a given type \n the type is then treated as the union of all types that can be derived from it. Types derived by restriction \nadd nothing new to this union, but types derived by extension do. This closed world approach that type \nchecking requires knowing all the types derived from a type is quite di.erent from the open world approach \nused in many object-oriented lan\u00adguages where one can type-check a class without knowing all its subclasses. \nIn an object-oriented language, one might expect that if an element of type colorPoint is passed to this \nfunction, then the x and y elements would be visible but the c element would not be visible. Could the \nXQuery design adhere bet\u00adter to the object-oriented expectation? It is not obvious how to do so. For \ninstance, consider the above function when pointType is replaced by xs:anyType. de.ne function countChildren \n( $x as element of type xs:anyType ) as xs:integer { count($x/*) } Here it seems natural to count all \nthe children, while an object-oriented interpretation might suggest counting none of the children, since \nxs:anyType is the root of the type hi\u00aderarchy. 3. VALUES AND TYPES 3.1 Values We now give a formal de.nition \nof values. We take names, string, and integers as primitive. We do not formalize the mapping between \nXML notation and our notation for values, as it is straightforward. A value is a sequence of zero or \nmore items. An item is either an element or an atomic value. An element has an element name, an optional \ntype annotation, and a value. An element with no type annotation is the same as an element with the type \nannotation xs:anyType. An atomic value is a string or an integer. We write V alue1 , V alue2 for the \nconcatenation of two values. Value ::= () | Item(,Item)* Item ::= Element | Atom Element ::= element \nElementName OfType? { Value } OfType ::= of type TypeName Atom ::= String | Integer An untyped value \nis a sequence of zero or more untyped items. An untyped item is either an element without type annotation \nor a string. Untyped values are used to describe XML documents before validation. Every untyped value \nis a value. UntypedValue ::= () | UntypedItem(,UntypedItem)* UntypedItem ::= element ElementName {UntypedValue} \n| String A simple value consists of a sequence of zero or more atomic values. Every simple value is a \nvalue. SimpleValue ::= () | Atom(,Atom)* Here is an example of a value. element paper of type paperType \n{ element title of type xs:string { The Essence of Algol } , element author of type xs:string { John \nReynolds } } Here is an example of an untyped value. element paper { element title { The Essence of Algol \n}, element author { John Reynolds } } Here are examples of simple values. John Reynolds 10023 1, 2, \n3 3.2 Types Types are modeled on regular tree grammars [20, 9]. A type is either the empty sequence \n(()), an item type, or composed by sequence (,), choice (|), or multiple occurrence either optional \n(?), one or more (+), or zero or more (*). Type ::= () | ItemType | Type , Type | Type | Type | Type \nOccurrence Occurrence ::= ? | + | * An item type is an element type or an atomic type. Atomic types are \nspeci.ed by an AtomicTypeName;, these names include xs:string and xs:integer. Every AtomicTypeName is \nalso a TypeName. ItemType ::= ElementType | AtomicTypeName An element type gives an optional element \nname and an optional type name. An element name alone refers to a global declaration (element author). \nAn element name with a type name is a local declaration (element author of type xs:string). A type name \nalone matches any element with a type derived from the speci.ed type (element of type publi\u00adcationType). \nThe word element alone matches any element. ElementType ::= element ElementName? OfType? A simple type \nis composed from atomic types by choice or occurrence. Every simple type is a type. SimpleType ::= AtomicTypeName \n| SimpleType | SimpleType | SimpleType Occurrence At the top level one can de.ne elements and types. \nA global element declaration, like a local element declaration, consists of an element name and a type \nspeci.er. A global type declaration consists of a type name and a type deriva\u00adtion. De.nition ::= de.ne \nelement ElementName OfType | de.ne type TypeName TypeDerivation A type derivation either restricts an \natomic type, or re\u00adstricts a named type to a given type, or extends a named type by a given type. TypeDerivation \n::= restricts AtomicTypeName | restricts TypeName { Type } | extends TypeName { Type } The two XML Schema \nbuilt-in types xs:anySimpleType and xs:anyType are de.ned as follows. de.ne type xs:anySimpleType restricts \nxs:anyType { ( xs:integer | xs:string ) * } de.ne type xs:anyType restricts xs:anyType { ( xs:anySimpleType \n| element) * }  4. ANCILLARY JUDGMENTS We now de.ne four ancillary judgments that are used in matching \nand validation. Here is the rule from matching that uses these judgments. ElementType yields BaseElementName \nof type BaseTypeName BaseTypeName resolves to Type ElementName substitutes for BaseElementName TypeName \nderives from BaseTypeName Value matches Type element ElementName of type TypeName { Value } matches \nElementType The element type yields a base element name and a base type name, and the base type name \nresolves to a type. Then the given element matches the element type if three things hold: the element \nname must be substitutable for the base element name, the type name must derive from the base type name, \nand the value must match the type. The next four sections de.ne the .rst four judgments in the hypothesis \nof the above rule. 4.1 Yields The judgment ElementType yields ElementName OfType takes an element type \nand yields an element name and a type name. We assume that the element names include a special wildcard \nname *, which is returned if the element type does not specify an element name. For example, element \nauthor yields author of type xs:string element height of type feet yields height of type feet element \nof type feet yields * of type feet element yields * of type xs:anyType If the element type is a reference \nto a global element, then it yields the the name of the element and the type speci.er from the element \ndeclaration. (Note the use of a top-level de.nition as a hypothesis.) de.ne element ElementName OfType \nelement ElementName yields ElementName OfType If the element type contains an element name and a type \nspeci.er, then it yields the given element name and type speci.er. element ElementName OfType yields \nElementName OfType If the element type contains only a type speci.er, then it yields the wildcard name \nand the type speci.er. element OfType yields * OfType If the element type has no element name and no \ntype speci.er, then it yields the wildcard name and the type xs:anyType. element yields * of type xs:anyType \n 4.2 Resolution The judgment TypeName resolves to Type resolves a type name to a type. For example, feet \nresolves to feet and bookType resolves to element author + , element title , element year and colorPoint \nresolves to element x of type xs:integer , element y of type xs:integer , element c of type color If \nthe type name is de.ned by restriction of an atomic type, then return the atomic type. de.ne type TypeName \nrestricts AtomicTypeName TypeName resolves to AtomicTypeName If the type name is de.ned by restriction \nof a non-atomic type, then return the restricted given type. de.ne type TypeName restricts BaseTypeName \n{ Type } TypeName resolves to Type If the type name is de.ned by extension, then resolve the base type \nname to get the base type, and return the con\u00adcatenation of the base type and the given type. de.ne type \nTypeName extends BaseTypeName { Type } BaseTypeName resolves to BaseType TypeName resolves to BaseType \n, Type 4.3 Substitution The judgment ElementName1 substitutes for ElementName2 holds when the .rst element \nname may substitute for the second element name. This happens when the two names are equal, or when the \nsecond name is the wildcard element name *. For example: book substitutes for book book substitutes for \n* (We do not discuss element substitution groups here, but the judgment generalizes neatly to handle \nthese.) An element name may substitute for itself. ElementName substitutes for ElementName An element \nname may substitute for the distinguished element name *. ElementName substitutes for * 4.4 Derives \nThe judgment TypeName1 derives from TypeName2 holds when the .rst type name derives from the second type \nname. For example, bookType derives from bookType bookType derives from publicationType bookType derives \nfrom xs:anyType This relation is a partial order: it is re.exive and transitive by the rules below, and \nit is asymmetric because no cycles are allowed in derivation by restriction or extension. Derivation \nis re.exive and transitive. TypeName derives from TypeName TypeName1 derives from TypeName2 TypeName2 \nderives from TypeName3 TypeName1 derives from TypeName3 Every type name derives from the type it is \ndeclared to derive from by restriction or extension. de.ne type TypeName restricts BaseTypeName TypeName \nderives from BaseTypeName de.ne type TypeName restricts BaseTypeName { Type } TypeName derives from BaseTypeName \nde.ne type TypeName extends BaseTypeName { Type } TypeName derives from BaseTypeName  5. MATCHES The \njudgment Value matches Type holds when the given value matches the given type. For example, element con.guration \nof type con.gurationType { element shuttle of type shuttleType { element height of type miles { 120 \n} } , element laser of type laserType { element height of type feet { 10023 } } } matches element con.guration \n and element author of type xs:string { Robert Harper } , element author of type xs:string { John Mitchell \n} matches element author of type xs:string + and 10023 matches feet The empty sequence matches the empty \nsequence type. () matches () If two values match two types, then their sequence matches the corresponding \nsequence type. Value1 matches Type1 Value2 matches Type2 Value1 , Value2 matches Type1 , Type2 If a \nvalue matches a type, then it also matches a choice type where that type is one of the choices. Value \nmatches Type1 Value matches Type1 | Type2 Value matches Type2 Value matches Type1 | Type2 A value matches \nan optional occurrence of a type if it matches either the empty sequence or the type. Value matches () \n| Type Value matches Type? A value matches one or more occurrences of a type if it matches a sequence \nof the type followed by zero or more occurrences of the type. Value matches Type , Type* Value matches \nType+ A value matches zero or more occurrences of a type if it matches an optional one or more occurrences \nof the type. Value matches Type+? Value matches Type* A string matches an atomic type name if the atomic \ntype name derives from xs:string. Similarly for integers. AtomicTypeName derives from xs:string String \nmatches AtomicTypeName AtomicTypeName derives from xs:integer Integer matches AtomicTypeName The rule \nfor matching elements was explained at the be\u00adginning of Section 4. ElementType yields BaseElementName \nof type BaseTypeName BaseTypeName resolves to Type ElementName substitutes for BaseElementName TypeName \nderives from BaseTypeName Value matches Type element ElementName of type TypeName { Value } matches \nElementType 6. ERASURE The judgment Value erases to UntypedValue holds when the given value erases to \nthe untyped value. For example, element con.guration of type con.gurationType { element shuttle of type \nshuttleType { element height of type miles { 120 } } , element laser of type laserType { element height \nof type feet { 10023 } } } erases to element con.guration { element shuttle { element height { 120 \n} } , element laser { element height { 10023 } } } Erasure turns all atomic values into strings, and \nconcate\u00adnates any adjacent strings in the result with a separating space. No space is added when an atomic \nvalue is adjacent to an element. For example, element ints of type intsType { 1, 2, 3 } erases to element \nints 1 2 3 and element fact of type intOrStr { I , saw , 8, cats } erases to element fact { I saw 8 \ncats } and element mixed of type xs:anyType { I saw , eight , element em of type xs:string { cats } \n} erases to element mixed { I saw eight , element em { cats }} (In the last, note no space is inserted \nbefore the element.) Erasure is de.ned as a relation. Since an integer has more than one string representation, \nit may have more than one erasure. For example, 7 erases to 7 7 erases to 007 The empty sequence erases \nto itself. () erases to () The erasure of the concatenation of two values yields the concatenation of \ntheir erasures. If the .rst erasure ends in a string and the second erasure begins with a string, concate\u00adnate \nthe strings with an intervening space. Value1 erases to UntypedValue1 , String1 Value2 erases to String2 \n, UntypedValue2 String3 = concat(String1, , String2) Value1 , Value2 erases to UntypedValue1 , String3 \n, UntypedValue2 Value1 erases to UntypedValue1 Value2 erases to UntypedValue2 UntypedValue1 does not \nend in a string or UntypedValue2 does not begin with a string Value1 , Value2 erases to UntypedValue1 \n, UntypedValue2 The erasure of an element is an element that has the same name and the erasure of the \ngiven content. Value erases to UntypedValue element ElementName of type TypeName { Value } erases to \nelement ElementName { UntypedValue } A string erases to itself. String erases to String An integer erases \nto any string that represents it. integer-of-string(String) erases to String 7. VALIDATION The judgment \nvalidate as Type { UntypedValue } . Value holds if validating the untyped value against the type suc\u00adceeds \nand returns the validated value. For example, validate as element con.guration { element con.guration \n{ element shuttle { element height { 120 } } , element laser { element height { 10023 } } } } . element \ncon.guration of type con.gurationType { element shuttle of type shuttleType { element height of type \nmiles { 120 } } , element laser of type laserType { element height of type feet { 10023 } } } and validate \nas element ints { element ints { 1 2 3 } } . element ints of type intsType { 1, 2, 3 } Validating the \nempty sequence as the empty type yields the empty sequence. validate as () { () } . () Validating a concatenation \nof untyped values against a concatenation of types yields the concatenation of the vali\u00addated values. \nDecomposing a concatenation of untyped val\u00adues removes a space between adjacent strings, inverting the \ncorresponding rule for erasure. validate as Type1 { UntypedValue1 , String1 } . Value1 validate as Type2 \n{ UntypedValue2 , String2 } . Value2 String3 = concat(String1, , String2) validate as Type1 , Type2 \n{ UntypedValue1 , String3 , UntypedValue2 } . Value1 , Value2 validate as Type1 { UntypedValue1 } . Value1 \nvalidate as Type2 { UntypedValue2 } . Value2 UntypedValue1 does not end in a string or UntypedValue2 \ndoes not begin with a string validate as Type1 , Type2 { UntypedValue1 , UntypedValue2 } . Value1 , Value2 \nValidating a value against a choice type yields the result of validating the value as either the .rst \nor second type in the choice. validate as Type1 { UntypedValue } . Value validate as Type1 | Type2 { \nUntypedValue } . Value validate as Type2 { UntypedValue } . Value validate as Type1 | Type2 { UntypedValue \n} . Value The validation rules for occurrences are similar to the rules for occurrences in matching. \nvalidate as (() | Type) { UntypedValue } . Value validate as Type?{ UntypedValue } . Value validate as \n(Type , Type*) { UntypedValue } . Value validate as Type+{ UntypedValue } . Value validate as Type+? \n{ UntypedValue } . Value validate as Type*{ UntypedValue } . Value Validating a string against an atomic \ntype derived from xs:string yields the string itself. AtomicTypeName derives from xs:string validate \nas AtomicTypeName { String } . String Validating a string against an atomic type derived from xs:integer \nyields the result of converting the string to an integer. AtomicTypeName derives from xs:integer validate \nas AtomicTypeName { String } . integer-of-string(String) Validating an element against an element type \nis described by the following rule. ElementType yields BaseElementName of type BaseTypeName BaseTypeName \nresolves to Type ElementName substitutes for BaseElementName validate as Type { UntypedValue } . Value \n validate as ElementType { element ElementName { UntypedValue } } . element ElementName of type TypeName \n{ Value } The element type yields a base element name and a base type name, and the base type name resolves \nto a type. Then the given element validates against the element type if three things hold: the element \nname must be substitutable for the base element name, the type name must derive from the base type name, \nand the untyped value must validate against the type. The resulting element has the element name, the \ntype name, and the validated value. 8. THE VALIDATION THEOREM We characterize validation in terms of \nerasure and match\u00ading, and show that roundtripping holds for unambiguous types. Unambiguous for validation. \nValidation is a judgment that relates a type and an untyped value to a value. validate as Type { UntypedValue \n} . Value In most of the examples we have seen, validation behaves as a partial function. That is, for \na given type, for every untyped value, there is at most one value such that the above judgment holds. \nIn this case, we say the type is unambiguous for validation. But just as there is more than one way to \nskin a cat, sometimes there is more than one way to validate a value. Here is an example of an ambiguous \ncomplex type: de.ne element amb { element elt of type xs:integer | element elt of type xs:string } validate \nas amb {<amb><elt>1</elt></amb>} . element amb { element elt of type xs:integer { 1 }} validate as amb \n{<amb><elt>1</elt></amb>} . element amb { element elt of type xs:string { 1 }} This type is permitted \nby our model, but prohibited by XML Schema. So in practice this sort of ambiguity does not arise. Here \nis an example of an ambiguous simple type: validate as intOrStrList { one 2 3 } . one 2 3 validate as \nintOrStrList { one 2 3 } . one 2 , 3 validate as intOrStrList { one 2 3 } . one , 2 , 3 validate as intOrStrList \n{ one 2 3 } . one , 2, 3 This type is permitted by our model, and also permitted by XML Schema. XML Schema \nrequires that simple list types are always space separated, and that the simple union types always return \nthe .rst of the possible unions. So XML Schema is unambiguous, in that it speci.es that the last of the \nabove interpretations must be chosen. Nonetheless, this sort of ambiguity does lead to practical problems, \nas discussed below. Our formal model di.ers from Schema for two reasons. First, while Schema is concerned \nsolely with validation of a value against a user de.ned type, XQuery must also support type inference. \nAnd while it may be reasonable to require that a user write types that are unambiguous, it is not rea\u00adsonable \nto place this restriction on a type inference system. For example, if expression e0 has type xs:boolean \nand e1 has type t1 and e2 has type t2, the expression if (e0) then e1 else e2 has type t1|t2, and it \nis not reasonable to require that t1 and t2 be disjoint. Second, de.ning validation as a relation rather \nthan a function permits a simple characterization of validation in terms of matching and erasure, as \ngiven below. Unambiguous for erasure. Erasure is a judgment that relates a value to an untyped value. \nValue erases to UntypedValue Again, in most of the examples we have seen, erasure be\u00adhaves as a function. \nThat is, for a given value, there is exactly one untyped value such that the above judgment holds. Indeed, \nthe only ambiguity arises when the value is an integer or contains an integer. This ambiguity occurs \nbecause there is more than one string represents the same integer, and hence there is more than one way \nto erase it. For example, the integer 7 is represented by both 7 and 007 , and so has both of these as \nerasures. If a type does not contain any integers, then we say it is unambiguous for erasure. The validation \ntheorem. We can characterize validation in terms of erasure and matching. Theorem 1. (Validation) We \nhave that validate as Type { UntypedValue } . Value if and only if Value matches Type Value erases to \nUntypedValue. Proof. By induction over derivations. Roundtripping. We would like to know that if we \nconvert an internal value of a given type to an external value (us\u00ading erasure) and then convert the \nexternal value back to an internal value (using validation against that type) that we again end up back \nwhere we started, so long as the type is unambiguous. This follows immediately from the validation theorem. \nCorollary 1. (Roundtripping) If Value matches Type Value erases to UntypedValue validate as Type { UntypedValue \n} . Value. Type is unambiguous for validation then Value = Value. Proof. By the validation theorem, \nwe have that the .rst two hypotheses are equivalent to validate as Type { UntypedValue } . Value Taking \nthis together with the third hypothesis and the fact that validate is a partial function when the type \nis unam\u00adbiguous, the conclusion follows immediately. For example, we have element author of type string \n{ John Reynolds } erases to <author>John Reynolds</author> and validate as element author of type string \n{ <author>John Reynolds</author> } . element author of type string { John Reynolds } which satis.es \nroundtripping. On the other hand, we have element fact of type intOrStr { one , 2 , 3 } erases to <fact>one \n2 3</fact> and validate as element fact of type intOrStr { <fact>one 2 3</fact> } . element fact of \ntype intOrStr { one , 2, 3 } which does not satisfy roundtripping. Because XML Schema prohibits ambiguous \ncomplex types, the only counterexam\u00adples to roundtripping involve simple types that are lists or unions. \nUsers will stub their toes on this rarely, but when they do it will hurt! Reverse roundtripping. Similarly, \nwe would like to know that if we convert an external value to an internal value (using validation) and \nthen convert the internal value back to an external value (using erasure) that we end up back where we \nstarted, so long as the type is unambiguous for erasure. Again, this follows immediately from the validation \ntheorem. Corollary 2. (Reverse roundtripping) If validate as Type { UntypedValue } . Value Value erases \nto UntypedValue. Type is unambiguous for erasure then UntypedValue = UntypedValue. . Proof. From the \n.rst hypothesis and the validation the\u00adorem we have that Value erases to UntypedValue Taking this together \nwith the second hypothesis and the fact that erasure is a function, the conclusion follows imme\u00addiately. \nFor example, we have validate as element author of type string { <author>John Reynolds</author> } . element \nauthor of type string { John Reynolds } and element author of type string { John Reynolds } erases to \n<author>John Reynolds</author> which satis.es reverse roundtripping. On the other hand, we have validate \nas element height of type feet { <height>007</height> } . element height of type feet { 7 } and element \nheight of type feet { 7 } erases to <height>7</height> which does not satisfy reverse roundtripping. \nThe only counterexamples to reverse roundtripping in\u00advolve leading zeros or other cases where base types \nhave multiple representations. Unlike roundtripping, this is not a serious problem. 9. SENSIBILITY A \nvalue is sensible if whenever it contains an element with a type annotation, then the value of the element \nmatches the type in the annotation. This section de.nes sensible values, and observes that the value \nreturned by validation is always sensible. This fact can be used to optimize matching. 9.1 Subtype We \ncan easily de.ne a notion of structural subtyping, sim\u00adilar to that used in XDuce [11]. When one type \nis declared to derive from another type by restriction, we expect that the .rst type should be a subtype \nof the second. The judgment Type1 subtype Type2 holds if every value that matches the .rst type also \nmatches the second. For example, element of type feet subtype element of type xs:integer element author \n+ subtype element author * element of type bookType subtype element of type publicationType Subtyping \nis the only judgment that is not de.ned by structural inference rules. Instead, it is de.ned by a logical \nequivalence. We have Type1 subtype Type2 if and only if for every Value we have Value matches Type1 implies \nValue matches Type2. Subtyping can be checked by straightforward modi.cation to well-known algorithms \nfor checking for inclusion between the languages generated by two regular expressions [2]. Other type \nsystems for XML (such as XDuce or YATL) require subtyping algorithms based on tree regular expres\u00adsions \nand .nite state tree automata [11, 14, 20, 9]. Here we can use ordinary regular expressions and ordinary \n.nite state automata because pure named typing guarantees that one can check that an element matches \nagainst a type by looking only at the element name (not the element contents) as described in 9.4. 9.2 \nSensible de.nition The judgment De.nition ok holds if an element or type de.nition is sensible. An element \nde.nition is always sensible. de.ne element ElementName OfType ok A restriction of an atomic type is \nalways sensible. de.ne type TypeName restricts AtomicTypeName ok A restriction to a given type is sensible \nif the type is a subtype of the base type. BaseTypeName resolves to BaseType Type subtype BaseType de.ne \ntype TypeName restricts BaseTypeName { Type } ok An extension is always sensible. de.ne type TypeName \nextends BaseTypeName { Type } ok 9.3 Sensible value The judgment Value ok holds if a value is sensible. \nThe empty sequence is sensible. () ok If two values are sensible, then their sequence is sensible. Value1 \nok Value2 ok Value1 , Value2 ok An element is sensible if the value is sensible, and if the value matches \nthe annotated type. TypeName resolves to Type Value ok Value matches Type element ElementName of type \nTypeName { Value } ok An atomic value is sensible. Atom ok 9.4 Optimized matching Validation always yields \na sensible value. Theorem 2. (Sensibility) If validate as Type { UntypedValue } . Value then Value ok \nProof. By induction on derivations. As a corollary, matching against an element can be greatly simpli.ed. \nCorollary 3. (Optimized matching) In the rule ElementType yields BaseElementName of type BaseTypeName \nBaseTypeName resolves to Type ElementName substitutes for BaseElementName TypeName derives from BaseTypeName \nValue matches Type element ElementName of type TypeName { Value } matches ElementType the hypothesis \nValue matches Type need not be tested if the element is the result of validation. Optimized matching \nis both easier to implement and more e.cient to execute. The simpli.cation is a consequence of pure named \ntyping, which ensures that every validated ele\u00adment contains a type name that accurately characterizes \nits contents. 10. CODA In October 2002 the XQuery working group decided to adopt pure named typing. The \n.nal step before adoption was a presentation describing how pure named typing sim\u00adpli.es the formal semantics. \nThe presentation was followed by unanimous agreement to adopt pure named typing. In the two-day meeting, \nthis was the only decision adopted without dissent a resounding demonstration of the value of formal \nsemantics! 11. REFERENCES [1] Martin Abadi and Luca Cardelli A Theory of Objects Springer-Verlag, 1996. \n[2] Alfred Aho, John Hopcroft, Je.rey Ullman. The Design and Analysis of Computer Algorithms. Addison \nWesley, 1974. [3] Tim Bray, Jean Paoli, and C. M. Sperberg-McQueen. Extensible Markup Language (XML) \n1.0. W3C Recommendation, February 1998. [4] Allen Brown, Matthew Fuchs, Jonathan Robie, and Philip Wadler. \nMSL -a model for W3C XML Schema. In Proceedings of International World Wide Web Conference, pages 191 \n200, Hong Kong, China, 2001. [5] James Clarke. XSL Transformations (XSLT) version 1.0. W3C Recommendation, \nNovember 1999. [6] James Clarke. TREX Tree Regular Expressions for XML. Thai Open Source Software Center, \nFebruary 2001. [7] James Clarke and Murata Makoto. RELAX NG speci.cation. Oasis, December 2001. [8] \nSophie Cluet, Claude Delobel, J\u00b4er ome Sim\u00b4eon, and Katarzyna Smaga. Your mediators need data conversion! \nIn Proceedings of ACM Conference on Management of Data (SIGMOD), pages 177 188, Seattle, Washington, \nJune 1998. [9] H. Comon, M. Dauchet, R. Gilleron, F. Jacquemard, D. Lugiez, S. Tison, and M. Tommasi. \nTree automata techniques and applications, 1997. [10] Carl Gunter and John Mitchell. Theoretical Aspects \nof Object-Oriented Programming. MIT Press, 1994. [11] Haruo Hosoya and Benjamin C. Pierce. XDuce: an \nXML processing language. In International Workshop on the Web and Databases (WebDB 2000), Dallas, Texas, \nMay 2000. [12] Michael Kay. XSL Transformations (XSLT) version 2.0. W3C Working Draft, April 2002. [13] \nMurata Makoto. Document description and processing languages regular language description for XML (relax), \nOctober 2000. [14] Frank Neven. Automata Theory for XML Researchers. SIGMOD Record 31(3), September 2002. \n[15] Peter Neumann. Risks to the public from the use of computers. ACM Software Engineering Notes 10(3), \nJuly 1985. [16] Yannis Papakonstantinou and Victor Vianu. DTD inference for views of XML data. In Proceedings \nof ACM Symposium on Principles of Database Systems (PODS), Dallas, Texas, May 2000. [17] Benjamin C. \nPierce. Types and Programming Languages. MIT Press, 2002. [18] John C. Reynolds. Syntactic Control of \nInterference In Fifth ACM Symposium on Principles of Programming Languages, Tucson, AZ, Jan 1978, pages \n36 49. [19] John C. Reynolds. The essence of Algol. In J. W. de Bakker and J. C. van Vliet, editors, \nAlgorithmic Languages. North-Holland, Amsterdam, 1981, pages 345-372. [20] Grzegorz Rozenberg and Arto \nSalomaa, editors. Handbook of Formal Languages. Springer-Verlag, 1997. [21] J\u00b4er ome Sim\u00b4eon and Philip \nWadler. The essence of XML (preliminary version) [invited talk]. In International Symposium on Functional \nand Logic Programming (FLOPS), Aizu, Japan, September 2002. Springer-Verlag, 2002. [22] Henri S. Thompson, \nDavid Beech, Murray Maloney, and N. Mendelsohn. XML Schema part 1: Structures. W3C Recommendation, May \n2001. [23] XPath 2.0. W3C Working Draft, November 2002. [24] XQuery 1.0: An XML Query Language. W3C Working \nDraft, November 2002. [25] XQuery 1.0 Formal Semantics. W3C Working Draft, November 2002. [26] XQuery \nFormal Semantics FS Issue-0141 FS Issue-0151.    \n\t\t\t", "proc_id": "604131", "abstract": "The World-Wide Web Consortium (W3C) promotes XML and related standards, including XML Schema, XQuery, and XPath. This paper describes a formalization of XML Schema. A formal semantics based on these ideas is part of the official XQuery and XPath specification, one of the first uses of formal methods by a standards body. XML Schema features both named and structural types, with structure based on tree grammars. While structural types and matching have been studied in other work (notably XDuce, Relax NG, and a previous formalization of XML Schema), this is the first work to study the relation between named types and structural types, and the relation between matching and validation.", "authors": [{"name": "J&#233;r&#244;me Sim&#233;on", "author_profile_id": "81100341601", "affiliation": "Bell Laboratories", "person_id": "P414183", "email_address": "", "orcid_id": ""}, {"name": "Philip Wadler", "author_profile_id": "81100173596", "affiliation": "Avaya Labs", "person_id": "PP39030941", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/604131.604132", "year": "2003", "article_id": "604132", "conference": "POPL", "title": "The essence of XML", "url": "http://dl.acm.org/citation.cfm?id=604132"}