{"article_publication_date": "01-15-2003", "fulltext": "\n The M-calculus: A Higher-Order Distributed Process Calculus Alan Schmitt Jean-Bernard Stefani INRIA \nINRIA alan.schmitt@inria.fr jean-bernard.stefani@inria.fr ABSTRACT This paper presents a new distributed \nprocess calculus, called the M-calculus, that can be understood as a higher-order version of the Distributed \nJoin calculus with programmable localities. The calculus retains the implementable character of the Distributed \nJoin calculus while overcoming several important limitations: insu.cient control over communica\u00adtion \nand mobility, absence of dynamic binding, and limited locality semantics. The calculus is equipped with \na poly\u00admorphic type system that guarantees the unicity of locality names, even in presence of higher-order \ncommunications a crucial property for the determinacy of message routing in the calculus. Categories \nand Subject Descriptors F.m [Theory of Computation]: Miscellaneous  General Terms Design, Languages, \nTheory  Keywords Process Calculi, Distribution, Mobility, Higher Order, Type Systems 1. INTRODUCTION \nAmong the process calculi which have been introduced over the past decade to serve as a basis for a distributed \nand mobile programming model, the Distributed Join calcu\u00adlus [7, 6, 11] constitutes an interesting milestone. \nIt provides a distributed programming model with hierarchical fail-stop localities, transparent mobility \nand communications, and it can be e.ciently implemented. The Distributed Join calcu\u00adlus, however, has \nseveral limitations: This work has been supported in part by the Mikado IST Global Computing Project \n(IST-2001-32222) Permission to make digital or hard copies of all or part of this work for personal or \nclassroom use is granted without fee provided that copies are not made or distributed for pro.t or commercial \nadvantage and that copies bear this notice and the full citation on the .rst page. To copy otherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. POPL 03, January 15 17, 2003, New Orleans, Louisiana, USA. Copyright 2003 ACM 1-58113-628-5/03/0001 \n...$5.00. It o.ers insu.cient control over communication and process mobility, which is an issue in \ndistributed en\u00advironments where security is a primary concern. For instance, it is not possible to prevent \na locality from migrating to another locality, except by forcing its fail\u00adure. Also, once a resource \n(a Distributed Join calculus de.nition) has been de.ned and communicated, it is very di.cult to prevent \naccess to that resource or to de.ne the equivalent of a .rewall [4].  It does not support dynamic binding. \nIn a distributed programming model, it is important to provide both local and remote equivalent of libraries \nor services, be\u00adcause of the cost, safety, and security considerations that may apply. Thus, it should \nbe possible to access identically named libraries or services (like a print ser\u00advice) at di.erent sites. \nIn the Distributed Join calculus such a choice is not directly available since each de.ni\u00adtion is uniquely \nde.ned: every resource is permanently bound to a single locality.  It does not support the de.nition \nof localities with di.erent semantics. For instance, localities in the Dis\u00adtributed Join calculus are \nde.ned to be fail-stop. While it would be possible to change the semantics of the cal\u00adculus to accommodate \ndi.erent failure modes (such as omission or byzantine failures), the question remains as to how one can \ncombine di.erent failure modes within the same calculus. Likewise, one could require a locality to be \nendowed with a particular form of ac\u00adcess control (e.g. restricting access to resources within a locality \nto principals appearing in an access control list).  The M-calculus presented in this paper is designed \nto over\u00adcome the limitations of the Distributed Join calculus while preserving some of its key features, \nnotably, its concept of hierarchical localities (which is crucial to deal with security, migration, and \nfailures), its notion of multiway synchroniza\u00adtion, and its implementable character. Speci.cally, the \nmain contributions of this paper are: the notion of programmable locality, that generalizes the di.erent \nconcepts of locality found in the Dis\u00adtributed Join calculus and other distributed process calculi; \n the conjunction of higher-order processes and hierar\u00adchical programmable localities to unify communication \nand process migration, combining the possibility of  P ::= process 0 null process ||||||||| V a(P)[P] \nP | P PP (P,...,P) .n.P ([\u00b5 = V]P,P) (JrP) pass V value locality parallel composition application tuple \nrestriction conditional reaction rule passivation V ::= value () null value ||| u (V,...,V) .x.P name \ntuple abstraction J ::= Join pattern rx message | J | J synchronization Figure 1: Syntax of the M-calculus \ntransparent routing as in the Distributed Join calculus with .ne-grained ambient-like control over information \nexchange; the introduction of a passivation operator as a key primitive for programming di.erent forms \nof control that can be exercised by localities;  the de.nition of a type system that guarantees the \nde\u00adterminacy of the routing mechanism by ensuring that every locality bears a unique name, even in presence \nof higher-order communication.  A programmable locality in the M-calculus (or locality, in brief) has \na name and contains two processes: a con\u00adtroller, which .lters incoming and outgoing messages, and a \ncontent. In order to apply the same control mechanisms to remote communication and process migration, \nthe latter is just communication of a thunk, i.e. a frozen process. A running locality may be frozen \nby its controller using the passivation operator. This operator takes a function that de.nes the operations \nto apply on the controller and con\u00adtent processes of a locality, such as sending them in a remote message, \ndiscarding them, or modifying them. The paper is organized as follows. Section 2 de.nes the syntax and \noperational semantics of the M-calculus. Sec\u00adtion 3 introduces a type system that ensures the unicity \nof locality names. Section 4 gives an encoding of the Join cal\u00adculus that illustrate the versatility \nof the calculus. Section 5 discusses related work. Section 6 concludes the paper.  2. THE M-CALCULUS \nWe present in this section the M-calculus, introducing the syntax and the semantics as we describe local \ncommunica\u00adtion, remote communication, control, and migration. The syntax is summarized in .gures 1 and \n2. In the following, we use bold fonts for identi.ers that may stand for names or variables, as described \nin .gure 2. Communication takes the form of an asynchronous, chan\u00adnel-based, point-to-point exchange \nof messages, re.ecting the dominant mode of communication in current large scale n ::= resolved name \nr resource name | a locality name r ::= variable resource name r resource name | x variable a ::= variable \nlocality name a locality name | x variable u ::= name a variable locality name | r variable resource \nname | a.r located resource \u00b5 ::= name pattern n resolved name wildcard | Figure 2: Names E ::= ( \u00b7 ) \n| EV | PE | .n.E | (E | P) | (P | E) | a(P)[E] | a(E)[P] | (P1,...,E,...,Pn) Figure 3: Evaluation Contexts \nnetworks. Channels are called resources and we assume there is an in.nite countable set of resource names. \nWe let r range over this set. A local message is an application of a resource name to a tuple of values \nrVX. Receivers in the M-calculus are reaction rules composed of a multiway synchronization pattern (similar \nto the one proposed infor\u00admally by Milner for his Polynomial p-calculus and to Join patterns), and of \na guarded process. Every reaction rule (r1xx1 | ... | rnxxn CP) de.nes theresourcenames r1, ..., rn. \nThe formal parameters xx1, ..., xxn are tuples of vari\u00adables, and we assume there is an in.nite countable \nset of variables. The local communication rule is very similar to the Join rule of the Join calculus, \nsubstituting message ar\u00adguments for formal arguments in the guarded process (rule R.Res of .gure 4). \nWe remark that the reaction rule is repli\u00adcated: it does not disappear after reduction. We also remark \nthat a reaction rule does not bind its de.ned names. New resource names are introduced and bound using \na restriction operator .r.P. In the reduction rules of .gure 4, rule R.Context uses evaluation contexts \nde.ned in .gure 3, and rule R.Equiv uses structural equivalence. Structural equivalence, =,isthe smallest \nequivalence relation that satis.es the rules given in Figure 5, where the parallel composition operator \n| for pro\u00adcesses is taken to be commutative and associative, with 0 as its neutral element. The structural \nrules comprise scope extrusion rules for the restriction operator, standard rules for equivalence under \na-conversion, and congruence for eval\u00aduation contexts. Equivalence of two processes P and Q up to a-conversion \nis noted P =a Q.We recall that in .n.P, .x.P,and (r1xx1 | ... | rnxxn CP), the names and variables n, \nx,and xXi are bound in P. Free names of a process P are de.ned as usual and written fn(P). We recall \nthat the de.ned names of a reaction rule (JCP) are free. [R.Beta] (.x.P)V .P{V/x} match(\u00b5, V ) [R.If.Then] \n([\u00b5 = V ]P,Q) .P \u00acmatch(\u00b5, V ) [R.If.Else] ([\u00b5 = V ]P,Q) .Q [R.Passiv] a(pass V |P)[Q] .Va(..P)(..Q) \n(JrP)= (r1xV1 |... |rnxVn rP) [R.Res] . (JrP)|r1VV1 |... |rnVVn .(JrP)|P{Vi/.} xi P .Q [R.Context] E(P) \n.E(Q) P =P' P' .Q' Q' =Q [R.Equiv] P .Q Figure 4: Computing Rules n .fn(Q) [S.Nu.Par] (.n.P) |Q =.n.P \n|Q n .fn(Q) . n= a [S.Nu.Ctrl] a(.n.P)[Q] =.n.a(P)[Q] .fn(P) . n= a n P =a Q [S.Nu.Cont][S.a] a(P)[.n.Q] \n=.n.a(P)[Q] P =Q P =Q [S.Context] E(P) =E(Q) Figure 5: Structural Equivalence As a communication example, \nwe may write a reference cell process as in the Join calculus: .s. (get(k) '|s(st) Ck(st) '|s(st)) )| \n|(set(st) |s(st) Cs(st)) get(print) |set(3) |s(0) which may reduce to print(0) or print(3). We now describe \nremote communication of asynchronous messages. In many calculi, remote communication involves two steps: \nresolving where to send the message, and send\u00ading it. For instance, in the Distributed Join calculus, \nevery channel is de.ned in at most one location and de.nitions cannot move from one location to another. \nThus a de.ned channel name is unambiguously associated to the location containing its de.nition. In the \ndynamic Join calculus [20], the destination for a dynamic message is resolved accord\u00ading to the channel \nname and the current position of the message. In the Ambient calculus, an ambient migrates ac\u00adcording \nto the explicit capabilities that it expresses and its local environment. The destination of a message \nin the Box\u00adp calculus [21] also depends on the immediate environment of the message. In order to avoid \nrestricting the calculus to one particular semantics, we let the resolving step be a X part of the calculus: \na remote message has the form a.rV , where a is the explicit destination of the message, which [R.A.Ctrl.Final] \na(P |a.rVx)[Q] .a(P |rVx)[Q] [R.A.Cont.Final] a(P)[Q |a.rVx] .a(P)[Q |rVx] b .locs(P) .locs(Q) .{a} [R.A.In] \nb.rVx|a(P)[Q] .a(P |i(b, r, Vx))[Q] b .locs(Q) \\locs(P) b= a [R.A.Ctrl.To.Cont] a(P |b.rVx)[Q] .a(P)[Q \n|b.rVx] b. locs(P) .locs(Q) b = a [R.A.Ctrl.To.Env] a(P |b.rVx)[Q] .a(P)[Q] |b.rVx b. locs(Q) b = a [R.A.Out] \na(P)[Q |b.rVx] .a(P |o(b, r, Vx))[Q] Figure 6: Routing Rules (Addressed Messages) locs(.n.P)= locs(P) \n\\{n} locs(PQ)= \u00d8 locs(a(P)[Q]) = a,locs(P),locs(Q) locs((JrQ))= \u00d8 locs(P |Q)= locs(P),locs(Q) locs(([\u00b5 \n= V ]P,Q)) = \u00d8 locs(pass V )= \u00d8 locs(V )= \u00d8 locs(0)= \u00d8 locs(P1,...,Pq)= \u00d8 Figure 7: Multiset of Active \nLocalities can be thus chosen by the programmer. We see that an ad\u00addressed resource a.r is composed of \nan address (a locality name), whichmay correspondtoan IP address, anda re\u00adsource name, which may correspond \nto a port number. This construction is similar to the high-level c@a construct of No\u00admadic Pict [24]. \nThe second step of remote communication is the actual sending of the message to the remote locality. \nThis communication step might be direct independently of the relative positions of the message and the \ndestination, as in the Join calculus, or it might involve several local steps, following the structure \nof localities to reach the destination, as in the Ambient calculus. We remark that these two mod\u00adels \nmay coincide when considering a .at model of localities. Just as in the Distributed Join calculus and \nin Ambient calculi, we retain the idea of hierarchically organized local\u00adities, a crucial feature for \ncapturing the spatial and logical partitioning of control in distributed systems. We assume there is \nan in.nite countable set of locality names, and we let a, b range over this set. New locality names are \nintro\u00adduced and bound by the restriction operator .a.P. To de.ne the routing rules, we write locs(P) \nfor the multiset of un\u00adrestricted active localities of P. This multiset is formally de.ned in .gure 7. \nIn the rest of this paper, we say that a process P is active in Q if Q is structurally equivalent to \na process of the form E(P) for some evaluation context E.Lo\u00adcalities in the M-calculus provide the means \nto enforce some control on incoming and outgoing messages. This control may be arbitrarily complex, may \nrequire maintaining some state, and should be kept separate from the program run\u00adning in the locality. \nFor this reason, localities take the form a(P)[Q]where a is the name of the locality, P is a process \ncontrolling the locality and its interactions with the envi\u00adronment, and Q is the content of the locality. \nThe .rst role of the controller is to .lter incoming and outgoing messages. To this end, we introduce \ntwo special resource names i and r .dln(P) r .dln(Q) [R.L.Ctrl.To.Cont] a(P |rVx)[Q] .a(P)[Q |rVx] r \n.dln(P) r .dln(Q) [R.L.Cont.To.Ctrl] a(P)[Q |rVx] .a(P |rVx)[Q] Figure 8: Routing Rules (Local Messages) \ndln(PQ)= \u00d8 dln(.n.P)= dln(P) \\{n} dln(a(P)[Q]) = \u00d8 dln((r1xV1 |...|rqxVq rP))= {r1,...,rq} dln(pass V)= \n\u00d8 dln(P |Q)= dln(P) .dln(Q) dln(V)= \u00d8 dln(([\u00b5 = V]P,Q)) = \u00d8 dln(0)= \u00d8 dln((P1,...,Pq)) = \u00d8 Figure 9: \nDe.ned local names o on which incoming and outgoing messages are intercepted (rules R.A.In and R.A.Out \nin .gure 6). On interception, an incoming or outgoing message is split into three parts: the destination \naddress, the targeted resource, and the mes\u00adsage arguments. The controller should provide a reaction \nrule for these .ltering channels, implementing the desired behavior. For instance, a locality that does \nnot want to block any message could contain the process Fwd in its con\u00adtroller, where: def Fwd = (i(x,y,z) \nCx.y z)|(o(x,y,z) Cx.y z) We remark that this de.nition is stateless and relies on the other routing \nrules to send the message to its .nal destina\u00adtion automatically: even though the routing is step by \nstep, it is not necessary to specify how to take each step. This is much di.erent from the Ambient calculus \nwhere an explicit path to the target ambient needs to be given. As localities form a tree, there is no \nnotion of site as in Nomadic Pict (a site can be modeled by a locality at a given level in the tree) \nand the routing algorithm is part of our semantics. It is however possible to express di.erent routing \nalgorithms by forwarding messages from locality to locality using some speci.ed resource. One example \nof this is the simulation of the dynamic Join calculus in the M-calculus in [19]. It is also possible \nto intercept and reroute messages using the control mechanism, as shown below. A message present in the \ncontroller is considered as hav\u00ading been controlled and may freely leave the controller (rules R.A.Ctrl.To.Cont \nand R.A.Ctrl.To.Env). A message that has reached its .nal destination becomes a local mes\u00adsage (rules \nR.A.Ctrl.Final and R.A.Cont.Final). Local messages may move freely from controller to content and vice \nversa (.gure 8), depending on where the resource is de.ned. To this end, we call de.ned local names the \nset of resources that are de.ned in a given process without in\u00adspecting sublocalities. This set is formally \nde.ned in .gure 9. We give an example of transparent incoming message routing in .gure 10. One interesting \nfeature when writing a reaction rule for the .ltering channels i and o is to be able to test the target \nlocality or resource. To this end, we introduce a simple name matching operator ([\u00b5 = V ]P,Q), whose \nsemantics (rules R.If.Then and R.If.Else in .gure 4) rely on a match() predicate, which is true only \nin the following cases: match( ,V ) match(n, n) a.rVx|b(i(d,r,v) rd.rv)a((i(d,r,v) rd.rv))[(r = ...)] \n . b(i(d,r,v) rd.rv)|i(a,r, Vx)a((i(d,r,v) rd.rv))[(r = ...)] . b(i(d,r,v) rd.rv)|a.rVxa((i(d,r,v) \nrd.rv))[(r = ...)] . b(i(d,r,v) rd.rv)a.rVx|a((i(d,r,v) rd.rv))[(r = ...)]  . b(i(d,r,v) rd.rv)a((i(d,r,v) \nrd.rv)|i(a,r, Vx))[(r = ...)] . b(i(d,r,v) rd.rv)a((i(d,r,v) rd.rv)|a.rVx)[(r = ...)] . b(i(d,r,v) \nrd.rv)a((i(d,r,v) rd.rv)|rVx)[(r = ...)] . b(i(d,r,v) rd.rv)a((i(d,r,v) rd.rv))[(r = ...)|rVx] Figure \n10: Remote communication example For instance, a .lter for incoming messages could be: (i(d,r,v) C[a \n= d](b.r v,0)) This .lter throws away any message that is not for locality a, and reroutes messages for \na to b. As in the Ambient calculus and the Join calculus, we pro\u00advide a way to modify the tree structure \nof localities. How\u00adever, we want to be able to control incoming and outgoing localities at every locality \nboundary, as is possible with re\u00admote communication. We thus unify migration and remote communication \nby considering migration as the communi\u00adcation of a frozen process. A frozen process is of the form ..P, \nand may be unfrozen by applying it to the null value (). We actually consider a generalization by embedding \na call by value .-calculus within our calculus (with the usual \u00df reduction rule R.Beta of .gure 4). We \nuse standard no\u00adtational conventions: in a term .x.P or .n.P,the scope extends as far to the right as \npossible; PQ1 ...Qn stands for (...(PQ1) ...Qn); .x1 ...xq.P stands for .x1.... .xq.P; .n1 ...nq .P stands \nfor .n1.....nq.P. Wealso makeuse of the notation ..P to stand for a thunk .x.P,with x not free in P. \nThe passivation primitive pass V ,where V is a function expecting a locality name and two frozen processes, \nis intro\u00adduced to freeze running processes. Passivation is the second role of a controller: when evaluated \nin the controller of a lo\u00adcality a(pass V |P)[Q], the locality is split into three parts: its name a, \nits frozen controller ..P,and itsfrozen content ..Q. These parts are given as arguments to the function \nV : a(pass V |P)[Q] .Va (..P)(..Q) For instance, a function V = .xpq.x(p())[q()] simply recre\u00adates the \npassivated locality. Locality mobility can be implemented using higher-order messages and passivation \n(cf the go construct in the Join calculus and ambients in and out capabilities). Locality Qm(a) below \ncan be moved to a di.erent locality: Qm(a)= a(Fwd |(go uCGo(u)))[Q] Go(u)= pass .xpq.(u.enter ..x(p())[q()]) \nArequest go b, results in the passivation of the locality a and its sending as a thunk to the resource \nenter of the lo\u00adcality named b. If the request comes from the outside of the locality, the result is \nan objective form of move. If the request comes from the content of the locality, the result is a subjective \nform of move. The controller of locality b can contain the process Enter, depicted below, to de.ne the \nre\u00adsource enter used to insert and spawn a frozen process in its content: Enter = (enter fC pass .x p \nq.x(p())[q() |f()]) Passivation may also be used to implement various forms of control on a locality. \nLocality Qo(a)below can besus\u00adpended, resumed, dissolved (cf the open capability of ambi\u00adents), and updated \nwith a new controller (we note simply r a message of the form r() ): Qo(a)= .s on.L(a, s, on) Fwd |(suspend \n|on r S(s))L(a, s, on)= a |(resume |sf rR(f, on)) )[Q] |(open rO)|(update frU(f))|on S(s)= pass .x p \nq.x(p() |(sq))[0] R(f, on)= pass .x p q.x(p() |on)[f()] O = pass .x p q.q() U(f)= pass .x p q.x(f())[q()] \n As usual, we take the reduction relation for the M-calculus, ., as the smallest relation that satis.es \nthe rules given in Figures 4, 6, and 8. We present as an example an M-calculus variant of the taxi example \npresented by L. Cardelli in [3]. The basic idea is as follows: a passenger enters a taxi by specifying \na route (list of localities to enter), a sitting behavior (to be executed while sitting in the taxi), \nand a continuation behavior (to be executed on arrival) L. Cardelli s version only comprises a route \nand a continuation behavior. A route consists of a list of locality names a1,...,an, which we represent \nby the frozen process ..route(a1, ..route(a2, M = ..., ..route(an,..route(nil,..0)) ...)) where nil is \na special locality name reserved to signal the end of the list. A passenger requests entrance in the \ntaxi named tx by emitting a message tx.enter(M, ..S, ..C) where S is the sitting behavior, and C is the \ncontinuation behavior. A taxi named tx is de.ned as follows: Taxi = .f.tx((Enter)|(Exit)|(Route)|f)[0] \nenter(r, s, c) |f C Enter = pass .x p q.x(p()|onexit(c)|r())[s()] exit |onexit(c) C Exit = pass .x p \nq.x(p()|f)[0] |q() |c() route(x, y) C Route = ( ( [nil = x] exit, pass .z pq. x.visit(..z(y() |p())[q()]) \n ) )) t ::= type . process type | s value type s ::= value type unit unit type | a plain type variable \n| dom(w) name type | s1,...,sq tuple type | s .t function type |(s). plain resource + |(s)sendable resource \n. w ::= locality name variable a locality name | d name type variable |\u00d8 no such locality . ::= locality \nname multiset \u00d8 empty multiset | . multiset variable | d name type variable | a locality name | ., . \nmultiset union s ::= .axx..s dxtype scheme Figure 11: Types: Syntax unfrozen, and the sitting behaviour \nis spawned in the con\u00adtent of the taxi, using passivation. Since the route consists of a message containing \na locality name and the rest of the route, the (Route)de.nition matches the locality name. If if it is \nnil, then the taxi has arrived, and the exit message is spawned. This message triggers the (Exit)de.nition, \nthat consumes it as well as the reference cell onexit, recreates the taxiasfreetohire(spawning the lock \nf), and spawns the continuation as well as the content of the taxi outside. If the next destination is \nnot nil, then the taxi migrates to this destination. We suppose every locality has a channel visit that \nsimply spawns its argument. The frozen taxi is thus sent to the next stop, with the remaining of the \nroute spawned in its controller.  3. THE TYPE SYSTEM The routing rules for addressed messages in Figure \n6 rely heavily on locality names and active localities. Locality namesthusplaythe role of addresses in \nthe M-calculus. However, to faithfully mirror the situation in current wide area networks, and to allow \nfor an e.ective implementation of the calculus, one must ensure the determinacy of the .nal destination \nof a remote message by ensuring that no two ac\u00adtive localities may bear the same name. Unfortunately, \nit is not possible to obtain this property by syntactic means only. In fact, even a simple type system \nwill not do because of the higher-order features of the calculus. In presence of the pas\u00ad sivation operator, \none must indeed be careful of the e.ects of functions on locality names. For instance, if a resource \ntwice is de.ned as (twice fCf() | f()), then a passivation instruction of the form pass .x p q.(twice \n..x(p())[q()]) may Intuitively, each taxi contains a private lock (here the lead to the illicit duplication \nof the passivated cell. name f) indicating the taxi is free to hire. When a pas-To enforce the unicity \nof active locality names, we intro\u00adsenger enters the taxi, the lock is consumed, the frozen con-duce \nthe following type system. The grammar for types tinuation is stored in the reference cell onexit, the \nroute is is given in Figure 11. We remark that terms in the M\u00ad . =. ' . . .. ' '' )i.[1..n] sx=sx. (si \n=s i '' unit =unit s .t =s .t ' . s =s and t =t ' '' dom(w) =dom(w) (s). =(s ).' . s =s and . =. ' '' \na=a (s). =s .. ' . s =s and . =. ' ++ + '' (s)=(s)(s)=(s ).' . s =s and . =. ' .. . + '' (s)=s .. ' . \ns =s and . =. ' . Figure 12: Subtyping relation calculus are partitioned in two kinds: processes and \nexpres\u00adsions. This distinction is di.cult to manifest by relying only on the syntax, mainly because of \nfunctional applica\u00adtion (the result of an application may either be an expres\u00adsion or a process), but \nthe intuition behind this partition is that processes may be put in parallel, and include mes\u00adsages, \nlocalities, controller and content of localities, whereas expressions may reduce to values and include \nfunctions, tu\u00adples, and names. We formalize this partition by making a distinction among types t between \nprocess types .and value types s. Process types are multisets of locality names, representing an upper \nbound of the localities that may be or become active in the process. Value types represent the value \nthe expression may eventually reduce to. They in\u00adclude function types s . t , tuple types sX,the unit \ntype, and types for names. Resource names have type (s). or (s)+ if they expect an argument of type s \n(which may be . a tuple) and if a message on this resource name leads to the creation of localities .. \nA resource name with the type (s)+ may be received and used for further input, as in the . creation of \na reaction rule (create xC(x() Ca(0)[0])),where create may have the type ((unit)+ a )\u00d8. Locality names \nhave type dom(w), where w may either be a locality name a,a name type variable d, or the empty set \u00d8. \nIntuitively, a lo\u00adcality name a has singleton type dom(a), a variable x may have type dom(d), and no \nname may have type dom(\u00d8) (this last type is needed for technical reasons). Name type vari\u00adables d re.ect \nterm variables x that may be instantiated to locality names, as in (create(x) Cx(0)[0]) where create \nmay be given the type .d.(dom(d))d. Multisets . include locality names a, name type variables d, multiset \nvariables ., the empty multiset \u00d8, and unions of multisets ., . ' . The basic intuition to guarantee \nthe unicity of names of active localities in a process P is to type aprocess P with a multiset .. If \nthis multiset happens to be a set, then we prove that every active locality bears a unique name. We use \n.aXX..s to denote a type scheme where plain type dXvariables aX, name type variable dXand multiset variables \n.Xare generalized. We use \u00df to range indi.erently over these di.erent type variables. In what follows, \nwe consider an extended syntax for the M-calculus, where new resource names are required to be annotated \nby their type scheme, in order to specify whether the resource has a plain resource type (which may be \npoly\u00admorphic) or if it has a sendable resource type (which cannot be polymorphic for safety reasons). \nThe intersection operation between multisets, n,is the standard intersection on multisets (taking the \nsmallest num\u00adber of occurrences in both multisets). The inclusion relation . between multisets is also \nthe standard one. By . - . ' , a,. Ua,. ' = a,(. U. ' ) .,. U.,. ' = .,(. U. ' ) d,. Ud,. ' = d,(. U. \n' ) . U. ' =.,. ' if . n. ' = \u00d8 unit Uunit = unit dom(w) Udom(w)= dom(w) aUa = a ''' ' (s1,...,sn) U(s1,...,s \nn)=(s1 Us1,...,sn Usn) '' s .t Us .t ' =(sns ) .(t Ut ' ) '' (s). U(s ).' = (sns ).u.' '' (s). Us .. \n' =(sns ) .(. U. ' ) ++ + (s)U(s)= (s) .. . + ' + '' (s)U(s )' = (sns ).u.' if s = s or .=. ' .. + '' \n(s)U(s ).' = (sns ).u.' . + '' (s)Us .. ' =(sns ) .(. U. ' ) . Figure 13: De.nition of U a,. na,. ' = \na,(. n. ' ) .,. n.,. ' = .,(. n. ' ) d,. nd,. ' = d,(. n. ' ) . n. ' = \u00d8if . n. ' = \u00d8 unit nunit = unit \ndom(w) ndom(w)= dom(w) ana = a ''' ' (s1,...,sn) n(s1,...,s n)=(s1 ns1,...,sn nsn) '' s .t ns .t ' =(sUs \n) .(t nt ' ) '' (s). n(s ).' = (sUs ).n.' '' (s). ns .. ' = (sUs ).n.' + ' ++ ' (s)ns = (s)if (s)=s . \n.. Figure 14: De.nition of n we denote the multiset which is composed of the elements of . (locality \nnames or multiset variables) after removing each element of . ' . For instance ., ., a, b, b - ., a, \na, b = ., b. We de.ne in .gure 12 a subtyping relation = (where sXand sX' are tuples of the same size \nn). The intuition behind the subtyping relation is that it is safe (with regard to the unicity of locality \nnames) to replace a process that includes more active localities with a process that includes fewer active \nlocalities. It is also safe to replace a function by a resource name if the types agree (a resource name \nmay be used to send a message, by functional applica\u00adtion, but it can also be used to create an addressed \nresource name). It is also safe to replace a plain resource name by a sendable resource name (sendable \nresource names may be used for message sending, but they can also be used to in\u00adstantiate variables that \nare de.ned names of a Join pattern). We remark that sendable resource types have no subtype, except themselves. \nThis is necessary for type safety since, unlike [25], we do not distinguish between input and output \ntypes. We de.ne the symmetric U and n operators on types in .g\u00adures 13 and 14 (other possible cases not \nlisted are unde.ned). .1 U .2 is de.ned as the multiset where the multiplicity of each name a is taken \nto be the max of the multiplicities in .1 and .2,and .1 n .2 is de.ned as the multiset where the multiplicity \nof each name a is taken to be the min of the multiplicities in .1 and .2 (it is the usual intersection \non multisets). We use G and its decorated variants to denote type en\u00advironments, i.e. .nite mappings \nbetween names and type schemes. We de.ne the set of free plain type variables ftv() fsv(\u00d8)= \u00d8 fwv(\u00d8)= \n\u00d8 fsv(.)= {.} fwv(.)= \u00d8 fsv(d)= \u00d8 fwv(d)= {d} fsv(a)= \u00d8 fwv(a)= \u00d8 fsv(.,. ' )= fsv(.) .fsv(. ' ) fwv(.,. \n' )= fwv(.) .fwv(. ' ) Figure 15: De.nition of fsv() and fwv() C ::= \u00b7: t |.r : s.C |.a.C |.x.C |a(C)[Q] \n| a(P)[C] |(C |P) |(P |C) |pass C |(CQ) | (PC) |([\u00b5 = C]P,Q) |([\u00b5 = V ]C,P) | ([\u00b5 = V ]P,C) |(JrC)|(P1,...,C,...,Pq) \nFigure 16: Typed Contexts as usual. We de.ne the set of free multiset variables fsv() and the set of \nfree name type variables fwv() in .gure 15. We letthe setof freevariables fv() be the union of ftv(), \nfsv(), and fwv(). Type judgments take the following form, where C is an M-context extended with a typed \nhole, as de.ned in Figure 16: G . C : t and G . P : t . We write fun(s; t ) for the types of all values \nthat may be used as functions, that is for either s . t , (s)t ,or (s)+ t (in the latter two cases, t \nis necessarily a process type .). We write chan(s; .) for channel types (either (s). or (s)+ ). . In \norder to correctly type the i and o resources, we consider only type environments with the following \nassociations: i : .ad..(dom(d), (a).,a). o : .ad..(dom(d), (a).,a).  Both the i and o resources expect \na locality name (the des\u00adtination of the message), the targeted resource expecting an argument of type \na and creating localities ., and an argu\u00adment of type a. A message on such a channel potentially creates \nlocalities .. The type system is de.ned by the rules in Figure 17. They make use of the Inst operator, \nthat takes a type scheme and returns a type where the generalized plain type variables, multiset variables, \nand name type variables have been in\u00adstantiated to types, multisets, and locality names or name type \nvariables respectively. Typing rule Join may seem complex but is the usual typ\u00ading rule for Join patterns: \nthe guarded process is typed in an environment extended with the formal parameters, and the result is \nchecked to create fewer localities than advertised by the resource types. Every de.ned resource name \nthat is a variable is checked to have a sendable resource type in the environment. The additional hypotheses \ncheck that the type schemes associated with the resources are consistent with the typing environment, \nfollowing the usual rules of the Distributed Join calculus: no generalized variable may occur free in \nthe environment nor be shared by two resources in aJoinpattern. Inrule Pass, the passivation function \nis checked to have a type that is a subtype of a function ex\u00adpecting a locality name and two thunks. \nThe name type variable d in the locality name type represents the name of the passivated cell. Each thunk \ntype includes a multiset vari\u00adable .1 or .2 representing the active localities of the thunk. These three \nvariables are intuitively generalized by check\u00ading that they do no occur in the typing environment (they \nwill respectively be substituted by the name of the passi\u00advated locality and by the active localities \nof the controller and content, that are unknown when typing the primitive). The type of the whole passivation \nconstruct is simply the type of the result of the passivation function, removing the name of the passivated \nlocality and the multiset variables since the locality is passivated. The soundness of the our type system \nis characterized by the following de.nitions and theorems. De.nition 1. A typing environment G is well-formed \nif and only if: \u00df.(s)., 1. G only contains associations of the form r : .X r : (s)+,and a : dom(a); . \n2. we have fn(G) = dom(G). Lemma 3.1. Let G . P : t be a typing derivation with G well-formed. If P = \nP ' , then there exists a typing derivation G . P ' : t . Theorem 1 (Subject reduction). Let G . P : \nt be a typing derivation with G well-formed. If P . P ' ,then '' '' there exists a type t such that t \n= t and G . P : t . De.nition 2. A locality a(P ' )[Q ' ]issaid tobe free and active in P if it is active \nin P and if it is not under a scope restriction for a. Aprocess P has failed if and only if there is \nsome pro\u00adcess P ' active in P containing at least two free and active localities bearing the same name. \nTheorem 2 (Progress). Let G . P :. be a typing derivation with G well-formed. If . is a set, then the \nprocess P has not failed. Most of the complexity of the subject reduction proof is alleviated by distinguishing \nname variables x from name type variables d, greatly simplifying the substitution lemma. Complete proofs \nare available in the draft of the long version of this paper [18]. Our notion of progress deals only \nwith the unicity of active locality names. Since our type system is very close to type systems for the \n.-calculus and the Distributed Join calculus, this progress property can be easily extended to more usual \nguarantees. We now discuss the power and limits of our type system. Linearity. Since our type system \naims at enforcing the lin\u00adearity of names of active localities, we describe how this feature interacts \nwith functions (or resources) that are not linear. First of all, our system guarantees the linearity \nof names of localities that are active (as described in theo\u00adrem 2). Relaxing the linearity constraint \nfor localities that are not active yields a much simpler type system (e.g. our system allows the typing \nof ..a(0)[0] | a(0)[0]as longas this function is not applied). We also require linearity of a newly introduced \nlocality name in the process under the scope restriction (rule Nu.Dom, since the introduced name should \nnot occur in the type). We recall that the type of a process is a conservative approximation of the active \nlo\u00adcalities it may contain. In the following, we only consider processes that are active. xx u : .\u00df.s \n.G s. = Inst(.\u00df.s) fn(ran(.)) .dom(G) [Name][Nil][Void] G fu : s. G f0 : \u00d8G f() : unit G fa : dom(w)G \nfr : chan(s;.) [Proc.Hole][Addr] G f( \u00b7: t): t G fa.r : s .. Pi : si)i.[1..q] G+ x : s fP : tx .dom(G) \nfn(s) .dom(G) (G f [Fun][Tuple] G f.x.P : s .t G fP1,...,Pq :(s1,...,sq ) G fa : dom(w)G fP :.1 G fQ \n:.2 G fP :.1 G fQ :.2 [Dom][Par] G fa(P)[Q]: w,.1,.2 G fP |Q :.1,.2 xxx G+ r : .\u00df.(s). fP :.1 r .dom(G) \nfv(.\u00df.(s).)= \u00d8 fn(.\u00df.(s).) .dom(G) [Nu.Res.1] x G f.r : .\u00df.(s)..P :.1 + ++ G+ r : (s)fP :.1 r .dom(G) \nfv((s))= \u00d8 fn((s)) .dom(G) . ..[Nu.Res.2] + G f.r : (s).P :.1 . G+ a : dom(a) fP :. a .fn(G) a .(. -a) \n[Nu.Dom] G f.a.P :. -a G fV : dom(d) .(unit ..1) .fun(unit ..2;.) .1 = .2 .1 ..1 .2 ..2 d, .1,.2 .fv(G) \n.(. -(d, .1,.2)) [Pass] G fpass V :. -(d, .1,.2) G fP : fun(s; t) s ' =s G fQ : s ' G fV : t G fP : \nt1 G fQ : t2 [App][Test] G fPQ : t G f([\u00b5 = V ]P,Q): t1 Ut2 (ri is not a variable and ri : si = .\u00dfxi.(sxi).G, \nor ri : si = (sxi)+ .G)i.[1..n] . ' =.1,...,.n (x i)i ndom(G) = \u00d8 .i .i G+ xV1 : sV1 + ... + xVn : sVn \nfP :. ' .i .[1..n].\u00dfxi nfv(G) = \u00d8.i,j .[1..n]2.i = j =.\u00dfxi n\u00dfVj = \u00d8 [Join] G f(r1xV1 |... |rnxVn rP): \n\u00d8 Figure 17: Typing rules Consider for instance the function .x.x() |x(). This func\u00adtion takes a frozen \nprocess and runs it twice. It is perfectly reasonable to apply it to a frozen process that does not re\u00adlease \nlocalities with free names, as in: (.x.x() |x())..0 or (.x.x() |x())...a.a(0)[0]. In these cases, the \nfunction has type (unit .\u00d8) .\u00d8. The type system would reject apply\u00ading this function to the thunk ..a(0)[0]. \nA function .x.x(), that only runs a process, can be given the type (unit . .) . .. Since functions never \nhave polymorphic types, one can instead consider a resource run de.ned as (run(x) Cx()). Such a resource \ncan be given the type ...(unit ..).: it simply recreates the active localities frozen in its argument. \nThe check that these localities do not interfere with currently active localities is done when typing \na message on run. We remark that our use of multiset variables is very similar to row variables described \nin [16]. Subtyping. Subtyping is explicitly used in typing rule App. Returning to the example of the \nrun resource above, this resource can receive a frozen process as argument, as in (run ..a.(0)[0]). It \ncan also receive a resource name, as in (run createa)with (createa() Ca(0)[0]),since (unit)a is a sub\u00adtype \nof unit .a. The subtyping used in typing rule Join gives some .ex\u00adibility when de.ning a resource, since \nthe type of the re\u00adsource gives an upper bound on the localities that may be created. For instance, the \nspecial channel i has type .ad..(dom(d), (a).,a).. Typical de.nitions for this channel are (i(d, r, args) \nCd.r args), which simply sends the message, and (i(d, r, args) C 0), which discards it. The typing of \nthe second de.nition relies on the fact that this de.nition of i does not create all the localities it \nis allowed to. Dependent Types and Polymorphism. Our type system does not allow dependent types, but \nsimulates them us\u00ading polymorphism and name type variables (type variables that represent locality names), \nsince locality names may oc\u00adcur in types. For instance the resource new in the de.ni\u00adtion (new(x) Cx(0)[0])may \nbegiven thepolymorphictype .d.(dom(d))d: it expects any locality name and creates a lo\u00adcality with this \nname. We remark that our solution is less powerful than dependent types, since it does not allow the \ntyping of (.f.f a | fb)(.x.x(0)[0]). However, polymor\u00adphism is powerful enough to let us type de.nitions \nof the form: (create(x, p, q) Cx(p())[q()]),where create is given the type .d.1.2.(dom(d), unit ..1, \nunit ..2)d,.1,.2 . Passivation. One limitation of our type system comes from the passivation operator. \nConsider for instance the pro\u00adcess: a (pass .xpq.x(0)[b(0)[0]]) [b(0)[0]]. The pass oper\u00adator freezes \nlocality a and respawns it, discarding its con\u00adtroller and content, but adds a locality b in its content. \nSince the locality b that is added is .rst discarded, one would ex\u00adpect this process to be well typed. \nThis is not the case because locality b is active, and may be sent somewhere else (see for instance the \nmigration example in section 2). This is why the process pass .xpq.x(0)[b(0)[0]] has type b:this process \ncreates an active locality b, independently of the con\u00adtroller and content that are passivated. On the \nother hand, the process pass .xpq.x(p())[q()] has type \u00d8 (it only recre\u00adates a locality that has been \npassivated) and the following process is well typed: a(pass .xpq.x(p())[q()]) [b(0)[0]]. Example. As \na small example, we remark that the taxi example we describe at the end of section 2 is well typed with \nthe following bindings: enter : ..S,.C .(unit .\u00d8,unit . .S,unit . .C ).S,.C exit : (unit)\u00d8 onexit : ..C \n.(unit . .C ).C route : .d.(dom(d),unit .\u00d8)\u00d8 visit : ...(unit . .).  4. SIMULATING THE JOIN CALCULUS \nIn this section, we show that we can simulate the Dis\u00adtributed Join calculus in a straightforward manner, \nthus re\u00adtaining all its expressivity. However, we .rst check that the M-Calculus addresses the limitation \nof the Distributed Join calculus described in the introduction. The lack of control over communication \nand mobility is directly addressed by the possibility to program controllers for each locality to .lter \nincoming and outgoing messages. These controllers are normal M-Calculus processes, they can be arbitrarily \ncomplex. Dynamic binding, or more precisely locality based bind\u00ading, is provided by addressed messages, \nwhich explicitly in\u00adclude the name of the locality hosting the targeted resource, and by the possibility \nto de.ne resources at several locali\u00adties. A simulation of the Dynamic Join calculus [20] in the M-Calculus \npresented in [19] illustrates how to use addressed messages to get transparent locality based binding. \nFinally, programmable controllers and the passivation op\u00aderator let the programmer de.ne localities with \ndi.erent se\u00admantics within the same program. Since the M-calculus is a direct o.spring of the Distributed \nJoin calculus, a translation of a Distributed Join calculus process into an M-calculus process is relatively \nstraightfor\u00adward. Such a translation is interesting to present, however, because it illustrates the versatility \nof programmable local\u00adities. In the following, we only consider Join processes with no free names. We \nproceed in three steps, in order to account for the fact that resource names are introduced with their \ntypes in the M-calculus, and that message routing requires the messages to be annotated with address \ninformation. The .rst step consists in typing the Distributed Join cal\u00adculus process, and annotating \nevery local Join calculus de.\u00adnition with the channel names (as well as their type schemes) and location \nnames it de.nes. We write def (D; n1 : s1,nq : sq,a1,...,ar) in ...the result of the .rst translation \nstep of def D in P if dn(D)= {n1,...,nq }.{a1,...,ar} and if the channel names ni have type schemes si \nafter generalization. By de.nition of the types of the Distributed Join calculus, the si are of the form \n.Xt). a.(XWe suppose that these type schemes have no free type variables, and we transform them immediately \nin M-calculus type schemes, writing ()\u00d8 instead of (). The second translation step consists in annotating \nevery channel name that is not a variable with the locality where its de.nitions reside. To do this, \nwe rely on the fact that in the Distributed Join calculus, the only locality in which a de.nition may \neventually be dissolved is the syntactically enclosing locality. This property is a direct consequence \nof the de.nition of migration: the only way to have processes migrate in the Distributed Join calculus \nis by locality migra\u00adtion. Thus de.nitions cannot be separated from the locality where they syntactically \noccur. For reasons of space, we do not formally present the algorithm used in this second step, which \nis roughly of the following form: for every channel name that is not in a Join pattern, .nd the enclosing \ndef binder for this name, then .nd the name of the syntacti\u00adcally enclosing locality, and prepend the \nlocality name to the channel name. The third step is the translation to the M-calculus itself. We represent \na location of the Distributed Join calculus a[ \u00b7] by a locality a(PJ )[ \u00b7]with: PJ = Fwd |(add frAdd( \nf) )|(go ( b,.) rSend( b,.) ) Add( f)= pass .xpq.x( p())[ q() |f()] Send( b,.)= pass .xpq.( b.add ..x( \np())[ q() |.()]) We type the resource add with the type ...(unit . .). that expects a thunk and frees \nit, and the resource go with the type .d..(dom(d),unit . .)., that takes a locality name and a frozen \ncontinuation that it will eventually spawn. Writing [ \u00b7 ] for the translation operator, we have: [[ b.n]] \n= b.n [[ b]] = b [[ x]] = x [[ 0]] = 0 [[ P |Q]]= [ P]] |[[ Q]] [[ .]] = 0 [[ go b; P]] = go( b,..[[ \nP]]) [ D,D ' ]]= [ D]] |[[ D ' ]] [[ b[ D : P]]] = b( PJ )[[ D]] |[[ P]]] [[ m(n1,...,nq)]]= [ m]]([ \nn1]] ,...,[[ nq]]) [[ n1(xV1)|...|nq(xVq )rP]] = (n1(xV1)|...|nq(xVq )r[[ P]] ) [[ def ( D; n1 : s1,...,nq \n: sq,a1,...,ar ) in P]] = .n1 : s1,...,nq : sq..a1,...,ar .[[ D]] |[[ P]] Note that our translation is \nnot entirely faithful with re\u00adspect to migration, since in the Distributed Join calculus migration does \nnot occur if the target locality is a sublocal\u00adity of the moving one. In order to detect these cases, \nwe would need a more complex translation. We now extend the previous translation to the Distributed Join \ncalculus with failures. To do this, we only need to change the translation of a locality, replacing the \nPJ con\u00adtroller by the following PJF (a) controller: PJF = Fwd |(add frAdd( f) ) |(go ( b,.) rSend( b,.) \n) |(halt rHalt) |(ping ( y,n) ry() ) Add( f)= pass .xpq.x( p())[ q() |f()] Send( b,.)= pass .xpq.( b.add \n..x( p())[ q() |.()]) (ping ( y,n) rn() )  Halt = pass .xpq.x(|(add frAdd( f) ) ) [ q()] |(i ( d,m,v) \nrP( m,v) ) |(o ( d,m,v)= 0) P( m,v)= ([ ping = m] mv,([ add = m] mv,0)) Thus, when a locality has failed, \nit prevents all outgoing messages from leaving the failed locality: no sublocality may send a message \noutside. Similarly, with respect to incoming messages, a failed locality only accepts messages sent on \nping or on add for itself or its sublocalities. Messages on ping are emitted locally, and will be subsequently \nreduced by the new de.nition for ping, that will answer saying the sublocality has failed. Messages on \nadd will add the migrating location to the current locality, thereby cutting it from the rest of the \nworld. We remark that the sublocalities of the failing one are still active, but they cannot communicate \nwith the outside world. This translation strongly relies on the interception of routed messages by controller \nprocesses.  5. RELATED WORK Several distributed process calculi have been proposed in the recent years, \nbut they all have shortcomings as dis\u00adtributed programming models: Ambient calculi, such as the original \nMobile Ambients [4] and the subsequent variants (Safe Ambients [10], Safe Ambients with Passwords [13], \nBoxed Ambients [2], Controlled Ambients [22]), provide a simple model of hierarchical localities with \n.ne-grained control over locality moves and communications, but their basic mobility primitives (the \nin and out capabilities) re\u00adquire a 3-party atomic handshake which makes them costly to implement in \na distributed setting as illus\u00adtrated by the implementation of Mobile Ambients in the Distributed Join \ncalculus [8].1  Higher-order process calculi such as as Facile/CHOCS and Dp. [25] model process mobility \nvia higher-order communication and remote process execution, but lack an explicit notion of locality \nto account for potential failures or to provide a basis for access control. Fur\u00adthermore, they do not \nallow for a running process to be migrated to a di.erent locality, unless the process has been explicitly \nde.ned to allow for such a migration.  Variants of the .rst-order asynchronous p-calculus with explicit \nlocalities such as the Distributed Join calcu\u00adlus [6, 11], Nomadic Pict [24], DiTyCo [12], or the p1l-calculus \n[1], feature process migration primitives (go in the Distributed Join calculus, spawn in the p1l \u00adcalculus, \nmigrate in Nomadic Pict) but lack su.cient control over resource access and process migration.  Compared \nto these works, the M-calculus has several dis\u00adtinguishing features. Its notion of programmable locality \nallows the de.nition of di.erent forms of locality within the same calculus. In contrast, the calculi \nabove, or even calculi such as Klaim [14, 15] (that uses generative communication as its basic form of \ncommunication), or ATF [5] (that considers distributed 2\u00adphase transactions as processes), consider only \na single form of locality. 1Recent work on a distributed abstract machine for Safe Ambients [17], just \nreinforces this point. The distributed implementation of ambients proposed there does away with the problem \nby implementing the in and out capabilities lo\u00adcally (by using cocapabilities and single-threadedness), \nand interpreting the open capability as a move to the implicit location of the parent ambient. In this \ninterpretation, am\u00adbients no longer characterize the physical distribution of a computation, which defeats \nthe original intent of the cal\u00adculus. Furthermore, work on Boxed Ambients successfully argues against \nthe open capability. In distributed calculi, many alternatives exist when it comes to combine communication \nand localities. At one extreme lies the fully transparent communication of the Dis\u00adtributed Join calculus, \nwhere messages are routed directly to the target locality. At the other extreme lies Mobile Am\u00adbients, \nwhere communication is purely local to an ambient and remote communication must use migration primitives \nand explicitly encoded routes to deliver an ambient mes\u00adsage. The Seal calculus [23] and Boxed Ambients \nlie be\u00adtween these two extremes by providing the ability to com\u00admunicate across one locality boundary. \nIn the M-calculus, we still provide transparent routing but allow messages to be intercepted each time \nthey cross a locality boundary. Finally, one may remark that there are striking similarities between \ncontrolling migration on one hand, and controlling communication on the other hand. For this reason, \nwe take the further step to merge the two aspects, by considering a higher-order calculus. In our setting, \nmigration becomes communication of a thunk or passivated process. With respect to the type system, Yoshida \nand Hennessy s work on Dp., a higher-order distributed process calculus [26], is closest to our own. \nDp. allows the communication of processes as thunks. In this regard, it is similar to the M\u00adcalculus. \nThere are however several important di.erences that we now detail. The two calculi take a di.erent ap\u00adproach \nto the determinacy of communication. As in the Join calculus, the Dp. calculus adopts a channel local\u00adity \ninvariant, which ensures a channel or resource is only present in one locality. In the M-calculus, resources \nof the same name can be present in di.erent localities in order to allow for dynamic binding. The M-calculus \ntherefore relies on addressed resources, where a resource name is annotated with a locality name, to \nensure the determinacy of message routing. The unicity of locality names invariant in the M-calculus \nis more complex to ensure than the channel lo\u00adcality invariant in the Dp. calculus. This is due to the \npassivation operator in the M-calculus. This operator has no counterpart in the Dp. calculus, where the \nonly way to obtain a thunk (frozen process) is by either specifying it, or by receiving it. The ability \nto passivate an active process, as in the M-calculus, is powerful but it makes the type system more complex, \nas the type of the passivation operator de\u00adpends on some type information of the passivated process. \nAsin theDp. calculus, a process in the M-calculus has a type that gives information on its behavior (its \ninterface for the Dp., its active localities for the M-calculus). More precisely, the type of a term \nis a conservative approxima\u00adtion of the value or process it may become. Thus locality errors in Dp. and \nmultiple locality de.nitions in the M\u00adcalculus only lead to type errors if the faulty process may eventually \nbecome active. Both systems also have a form of dependent types, but they are dealt with di.erently. \nIn the Dp.-calculus, name variables can occur in types and can be bound in types, yielding dependent \ntypes. In the M-calculus, the dependency between input and output of a resource (channel) is represented \nas a type variable (which may stand for a locality name) that is generalized. Accord\u00ading to the type \nof the argument, the type variables of the type scheme of a resource are instantiated to the correct \nvalues, and the type of a message is thus dependent on the type of the argument. In order to simplify \nthe type sys\u00adtem of the M-calculus, we allow cell names in the types but not name variables. We use instead \nname type vari\u00adables, which provide us with a cleaner distinction between types and names. The advantage \nof dependent types ap\u00adpears when considering partial application: if the result of an application is \na function that has a dependent type, this function may still be applied to several frozen processes \nhav\u00ading di.erent types, which is impossible when relying on .rst order polymorphism. However, previous \nwork on the typing of the Join calculus and our experience with programming in JoCaml showed us that \n.rst order polymorphism is useful, well-understood, and powerful enough when using Join pat\u00adterns. Finally, \nboth the Dp. calculus and the M-calculus al\u00adlow input on channels that were received previously, but \nthe Dp. uses .ner input-output types for channels that could be adapted to our setting. 6. CONCLUSION \nAND FUTURE WORK We have presented in this paper the M-calculus, a higher\u00adorder distributed process calculus, \nand an associated type system that statically enforces the unicity of locality names, a crucial invariant \nfor the determinacy of .nal destination for remote messages. The M-calculus constitutes a non\u00adtrivial \nand powerful extension of the Join calculus [6, 11] with call-by-value higher-order functions, programmable \nlo\u00adcalities, and dynamic binding. The possibility to de.ne, within the same calculus, di.er\u00adent kinds \nof localities, with non-trivial behavior, is an im\u00adportant requirement for a realistic foundation of \ndistributed mobile programming. While the M-calculus still falls short of meeting key requirements for \nadvanced distributed pro\u00adgramming (e.g. support for transactional behavior), we be\u00adlieve it constitutes \nan important step. To validate the implementable character of the M-calculus, we have de.ned and implemented \na distributed abstract ma\u00adchine for it [9], and, in order to prove the correctness of our abstract machine, \nwe are working on an annotated lower\u00adlevel calculus that makes the routing and passivation reduc\u00adtion \nrules more local. In parallel, we are de.ning notions of observables in order to compare, using operational \nequiva\u00adlences, the annotated calculus to the original calculus, and to study the correctness of the translations \nfrom distributed calculi to the M-calculus. 7. REFERENCES [1] R. Amadio. An asynchronous model of locality, \nfailure, and process mobility. Technical report, INRIA Research Report RR-3109, INRIA Sophia-Antipolis, \nFrance, 1997. [2] M. Bugliesi, G. Castagna, and S. Crafa. Boxed ambients. In 4th International Symposium \non Theoretical Aspects of Computer Software (TACS), 2001. [3] L. Cardelli. Types for mobile ambients. \nIn Proceedings 26th Annual ACM Symposium on Principles of Programming Languages (POPL), 1999. [4] L. \nCardelli and A. Gordon. Mobile ambients. In Foundations of Software Science and Computational Structures, \nM. Nivat (Ed.), Lecture Notes in Computer Science, Vol. 1378. Springer Verlag, 1998. [5] D. Duggan. Atomic \nfailure in wide-area computation. In Proceedings 4th IFIP International Conference on Formal Methods \nfor Open Object-Based Distributed Systems (FMOODS),S.Smith andC.Talcott eds. Kluwer, 2000. [6] C. Fournet. \nThe Join-Calculus.PhD thesis,Ecole Polytechnique, 1998. [7] C. Fournet, G. Gonthier, J.J. Levy, L. Maranget, \nand D. Remy. A calculus of mobile agents. In In Proceedings 7th International Conference on Concurrency \nTheory (CONCUR 96), Lecture Notes in Computer Science 1119. Springer Verlag, 1996. [8] C.Fournet,J.J. \nLevy, andA.Schmitt. An asynchronous distributed implementation of mobile ambients. In Proceedings of \nthe International IFIP Conference TCS 2000, Sendai, Japan, Lecture Notes in Computer Science 1872. Springer, \n2000. [9] F. Germain, M. Lacoste, and J.B. Stefani. An abstract machine for a higher-order distributed \nprocess calculus. In Proceedings of the EACTS Workshop on Foundations of Wide Area Network Computing \n(F-WAN), July 2002. [10] F. Levi and D. Sangiorgi. Controlling interference in ambients. In Proceedings \n27th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages (POPL 2000), 2000. [11] \nJ.J. Levy. Some results on the join-calculus. In 3rd International Symposium on Theoretical spects of \nComputer Software (TACS), Lecture Notes in Computer Science no 1281. Springer, 1997. [12] L. Lopes, F. \nSilva, A. Figueira, and V. Vasconcelos. DiTyCO: An Experiment in Code Mobility from the Realm of Process \nCalculi. In Proceedings 5th Mobile Object Systems Workshop (MOS 99), 1999. [13] M. Merro and M. Hennessy. \nBisimulation congruences in safe ambients. In 29th ACM Symposium on Principles of Programming Languages \n(POPL), Portland, Oregon, 16-18 January, 2002. [14] R. De Nicola, G.L. Ferrari, and R. Pugliese. Klaim: \na Kernel Language for Agents Interaction and Mobility. IEEE Trans. on Software Engineering, Vol. 24, \nno 5, 1998. [15] R. De Nicola, G.L. Ferrari, R. Pugliese, and B. Venneri. Types for Access Control. \nTheoretical Computer Science, Vol. 240, no 1, 2000.  [16] Didier R\u00b4emy. Type inference for records in \na natural extension of ML. In Carl A. Gunter and John C. Mitchell, editors, Theoretical Aspects Of Object-Oriented \nProgramming. Types, Semantics and Language Design. MIT Press, 1993. [17] D. Sangiorgi and A. Valente. \nA Distributed Abstract Machine for Safe Ambients. In Proceedings of the 28th International Colloquium \non Automata, Languages and Programming, volume 2076 of Lect. Notes in Comp. Sci. Springer-Verlag, 2001. \n[18] A. Schmitt and J.B. Stefani. The M-calculus: A Higher Order Distributed Process Calculus. Draft \nof the long version, available at http://pauillac. inria.fr/~aschmitt/publications.html, 2002. [19] Alan \nSchmitt. Conception et Implmentation de Calculs d Agents Mobiles. PhD thesis, Ecole Polytechnique, 2002. \n[20] Alan Schmitt. Safe Dynamic Binding in the Join Calculus. In IFIP TCS 02, Montreal, Canada, 2002. \n[21] Peter Sewell and Jan Vitek. Secure composition of untrusted code: Box-p, wrappers and causality \ntypes. Journal of Computer Security, 2000. Invited submission for a CSFW00 special issue. To appear. \n[22] D. Teller, P. Zimmer, and D. Hirschko.. Using Ambients to Control Resources. In Proceedings CONCUR \n02, 2002. [23] J. Vitek and G. Castagna. Towards a calculus of secure mobile computations. In Proceedings \nWorkshop on Internet Programming Languages, Chicago, Illinois, USA, 1998. [24] P. Wojciechowski and P. \nSewell. Nomadic Pict: Language and Infrastructure. IEEE Concurrency, vol. 8, no 2, 2000. [25] N. Yoshida \nand M. Hennessy. Subtyping and locality in distributed higher-order processes. In Proceedings CONCUR \n99, Lecture Notes in Computer Science no 1664. Springer, 1999. [26] N. Yoshida and M. Hennessy. Assigning \ntypes to processes. In 15th Annual IEEE Symposium on Logic in Computer Science (LICS), 2000.  \n\t\t\t", "proc_id": "604131", "abstract": "This paper presents a new distributed process calculus, called the M-calculus, that can be understood as a higher-order version of the Distributed Join calculus with programmable localities. The calculus retains the implementable character of the Distributed Join calculus while overcoming several important limitations: insufficient control over communication and mobility, absence of dynamic binding, and limited locality semantics. The calculus is equipped with a polymorphic type system that guarantees the unicity of locality names, even in presence of higher-order communications -- a crucial property for the determinacy of message routing in the calculus.", "authors": [{"name": "Alan Schmitt", "author_profile_id": "81326492348", "affiliation": "INRIA", "person_id": "PP43115114", "email_address": "", "orcid_id": ""}, {"name": "Jean-Bernard Stefani", "author_profile_id": "81100550503", "affiliation": "INRIA", "person_id": "PP14191226", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/604131.604136", "year": "2003", "article_id": "604136", "conference": "POPL", "title": "The m-calculus: a higher-order distributed process calculus", "url": "http://dl.acm.org/citation.cfm?id=604136"}