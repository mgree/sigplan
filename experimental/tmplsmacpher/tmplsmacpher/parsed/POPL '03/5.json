{"article_publication_date": "01-15-2003", "fulltext": "\n A Generic Approach to the Static Analysis of Concurrent Programs with Procedures Ahmed Bouajjani* Javier \nEsparza Tayssir Touili* ABSTRACT We present a generic aproach to the static analysis of con\u00adcurrent programs \nwith procedures. We model programs as communicating pushdown systems. It is known that typical data.ow \nproblems for this model are undecidable, because the emptiness problem for the intersection of context-free \nlanguages, which is undecidable, can be reduced to them. In this paper we propose an algebraic framework \nfor de.n\u00ading abstractions (upper approximations) of context-free lan\u00adguages. We consider two classes \nof abstractions: .nite-chain abstractions, which are abstractions whose domains do not contain any in.nite \nchains, and commutative abstractions corresponding to classes of languages that contain a word if and \nonly if they contain all its permutations. We show how to compute such approximations by combining automata \ntheo\u00adretic techniques with algorithms for solving systems of poly\u00adnomial inequations in Kleene algebras. \nCategories and Subject Descriptors D.2.4. [Software/Program Veri.cation], F.1.1 [Models of Com\u00adputation], \nF.3.1. [Specifying and Verifying and Reasoning about Programs], F.4.2. [Grammars and Other Rewriting \nSystems]. General Terms Algorithms, Reliability, Theory, Veri.cation. Keywords Concurrent programs with \nprocedures, pushdown systems, Kleene algebras, abstraction, static analysis, veri.cation. * Liafa, University \nof Paris 7, Email: {Ahmed.Bouajjani,Tayssir.Touili}@liafa.jussieu.fr Lab. for Foundations of Computer \nScience,University of Ed\u00adinburgh. Email: jav@dcs.ed.ac.uk Permission to make digital or hard copies of \nall or part of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to \nlists, requires prior speci.c permission and/or a fee. POPL 03, January 15 17, 2003, New Orleans, Louisiana, \nUSA. Copyright 2003 ACM 1-58113-628-5/03/0001 ...$5.00 1. INTRODUCTION Multithreading is widely used \nin modern software, but it also enables new kinds of programming errors. Developing static analysis techniques \nable to detect some of these errors is be\u00adcoming increasingly important, and has been the subject of \na number of recent papers (see [14] for a recent survey). Devel\u00adoping these techniques is also a very \nchallenging task, espe\u00adcially in the interprocedural case, i.e., when the programming language may contain \nnot only synchronization primitives, but also procedures. In this case, a basic result [13] states that \neven the basic problem of deciding if a given control point can ever be reached is undecidable. Notice \nthat this is the case even if, as usual in a data-.ow setting, all if-then-else instructions and loop \nguards are replaced by nondetermin\u00adism; the analysis must only be sensitive to procedure calls and synchronizations. \nDue to this negative result, every analysis algorithm must necessarily work with an upper approximation \nof the set of possible program paths. Such algorithms have been presented in [4, 1]. These techniques \napproximate both the e.ect of pro\u00adcedures and synchronization. In other words, they remain approximate \nboth in the intraprocedural case (no procedures but synchronization) and in the synchronization-free \ncase (no synchronization but procedures). In this paper, we present an analysis technique based on our \nprevious work on model\u00adchecking and interprocedural analysis of sequential programs [2, 7, 6]. Our technique \nexhibits two main features with re\u00adspect to previous work. First, it only approximates the e.ect of synchronizations; \nprocedures are handled in an exact way. Second (and arguably more important), it presents a generic algorithm \nwhich allows to perform analysis of di.erent pre\u00adcision and cost. In order to explain the basic idea \nof the approach, let us brie.y recall the result of [13]. Consider a sequential pro\u00adgram with possibly \nrecursive procedures and one of its con\u00ad.gurations c. Here, a con.guration is a pair consisting of a \ncontrol point and a stack of activation records contain\u00ading the information about the procedures which \nhave been called but whose execution is not yet .nished. If we look at a possible execution path of the \nprogram as a sequence of statements, we can identify the set of all possible pro\u00adgram paths reaching \nc from the initial con.guration c0 with a context-free language L(c0,c) (and every context-free lan\u00adguage \ncan be obtained this way). E.g. take a program that either terminates immediately or executes a statement \na, calls itself recursively, executes a statement b, and terminates; let c be the con.guration corresponding \nto termination; we have L(c0,c)= {a nbn | n = 0}. Consider now a concurrent system consisting of two \nsequen\u00adtial programs communicating with each other by rendezvous, and a con.guration (c1,c2) of the system. \nThe problem is if (c1,c2) is reachable from (c01,c02) when synchronizations are taken into account. A \n.rst necessary condition is that ci be reachable from c0i when synchronizations are not taken into account. \nWe now interpret the execution paths reaching c1 and c2 as sequences of synchronization statements (i.e. \nwe hide all statements that can be executed by one of the two programs independently of its partner), \nand obtain in this way two context-free languages L(c01,c1),L(c02,c2). Then (c1,c2) is reachable if and \nonly if L(c01,c1) n L(c02,c2)is nonempty, i.e., if there exist sequences of both components o.ering the \nsame sequence of communications to its partner. Unfortunately, since emptiness of the intersection of \ncontext\u00adfree languages is undecidable, forward reachability of (c1,c2) from (c01,c02) is also undecidable. \nIn general, forward or backward reachability between con.gurations is undecidable. Our attack on this \nproblem is based on our previous work, which shows how to compute, given an arbitrary regular set C of \ncon.gurations of a sequential program, the sets pre * (C) and post * (C) of predecessors and successors \nof C. We ad\u00address the following problem: given two sets C1 \u00d7 C2, C1L\u00d7 C2Lof con.gurations of the concurrent \nsystem, is (some con.g\u00aduration of) C1 \u00d7 C2 reachable from (some con.guration of ) CL* 1 \u00d7 C2L? This amounts \nto deciding if (C1L\u00d7 C2L) n pre (C1 \u00d7 * (C1L\u00d7 CL C2) \u00d8 or post 2) n (C1 \u00d7 C2)= \u00d8. Let us con\u00ad = sider \nthe .rst possibility for this discussion. Our approach consists of computing an abstraction of the path \nlanguage L L(CiL,Ci)= L(c,c), i.e., a set A(CiL,Ci) satisfy\u00ad c.Ci,c'.Ci ing A(CiL,Ci) . L(CiL,Ci). Clearly, \nemptiness of A(C1L,C1) n A(C2L,C2) implies emptiness of L(C1L,C1) n A(C2L,C2). Sowe check if A(C1L,C1) \nn A(C2L,C2)= \u00d8, and if so we conclude that C1 \u00d7 C2 is unreachable from C1L\u00d7 C2L. The problem is to .nd \ncomputable abstract path languages for which emptiness of intersection is decidable. In this pa\u00adper, \nwe provide a generic algorithm for the computation of these approximations. This algorithm is based on \nthe res\u00adolution of polynomial inequalities in abstract domains. We consider two classes of abstractions: \n(1) Finite-chain abstrac\u00adtions, which are abstractions whose domain do not contain any in.nite chain. \nIn this case the inequalities can be solved by an iterative .xpoint computation. (2) Commutative ab\u00adstractions, \nwhich are abstractions that forget the order be\u00adtween the di.erent actions, meaning that if a word belongs \nto A(CL,C) then all its permutations also belong to A(CL,C). In this case, we solve the polynomial inequalities \nusing the very elegant machinery of [9] for solving systems of equations in commutative Kleene algebras. \nWe give several examples of useful abstractions leading to analysis algorithms of di.erent Proc: p2 Proc: \np1 m0 n0 m2 n1 m3n3 Program 1 Program 2 Figure 1: An example precision and cost. The paper is organised \nas follows. Section 2 presents our program model and communicating pushdown systems, our formal model. \nSection 3 gives examples of abstractions and de.nes the classes of abstractions considered in the paper. \nSection 4 reduces the computation of abstract path languages to the computation of certain sets of predecessors/successors. \nSection 5 presents the generic algorithm for computing pre\u00addecessors and discusses its complexity. Finally, \nsection 6 con\u00adtains conclusions and discusses related work. For lack of space, all proofs are omitted \nand can be found in the full version of the paper. 2. THE MODEL 2.1 Program model: Flow Graph Systems \nOur program model is very similar to the trace .ow graph of [5] or [12]. We represent a sequential program \nby a sys\u00adtem of .ow graphs, one for each procedure. The nodes of a .ow graph correspond to control points \nin the procedure, and its edges are annotated with statements. An unlabelled statement corresponds to \na noop. We allow arbitrary recur\u00adsion, even mutual procedure calls, between procedures; how\u00adever, as \nusual, we require that in.nite data types have been abstracted into .nite types using standard techniques \nof ab\u00adstract interpretation (in the classical data.ow framework, all datatypes are abstracted away). \nAbstraction usually leads to non-deterministic control .ow, which is explicitly allowed. A concurrent \nprogram is represented by a tuple of .ow graph systems, one for each sequential component. Statements \nare assignments, calls to other procedures of the same sequential program, or communications with another \nsequential program. Communication takes place in rendezvous style by means of unidirectional point-to-point \nchannels. A send statement ch!x sends the value of x along channel ch, and a receive statement ch?y waits \nfor a value to be received along channel ch, and binds it to the variable y. We also allow communication \nof synchronization signals by means of statements ch! and ch?. Figure 1 shows two sequential pro\u00adgrams, \neach one consisting of one procedure, which exchange signals through channels a and b. 2.2 Formal model: \nPushdown systems A pushdown system (PDS) is a .ve-tuple P =(P, Act, G,c0, .) where P is a .nite set of \ncontrol locations, Act is a .nite set of actions, G is a .nite stack alphabet, and . . (P \u00d7 G) \u00d7 Act \n\u00d7 (P \u00d7 G * ) is a .nite set of transition rules.If L aL ((p, .),a, (p ,w)) . . then we write (p, .) \"( \np -. ,w).A con.guration of P is a pair (p, w) where p . P is a control location and w . G * is a stack \ncontent. c0 is called the initial con.guration of P . We assume w.l.o.g. that all the rules of . aL are \nof the form (p, .) \",w) such that |w|= 2 (in fact, -. ( p as we shall see below, the PDSs obtained from \nprograms al\u00adready satisfy this constraint). The set of all con.gurations is denoted by C . A set C of \ncon.gurations is regular if for each control location p . P the language {w . G * |(p, w). C} is regular. \na For each action a, we de.ne a relation -..C\u00d7C as follows: aL aL if (q, .) \",w), then (q, .v) -.(q ,wv) \nfor every v . G * -. ( q ; we say that (q, .v) is an immediate predecessor of (q L ,wv), and (q L ,wv) \nan immediate successor of (q, .v). The predecessor function pre * :2C . 2C of P is de.ned as follows: \nc belongs to pre * (C) if some successor of c belongs to C. We de.ne post * (C) similarly. A communicating \npushdown system (CPDS) is a tuple CP = (P 1,..., Pn) of pushdown systems over the same set of ac\u00adtions \nAct. In order to model communication, we assume that Act contains a special action t that represents \ninter\u00adnal actions, and that every action in Lab = Act \\{t} is a synchronization action. These actions \nin Lab will be called labels. A global con.guration of CP is a tuple g =(c1,...,cn)of a con.gurations \nof P1,... Pn. We extend the relations -. to pairs of global con.gurations as follows. Let g =(c1,...,cn) \nLL L and g =(c1,...,c n) be global con.gurations: t t g -. g L if there is 1 = i = n such that ci -. \nc L i and c L j = cj for each j = i; aL aL aL g -. g there are indices i = j such that ci -. ci, cj -. \ncj , and ck L = ck for every i = k = j. Given a set G of global con.gurations, we de.ne pre * (G) and \npost * (G) in the obvious way.  2.3 From the program model to the formal model Given a tuple of .ow-graph \nsystems (our model of concurrent programs), we de.ne a corresponding CPDS. Each .ow-graph system is assigned \na PDS; the CPDS is just the tuple of these PDSs. For simplicity, we assume that all procedures of the \n.ow\u00adgraph system have the same local variables. The correspond\u00ading PDS P =(P, Act, G,c0, .) is de.ned \nas follows. P is the set of all possible valuations of the local variables, or a single\u00adton if the program \nhas no variables or all variables have been abstracted away. Act contains the action t and an action \nch(n) for each channel ch and each possible value n that can be transmitted through it. If only signals \nare transmitted, then the action is ch. G is the set of all pairs (n, v), where n is a node of a .ow \ngraph, and v is a valuation of the local variables. We take c0 = (glob0, (n0, loc0)), where glob0 and \nloc0 are the initial values of the global and local variables, and n0 is the initial node of the main \nprocedure. . contains a set of rules for each program statement, de.ned next. Let s be the statement \nlabelling an edge of the .ow graph system from node n1 to node n2.If s is an assignment, then it is translated \ninto a set of rules of the form t (glob, (n1, loc)) \", (n2, locL -. ( globL )). where glob and globL \n(loc and locL) are the values of the global (local) variables before and after the assignment. If s is \na procedure call, then it is translated into a set of rules of the form t (glob, (n1, loc)) \"L)(n2, locLL \n-. ( glob, (m0, loc)) where m0 is the start node of the called procedure, locL de\u00adnotes the initial \nvalues of its local variables, and locLL saves the local variables of the calling procedure. An input \nch?y is translated into a set of rules of the form ch(v) (glob, (n1, loc)) \"-. ( globL , (n2, locL)). \n where globL and locL is the result of assigning the value v to y in glob or loc (depending on whether \ny is global or local). An output ch!x is translated into a set of rules of the form ch(v) (glob, (n1, \nloc)) \"-. ( glob, (n2, loc)). where v is the value of x in glob or loc. Finally, a node n without output \nedges, corresponding to the return instruction of a procedure, is translated into rules of the form t \n(glob, (n, loc)) \" -. ( glob,e) Procedures which return values can be simulated by intro\u00adducing an additional \nglobal variable and assigning the return value to it. Notice that, since channels are unidirectional \nand point to ch(v) point, we can only have g ----. g L if one of the components executes an input and \nanother one an output. Figure 1 yields a CPDS with two elements. The PDS for the sequential program on \nthe right-hand-side has one sin\u00ad a gle control location p and rules r1 : (p, m0) -. \"( p, m1), b t \n 3. ABSTRACTING PATH LANGUAGES 3.1 Reachability Analysis and Path Languages Let (P1,...,Pn) be a CPDS \nand consider the problem of checking whether a set of con.gurations C1 \u00d7\u00b7\u00b7\u00b7\u00d7Cn is reach\u00adable from a set \nof con.gurations C1 L \u00d7\u00b7\u00b7\u00b7\u00d7CnL . This problem can be reduced to the problem of checking the emptiness \nof the intersection of context-free languages. Indeed, let us as\u00adsume w.l.o.g. that the set of labels \n(visible actions) Lab is a disjoint union of sets Labi,j corresponding to synchroniza\u00adtion actions between \neach pair of systems Pi and Pj (any system can be transformed in order to satisfy this condition by duplicating \nand relabeling transitions corresponding to synchronization actions which are common to di.erent pairs \nof systems). Then, let Li = L(CiL,Ci) be the set of paths leading in Pi from a con.guration in Ci L to \na con.guration in Ci, and let L Li = Li WW ( Labj,k) * j,k =i where WW is the shu.e (interleaving) operator, \nwhich means that we insert everywhere in the paths of Pi labels corre\u00adsponding to synchronization actions \nbetween pairs of other processes. In other words, we extend each pushdown system Pi by self loops on \neach of its control states labeled with syn\u00adchronization actions between pairs of other processes. Notice \nthat this extension is done only when n = 3 (for n =2, we have LLi = Li). Since t actions are hidden \nin the path languages Li s, it is easy to see that C1 \u00d7\u00b7\u00b7\u00b7\u00d7Cn is reachable from C1 L \u00d7\u00b7\u00b7\u00b7\u00d7Cn L if and \nonly if LL1 n...nLLn = \u00d8 (1) As mentioned in the introduction, our approach for tackling this problem \n(which is undecidable) is based on computing abstractions A(CL,C) of path languages L(CL,C) of push\u00addown \nsystems, for given source and target sets of con.gura\u00adtions CL and C. Therefore, once abstractions A(CiL,Ci)of \nthe path languages LLi have been computed, we check if their intersection is empty, and if the answer \nis a.rmative we con\u00adclude that C1 \u00d7\u00b7\u00b7\u00b7\u00d7Cn is not reachable from C1 L \u00d7\u00b7\u00b7\u00b7\u00d7CnL .  3.2 Examples of Path \nLanguage Abstractions We consider hereafter four examples of abstract path lan\u00adguages. Notice that in \norder to apply our approach described above, we must give a .nite representation of A(CL,C). So, in fact, \nwe compute an abstract object representing A(CL,C). For the moment we do this informally, and delay the \nformal presentation, which uses a standard abstract interpretation framework, to the next subsection. \n3.2.1 First occurrence ordering The abstract object representing A(CL,C) is a set S of words w such that \nfor every a . Lab, |w|a = 1(|w|a denotes the number of occurrences of the letter a in w). A word Proc: \np1 Proc: p2  n3 m3 Program 2 Program 1 Figure 2: Another example w = a1 \u00b7\u00b7\u00b7an belongs to S if there \nis a path in L(CL,C) such that the set of letters occurring in this path is precisely {a1,...,an}, and \nmoreover, the .rst occurrences of these let\u00adters in the path occur in the ordering de.ned by w (i.e., \nfor every i<j, ai occurs for the .rst time before aj). Checking emptiness of the intersection of the \nlanguages represented by S1 and S2 is equivalent to checking emptiness of their inter\u00adsection as sets. \nIn Figure 2 we can conclude that no global con.guration with n3 and m3 as control locations is reachable: \nWe have S(n3)= {ab,b}, while S(m3)= {cba,ba}. 3.2.2 Label bitvectors Let us forget about the order in \nwhich the .rst occurrence of each letter appears. The abstract object representing A(CL,C) is now a set \nS of bitvectors Lab . B. A bitvector b belongs to S if there is a sequence in L(CL,C) such that b(a)=1 \nif a occurs in the sequence and b(a) = 0 otherwise. In Figure 1 we can conclude that no global con.guration \nwith n3 and m3 as control locations is reachable: We have m3m3 m3 10 1 S(n3)= { , }, while S(m3)= {} \n(the components of 01 1 the bitvectors correspond to the labels a,b). 3.2.3 Forbidden and required sets \nThe abstract object representing A(CL,C) is a pair [F,R], where F,R . Lab. F, the forbidden set, contains \nthe la\u00adbels a that do not occur in any sequence of L(CL,C). R, the required set, contains the labels \na that appear in all se\u00adquences of L(CL,C). [F,R] represents the language of all sequences containing \nno occurrence of letters in F and at least one occurrence of each letter in R. It is easy to see that \nthe languages represented by [F1,R1] and [F2,R2] have empty intersection if and only if F1 nR2 = \u00d8 or \nR1 nF2 = \u00d8. In Figure 3 we can use this information to conclude that no global con.guration with n1 and \nm2 as control locations is reachable: The action ais required to reach n1, but forbidden if we wish to \nreach m2. 3.2.4 Parikh images The abstract object representing A(CL,C) is a (possibly in\u00ad.nite, but, \nas we shall see in the next section, .nitely repre\u00ad Proc: p1 Proc: p2 m0 n0 call p1 n1 m1 m2 Program \n1 Program 2 Figure 3: Yet Another example Proc: p1 Proc: p2 a? m1 call p1 n1 call p1 n3 m2 Program 1 \nProgram 2 Figure 4: A last example sentable) set M of integer vectors Lab . N. A mapping m belongs to \nM if L(CL,C) contains a sequence in which each la\u00adbel a occurs exactly m(a) times. We call mthe Parikh \nimage of the sequence. M represents the language of all sequences whose Parikh-images belong to M. Checking \nemptiness of the intersection of M1 and M2 seen as languages is equiva\u00adlent to checking emptiness of \ntheir intersection as sets.1 In Figure 4 we can conclude that no global con.guration with n3 and m2 as \ncontrol location is reachable: In order to reach n3, a must occur an even number of times; however, in \norder to reach m3, it must occur an odd number of times. There are many other examples. For instance, \nit is possible to mix label bitvectors and Parikh images. For some actions, we retain the information \nwhether they occur in a sequence or not, while for others we count the number of occurrences. Also, in \nsome cases, like the one of Figure 4, it is useful to count modulo a number.  3.3 A formal framework \nLet L be the complete lattice of languages over Lab, i.e., L =(2Lab * ,.,.,n,\u00d8,Lab * ). Formally, an \nabstraction re\u00adquires an abstract lattice D =(D,.,W,n,.,T), where D is some abstract domain, and a Galois \nconnection (a,.)be\u00ad 1It is well-known that Parikh-images of context-free lan\u00adguages are semi-linear sets \nof integer vectors (i.e., unions of sets of the form {Uu+ k1Uu1 + \u00b7\u00b7\u00b7+ knUun |k1,...,kn .N}), or equivalently, \nPresburger arithmetics de.nable sets. tween L and D, i.e., a pair of mappings a : L.D and . : D.Lsuch \nthat .x.L, .y .D.a(x) .y =.x..(y) . Our purpose is to de.ne abstractions such that (i) the ab\u00adstract \npath language a(L(CiL,Ci)) is computable when Ci and Ci L are regular, and (ii) emptiness of an intersection \nis decidable in the domain D. To that aim, we consider ab\u00adstractions where the carrier D of the lattice \nis an idempo\u00adtent closed semiring. An idempotent semiring is a structure \u00af\u00af K=(K,.,8,0,1), where .is \nan associative, commutative, and idempotent (a.a= a) operation, and 8is an associative operation. 0 and \n\u00af \u00af 1 are neutral elements for .and 8, respec\u00adtively, \u00af0 is an annihilator for 8 (a80=\u00af0\u00af8a = 0), and \n8 \u00afdistributes over .. A semiring is closed if .can be extended to an operator over countably in.nite \nsets (i.e., countably in\u00ad.nite sums are allowed), and this operator has the same prop\u00aderties as .(it \nis associative, commutative, idempotent, and 8 0 n+1 n distributes over it). As usual, we de.ne a =\u00af= \na8a 1, a , s *n and a= n=0 a . Adding the *-operation to Ktransforms it into a Kleene algebra. The semiring \nof an abstraction is generated by \u00af1 and an element va 0, \u00affor each a.Lab. Intuitively, the abstract \noperations .and 8of Kcorrespond to union and concatenation of languages in the lattice L.0 \u00afand 1 are \nthe abstract objects corresponding to the empty \u00aflanguage and to {E}, respectively. The element va corre\u00adsponds \nto the language {a}. The order, bottom element and join operation of the abstract lattice are given by \nx = y if x.y = y, . = 0, and W = ., \u00afrespectively. Intuitively, the top element T. K and the meet operation \nncorrespond in the lattice Lto Lab * and to language intersection, respectively. The Galois connection \nof an abstraction is given by a:2Lab * . K and . : K .2Lab * such that a(L)= va1 8\u00b7\u00b7\u00b78van a1\u00b7\u00b7\u00b7an.L \n.(x)= {a1 \u00b7\u00b7\u00b7an .2Lab * |va1 8\u00b7\u00b7\u00b78van =x} It can easily be checked that (a,.) is indeed a Galois con\u00adnection. \nMoreover, we have a(\u00d8)= . and .(.)= \u00d8, which implies that .L1,...,Ln.a(L1) n...na(Ln)= .. L1 n...nLn \n= \u00d8 This property is necessary for our approach: In order to check the emptiness of the intersection \nof context-free languages, it su.ces to check the emptiness of the intersection of their abstractions. \nIn this paper, we consider two families of abstractions: 3.3.1 Finite-chain abstractions A .nite-chain \nabstraction is an abstraction such that the semilattice (K,.) has no in.nite ascending chains. Partic\u00adular \ncases of such abstractions are .nite abstractions where the abstract domain K is .nite. 3.3.2 Commutative \nabstractions A commutative abstraction is an abstraction where 8 is com\u00admutative. Intuitively, this means \nthat 8 forgets the order of labels. Thus we get that (K,.,8,*,\u00af0,1) is a commutative \u00afKleene algebra. \n 3.4 Instances of abstractions We show that the four examples of section 3.2 fall in our classes of \nabstractions. 3.4.1 First occurrence ordering Let W = {w . Lab * |.a . Lab,|w|a = 1}, i.e., the set of \nwords where each letter occurs at most once. We consider the semiring K given by: (1) K =2W ; this set \nis generated by the elements va for each a in Lab, where va = {a}, (2) ==., (3) . = ., (4) U 8 V = {u1 \n\u00b7 v2 L | u1 . U and .v2 . V. v2 L is the projection of v2 on the set of letters which do not occur in \nu1}, (5) 0= \u00d8, and (6) 1= {E}. The abstract lattice is obtained by taking T = W, and n = n. Observe that \nthis is a .nite abstraction since K is .nite. 3.4.2 Label bitvectors We consider the semiring K given \nby: (1) K =2[Lab.B] , where [Lab . B] is the set of bitvectors indexed by Lab. K is generated by the \nelements va for each ain Lab, where va is the singleton {ba} given by ba(a)= true, and ba(a L)= false \nfor every a L = a, (2) ==., (3) . = ., (4) 8 = . (extended to vectors componentwise, and to sets of vectors), \n(5) 0= \u00d8, and(6) 1= {(false,...,false)}. The abstract lattice is obtained by taking T =2[Lab.B], and \nn = n. Notice that this abstraction is both .nite and commutative. 3.4.3 Forbidden and required sets \nAbstract elements are no longer sets of vectors, but pairs of sets. The semiring K is de.ned as follows: \n K = {0}.{[F,R] . 2Lab \u00d72Lab | FnR = \u00d8}, i.e., the set of all pairs of sets of actions generated by the \nelements va for each a . Lab, where va(a)=[Lab \\{a},{a}], augmented with a special element 0,  [F1,R1] \n= [F2,R2] iff F1 . F2 and R1 . R2,  [F1,R1] . [F2,R2]=[F1 n F2,R1 n R2],  [F1,R1] 8 [F2,R2]=[F1 n F2,R1 \n. R2],  0 is by de.nition neutral for . and annihilator for 8,  1=[Lab,\u00d8].  The abstract lattice is \nobtained by taking T =[\u00d8,\u00d8], and de.ning n by: [F1,R1] n [F2,R2]=[F1 . F2,R1 . R2]if(F1 n R2) . (F2 \nn R1)= \u00d8,  [F1,R1] n [F2,R2]= 0 otherwise,  0 n x= xn 0= 0. Like the previous one, this abstraction \nis both .nite and com\u00admutative. 3.4.4 Parikh images Abstract elements are semilinear sets of integer \nvectors in [Lab . N]. We recall that semilinear sets are .nite unions of sets of the form {Uu + k1Uv1 \n+ ...knUvn | k1 ...kn . N}, where Uu,Uv1,...,Uvn . [Lab . N](Uu is the basis, and the Uvi s are the periods). \nWe represent semilinear sets as sets of pairs (Uu,{Uv1,...,Uvn}), and we consider the commutative abstraction \nwhere: K is the set of sets of pairs (Uu,.) . [Lab . N] \u00d7 2[Lab.N] generated by the elements va = {(Uua,\u00d8)}, \nfor each a. Lab, where Uua(a)=1 and Uua(b) = 0 for every b= a. . = ., (Uu1,.1) 8 (Uu2,.2)=(Uu1 + Uu2,.1 \n. .2), generalized to sets in the straightforward way,  0= \u00d8,  1= {(U0,\u00d8)}, where U0 is the vector \nassociating 0 to every label a,  {(Uu1,.1),...,(Uun,.n)} * = {(U0,{Uu1,...,Uun}. n .i)}. i=1 The top \nelement T corresponds to the set of all vectors. It is represented by T = {(U0,{Uua | a. Lab})}. The \njoin operation corresponds to set intersection of semilinears. We omit here its de.nition in terms of \nthe representations above since this is not essential for the aim of the paper (it is well-known that \nsemilinear sets are closed under intersection).  4. COMPUTING ABSTRACT PATH LANGUAGES We de.ne structures \nfor representing a(L(CL,C)) and show how their construction can be reduced to a predecessor/successor \ncomputation. 4.1 K-predecessors and K-successors We introduce hereafter a notion of K-con.guration and \nK\u00adtransition relation of pushdown systems. Let us .x from now on a pushdown automaton P =(P,Act,G,c0,.) \n \u00afabstraction. The set of path-expressions .K is the smallest subset of K containing \u00afand a Kleene algebra \n(K,.,8,*,\u00af0,1) corresponding to some 1 and all its basic elements, and closed under 8.A K-con.guration \nof P is a pair (c,p), where c is a con.guration of P and p is a path-expression over K. a We extend the \npushdown transition relation -. to K-con.gu\u00ad a rations as follows: if c-. c L for some action a, then \n(c, p) . K (c L ,va 8 p) and (c, va 8 p) . K (c L,p) for every p . .K ;we say that (c L ,va 8 p) is an \nimmediate K-successor of (c, p) and (c, va 8 p) an immediate K-predecessor of (c L ,va). The forward \n(backward) reachability relation over K .K (. K )is **  4.3 Reduction to computing pre and post im- \nKK ages Let C and CL be two regular sets of con.gurations repre\u00adsented by means of multi-automata, and \nconsider the prob\u00adlem of computing a(L(CL,C)). Assume that we are able to compute a K-multi-automaton \nA pre * K which recognizes the set pre K * (C). Then, we can construct a K-multi-automaton the re.exive \nand transitive closure of . K (. K ). ** A C ' K (C)(postK (C)) pre * K over G \u00d7 K which is the restriction \nof A pre * K to con.g- Given a set of con.gurations C, we de.ne pre as the set of K-con.gurations (c, \np) such that (c, \u00af L 1) . K urations in CL . This automaton can be straightforwardly con\u00ad \u00af (c, p)((c \nL , 1) . K (c, p)) for some c L . C. Intuitively, a K-structed by a product between A pre * K and the \nmulti-automaton successor (c L,p) of a con.guration c memorizes in p a se\u00adrecognizing CL . 2 quence \nof actions that lead from c to c L (from c L to c for K-predecessors). In other words, we have Let us \nassume w.l.o.g. that all con.gurations in CL have the pre K * (c)= { (c L,p) | c L . pre * (c),p . a(L(c \nL ,c))} same control location, say p (the generalization to several control locations is straightforward). \nThen, a(L(CL,C)) is * LL* L postK (c)= { (c ,p) | c . post (c),p . a(L(c, c ))} the element of K de.ned \nby: { e1 8\u00b7\u00b7\u00b78 en | 4.2 K-multi-automata (w,e18\u00b7\u00b7\u00b78en) The algorithmic approach we propose is based \non construct\u00ad ** . p ----------. q an accepting run in A C ' pre ing automata representations of pre \nK and postK-images of regular sets of con.gurations. * K } A symmetrical approach can be adopted by \ncomputing an au\u00ad * K (CL) and then restricting tomaton A post * K recognizing postIn [2, 6] multi-automata \nare used to represent possibly in\u00ad .nite sets of con.gurations. We now extend this notion to K-multi-automata \nin order to manipulate regular sets of K\u00adcon.gurations. Definition 4.1. A K-multi-automaton for the PDS \nP (K-MA for short) is a tuple A =(G,Q, d,P,F ) where Q is a .nite set of states, d . Q\u00d7 G\u00d7 K \u00d7 Q is a \nset of transitions, P . Q is the set of initial states, and F . Q is the set of .nal states. We de.ne \nthe transition relation -.. Q \u00d7 G * \u00d7 K \u00d7 Q as the smallest relation satisfying: (.,e) if (q, ., e, qL) \n. d then q ----. q L , (E,\u00af 1) q ---. q for every q . Q, and (w1,e1)(w2,e2)(w1w2,e18e2) LLLLL L if q \n-----. q and q -----. q then q ----------. q . (.1,e1)(.n,en) A run of A is a sequence p -----. q1 \u00b7\u00b7 \n\u00b7 -----. qn. The label of this run is (.1 \u00b7\u00b7\u00b7 .n,e1 8\u00b7\u00b7\u00b78 en). A accepts a pair m3 (w,p.e) if p ------. \nq for some q . F and some e . K. ( p, w) ,p it to the set of con.gurations C. Therefore, we have reduced \nour problem of computing a(L(CL,C))to (i) constructing K-multi-automata recogniz\u00ading pre * or postK * \n-images, and then (ii) constructing ele- K ments in K representing the K-languages recognized by .nite \nK-automata. The problem (ii) can be solved using standard techniques for solving linear equations in \nclosed semi-rings (e.g., using Floyd-Warshall algorithm, or Gauss elimination). Indeed, this problem \nis similar to the problem of building regular expressions associated with .nite-state automata. Hence, \nthe main problem to solve is how to compute repre\u00adsentations for post * and pre K * -images. We show \nthat we can K reduce this problem to solving polynomial (in)equations. In the following, we consider \nonly the case of computing pre * - K images. A similar procedure which computes postK * -images can \nbe found in the full version of the paper.  5. COMPUTING PRE * IMAGES K Given a regular set of con.gurations \nC recognized by a MA that recognizes pre K * (C). A , we construct a K-MA A pre * K We assume w.l.o.g. \nthat A has no transition leading to an initial state. Multi-automata can be seen as a special case of \nK-multi\u00adautomata in which all transitions are labelled by \u00af 1. Equiva\u00adlently, they can be obtained by \ndropping all the references to K in the de.nition of K-multi-automata. Given a MA A ,we denote by Conf(A \n) the set of con.gurations recognized by A . 2We consider the smallest set of transitions such that \nif Throughout the paper, we will use the symbols p, p L LL (a,e) ,p ,pi, etc. to denote initial states \nof (K-)MAs. Arbitrary states L aL q1 -. q A pre q2 -. q is in A C ' thenis in and * K 1 2 (a,e) LL \n-. (q1,q2)is in A C ' pre L LL (q1,q2) will be denoted by q, q ,qi, etc. * K ,q . 5.1 A generic procedure \nWe proceed in two steps. First, we construct a MA Apre * recognizing the set pre * (C). Then, we tag \nthe transitions of A pre * with adequate elements of K. For the .rst step we use the procedure of [2, \n6], which consists of adding new transitions to A according to the following saturation rule: a LL w \nIf ( p,.) \"-. ( p ,w) and p - . q in the current automaton, add a transition (p,.,q). The second step \nconsists of tagging the transitions t of Apre * with elements l(t) . K, de.ned as the smallest elements \nof K (with respect to = ) satisfying the following inequalities (where vt =\u00af 1): (a1)if t=(q,.,qL) was \nalready a transition of A , then \u00af 1 = l(t), a (a2) for every rule ( p,.) \"-. ( p L,.L) , and every q \n. Q, m 3m3 va 8 l (p L,.L ,q) = l (p,.,q) a (a3) for every rule ( p,.) \"-. ( p L,E) , m L3 va = l (p,.,p) \na (a4) for every rule ( p,.) \"-. ( p L,.1.2) , and every q . Q, m 3m 3 m3 va 8 l (p L,.1,q L) 8 l (q \nL,.2,q) = l (p,.,q) q ' .Q Before showing how to compute these tags, let us brie.y ex\u00adplain the intuition \nbehind the rules. Rules (a1) express that if c is a con.guration from Conf (A ), then (c, \u00af1) has to \nbe accepted by A pre * , K Rules (a2), (a3), and (a4) express that for every rule a L r =(p,.) \". (p \n,u), and every q . Q,if w is such that wL LL q -. q for some .nal state q , and if (( p ,uw) ,p)isa K-predecessor \nof Conf (A ), then so is (( p,.w) ,va 8 p). We have the following theorem, proved in the full paper. \nTheorem 5.1. Given a PDS P and a regular set of con.g\u00adurations recognized by a MA A , the K-MA Apre * \ndescribed K m3 above recognizes precisely preK * Conf(A ) . It remains to show how to compute the tagging \nl(t) for each transition t. For that let t1,t2,...,tm be an arbitrary num\u00adbering of the transitions of \nApre * , and let x1,...,xm be as\u00adsociated variables. Then, by (a1) (a4), l(t1),...,l(tm)isthe smallest \nsolution of a system of inequalities of the form fi(x1,...,xm) = xi, 1 = i= m (2) where the fi s are \nmonomials in K[x1,...,xm]. (It su.ces to observe that two di.erent inequalities of the form e1 = m3 m3 \n l (p,.,q) and e2 = l (p,.,q) can be replaced by the in\u00ad m3 equality e1 . e2 = l (p,.,q) .) Solving \nthese inequations depends on the kind of abstraction we are considering: 5.1.1 Finite-chain abstraction \n Let X =(x1,...,xm), and F be the function m 3 F(X)= f1(x1,...,xm),...,fm(x1,...,xm) . The least solution \nof (2) is the least pre-.xpoint of F.We can show that F is monotonic and . -continuous. Therefore, by \nTarski s theorem, the least pre-.xpoint of F exists and is equal to its least .xpoint, and by Kleene \ns theorem this .xpoint is equal to: Fi(\u00af0) i=0 Then, since (K,. ) does not contain any ascending in.nite \nchain, an iterative computation of the least .xpoint always terminates. Notice that the length of the \nascending chains is not necessarily bounded. When a maximal length exists, e.g., in the case of .nite \nabstractions, it gives an upper bound on the number of iterations of the algorithm. 5.1.2 Commutative \nabstraction \u00afThe system of equations (2) can be solved using Gauss elimi\u00adnation, plus the elegant formula \nof [9] for solving an equation in one single variable. This is the most adequate procedure for an implementation. \nHowever, [9] also provides a .xpoint algorithm to directly solve (2). Since this is more adequate for \na complexity estimate, we recall it brie.y here. In this case (K,. ,8 ,*,\u00af0,1) is a commutative Kleene \nalgebra. We need some preliminaries: Let x =(x1,...,xn) be a vector of indeterminates, let a =(a1,...,an) \nbe a vector of elements of K, and let f = f1,...,fl be a vector of polynomials with indeterminates x \nand coe.cients in K. We write f(a) for the value of f evaluated at a. The jacobian of f, ..xf (x), is \nthe .fi . l\u00d7 n matrix whose i,jth element is (x), where is the .xj .xi di.erential operator given by \n.xi .xj .a = 1,\u00af= 0 for\u00afi = j, and = 0 for\u00afa. K. .xi .xi .xi .f .g . (f . g)= . .xi .xi .xi . .g ) . \n( .f (f 8 g)=(f 88 g) .xi .xi .xi . (f * )= f * 8 .f .xi .xi (m1,e5),(m3,e6)(m1,e9),(m3,e9) (m2,e7),(m0,e8)(m2,e9),(m0,e9) \n Figure 5: The K-MA representing Pre K* (( p,m3G * ) ) Then, the least solution of (2) is the .xpoint \nof the chain a0 = a1 = a2 ... 3 given by a0 = f(0\u00af) .f * ak+1 =(ak) 8 ak, .x That is, to compute ak+1 \nwe evaluate the jacobian at the vector ak, obtaining a matrix over K. Then, we compute the transitive \nclosure of this matrix using e.g. Floyd-Warshall s algorithm. Finally, we compute the product of the \nresulting matrix and the vector ak.  5.2 Example Let us consider as example the program presented on \nthe right of Figure 1. This program is represented by the push\u00addown system P =({ p} ,{ a,b,t} ,{ m0,m1,m2,m3} \n,( p,m0) ,.), where . is the set of rules given at the end of section 2. \u00af Let (K,. ,8 ,*,\u00af0,1) be a \nKleene algebra associated to P . We compute pre K* (( p,m3G * ) ). We start with the MA A = ({ m0,m1,m2,m3} \n,{ p,q} ,{ (p,m3,q),(q,m0,q),...,(q,m3,q)} , { p} ,{ q} ) recognizing ( p,m3G * ) . Our algorithm yields \nthe K-MA depicted in Figure 5, where the labels e1,...,e9 are the least solution of the following inequalities: \n(x4 8 x9) . (x8 8 x3) = x1 va 8 x3 = x2 \u00af 1 = x3 (va 8 x1) . (vb 8 x2) = x4 x8 8 x6 = x5 \u00af 1 = x6 va \n8 x6 = x7 (vb 8 x7) . (va 8 x5) = x8 \u00af 1 = x9 3That this is in fact a chain follows easily from the axioms \nof a Kleene algebra. Let us explain brie.y these inequalities. The inequality va 8 x3 = x2 expresses \nthat if p is a path-expression of K such that (( p,m3) ,p)isa K-predecessor of (( p,m3G * ) ,1), then \nso \u00af m3 is (( p,m2) ,va 8 p) (rule r4). Since the transitions p---. q m2 and p---. q are respectively \ntagged with e3 and e2, it follows that p = e3 . va 8 p = e2. Therefore, va 8 e3 = e2. Similarly, the \ninequality (x4 8 x9) . (x8 8 x3) = x1 expresses that if p is a path-expression of K such that (( p,m0m3) \n,p)is a K-predecessor of (( p,m3G * ) ,1), then so is (( p,m1) ,p) (rule \u00afr3). Since there are two paths \nleading from p to q by m0m3 (which are respectively tagged with e4 8 e9 and e8 8 e3), it follows that \nif p = e8 8 e3 or p = e4 8 e9, then p = e1, which means that e8 8 e3 = e1 and e4 8 e9 = e1, i.e., (e4 \n8 e9) . (e8 8 e3) = e1. We give the solution of these inequalities in the case where (K,. ,8 ,*,\u00af0,1) \nis a commutative Kleene algebra. We apply \u00afthe algorithm provided by [9], where, for example, f1(x)is \nthe monomial (x4 8 x9). (x8 8 x3), and f4(x) is the monomial (va 8 x1) . (vb 8 x2). The jacobian ..xf \nisa9 \u00d7 9 matrix whose elements are either 0, va, vb,or xi. For example, the (1,3)th element of this matrix \nis x8 (since .f1 = x8), and the (2,3)th .x3 .f2 element is va (since .x3 = va). The least solution, \ngiven by e1 = e5 = e8 = va* 8 va 8 vb, e3 = e6 = e9 = 1,\u00afe2 = e7 = va, and e4 =(va 8 va* 8 va 8 vb) . \n(va 8 vb) , is obtained after one iteration. It follows that the con.guration ( p,m0) is tagged with \ne4, meaning that L(( p,m0) ,( p,m3G * ) ) is approximated by e4 = (va 8 va* 8 va 8 vb) . (va 8 vb). For \nthe three commutative abstractions we have considered, we get: m3 m3 In the label bitvectors framework, \nva = 1 , vb = 0 , m3 01 and e4 = 11 . This means that we have to execute at least one a and one b to \ngo from m0 to m3.  In the forbidden and required sets framework, va = [{ b} ,{ a} ] and vb =[{ a} ,{ \nb} ], which means that e4 = [\u00d8 ,{ a,b} ]. This shows that starting from m0, both a and b are required \nto reach the point m3.  m3 m3 In the parikh images framework, va = 01 , vb = 10 , m3 and e4 = { k | \nk = 1} . This expresses that the paths 1 leading from m0 to m3 contain an arbitrary number (= 1) of a \ns, and exactly one b.  5.3 Complexity of the procedure 5.3.1 The .nite-chain case Let nF be the maximal \nnumber of ./8-operations in the monomials fi. \"From the de.nition of the fi s we have that nF = O(|.|\u00b7|Q|). \nTherefore, each iteration step has a cost O(m\u00b7|.|\u00b7|Q|), where m is the number of transitions of Apre \n* . It is shown in [6] that Apre * has O(|Q||.|+|d|) transitions. In typical applications the automaton \nA has constant size (two or three states for pure data.ow analysis). So we can con\u00adsider that m is in \nO(|.|), and therefore that each iteration step computes O(|.|2) operations. The total cost of the al\u00adgorithm \ndepends on the number of iterations which is known to be .nite but not necessarily bounded for all inputs. \nIn the case where this number is bounded, e.g., when the abstract domain is .nite, let . be the length \nof the longest chain in K. In this case, we can have at most m. iterations, since we are computing a \nvector of m elements. Therefore, the run\u00adning time of the iterative .xpoint evaluation algorithm is in \nO(. \u00b7|.|3 \u00b7c), where c is the cost of an operation. Let us study in more details the complexities of \nthe di.erent .nite abstractions we have considered: First occurrence ordering and label bitvectors: In \nthis case the order =is simply set inclusion. So the longest chain in K has 2|Lab| elements. In this \ncase, one operation takes O(2|Lab| ) time. Therefore, the running time of the iterative computation is \n2O(|Lab|) \u00b7|.|3 . Forbidden and required sets: Since we have [F1,R1] = [F2,R2] if and only if F2 . F1 \nand R2 . R1, and since for every [F, R] . K we have F, R . Lab and F nR = \u00d8, the longest possible chain \nin K has at most length |Lab|.If sets of labels are implemented as bitvectors, the . and 8 operations \nare computed using bitwise OR and AND, whose cost is constant or O(|Lab|), depending on the application. \nSo the algorithm runs in O(|Lab|2 \u00b7|.|3)or O(|Lab|\u00b7|.|3)time. 5.3.2 The commutative case The complexity \nis dominated by the .xpoint algorithm of [9]. Since the manipulated matrices have dimension m \u00d7m, each \niteration of this algorithm requires to compute O(m 3) ./8/*-operations. Recall that m is the number \nof transitions of Apre * . As said above, we can consider that m is in O(|.|), and hence, the running \ntime is in O(t \u00b7|.|3 \u00b7c), where t is the number of iterations, and c is the cost of an operation. It \nis proved in [9] that for an arbitrary Kleene algebra the .xpoint of the chain is reached after at most \nO(3m) iterations. Since each iteration requires to compute a transitive closure, the size of the expressions \ncan grow exponentially at each iteration. So the maximal size of an expression can be double exponential \nin m, and so the cost of an operation is also double exponential in m. This is also the dominating factor \nin the overall complexity. However, for particular algebras the running time can be much lower. Let us \ncompute it for our three commutative abstractions. Label bitvectors: If the maximal =-chain in the abstract \nlattice has length ., then the number of iterations of the .x\u00adpoint algorithm is obviously bounded by \nm.. In this case the longest chain in K has 2|Lab| elements. Since the cost of an operation takes O(2|Lab|) \ntime, we get 2O(|Lab|) \u00b7|.|4 time. Forbidden and required sets: In this case the longest pos\u00adsible chain \nin K has at most length |Lab|. So the .xpoint al\u00adgorithm terminates after at most m|Lab|iterations. Since \nthe cost of an operation is constant or O(|Lab|)(* is the identity), the algorithm runs in O(|Lab|2 \u00b7|.|4)or \nO(|Lab|\u00b7|.|4)time. Parikh images: In this case the complexity is the same as for arbitrary algebras. \nAs a result of this analysis, we conclude that the forbidden\u00adrequired analysis has acceptable cost, the \n.rst occurrence or\u00addering and label bitvectors analysis have acceptable cost if there are few synchronization \nstatements, and the Parikh\u00adimage analysis is likely to have too high cost in most cases. It only seems \nof practical interest when there are few syn\u00adchronization statements in loops, since those are responsible \nfor the explosion in the size of the solution. Note that since the label bitvectors and the forbidden \nand re\u00adquired sets abstractions are both .nite and commutative, we can apply either the iterative .xpoint \nevaluation algorithm, or the algorithm of [9]. The analysis above shows that the .rst algorithm has a \nworst case better complexity for these abstractions. However, it is worth mentioning that the num\u00adber \nof iterations in the algorithm of [9] is always bounded whereas this number depends on the considered \ndomain in the case of the .xpoint evaluation algorithm. In fact the algo\u00adrithm of [9] performs a kind \nof .xpoint acceleration. Indeed, this algorithm introduces *-operations after each iteration, which can \nbe seen as acceleration steps. These accelerations can be useful for .nite-chain domains where the chains \ncan be longer than the 3m bound given in [9].  6. CONCLUSIONS AND RELATED WORK We have presented a generic \napproach to the static analysis of concurrent programs with procedures. The e.ect of the procedures is \ndetermined exactly, while the constraints on program paths induced by synchronizations is only approxi\u00admated. \nDue to the undecidability result of [13], approxima\u00adtion techniques must be used. The gist of our technique \nis to approximate context-free languages representing all program paths between two regular sets of con.gurations \nby languages closed under intersection, and for which emptyness is decid\u00adable. We have shown how to compute \na context-free algebra for the context-free language of program paths between two arbitrary regular sets \nof con.gurations. Using algebraic re\u00adsults we have provided two generic algorithms for the com\u00adputation \nof the approximations, and we have shown four pos\u00adsible instantiations leading to analysis of di.erent \nprecision and cost. Work on static analysis of concurrent programs goes back to Taylor s seminal paper \n[15], which showed that many prob\u00adlems are NP-complete even in the intraprocedural case (other problems \nare even PSPACE-complete) and proposed a gen\u00aderal analysis algorithm for di.erent problems. Since then, \nthe intraprocedural case has received considerable attention, and [14] is a good recent survey. In our \nframework, this case corresponds to communicating .nite automata instead of communicating pushdown systems. \nThe set of program paths of each component is regular, and, since regular lan\u00adguages are closed under \nintersection, so is the overall set of program paths. In this case, approximations are used to re\u00adduce \nthe computational cost. The approach of Corbett [3], in which program paths are approximated using integer \nlinear programming, is less precise than our Parikh image approx\u00adimation, but computationally more e.cient. \nIn [11], Mer\u00adcouro. proposes an analysis based on counting the number of communications that have occurred \nin the di.erent chan\u00adnels of the system. The computed approximations are less precise than ours since \nthey are based on a forward analy\u00adsis which terminates due to rough extrapolation techniques. The approach \nof [12] is especially interesting for us. It avoids an exponential state based analysis by means of what \ncan be seen as the de.nition of a weak product of .nite automata. This technique is orthogonal to the \nones shown here, and can be adapted to our pushdown automata model. The only paper to explicitely study \nconcurrency analysis in the presence of procedures seems to be [4]. The paper pro\u00advides an approximate \nanalysis for determining which state\u00adments can be concurrently executed. If statements a and b can be \nconcurrently executed, then it is possible to execute a before b and b before a. The analysis of [4] \ncomputes for each statement a a set of statements B such that for every b .B and every program path, \neither every occurrence of b appears before every occurrence of a, or every occurrence of a appears before \nevery occurrence of b. We have then that a cannot be concurrently executed with any occurrence of b. \nThis analysis can also be carried out in our framework, and we sketch how. First, we say that a1 ...an \nis a subword of a language L if L contains a word of the form u0a1u1 ...un-1anun. Our abstract lattice \nhas as elements pairs (LabL,D), where LabL .Lab and D: LabL \u00d7LabL .{none,12,21,both}. Given a path language \nL(CL,C), we have a(L(CL,C)) = (LabL,D), where LabL is the set of actions that occur in L(CL,C), and \nD(a,b)= none if neither ab nor ba are subwords of L(CL,C);  D(a,b)= 12 if ab is a subword of L(CL,C), \nbut ba is not;  D(a,b)= 21 if ba is a subword of L(CL,C), but ab is not;  D(a,b)= both if both ab \nand ba are subwords of L(CL,C).  It is easy to de.ne operations .and 8corresponding to union and concatenation \nof languages, as well as the operation n corresponding to intersection. Since the lattice is .nite, the \napproximation can be e.ectively computed. If the approxi\u00admation says that D(a,b)= both, then we know \nthat a and b cannot be concurrently executed in any program path from CL to C. Notice that in this case \nwe are not interested in determining if the intersection is empty, but in actually com\u00adputing it. The \nmain advantage of our approach over that of [4] is its genericity. For instance, we can combine the approximation \nof [4] with our alphabet approximation to obtain a more pre\u00adcise analysis. Also, we do not need to prove \nthe correctness of data.ow equations. Notice, however, that in [4] dynamic task creation is allowed, \nwhich is not possible in our current setting. In fact, concurrency analysis with task creation has been \nfurther analyised in recent papers [1, 16]. While pro\u00adcedures can be approximated by considering them \nas new tasks, the analysis is not sensitive to multiple incarnations of the procedure. A possibility \nto add dynamic creation to our setting is to use the technique of [8, 10], and we plan to investigate \nthis in the future. Acknowledgements We thank Luca Aceto for helpful discussions on commuta\u00adtive semirings. \nSriram Rajamani and three anonymous refer\u00adees provided very valuable comments that greatly helped to \nimprove the paper. 7. REFERENCES [1] J. Blieberger, B. Burgstaller, and B. Scholz. Symbolic Data Flow \nAnalysis for Detecting Deadlocks in Ada Tasking Programs. In Proc. of the Ada-Europe International Conference \non Reliable Software Technologies, Potsdam, Germany, 2000. [2] A. Bouajjani, J. Esparza, and O. Maler. \nReachability Analysis of Pushdown Automata: Application to Model Checking. In CONCUR 97, volume 1243 \nof LNCS, 1997. [3] J. C. Corbett. Automated Formal Analysis Methods for Concurrent and Real-Time Software. \nPhD thesis, University of Massachusetts at Amherst. 1992. [4] E. Duesterwald and M. So.a. Concurrency \nanalysis in the presence of of procedures using a data-.ow framework. In Proc. of the Symposium on Testing, \nAnalysis, and Veri.cation, Victoria, Canada, pages 36 48. ACM Press, 1991. [5] M. B. Dwyer and L. A. \nClarke. Data .ow analysis for verifying properties of concurrent programs. In Proceedings of the ACM \nSIGSOFT 94 Symposium on the Foundations of Software Engineering, pages 62 75. ACM Press, 1994. [6] J. \nEsparza, D. Hansel, P. Rossmanith, and S. Schwoon. E.cient algorithm for model checking pushdown systems. \nIn CAV 00, volume 1885 of LNCS, 2000. [7] J. Esparza and J. Knoop. An automata-theoretic approach to \ninterprocedural data-.ow analysis. In W. Thomas, editor, Proc of Foundations of Software Science and \nComputation Structure, FoSSaCS 99, volume 1578 of Lecture Notes in Computer Science. Springer, 1999. \n[8] J. Esparza and A. Podelski. E.cient algorithms for pre* and post* on interprocedural parallel .ow \ngraphs. In Proceedings of the 27th ACM SIGPLAN-SIGACT on Principles of Programming Languages, POPL 2000, \npages 1 11. ACM Press, 2000. [9] M. Hopkins and D. Kozen. Parikh s Theorem in Commutative Kleene Algebra. \nIn Proc. IEEE Conf. Logic in Computer Science (LICS 99). IEEE, 1999. [10] D. Lugiez and P. Schnoebelen. \nThe Regular Viewpoint on PA-processes. In TCS, volume 274(1-2), 2002. [11] N. Mercouro.. An algorithm \nfor analyzing communicating processes. In Mathematical Foundations of Programming Semantics, volume 598 \nof LNCS, pages 312 25, 1991. [12] G. Naumovich and G. Avrunin. A conservative data .ow algorithm for \ndetecting all pairs of statement that may happen in parallel. In Proceedings of the ACM SIGSOFT International \nSymposium on Foundations of Software Engineering, pages 24 34. ACM Press, 1998. [13] G. Ramalingam. Context-sensitive \nsynchronization-sensitive analysis is undecidable. ACM Transactions on Programming Languages and Systems \n(TOPLAS), 22:416 430, 2000. [14] M. Rinard. Analysis of multithreaded programs. In P. Cousot, editor, \nProc. of the 8th International Symposium on Static Analysis, SAS 2001, volume 2126 of LNCS, 2001. [15] \nR. Taylor. A general-purpose algorithm for analyzing concurrent programs. Communications of the ACM, \n26:362 376, 1983. [16] E. Yahav. Verifying safety properties of concurrent Java programs using 3-valued \nlogic. ACM SIGPLAN Notices, 36(3):27 40, 2001.  \n\t\t\t", "proc_id": "604131", "abstract": "We present a generic aproach to the static analysis of concurrent programs with procedures. We model programs as communicating pushdown systems. It is known that typical dataflow problems for this model are undecidable, because the emptiness problem for the intersection of context-free languages, which is undecidable, can be reduced to them. In this paper we propose an algebraic framework for defining abstractions (upper approximations) of context-free languages. We consider two classes of abstractions: finite-chain abstractions, which are abstractions whose domains do not contain any infinite chains, and commutative abstractions corresponding to classes of languages that contain a word if and only if they contain all its permutations. We show how to compute such approximations by combining automata theoretic techniques with algorithms for solving systems of polynomial inequations in Kleene algebras.", "authors": [{"name": "Ahmed Bouajjani", "author_profile_id": "81100358502", "affiliation": "University of Paris", "person_id": "PP14128276", "email_address": "", "orcid_id": ""}, {"name": "Javier Esparza", "author_profile_id": "81100206259", "affiliation": "University of Edinburgh", "person_id": "PP14081224", "email_address": "", "orcid_id": ""}, {"name": "Tayssir Touili", "author_profile_id": "81100592334", "affiliation": "University of Paris", "person_id": "PP39049961", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/604131.604137", "year": "2003", "article_id": "604137", "conference": "POPL", "title": "A generic approach to the static analysis of concurrent programs with procedures", "url": "http://dl.acm.org/citation.cfm?id=604137"}