{"article_publication_date": "01-15-2003", "fulltext": "\n From Symptom to Cause: Localizing Errors in Counterexample Traces * Thomas Ball Mayur Naik Sriram K. \nRajamani Microsoft Research Purdue University Microsoft Research tball@microsoft.com mnaik@cs.purdue.edu \nsriram@microsoft.com ABSTRACT There is signi.cant room for improving users experiences with model checking \ntools. An error trace produced by a model checker can be lengthy and is indicative of a symptom of an \nerror. As a result, users can spend considerable time examining an error trace in order to understand \nthe cause of the error. Moreover, even state-of-the-art model check\u00aders provide an experience akin to \nthat provided by parsers before syntactic error recovery was invented: they report a single error trace \nper run. The user has to .x the error and run the model checker again to .nd more error traces. We present \nan algorithm that exploits the existence of correct traces in order to localize the error cause in an \nerror trace, report a single error trace per error cause, and gen\u00aderate multiple error traces having \nindependent causes. We have implemented this algorithm in the context of Slam,a software model checker \nthat automatically veri.es temporal safety properties of C programs, and report on our experi\u00adence using \nit to .nd and localize errors in device drivers. The algorithm typically narrows the location of a cause \ndown to a few lines, even in traces consisting of hundreds of state\u00adments. Categories and Subject Descriptors \nD.2.4 [Software Engineering]: Software/Program Veri\u00ad.cation model checking; D.2.5 [Software Engineering]: \nTesting and Debugging; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning \nabout Programs General Terms Algorithms, Veri.cation  Keywords software model checking, debugging * \nThis author performed the work reported here during a summer internship at Microsoft Research. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 03, January \n15 17, 2003, New Orleans, Louisiana, USA. Copyright 2003 ACM 1-58113-628-5/03/0001 ...$5.00. 1. INTRODUCTION \nIn recent years, model checking has gained wider use in checking properties of software [13, 7, 3]. Model \nchecking is attractive for two main reasons. First, it does not require the user to provide annotations \nsuch as pre-conditions or loop invariants. Second, when a property violation is detected, a witness to \nthe violation is produced in the form of an error trace (a counterexample) at the source level. Despite \nthese advantages, we believe there is signi.cant room for improving users experiences with model checkers. \nAn error trace can be very lengthy and only indicates the symptom of the error. Users may have to spend \nconsiderable time inspecting an error trace to understand the cause of the error. Moreover, even state-of-the-art \nmodel checkers report a single error trace per run. The user has to .x the error and run the model checker \nagain to .nd more error traces. In this paper, we present a technique that localizes the error cause \nin an error trace, reports a single error trace per error cause, and generates multiple error traces \nhaving independent causes. Our technique requires no changes to model checking machinery it simply uses \nthe model checker as a subroutine. Model checkers function by exhaustively exploring the reachable state \nspace of a model of a program. Upon detect\u00ading a violation of a property, a model checker s internal \ndata structures contain, in addition to the information needed to produce an error trace, information \nabout correct traces paths in which the property of interest is not violated. Our insight is to use \ncorrect traces to localize the likely cause of the error in an error trace. In particular, our algorithm \nidenti.es the transitions of an error trace that are not in any correct trace of the program. The program \nstatements that induce these transitions are likely to contain the causes of the error. Next, the algorithm \nintroduces halt statements in the program at the location of each cause and re-runs the model checker \nto produce additional error traces. Example. Consider the example program in Figure 1. We wish to check \nthat the program uses AcquireLock and ReleaseLock in strict alternation along all paths. We as\u00adsume that \nthe lock is not held on entering main and require that the lock not be held on exiting main. When we \ninput the above program and property to Slam [3], it produces the error trace t1 =[1, 2, 4, 5]. Our algorithm \nuses information about correct traces in the pro\u00adgram to localize the cause of the error. This program \nhas only one correct trace t2 =[1, 2, 3, 5, 6, 7, 9]. The only portion of t1 that does not intersect \nwith t2 is line 4 and our algorithm highlights it as the likely cause. Indeed, the main() {1 AcquireLock(); \n2 if (...) 3 ReleaseLock(); else 4 ...; 5 AcquireLock(); 6 if (...) 7 ReleaseLock(); else 8 ...; 9 \nreturn; } Figure 1: Example program with improper lock us\u00adage. program is missing a call to ReleaseLock \non line 4. The algorithm then introduces a halt statement at line 4 and invokes the model checker again. \nThe halt statement instructs the model checker to stop exploring paths through the statement at line \n4. As a result, the model checker reports a di.erent error trace t3 =[1, 2, 3, 5, 6, 8, 9]. Again, by \ncomparing t3 with the correct trace t2, line 8 is highlighted as the potential cause of the error, another \nhalt statement is introduced at line 8, and the model checker is invoked for the third time. At this \npoint, it reports that there are no more error traces. In summary, our algorithm automatically produces \ntwo error traces, namely, t1 =[1, 2, 4, 5] with line 4 as the identi.ed cause, and t3 =[1, 2, 3, 5, 6, \n8, 9] with line 8 as the identi.ed cause. 0 We present the following results in this paper: A technique \nfor using a model checker as a subroutine to localize the error cause in an error trace, report one error \ntrace per error cause, and generate multiple er\u00adror traces having independent causes; the technique exploits \nthe existence of correct transitions (transi\u00adtions along correct traces) in the state space computed \nby the model checker.  E.cient algorithms for computing the complete set of correct transitions in the \nintraprocedural and interpro\u00adcedural cases; the time complexity of the algorithms is linear in the size \nof the state space computed by the model checker.  Experimental results in the context of the Slam toolkit \nshowing that these algorithms are e.ective at localiz\u00ading the causes of errors in real-world programs. \n Outline. The remainder of the paper is organized as fol\u00adlows. Section 2 presents background material. \nSection 3 de\u00adscribes our general framework for localizing causes in error traces and generating multiple \ntraces using a generic model checker. Section 4 presents the algorithm to identify correct transitions \nfor the intraprocedural case and Section 5 ex\u00adtends it to the interprocedural case. Section 6 demonstrates \nthe performance of our technique in the context of analyz\u00ading safety properties of Windows device drivers. \nSection 7 reviews related work, and Section 8 concludes with a note on future work. 2. PRELIMINARIES \n2.1 Control Flow Graphs We represent programs abstractly via control .ow graphs, following [18]. Each \nprocedure pi in program P = {p1,\u00b7\u00b7\u00b7 ,pn} is repre\u00adsented by a directed graph Gi =(Vi,Ei,ei,xi)withvertices \nVi,edges Ei, entry vertex ei and exit vertex xi.Vertices in Vi corresponding to procedures calls are \ndenoted by Calli .Vi. Each vertex vc in Calli is paired with a unique return-site vertex vr in RetPti \n. Vi.Given a vertex vr in RetPti,we denote the corresponding call vertex by toCall(vr). Program P is \nrepresented by a control .ow supergraph G * =(V * ,E * ,emain) that is the union of the (vertex-and edge-disjoint) \ncontrol .ow graphs of procedures, with addi\u00adtional edges representing the .ow of control via procedure \ncalls and returns. Speci.cally, . V * = Vi,and 1=i=n E * = E0 .E1 . where E0 = Ei and E1 represents the \n.ow of control 1=i=n from caller to callee and vice versa. Edge (v,w) . E1 i. there is a procedure pi \nsuch that either: (i) v .Calli, the procedure called at v is pj,and w = ej, the entry vertex of Gj ,or \n (ii) w . RetPt i, the procedure called at toCall(w)is pj, and v = xj, the exit vertex of Gj.  Finally, \nwe de.ne the following subsets of V * : Entry = {ei |1 =i =n},  Exit = {xi |1 =i=n},  . Call = Calli,and \n1=i=n . RetPt = RetPti. 1=i=n 2.2 Transitions and Traces We assume that programs have global variables \nand pro\u00adcedures have local variables and formal parameters. A state of the program at a vertex is a valuation \nto the variables in scope at the vertex (before the execution of the state\u00adment associated with the vertex). \nLet T denote the set of all states. Each vertex v . V * has an associated statement and a transfer function \nd(v) that maps a state to a set of states. Intuitively, if the statement at v is executed in state . \nthen the resultant set of states is d(v)(.). A transition of G * is a pair ((v1,.1),(v2,.2)) such that \n(v1,v2) . E * and .2 . d(v1)(.1). A projection of a transi\u00adtion, project (((v1,.1),(v2,.2))), is the \nedge (v1,v2). Pro\u00adjections can be generalized to sets of transitions in the usual way. We write (v1,.1) \nr (v2,.2)if ((v1,.1),(v2,.2)) is a transition. A sequence (v1,.1),(v2,.2),...,(vk,.k)is a trace of G \n* if (1) v1 = emain,(2) (vi,.i) r (vi+1,.i+1)for 0 <i<k, and (3) the return vertices in the sequence \nare properly matched with call vertices. (A formal de.nition of the third condition requires associating \na distinguished open and closed parenthesis for each call and return, de.ning a context-free grammar \nfor the language of balanced paren\u00adtheses [18, 2].) procedure Localize(G * , d, v, f) begin while true \ndo switch ModelCheck(G * , d, v, f) of case SUCCESS: output success ; break case FAILURE(T): let C = \nGetCorrectTransitions(G * , d, v, f) and let Causes = project(T) \\project(C) in output T as error trace \nwith causes Causes if Causes =\u00d8 then break for each (vi,vj ) .Causes do let vk = halt in V * := V * .{vk \n}E * := E * -{(vi,vj) }.{(vi,vk),(vk,vj) } end Figure 2: Error cause localization algorithm.  3. ERROR \nCAUSE LOCALIZATION AL-GORITHM We assume we are given a model checking function Mod\u00adelCheck that takes \nas input: a control .ow supergraph G * ,  a transfer function d : V * .T .2T ,  aspeci.ed vertex v \n.V * ,and  a correctness function f :T .bool.  This function can be used to check safety properties, \nsince safety checking can be transformed by a suitable product construction to reachability. The ModelCheck \nfunction determines if there is a trace T ending with (v,.) such that f(.) = false. If there is no such \ntrace, then it returns SUCCESS. Otherwise, it returns FAILURE(T). We assume that, as a side-e.ect, ModelCheck \nannotates each vertex v with States(v), the set of reachable states of v (i.e.,. . States(v) i. there \nis a trace that ends with (v,.)).1 Of course, the existence of such a model checking function presumes \nthat the set of reachable states is computable in .nite time. If not, one must .rst construct a suitable \nab\u00adstraction of the program, such as a boolean program [2]. We will discuss the impact of abstraction \non our algorithm in Section 6. Figure 2 presents the high-level structure of our algo\u00adrithm in the procedure \nLocalize.If ModelCheck re\u00adturns FAILURE(T), then the algorithm invokes the function GetCorrectTransitions \nwhich uses the results of Mod\u00adelCheck to .nd the transitions that belong to correct traces (with respect \nto vertex v and correctness function f). For\u00admally, transition t .GetCorrectTransitions(G * ,d,v,f)i. \nthere is a trace T' containing t such that T' ends with (v,.) and f(.) = true. As we shall see later, \nthe complexity of GetCorrectTransitions is linear in the size of the control 1For the interprocedural \ncase, the ModelCheck function will have to compute more auxiliary information, as dis\u00adcussedinSection \n5. function GetCorrectTransitions(G * , d, v, f) begin var worklist: set of (V * ,T) := {(v,.) |. .States(v) \n.f(.) = true} var visited : set of (V * ,T) := \u00d8 var M: set of transition := \u00d8 while worklist =\u00d8 do \nremove (vj ,.j )from worklist if (vj ,.j ) ./visited then visited := visited .{(vj ,.j )} for each (vi,vj) \n.E * do for each .i .States(vi) do if .j .d(vi)(.i) then worklist := worklist .{(vi,.i)}M := M .{((vi,.i),(vj, \n.j ))} return M end Figure 3: Intraprocedural algorithm for computing correct transitions. .ow graph \nG * and the number of states (that is, it is of the same complexity as ModelCheck). Next, the cause of \nthe error is computed as Causes = project(T) \\project(C).2 That is, the cause lies along edges that belong \nto the error trace T but do not belong to any correct trace. If Causes is non-empty, the algorithm introduces \na halt statement along each edge in Causes,and repeat the entire procedure. Since G * is .nite and each \niter\u00adation introduces at least one halt statement, the algorithm is guaranteed to terminate.  4. COMPUTING \nINTRAPROCEDURAL CORRECT TRANSITIONS Figure 3 presents the algorithm GetCorrectTransitions for the intraprocedural \ncase (a single-procedure program without calls). The simple idea behind our algorithm is to work backwards \nin the state space computed by Mod\u00adelCheck from the states at vertex v that satisfy the cor\u00adrectness \nfunction f (see the initialization of worklist). While the worklist is not empty, a pair (vj ,.j ) is \nremoved. If this pair has not been visited before, each pair (vi,.i) such that (vi,vj ) .E * and .j .d(vi)(.i) \nis added to the worklist. The transition (vi,.i) r (vj ,.j ) is a correct transition and is added to \nset M, which is returned from the function. We now revisit the example of Figure 1 to illustrate the \noperation of GetCorrectTransitions. Figure 4(a) contains the example rewritten to replace each call to \nAcquireLock and ReleaseLock with statements to check the property that locks are alternately acquired \nand released. The variable L is true at a vertex i. the last action to execute was a lock acquisition. \nFigure 4(b) shows the control .ow graph of this program and Figure 4(c) shows its reachable state-space \ngraph (as computed by Mod\u00adelCheck). Let us focus on vertex 5 in the control .ow graph and determine whether \nor not the assert statement at that vertex can fail (i.e., the correctness function f re\u00adturns true i. \nthe expression !L is true). Given this query, 2In Section 6, we will discuss a variation of the algorithm \nthat computes Causes as project(T \\C), and its e.ect on error cause localization. main() { assume(!L) \n1 assert(!L); L := true; 2 if ( ) 3 3{assert(L); L := false;} else 4 ; 5 assert(!L); L := true; 6 if \n( ) 7{assert(L); L := false;} else 7 8 9 assert(!L); } (a) 1 2 5 6  9  assert(!L) L := true assert(!L) \nL := true assert(!L)  (b) 4 8  (c) Figure 4: (a) The program of Figure 1 rewritten with assertions. \n(b) The control .ow graph of this program. (c) The reachable state-space graph of this program. The grey \nbold nodes represent error states (states in which an assertion will fail). ModelCheck produces the error \ntrace T =(1,L=false) r (2,L=true) r (4,L=true) r (5,L=true), which shows how the assertion can fail. \nNote that, in the reachable state-space graph, it is also possible to reach vertex 5 in a state in which \nthe assertion does not fail. So, GetCorrectTransitions initializes its worklist to the pair (5,L= false) \nand proceeds backwards in the state space of the program, generating as its result the set of correct \ntransitions (1,L=false) r (2,L=true) (2,L=true ) r (3,L=true) (3,L=true) r (5,L=false) Since the projection \nof the set of correct transitions is {(1,2), (2,3), (3,5)}and the projection of the set of transitions \nin error trace T is {(1,2), (2,4), (4,5)},the value of Causes in the Localize procedure of Figure 2 is \n{(2,4), (4,5)},which localizes the cause of the error to line 4 of the program. Since there are only \nthree feasible paths in this program (see the program s state space in Figure 4(c)), both error traces \ncould have been generated by a naive approach in which the model checker generates all error traces. \nHow\u00adever, this approach will report multiple error traces having the same cause. Consider the program \nfrom Figure 1 with the extra conditional statement if (...) A else B inserted before the .rst AcquireLock \ncall. Neither branch of the conditional alters the state of the lock. There are six fea\u00adsible paths in \nthis program: two correct traces and four error traces. The naive approach would report all four error \ntraces but our algorithm still reports two error traces, one per cause. In practice, many branches in \nreal-world pro\u00adgrams are irrelevant to the property being checked. If we do not identify error traces \nby causes, the model checker will report huge numbers of error traces for the same cause.  5. COMPUTING \nINTERPROCEDURAL CORRECT TRANSITIONS Precise model checking and computation of correct tran\u00adsitions in \nthe interprocedural case must take into account the calling context of each called procedure. In particular, \nthe algorithms should only analyze paths in which each call and return are properly matched. 5.1 Additional \nModel Checker Assumptions The ModelCheck function must record at each vertex v .V * more detailed information \nthan States(v). In partic\u00adular, we assume it stores a set of path edges at each vertex and a set of summary \nedges at each call vertex [18, 2]. Intuitively, a path edge incident on vertex v .V * in pro\u00adcedure pg \nis a pair of states (.g ,.) such that there is a trace from the entry vertex of main to the entry vertex \nof pg at state .g and there is a continuation of the trace that reaches (v,.) without exiting pg. Formally, \na path edge incident on vertex v .V * in procedure pg is a pair of states (.g ,.) such that there is \na trace T = T0.T1 where T0 =(v0,.1) r ... r (vi,.i), and T1 =(vi,.i) r ... r (vj ,.j ), and v0 = emain, \nand (vi,.i)=(eg,.g)where eg is the entry vertex of the procedure pg,and (vj ,.j )=(v,.), and for all \ni =k<j, vk = xg where xg is the exit vertex of pg. Let PE(v)denote the set of path edges incident on \nv. Let vc be acall toaprocedure pg. The set of summary edges at vc represents the e.ect of pg as a transfer \nfunction. Formally, the set of summary edges at vc is Summary(vc)= { (.1,.2) |.(.g,.i) .PE(xg)and .g \n.d(vc)(.1)and .2 .d(xg)(.i) } For each vc .Call, we de.ne SE(vc)(.) = {. ' |(.,. ' ) . Summary(vc) }. \n function GetCorrectTransitions(G * , d, v, f): set of transition begin var M: set of transition := \u00d8 \nvar visited: set of (V * ,T,T) := \u00d8 var WL1, WL2: set of (V * ,T,T) WL1 := {(v,.g ,.) |(.g,.) .PE(v) \n.f(.) = true} WL2 := \u00d8 // Phase 1: ascend to callers via call edges, don t descend to callee via return \nedges while WL1 =\u00d8 do remove (vj ,.g ,.j )from WL1 if (vj,.g ,.j ) ./visited then  visited := visited \n.{(vj ,.g ,.j )}if vj .RetPt then let (T,Wc,Wx)= PropagateToCallAndExit(vj,.g,.j ) in M := M .T ; WL1 \n:= WL1 .Wc; WL2 := WL2 .Wx else let (T,W)= Propagate(vj ,.g,.j ) in M := M .T; WL1 := WL1 .W // Phase \n2: descend to callee via return edges, don t ascend to callers via call edges while WL2 =\u00d8 do remove \n(vj ,.g ,.j )from WL2 if (vj,.g ,.j ) ./visited then  visited := visited .{(vj ,.g ,.j )}if vj .RetPt \nthen let (T,Wc,Wx)=PropagateToCallAndExit(vj,.g ,.j ) in M := M .T ; WL2 := WL2 .Wc .Wx else if vj .Entry \nthen let (T,W)= Propagate(vj ,.g,.j ) in M := M .T ; WL2 := WL2 .W return M end Figure 5: Interprocedural \nalgorithm for computing correct transitions. 5.2 Interprocedural Algorithm Figures 5 and 6 presents \nthe algorithm GetCorrect-Transitions for the interprocedural case. The basic idea is the same as that \nfor the intraprocedural case: to work back\u00adwards in the state space computed by ModelCheck from the states \nat vertex v that satisfy the correctness function f. However, the algorithm must be context-sensitive, \ni.e., it must work backwards only along paths in which each call and return are properly matched. Our \nalgorithm is similar to the interprocedural slicing al\u00adgorithm of Horowitz, Reps, and Binkley [14], having \ntwo phases: Phase1 can ascend from the entry vertex of a pro\u00adcedure pg to the vertices that call pg, \nbut it cannot descend from a return point in RetPt to the corresponding callees procedure exit; Phase2, \non the other hand, can descend to procedure exits but cannot ascend to call vertices. (Both phases use \nthe summary edges to move across a call, while properly accounting for its e.ect). The phases operate \non worklists WL1 and WL2 respectively. Each worklist consists of triples (vj ,.g ,.j )where vj .V * and \n(.g ,.j ) .PE(vj ). That is, the worklist consists of path edges incident on ver\u00adtices that are awaiting \nprocessing. While WL1 is not empty, the .rst phase removes a triple (vj ,.g ,.j ) and processes it as \nfollows: If vj .RetPt,the PropagateToCallAndExit func\u00adtion (see Figure 6) is called. This function uses \nthe summary edges for the corresponding call vertex toCall(vj ) to propagate across the call, resulting \nin new correct transitions in T and new triples Wc at the call vertex. The function also computes new \ntriples Wx at the exit of the procedure called at toCall(vj). The sets T and Wc are accumulated in M \nand WL1, respectively, while Wx is accumulated in WL2 to await processing in Phase 2 (recall that the \n.rst phase does not descend to analyze callee procedures).  If vj ./RetPt,the Propagate function is \ncalled, which simply pushes triples backwards through all prede\u00adcessors of vj , identifying new correct \ntransitions and new triples. That is, for each predecessor vi of vj ,if (.g,.i) .PE(vi)and .j .d(vi)(.i), \nthen the transi\u00adtion (vi,.i) r (vj,.j ) is added to T and a new triple (vi,.g,.i) is added to W. T and \nW are accumulated in M and WL1, respectively.  While WL2 is not empty, the second phase removes a triple \n(vj ,.g ,.j ) and processes it as follows: If vj .Entry, then nothing is done (recall that the second \nphase does not ascend to callers). function Propagate(vj :vertex, .g :T,.j :T): (set of transition, \nset of (V * , T, T)) begin var T : set of transition := \u00d8 var W : set of (V * , T, T) := \u00d8 for each (vi,vj \n) .E * do for each (. ' g, .i) .PE(vi) do if (.g =. ' g ) and (.j .d(vi)(.i)) then T := T .{((vi, .i), \n(vj , .j ))}; W := W .{(vi, .g , .i)}return (T,W ) end function PropagateToCallAndExit(vj:vertex, .g \n:T,.j :T): (set of transition, set of (V * , T, T), set of (V * , T, T)) begin var T : set of transition \n:= \u00d8 var Wc: set of (V * , T, T) := \u00d8 var Wx: set of (V * , T, T) := \u00d8 let vc = toCall(vj ) and xh = \nexit vertex of procedure ph for each (. ' g, .c) .PE(vc) do if (.g =. ' g ) and (.j .SE(vc)(.c)) then \ncalled at vc in T := T .{((vc, .c), (vj , .j ))}; Wc := Wc .{(vc, .g, .c)} for each (.h, .i) .PE(xh) \ndo if .h .d(vc)(.c) and .j .d(xh)(.i) then Wx := Wx .{(xh, .h, .i)} return (T,Wc,Wx) end Figure 6: Propagation \nfunctions used by interprocedural algorithm for computing correct transitions. If vj .RetPt ,the PropagateToCallAndExit \nfunc\u00adtion is called. T , Wc,and Wx are computed as before. T is accumulated in M while Wc and Wx are \naccumu\u00adlated in WL2.  Otherwise, the Propagate function is called. T and W are computed as before and \naccumulated in M and WL2, respectively.   6. EXPERIMENTAL ASSESSMENT We have implemented our algorithm \nin the Slam toolkit [3], which checks temporal safety properties of sequential C programs. We checked \n30 Windows device drivers for 2 properties: (i) SpinLock which expresses that locks should be acquired \nand released in strict alternation; it consists of 2 assertions and 2 states, and (ii) IrpCompletion \nwhich speci.es how I/O request packets should be processed; it consists of 18 assertions and more than \n50 states. Figure 7 presents the results of our experiments performed on a 2.2 GHz Pentium PC with 1.5 \nGB RAM. In all, 15 er\u00adror traces were reported for 8 of the drivers. Error trace (15) was a violation \nof SpinLock; the rest were violations of IrpCompletion. The cause was localized precisely in 11 of the \nerror traces. All error traces had single causes; we did not .nd any error trace with multiple causes. \nThe cause was not localized in each of error traces (1), (4), and (11) because of coincidental correctness:a \nsituation in which every control-.ow edge in the error trace is contained in a correct trace. In this \ncase, the variable Causes in Fig\u00adure 2 is the empty set. We illustrate this problem by means of two examples \ndrawn from our experiments, and then show how computing Causes as project(T \\C) instead of project(T \n) \\project(C) solves this problem. Consider the program in Figure 8. We wish to check if it returns the \nsame value as the function foo, which is called exactly once along every path. The program has one error \ntrace t1 =[1, 2, 3, 7, 9, 4, 6]. The error cause lies on lines 3 and 4: the value returned by foo is \nignored at line 3 and the value SUCCESS is unconditionally assigned to the variable status at line 4. \nThe algorithm fails to localize this cause since it belongs to a portion of t1 that intersects with correct \ntrace t2 =[1, 2, 3, 7, 8, 4, 6].3 Note, however, that the transition (4, g=FAILURE) r (6, g=FAILURE, \nstatus=SUCCESS) in the error trace is not in any correct trace. In particular, in the correct trace t2 \nthe transition corresponding to the control edge (4, 6) is (4, g=SUCCESS) r (6, g=SUCCESS, status=SUCCESS). \nin which both variabes g and status have the value SUCCESS at line 6. Consider the program in Figure \n9. We wish to check whether the function bar is called at most once along every path. The program has \none error trace t1 = [1, 2, 3, 9, 10, 4, 5, 6, 7, 8] in which bar is called twice. The error cause is \non line 3: baz is called assuming that the return value of foo is always SUCCESS. The algorithm fails \nto localize this cause since it belongs to a portion of t1 that intersects with correct trace t2 =[1, \n2, 3, 9, 4, 5, 6, 7, 8]. For each of the above cases, localization can be success\u00adfully achieved by computing \nCauses as (1) project(T \\C) 3 There are also two other correct traces that cover the con\u00adtrol edges of \nt1 not covered by t2. name of device driver LOC error trace ID number of transitions in: error cause \nerror trace cumulative running time (sec.) for: model checking cause localization mouse packet .lter \n984 1 2 0 4 73 110 44.6 7.8 serial mouse port driver 7441 3 1 56 62.0 185.9 keyboard packet .lter 1067 \n4 5 0 4 73 107 44.1 7.8 IEEE 1394 bus driver 5818 6 7 8 9 10 7 7 1 3 0 45 44 60 81 85 205.8 114.1 keyboard \nclass driver 13161 11 0 158 365.4 97.8 i8042 port driver 22168 12 13 1 5 127 124 41.6 10.6 packet-based \nDMA driver 24971 14 1 75 40.0 5.4 serial port driver 30905 15 3 248 19.9 6.4 Figure 7: Results of analyzing \nWindows device drivers using SLAM. There is one row per error trace discovered. Column two is the number \nof lines of code in the driver. Column .ve is the number of transitions in the error trace, while column \nfour is the number of transitions in the cause, as identi.ed by our algorithm. For each identi.ed cause, \nwe veri.ed manually that the transitions reported in column four were indeed the real cause of the error. \nColumns six and seven report, for each device driver, the total running time of the model checker and \nthe error cause localization algorithm respectively over all error traces reported for that driver. 1 \nint g; 2 if (...) { 3 foo(); 4 status := SUCCESS; // error: return value } else // of foo is ignored \n5 status := foo(); 6 assert(status = g); return status; int foo() {7 if (...) {8 g := SUCCESS; return \ng; } else {9 g := FAILURE; return g; } } Figure 8: Example of variable-value error. instead of (2) project(T \n) \\ project(C)in Figure 2. Ingen\u00aderal, approach (1) is more precise because it takes into ac\u00adcount di.erences \nin the state components before projecting the state away, while approach (2) projects away the state \ncomponents and then computes the di.erence. However, a drawback of this approach is that it localizes \nthe error cause to an entire su.x of the error trace whose .rst element is the actual cause. For instance, \nin each of the above programs, it localizes the error cause to the su.x of the error trace t1 beginning \nat line 3. It would be interesting to explore ways of combining the two approaches to precisely localize \nerror causes. The cause was not localized in error trace (10) because the current implementation of our \nalgorithm in the Slam toolkit computes correct transitions using abstract states 1 int cnt := 0; 2 status \n:= foo(); 3 baz(); // error: baz should have been called 4 ... // only if status = SUCCESS 5 if (status \n= FAILURE) 6 bar(); 7 ... 8 assert(cnt = 1); void baz() {9 if (...) 10 bar(); } void bar() { cnt++; \n} Figure 9: Example of control .ow error. Function foo is de.ned in Figure 8. as opposed to concrete \nstates, namely, it computes correct transitions in a boolean abstraction constructed from the C program \n[1]. As a result, some of these transitions might be infeasible in the C program and thereby misguide \ncause localization. For instance, for the program in Figure 10, Slam abstracts away the predicate on \nline 4 in the boolean program. As a result, our algorithm .nds the correct trace t1 =[1, 2, 8, 10, 11, \n3, 4, 5, 6, 7] which, while is infea\u00adsible in the C program, is feasible in the boolean program. The \nmodel-checking phase of Slam detects the error trace t2 =[1, 2, 8, 10, 11, 3, 4, 6, 7] in the boolean \nprogram, which is con.rmed to be a feasible trace in the C program. The error cause lies on line 11. \nHowever, our algorithm fails to localize it since line 11 is in correct trace t1. Such impre\u00adcision can \nbe addressed by re.ning the boolean abstraction 1 int cnt := 0; 2 status := taz(); 3 ... 4 if (status \n= SUCCESS) 5 bar(); 6 ... 7 assert(cnt = 1); void taz() {8 if (...) {9 return SUCCESS; else {10 ... \n// error: bar is not called 11 return FAILURE; }} void bar() { cnt++; } Figure 10: Example of model imprecision. \nto include more predicates to rule out the infeasible correct paths. In the above example, this would \nrequire adding the predicate (status = SUCCESS) to the boolean abstraction. Automating this idea is a \ntopic for future work.  7. RELATED WORK 7.1 Multiple Counterexamples There is little work on generating \nmultiple counterexam\u00adples during model checking. The most relevant work is em\u00adbodied in the Verisim testing \ntool for network protocols [5]. Verisim consists of a network simulator that generates traces simulating \na network and a trace checker that determines whether a trace satis.es an extended LTL formula f.Ifa \nviolation is detected, a technique called tuning is used to replace the formula f by a formula . that \nignores the vio\u00adlation. Tuning is not fully automatic and does not attempt to localize the cause of the \nviolation. In the context of detecting security violations in network models, techniques have been proposed \nto generate a set of counterexamples from a model checker as a graph [21]. Our work di.ers from this \ne.ort in that we localize causes in counterexamples and generate one counterexample per cause. 7.2 Error \nCause Localization There are several techniques for error cause localization that are complementary to \nthe approach presented in this paper. The work most closely related to ours is that of Groce and Visser \n[10]. Given error trace T, their technique com\u00adputes a set of negatives, error traces (including T)thatlead \nto the same assertion violation as T,and aset of positives, correct traces that lead to the assertion \nbut do not violate it. Analysis of the common features and the di.erences be\u00adtween positives and negatives \nprovides succinct and useful information about the error trace to the user. Jin, Ravi, and Somenzi [15] \npresent a game-theoretic tech\u00adnique that partitions an error trace into fated segments, con\u00adtrolled by \nthe environment attempting to force the system into an error, and free segments, controlled by the system \nattempting to avoid the error. Fated segments manifest unavoidable progress towards the error while free \nsegments contain choices that, if avoided, might have prevented the error. There isalargebodyofworkonlocating \nthe sourcesof type errors in implicity typed, higher-order languages with let-polymorphism like Haskell, \nMiranda, O Caml, and Stan\u00addard ML [23, 16, 4, 8, 22, 6]. These techniques usually employ the underlying \ntype inference algorithm to identify the source of a type error as a program point or the program subtree \nrooted at that point or, more recently, as a set of program points (a slice) [22]. Program slicing [24] \n(especially dynamic slicing [17]) can be used to .nd the set of statements in an error trace that may \nbe relevant to the cause of the error. Program slicing uses data and control dependences to slice away \nstatements that do not directly a.ect a statement of interest. How\u00adever, such slicing can be misleading \nwhen an error is one of omission. For example, in Figure 4(a), program slicing with respect to the assert \nstatements will slice away the portion of the code in which the omission may lie. Algorithmic debugging \n[20] involves isolating an erroneous procedure by starting from an external point of failure (e.g., an \nincorrect output value) and asking the user a series of questions related to the behavior of procedures \nin the pro\u00adgram (e.g., should concat([ab], [cde]) return [abde] ?). Algorithmic debugging is interactive \nand it does not localize the cause of the error within a procedure it declares erro\u00adneous. Delta debugging \nis a combinatorial testing algorithm that narrows the di.erence in the program state between a pass\u00ading \nrun and a failing run to isolate the statements consti\u00adtuting the cause of the error [25]. Given a correct \nprogram P and a set of changes C = {c1,\u00b7\u00b7\u00b7 ,cn} to P that yield an incorrect program P ' , delta debugging \napplies subsets of C to P and runs the resulting programs in order to determine whether the same error \nis manifested as in P ' .In this man\u00adner, delta debugging uses non-erroneous runs to determine the set \nof changes responsible for the error. 7.3 Anomaly Detection Static analysis techniques like Meta-Level \nCompilation [11] and dynamic analysis tools like Daikon [9], DIDUCE [12], and Eraser [19] all use the \nidea that consistent be\u00adhavior in a program is correct behavior while inconsistent behavior is a likely \nerror. For example, if AcquireLock and ReleaseLock are called in strict alternation 99 out of 100 times, \nthen the single anomalous behavior is .agged as a possible error. Our algorithm can be viewed as a static \ntechnique that exploits consistent behavior to determine the cause of a given error as opposed to the \nerror itself.  8. CONCLUSIONS Techniques such as model checking and data.ow analy\u00adsis have the capability \nto .nd subtle errors in programs. Nonetheless, the problem of .nding the cause of an error is relegated \nto the user. We have shown how to localize the cause in error traces generated by model checkers. The \nkey idea is to .nd transitions in the error trace that ap\u00adpear in no correct trace. Our techniques are \nquite general and should be applicable to error detection tools based on data.ow analysis as well. A \nnumber of interesting research questions remain open. First, is it possible (in some cases) to suggest \na .x to an erroneous program? For example, in the case of the program in Figure 1, it would be fairly \nstraightforward to enhance our algorithm to output a suggested .x of introducing a call to ReleaseLock \nat each of lines 4 and 8. Second, what other kind of information can be used to help localize the cause \nof an error? Program slicing and algorithmic debugging provide information in the form of dynamic data \ndependences and user input. Dynamic data dependences from an error trace track the .ow of values between \nstatements and could be very helpful in tracing back from an assertion failure to the variable de.nitions \nthat caused it. Likewise, user input about which functions in a program can be trusted (e.g., library \nfunctions) could be used to guide the search for a cause. 9. REFERENCES [1] T. Ball, R. Majumdar, T. \nMillstein, and S. K. Rajamani. Automatic predicate abstraction of C programs. In PLDI 01: Programming \nLanguage Design and Implementation, pages 203 213. ACM, 2001. [2] T. Ball and S. K. Rajamani. Bebop: \nA symbolic model checker for Boolean programs. In SPIN 00: SPIN Workshop, LNCS 1885, pages 113 130. Springer-Verlag, \n2000. [3] T. Ball and S. K. Rajamani. The SLAM project: Debugging system software via static analysis. \nIn POPL 02: Principles of Programming Languages, pages 1 3. ACM, 2002. [4] M. Beaven and R. Stansifer. \nExplaining type errors in polymorphic languages. ACM Letters on Programming Languages and Systems, 2(1-4):17 \n30, 1993. [5] K.Bhargavan,C. A. Gunter, M. Kim, I. Lee, D. Obradovic, O. Sokolsky, and M. Viswanathan. \nVerisim: Formal analysis of network simulations. IEEE Transactions on Software Engineering, 28(2):129 \n145, Feb. 2002. [6] O. Chitil. Compositional explanation of types and algorithmic debugging of type errors. \nIn ICFP 01: International Conference on Functional Programming, pages 193 204. ACM, 2001. [7] J. Corbett, \nM. Dwyer, J. Hatcli., C. Pasareanu, Robby, S. Laubach, and H. Zheng. Bandera: Extracting .nite-state \nmodels from Java source code. In ICSE 2000: International Conference on Software Engineering, pages 439 \n448. ACM, 2000. [8] D. Duggan and F. Bent. Explaining type inference. Science of Computer Programming, \n27(1):37 83, July 1996. [9] M. D. Ernst, J. Cockrell, W. G. Griswold, and D. Notkin. Dynamically discovering \nlikely program invariants to support program evolution. IEEE Transactions in Software Engineering, 27(2):1 \n25, February 2001. [10] A. Groce and W. Visser. What went wrong: Explaining counterexamples. Technical \nReport 02-08, RIACS, USRA, 2002. [11] S. Hallem, B. Chelf, Y. Xie, and D. Engler. A system and language \nfor building system-speci.c, static analyses. In PLDI 02: Programming Language Design and Implementation, \npages 69 82. ACM, 2002. [12] S. Hangal and M. S. Lam. Tracking down software bugs using automatic anomaly \ndetection. In ICSE 2000: International Conference on Software Engineering, pages 291 301. ACM, 2002. \n[13] G. Holzmann. Logic veri.cation of ANSI-C code with Spin. In SPIN 00: SPIN Workshop, LNCS 1885, pages \n131 147. Springer-Verlag, 2000. [14] S. Horwitz, T. Reps, and D. Binkley. Interprocedural slicing using \ndependence graphs. ACM Transactions on Programming Languages and Systems, 12(1):26 60, Jan. 1990. [15] \nH. Jin, K. Ravi, and F. Somenzi. Fate and free will in error traces. In TACAS 02: Tools and Algorithms \nfor Construction and Analysis of Systems, LNCS 2031, pages 445 459. Springer-Verlag, 2002. [16] G. F. \nJohnson and J. A. Walz. A maximum .ow approach to anomaly isolation in uni.cation-based incremental type \ninference. In POPL 86: Principles of Programming Languages, pages 44 57. ACM, 1986. [17] B. Korel and \nJ. Laski. Dynamic program slicing. Information Processing Letters, 29(10):155 163, October 1988. [18] \nT. Reps, S. Horwitz, and M. Sagiv. Precise interprocedural data.ow analysis via graph reachability. In \nPOPL 95: Principles of Programming Languages, pages 49 61. ACM, 1995. [19] S. Savage, M. Burrows, G. \nNelson, P. Sobalvarro, and T. Anderson. Eraser: A dynamic data race detector for multithreaded programs. \nACM Transactions on Computer Systems, 15(4):391 411, Nov. 1997.  [20] E. Y. Shapiro. Algorithmic Program \nDebugging.MIT Press, 1982. ACM Distinguished Dissertation. [21] O. Sheyner, S. Jha, and J. M. Wing. Automated \ngeneration and analysis of attack graphs. In IEEE Symposium on Security and Privacy, pages 273 284. IEEE, \n2002. [22] F. Tip and T. B. Dinesh. A slicing-based approach for locating type errors. ACM Transactions \non Software Engineering and Methodology, 10(1):5 55, Jan. 2001. [23] M. Wand. Finding the source of type \nerrors. In POPL 86: Principles of Programming Languages, pages 38 43. ACM, 1986. [24] M. Weiser. Program \nslicing. IEEE Transactions on Software Engineering, SE-10(4):352 357, July 1984. [25] A. Zeller. Yesterday, \nmy program worked. today, it does not. why? In FSE 99: Foundations of Software Engineering, pages 253 \n 267. ACM, 1999.  \n\t\t\t", "proc_id": "604131", "abstract": "There is significant room for improving users' experiences with model checking tools. An error trace produced by a model checker can be lengthy and is indicative of a <i>symptom</i> of an error. As a result, users can spend considerable time examining an error trace in order to understand the <i>cause</i> of the error. Moreover, even state-of-the-art model checkers provide an experience akin to that provided by parsers before syntactic error recovery was invented: they report a single error trace per run. The user has to fix the error and run the model checker again to find more error traces.We present an algorithm that exploits the existence of correct traces in order to localize the error cause in an error trace, report a single error trace per error cause, and generate multiple error traces having independent causes. We have implemented this algorithm in the context of <sc>slam</sc>, a software model checker that automatically verifies temporal safety properties of C programs, and report on our experience using it to find and localize errors in device drivers. The algorithm typically narrows the location of a cause down to a few lines, even in traces consisting of hundreds of statements.", "authors": [{"name": "Thomas Ball", "author_profile_id": "81100472343", "affiliation": "Microsoft Research", "person_id": "PP39044398", "email_address": "", "orcid_id": ""}, {"name": "Mayur Naik", "author_profile_id": "81100223912", "affiliation": "Purdue University", "person_id": "P195415", "email_address": "", "orcid_id": ""}, {"name": "Sriram K. Rajamani", "author_profile_id": "81100468626", "affiliation": "Microsoft Research", "person_id": "P266638", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/604131.604140", "year": "2003", "article_id": "604140", "conference": "POPL", "title": "From symptom to cause: localizing errors in counterexample traces", "url": "http://dl.acm.org/citation.cfm?id=604140"}