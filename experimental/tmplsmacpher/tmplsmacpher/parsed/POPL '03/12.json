{"article_publication_date": "01-15-2003", "fulltext": "\n From Control Effects to Typed Continuation Passing Hayo Thielecke School of Computer Science University \nof Birmingham Birmingham B15 2TT United Kingdom H.Thielecke@cs.bham.ac.uk ABSTRACT First-class continuations \nare a powerful computational ef\u00adfect, allowing the programmer to express any form of jump\u00ading. Types \nand e.ect systems can be used to reason about continuations, both in the source language and in the target \nlanguage of the continuation-passing transform. In this pa\u00adper, we establish the connection between an \ne.ect system for .rst-class continuations and typed versions of continuation\u00adpassing style. A region \nin the e.ect system determines a local answer type for continuations, such that the continua\u00adtion transforms \nof pure expressions are parametrically poly\u00admorphic in their answer types. We use this polymorphism to \nderive transforms that make use of e.ect information, in particular, a mixed linear/non-linear continuation-passing \ntransform, in which expressions without control e.ects are passed their continuations linearly. Categories \nand Subject Descriptors D.3.1 [Programming Languages]: Formal De.nitions and Theory; D.3.3 [Programming \nLanguages]: Language Con\u00adstructs and Features General Terms Languages, Theory Keywords Continuations, \ncontrol e.ects, type and e.ect systems, poly\u00admorphism 1. INTRODUCTION The transformation of a program \ninto continuation pass\u00ading style (CPS) makes all control transfers, such as jumps or procedure calls, \nexplicit. CPS can be used as an interme\u00addiate language in compiling [2, 26]. Moreover, CPS makes it easy \nto accommodate powerful control operators in the Permission to make digital or hard copies of all or \npart of this work for personal or classroom use is granted without fee provided that copies are not made \nor distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. POPL 03, January 15 17, 2003, New Orleans, Louisiana, USA. Copyright \n2003 ACM 1-58113-628-5/03/0001 ...$5.00. programming language, including .rst-class continuations, since \nthese are easily transformed into CPS. Modern programming languages tend to use advanced type systems, \nand increasingly such type systems are used in intermediate and even low level languages. For continua\u00adtions, \nthere are two quite di.erent levels at which types can play a role: the source and the target language \nof the CPS transform. Types for continuation operators in the source, such as call/cc in Scheme [16], \nwere proposed by Gri.n [12] and incorporated into the New Jersey dialect of Standard ML [9]. A further \nre.nement of types is given by type and e.ect systems, as in the FX programming language, which super\u00adimposes \na type and e.ect [17] discipline on a Scheme-like language. While this e.ect system was originally concerned \nwith assignments, Gi.ord and Jouvelot [15] extended it to control e.ects. The output of the CPS transform \nis highly stylized; some of this can be formalized with types [19]. Concretely, if an expression M has \ntype A, its CPS transform M has type (A . Ans) . Ans, where the latter typing can be re.ned in several \nways (some of which are part of the continuations folklore). 1.1 Answer type polymorphism First, the \nanswer type is abstract, in that we can assume it to be a free type variable a: G f M :(A . a) . a Relatively \nlittle use seems to have been made of the ab\u00adstractness of the answer type, although it is used in a \nproof in [25]. Furthermore, if there are no control operators, then we can in fact .-quantify over the \nanswer type variable: G f M : .a.(A . a) . a  1.2 Naturality Another, a priori quite di.erent, property \nwhich an ex\u00adpression in CPS may enjoy, is given by equational reason\u00ading (possibly in an untyped setting). \nSuppose we supply a continuation K to an expression M in continuation passing style. This may or may \nnot be the same as supplying an identity continuation and wrapping K around. We say that M is natural \nif the equation MK = K(M(.x.x)) holds. Naturality holds for expressions which simply return to their \ncurrent continuation, but it may fail for expressions with control e.ects. For instance, if M jumps, \nthus dis\u00adcarding its current continuation, it can discard K in MK; whereas in K(M(.x.x)), it can only \ndiscard .x.x, with K still being applied to the answer. Hence naturality is a possi\u00adble notion of purity. \nA di.erent perspective is given by con\u00adtrol delimiters. Speci.cally, Felleisen [10] de.nes a control \ndelimiter, or prompt , that passes the identity continuation and wraps the current continuation around \nthe answer: % M = .k.k(M (.x.x)) Naturality of M can then be read as M being insensitive to the insertion \nof a prompt, in the sense of M = % M. 1.3 Linear continuation passing Finally, an expression may use \nits continuation linearly: G f M :(A . a) a Here the linear function type indicates that the contin\u00aduation \nis passed linearly, so that M can neither discard its current continuation, nor invoke it multiple times. \nLinear continuation passing is not restricted to languages without control: surprisingly many idioms \nof control, in which con\u00ad tinuations are not .rst-class, adhere to linearity [4]. an e.ect e. E.ects \ntypically form a semilattice with a join operation . and a least element \u00d8 (usually just .nite sets). \nThe least e.ect \u00d8 represents the absence of any e.ects, and an expression with this e.ect is said to \nbe pure. The basic ideas are that an application, in rule (.E), un\u00adleashes all the e.ects that the operator, \nthe operand and the application itself may have. Conversely, .-abstraction, in rule (.I), delays all \nthe e.ects that the body of the ab\u00adstraction may have, turning them into latent e.ects that happen later, \nwhen the procedure is applied. We elide type and region abstraction and application in straction .a.V \n. Since we only consider expressions in the source language together with a type and e.ect derivation, \nexpressions,usingaCurryratherthanaChurchstylesys-.For example,theexpressionwithtype a.A inthe tem. .rule(aI)iswrittenas \nV ,ratherthananexplicittypeab-thetermannotationscouldalwaysbereconstructed. Weassumecountablein.nitesetsoftypeandregionvari-ables.Let \na variablesand .type rangeover rangeover regionvariables.Thesetoffreetypevariablesisde.nedas e follows: \nTyvar(a)= {a} In the absence of control operators, local answer type Tyvar(A polymorphism, naturality \nand linearity are all easy to see and to prove with a straightforward induction. The addition of call/cc \nto the source language, however, seems to break all these properties beyond repair: in the worst case, \nno continuation would be used linearly, all answer types would have to be the same (albeit still a free \ntype variable), and . B) Tyvar(...A)= Tyvar(A) Tyvar(.a.A)= Tyvar(A) \\{a} Analogously, the set of free \nregions is de.ned as follows: Reg(a)= \u00d8 Tyvar(A) . Tyvar(B) = no expression would be natural. 1.4 Contribution \nThe main contribution of this paper is to recover, as far as possible, the above properties of the CPS \ntransform in the presence of call/cc, if .rst-class continuations are tamed by an e.ect system in the \nsource language. On the technical side, this opens the door to bring parametricity machinery to bear \non control e.ects. On a more practical side, it sug\u00adgests the use of e.ect systems for statically deriving \nlinearity of CPS code with the possibility of stack-allocation of acti\u00advation records. 1.5 Outline Section \n2 presents the e.ect system for control which will be used in the paper. We show how regions in the source \nlanguage relate to answer type polymorphism in the target language of the CPS transform in Section 3. \nBuilding on the answer type polymorphism, we modify the CPS transform using parametricity arguments in \nSection 4. We can then pass continuations of expressions without control e.ects lin\u00adearly, as show in \nSection 5. Section 6 concludes.  2. A CONTROL EFFECT SYSTEM We de.ne a type and e.ect system for .-calculus \nwith call/cc closely based on a subset of Jouvelot and Gi.ord s control e.ects [15]. 2.1 Effect systems \nMost of the e.ect system, given in Figure 1, is quite generic in that it could be used for di.erent kinds \nof e.ects. A judgement G fc M : A ! e in a type and e.ect system e . B) Reg(...A)= Reg(A) \\{.} Reg(.a.A)= \nReg(A)  2.2 Control effects The only inference rule speci.c to control is the one for the call-with-current-continuation \noperator (call/cc for short) in Figure 2. The call/cc operation is annotated with e.ects in two places: \nwhere the continuation is seized, and where it is thrown to. Jouvelot and Gi.ord [15] di.eren\u00adtiate between \nthese, calling the latter goto . and the former comefrom .. From our perspective here, both of these \nef\u00adfects amount to non-linearity. Hence we drop the goto and comefrom annotations, so that a control \ne.ect is simply a .nite set of regions. As a further simpli.cation, we only consider the fragment of \nthe e.ect system fc in which e.ects are at most singletons: either the empty e.ect \u00d8, or a single region \n.. We write the singleton {.} as .. This amounts to taking the e.ect joining operation to be partial, \nde.ned only in these cases: \u00d8.\u00d8 = \u00d8 . .\u00d8 = . \u00d8. . = . . . . = . With the restriction to at most singleton \ne.ects, the type rule for call/cc boils down to the following two cases, de\u00adpending on whether the argument \nof call/cc has a control e.ect or not: Reg(A Reg(A) . Reg(B) . Reg(e) = ascribes to an expression M \nin context G both a type A and G fc . . . call/cc : ((A . B) . A) . A e1 G fM : A . B ! e2 G fN : A \n! e3 (.E) G fMN : B ! e1 . e2 . e3 G,x : A fM : B ! e (.I) (Var) ' G f.x.M : A . B ! \u00d8 G,x : A, Gfx \n: A ! \u00d8 G fV : A ! \u00d8 G fV : ...A ! \u00d8 (..I) ./. Reg(G) (..E) ' G fV : ...A ! \u00d8 G fV : A[. . .]! \u00d8 G fV \n: A ! \u00d8 G fV : .a.A ! \u00d8 (.aI) a/. Tyvar(G) (.aE) G fV : .a.A ! \u00d8 G fV : A[a . B]! \u00d8 G fM : A ! . G fM \n: A ! \u00d8 (Masking) ./. Reg(A) . Reg(G) (Weaken) c G fnewreg M : A ! \u00d8 G fM : A ! e cc cc Figure 1: A \ntype and e.ect system cc c e cc cccccc cc e (call/cc) ..e G fcall/cc : ....a..\u00df.((a . \u00df) . a) . a ! \n\u00d8 . Figure 2: Type and e.ect rule for call/cc c and Example 2.1 (Downward continuation) Consider the \nap\u00adplication of a possibly jumping function h: . \u00d8 . .fBc G f. A) Here A and B can be any types; note \nin particular that A The e.ect cannot be masked, since . appears in the context. may contain . free. \nWe supply the required h with an application of call/cc:As shown by Harper and Lillibridge [13, 14], \nadding the c call/cc : ((A . B) . A . h : A V (hW ): A ! . operator call/cc to the polymorphic .-calculus \nmakes the fcbemasked: avoidsthisunsoundness.Werestricttherulesdealingwith c restricted; the value restriction, \nas found in Standard ML [20], Assuming that . is not free in A, the control e.ect can then polymorphism \nin Figure 1 to apply only to values. As usual, f call/cc(.h.V (hW )) : A ! . type system unsound, unless \nthe rules for polymorphism are newreg (call/cc(.h.V (hW ))) : A ! \u00d8 values V comprise .-abstractions, \nvariables and constants (in this case only call/cc): V ::= .x.M | x | call/cc Note that while the operator \ncall/cc on its own is a value, its application to an argument, as in call/cc M, is of course not a value. \n(We will brie.y revisit the soundness issue in Remark 2.3 below.) Intuitively, W is thrown to the call/cc, \nwhile V is dis\u00adcarded; but from the outside, we only see that the expression evaluates to W , so it appears \npure. Example 2.2 (Upward continuation) Consider this ex\u00adpression, where . is not free in A: . fc One \nof the features that make an e.ect system with re-The control e.ect cannot be masked, since . is free \nin the gions work is e.ect masking, as in rule (Masking). Suppose type of the expression. Suppose we \napply the above to some call/cc(.k..x.k(.y.x)) : A . A ! .  2.3 Effect masking fGc there can then be \nno communication of this e.ect to the out-M : A ! ., where . is not free in G or A. Intuitively, pure \nN : A. The control e.ect can then be masked: fc Alternatively, suppose we .-abstract the e.ectful expression: \nnewreg (call/cc(.k..x.k(.y.x)) N): A ! \u00d8 side world, neither by shared variables in G, nor by return \nvalues of type A. Hence the e.ect is private to M and can, as far as the rest of the program is concerned, \nbe masked: . . seen from the outside, M appears not to have the e.ect. fc This control e.ect system is \nvery simple. Nonetheless, it appears reasonably expressive regarding the masking of The region . can \nthen be bound in the function type: .z. call/cc(.k..x.k(.y.x)) : B . (A . A)! \u00d8 control e.ects. . . \nfc 2.4 Examples We consider some small examples to illustrate control ef-Remark 2.3 The expression in \nExample 2.2 was used by fect masking. The .rst is an instance of a downward, the Harper and Lillibridge \n[13, 14] to show the unsoundness second of an upward continuation. of unrestricted .-introduction in \nthe presence of call/cc. .z. call/cc(.k..x.k(.y.x)) : ...B . (A . A)! \u00d8 Speci.cally, the type A could \nhave been a fresh type vari-Lemma 3.3 If a region . is not free in a type A, then the able a: type variable \na. is not free in the CPS transformed type A. . However, in our type and e.ect system as de.ned in Fig\u00adure \n1, we could not .-quantify a, that is, fc call/cc(.k..x.k(.y.x)) : a . a ! . Regions and answer type \npolymorphism are linked. More precisely: M : A ! ., then: . call/cc(.k..x.k(.y.x)) : .a.(a . a)! . G \nf M :(A . a.) . a. fProposition3.4 IfG c The .-introduction is not allowed by our type system, since \n.fc M : A ! \u00d8, then (for some fresh a): G f M : .a.(A . a) . a Proof. The proof is by induction on the \ne.ect derivation, fIfG c the application of call/cc is not a value; this restriction is su.cient to \navoid the unsoundness. As discussed in Example 2.2, region polymorphism and the central step being the \none for e.ect masking. Suppose e.ect masking seem quite analogous. In the next section, we will explain \nboth in terms of answer type polymorphism. f. canbemaskedinG c or A. M : A ! ., that is, . is not free \nin G But then a. is not free in G or A. So by the induction  3. FROM EFFECTS TO POLYMORPHISM When we \ntransform source language expressions into CPS, we can use their e.ect judgements to give a more .ne\u00adgrained \ntyping of the transformed expressions. 3.1 Basic CPS transform Our starting point is the basic call-by-value \nCPS trans\u00adform, enriched with call/cc; such transforms are standard in the continuations literature [9]. \n(We use a Fischer-style variant of CPS, where the continuation comes .rst, as the transform of function \ntypes becomes more symmetric that way.) De.nition 3.1 The basic CPS transform (-) is de.ned as follows: \nx = .k.kx .x.M = .k1.k1(.k2x.Mk2) MN = .k.M(.m.N(.n.mkn)) call/cc = .k1.k1(.k2f.fk2(.k3x.k2x)) newreg \nM = M The basic CPS transform works irrespective of e.ects, so that the newreg M construct is ignored; \nwe could as well delete it before applying the CPS transform. The operator call/cc is typically used \ntogether with a .-abstraction in the idiom call/cc(.h.M), which is trans\u00adformed as follows: call/cc(.h.M)= \n.k1.M[h . .k2x.k1x]k1 The type system for the target language of the CPS trans\u00adform is the polymorphic \n. calculus; see Figure 3. hypothesis, G f M :(A . a.) . a. hence G f M : .a..(A . a.) . a. By renaming \nthe bound variable to some fresh a, we have the required judgement: G f newreg M : .a.(A . a) . a Proposition \n3.4 states that a region determines a local answer type. Masking control e.ects by hiding a region amounts \nto quantifying a local answer type. Example 3.5 Let us revisit Example 2.2. The expression and its type \nare transformed as follows: .z. call/cc(.k..x.k(.y.x)) = .k1.k1(.k2z.k2(.k3x.k2(.k4y.k4x))) ...B . . \n(A . . A) = .a..(((A . a.) . (A . a.)) . a.) . (B . a.) Note how the shared e.ect . forces the answer \ntypes of A . ... and B . ... to be the same, a.. Thus the B\u00adaccepting continuation k2 and the A-accepting \ncontinuation k3 are given the same answer type, as is required to make the CPS-transformed expression \nwell typed. Example 3.6 Consider an expression without control ef\u00adfects, such as: .z..x.x : B \u00d8 \u00d8 c \nf. (A . A)! \u00d8 Then the expression and its type are transformed as follows: De.nition 3.2 We assume that \nfor each region variable . we have a unique type variable a.. The CPS transform of types is then de.ned \nas follows: .z..x.x \u00d8 . B . A . B =(B . a.) . (A . a.) A .a.((B . a) . (A . a)) (a fresh) = = .k1.k1(.k2z.k2(.k3x.k3x)) \n \u00d8 \u00d8 \u00d8 \u00d8 . (A. A) .a.A = .a.A = .a2.((.a3.(A . a3) . (A . a3)) . a2) ...A = .a..A . (B . a2) a = a We \nhave the following CPS-transformed judgement: . (A . A) . a1) . a1 B A transform on types extends to \ncontexts G in the evident way (pointwise). It is easy to see the following lemma: f .z..x.x : .a1.(B \nEach continuation ki has its own (.-bound) answer type ai; there is no sharing of answer types, due to \nthe absence of control e.ects. Example 3.7 Note that the answer type polymorphism does not exclude latent \ncontrol e.ects: the simplest example is a variable with a latent control e.ect: .. h : A . B fc h : A \n. B ! \u00d8 Then we have: h :(B . a.) . (A . a.) f .k.kh : .a.(((B . a.) . (A . a.)) . a) . a Example 3.8 \nConversely, an e.ectful function may be ap\u00adplied to a pure argument: \u00d8 . g :(A . A) . B fc g(.x.x): B \n! . Then after CPS transformation, we have: g :(B . a.) . (.a.(A . a) . (A . a)) . a. ..l f .k.gk(.k2x.k2x):(B \n. a.) . a. The CPS transform in this section only used the e.ect information on types and judgements, \nbut not on terms. Our goal in the next sections is to use the e.ects, purity in particular, to guide \nthe transform of the terms themselves.  4. PARAMETRICITY AND ANSWER TYPE POLYMORPHISM Having established \nthe answer type polymorphism of pure expressions, we now aim to formalize the very restricted use that \na pure expression can make of its continuation. \u00b7 Considering M as a map M : .a.(A . a) . a, where a \nis a fresh answer type, the equality MK = K(M(.x.x)) amounts to naturality in a, with M being a natural \ntrans\u00adformation from the covariant hom functor [A . (-)] to the identity functor [18]. M a .. l [A . \na] [A.K] [A . a ' --. K G,x : A f x : A G,x : A f M : P G f M : A . P G f N : A G f .x.M : A . P G f \nMN : P G f M : A G f M : .a.A a/. Tyvar(G) G f M : .a.A G f M : A[a . B] Figure 3: Polymorphic typing \nof the target language M ] --. What we need is some more general notion of being well\u00adbehaved in a. \nthat specializes to naturality whenever the e.ect can be masked. Relational parametricity [24, 28] pro\u00advides \nsuch a notion. The property we are aiming for is, in essence, one of its basic instances, the Reynolds \nisomorphism (.a.(A . a) . a) ~ = A (where a is not free in A). 4.1 Some basics on parametricity We recall \nsome of the basics of parametricity [24] to prove what Wadler calls theorems for free [28]: equational \nprop\u00aderties that follow from the type of an expression. We follow Pitts [23] in working directly on the \nsyntax. We write R : A . A ' if R is a relation between A and A ' . Let R1 : A . A ' and R2 : B . B ' \nbe relations. Then we de.ne a relation R1 . R2 :(A . B) . (A ' . B ' ) ' ''' by (F, F ) . R1 .R2 i. \nfor all (M, M ) . R1,(FM,F M ) . R2. Let R be a function that maps relations to relations. We de.ne a \nrelation .R as follows: (M, M ' ) . .R i. for all closed types A, A ' , for all relations R : A . A ' \n,(M, M ' ) . R(R). Given an environment . that maps type variables to rela\u00adtions, we interpret each type \nas a relation as follows: Rel(a). = .(a) Rel(A . B). = Rel(A). . Rel(B). Rel(.a.A). = .(R . Rel(A)(.[a \n. R])) We de.ne ' G |= M . M : A to hold if for all environments . mapping type variables to relations \non closed types, and for all substitutions s and s ' with (s(x),s ' (x)) .Rel(G(x)). for all x in G, \nit is the case that (Ms, M ' s ' ) .Rel(A).. We will need the following lemma when building up ex\u00adpressions: \nLemma 4.1 The relation . is compatible [23] in the fol\u00ad lowing sense: a ' G,x : A |= x . x : A Naturality \nis one of the fundamental notions of being uni\u00adform in a. However, the naturality square above is much \ntoo weak as an induction hypothesis, since it is not even clear what naturality in a. is supposed to \nmean in a type like (((A . a.) . (A . a.)) . a.) from Example 3.5. If G |= M . M ' : A . B and G |= \nN . N ' : A, then G |=(MN) . (M ' N ' ): B.  If G,x : A |= M . M ' : B, then G |=(.x.M) . (.x.M ' ): \nA . B.  If G |= M . M ' : A, where a is not free in G, then G |= M . M ' : .a.A.  If G |= M . M ' : \n.a.A, then G |= M . M ' : A[a . B]. Proof. Straightforward induction.  4.2 From polymorphism to naturality \nWe need the answer type polymorphism of pure expres\u00adsions to make the naturality even well-typed, because \nfor a pure expression it is meaningful to supply the identity as the top-level continuation. Assume G \nf M : .a.(A . a) . a where a is not free in A. So we can instantiate a to A with\u00adout a.ecting A, so that \nwe have G f M :(A.A).A, hence G f M(.x.x): A. In fact, the answer type polymorphism, in connection with \nparametricity, is su.cient for naturality to hold, in the following sense: Proposition 4.2 If G fc M \n: A ! \u00d8 then G |= M . .k.k(M(.x.x)) : .a.(A . a) . a That is, we can insert a control delimiter in front \nof a pure term without a.ecting its meaning. If we consider prompts as control operators, inserting them \nwhen they have no ef\u00adfect would seem rather pointless. However, another motiva\u00adtion for them is in terms \nof implementation, since a prompt limits the amount of control information that can be ma\u00adnipulated by \ncall/cc, thus facilitating stack allocation. We could use Proposition 4.2 as the basis for a CPS transform \nwhich inserts a control delimiter for each new region. We will do that in the next section, but using \na dif\u00adferent version of control delimiters. Rather than using a prompt that wraps the current continuation \naround the ex\u00adpression, we will use a control delimiter which works by in\u00adserting .xs.sx. In that connection, \nwe will need the follow\u00ading lemma. Lemma 4.3 If G |= M . M ' : .a.(A . a) . a, where a is not free in \nA, then G |= M . M ' (.xs.sx): .a.(A . a) . a Proof. Let . be an environment mapping type variables to \nrelations on closed types, and let s and s ' be substitutions with (s(x),s ' (x)) .Rel(G(x)).. We need \nto prove that (Ms, M ' s ' (.xs.sx)) .Rel(.a.(A . a) . a). Let B and B ' be closed types and R a relation \nR : B . B ' . Since a is not free in A, Rel(A)(.[a . R]) = Rel(A)., so that Rel((A . a) . a)(.[a . R]) \n=(Rel(A)(.[a . R]) .Rel(a)(.[a . R])) .Rel(a)(.[a . R]) =(Rel(A). . R) . R Let (K, K ' ) .Rel(A). . \nR. De.ne a relation R1 : B . ) . B '' ((A . B ' ) by (N, F ) . R1 i. (N, F K ) . R. Then (K, .xs.sx) \n.Rel(A). . R1. For whenever (N, N ' ) . Rel(A)., we have (KN, (.xs.sx)N ' ) . R1, since '' '' (.xs.sx)NK \n= KN and (KN, K ' N ' ) . R. Now since (Ms, M ' s ' ) .Rel(.a.(A . a) . a))., we have (Ms, M ' s ' ) \n.Rel((A . a) . a))(.[a . R1]) Hence (Ms, M ' s ' ) . (Rel(A)..R1).R1. Since (K, .xs.sx) . Rel(A) . R1, \nthis implies that ((Ms)K, (M ' s ' )(.xs.sx) . R1 ' s '' By de.nition of R1, ((Ms)K, (M )(.xs.sx)K ) \n. R. Hence (Ms, (M ' (.xs.sx))s ' ) . (Rel(A). . R) . R as required. 4.3 An effect-based CPS transform \nInstantiating the answer type in a polymorphic CPS trans\u00adform allows us to obtain more complex CPS transforms \nfrom simpler ones. In particular, instantiating the answer type to \u00df . a gives us a form of continuation-passing, \nstate-passing transform. (The same observation has also been used by F\u00a8uhrmann [11] to generalize from \na continuations monad to a state and continuations monad.) Since the state is merely passed along and \nnot used for anything, it can be typed poly\u00admorphically. We do not need to change anything at all on \nthe transform of expressions, although a few .-expansions may make it clearer how the state s is passed: \nx = .ks.kxs .x.M = .k1s1.k1(.k2xs2.Mk2s2)s1 MN = .ks1.M(.ms2.N(.ns3.mkns3)s2)s1 call/cc = .k1s1.k1(.k2fs2.fk2(.k3xs3.k2xs3)s2)s1 \n In particular, the type variable \u00df could itself be specialized to continuation type, giving us composable \ncontinuations in the style that Danvy and Filinski call meta-continuation passing style [7]. Using the \nanswer type polymorphism, we can in fact switch to meta-continuation passing style locally, each time \nan ef\u00adfect is masked, as we do in our next CPS transform. De.nition 4.4 The e.ect-based CPS transform \n[[-]] is de\u00ad.ned as follows: [[x]] = .k.kx [[.x.M]] = .k1.k1(.k2x.[[M]]k2) [[MN]] = [[M]](.m.[[N]](.n.mkn)) \n[[call/cc]] = .k1.k1(.k2f.fk2(.k3x.k2x)) [[newreg M]] = [[M]] (.xs.sx) The application to (.xs.sx) in \nthe clause for [[newreg M]] is related to Danvy and Filinki s shift and reset control operators [7]. \nWe have not considered the issue of adminis\u00adtrative reductions, but it would be straightforward to modify \nthe transform in the light of Danvy and Nielsen s one-pass CPS transform [8] to avoid generating administrative \nre\u00addexes, which could be done by adding subclauses for values in applications. Proposition 4.5 If G fc \nM : A ! . then G f [[M]] : (A . a.) . a. If G fc M : A ! \u00d8 then G f [[M]] : .a.(A . a) . a To see in \nwhat sense the CPS transform [[-]] amounts to meta-continuation passing, consider the typing of [[newreg \nM]]: the answer type variable is instantiated to the type (A.a). a to get from G f [[M]] : (A . a.) . \na. to [[M]](.xs.sx): (A . a) . a. The next result shows in what sense the e.ect-based CPS transform agrees \nwith the usual one. Proposition 4.6 If G fc M : A ! ., then G |= M . [[M]] : (A . a.) . a. If G fc M \n: A ! \u00d8 then G |= M . [[M]] : .a.(A . a) . a Proof. The proof is by induction over the derivation of \nG fc M : e, using Lemma 4.1. For the clause for e.ect masking, we need Lemma 4.3. The following example \nillustrates how the insertion of con\u00adtrol delimiters based on e.ect information could be useful in an \nimplementation. Example 4.7 Consider the transform of the following ex\u00adpression: call/cc (.h..x.((.y.x)h)). \nIf applied to some huge continuation K, it could keep K live inde.nitely, since h in (.x.((.y.x)h)) keeps \na reference to K. However, h is never invoked, and in fact the control e.ect can be masked. We can insert \na new region, allowing the CPS transform to delimit control: [[newreg (call/cc (.h..x.((.y.x)h)))]] K \n= [[(call/cc (.h..x.((.y.x)h)))]] (.xs.sx) K Here h refers to (.xs.sx) rather than to K. The bene.t of \nusing e.ect information to insert control de\u00adlimiters will become more evident if we combine it with \nlin\u00adear continuation passing in the next section.  5. EFFECT-BASED LINEAR/NON-LINEAR CPS TRANSFORM \nBuilding on the e.ect-based CPS transform, our aim in this section is to use e.ect information to pass \ncontinuations linearly whenever there are no control e.ects. The target language with linear typing is \nde.ned as in Fig\u00adure 4. It is essentially the same target language as was used for studying linear continuation \npassing in earlier work [4], based on Barber and Plotkin s Dual Intuitionistic Linear Logic. In addition \nto the usual (intuitionistic) application and abstraction, the target language contains linear application, \nM N, and linear abstraction, dx.M; the latter will only be used for passing continuations. Continuations \nthemselves are not linear, in that they can use their arguments any number of times. A pure expression \nis passed its continua\u00adtion linearly. An expression with control e.ects is passed its continuation intuitionistically \n(that is, without restrictions on copying and discarding). If a continuation is constrained to be passed \nlinearly, then we cannot pass it to a non-linear function: the type system prevents that. To interface \nbe\u00adtween the linear and non-linear continuation passing, we use meta-continuations and control delimiters. \n This e.ect-based CPS transform is de.ned on e.ect judge\u00adments of fc, rather than simply on terms. To \nbe able to write it concisely, we abuse notation as follows. We assume that for each term M we are given \nthe type A and e.ect e ascribed to M in the derivation by writing (|M : A ! e|). The e.ect annotations \non the right-hand side are meant to be read as guards , determining which clause is chosen. For instance, \nthe transform of applications MN,(|MN : B ! e|), depends on whether M, N, and the procedural value returned \nby M are pure or not. Whenever any of these is pure, the cor\u00adresponding continuation is passed linearly; \notherwise it is passed non-linearly. Hence there are 23 = 8 separate cases for the transform of an application. \nDe.nition 5.1 The CPS transform (|-|) is de.ned on terms as in Figure 5. Here is the corresponding CPS \ntransform of types: . (|A . B|) = ((|B|) . a.) . ((|A|) . a.) \u00d8 (|A . B|)= .a.((|B|) . a) ((|A|) . a)(a \nfresh) (|.a.A|)= .a.(|A|) (|...A|)= .a..(|A|) (|a|) = a \u00d8 Pure function types A . B are transformed \nas linear con\u00adtinuation transformers. For this transform, we have: Proposition 5.2 If G fc M : A ! ., \nthen (|G|) f (|M : A ! .|) : ((|A|) . a.) . a. If G fc M : A ! \u00d8, then (for some fresh a): (|G|) f (|M \n: A ! \u00d8|): .a.((|A|) . a) a Proof. We only consider the case of e.ect masking, as the most crucial part \nof the mixed linear/non-linear CPS transform is the interfacing between unrestricted continua\u00adtion passing \nfor e.ectful expressions and the linear continu\u00adation passing for pure expressions. Suppose M has a control \ne.ect that can be masked: G fc M : A ! . where . is not free in G or A. Then (|G|) f (|M : A ! .|) : \n((|A|) . a.) . a. Since a. is not free in (|G|) or (|A|), we can specialize it (by quantifying and then \ninstantiating). We specialize a. to ((|A|) . a) a, for some fresh a. Intuitively, this amounts to introducing \nlinear state-passing of an (|A|)-accepting con\u00adtinuation. (|G|) f (|M : A ! .|) : ((|A|) . ((|A|) . a) \na) .((|A|) . a) a Then, because f .x.ds.sx :(|A|) . ((|A|) . a) a, we have (|G|) f (|M : A ! .|)(.x.ds.sx) \n: ((|A|) . a) a Since a is not free in (|G|) or (|A|), we can quantify over it: (|G|) f (|M : A ! .|)(.x.ds.sx): \n.a.((|A|) . a) a This is the type required for the pure expression (|newreg M : A ! \u00d8|)=(|M : A ! .|)(.x.ds.sx) \n G, x : A; f x : A G; x : P f x : P G; ., x : P f M : Q G; .1 f M : P Q G; .2 f N : P G; . f dx. M : \nP Q G; .1, .2 f M N : Q G, x : A; . f M : P G; . f M : A . P G; f N : A G; . f .x. M : A . P G; . f M \nN : P G; . f M : A G; . f M : .a.A a /. Tyvar(G) . Tyvar(.) G; . f M : .a.A G; . f M : A[a . B] Figure \n4: Target language with linear typing \u00d8\u00d8\u00d8\u00d8.... \u00d8. .. \u00d8. (|MN : B ! \u00d8|)= dk.(|M : A . B ! \u00d8|)(.m.(|N \n: A ! \u00d8|)(.n.m kn)) (|MN : B ! .|)= .k.(|M : A. B ! .|)(.m.(|N : A ! \u00d8|)(.n.m kn)) .. (|MN : B ! .|)= \n.k.(|M : A . B ! \u00d8|)(.m.(|N : A ! .|)(.n.m kn)) (|MN : B ! .|)= .k.(|M : A . B ! .|)(.m.(|N : A ! .|)(.n.m \nkn)) (|MN : B ! .|)= .k.(|M : A . B ! \u00d8|)(.m.(|N : A ! \u00d8|)(.n.mkn)) (|MN : B ! .|)= .k.(|M : A . B ! \n.|)(.m.(|N : A ! \u00d8|) (.n.mkn)) (|MN : B ! .|)= .k.(|M : A . B ! \u00d8|) (.m.(|N : A ! .|)(.n.mkn)) (|MN : \nB ! .|)= .k.(|M : A . B ! .|)(.m.(|N : A ! .|)(.n.mkn)) (|.x.M : A . B ! \u00d8|)= dk1.k1(dk2..x.(|M : B ! \n\u00d8|) k2) (|.x.M : A . B ! \u00d8|)= dk1.k1(.k2x.(|M : B ! .|)k2) (|x : A ! \u00d8|)= dk.kx (|call/cc : ((A . B) \n. A) . A ! \u00d8|)= dk1.k1(.k2f.f k2(.k3x.k2x)) (|call/cc : ((A . B) . A) . A ! \u00d8|)= dk1.k1(.k2f.fk2(.k3x.k2x)) \n(|M : A ! .|)= .k.(|M : A ! \u00d8|) k (|newreg M : A ! \u00d8|)=(|M : A ! .|)(.x.ds.sx) Figure 5: E.ect-based \nlinear/non-linear CPS transform The application to .x.ds.sx amounts to a control delim\u00aditer, in that \nthe expression M is only passed the composable continuation (.x.ds.sx), which it is at liberty to discard \nof copy. The outer portion of the continuation, however, is una.ected by that, since it it merely passed \nalong linearly. To relate the mixed linear/non-linear CPS transform to those that do not use linearity, \nwe de.ne a translation (). , which simply forgets about linearity: (dx.M). = .x.M. (MN). = M .N. (AB). \n= A. . B. On non-linear abstractions and applications, the translation does nothing: (.x.M). = .x.M. \n(MN). = M.N. . x = x (A . B). = A. . B. (.a.M). = .a.M. a. = a If G;. f M : A, then G. , .. f M. : A. \n. Erasing the linearity gives us the previous transform, [[-]]. Proposition 5.3 If G fc M : A ! \u00d8 then \nG |= M . (|M : A ! \u00d8|). : .a.(A . a) . a If G fc M : A ! ., then G |= M . (|M : A ! .|). :(A . a.) . \na. Example 5.4 Consider transforming the expression (newreg (call/cc(.h.V (hW )))) U into continuation \npassing style, where V and W are val\u00adues not containing h. Intuitively, when h is applied to W , control \nwill jump past the application of V , but not the ap\u00adplication to U, so that we can mask the control \ne.ect of the application of call/cc. Hence we would hope to pass the continuation corresponding to the \napplication of U linearly. With the standard CPS transform, that is not possible. We have: (newreg (call/cc \n(.h.V (hW )))) U = .k1.call/cc(.h.V (hW ))(.m.U(.n.mk1n)) = .k1.(.k2..h.V (hW )(.f.fk2(.k3x.k2x))) (.m.U(.n.mk1n)) \nSince k2 appears twice in the application fk2(.k3x.k2x)), we cannot replace the abstraction .k2 with \na linear abstraction dk2. However, if we use the mixed linear/non-linear CPS trans\u00adform, the e.ect masking \ninserts a control delimiter: (|newreg (call/cc(.h.V (hW ))) : A ! \u00d8|) =(|call/cc(.h.V (hW )) : A ! .|)(.x.ds.sx) \n.. =(.k2.(|.h.V (hW ):(A . B) . A ! \u00d8|) (.f.fk2(.k3x.k2x))) (.x.ds.sx) Only the composable continuation \n(.x.ds.sx) is seized by the call/cc and manipulated in a non-linear fashion. The outer continuation corresponding \nto the application to U will be passed linearly. This only works because the e.ect system guarantees \nthat the control e.ects do not extend as far as the application to U.  6. CONCLUSIONS This paper establishes \nthe following: a connection between control e.ects on the source, and answer type polymorphism on the \ntarget of the CPS transform;  equational properties (naturality) following from the answer type polymorphism; \n a connection between polymorphism and linearity in a meta-continuation passing transform.  Together, \nthe above lets us de.ne CPS transforms that use e.ect information. The main ideas of linking e.ects and \nCPS can be summarized as follows: E.ect system Polymorphic CPS region answer type e.ect sharing constraint \nfor answer types purity .-quanti.ed fresh answer type e.ect masking .-introduction for the answer type \n The simpli.ed control e.ect system and the CPS trans\u00adform into the polymorphic .-calculus are also relevant \nto the study of programming languages from a logical perspec\u00adtive, speci.cally the correspondence between \ncontrol opera\u00adtors and classical logic [12]. At the logical level, it is known that CPS transforms correspond \nto double-negation transla\u00adtions from classical to intuitionistic logic. These translations use either \nfalsity or some arbitrary proposition as the an\u00adswer type . Using the CPS transforms de.ned here, one \ncan be more precise, using di.erent answer types, and quanti.\u00adcation over them, to delimit the extent \nof classical reasoning in a proof. 6.1 Related work Gi.ord and Jouvelot pioneered control e.ect systems \n[15]; they used a continuation semantics, but did not consider typed CPS. By establishing some linearity \neven in the pres\u00adence of call/cc, the present paper addresses one of the loose ends left over by our \nearlier work on linear continuation pass\u00ading [4]. Control delimiters, as studied by Felleisen [10] and \nDanvy and Filinski [7] have a similar aim of con.ning control to parts of a program. Nielsen [22] has \nrecently de.ned a selective CPS trans\u00adform that leaves expressions without control e.ects in direct style. \nHis e.ect system, however, contains neither regions nor e.ect masking. Harper and Lillibridge [14] study \nCPS transforms of polymorphic, ML-like languages. Their con\u00adcern is the polymorphism due to the source \nlanguage, not additional binders introduced by the transform, as we con\u00adsider here. (In fact, even if \nthe source language had no poly\u00admorphism, we would still have answer type polymorphism in the target \nof the CPS transform.) Banerjee, Heintze and Riecke [3] encode Tofte and Talpin s [27] region calculus \ninto a polymorphic .-calculus. It remains to be seen whether their approach could be combined with the \none presented here. 6.2 Directions for further work We have considered only a very simple source language, \nand it remains to extend the results to a more realistic lan\u00adguage. E.ect masking would have to be extended \nto store\u00adpassing. Typing the store in a continuation-passing, store\u00adpassing transform would require the \naddition of recursive types to the target language to accommodate the implicit mutual recursion between \nprocedure and store types (since procedures are passed stores, which themselves contain pro\u00adcedures). \nIn the presence of recursion, parametricity argu\u00adments become more subtle [28], requiring strictness \nto be taken into account. This should not be a problem, since we only need such arguments for continuations, \nwhich could be assumed to be strict. For establishing the connections between polymorphic CPS and operational \nsemantics, the operational techniques developed by Pitts [23] could be use\u00adful. Besides extending the \nlanguage, the other direction for further research is to move closer to the machine. The poly\u00admorphic \nand linear typing of CPS code could be used for deriving e.cient representation of control in typed inter\u00admediate \nor assembly languages [21, 1]. Linear continuation passing could be used to eliminate dynamic checks \nin imple\u00admentations using one-shot continuations [5]. Starting from the mixed linear/non-linear CPS transform, \nit should be possible to derive an implementation in which the contin\u00aduations of expressions without \ncontrol e.ects are stack allo\u00adcated [6], while the continuations of expressions with control e.ects are \nallocated in a stack of regions [27]. Acknowledgments Thanks to Josh Berdine for discussions, and to \nthe anony\u00admous referees and Hongseok Yang for spotting typos.  7. REFERENCES [1] Amal Ahmed and David \nWalker. The logical approach to stack typing. ACM SIGPLAN Workshop on Types in Language Design and Implementation \n(TLDI 03), 2003. [2] Andrew Appel. Compiling with Continuations. Cambridge University Press, 1992. [3] \nAnindya Banerjee, Nevin Heintze, and Jon G. Riecke. Region analysis and the polymorphic lambda calculus. \nIn Proceedings of the Fourteenth Annual IEEE Symposium on Logic in Computer Science, pages 88 97, 1999. \n[4] Josh Berdine, Peter W. O Hearn, Uday Reddy, and Hayo Thielecke. Linear continuation passing. Higher-order \nand Symbolic Computation, 15(2/3), 2002. [5] Carl Bruggeman, Oscar Waddell, and R. Kent Dybvig. Representing \ncontrol in the presence of one-shot continuations. ACM SIGPLAN Notices, 31(5):99 107, May 1996. [6] Olivier \nDanvy. Formalizing implementation strategies for .rst-class continuations. In Gert Smolka, editor, Programming \nLanguages and Systems, 9th European Symposium on Programming, ESOP, number 1782 in LNCS, pages 88 103. \nSpringer Verlag, 2000. [7] Olivier Danvy and Andrzej Filinski. Representing control, a study of the CPS \ntransformation. Mathematical Structures in Computer Science, 2(4):361 391, December 1992. [8] Olivier \nDanvy and Lasse R. Nielsen. A .rst-order one-pass CPS transformation. In Foundations of Software Science \nand Computation Structures (FoSSaCS) 02, number 2303 in LNCS. Springer, 2002. [9] Bruce Duba, Robert \nHarper, and David MacQueen. Typing .rst-class continuations in ML. In Principles of Programming Languages \n(POPL 91), pages 163 173. ACM, January 1991. [10] Matthias Felleisen. The theory and practice of .rst-class \nprompts. In Principles of Programming Languages (POPL 88), pages 180 190. ACM, January 1988. [11] Carsten \nF\u00a8uhrmann. Varieties of e.ects. In Foundations of Software Science and Computation Structures (FOSSACS) \n2002, volume 2303 of LNCS, pages 144 158. Springer, 2002. [12] Timothy G. Gri.n. A formulae-as-types \nnotion of control. In Principles of Programming Languages (POPL 90), pages 47 58. ACM, 1990. [13] Robert \nHarper and Mark Lillibridge. Polymorphic type assignment and CPS conversion. In Olivier Danvy and Carolyn \nTalcott, editors, Proceedings of the ACM SIGPLAN Workshop on Continuations CW 92, pages 13 22. Department \nof Computer Science, Stanford University, June 1992. Published as technical report STAN CS 92 1426. [14] \nRobert Harper and Mark Lillibridge. Explicit polymorphism and CPS conversion. In Principles of Programming \nLanguages (POPL 93), pages 206 219. ACM, 1993. [15] Pierre Jouvelot and David K. Gi.ord. Reasoning about \ncontinuations with control e.ects. In Prgramming Language Design and Implementation (PLDI), pages 218 \n226. ACM, 1988. [16] Richard Kelsey, William Clinger, and Jonathan Rees, editors. Revised5 report on \nthe algorithmic language Scheme. Higher-Order and Symbolic Computation, 11(1):7 105, 1998. [17] John \nM. Lucassen and David K. Gi.ord. Polymorphic e.ect systems. In Principles of Programming Languages (POPL \n88), pages 47 57. ACM, 1988. [18] Saunders Mac Lane. Categories for the Working Mathematician. Springer \nVerlag, 1971. [19] Albert R. Meyer and Mitchell Wand. Continuation semantics in typed lambda-calculi \n(summary). In Rohit Parikh, editor, Logics of Programs, number 193 in Lecture Notes in Computer Science, \npages 219 224. Springer-Verlag, 1985. [20] Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. \nThe De.nition of Standard ML (Revised). MIT Press, 1997. [21] Greg Morrisett, David Walker, Karl Crary, \nand Neal Glew. From system F to typed assembly language. In Principles of Programming Languages (POPL \n98), pages 85 97. ACM, 1998. [22] Lasse R. Nielsen. A selective CPS transformation. In 27th Annual Conference \non the Mathematical Foundations of Programming Semantics (MFPS), number 45 in ENTCS. Elsevier, 2001. \n[23] Andrew M. Pitts. Parametric polymorphism and operational equivalence. Mathematical Structures in \nComputer Science, 10:321 359, 2000. [24] John C. Reynolds. Types, abstraction and parametric polymorphism. \nIn R. E. A. Mason, editor, Information Processing 83, pages 513 523, Amsterdam, 1983. Elsevier Science \nPublishers B. V. (North-Holland). [25] Jon G. Riecke and Hayo Thielecke. Typed exceptions and continuations \ncannot macro-express each other. In Proceedings 26th International Colloquium on Automata, Languages \nand Programming (ICALP), volume 1644 of LNCS, pages 635 644. Springer Verlag, 1999. [26] Guy Steele. \nRabbit: A compiler for Scheme. Technical Report AI TR 474, Arti.cial Intelligence Laboratory, Massachusetts \nInstitute of Technology, May 1978. [27] Mads Tofte and Jean-Pierre Talpin. Implementation of the typed \ncall-by-value lambda-calculus using a stack of regions. In Principles of Programming Languages (POPL \n94), pages 88 201. ACM, 1994. [28] Philip Wadler. Theorems for free! In 4 th International Conference \non Functional Programming and Computer Architecture (FPCA 89), pages 347 359. ACM, 1989.  \n\t\t\t", "proc_id": "604131", "abstract": "First-class continuations are a powerful computational effect, allowing the programmer to express any form of jumping. Types and effect systems can be used to reason about continuations, both in the source language and in the target language of the continuation-passing transform. In this paper, we establish the connection between an effect system for first-class continuations and typed versions of continuation-passing style. A region in the effect system determines a local answer type for continuations, such that the continuation transforms of pure expressions are parametrically polymorphic in their answer types. We use this polymorphism to derive transforms that make use of effect information, in particular, a mixed linear/non-linear continuation-passing transform, in which expressions without control effects are passed their continuations linearly.", "authors": [{"name": "Hayo Thielecke", "author_profile_id": "81100325684", "affiliation": "University of Birmingham, Birmingham, UK", "person_id": "PP14118206", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/604131.604144", "year": "2003", "article_id": "604144", "conference": "POPL", "title": "From control effects to typed continuation passing", "url": "http://dl.acm.org/citation.cfm?id=604144"}