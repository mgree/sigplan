{"article_publication_date": "01-15-2003", "fulltext": "\n Guarded Recursive Datatype Constructors Hongwei Xi* Chiyan Chen* Gang Chen Boston University {hwxi, \nchiyan, gangchen}@cs.bu.edu ABSTRACT We introduce a notion of guarded recursive (g.r.) datatype constructors, \ngeneralizing the notion of recursive datatypes in functional programming languages such as ML and Haskell. \nWe address both theoretical and practical issues resulted from this generalization. On one hand, we design \na type system to formalize the notion of g.r. datatype construc\u00adtors and then prove the soundness of \nthe type system. On the other hand, we present some signi.cant applications (e.g., implementing objects, \nimplementing staged computa\u00adtion, etc.) of g.r. datatype constructors, arguing that g.r. datatype constructors \ncan have far-reaching consequences in programming. The main contribution of the paper lies in the recognition \nand then the formalization of a program\u00adming notion that is of both theoretical interest and practical \nuse. Categories and Subject Descriptors D.3.2 [Programming Languages]: Language Classi.ca\u00adtions Applicative \nLanguages; D.3.3 [Programming Lan\u00adguages]: Language Constructs and Features Datatypes and Structures \n General Terms Languages, Theory  Keywords Guarded Recursive Datatype Constructors 1. INTRODUCTION \nAlthough we have since found a variety of applications of guarded recursive (g.r.) datatype constructors, \nwe ini\u00adtially encountered this notion in a study on run-time type\u00adpassing. In parametric polymorphism, \nthere is no facility * Partially supported by the NSF Grants No. 0224244 and No. CCR-0229480 Partially \nsupported by the NSF Grant No. 9988529. for a polymorphic function to inspect its type arguments and \nsuch a function behaves uniformly on all possible type arguments. As a consequence, there is no need \nfor passing types at run-time. However, there are numerous occasions in practice where we would want \npolymorphic functions to behave di.erently on di.erent type arguments. This is often called ad-hoc polymorphism. \nFor instance, we may want to implement a function val2string for converting run-time val\u00adues into string \nrepresentations. In order to construct such a function, we need to analyze the types of values at run-time. \nWith run-time type analysis, we can also support various advanced implementation techniques such as .attened \ndata representation [10], polymorphic marshaling [16], unboxed function arguments [12], tag-free garbage \ncollection [20], etc. A (conceptually) simple and direct approach to run-time type analysis is to pass \ntypes or, more precisely, terms repre\u00adsenting types at run-time and then inspect the structure of such \nterms. In order to capture the relation between a type and its term representation, we can declare a \ng.r. datatype constructor TY as follows. typecon (type) TY = (int) TYint | { a, b}.( a * b) TYtup of \na TY * b TY | { a, b}.( a -> b) TYfun of a TY * b TY | { a}.( a TY) TYtyp of a TY The syntax typecon \n(type) TY means that TY is a type constructor of the kind *.*,that is, TY takes one type to form another \ntype. There are four value constructors TYint, TYtup, TYfun and TYtyp associated with TY,which are assigned \nthe following types. TYint :(int)TY TYtup : .a.\u00df.(a)TY *(\u00df)TY .(a *\u00df)TY TYfun : .a.\u00df.(a)TY *(\u00df)TY .(a \n.\u00df)TY TYtyp : .a.\u00df.(a)TY .((a)TY)TY For instance, the following value, TYfun(oTYtup(oTYint, TYint.), \nTYint.) which has the type (int *int . int)TY ,represents the type int *int .int. In general, a value \nof the type (t )TY represents the type t . Nowwe can implement the val2string function as follows. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 03, January \n15 17, 2003, New Orleans, Louisiana, USA. Copyright 2003 ACM 1-58113-628-5/03/0001 ...$5.00. fun val2string \nTYint x = int2string x | val2string (TYtup (pf1, pf2)) (x1, x2) = \"(\" ^ val2string pf1 x1 ^ \",\" ^ val2string \npf2 x2 ^ \")\" | val2string (TYfun _) _ = \"[a function value]\" | val2string (TYtyp _) _ = \"[a type value]\" \nwithtype { a}. a TY -> a -> string The withtype clause in the de.nition is a type annotation, which assigns \nthe type .a.(a)TY . a . string to the de.ned function val2string. The above idea of using terms to represent \ntypes can al\u00adready be found in [6, 22], where a typed calculus .R is intro\u00adduced to facilitate type-passing. \nThe type constructor R in .R corresponds to TY, and its associated value constructors Rint,R\u00d7,R. and \nRR correspond to TYint, TYtup, TYfun and TYtyp, respectively. However, with g.r. datatype con\u00adstructors, \nwe can also form interesting and useful types that cannot be handled in .R. For instance, we can declare \na g.r. datatype constructors HOAS as follows. typecon (type) HOAS = { a}. ( a)HOASlift of a | { a, b}. \n( a * b)HOAStup of a HOAS * b HOAS | { a. b}. ( a -> b)HOASlam of a HOAS -> b HOAS | { a, b}. ( b)HOASapp \nof ( a -> b) HOAS * a HOAS | { a, b}. ( a)HOASfix of a HOAS -> a HOAS This declaration indicates that \nHOAS is a unary type con\u00adstructor, and the value constructors associated with HOAS are assigned the types \nin Figure 1. The type constructor HOAS, which is intended to construct types for a form of higher-order \nabstract syntax trees [4, 18], cannot be induc\u00adtively de.ned because of the type of the value constructor \nHOAS.x.Given a type t ,(t )HOAS is the type for higher\u00adorder abstract syntax trees representing monomorphically \ntyped expressions of the type t . For instance, the following expression in ML, which has the type (int \n. int) . int . int, fn (x:int -> int) => fn (y:int) => x(y) can be represented as follows: HOASlam(fn \n(x:(int -> int) HOAS) => HOASlam (fn (y:int HOAS) => HOASapp (x, y))) Note that the type of the above \nexpression is ((int . int) . int . int)HOAS. Furthermore, we can implement the following function eval \nfor evaluating higher-order abstract syntax trees. fun eval (HOASlift v) = v | eval (HOAStup (e1, e2)) \n= (eval e1, eval e2) | eval (HOASlam f) = fn x => eval (f (HOASlift x)) | eval (HOASapp (e1, e2)) = \n(eval e1) (eval e2) | eval (e as HOASfix f) = eval (f e) withtype { a}. a HOAS -> a Note eval is assigned \nthe type .a.(a)HOAS . a, indicat\u00ading that the evaluation of higher-order abstract syntax trees is type-preserving. \nLater, we will show that the type con\u00adstructor HOAS can play a key r ole in implementing staged computation \n[7, 19]. The introduction of g.r. datatype constructors raises a number of theoretical and practical \nissues. We brie.y out\u00adline our results and design decisions. The .rst and foremost issue that arises \nis the formalization of g.r. datatype constructors in type theory. We showhow .xed-point operators over \ntype constructors of higher kinds can be used to formally de.ne g.r. datatype constructors. In particular, \nwe showhowthe standard fold/unfold operations (for recursive types) and injection operations (for sum \ntypes) can be used to de.ne the value constructors associated with a declared g.r. datatype constructor. \nThe second issue is the decidability and practicality of type-checking in the presence of g.r. datatype \nconstructors. We address this question in two steps. We .rst present an explicitly typed (and overly \nverbose) internal language .2,G\u00b5 in which type-checking can be handled straightforwardly. We next present \nan external language ML2,G\u00b5, a slightly extended fragment of ML, and then mention an elaboration process \nfrom ML2,G\u00b5 to .2,G\u00b5 that preserves the standard operational semantics. When programming in ML2,G\u00b5,the \nprogrammer may omit writing types at various occasions (determined by the elaboration process). The third \nissue is the usefulness of g.r. datatype construc\u00adtors in practice. We present various examples to illustrate \nsome interesting applications of g.r. datatype constructors in capturing program invariants. In particular, \nwe show that g.r. datatype constructors can be combined with a restricted form of dependent types [25, \n23] to type programming ob\u00adjects, overcoming some signi.cant de.ciencies in many ex\u00adisting type systems \nfor object-oriented programming [2]. In summary, we present a generalization of the notion of recursive \ndatatypes, allowing the programmer to form g.r. datatype constructors. The most signi.cant contribution \nof the paper lies in the recognition of such a simple and nat\u00adural generalization that can have far-reaching \nconsequences in programming. We formalize the notion of g.r. datatype constructors in a type system and \nthen establish the type soundness of the type system, which constitutes the main technical contribution \nof the paper. We also present various realistic and interesting examples in support of the intro\u00adduction \nof g.r. datatype constructors into a programming language. We organize the rest of the paper as follows. \nIn Section 2, we introduce an internal language .2,G\u00b5 to formalize the notion of g.r. datatype constructors, \npresenting both static and dynamic semantics for .2,G\u00b5 and proving its type sound\u00adness. We next form \nan external language ML2,G\u00b5 in Sec\u00adtion 3 and then mention an elaboration process from ML2,G\u00b5 to .2,G\u00b5 \nto support unobtrusive programming. We use some interesting examples in Section 4 to illustrate various \nappli\u00adcations of g.r. datatype constructors. Lastly, we mention some future research directions and related \nworks. There is a full version of the paper on-line [24], where various omitted details can be found. \n 2. THE LANGUAGE .2,G\u00b5 We present a language .2,G\u00b5 based on the explicitly typed second-order polymorphic \n.-calculus. We present both static and dynamic semantics for .2,G\u00b5 and then showthat the type system \nof .2,G\u00b5, which supports g.r. datatype con\u00adstructors, is sound. The language .2,G\u00b5 is designed to be \nan internal language. Later, we will also present an external language ML2,G\u00b5 and mention an elaboration \nprocess from ML2,G\u00b5 to .2,G\u00b5. When programming in ML2,G\u00b5, the programmer may omit writing certain types, \nwhich can be reconstructed through the elaboration process. 2.1 Syntax We present the syntax for .2,G\u00b5 \nin Figure 2, which is mostly standard. We use a for type variables, 1 for the unit type and Tt for a \n(possibly empty) sequence of types t1,...,tn. We have two kinds of expression variables: x for lam-variables \nand f for .x-variables. We use xf for either a lam-variable or a .x-variable. We can only form a .\u00adabstraction \nover a lam-variable and a .xed-point expression over a .x-variable. Note that a lam-variable is a value \nbut a .x-variable is not. We use c for constructors and assume that every constructor is unary.1 Also, \nwe require that the 1For a constructor taking no argument, we can treat it as a HOASlift HOAStup HOASlam \nHOASapp HOAS.x : .a.a .(a)HOAS : .a.\u00df.(a)HOAS *(\u00df)HOAS .(a *\u00df)HOAS : .a.\u00df.((a)HOAS .(\u00df)HOAS) .(a .\u00df)HOAS \n: .a.\u00df.(a .\u00df)HOAS *(a)HOAS .(\u00df)HOAS : .a.((a)HOAS .(a)HOAS) .(a)HOAS Figure 1: The value constructors \nassociated with HOAS and their types types t ::= patterns p ::= clauses ms ::= expressions e ::= values \nv ::= exp. var. ctx. G ::= typ. var. ctx. . ::= a |1 |t1 *t2 |t1 .t2 | (Tt)T |.a.t x |o.|op1,p2.|c[aT](p) \n(p1 .e1 |\u00b7\u00b7\u00b7|pn .en) x |f |c[Tt](e) o.|oe1,e2.|fst(e) |snd(e) | .x : t.e |e1(e2) |.a.v |e[t] | .x f : \nt.v |case e of ms | let x = e1 in e2 end x |c[Tt](v) |o.|ov1,v2.| .x : t.e |.a.v \u00b7|G,x : t \u00b7|.,a |.,t1 \n=t2 Figure 2: Syntax for the internal language .2,G\u00b5 body of either . or .x be a value. The syntax for \npatterns is to be explained in Section 2.3. We use T for substitutions mapping type variables to types \nand dom(T) for the domain of T. Note that T[a . t], where we assume a .dom(T), extends T with a map\u00adping \nfrom a to t. Similar notations are also used for sub\u00adstitutions . mapping variables xf to expressions. \nWe write [T] ( [.]) for the result of applying T (.)to ,where can be a type, an expression, a type variable \ncontext, an expression variable context, etc. We use.for typevariable contextsin .2,G\u00b5.As usual, we can \ndeclare a type variable a in a type variable context .. We use. f t : * to mean that t is a well-formed \ntype in which every type variable is declared in .. All type formation rules are standard and thus omitted. \nWe can also declare a type equality t1 = t2 in .. Intuitively, when deciding type equality under ., we \nassume that the types t1 and t2 are equal if t1 =t2 is declared in .. Given two types t1 and t2,wew rite \nt1 = t2 to mean that t1 is a-equivalent to t2. The following rules are for deriving judgments of the \nform fT : ., which roughly means that Tmatches .. fT:. ft : *fT:. t1[T] = t2[T] f[] : \u00b7fT[a .t]:.,a fT:.,t1 \n=t2 We use . |= t1 =t2 for a type constraint; this constraint is satis.ed if we have ft1[T] =t2[T] for \nevery T such that f T : . is derivable. As can be expected, we have the following proposition. Proposition \n2.1. If . ft : *is derivable, then . |= t =t holds.  If . |= t1 =t2 holds, then . |= t2 =t1 also holds. \n If . |= t1 =t2 and . |= t2 =t3 hold, then . |= t1 = t3 also holds.  constructor taking the unit o.as \nits argument. Pattern typing rules .0 fp .t .(.; G) .0 ft : * (pat-var) .0 fx .t .\u00b7; x : t (pat-unit) \n.0 fo..1 .\u00b7; \u00b7 .0 fp1 .t1 ..1;G1 .0 fp2 .t2 ..2;G2 (pat-tup) .0 fop1,p2..t1 *t2 ..1, .2;G1, G2 S(c)= \n.Tt1)T a.t .(T .0,Ta,Tt1 =Tt2 fp .t ..; G (pat-cons) .0 fc[aT](p) .(Ta,Tt2, .; G t2)T .Tt1 =TClause \ntyping rule .; G fp .e : t1 .t2 . fp .t1 .(.';G')., .';G, G' fe : t2 .; G fp .e : t1 .t2 Clauses typing \nrule .; G fms : t1 .t2 .; G fpi .ei : t1 .t2 for i =1,...,n .; G f(p1 .e1 |\u00b7\u00b7\u00b7|pn .en): t1 .t2 Figure \n3: Pattern typing rules Expression typing rules .; G fe: t . |= t1 =t2 .; G fe: t1 (ty-eq) .; G fe: \nt2 G(xf )= t (ty-var) .; G fxf : t S(c)= .a.tT1 .t2 . fTt : T* .; G fe: t1[aT.Tt] (ty-cons) .; G fc[Tt](e): \nt2[aT.Tt] (ty-unit) .; G fo.: 1 .; G fe1 : t1 .; G fe2 : t2 (ty-tup) .; G foe1,e2.: t1 *t2 .; G fe: t1 \n*t2 (ty-fst) .; G ffst(e): t1 .; G fe: t1 *t2 (ty-snd) .; G fsnd(e): t2 .; G,x : t1 fe: t2 (ty-lam) .; \nG f.x: t1.e : t1 .t2 .; G fe1 : t1 .t2 .; G fe2 : t1 (ty-app) .; G fe1(e2): t2 .,a;G fe: t (ty-tlam) \n.; G f.a.e : .a.t .; G fe: .a.t . ft1 : * (ty-tapp) .; G fe[t1]: t[a.t1] .; G,f : t fe: t (ty-.x) .; \nG f.x f : t.e: t .; G fe1 : t1 .; G,x : t1 fe2 : t2 (ty-let) .; G flet x= e1 in e2 end : t2 .; G fe: \nt1 .; G fms: t1 .t2 (ty-case) .; G fcase eof ms: t2 Figure 4: Typing rules for expressions At this moment, \nthere is no need to be concerned with how type constraints can be solved; we may simply assume the existence \nof an oracle for doing this. In Section 3, we will present a complete procedure for solving type constraints. \n 2.2 G.R. Datatype Constructors We use *as the kind for types and (*,...,*) .*as the kind for type constructors \nof arity n,where n the number of the occurrences of *in (*,...,*). We use T for a recur\u00adsive type constructor \nof arity n and associate with T a list of (value) constructors c1,...,ck;for each 1 = i = k,the type \nof ci is of the form .aTi.ti .(Tti)T,where Tti is for a sequence of types t1i,...,tni i ,and .aTi stands \nfor a (possi\u00ad bly empty) sequence of quanti.ers .ai 1 ....ai (assuming mi aTi = a1i ,...,ai ). In our \nconcrete syntax, T can be de\u00ad mi clared as follows. typecon(type,...,type) T = {aT1}.(Tt1) c1 of t1 |{aT2}.(Tt2) \nc2 of t2 | ... |{aTk}.(Ttn) ck of tk We write ...t for a guarded type, where . is a type variable context \nthat may contain some type equalities. We use the name guard for such a type equality. For instance, \n..1.t is a guarded type, where .1 =(a1,a2,a1 *a2 =int *bool) and t = a1 *a1; thistype isequivalent to \nint *int since wemust map a1 to int in order to satisfy the type equality a1 *a2 =int *bool.The type \n..2.t is also a guarded type, where .2 =(a1,a2,a1 *a2 =int); this type is equivalent to the type void, \ni.e., the type in which there is no element, since the type equality a1 *a2 = int cannot be satis.ed. \nFor . = (a1,a2,a1 *a2 = a), we observe that the type constructor .a...t has the following interesting \nfeature: when applied to a type t0, the type constructor forms a type that is equivalent to t1 *t1 if \nt0 is of the form t1 *t2, or void otherwise. We showthat the type constructor T can be formally de.ned \nas \u00b5t.s,where s is the following sum of guarded types. Therefore, we call T a guarded recursive datatype \nconstructor. \u00b5t..Ta.(.{aT1,Tt1 =aT}.t1 + ...+ .{aTk,Ttk =aT}.tk) Note that for i =1,...,k, aT= a1,...,an \nand aTi are as\u00adsumed to share no common type variables, and the T s in Tti and ti have been replaced \nwith t s. Given a type variable context ., we de.ne |.|as follows. |\u00b7|= \u00b7|.,a|= |.|,a |.,t1 =t2|= |.| \nFor a type substitution T and a sequence of type variables aT= a1,...,an,wew riteT(aT)for T(a1),...,T(an). \nThe introduction and elimination rules for guarded types can be formed as follows. .1;G fe: t[T] .1 fT:.2 \n(.-intro) .1;G foT(|.2|) |e.: ..2.t .1;G fe1 : ..2.t1 .1,.2;G,x : t1 fe2 : t2 (.-elim) .1;G fopen e1 \nas o|.2||x.in e2 : t2 Note that a judgment of the form .1 fT: . means that dom(T) = dom(.2)and .1 |= \nt1[T] =t2[T] for each type equality t1 =t2 in .2. In the elimination rule, we require that t2 contain \nno type variable in dom(.2). +...+tk Given types t1,...,tk and 1 =i =k,weuse injti 1for the ith injection \nthat injects values of the type ti into val\u00adues of the type t1 +...+tk . In addition, we use unfold((Tt)T) \nfor the expansion of (Tt)T to s[t .T][aT.Tt], where Tt is a aTi; x : ti fx : ti aTi f[\u00dfTi .aTi]: \u00dfTi,Tti[aTi \n.\u00dfTi] =Tti (.-intro) aTi; x : ti foaTi |x.: .{\u00dfTi,Tti[aTi .\u00dfTi] =Tti}.ti[aTi .\u00dfTi] (+-intro) unfold((ti)T \n) aTi; x : ti finj(oaTi |x.): unfold((Tti)T ) i (fold) unfold((ti)T ) aTi; x : ti finj(oaTi |x.):(Tti)Ti \n(.-intro) unfold((ti)T ) aTi; \u00b7f.x : ti.inj(oaTi |x.): ti .(Tti)T i (.-intro) unfold((ti)T ) \u00b7; \u00b7f.aTi..x \n: ti.inj(oaTi |x.): .aTi.ti .(Tti)T i Figure 5: De.ning value constructors associated with T sequence \nof n types. Then we can construct a typing deriva\u00adtion in Figure 5, where all the applied rules are standard. \nBy the derivation, we can de.ne ci as follows for i =1,...,k: unfold((ti)T ) .aTi..x : ti.injoaTi |x. \ni Therefore, we have justi.ed the notion of g.r. datatype con\u00adstructors in terms of standard type-theoretical \nconcepts. We nowpresent some simple examples of g.r. datatype constructors so as to facilitate the understanding \nof this con\u00adcept. Example 1 The following syntax typecon TOP = Top of a declares a value constructor \nTop of the type .a.a .TOP; TOP is de.ned as \u00b5t..{a}.a, which is equivalent to .a.a. The type TOP is called \nan abstract datatype in [11]. In general, the the notion of abstract datatypes is subsumed by the notion \nof g.r. datatype constructors. Example 2 The following syntax typecon (type) list = ( a) nil | ( a) cons \nof a * a list declares two constructors nil and cons of the types .a.1 . (a)list and .a.a *(a)list .(a)list, \nrespectively; the type constructor list is de.ne as follows, which is essentially equiv\u00adalent to the \ntype constructor \u00b5t..a.1 + a *(a)t. \u00b5t..a..{a1,a1 =a}.1 + .{a2,a2 =a}.a2 *(a2)t Note that the usual list \ntype constructor in ML is de.ned as .a.\u00b5t.1 + a *t. In the rest of the paper, we are no longer in need \nof guarded types of the form ...t directly. The typing rules (.-intro) and (.-elim) are to be absorbed \ninto the typing rules (ty-cons) and (ty-case), respectively. Similarly, we we will make no use of expressions \nof the form oTt |e.or the form open e1 as oaT|x.in e2 directly.  2.3 Pattern Matching We use p for patterns. \nAs usual, a type (value) variable may occur at most once in each pattern. We use a judgment of the form \nv . p f (T; .)to mean thatmatching a value v against a pattern p yields substitutions T and . for the \ntype and value variables in p. The rules for deriving such judgments are listed as follows. v .x .([]; \n[x .v]) o..o..([]; []) v1 .p1 .(T1; .1) v2 .p2 .(T2; .2) ov1,v2..op1,p2..(T1 .T2; .1 ..2) v .p .(T; .) \nc[Tt ](v) .c[aT](p) .([aT.Tt ] .T; .) Given a type variable context .0, a pattern p and a type t , we \ncan use the rules in Figure 3 to derive a judgment of the form .0 fp .t .(.; G), whose meaning is formally \ncaptured by Lemma 2.3. 2.4 Static and Dynamic Semantics We present the typing rules for .2,G\u00b5 in Figure \n4. We assume the existence of a signature S in which the types of constructors are declared. Most of \nthe typing rules are standard. The rule (ty-eq) indicates that the type equality in .2,G\u00b5 is modulo type \ncon\u00adstraint solving. Please notice the great di.erence between the rules presented in Figure 3 for typing \nclauses and the standard ones in [14]. We form the dynamic semantics of .2,G\u00b5 through the use of evaluation \ncontexts, which are de.ned below. Evaluation context E ::= [] |fst(E) |snd(E) |oE, e.|ov, E.|E(e) |v(E) \n|E[t ] |let x = E in e end |case E of ms Definition 2.2. A redex is de.ned as follows. fst(ov1,v2.) \nis a redex that reduces to v1.  snd(ov1,v2.) is a redex that reduces to v2.  (.x : t.e)(v) is a redex \nthat reduces to e[x .v].  (.a.v)[t ] is a redex that reduces to v[a .t ].  let x = v in e end is a \nredex that reduces to e[x .v].  .xf : t.v is a redex that reduces to v[f ..xf : t.v].  case v of ms \nis a redex if v .p .(T; .) is derivable for some clause p . e in ms, and the redex reduces to e[T][.]. \nNote that there may be certain amount of nondeterminism in the reduction of case v of ms as v may match \nthe patterns in several clauses in ms.  Given a redex e1,we w rite e1 ..e2 if e1 reduces to e2.If e \n' = E[ei]for i =1, 2and e1 is a redex reducing to e2,then i '' '' wew rite e1 ..e2 and say that e1 reduces \nto e2 in one step. Let .. * be the re.exive and transitive closure of ...We say that e1 reduces to e2 \n(in many steps) if e1 .. * e2 holds. Givenaclosed well-typedexpression e in .2,G\u00b5,weuse |e|for the type \nerasure of e, that is, the expression obtained from erasing all types in e. We can then evaluate |e|in \na un\u00adtyped .-calculus extended with pattern matching. Clearly, e.. * e ' holds if and only if |e|evaluates \nto |e ' |.In other words, .2,G\u00b5 supports type-erasure semantics. 2.5 Type Soundness Given an expression \nvariable context G such that G(x)is aclosedtype for each x .dom(G), we write . :G if \u00b7; \u00b7f .(x): G(x) \nis derivable for each x . dom(.)= dom(G). In general, we write (T; .): (.; G) to mean that f T: . is \nderivable and . : G[T] holds. The following lemma essentially veri.es that the rules for deriving judgments \nof the form p .t .(.; G) are properly formed. Lemma 2.3. Assume that .0 fp .t .(.; G) is deriv\u00adable and \nT0 :.0 holds. If v is aclosedvalue of the type t [T0], that is, \u00b7; \u00b7fv : t [T0] is derivable, and we \nhave v . p .(T,.) for some T and .,then (T; .): (.[T0]; G[T0]) holds. Proof By structural induction on \na derivation of .0 fp . t .(.; G) As usual, we need the following substitution lemma to es\u00adtablish the \nsubject reduction theorem for .2,G\u00b5. Lemma 2.4. Assume that .; G f e : t is derivable. If f(T; .): (.; \nG) holds, then \u00b7; \u00b7fe[T][.]: t [T] is derivable. Proof By structural induction on a derivation of .; \nG fe : t . Theorem 2.5. (Subject Reduction) Assume that \u00b7; \u00b7fe : t is derivable. If e.. e ' holds, then \n\u00b7; \u00b7f e ' : t is also derivable. Proof Assume that e = E[e1]and e ' = E[e2]for some redex e1 that reduces \nto e2. The proof follows from structural in\u00adduction on E. In the case where E = [], the proof proceeds \nby induction on the height of a derivation of \u00b7; \u00b7fe : t ,han\u00addling various cases through the use of \nLemma 2.4. For han\u00addling the typing rule (ty-case), Lemma 2.3 is also needed. However, we cannot prove \nthat if e is a well-typed non\u00advalue expression then e must reduce to another well-typed expression. In \nthe case where e = E[e1]for some e1 = case v of ms that is not a redex (because v does not match any \npattern in ms), the evaluation of e becomes stuck. This is so far the only reason for the evaluation \nof an expression to become stuck. As is the case for the usual datatypes in ML, it can also be checked \nwhether pattern matching is exhaustive with respect to types of the form (Tt)T for g.r. datatype constructors \nT .  3. ELABORATION We have presented an explicitly typed language .2,G\u00b5. Since a programmer may be \nquickly overwhelmed with the need for writing types in such a setting, it becomes appar\u00adent that we need \nto provide an external language ML2,G\u00b5 together with an elaboration process from ML2,G\u00b5 to .2,G\u00b5 that \npreserves dynamic semantics. Some of the syntax for ML2,G\u00b5 is presented in Figure 6 and it should be \nstraightforward to relate the concrete syntax patterns p ::= x |o.|op1,p2.|c(p) clauses ms ::= (p1 .e1 \n|\u00b7\u00b7\u00b7|pn .en) expressions e ::= x |f |c | o.|oe1,e2.|fst(e) |snd(e) | .x.e |.x : t.e |e1(e2) | .x f.v \n|.x f : t.v | case e of ms | let x = e1 in e2 end |(e : t ) values v ::= x |c |o.|ov1,v2.| .x.e |.x \n: t.e Figure 6: Syntax for the external language ML2,G\u00b5 aTft : * T is not T ' aTft =t a, (T t2)T ' , \n. ft1 =t2 Tt1)T =(T T a, . ft1 =t2 T a, a =a, . ft1 =t2 t contains a free occurrence of a but is not \na T a, a =t, . ft1 =t2 t contains a free occurrence of a but is not a T a, t =a, . ft1 =t2 T a, .[a .t \n] ft1[a .t ] =t2[a .t ] a has no free occurrences in t T a, a =t, . ft1 =t2 T a, .[a .t ] ft1[a .t ] \n=t2[a .t ] a has no free occurrences in t T a, t =a, . ft1 =t2 a,TTt1 =Tt2 ft1 =t2 a,T(Tt1)T =(Tt2)T, \n. ft1 =t2 T1' [a1 .(aT)A] =t2' [a2 .(aT)A] ft1 =t2 a, t A is a fresh skolemized constant a,T.a1.t1 ' \n=.a2.t2 ' ft1 =t2 Figure 7: The rules for solving type constraints in the examples we present to that \nof ML2,G\u00b5.The types in ML2,G\u00b5 are the same as in .2,G\u00b5.The syntax for type ascription is (e : t ), which \nbasically means the expression e is required to be of the type t . Also, the types for bound variables \nin ML2,G\u00b5 may be omitted. Note that the language ML2,G\u00b5 is not a conservative extension of ML as there \nare strictly more programs that are typable in ML2,G\u00b5 than in ML. During the elaboration of a program, \ntype constraints of the form . f t1 =t2 are generated. We present a set of rules for solving such type \nconstraints in Figure 7, where weuse T to range over all type constructors, either built\u00adins (*and .), \nuser-de.ned g.r. datatype constructors, or skolemized constants (introduced by applying the last rule \nin Figure 7) Definition 3.1. Given a type t , the size [t ] of t is de\u00ad.ned as follows. [a]=1 [(t1,...,tn)T \n]=1+[t1]+ ... +[tn] Furthermore, given a type equality t1 =t2, its size is de.ned as [t1]+[t2]; given \na type variable context ., its size is the sum of the sizes of the type equalities in .. Note that for \neach rule in Figure 7 of the following form: . f t1 = t2 . ' f t1 ' = t ' , 2 wehave [.] < [. ' ]. This \nobservation is needed to justify the soundness and the completeness of the rules for solving type constraints. \nTheorem 3.2. . |= t1 = t2 holds if and only if . f t1 = t2 is derivable. Proof Assume that . Tfor some \n. ' that does not = a,. ' begin with a type variable. The proof follows from induction on the lexicographic \nordering (n1,n2,n3), where n1 is the number of free type variables in . ' , n2 is the number of occurrences \nof . in . ' and n3 is the size of . ' . Therefore, the rules in Figure 7 for solving type constraints \nare both sound and complete. The elaboration process for ML2,G\u00b5 is similar to the one for DML [25, 23], \nfollowing essentially the same strategy. Given .,Gand e, a synthesizing judgment .; G f e. t . e * means \nthat e can be elaborated into e * with type t such that .; G f e * : t is derivable and |e| and |e * \n| are opera\u00adtionally equivalent, where |e| and |e * | are the erasures of e and e * , respectively. Given \n.,G,e and t, a checking judg\u00adment .; G f e . t . e * means that e can be elaborated into e * such that \n.; G f e * : t is derivable and |e| and |e * |are operationally equivalent. We have formulated a list \nof rules for deriving both synthesizing and checking judgments. Please refer to [24] for these rules \nplus other details on the issue of elaboration in ML2,G\u00b5.  4. APPLICATIONS In this section, we showhowg.r. \ndatatype constructors can be used to handle some realistic and interesting exam\u00adples that involve a variety \nof programming features. We have .nished a prototype implementation that supports most of the main features \nin the core of ML (e.g., pattern matching, polymorphism, e.ects, etc.) plus g.r. datatype constructors. \nThe implementation, written in Objective Caml, is available at [24], where we have also presented many \nother examples in addition to the following ones, including an implementa\u00adtion of queue in message-passing \nstyle, an implementation of polymorphic marshaling as is described in [16], etc. 4.1 Polymorphic Generic \nFunctions The notion of polymorphic generic functions is introduced in [8], which allows the programmer \nto de.ne polymorphic functions that may behave di.erently on di.erent type ar\u00adguments. We use an example \nto showthat generic functions can be readily handled through the use of g.r. datatype constructors. In \nthe C programming language, sprintf is a function that takes a format string and a list of arguments, \nand then re\u00adturns a string representation of the arguments according to the format string. Let us declare \nthe type FORMAT as follows. typecon (type) FORMAT = (int -> a) I of a FORMAT | (char -> a) C of a FORMAT \n| ( a) S_ of string * a FORMAT | (string) S0 of string When applied to a format of the type (t1 . ... \n. tn . string)FORMAT,the sprintf function expects that the n fun sprintf fmt = let fun aux pre (I fmt) \n= (fn i => aux (pre ^ int2string i) fmt) | aux pre (C fmt) = (fn c => aux (pre ^ char2string c) fmt) \n| aux pre (S_ (s, fmt)) = aux (pre ^ s) fmt |aux pre (S0 s) =pre ^ s withtype string -> a FORMAT -> a \nin aux \"\" fmt end withtype a FORMAT -> a Figure 8: An implementation of the sprintf function arguments \nfollowing the format have the types t1,...,tn, respectively. We give an implementation of sprintf in \nFig\u00adure 8. We can make a format expression more readable by de.ning an in.x operator $ for application \nand currying S into S. infixr $ fun f$ x= f(x) fun Ss fmt =S_ (s, fmt) For instance, the following \nexpression binds fmt with a for\u00admat of the type (int . char . string)FORMAT. val fmt =S \"int i= \"$ I$ \nS \"and char c =\" $C $S0 \"\" As can be expected, sprintf(fmt) returns a function of the type int . char \n. string, which yields the following string \"int i=1 and char c= a\" when applied to the integer 1 and \nthe character a. Certainly, a functions like sprintf can also be implemented through the use of type \nclasses (or their variants). The above implementation of sprintf is actually adopted from [15]. In this \ncase, the format argument of the sprintf function is most likely to be provided by the user instead of \nbeing automatically synthesized and the very issue of overload\u00ading addressed by type classes does not \nreally seem to exist here. Therefore, we feel the above implementation of sprintf through g.r. datatype \nconstructors is more natural and di\u00adrect. 4.2 Implementing Staged Computation We outline an implementation \nof staged computation [7, 19] through the use of higher-order abstract syntax. We .rst associate a fewmore \nvalue constructors with the g.r. datatype constructor HOAS de.ned in Section 1. typecon (type) HOAS = \n... ... | { a}. ( a) HOASvar of string | { a}. ( a) HOASif of bool HOAS * a HOAS * a HOAS Obviously, \nHOASif is introduced for forming h.o.a.s trees to represent conditional expressions. In general, many \nmore language constructs can be readily handled by properly as\u00adsociating some value constructors with \nHOAS.The only (ad hoc and ugly) use of HOASvar is shown in Figure 9, where a translation from higher-order \nabstract syntax (h.o.a.s.) to .rst-order abstract syntax (f.o.a.s.) is given. For instance, the translation \nof HOASlam(fnx . x)) is simply FOASlam( x ,FOASvar( x )) typecon FOAS = FOASvar of string | { a}. FOASlift \nof a | FOAStup of FOAS * FOAS | FOASlam of string * FOAS | FOASapp of FOAS * FOAS | FOASfix of string \n* FOAS | FOASif of FOAS * FOAS * FOAS (* new_name() produces a fresh name *) val new_name: unit -> string \nfun h2f (HOASvar name) = FOASvar name | h2f (HOASlift v) = FOASlift v | h2f (HOAStup (e1,e2)) = FOAStup(h2f \ne1,h2f e2) | h2f (HOASlam f) = let val name = new_name () in FOASlam (name, h2f (f (HOASvar name))) end \n| h2f (HOASapp (e1,e2)) = FOASapp(h2f e1,h2f e2) | h2f (HOASfix f) = let val name = new_name () in FOASfix \n(name, h2f (f (HOASvar name))) end | h2f (HOASif (e1, e2, e3)) = FOASif (h2f e1, h2f e2, h2f e3) withtype \n{ a}. a HOAS -> FOAS Figure 9: A translation from h.o.a.s to f.o.a.s (assuming x is the freshly generated \nname for the bound variable x). Also, we assume a built-in function compile of the type .a.(a)HOAS . \na that compiles h.o.a.s. trees. For instance, compile can be implemented in such a manner: Given a h.o.a.s \ntree e,we translate e into a f.o.a.s tree h2f(e)and then compile the f.o.a.s. tree with a standard approach \n(as is done in Scheme). Note that the function compile corresponds to the function run in MetaML [19]. \nAs an example, we stage the usual power function as fol\u00adlows, where the bloated syntax is soon to be \nreplaced with some syntactic sugar. fun power1 n = if n = 0 then HOASlam (fn x => HOASlift 1) else HOASlam \n(fn (x: int HOAS) => HOASapp (HOASlift *, HOAStup (x, HOASapp (power1 (n-1), x)))) withtype int -> (int \n-> int) HOAS Then we can de.ne the square function as follows. val square1: int -> int = compile (power1 \n2) It can be readily veri.ed that the f.o.a.s. tree translated from (power1 2) represents the following \nprogram: (fn x2 => x2* (fn x1=> x1 *(fn x0 =>1) x1) x2) Now suppose we stage the power function as follows. \nfun power2 n x = if n = 0 then (HOASlift 1) else HOASapp ( HOASlift *, HOAStup (x, power2 (n-1) x)) withtype \nint -> (int) HOAS -> (int) HOAS (xf )= HOASlift(xf ) (c)= HOASlift(c) (o.)= HOASlift(o.) (oe1,e2.)= HOAStup( \n(e1), (e2)) (if(e1,e2,e2)) = HOASif( (e1), (e2), (e3)) (.x.e)= HOASlam(.x. (e[x . (x)])) (.x : t.e)= \nHOASlam(.x : ot .. (e[x . (x)])) (e1(e2)) = HOASapp( (e1), (e2)) (.x f.v)= HOAS.x(.f. (v[f . (f)])) (.x \nf : t.v)= HOAS.x(.f : ot .. (v[f . (f)])) (e : t )= ( (e): ot .) ( (e)) = e Figure 10: Syntactic sugar \nfor staged computation . Then the square function can be de.ne as: val square2: int -> int = compile(HOASlam(fn \n(x: int HOAS) => power2 2 x)) This time, the f.o.a.s. tree translated from the following h.o.a.s tree \nHOASlam (fn (x: int HOAS) => power2 2 x) is (fnx=> x *(x* 1)). In Figure 10, we introduce some syntactic \nsugar to facil\u00aditate staged computation. Note that we now write ot . for (t )HOAS. Essentially, (e) corresponds \nto oe. in the syn\u00adtax of MetaML, and (e) corresponds to (e). For instance, in our concrete syntax, the \ncode (fn (x: int) => x * x) expands into the following code, which has the type oint . int.. HOASlam \n(fn (x: <int>) => HOASapp (HOASlift *, HOAStup (x, x))) We reject code in which some syntactic sugar \ncannot be removed. For instance, ^x +1 is ill-formed since the symbol ^ can not be translated away. However, \n(^x+1) is well\u00adformed, which translates into: HOASapp(HOASlift +, HOAStup(x, HOASlift 1)) Therefore, \nill-formedness is context-sensitive. The above functions power1, square1, power2 and square2 cannow be \nwrittenasfollows. fun power1 n = ifn =0 then (fn x=> 1) else (fn x => x * ^(power1 (n-1)) x) withtype \nint -> <int -> int> val square1 = compile (fn x => ^(power1 2) x) fun power2 n x = if n = 0 then 1 else \n(^x * ^(power2 (n-1) x)) val square2 = compile (fn x => ^(power2 2 x)) Generally speaking, we expect \nthe following. Assume that e is an expression of type t in MetaML. Let e * be the ex\u00adpression obtained \nfrom replacing each o\u00b7. in e with (\u00b7)and each with and then translating away the syntactic sugar. Then \ne * should have the same type t (if we identify the type constructor o\u00b7. in MetaML with HOAS). Unfortunately, \nthe outlined implementation of staged com\u00adputation contains an annoying problem, which is often called \nopen code extrusion. For instance, the following program: (fn x: int HOAS => ^(compile (x))) translates \ninto the following h.o.a.s. tree t: HOASlam (fn x: (int HOAS) HOAS => compile (x)) Suppose we want to \ncompile t; then we need to turn t into a f.o.a.s tree by applying the function h2f to t; clearly, eval\u00aduating \nh2f(t)leads to a call of compile on HOASvar( x ) (assuming x is the freshly generated name for the bound \nvariable x); but this call leads to a run-time error as there is no way to compile a variable. It is \nof great di.culty to properly address the problem with open code extrusion. For an approach to implement\u00ading \nstaged computation that can prevent open code extru\u00adsion, please refer to [3], where a g.r. datatype \nconstructor is formed for representing typed code via deBruijn indices. In [7], a language Mini-MLe with \na type system based on the modal logic S4 is presented for studying staged com\u00adputation. There, the type \nconstructor is intended to capture the closedness of code. Since h.o.a.s. trees (with no use of HOASvar) \ncan only represent closed expressions, we naturally expect a relation between and HOAS.This is to be \nstudied in future.  4.3 Implementing Programming Objects We brie.y outline an approach to implementing \nobjects through the use of g.r. datatype constructors. When com\u00adpared with various existing approaches \nin the literature, this approach addresses many di.cult issues in objected\u00adoriented programming (e.g., \nparametric polymorphism, bi\u00adnary methods, the self type, etc.) in a purely type-theoretical manner, which \nwe feel is both natural and satisfactory. In the following presentation, we take a view of objects in \nthe spirit of Smalltalk [9, 13], suggesting to conceptualize an ob\u00adject as a little intelligent being \nthat is capable of performing actions according to the messages it receives. We assume the existence \nof a guarded recursive datatype constructor MSG that takes a type t and forms a message type (t )MSG. \n2 Also, we require that MSG be extensible (like the exception type in ML). After receiving a message \nof type (t )MSG, an object is expected to return a value of type t . Therefore, we assign an object the \nfollowing type OBJ : OBJ = .a.(a)MSG . a Suppose that we have declared through some syntax that MSGgetfst, \nMSGgetsnd , MSGsetfst and MSGsetsnd are mes\u00adsage constructors of the following types, where 1 stands \nfor the unit type. MSGgetfst :(int)MSG MSGgetsnd :(int)MSG MSGsetfst : int . (1)MSG MSGsetsnd : int . \n(1)MSG In Figure 11, we implement integer pairs in a message\u00adpassing style, where the withtype clause \nis a type annota\u00adtion that assigns the type int . int . OBJ to the de.ned function newIntPair. We point \nout it is solely for illustra\u00adtion purpose that we use the pre.x MSG in the name of each message constructor. \nGiven integers x and y,we can 2In the following presentation, when the arguments of a con\u00adstructor are \ntypes, we always write the arguments in front of the constructor. fun newIntPair x y = let valxref =ref \nxand yref = ref y fun dispatch MSGgetfst = !xref | dispatch MSGgetsnd = !yref | dispatch (MSGsetfst x \n) = (xref := x ) | dispatch (MSGsetsnd y ) = (yref := y ) | dispatch msg = raise UnknownMessage in dispatch \nend withtype int -> int -> OBJ Figure 11: An implementation of integer pairs form an integer pair anIntPair \nby calling newIntPair(x)(y); we can then send the message MSGgetfst to the pair to obtain its .rst component: \nanIntPair(MSGgetfst); we can also reset its .rst component to x ' by sending the message MSGsetfst(x \n' ) to the pair: anIntPair(MSGsetfst(x ' )); oper\u00adations on the second component of the pair can be performed \nsimilarly. Note that an exception is raised at run-time if anIntPair cannot interpret a message sent \nto it. Classes Obviously, there exist some serious problems with the above approach to implementing objects. \nSince every object is currently assigned the type OBJ, we cannot use types to di.erentiate objects. For \ninstance, suppose that MSGfoo is another declared message constructor of the type (1)MSG;then anIntPair(MSGfoo) \nis well-typed, but its ex\u00adecution leads to an uncaught exception UnknownMessage at run-time. This is \nclearly undesirable: anIntPair(MSGfoo) should be rejected at compile-time as an ill-typed expression. \nWe address this problem by providing the type constructor MSG with another parameter. Given a type t \nand a class C, (t )MSG(C) is a type; the intuition is that a message of the type (t )MSG(C) should only \nbe sent to objects in the class C, to which we assign the type OBJ(C) de.ned as follows: OBJ(C)= .a.(a)MSG(C) \n. a First and foremost, we emphasize that a class is not atype; it is really a tag used to di.erentiate \nmessages. For instance, wemay declareaclass IntPairClass and associate with it the following message \nconstructors of the corresponding types: MSGgetfst :(int)MSG(IntPairClass) MSGgetsnd :(int)MSG(IntPairClass) \nMSGsetfst : int . (1)MSG(IntPairClass) MSGsetsnd : int . (1)MSG(IntPairClass) The function newIntPair \ncannowbe giventhe type int . int . OBJ(IntPairClass); since anIntPair has the type OBJ(IntPairClass), \nanIntPair(MSGfoo) becomes ill-typed if MSGfoo hasa type(1)MSG(C) for some class C that is not IntPairClass. \nFollowing Dependent ML [25, 23], we use class as the sort for classes. Parameterized Classes There is \nan immediate need for class tags parameterizing over types. Suppose we are to gen\u00aderalize the monomorphic \nfunction newIntPair into a poly\u00admorphic function newPair, which can take arguments x and y of any types \nand then return an object representing the pair whose .rst and second components are x and y,respec\u00adtively. \nWe need a class constructor PairClass that takes two given types t1 and t2, to form a class (t1,t2)PairClass. \nWe may use some syntax to declare such a class construc\u00adtor and associate with it the following polymorphic \nmessage fun newPair x y = let val xref =ref x and yref =ref y fun dispatch MSGgetfst = !xref | dispatch \nMSGgetsnd = !yref | dispatch (MSGsetfst x ) = (xref := x ) | dispatch (MSGsetsnd y ) = (yref := y ) | \ndispatch msg = raise UnknownMessage in dispatch end withtype { a, b}. a -> b -> OBJ(( a, b)PairClass) \n fun newColoredPair c x y = let val cref = ref c and xref =ref x and yref =ref y fun dispatch MSGgetcolor \n= !cref | dispatch (MSGsetcolor c ) = (cref := c ) | dispatch MSGgetfst = !xref | dispatch MSGgetsnd \n= !yref | dispatch (MSGsetfst x ) = (xref := x ) | dispatch (MSGsetsnd y ) = (yref := y ) | dispatch \nmsg = raise UnknownMessage in dispatch end withtype { a, b} color -> a -> b -> OBJ (( a, b)ColoredPairClass) \nFigure 12: Functions for constructing objects in the classes PairClass and ColoredPairClass constructors: \nMSGgetfst : .a..\u00df.(a)MSG((a, \u00df)PairClass) MSGgetsnd : .a..\u00df.(\u00df)MSG((a, \u00df)PairClass) MSGsetfst : .a..\u00df.a \n. (1)MSG((a, \u00df)PairClass) MSGsetsnd : .a..\u00df.\u00df . (1)MSG((a, \u00df)PairClass) The function newPair for constructing \npair objects is im\u00adplemented in Figure 12. Subclasses Inheritance is a major issue in object-oriented \nprogramming as it can signi.cantly facilitate code organiza\u00adtion and reuse. We approach the issue of \ninheritance by introducing a predicate = on the sort class;given two classes C1 and C2,wew rite C1 = \nC2 to mean that C1 is a subclass of C2. The type of a message constructor mc is nowof the general form \n.T a..a . C.(t )MSG(a)or .a.T.a . C.t1 . (t2)MSG(a), where a . C means that a is of the subset sort {a \n: class | a = C}, i.e., the sort for all subclasses of the class C; for a sequence of types Tt that is \nof the same length as aT, mc[Tt ] becomes a mes\u00adsage constructor that is polymorphic on all subclasses \nof C0 = C[aT. Tt ]; therefore, mc canbe usedto construct a message for any object tagged by a subclass \nof C0.For in\u00adstance, the types of the message constructors associated with PairClass are nowlisted in \nFigure 13. Suppose we introduce another class constructor ColoredPairClass,which takes tw o types to \nform a class, and assume the following holds, i.e., (t1,t2)ColoredPairClass is a subclass of (t1,t2)PairClass \nfor any types t1 and t2: .a.\u00df.(a, \u00df)ColoredPairClass = (a, \u00df)PairClass We then associate with ColoredPairClass \nthe message con\u00adstructors MSGgetcolor and MSGsetcolor,whose types are given in Figure 13. Note that color \nis just some already de.ned type for colors. We can then implement the function newColoredPair in Figure \n12 for constructing colored pairs. Clearly, the im\u00adplementation of newColoredPair shares a lot of common \ncode with that of newPair. We plan to provide some syn\u00adtactic support for the programmer to e.ectively \nreuse the code in the implementation of newPair when implementing newColoredPair . Binary Methods Our \napproach to typed object-oriented programming o.ers a clean solution to handling binary meth\u00adods. For \ninstance, we can declare a class EqClass and asso\u00adciate with it two message constructors MSGeq and MSGneq \nwhich are assigned the following types: MSGeq :.a . EqClass.OBJ(a) . (bool)MSG(a) MSGneq :.a . EqClass.OBJ(a) \n. (bool)MSG(a) Suppose self is an object of type OBJ(C)for some C = Eq. If we pass a message MSGeq(other)to \nself , other is required to have the type OBJ(C)in order for self (MSGeq(other )) to be well-typed. Therefore, \nself and other must be two objects belonging to the same class. The Self Type Our approach also o.ers \na clean solution to handling the notion of self type, namely, the type for the receiver of a message. \nSuppose we want to support a message MSGcopy that can be sent to any object to obtain a copy of the object.3 \nWe may assume MSGcopy is a message constructor associated with some class ObjClass and C = ObjClass holds \nfor any class C. We can assign MSGcopy the following type to indicate that the returned object is in \nthe same class as the object to which the message is sent, since self (MSGcopy)has thetype OBJ(C) whenever \nself is an object of type OBJ(C) for some class C. MSGcopy :.a . ObjClass.(OBJ(a))MSG(a) If this is done \nin Java, all we can state in the type system of Java is that an object is to return another object after \nreceiving the message MSGcopy. This isimprecise and isa rich source for the use of type downcasting. \nInheritance Inheritance is handled in a Smalltalk-like manner, but there is some signi.cant di.erence. \nFor those who are familiar with exceptions in Standard ML, we point out that the way that method lookup \nis implemented re\u00adsembles howexceptions are handled by exception handlers. We nowuse a concrete example \nto illustrate howinheritance can be implemented. This is also a proper place for us to introduce some \nsyntax that is designed to facilitate OOP. We use the following syntax: class ObjClass { MSGcopy: selfType \n=> self; } to declare a class tag ObjClass and a message constructor MSGcopy of the type: .a . ObjClass.(OBJ(a))MSG(a) \nNote selfType is merely syntactic sugar here. In addition, the syntax also automatically induces the \nde.nition of a function superObj, which is written as follows in ML-like syntax. (* self is just an ordinary \nvariable *) fun superObj self = let fun dispatch MSGcopy = self | dispatch msg = raise UnknownMessage \nin dispatch end withtype {a <: ObjClass} OBJ(a) -> OBJ(a) 3It is up to the actual implementation as to \nhowsuch a copy can be constructed. MSGgetfst : .a..\u00df..a . (a, \u00df)P airClass.(a)MSG(a) MSGgetsnd : .a..\u00df..a \n. (a, \u00df)P airClass.(\u00df)MSG(a) MSGsetfst : .a..\u00df..a . (a, \u00df)P airClass.a . (1)MSG(a) MSGsetsnd : .a..\u00df..a \n. (a, \u00df)P airClass.\u00df . (1)MSG(a) MSGgetcolor : .a.\u00df..a . (a, \u00df)ColoredPairClass.(color )MSGgetcolor (a) \nMSGsetcolor : .a.\u00df..a . (a, \u00df)ColoredPairClass.color . (1)MSGsetcolor (a) Figure 13: Some message constructors \nand their types The function superObj we present here is solely for explain\u00ading howinheritance can be \nimplemented; such a function is not to occur in a source program. The type of the func\u00adtion .a . ObjClass.OBJ(a) \n. OBJ(a) indicates this is a function that takes an object tagged by a subclass C of ObjClass and returns \nan object tagged by the same class. In general, for each class C, a super function of the type .a . C.OBJ(a) \n. OBJ(a) is associated with C. It should soon be clear that such a function holds the key to imple\u00admenting \ninheritance. Nowwe use the following syntax to declare classes Int1Class and ColoredInt1Class as well \nas some message constructors associated with them. class Int1Class inherits ObjClass { MSGget_x: int; \nMSGset_x (int): unit; MSGdouble: unit => self(MSGset_x(2 * self(MSGget_x)); } class ColoredInt1Class \ninherits Int1Class { (* color is just some already defined type *) MSGget_c: color; MSGset_c (color): \nunit; } The super functions associated with the classes Int1Class and ColoredInt1Class are automatically \ninduced as follows. fun superInt1 self = let fun dispatch MSGdouble = self(MSGset_x(2 * self(MSGget_x))) \n| dispatch msg = superObj self msg in dispatch end withtype {a <: Int1Class} OBJ(a) -> OBJ(a) fun superColoredInt1 \nself = let fun dispatch msg = superInt1 self msg in dispatch end withtype {a <: ColoredInt1Class} OBJ(a) \n-> OBJ(a) The functions for constructing objects in the classes Int1Class and ColoredInt1Class are implemented \nin Figure 14. There is something really interesting here. Suppose we use newInt1 and newColoredInt1 to \nconstruct objects o1 and o2 that are tagged with Int1Class and ColoredInt1Class, respectively. If we \nsend the message MSGcopy to o1,then a copy of o1 (not o1 itself) is returned. If we send MSGdouble to \no2, then the integer value of o2 is doubled as it inherits the corresponding method from the class Int1Class.What \nis remarkable is that the object o2 itself is returned if we send the message MSGcopy to o2. The reason \nis that no copying method is de.ned for o2; searching for a copying method, o2 eventually .nds the one \nde.ned in the class ObjClass (as there is no such a method de.ned in either the class ColoredInt1Class \nor the class Int1Class). This is a desir\u00adable consequence: if o2 were treated as an object in the class \nInt1Class, the returned object would be in the class fun newInt1 (x0: int) = let valx =ref x0 fun dispatch \nMSGget_x = !x | dispatch (MSGset_x x ) = (x := x ) | dispatch MSGcopy = newInt1 (!x) | dispatch msg = \nsuperInt1 dispatch msg in dispatch end withtype int -> OBJ(Int1Class) fun newColoredInt1 (c0: color, \nx0: int) = let valc =ref c0 and x= ref x0 fun dispatch MSGget_c = !c | dispatch (MSGset_c c ) = (c := \nc ) | dispatch MSGget_x = !x | dispatch (MSGset_x x ) = (x := x ) | dispatch msg = superColoredInt1 dispatch \nmsg in dispatch end withtype int -> OBJ(ColoredInt1Class) Figure 14: Functions for constructing objects \nin Int1Class and ColoredInt1Class Int1Class, not in the class ColoredInt1Class,as it would be generated \nby newInt1 (o2(MSGget x)), making the type system unsound. We are currently not aware of any other approach \nto correctly typing this simple example. Note that the function newInt becomes ill-typed if we employ \nthe no\u00adtion MyType here. Subtypes There is not an explicit subtyping relation in our approach. Instead, \nwe can use existentially quanti.ed dependent types to simulate subtyping. For instance, given aclass \ntagC, the type OBJECT(C)=Sa . C.OBJ(a)is the sum of all types OBJ(a) satisfying a = C.Hence, for each \nC1 = C, OBJ(C1) can be regarded as a subtype of OBJECT(C) as each value of the type OBJ(C1)can be co\u00aderced \ninto a value of the type OBJECT(C). As an example, the type OBJ((OBJECT(Int1Class), OBJECT(Int1Class))PairClass) \nis for pair objects whose both components are objects in some subclasses of Int1Class.  5. RELATED \nWORK AND CONCLUSION Our work is related to both intentional polymorphism and type classes. There have \nalready been a rich body of studies in the literature on passing types at run-time in a type-safe man\u00adner \n[6, 5, 21]. Many of such studies followthe framework in [10], which essentially provides a construct \ntypecase at term level to perform type analysis and a primitive recursor Typerec over type names at type \nlevel to de.ne newtype constructors. However, in the presence of Typerec,it be\u00adcomes rather di.cult to \nde.ne a proper equality on types. For instance, the type equality de.ned in [10] is not closed under \nsubstitution. The language .MLi in [10] is subsequently extended to .R in [6] to support type-erasure \nsemantics. The type con\u00adstructor R in .R can be seen as a special g.r. datatype constructor. The system \nof type classes in Haskell provides a pro\u00adgramming methodology that is of great use in practice. A common \napproach to implementing type classes is through dictionary-passing, where a dictionary is essentially \na record of the member functions for a particular instance of a type class [1]. We encountered the notion \nof g.r. datatype con\u00adstructors when seeking an alternative implementation of type classes through intensional \npolymorphism. An approach to implementing type classes through the use of g.r. datatype constructors \ncan be found at [24]. The dependent datatypes in DML [25, 23] also shed some light on g.r. datatype constructors. \nFor instance, we can have the following dependent datatype declaration in DML. datatype a list with nat \n= nil(0) | {n:nat} cons(n+1) of a * a list(n) The syntax introduces a type constructor list that takes \na type and a type index of sort nat to form a list type. The constructors nil and cons are assigned the \nfollowing types. nil : .a.(a)list(0) cons : .a.a * (a)list(n) . (a)list(n +1) Given a type t and natural \nnumber n,the type (t )list(n)is for lists with length n in which each element has the type t . Formally, \nthe type constructor list can be de.ned as follows: '' ' .a.\u00b5t..a : nat..{0= a}.1 + .{a : nat,a +1= a}.a \n* t(a ) Clearly, this is also a form of guarded datatype constructor, where the guards are constraints \non type index expressions (rather than on types). Although we initially met the notion of g.r. datatype \nconstructors during a study on run-time type-passing, we have since found a variety applications of this \nnotion be\u00adyond type-passing (e.g., implementing staged computation and implementing programming objects). \nCurrently, we are particularly interested in implementing a CLOS-like object system on the top of DML \nextended with g.r. datatype con\u00adstructors, facilitating object-oriented programming styles in a typed \nfunctional programming setting. 6. REFERENCES [1] L. Augustsson. Implementing Haskelloverloading. In \nFunctional Programming Languages and Computer Architecture,93. [2] K.B.Bruce.Foundations of Object-Oriented \nLanguages. The MIT Press, Cambridge, MA, 2002. [3] C. Chen and H. Xi. Implementing typed meta-programming. \nAvailable at http://www.cs.bu.edu/~hwxi/academic/papers/TMP.ps, November 2002. [4] A. Church. A formulation \nof the simple type theory of types. Journal of Symbolic Logic, 5:56 68, 1940. [5] K. Crary and S. Weirich. \nFlexible Type Analysis. In Proceedings of International Conference on Functional Programming (ICFP 99), \nParis, France, 1999. [6] K. Crary, S. Weirich, and G. Morrisett. Intensional polymorphism in type-erasure \nsemantics. In Proceedings of the International Conference on Functional Programming (ICFP 98), pages \n301 312, Baltimore, MD, September 1998. [7] R. Davies and F. Pfenning. A Modal Analysis of Staged Computation. \nJournal of ACM, 2002. [8] C. Dubois, F. Rouaix, and P. Weis. Generic Polymorphism. In Proceeding of \nthe 22th ACM Symposium on Principles of Programming Languages (POPL 95), pages 118 129, London, UK, January \n1995. [9] A. Goldenberg and D. Robson. Smalltalk-80: The Language and Its Implementation. Addison Wesley, \n1983. [10] R. W. Harper and G. Morrisett. Compiling polymorphism using intensional type analysis. In \nConference Record of POPL 95: 22nd ACM SIGPLAN Symposium on Principles of Programming Languages, pages \n130 141, San Francisco, 1995. [11] K. L\u00a8aufer and M. Odersky. Ploymorphic Type Inference and Abstract \nData Types. ACM Transactions of Programming Languages and Systems (TOPLAS), 16(5):1411 1430, September \n1994. [12] X. Leroy. Unboxed objects and polymorphic typing. In Conference Record of the Nineteenth Annual \nACM SIGPLAN Symposium on Principles of Programming Languages, pages 177 188, Albuquerque, New Mexico, \nJanuary 1992. [13] C. Liu.Smalltalk, Objects, and Design. Manning Publications Co., Greenwich, CT 06830, \n1996. [14] R. Milner, M. Tofte, R. W. Harper, and D. MacQueen. The De.nition ofStandardML(Revised). MIT \nPress, Cambridge, Massachusetts, 1997. [15] M. Neubauer, P. Thiemann, M. Gasbichler, and M. Sperber. \nA Functional Notation for Functional Dependencies. In Proceedings of 2001 Haskell Workshop, pages 101 \n120, Florence, Italy, September 2001. [16] A. Ohori and K. Kato. Semantics for communication primitives \nin a polymorphic language. In Conference Record of the Twentieth Annual ACM SIGPLAN Symposium on Principles \nof Programming Languages, pages 99 112, Charleston, SC, January 1993. [17] S. Peyton Jones et al. Haskell \n98 A non-strict, purely functional language. Available at http://www.haskell.org/onlinereport/, Feb. \n1999. [18] F. Pfenning.Computation and Deduction. Cambridge University Press, 2002. [19] W. Taha and \nT. Sheard. MetaML and multi-stage programming with explicit annotations. Theoretical Computer Science, \n248(1-2):211 242, 2000. [20] A. Tolmach. Tag-free garbage collection using explicit type parameters. \nIn Proceedings of ACM Conference on LISP and Functional Programming, pages 1 11, Orlando, FL, June 1994. \n[21] V. Trifonov, B. Saha, and Z. Shao. Fully Re.exive Intensional Type Analysis. In Proceedings of the \nInternational Conference on Functional Programming, September 1999. [22] S. Weirich. Encoding intensional \ntype analysis. In D. Sands, editor, Programming Languages and Systems: 10th European Symposium on Programming, \nESOP 2001 Held as Part of the Joint European Conferences on Theory and Practice of Software, ETAPS 2001 \nGenova, Italy, April 2-6, 2001, volume 2028 of Lecture Notes in Computer Science, pages 92 106. Springer, \n2001. [23] H. Xi. Dependent Types in Practical Programming.PhD thesis, Carnegie Mellon University, 1998. \npp. viii+189. Available as http://www.cs.cmu.edu/~hwxi/DML/thesis.ps. [24] H. Xi, C. Chen, and G. Chen. \nGuarded Recursive Datatype Constructors, 2002. Available at http://www.cs.bu.edu/~hwxi/GRecTypecon/. \n[25] H.Xi andF.Pfenning.Dependenttypesinpractical programming. In Proceedings of ACM SIGPLAN Symposium \non Principles of Programming Languages, pages 214 227, San Antonio, Texas, January 1999.  \n\t\t\t", "proc_id": "604131", "abstract": "We introduce a notion of guarded recursive (g.r.) datatype constructors, generalizing the notion of recursive datatypes in functional programming languages such as ML and Haskell. We address both theoretical and practical issues resulted from this generalization. On one hand, we design a type system to formalize the notion of g.r. datatype constructors and then prove the soundness of the type system. On the other hand, we present some significant applications (e.g., implementing objects, implementing staged computation, etc.) of g.r. datatype constructors, arguing that g.r. datatype constructors can have far-reaching consequences in programming. The main contribution of the paper lies in the recognition and then the formalization of a programming notion that is of both theoretical interest and practical use.", "authors": [{"name": "Hongwei Xi", "author_profile_id": "81100625632", "affiliation": "Boston University", "person_id": "PP39051360", "email_address": "", "orcid_id": ""}, {"name": "Chiyan Chen", "author_profile_id": "81100119914", "affiliation": "Boston University", "person_id": "P414181", "email_address": "", "orcid_id": ""}, {"name": "Gang Chen", "author_profile_id": "81100110827", "affiliation": "Boston University", "person_id": "PP15022403", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/604131.604150", "year": "2003", "article_id": "604150", "conference": "POPL", "title": "Guarded recursive datatype constructors", "url": "http://dl.acm.org/citation.cfm?id=604150"}