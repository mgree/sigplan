{"article_publication_date": "01-15-2003", "fulltext": "\n New Results on the Computability and Complexity of Points to Analysis Venkatesan T. Chakaravarthy \nComputer Sciences Department University of Wisconsin Madison 1210, West Dayton Street, Madison, WI 53706, \nUSA. venkat@cs.wisc.edu ABSTRACT Given a program and two variables p and q, the goal of points-to analysis \nis to check if p can point to q in some ex\u00adecution of the program. This well-studied problem plays a \ncrucial role in compiler optimization. The problem is known to be undecidable when dynamic memory is \nallowed. But the result is known only when variables are allowed to be structures. We extend the result \nto show that, the problem remains undecidable, even when only scalar variables are al\u00adlowed. Our second \nresult deals with a version of points-to analysis called .ow-insensitive analysis, where one ignores \nthe control .ow of the program and assumes that the state\u00adments can be executed in any order. The problem \nis known to be NP-Hard, even when dynamic memory is not allowed and variables are scalar. We show that \nwhen the variables are further restricted to have well-de.ned data types, the problem is in P. The corresponding \n.ow-sensitive version, even with further restrictions, is known to be PSPACE-Complete. Thus, our result \ngives some theoretical evidence that .ow-insensitive analysis is easier than .ow-sensitive analysis. \nMoreover, while most variations of the points-to analysis are known to be computationally hard, our result \ngives a rare instance of a non-trivial points-to problem solv\u00adable in polynomial time.  Categories and \nSubject Descriptors D.3.4 [Programming Languages]: Processors compil\u00aders,optimization General Terms \nLanguages, Theory  Keywords Pointer analysis, .ow-sensitive, .ow-insensitive, complexity, undecidability \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n03, January 15 17, 2003, New Orleans, Louisiana, USA. Copyright 2003 ACM 1-58113-628-5/03/0001 ...$5.00. \n1. INTRODUCTION Modern compilers use static analysis to optimize and speed\u00adup programs. The analysis \ngets complicated for languages that support pointers (such as C). In order to analyze a pro\u00adgram that \ninvolves pointers, it is necessary to know what each variable may point to at a given program statement. \nFor example, consider the following segment of a program. 1. x=3; 2. *p =5;  3. y =4*x; If we know \nthat p can never point to x at statement (2), we can optimize the program by changing statement (3) to \nbe y=12 . This may lead to further optimization possibil\u00adities. Thus points-to analysis is useful in \nstatic analysis and optimization of programs. Two types of points-to analysis are prevalent: .ow-sensitive \nand .ow-insensitive.This pa\u00adper deals with the theoretical aspects of both versions of the problem. In \nthe .ow-sensitive points-to analysis problem, we are given the control .ow graph of a program, a pair \nof vari\u00adables p and q and a location in the program. The goal is to check if there is some path in the \ncontrol .ow graph such that executing the statements along the path makes p point to q at the given program \nlocation. We will discuss the se\u00admantics of the programming language in Section 3. Brie.y, the program \nis allowed to use the usual assignment state\u00adments, branching statements and loops. As is traditionally \ndone, we make the conservative assumption that all paths in the program are executable. Thus, we ignore \nthe conditions in the branching statements. The points-to problem has been well studied, in terms of \nboth theory and practice. The theoretical results have dealt with the complexity of the problem, whereas \napproximation algorithms have been proposed in practice. Throughout the following discussion, we assume \nthat the input program is made of a single procedure (with no proce\u00addure calls). Even with such a restriction, \nvarious versions of the problem are known to be undecidable or computation\u00adally hard. Thus the assumption, \nin fact, gives us stronger hardness results. Our .rst result deals with classifying various special cases \nof the .ow-sensitive analysis. The special cases are obtained by placing restrictions on the input program. \nFirstly, we can either allow or disallow the program to use dynamic memory. Secondly, we can either restrict \nthe program to use only scalar variables (e.g. int, int*, int** etc.) or allow non\u00adscalar variables (i.e. \narrays and structures) as well. Landi [7] and Ramalingam [10] proved the following result. Theorem 1. \n([7, 10]) Single procedural .ow-sensitive points\u00adto analysis with dynamic memory and non-scalar variables \nis undecidable. Our .rst result improves the above undecidability result to Theorem 2. Single procedural \n.ow-sensitive points-to analysis with dynamic memory is undecidable, even when only scalar variables \nare allowed. The new result gains some interest when we interpret it with the known results for the other \ncase where dynamic memory is not allowed. In this case, the problem is decid\u00adable, as the con.guration \nspace of pointers becomes .nite. But, Landi [6] and Muth and Debray [9] proved a very strong PSPACE-Hardness \nresult for this case. To state their result, let us restrict the problem further. First, we assume that \nthe variables are scalars. Next, we assume that the variables have well-de.ned data types and that the \nprograms conform to typing rules. For example, a pointer of type int ** can only point to a variable \nof type int*. Furthermore, we re\u00adstrict that the number of levels of dereferences in the types is just \n2. For example, the variables can only be of type int, int* or int **. Now we are ready to state the \nPSPACE-Hardness result: Theorem 3. ([6],[9]) 1 Single procedure .ow-sensitive points-to analysis is PSPACE-Complete, \neven when all vari\u00adables are scalars with well de.ned types and only two levels of dereferencing in the \ntypes are allowed. The only possible further restrictions are either to allow only one level of dereferencing \nor to disallow the use of point\u00aders! As the second case does not allow use of any pointers, we ignore \nit! The .rst case is known to be solvable in poly\u00adnomial time [6]. Theorem 3 combined with Theorem 1 \ngives us a very good understanding of the theory of .ow-sensitive analysis. The only case left open is \nto allow dynamic memory, but restrict variables to be scalars. Theorem 2 shows that this case is also \nundecidable. We can now summarize the results as Figure 1. Points-to Analysis (Undecidable) With well \ndefined types Without well defined types (PSPACE-Complete) Levels >= 2 Levels < 2 (PSPACE-Complete) \n(Is in P) Figure 1: Flow sensitive points-to analysis -a clas\u00adsi.cation Our second result deals with \n.ow-insensitive analysis. In this type of analysis, we ignore the control .ow of the pro\u00adgram and assume \nthat the statements can be executed in any order (with possible repetition). Thus .ow-insensitive 1The \nabove result was proved for four levels in [6] and was improved to two levels in [9]. analysis is a special \ncase of .ow-sensitive analysis, where the input control .ow graph is a complete graph. As .ow-sensitive \nanalysis is hard, there have been at\u00adtempts to do .ow-insensitive analysis. Many algorithms for approximate \n.ow-insensitive analysis have been proposed [1, 2, 3, 11, 12, 13]. These algorithms compute a safe solution \nto the problem: given the input program and a pair of point\u00aders (p, q), if there is an execution that \nmakes p point to q, the algorithm would de.nitely accept the pair. But, the al\u00adgorithm may accept the \npair (p, q), even though there may not be any execution that makes p point to q.Thus, the algorithm compute \nan approximate solution (with one sided error). In this paper, we focus on the complexity of com\u00adputing \nthe exact solution to the problem. One important result in this context is the following. Theorem 4. \n(Horwitz [5]) Even when dynamic memory is not allowed and variables are scalar, .ow-insensitive anal\u00adysis \nis NP-Hard, provided arbitrary number of dereferences is allowed in pointer expressions 2 Except for \nthis result, unfortunately, not much is known about the computability and complexity of the problem. \nSeveral questions remain open: Is the above problem in NP? Is the problem decidable, if we allow dynamic \nmemory? Can the problem be solved in polynomial time, if we bound the number of dereferences allowed \nin pointer expression? A positive answer to the last question will have practical im\u00adplications, because \nin real world programs, a pointer expres\u00adsion like ***... *p uses only a limited number of derefer\u00adences. \nThus, unlike the .ow sensitive case, the complexity of .ow-insensitive case is less understood. In this \nscenario, our second result aims to shed some light on the complex\u00adity of .ow-insensitive analysis. We \nshow that the problem stated in Theorem 4 can be solved in polynomial time, if we add the restriction \nthat the variables have well-de.ned data types. Theorem 5. When dynamic memory is not allowed and the \nvariables are scalars with well de.ned types, the .ow insensitive analysis can be solved in polynomial \ntime, even when arbitrary number of dereferences are allowed in an ex\u00adpression. The above theorem is \ninteresting for a few reasons. First of all, from our discussion so far, we can see that there are only \nnegative results on points-to analysis problems. The theorem shows that there is a somewhat-natural, \nnon\u00adtrivial points-to problem solvable in polynomial time. Sec\u00adondly, though .ow-insensitive analysis \n(being a special case) seems to be easier than .ow-sensitive analysis, there is lit\u00adtle theoretical evidence \nfor this thesis. The new result, when compared with Theorem 3, gives us a version of the problem where \n.ow-insensitive analysis is easier than .ow\u00adsensitive analysis. When the variables have well-de.ned types, \n.ow-insensitive analysis can be solved in polynomial time (for arbitrary levels of dereferences in types), \nwhereas .ow-sensitive analysis is PSPACE-Complete (even for just 2The issue of number of dereferences \nin an expression did not arise in the context of .ow-sensitive analysis, because there, using temporary \nvariables, we can break an expression into a sequence of statements that use one level of dereferencing. \nBut in .ow insensitive analysis, breaking statements may not preserve the solution. two levels). Finally, \nideas used in the proof of the theorem may be useful in solving the open questions. The rest of the paper \nis organized as follows. In Sec\u00ad tion 2, we prove Theorem 5 that deals with .ow-insensitive analysis. \nIn Section 3, we prove Theorem 2 that deals with     db  ac  .ow-sensitive analysis. We state \na few open problems and conclusions in Section 4. Figure 2: Realizability graph of Example 1  2. FLOW-INSENSITIVE \nANALYSIS WITH WELL DEFINED TYPES In this section, we give a polynomial time algorithm for the .ow-insensitive \nanalysis with well-de.ned types and thereby prove Theorem 5. We .rst consider the problem without well-de.ned \ntypes and brie.y discuss the di.culties in solving it (Section 2.1). There, we also develop some notation \nused throughout the paper. Then, we discuss how these di.culties can be handled when the input program \nhas well-de.ned types and present a high level overview of the algorithm (Section 2.2). We then solve \ntwo subproblems in Sections 2.3 and 2.4 that are used in our algorithm. Finally, we present our algorithm \nin Section 2.5. Throughout the discussion, we use notations from the C language. 2.1 Flow-Insensitive \nAnalysis Without Types In this problem, we are given a set of pointers (or vari\u00adables) {p1,p2,... ,pn}, \na set of statements S and a pair of pointers p and q. A statement can be of two types: (i) ***... *pi \n=&#38;pj or (ii) ***... *pi = ***... *pj,for some variables pi and pj. Given the set of pointers, the \nset of statements and two pointers p and q, the goal is to check if there is a .nite sequence s = s1,s2,... \n,sr of the input statements from S, such that at the end of executing these statements (in order) p points \nto q. We then say that the sequence s makes p point to q. In such a sequence, a single statement can \nbe used any number of times. We assume the usual semantics of using pointers. In the beginning of any \nexecution all the variables point to a special NULL value. We do not consider sequences that dereference \nthe NULL value any time during their execution. That is, by de.ni\u00adtion, such a sequence cannot make p \npoint to q. As stated in Theorem 4, the above problem is known to be NP-Hard. Here, we discuss the problem \nand some known approximation algorithms. Our aim is to highlight the dif\u00ad.culties involved in solving \nthe problem. Later, we shall see how these di.culties can be overcome if add the typing restrictions \nto the problem. We .rst develop some notation. Notation: We denote the expression ***... *x,with i stars, \nas *i x. If a sequence of input statements from S makes x point to y then we say that the sequence realizes \nthe pair (x, y). If some such sequence exists, we say that the pair (x, y) is realizable. Observe that, \nthe goal of the problem is to check if the input pair (p, q) is realizable. We say that a set {(x1,y1), \n(x2,y2),... , (xk,yk)} is realizable, if there is a sequence of input statements from S that makes each \nxi point to yi (simultaneously). As a special case, if a set of pointers {(x1,x2), (x2,x3), (x3,x4)... \n, (xk-1,xk)} is realizable, we say that the chain x1 .x2 .\u00b7\u00b7\u00b7.xk is realizable. Though we are mainly \ninterested in the realizability of the input pair, (p, q), it is useful to consider the set of allrealizable \npairs. For the given set of input statements S,we denote its solution as .(S)= {(x, y)| the pair (x, \ny) is realizable.} It is often convenient to view the solution as a directed graph: the pointers form \nthe vertices of the graph and .(S) serves as the edge set. In other words, (x, y) will be an edge in \nthe graph i. the pair (x, y)is realizable. We call the graph the realizability graph of the set of input \nstatements S. Example 1 Consider a set of pointers P = {a, b, c, d} and the set of statements S = {a \n=&#38;c, c =&#38;b, b =&#38;a, b = a, *b = c, d = *a} It is easy to see that (a, c), (c, b) and (b, a) \nare realizable. The sequence a =&#38;c, b = a realizes the pair (b, c).The sequence c =&#38;b, b =&#38;a, \n*b = c realizes the pair (a, b).The following sequence would realize the pair (d, a): c =&#38;b, b =&#38;a, \n*b = c, b =&#38;a, d = *a One can construct sequences that realize the pairs (d, b)and (b, b). One can \nargue that no other pair is realizable. In particular, note that the pair (d, c) is not realizable. So, \nthe solution is .(S)= {(a, c), (c, b), (b, a), (a, b), (b, c), (b, b), (d, a), (d, b)} The realizability \ngraph is shown in Figure 2 As the problem is NP-Hard, approximation algorithms have been proposed by \nAndersen [1], Steensgaard [12], and Shapiro and Horwitz [11], to name a few. These algorithms compute \na safe solution T to a given set of input statements S.We say that T is a safe solution if T is a superset \nof the exact solution .(S). For example, the set of all pairs of pointers is a safe solution. The accuracy \nof a solution is measured in terms of its size: smaller the better. The above algorithms consider a restricted \nversion of the prob\u00adlem where only one dereferencing is allowed in any input statement. That is, the \nonly statements allowed are of the form x =&#38;y, x = y, *x = y and x = *y. The idea is that the given \nset of statements S can be transformed into a new set of statements S'. We break a more general statement \n***... *x = y in S into a sequence of statements that use at most one dereferencing by using temporary \nvariables. In .ow-sensitive analysis, one can do the above transformation without loss of accuracy. But \nin .ow-insensitive analysis, it may lead to some loss of accuracy, because extra pairs of pointers may \nbe realizable in the transformed program. However, the transformation will not compromise safety, be\u00adcause \n.(S) . .(S'). The three algorithms provide tradeo. between accuracy and running time. We brie.y discuss \nAn\u00addersen s algorithm. Given the set of input statements S, we start with an empty solution T = f. We \n.rst consider direct assignment statements of the form x =&#38;y and add the pair (x, y)to T . Then, \nwe executte the following procedure iteratively, and add more pairs to T.If x = y is an input statement \nin S and p1p2 Layer 3  x1 x2 Layer 2 (y, z).T, weadd thepair (x, z)to T.If x = *y is in S and (y, w) \nand (w, z) are in T,we add (x,z) to T. Similarly, if *x = y is in S,and (x, w)and (y, z)are in T,weadd \n(w, z)to T. We stopwhenno more pairs canbe added to T. It is easy to see that Andersen s algorithm will \noutput a safe solution. However, it may not be the exact solu\u00adtion. The issue is that there may be pairs \n(y,w)and (w, z)that are realizable individually, but not simultaneously (i.e. y1y2 Layer 1  q1 q2 Layer \n0 (y, w) and (w, z) are realizable, but {(y, w), (w, z)} is not realizable). Suppose such pairs exist \nand x = *y is an in\u00ad put statement. Then, the algorithm would include (x, z)in its solution T, even though \n(x, z)may not be realizable. In the above situation, informally, we say that the realizable pairs (y, \nw) and (w, z) are dependent on each other. For instance, consider the set of statements S presented in \nEx\u00adample 1. We see that (a,b)and (b, c)are realizable individu\u00adally. But they are not realizable simultaneously. \nSo the pairs are dependent. Consider running Andersen s algorithm on Example 1. As pairs (a, b) and (b, \nc) are realizable, and d = *a is an input statement, the algorithm would include (d, c)in its solution. \nBut (d, c)is not actually realizable (i.e. (d, c) ..(S)). The above discussion shows that in order to \ncompute the exact solution, we have to handle the dependencies among the realizable pairs more carefully \n(at least, when one tries to extend Andersen s algorithm to compute exact solutions). It remains open \nwhether one can do that e.ciently. Recall that, the general problem where arbitrary number of deref\u00aderencing \nis allowed in an input statement is NP-Hard (The\u00adorem 4). But, when the number of dereferences allowed \nis bounded (say, only one dereferencing per statement is al\u00adlowed), no such hardness result is known. \nHence, one may be able to compute the exact solution in polynomial time. It is a challenging open problem. \nWe believe that some mech\u00adanism to handle the dependencies correctly and e.ciently may lead to a polynomial \ntime algorithm. In this paper, we show that when the pointers are required to have well-de.ned types, \nwe can deal with the dependen\u00adcies correctly and e.ciently (in polynomial time). More\u00adover, we can do \nthat even when the input statements use arbitrary number of dereferences. We do not break such statements \nand hence obtain exact solutions. The rest of the section presents a polynomial time algorithm for the \n.ow-insensitive analysis with types. 2.2 Flow-Insensitive Analysis With Types This problem is de.ned \nby restricting the general .ow\u00adinsensitive analysis (discussed in Section 2.1) to programs with well-de.ned \ntypes. A more precise de.nition follows. We are given a set of pointers (or variables) {p1,p2,... ,pn}, \na set of statements S and a pair of pointers p and q.A statement can be of two types: (i) ***... *pi \n=&#38;pj or (ii) ***... *pi = ***... *pj, for some variables pi and pj . All variables are scalars with \nwell-de.ned types (e.g. int, int*, int** etc.). A variable can point to only variables of compatible \ntype. For example, a variable of type int **can only point to a variable of type int*. We identify the \ntype of a variable by the number of dereferences used. For exam\u00adple, variables of type int and int ** \nare said to have types 0 and 2 respectively. The type information is part of the input, given by a function \nType(). The statements satisfy the typing rule mentioned above. For example, if pi =&#38;pj Figure 3: \nRealizability graph of Example 2 is a statement, then Type(pi) should be Type(pj)+1. Simi\u00adlarly, if ***pi \n= *pj is a statement, then Type(pi) should be Type(pj)+2. Given the set of pointers, the set of statements \nand two pointers p and q, the goal is to check if there is a .nite sequence s = s1,s2,... ,sr of the \ninput statements, such that at the end of executing these statements p points to q. We then say that \nthe sequence s makes p point to q.In such a sequence, a single statement can be used any number of times. \nExample 2 Input variables are {p1,p2,x1,x2,y1,y2,q1,q2}and their types are: Type(p1)= Type(p2)=3 Type(x1)= \nType(x2)=2 Type(y1)= Type(y2)=1 Type(q1)= Type(q2)= 0. The set of input statements is: {p1 =&#38;x1,p2 \n=&#38;x2, x1 =&#38;y1,x2 =&#38;y2, y1 =&#38;q1,y2 =&#38;q2, p1 = p2,p2 = p1, **p1 = **p2} The realizability \ngraph is shown in Figure 3. In the rest of the section, we make some preliminary ob\u00adservations and present \nan overview of our polynomial time algorithm for .ow-insensitive analysis with types. The algo\u00adrithm \nwill be presented in detail in Section 2.5. As the variables have well-de.ned types, the realizability \ngraph will be acyclic. Moreover, the variables will be ar\u00adranged into layers . For instance, variables \nof type int will be in layer 0, those of type int*will be in layer 1, and so on. In general, a variable \nof type i will be in layer i.Further\u00admore, a pointer of type i can only point to a pointer of type i \n-1. Hence, any edge in the realizability graph can only be from layer i to i -1(forsome i). Thus, the \nrealizability graph will always be layered: Definition 1. (Layered DAG) A directed graph G =(V, E) over \nn vertices is said to be layered if there is a layering func\u00adtion l : V .[0..(n -1)] such that for all \nedges (u, v) .E, l(v)= l(u) -1. We say that a vertex u is in layer l(u) and an edge (x, y) is in layer \nl(x). Note that layered graphs are acyclic. We next observe that pointers in a layer r are not useful \nin realizing any edge in a layer l>r.In other words, if xis a pointer in layer l,and (x,y) is a realizable \npair, then there is an execution sequence that realizes this pair without using any pointer in a layer \nr<l. As a consequence, if (x,y) and (u,v) are realizable (individually) and layer(x)= layer(u), then \n{(x,y),(u,v)} is realizable 3 . Thus, edges in di.erent layers can never be dependent. (Later, we will \nargue this claim in more detail). However, the claim does not preclude the possibility of edges in the \nsame layer being dependent. For instance, in Example 2, (p1,x2) and (p2,x1) are real\u00adizable individually, \nbut {(p1,x2),(p2,x1)} is not realizable. Thus, even though type restrictions do not eliminate depen\u00addencies \ntotally, they do make it easier to handle the depen\u00addencies. As dependent pair of edges in the same layer \nwill be important in our algorithm, we give them a special name: we call a pair of edges (x,y)and (u,v)in \nthe same layer a forbidden pair if (x,y) and (u,v) are realizable individually, but they are not realizable \nsimultaneously. Next we extend the above claim as follows. If individual links of a chain are realizable, \nthen the chain is realizable. That is, if each of (p1,p2), (p2,p3),(p3,p4), ...,(pk-1,pk) is realizable, \nthen the chain p1 . p2 .\u00b7\u00b7\u00b7 . pk is realizable. With these observations, the idea is to compute the realiz\u00adability \ngraph layer by layer, starting with the highest layer. Suppose, by induction, we have computed all layers \nfrom the highest down to layer l+ 1 and we want to compute edges in layer l. We .rst consider statements \nof the form *d p =&#38;z (with d = 0). For each x in layer l,if there is a path of length d from p to \nx (in the graph constructed so far) then we add the edge (x,y). *d1 *d2 Handling copying statements of \nthe form p = q is more tricky. Let x and y be pointers in layer l.It is tempt\u00ading to conclude that, if \nthere is a path of length d1 from pto x and a path of length d2 from q to y, then values of y can be \ncopied to x. This is not true in general. We must also make sure that the two paths can be realized simultaneously. \nThat involves checking for two necessary conditions. First, the paths should be vertex disjoint. Second, \nany two edges in the same layer used by the paths must be realizable simul\u00adtaneously. So, it is not enough \nif we compute only the edges in each layer. In each layer, we also need to know which pair of edges are \nrealizable simultaneously and which are forbid\u00adden. Now we are faced with two new subproblems. First, \nwe should be able to check for existence of vertex disjoint paths that do not use forbidden pairs. Second, \nwe should also be able to compute forbidden pair of edges in each layer. We formalize the .rst problem \nand solve it in Section 2.3. As for the second problem, the set of forbidden pairs in a layer is determined \nsolely by how copy propagation works in that layer. We formalize the problem as concurrent copy propagation \nand solve it in Section 2.4. 2.3 Disjoint Paths With Forbidden Pairs In this problem, we are given a \ndirected graph G,a pair of source vertices s1 and s2, a pair of target vertices t1 and t2, and a set \nof pairs of edges F . E\u00d7 E. We call the pairs in F as forbidden pairs. The goal of the problem is to \ncheck 3This claim fails if the pointers do not have well-de.ned types, or if the goal is to do .ow-sensitive \nanalysis. if there are two paths p1 and p2 such that i) p1 is a path from s1 to t1 and p2 is a path from \ns2 to t2; ii) p1 and p2 are vertex disjoint (i.e., they do not share any vertex); iii) for any forbidden \npair (e1,e2) . F,if p1 uses e1 then p2 does not use e2. The well-known disjoint paths problem is a special \ncase of the above problem where there are no forbidden pairs (i.e. F = f). The problem is known to be \nNP-Complete [4]. Here we consider a special case of the problem where the input graph is layered and \nfor any forbidden pair (e1,e2), the edges e1 and e2 are in the same layer of the graph. We show that \nthis restriction can be solved in polynomial time. Theorem 6. The problem of disjoint paths with forbid\u00adden \npairs can be solved in polynomial time, if the input graph is layered and each forbidden pair of edges \nappear in the the same layer. Proof. We reduce the given problem to a question of reachability in directed \ngraphs. Let the input instance con\u00adsist of a layered graph G =(V,E) with a layering function l,source \nvertices s1 and s2, target vertices t1 and t2,and a set of forbidden pairs F. Without loss of generality, \nwe assume that the two source vertices are in the same layer. (Suppose s2 is in a layer higher than s1. \nWe can add new vertices u1,u2,... ,ud to G,where d = l(s2) - l(s1), and add d- 1edges (u1,u2),(u2,u3),... \n,(ud-1,ud), creating a chain. Then we add the edge (ud,s1)and make u1 as a source vertex, instead of \ns1.) Similarly, assume that the two target vertices are in the same layer. Now we construct a new graph \nG ' =(V ' ,E ' ). V ' . V \u00d7 V consists of pairs of distinct vertices in the same layer of G. Two vertices \nin G ' are connected by an edge if the corresponding components of these vertices are connected by a \npair of non-forbidden edges in G. Formally let, V ' = {(u,v)|u,v . V,u= v, and l(u)= l(v)} E ' = {((u1,v1),(u2,v2))|((u1,u2),(v1,v2)). \nE \u00d7 E- F} It is clear that G ' is also layered. Now we show that the given instance has a solution i. \nthere is a path from (s1,s2) to (t1,t2) in G ' . Suppose the given instance has a solution via the disjoint \npaths p1 = u1,u2,... ,uk and p2 = v1,v2,... ,vk,where u1 = s1,uk = t1,v1 = s2 and vk = t2. Wemade surethat \nl(s1)= l(s2)and l(t1)= l(t2). So for any i, l(ui)= l(vi). As the paths are vertex disjoint, ui = vi.Hence, \n(ui,vi). V ' , for all 1 = i = k.Moreover, for 1 = i<k, the pair of edges (ui,ui+1)and (vi,vi+1) is not \nforbidden. Hence, ((ui,vi),(ui+1,vi+1)) . E ' .So p = (u1,v1),... ,(uk,vk) is a path from (s1,s2) to \n(t1,t2) in G ' . For the other direction, assume that there is a path p = (u1,v1),(u2,v2),... ,(uk,vk) \nfrom (s1,s2) to (t1,t2) in G ' . Consider the paths p1 = u1,u2,... ,uk and p2 = v1,v2,... ,vk. It is \nclear that p1 and p2 are indeed legitimate paths in G, from s1 to t1 and s2 to t2, respectively. We .rst \nshow that they are vertex disjoint. By our construction and as Gis lay\u00adered, for i = j, ui = vj. Moreover, \nas (ui,vi). V ' , ui = vi. Hence the paths are vertex disjoint. To show that no for\u00adbidden pair is used \nin p1 and p2, note that a forbidden pair of edges will be in the same layer (by problem de.nition). Thepresenceof \nthe edge ((ui,vi),(ui+1,vi+1)) implies that the pair of edges (ui,ui+1)and (vi,vi+1) are not forbidden. \nHence p1,p2 is a valid solution to our problem. Thus we have reduced the given instance to a question \nof reachability in G ' .Size of G ' is polynomial in size of G and reachability can be solved in polynomial \ntime (say, via depth .rst search). Our reduction algorithm runs in polynomial time. Hence disjoint paths \nwith forbidden pairs on layered graphs can be solved in polynomial time.  2.4 Concurrent Copy Propagation \nProblem k-Concurrent Copy Propagation Problem (k-CCP): Let k be a positive integer. In the k-CCP problem, \nwe are given a set of variables V,a set of constants (or values) C andaset of statements S. We represent \nvariables by capital letters and constants by small letters. A statement can be of two types: (i) X := \na,for some X . V and a . C or (ii) X := Y,for some X,Y . V. Executing the former state\u00adment assigns the \nconstant ato X, whereas executing the lat\u00adter statement copies the current value of Y to X.Consider a \nset of goals G = {(X1,a1),(X2,a2),... ,(Xk,ak)},where Xi are distinct. We say that G can be realized \nif there is some .nite sequence s1,s2,... ,sr,with each si . S, such that at the end of executing this \nsequence, for each 1 = i = k,the value Xi is ai.The solution . of k-CCP is the set of all such realizable \nsets of k goals: . = {s|s is a realizable set of size k} If kcan be arbitrary (and is part of the input) \nthe decision version of the problem is known to be PSPACE-Complete [9]. But when k is a constant, k-CCP \ncanbe solvedinpolyno\u00admial time. For our purposes, we only need the cases where k is either 1 or 2. When \nk = 1, it is easy to see that the prob\u00adlem can be reduced to a question of reachability in directed graphs \nand hence can be solved in polynomial time. Theorem 7. The 1-CCP problem can be solved in poly\u00adnomial \ntime. Theorem 8. The 2-CCP problem can be solved in poly\u00adnomial time. Proof. Given a set of variables \nV, constants C and state\u00adments S, we compute the solution . using the idea of tran\u00adsitive closure. We \nstart with . = {{(X,x),(Y,y)}|X = Y and X := x and Y := y are statements in S} Now we iterate and add \nmore elements to .. For each ele\u00adment {(X,x),(Y,y)} in ., 1. For each statement Z := z in S,with Z=X,add \n{(X, x), (Z, z)}to .. 2. For each statement Z := X,with Z=X,add {(X, x), (Z, x)}to .. 3. For each statement \nZ := X,with Z=Y ,add {(Z, x), (Y, y)}to ..  A variable cannot hold two constants simultaneously. The \ninequality checks in the above procedure are to ensure this property. Now we apply the above procedure \niteratively and stop when we cannot add any more elements to ..The boundary condition in which X is the \nonly variable that gets a constant assigned to it directly has to be handled separately. The details \nare omitted for brevity. . can have at most |V|2 \u00d7|C|2 elements. Thus the above algorithm would need \nno more than that many iterations. Hence it runs in polynomial time. One can prove the cor\u00adrectness of \nthe algorithm using induction.  2.5 Main Algorithm Given a set of pointers {p1,p2,... ,pn} (with types) \nand a set of statements S, we describe a polynomial time algorithm to compute the realizability graph. \nLet the number of types used by the pointers be L. Recall that the graph would be layered with L+ 1 layers \nnumbered 0,1,... ,L. We will .nd the edges of the graph layer by layer, from L down to 1. For each layer \ni, we will also compute the set Fi of all forbidden pairs of edges. By induction, assume that we have \ncomputed the edges and set of forbidden pairs for layers L down to l+ 1 correctly and we want to compute \nthe same information for layer l. The computation of edges and forbidden pairs in a given layer l of \nG consists of four phases: 1. Direct Assignments: Analyze each statement of the form *d p=&#38;z and \n.nd the variables q, in level l,that can be made to point to z by this statement. 2. Copying Statements: \nAnalyze each statement of the form *d1 p1 = *d2 p2 and .nd pairs of variables q1 and q2, in level l, \nsuch that values of q2 canbe copiedto q1 using this statement. 3. Edge Computation: Compute edges in \nlayer l in this phase. 4. Forbidden Pair Computation: Compute the forbidden pairs of edges in layer \nl.  Direct Assignments: We consider each (direct as\u00adsignment) statement of the form p =&#38;z.As variables \n*d in layer l can only point to those in layer l- 1, we ignore the statement if layer(z)= l- 1. So, assume \nthat z is in layer l - 1. Then, we claim that if there exists a path of length d from p to q (in the \ngraph constructed so far) then (q,z) is realizable (where, length of a path is the number of edges used). \nSuppose there is such a path rd,rd-1,... ,r0, where rd = p, r0 = q. We have to exhibit a sequence that \nrealizes the pair (q,z).The edges (rd,rd-1), (rd-1,rd-2), ...,(r1,r0), are all in some layer higher than \nl.Thus, by our induction hypothesis, each of these edges is realizable. So there exist execution sequences, \nE1, E2,... Ed that re\u00adalize the pairs (r1,r0), (r2,r1),..., (rd,rd-1), respectively. Because of the type \nrestrictions, variables in a layer are not useful in realizing any edge in a higher layer. Hence, without \nloss of generality, we can assume that, for each 1 = i = d, the sequence Ei does not use the variables \nri-1,ri-2,...,r0. So, executing the sequence Ei will not change the value of ri-1,ri-2,...,r0. Now consider \nthe sequence obtained by concatenating E1,E2,...,Ed (in that order 4 ). Executing this sequence would \nrealize the chain, (p=)rd . rd-1 .\u00b7\u00b7\u00b7 . r0(= q) By appending the statement *d p=&#38;zto the above sequence \nwe can realize the pair (q,z). Thus, we have proved the claim that if there is a path of length d from \np to q (in the graph constructed so far), then (q,z) is realizable. So, if there is a path of length \nd exists, we add the edge (q,z). Copying Statements: Next we consider each (copy\u00ading) statement of the \nform *d1 p1 = *d2 p2.We .rst check if 4Here is whereweuse the factthat weare doing .ow insen\u00adsitive analysis. \nIf there is a input control .ow graph that regulates the ordering among statements, we cannot execute \nthe statements in the order we want. layer(p)= l + d1 or layer(p2)= l+ d2. If not, the state\u00adment is \nnot relevant at layer l and we ignore it. Then, we consider each pair of pointers q1 and q2 in layer \nl.We want to check if the above statement can copy values of q2 to q1. It is tempting to say that this \nis the case if there is a path from p1 to q1 and a path from p2 to q2. But these paths should satisfy \ntwo necessary conditions. Condition 1: The paths should be vertex disjoint. Sup\u00adpose the paths are not \nvertex disjoint. Let the paths be p1,... ,x,x1,... ,q1 and p2,... ,x,x2,... ,q2.At any point during an \nexecution, x can point to either x1 or x2, but not both. Hence, though these two chain of pointers can \nbe re\u00adalized individually, they cannot be realized concurrently. So we need to make sure that the two \npaths are vertex disjoint. Condition 2: As forbidden pair of edges cannot be re\u00adalized simultaneously, \nwe need to make sure that the paths do not use them. That is, for every pair of forbidden pair of edges \ne1 and e2, if one of the paths uses e1, the other path should not use e2. We illustrate the need for \nthe second condition, using Fig\u00adure 3 and the associated example. That graph has vertex disjoint paths \nof length two from p1 to y2 and p2 to y1. But, the pair of edges (p1,x2)and (p2,x1) cannot be re\u00adalized \nsimultaneously. So the edges (p1,x2)and (p2,x1) form a forbidden pair. Hence, even though the two chains \np1 . x2 . y2 and p2 . x1 . y1 can be realized individ\u00adually, they cannot be realized simultaneously. \nIf we do not check for Condition 2, while processing the input statement **p1 = **p2, we will add the \nedge (y2,q1). But the edge (y2,q1) cannot be realized by any sequence. Based on above discussion, our \nalgorithm to process the d1 d2 statement *p1 = *p2 is as follows. We consider each pair of pointers q1 \nand q2 in level l. We claim that values of q2 can be copied to q1 if there is a path from p1 to q1 and \na path from p2 to q2 such that the paths are vertex disjoint and they respect the forbidden pair of edges \nin layers L through l+ 1. Suppose such paths exist. Let the paths be (p1 =)xd1 .xd2-1 \u00b7\u00b7\u00b7. x0(= q1) and \n(p2 =)yd2 .yd2-1 .\u00b7\u00b7\u00b7.y0(= q2). Assume that d1 = d2 (the other case is similar). By our induction hypothesis, \nthere exist execution sequences E1, E2,...,Ed2 such that, for d2 = i<d1, Ei realizes the pair (yi,yi-1). \nMoreover, by our induction hypothesis, for each d1 = i = 1, Ei realizes the pairs (xi,xi-1) and (yi,yi-1)simultaneously, \nbecause they are not forbidden. Then the sequence obtained by concatenating E1,E2,...,Ed2 (in that order) \nwould realize the two chains of pointers. We can copy d1 d2 values of q2 to q1 by appending the statement \n*p1 = *p2 to the above sequence. Edge Computation: From the Direct Assignments phase, we have identi.ed \nthe set of pairs (q,z) such that q is layer l, z is in layer l -1and q can bemadetopoint to z. From the \nCopying Statements phase, we have pairs (q1,q2) with both q1 and q2 in layer l such that values from \nq2 can be copied to q1. We use the above information to compute the edges in layer l by solving a copy \npropagation problem. The set of pointers in layer l correspond to the variables for the copy propagation \nproblem and the set of pointers in layer l -1 correspond to the constants. More precisely, construct \na set VCCP by adding a variable Xq for each pointer q in layer l.Then construct a set CCCP by adding \na constant cz for each pointer zin layer l-1. De.ne a set of statements SCCP for the copy propagation \nproblem as follows. For each pair (q,z)identi.ed in Direct Assignments phase, add a statement Xq := cz \nto SCCP and for each pair (q1,q2) identi.ed in Copying Statements phase, add a statement Xq1 := Xq2 to \nSCCP . Then using the algorithm claimed in Theorem 7 we solve the 1-CCP problem with VCCP as the set \nof variables, CCCP as the set of constants and SCCP as the set of statement. For each pair (Xq,cz) in \nthe solution to the 1-CCP problem, we add the edge (q,z) to the graph. Forbidden Pair Computation: If \n(q1,z1)and (q2,z2) are edges in layer l, whether they can be realized simulta\u00adneously is determined solely \nby the way copy propagation works in layer l. So using the algorithm claimed in Theo\u00adrem 8 we solve the \n2-CCP problem with VCCP as the set of variables, CCCP as the set of constants and SCCP as the set of \nstatements. For any ((Xq1 ,cz1 ),(Xq2 ,cz2 )) in the solu\u00adtion to the 2-CCP problem, we can realize the \npairs (q1,z1)and (q2,z2) simultaneously. Every other pair of realizable edges in layer l is declared \nforbidden. The algorithm is presented in Figure 4. It is easy to see that the algorithm runs in polynomial \ntime. Our discus\u00adsion shows that if the algorithm includes an edge (u,v)in its output graph, then pair \n(u,v) is indeed realizable. One can prove the claim formally, by using an induction on the layer number \nof (u,v). On the other hand, suppose a (u,v)is realizable. Then, we can prove that (u,v) will be an edge \nin the output graph by using induction on the length of the shortest sequence realizing the pair (u,v). \nThough straight\u00adforward, these proofs are somewhat lengthy. For want of space, we omit them.  3. UNDECIDABILITY \nOF FLOW-SENSITIVE ANALYSIS WITH SCALAR VARIABLES In this section we prove Theorem 2. Problem De.nition: \nWe are given a set of pointers, a program (or say, its control .ow graph) and two pointers p and q. Three \ntypes of assignment statements are allowed in the program: (1) ***... *x =&#38;y,(2) ***... *x = ***...*y \nand (3) ***...*x = New . The third statement creates a new unnamed variable and makes ***...*x point \nto it. Two types of control .ow statements are allowed: if(..)then...else... and while(..).... Now the \ngoal is to check if there is some path from the start node to the exit node in the control .ow graph, \nsuch that, at the end of executing the statements along the path, p points to q. As it is traditionally \ndone, we make the conservative as\u00adsumption that every path in the program is executable. This means that, \nno matter through which path we arrived at an if(..)then...else... statement, we can proceed through \neither the if part or the else part. In other words, we ignore the conditional expression. A similar \nassumption is made about the While(..) statement. One can see that relaxing this assumption makes the \nproblem even harder. A variation of the problem where variables could be struc\u00adtures is known to be undecidable. \nLandi proved this the\u00adorem by giving a reduction from the halting problem [7]. Ramalingam gave a simpler \nproof using a reduction from the Post s correspondence problem [10]. Here we prove the undecidability \nmaking use of only scalar variables. Input: Aset of n pointers with L types and a set of statements \nS. Output: Realizability graph G of S. For l from L to 1 do 1. Let VCCP = {Xq|q is a pointer in layer \nl}.  2. Let CCCP = {cz|z is a pointer in layer l- 1}. 3. Let SCCP = {}.  4. For each statement *d \np=&#38;z, such that, layer(z)= l- 1 and layer(p)= l+ d For each each pointer q in layer l If there is \na path from p to q then add the statement Xq := cz to SCCP . 5. Let F = .L Fi  i=l+1 *d1 = *d2 \n 6. For each statement p1 p2 such that layer(p1)= l+ d1 and layer(p2)= l+ d2 For each pair of pointers \nq1 and q2 in layer l Use algorithm in Theorem 6 to check if there are vertex disjoint paths from p1 to \nq1 and p2 to q2 that respect the set of forbidden pairs F. If such paths exist add the statement Xq1 \n:= Xq2 to SCCP . 7. Use algorithm for 1-CCP (Theorem 7) with VCCP as variables, CCCP as constants and \nSCCP as statements and compute the solution .1-CCP . 8. For each pair (Xq,cz) in .1-CCP , add the edge \n(q,z) to G. 9. Use algorithm for 2-CCP (Theorem 8) with VCCP as variables, CCCP as constants and SCCP \nas statements and compute the solution .2-CCP . 10. Let Fl = {}.  11. For each (Xq1 ,cz1 ) and (Xq2 \n,cz2 ) in .1-CCP , with q1 = q2, If {(Xq1 ,cz1 ),(Xq2 ,cz2 )} is not in .2-CCP , add {(q1,z2),(q2,z2)} \nto Fl.  Figure 4: Algorithm to compute realizability graph The problem of checking whether a multivariate \npolyno\u00admial has integer roots is known to be undecidable. In this problem, we are given a polynomial \nP(x1,x2,... ,xn)over the variables x1,x2,... ,xn. A sequence of (positive or neg\u00adative) integer constants \na1,a2,... ,an, not all zero, is called an integer root of P if P(a1,a2,... ,an)=0. Given the polynomial, \nthe problem is to check if it has any integer roots. The problem is also known as the Hilbert s tenth \nproblem. Building on the work of Davis, Putnam and Robin\u00adson, Matijasevi.c proved the undecidability \nof the Hilbert s tenth problem [8]. We prove our undecidability result via a reduction from the above \nproblem. The polynomial P(x1,x2,x3)= x1 + x1x2 - x2x3 is used as a running example to illustrate our \nreduction. The output program for this example is given in Appendix A. Here we explain the ideas used. \nOur output program starts with the following piece of code: D =&#38;Success; Zero = temp= New ; While(..) \n{ *temp=New ; temp=*temp;} The .rst statement makes D point to Success. We will make sure that the polynomial \nhas integer roots if and only if there is an execution path in which D remains pointing to Success at \nthe exit statement of the program. This would prove the required undecidability. The next few statements \nin the above code create a singly linked list with Zero as the head. This would simulate the positive \ninteger number line, with the kth node representing integer k. The next segment of the output program \nsimulates choos\u00ading constant values for each variable xi.The value has a magnitude and a (positive or \nnegative) sign. To choose the magnitude of xi we use a pointer Xi and traverse the linked list. For our \nexample polynomial, the next segment of code is: X1 = Zero; While(..) {X1 = *X1; }X2 = Zero; While(..) \n{X2 = *X2; }X3 = Zero; While(..) {X3 = *X3; } If a path iterates the .rst loop a1 times, X1 would point \nto the a th 1 node in our linked list. This corresponds to as\u00adsigning x1 = a1. In general, let X1,X2,... \n,Xn point to nodes a1,a2,... ,an of the linked list. Then, this simulates choosing these values for the \nvariables. Recall that we want to check if there is a nonzero integer root. Thus, we need to ensure that \nat least one variable is assigned a nonzero value. The next segment of output our program, ensures that \nby using a multiway branch with n branches. The code segment for our example would be: Switch(..) { Case: \nX1 = *X1; Case: X2 = *X2; Case: X3 = *X3; }As one of the branches must be executed, not all variables \ncan point to node zero of the linked list. Next we simulate choosing signs for the variables. As each \nof the n variables can be positive or negative, the signs can be chosen in 2n possible ways. We use a \nmultiway branch 5 (a switch statement) with 2n branches to do the simula\u00adtion. Each branch represents \nchoosing a particular combi\u00adnation of signs for the variables. Consider any one branch with one such \n.xed combination of signs. Then the sign of any term in the polynomial also gets .xed. The sign of a \nterm is determined by the its sign in the input poly\u00ad 5The multiway branch can easily be translated into \na se\u00adquence of if(..)then...else... statements. nomial and the combination .xed by the branch. In our \nexample, consider the branch that .xes x1,x3 to be posi\u00adtive and x2 to be negative. Then, sign of the \nterm -x2x3 would be positive. We separate the terms of the polynomial into groups of positive and negative \nterms and get two poly\u00adnomials P1 and P2. Then, a1,a2,... ,an is an integer root of P i. if P1(a1,a2,... \n,an)= P2(a1,a2,... ,an). In our example, consider a branch that represents choosing x1,x3 to be positive \nand x2 to be negative. Now, irrespective of the magnitudes, the terms x1 and -x2x3 would be positive, \nwhereas the term x1x2 would be negative. So P1 = x1 +x2x3 and P2 = x1x2. Before proceeding further, we \nde.ne a macro 6 used in the remainder of our program. The macro takes two parameters A and B and checks \nif they point to the same location: ALIAS -CHECK(A, B): temp1 = *A; temp2 = *B; *A =&#38;D; *B =&#38;dummy; \n**A =&#38;Failure; *A = temp1; *B = temp2; Ignore the .rst two and the last two statements for the mo\u00adment. \nThen, if A and B point to di.erent locations then the variable D would point to Failure. On the the other \nhand, if they point to the same location then D would re\u00admain pointing to Success and only a dummy variable \nwill be made to point to Failure. The .rst two and the last two statements ensure that no other variable \nis a.ected by this macro. Recall that we want to check if the polynomials P1 and P2 evaluate to the same \nvalue. For this purpose, we use two pointers p1 and p2.We .rst set p1 and p2 to point to node zero of \nthe linked list. Then we consider the terms of the polynomial one by one. A term would contribute to \nP1 if it is positive and to P2 if it is negative. The sign of the term is determined by two factors: \nthe sign given to the term in the polynomial and which branch of the Switch statement we are dealing \nwith. Suppose the term contributes to P1.In that case we would move p1 forward on the linked list. If \nit contributes to P2, we would move the pointer p2.In either case, the number of nodes by which the pointer \nmoves is de\u00adtermined by the chosen values a1,a2,... ,an. For example, let us take the term x1x2. Suppose \nwe are writing code for the branch that represents choosing x1 and x3 to be positive and x2 to be negative. \nThe term x1x2 would be negative. So, we move p2. We need to move it by a1 \u00d7a2 number of nodes. We use \nnested loops to achieve this: r1 = Zero; While(..) { r1 = *r1; r2 = Zero; While(..) {r2 = *r2; p2= *p2; \n} }The problem with the above code is that the loops may be executed arbitrary number times. But we \nwant the inner loop to run for exactly a2 iterations and the outer loop for exactly a1 times. To ensure \nthis, we use the fact that X1 and X2 are pointing to a1 and a2 and do alias checks. The new program fragment \nis: 6Using macros is not an issue, as they can always be ex\u00adpanded. r1 = Zero; While(..) { r1 = *r1; \nr2 = Zero; While(..) {r2 = *r2; p = *p; } ALIAS -CHECK(X2,r2); } ALIAS -CHECK(X1,r1); Now either p2 \npoints to node numbered a1 \u00d7a2 or D points to Failure. Our program will make sure that it never goes \nback to Success. After evaluating all the terms of the polynomial we .nally check whether p1 and p2 point \nto the same location, using the macro ALIAS -CHECK. Thus D can point to Success at the exit of the program \ni. the polynomial has integer roots.  4. CONCLUSIONS AND OPEN PROBLEMS In this paper, we proved two \nmain results. We showed that .ow sensitive pointer analysis is undecidable even if the in\u00adput programs \nhave only scalar variables, provided dynamic memory is allowed. This extends the previously known re\u00adsult \nthat required non-scalar variables as well [7, 10]. Our re\u00adsult presents a complete classi.cation of \n.ow-sensitive anal\u00adysis as showninFigure 1. Unlike .ow-sensitive analysis, the complexity of .ow in\u00adsensitive \nanalysis is less understood. When arbitrary levels of dereferencing is allowed in pointer expressions \nand vari\u00adables are scalars, the problem in known to be NP-Hard [5]. Except for this result, we know little \nabout the complexity of the problem. In this paper, we showed that the above prob\u00adlem can be solved in \npolynomial time, with a further restric\u00adtion that the variables have well-de.ned types. In contrast, \nit is known that .ow-sensitive analysis is PSPACE-Complete even for two levels of types. Though there \nhas been empiri\u00adcal evidence that .ow-insensitive analysis is computationally easier than .ow-sensitive \nanalysis, this result gives, to the best of our knowledge, the .rst theoretical evidence. More\u00adover, \nwhile most of the results pertaining to the points-to analysis problem are undecidability and hardness \nresults, our result is a rare instance of a non-trivial points-to analy\u00adsis problem solvable in polynomial \ntime. There are several open problems related to .ow-insensitive analysis: When dynamic memory is not \nallowed but arbitrary number of levels of dereferencing is allowed, the prob\u00adlem is NP-Hard [5]. Is it \nin NP?  Consider the above problem but with bounded number of dereferences. Is this problem in P?  \nWhen dynamic memory is allowed, is the problem de\u00adcidable?  5. ACKNOWLEDGMENTS I thank Jin-Yi Cai, \nSusan Horwitz, Raghav Kaushik and Rajasekar Krishnamurthy for extensive discussions and help\u00adful comments. \nI thank Rajasekar Krishnamurthy and the anonymous referees for their suggestions on improving the presentation \nof the paper. I thank an anonymous referee of an earlier paper for suggesting the problem considered \nin Theorem 5. This work was supported in part by the Na\u00adtional Science Foundation under grants CCR-9634665 \nand CCR-0208013. 6. REFERENCES [1] L.O.Andersen. Program Analysis and Specialization for the C Programming \nLanguage. PhD thesis, DIKU, University of Copenhagen, May 1994. (DIKU report 94/19). [2] M.Burke,P.Carini, \nJ.-D.Choi, andM.Hind. Flow-insensitive interprocedural alias analysis in the presence of pointers. In \nK. Pingali, U. Banerjee, D. Gelernter, A. Nicolau, and D. Padua, editors, Language and Compilers for \nParallel Computing, 7th International Workshop, LNCS 892, pages 234 250. Springer-Verlag, Aug. 1994. \n[3] J. Choi, M. Burke, and P. Carini. E.cient .ow-sensitive interprocedural computation of pointer-induced \naliases and side e.ects. In ACM Symposium on Principles of Programming Languages, pages 232 245, Jan. \n1993. [4] S. Fortune, J. Hopcroft, and J. Wyllie. The directed subgraph homeomorphism problem. Theoretical \nComputer Science, 10:111 121, 1980. [5] S. Horwitz. Precise .ow-insensitive alias analysis is NP-hard. \nACM Transactions on Programming Languages and Systems, 19(1), Jan. 1997. [6] W. Landi. Interprocedural \nAliasing in the Presence of Pointers. PhD thesis, Rutgers University, 1992. [7] W. Landi. Undecidability \nof static analysis. ACM Letters on Programming Languages and Systems, 1(4):323 337, 1992. [8] Y. Matiyasevi.c. \nHilbert s 10th Problem. MIT Press, 1993. [9] R. Muth and S. Debray. On the complexity of .ow-sensitive \ndata.ow analyses. In ACM Symposium on Principles of Programming Languages, pages 67 80, 2000. [10] G. \nRamalingam. The undecidability of aliasing. ACM Transactions on Programming Languages and Systems, 16(5):1467 \n1471, 1994. [11] M. Shapiro and S. Horwitz. Fast and accurate .ow-insensitive points-to analysis. In \nACM Symposium on Principles of Programming Languages, Jan. 1997. [12] B. Steensgaard. Points-to analysis \nin almost linear time. In ACM Symposium on Principles of Programming Languages, pages 32 41, Jan. 1996. \n[13] S. Zhang, B. Ryder, and W. Landi. Program decomposition for pointer aliasing: A step toward practical \nanalyses. In ACM SIGSOFT Symposium on Foundations of Software Engineering, pages 81 92, 1996. APPENDIX \n A. APPENDIX A This Appendix is related to Section 3. Here we take P (x1,x2,x3)= x1 + x1x2 -x2x3 as an \nexample polynomial and present the complete program output by the reduction given in Section 3. For ease \nof understanding we use a few macros. The .rst macro is as follows: ALIAS -CHECK(A, B): temp1 = *A; temp2 \n= *B; *A =&#38;D; *B =&#38;dummy; **A =&#38;Failure; *A = temp1; *B = temp2; The macro checks if A and \nB point to the same node. If they are aliased a dummy variable is made point to Failure.If not, it makes \nD to point to Failure. The other pointers A, B, *A and *B are not a.ected by the macro. For each term \nof the polynomial, we de.ne a macro. The macro takes a parameter p. Suppose the the value of the term \nat the chosen constants is v, Then the macro either moves forward p by v nodes on the linked list or \nmakes D point to Failure. TERM1(p): r1 = Zero; While(..) {r1 = *r1; p = *p; } ALIAS -CHECK(X1,r1); TERM2(p): \nr1 = Zero; While(..) { r1 = *r1; r2 = Zero; While(..) {r2 = *r2; p = *p; } ALIAS -CHECK(X2,r2); } ALIAS \n-CHECK(X1,r1); TERM3(p): r1 = Zero; While(..) { r1 = *r1; r3 = Zero; While(..) {r3 = *r3; p = *p; } \nALIAS -CHECK(X3,r3); } ALIAS -CHECK(X1,r1); Now we are ready to present the code: Variables : D, Success, \nFailure; Variables : X1,X2,X3; Variables : p1,p2; Variables : r1,r2,r3, temp, dummy; /* Initialize D \n*/ D =&#38;Success; /* Setup number line */ Zero = temp = New ; While(..) {*temp=New ; temp=*temp;} \n /* Choose values */ X1 = Zero; While(..) {X1 = *X1; } X2 = Zero; While(..) {X2 = *X2; } X3 = Zero; While(..) \n{X3 = *X3; } /* Make sure not all values are zero */ Switch(..) { Case: X1 = *X1; Case: X2 = *X2; Case: \nX3 = *X3; } /* Initialize p1 and p2 */ p1 = Zero; p2 = Zero; /* Choose signs and evaluate the two polynomials. \nEach branch chooses a particular combination of signs. In any branch, we consider all the three terms. \nAnd move p1 if the term is positive and move p2 if the term is negative Whether a term is positive or \nnegative is determined by the sign of term in the input polynomial and the combination of signs represented \nby the branch. */ Switch(..) {Case: :TERM1(p1); TERM2(p1); TERM3(p2); /*+X1,+X2,+X3*/ Case: :TERM1(p1); \nTERM2(p1); TERM3(p1); /*+X1,+X2,-X3*/ Case: :TERM1(p1); TERM2(p2); TERM3(p1); /*+X1,-X2,+X3*/ Case: :TERM1(p1); \nTERM2(p2); TERM3(p2); /*+X1,-X2,-X3*/ Case: :TERM1(p2); TERM2(p2); TERM3(p2); /*-X1,+X2,+X3*/ Case: :TERM1(p2); \nTERM2(p2); TERM3(p1); /*-X1,+X2,-X3*/ Case: :TERM1(p2); TERM2(p1); TERM3(p1); /*-X1,-X2,+X3*/ Case: :TERM1(p2); \nTERM2(p1); TERM3(p2); /*-X1,-X2,-X3*/ } /* Finally check if p1 and p2 point to same node in the number \nline */ ALIAS - CHECK(p1,p2) The polynomial has non-zero integer roots if and only if there is a execution \npath in the program such that at the last statement D points to Success.  \n\t\t\t", "proc_id": "604131", "abstract": "Given a program and two variables <i>p</i> and <i>q</i>, the goal of points-to analysis is to check if <i>p</i> can point to <i>q</i> in some execution of the program. This well-studied problem plays a crucial role in compiler optimization. The problem is known to be undecidable when dynamic memory is allowed. But the result is known only when variables are allowed to be structures. We extend the result to show that, the problem remains undecidable, even when only scalar variables are allowed. Our second result deals with a version of points-to analysis called flow-insensitive analysis, where one ignores the control flow of the program and assumes that the statements can be executed in any order. The problem is known to be NP-Hard, even when dynamic memory is not allowed and variables are scalar. We show that when the variables are further restricted to have well-defined data types, the problem is in P. The corresponding flow-sensitive version, even with further restrictions, is known to be PSPACE-Complete. Thus, our result gives some theoretical evidence that flow-insensitive analysis is easier than flow-sensitive analysis. Moreover, while most variations of the points-to analysis are known to be computationally hard, our result gives a rare instance of a non-trivial points-to problem solvable in polynomial time.", "authors": [{"name": "Venkatesan T. Chakaravarthy", "author_profile_id": "81100097085", "affiliation": "University of Wisconsin--Madison, Madison, WI", "person_id": "P290390", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/604131.604142", "year": "2003", "article_id": "604142", "conference": "POPL", "title": "New results on the computability and complexity of points--to analysis", "url": "http://dl.acm.org/citation.cfm?id=604142"}