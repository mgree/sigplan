{"article_publication_date": "01-15-2003", "fulltext": "\n Ownership Types for Object Encapsulation Chandrasekhar Boyapati Barbara Liskov Liuba Shrira Laboratory \nfor Computer Science Laboratory for Computer Science Department of Computer Science Massachusetts Intitute \nof Technology Massachusetts Intitute of Technology Brandeis University Cambridge, MA 02139 Cambridge, \nMA 02139 Waltham, MA 02454 chandra@lcs.mit.edu liskov@lcs.mit.edu liuba@cs.brandeis.edu Abstract Ownership \ntypes provide a statically enforceable way of spec\u00adifying object encapsulation and enable local reasoning \nabout program correctness in object-oriented languages. However, a type system that enforces strict object \nencapsulation is too constraining: it does not allow e.cient implementation of important constructs like \niterators. This paper argues that the right way to solve the problem is to allow objects of classes de.ned \nin the same module to have privileged ac\u00adcess to each other s representations; we show how to do this \nfor inner classes. This approach allows programmers to ex\u00adpress constructs like iterators and yet supports \nlocal reason\u00ading about the correctness of the classes, because a class and its inner classes together \ncan be reasoned about as a module. The paper also sketches how we use our variant of owner\u00adship types \nto enable e.cient software upgrades in persistent object stores. Categories and Subject Descriptors \nD.3.3 [Programming Languages]: Language Constructs; D.2.4 [Software Engineering]: Program Veri.cation \n General Terms Languages, Veri.cation, Theory  Keywords Ownership Types, Object Encapsulation, Software \nUpgrades 1 Introduction The ability to reason locally about program correctness is crucial when dealing \nwith large programs. Local reasoning allows correctness to be dealt with one module at a time. Each module \nhas a speci.cation that describes its expected behavior. The goal is to prove that each module satis.es \nits The research was supported in part by DARPA Contract F30602-98-1-0237, NSF Grant IIS-98-02066, and \nNTT. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n03, January 15 17, 2003, New Orleans, Louisiana, USA. Copyright 2003 ACM 1-58113-628-5/03/0001 ...$5.00 \n speci.cation, using only the speci.cations but not code of other modules. This way the complexity of \nthe proof e.ort (formal or informal) can be kept under control. This local reasoning approach is sound \nif separate veri.ca\u00adtion of individual modules su.ces to ensure the correctness of the composite program \n[43, 28]. The key to sound lo\u00adcal reasoning in object-oriented languages is object encap\u00adsulation. Consider, \nfor example, a Stack object s that is implemented using a linked list. Local reasoning about the correctness \nof the Stack implementation is possible if objects outside s do not directly access the list nodes, i.e., \nthe list nodes are encapsulated within the s. This paper presents a variant of ownership types for spec\u00adifying \nand statically enforcing object encapsulation. With ownership types, a program can declare that s owns \nall the list nodes. The type system then statically ensures that the list nodes are encapsulated within \ns. A type system that enforces strict object encapsulation, how\u00adever, is too constraining [55]: it does \nnot allow e.cient im\u00adplementation of important constructs like iterators [48, 32]. Consider, for example, \nan iterator over the above-mentioned Stack object s. If the iterator is encapsulated within s, it cannot \nbe used outside s. If the iterator is not encapsulated within s, it cannot directly access the list nodes \nin s, and hence cannot run e.ciently. Previous ownership type systems were either too constrain\u00ading to \nsupport constructs like iterators [22, 21], or too per\u00admissive to support local reasoning [20, 14, 11]; \nfor example they allowed objects outside the above-mentioned Stack ob\u00adject s to temporarily get direct \naccess to the list nodes. This paper argues that the right way to solve the problem is to provide special \naccess privileges to objects belonging to classes in the same module; we show how to do this for inner \nclasses [50, 38]. Our variant of ownership types allows inner class objects to have privileged access \nto the representations of the corresponding outer class objects. This principled vi\u00adolation of encapsulation \nallows programmers to express con\u00adstructs like iterators using inner classes, yet supports local reasoning \nabout the correctness of the classes. Our system supports local reasoning because a class and its inner \nclasses can be reasoned about together as a module. The paper also describes how our variant of ownership \ntypes enables e.cient software upgrades in persistent object stores. Our interest in software upgrades \nled us to work on owner\u00adship types. The paper shows how our ownership types can be used to ensure that \ncode for upgrading objects does not observe broken invariants or interfaces unknown at the time it was \nwritten; this makes it possible for programmers to reason about the correctness of their upgrades. This \npaper is organized as follows. Section 2 discusses object encapsulation. Section 3 describes our variant \nof ownership types for enforcing object encapsulation. Section 4 presents a formal description of the \ntype system. Section 5 shows how ownership types can be used to enable modular upgrades. Section 6 discusses \nrelated work and Section 7 concludes.  2 Object Encapsulation Object encapsulation is important because \nit provides the ability to reason locally about program correctness. Rea\u00adsoning about a class in an object-oriented \nprogram involves reasoning about the behavior of objects belonging to the class. Typically objects point \nto other subobjects, which are used to represent the containing object. Local reasoning about class correctness \nis possible if the sub\u00adobjects are fully encapsulated, that is, if all subobjects are accessible only \nwithin the containing object. This condi\u00adtion supports local reasoning because it ensures that outside \nobjects cannot interact with the subobjects without calling methods of the containing object. And therefore \nthe con\u00adtaining object is in control of its subobjects. However, full encapsulation is often more than \nis needed. Encapsulation is only required for subobjects that the con\u00adtaining object depends on [43, \n28]: D1. An object x depends on subobject y if x calls meth\u00adods of y and furthermore these calls expose \nmutable behavior of y in a way that a.ects the invariants of x. Thus, a Stack object s implemented using \na linked list de\u00adpends on the list but not on the items contained in the list. If code outside could \nmanipulate the list, it could invalidate the correctness of the Stack implementation. But code out\u00adside \ncan safely use the items contained in s because s doesn t call their methods; it only depends on the \nidentities of the items and the identities never change. Similarly, a Set of immutable elements does \nnot depend on the elements even if it invokes a.equals(b) to ensure that no two elements a and b in the \nSet are equal, because the elements are immutable. Local reasoning about a class is possible if objects \nof that class encapsulate every object they depend on. But strict object encapsulation is too constraining \n[55]: it prevents ef\u00ad.cient implementation of important constructs like iterators. For example, to run \ne.ciently, an iterator over the above\u00admentioned Stack object s needs access to the list nodes in s. To \nprovide this access, we have to allow objects like iterators to violate encapsulation. Local reasoning \nis still possible provided all violations of en\u00adcapsulation are limited to code contained in the same \nmod\u00adule. For example, if both the Stack and its iterator are imple- Figure 2: An Ownership Relation \nmented in the same module, we can still reason about their correctness locally, by examining the code \nof that module. 3 Ownership Types for Encapsulation Ownership types [22, 20, 14, 11] provide a statically \nenforce\u00adable way of specifying object encapsulation. The idea is that an object can own subobjects it \ndepends on, thus pre\u00adventing them from being accessible outside. This section presents our ownership \ntype system. This system is similar to the one described in [20] the di.erence is that to sup\u00adport constructs \nlike iterators, the type system in [20] allows temporary violations of encapsulation. We disallow this \nvi\u00adolation. Instead, we support constructs like iterators using inner classes. The key to the type system \nis the concept of object owner\u00adship. Every object has an owner. The owner can either be another object \nor a special owner called world. Our type sys\u00adtem statically guarantees the ownership properties shown \nin Figure 1. Figure 2 presents an example ownership relation. We draw an arrow from x to y if x owns \ny. In the .gure, the special owner world owns objects o1, o5, and o6; o1 owns o2 and o4; o2 owns o3; \nand o6 owns o7. Ownership allows a program to statically declare encapsula\u00adtion boundaries that capture \ndependencies: D2. An object should own all the objects it depends on. The system then enforces encapsulation: \nif y is inside the encapsulation boundary of z and x is outside, then x cannot access y. (An object x \naccesses an object y if x has a pointer to y, or methods of x obtain a pointer to y.) In Figure 2, o7 \nis inside the encapsulation boundary of o6 and o1 is outside, so o1 cannot access o7. An object is only \nallowed to access: 1) itself and objects it owns, 2) its ancestors in the ownership tree and objects \nthey own, and 3) globally accessible objects, namely objects owned by world. 1 Thus, o1 can access all \nobjects in the .gure except for o3 and o7. 1Note the analogy with nested procedures: proc P1 {var x2; \n1 2= 3 4 5= 6 7= 8 9 10 == 11 == 12 13 14 15 16 17 18 19 20 == 21 22 23 24 25 26 27 28 29 30 = 31 = \n32 = 33 = 34 Figure 4: Ownership Relation for TStacks s1, s2, s3 3.1 Owner Polymorphism We present our \ntype system in the context of a Java-like language augmented with ownership types. Every class def\u00adinition \nis parameterized with one or more owners. The .rst owner parameter is special: it identi.es the owner \nof the corresponding object. The other owner parameters are used to propagate ownership information. \nParameterization al\u00adlows programmers to implement a generic class whose ob\u00adjects have di.erent owners. \nThis parameterization is similar to parametric polymorphism [54, 16, 1, 61] except that our parameters \nare owners, not types. An owner can be instantiated with this, with world, or with another owner parameter. \nObjects owned by this are en\u00adcapsulated objects that cannot be accessed from outside. Objects owned by \nworld can be accessed from anywhere. proc P2 {var x3; proc P3 {...}}}. Say xn+1 and Pn+1 are children \nof Pn.Pn can only access: 1) Pn and its children, 2) the ancestors of Pn and their children, and 3) global \nvariables and procedures. 1 class C<cOwner, sOwner, tOwner> where (sOwner <= tOwner) { 2 ... 3 TStack<sOwner, \ntOwner> s; 4} Figure 5: Using Where Clauses to Constrain Owners Figure 3 shows an example.2 A TStack \nis a stack of T ob\u00adjects. It is implemented using a linked list. The TStack class is parameterized by \nstackOwner and TOwner. stack-Owner owns the TStack object; TOwner owns the T objects contained in the \nTStack. The code speci.es that the TStack object owns the nodes in the list; therefore the list nodes \ncannot be accessed from outside the TStack object. The type of TStack s1 is instantiated using this for \nboth the owner parameters. This means that TStack s1 is owned by the TStackClient object that created \nit and so are the T objects in s1. TStack s2 is owned by the TStackClient object, but the T objects in \ns2 are owned by world. TStack s3 is owned by world and so are the T objects in s3. The ownership relation \nfor s1, s2, and s3 is depicted in Figure 4 (assuming the stacks contain two elements each). (The dotted \nline indicates that every object is directly or indirectly owned by world.) 3.2 Constraints on Owners \nFor every type T (x1, ..., xn) with multiple owners, our type system statically enforces the constraint \nthat (x1 -xi) for all i .{1..n}. Recall from Figure 1 that the ownership relation forms a tree rooted \nat world. The notation (y -z) means that y is a descendant of z in the ownership tree. The notation (y \n-z) means that y is either the same as z, or y is a descendant of z in the ownership tree. Thus, the \ntype of TStack s4 in Figure 3 is illegal because (world -this). The above constraint is the same as in \n[20]. However, we extend it to parameterized methods as well. For a method m(xn+1, ..., xk)(...){...} \nof an object of type T (x1, ..., xn), the restriction is that (x1 -xi) for all i .{1..k}. (These con\u00adstraints \nare needed to provide encapsulation in the presence of subtyping. [11] illustrates this point with an \nexample.) To check ownership constraints modularly, it is sometimes necessary for programmers to specify \nadditional constraints on class and method parameters. For example, in Figure 5, the type of s is legal \nonly if (sOwner -tOwner). We al\u00adlow programmers to specify such additional constraints us\u00ading where clauses \n[25, 54], and our type system enforces the constraints. For example, in Figure 5, class C speci.es that \n(sOwner -tOwner). An instantiation of C that does not satisfy the constraint is illegal. 3.3 Subtyping \nThe rule for declaring a subtype is that the .rst owner pa\u00adrameter of the supertype must be the same \nas that of the subtype; in addition, of course, the supertype must satisfy the constraints on owners. \nThe .rst owners have to match 2The example shows type annotations written explicitly. However, many of \nthem can be automatically inferred. See Section 4.3 for details. 1 class TStack<stackOwner, TOwner> { \n2 TNode<this, TOwner> head = null; 3 ... 4 TStackEnum<enumOwner, TOwner> elements<enumOwner>() 5 where \n(enumOwner <= TOwner) { 6 return new TStackEnum<enumOwner, TOwner>(); 7} 8 class TStackEnum<enumOwner, \nTOwner> 9 implements TEnumeration<enumOwner, TOwner> { 10 11 TNode<TStack.this, TOwner> current; 12 \n13 TStackEnum() { current = TStack.this.head; } 14 15 T<TOwner> getNext() { 16 if (current == null) return \nnull; 17 T<TOwner> t = current.value(); 18 current = current.next(); 19 return t; 20 } 21 boolean hasMoreElements() \n{ 22 return (current != null); 23 } 24 } 25 } 26 27 class TStackClient<clientOwner> { 28 void test() \n{ 29 TStack<this, world> s = new TStack<this, world>(); 30 TEnumeration<this, world> e1 = s.elements(); \n31 TEnumeration<world, world> e2 = s.elements(); 32 }} 33 34 interface TEnumeration<enumOwner, TOwner> \n{ 35 T<TOwner> getNext(); 36 boolean hasMoreElements(); 37 } Figure 6: TStack With Iterator because \nthey are special, in that they own the correspond\u00ading objects. Thus, TStack(stackOwner, TOwner) is a \nsubtype of Object(stackOwner). But T(TOwner) is not a subtype of Object(world) because the .rst owners \ndo not match.  3.4 Inner Classes Our inner classes are similar to the member inner classes in Java. \nInner class de.nitions are nested inside other classes. Figure 6 shows an example. The inner class TStackEnum \nimplements an iterator for TStack; the elements method of TStack provides a way to create an iterator \nover the TStack. The TStack code is otherwise similar to that in Figure 3. Recall from before that an \nowner can be instantiated with this, with world, or with another owner parameter. Within an inner class, \nan owner can also be instantiated with C.this, where C is an outer class. This feature allows an inner \nobject to access the objects encapsulated within its outer objects. In Figure 6, the owner of the current \n.eld inTStackEnum is instantiated with TStack.this. The current .eld accesses list nodes encapsulated \nwithin its outer TStack object. An inner class is parameterized with owners just like a reg\u00adular class. \nIn our system, the outer class parameters are not automatically visible inside an inner class. If an \ninner class uses an outer class parameter, it must explicitly include the outer class parameter in its \ndeclaration. In Figure 6, the TStackEnum declaration includes the owner parameter TOwner from its outer \nclass. TOwner is therefore visible inside TStackEnum. But the TStackEnum declaration does 1 class TStack<stackOwner, \nTOwner> { 2 TNode<this, TOwner> head = null; 3 ... 4 class TStackEnum<enumOwner, TOwner> 5 implements \nTEnumeration<enumOwner, TOwner> { 6 7 TNode<TStack.this, TOwner> current; 8 ... 9 T<TOwner> getNext() \nwrites(this) reads(TStack.this){...}  10 boolean hasMoreElements() reads(this){...} 11 } 12 } 13 14 \ninterface TEnumeration<enumOwner, TOwner> { 15 T<TOwner> getNext() writes(this) reads(world); 16 boolean \nhasMoreElements() reads(this); 17 } Figure 7: TStack Iterator With E.ects not include stackOwner. Therefore, \nstackOwner is not visible inside TStackEnum. Note that in this example, the elements method is parame\u00adterized \nby enumOwner. This allows a program to create dif\u00adferent iterators that have di.erent owners. elements \nreturns an iterator of type TStackEnum(enumOwner, TOwner). For this type to be legal, it must be the \ncase that (enumOwner -TOwner). This requirement is captured in the where clause. Note also that TStack(stackOwner, \nTOwner).TStackEnum\u00ad(enumOwner, TOwner) is declared to be a subtype of TEnu\u00admeration(enumOwner, TOwner). \nThis allows TStackClient to create an unencapsulated iterator e2 over an encapsulated TStack s; the program \ncan then pass e2 to objects outside the TStackClient. In general, inner classes can be used to im\u00adplement \nwrappers [32] that expose a limited interface to an outer object. A program can then create a wrapper \naround an encapsulated subobject, and pass the wrapper object out\u00adside the encapsulation boundary. 3.5 \nEncapsulation Theorem Our system provides the following encapsulation property: Theorem 1. x can access \nan object owned by o only if: 1. (x -o), or 2. x is an inner class object of o.  Proof. Consider the \ncode: class C(f, ...){... T (o, ...) y ...}. Variable y of type T (o, ...) is declared within the static \nscope of class C. Owner o can therefore be either 1) this, or 2) world, or 3) a formal class parameter, \nor 4) a formal method parameter, or 5) C. .this, where C. is an outer class. We will show that in the \n.rst four cases, the constraint (this -o) holds. In the .rst two cases, the constraint holds trivially. \nIn the last two cases, (f -o) and (this -f), so the constraint holds. In the .fth case, (C. .this = o). \nTherefore an object x of a class C can access an object y owned by o only if either 1) (x -o), as in \nthe .rst four cases, or 2) x is an inner object of o, as in the .fth case. 1 class IntVector<vOwner> \n{ 2 int elementCount = 0; 3 int size() reads (this) { return elementCount; } 4 void add(int x) writes(this) \n{ elementCount++; ... } 5 ... 6} 7 8 class IntStack<sOwner> { 9 IntVector<this> vec = new IntVector<this>(); \n10 void push(int x) writes (this) { vec.add(x); } 11 ... 12 } 13 14 void m<sO,vO> (IntStack<sO> s, IntVector<vO> \nv) 15 writes (s) reads (v) where !(v <= s) !(s <= v) { 16 17 int n = v.size(); s.push(3); assert(n == \nv.size()); 18 } Figure 8: Reasoning About Aliasing and Side E.ects  3.6 Discussion Our variant of ownership \ntypes supports local reasoning pro\u00advided the programmer declares that all depended-on objects are owned. \nThe above theorem implies that owned objects can only be accessed from inside the owner, and by inner \nob\u00adjects. Therefore if ownership captures the depends relation described in Section 2, local reasoning \nabout the correctness of a class is possible, because the class and its inner classes together can be \nreasoned about as a module. Our ownership types are also expressive. They allow e.\u00adcient implementation \nof constructs like iterators and wrap\u00adpers [32]. Furthermore, they also allow programs to create wrappers \nthat can be used in contexts where the underlying object is inaccessible. This ability was illustrated \nin Figure 6; iterator e2 can be used globally even though the TStack it is iterating over can only be \nused in TStackClient. Ours is the .rst ownership type system to support constructs like iterators and \ngenerally accessible wrappers while also en\u00adsuring local reasoning. We discuss this further in Section \n6.  3.7 E.ects Clauses Our system also contains e.ects clauses [49] because they are useful for specifying \nassumptions that hold at method boundaries and enable modular reasoning and checking of programs. We \nuse e.ects with ownership types to enable modular upgrades; we describe this in Section 5. Our system \nallows programmers to specify reads and writes clauses. Consider a method that speci.es that it writes \n(w1, ..., wn) and reads (r1, ..., rm). The method can write an object x (or call methods that write x) \nonly if (x -wi) for some i .{1..n}. The method can read an object y (or call methods that read y) only \nif (y -wi) or (y -rj ), for some i .{1..n}, j .{1..m}. We thus allow a method to both read and write \nobjects named in its writes clause. Figure 7 shows a TStack iterator that uses e.ects, but is otherwise \nsimilar to the TStack iterator in Figure 6. In the example, the hasMoreElements method reads the this \nobject. The getNext method reads objects owned by TStack.this and writes (and reads) the this object. \nP ::= defn* e defn ::= class cn(formal+) extends c where constr* body body ::= {innerclass* .eld* meth*} \nc ::= cn(owner+)| Object(owner+)| c.cn(owner+) owner ::= formal | world | cn.this constr ::= (owner : \nowner) | (owner : owner) innerclass ::= defn meth ::= t mn(formal*)(arg*) e.ects where constr* {e} e.ects \n::= reads (owner*) writes (owner*) .eld ::= t fd arg ::= tx t ::= c | int formal ::= f e ::= new c | \nx.new c | x | let (arg=e) in {e}| x.fd | x.fd = y | x.mn(owner* )(y*) cn . class names fd . .eld names \nmn . method names x,y . variable names f . owner names Figure 9: Grammar When e.ects clauses are used \nin conjunction with subtyping, the e.ects of an overridden method must subsume the e.ects of the overriding \nmethod. This sometimes makes it di.cult to specify precisely all the e.ects of a method. For example, \nit is di.cult to specify precisely all the read e.ects in the getNext method of the TEnumeration class \nbecause TEnumer\u00adation is expected to be a supertype of subtypes like TStack-Enum and TEnumeration cannot \nname the speci.c objects used in the getNext methods of these subtypes. To accom\u00admodate such cases, we \nallow an escape mechanism, where a method can include world in its e.ects clauses. Ownership types and \ne.ects can be used to locally reason about the side e.ects of method calls. Consider, for example, the \ncode in Figure 8, which shows an IntStack implemented using an IntVector vec. (We adopted this example \nfrom [44].) The example has a method m that receives two arguments: an IntStack s and an IntVector v. \nThe condition in the assert statement in m can be true only if v is not aliased to s.vec. In the example, \nthe method m uses a where clause to specify that (v -s) and (s -v). Since the ownership relation forms \na tree (see Figure 1), this constraint implies that v cannot be aliased to s.vec. Furthermore, IntVector.size \ndeclares that it only reads objects owned by the IntVector, and IntStack.push declares that it only writes \n(and reads) objects owned by the IntStack. Therefore, it is possible to reason locally that v.size and \ns.push cannot interfere, and thus the condition in the assert statement in m must be true.  4 The Type \nSystem This section presents a formal description of our type system. To simplify the presentation of \nkey ideas, we describe our type system in the context of a core subset of Java [33] known as Classic \nJava [31]. We add inner classes to Classic Java and augment its type system with ownership types. Our \napproach, however, extends to the whole of Java and other similar languages. 4.1 Type Checking Figure \n9 presents our grammar. The core of our type system is a set of rules for reasoning about the typing \njudgment: f P : t [PROG] WFClasses(P) FieldsOnce(P) P = defn1..n e P ; E f constr P f defn . c [CLASS] \ndef def ClassOnce(P) IClassOnce(P) OFields(c.cn(f1..n))= c.cn(f1..n) cn.this, OFields(c) OFields(\u00d8)= \n\u00d8 MethodsOnce(P) OverridesOK(P) E = OFields(c.cn(f1..n)), owner f1..n, constr* P ; E f wf ' P f defni \n.\u00d8 P ; \u00d8; world; world f e : tP ; E f cP f iclassi . c.cn(f1..n) P ; E f .eldi P ; E f methi f P : t \n' P f class cn(f1..n) extends cwhere constr*{iclass* .eld* meth*} . c [= WORLD] [CONSTR ENV] [= OWNER] \n[= REFL] [= TRANS] P ; E fowner oE = E1, constr, E2 P ; E f e : cn(o1..n) P ; E fowner oP ; E f (o1 : \no2) P ; E f (o2 : o3) P ; E f (o : world) P ; E f constr P ; E f (e : o1) P ; E f (o : o) P ; E f (o1 \n: o3) P ; E f X = Y o P ; E f t P ; E fowner [X = Y ] [OWNER WORLD] [OWNER FORMAL] [OWNER THIS] [TYPE \nINT] [TYPE OBJECT] X = x1..n Y = y1..m .i.{1..n} .j.{1..m} (xi : yj) E = E1, owner f, E2 E = E1, c cn.this, \nE2 P ; E fowner o P ; E f (X : Y ) P ; E fowner world P ; E fowner fP ; E fowner cn.this P ; E f int \nP ; E f Object(o) P ; E f t1 <: t2 [SUBTYPE C] [TYPE C] P f class cn(f1..n)... where constr* ... . cn(f) \nP ; E f cn(o) P ; E fowner oi P ; E f o1 : oi P ; E f constr [o1/f1]..[on/fn] P ; E f cn(o).cn(o1..n) \n ' '(oP ; E f cn(o).cn(o1..n) P ; E f cn(o).cn(o1..n) <: cn'(o').cn'(f1 o*) [o1/f1]..[on/fn] (fij . \nf) . (oij . o) . (fk = fij )=. (ok = oij ) P f class cn(f1..n) extends cn').cn(f1 o*) ... . cn(f) P ; \nE f wf [SUBTYPE REFL] [SUBTYPE TRANS] [ENV \u00d8] [ENV X] [ENV OWNER] [ENV CONSTR] '' P ; E f wf constr \n=(o : o) . constr =(o : o) ' P ; E f t1 <: t2 x ./Dom(E) P ; E f wf P ; E f wf P ; E fowner o, oP ; \nE f tP ; E f t2 <: t3 P ; E f tf ./Dom(E) E' = E, constr P ; E f t<: tP ; E f t1 <: t3 P ; \u00d8f wf P ; \nE, tx f wf P ; E, owner f f wf P f meth . c [METHOD DECLARED] [METHOD INHERITED] P f meth . cn(f).cn(f1..n) \n' P f class cn(f1..n)... {... meth ...}. cP f class cn'(g1..m) extends cn(o).cn(o1..n)... . c ' P f \nmeth . c.cn(f1..n) P f meth [o1/f1]..[on/fn] . c.cn'(g1..m) P f .eld . c [FIELD DECLARED] [FIELD INHERITED] \n P f .eld . cn(f).cn(f1..n) ' P f class cn(f1..n)... {... .eld ...}. cP f class cn'(g1..m) extends cn(o).cn(o1..n)... \n. c ' P f .eld . c.cn(f1..n) P f .eld [o1/f1]..[on/fn] . c.cn'(g1..m) P ; E; R; W f e : t .x,y (P ; \nE' f x : y) . (P ; E' f x : y) P ; E, constr f wf P ; E f method [METHOD] E' = E, owner f1..n, constr*, \narg* P ; E' f wf P ; E'; r*,w*; w*f e : t P ; E f t mn(f1..n)(arg*) reads(r*) writes(w*) where constr* \n{e} P ; E f .eld P ; E f e : t [FIELD] [EXP TYPE] P ; E f t P ; E; world; world f e : t P ; E f tfd \nP ; E f e : t [EXP SUB] [EXP REF] [EXP REF ASSIGN] ' P ; E; R; W f e : tP ; E; R; W f x : cn(o) P f \n(t fd) . cn(f) P ; E; R; W f x : cn(o) P f (t fd) . cn(f) ' P ; E; R; W f t<: tR = R1, r, R2 x : rW \n= W1, w, W2 x : wP ; E; R; W f y : t [o/f] P ; E; R; W f e : tP ; E; R; W f x.fd : t [o/f] P ; E; R; \nW f x.fd = y : t [o/f] [EXP NEW] [EXP X.NEW] [EXP VAR] P ; E f cn(o1..n) P ; E f x : cP ; E f c.cn(o1..n) \nE = E1, tx, E2 P ; E; R; W f new cn(o1..n) : cn(o1..n) P ; E; R; W f x.new cn(o1..n) : c.cn(o1..n) P \n; E; R; W f x : t [EXP LET] [EXP INVOKE] j.1..k P f (t mn(f(n+1)..m)(tj yj ) reads(r1..r) writes(w1..w) \nwhere constr*{e}) . cn(f).cn(f1..n)P ; E; R; W f x : cn(o).cn(o1..n) P ; E; R; W f xj : tj [o1/f1]..[om/fm] \narg = tx P ; E; R; W f e : tP ; E fowner oi P ; E f o1 : oi P ; E f r1..r [o1/f1]..[om/fm] : R '' P \n; E, arg; R; W f e: tP ; E f constr [o1/f1]..[om/fm] P ; E f w1..w [o1/f1]..[om/fm] : W P ; E; R; W f \nlet (arg = e) in {e'} : t)(x1..k): t [o1/f1]..[om/fm] ' P ; E; R; W f x.mn(o(n+1)..m Figure 10: Type \nChecking Rules Judgment Meaning . P : t program P yields type t P . defn . c defn is a well-formed class \nin class c P ; E .owner o o is an owner P ; E . constr constraint constr is satis.ed P ; E . X . Y e.ect \nX is subsumed by e.ect Y P ; E . t t is a well-formed type P ; E . t1 <: t2 t1 is a subtype of t2 P ; \nE . wf typing environment E is well-formed P . .eld . c class c declares/inherits .eld P . meth . c class \nc declares/inherits meth P ; E . .eld .eld is a well-formed .eld P ; E . meth meth is a well-formed method \nP ; E . e : t expression e has type t P ; E; R; W . e : t expression e has type t and read/write e.ects \nof e are subsumed by R/W Figure 11: Typing Judgments  Predicate Meaning WFClasses(P) There are no \ncycles in the class hierarchy ClassOnce(P) No class is declared twice in P IClassesOnce(P) No class contains \ntwo inner classes with same name, either declared or inherited FieldsOnce(P) No class contains two .elds \nwith same name, either declared or inherited MethodsOnce(P) No class contains two methods with same name \nOverridesOK(P) Overriding methods have the same return type and parameter types as the methods being \noverridden. The read and write e.ects of an overriding method must be superseded by those of the overridden \nmethods Figure 12: Predicates Used in Type Checking Rules  P ; E; R; W . e : t. P , the program being \nchecked, is included here to provide information about class de.nitions. E is an environment providing \ntypes for the free variables of e. R and W must subsume the read and write e.ects of e. t is the type \nof e. We de.ne a typing environment as E ::= \u00d8| E, tx | E, t cn.this | E, owner f | E, constr. We de.ne \ne.ects as R, W ::= o1..n. We de.ne the type system using the judgments in Figure 11. We present the rules \nfor these judgments in Figure 10. The rules use a number of predicates that are shown in Figure 12. These \npredicates are based on similar predicates from [31]. For simplicity, we sometimes treat outermost classes \nin our rules as if they were inner classes of class \u00d8. We also sometime use cn(f) to denote cn1(f11..1n1 \n).cn2(f21..2n2 )..cnk(fk1..knk ).  4.2 Soundness of the Type System Our type checking rules ensure that \nfor a program to be well-typed, the program respects the properties described in Figure 1. A complete \nsyntactic proof [63] of type soundness can be constructed by de.ning an operational semantics (by extending \nthe operational semantics of Classic Java [31]) and then proving that well-typed programs do not reach \nan er\u00adror state and that the generalized subject reduction theorem holds for well-typed programs. The \nsubject reduction theo\u00adrem states that the semantic interpretation of a term s type is invariant under \nreduction. The proof is straightforward but tedious, so it is omitted here. 4.3 Type Inference Although \nour type system is explicitly typed in principle, it would be onerous to fully annotate every method \nwith the extra type information. Instead, we can use a combination of inference and well-chosen defaults \nto signi.cantly reduce the number of annotations needed in practice. [14, 11] de\u00adscribe an intraprocedural \ntype inference algorithm and some default types; we can use a similar approach. (In [14, 11], about one \nin thirty lines of code had to be changed to express Java programs in an ownership type system.) We emphasize \nthat this approach to inference is purely intraprocedural and does not infer method signatures or types \nof instance vari\u00adables. Rather, it uses a default completion of partial type speci.cations in those cases \nto minimize the required anno\u00adtations. This approach permits separate compilation.  4.4 Runtime Overhead \nThe system we described is a purely static type system. The ownership relations are used only for compile-time \ntype checking and are not preserved at runtime. Consequently, our programs have no runtime overhead compared \nto regular (Java) programs. In fact, one way to compile and run a pro\u00adgram in our system is to convert \nit into a regular program after type checking, by removing the owner parameters, the constraints on owners, \nand the e.ects clauses. A language like Java, however, is not purely statically-typed. Java allows downcasts \nthat are checked at runtime. Sup\u00adpose an object with declared type Object(o) is downcast to Vector(o,e). \nSince the result of this operation depends on in\u00adformation that is only available at runtime, our type \nchecker cannot verify at compile-time that e is the right owner pa\u00adrameter even if we assume that the \nobject is indeed a Vec\u00adtor. To safely support downcasts, a system has to keep some ownership information \nat runtime. This is similar to keeping runtime information with parameterized types [54, 61]. [10] describes \nhow to do this e.ciently for ownership by keeping runtime information only for objects that can be potentially \ninvolved in downcasts into types with multiple parameters.  5 Upgrades in Persistent Object Stores This \nsection shows how ownership types and e.ects clauses can be used to enable modular reasoning about the \ncorrect\u00adness of upgrades in a persistent object store. The desire to achieve such reasoning was the motivation \nfor our work on ownership types for encapsulation. A persistent object store [46, 5, 9, 17, 18, 29, 56] \ncontains conventional objects similar to what one might .nd in an object-oriented language such as Java. \nApplications access persistent objects within atomic transactions, since this is necessary to ensure \nconsistency for the stored objects; trans\u00adactions allow for concurrent access and they mask failures. \nUpgrades are needed in such a system to improve object implementations, to correct errors, or even to \nchange inter\u00adfaces in the face of changing application requirements; this includes incompatible changes \nto interfaces where the new interface does not support the same methods as the old one. Providing a satisfactory \nsolution for upgrades in persistent object stores has been a long-standing challenge. An upgrade for \na persistent object store is de.ned as a set of class-upgrades, one for each class whose objects need \nto change. A class-upgrade is a triple: (old-class, new-class, TF). It indicates that all objects belonging \nto old-class should be transformed, through the use of the transform function TF provided by the programmer, \ninto objects of new-class. TF takes an old-class object and a newly al\u00adlocated new-class object and initializes \nthe new-class object from the old-class object. The upgrade infrastructure causes the new-class object \nto take over the identity of the old-class object, so that all objects that used to point to the old-class \nobject now point to the new-class object. An upgrade is executed by transforming all objects whose classes \nare being replaced. However, transforms must not interfere with application access to the store, and \nmust be performed e.ciently in both space and time. In addition, they must be done safely so that important \npersistent state is not corrupted. Previous approaches [4, 7, 29, 45, 56, 57] do not provide a satisfactory \nsolution to these challenges; they either stop application access to the database while running the upgrade, \nor they keep copies of the database, or they limit the expressive power of transforms (e.g., transform \nfunctions are not allowed to make method calls). Our system provides an e.cient solution. It performs \nup\u00adgrades lazily. An object is transformed just before an appli\u00adcation accesses it: the application transaction \nis interrupted to run the transform function. The transform runs in its own transaction; when this transaction \ncommits, the appli\u00adcation transaction is resumed. Our system also allows later upgrades to run in parallel \nwith earlier ones. If an object has several pending transforms, they are run one after another, in upgrade \norder. Furthermore, if a transform transaction T encounters an object with a pending transform from an \nearlier upgrade, T is interrupted (just like an application transform) to run the pending transform, \nand continues ex\u00adecution after the pending transform commits. More details can be found in [13, 12, 47]. \n 5.1 Ownership Types for Safe Upgrades Our upgrade system is e.cient and expressive: it does not delay \napplication transactions, avoids the use of versions (copies of objects), and does not limit the expressive \npower of transform functions. But it also needs to support modu\u00adlar reasoning about the correctness of \ntransform functions. This is possible if each transform function encounters only object interfaces and \ninvariants that existed when its up\u00adgrade started, even though in reality the transform func\u00adtion might \nrun much later, after application transactions and other transform transactions. We use our variant of \nownership types to enable modular reasoning about the correctness of transform functions. Our system \nchecks statically whether transform functions satisfy the following constraint, using ownership and e.ects \ndecla\u00adrations (e.ects clauses state what objects TFs access): S1. TF(x) only accesses objects that x \nowns (directly or transitively). Transform functions often satisfy S1 because ownership fre\u00adquently \ncaptures the depends relation discussed in Section 2, and typically transform functions only access the \ndepended\u00adon objects. (We discuss in [13] how we support modular reasoning of transform functions when \nS1 does not hold.) Our implementation also ensures the following: S2. For any object x a.ected by an \nupgrade, x is accessed before any object owned by x. We ensure S2 using two mechanisms. If the owned \nobject is encapsulated within x, the type system guarantees that x is accessed .rst. If the owned object \nis shared with an inner class object of x, our system causes x to be accessed just before the inner class \nobject is .rst used after the upgrade. This latter mechanism is described in more detail in [13]. When \nS1 holds, we can prove that out-or-order processing of transforms does not cause problems. In particular, \nwe can show that: applications do not interfere with transform functions, transform functions of unrelated \nobjects do not interfere with each other, and transform functions of related objects run in a pre-determined \norder (namely an object is transformed before its owned subobjects). (The proofs are given in [13]). \nThus when S1 holds, we can ensure that transform functions encounter the expected interfaces and invariants. \nThis sup\u00adports modular reasoning: each transform function can be reasoned about as extra method of its \nold class.  6 Related Work Euclid [41] is one of the .rst languages that considered the problem of aliasing. \n[37] stressed the need for better treat\u00adment of aliasing in object-oriented programs. Early work on Islands \n[36] and Balloons [3] focused on fully encapsulated objects where all subobjects an object can access \nare not ac\u00adcessible outside the object. Universes [53] also enforces full encapsulation, except for read-only \nreferences. However, full encapsulation signi.cantly limits expressiveness, and is often more than is \nneeded. The work on ESC/Java pointed out that encapsulation is required only for subobjects that the \ncontaining object depends on [43, 28], but ESC/Java was unable to always enforce encapsulation. 6.1 Ownership \nTypes and Encapsulation Ownership types provide a statically enforceable way of spec\u00adifying object encapsulation. \nThey were proposed in [22] and formalized in [21]. These systems enforce strict object en\u00adcapsulation, \nbut do so by signi.cantly limiting expressive\u00adness. They require that a subtype have the same owners \nas a supertype. So TStack(stackOwner, TOwner) cannot be a subtype of Object(stackOwner). Moreover, they \ndo not support iterators. PRFJ [14], SCJ [11], and JOE [20] extended ownership types to support a natural \nform of subtyping. To do so without violating encapsulation, JOE introduces the constraint that in every \ntype with multiple owners, the .rst owner -all other owners. As a result, in JOE, a program can create \na pointer from object x to an object owned by o only if (x \u00ado). PRFJ and SCJ allow an object to contain \npointers to subobjects owned by a di.erent object, but they have e.ects clauses that prevent a program \nfrom following such point\u00aders. The above systems e.ectively enforce encapsulation for object .elds. However, \nto support constructs like iterators, they allow method local variables to violate encapsulation. Therefore \nthey do not support local reasoning. AliasJava [2] uses ownership types to aid program under\u00adstanding. \nLike other ownership type systems, AliasJava al\u00adlows programmers to use ownership information to reason \nabout aliasing. AliasJava is also more .exible than other ownership type systems. However, unlike other \nownership type systems, AliasJava does not enforce any encapsulation properties. (This is illustrated \nwith an example in [11].) Ownership types have been extended to inner classes in [19, 2]. However, these \nsystems do not enforce the property stated in Section 3.5, and do not support local reasoning. Ownership \ntypes have also been used to enforce other prop\u00aderties. Parameterized Race-Free Java (PRFJ) [14] uses \nan ownership based type system to prevent data races in multi\u00adthreaded programs. Safe Concurrent Java \n(SCJ) [11] extends this to prevent both data races and deadlocks. These sys\u00adtems can be combined with \nour approach to enforce object encapsulation as well as prevent data races and deadlocks. [11] sketches \na way of doing this. Recent work [15, 59] combines region types [60, 24, 35] with our type system to \nstatically ensure both object encapsula\u00adtion and safe region-based memory management.  6.2 Related Type \nSystems Linear types [62] and unique pointers [51] can also be used to control object aliasing. Linear \ntypes have been used in low level languages to support safe explicit memory deallo\u00adcation [24] and to \ntrack resource usage [26, 27]. Linear types and unique pointers are orthogonal to ownership types, but \nthe two can be used in conjunction to provide more expres\u00adsive systems. PRFJ [14] is the .rst system \nthat combines ownership types with conventional unique pointers. Recent work [23] proposes a better approach \nthat allows a program to specify a unique external pointer to an object; there can be other internal \npointers to the object from its subobjects. E.ects clauses [49] are useful for specifying assumptions \nthat must hold at method boundaries. E.ects enable modular checking of programs. PRFJ [14] is the .rst \nsystem to com\u00adbine e.ects with ownership types to statically prevent data races. [11] and [20] also combine \ne.ects with ownership for preventing deadlocks and for program understanding. This paper uses e.ects \nwith ownership to enable lazy upgrades. Data groups [42, 44] can be used to name groups of objects in \nan e.ects clause to write modular speci.cations in the pres\u00adence of subtyping. Ownership types provide \nan alternate way of writing modular speci.cations. Ownership types can also be used to name groups of \nobjects in an e.ects clause the name of an owner can be used to name all the objects transitively owned \nby the owner. Figure 8 presents an exam\u00adple from [44] expressed using ownership types. Data groups are \nimplemented using a theorem prover, and in principle, they can be very .exible. However, pivot uniqueness \nin [44] imposes drastic restrictions on pivot .elds. Ownership types do not impose such restrictions; \nthey only require that the owner of an object be unique. In [44], the owner exclusion constraint is hard \ncoded. In our system, programmers can specify arbitrary constraints on owners using where clauses; owner \nexclusion can be used as a default. Systems such as TVLA [58], PALE [52], and Roles [40] spec\u00adify the \nshape of a local object graph in more detail than ownership types. TVLA can verify properties such as \nwhen the input to the program is a tree, the output is also a tree. PALE can verify all the data structures \nthat can be expressed as graph types [39]. Roles can verify global prop\u00aderties such as the participation \nof objects in multiple data structures. Roles also support compositional interprocedural analysis. In \ncontrast to these systems that take exponential time for veri.cation, ownership types provide a lightweight \nand practical way to constrain aliasing.  7 Conclusions Object encapsulation enables sound local reasoning \nabout program correctness in object-oriented languages. Owner\u00adship types provide a way of specifying \nand statically en\u00adforcing object encapsulation. However, a type system that enforces strict object encapsulation \nis too constraining: it does not allow e.cient implementation of important con\u00adstructs like iterators. \nThis paper argues that the right way to solve the problem is to allow objects of classes de.ned in the \nsame module to have privileged access to each other s representations. We show how to do this for inner \nclasses. Our variant of owner\u00adship types allows objects of inner classes to have privileged access to \nthe representations of the corresponding objects of outer classes. This principled violation of encapsulation \nallows programmers to express constructs like iterators and wrappers using inner classes. Our system \nalso allows wrap\u00adpers to be used in more global contexts than the objects they wrap. Yet our system supports \nlocal reasoning about the correctness of classes, because a class and its inner classes can be reasoned \nabout together as a module. Thus the paper describes the .rst ownership type system that is expressive \nenough to support iterators and wrappers, while also supporting local reasoning. In addition, the pa\u00adper \ndescribes an application of the technique to enable mod\u00adular reasoning about upgrades in persistent object \nstores. Ownership types have been used for other purposes as well, such as for preventing data races \nand deadlocks, and for safe region-based memory management. Since ownership types require little programming \noverhead, their type checking is fast and scalable, and they provide several bene.ts, they o.er a promising \napproach to making object-oriented pro\u00adgrams more reliable.  Acknowledgments We thank Daniel Jackson, \nViktor Kuncak, Greg Nelson, Martin Rinard, and Alexandru Salcianu for useful discus\u00adsions and comments \non earlier drafts of this paper.  References [1] O. Agesen, S. N. Freund, and J. C. Mitchell. Adding \ntype parameterization to the Java language. In Object-Oriented Programming, Systems, Languages, and Applications \n(OOPSLA), October 1997. [2] J. Aldrich, V. Kostadinov, and C. Chambers. Alias annotations for program \nunderstanding. In Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), November \n2002. [3] P. S. Almeida. Balloon types: Controlling sharing of state in data types. In European Conference \nfor Object-Oriented Programming (ECOOP), June 1997. [4] M. P. Atkinson, M. A. Dmitriev, C. Hamilton, \nand T. Printezis. Scalable and recoverable implementation of object evolution for the PJama 1 platform. \nIn Persistent Object Systems (POS), September 2000. [5] M. P. Atkinson, M. J. Jordan, L. Daynes, and \nS. Spence. Design issues for persistent Java: A type-safe, object-oriented, orthogonally persistent system. \nIn Persistent Object Systems (POS), May 1996. [6] A. Banerjee and D. A. Naumann. Representation independence, \ncon.nement, and access control. In Principles of Programming Languages (POPL), January 2002. [7] J. \nBanerjee, W. Kim, H. Kim, and H. F. Korth. Semantics and implementation of schema evolution in object-oriented \ndatabases. In ACM SIGMOD International Conference on Management of Data, May 1987. [8] B. Bokowski and \nJ. Vitek. Con.ned types. In Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), \nOctober 1999. [9] C. Boyapati. JPS: A distributed persistent Java system. SM thesis, Massachusetts Institute \nof Technology, September 1998. [10] C. Boyapati, R. Lee, and M. Rinard. Safe runtime downcasts with ownership \ntypes. Technical Report TR-853, MIT Laboratory for Computer Science, June 2002. [11] C. Boyapati, R. \nLee, and M. Rinard. Ownership types for safe programming: Preventing data races and deadlocks. In Object-Oriented \nProgramming, Systems, Languages, and Applications (OOPSLA), November 2002. [12] C. Boyapati, B. Liskov, \nand L. Shrira. Ownership types and safe lazy upgrades in object-oriented databases. Technical Report \nTR-858, MIT Laboratory for Computer Science, July 2002. [13] C. Boyapati, B. Liskov, L. Shrira, C. Moh, \nand S. Richman. Lazy modular upgrades in persistent object stores. Submitted for publication, November \n2002. [14] C. Boyapati and M. Rinard. A parameterized type system for race-free Java programs. In Object-Oriented \nProgramming, Systems, Languages, and Applications (OOPSLA), October 2001. [15] C. Boyapati, A. Salcianu, \nW. Beebee, Jr., and M. Rinard. Ownership types for safe region-based memory management in Real-Time Java. \nSubmitted for publication, November 2002. [16] G. Bracha, M. Odersky, D. Stoutamire, and P. Wadler. Making \nthe future safe for the past: Adding genericity to the Java programming language. In Object-Oriented \nProgramming, Systems, Languages, and Applications (OOPSLA), October 1998. [17] R. Bretl et al. The GemStone \ndata management system. In W. Kim and F. H. Lochovsky, editors, Object-Oriented Concepts, Databases, \nand Applications. 1989. [18] M. J. Carey et al. Shoring up persistent applications. In ACM SIGMOD International \nConference on Management of Data, May 1994. [19] D. G. Clarke. Ownership and containment. PhD thesis, \nUniversity of New South Wales, Australia, July 2001. [20] D. G. Clarke and S. Drossopoulou. Ownership, \nencapsulation and disjointness of type and e.ect. In Object-Oriented Programming, Systems, Languages, \nand Applications (OOPSLA), November 2002. [21] D. G. Clarke, J. Noble, and J. M. Potter. Simple ownership \ntypes for object containment. In European Conference for Object-Oriented Programming (ECOOP), June 2001. \n[22] D. G. Clarke, J. M. Potter, and J. Noble. Ownership types for .exible alias protection. In Object-Oriented \nProgramming, Systems, Languages, and Applications (OOPSLA), October 1998. [23] D. G. Clarke and T. Wrigstad. \nExternal uniqueness. In Workshop on Foundations of Object-Oriented Languages (FOOL), January 2003. [24] \nK. Crary, D. Walker, and G. Morrisett. Typed memory management in a calculus of capabilities. In Principles \nof Programming Languages (POPL), January 1999. [25] M. Day, R. Gruber, B. Liskov, and A. C. Myers. Subtypes \nvs. where clauses: Constraining parametric polymorphism. In Object-Oriented Programming, Systems, Languages, \nand Applications (OOPSLA), October 1995. [26] R. DeLine and M. Fahndrich. Enforcing high-level protocols \nin low-level software. In Programming Language Design and Implementation (PLDI), June 2001. [27] R. DeLine \nand M. Fahndrich. Adoption and focus: Practical linear types for imperative programming. In Programming \nLanguage Design and Implementation (PLDI), June 2002. [28] D. L. Detlefs, K. R. M. Leino, and G. Nelson. \nWrestling with rep exposure. Research Report 156, Compaq Systems Research Center, July 1998. [29] O. \nDeux et al. The story of O2. In IEEE Transactions on Knowledge and Data Engineering (TKDE) 2(1), March \n1990. [30] C. Flanagan and S. N. Freund. Type-based race detection for Java. In Programming Language \nDesign and Implementation (PLDI), June 2000. [31] M. Flatt, S. Krishnamurthi, and M. Felleisen. Classes \nand mixins. In Principles of Programming Languages (POPL), January 1998. [32] E. Gamma, R. Helm, R. Johnson, \nand J. Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, 1995. \n[33] J. Gosling, B. Joy, and G. Steele. The Java Language Speci.cation. Addison-Wesley, 1996. [34] A. \nGreenhouse and J. Boyland. An object-oriented e.ects system. In European Conference for Object-Oriented \nProgramming (ECOOP), June 1999. [35] D. Grossman, G. Morrisett, T. Jim, M. Hicks, Y. Wang, and J. Cheney. \nRegion-based memory management in Cyclone. In Programming Language Design and Implementation (PLDI), \nJune 2001. [36] J. Hogg. Islands: Aliasing protection in object-oriented languages. In Object-Oriented \nProgramming, Systems, Languages, and Applications (OOPSLA), October 1991. [37] J. Hogg, D. Lea, A. Wills, \nand D. de Champeaux. The Geneva convention on the treatment of object aliasing. In OOPS Messenger 3(2), \nApril 1992. [38] JavaSoft. Inner class speci.cation, February 1997. Available at http://java.sun.com/products/JDK/1.1. \n[39] N. Klarlund and M. I. Schwartzbach. Graph types. In Principles of Programming Languages (POPL), \nJanuary 1993. [40] V. Kuncak, P. Lam, and M. Rinard. Role analysis. In Principles of Programming Languages \n(POPL), January 2002. [41] B. W. Lampson, J. J. Horning, R. L. London, J. G. Mitchell, and G. J. Popek. \nReport on the programming language Euclid. In Sigplan Notices, 12(2), February 1977. [42] K. R. M. Leino. \nData groups: Specifying the modi.cation of extended state. In Object-Oriented Programming, Systems, Languages, \nand Applications (OOPSLA), October 1998. [43] K. R. M. Leino and G. Nelson. Data abstraction and information \nhiding. Research Report 160, Compaq Systems Research Center, November 2000. [44] K. R. M. Leino, A. Poetzsch-He.ter, \nand Y. Zhou. Using data groups to specify and check side e.ects. In Programming Language Design and Implementation \n(PLDI), June 2002. [45] B. S. Lerner and A. N. Habermann. Beyond schema evolution to database reorganization. \nIn Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), October 1990. [46] B. \nLiskov, M. Castro, L. Shrira, and A. Adya. Providing persistent objects in distributed systems. In European \nConference for Object-Oriented Programming (ECOOP), June 1999. [47] B. Liskov, C. Moh, S. Richman, L. \nShrira, Y. Cheung, and C. Boyapati. Safe lazy software upgrades in object-oriented databases. Technical \nReport TR-851, MIT Laboratory for Computer Science, June 2002. [48] B. Liskov, A. Snyder, R. R. Atkinson, \nand C. Scha.ert. Abstraction mechanisms in CLU. In Communications of the ACM (CACM) 20(8), August 1977. \n[49] J. M. Lucassen and D. K. Gi.ord. Polymorphic e.ect systems. In Principles of Programming Languages \n(POPL), January 1988. [50] O. L. Madsen, B. Moller-Pedersen, and K. Nygaard. Object-Oriented Programming \nin the Beta Programming Language. Addison-Wesley, 1993. [51] N. Minsky. Towards alias-free pointers. \nIn European Conference for Object-Oriented Programming (ECOOP), July 1996. [52] A. Moeller and M. I. \nSchwartzbach. The pointer assertion logic engine. In Programming Language Design and Implementation (PLDI), \nJune 2001. [53] P. Muller and A. Poetzsch-He.ter. Universes: A type system for controlling representation \nexposure. In A. Poetzsch-He.ter and J. Meyer, editors, Programming Languages and Fundamentals of Programming. \n1999. [54] A. C. Myers, J. A. Bank, and B. Liskov. Parameterized types for Java. In Principles of Programming \nLanguages (POPL), January 1997. [55] J. Noble. Iterators and encapsulation. In Technology of Object-Oriented \nLanguages and Systems (TOOLS), June 2000. [56] Object Design Inc. ObjectStore Advanced C++ API User Guide \nRelease 5.1, 1997. [57] D. J. Penney and J. Stein. Class modi.cation in the GemStone object-oriented \nDBMS. In Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), October 1987. [58] \nM. Sagiv, T. Reps, and R. Wilhelm. Solving shape-analysis problems in languages with destructive updating. \nTransactions on Programming Languages and Systems (TOPLAS) 20(1), January 1998. [59] A. Salcianu, C. \nBoyapati, W. Beebee, Jr., and M. Rinard. A type system for safe region-based memory management in Real-Time \nJava. Technical Report TR-869, MIT Laboratory for Computer Science, November 2002. [60] M. Tofte and \nJ. Talpin. Region-based memory management. In Information and Computation 132(2), February 1997. [61] \nM. Viroli and A. Natali. Parametric polymorphism in Java: An approach to translation based on re.ective \nfeatures. In Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), October 2000. \n[62] P. Wadler. Linear types can change the world. In M. Broy and C. Jones, editors, Programming Concepts \nand Methods. 1990. [63] A. K. Wright and M. Felleisen. A syntactic approach to type soundness. In Information \nand Computation 115(1), November 1994. \n\t\t\t", "proc_id": "604131", "abstract": "Ownership types provide a statically enforceable way of specifying object encapsulation and enable local reasoning about program correctness in object-oriented languages. However, a type system that enforces strict object encapsulation is too constraining: it does not allow efficient implementation of important constructs like iterators. This paper argues that the right way to solve the problem is to allow objects of classes defined in the same module to have privileged access to each other's representations; we show how to do this for inner classes. This approach allows programmers to express constructs like iterators and yet supports local reasoning about the correctness of the classes, because a class and its inner classes together can be reasoned about as a module. The paper also sketches how we use our variant of ownership types to enable efficient software upgrades in persistent object stores.", "authors": [{"name": "Chandrasekhar Boyapati", "author_profile_id": "81319488571", "affiliation": "Massachusetts Intitute of Technology, Cambridge, MA", "person_id": "PP42052098", "email_address": "", "orcid_id": ""}, {"name": "Barbara Liskov", "author_profile_id": "81100323833", "affiliation": "Massachusetts Intitute of Technology, Cambridge, MA", "person_id": "PP39037707", "email_address": "", "orcid_id": ""}, {"name": "Liuba Shrira", "author_profile_id": "81100088703", "affiliation": "Brandeis University, Waltham, MA", "person_id": "P172676", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/604131.604156", "year": "2003", "article_id": "604156", "conference": "POPL", "title": "Ownership types for object encapsulation", "url": "http://dl.acm.org/citation.cfm?id=604156"}