{"article_publication_date": "01-15-2003", "fulltext": "\n A Type System for Higher-Order Modules* Derek Dreyer Karl Crary Robert Harper School of Computer Science \nCarnegie Mellon University Pittsburgh, PA 15213 {dreyer,crary,rwh}@cs.cmu.edu Abstract We present a \ntype theory for higher-order modules that accounts for many central issues in module system design, including \ntranslu\u00adcency, applicativity, generativity, and modules as .rst-class values. Our type system harmonizes \ndesign elements from previous work, resulting in a simple, economical account of modular programming. \nThe main unifying principle is the treatment of abstraction mecha\u00adnisms as computational effects. Our \nlanguage is the .rst to provide a complete and practical formalization of all of these critical issues \nin module system design. Categories and Subject Descriptors D.3.1 [Programming Languages]: Formal De.nitions \nand The\u00adory; D.3.3 [Programming Languages]: Language Constructs and Features Abstract data types, Modules; \nF.3.3 [Logics and Mean\u00adings of Programs]: Studies of Program Constructs Type structure General Terms \nLanguages, Theory  Keywords Type theory, modularity, computational effects, abstract data types, functors, \ngenerativity, singleton types 1 Introduction The design of languages for modular programming is surprisingly \ndelicate and complex. There is a fundamental tension between *The ConCert Project is supported by the \nNational Science Foundation under grant number 0121633: ITR/SY+SI: Language Technology for Trustless \nSoftware Dissemination . the desire to separate program components into relatively indepen\u00addent parts \nand the need to integrate these parts to form a coher\u00adent whole. To some extent the design of modularity \nmechanisms is independent of the underlying language [17], but to a large ex\u00adtent the two are inseparable. \nFor example, languages with poly\u00admorphism, generics, or type abstraction require far more complex module \nmechanisms than those without them. Much work has been devoted to the design of modular program\u00adming \nlanguages. Early work on CLU [19] and the Modula family of languages [34, 2] has been particularly in.uential. \nMuch effort has gone into the design of modular programming mechanisms for the ML family of languages, \nnotably Standard ML [23] and Ob\u00adjective Caml [27]. Numerous extensions and variations of these designs \nhave been considered in the literature [21, 18, 28, 31, 5]. Despite (or perhaps because of) these substantial \nefforts, the .eld has remained somewhat fragmented, with no clear unifying theory of modularity having \nyet emerged. Several competing designs have been proposed, often seemingly at odds with one another. \nThese decisions are as often motivated by pragmatic considerations, such as engineering a useful implementation, \nas by more fundamental considerations, such as the semantics of type abstraction. The rela\u00adtionship between \nthese design decisions is not completely clear, nor is there a clear account of the trade-offs between \nthem, or whether they can be coherently combined into a single design. The goal of this paper is to provide \na simple, uni.ed formalism for modular programming that consolidates and elucidates much of the work \nmentioned above. Building on a substantial and growing body of work on type-theoretic accounts of language \nstructure, we propose a type theory for higher-order program modules that har\u00admonizes and enriches these \ndesigns and that would be suitable as a foundation for the next generation of modular languages. 1.1 \nDesign Issues Before describing the main technical features of our language, it is useful to review some \nof the central issues in the design of module systems for ML. These issues extend to any language of \nsimilar expressive power, though some of the trade-offs may be different for different languages. Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 03, January \n15 17, 2003, New Orleans, Louisiana, USA. Copyright 2003 ACM 1-58113-628-5/03/0001 ...$5.00 Controlled \nAbstraction Modularity is achieved by using signa\u00adtures (interfaces) to mediate access between program \ncomponents. The role of a signature is to allow the programmer to hide type information selectively. \nThe mechanism for controlling type prop\u00adagation is translucency [11, 14], with transparency and opacity \nas limiting cases. Phase Separation ML-like module systems enjoy a phase sep\u00adaration property [12] stating \nthat every module is separable into a static part, consisting of type information, and a dynamic part, \ncon\u00adsisting of executable code. To obtain fully expressive higher-order modules and to support abstraction, \nit is essential to build this phase separation principle into the de.nition of type equivalence. Generativity \nMacQueen coined the term generativity for the creation of new types corresponding to run-time instances \nof an abstraction. For example, we may wish to de.ne a functor SymbolTable that, given some parameters, \ncreates a new symbol table. It is natural for the symbol table module to export an abstract type of symbols \nthat are dynamically created by insertion and used for subsequent retrieval. To preclude using the symbols \nfrom one symbol table to index another, generativity is essential each in\u00adstance of the hash table must \nyield a new symbol type, distinct from all others, even when applied twice to the same parameters. Separate \nCompilation One goal of module system design is to support separate compilation [14]. This is achieved \nby ensuring that all interactions among modules are mediated by interfaces that capture all of the information \nknown to the clients of separately\u00adcompiled modules. Principal Signatures The principal, or most expressive, \nsigna\u00adture for a module captures all that is known about that module dur\u00ading type checking. It may be \nused as a proxy for that module for purposes of separate compilation. Many type checking algorithms, \nincluding the one given in this paper, compute principal signatures for modules. Modules as First-Class \nValues Modules in ML are second\u00adclass in the sense that they cannot be computed as the results of ordinary \nrun-time computation. It can be useful to treat a mod\u00adule as a .rst-class value that can be stored into \na data structure, or passed as an ordinary function argument or result [11, 24]. Hidden Types Introducing \na local, or hidden , abstract type within a scope requires that the types of the externally visible com\u00adponents \navoid mention of the abstract type. This avoidance problem is often a stumbling block for module system \ndesign, since in most expressive languages there is no best way to avoid a type vari\u00adable [9, 18]. 1.2 \nA Type System for Modules The type system proposed here takes into account all of these design issues. \nIt consolidates and harmonizes design elements that were previously seen as disparate into a single framework. \nFor example, rather than regard generativity of abstract types as an alternative to non-generative types, \nwe make both mechanisms available in the language. We support both generative and applicative functors, \nad\u00admit translucent signatures, support separate compilation, and are able to accommodate modules as .rst-class \nvalues [24, 29]. Generality is achieved not by a simple accumulation of features, but rather by isolating \na few key mechanisms that, when com\u00adbined, yield a .exible, expressive, and implementable type system \nfor modules. Speci.cally, the following mechanisms are crucial. Singletons Propagation of type sharing \nis handled by singleton signatures, a variant of Aspinall s and Stone and Harper s singleton kinds [33, \n32, 1]. Singletons provide a simple, orthogonal treat\u00adment of sharing that captures the full equational \ntheory of types in a higher-order module system with subtyping. No previous module system has provided \nboth abstraction and the full equational the\u00adory supported by singletons,1 and consequently none has \nprovided optimal propagation of type information. Static Module Equivalence The semantics of singleton \nsigna\u00adtures is dependent on a (compile-time) notion of equivalence of modules. To ensure that the phase \ndistinction is respected, we de.ne module equivalence to mean equivalence of static compo\u00adnents, ignoring \nall run-time aspects. Subtyping Signature subtyping is used to model forgetting type sharing, an essential \npart of signature matching. The coercive aspects of signature matching (dropping of .elds and specialization \nof polymorphic values) are omitted here, since the required coer\u00adcions are de.nable in the language. \nPurity and Impurity Our type system classi.es module expres\u00adsions into pure (effect-free) and impure \n(effectful) forms. To ensure proper enforcement of abstraction, impure modules are incompa\u00adrable (may \nnot be compared for equality with any other module) and non-projectible (may not have type components \nprojected from them). It follows that impure modules are also non-substitutable (may not be substituted \nfor a module variable in a signature). Abstraction and Sealing Modules that are sealed with a signa\u00adture \nto impose type abstraction [11] are regarded as impure. In other words, sealing is regarded as a pro \nforma computational effect. This is consistent with the informal idea that generativity involves the \ngeneration of new types at run time. Moreover, this ensures that sealed modules are incomparable and \nnon-projectible, which is suf\u00ad.cient to ensure the proper semantics of type abstraction. Totality and \nPartiality Functors are .-abstractions at the level of modules. A functor whose body is pure is said \nto be total; otherwise it is partial. It follows that the application of a pure, total functor to a pure \nargument is pure, whereas the application of a pure, partial functor to a pure argument is impure. Partial \nfunctors are naturally generative, meaning that the abstract types in its result are new for each instance; \ntotal functors are applicative, meaning that equal arguments yield equal types in the result. Generative \nfunctors are obtained without resort to generative stamps [23, 21]. Weak and Strong Sealing Since sealing \ninduces a compu\u00adtational effect, only partial functors may contain sealed sub\u00adstructures; this signi.cantly \nweakens the utility of total functors. To overcome this limitation we distinguish two forms of effect, \nstatic and dynamic, and two forms of sealing, weak and strong. Weak sealing induces a static effect, \nwhich we think of as occur\u00adring once during type checking; strong sealing induces a dynamic effect, which \nwe think of as occurring during execution. Dynamic effects induce partiality, static effects preserve \ntotality. Existential Signatures In a manner similar to Shao [31], our type system is carefully crafted \nto circumvent the avoidance prob\u00adlem, so that every module enjoys a principal signature. However, this \nrequires imposing restrictions on the programmer. To lift these restrictions, we propose the use of existential \nsignatures to provide principal signatures where none would otherwise exist. We show that these existential \nsignatures are type-theoretically ill-behaved in 1Typically the omitted equations are not missed because \nrestric\u00adtions to named form or valuability prevent programmers from writ\u00ading code whose typeability would \ndepend on those equations in the .rst place [4]. types t ::= Typ M |.s:s.t |t1 \u00d7t2 terms e ::= Val M \n|(e1,e2)|pie |eM |.x f ( s:s) :t.e |let s = M in ( e : t) signatures s ::= 1 |[[ T ]] |[[ t]] |.tots:s1.s2 \n|.pars:s1.s2 |Ss:s1.s2 |.( M) modules M ::= s |()|[ t] |[ e : t] |.s:s.M |M1M2 |(s = M1,M2)|piM |let \ns = M1 in ( M2: s) |M :> s |M :: s contexts G ::= |G, s:s Figure 1. Syntax general, so, we restrict their \nuse to a well-behaved setting. In the style of Harper and Stone [13], we propose the use of an elaboration \nalgorithm from an external language that may incur the avoidance problem, into our type system, which \ndoes not. Packaged Modules Modules in our system are second-class in the sense that the language of modules \nis separate from the language of terms. However, following Mitchell et al. [24] and Russo [29], we provide \na way of packaging a module as a .rst-class value. In prior work, such packaged modules are typically \ngiven an existen\u00adtial type, whose closed-scope elimination construct can make for awkward programming. \nInstead, our account of type generativity allows us to employ a more natural, open-scope elimination \ncon\u00adstruct, whereby unpackaging a packaged module engenders a dy\u00adnamic effect. While these features combine \nnaturally to form a very general lan\u00adguage for modular programming, they would be of little use in the \nabsence of a practical implementation strategy. Some previ\u00adous attempts have encountered dif.culties \nwith undecidability [11] or incompleteness of type checking [27]. In contrast, our formalism leads to \na practical, implementable programming language. The rest of this paper is structured as follows: In \nSection 2 we present our core type system for higher-order modules, including the intuition behind its \ndesign and a brief description of the de\u00adcidable typechecking algorithm. In Section 3 we discuss the \npro\u00adgramming importance of having both weak and strong forms of sealing. In Section 4 we explain the \navoidance problem and how it can be circumvented using an elaboration algorithm. In Section 5 we present \na very simple, orthogonal extension of our core system to provide support for packaging modules as .rst-class \nvalues. Fi\u00adnally, in Section 6 we compare our system with related work and in Section 7 we conclude. \n  2 Technical Development We begin our technical development by presenting the syntax of our language \nin Figure 1. Our language consists of four syntac\u00adtic classes: terms, types, modules, and signatures \n(which serve as the types of modules). The language does not explicitly include higher-order type constructors \nor kinds (which ordinarily serve as constructors types); in our language the roles of constructors and \nkinds are subsumed by modules and signatures. Contexts bind mod\u00adule variables (s) to signatures. As usual, \nwe consider alpha-equivalent expressions to be identical. We write the capture-avoiding substitution \nof M for s in an expres\u00adsion E as E[ M/s] . Types There are three basic types in our language. The product \ntype (t1 \u00d7t2) is standard. The function type, .s:s.t, is the type of functions that accept a module argument \ns of signature s and return a value of type t (possibly containing s). As usual, if s does not appear \nfree in t, we write .s:s.t as s .t. (This convention is used for the dependent products in the signature \nclass as well.) Finally, when M is a module containing exactly one type (which is to say that M has the \nsignature [[ T ]] ), that type is extracted by Typ M.A full-featured language would support a variety \nof additional types as well. Terms The term language contains the natural introduction and elimination \nconstructs for recursive functions and products. In ad\u00addition, when M is a module containing exactly \none value (which is to say that M has the signature [[ t]] , for some type t), that value is extracted \nby Val M. When f does not appear free in e, we write .x f ( s:s) :t.e as .s:s.e. The conventional forms \nof functions and polymorphic function are built from module functions. Ordinary functions are built using \nmodules containing a single value: def t1 .t2 =[[ t1]] .t2 def .x:t.e( x)= .s:[[ t]] .e( Val s) def e1e2 \n= e1[ e2] and polymorphic functions are built using modules containing a sin\u00adgle type: def .a.t( a)= \n.s:[[ T ]] .t( Typ s) def .a.e( a)= .s:[[ T ]] .e( Typ s) def et = e[ t] Signatures There are seven basic \nsignatures in our language. The atomic signature [[ T ]] is the type of an atomic module containing a \nsingle type, and the atomic signature [[ t]] is the type of an atomic module containing a single term. \nThe atomic modules are written [ t] and [ e : t] , respectively. (We omit the type label : t from atomic \nterm modules when it is clear from context.) The trivial atomic signature 1 is the type of the trivial \natomic module (). The functor signatures .tots:s1.s2 and .pars:s1.s2 express the type of functors that \naccept an argument of signature s1 and return a result of signature s2 (possibly containing s). The reason \nfor two different . signatures is to distinguish between total and partial functors, which we discuss \nin detail below. For convenience, we will take . (without a superscript) to be synonymous with .tot . \nWhen s does not appear free in s2, we write .s:s1.s2 as s1 .s2. The structure signature Ss:s1.s2 is the \ntype of a pair of modules where the left-hand component has signature s1 and the right-hand component \nhas signature s2, in which s refers to the left-hand com\u00adponent. As usual, when s does not appear free \nin s2, we write Ss:s1.s2 as s1 \u00d7s2. The singleton signature .( M) is used to express type sharing infor\u00admation. \nIt classi.es modules that have signature [[ T ]] and are stati\u00adcally equivalent to M. Two modules are \nconsidered statically equiv\u00adalent if they are equal modulo term components; that is, type .elds must \nagree but term .elds may differ. Singletons at signatures other than [[ T ]] are not provided primitively \nbecause they can be de.ned using the basic singleton, as described by Stone and Harper [33]. The de.nition \nof .s( M) (the signature containing only modules equal to M at signature s) is given in Figure 5. signature \nSIG = sig type s type t =s* int structure S : sig type u val f:u -> s end val g: t-> S.u end ... iscompiledas... \nSs:[[ T ]] . St:.([ Typ s \u00d7 int]) . SS:( Su:[[ T ]] .S f :[[ Typ u . Typ s]] .1) . Sg:[[ Typ t . Typ \n( p1S)]] .1 Figure 2. ML Signature Example Modules The module syntax contains module variables (s), the \natomic modules, and the usual introduction and elimination con\u00adstructs for . and S signatures, except \nthat S modules are introduced by (s = M1,M2), in which s stands for M1 and may appear free in M2. (When \ns does not appear free in M2, the s = is omitted.) No introduction or elimination constructs are provided \nfor single\u00adton signatures. Singletons are introduced and eliminated by rules in the static semantics; \nif M is judged equivalent to M. in s, then M belongs to .s( M') , and vice versa. The remaining module \nconstructs are strong sealing, written M :> s, and weak sealing, written M :: s. When a module is sealed \neither strongly or weakly, the result is opaque. By opaque we mean that no client of the module may depend \non any details of the imple\u00admentation of M other than what is exposed by the signature s. The distinction \nbetween strong and weak sealing is discussed in detail below. Although higher-order type constructors \ndo not appear explicitly in our language, they are faithfully represented in our language by unsealed \nmodules containing only type components. For example, the kind ( T .T ) .T is represented by the signature \n([[ T]] .[[ T ]]) . [[ T ]] ; and the constructor .a:( T . T ) .( int \u00d7 aint) is represented by the module \n.s:([[ T ]] . [[ T ]]) .[ int \u00d7 Typ ( s[ int])] . Examples of how ML-style signatures and structures \nmay be ex\u00adpressed in our language appear in Figures 2 and 3. Comparability and Projectibility Two closely \nrelated issues are crucial to the design of a module system supporting type abstrac\u00adtion: 1. When can \na module be compared for equivalence with another module? 2. When can a type component be projected \nfrom a module and used as a type?  We say that a module is comparable iff it can be compared for equivalence \nwith another module, and that a module is projectible iff its type components may be projected and used \nas type expres\u00adsions. (In the literature most presentations emphasize projectibil\u00adity [11, 14, 15].) \nstructure S1 = struct type s = bool type t =bool * int structure S = struct type u = string val f = (fn \ny:u => true) end val g = (fn y:t => \"hello world\") end ... iscompiledas... (s =[ bool] , (t =[ bool \n\u00d7 int] , (S = (u =[ string] ,( f =[ .y:Typ u.true] ,())), (g =[ .y:Typ t.\"hello world\"] ,())))) Figure \n3. ML Structure Example A simple analysis of the properties of comparability and projectibil\u00adity suggests \nthat they are closely related. Suppose that M is a pro\u00adjectible module with signature [[ T]] , so that \nTyp M is a type. Since type equality is an equivalence relation, this type may be compared with any other, \nin particular, Typ M. for another projectible mod\u00adule M. of the same signature. But since Typ M and Typ \nM. fully determine M, we are, in effect, comparing M with M. for equiva\u00adlence. This suggests that projectible \nmodules be regarded as compa\u00adrable for type checking purposes. Conversely, if M is a comparable module, \nthen by extensionality M should be equivalent to [ Typ M] , which is only sensible if M is also projectible. \nPurity and Impurity The design of our module system rests on the semantic notions of purity and impurity \ninduced by computa\u00adtional effects. To motivate the design, .rst recall that in a .rst-class module system \nsuch as Harper and Lillibridge s [11] there can be impure module expressions that yield distinct type \ncomponents each time they are evaluated. For example, a module expression M might consult the state of \nthe world, yielding a different mod\u00adule for each outcome of the test. The type components of such a module \nare not statically well-determined, and hence should not be admitted as type expressions at all, much \nless compared for equiv\u00adalence. On the other hand, even in such a general framework, pure (effect-free) \nmodules may be safely regarded as both comparable and projectible. In a second-class module system such \nexamples are not, in fact, expressible, but we will nevertheless .nd it useful to classify mod\u00adules according \nto their purity.2 This classi.cation is semantic, in the sense of being de.ned by judgments of the calculus, \nrather than syntactic, in the sense of being determined solely by the form of expression. Such a semantic \napproach is important for a correct account of type abstraction in a full-featured module language. The \naxiomatization of purity and impurity in our system is based on a set of rules that takes account of \nthe types of expressions, as well as their syntactic forms. The type system is conservative in that it \nassumes the worst of an impure module expression, ruling it 2Moreover, in Section 5 we will introduce \nthe means to re-create these examples in our setting, making essential use of the same clas\u00adsi.cation \nsystem. incomparable and non-projectible, even when its type components are in fact statically well-determined. \nAs we will see shortly, this is important for enforcing type abstraction, as well as ensuring sound\u00adness \nin the presence of .rst-class modules. In addition, since it is sound to do so, we deem all pure module \nexpressions to be compa\u00adrable and projectible. That is, to be as permissive as possible with\u00adout violating \nsoundness or abstraction, we identify comparability and projectibility with purity. Finally, note that \na module is judged pure based on whether its type components are well-determined, which is independent \nof whether any term components have com\u00adputational effects. In the literature different accounts of higher-order \nmodules provide different classes of pure modules. For example, in Harper and Lil\u00adlibridge s .rst-class \nmodule system [11], only syntactic values are considered pure. In Leroy s second-class module calculi \n[14, 15], purity is limited to the syntactic category of paths. In Harper et al. s early phase-distinction \ncalculus [12] all modules are deemed to be pure, but no means of abstraction is provided. Abstraction \nvia Sealing The principal means for de.ning ab\u00adstract types is sealing, written M :> s. Sealing M with \ns pre\u00advents any client of M from depending on the identities of any type components speci.ed opaquely \nwith signature [[ T ]] rather than .[[ T ]]( M) inside s. From the point of view of module equivalence, \nthis means that a sealed module should be considered incompara\u00adble. To see this, suppose that M =([ int] \n:>[[ T ]]) is regarded as comparable. Presumably, M could not be deemed equivalent to M' =([ bool] :>[[ \nT ]]) since their underlying type components are different. However, since module equivalence is re.exive, \nif M is comparable, then M must be deemed equivalent to itself. This would mean that the type system \nwould distinguish two opaque modules based on their underlying implementation, a violation of type abstraction. \nA signi.cant advantage of our judgmental approach to purity is that it affords a natural means of ensuring \nthat a sealed module is in\u00adcomparable, namely to judge it impure. This amounts to regarding sealing as \na pro forma run-time effect, even though no actual effect occurs at execution time. Not only does this \nensure that abstraction violations such as the one just illustrated are ruled out, but we will also show \nin Section 3 that doing so allows the type system to track the run-time generation of new types. Applicative \nand Generative Functors Functors in Standard ML are generative in the sense that each abstract type in \nthe result of the functor is generated afresh for each instance of the functor, regardless of whether \nor not the arguments in each instance are equivalent. Functors in Objective Caml, however, are applicative \nin the sense that they preserve equivalence: if applied to equivalent arguments, they yield equivalent \nresults. In particular, the abstract types in the result of a functor are the same for any two applications \nto the same argument. Continuing the analogy with computational effects, we will deem any functor whose \nbody is pure to be total, otherwise partial. The application of a pure, total functor to a pure argument \nis pure, and hence comparable. Total functors are applicative in the sense that the application of a \npure total functor to two equivalent pure mod\u00adules yields equivalent pure modules, because the applications \nare pure, and hence comparable. Partial functors, on the other hand, always yield impure modules when \napplied. Therefore they do not respect equivalence of arguments (because the results, being im\u00adpure, \nare not even comparable), ensuring that each instance yields a distinct result. We distinguish the signatures \nof total (applicative) and partial (gen\u00aderative) functors. Total functors have . signatures, whereas \npartial functors have .par signatures. The subtyping relation is de.ned so that every total functor may \nbe regarded (degenerately) as a partial functor. Weak and Strong Sealing In our system we identify applicative \nfunctors with total ones, and generative functors with partial ones. To make this work, however, we must \nre.ne the notion of effect. For if sealing is regarded as inducing a run-time effect, then it is impossible \nto employ abstraction within the body of a total func\u00adtor, for to do so renders the body impure. (We \nmay seal the entire functor with a total functor signature to impose abstraction, but this only ensures \nthat the exported types of the functor are held abstract in any clients of that functor. It does not \npermit a substructure in the body of the functor to be held abstract in both the clients of the functor \nand in the remainder of the functor body.) The solution is to distinguish two forms of sealing strong, \nwritten M :> s as before, and weak, written M :: s. Both impose abstrac\u00adtion in the sense of limiting \ntype propagation to what is explicitly speci.ed in the ascribed signature by regarding both forms of \nseal\u00ading as inducing impurity. However, to support a useful class of applicative functors, we further \ndistinguish between static and dy\u00adnamic effects. Weak sealing induces a static effect, whereas strong \nsealing induces dynamic effect. The signi.cance of this distinction lies in the de.nition of total and \npartial functors. A functor whose body involves a dynamic effect (i.e.,is dynamically impure), is ruled \npartial, and hence generative. Thus strong sealing within a functor body induces generativity of that \nfunctor. A functor whose body is either pure, or involves only a static effect (i.e.,is dynamically pure), \nis ruled total, and hence applicative. This ensures that applicative functors may use abstrac\u00adtion within \ntheir bodies without incurring generative behavior. The methodological importance of this distinction \nis discussed in Sec\u00adtion 3. A dynamic effect may be thought of as one that occurs during exe\u00adcution, \nwhereas a static effect is one that occurs during type check\u00ading. Dynamic effects are suspended inside \nof a .-abstraction, so functor abstractions are dynamically pure. However, when applied, the dynamic \neffects inside the functor are released, so that the ap\u00adplication is dynamically impure. On the other \nhand, static effects occur during type checking, and hence are not suspended by .\u00adabstraction, nor released \nby application. Formalization The typing judgment for our system is written G f. M : s, where . indicates \nM s purity. The classi.er . is drawn from the following four-point lattice: W / \\ DS \\ / P The point \nP indicates that M is pure (and hence comparable and pro\u00adjectible), D indicates dynamic purity, S indicates \nstatic purity, and W indicates well-formedness only (no purity information). Hence, G fP M : s is our \npurity judgment. It will prove to be convenient in our typing rules to exploit the ordering (written \nC), meets (n), and joins (U) of this lattice, where P is taken as the bottom and W is taken as the top. \nWe also sometimes .nd it convenient to use the notation .ds:s1.s2 for a functor signature that is either \ntotal or partial depending on whether d = tot or d = par, respectively. ' Gf.M : s.C .Gf.M : sGf.M : \nsGf ok ( 1)( 2)( 3)( 4) Gf.' M : sGfW ( M :> s) : sGf.UD ( M :: s) : sGfP s : G( s) G,s:s1 f.M : s2 .C \nD G,s:s1 f.M : s2 G,s:s1 f s2 sig ( 5)( 6)( 7) totpartotpar Gf..s:s1.M : .s:s1.s2 Gf.nD .s:s1.M : .s:s1.s2 \nGf .s:s1.s2 = .s:s1.s2 totpar Gf.M1: .s:s1.s2 GfP M2: s1 Gf.M1: .s:s1.s2 GfP M2: s1 ( 8)( 9) Gf.M1M2: \ns2[ M2/s] Gf.US M1M2: s2[ M2/s] ' Gf.M : Ss:s1.s2 GfP M : Ss:s1.s2 Gf.M : sGf s= s ( 10)( 11)( 12) ' \n Gf.p1M : s1 GfP p2M : s2[ p1M/s] Gf.M : s Figure 4. Key Typing Rules Some key rules are summarized in \nFigure 4. Pure modules are dy\u00adnamically pure and statically pure, and each of those are at least well-formed \n(rule 1). Strongly sealed modules are neither statically nor dynamically pure (2); weakly sealed modules \nare not statically pure, but are dynamically pure if their body is (3). Applicative functors must have \ndynamically pure bodies (5); generative func\u00adtors have no restriction (6). Applicative functors may be \nused as generative ones (7). Variables are pure (4), and lambdas are dy\u00adnamically pure (5 and 6). The \napplication of an applicative functor is as pure as the functor itself (8), but the application of a \ngenerative functor is at best statically pure (9). Finally, the purity of a module is preserved by signature \nsubsumption (12). The complete set of typing rules is given in Appendix A. The rules for functor application \n(rules 8 and 9) require that the functor argument be pure. This is because the functor argument is substituted \ninto the functor s codomain to produce the result signa\u00adture, and the substitution of impure modules \nfor variables (which are always pure) can turn well-formed signatures into ill-formed ones (for example, \n[ Typ s] becomes ill-formed if an impure mod\u00adule is substituted for s). (An alternative rule proposed \nby Harper and Lillibridge [11] resolves this issue, but induces the avoidance problem, as we discuss \nin Section 4.) Therefore, when a functor is to be applied to an impure argument, that argument must .rst \nbe bound to a variable, which is pure. Similarly, projection of the sec\u00adond component of a pair is restricted \nto pure pairs (rule 11), but no such restriction need be made for projection of the .rst component (rule \n10), since no substitution is involved. Static Equivalence In the foregoing discussion we have fre\u00adquently \nmade reference to a notion of module equivalence, without specifying what this means. A key design decision \nfor a module cal\u00adculus is to de.ne when two comparable modules are to be deemed equivalent. Different \nmodule systems arise from different notions of equivalence. If a pure module has signature [[ T ]] , \nit is possible to extract the type component from it. Type checking depends essentially on the matter \nof which types are equal, so we must consider when Typ M is equal to Typ M '. The simplest answer would \nbe to regard Typ M = Typ M ' exactly when the modules M and M ' are equal. But this is too naive because \nwe cannot in general determine when two modules are equal. Suppose F : [[ int]] .sand e,e ' : int. Then \nF [ e]= F [ e '] if and only if e = e ', but the latter equality is undecid\u00adable in general. A characteristic \nfeature of second class module systems is that they respect the phase distinction [12] between compile-time \nand run\u00adtime computation. This property of a module system states that type equivalence must be decidable \nindependently of term equivalence. This should be intuitively plausible, since a second-class module \nsystem provides no means by which a type component of a module can depend on a term component. (This \nis not happenstance, but the result of careful design. We will see in Section 5 that the matter is more \nsubtle than it appears.) Based on this principle, we de.ne module equivalence to be equiv\u00adalence for \ntype checking purposes , or static equivalence. Roughly speaking, two modules are deemed to be equivalent \nwhenever they agree on their corresponding type components.3 We write our module equivalence judgment \nas Gf M ~M ' : s. = The rules for static equivalence of atomic modules are the expected ones. Atomic \ntype components must be equal, but atomic term components need not be: Gf t= t' GfP M : [[ t]] GfP M \n' : [[ t]] ] ~f M ~ Gf [ t=[ t'] : [[ T ]] G= M ' : [[ t]] Since the generative production of new types \nin a generative functor is notionally a dynamic operation, generative functors have no static components \nto compare. Thus, pure generative functors are always statically equivalent, just as atomic term modules \nare: parpar GfP M : .s:s1.s2 GfP M ' : .s:s1.s2 Gf M ~M ' : .s:s = par1.s2 The complete set of equivalence \nrules is given in Appendix A. As an aside, this discussion of module equivalence refutes the mis\u00adconception \nthat .rst-class modules are more general than second\u00adclass modules. In fact, the expressiveness of .rst-and \nsecond-class modules is incomparable. First-class modules have the obvious ad\u00advantage that they are .rst-class. \nHowever, since the type compo\u00adnents of a .rst-class module can depend on run-time computations, it is \nimpossible to get by with static module equivalence and one 3The phase distinction calculus of Harper, \net al. [12] includes non-standard equality rules for phase-splitting modules M into structures (Mstat,Mdyn) \nconsisting of a static component Mstat and a dynamic component Mdyn. Our static equivalence M ~M ' amounts \n= to saying Mstat = stat in their system. However, we do not identify M ' functors with structures, as \nthey do. must use dynamic equivalence instead (in other words, one can\u00adnot phase-split modules as in \nHarper et al. [12]). Consequently, .rst-class modules cannot propagate as much type information as second-class \nmodules can. Singleton Signatures Type sharing information is expressed in our language using singleton \nsignatures [33], a derivative of translu\u00adcent sums [11, 14, 18]. (An illustration of the use of singleton \nsignatures to express type sharing appears in Figure 2.) The type system allows the deduction of equivalences \nfrom membership in singleton signatures, and vice versa, and also allows the forgetting of singleton \ninformation using the subsignature relation: G fP M : .s( M ') G fP M ' : sG f M ~M ' : s = G f M ~= \nM ' : s G fP M : .s( M ') G fP M : s G f M ~= M ' : s G f .s( M) = s G f .s( M) = .s( M ') When s =[[ \nT]] , these deductions follow using primitive rules of the type system (since .[[ T ]]( M)= .( M) is \nprimitive). At other signa\u00adtures, they follow from the de.nitions given in Figure 5. Beyond expressing \nsharing, singletons are useful for sel..ca\u00adtion [11]. For instance, if s is a variable bound with the \nsignature [[ T ]] , s can be given the fully transparent signature .( s) . This fact is essential to \nthe existence of principal signatures in our type check\u00ading algorithm. Note that since singleton signatures \nexpress static equivalence information, the formation of singleton signatures is restricted to pure modules. \nThus, only pure modules can be sel.\u00ad.ed (as in Harper and Lillibridge [11] and Leroy [14]). Singleton \nsignatures complicate equivalence checking, since equiv\u00adalence can depend on context. For example, .s:[[ \nT ]] .[ int] and .s:[[ T ]] .s are obviously inequivalent at signature [[ T ]] . [[ T ]] .How\u00adever, using \nsubsignatures, they can also be given the signature .([ int]) .[[ T ]] and at that signature they are \nequivalent, since they return the same result when given the only permissible argument, [ int] . As this \nexample illustrates, the context sensitivity of equivalence provides more type equalities than would \nhold if equivalence were strictly context insensitive, thereby allowing the propagation of ad\u00additional \ntype information. For example, if F : ( .([ int]) . [[ T]]) . [[ T ]] , then the types Typ ( F( .s:[[ \nT ]] .[ int])) and Typ ( F( .s:[[ T]] .s)) are equal, which could not be the case under a context-insensitive \nregime. A subtle technical point arises in the use of the higher-order singletons de.ned in Figure 5. \nSuppose F : [[ T ]] . [[ T ]] . Then .[[ T ]] .[[ T ]]( F)= .s:[[ T ]] ..( Fs) , which intuitively contains \nthe mod\u00adules equivalent to F: those that take members of F s domain and return the same thing that F \ndoes. Formally speaking, however, the canonical member of this signature is not F but its eta-expansion \n.s:[[ T ]] .Fs. In fact, it is not obvious that F belongs to .[[ T ]] .[[ T ]]( F) . To ensure that F \nbelongs to its singleton signature, our type system (following Stone and Harper [33]) includes the extensional \ntyping rule: G fP M : .s:s1.s' 2 G,s:s1 fP Ms : s2 G fP M : .s:s1.s2 Using this rule, F belongs to .s:[[ \nT ]] ..( Fs) because it is a function and because Fs belongs to .( Fs) . A similar extensional typing \nrule is provided for products. It is possible that the need for these def .[[ T ]]( M)= .( M) def .[[ \nt]]( M) =[[ t]] def .1( M)= 1 def .tot ..tots:s1.s2 ( M)= s:s1..s2 ( Ms) def .par ..pars:s1.s2 ( M)= \ns:s1.s2 def .Ss:s1 .s2 ( M)= .s1 ( p1M) \u00d7 .s2[ p1M/s]( p2M) def .( M)= .( M) .( M') Figure 5. Singletons \nat Higher Signatures rules could be avoided by making higher-order singletons primitive, but we have \nnot explored the meta-theoretic implications of such a change. Since a module with a (higher-order) singleton \nsignature is fully transparent, it is obviously projectible and comparable, and hence could be judged \nto be pure, even if it would otherwise be classi.ed as impure. This is an instance of the general problem \nof recognizing that benign effects need not disturb purity. Since purity is a judg\u00adment in our framework, \nwe could readily incorporate extensions to capture such situations, but we do not pursue the matter here. \nType Checking Our type system enjoys a sound, complete, and effective type checking algorithm. Our algorithm \ncomes in three main parts: .rst, an algorithm for synthesizing the principal (i.e., minimal) signature \nof a module; second, an algorithm for check\u00ading subsignature relationships; and third, an algorithm for \ndeciding equivalence of modules and of types. Module typechecking then proceeds in the usual manner, \nby syn\u00adthesizing the principal signature of a module and then checking that it is a subsignature of the \nintended signature. The signature synthesis algorithm is given in Appendix B, and its correctness the\u00adorems \nare stated below. The main judgment of signature synthesis is G f. M . s, which states that M s principal \nsignature is s and M s purity is inferred to be .. Subsignature checking is syntax-directed and easy \nto do, given an algorithm for checking module equivalence; module equivalence arises when two singleton \nsignatures are compared for the subsigna\u00adture relation. The equivalence algorithm is closely based on \nStone and Harper s algorithm [33] for type constructor equivalence in the presence of singleton kinds. \nSpace considerations preclude further discussion of this algorithm here. Full details of all these algorithms \nand proofs appear in the companion technical report [7]. THEOREM 2.1 (SOUNDNESS). If G f. M . s then \nG f. M : s. THEOREM 2.2 (COMPLETENESS). If G f. M : s then G f.' M . s' and G f s'= s and .'C .. Note \nthat since the synthesis algorithm is deterministic, it follows from Theorem 2.2 that principal signatures \nexist. Finally, since our synthesis algorithm, for convenience, is presented in terms of in\u00adference rules, \nwe require one more result stating that it really is an algorithm: THEOREM 2.3 (EFFECTIVENESS). For any \nG and M, it is decid\u00adable whether there exist s and . such that G f. M . s. signature SYMBOL TABLE = \nsig type symbol val string to symbol : string -> symbol val symbol to string : symbol -> string val eq \n: symbol * symbol -> bool end functor SymbolTableFun () :> SYMBOL TABLE = struct type symbol = int val \ntable : string array = (* allocate internal hash table *) Array.array (initial size, NONE) fun string \nto symbol x = (* lookup (or insert) x *) ... fun symbol to string n = (case Array.sub (table, n) of SOME \nx => x | NONE => raise (Fail \"bad symbol\")) fun eq (n1, n2) = (n1 = n2) end structure SymbolTable = \nSymbolTableFun () Figure 6. Strong Sealing Example  3 Strong and Weak Sealing Generativity is essential \nfor providing the necessary degree of ab\u00adstraction in the presence of effects. When a module has side-effects, \nsuch as the allocation of storage, abstraction may demand that types be generated in correspondence to \nstorage allocation, in order to en\u00adsure that elements of those types relate to the local store and not \nthe store of another instance. Consider, for example, the symbol table example given in Figure 6. A symbol \ntable contains an abstract type symbol, operations for in\u00adterconverting symbols and strings, and an equality \ntest (presumably faster than that available for strings). The implementation creates an internal hash \ntable and de.nes symbols to be indices into that internal table. The intention of this implementation \nis that the Fail exception never be raised. However, this depends on the generativity of the symbol type. \nIf another instance, SymbolTable2, is created, and the types SymbolTable.symbol and SymbolTable2.symbol \nare considered equal, then SymbolTable could be asked to interpret indices into SymbolTable2 s table, \nthereby causing failure. Thus, it is essential that SymbolTable.symbol and SymbolTable2.symbol be considered \nunequal. The symbol table example demonstrates the importance of strong sealing for encoding generative \nabstract types in stateful modules. Generativity is not necessary, however, for purely functional mod\u00adules. \nLeroy [15] gives several examples of such modules as moti\u00advation for the adoption of applicative functors. \nFor instance, one may wish to implement persistent sets using ordered lists. Figure 7 signature ORD = \nsig type elem val compare : elem * elem -> order end signature SET = (* persistent sets *) sig type elem \ntype set val empty : set val insert : elem * set -> set ... end functor SetFun (Elem : ORD) :: SET where \ntype elem = Elem.elem = struct type elem = Elem.elem type set = elem list ... end structure IntOrd = \nstruct type elem = int val compare = Int.compare end structure IntSet1 = SetFun(IntOrd) structure IntSet2 \n= SetFun(IntOrd) Figure 7. Weak Sealing Example exhibits a purely functional SetFun functor, which is \nparameter\u00adized over an ordered element type, and whose implementation of the abstract set type is sealed. \nWhen SetFun is instantiated multi\u00adple times e.g., in different client modules with the same element type, \nit is useful for the resulting abstract set types to be seen as interchangeable. In our system, SetFun \nis made applicative, but still opaque, by weakly sealing its body. Speci.cally, IntSet1.set and IntSet2.set \nare both equivalent to SetFun(IntOrd).set. This type is well-formed because SetFun has an applicative \nfunctor sig\u00adnature, and SetFun and IntOrd, being variables, are both pure. Recall that a functor containing \nweak sealing is impure and must be bound to a variable before it can be used applicatively. The astute \nreader may notice that weak sealing is not truly neces\u00adsary in the SetFun example. In fact, one can achieve \nthe same effect as the code in Figure 7 by leaving the body of the functor unsealed and (strongly) sealing \nthe functor itself with an applicative functor signature before binding it to SetFun. This is the technique \nem\u00adployed by Shao [31] for encoding applicative functors, as his sys\u00adtem lacks an analogue of weak sealing. \nA failing of this approach is that it only works if the functor body is fully transparent in the absence \nof weak sealing, any opaque substructures would have to be strongly sealed, preventing the functor from \nbeing given an ap\u00adplicative signature. The best examples of the need for opaque substructures in applica\u00adtive \nfunctors are provided by the interpretation of ML datatype s as abstract types [13]. In both Standard \nML and Caml, datatype s are opaque in the sense that their representation as recursive sum types is not \nexposed, and thus distinct instances of the same datatype declaration create distinct types. Standard \nML and Caml differ, however, on whether datatype s are generative.In the presence of applicative functors \n(which are absent from Stan\u00addard ML) there is excellent reason for datatype s not to be generative namely, \nthat a generative interpretation would prevent datatype s from appearing in the bodies of applicative \nfunctors. This would severely diminish the utility of applicative functors, par\u00adticularly since in ML \nrecursive types are provided only through the datatype mechanism. For example, an implementation of SetFun \nwith splay trees, using a datatype declaration to de.ne the tree type, would require the use of weak \nsealing. For these reasons, strong sealing is no substitute for weak sealing. Neither is weak sealing \na substitute for strong. As Leroy [15] ob\u00adserved, in functor-free code, generativity can be simulated \nby what we call weak sealing. (This can be seen in our framework by ob\u00adserving that dynamic purity provides \nno extra privileges in the ab\u00adsence of functors.) With functors, however, strong sealing is nec\u00adessary \nto provide true generativity. Nevertheless, it is worth noting that strong sealing is de.nable in terms \nof other constructs in our language, while weak sealing is not. In particular, we can de.ne strong sealing, \nusing a combination of weak sealing and generative functor application, as follows: :1.M) ::( .par M \n:> s =(( . def:1.s)) () The existence of this encoding does not diminish the importance of strong sealing, \nwhich we have made primitive in our language regardless. 4 The Avoidance Problem The rules of our type \nsystem (particularly rules 8, 9, and 11 from Figure 4) are careful to ensure that substituted modules \nare always pure, at the expense of requiring that functor and second-projection arguments are pure. This \nis necessary because the result of substi\u00adtuting an impure module into a well-formed signature can be \nill\u00adformed. Thus, to apply a functor to an impure argument, one must let-bind the argument and apply \nthe functor to the resulting (pure) variable. A similar restriction is imposed by Shao [31], but Harper \nand Lillib\u00adridge [11] propose an alternative that softens the restriction. Harper and Lillibridge s proposal \n(expressed in our terms) is to include a non-dependent typing rule without a purity restriction: G f. \nM1: s1 . s2 G f. M2: s1  G f. M1M2: s2 When M2 is pure, this rule carries the same force as our dependent \nrule, by exploiting singleton signatures and the contravariance of functor signatures: .s:s1.s2 = .s:.s1 \n( M2) .s2 = .s:.s1 ( M2) .s2[ M2/s] = .s1 ( M2) . s2[ M2/s] When M2 is impure, this rule is more expressive \nthan our typing rule, because the application can still occur. However, to exploit this rule, the type \nchecker must .nd a non-dependent supersignature that is suitable for application to M2. The avoidance \nproblem [9, 18] is that there is no best way to do so. For example, consider the signature: s =([ T ]] \n. .( s)) \u00d7 .( s) To obtain a supersignature of s avoiding the variable s, we must forget that the .rst \ncomponent is a constant function, and therefore we can only say that the second component is equal to \nthe .rst component s result on some particular argument. Thus, for any type t, we may promote s to the \nsupersignature: SF:([[ T]] . [[ T ]]) . .( F[ t]) This gives us an in.nite array of choices. Any of these \nchoices is superior to the obvious ([[ T ]] .[[ T ]]) \u00d7[[ T]] , but none of them is com\u00adparable to any \nother, since F is abstract. Thus, there is no minimal supersignature of s avoiding s. The absence of \nminimal signatures is a problem, because it means that there is no obvious way to per\u00adform type checking. \nIn our type system, we circumvent the avoidance problem by requir\u00ading that the arguments of functor application \nand second-projection be pure (thereby eliminating any need to .nd non-dependent super\u00adsignatures), and \nprovide a let construct so that such operations can still be applied to impure modules. We have shown \nthat, as a result, our type theory does enjoy principal signatures. To achieve this, however, our let \nconstruct must be labeled with its result signature (not mentioning the variable being bound), for oth\u00aderwise \nthe avoidance problem re-arises. This essentially requires that every functor application or projection \ninvolving an impure ar\u00adgument be labelled with its result signature as well, leading to po\u00adtentially \nunacceptable syntactic overhead in practice. Fortunately, programs can be systematically rewritten to \navoid this problem, as we describe next. 4.1 Elaboration and Existential Signatures Consider the unannotated \nlet expression let s = M1 in M2, where M1: s1 and M2: s2( s) .If M1 is pure, then the let expression \ncan be given the minimal signature s2( M1) . Otherwise, we are left with the variable s leaving scope, \nbut no minimal supersignature of s2( s) not mentioning s. However, if we rewrite the let expression as \nthe pair (s = M1,M2), then we may give it the signature Ss:s1.s2( s) and no avoidance problem arises. \nSimilarly, the functor application F( M) with F : .s:s1.s2 and impure M : s1 can be rewritten as (s = \nM,F( s) ) and given signature Ss:s1.s2. Following Harper and Stone [13], we propose the use of an elabora\u00adtion \nalgorithm to systematize these rewritings. This elaborator takes code written in an external language \nthat supports unannotated let s, as well as impure functor application and second-projection, and produces \ncode written in our type system. Since the elaborator rewrites modules in a manner that changes their \nsignatures, it also must take responsibility for converting those modules back to their expected signature \nwherever required. This means that the elabora\u00adtor must track which pairs are real and which have been \ninvented by the elaborator to circumvent the avoidance problem. The elaborator does so using the types. \nWhen the elaborator invents a pair to circumvent the avoidance problem, it gives its signature us\u00ading \nan existential . rather than S. In the internal language, .s:s1.s2 means the same thing as Ss:s1.s2, \nbut the elaborator treats the two signatures differently: When the elaborator expects (say) a functor \nand encounters a Ss:s1.s2, it generates a type error. However, when it encounters an .s:s1.s2, it extracts \nthe s2 component (the elab\u00adorator s invariants ensure that it always can do so), looking for the expected \nfunctor. Space considerations preclude further details of the elaboration algorithm, which appear in \nthe companion technical report [7]. In a sense, the elaborator solves the avoidance problem by intro\u00adducing \nexistential signatures to serve in place of the non-existent minimal supersignatures not mentioning a \nvariable. In light of this, a natural question is whether the need for an elaborator could be eliminated \nby making existential signatures primitive to the type system. One natural way to govern primitive existentials \nis with the intro\u00adduction and elimination rules: G f P M : s1 G f s = s2[ M/s] G,s:s1 f s2 sig G f s \n=. s:s1.s2 and G,s:s1 f s2 = sG f s1 sig G f s sig G f. s:s1.s2 = s With these rules, the avoidance problem \ncould be solved: The least supersignature of s2( s) not mentioning s:s1 would be . s:s1.s2( s) . Unfortunately, \nthese rules (particularly the .rst) make type check\u00ading undecidable. For example, each of the queries \n? .s:s.[[ t]] =. s ' :s..s:.s( s ' ) .[[ t' ]] and ? ~ ( .s:s.[ t]) = ( .s:s.[ t' ]) : . s ' :s..s:.s( \ns ' ) .[[ T ]] holds if and only if there exists pure M : s such that the types t[ M/s] and t' [ M/s] \nare equal. Thus, deciding subsignature or equivalence queries in the presence of existentials would be \nas hard as higher\u00adorder uni.cation, which is known to be undecidable [10]. 4.2 Syntactic Principal Signatures \nIt has been argued for reasons related to separate compilation that principal signatures should be expressible \nin the syntax available to the programmer. This provides the strongest support for separate compilation, \nbecause a programmer can break a program at any point and write an interface that expresses all the information \nthe compiler could have determined at that point. Such strong support does not appear to be vital in \npractice, since systems such as Objec\u00adtive Caml and Standard ML of New Jersey s higher-order modules \nhave been used successfully for some time without principal signa\u00adtures at all, but it is nevertheless \na desirable property. Our type system (i.e., the internal language) does provide syntac\u00adtic principal \nsignatures, since principal signatures exist, and all the syntax is available to the programmer. However, \nthe elaborator s external language does not provide syntax for the existential sig\u00adnatures that can appear \nin elaborator signatures, which should be thought of as the principal signatures of external modules. \nThus, we can say that our basic type system provides syntactic principal signatures, but our external \nlanguage does not. In an external language where the programmer is permitted to write existential signatures, \nelaborating code such as: ( .s ' :( . s:s1.s2) ...) M requires the elaborator to decide whether M can \nbe coerced to be\u00adlong to . s:s1.s2, which in turn requires the elaborator to produce a M ' : s1 such \nthat M : s2[ M ' /s] . Determining whether any such M ' exists requires the elaborator to solve an undecidable \nhigher-order uni.cation problem: if s2 = .([ t]) . .([ t' ]) and M = .t:[[ T ]] .t, then M : s2[ M ' \n/s] if and only if t[ M ' /s] and t' [ M ' /s] are equal. Thus, to allow programmer-speci.ed existential \nsignatures in the greatest possible generality would make elaboration undecidable. Partial measures may \nbe possible, but we will not discuss any here.  5 Packaging Modules as First-Class Values It is desirable \nfor modules to be usable as .rst-class values. This is useful to make it possible to choose at run time \nthe most ef.cient implementation of a signature for a particular data set (for example, sparse or dense \nrepresentations of arrays). However, fully general .rst-class modules present dif.culties for static \ntyping [18]. One practical approach to modules as .rst-class values was sug\u00adgested by Mitchell, et al. \n[24], who propose that second-class mod\u00adules automatically be wrapped as existential packages [25] to \nobtain .rst-class values. A similar approach to modules as .rst-class val\u00adues is described by Russo and \nimplemented in Moscow ML [29]. This existential-packaging approach to modules as .rst-class values is \nbuilt into our language. We write the type of a packaged module as (| s|) and the packaging construct \nas pack M as (| s|) . Elimina\u00adtion of packaged modules (as for existentials) is performed using a closed-scope \nunpacking construct. These may be de.ned as fol\u00adlows: def (| s|) = . a.( s . a) . a def pack M as (| \ns|) = .a.. f :( s . a) .fM ' def unpack e as s:s in ( e : t)= et( .s:s.e ' ) (Compare the de.nition of \n(| s|) with the standard encoding of the existential type . \u00df.t as . a.( . \u00df.t . a) . a.) The main limitation \nof existentially-packaged modules is the closed-scope elimination construct. It has been observed repeatedly \nin the literature [20, 3, 18] that this construct is too restrictive to be ' very useful. For one, in \nunpack e as s:s in ( e : t) , the result type t may not mention s. As a consequence, functions over packaged \nmodules may not be dependent; that is, the result type may not men\u00adtion the argument. This de.ciency \nis mitigated in our language by the ability to write functions over unpackaged, second-class mod\u00adules, \nwhich can be given the dependent type .s:s.t( s) instead of (| s|) . t. Another problem with the closed-scope \nelimination construct is that a term of package type cannot be unpacked into a stand-alone second-class \nmodule; it can only be unpacked inside an enclosing term. As each unpacking of a packaged module creates \nan abstract type in a separate scope, packages must be unpacked at a very early stage to ensure coherence \namong their clients, leading to scope inversions that are awkward to manage in practice. What we desire, \ntherefore, is a new module construct of the form unpack e as s , which coerces a .rst-class package e \nof type (| s|)back into a second-class module of signature s. The following ex\u00adample illustrates how \nadding such a construct carelessly can lead to unsoundness: module F = .s:[[ (| s|) ]] .( unpack ( Val \ns) as s) module X1 = F [ pack M1 as (| s|) ] module X2 = F [ pack M2 as (| s|) ] Note that the argument \nof the functor F is an atomic term module, so all arguments to F are statically equivalent. If F is given \nan applicative signature, then X1 and X2 will be deemed equivalent, even if the original modules M1 and \nM2 are not! Thus, F must be types t ::= \u00b7\u00b7\u00b7 | (| s|)terms e ::= \u00b7\u00b7\u00b7 | pack M as (| s|)modules M ::= \u00b7\u00b7\u00b7 \n| unpack e as s G f s1 = s2 G f . M : s G f(| s1|) = (| s2|) G f pack M as (| s|) : (| s|) G f e : (| \ns|) G f S unpack e as s : s Figure 8. Packaged Module Extension deemed generative, which in turn requires \nthat the unpack construct induce a dynamic effect. Packaged modules that admit this improved unpacking \nconstruct are not de.nable in our core language, but they constitute a simple, orthogonal extension to \nthe type system that does not complicate type checking. The syntax and typing rules for this extension \nare given in Figure 8. Note that the closed-scope unpacking construct is de.nable as ' let s =(unpack \ne as s) in (e : t) Intuitively, unpacking is generative because the module being un\u00adpacked can be an \narbitrary term, whose type components may de\u00adpend on run-time conditions. In the core system we presented \nin Section 2, the generativity induced by strong sealing was merely a pro forma effect the language, \nsupporting only second-class mod\u00adules, provided no way for the type components of a module to be actually \ngenerated at run time. The type system, however, treats dynamic effects as if they are all truly dynamic, \nand thus it scales easily to handle the real run-time type generation enabled by the extension in Figure \n8. 6 Related Work Harper, Mitchell and Moggi [12] pioneered the theory of phase sep\u00adaration, which is \nfundamental to achieving maximal type propaga\u00adtion in higher-order module systems. Their non-standard \nequational rules, which identify higher-order modules with primitive phase\u00adsplit ones, are similar in \nspirit to, though different in detail from, our notion of static module equivalence. One may view their \nsys\u00adtem as a subsystem of ours in which there is no sealing mechanism (and consequently all modules are \npure). MacQueen and Tofte [21] proposed a higher-order module exten\u00adsion to the original De.nition of \nStandard ML [22], which was im\u00adplemented in the Standard ML of New Jersey compiler. Their se\u00admantics \ninvolves a two-phase elaboration process, in which higher\u00adorder functors are re-elaborated at each application \nto take advan\u00adtage of additional information about their arguments. This advan\u00adtage is balanced by the \ndisadvantage of inhibiting type propagation in the presence of separate compilation since functors that \nare com\u00adpiled separately from their applications cannot be re-elaborated. A more thorough comparison \nis dif.cult because MacQueen and Tofte employ a stamp-based semantics, which is dif.cult to transfer \nto a type-theoretic setting. Focusing on controlled abstraction, but largely neglecting higher\u00adorder \nmodules, Harper and Lillibridge [11] and Leroy [14, 16] in\u00adtroduced the closely related concepts of translucent \nsums and man\u00adifest types. These mechanisms served as the basis of the module system in the revised De.nition \nof Standard ML 1997 [23], and Harper and Stone [13] have formalized the elaboration of Stan\u00addard ML 1997 \nprograms into a translucent sums calculus. To deal with the avoidance problem, Harper and Stone rely \non elaborator mechanisms similar to ours. The Harper and Stone language can be viewed as a subsystem \nof ours in which all functors are generative and only strong sealing is supported. Leroy introduced the \nnotion of an applicative functor [15], which enables one to give fully transparent signatures for many \nhigher\u00adorder functors. Leroy s formalism may be seen as de.ning purity by a syntactic restriction that \nfunctor applications appearing in type paths must be in named form. On one hand, this restriction provides \na weak form of structure sharing in the sense that the abstract type F(X).t can only be the result of \napplying F to the module named X. On the other hand, the restriction prevents the system from captur\u00ading \nthe full equational theory of higher-order functors, since not all equations can be expressed in named \nform [4]. Together, manifest types and applicative functors form the basis of the module sys\u00adtem of Objective \nCaml [27]. The manifest type formalism, like the translucent sum formalism, does not address the avoidance \nprob\u00adlem, and consequently it lacks principal signatures. More recently, Russo, in his thesis [28], formalized \ntwo separate module languages: one being a close model of the SML module system, the other being a higher-order \nmodule system with applica\u00adtive functors along the lines of O Caml, but abandoning the named form restriction \nas we do. Russo s two languages can be viewed as subsystems of ours, the .rst supporting only strong \nsealing, the sec\u00adond supporting only weak sealing. We adopt his use of existential signatures to address \nthe avoidance problem, although Russo also used existentials to model generativity, which we do not. \nRusso s thesis also describes an extension to SML for packaging modules as .rst-class values. This extension \nis very similar to the existential\u00adpackaging approach discussed in the beginning of Section 5, and therefore \nsuffers from the limitations of the closed-scope unpack\u00ading construct. While Russo de.ned these two languages \nseparately, he imple\u00admented the higher-order module system as an experimental exten\u00adsion to the Moscow \nML compiler [26]. Combining the two lan\u00adguages without distinguishing between static and dynamic effects \nhas an unfortunate consequence. The Moscow ML higher-order module system places no restrictions on the \nbody of an applicative functor; in particular, one can defeat the generativity of a generative functor \nby eta-expanding it into an applicative one. Exploiting this uncovers an unsoundness in the language \n[6], that, in retrospect, is clear from our analysis: one cannot convert a partial into a total functor. \nShao [31] has proposed a single type system for modules supporting both applicative and generative functors. \nRoughly speaking, Shao s system may be viewed as a subsystem of ours based exclusively on strong sealing \nand dynamic effects, but supporting both . and .par signatures. As we observed in Section 3, this means \nthat the bodies of applicative functors may not contain opaque substructures (such as datatype s). Shao \ns system, like ours, circumvents the avoid\u00adance problem (Section 4) by restricting functor application \nand pro\u00adjection to pure arguments (which must be paths in his system), and by eliminating implicit subsumption, \nwhich amounts to requiring that let expressions be annotated, as in our system. It seems likely that \nour elaboration techniques could as well be applied to Shao s system to lift these restrictions, but \nat the expense of syntactic prin\u00adcipal signatures. Shao also observes that fully transparent functors \nmay be regarded as applicative; this is an instance of the general problem of recognizing benign effects, \nas described in Section 2. 7 Conclusion Type systems for .rst-order module systems are reasonably well \nunderstood. In contrast, previous work on type-theoretic, higher\u00adorder modules has left that .eld in \na fragmented state, with various competing designs and no clear statement of the trade-offs (if any) \nbetween those designs. This state of the .eld has made it dif.cult to choose one design over another, \nand has left the erroneous im\u00adpression of trade-offs that do not actually exist. For example, no previous \ndesign supports both (sound) generative and applicative functors with opaque subcomponents. Our language \nseeks to unify the .eld by providing a practical type system for higher-order modules that simultaneously \nsupports the key functionality of preceding module systems. In the process we dispel some misconceptions, \nsuch as a trade-off between fully ex\u00adpressive generative and applicative functors, thereby eliminating \nsome dilemmas facing language designers. Nevertheless, there are several important issues in modular \npro\u00adgramming that go beyond the scope of our type theory. Chief among these are: Structure Sharing. \nThe original version of Standard ML [22] included a notion of module equivalence that was sensitive to \nthe dynamic, as well as static, parts of the module. Although such a notion would violate the phase distinction, \nit might be possible to formulate a variation of our system that takes ac\u00adcount of dynamic equivalence \nin some conservative fashion. It is possible to simulate structure sharing by having the elab\u00adorator \nadd an abstract type to each structure to serve as the compile-time name of that structure. However, \nthis would be merely an elaboration convention, not an intrinsic account of structure sharing within \ntype theory.  Recursive Modules. An important direction for future re\u00adsearch is to integrate recursive \nmodules [8, 5, 30] into the present framework. The chief dif.culty is to achieve prac\u00adtical type checking \nin the presence of general recursively de\u00adpendent signatures, or to isolate a practical sub-language \nthat avoids these problems.  8 References [1] David R. Aspinall. Type Systems for Modular Programs \nand Speci.cations. PhD thesis, Edinburgh University, Edinburgh, Scotland, December 1997. [2] Luca Cardelli, \nJim Donahue, Mick Jordan, Bill Kalso, and Greg Nelson. The Modula-3 type system. In Sixteenth ACM Symposium \non Principles of Programming Languages, pages 202 212, Austin, TX, January 1989. [3] Luca Cardelli and \nXavier Leroy. Abstract types and the dot notation. In M. Broy and C. B. Jones, editors, Proceedings IFIP \nTC2 working conference on programming concepts and methods, pages 479 504. North-Holland, 1990. Also \navail\u00adable as research report 56, DEC Systems Research Center. [4] Karl Crary. Sound and complete elimination \nof singleton kinds. In Third Workshop on Types in Compilation, vol\u00adume 2071 of Lecture Notes in Computer \nScience, pages 1 25. Springer-Verlag, September 2000. Extended version pub\u00adlished as CMU technical report \nCMU-CS-00-104. [5] Karl Crary, Robert Harper, and Sidd Puri. What is a recur\u00adsive module? In SIGPLAN \n99 Conference on Programming Language Design and Implementation (PLDI), pages 50 63, Atlanta, GA, 1999. \nACM SIGPLAN. [6] Derek Dreyer. Moscow ML s higher-order modules are un\u00adsound. Posted to the TYPES electronic \nforum, September 2002. [7] Derek Dreyer, Karl Crary, and Robert Harper. A type sys\u00adtem for higher-order \nmodules (expanded version). Techni\u00adcal Report CMU-CS-02-122R, School of Computer Science, Carnegie Mellon \nUniversity, December 2002. [8] Matthew Flatt and Matthias Felleisen. Units: Cool modules for HOT languages. \nIn 1998 ACM SIGPLAN Conference on Programming Language Design and Implementation, pages 236 248, Montreal, \nCanada, June 1998. [9] Giorgio Ghelli and Benjamin Pierce. Bounded existentials and minimal typing. Theoretical \nComputer Science, 193:75 96, 1998. [10] Warren D. Goldfarb. The undecidability of the second-order uni.cation \nproblem. Theoretical Computer Science, 13:225 230, 1981. [11] Robert Harper and Mark Lillibridge. A type-theoretic \nap\u00adproach to higher-order modules with sharing. In Twenty-First ACM Symposium on Principles of Programming \nLanguages, pages 123 137, Portland, OR, January 1994. [12] Robert Harper, John C. Mitchell, and Eugenio \nMoggi. Higher\u00adorder modules and the phase distinction. In Seventeenth ACM Symposium on Principles of \nProgramming Languages, San Francisco, CA, January 1990. [13] Robert Harper and Chris Stone. A type-theoretic \ninterpreta\u00adtion of Standard ML. In Gordon Plotkin, Colin Stirling, and Mads Tofte, editors, Proof, Language, \nand Interaction: Es\u00adsays in Honor of Robin Milner. MIT Press, 2000. [14] Xavier Leroy. Manifest types, \nmodules, and separate compi\u00adlation. In Proceedings of the Twenty-.rst Annual ACM Sym\u00adposium on Principles \nof Programming Languages, Portland. ACM, January 1994. [15] Xavier Leroy. Applicative functors and fully \ntransparent higher-order modules. In Conference Record of POPL 95: ACM SIGPLAN-SIGACT Symposium on Principles \nof Pro\u00adgramming Languages, pages 142 153, San Francisco, CA, January 1995. [16] Xavier Leroy. A syntactic \ntheory of type generativity and sharing. Journal of Functional Programming, 6(5):667 698, 1996. [17] \nXavier Leroy. A modular module system. Journal of Func\u00adtional Programming, 10(3):269 303, 2000. [18] \nMark Lillibridge. Translucent Sums: A Foundation for Higher-Order Module Systems. PhD thesis, Carnegie \nMellon University, Pittsburgh, PA, December 1996. [19] Barbara Liskov and John Guttag. Abstraction and \nSpeci.ca\u00adtion in Program Development. MIT Press, 1986. [20] David MacQueen. Using dependent types to \nexpress modu\u00adlar structure. In Thirteenth ACM Symposium on Principles of Programming Languages, 1986. \n[21] David B. MacQueen and Mads Tofte. A semantics for higher\u00adorder functors. In Donald T. Sannella, \neditor, Programming Languages and Systems ESOP 94, volume 788 of Lecture Notes in Computer Science, \npages 409 423. Springer-Verlag, 1994. [22] Robin Milner, Mads Tofte, and Robert Harper. The De.nition \nof Standard ML. MIT Press, 1990. [23] Robin Milner, Mads Tofte, Robert Harper, and David Mac-Queen. The \nDe.nition of Standard ML (Revised). MIT Press, 1997. [24] John Mitchell, Sigurd Meldal, and Neel Madhav. \nAn exten\u00adsion of Standard ML modules with subtyping and inheritance. In Eighteenth ACM Symposium on Principles \nof Program\u00adming Languages, January 1991. [25] John C. Mitchell and Gordon D. Plotkin. Abstract types \nhave existential type. ACM Transactions on Programming Lan\u00adguages and Systems, 10(3):470 502, July 1988. \n[26] Moscow ML. http://www.dina.dk/~sestoft/mosml.html. [27] Objective Caml. http://www.ocaml.org. [28] \nClaudio V. Russo. Types for Modules. PhD thesis, Edinburgh University, Edinburgh, Scotland, 1998. LFCS \nThesis ECS LFCS 98 389. [29] Claudio V. Russo. First-class structures for Standard ML. Nordic Journal \nof Computing, 7(4):348 374, 2000. [30] Claudio V. Russo. Recursive structures for Standard ML. In International \nConference on Functional Programming, pages 50 61, Florence, Italy, September 2001. [31] Zhong Shao. \nTransparent modules with fully syntactic signa\u00adtures. In International Conference on Functional Program\u00adming, \npages 220 232, Paris, France, September 1999. [32] Christopher A. Stone. Singleton Kinds and Singleton \nTypes. PhD thesis, Carnegie Mellon University, Pittsburgh, PA, Au\u00adgust 2000. [33] Christopher A. Stone \nand Robert Harper. Deciding type equivalence in a language with singleton kinds. In Twenty-Seventh ACM \nSymposium on Principles of Programming Lan\u00adguages, pages 214 227, Boston, January 2000. [34] Niklaus \nWirth. Programming in Modula-2. Texts and Mono\u00adgraphs in Computer Science. Springer-Verlag, 1983. A \nType System Well-formed contexts: Gf ok Gf ssig s ..dom( G) f ok G,s:sf ok Well-formed types: Gf ttype \nGfP M : [[ T ]] G,s:sf ttype Gf Typ M type Gf .s:s.ttype ' '' Gf ttype Gf ttype Gf ssig '' Gf t'\u00d7 ttype \nGf(|s|) type Type equivalence: Gf t1 = t2 Gf [ t1] ~[ t2] : [[ T ]] 1 = s21 f t1 = t2 = Gf sG,s:s Gf \nt1 = t2 Gf .s:s1.t1 = .s:s2.t2 ' ' '''' Gf t1 = t2 Gf t1 = t2 Gf s1 = s2 ' '' ' '' Gf t1 \u00d7 t1 = t2 \u00d7 \ntGf(|s1|) = (|s2|) 2 Well-formed terms: Gf e : t Gf e : t' Gf t' = t Gf.M : [[ t]] Gf e : t Gf Val M \n: t Gf.M : sG,s:sf e : tGf ttype Gf.M : s Gf let s = M in ( e : t) : tGf pack M as (|s|) : (|s|)G, f \n:[ .s:s.t] ,s:sf e : tGf e : .s:s.tGfP M : s Gf .x f ( s:s) :t.e : .s:s.tGf eM : t[ M/s] ' '' : t'' '\u00d7 \nt'' '\u00d7 t'' Gf e ' : tGf e Gf e : tGf e : tGf(e ' ,e '') : t'\u00d7 t'' Gf p1e : t' Gf p2e : t'' Well-formed \nsignatures: Gf ssig Gf ttype Gf 1 sig Gf [[ T ]] sig Gf [[ t]] sig Gf ok Gf ok ' '' ' '' d''' ''' GfP \nM : [[ T ]] G,s:sf ssig G,s:sf ssig Gf .( M) sig Gf .s:s.ssig Gf Ss:s.ssig Signature equivalence: Gf \ns1 = s2 G~M2: [[ T ]] Gf ok Gf ok Gf t1 = t2 f M1 = Gf 1 = 1 Gf [[ T ]] = [[ T ]] Gf [[ t1 ]] = [[ t2]] \nGf .( M1) = .( M2) ' ' ''''' ' ' ''''' Gf s2 = sG,s:s2 f s1 = sGf sG,s:s 1 21 = s21 f s1 = s2 d' '' d''' \n''' ''' Gf .s:s1.s1 = .s:s2.sGf Ss:s1.s1 = Ss:s2.s 2 2 Signature subtyping: Gf s1 = s2   Notes on \nAppendices Gf ok Gf ok Gf t1 = t2 Gf 1 = 1 Gf [[ T ]] = [[ T ]] Gf [[ t1]] = [[ t2 ]] Appendix A gives \nthe type system for our module calculus. Ap\u00adpendix B gives the module typechecking and principal signature \n~ GfP M : [[ T ]] Gf M1 = M2: [[ T ]] synthesis judgements that form the core of our typechecking algo\u00ad \nGf .( M) = [[ T ]] Gf .( M1) = .( M2) rithm. We omit the judgments for term typechecking (Gf e . t) ' \n' ''''' ''' and unique type synthesis (Gf e . t) for space reasons; they are Gf s2 = s1 G,s:s2 f s1 \n= s2 G,s:s1 f s1 sig ( d2) . 1,d =( par,tot) fully detailed in the companion technical report [7]. d' \n'' d' '' Gf .1 s:s1.s1 = .2 s:s2.s 2 ' ' ''''' ''' Gf s1 = sG,s:s1 f s1 = sG,s:s2 f s2 sig 22 ''' ''' \nGf Ss:s1.s1 = Ss:s2.s 2 Well-formed modules: Gf.M : s ' '' Gf ok Gf ok Gf ttype Gf e : tGf ttype G,s:sf.M \n: s.C D ' ''' GfP s : G( s) GfP () :1 GfP [ t] : [[ T]] GfP [ e : t] : [[ t]] Gf..s:s.M : .s:s.s ' '' \n''' ''' ' par''' ' G,s:sf.M : sG,s:sf ssig Gf.F : .s:s.sGfP M : sGf.F : .s:s.sGfP M : s' par' '' ''[ \nM/s] ''[ M/s] Gf.nD .s:s.M : .s:s.sGf.FM : sGf.US FM : s '' M'' : s'' ''' ''' Gf.M' : sG,s:sf.Gf.M : \nSs:s.sGfP M : Ss:s.sGfP M : [[ T]] Gf.(s = M' ,M'') : Ss:s' .s'' Gf.p1M : s' GfP p2M : s''[ p1M/s] GfP \nM : .( M) ''' ' ' '' Gf.M : sGf.M : sG,s:sfP Ms : sGfP M : .s:s..GfP p1M : sGfP p2M : s ' '' '' Gf.UD \n( M:: s) : sGfW ( M:> s) : sGfP M : .s:s.sGfP M : s'\u00d7 s ' ' Gf.M' : sG,s:s'f.M'' : sGf ssig Gf e : (|s|) \nGf.' M : sGf s'= s.'C . Gf.let s = M' in ( M'' : s) : sGfS unpack e as s: sGf.M : s ~  Module equivalence: \nGf M1 = M2: s ~~~Gf tGfP M : [[ T]] GfP M : sGf M2 = M1: sGf M1 = M2: sGf M2 = M3: s 1 = t2 Gf M ~M \n: sG~G~Gf [ t1] ~[ t2] : [[ T]] Gf [ Typ M] ~M : [[ T]] = f M1 = M2: s f M1 = M3: s == par' '' par' '' \n GfP M1:1 GfP M2:1 GfP M1: [[ t]] GfP M2: [[ t]] GfP M1: .s:s.sGfP M2: .s:s.s ~~~par' '' Gf M1 = M2:1 \nGf M1 = M2: [[ t]] Gf M1 = M2: .s:s.s ''' '' Gf s2 G,s:s~~''' ~' 1 = s1 f M1 = M2: sGf F1 = F2: .s:s.sGf \nM1 = M2: s'~' ''' ~''[ M1/s] Gf .s:s1.M1 = .s:s2.M2: .s:s1.sGf F1M1 = F2M2: s~M'' 'f M'' ~M'' '' ''' \n''' Gf M' = G,s:s= ~~ 1 2: s1 2: sGf M1 = M2: Ss:s.sGf M1 = M2: Ss:s.sGf(s = M1' ,M1 '') ~(s = M2' ,M'' \ns:s' .s'' Gf p~p' Gf p~p''[ p = 2 ) : S1M1 = 1M2: s2M1 = 2M2: s1M1/s] 'f M1s ~~'~'' ''' ' G,s:s= M2s \n: sGfP M1: .s:s..1 GfP M2: .s:s..2 Gf p1M1 = p1M2: sGf p2M1 = p2M2: s Gf M1 ~= M2 : .s:s' .s'' GfP M' \n: s' G,s:s' fP M'' : sGf ssig Gf let s = M' in ( M'' : s) ~= M''[ M' /s] : s GfP M1 : .( M2) Gf M1 ~= \nM2 : .( M2) Gf M1 ~= M2 : s' \u00d7 s'' Gf M1 ~= M2 : s' Gf s' = s Gf M1 ~= M2 : s B Typechecking Algorithm \n Module typechecking: Gf.M . s ' Gf.M . sGf s'= s Gf.M . s Principal signature synthesis: Gf.M . s \n Gf ok Gf ok Gf ttype Gf e . t G,s:s' f.M . s'' .C D GfP s . .G( s) ( s) GfP () . 1 GfP [ t] . .([ t]) \nGfP [ e : t] . [[ t]] Gf..s:s' .M . .s:s' .s'' G,s:s' f.M . s'' S C . Gf.F . .s:s' .s'' GfP M . s' Gf.F \n. .pars:s' .s'' GfP M . s' ' par' '' ''[ M/s] ''[ M/s] Gf.nD .s:s.M . .s:s.sGf.FM . sGf.US FM . s' 'fP \nM'' . s'' M'. s' 'f.M'' . s'' 'U .'' GfP M'. sG,s:sGf.' G,s:s'' ..= P GfP (s = M ' ,M ''). s'\u00d7 s''[ M \n' /s] Gf.'U.'' (s = M ' ,M ''). Ss:s' .s'' ' '' '' Gf.M . Ss:s.sGfP M . s'\u00d7 sGf.M . sGf.M . sGf e .(|s|)' \n'' Gf.p1M . sGfP p2M . sGf.UD M:: s. sGfW M:> s. sGfS unpack e as s. s ' '' '' GfP M'. sG,s:s'fP M'' \n. sGf ssig Gf.' M '. sG,s:sf.'' M '' . sGf ssig .'U ..= P GfP let s = M' in ( M'' : s) . .s( let s = \nM' in ( M'' : s)) Gf.'U.'' let s = M' in ( M'' : s) . s  \n\t\t\t", "proc_id": "604131", "abstract": "We present a type theory for higher-order modules that accounts for many central issues in module system design, including translucency, applicativity, generativity, and modules as first-class values. Our type system harmonizes design elements from previous work, resulting in a simple, economical account of modular programming. The main unifying principle is the treatment of abstraction mechanisms as computational effects. Our language is the first to provide a complete and practical formalization of all of these critical issues in module system design.", "authors": [{"name": "Derek Dreyer", "author_profile_id": "81100381796", "affiliation": "Carnegie Mellon University, Pittsburgh, PA", "person_id": "P414177", "email_address": "", "orcid_id": ""}, {"name": "Karl Crary", "author_profile_id": "81100253026", "affiliation": "Carnegie Mellon University, Pittsburgh, PA", "person_id": "P157139", "email_address": "", "orcid_id": ""}, {"name": "Robert Harper", "author_profile_id": "81100140064", "affiliation": "Carnegie Mellon University, Pittsburgh, PA", "person_id": "PP39029370", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/604131.604151", "year": "2003", "article_id": "604151", "conference": "POPL", "title": "A type system for higher-order modules", "url": "http://dl.acm.org/citation.cfm?id=604151"}