{"article_publication_date": "01-15-2003", "fulltext": "\n Toward a Foundational Typed Assembly Language Karl Crary Carnegie Mellon University Abstract We present \nthe design of a typed assembly language called TALT that supports heterogeneous tuples, disjoint sums, \nand a general account of addressing modes. TALT also im\u00adplements the von Neumann model in which programs \nare stored in memory, and supports relative addressing. Type safety for execution and for garbage collection \nare shown by machine-checkable proofs. TALT is the .rst formalized typed assembly language to provide \nany of these features. Categories and Subject Descriptors D.3 [Programming Languages]: Language Constructs \nand Features; F.3.1 [Logics and Meanings of Programs]: Specifying and Verifying and Reasoning about Programs. \nGeneral Terms Languages, Security, Veri.cation Keywords Typed assembly language, proof-carrying code \n1 Introduction The proliferation of low-cost computing hardware and the ubiquity of the Internet has \ncreated a situation where a huge amount of computing power is both idle and in principle accessible to \ndevelopers. The goal of exploiting these idle computational resources has existed for years, and, begin\u00adning \nwith SETI@Home [28] in 1997, a handful of projects have successfully made pro.table use of idle computation \nre\u00adsources on the Internet. More recently, this paradigm, now called grid computing, has elicited serious \ninterest among academics [5, 16] and in industry as a general means of con\u00adducting low-cost supercomputing. \nThis material is based on work supported in part by NSF grants CCR\u00ad9984812 and CCR-0121633. Any opinions, \n.ndings, and conclusions or recommendations in this publication are those of the authors and do not re.ect \nthe views of this agency. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. POPL 03, January 15 17, 2002, New Orleans, Louisiana, USA. Copyright 2002 ACM 1-58113-628-5/03/0001 \n...$5.00 Despite the increasing interest in grid computing, a re\u00admaining obstacle to its growth is the \n(understandable) reluc\u00adtance of computer owners to download and execute software from developers they \ndo not know or trust, and may not have even heard of. This has limited the practical use of grid computing \nto the small number of potential users that have been able to obtain the trust of thousands of computer \nowners they do not know. The ConCert project at CMU [9] is seeking to overcome this obstacle by developing \na system for trustless dissemi\u00adnation of software. In the ConCert framework, a machine owner installs \na steward program that ensures the safety of any downloaded software. When a new grid application is \nobtained for execution (other parts of the ConCert frame\u00adworkdetermine when and how this takes place), \nthat ap\u00adplication is expressed in the form of certi.ed code, in which the executable code is accompanied \nby a certi.cate prov\u00ading that the code is safe. The steward then veri.es that the certi.cate is valid \nbefore permitting the code to be executed. The form of certi.ed code used in the prototype ConCert system \n[7] is Typed Assembly Language (TAL) [20, 19], as implemented in the TALx86 system [18], which was devel\u00adoped \nprimarily at Cornell. TALx86 specializes TAL to the Intel IA-32 architecture1 [15], and enhances it with \na num\u00adber of constructs not supported in the theoretical system. Although certi.ed code eliminates the \nneed to trust the developers of grid applications, there remains the need to trust the soundness of the \nsteward. For TALx86 (other production-quality certi.ed code systems such as the Java VM [17] or Proof-Carrying \nCode (PCC) [8] are similar), the need for trust stems from four issues: 1. TALx86 s safety is justi.ed \ninformally (by analogy to TAL and other work), not by any rigorous proof. 2. The safety of TAL (and \nTALx86 by analogy) is given in terms of an abstract machine. Although this ab\u00adstract machine is very \nlow-level for a type system, in a few ways it is still somewhat high-level compared to the concrete architecture, \nand obscures some important issues thereof. 3. The safety proofs that exist are given in written form, \nand consequently checking their veracity is error-prone and can be done only by experts. 4. One must \ntrust that the TALx86 type checking soft\u00adware correctly implements its type system.  To a certain extent, \nthe need to trust the steward under these conditions is not a serious obstacle. Machine owners routinely \ntrust the safety of a great variety of applications 1Popularly known as the x86 architecture. and have \nfar less formal basis for doing so. Moreover, a certain amount of trust is required in any case, since \nvery few participants will personally inspect any of the components of the system before using it. Nevertheless, \nminimizing the system s trusted computing base is always a laudable goal. For grid computing, however, \nthe desire to minimize trust in the steward goes beyond such general considera\u00adtions. The key issue is \nextensibility. Our aim is to enable the establishment of a decentralized grid computing fabric available \nfor a wide array of participants. For this purpose, it is implausible to imagine that a single type system \nwill suf\u00ad.ce for all potential grid applications. Furthermore, it is also implausible (and indeed undesirable) \nthat a single trusted agent would checkthe soundness of all proposed new type systems. Thus, it is necessary \nthat the basic steward can be safely extended with new type systems from untrusted sources. The natural \nway to achieve this is using foundational certi.ed code, in which the entire safety argument, down to \na safety policy expressed in terms of the concrete architec\u00adture, is given in machine-checkable form. \nIn its incarnation as foundational PCC [1], a binary is accompanied by an complete proof of its safety. \nIn our proposed foundational TAL, a program s safety argument is broken into two parts: The .rst portion, \na self-certi.ed type system, is the speci.\u00adcation of a type system and a machine-checkable proof that \nit satis.es an established safety policy. This portion would generally be independent of any particular \napplication. The second portion is the application s typing derivation in a certi.ed type system. In \nthis model, any grid application developer could de\u00advise his or her own type system su.cient to certify \nhis or her applications. Whenever a steward encountered a cer\u00adti.ed application referring to an unknown \ntype system, the steward would automatically download the type system, ver\u00adify its safety proof, and \nthereafter accept applications with valid typing derivations in that type system. This model addresses \neach of the four issues demand\u00ading trust of the new type system. The .rst three issues are clearly dealt \nwith by the use of complete, machine-checkable proofs. By packaging applications with typing derivations, \nas opposed to type annotations, the fourth issue is also ad\u00addressed: a single proof checker can check \nderivations for any type system, and no new checker need ever be employed. The aim of this workis to \nimplement a .rst example of foundational typed assembly language for the Intel IA\u00ad32 architecture, and \nalso to build a .exible foundation on which a variety of other type systems may be built. Accord\u00adingly, \nwe have broken the development of our system into two stages (in the model of Hamid, et al. s development \nof Featherweight TAL [13]): The .rst stage develops a general typed assembly lan\u00adguage that is not (very) \nspeci.c to any architecture. This general language is given an operational seman\u00adtics, and its abstract \nsafety is established by machine\u00adcheckable proofs of type preservation and progress. The safety of garbage \ncollection is also established at this level (Section 4).  The second stage shows that the abstract \noperational semantics maps correctly onto the concrete architec\u00adture. The general type system is designed \nto account  for all those issues that pertain to the type system (in\u00adcluding nearly all central issues), \nso this second stage is a type-free simulation argument. This topic of this paper is the .rst stage of \nthis e.ort. The second is currently underway. 1.1 TALT This paper presents a new typed assembly language \ncalled TALT ( TAL Two ). The aims of TALT are threefold: First, TALT is intended to provide su.cient \nexpressive power to serve as the target language for certifying compilers for expressive, high-level \nlanguages (in particular, Standard ML and Popcorn (a safe dialect of C) [18]). Second, TALT s operational \nsemantics is intended to account, to the great\u00adest extent possible, for the central issues of execution \non the actual hardware, so that the second stage of the founda\u00adtional safety proof discussed above is \na simple (albeit lengthy and tedious) simulation argument. Third, TALT is intended to be fully formalized \nand enjoy a machine-checkable type safety proof. We begin our discussion with an overview of how TALT \naccomplishes each of these aims: Expressiveness In order to provide the expressive power necessary to \ncompile practical, high-level programming lan\u00adguages, TALT follows TALx86 [18] in adding support for \nheterogeneous tuples (i.e., tuples in which not all .elds have the same size), recursive types, disjoint \nsums, and arrays. (Due to space considerations, discussion of arrays is omit\u00adted in this paper, and appears \ninstead in the companion technical report [10].) Unlike TALx86, however, TALT sup\u00adports these constructs \nusing a formalized type theory, rather than using specialized code in the type checker. TALT provides \nall the expressive power of the original published TALx86, with the exception of TAL s initializa\u00adtion \n.ags, which are replaced by another, slightly less gen\u00aderal mechanism (Section 2.2.2). Most later enhancements \nof TALx86 are not supported in TALT, although many could be added without di.culty. Completeness The \noperational semantics of TAL is spec\u00adi.ed in terms of a low-level abstract machine, including an explicit \nregister .le, memory, and (in stack-based TAL [19]) stack. This brings TAL nearly to as low a level as \npossible without committing to the details of an architecture. How\u00adever, the TAL machine model did not \ninclude a program counter; instead, it included a stream of input instructions that served as a surrogate \nfor the program counter. On any branch instruction, the machine would discard the current stream of instructions \nand copy in the instructions at the branch address. TALT, on the other hand, includes an ex\u00adplicit program \ncounter. A program counter must be part of the model to address a few important issues: On the concrete \narchitecture, it is possible in principle to write into the code just ahead of the program counter. This \nis rarely permitted in practice, of course, but even so, since programs are in fact stored in memory, \nit is an essential part of a foundational safety proof to explicitly address the issue. The requisite \nargument is not di.cult (TALT follows most standard practice and makes the code read-only), but the machine \nmodel must include an explicit program counter to make the argument at all. An explicit program counter \nis also necessary to account for the notion of relative addressing, which is particularly important on \nthe IA-32 where most control transfers (includ\u00ading all conditional jumps) are relative. Finally, an explicit \nprogram counter, or, more precisely, the fact that each in\u00adstruction is individually addressable, allows \nfor a true call instruction in which the return address is taken from the program counter. Our system \nincludes a conservative garbage collector [4] as part of its trusted computing base. This makes the garbage \ncollector e.ectively a part of the architecture. Ac\u00adcordingly, there is no need to prove that the collector \nitself is safe, but it is necessary to show that programs adhere to the invariants that the collector \nrequires [3, 2]. The TALT type system accounts for these invariants, and using those invari\u00adants we prove \nthat type safety is not disrupted by garbage collection (Section 4). In the interest of simplicity, the \nversion of TALT in this paper provides only a few representative arithmetic opera\u00adtions (add, subtract, \nand compare). We also omit any dis\u00adcussion of .oating point; this is because the IA-32 s imple\u00admentation \nof .oating point (using register stacks) is very idiosyncratic. We foresee no fundamental di.culties \nin ex\u00adtending TALT in either direction. TALT also follows stack-based TAL in viewing the stack as a separate \nunbounded resource, rather than as just a des\u00adignated area of memory. This dramatically simpli.es the \ntype system [19], but requires the second stage of the foun\u00addational safety proof to show that the TALT \nstackcan be mapped onto the concrete stack. The principal issue in do\u00ading so is stackover.ow, which we \naddress in Section 6. Machine-Checkable Proofs TALT is formalized in LF [14] as mechanized in the Twelf \nsystem [24, 25]. In accordance with the usual LF methodology, TALT typing judgements correspond to LF \ntypes, typing rules correspond to LF constants, and TALT typing derivations correspond to LF terms. The \nvalidity of a typing derivation can then be veri\u00ad.ed by type checking. Of central importance to this \ne.ort are the type safety meta-theorems (progress, type preservation, and GC safety). These are expressed \nin Twelf in relational form as logic pro\u00adgrams [22, 23]. In support of this, Twelf provides a totality \nchecker [27, 25] that ensures that the relations represent to\u00adtal functions, and are therefore valid \nmeta-proofs. This is discussedindetail inSection 5. It is important to note that decidable checking of \ntypabil\u00adity is not an aim for TALT. Unlike TAL and TALx86, TALT is a type assignment (or Curry-style) \nsystem; values contain none of the type annotations they carry in explicitly typed (or Church-style) \nsystems such as TAL. This means that checking the typability of TALT programs requires type in\u00adference, \nand since TALT s type system is polymorphic, this means that typability checking is almost certainly \nundecid\u00adable [31]. Consequently, the safety certi.cate for a TALT pro\u00adgram is an entire typing derivation, \nrather than as it is in TALx86 a collection of type annotations from which one can reconstruct a typing \nderivation. However, this is largely just a matter of presentation; a TALT typing derivation con\u00adtains \nlittle information that would not appear in type anno\u00adtations, and we conjecture that what overhead remains \ncan be eliminated using Necula and Rahul s technique [21]. unit values u ::= b| junk | a:i| .k:i values \nv ::= (u1,...,un) addresses a ::= e+n cond. codes cc ::= {cf . bit,zf . bit} memories H ::= {e1 . v1,...,en \nn} . vregister .les R ::= {r1 . v1,...,rN . vN ,fl. cc}states M ::= (H,R,a) Figure 1: Untyped TALT Syntax \nThis paper is organized as follows: We begin in Section 2 by presenting the basic TALT language, and \nin Section 3 we present extensions supporting disjoint sums and relative addressing. In Section 4 we \ngive our formalization of GC safety. Section 5 discusses the pragmatics of our machine\u00adchecked proofs. \nConcluding remarks follow in Section 6. 2Basic TALT We begin our presentation of the basic TALT language \nby presenting its untyped fragment in four parts: First we present the structure of values, second we \npresent the ma\u00adchine model, third we discuss the instruction set, and fourth we give its operational \nsemantics. Following this, we present the type system. Throughout this section we will remark on the \ndi.erences between TALT and TAL for the bene.t of those readers familiar with the latter; readers unfamiliar \nwith TAL may skip these remarks. We adopt the following notational conventions: W stands for the size \nof the machine word (measured in bytes, 4 for the IA-32); i, j, k, m and n range over nonnegative integers; \nbit ranges over {0,1}; b ranges over bytes (i.e., integers modulo 256); and B ranges over words (i.e., \ninte\u00adgers modulo 28W ). As usual, we consider alpha-equivalent expressions to be identical. However, \nsection identi.ers (e) and registers (r) will not be considered variables and will not alpha-vary; the \nonly variables appearing in TALT will be type constructor variables (a). 2.1 Untyped TALT Values TAL \nseparated its collection of values into two syn\u00adtactic classes, called heap and word values.2 This syn\u00adtactic \ndistinction determined what could .t into a register. In TALT, we combine these into a single syntactic \nclass of values that may vary in size, and use types rather than syn\u00adtax to determine how they may be \nused. The syntax of type-free TALT appears in Figure 1. Val\u00adues are simply sequences of zero or more \nunit values, each of which is exactly one byte in size. We construct values from unit values to ensure \nthat any byte (including bytes in the middle of an atomic object) may be addressed, and to make it easy \nto compute the size of any value. Note that it is not merely a cosmetic change to eliminate word values \nbut add unit values; unlike TAL s word values, unit values are 2 TAL also included a third class called \nsmall values. These were not truly values at all, and were renamed operands in later work [19], as they \nare called here. never objects of interest by themselves and are used only to construct values. By a \nconvenient abuse of notation, we will also often write values in the form (v1,...,vn),representing the \nap\u00adpending of several values. There are four forms of value that we may consider atomic: literal bytes \nb, junkvalues, addresses a (which are W bytes in length), and instruction encodings .k.The metavariable \n.k ranges over all k-byte instruction encodings. At this level of abstraction, it is not appropriate \nto specify the possible values for .k; instead, instead we assume the existence of a decoding function \n[ .k] that takes instruction encodings to instructions (.), which we discuss a bit later. Note that [ \n-] need not be injective, as a single instruction can have multiple encodings, nor need it be surjective. \nLiterals and junkvalues are one byte in size, and are represented directly as unit value constructs. \nHowever, ad\u00addresses and (usually) instruction encodings have size greater than one byte. Thus, the latter \ntwo forms of unit value rep\u00adresents bytes taken from larger atomic values: a:i represents the ith byte \nof the address a,and .k:irepresents the ith byte of the instruction encoding .k.When i is out of the \nappro\u00adpriate range, these constructs are considered junkvalues. We will rarely need to deal with subcomponents \nof ad\u00addresses and instructions, so for most purposes a and .k can be viewed as value forms, using the \nabbreviations: def a = (a:0,...,a:(W-1)) def .k = (.k:0,...,.k:(k-1)) We also write B for the encoding \nof B in bytes; on a little\u00adendian architecture such as the IA-32, B = (bW -1,...,b0)where B is b0b1 ...bW \n-1. Machine Model Like TAL, the TALT machine model con\u00adtains a memory and register .le, but it replaces \nTAL s stream of input instructions with an explicit program counter. We also augment the state with a \ncollection of con\u00addition codes (indicating the carry and zero .ags here, but it would not be di.cult \nto add more), which it is convenient to consider as part of the register .le, contained in a .ag (fl) \nregister. The TALT register .le has a .xed collection of N general-purpose registers, r1 through rN. \n3 (TAL, on the other hand, assumed an in.nite supply of registers.) The TALT memory is broken into sections, \nidenti.ed by section identi.ers e. A section represents an area of memory that is known to be contiguous. \nDistinct sections, however, appear in an unknown order in memory, possibly with inter\u00advening gaps. Thus, \nwe view the TALT memory as a map\u00adping of section identi.ers to values (since values are simply sequences \nof bytes). Any byte in memory can be addressed (subject to the limitations of the garbage collector) \nby com\u00adbining a section identi.er e with a numeric o.set n into the section to produce an address e+n. \nWhen we consider garbage collection in Section 4, it will be necessary for us to distinguish between \nthe heap (which the collector manages) and the remainder of memory. We refer to these portions as the \nheap and code segments. In anticipation of this development, we make a few remarks now. We view the segment \nthat a section resides in to be an intrinsic property of the section that may be determined 3On the IA-32, \nN is 7, since the stack pointer is treated specially (Section 2.3). registers r ::= r1 |\u00b7\u00b7\u00b7|rN operands \no ::= im(v) |rco(r) |mco(m,o,n) destinations d ::= rdest(r) |mdest(m,o,n) conditions . ::= eq |neq |lt \n|lte |gt |gte instructions . ::= add d,o1,o2 | cmp o1,o2 | jcc .,o | jmp o | malloc n,d | mov d,o | \nsub d,o1,o2 code I ::= . |.; I Figure 2: Instructions from its identi.er. This is formalized using two \npredicates; hseg(e)holds if eresides in the heap segment and conversely for cseg. The heap segment is \ntraced by the collector and is read/write; the code segment is not traced and is read-only. Newly allocated \nsections always appear in the heap segment. The Instruction Set The basic TALT instruction set is given \nin Figure 2. With the exception of malloc (which is implemented by the run-time system, rather than the \nar\u00adchitecture), the instructions should be familiar to any pro\u00adgrammer of the IA-32. Note that instructions \nare given in Intel-style (destination .rst) notation. Note also that the load and store instructions \nof TAL are omitted; they are re\u00adplaced by the mov instruction used with appropriate address\u00ading modes. \nCode sequences (I) are not used in the TALT operational semantics, but will arise in the type checking \nrules. Our notation for operands and destinations is more novel. The operand im(v) indicates an immediate \noperand, and the operand rco(r) indicates that the operand is the contents of the register r. The contents \nof memory are obtained using the operand mco(m,o,n), where o is a sub\u00adoperand providing an address; nindicates \na .xed o.set from that address at which to read, and mindicates the size of the operand to be read (typically \nW). Similarly, rdest(r) indi\u00adcates that the destination for the instruction is the register r,and mdest(m,o,n) \nindicates that the destination (of size m) is in memory, with the address indicated by the operand o \nplus o.set n. In order to make TALT as elegant and as general as pos\u00adsible, no e.ort has been made to \nlimit the available operands or operand/instruction combinations to those actually sup\u00adported on the \nIA-32 (or any other) architecture. (For exam\u00adple, no real architecture permits arbitrary chaining of \nindi\u00adrection through nesting of memory operands as TALT does; and few sizes of memory reads are permitted.) \nIt is more elegant to include a variety of unsupported possibilities, and to note that these unsupported \ninstructions are simply not in the range of the decoding function. Operational Semantics The operational \nsemantics are given in Figure 3. The main judgement is M .M', indicat\u00ading that the machine state M steps \nto the machine state M. . M . M' when M =(H,R,a) H(a)= (.k ,...) and: if [ .k]] is: then M' is: provided \nthat: add d,o1,o2 (H',R'{fl . cc},a+ k) M c o1 . B1 M c o2 . B2 B1 + B2 = B3(cc) M c d:= B3 . (H',R') \ncmp o1,o2 (H,R{fl . cc},a+ k) M c o1 . B1 M c o2 . B2 B1 - B2 = B3(cc) jcc .,o (H,R,a') R(fl) F . M c \no . a' jcc .,o (H,R,a+ k) \u00ac R(fl) F . jmp o (H,R,a') M c o . a' malloc n,d (H',R' ,a+ k) e is fresh and \nhseg(e) (H{ e. junkn} ,R,a) c d:= e+0 . (H',R') mov d,o (H',R' ,a+ k) M c o . v M c d:= v . (H',R') sub \nd,o1,o2 (H,R'{fl . cc},a+ k) M c o1 . B1 M c o2 . B2 B1 - B2 = B3(cc) M c d:= B3 . (H',R') Operand Resolution \n (H,R,a) c o . a' H(a')= (v1,v2,v3)|v1| = n |v2| = m M c im(v) . v (H,R,a) c rco(r) . R(r)(H,R,a) c mco(m,o,n) \n. v2 Destination Propagation |v| = W (H,R,a) c rdest(r):= v . (H,R{r . v}) (H,R,a) c o . e+n' H(e)= \n(v1,v2,v3)|v1| = n' + n |v| = |v2| = m hseg(e) (H,R,a) c mdest(m,o,n):= v . (H{e.(v1,v,v3)},R) Condition \nSatisfaction cc F eq i. cc(zf)=1 cc F neq i. cc(zf)=0 cc F lt i. cc(cf)=1 cc F gte i. cc(cf)=0 cc F \nlte i. cc(cf)=1 . cc(zf)=1 cc F gt i. cc(cf)=0 . cc(zf)=0 De.nitions def |(u1,...,un)| = n def H(e+n)= \nv2 where H(e)= (v1,v2) and |v1| = n def (e+n)+ k = e+(n+ k) def v n = (v,...,v) '-v \" n times Figure \n3: Operational Semantics kinds K ::= T types | Ti types of size i types t ::= a type variable | B0 null \nvalue | B1 bytes | t1 \u00d7 t2 tuples | box(t) pointers | mbox(t) mutable pointers | code(G) code values \n| G . 0 code pointers |.a:K.t universal quant. |.a:K.t existential quant. | t1 . t2 intersection type \n| t1 . t2 union type | ns top (nonsense) type | void bottom (empty) type | \u00b5a.t recursive type r. f. \ntypes G ::= {r1 : t1,...,rN : tN }mem. types . ::= {e1 : t1,...,en : tn}contexts . ::= a1:K1,...,an:Kn \nFigure 4: Type Syntax There are three main auxiliary judgements to discuss; with them established, and \nusing some auxiliary de.nition given in the .gure, the operational semantics should be entirely unsurprising. \nThe resolution of operands is formalized by the judge\u00adment M c o . v, which indicates that in machine \nstate M, the operand o resolves to value v. Propagation of computed results to their destinations is \nformalized by the judgement M c d:= v . (H,R), which indicates that in machine state M, when a destination \ndis assigned the value v, the resulting memory and register .le are H and R. Finally, conditions (for \nthe conditional jump jcc) are handled by the proposi\u00adtion cc F ., which is true if and only if the condition \ncodes cc satisfy the condition .. A few other points of notation merit comment. Note that the arithmetic \nequations in the semantics specify a condition code result as well as the numeric result. The condition \ncode results are determined in the usual manner: the carry .ag (cf) is set when the operation generates \na carry or borrow (formally, when the denormalized result lies outside the al\u00adlowable range), and the \nzero .ag (zf) is set when the result is zero. Map update is written H{e . v} for memories and similarly \nfor register .les. Map extension (for memories only) is written H{ e. v} ,when e is fresh.  2.2 The \nType System The types of TALT appear in Figure 4. The base types are B0 which is the type of the zero-length \nvalue (()), and B1 which is the type of byte literals. The most important type constructor is the product \nspace, t1 \u00d7t2, which contains values consisting of two adjacent values, having types t1 and t2. Since \nappending of values is associative and has a unit (namely ()), products are also associative and have \na (left and right) unit (namely B0); these equivalences are realized by a collection of subtyping rules. \nt0 def = B0 def tn+1 = t \u00d7 tn def int = B1W def W nsw = ns Figure 5: Type Abbreviations Note that unlike \nin TAL, a product space does not con\u00adtain pointers to tuples; in TALT the pointer is made explicit with \nits own type constructor (box, below). This is one fac\u00adtor necessary to combine TAL s heap and word values; \nsince tuples and pointers to tuples have di.erent types, they need not be distinguished by syntactic \nclass, as in TAL. Three di.erent types are provided for pointers: box(t) is the type of ordinary pointers \nto t, mbox(t)is the type of mutable pointers, and G . 0 is the type of code pointers. Each pointer type \nprovides di.erent privileges: box is co\u00advariant but immutable, mbox is mutable but invariant, and only \ncode pointers may be jumped to. A subtyping rule is provided for promoting mutable pointers to covariant \nones. A series of instructions can be given the type code(G) when it is executable provided the register \n.le has type G. The function space G .0 contains executable code pointers; G . 0 is like box(code(G)), \nexcept that the pointer must point into the code segment. Universal and existential quanti.ers, intersection \ntypes, union types, and recursive types are standard (for a Curry\u00adstyle system). The top type (ns) contains \nany value of size 1. (Wider top types may be de.ned by exponents of ns.) The bottom type (void) is empty. \nSeveral useful abbreviations (including a word-sized top nsw) are de.ned in Figure 5. There are two kinds \nfor TALT types: the kind T contains all types, and the sized kind Ti contains those types whose elements \nall have size i. For example, B0 belongs to T0 , B1 belongs to T1 ,and t \u00d7 t ' belongs to T(i+ j)if t \n: Ti and t ' : Tj . The various pointer types all belong to TW . Uninhabited types may vacuously belong \nto more than one sized kind (e.g., B0 . B1 belongs to T0 and T1 ,and void vacuously belongs to any Ti), \nbut any inhabited type has at most one sized kind. Register .le types give the type for each register \n(other than fl). In a well-formed register .le type, each register s type must have kind TW. Every register \nmust be included, so no width subtyping rules need be included. Instead, when a register s value is irrelevant \nit may be given the type nsw, and promotion to nsw can be done using depth subtyping. Heap types give \na type for each section. 2.2.1 Static Semantics The collection of judgements in the TALT static semantics \nis given in Figure 6. There are thirteen total judgements. Due to space considerations, the complete \nset of rules is not given here, but appears in the companion technical re\u00adport [10]. Three judgements \nare for type formation; these rules are unsurprising and are given only in the Appendix. Two judgements \nare for subtyping, one for ordinary types and one for register .le types; the latter simply applies the \nformer pointwise to each register s type. fM .f. .;. fH :. .;. fR :G cseg(e) .;.;G f[[[H(e+n)]]] f(H,R,e+n) \nwhere: def [[[(.k1 ,...,.kn )]]] =[[.k1 ]]; ...;[[.kn ]]; n 11 n .; . fH :. ' .; . fvi : ti (for 1 =i \n=n) .; . f{e1 .v1,...,en .vn}: {e1 : t1,...,en : tn} .; . fR :G .; . fvi : ti . fti : TW (for 1 =i =N) \n.; . f{r1 .v1,...,rN .vN ,fl .cc}: {r1 : t1,...,rN : tN } .; . fv : t .; . f(): B0 .; . f(b): B1 .; \n. f(u): ns .; .; G fo : t .; . fv1 : t1 .; . fv2 : t2 . fG .;.;G f[[[v]]] .; . fv : t G(r)= t .; . f(v1,v2): \nt1 \u00d7t2 .; . fv : code(G) .; .; G fim(v): t .; .; G frco(r): t . f.(e) =t1 \u00d7t2 . ft1 \u00d7t2 =.(e) . ft1 : \nTn . ft2 : T hseg(e) .; .; G fo: box(t1 \u00d7t2 \u00d7t3). ft1 : Tn . ft2 : Tm .; . fe+n : mbox(t2) .; .; G fmco(m,o,n): \nt2 .; .; G fo: t1 . ft1 =t2 . f.(e) =t1 \u00d7t2 . ft1 : Tn . ft2 : T .; .; G fo : t2 .; . fe+n: box(t2) \n. f.(e) =t \u00d7code(G) . ft : Tn . fG cseg(e) .; .; G fd: t .G ' .; . fe+n :G .0 . ft : TW .; .; G frdest(r): \nt .G{r:t} (.,a:K); . fv : t .; . fv : t1 .; . fv : t2 .; . fv : .a:K.t .; . fv : t1 .t2 .; .; G fo : \nmbox(t1 \u00d7t2 \u00d7t3). ft1 : Tn . ft2 : Tm .; .; G fmdest(m,o,n): t2 .G .; . fv : t1 . ft1 =t2 .; . fv : \nt2 Figure 7: Typing Rules (except instructions) Judgement Interpretation . ft : K t is well-formed with \nkind K . fG G is well-formed . f. . is well-formed . ft1 =t2 t1 is a subtype of t2 . fG1 =G2 G1 is a \nsubtype of G2 .; . fv : t .; .; G fo : t .; .; G fd : t .G ' value v has type t operand o has type t \npropagation of a value having type t to destination d results in a register .le with type G ' .; .; G \nfI code I is executable when the register .le has type G .; .; G f I inits r:mbox(t) discussed in Section \n2.2.2 .; . fH :. ' H is well-formed with type . ' .; . fR :G R is well-formed with type G fM M is well-formed \n Figure 6: Static Judgements The remaining judgements are for typing. Three are for typing values, operands, \nand destinations; two are for typing code (the second is an auxiliary judgement for typing tuple initialization \ncode); and the .nal three judgements are for typing machine states and their top-level components. Since \npointers may appear anywhereand thetypeof a pointer depends on the type of the value it points to, each \ntyping judgement (except state typing4) includes a memory type as part of the context. Operands, destinations, \nand code can also refer to registers, so their typing judgements also include a register .le type in \nthe context. The TALT typing rules appear in Figures 7 and 8 and are discussed below. Machine States \nThe typing rules for machine states are essentially the same as those of TAL. A state is well-formed \nif thereexists a memory type . and register .letypeG with respect to which the memory, register .le, \nand pro\u00ad 4 The state typing judgement omits a memory type because the full machine state is closed. Although \nthe full memory is also closed, the memory typing judgement still includes a memory type as part of the \ncontext because it is occasionally necessary to type check a memory under weakened assumptions. gram \ncounter may be consistently typed. To type checkthe program counter, the current code I is looked up \nin mem\u00adory at the program counter s address and type checked. The memory s series of bytes is converted \nto a code sequence by the function [ -] , which lifts the instruction decode function from single instructions \nto series of instructions. Two aspects of this will change in future developments. First, we will add \na second state typing rule for typing the in\u00adtermediate states of tuple initialization (Section 2.2.2). \nSec\u00adond, the decode function [ -] will be generalized to account for relative addressing (Section 3.2). \nValues Most of the value typing rules are self-explanatory, but the rules for pointers merit discussion. \nA pointer with o.set n may begiven thetype box(t2) when the section it points to can be given type t1 \n\u00d7t2 and all elements of t1 have size n (i.e., they are skipped by the o.set). Pointers e into the heap \nsegment may be given the stronger type mbox(t2), provided that .(e) is a subtype and asupertype of t1 \n\u00d7t2. This ensures that when a t2 is written backinto the heap object, the object still has type .(e), \nso the heap s type is unchanged. The value typing rules tell far from the entire story. Most of the .exibility \nof the TALT type system is provided by its subtyping rules. Subtyping provides the introduction facil\u00adity \nfor existential, union, and recursive types; the elimina\u00adtion facility for universal, intersection, and \nrecursive types; associativity and identity rules for products; and distribu\u00adtivity rules for intersection \nand union types and void. There are about .fty subtyping rules in all, listed in Appendix A; in the interest \nof brevity, we will discuss individual rules only as they arise. Operands and Destinations Since an operand \nmay be drawn from a register, the operand typing judgement in\u00adcludes the register .le s type in its context. \nSimilarly, since a destination may be a register, propagation of a value to a destination can change \nthe register .le type, and hence the destination typing judgement includes register .le types for before \nand after. The typing rules for memory operands and destinations are novel. Using the associativity and \nidentity subtyping rules for products,5 one casts the pointer s type in the form (m)box(t1 \u00d7t2 \u00d7t3), \nwhere t2 is the operand s type, and t1 and t3 are the types of the left and right residual values. The \nsizes are checked using kinds: t1 must have kind Tn to match the o.set, and t2 must have kind Tm to match \nthe operand size. Note that unlike register destinations, mem\u00adory destinations are forbidden to change \nthe data s type; allowing changes would be unsound due to the possibility of aliasing. Instructions With \nmuch of the type system moved into the rules for operands and destinations, the typing rules for in\u00adstructions \ngiven in Figure 8 should be largely as expected. The .nal two rules merit comment. The .rst is a subtyp\u00ading \nrule for code; it states that if I type checks under as\u00adsumptions G ' then it also type checks under \nthe stronger assumptions G. The second rule is the elimination rule for existential types. When a register \ncontains a value of exis\u00adtential type, it allows that value to be unpacked in place. 5Although mbox is \ninvariant, it does respect symmetric subtyping (that is, mbox(t) = mbox(t.)when t = t. and t. = t), so \nassociativity and identity for products can be applied beneath an mbox. .; .; G fo1 : int .; .; G fo2 \n: int .; .; G fd : int .G ' .; .; G ' fI .; .; G fadd d, o1,o2; I .; .; G fo1 : int .; .; G fo2 : int \n.; .; G fI .; .; G fcmp o1,o2; I .; .; G fo :G .0 .;.;G fI .; .; G fjcc ., o; I .; .; G fo :G .0 .; .; \nG fjmp o; I .; .; G fo : t .; .; G fd : t .G ' .; .; G ' fI .; .; G fmov d, o; I .; .; G fo1 : int .; \n.; G fo2 : int .; .; G fd : int .G ' .; .; G ' fI .; .; G fsub d, o1,o2; I .; .; G ' fI . fG =G ' .; \n.; G fI G(r)= .a:K.t (.,a:K); .; G{r:t}fI .; .; G fI Figure 8: Instruction Typing Rules (except allocation) \n(The TAL instruction unpack is obtained by combining a mov instruction with this rule.)  2.2.2 Allocation \nand Initialization The most complicated TALT typing rule is for malloc.A newly allocated tuple begins \n.lled with junkand is then initialized .eld-by-.eld. As a tuple is initialized, its type must change \nto re.ect its new components. This means that initialization is incompatible with our usual rule for \nmemory writes. TAL provided an elegant way to handle this using ini\u00adtialization .ags, in which the a \nnewly allocated tuple is essentially stamped with its ultimate type and any initial\u00adization must move \ntoward that ultimate type [11]. This addressed the aliasing problem because any aliases could have weaker \nviews of a tuple, but not incompatible ones. Moreover, since TAL con.ates the mechanisms of pointers \nand tuples, TAL can trackthe initialization of a tuple on a .eld-by-.eld basis. Thus, TAL permits the \ninterleaving of initialization with other computation. Unfortunately, (.eld-by-.eld) initialization .ags \nare in\u00adcompatible with TALT because of TALT s decoupling of pointers and tuples. Moreover, the .exibility \na.orded by initialization .ags appears rarely to be used in practice. Therefore, as an expedient alternative, \nTALT requires that a newly allocated object be fully initialized before any other computation takes place. \nDuring this uninterrupted initial\u00adization, it is easy to maintain the invariant that no aliases to the \nnew object exist. A more powerful account of initial\u00adization could likely be given using alias types \n[29], but we have not explored such an extension. .; .; G{r:nsw}fI inits r:mbox(ns n) .; .; G fmalloc \nn,rdest(r); I . ft =t1 \u00d7t2 \u00d7t3 . ft1 : Tn . ft2 : Tm . ft2 ' : Tm .; .; G fo : t2 ' .; .; G fI inits \nr:mbox(t1 \u00d7t2 ' \u00d7t3) .; .; G fmov mdest(m,rco(r),n),o; I inits r:mbox(t) .; .; G{r:mbox(t)}fI .; .; \nG fI inits r:mbox(t) Figure 9: Allocation/Initialization Typing Rules The rules implementing this mechanism \nappear in Fig\u00adure 9. The .rst rule provides that when an object is allo\u00adcated and its pointer is placed \nin register r,type checking moves into a special mode in which r s type can be updated, but r cannot \nbe used for any other purpose (the latter is en\u00adforced by giving it type nsw). After a series of initializing \nmoves, the .nal rule is used to make r an ordinary pointer and shift backinto the ordinary type checking \nmode. An ad\u00additional (ugly) rule for type checking machine states in the midst of initialization appears \nin the technical report [10]; it expresses the invariants of initialization so that the Type Preservation \nproperty can be established.  2.3 Stacks TALT supports stacks using type mechanism essentially identical \nto those of stack-based TAL [19], although a vari\u00adety of its special instructions have been folded into \nTALT s operand/destination mechanism. The full details appear in the technical report [10]. For reasons \nof brevity, we omit any discussion of stacks in the body of this paper beyond a few remarks here. Since \nTALT already has the notions of a null object (()) and of concatenation of objects in memory (\u00d7), there \nis no need to introduce special types (nil and ::)as in stack\u00adbased TAL. There is, however, a need for \na special kind: since the stack s type must determine its size, and TALT types do not always do so (e.g., \nB0 .B1), we require a kind of types whose size are determined (though possibly unknown, as for variables \nof kind TD). This kind, called TD,is rarely useful aside from stacks, so for practical purposes it serves \nas the kind of stack types.  2.4 Multiple Entry Points One facility provided by TALT that may not immediately \nbe obvious is the ability to jump into the middle of a block of code, which is impossible in TAL. Operationally \nit is clear that one can jump to any valid address. What is less obvious is that such jumps can be well-typed. \nSuppose H(e)= (vcode ,vmorecode ) where, for simplicity, (vcode ,vmorecode ) and vmorecode are each executable \nwith register .le type G, and suppose |vcode |= n. We wish to assign e atype sothat both e+0 and e+n \nhave types t ::= \u00b7\u00b7\u00b7|set=(B) |set<(B) |set>(B) .; . fB : set=(B) B<B ' B>B ' .; . fB : set<(B ' ) .;. \nfB : set>(B ' ) set=(B) = int set<(B) = int set>(B) = int set=(B) .set<(B) = void set=(B) .set>(B) = \nvoid set<(B) .set>(B) = void set<(B1) = set<(B2)(if B1 =B2) set>(B1) = set>(B2)(if B1 =B2) set=(B1) = \nset<(B2)(if B1 <B2) set=(B1) = set>(B2)(if B1 >B2) Figure 10: Integer Ranges type G .0. This is possible \nby giving e the type: code(G) .(ns n \u00d7code(G)) This makes it possible to structure TALT code with any \ndesired forward and backward jumps, without needing to insert arbitrary breaks for typing purposes. More \nimpor\u00adtantly, since any executable address can be given a type in this manner, TALT can support a true \ncall instruction in which the return address is obtained from the program counter. Details of the call \ninstruction appear in the tech\u00adnical report [10]. 3 Extensions 3.1 Disjoint Sums The standard implementation \nof a disjoint sum type, say int +(int \u00d7int), is as a pointer to a tuple whose leading .eld is a tag identifying \nthe arm of the sum. In TALx86, this idiom is supported directly by a special type for dis\u00adjoint sums. \nIn TALT, we decompose it into its primitive components: First we add the notion of a singleton type, \nwritten set=(B), containing only the integer B.With it, we can easily construct a type that faithfully \ncharacterizes this en\u00adcoding: box(set=(0) \u00d7int) .box(set=(1) \u00d7int \u00d7int)(*) An element of this type is \neither a pointer to an int following a zero tag, or a pointer to an int \u00d7int following a one tag. Figure \n10 gives the typing rules and some pertinent sub\u00adtyping rules for set=, and also for the upper and lower \nsub\u00adrange types set< and set>, which will be useful shortly. By themselves, these rules are not su.cient, \nhowever, because although the type above accurately expressed the members of a disjoint sum, it is not \nimmediately useful. The problem is the absence of an elimination rule for union types. We may load the \ntag word from o.set 0 into instructions . ::= \u00b7\u00b7\u00b7|cmpjcc o1,o2,., o3 t eq,B t neq,B == set=(B) t neq,B \nt eq,B sat unsat == set<(B) .set>(B) lt,B gte,B sat unsat t = t = set<(B) sat unsat lte,B gt,B t = t \n= set<(B) .set=(B) sat unsat t gt,B t lte,B == set>(B) sat unsat gte,B t lt,B tsat == set>(B) .set=(B) \nunsat .; .; G fo1 : int (1) .; .; G fo2 : set=(B) (2) .; .; G frco(r): t1 .t2 (3) . ft1 .t2 : TW .; .; \nG{r:t1}fo1 : t1 ' (5) .; .; G{r:t2}fo1 : t2 ' 1 ' .t .,B . ft =void (7) unsat ' .,B . ft2 .tsat =void \n.; .; G fo3 :(G{r:t1}) .0(9) .; .; G{r:t2}fI (10) .; .; G fcmpjcc o1,o2,., o3; I Figure 11: Union Elimination \nthe disjoint union, since: box(set=(0) \u00d7int) .box(set=(1) \u00d7int \u00d7int) = (distributing .over box) box((set=(0) \n\u00d7int) .(set=(1) \u00d7int \u00d7int)) = (distributing .over \u00d7) box((set=(0) .set=(1)) \u00d7(int .(int \u00d7int))) = (promotion \nof set= to int) box(int \u00d7(int .(int \u00d7int))) Then, by comparing the tag to zero, we may determine (dy\u00adnamically) \nwhich arm of the disjoint union the object be\u00adlongs to. However, with the rules discussed so far, there \nis no way to take advantage of that information in the static typing, so there is no way to access the \nvariant constituents of the disjoint union. To make it possible to eliminate union types, we add a new \ninstruction cmpjcc. Operationally, cmpjcc o1,o2,., o3 is identical to the two-instruction sequence cmp \no1,o2; jcc ., o3. What is special about this (pseudo-)instruction is its typing rule. Suppose r : t1 \n.t2,and r is used in the comparison of o1 to o2.(In the example above, r has type (*), and the comparison \nis of mco(W, rco(r), 0) to im(0) using condition eq.) The idea of the rule is to eliminate r s union \ntype by providing a static proof that r cannot have type t2 when the branch is taken, and that r cannot \nhave type t1 when the branch is skipped. It follows that r can be given type t1 for the branch, and t2 \nfor the non-branch. Consider the cmpjcc typing rule, given in Figure 11. Clauses 1 and 2 ensure that \nthe comparison itself is permis\u00adsible, and indicate that the value being compared against is the number \nB. In the event the branch is taken, o1 must .,B .,B have the type t ,and t if it is not. sat unsat Clause \n3 identi.es the union type of interest, t1 .t2.It follows that r has either type t1 or type t2.Clause \n5 then re-types the .rst operand in the .rst hypothetical circum\u00adstance. Thus, if r has type t1,then \no1 has type t1' . However, if the branch is skipped, o1 must also have the type t .,B , unsat and clause \n7 proves that both cannot simultaneously be true. Therefore, if the branch is skipped we may conclude \nthat r has type t2 (clause 10). A similar argument shows that if the branch is taken, we may conclude \nthat r has type t1 (clause 9). For example, suppose r has type (*) and we wish to jump if the tag is \nzero using cmpjcc mco(W, rco(r), 0), im(0), eq,ojump The .rst six clauses are easily established (using \nthe argu\u00adment above for clause 1); t1 ' and t2 ' workout to be set=(0) and set=(1). It remains to show \nthat set=(0) .(set<(0) .set>(0)) =void and set=(1) .set=(0) =void It is easy to obtain the .rst using \ndistributivity and the contradiction subtyping rules set=(B) .set<(B) = void and set=(B) .set>(B) = void. \nFor the second, observe that set=(1) =set>(0) and then the result follows by the latter contradiction \nsubtyping rule. Thus, we may continue type checking with a re.ned type for r in each branch. In the more \ngeneral case of n-ary sums, we may wish to case-analyze a sum using binary search to execute log2 n comparisons \nrather than n -1. This can be done using the same rule by choosing an inequality comparison rather than \nequality. To set up the rule, it is necessary to use the associativity of union types to cast an n-ary \nsum in the form of a single union type in which one arm is incompatible with branching and the other \nwith not branching.  3.2 Relative Addressing Given the TALT machine model, PC-relative addressing is \nnot di.cult to add operationally. We simply add a new operand form pcrel(\u00b1n) and the operand resolution \nrules: (H, R, a) c pcrel(+n) .a + n and a ' + n = a (H, R, a) c pcrel(-n) .a ' For the type system, however, \nmatters are trickier. Rela\u00adtive addressing creates a situation in which code (and there\u00adfore values in \ngeneral) may have a certain type only when it resides in a particular location, at least when viewed \nnaively. This situation is undesirable for two reasons: First, making the typing rules aware of the locations \nin which values re\u00adside would require wide-scale changes to the type system that would lessen its elegance. \nSecond, the resulting type system would be very unlike conventional type systems in which a value s type \ndoes not depend on where it is written. To preserve the type system in its current form, we in\u00adtroduce \na technical device we call delocalization. We employ a function deloc to convert relative addresses to \nabsolute ones. For example: deloc(a, pcrel(+n)) = im(a + n) deloc(a, pcrel(-n)) = im(a ' )(where a ' \n+ n = a) deloc(a, im(v)) = im(v) deloc(a, rco(r)) = rco(r) deloc(a, mco(m, o, n)) = mco(m, deloc(a, o),n) \nCode is always type checked in delocalized form, so no typing rule need be provided for relative operands. \nConsequently, the typing rules for instruction can be preserved without change. The burden of delocalization \nis assumed in the code typ\u00ading rule, where values are converted to code sequences for type checking. \nRecall the rule from Figure 8: . f G .;.;G f [[[v]]] (old).; . f v : code(G) First, we modify the decode \nfunction (now [ v]]]a) to account for delocalization: [[[(.k,v)]]]a= deloc(a,[[.k]]); [[[v]]](a+ k) [[[()]]]a= \n. Second, since the typing rule does not know where in mem\u00adory v lies, it is permitted to assume any \naddress (just as it may assume any register .le type) and it records the as\u00adsumption in the type: . f \nG.;.;G f [[[v]]]a (new).; . f v : code(a,G) The type code(a,G) should be read as code that may be executed \nwhen the register .le has type G, provided it resides at address a. The obligation is discharged in the \ntyping rule for code pointers, which admits only properly delocalized pointers as code pointers: . f \n.(e) = t \u00d7 code(e+n,G) . f t : Tn . f G cseg(e) (new) .; . f e+n :G . 0 Note that if a code blockis delocalized \nat an address other than where it resides, that address cannot be given a code pointer type. The only \nother change that must be made to the type system is that the top-level state typing rule must be mod\u00adi.ed \nin the obvious manner to account for delocalization: . f . .;. f H :. .;. f R :G cseg(e) .;.;G f [[[H(e+n)]]](e+n) \nf (H,R,e+n) 4GCSafety The principal safety results for TALT, as usual, are Progress and Type Preservation: \nTheorem 4.1 (Progress) If f M then M . M ' ,for some M ' . Theorem 4.2 (Type Preservation) If f M and \nM . M ' then f M ' . The Progress proof is by induction on the typing deriva\u00adtion. The Type Preservation \nproof is by case analysis on the evaluation derivation, with an outer induction on the typ\u00ading derivation \n(to handle the register .le subsumption and existential unpacking rules). .; .. f v : t .; .; G f im(v): \nt .; . f vi : ti (for 1 = i= n where hseg(ei)) .; .. f vi : ti (for 1 = i= n where cseg(ei)) .; . f{e1 \n. v1,...,en . vn} : {e1 : t1,...,en : tn} where .. =. I {e . dom(.) | cseg(e)} Figure 12: Modi.ed Rules \nfor GC Safety Additionally, since the TALT operational semantics does not account for garbage collection, \nwe must prove an addi\u00adtional result showing that garbage collection does not dis\u00adrupt typability. Like \nTALx86, TALT is designed for use with the Boehm-Demers-Weiser conservative garbage collector [4]. Therefore \nthere is no need to maintain any tagging invariants in order to assist the collector in distinguishing \npointers from inte\u00adgers. However, one GC safety condition must be maintained for the collector to function \nproperly [3]: Every live heap object must be reachable by a chain of pointers from the root set. A pointer \nis permitted to reach an object by pointing any\u00adwhere from the object s beginning to its end.6 Our root \nset is the collection of values in the register .le and stack. If this condition is not maintained, the \nonly consequence is that live objects may be garbage collected. Therefore, for our purposes we de.ne \na live object to be one whose presence is required for the state to be well-typed. Our main GC result \nthen will be a proof that garbage collecting unreachable objects cannot breaktypability of the state. \nIn order to satisfy the GC safety condition, we impose the following two invariants on well-typed TALT \ncode: 1. The code segment contains no (non-accidental) point\u00aders into the heap segment. 2. Immediate \noperands contain no (non-accidental) point\u00aders into the heap segment.  Invariant 1 is necessary because \nthe code segment is not part of the collector s root set. Invariant 2 is not stricly speaking necessary \nbut is not burdensome either; if an operand is part of an instruction in the code segment then invariant \n2 follows from invariant 1, and if not the instruc\u00adtion is useless anyway. The invariant is imposed because \nit dramatically simpli.es the development to follow, since it means there is no need to formalize how \nto lookfor pointers in code values. These invariants are achieved by replacing the typing rules for immediate \noperands and memories with the rules in Figure 12, which strip all heap sections from the memory type \nwhen typing code sections and immediate operands. To formalize the GC safety theorem, we need a de.nition \nof unreachability: 6Interior pointers are not permitted by Boehm and Chase s speci\u00ad.cation [3], but are \npermitted by the collector s implementation. A section is unreachable from the memory as a whole if every \nsection that can reach it is either untraced (i.e., in the code segment) or unreachable itself: De.nition \n4.4 Suppose S is a set of heap section identi\u00ad.ers. Then S is unreachable from H if for every e .dom(H), \neither cseg(e)or e .S or S is not H-reachable from H(e). De.nition 4.5 Suppose S is a set of heap section \nidenti\u00ad.ers. Then S is unreachable in (H, R, a)if: S is unreachable from H,and  for every r, S is not \nH-reachable from R(r), and  S is not H-reachable from R(sp).  Note that the de.nition of unreachability \nis not deter\u00administic. When S is unreachable in M, S can be as small as the empty set. The de.nition \nis crafted in this manner because we cannot predict what objects will actually be col\u00adlected by a conservative \ncollector. Instead, we prove our result for all unreachable sets, thereby covering whatever the collector \nturns out to do. Theorem 4.6 (GC Safety) Suppose S is unreachable in (H, R, a) and suppose that f(H, \nR, a).Then f(H \\S, R, a), where H \\S = H I (dom(H) \\S). The proof is by induction on the typing derivation. \nMachine-Checked Proofs The results of this paper are formalized as machine-checked proofs in the Twelf \nsystem [24, 25]. The .rst step in this for\u00admalization is to encode the TALT syntax, type system, and \noperational semantics as an LF signature [14] wherein judge\u00adments become types and derivations become \nterms. This process is standard, so we will not belabor it here. Once the language is formalized, we \ncan state and prove the principal meta-theorems: Progress, Type Preservation, and GC Safety. A meta-theorem \nstatement is encoded as a relation between derivations [22, 23]. For example, the principal meta-theorem \nstatements become: progress : machineok M -> stepsto M M -> type. %mode progress +D1 -D2. preservation \n: machineok M -> stepsto M M -> machineok M -> type. %mode preservation +D1 +D2 -D3. collect ok : collect \nM M -> machineok M -> machineok M -> type. %mode collect ok +D1 +D2 -D3. For instance, the progress theorem \nis a relation between machineok M derivations and stepsto M M derivations, and so forth. The %mode declaration \nfollowing each statement in\u00addicates the input and output arguments of the relation [26].  De.nition \n4.3 Suppose S is a set of heap section identi\u00ad.ers. Then S is H-reachable from v if v canbe writtenin \nthe form (v1,e+n, v2)for some e .S and n =|H(e)|. Proof Components lines purpose 210 252 320 349 361 \n372 399 407 429 515 537 548 592 713 844 925 1119 1245 Properties of canonical forms Properties of conditions \nProperties of memory lookup/update/extension Instruction decode lemmas Size lemmas Properties of register \n.le lookup/update Properties of values Equality lemmas Properties of natural number arithmetic Validity \n(well-behavedness of derivations) Canonical Forms lemma Lemmas regarding type formation Progress Weakening \nand strengthening of memory types Operand/destination lemmas Type Preservation GC Safety Properties of \nbinary arithmetic Table 1: Safety Proof Breakdown In each of these cases, the last argument (with the \n- mode) is the sole output argument. A proof of a meta-theorem so encoded is a logic program whose type \nis the relational encoding of the theorem. The program can then (in principle) be given derivations in \nthe input arguments and uni.cation variables in the output ar\u00adguments and executed to obtain the resulting \nderivations. A logic program represents a valid meta-proof if the execution always runs to a successful \nconclusion. The Twelf totality checker veri.es that the logic program is in fact total, with assistance \nfrom the programmer in iden\u00adtifying the induction variable(s). This consists of checking three facts: \n1. Mode checking: output arguments (and input argu\u00adment to subcalls) are fully determined. 2. Termination \nchecking: the induction variable(s) de\u00adcrease in all recursive calls. 3. Totality checking: in every \ncase analysis, all cases are covered.  For details, the reader is referred to Pfenning and Sch\u00a8urmann \n[25] or Sch\u00a8urmann [27]. The speci.cation of TALT in LF consists of 2081 lines of Twelf code, and the \ncomplete proof of Theorems 4.1, 4.2 and 4.6 consists of 10137 lines of Twelf code (including com\u00adments). \nA breakdown of the proof code for the interested reader is given in Table 1. The full proof takes approxi\u00admately \nthree minutes to checkin Twelf 1.3R3 on a Pentium 3 with 128 megs of RAM. 6 Conclusion TALT provides \nan elegant, expressive, and fully formalized type system for assembly language. The machine-checkable \nsafety theorems of Section 5 provide a complete safety ar\u00adgument for TALT programs in terms of a safety \npolicy ex\u00adpressed (by the operational semantics) at the assembly lan\u00adguage level. To complete a foundational \nTAL system, this workmust be combined with a proof that the TALT oper\u00adational semantics maps correctly \non the concrete architec\u00adture. TALT is designed so that this latter stage of the proof implementation \nis a type-free simulation argument. TALT is also designed to be easily adaptable to other architectures. \nThe general architectural constants (big\u00adendian vs. little-endian, the number of registers, and the size \nof the machine word) are parameters to the language and can easily be changed. New instruction can also \neas\u00adily be added; in fact, given the generality of the TALT operand/destination mechanism, many new instructions \nmay already be present. This means that the primary bur\u00adden of specializing TALT to an architecture is \naccounting for its idiosyncrasies (e.g., the IA-32 s treatment of .oat\u00ading point, or the delay slots \nfollowing jumps on many RISC architectures). One issue not addressed in TALT is the issue of pro\u00adcessor \nexceptions and faults (e.g., division by zero, stack over.ow, or various .oating-point exceptions). These \ncan be prohibitively expensive to prevent dynamically, and are di.cult to prevent statically. Fortunately, \nfor our purposes they can be safely ignored, assuming that the occurrence of an exception aborts the \nprogram, because a program that is no longer running is certainly safe. The issue of stackover.ow is \na little bit more involved, because we must ensure that any stackthat over.ows will cause the stackover.ow \nexception. We can do so by follow\u00ading the standard practice of preceding7 the stackin memory by at least \none (typically many) unmapped memory pages. Any push instruction that over.ows the stackwill there\u00adfore \nhit an unmapped page and cause the exception. The salloc instruction, which increases the stack s size \nby an arbitrary amount, is a bit trickier because it could skip all the unmapped pages and land in accessible \nmemory. We can prevent this by limiting salloc to one page at a time and forcing it to touch the top \nof the stackas push does. This ensures that any over.owing salloc will hit the unmapped page. To assist \nin the development of TALT programs, we have also designed an explicitly typed variant of TALT, called \nXTALT, that enjoys decidable type checking. XTALT adds type annotations to sections and replaces TALT \ns subtyp\u00ading with explicit coercions. We are implementing an assem\u00adbler that typechecks XTALT programs, \ngenerates the cor\u00adresponding TALT derivations, and compresses them using Necula and Rahul s technique \n[21]. Also under development is a Popcorn [18] to XTALT compiler. These tools can be combined with Dun.eld \ns Standard ML to Popcorn com\u00adpiler [12] (based on RML [30] and MLton [6]) to provide a complete certifying \ncompiler from Standard ML to TALT. A direct Standard ML to TALT compiler is also underway. References \n[1] Andrew W. Appel and Amy P. Felty. A semantic model of types and machine instructions for proof\u00adcarrying \ncode. In Twenty-Seventh ACM Symposium on Principles of Programming Languages, pages 243 253, Boston, \nJanuary 2000. [2] Hans-J. Boehm. Simple garbage-collector safety. In 1996 SIGPLAN Conference on Programming \nLanguage 7assuming a downward growing stack Design and Implementation, pages 89 98, Philadelphia, Pennsylvania, \nMay 1996. [3] Hans-J. Boehm and David Chase. A proposal for garbage-collector-safe C compilation. The \nJournal of C Language Translation, 4(2):126 141, December 1992. [4] Hans-J. Boehm and MarkWeiser. Garbage \ncollection in an uncooperative environment. Software Practice and Experience, 18(9):807 820, September \n1988. [5] Rajkumar Buyya and Mark Baker, editors. First Inter\u00adnational Workshop on Grid Computing, volume \n1971 of Lecture Notes in Computer Science, Bangalore, India, December 2000. Springer-Verlag. [6] Henry \nCejtin, Suresh Jagannathan, and Stephen Weeks. Flow-directed closure conversion for typed languages. \nIn European Symposium on Programming, March 2000. [7] Bor-Yuh Evan Chang, Karl Crary, Margaret DeLap, \nRobert Harper, Jason Liszka, Tom Murphy VII, and FrankPfenning. Trustless grid computing in Con-Cert. \nTechnical Report CMU-CS-02-152, Carnegie Mel\u00adlon University, School of Computer Science, June 2002. [8] \nChristopher Colby, Peter Lee, George Necula, and Fred Blau. A certifying compiler for Java. In 2000 SIG-PLAN \nConference on Programming Language Design and Implementation, pages 95 107, Vancouver, British Columbia, \nJune 2000. [9] ConCert. http://www.cs.cmu.edu/~concert,Septem\u00adber 2001. [10] Karl Crary. Toward a foundational \ntyped assembly language. Technical Report CMU-CS-02-196, Carnegie Mellon University, School of Computer \nScience, Decem\u00adber 2002. [11] Karl Crary and Greg Morrisett. Type structure for low-level programming \nlangauges. In Twenty-Sixth In\u00adternational Colloquium on Automata, Languages, and Programming, volume \n1644 of Lecture Notes in Com\u00adputer Science, pages 40 54, Prague, Czech Republic, July 1999. Springer-Verlag. \n[12] Joshua Dun.eld. Personal communication. [13] Nadeem Hamid, Zhong Shao, Valery Trifonov, Ste\u00adfan \nMonnier, and Zhaozhong Ni. A syntactic ap\u00adproach to foundational proof-carrying code. In Seven\u00adteenth \nIEEE Symposium on Logic in Computer Science, Copenhagen, Denmark, July 2002. [14] Robert Harper, Furio \nHonsell, and Gordon Plotkin. A frameworkfor de.ning logics. Journal of the ACM, 40(1):143 184, January \n1993. [15] Intel Corporation. IA-32 Intel Architecture Software Developer s Manual, 2001. Order numbers \n245470 245472. [16] Craig Lee, editor. Second International Workshop on Grid Computing, volume 2242 of \nLecture Notes in Computer Science, Denver, Colorado, November 2001. Springer-Verlag. [17] Tim Lindholm \nand FrankYellin. The Java Virtual Ma\u00adchine Speci.cation. Addison-Wesley, 1996. [18] Greg Morrisett, Karl \nCrary, Neal Glew, Dan Gross\u00adman, Richard Samuels, FrederickSmith, David Walker, Stephanie Weirich, and \nSteve Zdancewic. TALx86: A realistic typed assembly language. In Second Work\u00adshop on Compiler Support \nfor System Software,At\u00adlanta, May 1999. [19] Greg Morrisett, Karl Crary, Neal Glew, and David Walker. \nStack-based typed assembly language. Jour\u00adnal of Functional Programming, 12(1):43 88, January 2002. An \nearlier version appeared in the 1998 Work\u00adshop on Types in Compilation, volume 1473 of Lecture Notes \nin Computer Science. [20] Greg Morrisett, David Walker, Karl Crary, and Neal Glew. FromSystemFto typed \nassembly language. ACM Transactions on Programming Languages and Systems, 21(3):527 568, May 1999. An \nearlier version appeared in the 1998 Symposium on Principles of Pro\u00adgramming Languages. [21] George Necula \nand S. P. Rahul. Oracle-based checking of untrusted software. In Twenty-Eighth ACM Sympo\u00adsium on Principles \nof Programming Languages, pages 142 154, London, January 2001. [22] FrankPfenning. Logic programming \nin the LF logical framework. In G\u00b4erard Huet and Gordon Plotkin, ed\u00aditors, Logical Frameworks, pages \n149 181. Cambridge University Press, 1991. [23] FrankPfenning and Ek ehard Rohwedder. Imple\u00admenting the \nmeta-theory of deductive systems. In Eleventh International Conference on Automated De\u00adduction, volume \n607 of Lecture Notes in Computer Sci\u00adence, pages 537 551, Saratoga Springs, New York, June 1992. Springer-Verlag. \n[24] FrankPfenning and Carsten Sch\u00a8urmann. System de\u00adscription: Twelf a meta-logic frameworkfor deduc\u00adtive \nsystems. In Sixteenth International Conference on Automated Deduction, volume 1632 of Lecture Notes in \nComputer Science, pages 202 206, Trento, Italy, July 1999. Springer-Verlag. [25] FrankPfenning and Carsten \nSch\u00a8urmann. Twelf User s Guide, Version 1.3R4, 2002. Available electronically at http://www.cs.cmu.edu/~twelf. \n[26] Ekkehard Rohwedder and Frank Pfenning. Mode and termination checking for higher-order logic programs. \nIn European Symposium on Programming, volume 1058 of Lecture Notes in Computer Science, pages 296 310, \nLink\u00a8oping, Sweden, April 1996. Springer-Verlag. [27] Carsten Sch\u00a8urmann. Automating the Meta Theory \nof Deductive Systems. PhD thesis, Carnegie Mellon Uni\u00adversity, School of Computer Science, Pittsburgh, \nPenn\u00adsylvania, October 2000. [28] SETI@Home. http://setiathome.ssl.berkeley.edu, November 2000. [29] \nFrederickSmith, David Walker, and Greg Morrisett. Alias types. In European Symposium on Programming, \nBerlin, Germany, March 2000. [30] Andrew Tolmach and Dino P. Oliva. From ML to Ada: Strongly-typed language \ninteroperability via source translation. Journal of Functional Programming, 8(4):367 412, July 1998. \n[31] J. B. Wells. Typability and type checking in System F are equivalent and undecidable. Annals of \nPure and Applied Logic, 98(1 3):111 156, 1999. A Type Formation and Subtyping Rules .c :K .t1 :T .t2 \n:T .t1 :TD .t2 :TD .a :.(a).B0 :T0 .B1 :T1 .B :Num .t1 \u00d7t2 :T .t1 \u00d7t2 :TD .t1 :Ti .t2 :Tj .t :T .t :T \n.t :TD .t1 \u00d7t2 :T (i +j).box(t):TW .mbox(t):TW .sptr(t):TW .G.G.x :Num .x :Num .x :Num .code(a, G):T \n.G.0:TW .set=(x):TW .set<(x):TW .set>(x):TW .,a:K t :T .,a:K t :T .c :K .t[c/a]:K ' .,a:K t :T .,a:K \nt :Ti (K ' .{TD, Ti}) ..a:K.t :T ..a:K.t :K ' ..a:K.t :T ..a:K.t :Ti .,a:T t :T .,a:T t :T .t[\u00b5a.t/a]:K \n (K .{TD, Ti}) .ns :T1 .void :Ti .\u00b5a.t :T .\u00b5a.t :K .t1 :T .t2 :T .t1 :TD .t2 :T .t1 :T .t2 :TD .t1 \n:Ti .t2 :T .t1 .t2 :T .t1 .t2 :TD .t1 .t2 :TD .t1 .t2 :Ti .t1 :T .t2 :Ti .t1 :T .t2 :T .t1 :Ti .t2 :Ti \n.t :TD .t :Ti .t1 .t2 :Ti .t1 .t2 :T .t1 .t2 :Ti .t :T .t :TD .t1 =t2 '' .t1 =t .t2 =t .t1 =t2 .t2 =t3 \n12 '' .t =t .t1 =t3 .t1 \u00d7t2 =t1 \u00d7t 2 ' ' ''' .G =G.G =G.t =t .t =t .t =t ' '' .code(a, G)=code(a, G) \n.G.0=G ' .0.box(t)=box(t ).mbox(t)=mbox(t ) '' '' .t =t .t :TD .t :TD .,a:K t =t .,a:K t =t ' '' .sptr(t)=sptr(t \n)..a:K.t =.a:K.t ..a:K.t =.a:K.t .,a:K t :T .c :K .,a:K t :T .c :K (a .t)(a .t) ..a:K.t =t[c/a].t[c/a]=.a:K.t \n.t =.a:K.t ..a:K.t =t .t :Ti .,a:T t :T .,a:T t :T .t :T .t =nsi .void =t .t[\u00b5a.t/a]=\u00b5a.t .\u00b5a.t =t[\u00b5a.t/a] \n.t =t1 .t =t2 .t2 :T .t1 :T .t2 :T .t =t1 .t2 .t1 .t2 =t1 .t1 .t2 =t2 .t1 =t1 .t2 ' .t1 :Ti .t :Ti .t1 \n:T 1 '' '' .t2 =t1 .t2 .t .(t1 .t2)=(t .t1).(t .t2).(t1 \u00d7t2).(t \u00d7t )=(t1 .t )\u00d7(t2 .t ) 1212 .t \u00d7(t1 \n.t2)=(t \u00d7t1).(t \u00d7t2).(t1 .t2)\u00d7t =(t1 \u00d7t).(t2 \u00d7t) .t :T .t :T .t \u00d7void =void .void \u00d7t =void .mbox(t)=box(t).t1 \n\u00d7(t2 \u00d7t3)=(t1 \u00d7t2)\u00d7t3 .(t1 \u00d7t2)\u00d7t3 =t1 \u00d7(t2 \u00d7t3).t =B0 \u00d7t .B0 \u00d7t =t .t =t \u00d7B0 .t \u00d7B0 =t .set=(B)=int \n.set<(B)=int .set>(B)=int set=(B).set<(B)=void set=(B).set>(B)=void set<(B).set>(B)=void .int =.a:Num.set=(a) \nB1 =B2 B1 =B2 B1 <B2 B1 >B2 set<(B1)=set<(B2) set>(B1)=set>(B2) set=(B1)=set<(B2) set=(B1)=set>(B2) ' \n.G=G '' .ti =ti (for1=i =N).t =t '' .{r1:t1,..., rN:tN , sp:t}={r1:t1,..., rN:tN , sp:t ' }   \n\t\t\t", "proc_id": "604131", "abstract": "We present the design of a typed assembly language called TALT that supports heterogeneous tuples, disjoint sums, and a general account of addressing modes. TALT also implements the von Neumann model in which programs are stored in memory, and supports relative addressing. Type safety for execution and for garbage collection are shown by machine-checkable proofs. TALT is the first formalized typed assembly language to provide any of these features.", "authors": [{"name": "Karl Crary", "author_profile_id": "81100253026", "affiliation": "Carnegie Mellon University, Pittsburgh, PA", "person_id": "P157139", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/604131.604149", "year": "2003", "article_id": "604149", "conference": "POPL", "title": "Toward a foundational typed assembly language", "url": "http://dl.acm.org/citation.cfm?id=604149"}