{"article_publication_date": "01-01-1999", "fulltext": "\n Dependent Types in Practical Programming* (Extended Abstract) Hongwei Xi Frank Pfenning Department of \nComputer Science and Engineering Department of Computer Science Oregon Graduate Institute of Science \nand Technology Carnegie Mellon University hongweiQcse.ogi.edu fp@cs.cmu.edu Abstract We present an approach \nto enriching the type system of ML with a restricted form of dependent types, where type index objects \nare drawn from a constraint domain C, leading to the DML(C) language schema. This allows specification \nand in-ference of significantly more precise type information, facil-itating program error detection \nand compiler optimization. A major complication resulting from introducing dependent types is that pure \ntype inference for the enriched system is no longer possible, but we show that type-checking a sufficiently \nannotated program in DML(C) can be reduced to constraint satisfaction in the constraint domain C. We \nexhibit the un-obtrusiveness of our approach through practical examples and prove that DML(C) is conservative \nover ML. The main contribution of the paper lies in our language design, in-cluding the formulation of \ntype-checking rules which makes the approach practical. To our knowledge, no previous type system for \na general purpose programming language such as ML has combined dependent types with features includ-ing \ndatatype declarations, higher-order functions, general recursions, let-polymorphism, mutable references, \nand ex-ceptions. In addition, we have finished a prototype imple-mentation of DML(C) for an integer constraint \ndomain C, where constraints are linear inequalities (Xi and Pfenning 1998). Introduction Type systems \nfor functional languages can be broadly classi-fied into those for rich, realistic languages such as \nStandard ML (Milner, Tofte, and Harper 1990), Cam1 (Weis and Leroy 1993), or Haskell!(Hudak, Peyton Jones, \nand Wadler 1992), and those for small, pure languages such as the ones under-lying Coq (Dowek, Felty, \nHerbelin, Huet, Murthy, Parent, Paulin-Mohring, and Werner 1993), NuPrl (Constable et al. 1986), or PX \n(Hayashi and Nakano 1988). Type-checking in realistic languages should be theoretically decidable and \nThis research was sponsored in part by the Advanced Research Projects Agency CSTO under the title The \nFox Project: Advanced Languages for Systems Software , ARPA Order No. C533. Permission to make digital \nor hard copies ofall or part ofthis work for personal or classroom use is granted without fee provided \nthat copies arc not made or distributed for prolit or commercinl ad\\,anlqy and that topics bear this \nnotice and the full citation on the first page. To copy otherwise. to republish. to post on servers or \nto redistribute to lists, requires prior specific permission and/or a fee. POPL 99 San Antonio Texas \nUSA Copyright ACM 1999 l-58113-095-3/99/01...$5.00 must be practically feasible without requiring large \namounts of type annotations. In order to achieve this, the type sys-tems are relatively simple and only \nelementary properties of programs can be expressed and thus checked by a com-piler. For instance, the \nerror of taking the first element out of an empty list cannot be detected by the type system of ML since \nit does not distinguish an empty list from a non- empty one. Richer type theories such as the Calculus \nof In- ductive Constructions (underlying Coq) or Martin-Mf type theories (underlying NuPrl) allow full \nspecifications to be formulated, which means that type-checking becomes unde-cidable or requires excessively \nverbose annotations. It also constrains the underlying functional language to remain rel-atively pure, \nso that it is possible to effectively reason about program properties within a type theory. Some progress \nhas been made towards bridging this gap, for example, by extracting Cam1 programs from Coq proofs, by \nsynthesizing proof skeletons from Cam1 programs (Parent 1995), or by embedding fragments of ML into NuPrl \n(Kreitz, Hayden, and Hickey 1998). In this paper, we address the issue of designing a type system for \npractical programming in which a restricted form of dependent types is available, allowing more program \ninvariants to be captured by types. We conservatively refine the type system of ML by allowing some dependencies, \nwithout destroying desirable properties of ML such as prxtical and unintrusive type-checking. We now \npresent a short example from our implementa-tion before going into further details. A correct implemen-tation \nof the append function on lists should return a list of length m + n when given two lists of lengths \nm and n, respectively. This property, however, cannot be captured by the type system of ML. This inadequacy \ncan be remedied if we introduce a restricted form of dependent types. The code in Figure 1 is written \nin the style of ML with a type annotation, which will be explained shortly. We assume that we are working \nover the domain of natural numbers with constants 0 and 1 and the addition operation +. The datatype \na list is defined and then indexed by a natural number, which stands for the length of a list in this \ncase. The constructors of a list are then assigned dependent types: nil <I a list (0) states that nil \nis an a list of length 0. cons <I (n:nat) a * a list(n) -> a list (n+l) states that cons yields an a \nlist of length n+l when given a pair consisting of an element of type a and an a list of length n. We \nwrite Cn:nat) for the de-pendent function type constructor, usually written as IIn : nat, which can \nalso be seen as a universal quan-1997). For the domain of linear inequalities on integers, they tifier. \ninclude quicksort on arrays, mergesort on lists, a red/black The where clause in the declaration of append \nis a type an-notation, which precisely states that append returns a list of length m + n when given a \npair of lists of lengths m and n, respectively. Generally speaking, the programmer is responsible for \nrefining a datatype and programs are then automatically checked against type annotations with respect \nto the refinement made. Let us consider another short example. Suppose that we intend to specify that \nan implementation of the evaluation function for the pure call-by-value X-calculus returns a clo- sure \n(if it terminates) when given a closed X-expression. It seems difficult in ML, if not impossible, to \nconstruct a type for closed lambda expressions. With dependent types, this can be done elegantly. The \ndatatype lamexp in Figure 2 is a representation of X- expressions in de Bruijn s notation. For instance, \nXzXy.z(y) is represented as Abs (Abs (App (Shif t (One> , One) 1. lamexp is indexed with a natural number \nn, which roughly means that there are at most n free variables in a X-expression of type lamexp (n>.Therefore, \nlamexp (0) is the type for closed X-expressions. A complete implementation of the evaluation function \ncan be found in (Xi 1997). Adding dependent types to ML raises a number of theo- retical and pragmatic \nquestions. We briefly summarize our results and design choices. The first question that arises is the \nmeaning of expres- sions with effects when they occur as index objects to type families. In order to \navoid these difficulties we require index objects to be pure. In fact, our type system is parameterized \nover a domain of constraints from which type index objects are drawn. We can maintain this purity and \nstill make the connection to run-time values by using singleton types, such as int(n) which contains \njust the integer n. This is critical for practical applications such as static elimination of array bound \nchecking (Xi and Pfenning 1998). The second question is the decidability and practicality of type-checking. \nWe address this in two steps: the first step is to define an explicitly typed (and unacceptably verbose) \nlanguage for which type-checking is easily reduced to con-straint satisfaction in C. The second step \nis to define an elaboration from DML(C), a slightly extended fragment of ML, to the fully explicitly \ntyped language which preserves the standard operational semantics. The correctness of elab- oration and \ndecidability of type-checking modulo constraint satisfiability constitute the main technical contribution \nof this paper. The third question is the interface between dependently annotated and other parts of a \nprogram or a library. For this we use existential dependent types, although they introduce non-trivial \ntechnical complications into the elaboration pro-cedure. Our experience shows that existential dependent \ntypes are indispensable in practice. For instance, they are involved in almost all the realistic examples \nin our experi-ments. We have so far finished developing a theoretical foun- dation for combining dependent \ntypes with all the major features in the core of ML, including datatype declarations, higher-order functions, \ngeneral recursion, let-polymorphism, mutable references and exceptions. We have also imple- mented our \ndesign for a fragment of ML which encompasses all these features. The only main feature in the core of \nML which we have not implemented is records. In addition, we have experimented with different constraint \ndomains and applications. Many non-trivial examples are available at (Xi tree implementation, a highly \noptimized byte copy function, an implementation of Knuth-Morris-Pratt s algorithm for string matching \nand others in which array bound checks can be statically eliminated without excessive annotations. On \nsymbolic domains we have verified the type preservation property for an implementation of the evaluation \nfunction for the pure simply typed call-by-value X-calculus. Also a different red/black tree implementation \nis verified using a fi- nite domain, where the constraint solver is based on model-checking. In our experience, \nDML(C) is acceptable from the prag-matic point of view: programs can often be annotated with very little \ninternal change, annotations are usually to the point and roughly comparable to what one would find in \na typical ML program (including signatures). The resulting constraint simplification problems can be \nsolved efficiently in practice. Also the annotations are mechanically verified, and therefore can be \nfully trusted as program documenta-tion. Due to length restrictions, it is impossible to present here \nall aspects of DML(C). Instead, we concentrate on its main features. In contrast to (Xi and Pfenning \n1998), this extended abstract emphasizes the theoretical foundation of DML(C), showing that the type \nsystem of DML(C) is sound and type-checking in DML(C) can be made practical. We refer the interested \nreader to (Xi 1998) for the details. The remainder of the paper is organized as follows. We present a \nmonomorphic language ML0 in Section 2, which is a simply typed X-calculus with general pattern match-ing. \nWe start with a monomorphic language simply because the development of dependent types is largely orthogonal \nto polymorphism. We then introduce the notion of constraint domain in Section 3. We proceed to extend \nML0 with uni-versal dependent types in Section 4, leading to the language ML:(C) parameterized over a \nconstraint domain C. We give the typing rules and operational semantics of ML!(C) and show why the type \nsystem of ML:(C) can be regarded as a restricted form of dependent types. In Section 5, we present the \nrules for elaboration from DMLo(C), an exter-nal language, into ML, (C) and prove the correctness of \nthe elaboration. We explain the need for existential dependent types in Section 6 and extend ML:(C) to \nMLzl (C). We then briefly mention in Section 7 how dependent types can be combined with let-polymorphism \nand effects. In Sec-tion 8, we sketch some interesting applications. The rest of the paper is concerned \nwith some related work, current status and future research directions.  2 Mini-ML with Pattern Matching \n We start with a monomorphic programming language (MLo) along the lines of Mini-ML, including general \npattern match- ing which is critical in practice and whose theory in this setting is non-trivial. Polymorphism, \non the other hand, is largely orthogonal and therefore postponed until Section 7. There we also discuss \nhow to extend the language with ef- fects such as mutable references and exceptions. The syntax of ML0 \nis given in Figure 3. We sssume throughout that variables are declared at most once in a context and \nthat bound variables may be renamed tacitly. We omit the typing rules and the call-by-value natural \nsemantics of this language, which are completely standard. Given e,v in MLo, we write e -+o v if e evaluates \nto v. datatype a list = nil typeref a list of nat nil <I a list(O) I cons <I Cn:nat) a funOa> append(ni1, \nI append(cons(x, where append <I datatype lamexp ys) = ys xs>, ys) = cons(x, appendcxs, ys)) {m:nat){n:nat) \na list(m) * a list(n) -> a list (mtn) Figure 1: An introductory example: append = One I Shift of lamexp \nI Abs of lamexp I App of lamexp * lamexp typeref lamexp of nat with One <I Cn:nat> lamexp(n+l) I Shift \n<I {n:nat) lamexp(n) -> lamexp(n+l) I Abs <I {n:nat) lamexp(nt1) -> lamexp(n) I App <I {n:nat) lamexp(n) \n* lamexp(n) -> Figure 2: Another introductory Constraint Domains Our enriched language will be parameterized \nover a domain of constraints from which the type index objects are drawn. Typical examples include linear \ninequalities over integers, boolean constraints, or finite sets. Due to space limitations, we only briefly \nsketch the interface to constraints as they are used in our type system. First we note that constraints \nthemselves are typed. In order to avoid confusion we call the types of the constraint language index \nsorts. We use b for base index sorts such as boo1 for booleans and int for integers. We use f for in- \nterpreted functions symbols, p for atomic predicates (that is, functions of sort 7 + bool) and we assume \nto have con- stants such as equality G for every sort, truth values T and I, negation 7, conjunction \nA, and disjunction V, all of which are interpreted as usual. index sorts 7 ::= bllIyi*yzI{a:ylP} index \npropositions P ::= T 1 I 1p(i) I 4 A P2 I A v P2 Here {a : y ( P} is the subset index sort for those \nelements of 7 satisfying proposition P. For instance, nat is an abbre- viation for {o : int I a > 0). \nWe use a for index variables, and formulate index objects as follows. index objects i, j ::= a I () I \n(i, j) 1f(i) index contexts 4 ::= .I(&#38;a:rlqS,P index constraints Cp ::= P I +I A 91 I P > Cp 1 Va \n: 7.9 I 3a : y.@ satisfaction relation $I=@ The satisfaction relation 4 k 0 means that cf, is satisfied \nin the constraint domain under index context 4. The method for verifying such a relation depends on the \nconstraint do-main. For instance, model-checking can be chosen for finite domains. lamexp(n) example: \nclosed lambda expressions We omit the standard sorting rules for this index lan-guage and the standard \ndefinition of constraint satisfaction. The index constraints listed here are the ones which re-sult from \nelaboration and should therefore be practically solvable for C in order to obtain a usable type-checker \nfor DML(C). This is the case, for example, for integer inequal- ities, which our implementation solves \nby a variant of the Fourier variable elimination method. Empirical results and further references can \nbe found in (Xi and Pfenning 1998). 4 Universal Dependent Types We now present ML!(C), which extends \nML0 with univer- sal dependent types. Given a domain C of constraints, the syntax of ML:(C) is given \nin Figure 4. Note that only the syntax different from ML0 is present. We use 6 for base type families, \nwhere we use a() for unindexed types. We do not specify here how new type families or con-structor types \nare actually declared, but assume only that they can be processed into the form given above. Our im- \nplementation provides both built-in and user-declared re-finement of types as shown in the examples. \nThe typing rules for ML:(C) should be familiar from a dependently typed &#38;calculus (such as the ones \nunderly-ing Coq or NuPrl), except that we separate index variables, abstractions, and applications from \nterm variables, abstrac- tions, and applications. The critical rule of type conversion uses the judgment \n4 I- 71 I rs which is the congruent ex-tension of equality on index objects to arbitrary types: 4+iiii \n4 I- ri = r; fp I- 72 I r; f#l I- a(i) . a(i)) 4 k 71 * 72 I 7; * 7; I$ b 7; I ri 4 I- 72 3 r; $!J,o:ykr=r \nf#Jt- 7.1 + 7-z i r: + 7-i $5 I- no : 7. E l-h : 7. Notice that it is the application of these rules \nwhich gener- ates constraints. For instance, the constraint 4 k (o + n) + 1 k m + n is generated in order \nto derive 4 I- intlist((a + 1 cons of a * a list with (* indexing the datatype a list with nat *> * \na list(n) -> a list (n+l) base types p ::= boo1 1int 1(other user defined datatypes) types Q, r ::= pI11T*ulcT-iT \n patterns P ::= 2 I dd IO I bl,Pd matches ma ::= (p * e) I (p * e I ma) expressions e ::= x I () I (el, \ne2) I c(e) ) (case e of ms) I (lam x : 7.e) I el (e2) I let x = ei in e2 end 1 (Ax f : 7.21) values \n::= 2 I c(V) I () ( (m,V2) I (lam x : r.e) contexts : ::= . I r,z: 7 Figure 3: The syntax for ML0 families \n6 ::= (family of built-in or user-declared refined types) constructor signature S ::= * I S, c : IIai \n: 71. . . IIa, : ^Im. r + J(i) major types P ::= a(i) I 11 (71 * 72) 1 (Tl + T2) types r ::= p 1 (l-h: \n7.T) ..- patterns P ..-. . 1c[m]., . [an](P) ..- expressions e .*-. . . I c[i~].. . [in](e) I (Aa : \n7.e) I e[i] ..- values V ..-. . . I C[il] . . . [in](v) I (Xa : 7.v) ..- substitutions 8 ..-**. ]@Zl+_,i] \nFigure 4: The syntax for ML:(C) 4+ 1)z intliat(m + n) in an example below, where 4 is the derivation \nof such a judgment. m:nat,n:nat,a:nat,a+l+m. The only significant complication arises from pattern p \n.l rl D (4'; r') $,#;r,r' k-e : rz matching, where new index propositions P are generated. $;ri-p*e:Tl \nJT~ We restrict the index arguments to constructors appearing in patterns to index variables so that \npattern matches fail f$;r I- (p * e) :71 * r2 4;r I- rns :TI =s 72 or succeed independently of the indices. \nThis is essential to f$;l?l-(p*e~ma):~l=+r~ proving the conservativity of ML, (C) over MLe. The judgment \np J. T D (#;I ) expresses that the index For instance, also using the rules for expressions from and \nordinary variables in pattern p have the sorts and types Figure 6, it can be readily verified that the \nfollowing is deriv- declared in 4 and l?, respectively, if we know that p must able. have type r. It \nis defined by the following rules. m : nat, n : nat; append : r 2 J- 7 b (q 2 : T) 0 J- 1 D (*; .) I-(~44((~, \n41, v4 =+- coda + nl(b, amd4bl((~s, w4))) : intZist(m) * intliat(n) * intliat(m + n) plhD(h;rl) Pz172D(+z;r2) \n(p1,~2)~~l*~~D(~l,~2;rl,r2) where r is  IIm : nat.lln : nat. intliat(m) * intliat(n) + intliat(m + n) \nNotice that this involves deriving the following, which is Assume that cons is of type obviously true \nin an integer domain. IIa : nat.int * intZiat(a) + intliat(a + 1) m:nat,n:nat,a:nat,a+lkm since polymorphism \nis not available at this moment. Then + (a+n)+lGm+n the following is derivable. The remaining typing \nrules for ML!(C) are in Figure 6. (cons[a]((x, x3)), ya) 1 intlist(m) * intlist(n) We now present an \nexample in Figure 5, which is basi- D a:nat,a+lsm; cally an expression in ML, (C) corresponding to a \nmonomor- x : int, x.9 : intliat(a), ya : intliat(n) phic version of the code in Figure 1. We also present \na sug- ared version of the expression to enhance readability but we The judgment for match expressions \n4; l? I- ma : 71 + rz emphasize that there is no sugared syntax for MLb(C) in checks independently for \neach case that given a subject of our implementation (see Section 5). type ri the case branch will have \ntype 72. In other words, Next we turn to the operational semantics. The critical ri + 72 is the type \nof match ma. The following rules are for design decisions are that (a) indices are never evaluated, (b) \nindices are never used to select branches during pattern matches, and (c) we evaluate underneath index \nabstractions fix append : IIm : nat.k : nat.intlist(m) * intZist(n) + intlist(m + n). Am : natAn : nat.lam \n1 : intlist(m) * i&#38;list(n). case 1 of fun append CO] Cn] (nil, ys) = ys I append [a+11 Cnl (cons \nCal (x, x(t) , ys) = cons Cad (x , append [al Cnl (xs , ys> 1 where append <I {m:nat){n:nat) intlist(m) \n* intlist(n) -> intlist(m+n) Figure 5: An expression in ML, (C) and its sugared version $;I? l-e : 71 \n4 k 71 E 72 (ty_eq) r(z)= 7 4;r ~f.~f[\"\"\"l (tY-4 &#38;I? I- e : 72 S(c) = na : q.7 + b(i) f$G:~ q%;rl-v:T[a:=~ \n'(') = 6(i) (ty_cons_wo) 4;r t c: 6(i) 4; r k c[q(~) : a(i[a := i)) (ty-cons-w) 4; r I-el : 7l C#J;t-e2 \n: 72 r (ty-prod) +;rt-(el,e2):71*T2 dir k 0: 1 (ty-unit) f$l-71:* PJ~~D(#;P) +,+ ;r,r ke:T2 41-r2 :* \n(ty-match) &#38;rl-p*e:rl =3r2 &#38;rl-(p*e):TI=+-7 4;ri-m5:T137 (ty-mat ches) +;rk(p*elms):71*7 4;r \nk e: 7l 4; r t- ms : 71 + 7 tty_caseJ 4; r I- (case e of ms) : T q5,a:y;rke:T 4; r I- e : IIa : 7.~ C#J \n(ty_iapp) I- i : y 4; r I-(Xa : y.e) : (IIa : 7.7) (ty-ilam) 4; r I- e[i] : 7[a := i] 4; r, z : 71 I- \ne : r2 W k el;;;;e;e2ELk e2 : ~1 tty_appl (ty-lam) +;r t- (lam z : 7l.e) : 71 + ~2 f$;r I- el : 71 +;r,x \n: 71 i- e2 :72 (ty_let) qi; r t-let x = el in e2 end : 72 Figure 6: Typing Rules for ML, (C) Xa : y.e. \nWe do, however, substitute for index variables such that e _)d v is derivable. If qb; I? I- e : r is \nderivable, when a branch in a pattern match has been selected, or then q5; I? I- v : r is derivable. \nwhen a dependently typed function is applied to an index argument as in e[i]. These points together \nguarantee type Proof By a structural induction on the derivations of e +d vand4;rke:r. Hpreservation \nfor ML, (C) and conservativity over MLo. There is no obstacle preventing the evaluation of type in- The \nfollowing definition and theorems detail the rela-dices at, run-time--there is simply no need to do so. \nClearly, tionship between ML, (C) and MLo. Basically, MLF(C) is this would change immediately if run-time \ntype-checking be- a refinement of the type system of ML0 which allows us to came necessary, but we do \nnot intend to run DML programs express more properties, but neither affects the operationalwhich could \nnot be type-checked at compile-time. semantics nor the typing judgments already expressible in For the \nsake of brevity, we omit the operational seman- MLo. tics in this extended abstract. Given the remarks \nabove, it is straightforward to define e _)d v in the style of natural Definition 4.2 We define the index \nerasure fin&#38;on )I . 11 semantics, which means e evaluates to v in ML, (C). Next, we prove the central \nproperties of ML, (C). The first basic property states that dependent types are pre-served under the \noperational semantics. Theorem 4.1 (Type preservation) Given e,v in ML:(C) as follow3: Mil ,...,iJl = \n6 1171* Al = IhI1 * 117211 IIn -+ 7211 = +  11~11111741 llna : 7.41 = llrll II44 . . . MWII = 4ll4) \nII(lam x : 7.e)ll 1 1;;; x : 11~1144) ~~Oyll: r.e)ll = II:11 11:: z : 7.2111 = Ax x : llTll.1lVll IF, \nx : 41 = Ilrll,~ : lldl It maps an expression in ML:(C) into one in MLo. Note that a few trivial cases \nare omitted for the sake of brevity. The erasure of a program written in ML, (C) is executed in MLo. \nIn general, the erasure of a DML program is executed in ML. The next theorem guarantees that the index \nerasure of a well-typed program in ML, (C) is also well-typed in MLo. Theorem 4.3 If 4; l? I- e : 7 is \nderivable in ML, (C), then llrll k [IelI : 11~11 isderivable in MLo. Proof By a structural induction \non the derivation of 4; l? I- e : 7. . A significant consequence of Theorem 4.3 is that if an untyped \nprogram is typable in ML:(C) then it is already typable in MLo. This distinguishes our design from those \nwhich aim at making more programs typable by extending the type system of ML. Instead, our objective \nis to assign more accurate types to programs. Also we must guarantee that the operational semantics of \na program in ML:(C) is preserved when it is evaluated in MLo. This is done by the following two theorems. \nTheorem 4.4 (Soundness) If e _)d v derivable in ML:(C), then llell +o Ilull is derivable. Proof By a \nstructural induction on the derivation of e +d 2). . The corresponding completeness property relies on \nthe restrictions on the form of constructor types and the index arguments to constructors in patterns. \nTheorem 4.5 (Completeness) Given 4; r I- e : r derivable in ML!(C). If llell +O vg is derivable for some \nvg in MLo, then there exists v in ML:(C) such that e _)d v and ~~v~~ = vo. Proof By a structural induction \non the derivations of [IelI +O v. and 4; r b e : T. w It is a straightforward observation on the typing \nrules for ML, (C) that the following theorem holds. Therefore, if the user does not index any types, \nthen his code is valid in ML, (C) iff it is valid in MLo. Theorem 4.6 ML, (C) is a conservative extension \nof MLo. We call the type system of ML, (C) a restricted form of dependent types since we view both index \nobjects and ex-pressions in ML:(C) as terms. In this view, the type of one term can depend on the valve \nof other terms. For instance, the type of append[m][n]((xs, ys)) depends on m and n. An alternative is \nto view index objects as types, and therefore to regard the type system of ML, (C) as a polymorphic type \nsystem. However, this alternative leads some (unnecessary) complications. For instance, it is unclear \nwhich expressions are of type i if i is an index object. A more serious problem is how subset sorts should \nbe treated under this alternative view. In a filly dependent type system such as the one which underlies \nLF (Harper, Honsell, and Plotkin 1993) or Coq, there is no differentiation between type index objects \nand language expressions. In other words, the constraint domain is the same as the language. Therefore, \nconstraint satisfac-tion is as difficult as program verification, which seems to be intractable in practice. \nThe novelty of ML:(C) is precisely the differentiation between type index objects and language expressions, \nwhich makes our approach practical and scal-able.  5 Elaboration We have so far presented an explicitly \ntyped language ML:(C) . This presentation has a serious drawback from a program-mer s point view: one \nwould quickly be overwhelmed with types when programming in such a setting. It then becomes apparent \nthat it is necessary to provide an external language DMLo(C) together with a mapping to the internal \nlanguage ML, (C). This mapping is called elaboration. For instance, the declaration of (a monomorphic \nversion of) append in Figure 1 is to be elaborated into the ML: (C)-expression in Figure 5. 5.1 The \nExternal Language DMLo(C) The syntax for DMLo(C) is given as follows. patterns p ::= x I c(P) I 0 I (Pl!P2) \nmatches ms ::= (p*e)I(p=FeIms) expressions e ::= x I c(e) I () I (el,e2) I case e of ms I el(e2) 1lam \nx.e 1lam 2 : T.e I let 2 = el in e2 end I fix f.v I fix f : T.V 1 e : T Note that this is basically the \nsyntax for ML0 though types here could be dependent types. This partially attests to the unobtrusiveness \nof our enrichment.  5.2 Elaboration as Static Semantics We illustrate the intuitions behind some elaboration \nrules while presenting them. Elaboration, which incorporates type-checking, is defined via two mutually \nrecursive judg- ments: one to synthesize a type where this can be done in a most general way, and one \nto check a term against a type where synthesis is not possible. A synthesizing judgment has the form \n+;I t-e t 7 =X e and means that e elab- orates into e with type r. A checking judgment has the form 4; \nr I- e .J r =S e and means that e elaborates into e against type 7. In general, we use e,p,ms for external \nexpressions, patterns and matches, and e*,p , ms for their internal counterparts. The purpose of the \nfirst two rules is to eliminate II quan- tifiers. For instance, let us assume that el(e2) is in the code \nand a type of form Ha : 7.~ is synthesized for el; then we must apply the rule (elab-pi-elim) to remove \nthe II quan- tifier in the type. We continue doing so until a major type is reached, which must be of \nform ~1 + 72 (if the code is type-correct). Note that the actual index i is not locally determined, \nbut becomes an existential variable for the con- straint solver. The rule (elab-pi-intro) is simpler \nsince we check against a given dependent function type. 4,a:r;rt-eJT*e* 4; r I-e 1 lla : 7.7 * (Xa  \n : r.e*) (elab-pi-intro) The next rule (elab-lam) is for lambda abstraction, which checks a lam expression \nagainst a type. The rule for the fixed point operator is similar. We emphasize that we never synthesize \ntypes for either lam or Ax expressions (for which principal types do not exist in general). 4; r, x : \n~~ !- e 1 rz * e* 4; r t- (lam x.e) J. Tl + 72 * (lam x : 71.6;) The next rule (elab-app-up) is for function \napplication, where the interaction between the two kinds of judgments takes place. After synthesizing \na major type ~1 + ~2 for el, we simply check e2 against 71-synthesis for e2 is unneces- sary. We maintain \nthe invariant that the shape of types of vaxi- ables in the context is always determined, modulo possible \nindex constraints which may need to be solved. This means that with the rules above we can already check \nall normal forms. A term which is not in normal form most often will be a let-expression, but in any \ncase will require a type an-notation, as illustrated in the rule (elab-let-down) below. q3;rI-el t 71 \na f3i 4; r, 2 : 71 b e2 J- 72 * eZ 4; r, x : 71 I- let x = el in e2 end J- 72 j e* where e* = let x = \nei in e; end. Even if we are checking against a type, we must synthesize the type of el. If el is a function \nor fixpoint, its type must be given, in practice mostly by writing let x : 7 = el in e2 end which abbrevi- \nates let c = (el : T) in e2 end. The following rule allows us to take advantage of such annotations. \nr e 7 * e* (elab anno up) 4;rl-(e:7)?7*e* _ - As a result, the only types which itre required in realistic \nprograms are due to declarations of functions and a few cases of polymorphic instantiation. Moreover, \nin the presence of existential dependent types, which will be introduced in Section 6, a pure ML type \nwith- out dependencies obtained in the first phase of type-checking is assumed if no explicit type annotation \nis given. This makes our extension truly conservative in the sense that pure ML programs will work exactly \nas before, not requir- ing any annotations. Elaboration rules for patterns are particularly simple, due \nto the constraint nature of the types for constructors. We elaborate a pattern p against a type r, yielding \nan in- ternal pattern p and index and term contexts 4 and I , re- spectively. This is written as p &#38; \nT + (p*; 4; l?) in Figure 7. This judgment is used in the following rule (elab-match) for pattern matching: \nthe generated context 4 is assumed x~T=+(x;~;x:T) 0 1 1 * (0; i *I PI -1~1 3 Cpi;41;rl) ~2 4~2 * (p;;42;r2) \n(Pl,p2) 4~~ ~~~ + ((p:,p4)i~l,~2;rl,r2) S(C)= na : 7.7 -+ a(i) p 4 T =$ (p*; 4; r) 4~) 4 a(j) + (4-w); \n2 : 7, i k j, 4; r) Figure 7: The elaboration rules for patterns into the context 4 while elaborating \ne. For constraint satis- faction, the declarations in I#J are treated as hypotheses. The complete elaboration \nrules for DMLo(C) are listed in Appendix B, and they are justified by the following theorem. Theorem \n5.1 Let Z be the operational equivalence relation. 1. If q5; r i- e t r + e* is derivable, then q5; I? \nI- e* : T is derivable and e P e' . 2. Ifqi;rl-eJ_r=+e* isderivable, thenq5;rke :ris derivable and e \ng e* .  Proof (1) and (2) follow straightforwardly from a simul- taneous structural induction on the \nderivations of r I- e t r=+e* and4;I ke$rje*. . The description of type reconstruction as static seman-tics \nis intuitively appealing, but there is still a gap between the description and its implementation. There, \nelaboration rules explicitly generate constraints, thus reduce dependent type-checking to constraint \nsatisfaction. This kind of trans- formation is standard and therefore omitted here. For in- stance, when \nelaborating the first and second clauses in the function declaration in Figure 1, we generate the following \ntwo constraints, which are obviously true. Vn : nat.O + n L n Vm : nat.Vn : nat.Va : nat. a+l~m>(a+n)+l~m+n \n Therefore the code is well-typed in ML, (C). A thoroughly explained example on elaboration and constraint \ngeneration is available in (Xi 1998). 6 Existential Dependent Types In practice, the constraint domain \nmust be relatively sim-ple to permit the implementation of an effective constraint solver. Therefore \nthere remain many properties of indices which cannot be expressed. For instance, if we apply the following \nfilter function to a list of length n, we cannot express the length of the resulting list since it depends \non the predicate p. fun filter p nil = nil I filter p (x::xs) = if p(x) then I:: (filter p xs) else (filter \np x8) Nonetheless, we know that there exists some m 5 n such If we check append((l,l )) against Ca : \nnat.intlist(a), then that the length of the resulting list is m, which can be ex-append( (1,1 )) istranslated \nto pressed using an existential dependent type, also called weak dependent sum. Also, existential types \ncan mediate between dependent and ordinary ML types. For instance, given a function of ML type a list \n-> a list, we can assign to it a dependent type which states that the function returns a list of unknown \nlength when applied to a list of unknown length. This yields an approach to handling existing func-tions \nsuch as those in a library, whose definitions may not be available. Notice that this is crucial to support \nsepa-rate compilation. However, the use of existential types to represent ML types leads to a major loss \nof information at module boundaries. We would like soon to address this issue by exporting dependent \ntypes in signatures, extending DML to full SML. This approach closely relates to Extended ML (Sannella \nand Tarlecki 1989). We now extend ML:(C) to ML: (C). ..- 7 ..-. . . 1 (Ca : -y*T) expressions e ::= \n... I 6 I 4 I let (a 1 z) = el in ez end .._ types values 21 ..-. . . 1 (i I v) We need the additional \ntyping rules (t-sig-intro) and (t-sig-elim) 4; l? I- e : ~[a := i] I- i  (t-s&#38;intro) 4; l? I- (i \n1 e) : (Ca : 7.7) $;rt-el:Ea:7.71 f$,a:y;r,2:71+e2:72 (t-sig-elim)4; I k let (a I z) = el in e2 end \n: 72 where a may not occur in 72 in the latter (in addition to the general assumption that a and x are \nnot already declared in 4 and I?, respectively). For instance, we can assign the following type to the \nfunction filter: ( a -> bool) -> In:nat) 'a list(n) -> Cm:nat I m<=nI 'a list(m), where Cm:nat Im<=nl \nstands for Cm: {a : not I a 5 n}. Also, we can assign the type ([n:natl a list(n)) -> [n:nat] a list(n), \nto any function of ML type a list -> a list. We can then prove all the theorems in Section 4 for MLfl \n(C). It is also straightforward to give a sound elabo-ration procedure from DMLo(C) to MLfYc(C). The \nfollow-ing is a significant rule for this purpose.  4; r I- el t Ca : 7.~1 * e; 4; r I- let x = el in \ne2 end $72 + e , where e is let (a I z) = ei in eg end. Unfortunately, this elaboration rule requires \na let to be present in the source when eliminating an existential de-pendent type, which will not be \nthe case in many typical ML programs. We therefore apply the A-translation (Moggi 1989; Sabry and Felleisen \n1993) before elaboration. For ex-ample, suppose that the synthesized types of I and 1 are Ca : nat.intlist(a), \nthat is, the lengths of 1 and 1 are unknown. let x = 1 in let z = 1 in append((z,z )) end end, which \nis then elaborated into let (a I x) = I in let (a I 2 ) = 1 in (a + a I append[a][a ]((z, z ))) end end \n There are some pragmatic issues on whether A-translation should be controlled by the programmer or applied \nauto-matically. We have chosen the latter in our current imple-mentation. Please see (Xi 1998) for details. \n7 Polymorphism and Effects It is straightforward to extend ML: (C) with polymor-phism. We have designed \na two-phase elaboration algorithm which elaborates a program as follows. Phase one It verifies that the \nindex erasure of the program is a well-typed ML program. Phase two It then applies the elaboration algorithm \nfor ML:* (C) to the result obtained in phase one. If a needed type annotation is unavailable, the type \nin- ferred in phase one is supplied. This guarantees that a valid ML program is always valid in DML(C). \n The type system becomes unsound if dependent types are combined directly with effects. The symptom is \nthe same as that of combining polymorphism with effects. Soundness can be recovered if we adopt a value \nrestriction, that is, we replace the rule (ty-ilam) with the following.  4,a:y;rkv:T 4; r I- (Xa : 7.~) \n: (Ha : 7.~) After this, the development is standard, which is thoroughly explained in (Xi 1998). 8 \nApplications 8.1 Program Error Detection A red/black tree is a balanced binary tree which satisfies the \nfollowing conditions: (a) all leaves are marked black and all other nodes are marked either red or black; \n(b) for every node there are the same number of black nodes on every path connecting the node to a leaf, \nand this number is called the black height of the node; (c) the two sons of every red node are black. \nIn Figure 8, we define a polymorphic datatype a diet, which is essentially a binary tree with colored \nnodes. We then refine the datatype with type index objects (c, bh) drawn from the sort bool * nut, where \nc and bh are the color and the black height of the root of the binary tree. The node is black if and \nonly if c is true. Therefore, the properties of a red/black tree are naturally captured with this datatype \nrefinement. This enables the programmer to catch program errors which lead to violations of these properties \nwhen im-plementing an insertion or deletion operation on red/black trees. We have indeed encountered \nerrors caught in this way in practice. The types of other balanced trees such as AVL trees can be declared \nsimilarly (see Appendix A). type a entry = int * a datatype a diet = Empty (* considered black *) I Black \nof a entry . a diet * a diet 1 Red of a entry * a diet * a diet typeref a diet of boo1 * nat with Empty \n<I a dict(true, 0) I Black <I icl:bool){cr:bool)<bh:nat) a entry * a dict(c1, bh) * a dict(cr, bh) -> \na dict(true, bh+l) I Red <I ibh:nat) a entry * a dict(true, bh) * a dict(true, bh) -> a dictcfalse, bh) \n Figure 8: The red/black tree data structure  8.2 Array Bound Check Elimination We refine the built-in \ntypes: (a) for every integer n, int(n) is a singleton type which contains only n, and (b) for every natural \nnumber n, a array(n) is the type of arrays of size n. We then assume that the array operations sub and \nupdate have been assigned the following types. sub <I (n:nat) Ci:nat I i < n) a array(n) * int(i) -> \na update <I in:nat) Ci:nat I i < n) a array(n) * int(i) * a -> unit Clearly, the array accesses through \nsub or update cannot result in array bounds violations, and therefore it is unnec- essary to insert array \nbound checks when we compile the code. Please see (Xi and Pfenning 1998) for the details. 8.3 Dead Code \nElimination The following function zip zips two lists together. If the clause zip(_, _) = raise zipException \nis missing, then ML compilers will issue a warning message stating that zip may result in a match exception. \nThis happens if two argu- ments of zip are of different lengths. exception zipException fun(,a, b) zip(ni1, \nnil) = nil I zip(cons(x, x18), cons(y, ys)) = cons((x,y), zip(xs, ys>) I zip(_, _I = raise zipException \nHowever, this function is meant to zip two lists of equal length. If we declare zip to be of the following \ndependent type, Cn:natI ,a list(n) * ,b list(n) -> (,a * b) list(n) the clause zip(_, _) = raise zipException \nin the defini-tion of zip can never be reached, and therefore can be safely removed. This leads to not \nonly more compact but also potentially more efficient code. For instance, if it has been verified that \nthe first argument of zip is non-empty, then the second argu-ment must also be non-empty. Therefore, \ntag-checking can be reduced significantly when this example is implemented. Such examples are abundant \nin practice. It will not be straightforward to extend the usual pattern compilation algorithms to take \nadvantage of such additional information, and we have not yet tried this idea in a com- piler. However, \nthe benefit of such dead code elimination for error detection can be readily realized. We refer the interested \nreader to (Xi 1999) for further explanation. 8.4 Other Applications There are many other potential applications \nof dependent types which can be found in (Xi 1998), including facili-tating partial evaluation, performing \nloop-unrolling, passing dependent types to an assembly language, etc. 9 Related Work Our work falls in \nbetween full program verification, either in type theory or systems such as PVS (Owre, Rajan, Rushby, \nShankar, and Srivas 1996), and traditional type systems for programming languages. When compared to verification, \nour system is less expressive but more automatic when con-straint domains with practical constraint satisfaction \nprob-lems are chosen. Our work can be viewed as providing a systematic and uniform language interface \nfor a verifier in-tended to be used as a type system during the program development cycle. Since it extends \nML conservatively, it can be used sparingly as existing ML programs will work as before (if there is \nno keyword conflict). Most closely related to our work is the system of indexed types developed independently \nby Zenger in his forthcoming Ph.D. Thesis (Zenger 1998) (an earlier version of which is described in \n(Zenger 1997)). He works in the context of of lazy functional programming. His language is clean and \nel-egant and his applications (which significantly overlap with ours) are compelling. In general, his \napproach seems to re-quire more changes to a given Haskell program to make it amenable to checking indexed \ntypes than is the case for our system and ML. This is particularly apparent in the case of existential \ndependent types, which are tied to data con-structors. This has the advantage of a simpler algorithm \nfor elaboration and type-checking than ours, but the program (and not just the type) has to be more explicit. \nAlso, since his language is pure, he does not consider a value restriction. When compared to traditional \ntype systems for program- ming languages, perhaps the closest related work is refine- ment types (Freeman \nand Pfenning 1991), which also aims at expressing and checking more properties of programs that are already \nwell-typed in ML, rather than admitting more programs as type correct, which is the goal of most other \nresearch on extending type systems. However, the mecha-nism of refinement types is quite different and \nincomparable in expressive power: while refinement types incorporate in-tersection and can thus ascribe \nmultiple types to terms in a uniform way, dependent types can express properties such as these two argument \nlists have the same length which are not recognizable by tree automata (the basis for type refinements). \nWe plan to consider a combination of these ideas in future work. Parent (Parent 1995) proposed to reverse \nthe process of extracting programs from constructive proofs in Coq (Dowek, Felty, Herbelin, Huet, Murthy, \nParent, Paulin-Mohring, and Werner 1993), synthesizing proof skeletons from annotated programs. Such \nproof skeletons contain holes correspond- ing to logical propositions not unlike our constraint formu-las. \nIn order to limit the verbosity of the required anno-tations, she also developed heuristics to reconstruct \nproofs using higher-order unification. Our aims and methods are similar, but much less general in the \nkind of specifications we can express. On the other hand, this allows a richer source language with fewer \nannotations and, in practice, avoids in-teraction with a theorem prover. Extended ML (Sannella and Tarlecki \n1989) is proposed as a framework for the formal development of programs in a pure fragment of Standard \nML. The module system of Extended ML can not only declare the type of a function but also the axioms \nit satisfies. This requires theorem proving during extended type checking. We specify and check less \ninformation about functions which avoids general theorem proving. On the other hand, we currently do \nnot address module-level issues, although we believe that our approach should extend naturally to signatures \nand functors without much additional machinery. Cayenne (Augustsson 1998) is a Haskell-like language \nin which fully dependent types are available, that is, language expressions can be used as type index \nobjects. The steep price for this is undecidable type-checking in Cayenne. We feel that Cayenne pays \ngreater attention to making more programs typable than assigning programs more accurate types. In Cayenne, \nthe printf in C, which is not typable in ML (see (Danvy 1998) for further details), can be made typable, \nand modules can be replaced with records, but the notion of datatype refinement does not exist. This \nclearly separates our language design from that of Cayenne. The notion of sized types is introduced in \n(Hughes, Pareto, and Sabry 1996) for proving the correctness of reactive sys-tems. Though there exist \nsome similarities between sized types and datatype refinement in DML(C) for some domain C of natural \nnumbers, the differences are also substantial. We feel that the language presented in (Hughes, Pareto, \nand Sabry 1996) is too restrictive for general programming since the type system there can only handle \n(a minor variation) of primitive recursion. On the other hand, the use of sized types in the correctness \nproofs of reactive systems cannot be achieved in DML at this moment. Jay and Sekanina (Jay and Sekanina \n1996) have intro- duced a technique for array bounds checking based on the notion of shape types. Shape \nchecking is a kind of partial evaluation and has very different characteristics and source language when \ncompared to DML(C), where constraints are linear inequalities on integers. We feel that their design \nis more restrictive and seems more promising for languages based on iteration schemas rather than general \nrecursion. A key feature in DML(C) which does not exist in either of the above two systems is existential \ndependent types, which is indispensable in our experiment. Finally, recent work by Pierce and Turner \n(Pierce and Turner 1998) which includes some empirical studies, is based on a similar bi-directional \nstrategy for elaboration, although they are concerned with the interaction of polymorphism and subtyping, \nwhile we are concerned with dependent types. The use of constraints for index domains is quite different \nfrom the use of constraints to model subtyping constraints (see, for example, (Sulzmann, Odersky, and \nWehr 1997)). 10 Conclusion We have extended the entire core of ML with a restricted form of dependent \ntypes, yielding the DML(C) language schema. This includes proving the soundness of the type system of \nDML(C) and designing a type-checking algorithm. Type annotations are required, but not overly verbose. \nThe algorithm has shown itself to be practical for typical pro-grams and constraint domains, such as \nlinear inequalities over integers for array bounds checking (Xi and Pfenning 1998). In addition, we have \nfinished a prototype implemen-tation of DML(C) in which all the major features in the core of ML except \nrecords are available. The only reason for omitting records is that we already have tuples and we would \nlike to simplify the implementation. We have also ex- perimented with integer, symbolic and finite domains. \nWe are currently writing a frontend for &#38;ml-light. In future work, we plan to enrich DML with module-level \nconstructs, that is, extend DML to full Standard ML. Since our design explicitly separates indices from \nML expres- sions, we expect the extension to be mostly straightforward. Another practically important \nextension may be the intro-duction of limited forms of intersection types (Freeman and Pfenning 1991), \nso that more than one dependent type can be assigned to a function without code duplication. Our primary \nmotivation is to allow the programmer to express more program properties through types and thus catch \nmore errors at compile time. We are also interested in using this as a front-end for a certifying compiler \n(Necula and Lee 1998) which propagates program properties through a compiler where they can be used for \noptimizations or be packaged with the binaries in the form of proof-carrying code (Necula 1997). 11 \nAcknowledgements We are grateful to Rowan Davies for many technical discus-sions regarding the subject \nof this extended abstract. We also would like to thank Chad Brown for proofreading a draft and providing \nus with many helpful comments, and the referees for their highly constructive suggestions. References \nAugustsson, L. (1998). Cayenne -a language with dependent types. In Proceedings of ACM SIGPLAN International \nConference on Functional Programming, pp. 239-250. Constable, R.. L. et al. (1986). Implementing Mathematics \nwith the Nuprl Proof Development System. Englewood Cliffs, New Jersey: Prentice-Hall. Danvy, 0. (1998, \nMay). Functional unparsing. Technical Re-port RS-98-12, University of Aarhus. Dowek, G., A. Felty, H. \nHerbelin, G. Huet, C. Murthy, C. Par- ent, C. Paulin-Mohring, and B. Werner (1993). The Coq proof assistant \nuser s guide. Rapport Techniques 154, IN- RIA, Rocquencourt, France. Version 5.8. Freeman, T. aid F. \nPfenning (1991). Refinement types for ML. In ACM SIGPLAN Conference on Progmmming Language Design and \nImplementation, Toronto, Ontario, pp. 26% 277. Harper, R. W., F. Honsell, and G. D. Plotkin (1993, January). \nA framework for defining logics. Journal of the ACM 40(l), 143-184. Hayashi, S. and H. Nakano (1988). \nPX: A Computational Logic. The MIT Press. Hudak, P., S. L. Peyton Jones, and P. Wadler (1992, May). Report \non the programming language Haekell, a non-strict purely-functional programming language, Version 1.2. \nSIG- PLAN Notices 27(5). Hughes, J., L. Pareto, and A. Sabry (1996). Proving the cor-rectness of reactive \nsystems using sized types. In Conjer-ence Record of 23rd ACM SIGPLAN-SIGACT Symposium on Principles of \nProgramming Longuoger, pp. 410-423. Jay, C. and M. Sekanina (1996). Shape checking of array pro-grams. \nTechnical Report 96.09, University of Technology, Sydney, Australia. Kreitz. C., M. Hayden, and J. Hickey \n(1998, July). A proof environment for the development of group communication svstems. In H. Kirchner \nand C. Kirchner (Eds.). 15th Znter-national Conference on Automoted Deductiont LNAI 1421, Lindau, Germany, \npp. 317-332. Springer-Verlag. Milner, Ft., M. Tofte, and R. W. Harper (1990). The Definition of Standard \nML. Cambridge, Massachusetts: MIT Press. Moggi, E. (1989). Computational lambda-calculus and mon-ads. \nIn Proceedings Fourth Annual Symposium on Logic in Computer Science, pp. 14-23. Necula, G. (1997). Proof-carrying \ncode. In Conference Record of 24th Annual ACM Symposium on Principle8 of Pro-gramming Longuoges, pp. \n106-119. ACM press. Necula, G. and P. Lee (1998, June). The design and imple-mentation of a certifying \ncompiler. In ACM SIGPLAN 98 Conference on Progmmming Longuoge Design and Imple-mentotion, pp. 333-344. \nACM press. Owre, S., S. Rajan, J. Rushby, N. Shankar, and M. Srivas (1996, July/August). PVS: Combining \nspecification, proof checking, and model checking. In R. Alur and T. A. Hen- zinger (Eds.), Proceedings \nof the 8th International Con-ference on Computer-Aided Verification, CAV 96, New Brunswick, NJ, pp. 411-414. \nSpringer-Verlag LNCS 1102. Parent, C. (1995). Synthesizing proofs from programs in the calculus of inductive \nconstructions. In Proceedings of the International Conference on Mathematics for Progmms Constructions. \nSpringer-Verlag LNCS 947. Pierce, B. and D. Turner (1998). Local type inference. In Proceeding8 of the \n25th Annual ACM SIGPLAN-SIGACT Symposium on Principle8 of Programming Languages, pp. 252-265. Sabry, \nA. and M. Felleisen (1993). Reasoning about programs in continuation-passing style. LISP and Symbolic \nCompu-tation 6(3/4), 289-360. Sannella, D. and A. Tarlecki (1989, February). Toward formal development \nof ML programs: Foundations and method-ology. Technical Report ECS-LFCS-89-71, Laboratory for Foundations \nof Computer Science, Depatment of Computer Science, University of Edinburgh. Sulzmann, M., M. Odersky, \nand M. Wehr (1997). Type in-ference with constrained types. In Proceeding8 of 4th In-ternational Workshop \non Foundations of Object-Oriented Languages. Weis, P. and X. Leroy (1993). Le longoge Coml. Paris: InterEd-itions. \nXi, H. (1997, November). Some examples of DML program-ming. Available at http://vuu.cs.cmu.edu/ huxi/DML/~xamplea/. \nXi, H. (1998). Dependent npeo in Pmcticol Programming. Ph. D. thesis, Carnegie Mellon University. pp. \nviii+189. Forth-coming. The current version is available as http://wvw.cs.cmu.edu/ hvxi/DML/thesis.ps. \nXi, H. (1999, January). Dead code elimination through de-pendent types. In The First International Workshop \non Practical Aspects of Declomtive Language&#38; San Antonio, Texas. To appear. Xi, H. and F. Pfenning \n(1998, June). Eliminating array bound checking through dependent types. In Proceeding8 of ACM SIGPLAN \nConference on Progmmming Language Design and Implementation, pp. 249-257. Zenger, C. (1997). Indexed \ntypes. Theoretic01 Computer Sci- ence 187, 147-165. Zenger, C. (1998). Indisierte Qpen. Ph. D. thesis, \nFakultlit fiir Informatik, Universitgt Karlsruhe. Forthcoming.  A Further Examples We present some \nadditional examples for those who may have difficulty accessing (Xi 1997), where the complete ver-sions \nof these examples and some other larger ones are avail-able. An AVL tree is a balanced binary tree such \nthat for every interior node the difference between the heights of its two sons is at most one. The data \nstructure in Figure 9 precisely declares the type of AVL trees. Untyped X-expressions in de Bruijn form \nand an imple-mentation of evaluation are given in Figure 10. The depe-dent type checker verifies that \nno dangling de Bruijn refer-ences can occur during evaluation of a closed X-expression. This can be extended \nto verify type-safety statically, but requires a symbolic constraint domain. Assume that we have sorts \ntype and context and the following constants. unit : type arrow : type * type -+ type empty : context \n:: : type * context + context In Figure 11, the datatype lamexp, declared in Figure 2, is refined to \nformulate the type of simply typed X-expressions. Note that lamexp is indexed with a pair (t,ctx), where \nt stands for the simple type of a X-expression and ctx records the types of free variables in the X-expression. \nThere-fore the DML type of closed well-typed X-expressions is Xi! : type.lamexp(t,empty). Lastly, we \npresent a short implementation of quicksort on lists in Figure 12, where the type guarantees that this \nimplementation always returns a list of length n when given one of length n. Note that we use :: as an \ninfix operator for cons. B Elaboration Rules for ML, (C) We present the elaboration rules in Figures \n13 and 14. Note that some rules have (obvious) side conditions, which can be found in (Xi 1998). datatype \na tree = empty I branch of int * a * a tree * a tree (* height, key, left son, right son *) typeref a \ntree of nat with (* the index stands for the height *) empty <I a tree(O) I branch <I {lh:nat){rh:nat \nI rh -1 <= lh <= rh + 11 int(l+max(lh,rh)) * a + a tree(lh) * a tree(rh) -> a tree(l+max(lh,rh)) Figure \n9: AVL trees datatype lamexp = One I Shift of lamexp I Abs of lamexp I App of lamexp * lamexp typeref \nlamexp of int with One <I Cn:nat) lamexp(n+l) I Shift <I {n:nat) lamexp(n) -> lamexp(n+l) I Abs <I In:nat) \nlamexp(n+l) -> 1amexpM I App < I Cn:nat) 1amexpW * lamexp(n) -> lamexp(n) datatype closure = Closure \nof lamexp * env and env = Nil I Cons of closure * env typeref env of int with Nil <I env(0) I Cons <I \n{n:nat) closure * env(n) -> env(n+l) I Closure <I Cn:nat) lamexp(n) * env(n> -> closure fun callbyvalue(exp) \n= let fun cbv(One, Cons(clo, env)> = clo I cbv(Shift(exp), Cons(clo, env>) = cbvcexp, env) I cbv(Abs(exp) \n, env) -Closure(Abs (exp) , env) I cbv(App(fexp, exp), env) = let val Closure(Abs(body), envl) = cbvtfexp, \nenv) val clo = cbvcexp, env) in cbv(body , Cons (clo, envl)) end (* exhaustiveness of these cases follows \nfrom the dependent types *> where cbv <I in:nat) lamexp(n) * env(n) -> closure in cbvcexp, Nil) end where \ncallbyvalue <I lamexp(0) -> closure Figure 10: Closed X-expressions and evaluation datatype lamexp -One \nI Shift of lamexp I Abs of lamexp I App of lamexp * lamexp typeref lamexp of type * context with (* index \nlamexp with a pair (t, ctx) *I One <I Ct:type)Cctx:context) lamexp(t,t::ctx) I Shift <I Ctl:type)CtZ:type)Cctx:context) \nlamexp(tl,ctx) -> lamexp(tl,t2::ctx) I Abs <I Cti:type)Ct2:type)Cctx:context) lamexp(t2,tl: :ctx) -> \nlamexp(arrow(tl,t2) ,ctx) I App <I {ti:type)Ct2:type)Cctx:context) lamexp(arrow(tl,t2) ,ctx) * lamexp(tl,ctx) \n-> lamexp(t2,ctx) Figure 11: Simply-typed X-expressions fun( a) quickSort cmp [I = [I I quickSort cmp \n(x::xs) = par cmp (x, Cl, Cl, IS) where quickSort <I <n:nat) ( a * a -> bool) -> a list(n) -> a list(n) \nand( a) par cmp (x, left, right, xs) = case x8 of [] => (quickSort cmp left) (D (x:: (quicksort cmp \nright)) I y::ys => if cmp(y, x) then par cmp (x, y::left. right, ys) else par cmp (x, left, y::right, \nys) where par <I {p:nat){q:nat)<r:nat> ( a * a -> boo11 -> a * a list(p) * a list(q) * a list(r) -> \na list(p+q+r+l) Figure 12: Quicksort on lists +,a:y;I~eJr=%e* L; ~~$ T~~l~i~; l]i 7 (elab-pi-elim) (elab-pi-intro) \n&#38;II-eJIIIa:7.7=+(Xa:7.e*) S(c) = IIUl : 71.. . no, : 744 4 I- il : 71 . . . c$ I- i, : 7n (elab-cons-wo-up) \n +;rt-ct6(i[al,... ,a, :=i1,..* in]) =+ C[il] . . . [in] S(c) = I-IIal : 71 . . . ITa, : yn.7 + d(i) \nf$;l?l-e$+l ,..., a,:=il ,... &#38;1=+-e* q!J I- il : 71 *** q5 I- i, : -yn (elab-cons-w-up)+;rkc(e)ta(i[ol,... \n,a, :=i1,... in]) * c[il] . . . [i,](e*) r c~)I,t~P~(~ Ii2 ttr z cl (elab-cons-w-down) Figure 13: Elaboration \nrules for ML, (C), part I +; r k () + j () (elab-unit-w) (elab-unit-down) 1  4;r~oll=+o 4; r b el t \ncdl * ei 4;r e2 t p2 * e4 (elab_prod_up) 4; r I- el J. ~1 * ei r e2 T2 * e (elab-prod-down) 4; r k \n(el, e2) 4 71 * 72 * (ei, e;) pJ~l*(p*;#;r~) ~,~ ;r,rV-e~T2+e* fji-~~:* (elab-match)#;I? k (p * e) .J \n(71 * ~2) =+ (p * e*) 4; r t- (P * e) 4 (n * ~2) * (P * e ) 4; r I- ms -4 (~1 * TV) =+ ms* (elab matches) \n_ 4; r I- (p * e 1 ms) 4 (71 * 72) * (p * e 1 ms*) 4; r t- e t 71 * e di r t- ms 5- (~1 * ~2) * ms* \n~elabcase~ f$; r t-(case e of ms) J 72 * (case e* of m9 ) (elab-lam)4; r !-(lam 2.e) 4 71 + 72 * (lam \nc : Tl.e*) (b;r,Xl:Tl,X:Tke$T2=$e* &#38;r,Zl:T1kX1$T+ei (elab-lam-anno)f$; r I- (lam z : T.e) $ ~1 \n+ 72 =S (lam z1 : ~l.let x = f3; in e end) 4;rt-eltTl-+~2+~; ~;ri-e2iTl=$e; (elab-app-up) 4; r t- \nel(e2) t 72 * ei(4) 4;r i- el(e2) t ~1 =+ e* 9 I=~11 f ~2 (elab_app_down) qkrl-el(e2)lp2*eL C$;rkeltT1jei \n&#38;r,x:Tlke2tT2+ez (elab-let-up)4; r I- let z = el in e2 end t 72 3 let CE = e; in e; end f$;l?belt71=Sei \nC$;r,x:Tlt-e2~T2=k-e; (elab-let-down)4; r k let z = el in e2 end J- ~2 =S let x = ei in e; end &#38;r,f:Tt-V$T*21* \n (elab-flx-up) &#38;rk(fiXf:T.?J)fT=k+Xf:T.V*) &#38;r,f:Tk21$T+V* +;r,Z:TbZlT =ke* (elab-fix-down)~irt-(fixf:7.21)~7 \n=k.letx=(fixf:~.~*)ine*end 9; r k (e : T) t PI * e 9 I= PI = ~2 (elab_anno-down) 4 r e T * e* (elab \nanno-up) &#38;rb(e:T)tT+e* _ 4; r k (e : 7) 1 p2 + e Figure 14: Elaboration rules for ML, (C), part \nII  \n\t\t\t", "proc_id": "292540", "abstract": "", "authors": [{"name": "Hongwei Xi", "author_profile_id": "81100625632", "affiliation": "Department of Computer Science and Engineering, Oregon Graduate Institute of Science and Technology", "person_id": "PP39051360", "email_address": "", "orcid_id": ""}, {"name": "Frank Pfenning", "author_profile_id": "81100157780", "affiliation": "Department of Computer Science, Carnegie Mellon University", "person_id": "PP39030152", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/292540.292560", "year": "1999", "article_id": "292560", "conference": "POPL", "title": "Dependent types in practical programming", "url": "http://dl.acm.org/citation.cfm?id=292560"}