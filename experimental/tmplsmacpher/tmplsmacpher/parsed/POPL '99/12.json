{"article_publication_date": "01-01-1999", "fulltext": "\n Principality and Decidable Type Inference for Finite-Rank A. J. Kfoury*t Boston University Boston, MA \n02215, U.S.A. kfouryQcs.bu.edu http://www.cs.bu.edu/ kfoury Abstract Principality of typings is the \nproperty that for each ty- pable term, there is a typing from which all other typ-ings are obtained via \nsome set of operations. Type infer-ence is the problem of finding a typing for a given term, if possible. \nWe define an intersection type system which has principal typings and types exactly the strongly nor-malizable \nX-terms. More interestingly, every finite-rank restriction of this system (using Leivant s first notion \nof rank) has principal typings and also has decidable type inference. This is in contrast to System F \nwhere the fi- nite rank restriction for every finite rank at 3 and above has neither principal typings \nnor decidable type infer-ence. This is also in contrast to earlier presentations of intersection types \nwhere the status (decidable or unde- cidable) of these properties is unknown for the finite-rank restrictions \nat 3 and above. Furthermore, the no-tion of principal typings for our system involves only one operation, \nsubstitution, rather than several operations (not all substitution-based) as in earlier presentations \nof principality for intersection types (without rank re-strictions). In our system the earlier notion \nof expunsion is integrated in the form of expansion variables, which are subject to substitution as are \nordinary variables. A unification-based type inference algorithm is presented using a new form of unification, \nP-unification. 1 Introduction 1.1 Background and Motivation The Desire for Polymorphic Type Inference \nProgram-ming language designers now generally recognize the benefits (as well as the costs!) of strong \nstatic typing. Languages such as Haskell [PJHH+93], Java [GJS96], and ML [MTHMSO] were all designed with \nstrong typ-ing in mind. To avoid imposing an undue burden on Partly supported by NATO grant CRG 971607. \nPartly supported by NSF grant CCR-9417382. *Partly supported by EPSRC grant GR/L 38963. Permission to \nmake digital or hard copies ofall or part of this work for personal or classroom use is granted u,itlwut \nfee provided that copies arc not made or distributed for profit or commercial advantage and that topics \nbear this notice and the full citation on the first page. TO capy otherwise. to republish, to post on \nservers or to redistribute to lists, requires prior specific permission and/or a fee. POPL 99 San Antonio \nTexas USA Copyright ACM 1999 l-581 13-095-3/99/01...$5.00   Intersection Types J. B. Wellstj Heriot-Watt \nUniversity EDINBURGH, EH14 4AS, Scotland jbw@cee.hw.ac.uk http://www.cee.hw.ac.uk/ jbw the programmer, \nthe compiler is expected to infer as much type information as possible. To avoid rejecting perfectly \nsafe programs, the type inference algorithm should support as much type polymorphism as possi- ble. The \nmain options for polymorphism are univer- sal types, written VCY.~, and intersection types, written B \nA 7. (Their duals are the existential types, written %.r, and union types, written u V r.) The most popular \ntype inference algorithm is algo- rithm W by Damas and Milner [DM82] for the type sys- tem commonly called \nHindley/Milner which supports polymorphism with a restricted form of universal types. In practice this \ntype system is somewhat inflexible, sometimes forcing the programmer into contortions to convince the \ncompiler that their code is well typed. This has motivated a long search for more expressive type systems \nwith decidable typability. In this search, there have been a great number of negative results, e.g., \nunde- cidability of System F [We194], finite rank restrictions of F above 3 [KW94], F< [Pie94], F, [Urz97], \nF+Q [WelSS], and unrestricted intersection types [PotSO]. Along the way, there have been a few positive \nresults, some ex- tensions of the Damas/Milner approach, but, perhaps more interestingly, some with intersection \ntypes. What are Principal Typings? The various systems of intersection types have generally had a principal \ntyp-ings property, which differs from the principal types property of the Hindley/Milner system, as described \nby Jim [Jim96]: Principal Types Given: a term M typable in type environ-ment A. There exists: a type \nu representing all possible types for M in A. Principal Typings Given: a typable term M. There exists: \na judgement A I- M : T represent-ing all possible typings for M. A typing for a program is principal \nif all other typings for the same program can be derived from it by some set of operations. As explained \nby Jim, this kind of approach supports the possibility of true separate com-pilation as well as other \nbenefits. Principal Typings with Intersection Types The first system of intersection types for which \nprincipal typings was proved (as far as we are aware) was presented by Coppo, Dezani, and Venneri [CDCVSO] \n(a later version is [CDCVSl]). Like many systems of intersection types, it is similar to ours in that \nA can not appear to the right of I + and A-elimination can only occur at X- term variables. Like our \nsystem, this system is restricted so that the binding type of the bound variable of an abstraction must \nbe an intersection of exactly the set of types at which it is used. However, this system differs from \nours by allowing different occurrences of the bound variable to use the same member of an intersection. \nIt also has a rule to assign the special type w (representing the intersection of 0 types) to any term. \n There is a general approach for an algorithm for finding principal typings that was followed by Coppo, \nDezani, and Venneri for their type system as well as by Ronchi della Rocca and Venneri [RDRV84] and van \nBake1 [vB93] for other systems of intersection types. In this approach, the principal typing algorithm \nfirst finds a normal form (or approximate normal form) and then creates a typing for the normal form. \nA separate proof shows that any typing for the normal form is also a typing for the original term. The \nalgorithms of this approach are intrinsically impractical, not only due to the expense of normalization \nbut, more importantly, be-cause there is no possibility of a short cut to normaliza- tion. The principality \nof the principal typing is shown using a technique of several different kinds of opera-tions: expansion \n(sometimes called duplication), Rifling (sometimes called rise), and substitution. The biggest difference \nwith the approach we present in this paper is that we use expansion variables to formalize expansion \nin a much simpler way as part of substitution. This allows our approach to be based on both substitution \nand unification. This opens the possibility of more ef-ficient algorithms by adding additional (unnecessary) \nconstraints to the unification problem to shortcut the solution, an adaptation we leave to future work. \nSayag and Mauny [SM97, SM96] continue the ear-lier work cited above, and succeed in defining a simpler \nnotion of principal typings for a system of intersection types. An important difference with our analysis \nis the continued use of an expansion operation, although con-siderably simplified from earlier formulations, \nin part because they restrict attention to X-terms in normal form. Moreover, their approach is not substitution-based \nand it is not immediately clear how to extend it to arbitrary X-terms not in normal form. The first unification-based \napproach to principal typing with intersection types is by Ronchi della Rocca [RDRBB]. Of course, the \ngeneral method here will diverge for some terms in the full type system, but a decidable restriction \nis presented which bounds the height of types. Unfortunately, this approach uses the old, complicated \napproach to expansion and is very dif- ficult to understand. It also has trouble with commuta- tivity \nand associativity of A . Subsequent unification-based approaches to princi-pal typing with intersection \ntypes have focused on the rank-2 restriction of intersection types, using Leivant s notion of rank (Lei83]. \nVan Bake1 presents a unifica-tion algorithm for principal typing for a rank-2 sys-tem [vB93]. Later independent \nwork by Jim also at-tacks the same problem, but with more emphasis on handling practical programming \nlanguage issues such as recursive definitions, separate compilation, and accu- rate error messages [Jim96]. \nSuccessors to Jim s method include Banerjee s [Ban97], which integrates flow anal- ysis, and Jensen s \n[JenSB], which integrates strictness analysis. Other approaches to principal typings and type inference \nwith intersection types include [CG92] and [JMZ92]. 1.2 Contributions of This Paper The main contributions \nof this paper are the following: . A fully substitution-based notion of principality for a system of \nintersection types (with or with-out a rank restriction on types). Expansion vari-ables abstractly represent \nthe possibility of multi- ple subderivations for the same term, supporting a substitution-based approach \nin place of the old notion of expansion. This contribution makes the technology of inter- section types \nsignificantly more accessible to non-theorists. The notions of expansion in earlier liter- ature are \nso complicated that few but the authors could understand them. . A unification-based type inference algorithm \nfor in- tersection types using a novel form of unification, p-unification. The algorithm always returns \nprin-cipal typings when it halts. The algorithm is ter- minating when restricted to finite-rank types. \nThis algorithm is the first understandable type inference algorithm for intersection types beyond the \nrank-2 restriction which does not require that terms first be P-reduced to normal form. Although it may \nseem that there is quite a bit of material in this report, the vast majority of it exists only to prove \nproperties of the algorithm. The actual algorithm is largely contained in definitions 2.11, 2.12, 2.13, \n2.15, 3.1, 4.1, 4.2, 4.4, and 5.1, together with theorem 5.6. . Decidability of type inference and principal \ntypings for the restrictions to every finite rank. Ours is the first system of intersection types for \nwhich this has been shown. At rank 3, our system already types terms not typable in the very powerful \nsystem F,, e.g., the term (xx.z(z(xfu.fu))(r(Avg.gv)))(Xy.yyy), which was shown untypable in F, by Urzyczyn \n[Urz97]. 1.3 Future Work Using Intersection Types in Practice This work is car- ried out in the context \nof the Church Project, a fo-cused effort to explore the implications of intersection types for programming \nlanguage design and implemen- tation. The Church Project is actively implementing and evaluating intersection-type-based \ntechnology in an ML compiler. A number of practical concerns need to be addressed to finish the task \nof making the technol- ogy presented in this report usable in the overall project effort. In particular, \nthe following tasks are important: Adapt the technology to type systems in which A of X-terms is associative, \ncommutative, and idempotent. This will be vital for reducing the space and time com-plexity of our algorithm, \nbecause it will enable the expression of the rank restrictions without requir-ing an essentially linear \nflow analysis. Add support for sum types, e.g., booleans and con- ditionals. This is highly likely to \nrequire the addi- tion of union types. Add support for recursive definitions, e.g., a fix-point operator \nor letrec bindings. This will sig- nificantly complicate the analysis, because it will interfere with \nthe invariant that X-compatible con-straint sets (definition 3.7) have constraints neatly divided into \npositive and negative types (defini-tion 3.3). Also, polymorphic/polyvariant analysis of recursion is \nnotoriously difficult. Take advantage of the new notion of substitution developed in this report to devise \nefficient repre-sentations of polyvariant program analyses. This is particularly promising. Theoretical \nConcerns The work presented here in-spires the following possible tasks: . Investigate the relationship \nbetween p-unification and other forms of unification -decidable and undecidable. In particular, investigate \nthe rela-tionship with second-order unification and semi-unification. . Further develop the meta-theory \nof @unification. In particular, investigate conditions under which ,B- unification (1) satisfies a principality \nproperty and (2) is decidable. Use this to develop more sophis-ticated type inference algorithms. . Investigate \nthe complexity of the decidable finite-rank restriction of @unification introduced in sec- tion 6. Separately, \ninvestigate the complexity of the set of programs typable in the various finite- rank restrictions. \n2 intersection Types with Expansion Variables This section defines a system of intersection types for \nthe X-calculus with the additional feature of expansion variables. The expansion variables do not affect \nwhat is typable; instead they support reasoning about principal typings via a notion of substitution. \nThroughout the paper, the notation 2 is meta- notation standing for the notation Xi,. . . , X,. The notation \nr? stands for _? for some n 2 0 which either does not matter or is clear from the context. A warning: \nSome authors use the notation X for similar purposes, but in this paper the bar mark on a symbol is not \nused to stand for a sequence. 2.1 The Type System Definition 2.1 (X-Terms). Let z and y range over X-Var, \nthe set of X-term variables. We use the usual set M,NEh::=z]XCr.M]MN, quotiented by o-conversion as usual, \nand the usual no-tion of reduction (Xr.M)iv _)p M[x := N]. As usual, FV(M) denotes the set of free variables \nof M. cl The following definition gives a structure to type variable names that will be helpful later \nwhen we need to rename them distinctly. Definition 2.2 (Type Variables). The set of ba-sic type variables \nor basic T-variables is TVarb = { ai 1 i E N }. The set of basic expansion variables or basic E-variables \nis EVarb = { Fi 1 i E JV}. We assume TVarb and EVarb are disjoint sets, and use Varb to denote the union \nEVarbU Tvarb. We use binary strings in (0,l}*, called o&#38;et labels, to name (and later to rename) \nvariables. Ifs, t E (0, l} , we write s . t for their concatenation. The statement s 5 t holds iff t \n= s . s for some s E (0,1) . The set of type variables or T-variables and and the set of expansion variables \nor E-variables are: TVar={afIiEN, sE{O,l}*} EVar = { Ff I i E N, s E {O,l}* } Let TVar and EVar properly \nextend TVarb and EVarb by taking ai to be a4 and Fi to be F:, where E denotes the empty string. Let (a:) \ndenote &#38; and let (Ff)t denote Ff t. Let CY and ,B be metavariables ranging over TVar and let F (in \nitalics) be a metavariable ranging over EVar. For example, if a denotes a:, then crt denotes az t. We \nuse v (appropriately decorated) as a metavariable ranging over the disjoint union Var = EVar U TVar. \n0 Definition 2.3 (Types). Let + and A be binary type constructors. The set T of types and its subset \nI as well as metavariables over these sets are given as follows: r E T- ::= (YI (T -+ T) ?-ET ::= r I \n(T A 7 ) I (F 7) Note that ? is only a metavariable over I+ . The letters p and cr will be used later \nto range over certain other subsets of I . Observe in the tree representation of any r E T that no A \nand no E-variable can occur as the right child of I+ . We sometimes omit parentheses according to the \nrule that -+ and A associate to the right and the application of an expansion variable (e.g., F T) has \nhigher precedence than A which has higher precedence than I+ . For example, F ~1 A ~-2 -+ 73 = ((F 71) \nA 72) + 7-3. 0 Definition 2.4 (Type Environments). A type en-vironment is a function A from X-Var to \nT with finite domain of definition. A type environment may be writ- ten as a finite list of pairs, as \nin 21 :ri, . . . ,Xk :rk for some distinct 21,. , zk E X-Var, some 71,. . , Tk E % and some k > 0. If \nA is a type environment, then A[z C) T] is the type environment such that (A[a: ti T])(X) = T and (A[a: \ne 7])(y) = A(y) if y # x and A\\x = A -{x I+ A(x)}. If A and B are type envi- ronments, then A A B is \na new type environment given by: A(z) A B(x) zeFn;:A(z) and B(x) I if only h(x) defined, (A A B)(z) = \n; ,:I if only B(z) defined, undefined if both A(z) and B(z) undefined. If F E EVar is an E-variable and \nA is a type envi-ronment, then F A is the type environment such that 0 (FA)(z) = F(A(z)). Definition \n2.5 (Skeletons and Derivations). The sets of judgements, rule names, and pre-skeletons are determined \nby the following grammar: J E Judg ::= A k M : 7 1 A b-e M : T R E Rule ::= VAR 1 ABS-K 1 ABS-I 1 APP \nl AIF   Q E PSkel ::= (R, J, Q) Judgements formed with the I-, symbol will be used to restrict the \nA and F rules so these rules are used only for subterms which are the arguments of an application. Observe \nthat a pre-skeleton S is a rule name, a final judgement, and zero or more subskeletons. The order of \nthe subskeletons is significant. Note that F is a rule name for every F E EVar. A skeleton S of System \nI[ is a pre-skeleton Q such that, for every sub-pre-skeleton Q = (R, J, Q) occurring in Q, it holds \nthat the judgement J is obtained from the end judgements of the pre-skeletons Q (whose order is significant) \nby rule R and rule R is one of the rules for skeletons of System 1 in figure 1. The rule named (S) APP \nis used in skeletons {or the case of APP. The order of the pre-skeletons Q determines the order in which \ntheir end judgements must match the premises of the rule R. A skeleton (R, J, &#38;I . Qn) may be written \ninstead as: Ql . . . Qn R J A derivation I> of System II is a skeleton S such that every use of the \nrule named (S) APP also qualifies as a use of the more restrictive rule named (D) APP in figure 1. The \n(D) APP rule differs from the (S) APP rule in requiring the type of the term in function position to \nbe a function type, requiring the domain portion of the function type to match the type of the term in \nargument position, and requiring the codomain portion of the function type to match the result type. \nIn interpreting the rules in figure 1, the pattern A I-? M : T can refer to either A + M : 7 or A t-, \nM : 7. Henceforth, all skeletons and derivations belong to System I. Observe that the set Deriv of derivations \nis a proper subset of the set Skel of skeletons. Henceforth, we do not consider pre-skeletons that are \nnot also skeletons. Let the statement A b-1[ M : T hold iff there exists a derivation 2) of System 11 \nwhose final judgement is A k M : T. When this holds, we say that V is a typing for M. A term M is typable \nin System II iff A bn M : T holds for some A and r. Observe that the rule ABS-K is not a special case \nof the rule ABS-I. This is because there is no rule or other provision for weakening (adding redundant \ntype assumptions to a type environment) in our system and therefore, if there is a proof for the judgement \nA I- M : T where x $ FV(M), then A(x) is not defined. 17 The following result is merely what anyone would \nexpect from a system of intersection types formulated without a rule for w. Theorem 2.6 (Strong Normalization). \nA X-term M is strongly normalizable (i.e., there is no infinite ,B-reduction sequence starting from M) \nif and only if M is typable in System II. 0 Corollary 2.7 (Undecidability of Typability). It is undecidable \nwhether an arbitrarily chosen X-term M is typable in System II. 0 Later in the paper, we will show certain \nrestrictions of System II to have decidable typability. REMARK 2.8.System 1 does not have the subject \nre-duction property. For example,  z : CYZ -+ a1 + ~3, w : a1 A ~2 t-1 (Xz.(Xy.zyz)x)w : a3, but 2.:~2~~1-_)~3,w:~Ij\\~2~~(~~.~x2)~:~3. \nBy theorem 2.6, typability is preserved, so for example: I:ffz~al-,LY3,W:(YgACY1~-,(XX.~XX)W:(Yg. The \nreason for the lack of subject reduction is that (1) A is neither associative, commutative, nor idem- \npotent, (2) the implicit A-elimination done by the VAR rule and the way type environments are built together \nfix the component of an intersection type associated with a particular variable, and (3) there is no \nprovi-sion for weakening (i.e., introducing unneeded type as-sumptions). If subject reduction is viewed \nas a means to achieve other goals rather than as a goal by itself, then the lack of subject reduction \nis not a problem, be-cause derivations of System II can be easily translated into derivations of more \npermissive systems of intersec- tion types (see [vB93] for a survey) for which numerous desirable properties \nhave already been verified. The fea- tures of System I[ which prevent subject reduction make the later \nanalysis of principal typings and type inference much easier. 0 2.2 Substitution The notion of substitution \ndefined here will be used later in unification for type inference and in establishing a principal typing \nproperty for System I[. Definition 2.9 (Type Contexts). The symbol Cl de- notes a hole . The set Tn of \ntype contezts and its sub- set ?rz as well as metavariables over these sets are given as follows: (p \nE Tr;; ::= 0 I (Y I ( p + p) p E To ::= (p 1 ( P A cp ) 1 (Fv) inference Rules for both Skeletons and \nDerivations VAR x:?tx:T A A1 t?M:q; A2 I-:, M : 72 AlAAat- eM:qArz ABS-I A[z I+ T] t M : 7 At (Xx.M) \n: (T -+ I) F At? M FAt,M:Fr :T AtM:t ABS-K if z # FV(M) Remember that Q,? E T- and F E EVar. At (X2.M) \n: (T -+ 7) Inference Rule for Skeletons Only Inference Rule for Derivations Only A1 t M : 7; A2 t? IV \n: -T A1 t M : T t ?; A2 t? N : T (S) APP (23)APP A1AA2tMN:7 AlAAztMN:t Figure 1: Inference Rules of \nSystem II. Note that (p is only a metavariable over ll z. If 9 has n holes, we write #o(q) = n and use \nCl( ), . , IX( ) to denote these n holes in their order of occurrence in cp from left to right. Care \nmust be applied when insert- ing ri,... , ~~ E T in the holes of cp in order to obtain a type r = &#38;-I,... \n, ~~1 which is valid according to Definition 2.3. Specifically, if hole lJci) in cp is to the immediate \nright of I + , then ri must be restricted to the subset lI - . Cl Definition 2.10 (Expansions). The set \nE of erpan- sions is a proper subset of To, defined by the following grammar: e E E ::= El 1 (e A e ) \n1 (Fe) In words, an expansion is a type context which mentions no T-variable and no + . 0 Definition \n2.11 (Paths in Type Contexts). We define path as a partial function which determines the position of \n. The def- lci) in p as a string in { L, R, 0,l}*. inition goes as follows, using a value of .I_ to indicate \nthat the function is undefined on that input: path(Oci),O) = 1 fti,=, ,, { path@( ), c~) = ; , if p \n= path(O(i) cp) #J_ if q = path(~( -#D(V)), k) L.P R.9 path@( ), cp + Ip) = ( and 4 #L I otherwise. if \np = path(O(i) p) #I if q = path(n( l#o( P)) 0.P 1.9 IPP) path(Cl(i), p A cp ) = and q #J-, otherwise. \nIL path(O(i), Fp) = path(O(i), cp) Let paths(q) = { path(U(if,cp) 11 5 i 2 #O(P) }. Be-cause an expansion \ne E E is a type context that does not mention -+ , a path in e is a string in (0, 1)' rather than in \n{ L, R, 0,1) . We thus use binary strings in (0,1) for a dual purpose: as paths in expansions and as \noffset labels to rename variables (see definition 2.2). The coincidence between the two is by design. \n0 Definition 2.12 (Variable Renaming). For every t E {O,l}* (we do not need to consider the larger set \n{ L, R, 0, l}), we define a variable renaming ( ) from T to T, by induction: 1. (c# = &#38; for every \nc$ E TVar. 2. (7 + qt = (7) -+ (qt.  3. (71 A 72y = (T# A (7$. 4. (F T) = F, t (7) for every Ff E EVar. \nIn words, (7) is obtained from r by appending t to every offset that is part of a variable name in 7. \n0 Definition 2.13 (Substitution on Types). A sub-stitution is a total function S : Var + (E U a- ) which \nrespects sorts , i.e., SF E IE for every F E EVar and Sa E T+ for every Q: E TVar. Note that S(a) can \nnot have an E-variable or A in outermost position. We write SF instead of S(F) and Scr instead of S(LY), \nas long as no ambiguity is_introduced. We lift a substi- tution S to a function S from lf to IT by induction \non T: 1. sa = So. 2. S(r + 7) = (37) -+ (ST). 3. S(7.i A 5) = (Sri) A (S72). 4. I = e[s((r) l), ,i%((~) \n~)], where SF = e and 5% = path(Cl(i),e) for 1 5 i 5  #o(e) = n. When n_o ambiguity is possible, we \nwrite S for s and S 7 for S(r). 0 Definition 2.14 (Support of Substitutions). Let S : Var + (E U T-) \nbe a substitution. The non-trivial E-domain and non-trivial T-domain of S are EDom(S) = {F E EVar 1SF \n# FO} and TDom(S) = {(Y E TVar 1 Sa # CX}, respectively. The non-trivial do-main of S (or the support \nof S) is Dam(S) = EDom(S)U TDom(S). The notation ([FI := el,. . . ,Fm:=em,al :=?I ,... ,cY~:=T~D denotes \na substitution S with the indicated mappings where EDom(S) = {FI,.. . , Fm} and TDom(S) = {al,... ,&#38;I}. \n0 Definition 2.15 (Operations on Judgements and Skeletons). The notion of renaming from defini-tion \n2.12 is lifted to type environments, judgements, rule names, and skeletons in the obvious way. The A \noperator and the operation of applying an E-variable are lifted to skeletons as follows: 1. SAS =(A,A~AA~~-,M:T~ATZ,S,S \n)~~ S = (Rl,Al k? M: ~1,s) and S = (Rz, AZ ET M : r&#38;).  2. FS=(F,FAk,M:Fr,S)if S=(R,Ak?M:r$).  \n Using the preceding, the notation for expansion filling is lifted to skeletons as follows: 1. (e&#38;e \n)[&#38;,... ,S,]=S;/\\S if#o(e)=j, ,. . 7Sj] = S, and e [&#38;+I,. ,&#38;I = S .  2. (F e)[&#38;, . . \n. , S,] = F (e[&#38;, . . . , S,]). 3. cl[S] = s.  The notion of substitution is lifted to type environ- \nments so that S A is the function such that (S A)(z) = S(A(z)). Substitution is lifted to judgements \nso that S(A k? M : T) = S(A) l-7 M : S(r). Substitution is lifted to skeletons as follows: 1. ;(l$$S;, \n. . . S,) = (R, S J, (S&#38;J.. . (S&#38;)) if 2. S(F, J,S) = e[S((S) l), . , S((S)an)], where SF = e \nand si = path(O(i),e) for 1 5 i 5 #m(e) = n. 0 Lemma 2.16 (Substitution Preserves Skeletons and Derivations). \nLet S be any substitution. 1. If S is a skeleton, then S(S) is a skeleton. 2. Zf 2) is a derivation, \nthen S 2, is a derivation. 0  Definition 2.17 (Principal Typings). A derivation D is a principal typing \nfor X-term M iff 2, is a typing for M and for every other typing 2) for M, there is a substitution S \nsuch that V = S(V). The principality property for typings is the existence of a principal typing for \nevery typable X-term. 0 Subsequent sections will establish that System II has the principality property. \nWe next give two simple examples to illustrate how notions introduced so far are used, in particular, \nthe key concepts of skeleton , derivation and substitution in the presence of ex-pansion variables. EXAMPLE \n2.18 (Principal Typing for (X=r)(XY.YY)). Let Ml denote the X-term (X=)(Xy.yy). Depicted in figure 2 \nis a skeleton S1 for Ml. The skeleton S1 is a particular one, produced from Ml by the Skel algorithm \nof section 5. It is just a decorated version of the parse tree of MI and its size is therefore small \n, i.e., proportional to the size of Ml: y\\/y Applying an arbitrary substitution to &#38;, we can ob-tain \nanother skeleton for Ml. Thus, S1 is a scheme for infinitely many skeletons for MI. Associated with S1 \nis a constraint set produced from Ml by the l? algorithm of section 5. ( Constraint sets and restrictions \non them are defined precisely in section 3.) Note that there is one constraint in A, for each use of \nthe APP rule in S1. A particu- lar substitution S1, obtained from Al using the Unify algorithm of section \n4, is given by: SlF = FO, SIG = 0, S~(YI = S&#38; = ((Fa -+ /3) A FCE) -+ ,O, S~(YZ=FCY+/~, SI~~=CY, \nS&#38;=p. Applying substitution S1 to skeleton S1, we obtain an-other skeleton which is now a derivation \nVl = Sl(&#38;), depicted in figure 2. A consequence of the analysis in sections 4 and 5 is that VI is \na principal typing for MI, i.e., every typing 2) for Ml is of the form 27 = S (Vl) for some substitution \nS . . EXAMPLE 2.19 (A Principal Typing for (xx.xy.xy)(xz.zz)). Let M2 denote the X-term (Xx.Xy.zy)(Xr.az). \nDepicted in figure 3 is a skeleton S2 for Mz. As in example 2.18, the skeleton Sz is a particular one, \nproduced from Nz by the Skel algorithm. Associ-ated with Sz is the following constraint set, produced \nfrom M2 by the r algorithm of section 5: (~1 -+ FQ~ + ,&#38; + H(cr3 A Gcx4 + ,62) -+ p3, Ha3 A H(Ga4 \n-+ p2) }. A particular substitution S2, obtained from A2 using the Unify algorithm of section 4, is \ngiven by: SzF = 0 A GO, !&#38;G = GO, SzH = 0, &#38;al = S2@3 = ((Ga -+ ,B) A Ga) + ,f3, SZ(Y; = SSLYB= \nGcu + /3, SZ(Y: = S2a4 = a, SZPl = S2P2 = P. Observe that, in this example, SZ assigns values to the \noffsprings Q; and 0; of CYZ, but does not need to assign any particular value to CX:! itself. This follows \nfrom the way substitutions are applied outside-in , and becomes clear when we consider the action of \nS2 on Fcuz: Sz(Faz) = (0 A GO)[S(CQ)~, S(c#] = (0 A GO)[S&#38; SC&#38;] = So; A G(Sa:) =   (GcY-+P)AGQ.. \n Applying substitution Sz to skeleton SZ, we obtain a new skeleton which is also a derivation V2 = S2(&#38;), \nas depicted in figure 3. A consequence of the analysis in sections 4 and 5 is that 2)~ is a principal \ntyping for M2, i.e., every typing VD for Mz is of the form V = S (&#38;) for some substitution S . 0 \nThe skeleton S1 = Skel(M1) is: VAR y:asty:ag VAR F y:a2ty:a2 y : Fa3 te y : Fa3 APP y : cx2 A Fa3 t \nyy : 81 VAR ABS-I z:a1t2:cq t Xy.yy : a2 A Fa3 + 81 ABS-I G t xz.z : (11 + a1 Fe Xy.yy : G(a2 A Fa3 + \nPI) APP ._ t (XX.X)(XY.YY) : P2 Letting &#38; = I (Ml) and Sl = Unify(Al), the derivation v1 = Sl(&#38;) \nis: VAR y:aty:a VAR F y:Fa-+pty:Fa+p y:Fat_ey:Fa VAR APP x:rtx:r y:(Fa-+/?)AFcrtyy:P ABS-I ABS-I t Xx.x \n: 7 + l-t xy.yy : 7 APP t (Xx.x)(Xy.yy) : 7 where T = ((Fa -+ p) A Fa) + p. Figure 2: Skeleton S1 and \nderivation 2)1 for Ml = (h.z)(Xy.~~). rhe skeleton S2 = Skel(M2) is: VAR VAR y:crzty:az z:a4tz:a4 VAR \nF VAR G 2:a1 tx:a1 y : Fag t_e y : Fa2 z:cq.tz:a3 z : Ga4 te z : Ga4 APP APP x:cq,y:Faztxy:~~ z : a3 \nA Ga4 t zz : 82 ABS-I ABS-I x : al t Xy.xy : Fa2 -+ &#38; t Xz.zz : a3 A Ga4 -+ p2 ABS-I H t Xx.Xy.xy \n: al + Fa2 -+ 81 te Xz.zz : H(a3 A Ga4 -+ 82) APP t (xx.xy.xy)(xz.zz) : p3 ,etting A2 = r(M2) and S2 \n= Unify(Az), the derivation 272 = S2(&#38;) is: VAR y:aty:o: VAR G y : 71 t y : 71 y:Gat,y:Ga VAR A VAR \nx:7-3 t x:73 y : 72 te y : 72 z:atz:a APP VAR G x:T3,y:T2 t xy:p .z : 71 t z : 71 z:Gat,z:Go: ABS-I APP \n2 : 73 t xy.xy : 73 2:72t zz:p ABS-I ABS-I t xx.xy.xy : T3 -+ 73 t x.Z..ZZ : T3 APP t (xX.xy.Xy)(h.ZZ) \n: 73 vhere ~1, ~2 and 73 abbreviate the following typeS: 71 = Ga + p, 72 = T1 A Gcx = (Ga -b p) A Ga, \nT3=,-+~=(GCX+~)AGLY+~. Figure 3: Skeleton S2 and derivation V2 for Mz = (Xz.Xy.xy)(~z.zz). 3 Lambda-Compatible \nBeta-Unification The problem of @unification was introduced and shown undecidable by Kfoury in [KfoSX]. \nThis section in-troduces X-compatible ,&#38;unification, a restriction of /3- unification, in order to \ndevelop a principality property and in preparation for a unification algorithm presented later. Definition \n3.1 (E-paths). The set EVar of all finite sequences of E-variables is also called the set of E-paths. \nWe define a function E-path from Var x T to finite sub-sets of EVar . By induction: {c} if v =cy, 1. \nE-path(v,cr) = IzI  if v #cr. 2. E-path(v, r + 7 ) = E-path(v, r) U E-path(v, r ). 3. E-path(v, r A \nr ) = E-path(v, r) U E-path(v, 7 ). = {FG 1 G E E-path(v,r)} ifv#F, 4. E-path(v, Fr) {E} U {Fe 1 G \nE E-path(v,r)} if v = F. l1 Definition 3.2 (Well Named Types). If r E T, we write EVar(r) for the set \nof E-variables occurring in r, TVar(r) for the set of T-variables occurring in r, and Var(r) for the \ndisjoint union EVar(r) U TVar(r). We say that a type r E T is well named iff both of the following statements \nhold: 1. For every v E Var(r), it holds that E-path(v,r) = {G} (a singleton set) where v does not occur \nin G . 2. For all vS,vt E Var(r) with u basic and s,t E (0, l} , if s 5 t then s = t. Informally, the \nfirst condition says that, for ev-ery (type or expansion) variable v, the sequence of E-variables encountered \nas we go from the root of r (viewed as a tree) to any occurrence of v is always the same. Furthermore, \nE-variables do not nest themselves. If E-path(v,r) is the singleton set {@}, we can write E-path(v, r) \n= 1; without ambiguity. The second condition says that if a variable v occurs in 7, then no proper offspring \nof v occurs in r, where a variable v ~ is called an oflapring of vs. Note that types that mention only \nbasic variables automatically satisfy the second condition. cl Definition 3.3 (Positive and Negative \nTypes). We identify two proper subsets W and 9 of T, which we call the positive types and the negative \ntypes , respectively. We first define W and Is with polarities inserted, as fW and f9, defined simultaneously \nwith fIR+ and fS , together with metavariables over these sets, as follows: /s E flk ::= +a 1 (a -+ p) \np E fW ::= p 1 (+Fp) o E fS- ::= -a 1 (+Fp -+ a) (T E f9 ::= (T 1 (CJ A a ) I (-Fo) We obtain W and R \nfrom fW and flR, respectively, by omitting all polarities. Similarly we obtain 9 and 9 from S and +S. \nNote that there is a restriction that exactly one E-variable occurs in each positive position to the \nleft of I+ 7and A occurs only in negative positions. Note also that the metavariables p and (T are restricted \nto the subsets lR_ and S- , respectively. If p E W (resp. o E S), there is exactly one way of inserting \npolarities in p (resp. c) so that the resulting type p (resp. c-r ) with polarities is in zttw (resp. \nf9). Let (p)+ E fR (resp. (a)-E M) be the uniquely de-fined expression obtained by inserting polarities \nin p E W (resp. u E S). We thus have two well-defined functions: ( )+ from W to fIR and ( )- from 9 to \nf9. Cl Definition 3.4 (Constraint Sets). A constraint is an equation of the form r A 7 where r,r E T. \nAn instance A of p-unification is a finite set of constraints, i.e., Given A of the above form, we write \nEVar(A) for the set EVar(ri A.. .AT;), TVar(A) for the set TVar(ri A.. .ArA) and Var(A) for their disjoint \nunion EVar(A) UTVar(A). If A is a set of constraints and F E EVar, we write FA to denote the set of constraints: \nFA = { Fr A FT I 7 G 7 is a constraint in A } Cl  Definition 3.5 (Outer and Inner E-Variable Oc- currences). \nLet @ E EVar , p E W and u E 9, with Var(p) n Var(u) = 0. (All constraints generated will be of this \nform.) We say the expansion variable G has an outer (resp. inner) occurrence in the constraint $p f $0 \niff G E F (resp. iff G E EVar(pAu)). In words, an outer occurrence appears on both sides of the con-straint \nand at the top level. Occurrences of T-variables are always inner; only occurrences of E-variables are \ndifferentiated between outer and inner. Let A be a finite set of constraints, each of the form specified \nin the two preceding paragraphs. We say G E EVar has an outer (resp. inner) occurrence in A if G has \nan outer (resp. inner) occurrence in a constraint in A. The definition of outer and inner occurrences \nof E-variables carries over, in the obvious way, to the equa- tion F(p)+ A z(u)- after polarities are \ninserted. Only inner occurrences are said to be positive or negative. 0 Definition 3.0 (Connected Constraint \nSets). We say that a constraint set A is connected iff for all con-straints r A 7 and ? G ? in A, there \nare constraints {rr-r~,...,r~~-_~}~Asuchthat Var(T% k 3-i) rl Var(n+l A T,!+~) # 0 for 1 5 i 5 n -1 where \nr A 7 is ri + 7; and ail _ ~ is ~* i ,~,I. 0 Definition 3.7 (X-Compatibility). A constraint set A is \nX-compatible iff A is of the form: where @i E EVar*, and pi E R and u, E 9 such that if pi E W then ui \nE S for every 1 < i < n, and moreover A satisfies all of the following conditions: A is well named, which \nwe define to hold iff the type $ipiAFicri A ..A$~;~~~AF~~~ is well named. Every expansion variable F \nE EVar has at most one inner positive occurrence in A, i.e., +F oc-curs at most once in &#38;A, where \n&#38;A is obtained by inserting polarities in A: Every type variable (Y E TVar occurs at most twice in \nA. And if it occurs twice, it occurs once pos-itively as +cr and once negatively as -_(y in the constraint \nset *A. For every constraint $p k $cl in A, we have Var(p) fl Var(o) = 0. For every connected A c A and \nconstraint 2 p G @:o in A -A , either Var(A ) fl Var(p) = 0 or Var(A ) fl Var(a) = 0. In words, the variables \nof a connected A C A can overlap with the inner variables of at most one side of a constraint @p -$0 \nin A -A . We use the name X-compatible because, as shown in lemma 5.2, every constraint set induced by \na X-term satisfies the conditions above. 0 Definition 3.8 (Solutions). Let S : Var + (E U T ) be a substitution \nand let A = {ri e r;, . . . , ~~ A 7:) be a X-compatible constraint set. We say S is a solution for A \niff two conditions hold: 1. Dam(S) rl Var(Sv) = 0 for every u E Var. 2. S7; = S7: for every i E (1,. \n. . , n}. The first condition is a mild restriction. It can probably be eliminated, at the price of making \nthese propositions and their proofs more complicated. 0 Definition 3.9 (Principal Solutions). Let S : \nVar -+ (E U II ) be a substitution and let A be a X-compatible constraint set. The substitution S is \na prin- cipal solution for A iff S is a solution for A and for every solution S for A, there is a substitution \nS such that S A = S (SA). The principality property is the existence of a principal solution for every \nconstraint set that has a solution. 0 EXAMPLE 3.10 (Uniqueness of Principal Solutions in a Weaker Sense). \nA peculiarity resulting from the presence of expansion variables is illustrated by a simple example. \nLet A be the constraint set: A = { FGa A (al A 52) A ((Tg A 54)) where ai,iiZ,&#38;,a4 E S are arbitrary. \nAssume that A is X-compatible. By inspection, it is not difficult to see that A has three distinct principal \nsolutions, ignor-ing any principal solution obtained from one of these three by renaming variables in \nits range or by adding *We purposely write S A = S (SA) instead of S = S o S in order to avoid pitfalls \nassociated with the composition of substitutions in p-unification. redundant mappings. The three principal \nsolutions in question are: Si = (I F := 0, G := (0 A 0) A (0 A . U )n So Sz = (I F := 0 A 0, Go := 0 \nA 0, G1 := 0 A 0) U So S3 = ([ F := (0 A 0) A (0 ), A . Go0 := Cl, Go := 0, G1 := 0, G1 := 01 u So -1 \nwhere SO = (Icr := ai,ool := 02,(_y1 := 83,~ := 84). None of the three substitutions can be obtained \nfrom the other two by variable renaming, in contrast to principal solutions in first-order unification, \nsemi-unification, and other forms of unification. If Sl, SZ, and Ss are principal as claimed, then we \nmust have $A = S(SjA) for some substitution S, where i, j E {1,2,3}. This is indeed the case, by taking \nS = (I D, the identity substitution. Hence, after all, S,A = SsA = S3A, and the uniqueness of princi- \npal solutions is recovered in a weaker sense. However, there is no substitution S such that Si = S o \nSj, where i, j E {1,2,3} and i # j. It is worth noting that algo-rithm Unify in section 4 on input A \nreturns Ss, because Unify works in top-down fashion, i.e., it expands F before G. 0 4 Algorithm for Lambda-Compatible \nBeta-Unification We design a non-deterministic algorithm Unify which takes a X-compatible constraint \nset A as input, such that if A has a solution then every evaluation of Unify(A) terminates returning \na principal solution for A, and if A has no solution then every evaluation of Unify(A) diverges. The \npresentation of algorithm Unify in figure 4 is largely self-contained -except for two parts in the mode \nof operation , namely, the definition of E-env( A) and the evaluation of Si = S @&#38; SO, which we now \nex- plain. In general, the standard composition of two sub- stitutions using 0 does not produce a substitution, \ni.e., for substitutions Si and SZ, there does not neces-sarily exist a substitution Ss such that % = \n(?%ez). To work around this difficulty, we use Y&#38;Y to denote a new binary operation on substitutions, \nwhich we will call safe composition relative to &#38; , where Z is an en-vironment expressing certain \nnaming constraints. Definition 4.1 (E-Path Environment). Given a well-named type context cp, we form \nits E-path envi- ronment as follows: An E-path environment is a partial function &#38; : Var + EVar* \nthat is the result of applying the E-env function to a well-named type context. Let &#38; be a metavariable \nover E-path environments. If A = {ri * T;, . , r, G T:} is a well-named constraint set, then E-env(A) \n= E-env(ri A 7; A . A ~~ A ?-A). 0 Definition 4.2 (Safe Composition). We first define a function @ which, \ngiven a pair (e, S) consisting of an expansion e and a substitution S, returns a finite set Metavariable \nconventions: . PER+, PEW, @ES+, (T,(T E~, r,r ,ri,r,!ET, a~TVar. . F,G E EVar and H E Evarb, with F and \nG distinct and H fresh in rule 4. Mode of operation: . Initial call: Unify(A) j Unify(simplify(A), 4 \nD,E-env(A)). . Unify(O, S, E) * S. . Unify(As,Ss,&#38;) + Unify(Ai,Sr,E), where Ao =AU${pku}, Al = SAo \nand Si = S@&#38;So, provided p- u * S i! an instance of one of the rewrite rules. Rewrite rules: (Y t \n(T * I[o := ~78 (rule 1) FpG; + (IF := 08 (rule 3) p &#38; o * {o := /SD (rule 2) F,i-Ga + {F := GHOB \n(rule 4) Fp &#38; (T AU j {[F := F O A F U]} (rule 5) Applying substitutions to constraint sets: . S({T \n&#38; T } U A) = simplify((Sr) A (ST )) U SA. . simplify({r 4 T } U A) = simplify(r &#38; T ) U simplify(A). \n F simplify(ri &#38; T:) if T = FT~ and T = FT~, simplify(T{ &#38; 71) U simplify(Q &#38; Ti) if 7 = \nT1 -+ TZ and 7 = T; --f T;, . simplify(r &#38; T ) = simplify(ri -T:) U simplify(rs A T$) if r = 71 A \n72 and 7 = T; A Ti, 0 if 7 = T , {T k T } otherwise. Figure 4: Algorithm Unify. @(e, S) of triples in \n{O,l}* x (0,1) x (0,1) . The defi- nition of @ is by induction on e, for a fixed S throughout: @(Q S) \n= {(e, s, &#38;)I WeoAel,S) 2 P, i. q, r) I (p, q, r) E Wei, S), i E (0,111 .,,=g. ~{(si~p,q,~i~r)~(p,q,r)EQi((e)~~,S),l~iIn} \nwhere SF = e , #I = n, and .si = path(Cl( ),e ) for 1 5 i 5 n The intention of Cp is that if (p,q,r) \nE @(e,S), then the path p identifies hole Cl( ) in Se, the path q iden-tifies hole Cl(j) in e of which \n. and lci) in Se is a copy, r is the subsequence of the path p contributed by the substitution S. Given \nsubstitutions Sr and Sz, together with an E- path environment E, the safe composition of 541 and SZ relative \nto &#38; is a new substitution defined by: Sz(S1(v:))p if 2, = wOp,&#38;(vs) = Z , (Sz @E f%)(v) = S,(&#38;l) \n= e, zh;r;isz,@(e, and Ss), ( (I D(v) 0 In lemma 4.3, we state a condition and prove that it is sufficient \nto guarantee that the action of the substi- tution Ss 8~ Si on a type 7 is equal to the action of the \ncomposition Sz 0 Si on r. Lemma 4.3 (Sufficient Condition for Safe Com-position). Let S1 and Sz be substitutions, \nlet r be a type, and let S = S~@~SI for some E-path environment E. If r and SIT are well-named types \nand &#38; > E-env(r), then S (T) = &#38;(S~(T)). 0 Definition 4.4 (Unification Algorithm). The op-eration \nof Unify is based on the rewrite rules shown in figure 4. Because Unify is non-deterministic, there are \nin general many evaluations of Unify for the same input A. We exhibit the consecutive rewrite steps of \na particular evaluation of Unify(A) by writ-ing: Unify(As,([D,&#38;) + Unify(Ar,Si,E) + ... + Unify(Ai, \nSi,&#38;) a ... where As = simplify(A) and &#38; = E-env(A). To indicate that the evaluation of Unify(A) \nmakes i 2 1 calls to Unify (beyond the ini- tial call), and that the arguments of the ith call are the \nconstraint set Ai, the substitution Si, and the E-path environment E, we write: Unify(Ao, { D, E) =$ \nUnify(Ai, S;, E) . We write Unify(As, (I D,&#38;) &#38; Unify(A,S,&#38;) to mean that either (As, ([ \nD,&#38;) = (A, SE) or there is an evaluation of Unify(A) such that Unify(Ac, ([ D, e) &#38; Unify(A, \nS, E) for some i > 1. Whenever we say A and A are X-compatible con-straint sets such that Unify(A, S, \nE) * Unify(A , S , &#38;) for some substitutions S and S and some E-path en-vironment E, we assume that \nsimplify(A) = A. The way Unify is defined guarantees that simplify(A ) = A again. 0 Lemma 4.5 (X-Compatibility \nIs Invariant). Let Aa and A, be constraint sets such that Unify(Ao, SO, E) =G- Unify(Al, SI, &#38;) for \nsome substitutions SO and S1 and some E-path en-vironment &#38; (which do not matter here). If A0 is \nX-compatible, then so is A,. In words, the properties listed in definition 3.7 are invariant relative \nto the rewrite rules of Unify. cl Lemma 4.6 (Progress). Zf Ae is a non-empty X-for some substitutions \nS and S. Zf S1 is a principal compatible constraint set such that simplify(As) = As, together with a \nsubstitution Se and an E-path environ-  ment E, then there is a constraint set Ai such that Unify(Ao, \nSO, E) +-Unify(Ai, SI, &#38;) for some substitution Si (which does not matter here). In words, A0 always \ncontains a constraint that can be processed by one of the rewrite rules of Unify. 0 Lemma 4.7 (Solutions \nwith Finite Support Suf-fice). Let A be a X-compatible constraint set and let S : Var + (E U I - ) be \na substitution. Zf S is a solution for A, then we can construct a substitution S from S such that: 1. \nDom(S ) is finite. 2. S is a solution for A. 0  Definition 4.8 (Size). Given a type r E I , the func- \ntion size( ) applied to r returns an integer size(r) 1 1 which is the number of symbols in r excluding \nall oc- currences of E-variables and all parentheses. We extend size( ) to expansions e E E in the obvious \nway. Formal definitions, by induction on r and e respectively, are omitted. 0 Definition 4.9 (Degree). \nLet A be a X-compatible constraint set, with EVar(A) = {Fi,. . . ,Fk}. Let S be a solution for A with \nfinite Dam(S), say: S={G1:=el,..., G,:=e,,cul:=al,..., cxn:=unD If 2 E EVar*, let ($1 denote its length, \ni.e., the num-ber of variables in the sequence. We define a mea-sure degree(S,A) = (p,q,r) on the pair \n(S, A), where p,q,r E N, as follows: . p = Cl<i<m (size(ei) -1) o q = size(A) . r = Clsisk (k -IE-path(R, \nA)l) Given two triples (p, q, r) and (p , q , r ) of natural num-bers, we write (p,q, r) < (p ,q ,r \n) iff either p < p , or p = p and q < q , or p = p , q = q and r < r . This is the so-called lexicographic \nordering on triples of natural numbers, and it is easy to see that it is well- founded. El Lemma 4.10 \n(Decreasing Degree when Solv-able). Let Ae be a X-compatible constraint set, let Ai be a constraint \nset, and let Unify(Ae, SO, E) + Unify(Ai, Si, E) for some substitutions Se and Si and some E-path en-vironment \n&#38; (which do not matter here). Zf there is a solution Sb for A0 with Dom(Sb) finite, then there is \na solution Si for Ar with Dom(S;) finite such that degree(Sj:, Ai) < degree(Sb, A,). 0 Lemma 4.11 (Principal \nSolution Constructed). Let Ae be a X-compatible constraint set with &#38; = E-env(Ae), let Ai be a constraint \nset, and let Unify(Ae, S, f) 3 Unify(Ai, S @&#38; S, E) solution for Ai, then S1 8s S is a principal \nsolution for Ao. Cl The following theorem shows that the algorithm is sound (i.e., the substitutions \nUnify produces when it terminates are in fact solutions) and complete, (i.e., Unify produces a solution \nif there is one), as well as showing it produces principal solutions. Theorem 4.12 (Soundness, Completeness, \n&#38; Principality). Let A be a X-compatible constraint set with E = E-env(A). 1. A has a solution if \nand only if Unify(simplify(A), (I D, E) &#38;-Unify(0, S, E) for some substitution S. 2. Zf Unify(simplify(A), \n(I D, I) 3 Unify(0, S, E) for some S, then S is a principal solution for A. Cl  Note that Unify diverges \nexactly when there is no solution. The evaluation strategy does not matter, be-cause lemma 4.10 implies \ntermination when there is a solution and lemma 4.11 implies divergence when no solution exists. 5 Type \nInference Algorithm This section defines a procedure which, given a X-term M, generates a finite set \nI (M) of constraints, the solv- ability of which is equivalent to the typability of the term M. We use \nthis to prove the principality property for System I and to define a complete type inference algorithm. \nDefinition 5.1 (Algorithm Generating Con-straints and Skeleton). For every X-term M, figure 5 gives an \ninductive definition of a set of constraints I (M) and a derivation skeleton Skel(M), defined simultaneously \nwith a type Typ(M) and a type environment Env(M). In this definition, for a given subterm occurrence \nN, when a fresh variable is chosen, the same fresh variable must be used in Env(N), Typ(N), I (N), and \nSkel(N). The process of going from M to l?(M) and Skel(M) is uniquely determined up to the choice of \nexpansion variables and type variables. 0 Lemma 5.2 (Constraint Set is X-Compatible). Let M be an arbitrary \nX-term. The constraint set I (M) induced by M is X-compatible. 0 Lemma 5.3 (All Derivations Instances \nof Skel(M)). Zf V is a derivation of System I[ with final judgement A k M : 7, then there exists some \nsubstitution S such that 2, = S(Skel(M)). 0 Theorem 5.4 (Constraint Set and Skeleton Equivalent). Given \nX-term M, a substitution S is a solution for I (M) if and only if S(Skel(M)) is a derivation of System \nI[. Thus, I (M) is solvable if and only if M is typable in System II. 0 Corollary 5.5. It is undecidable \nwhether an arbitrarily chosen X-compatible constraint set A has a solution. 0 From the principality property \nfor X-compatible p-unification, we can derive the following. If M = I, for fresh a E TVarb: TYP(M) = \n0, Env(M) = {z ++ a}, I?(M) =0, Skel(M) = (VAR,Env(M) t- M : a). If M = (NiNa), for fresh F E EVarb, \np E TVarb: Typ(M) = p, Env(M) = Env(Ni) A F Env(Nz), p(M) =r(&#38;)u Fr(N2)u {Typ(N)--Typ(N2)--+P), Skel(M) \n= (APP,Env(M) + M : P,Skel(Ni) (FSkel(N2))). Env(N)(z) --t Typ(N) if Env(N)(z) defined, If M = (Xz.N), \nfor fresh a E TVarb: TYP(W = o --t TYP(N) otherwise, ;;$M) 1 $\\N)\\G Skel(M) = (R,Ehv(M) k M : Typ(M),Skel(N)) \nwhere if 2 E FV(N), then R = ABS-I, else R = ABS-K. Figure 5: Definition of I (M), Skel(M), Typ(M), and \nEnv(M). Theorem 5.6 (Principal Typings and Complete- ness of Type Inference). Let PT be the algorithm \nsuch that PT(M) = (Unify(P(M)))(Skel(M)) If M is typable in System 1, then PT(M) returns a prin-cipal \ntyping for M, else PT(M) diverges. Thus, Sys-tem I[ has the principality property and PT is a complete \ntype inference algorithm for System 1. 0  6 Termination and Decidability at Finite Ranks This section \ndefines UnifyFR, an adaptation of algo-rithm Unify which produces a solution S with bounded rank k for \na X-compatible constraint set A. The defi-nition of UnifyFR differs from Unify only in the mode of operation \nas presented in figure 6. The invocation of UnifyFR on A at rank k produces a solution S if Unify(A) \nproduces S and the rank of S is bounded by k. Otherwise UnifyFR halts indicating failure, unlike Unify \nwhich diverges if it can not find a solution. Note that the principality of solutions produced by UnifyFR \nfollows from the principality of solutions pro-duced by Unify. Definition 6.1 (Rank of Types). For every \ns E { L, R, 0, l} , let # L(S) denote the number of occur-rences of L in s. Let r E T. There is a smallest \n(and, therefore, unique) 9 E To with n _> 1 holes such that 1. 7-= /0[71,. . . ,m] for some71 ,... ,rn \nET. 2. None of the types in (~1,. . , TV} contains an oc- currence of A .  The ran/z of hole Ci) in \ncp is given . by hole-rank@ ), cp) = # L(path(Cl(i), 9)). If p = 0, i.e., r does not mention any A , \nwe define rank(r) = 0. If cp # 0, we define rank(r) by: rank(r) = 1 + max{hole-rank(Cl( ), p) ( 1 5 i \n< #m(p)} This definition of rank(r) is equivalent to others found in the literature. If A = {ri -ri, \n. , 7n A 7;) is a X-compatible constraint set, we define rank(A) by: rank(A) = max{rank(ri), rank(Ti), \n. , rank(r,), rank(rA)} Definition 6.2 (Rank-k System of Intersection Types). Let k 1 1. If S is a skeleton \nof System I[ where every environment type has rank 5 k -1 and every derived type has rank 5 k, we write \nrank(S) 5 k and say that S is a rank-k skeleton. We define the restriction lIk of System II as follows. \nA skeleton S of I[ is a skeleton of l[k iff rank(S) 5 k. A particular susbet of the rank-k skeletons \nare the rank-k derivations. 0 Definition 6.3 (Rank-k Solution). Let A be a X-compatible constraint set, \nA 5 TVar, and k 2 1. We say that a substitution S : Var -+ (E U T ) is a rank-k solution for A relative \nto A provided: 1. S is a solution for A. 2. rank(Sja) 5 k -1, for every cy E A. 3. rank(Scr) 5 k, for \nevery cr $ A.  The set A discriminates between T-variables corre-sponding to environment types and T-variables \ncorre-sponding to derived types in a typing; for a rank-k typ- ing, the first must have rank 5 k -1, \nand the second must have rank 5 k. 0 Lemma 6.4. Let M be a X-term and A = I (M). Zf S is a rank-k solution \nof A, then there is a derivation of M is System nkf2. . To show that for a fixed A C TVar and fixed k \n1 1, an evaluation of UnifyFR(A, A, k) always terminates, we need to reason about the rank of a constraint \nin a constraint set. The following definitions support this. Definition 6.5 (X-Compatible Pairs). Let \n(T, 7 ) be a pair of types. We define its constraint decomposition sequence d(r, T ) = (cp, ?I,. ,in,f;, \n,+A) with 1+2n entries, where cp E TO with n 2 0 holes is the largest (and therefore unique) type context \nsuch that 7-= cp[n,... ,m], T' = &#38;,... ,+J, {q,7-:} = {F;,?:} for 1 5 i 5 n, (r;, q!) = (Pi, ?l) \nif hole-rank@( ) p) is even (G, 7, ) = (y, ?i) if hole-rank@ ): cp) is odd.  Mode of operation: . Initial \ncall: UnifyFR(A, A, k) + UnifyFR(simplify(A), I[ D ,E-env(A), A, k) for A E TVar and k > 1. . UnifyFR(0, \nS,&#38;, A, k) + S. . UnifyFR(A0, Se, &#38;,A,k) a UnifyFR(Ai, Si, E, A, k) if Unify(Ae, So, E) + Unify(Ai, \nSi ,E) and also: -rank(Sia) 5 k -1 for every a E A. - rank(SicY) 5 k for every a e A. Figure 6: Algorithm \nUnifyFR (refer to figure 4 for missing parts). If G . = E-path@ ,v) for 1 5 i 5 n, then its constraint \n. set ~ecomposztzon( I s: If A(T, r ) is a X-compatible constraint set, then (r, r ) is a X-compatible \npair. In this case, 4 E W and +,! E 9 for 1 5 i 5 n, so we can let ii = pi and ?, = ui for 1 5 i < n \nand write A(r,r ) in the form:  A(r,+) = {Glpl -GIUI,. . . , G,p, G Gnon}. Note that simplify(A(r, \nr )) = A(r, r ), because d(r, r ) chooses the largest cp with the stated property. We de- fine the rank \nof constraint C?ipi A C?iai in (T, T ): rank(G;pi G Gigi, (r, r )) = hole-rank(O(i), cp). We also define \nh(r, 7 ): h(r, 7 ) = min{ hole-rank(O(i), p) 11 5 i 5 n}, i.e., h(r, r ) is a lower bound on the L-distance \nof all the holes in p from its root (viewed as a binary tree). If r = 7 = cp, i.e., p has 0 holes, we \nleave h(.r,~ ) undefined. 0 Definition 6.6 (Evaluating X-Compatible Pairs). Let (~0, r;) and (71, r;) \nbe X-compatible pairs. Let rule a be one of the 5 rules listed in figure 4. We write iffd(rc,r,$)=(cp,pr \n,... ,pn,al ,... ,o,)andthereisiE (1,. . ,n} such that: 1. pi A Ui * S is an instance of rule a. 2. \n(71,ri) = (Go, %-A).  In such a case, we say that (70, T;) is evaluated to (71,~;) by rule a. Moreover, \nif hole-rank(O(i),cp) = k, we say that the constraint pi k ui is at rank k and that the evaluation from \n(ro, 7;) to (ri, ri) is also at rank k, in-dicated by writing Wewrite(7e,r~)*(ri,r~)incase(ro,r~)~((ri,r~)for \nsome rule a, and &#38; for the reflexive transitive closure of *. Let R E (1,. ,5}. Let (TO, 7;) * . \n. * (m, TA) be an evaluation sequence with n 2 1 steps. We write (70,~;) + (~~,r;) to indicate that the \nevaluation has n steps, and that each step is carried out using rule a for some a E R. Finally, if there \nis no pair (ri, r;) such that (ro,rA) 9 (rl,r;), then we say that the pair (70,~;) is in R-normal form. \n0 Lemma 6.7 (Evaluating without Rule 5). Let R = {l,... ,4}, i.e., R is the set of all rewrite rules \nwithout rule 5. If (~0~~6) is a X-compatible pair, there is a bound kf(7.0,~;) solely depending on (T~,T;) \nsuch that for every evaluation with R. (TO, ~6) + (~1, T;), we have n 5 iVf(~o,~;). In words, a non-terminating \neval-uation of (70,~;) must use infinitely many times rule 5. cl Lemma 6.8 (Evaluating with Rule 5 at \na Fixed Rank). Let R be the set of all rewrite rules without rule 5, as in lemma 6.7. Hypothesis: Let \n(TO, Th) be a X-compatible pair in R-normal form, with k = h(To,~;), and consider an arbitrary evaluation \nwith the rules in R (with no rank restriction) and rule 5 restricted to rank k: (To,T;) 3 (TlrT;) 3 (T%T;) \n3 .. 3 (TnrT:) where for every 1 5 i 5 n, either ai E R or ai = 5 and the step (Ti-_1,Tl_1) 3 (T;,Ti) \nis at rank k. Conclusion: There is a uniform bound N(To, T;) solely depending on (TO, ~6) such that n \n5 N(To,T~). Moreover, if (TV, T:) cannot be evaluated further, i.e., if (TV, T;) is in R-normal form \nand in (5, k)-normal form pee definition 6.6), th en either TV = 7; or h(Tn,~A) > 0 Definition 6.9 (Increasing-Rank \nEvaluations). Let R be the set of all rewrite rules without rule 5, as in lemma 6.8. Let (~0~~6) be a \nX-compatible pair. An increasing-rank evaluation of (TO, ~6) is of the form: where (~1, T:) is in %normal \nform and, for every i 2 1, if Ti # Tl then I&#38; = R U ((5, ki)} where ki = h(Ti, Ti) and (T~+I, T,!+~) \niS in &#38;-normal form. cl Definition 6.10 (Coding X-Compatible Con-straint Sets as X-Compatible Pairs). \nThe coding rA of a X-compatible constraint set A = (71 &#38; TI,... ,Trz k T;} is the pair (T,T ) given \nby: T = (TI A A (T+1 A Tn)) 7 = (T: A A (T;-1 A T;)) It is clear that .A1 is a X-compatible pair (defini-tion \n6.5). 0 Lemma 6.11 (Increasing-Rank Evaluations Complete). Let n be a X-compatible constraint set, and \nlet (T,T ) = rA1. If an increasing-rank evaluation of (7,~ ) does not terminate, then A has no  solution. \n. Theorem 6.12 (Decidability of Finite-Rank p-Unification). Let A be a X-compatible constraint set, A \na set of T-variables, and k 1 1. 1. A has a rank-k solution relative to A iff there is a successful evaluation \nUnifyFR( A, A, k) 3 S. 2. There are no infinite (diverging) evaluations start-ing from UnifyFR( A, A, \nk). 3. It is decidable whether A has a rank-k solution rel-ative to A. 0  References [vB93] S. van \nBakel. Intersection Type Disciplines in Lambda Calculus and Applicative Term Rewriting Systems. PhD thesis, \nCatholic University of Ni-jmegen, 1993. [Ban971 A. Banerjee. A modular, polyvariant, and type-baaed closure \nanalysis. In Proc. 1997 Int l Conf. Functional Progmmming, 1997. [CDCVSO] M. Coppo, M. Dezani-Ciancaglini, \nand B. Ven-neri. Principal type schemes and X-calculus seman-tics. In Seldin and Hindley [SH80], pp. \n535-560. [CDCV81] M. Coppo, M. Dezani-Ciancaglini, and B. Ven-neri. Functional characters of solvable \nterms. 2. Math. Log. Grund. Math., 27:45-58, 1981. [CGQ2] M. Coppo and P. Giannini. A complete type infer-ence \nalgorithm for simple intersection types. In 17th Colloq. Trees in Algebra and Programming, vol. 581 of \nLNCS, pp. 102-123. Springer-Verlag, 1992. [DM82] L. Damas and R. Milner. Principal type schemes for functional \nprograms. In Conf. Rec. 9th Ann. ACM Symp. Principles of Programming Languages, pp. 207-212, 1982. [GJS96] \nJ. Gosling, B. Joy, and G. Steele. The Java Lan-guage Specification. Addison Wesley, 1996. [Jen98] T. \nJeraen. Inference of polymorphic and conditional strictnt. Troperties. In Conf. Rec. POPL 98: 25th A \nCM Symp. Principles of Prog. Languages, 1998. [Jim961 T. Jim. What are principal typings and what are \nthey good for? In Conf. Rec. POPL 96: 23rd ACM Symp. Principles of Prog. Languages, 1996. [JMZ92] B. \nJacobs, I. Margaria, and M. Zacchi. Filter models with polymorphic types. Theor. Comp. SC., 95:143-158, \n1992. [KfoSX] A. J. Kfoury. Beta-reduction as unification. In D. Niwinski, ed., Logic, Algebra, and Computer \nSci-ence (H. Rasiowa Memorial Conference, December 1996). Springer-Verlag, 199X. [KW94] A. J. Kfoury \nand J. B. Wells. A direct algorithm for type inference in the rank-2 fragment of the second-order X-calculus. \nIn Proc. 1994 ACM Conf. LISP Funct. Program., 1994. [Lei83] D. Leivant. Polymorphic type inference. In \nConf. Rec. 10th Ann. ACM Symp. Principles of Progmm-ming Languages, pp. 88-98, 1983. [MTHMSO] R. Milner, \nM. Tofte, R. Harper, and D. B. Mac-Queen. The Definition of Standard ML (Revised). MIT Press, 1990. [Pie941 \nB. Pierce. Bounded quantification is undecidable. Inb d Comput., 112:131-165, 1994. [PJHH+93] S. L. Peyton \nJones, C. Hall, K. Hammond, W. Partain, and P. Wadler. The Glasgow Haskell compiler: A technical overview. \nIn Proc. UK Joint Fmmework for Information Technology (JFIT) Technical Conf., 1993. [Pot801 G. Pottinger. \nA type assignment for the strongly normalizable X-terms. In Seldin and Hindley [SH80], pp. 561-577. [RDR88] \nS. Ronchi Della Rocca. Principal type schemes and unification for intersection type discipline. Theor. \nComp. SC., 59:181-209, 1988. [RDRV84] S. Ronchi Della Rocca and B. Venneri. Principal type schemes for \nan extended type theory. Theor. Comp. SC., 28:151-169, 1984. [SH80] J. P. Seldin and J. R. Hindley, eds. \nTo H. B. Curry: Essays on Combinatory Logic, Lambda Calculus, and Formalism. Academic Press, 1980. [SM96] \n6. Sayag and M. Mauny. A new presentation of the intersection type discipline through principal typings \nof normal forms. Technical Report RR-2998, INRIA, Oct. 16, 1996. [SM97] 8. Sayag and M. Mauny. Structural \nproperties of in- tersection types. In Proceedings of the 8th Interna-tional Conference on Logic and \nComputer Science -Theoretical Foundations of Computing (LIRA), pp. 167-175, Novi Sad, Yugoslavia, Sept. \n1997. [Urz97] P. Urzyczyn. Type reconstruction in F,. Math. Strut. in Comp. SC., 7(4):329-358, 1997. \n[We1941 J. B. Wells. Typability and type checking in the second-order X-calculus are equivalent and undecid-able. \nIn Proc. 9th Ann. IEEE Symp. Logic in Com-puter Sci., 1994. Superseded by [WelSX]. [We1961 J. B. Wells. \nTypability is undecidable for F+eta. Tech. Rep. 96-022, Comp. Sci. Dept., Boston Univ., Mar. 1996. [WelSX] \nJ. B. Wells. Typability and type checking in Sys-tem F are equivalent and undecidable. Ann. Pure d Appl. \nLogic, 199X. To appear. Supersedes [Wel94].    \n\t\t\t", "proc_id": "292540", "abstract": "", "authors": [{"name": "A. J. Kfoury", "author_profile_id": "81332508516", "affiliation": "Boston University, Boston, MA", "person_id": "PP39074288", "email_address": "", "orcid_id": ""}, {"name": "J. B. Wells", "author_profile_id": "81341498152", "affiliation": "Heriot-Watt University, EDINBURGH, EH14 4AS, Scotland", "person_id": "PP39080916", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/292540.292556", "year": "1999", "article_id": "292556", "conference": "POPL", "title": "Principality and decidable type inference for finite-rank intersection types", "url": "http://dl.acm.org/citation.cfm?id=292556"}