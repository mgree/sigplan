{"article_publication_date": "01-01-1999", "fulltext": "\n A Simple, Comprehensive Type System for Java Bytecode Subroutines Robert O Callahan Carnegie Mellon \nUniversity 500 Forbes Avenue Pittsburgh, PA 14122685728 roc+@cs.cmu.edu The goal of these alternative \nsystems was to formalize, explain ABSTRACT and correct the JVM verifier. Thus they are similar to the \nJVM A type system with proven soundness is a prerequisite for the safe verifier in spirit. However, we \nfound it instructive to construct a and efficient execution of Java bytecode programs. So far, efforts \ntype system from scratch based on conventional ideas such as to construct such a type system have followed \na forward continuations and polymorphic recursion, and compare it to the dataflow approach, in the spirit \nof the original Java Virtual JVM verifier and the aforementioned type systems. To facilitate Machine \nbytecode verifier. We present an alternative type system, direct comparison, we have constructed a language \nJVML-O-C based on conventional ideas of type constraints, polymorphic which is practically identical \nto Stata and Abadi s JVML-0 in recursion and continuations. We compare it to Stata and Abadi s syntax \nand dynamic semantics, but which has an entirely different JVML-0 type system for bytecode subroutines, \nand demonstrate static semantics. JVML-O-C satisfies the same soundness theorem that our system is simpler \nand able to type strictly more programs, as JVML-0. including code that could be produced by Java compilers \nand The type system of JVML-O-C is similar to the Stack-based Typed cannot be typed in JVML-0. Examination \nof real Java programs Assembly Language of Morrisett et al. [6] (hereafter referred to as shows that \nsuch code is rare but does occur. We explain some of STAL ). By targeting the JVMLO bytecode language, \nwethe apparently arbitrary constraints imposed by previous demonstrate that this approach leads to type \nrules that areapproaches by showing that they are consequences of our simpler somewhat simpler than the \ncorresponding rules of the JVM-like type rules, or actually unnecessary. systems. Furthermore, JVML-O-C \nis able to type strictly more Keywords programs. In particular, it admits programs that perform non-local \nreturns , which occur when a bytecode subroutine returns to Java, bytecode, types, subroutines, continuations, \npolymorphic code that was not its immediate caller, skipping some frames on recursion. the hypothetical \nsubroutine call stack. Such programs are not 1. INTRODUCTION typable in JVML-0, but can be acceptkd by \nthe JVM. This is The Java bytecode language (referred to hereafter as JVML), as important because such \ncode can be generated by the Java implemented by the Java Virtual Machine [S], has become a compiler. \nAs we describe below, examples are very rare but do widely used medium for distributing platform-independent \noccur in real Java code. The difficulty of typing these programs is programs. It attempts to enforce \nsafety properties for these due to JVML-O s need to label instructions with the subroutine programs, \nusing a mixture of static and dynamic checking. This is they belong to, which is not required in JVML-O-C. \nparticularly important because the programs may be untrusted. A significant benefit of studying JVML-O-C \nis that it illuminates For example, if a program can access memory in undisciplined some of the design \nchoices made in the JVM-like type systems. ways, then it may be able to steal private information. Hitherto, \nthe type constraints in those systems have been However, people [e.g., l] have found a number of weaknesses \nin evaluated according to three criteria: they match the expected the JVM s checks that have caused it \nto accept programs with behavior of bytecode programs, they are together sufficient to unsafe and possibly \ninsecure behavior. Therefore it seems prove soundness, and they admit code generated by the Java desirable \nto formalize the Java bytecode language and its type compiler. This gives great latitude in designing \nthe constraints, system and to prove safety. Researchers [8, 7, 21 have formulated but this latitude \ncan obscure the motivation and consequences of type systems for subsets of the Java bytecode language \nand proven the design choices. In contrast, each type constraint in JVML-O-C their soundness. has its \nown individual, clear rationale. We therefore use JVML-O-C as a basis for evaluating the rules of JVML-0 \n(and by analogy, the rules of other JVM-like type systems): Permission to make digital or hard copies \nofall or part ofthiswork for personal or classrwm use i!, &#38;Tanted without fee prmided that copies \n. Some properties described by others as needed for type arc not made or distributed for prc~lit or commercial \nadvnnlagc and that safety , such as a LIFO discipline for subroutine calls, can in topics hear this notice \nand the full citation on the first page. fo copy fact be violated by well-typed JVML-O-C programs, and \nthus otherwise. to republish. to post on servers or to redistribute to lists. are not fundamentally necessary \nfor type safety. require5 prior specilic permssion ontf: or a fee. POPL 99 San Antonio Texas L!SA Copyright \nACM 1999 I-581 13-095-3/99/O] . ..$5.00 instruction ::= inc increment the integer on top of the stack \nPOP push0 load store ifL jsrL discard the top value from the stack push the integer zero onto the stack \nx push the value of variable x onto the stack x pop from the stack and store the value into variable \nx pop from the stack and branch to L if non-zero jump to L, push the next instruction address onto the \nstack ret x jump to the address in variable x halt stop, returning the integer on top of the stack Figure \n1: JVML-O/JVML-O-C Syntax . JVML-0 is more restrictive than necessary in several other ways. In particular, \nthe need to label instructions with the subroutine they belong to is a key source of complexity and inflexibility, \nand is done away with in JVML-O-C by typing return addresses as continuations (hence the C in JVML-0-C \n). . An interesting property enforced by JVM-like systems is that a return address can only be used once. \nIt turns out that this property is a direct consequence of disallowing recursive return address types \nin JVML-O-C. . Most of the JVML-0 constraints are implied by the JVML-O-C constraints, and therefore \nobtain the same justifications. 2. OVERVIEW OF THE LANGUAGE AND TYPE SYSTEM 2.1 The language Except \nfor the type system, our language JVML-O-C is almost identical to JVML-0 -a bytecode-like language with \nan operand stack, simple arithmetic, conditional branches, local variable loads and stores, and subroutine \ncalls and returns (see Figure 1). A program includes the code for only a single method -there are no \nobjects, nor a heap. The syntax and dynamic semantics are unchanged. We prove the same soundness theorem \nas for JVML- 0, slightly strengthened to guarantee that an integer is returned. 2.2 JVML-O-C types As \nin JVML-0, a type is an abstraction of the state on entry to an instruction. We define state types, stack \ntypes and local variable types that are very similar to JVML-0. The key differences are the handling \nof return address types and the introduction of type variables into JVML-O-C. The program type P is a \nmap from instruction addresses to state types. A state-type 2 is a pair of a stack-type 8 and a locals-type \nT. It gives the types that hold on entry to a bytecode instruction. ..- c ..-(0, T> A stuck-type 8 is \neither a stack type variable 4, an application of a constructor taking the type of the top of the stack \nand the type of the rest of the stack, or NIL, the type of the empty stack. As in We require methods \nto return integers, whereas JVML-0 leaves the return type unspecified. STAL, the introduction of polymorphic \nstack type variables enables recursive subroutines. It s also necessary for translating JVML-0 types \nto JVML-O-C types; see Section 9. ..- 0 ..-7.8 I f4 I Nn  A locals-type T is a finite map from local \nvariables to their types. T VAR + element-type The type r of an element of the stack or of a local variable \n(an element-type) is one of the integer type INT, the type of all values TOP, a type of a return address \n(continuation) Cont , or an element type variable a. A return address type gives a state-type C that \nmust hold for the program state whenever the return address is returned to. This allows us to write rules \nfor the subroutine call and return instructions that are local , referring only to the types of the caller \ninstruction, the called instruction, and the returned-to instruction. We also avoid any need to explicitly \nname subroutines or label instructions as belonging to particular subroutines. In addition, the combination \nof type variables with continuations allows a flexible polymorphism in subroutines in a natural way. \n..- z ..-INT I TOP I Cant(Z) I a The scope of a type variable is the instruction type in which it appears. \nIn effect, the type of an instruction universally quantifies over all the type variables that appear \nwithin it. In the type rules, whenever we refer to the type of an instruction, we instantiate it with \nfresh bindings for the type variables. The type rules are given in Section 3. 2.3 Example Figure 2 is \nan example of a JVML-O-C program with a valid type assignment. It pushes zero and an unusable value onto \nthe stack, calls a subroutine to swap them, and then halts with the zero on top of the stack. The subroutine \nis polymorphic in the types of the stack values that it swaps. This kind of polymorphism is not available \nin either the JVM or JVML-0; subroutines in these systems are only polymorphic over local variables that \nthey do not touch in any way. i P[il 4 0 push0 (Nn, [0: %, 1: a,, 2: ci2, 3: aa]) 1 load 0 (INT NIL, \n[0: 1: a,, 2: a2, 3: as]) aa, 2 jsr 4 (g, INT . NIL, [0: a,,, 1: ai, 2: a2, 3: a&#38; 3 halt (INT aa. \nN&#38; [0: o!+, 1: a,, 2: cr+, 3: INT]) 4 store 1 (Cont(as . NIL, [0: %, 1: TOP, 2: a4, 3: as]) . a4. \na5 Nn, [0: o,,, 1: a,, 2: az. 3: a&#38; a4. 5 store 2 (a4. NIL, [0: 1: Cont(as a4 NIL, [0: ae, 1: TOP, \n2: a4, 3: as]), 2: a2, 3: a&#38; a5 o!a, 6 store 3 (as. NIL, [0: ae, 1: Cont(as a4. NIL, [0: o!,,, 1: \nTOP, 2: a4, 3: as]), 2: ad, 3: a3]) 7 load 2 (NIL, [0: 1: Cont(as a4 NIL, [0: a.,,, 1: TOP, 2: a4, 3: \nas]), 2: a4, 3: a*]) ~6, 8 load 3 (a4 NG [0: ~6, 1: Cont(as cl,. Ntt, [0: a.+, 1: TOP, 2: a4, 3: as]), \n2: a4, 3: as]) 9 ret 1 (a, a4. Nn, [0: Q, 1: Cont(as a4. Nn, [0: aa, 1: TOP, 2: cl,, 3: as]), 2: cl,, \n3: a5]>  Figure 2: A pdymorphic swap subroutine The type for instruction 0 indicates that on entry, \nit expects an empty stack, and the local variables can each have any type. The type for instruction 4 \nindicates that on entry, the local variables can have any type, but the stack must contain three elements. \nThe top element must be a return address, the next element has some arbitrary type a4, and the last element \nhas some arbitrary type as. The returned-to instruction must accept a state where the stack has two elements, \nthe top having type a5 and the next having type a,. It must also accept local variable 0 having the same \ntype it has on entry (aa), local variable 1 being unusable (TOP), local variable 2 having type a4 and \nlocal variable 3 having type as. (Local variable 1 becomes unusable on return because it holds the return \naddress when the subroutine returns at instruction 9; see Section 3.4 for why this is so.) Note that \ninstruction 3 is a valid return address for the subroutine because its type matches the return address \ntype. In type for instruction 3, a1 can be any type, so we can substitute T OP for it. Similarly, we \ncan substitute cc, for a4, and INT for as. The resulting instantiation is precisely the return address \ntype, which shows that whatever state the subroutine returns in will be acceptable at instruction 3. \n  2.4 Overview of the rest of the paper Section 3 gives the type rules for JVML-O-C. Section 4 compares \nJVML-O-C with JVML-0 and the JVM. In Sections 5.1 and 5.2 we discuss how JVML-O-C admits certain programs \nthat are accepted by the JVM but not by JVML-0. In Section 5.3 we mention some features that are typable \nin JVML-O-C but not by the JVM. Then in Section 0 we analyze aspects of the design of the JVM verifier, \nas captured by JVMLO. Section 6 presents some empirical data indicating that subroutines are rarely used \nin real Java code, and the kinds of situations that JVML-0 has trouble with are rarer still. However, \nthey do occur and must be handled. Section 4 presents the dynamic semantics of JVML-O-C, which are identical \nto those of JVML-0. Section 7 introduces JVML-0-CB, a restriction of JVML-O-C to programs for which the \nstack size at each instruction is known. In Section 8 we establish the properties identified as important \nby Stata and Abadi: . Type safety. An instruction will never be given an operand stack with too few values \non it, or with values of the wrong type. . Program counter safety. Execution will not jump to undefined \naddresses. . Bounded operand stack. The size of the operand stack will never grow beyond a static bound. \nThe first two properties hold for all JVML-O-C programs, but the third property holds only for JVML-0-CB \nprograms. In JVML-O-C, with an unbounded operand stack, it is possible to write bytecode programs that \nuse recursive subroutines in interesting ways, although such programs would never be generated by a standard \nJava compiler. We distinguish the two languages to demonstrate that the bound on the stack size is separable \nfrom the rest of the type system. In Section 9 we show that a program s JVML-0 typing can be translated \ninto a JVML-0-CB typing, implying that every JVML-0 program is also in JVML-0-CB. 3. STATIC SEMANTICS \nOF JVML-O-C 3.1 Preamble We define substitutions S to map stack type variables to stack types and element \ntype variables to element types in the natural way. The set of stack type variables and the set of element \ntype variables are disjoint. We define Xi I &#38; to mean instantiation, that is, 3 a substitution S. \nS(&#38;) = &#38; . The idea is that if a state can be given a type Zi, then it can also be given a type \nC, obtained from Zi by instantiating the type variables. (Comparing this to STAL, where the scope of \na type variable is a basic block of instructions, our approach is analogous to treating each instruction \nas a block of length one, with an explicit transfer from each instruction to its successor(s). This removes \nany need to explicitly identify or reason about blocks, which would require some overhead since JVML \nprograms are simply a vector of instructions, and not naturally block-structured as in STAL.) A program \nP is an array of instructions, i.e. a partial map from addresses to instructions. Addresses are isomorphic \nto integers, but distinguished from them. We use + and the constant 1 for addresses as well as integers. \nADDR is the set of all addresses. 3.2 Typing programs A program P is well-typed if there exists a partial \nfunction A mapping instruction addresses to types, satisfying the judgement A t- P, for which we have \none rule: Vx E dom VAR. E[X] = TOP A, I (NIL, E) tli~ domA.A,iCP domAcdomP AbP The first and second hypotheses \nestablish the initial conditions: the state-type for the first instruction must admit the type that has \nan empty stack and TOPtypes for all the local variables. (In other words, the local variables cannot \nbe used in any meaningful way.) The third hypothesis ensures that types are checked at each program point \nusing the rules below: A, i k P means that the program type A is correct for P at instruction i. The \nfourth hypothesis ensures that addresses outside the program are not given types; thus, any instruction \nthat could branch outside the program will not be typable, because each instruction s type rule has hypotheses \nwhich depend on the types of each of the successor instructions. We do not require every instruction \nto be typable; unreachable instructions need not have types. Of course, every constraint that mentions \nAi implicitly requires i to be in the domain of A. 3.3 Widening The widening operator < is defined by \nthe rules in Figure 4. It allows the type of any stack element or variable to be replaced with TOP. (Types \ninside a Cont do not change -allowing them to be widened would violate soundness, because the state accepted \nby the Cont might no longer be acceptable to the returned-to code.) This operator is used to erase some \ntype information in the typing rule for ret, as discussed below. Widening extends pointwise over state, \nstack and local variable types. Widening is reflexive. The last rule makes TOP an upper bound for element \ntypes. 8 < 8, T < T, (0, T) + (%, T,) Vx E VAR. T[x] < T,[x] T < T, P[i] = halt P[i] = if L UNT 8. T) \n= Ai - (INT 6, T) = Ai A,i b P Ai+r 2 (0, T> ALL@', T) P[i] = pop A, i t P (7. 8, T) = Ai Ai+l It@, T) \nP[i] = inc A, i t P (INT. 0, T) = Ai Ai+L I (INT 8, T) P[i] = push0 A, i t P (t3, T) = Ai Ai+l 5 (INT \n8, T) P[i]= jsrL A, i k P (f3, T) = Ai AL I (Cant(Z) . 8, T) P[i] = loadx Ai+i I Z (Et, T) = Ai A, i \nk P 4+l S (Tbl 8, 0 A, i I P P[i] = ret x (0, T) = Ai P[i] = store x T[x] = Corn@,, T,) (7. 8, T) = Ai \n(0, T) + to,, T,) Ai+i I@, Ux - ~1) A, i k P A, i t P Figure 3: JVML-O-C Type Rules 3.4 Typing instructions \nFor each kind of instruction, one of the rules in Figure 3 applies. Each rule has a simple motivation: \nthe type on entry to an instruction i must satisfy the immediate operational requirements of the instruction, \nand the types of i s successor(s) must be satisfied by the type of i s after state. The same reasoning \neven applies to jsr, where the after state contains a return address whose type encodes the requirements \nof the returned-to instruction. It also applies to ret, which introduces widening only to avoid a need \nfor recursive types. For example, the second hypothesis of the inc rule can be read the state-type for \ninstruction i implies that the top of the stack is an INT, that the rest of the stack has type 8, and \nthat the local variables have types T . The third hypothesis of the inc rule can be read the state-type \nfor instruction i+l admits a stack with an INT top element and tail of type 8, and local variables of \ntypes T . The rule for halt ensures that an integer is left on top of the stack as the return value for \nthe method. The rule for j sr ensures that whenever the subroutine returns to i+l, it returns in state \nZ, which will be acceptable at i+l . The rule for ret ensures that the state on return is the state expected \nby the return address. The third hypothesis ensures that the type of variable x is a return address, \nand the fourth hypothesis ensures that the current state type matches the type expected on return. Instead \nof these two hypotheses, it would be more natural to z < TOP simply write T[x] = Corm@, T) . However, \nthis would require T[x] to be a recursive type. Introducing recursive types would Figure 4: Widening \nrules P[pc] = inc P c <PC, f, n s> + <pc + l,J (n + 1) . s> p[Pcl=PoP P t <PC, f, v s> + <PC + l,f, \n0 P[pc]= push0 P 1 <pc,f, s> + <PC + l,f? 0. s> P[pc]=loadx P k <pc,f, s> + <PC + I,f,A4~ s> P[pc] = \nstorex P t <pc,f, v s> + <PC + l,fix -VI, s> P[pc]=if L P t- <pc,f, 0. s> + <PC + 1,x s> P[pc]=if L \nV#O P t <PC, f,V'S>-+cL,f,S> P[pc] = jsr L Pt<pc,f,s>+d,f,(pc+1)~s> P[pc] = retx P 1 <PC, ~s>-+<flxl,f,s> \nFigure 5: Dynamic Semantics for JVML-O/JVML-O-C complicate the type system, and the extra programs that \ncould be 5. COMPARING JVML-O-C WITH JVML-0 typed by such a system may not be practically interesting. \nAND THE JVM Therefore, we avoid recursive types by allowing type information to be erased using the widening \noperator. This allows us to type 5.1 Typing subroutines with abnormal T,.,[x] as TOP, effectively preventing \nthe returned-to code from behavior having access to its own address in x. Other variables or stack Bytecode \nsubroutines are used by Java compilers to compile try- locations can also be erased, as in the JVM and \nJVML-0. finally statements. The statement try S finally F executes S and STAL solves the problem in \na similar way; the register holding then F, no matter how control leaves S; if S throws an exception \nthe return address is never given a type by the code that is or returns from the method, F will still \nbe executed on the way returned to. In fact, giving a value type TOP is always analogous out . Typically \nthe code for F is placed in a subroutine, and called to simply omitting it from the STAL type signature. \non each of the exit paths for S. Note that allowing generalization in any of the hypotheses for The question \narises, what happens if control does not leave F ret (e.g. (0, T) I (e,, T,) ) leads to unsoundness. \nIntuitively, normally ? Consider the code in Figure 6. This program would constant code can be polymorphic, \nand therefore instantiated at different types by different predecessors, but a return address boolean \ndone = false; value is not polymorphic, because the type variables in the type of int x = 0; the returned-to \ncode have already been bound in the type while (true) C environment of the caller. try 1 x++; 4. DYNAMIC \nSEMANTICS OF JVML-O-C if (done) return x; The rules presented in this section are identical to those \nof ) finally { JVML-0. if (!done) continue; 1 Execution starts at address 1; if 1 p dom P, then no transitions \nI can occur and the program cannot typecheck. The initial state is cl, f, E> for some arbitraryf, where \nE is the empty stack. Figure 6: A Java program with an abnormal The small-step transition rules are given \nin Figure 5. subroutine 11 halt (INT . NIL, [0: 1: 2: a*])R, al, 12 jsr 14 (NIL, [0: IN-T, 1: INT, 2: \na2]) 13 got0 43 (NIL, [0: INT, 1: INT, 2: a*]> 14 store 2 (Cont(N&#38; [0: INT, 1: INT, 2: TOP]) . NIL, \n[0: INT, 1: INT, 2: a*]) 15 load 0 (NIL, [0: INT, 1: INT, 2: Cont(Nn, [0: INT, 1: INT, 2: TOP])]) 16 \nif4 (INT . NIL, [0: INT,1: INT, 2: Cont(NrL, [0: INT, 1: INT, 2: TOP])]) 17 ret 2 (NIL, [0: INT, 1: INT, \n2: Cont(Nn, [O:INT,1: INT,2: TOP])]) Figure 7: A bytecode program loop forever, but one could replace \ndone and ! done with more complicated boolean conditions yielding various results. Sun s Java compiler \n(supplied with JDK 1.1) produces bytecode similar to the JVML-O-C code in Figure 7 (shown with one possible \nJVML-O-C typing). Notice how the return address type in local variable 2 is widened to TOP on return \nso that the return address type need not be recursive. The local variable 0 corresponds to done, and \nlocal variable 1 corresponds to x. The finally subroutine at 14 may not return; instead, it exits by \nsimply jumping out! A similar exit without returning can occur when a subroutine throws an exception \nthat is caught in the method. These abnormal exits can make a subroutine appear to be invoked recursively, \nor a subroutine can appear to return to code that was not its immediate caller. JVML-0 cannot type such \nprograms, because it relies on control leaving a subroutine only through a ret instruction. In JVML-O-C, \nbecause we do not maintain a notion of the current subroutine , there is no need to know when the subroutine \nis exited. The return address value is simply discarded if it will not be used. 5.2 Typing control-flow \nmerges In the JVM, if there is a control flow merge where two predecessors have incompatible types for \na particular stack element, the program is rejected. However, merging of two incompatible types for a \nlocal variable yields TOP. If the value of the local variable is dead at the merge point, then the program \ncan pass verification. In JVML-O-C, this is achieved by typing a local variable with an arbitrary type \nvariable if the local variable is dead at the instruction. This type variable can be instantiated in \na different way by each predecessor of the instruction; i.e. incompatible types can be merged if the \nvariable or stack element is dead at the merge point. with an abnormal subroutine 5.3 Beyond the JVM \nJVML-O-C is more flexible than the JVM in some ways. A bytecode verifier based on JVML-O-C would allow \nconstructs that could be useful to advanced compilers for Java or other languages. JVMLO-C allows a subroutine \nto have multiple entry and/or exit points (JVML-0 requires a single entry point, and the JVM requires \na single entry and a single exit). In some situations this would reduce duplication of code. Our type \nsystem allows more polymorphism in subroutines than the JVM-like systems. In those systems a subroutine \nis polymorphic in the types of the local variables it does not touch. In our type system, polymorphic \nvalues (including values on the operand stack) can be manipulated by a subroutine, as long as the operations \ndo not constrain the value s type. For example, the program in Figure 2 contains a subroutine that swaps \nthe values of two stack elements regardless of their type. JVML-O-C allows subroutines to be truly recursive. \nIf a static bound on the stack size is required for implementation reasons, i.e., programs are restricted \nto JVML-0-CB, then recursive subroutines are not very useful. If such a bound is not required, then potentially \nuseful recursive subroutines can be typed: see Figure 8. This program calls the subroutine at 5 recursively, \nincrementing local variable 0 each time, until the value reaches zero. (Of course this never actually \nhappens, but the type system is oblivious to that fact.*) Unfortunately JVML-0 cannot encode subtraction \nor a comparison with nonzero. Figure 8: A recursive subroutine 5.4 Assessing subroutine constraints \nin the JVM verifier Because the JVM-like systems try to build an explicit model of the subroutine call \nstack, they impose a LIFO discipline on subroutine calls and returns. This necessitates subroutines being \nnamed and associated with instructions -the purpose of the labeling rules in JVML-0. These rules can \nreject programs if no consistent labeling can be found (examples are programs that jump out of subroutines \nas mentioned above). JVML-0 also uses strong labeling rules to construct an abstraction of the call stack \nat each program point. These rules reject all programs with recursive subroutine calls. JVML-O-C shows \nthat explicit modeling of a subroutine call stack, and all the associated machinery, is not necessary \nfor a sound type system. In order to maintain the LIFO behavior of subroutines, the JVM- like systems \nmust also carefully restrict the use of return address values. In JVML-0, the type of a return address \nvalue is of the form ret-from L. An instruction j sr L. pushes a value of type ret-from L into the stack, \nand a ret instruction requires its argument to be of type ret-from L where f. is the first instruction \nof the current subroutine. In contrast, in JVML-O-C the return address type simply specifies the state \nexpected by the returned-to code, and is not bound to any particular subroutine. Because the JVML-0 type \ndoes not encode the type of the return state, an extra nonlocal constraint in their type rule for ret \nis used to ensure that the state on return is acceptable to the returned-to code. The constraint is nonlocal \nin the sense that it quantifies over all instructions in the program. JVML-O-C does not require such \nnonlocal constraints. Without additional constraints in JVML-0, there remains the possibility that a \nsubroutine L could return to an address generated by a call to L that was not the most recently executed \n3 Unfortunately JVML-0 is so simple that it cannot faithfully encode goto (an unconditional branch that \ndoes not depend on the type of the following instruction). We take a little license by using it here; \nthe type rule for goto would simply require A,arRe,2 A.Tour,,. call to L. Therefore their rule for jsr \nL prohibits any stack element or local variable from being given the type ret-from L on entry to L -ensuring \nthat only the most recently generated return address is available for use.4 In JVML-O-C nothing prevents \na subroutine from returning to an old address, but it is still guaranteed to be safe. In other words, \nLIFO subroutine behavior is not necessary for a sound type system. JVML-0 and the JVM have explicit constraints \npreventing a return address value from being used by a ret instruction more than once. Interestingly, \nthis property is also enforced indirectly by JVML-O-C: it is a direct consequence of the absence of recursive \ntypes in JVML-O-C. We could probably remove this restriction by adding recursive types, but there is \nno justification for the extra complexity. 6. EMPIRICAL DATA ON THE USE OF SUBROUTINES We examined all \nthe code in the standard JDK 1.1.4 classes.zip library. There are about 2.2 MB of bytecode instructions, \ncorresponding to 10986 method bodies. Of these, 175 contain at least one subroutine. Seven of these contain \ncode that would not typecheck with naive labeling rules based on those of JVML-0. All these examples \nconsist of subroutines inside exception catch blocks: if an exception is thrown inside the subroutine, \ncontrol passes to the exception handling block and the subroutine is deemed to have returned , although \nno ret instruction has been executed. In retrospect, it seems that adding subroutines to the bytecode \nlanguage may have been a poor design choice. In the l-2% of methods that use them, the compiler could \nhave generated explicit flags recording the caller and used conditional branches to simulate a return. \nThe need for polymorphism could be avoided by duplicating more code and/or using more local variables. \nIt seems likely that the extra code size and runtime costs would have been minimal overall, and bytecode \nverification would have been 4 In a similar way, the constraints in Freund and Mitchell s type system \nfor object initialization [FM981 ensure that only one object of a particular type is available for initialization. \n greatly simplified. Of course, the need to support legacy code means that we are stuck with the language \nas it stands. 7. BOUNDING THE STACK SIZE IN JVML-0-CB The JVM requires that a static bound on the size \nof the stack be known, and that the height of the stack be known at each program point. This may simplify \nlanguage implementations. 7.1 Additional type rule We can enforce this constraint by using the following \nrule for A t P: Vx E dom VAR. E(X) = TOP A, 5 (NIL, E) ViE domA.A,itP domAcdomP Vie domA.%,zi ,..., ~,,TiAi=((2,....,2,.NIL,Ti) \nAtP  The extra fifth hypothesis forces each stack type to be a finite string of element types. We call \nthe language of programs that satisfy this rule JVML-0-CB. Clearly JVML-O-C is a superset of JVML-0-CB. \n 8. SOUNDNESS The main result is practically identical to that of Stata and Abadi, and establishes the \ntype safety and program counter safety properties. Their theorem statement mentions a type judgement \nrelating a dynamic stack to a stack type. To avoid introducing such judgements for our theorem statement, \nwe assume that the method is supposed to return INT. (In this language, the only alternative is to not \nreturn anything.) Theorem 1 (Soundness). Given A t P, execution of P only stops if a halt instruction \nis reached, and when it stops there is an integer on top of the stack. ~PC,fo,f, s. (P t <l, fo, E> -+* \n<pc,f, s> A ;s,c:f, s: P k <pc,f, s> + <pc: f, Sk-> ~P[pc]=halth3n,s :s=n.s For the proof, we define \nan extended dynamic semantics for typed programs that carries around some type information at runtime. \nWe show that the soundness result holds for this semantics, and then show that standard dynamic semantics \ncorresponds to the extended semantics with the type information erased. The proof machinery also enables \na demonstration that, in the extended dynamic semantics, a given return address value can be used by \na ret at most once. Because we show that the extended dynamic semantics bisimulates the standard dynamic \nsemantics, the result extends immediately to the standard dynamic semantics. 9. TRANSLATING JVML-0 TYPES \nJVML-0-CB is a superset of JVML-0. We show this by translating a program s JVML-0 type assignment into \na valid JVML-0-CB type assignment for the same program. The details of this translation are given in \nAppendix B. The correctness of the translation depends on the fact that JVML-0 subroutines cannot use \nnonlocal returns , which suggests that extending JVML-0 to handle nonlocal returns would be nontrivial. \nThe key problem with JVML-0 is that the Cp,i abstraction of the call stack at instruction i does not \nencode enough information to determine, statically, whether a nonlocal return should be allowed. For \nexample, if Cp,i = L Li . b, then we know that subroutine L is active, but we do not know if L, is active. \n(This abstraction could be generated when Li and I.e each call L.) Therefore a nonlocal return at i using \na value of type ret-fromLimayormaynotbevalid. 10. IMPLEMENTATION ISSUES The complete verification process \nmust first generate the type information, and then check it. Only the type checking phase needs to be \ntrusted. 10.1 Type checking Checking types is straightforward, given the type assignment A and for each \njsr instruction, the return to type Z used in its type rule. With these in hand, all terms occurring \nin the type rules are known. The equality and widening constraints are easily checked by structural induction. \nThe instantiation constraints are checked by trying to unify the two terms while treating the variables \nof the right hand side as constants. We have implemented the typechecker in C, totaling about 350 lines \nof code, and used it to check the examples in this paper. 10.2 Type inference The type system is closely \nrelated to type systems incorporating polymorphic recursion [3]. Full type inference for polymorphic \nrecursion has been shown to be undecidable in the general case [3]. In practice one would obtain types \nby applying some less general algorithm, such as an algorithm analogous to the JVM s own verifier, and \ntranslate the types into JVML-O-C to be checked for safety. 11. RELATED WORK The type system is very \nsimilar to that of the Stack-based Typed Assembly Language of Morrisett et al. [6]. They both rely on \npolymorphic recursion to handle loops, and they both type code addresses with the type of the state that \nthe code expects on entry. STAL s existential types for closures are unnecessary since JVML does not \nsupport closures. (Java does support inner classes , a limited kind of closures, but they are translated \nto JVML objects.) Freund and Mitchell [2] investigated adding object initialization constraints to JVML-0. \nIt does not appear to be difficult to adapt their approach to JVML-O-C. Qian has formulated type checking \nand inference for a very rich subset of JVML [7]. However, his machinery to handle subroutines that do \nnot exit cleanly is rather complex [Section 10.6 of [7]]. For example, for each instruction it constructs \na mapping from pairs of subroutine addresses to sets of local variables. Hagiya and Towaza [4] have proposed \nanother method for checking bytecode subroutines. Although it can handle some kinds of nonlocal returns, \nit relies on constructing the set of all possible call stacks at each instruction, and therefore cannot \ntype programs with an infinite number of possible subroutine call stacks (such as the valid Java program \nin Section 5.1). 12. CONCLUSIONS We have developed a type checker for bytecode subroutines by applying \nfamiliar concepts long known to the programming language community -continuations and polymorphic recursion \n- rather than creating ad-hoc structures based on the JVM s intuitive approach to approximating run-time \nbehavior. This enables a direct comparison between the two general approaches, and we believe that the \nresults show this constraint based type checking is fundamentally simpler and more powerful. We see no \nreason why this approach should be any more difficult than other approaches to extend to full JVML. In \nparticular, since the set of JVML object types and the subtype relation between them is known a priori \nby the bytecode verifier, we would not expect particular difficulties integrating a treatment of objects \ninto JVML-O-C. Our work has several practical implications. In general it seems that the design of low \nlevel typed languages such as bytecode would benefit from experiences with the type systems of high level \nlanguages. For JVML itself, our approach might lead to a design for a simple checking engine whose implementation \nwould be easier to trust than that obtained by other approaches. Furthermore, if such an engine were \nwidely used, then the extra programs it admits could be useful. For example, an optimizing compiler could \nbetter compact bytecodes by using subroutines with multiple entries and exits, or by collapsing similar \ncode sequences into a polymorphic subroutine and making use of the extra polymorphism we provide. Compilers \nfor other languages that target Java bytecode might also be able to exploit the extra flexibility. 13. \nACKNOWLEDGEMENTS I am supported by a Microsoft graduate fellowship. I would like to thank the CMU POP \ngroup for constantly bombarding me with types, and especially Robert Harper for his help and advice. \n 14. REFERENCES HI D. Dean, E. Felten and D. Wallach. Java Security: From HotJava to Netscape and beyond. \n1996 IEEE Symposium on Security and Privacy, May 1996. PI S. Freund and J. Mitchell. A type system for \nobject initialization in the Java bytecode language. Proceedings of the ACM SIGPLAN 98 Conference on \nObject-Oriented Programming Systems, Languages and Applications, October 1998. [31 F. Henglein. Type \ninference with polymorphic recursion. TOPLAS, Volume 15, No. 2, 1993. [41 M. Hagiya and A. Towaza. On \na new method for dataflow analysis of Java Virtual Machine subroutines. Proceedings of the Fifth International \nStatic Analysis Symposium, Springer- Verlag LNCS, 1998. T. Lindholm and F. Yellin. The Java Virtual Machine \nSpecification. Addison-Wesley. I61 G. Morrisett, K. Crary, N. Glew and D. Walker. Stack-Based Typed Assembly \nLanguage. 1998 Workshop on Types in Compilation. 171 Z. Qian. A formal specification of Java virtual \nmachine instructions. Formal Syntax and Semantics of Java, Springer- Verlag LNCS, 1998. El R. Stata and \nM. Abadi. A type system for Java bytecode subroutines. Proceedings of the 25th Annual ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages, January 1998. VI    \n\t\t\t", "proc_id": "292540", "abstract": "", "authors": [{"name": "Robert O'Callahan", "author_profile_id": "81100649205", "affiliation": "Carnegie Mellon University, 500 Forbes Avenue, Pittsburgh, PA", "person_id": "P245990", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/292540.292549", "year": "1999", "article_id": "292549", "conference": "POPL", "title": "A simple, comprehensive type system for Java bytecode subroutines", "url": "http://dl.acm.org/citation.cfm?id=292549"}