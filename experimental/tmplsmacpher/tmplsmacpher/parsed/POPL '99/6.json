{"article_publication_date": "01-01-1999", "fulltext": "\n Types for Mobile Ambients Luca Cardelli Andrew D. Gordon Microsoft Research Abstract Java has demonstrated \nthe utility of type systems for mobile code, and in particular their use and implications for security. \nSe- curity properties rest on the fact that a well-typed Java program (or the corresponding verified \nbytecode) cannot cause certain kinds of damage. In this paper we provide a type system for mobile computa- \ntion, that is, for computation that is continuously active before and after movement. We show that a \nwell-typed mobile compu-tation cannot cause certain kinds of run-time fault: it cannot cause the exchange \nof values of the wrong kind, anywhere in a mobile system. 1 Introduction In previous work [4] we introduced \nthe (untyped, monadic) am-bient calculus, a process calculus for mobile computation and mobile devices. \nThat calculus is able to express, via encodings, standard computational constructions such as channel-based \ncommunication, functions, and agents. The type system presented in this paper is able to provide typings \nfor those encodings, recovering familiar type systems for processes and functions. In addition, we obtain \na type system for mobile agents and other mobile computations. The type system is obtained by decorating \nthe untyped calculus with type infor- mation. An ambient, in our sense, is a confined place where process- \nes run. Each ambient has a name, and may contain multiple pro-cesses and subambients. A process can cause \nits surrounding am-bient to move in or out of other ambients, transporting all the subambients and active \nprocesses with it. A process may also open an ambient, that is, it can dissolve an ambient boundary while \npreserving its contents. Finally, processes within the same ambient may exchange messages. Our type system \ntracks the typing of messages exchanged within an ambient. For example, the following system consists \nof two ambients, named a and b: a[(x:Znt).P I open b] I b[in a. (3)] Permissioclto 111&#38;e digital \nor hard copies of all or part of rhis work for personal or classroom use is granted without fee provided \nthat copies arc not made or distributed for profit or commercial advantage and that topics bear this \nnotice and the full citation on dlC fi! St pgC. TO COPY otherwise. to repl~hlish. to post on serwrs or \nto redistribute to lists, requires prior specific permission and/or a fee. POPL 99 San Antonio Texas \nUSA Copyright ACM 1999 I-581 13-095-3/99/01...$5.00 The ambient named a contains a process (x:ht).P \nthat is ready to read an integer message into a variable x and proceed with P, and a process open b that \nis ready to open (dissolve the boundary) of an ambient b found within a. The ambient named b contains \na process in a. (3) that moves the ambient b inside a (by executing in a) and then outputs the message \n3. The ambient b is opened after moving into a, so the output comes into direct contact with the reading \nprocess within a. The result is the binding of an inte- ger message to an integer variable, yielding \nthe state: 4Plx+311 The challenge of the type system is to verify that this exchange of messages is well-typed. \nNote that in the original system the in- put and the output were contained in separate locations. Our \nambient calculus is related to earlier distributed vari-ants of the n-calculus, some of which have been \nequipped with type systems. The type system of Amadio [l] prevents a channel from being defined at more \nthan one location. Sewell s system [121 tracks whether communications are local or non-local, so as to \nallow efficient implementation of local communication. In Ri- ely and Hennessy s calculus [l 11, processes \nneed appropriate permissions to perform actions such as migration; a well-typed process is guaranteed \nto possess the appropriate permission for any action it attempts. Other work on typing for mobile agents \nincludes a type system by De Nicola, Ferrari, and Pugliese [5] that tracks the access rights an agent \nenjoys at different localities; type-checking ensures that an agent complies with its access rights. \n 2 The Polyadic Ambient Calculus We begin by reviewing and slightly extending the ambient cal-culus \nof [4]. In that calculus, communication is based on the ex- change of single values. Here we extend the \ncalculus with com- munication based on tuples of values (polyadic communication), since this simple extension \ngreatly facilitates the task of provid- ing an expressive type system. In addition, we annotate bound \nvariables with type information. Four of our process constructions (restriction, inactivity, composition \nand replication) are commonly found in process calculi. To these we add ambients, capabilities, and a \nsimple form of communication. We briefly discuss these constructions; see [4] for a more detailed introduction. \nThe restriction operator, (vn:W)P, creates a new (unique) name n of type W within a scope P. The new \nname can be used to name ambients and to operate on ambients by name. The in- active process, 0, does \nnothing. Parallel composition is denoted by a binary operator, P I Q, that is commutative and associative. \nReplication is a technically convenient way of representing iter-ation and recursion: the process !P \ndenotes the unbounded repli-cation of the process P and is equivalent to P I !P. An ambient is written \nM[P], where M is the name of the am- bient, and P is the process running inside the ambient. The process \nM.P executes an action regulated by the capa- bility M, and then continues as the process P. We consider \nthree kinds of capabilities: one for entering an ambient, one for exiting an ambient and one for opening \nup an ambient. (The latter re-quires special care in the type system.) Capabilities are obtained from \nnames; given a name n, the capability in II allows entry into n, the capability OUTn allows exit out \nof n and the capability open n allows the opening of n. Implicitly, the possession of one or all of these \ncapabilities is insufficient to reconstruct the original name n from which they were extracted. Capabilities \ncan also be composed into paths, MM , with E for the empty path. Communication is asynchronous and local \nto an ambient. It is similar to channel communication in the asynchronous n-cal-culus [2, 61, except \nthat the channel has no name: the surround- ing ambient provides the context where the communication \nhap-pens. The process (Ml, . . . . Mk) represents the output of a tuple of values, with no continuation. \nThe process (nl:W1, . . . . nk:Wk).P represents the input of a tuple of values, with continuation P. \nCommunication is used to exchange both names and capa- bilities, which share the same syntactic class \nM of expressions. One of the main tasks of our type system is to distinguish the MS that are names from \nthe MS that are capabilities, so that each is guaranteed to be used in an appropriate context. In general, \nthe type system might distinguish other kinds of expressions, such as integer and boolean expressions, \nbut we do not include those in our basic calculus.  Polyadic Ambient Calculus r I P,Q ::= processes \n(vn: W)P restriction 0 inactivity f lQ composition !P replication MPI ambient M.P action (n,:W1, . . \n. . nk:W,).P input (MI, . . . . M/J async output M ::= expressions n name in M can enter into M out M \ncan exit out of M open M can open M E null path M.M composite path 1 I  Syntactic conventions Parentheses \nmay be used for precedence. (vn: W)P I Q is read ((vn: W)P) I Q !PI Q is read (!P) I Q M.PlQ is read \n(M.P) I Q (nI:WI, . . . . nk:Wk).P I Q is read ((nl:W,, . . . . nk:Wk).P) I Q (vn,:W1, . . . . n,:W,)P \nA (vn1: W,)...(vnk: Wk)P 41 4 n[O] M ii M.0 (where appropriate) The following tables describe the operational \nsemantics of the calculus. The type annotations present in the syntax do not play a role in reduction; \nthey are simply carried along by the re- ductions and will be explained in the next section. Terms are \nidentified up to an equivalence relation, =, called structural congruence. This relation provides a way \nof rearrang- ing expressions so that interacting parts can be brought together. Then, a reduction relation, \n-, acts on the interacting parts to produce computation steps. The core of the calculus is given by the \nreduction rules (Red In), (Red Out), and (Red Open), for mo- bility, and (Red Comm), for communication. \nTerms are also identified up to the consistent renaming of bound variables, in the restriction and input \nconstructs. We write P{ntM} for the substitution of M for each free occurrence of the name n in the process \nP. Similarly for M( ntM }. Free names I 1 fi(@n:W)P) 2 fnm-In) fm A G f@ IQ, A fW ) ufn(Q> jq!P) &#38; \nj%(P) fnW[Pl) 4s fW0 ufW> f4M.P) 2 fn(M) u.fW ) fn((n1:W1, . ..? rI&#38;W,).P) A fn(P) -{n,, . ..) rzk) \nfn((M1, . ..t MA) 2 fn(Md u . . . ufn(Md f+@) A {n) @(in M) A 500 fn(outM) A fn(M) f4open Ml 4 MM) fn(E) \n2 Id fn(M.M ) AL J%(M) ufi(M ) I I  Structural Congruence I I P-P (Struct Refl) P=Q =s Q-P (Struct \nSymm) P=Q,Q=R a P=R (Struct Trans) P= Q + (vn:T)P= (vn:T)Q (Struct Res) P=Q a PlR=QlR (Struct Par) P-Q \n=ZJ !P=!Q (Struct Repl) P=Q =s M[P]=M[Q] (Struct Amb) P Q a M.P=M.Q (Struct Action) P=Q 3 (Struct Input) \n(n,:T,, . . . . nk:Tk).P = (nl:T,, . . . . nk:Tk).Q PlQ=QlP (StructPatComm) (PIQ)IR-Pl(QlR) (StructParAssoc) \n!P = PI !P (Struct Rep1 Par) (vn:T)(vm:U)P = (vm:ZJ)(vn:7JP if II f m (Struct Res Res) (vn:T)(P I Q) \n= P I (vn:T)Q if n L&#38;(P) (Struct Res Par) (vn:T)m[P] = m[(vn:T)P] if n z tn (Struct Res Amb) PIO-P \n(Struct Zero Par) (vn:Amb[Tj)O = 0 (Struct Zero Res) !O = 0 (StructZeroRepl) &#38;.P s P (Struct E) (M.M \n).P z M.M .P (Struct .) Reduction n[inm. PI Q] I m[R] -m[n[P I Q] I R] (Red In) m[n[out m. P I Q] I R] \n-n[P I Q] I m[R] (Red Out) open n. P I n[Q] -PI Q (Red Open) (n,:W,, . ..) r$W,).P I (M,, . . . . M/J \n- (Red Comm) P(n,tM1, . . . . n+MJJ P+Q a (vn:W)P -(vn: W)Q (Red Res) P--Q * 4pl -dQ1 (Red Amb) P-Q =a \nPIR-QIR (Red Par) P -P,P-+Q,Q=Q j P -+Q (Red -) L 1 3 Exchange Types An ambient is a place where other \nambients can enter and exit, and where processes can exchange messages. The first aspect, mobility, is \nregulated by run-time capabilities and will not be re- stricted by our type system. The second aspect, \ncommunication, is what we now concentrate on. 3.1 Topics of Conversation Within an ambient, multiple \nprocesses can freely execute input and output actions. Since the messages are undirected, it is easily \npossible for a process to utter a message that is not appropriate for some receiver. The main idea of \nour type system is to keep track of the topic ofconversation that is permitted within a given ambient, \nso that talkers and listeners can be certain of exchang- ing appropriate messages. The range of topics \nis described in the following table by message types, W, and exchange types, T. The message types are \nAmb[Tj, the type of names of ambients that allow exchanges of type T, and Cup[7J, the type of capabilities \nthat when used may cause the unleashing of T exchanges (as a consequence of open- ing ambients that exchange \n2). The exchange types are Shh,the absence of exchanges, and WIx...xWk, the exchange of a tuple of messages \nwith elements of the respective message types. For k=O, the empty tuple type is called 1; it allows the \nexchange of empty tuples, that is, it allows pure synchronization. The case k=l allows any message type \nto be an exchange type. Types I 1 w ::= message types ANTI ambient name allowing T exchange CapUl capability \nunleashing T exchange T ::= exchange types Shh noexchange W,X...XWk tuple exchange I I For example: \nA quiet ambient: Amb[Shh] A harmless capability: Cup[Shh] A synchronization ambient: Amb[l] An ambient \nthat allows the exchange of harmless capa- bilities: Amb[Cup[Shh]] A capability that may unleash the \nexchange of names of quiet ambients: Cup[Amb[Shh]]  3.2 Intuitions Before presenting the formal type \nrules, we discuss the intuitions that lead to them. Typing of Processes If a message M has message type \nW, then (M) is a process that outputs (exchanges) W messages. Therefore, we will have a rule stating \nthat: M:W * (M):W If P is a process that may exchange W messages, then (x:W).P is also a process that \nmay exchange W messages. Therefore: P: w 3 (x:W).P: w The process 0 exchanges nothing, so it naturally \nhas exchange type Shh.However, we may also consider 0 as a process that may exchange any type. This is \nuseful when we need to place 0 in a context that is already expected to exchange some type. 0 : T for \nany T If P and Q are processes that may exchange T, then P I Q is also such a process. Similarly for \n!P. P:T,Q:T j PIQ:T P:T 3 !P:T Therefore, by keeping track of the exchange type of a process, T-inputs \nand T-outputs are tracked so that they match correctly when placed in parallel. 7jping of Ambients An \nambient n[P] is a process that exchanges nothing at the cur- rent level, so, like 0, it can have any \nexchange type, and can be placed in parallel with any process. n[P] : T for any T There needs to be, \nhowever, a connection between the type of n and the type of P. We give to each ambient name a type Amb[Tl, \nmeaning that only T exchanges are allowed in any ambient of that name. Ambients of different names may \npermit internal ex-changes of different types. n:Amb[Tj,P:T ==a n[P] is well-formed (and can have any \ntype) By tagging the name of an ambient with the type of exchanges, we know what kind of exchanges to \nexpect in any ambient we enter. Moreover, we can tell what happens when we open an am- bient of a given \nname. Typing of Open Tracking the type of I/O exchanges is not enough by itself. We also need to worry \nabout open, which might open an ambient and unleash its exchanges inside the surrounding ambient. If \nambients named n permit Texchanges, then the capability open n may unleash those T exchanges. We then \nsay that open n has a capability type CuP[7J, meaning that it may unleash T ex- changes when used: n \n: Amb[Tj a open n : Cup[Tl As a consequence, any process that uses a Cup[TJ must be a process that is \nalready willing to participate in exchanges of type T, because further T exchanges may be unleashed. \nM: Cup[7J, P : T =a M.P : T The capability types Cup[TJ do not keep track of any infor- mation concerning \nin and out capabilities; only the effect of open is tracked. 3.3 ljping Rules We base our type system \non three judgments. The main judg- ment tracks the exchange type of a process, that is the type of the \nI/O operations of the process, and of the I/O operations that the process may unleash by opening other \nambients. Judgments EFO good environment EkM: W good expression of message type W EkP:T good process \nof exchange type T Based on the discussion in the previous section, we can formal- ize the type system \nas described in the following table. Conven- tion: a list of assumptions E k J, . . . E k Jk for k=O \nmeans Et-0. Rules , I (Env @) (Env n) (EXP n) E I- V nfdom(E) E , n: W, E k V @kO E,n:Wk V E , n: W, \nE I- n : W (EXP E) (EXP .) El-0 EkM:Cup[TJ El-M :Cup[fl Et-&#38;: Cup[Tj Et-M.M : Cup[7J (Exp In) (Exp \nOut) (Exp Open) El-M:Amb[fl El-M:Amb[Sj EkM:Amb[Tj E F in M : Cup[fl E I- out M: Cup[Tl E I- open M : \nCup[7J (ProcAction) (Proc Amb) Et-M: Cup[q El-P:T EkM:Amb[Tj El--P:T EkM.P:T EkM[P]:S (Proc Res) (Proc \nZero) E, n:Amb[Tj t- P : S El-0 Et-(vn:Amb[g)P : S EFO:T (ProcPar) (Proc Repl) El-P:T EkQ:T EkP:T EFPIQ:T \nEt-!P:T (Proc Input) E, nl:Wl, . . . . nk:Wkl-P: Wlx...xWk E F (n,:Wl, . . . . nk:W,).P : W1x...xWk (Proc \nOutput) EFM,: W, . . . EkMk: W, E k (Ml, . . . . Mk) : W,x...xWk 1 I . Example: A process that outputs \nnames of quiet ambients: @ F !(vn:Amb[Shh])(n) : Amb[Shh] . Example: A capability that may unleash S-exchanges. \nNote that the in n action contributes nothing to the type of the path; only the open m action does: @,n:Amb[a, \nm:Amb[fl I- in n. open m : Cup[g The correctness of the type system is expressed by the fol- lowing \nproposition (the proof is in Appendix 7): 3-l Proposition (Subject Reduction) IfEl-P: UandPjQthenEFQ: \nU. cl Certain run-time error expressions are allowed in the syn- tax but are nonsensical because they \nconfuse names with capa- bilities. Examples are in n[P], (vn:Amb[q)n.P, and (in (in n)). Such expressions \nare not initially typeable, and they cannot be produced by well-typed processes because Proposition 3-l \nsays that the evolution of well-typed processes leads only to well- typed processes. 4 Applications 4.1 \nChannel Types We now begin to explore the expressiveness of our type system. The first test case is whether \nwe can represent typed communi- cation channels, that is, whether we can find a typed encoding of the \nn-calculus [8]. The basic idea for the encoding of channels is to use an am-bient as a buffer where input \nand output processes can exchange messages. An output operation generates an output packet that enters \nthe buffer and (after being opened) deposits an output. An input operation generates an input packet \nthat similarly enters the buffer, reads an input, and creates a return packet that exits the buffer and \ncontinues with the rest of the process. Each name n of the n-calculus becomes a pair of names in the \nambient calculus: the name n of the buffer and the name n of the packets. There-fore, communication of \na x-calculus name becomes the commu-nication of a pair of ambient calculus names. A n-calculus chan-nel \ntype Ch[ IVl for names of type W is translated as Am&#38; WXW]. Encoding of the Typed Polyadic Asynchronous \nx-calculus I I (Et-P] i? ~E~F~P~:Shh and buffers. For the n-calculus this techniques leads to a nicer \nencoding, where a channel type maps simply to an ambient type. Still, the technique of passing packet \nnames along with associat-ed ambient names is often useful, as we show in later examples.  Gonthier \ns Encoding r I lch[w,, .... w,]D 4 /hb[~W~~X...X~Wk~] {(V KCh[W,, .... w,])PD A (vn:lCh[W,, .... Wk])) \nn[!open n] 1(PI (n(n,:w,, .... nk:w,).p~ A (vp:Amb[Shh]) (open p I @k:~CfdWl, ...>w/d)) k[in n. n[out \nk. open k. h:W1D,. VDIII)  nk:~WkD).pbutn. Qnhw,,nkwk)D ..', i+ (vk:tCh[W,, .... Wk]D)k[in n. n[out \nk. open k. (n,, .... nk)]] WIQD 4 U'DllQD  CIChWl, ...> W,lDA Amb[~W,Dx~W,Dx...x~W~Dx~W~Dl t(v n:Ch[W,, \n.... W,])PD 4 (vn,nQCh[W,, .... W/J)) (n[!open d ] I U D) {n(nl: W,, .... nk:W,).PD &#38; (vp:Amb[Shh]) \n(open p I np[in n. (n,,nP,:gW,D, .... nk,d &#38;WkD). p[out n. {PD]]) @Z(n,,.... nk)D 2 nP[in n. (n,, \nn ,, .... nk, n k)] (PI QD 2 U'DltQD  (!PDk !(PD  I I The translation induces the following derived \ntyping rules, which correspond to a fragment of Pierce and Sangiorgi s system [lo] consisting only of \nbidirectional channels, with no subtyp-ing. Each x-calculus process is given the type Shh, since no com-munication \nhappens at the level of processes. Instead, communi-cation happens within buffers, so each buffer receives \nthe type of the corresponding 7c-calculus channel. Input and output packets receive the same type as \nthe buffers where they are opened. tE,n:Ch[W,, .... W,] k PI =3 {El-(V n:Ch[W,, .... w,])Pl (Et-n : ch[w,, \n.... w,]j, @k n, : W,D, .... tfE k nk : W,D * (Et-nh, . ., nk)D (El-n : Ch[W,, .... Wk]D,(E, n,:W,, .... \nnk:Wk /-PI  * (Et-n(n,:W,, .... nk:W,).PD   Wb-D,Ct-QD -Wt--lQD {Et-PI -@F!PD Georges Gonthier has \ndevised two other encodings of the x-calculus as ambients. The first encoding uses a single name n for \nboth the buffer and the associated packets, instead of pairs of names n, d. The packets are temporarily \nhidden inside another layer of ambients, so that there is no confusion between packets (We use a subscript \ntype to indicate the type of a term that, while not available in the term itself, is available in its \ntype derivation.) Gonthier s second encoding also uses single names for buff-ers and packets. In addition, \nthe encoding does not rely on buff-ers being generated at the place of v: buffers are generated when-ever \n(and wherever!) needed by I/O operations. For the z-calcu-lus this makes little difference, but if we \nimagine using channels freely within the ambient calculus, then it is important not to rely on a fixed \nlocation for the buffer: we may want I/O operations on a channel to interact whenever they occur within \nthe same ambi-ent. The potential problem with this idea is that, since there are multiple buffers, all \nthe output packets may go in one buffer, and all the input packets may go in a different buffer. To solve \nthis problems, the buffers are designed to be self-coalescing. This technique is useful in general, when \nbuffers need to be generated in a decentralized fashion. Gonthier s Coalescing Encoding I I CIChWl, \n. . . . w,]) A Amb[~W,~x...X~Wk~] t(v%:Ch[W,, .... Wk])PD b (vn:tCh[W,, .... Wk])) (PI (n(nl:wl, .... \nnk:i ,).p) ii (vp:Amb[Shh]) (open p.p[] I n[!open n I in n I (n,:lW,D, .... nk:IWkj). p[!outn 1openp.IPD]]) \n{n(n,, .... n&#38;D 2 n[!open n I in n I (nl, .... nd]  U'IQDC WDltQD I!PD A !((PD I I 4.2 Parent-Child \nCommunication It is often useful for an ambient to communicate with its parent or its children, as when \nan agent enters a server and wants to ex- change information with it. We now describe such a derived \ncommunication mechanism, and how to type it. Parent-Child I/O I I n(W parent outputs to child n n(x: \nW).P child n inputs from parent %M) child n outputs to parent n(x: w).P parent inputs from child n I \nI We could adopt the following reduction rules as primitive: n(x:W).P I n[*n(M) I Q] -P(xtM} I n[Q] Vn(M) \nI n[ n(x:W).P I Q] -n[P(xtM} I Q] Instead of taking these operators as primitive, it is possible to \nap- proximate parent-child I/O with normal ambient I/O. The encod- ing given below, however, fails to \nprovide the same atomicity guarantees as the reductions above. When using this encoding, parent-child \nI/O operations are partially sensitive to disruptions of the protocol due to sudden movement of the child. \nTo avoid this problem, the child has to implement its own synchroniza- tion. The encoding of parent-to-child \nmessaging is quite simple, using the child ambient as the communication buffer. Messages from the parent \ndown to a child nch use packets labeled ndn. n(M) A nd [in rich. (M)] n(x:W).P &#38; open ndn. (x:W). \nP This messaging is not sensitive to sudden movement of the child: messages from parent to child may \nget blocked but do not get lost. The encoding of child-to-parent messaging, instead, is more problematic. \nThere is a choice of where to put the communica- tion buffer: in the child or in the parent. If the buffer \nis in the child, the parent has to send a process to fetch the message; such a process may get lost on \nthe way back if the child has moved. If the buffer is in the parent, the child has to send a process \nto de- posit the message; such a process may get lost if the child moves before the (asynchronous) process \ncan get out. In both cases, though, the child can wait for a confirmation from the parent that the message \nhas reached the parent; this can be done with parent-to-child communication, which is reliable. After \nthe confirmation, the child is free to move. We describe the case where the buffer is kept in the parent. \n This arrangement seems more interesting because, with a simple modification, it can be extended to anonymous \ncommunication between arbitrary children and a parent. Each communication from a child nch to a parent \nhappens within a mailbox nhoxwithin the parent; the mailboxes are self-coalescing. Messages from a child \nnch up to the parent use pack-ets labeled nup that are sent out of the child and then into nhox. n(M).P \n&#38; n P[out rich. in nbox. (M)] vn(x:W).Pw* 5 (vp:Amb[ W ]) (open p. p[] I nbox[open nup. (x: W). p[out \nnbox. openp. P] I !open nbox I in nb ]) (The idioms open p. p[] and p[ . . . open p. P] are used to \ndelay the activation of P until P reaches the proper position.) The type of names of child ambients that \nadmit parent-child I/O may be denoted by Ambav[WJ. This notation can be translat- ed to the ambient calculus \nby mapping each environment name n : AmbAv[~ to four environment names rich, n P, nd , nbox : Amb[Wl, \nand by mapping each restriction (vn:AmbAVIWl) P to the restrictions (vrfh:Am6[Wj) (vn P:Amb[ Wj) (vnd \n:Am6[ Wj) (vnbox :Amb[ Wj) P. The derived type rules are as follows. (n : AmbAv[Wj ti P : 7) =a (vn : \nAmbAv[Wj).P : T M : W, n : AmbAv[Wj =a Vn(M) : U (any U) M: W, n : AmbAv[Wj + *n(M) : U (any U) n : AmbAv[Wj, \n(x : W d P : w) * n(x:W).P : W n : AmbAv[Wj, (x : W 3 P : W ) 3 Vn(x:W).P : W   4.3 Function Qpes \nBy using a typed encoding of channels in the ambient calculus, we can provide typed encodings of h-calculi \nsimply by using the known encodings of h-calculi into the K-calculus [9]. For exam- ple: Encoding of \nthe Call-by-Value h-calculus into the JC-ca lculus I tdk ii k(x) I {hr.bDk 4? (v n) (k(n) I !n(x, k ). \ntblk ) I {b(a)Bk ?! (v k , k ) ({blk 1k (x). ({&#38; 1k (y). x(y, k))) I Encoding of the Typed Call-by-Value \nh-calculus into the Ambient Calculus I I (E k 659 &#38; @ ) t- (vKk:Ch[{7D]) {blk : Shh @, xl:A,, . . \n. . x/:AJ 4 pl, x,:{A&#38; . . . . xl:{AAIl @*BD 4 Ch[IAD, Ch[tBDII bDk 45 k(x) @x:A.6A+BDk 5 (v%:{A-d?D) \n(k(n) I !n(x:{Al, k :Ch[{BD]). (6&#38;) t6/t+B(4&#38; A (v k :Ch[{A+BI)], k :Ch[{AD]) ({bDk*I k (x:{A-+BD). \n({UDk-I k (y:{AD). x(y, k))) L I Therefore, as in the n-calculus, a function is represented by a channel \nthat communicates an argument and a channel for the re- sult. The derived types reflect this structure. \n 4.4 Records We define operations for handling records of mutable cells; these will be useful in the \nnext example. A record r containing cells ci has the general structure r[ . . . I c;~ ~[(M,) I !open \nc:p] I . . . 1, where r is the cell container, qbUf are the value containers for each cell, ci are input \npackets for read- ing and writing cell contents, and M, are the cell contents. The operations consist \nof creating an empty record named r (record r), adding a cell named c with initial contents M to a record \nr (add r c M), reading the contents of cell c of record r and binding it to a variable x in a scope P \n(get r c (x:W). P), and setting the con- tents of a cell c of record r to a value M and continuing with \nP (set r c (M). P). (record rl 42 r[] {addrcm 2 cbuf[!open c@ I in r. (M)] @et r c (x: W). Psi SI (vop:Amb[SJ) \n(open op. op[] I ciP[in r. in cbufl (x: W). ((x) I op[out cbUJ. out r. open op. {PI])]) {set r c (Mw). \nPsi 4 (vop:Amb[q) (open op. op[] I @[in r. in cbU/ (x: W). ((M) I op[out cbUf. out r. open op. (PI])]) \n The names cbUfand c p related to a cell c are assigned the type Amb[Wj, where W is the type of the values \nheld by the cell. The name r of a record is simply assigned the type Amb[.Shh]. A record is able to hold \ncells of different types. The type of names of a record field holding W may be de- noted by Field[Wj. \nThis notation can be translated to the ambient calculus by mapping each environment name n : Field[Wj \nto two environment names nbuf,n P : Amb[WJ, and by mapping each re- striction (vn:Field[Wj) P to the \nrestrictions (vnb f:Amb[Wj) (vn@:Amb[ Wj) P. 4.5 Agents One of the original motivations for the ambient \ncalculus was to provide a natural semantics for wide-area network languages. We now define a simple agent \nlanguage inspired by Telescript [ 131. In the Telescript model, agents travel over the network be-tweenplaces \n(agent servers) where agents can meet and commu- nicate with other agents. Agents carry with them a suitcase \ncon-taining local agent data. The syntax of our stripped-down agent language, Telestrip d, is described \nin the following table, together with an informal description of the various constructions. We give the \nsemantics of Telestrip d by translation to the ambient calculus. The dynamic hierarchical structure of \nplaces, agents and suitcas- es is preserved by our translation; it would not be preserved so obviously \nby translations into standard process calculi. We are able to assign types to our definitions, yielding \na typed agent language: Agent[W,, . . . . WJ is the type of names of agents that accept communications \nof type W~x...xWk. Telestrip d Syntax W ::= Agent[Wl, . . . . Wk] agent types (k 2 0) Net ::= the network \nnoplace no place place p[Arenn] a place called p Net I Net more places Arena :I= inside a place empty \nnobody there agent (n:W)[Code] an agent with fresh name n Arena IArena more agents Code :I= agent code \nstop stop go p. Code go to place p and continue spawn (n :W)[Code ]. spawn a fresh agent n in the Code \ncurrent place welcome (nl:Wl, . . . . nk:Wk). accept input from a local Code agent meet n(n,, . . . \n. nk). Code output to local agent n folder n n . Code add new folder n with con- tents n to the suitcase \nget n(x: W). Code get contents of folder n from the suitcase set n(n ). Code set contents of folder n \nto n in the suitcase . . . other constructs (omitted) Typed Telestrip d Semantics I 1 {Agent[Wl, . . \n. . W&#38; A Amb[(Wllx...x(WkD] {Net) : Shh (Arenalp : Shh if p : Amb[Shh] (Code&#38;, : (w$x...x(wk) \nif m : ((Agent[Wl, . . . . Wk]) (noplace) 2 0 @lace p[Arena]j S? p[tArena$] (for p:Amb[Shh]) {Net I \nNet) &#38; (Net) I (Net)   @mptyDpA 0 {agent (n:Agent[W,, . . . . Wk])[Code]b 2 (vn:(IAgent[Wl, . \n. . . Wk])) n[record sut I add sut at p I (Code),] ((Arena I Are@, 5 (ArenaDp I (ArenaI,, @top&#38; \nk 0 {gap. Code), A get sut at(q:Amb[Shh]). set sut at(p). out q. in p. (Code), {spawn (n :Agent[W,, . \n. . . Wk])[COde ]. Code&#38;, A (for n' # m) get suf at@:Amb[%h]). (vn ,u:tAgent[ WI, . . . . Wk])) (n \n[recordsutIaddsutatpI outm. openu. (Code D,,] I open u. (Code&#38;, I (vt:Amb[Shh]) t[out m. in n . out \nn . (u[out t. in n ] I u[out t. in ml)]) (meet n(nlw,, . . . . nkw,). Code), A often as desired, as \nbefore. (vk:tAgent[W,, . . . . Wk])) &#38;out m. in n. n[out k. open k. (nl, . . . . n,)]] I (Code), \n(welcome (nl: WI, . . . . nk:Wk). Code), 4l open m 1(nl:tW,D, . . . . nk:IWkl). (Code), uolder n n w. \nCode),,, &#38; (vn:Field[tm]) (add sut n n I (CodeD,) @et n(x: W). Code),, 4% get sut n(x:(m). (Code), \n{set n(n ). Code), c set sut n(n ). (Code), No exchange happens at the network level, so the network \nhas type SM. Each arena has also type Shh, so the name of each place has type Amb[Shh]. The type of an \nambient reflects only the type of the ex-changes performed within it; each agent welcomes (inputs) a \nsin- gle type of data, but can output to agents of several different types. The meet primitive given \nabove is asynchronous; a (more natural) synchronous version is possible but more complicated. The name \nof the agent suitcase, sut, is a distinguished name of type Amb[Shh]. A suitcase is a record containing \na collection of cells. Each suitcase contains a cell named at, a distinguished name of type Amb[Amb[Shh]], \ncontaining the name of the agent s current place. 5 Affine Capability Types In this section, we describe \nan extension of our type system ob- tained by adding a new type of affine capabilities Cup [TJ. We enforce \nthe rule that whenever a process inputs a capability of this type, the process may exercise or output \nthe capability at most once. The motivation for this type system is that in some situa-tions we may want \ncapabilities to play the role of tickets or stamps that may be used once to access a valuable resource \n(for example, a compute server, or a printer). We would like to guar- antee that if a well-typed process \nis presented with k capabilities for accessing a resource, perhaps after a fee has been paid, then that \nresource is exercised at most k times. 5.1 Limiting the Use of Capabilities Linear type systems for \nthe z-calculus, beginning with the work of Kobayashi, Pierce and Turner [7], restrict the usages of bound \nnames in a variety of ways. Our system is analogous, but is affine (at most one use of names) rather \nthan linear (exactly one use). We modify the syntax of types by renaming Cup[7J to Cu$ [I j and by introducing \na new type, Cup [fl, of affine capa- bilities. The multiplicities 0, 1 and o are used to count the num- \nber of occurrences of names in terms. We enforce the following simple principles: . An input name of \ntype Cap [7 j may be exercised at most once. . An input name of type Cup [q orAmb[T J may be exercised \nas . A restricted name of type Amb[Tl may be exercised as often as desired, as before. For example: . \nDisallowed: (x:Cup [7 J). ((1) I (x)), (x:Cup [TJ). ((x) I n[x.P]) . Allowed: (n:C@ [fl). ((x) I (x) \nI n[x.P]), (x:AmbP l). (x[l 1 x[l), (x:AmbKl). HP1 1 -dQl), (vx:Amb[Tj). ((open x) I (open x) I (y:Cup \n[fl). (y)) Here is the syntax of the extended type system: QPes I I w::= message types AmbV l ambient \nname C~P VI affine capability C&#38;V-l unlimited capability T ::= exchange types Shh noexchange w,x...xwk \ntuple exchange l.t ::= multiplicities 0 never 1 once 0 many I I We let p+ range over { 1, 0). Let the \nmultiplicity order, ~1 S cc , be the least reflexive and transitive relation to satisfy 0 I 1 5 w. Let \nthe addition, /.t+/.~ of multiplicities lt and u be the multiplicity defined by the equa- tions p+O = \nO+p = u, 1 +l = O, and p+o = 0tl.t = W. Let the rep-lication, !p, of a multiplicity be the multiplicity \n~+I_I. The functions n occurs M and n occurs P, given by the fol- lowing equations, count the occurrences \nof the name n in the term M and in the process P, respectively. Note that any name under a ! has multiplicity \nu. n occurs m 2 1 if m=n; 0 otherwise n occurs in M =A noccurs M n occurs out M =A n occurs M n occurs \nopen M 4 n occurs M n occurs M.M A (n occurs M) + (n occurs M ) n occurs E =A 0 n occurs M.P A (n occurs \nM) + (n occurs P) n occurs M[P] G (n occurs M) + (n occurs P) n occurs (vm:W)P 4 (n occurs hl) form # \nn n occurs 0 =A 0 n occurs P I Q 3 (n occurs P) + (n occurs Q) n occurs !P ?! !(n occurs P) n occurs \n(nl:Wl, .,., nk:Wk).P 4 n occurs P for n $ {ni, . . . . nk) n occurs (Ml, . . . . Mk) 2 (n occurs Ml) \n+ . . . + (n occurs Mk) For example: n 0ccurs (m[J I (vn:w) n[]) = 0 n occurs m[n.O] = 1 n occurs (m[n.O] \nI (n)) = w We define a new type system using the same rules as before except for the modifications listed \nbelow.  Rules I I (Exp E) (Exp .) EI-0 Et-M : C@+[7J E b M : CuP +[7J Et-E : Cq+ +[7J E F M.M : Cq+ \n+[7J (EXP In) (Exp Out) EtM:Amb[Sj EC-M:Amb[SJ E I- in M : CuPp [7J E F our M : CuP +[fl (Exp Open) (Proc \nAction) EI-M:Amb[Tj EFM:CupCL+[Tj EI-P:T E I- open M : Cupi +[rJ EI-M.P: T (P~oc Input) (where Vie 1 \n..k. Wi =Cup [Ti] * ni Occurs P 5 1) E, n,:W,, . . . . nk:WktP: W~x...xWk E I- (nl:Wl, . . . . nk:W,).P \n: W,x,..xWk I I A subject reduction result can be proven for the modified system (the proof is in Appendix \n8).  5-l Proposition (Subject Reduction) IfEl-P: UandP--*QthenEl-Q: U. 5.2 Avoiding a Synchronization \nError Using Affine Qpes To illustrate the use of affine capability types, we describe a taxi protocol. \nThis protocol uses affine typing to achieve proper movement synchronization between two parties. The \ntaxi pub- lishes a capability for a passenger to enter a seat in the back of the taxi. The passenger \nenters and tells the taxi a route to follow. At the end of the trip the taxi door is unlocked, and the \npassenger may exit. The capabilities for entering and exiting the taxi, and for the route, are given \naffine types. If the capability to enter the taxi were to be accidentally or maliciously duplicated, \na synchronization error could arise, in which a passenger holding a valid capability would attempt to \nenter the taxi, but would be left behind because another passen-ger got the taxi first. This possibility \nis ruled out by affine typing. In the following, the parameter M is the route the taxi is to follow, \nand the parameter P is the behavior of the passenger at the destination. passenger M P % (enter:Cap [ShhJ). \nmove[enter. tulk[out move. (M) I tulk[(exit:Cup [Shh]). move[exit. PI]]] taxi &#38; (V tu.d:Amb[Shh], \ngo:Amb[Shh], lock:Amb[Shh], seut:Amb[Cup*[Shh]]) ((in tari. in lock. in seat) I taxi[open go I lock[ \nseut[open talk. (route:Cup [Shh]). (open talk. (out seat. out tuxi) I go[out seat. out lock. route. open \nlock])]]]) If we suppose there is some environment E with: E F talk : Amb[Cup [Shh]] E F M : Cup [Shh] \nEt- move : Amb[Shh] E!-P:Shh then: E I- (passenger M P I taxi) : Cup [Shh] (N.B.: the passenger-taxi \nsystem can also be given type Cup [Shh]. We can force the Cup [Shh] typing by situating the system within \nan ambient whose name has type Amb[Cup [Shh]].) Initially, the system reduces as follows, up to the point \nwhere the passenger has entered the taxi and the taxi is ready to follow the route M: passenger M P I \ntaxi --+* (V taxi:Amb[ShhJ, lock:Amb[Shh], seut:Amb[Cup [Shh]]) taxi[M. open lock I lock[move[out taxi. \nP] I seut[move[]]] ] Once the route M has been followed, the lock ambient is opened, and the passenger \nexits.  5.3 Dispensing Transferrable Tokens Using Afflne Qpes A second example demonstrates that affine \ntypes allow capabil- ities to serve as consumable, transferrable tokens for a resource. We consider a \nsystem consisting of several principals that are given access to a printer. Each principal has an API \n(inter- face) allowing it to print messages on the printer. Each time it ac- cesses the AH, a principal \nmust consume a token, the capability open upi. This capability is given the affine type Cup [Msg], where \nMsg is the type of messages printed by the printer. By dis- pensing different numbers of these tokens \nto different principals, we may selectively control the number of messages each princi- pal has a right \nto print. The top-level of our system, sys, serves as a printer spool; any outputs here may be thought \nof as being sent to a printer. We describe each principal as follows: principal n P k n[open n I printAPI \nn I toks[!open toks I P]]  The process parameter P models the specific behavior of the principal. We \nassume that the names upi and print are not free in P. The ambient named t&#38;s represents a channel \non which the principal receives capabilities for printing. A token open api pro-vides access to the printer \nAPI, which is defined by: printAPf n L! !api[(x:Msg). print[out n. (x)]] Our example system consists \nof two principals, named alice and bob: sys k (v alice:Amb[Msg], bob:Amb[Msg], api:Amb[Msg], print:Amb[Msg], \ntoks:Amb[Cap [Msg]]) (!open print I toks[in alice. in toks I (open api) I (open api)] I principal alice \n((x1:Cap [Msg]). (xz:Cap [Msg]). alice[out toks I x1. (M) I toks[out alice. in bob. in toks. (xz)]]) \nprincipal bob ((y:Cap [Msg]). bob[out toks. y. (N)])) In this example, we dispense two tokens to alice, \nvia the process tok.s[in alice. in toks I (open api) I (open api)]. but none to bob. Principal alice \ninputs the two tokens as variables xi and x2; she uses xi herself to print M, but donates the other to \nbob, who inputs it as y, and uses it to print N. The process sys has type Msg. We have: SYS -b* (M) 109 \n We may easily add more principals to this example, and we may dispense as many tokens as is appropriate \nto each new prin- cipal. By using affine types to regulate the use of printer tokens, principals are \nfree to transfer tokens amongst themselves, but the total number of messages printed is limited by the \nnumber of to- kens dispensed initially. Without linear or affine types, it would be harder to allow the \ntransfer of printer tokens between princi-pals while still controlling their total number. 6 Conclusions \nWe have presented a type system for the ambient calculus. The types arising from this work are unusual \nin that they do not cor- respond directly to channel or function types. The type system guarantees the \nsoundness of message exchanges, while leaving great flexibility in mobility. As an example, we have given \na nat- ural semantics for a typed agent language. Our type system is rather basic, roughly corresponding \nto the simply-typed discipline for the h-calculus. Much richer typ- ing disciplines can be imagined, \nalong the usual lines. Perhaps more interestingly, it is appealing to try and use static type sys- tems \nto restrict mobility; this is the subject of current work. Acknowledgments Georges Gonthier made useful \nremarks on an early draft, and discovered new x-calculus encodings that illustrate interesting techniques. \n7 Appendix: Subject Reduction Let E k J denote any judgment. 7-l Lemma If E , n: W, E k J then n $ dom(E \n, E ). 7-2 Lemma IfEl-n: WandEl-n: W ,then W=W . 7-3 Lemma (Implied Judgment) If E , E I-J then E k \n0. 7-4 Lemma (Exchange) If E , n: W , m: W , E I- J then E , m: W , n: W , E k J. 7-S Lemma (Weakening) \nIfE ,E l-Jandn$dom(E ,E )thenE ,n:W,E kJ. 7-6 Lemma (Strengthening) IfE ,n:W,E tJandn$fn(J)thenE ,E \ntJ. 7-7 Lemma (Substitution) IfE ,n:W,E tJandE tM: WthenE ,E kJ{ntM]. 7-8 Proposition (Subject Congruence) \n(I) IfEtP: VandPEQthenEtQ: V. (2) IfEtP:VandQ=PthenEl-Q: V.  Proof By mutual induction on the derivations \nof P = Q and Q = P. (l)IfEl-P: VandPrQthenEl-Q: V. (Struct Refl) Trivial. (Struct Symm) Then Q = P. By \ninduction hypothesis (2), we haveEtQ: V. (Struct Trans) Then P = R, R = Q for some R. By induction hy- \npothesis (1) E t R : V. Again by induction hypothesis (1) E I- Q : V. (Struct Res) Then P = (vn:W)P \nand Q = (vn:W)Q , with P = Q . Assume Et P : V. This must have been derived from (Proc Res), with E, \nn:Amb[7 l t P : V, where W=Amb[fl. By induction hypothesis, E, n:Amb[7 l I-Q : V. By (Proc Res) E l-(vn:Amb[fl)Q \n: V. (Struct Par) Then P = P I R, Q = Q I R, and P = Q . Assume Et P I R : V. This must have been derived \nfrom (Proc Par), with Et P : V and E I- R : V. By induction hypothesis Et Q : V. By (Proc Par) Et Q IR \n: V. (Struct Repl) Then P = !P , Q = !Q , and P = Q . Assume Et P : V. This must have been derived from \n(Proc Repl), with E k- P : V. By induction hypothesis, E t Q : V. By (Proc Repl) E k- !Q : V. (Struct \nAmb) Then P = M[P ], Q = M[Q ], and P = Q . As- sume E k P : II. This must have been derived from (Proc \nAmb), with E t- M : Amb[Tj and E I- P : T for some T. By induction hypothesis, E I- Q : T. By (Proc Amb) \nwe derive E I- M[Q ] : U. (Struct Action) Then P = M.P , Q = M.Q , and P = Q . Assume E II P : U. This \nmust have been derived from (Proc Action), with E I- M : Cup[ v] and E k P : U. By induction hypothesis, \nE k Q : U. By (Proc Action) E I- M[Q ] : U. (Struct Input) Then P = (nl: WI, . . . . nk:Wk).P , Q = (n,:W,, \n. . . . nk:Wk).Q , and P E Q . Assume E !- P : U. This must have been derived from (PrOC InpUt), with \nE, nl:W,, . . . . nk:Wk i- P : U, where U = W+c...xWk. By induction hypothesis, E, nl:W,, . . . . nk: \nW, t- Q : u. By (PrOC IllpUt) E F (nl: WI, . . . . nk: W&#38;Q : u. (Struct Par Comm) Then P = P I P \nand Q = P I P . Assume E I- P I P : U. This must have been derived from (Proc Par), withEl-P : UandEl-P \n: U.By(ProcPar)EkP IP : U. (Struct Par Assoc) Then P = (P I P ) I P and Q = P I (P I P ). Assume E k \n(P I P ) I P : U. This must have been de- rived from (Proc Par) twice, with Et-P : U, E k P : U, and \nE t-P : U.By(ProcPar)twice,Et-P I(P IP ): U. (Struct Rep1 Par) Then P = !P and Q = P I !P . Assume E \nl- !P : U. This must have been derived from (Proc Repl), with El- P : U. By (Proc Par), E I- P I !P : \nU. (Struct Res Res) Then P = (vn: W)(vm:V)P and Q = (vm:V)(vn: W)P with n f m. Assume E I- (vn: W)(vm:V)P \n: U. This must have been derived from (Proc Res) twice, with E, n:Amb[TJ, m:Amb[S] I-P : U, where W=Amb[Tj \nand V=Amb[S]. By Lemma 7-4 we have E, m:Amb[Sj, n:Amb[Tj I- P : I/. By (Proc Res) twice we have E I- \n(vm:Amb[Sj)(vn:Amb[Tj)P : U. (Struct Res Par) Then P = (vn:W)(P I P ) and Q = P I (vn:W)P , with n @ \nfn(P ). Assume E t- P : U. This must have been derived from (Proc Res), with E, n:Amb[Tj I- P I P : U \nand W=Amb[TJ, and from (Proc Par), with E, n:Amb[Tj I-P : U and E, n:Amb[Tj i- P : U. By Lemma 7-6, since \nn $fn(P ), we have Et-P : U. By (Proc Res) we have E I- (vn:Amb[Tj)P : II. By (Proc Par) we have E I- \nP I (vn:Amb[Tj)P : U. (Struct Res Amb) Then P= (vn:W)m[P ] and Q = m[(vn:W)P ], with n # m. Assume E \nI- P : U. This must have been derived from (Proc Res) with E,n:Amb[TJ k m[P ] : U with W = Amb[TJ, and \nfrom (Proc Amb) with E, n:Amb[fl t- P : S and E, n:Amb[Tj l- m : Amb[S] for some S. By (Proc Res) we \nhave E k (vn:Amb[TJ)P : S. By Lemma 7-6, since n # m, we have E t- m : Amb[Sl. By (Proc Amb) we can derive \nE k m[(vn:Amb[TJ)P ] : 0: (Struct Zero Par) Then P = P I 0 and Q = P . Assume E I- P : U. This must have \nbeen derived from (Proc Par) with E k P : U andEF0: U. (Struct Zero Res) Then P = (vn: W)O and Q = 0. \nAssume E t- P : U. This must have been derived from (Proc Res) with E, n:Amb[TJ k 0 : U and W = Amb[TJ. \nBy Lemma 7-6, E F 0 : U. (Struct Zero Repl) Then P = !Oand Q = 0. Assume Et-P : U. This must have been \nderived from (Proc Repl) with E I- 0 : U. (Struct E) Then P = &#38;.P and Q = P . Assume E k P : U. This \nmust have been derived from (Proc Action) with E I- P : U. (Struct .) Then P = (M.M ).P and Q = M.M .P \n. Assume E I- P : U. This must have been derived from (Proc Action) with E k M.M : Cup[Uj and E F P : \nU. The former must come from (Exp .) with E k M : Cap[LJj and E I- M : Cap[UJ By (Proc Action) twice \nwe have E k M.M .P : U. (Z)IfEl-P: UandQsPthenEFQ: U. (Struct Refl) Trivial. (Struct Symm) Then P E Q. \nBy induction hypothesis (I), we haveEtQ: U. (Struct Trans) Then Q = R, R 5 P for some R. By induction \nhy- pothesis (2) Et R : U and E I- Q : U. (Struct Res), (Struct Par), (Struct Repl), (Struct Amb), (Struct \nAction), (Struct Input), (Struct Par Assoc) Symmet- rical to case (1). (Struct Par Comm) Then Q = P I \nP and P = P I P . Assume E I- P I P : U. This must have been derived from (Proc Par), withEl-P : UandEtP \n: U.By(ProcPar)EtP IP : II. (Struct Rep1 Par) Then Q = !P and P = P I !P . Assume E k P I !P : II. This \nmust have been derived from (Proc Par), with Et !P : u. (Struct Res Res) Then Q = (vn: W)(vm:V)P and \nP = (vm:V)(vn: W)P' with n # m. Assume E t- (vm:V)(vn: W)P' : U. This must have been derived from (Proc \nRes) twice, with E, m:Amb[S], n:Amb[TJ I- P : U, where W=Amb[Tj and V=Amb[S]. By Lemma 7-4 we have E, \nn:Amb[Tj, m:Amb[SJ I- P : U. By (Proc Res) twice we have E I- (vn:Amb[TJ)(vm:Amb[Sj)P : U. (Struct Res \nPar) Then Q = (vn:W)(P I P ) and P = P (vn:W)P , with n $ fn(P ). Assume E t P : U. This must have been \nderived from (Proc Par), with Et P : U and E t (vn:W)P : U, and the latter from (Proc Res), with E, n:Amb[Tj \nI- P : U where W=Amb[Tj. By Lemma 7-5, since n 6 dom(E ), we have E, n:Amb[TJ I- P : U. By (Proc Par) \nwe have E, n:Amb[Tj F P I P : U. By (Proc Res) we have E k (vn:Amb[TJ)(P I P ) : U. (Struct Res Amb) \nThen Q = (vn: W)m[P ] and P = m[(vn:W)P ], with n # m. Assume Et P : U. This must have been derived from \n(Proc Amb) with E I- m : Amb[Sj and E I- (vn:W)P : S for some S. The latter must have been derived from \n(Proc Res) with E, n:Amb[q k P : S with W = Amb[Tj. By Lemma 7-5, since n 6 dam(E), we have E, n:Amb[Tj \nt- m : Am&#38;S]. By (Proc Amb) we can derive E, n:Amb[Tj I- m[P ] : U. By (Proc Res) we have E t (vn:Amb[q)m[P \n] : U. (Struct Zero Par) Then Q = P I 0 and P = P . Assume E t- P : U. By Lemma 7-3, E t 0. By (Proc \nZero) E I- 0 : U. By (Proc Par),Et-P IO: U. (Struct Zero Res) Then Q = (vn:Amb[TJ)O and P = 0. Assume \nE !- P : CJ.By Lemma 7-5, E, n:Amb[q k 0 : U. By (Proc Res) Et (vn:Amb[Tj)O : U. (Struct Zero Repl) \nThen Q = !O and P = 0. Assume Et P : II. By (Proc Repl) with E k !O : U. (Struct E) Then Q = &#38;.P \nand P = P . Assume E I- P : U. By Lem- ma 7-3, Et- 0. By (Exp E), E k E : Cap[UJ By (Proc Action) with \nEFE.P : U. (Struct .) Then Q = (M.M ).P and P = M.M .P . Assume E I- P : U. This must have been derived \nfrom (Proc Action) twice, with El-M:Cap[u,EkM :Cap[fl,andEl-P :U.By(Exp.)we have E I- M.M : Cap[UJ. By \n(Proc Action) we have E k (M.M ).P : II. 0 7-9 Proof of Proposition 3-l (Subject Reduction) IfEl-P: \nUandPjQthenEl-Q: U. Proof By induction on the derivation of P --+ Q. (Red In) Then P = n[in m. P I P \n] I m[P ] and Q = m[n[P I P ] I P ]. Assume E k P : CT.This must have been derived from (Proc Par), with \nE k n[in m. P I P ] : U and E I- m[P ] : U. Those two judgments must have been derived from (Proc Amb), \nwithEkn:Amb[TJ,EFinm.P IP :TforsomeT,andEk-m : Amb[.S j, Et- P : S for some S. Moreover, E I- in m. \nP I P : T must come from (Proc Par) with E I- in m. P : T and E I- P : T, and E k in m. P : T must come \nfrom (Proc Action) with E I- in m : Cap[Tj and E k P : T. Note that E F m : Amb[.SJ is consis- tent with \nE k in m : Cap[TJ, by (Exp In). By (Proc Par) we have E k P I P : T, and by (Proc Amb) we can derive \nE F n[P I P ] : S. Then, by (Proc Par) we have E I- n[P I P ] I P : S, and by (Proc Amb) we can derive \nE I- m[n[P I P ] I P ] : U. (Red Out) Then P = m[n[out m. P I P ] I P ] and Q = n[P I P ] I m[P ]. Assume \nE I- P : U. This must have been derived from (Proc Amb), with E I- m : Amb[TJ and E k n[out m. P I P \n] I P : T for some T. The latter must come from (Proc Par) with E I- P : T and E k n[out m. P I P ] \n: T. The latter must come from (Proc Amb) with E I- n : Amb[Sj and E k out m. P I P : S for some S. The \nlatter must come from (Proc Par) with E I- P : S and E I- out m. P : S. The latter must come from (Proc \nAction) with E t- out m : Cap[SJ and E k P : S. Note that E k m : Amb[TJ is consistent with E F out m \n: Cap[a, by (Exp Out). By (Proc Par) we have E k P I P : S, and by (Proc Amb) we can derive E I- n[P \nI P ] : U. Then, by (Proc Amb) we can derive E F m[P ] : II, and by (Proc Par) we have E k n[P I P ] \nI m[P ] : U. (Red Open) Then P = open n. P I n[P ] and Q = P I P . As-sume E I- P : U. This must have \nbeen derived from (Proc Par), with E I- open n. P : U and Et-n[P ] : U. The judgment E I- open n. P : \nU must have been derived from (Proc Action), with E k open n : Cap[Ul and E I- P : U, and from (Exp Open) \nwith E k n :Amb[ UJ. The judgment E I- n[P ] : U must have then been derived from (Proc Amb) with E t \nn : Amb[U ], and E t- P : U . By Lemma 7-2, U =U. By (Proc Par) we have E F P I P : U. (Red Comm) Then \nP = (nl:Wl, . . . . nk:W&#38;P I (Ml, . . . . Mk) and Q = P {nltMl, . . . . nk+Mk}. Assume E I- P : U. \nThis must have been derived from (Proc Par) with Et-(nl:W,, . . . . nk:W,).P : U and E k (Ml, . . . . \nMk) : U. The former must have been derived from (Proc Input) with E, nl:Wl, . . . . nk:Wk t- P : W,x...xWk, \nand U = W1x...xWk. The latter must have been derived from (Proc Output) with E t-Ml : W, . . . E !-Mk \n: W, , and U = WI x...xWk . Hence, W, = WI . . W, = W, . By k applications of Lemma 7-7, we have that \nE I- P (nltM1, . . . . n+Mk} : U. (Red Res) Then P = (vn:W)P , Q = (vn:W)Q , and P -+ Q . As-sume E F \nP : U. This must have been derived from (Proc Res) with E, n:Amb[Tj I- P : U, where W = Amb[Tj. By induction \nhy-pothesis E, n:Amb[Tl I-Q : U. By (Proc Res), E k (vn:Amb[Tj)Q : U. (Red Amb) Then P = n[P ], Q = n[Q \n], and P + Q . Assume E I- P : II. This must have been derived from (Proc Amb) with E t- n : Amb[TJ and \nE I- P : T for some T. By induction hypothesis, E I- Q : T. Then, by (Proc Amb) we can derive E I- n[Q \n] : U. (RedPar)ThenP=P IR,Q=Q IR,andP --,Q .AssumeE k P : U. This must have been derived from (Proc Par) \nwith E I- P : U and Et-R : U. By induction hypothesis, E I- Q : U. By (ProcPar)E!-Q IR: U. (Redr)ThenP=P \n,Q-Q ,andP --,Q .AssumeEkP: U. By Proposition 7-8, E k P : U. By induction hypothesis, E I- Q : (1. By \nProposition 7-8, E I- Q : U. 0 8 Appendix: Subject Reduction for Affine Types 8-l Lemma p+p = p +p 8-2 \nLemma (p+p )+p = p+(p +j.l ) 8-3 Lemma !p = /.I + !/.I 8-4 Lemma If P i Q then n occurs P = n occurs \nQ. Proof By induction on the derivation of P = Q. (Struct Refl) Trivial. (Struct Symm) Then Q = P. By \ninduction hypothesis, we have n occurs Q = n occurs P. (Struct Trans) Then P = R, R = Q for some R. By \ninduction hy- pothesis, n occurs P = n occurs R. Again by induction hypothe- sis, n occurs R = n occurs \nQ. Hence, n occurs P = n occurs Q. (Struct Res) Then P = (vm:W)P and Q = (vm:W)Q , with P E Q . Since \nm is bound, we may assume that m # n. By induction hypothesis, n occurs P = n occurs Q . Therefore, n \noccurs P = n occurs P = n occurs Q = n occurs Q. (StructPar)ThenP=P IR,Q=Q IR,andP =Q .Byinduc- tion \nhypothesis, n occurs P = n occurs Q . Therefore, n occurs P = (n occurs P ) + (n occurs R) = (n occurs \nQ ) + (n occurs R) = n occurs Q.  (Struct Repl) Then P = !P , Q = !Q , and P = Q . By induction hypothesis, \nn occurs P = n occurs Q . Therefore, n occurs P = !(n occurs P ) = !(n occurs Q ) = n occurs Q. (Struct \nAmb) Then P = M[P ], Q = M[Q ], and P = Q . By in- duction hypothesis, n occurs P = n occurs Q . Therefore, \nn oc- curs P = (n occurs M) + (n occurs P ) = (n occurs M) + (n occurs Q ) = n occurs Q. (Struct Action) \nThen P = M.P , Q = M.Q , and P = Q . By in- duction hypothesis, n occurs P = n occurs Q . Therefore, \nn oc- curs P = (n occurs M) + (n occurs P ) = (n occurs M) + (n occurs Q ) = n occurs Q. (Struct Input) \nThen P = (nl:WI, . . . . nk:Wk).P , Q = (nl: WI, . . . . nk: Wk).Q , and P = Q . Since the names nl, \n. . . . nk are bound, we may assume that n $ {nl, . . . . nk). By induction hypothesis, n oc- curs P \n= n occurs Q . Therefore, n occurs P = n occurs P = n occurs Q = n occurs Q. (Struct Par Comm) Then P \n= P I P and Q = P I P . By Lem- ma 8-1, we have: n occurs P = (n occurs P ) + (n occurs P ) = (n occurs \nP )+(n occurs P ) = n occurs Q. (Struct Par Assoc) Then P = (P I P ) I P and Q = P I (P I P ). By Lemma \n8-2, we have: n occurs P = ((n occurs P ) + (n occurs P )) + (n occurs P ) = (n occurs P )+((n occurs \nP )+(n occurs P' )) = n occurs Q. (Struct Rep1 Par) Then P = !P and Q = P I !P . By Lemma 8-3, we have: \nn occurs P = !(n occurs P ) = (n occurs P ) + !(n oc- curs P ) = n occurs Q. (Struct Res Res) Then P \n= (vm:W)(vm :V)P and Q = (vm :V) (vm:W)P with m # m . Since the names m and m are bound, we may assume \nthat n # m and n # m . Therefore, n occurs P = n oc- curs P = n occurs Q. (Struct Res Par) Then P = (vm:W)(P \nI P ) and Q = P I (vm: W)P , with m $ fn(P ). Since the name m is bound, we may assume that n # m. Therefore, \nn occurs P = (n occurs P ) + (n oc- curs P ) = n occurs Q. (Struct Res Amb) Then P = (vm:W)m [P ] and \nQ = m [(vm: W)P ], with m z m . Since the name m is bound, we may assume that n # m. Therefore, n occurs \nP = (n occurs m )+(n oc-curs P ) = n occurs Q. (Struct Zero Par) Then P = P I 0 and Q = P . We have: \nn oc- curs P = (n occurs P ) + 0 = n occurs P = n occurs Q. (Struct Zero Res) Then P = (vm: W)O and Q \n= 0. We have, n oc- curs P = n occurs Q. (Struct Zero Repl) Then P = !Oand Q = 0. We have n occurs P \n= 0 = n occurs Q. (Struct E) Then P = E.P and Q = P . We have n occurs P = n oc- curs P = n occurs Q. \n(Struct .) Then P = (M.M ).P and Q = M.M .P . By Lemma 8-2, we have n occurs P = ((n occurs M) + (n occurs \nM )) + n oc- curs P = n occurs M + (n occurs M + n occurs P ) = n occurs Q. 0 8-5 Lemma If n P. fn(M) \nthen n occurs M = 0. Proof By induction on the structure of M. cl 8-6 Lemma If n $ (m) u fn(M) then: \n(1) n occurs N( mtM) = n occurs N. (2) n occurs P( mtM) = n occurs P.  Proof By inductions on the structure \nof N and P. 0 The extended type system is as follows: the judgments are as in Section 3.3, and the rules \nare as in Section 3.3, except for the modifications described in Section 5. We now prove subject reduction \nfor the extended system. 8-7 Lemma If E t- M : Tthen fn(M) c dam(E). 8-8 Lemma If E , n:W, E F J then \nn $ dom(E ,E ). 8-9 Lemma IfEFn: WandEl-n: W ,then W= W . 8-10 Lemma (Implied Judgment) IfE ,E kJthenE \n!-0. 8-11 Lemma (Exchange) If E , n: W , m: W , E !- I then E , m: W , n: W , E F J. 8-12 Lemma (Weakening) \nIf E , E I-J and n 6 dom(E ,E ) then E , n:W, E F J. 8-13 Lemma (Strengthening) If E , n: W, E I- J and \nn $ fn(J) then E , E I- J. 8-14 Lemma (Substitution) IfE ,n:W,E FJandE l-M: WthenE ,E FJ{ntM). Proof \nBy induction on the derivation of E , n: W, E F J. (Proc Input) We have E , n: W, E /- (nl: WI, . . . \n. nk:Wk).P : Tde-rived from E , n:W, E , nl:W,, . . . . nk:Wk k P : T and T = W1x...xWk. Moreover, for \nall i E l..k, if W; = Cup [T;] then ni oc- curs P < 1. By induction hypothesis, E , E , nl: W1, . . . \n. nk:Wk t- P{ ntM) : T. By Lemma 8-7, fn(M) z dom(E ). Hence, by Lem- ma 8-8, ((n) u fn(M)) f-7 {n,, \n. . . . nk) = @. By Lemma 8-6, ni OC-curs P( ntM)) = n, occurs P, for all i E 1..k. By (Proc Input), \nE , E t- (nl:Wl, . . . . nk:Wk).(P(ntM)) : T. Since ((n) Ufi(M)) f7 Inl, . . . . nk) = p.4,this is to \nsay that E , E b- ((nl:WI, . . . . nk: W,).P) (nthf)) : T. Other cases. The other cases are almost exactly \nas before. 0 8-15 Proposition (Subject Congruence) (1) IfEl-P: UandP-QthenEt-Q: I/. (2) IfEl-P:UandQ-PthenEkQ:U. \n  Proof By mutual inductions on derivations. (Struct Input) Then P = (nl: WI, . . . . nk: W,).P , P \n= Q , and Q = (n,:W), . . . . nk:W,).Q . For part (l), assume E b P : U. This must have been derived \nfrom (Proc Input), with E, nl:W,, . . . . nk:Wk t-P : U, where U = W~x...xWk. Moreover, for all i E l..k, \nif W, = Cup [T;] then n; oc- curs P I 1. By induction hypothesis, E, nl:W1, . . . . nk:Wk b- Q : U. By \nLemma 8-4, P = Q implies that n, occurs P = n; occurs Q for each i E l..k. Therefore, for all i E l..k, \nif Wi =Cap [T,] then n; occurs Q 5 1. By (Proc Input), E k (nl: WI, . . . . nk:Wk).Q : u. Part (2) follows \nby symmetric considerations. Other cases. The other cases are almost exactly as before. 0 8-16 Proof \nof Proposition 5-l (Subject Reduction) IfEI-P: UandP-+QthenEkQ: U. Proof By induction on the derivation \nof E F P : U. (Red Comm) Then P = (n,: W1, . . . . nk:Wk).P 1 (Ml, . . . . bfk) and Q = P {n,tM1, . . \n. . nktMk]. Assume E k P : II. This must have been derived from (Proc Par) with E l- (n,: WI, . . . . \nnk:Wk).P : U and Et-(MI, . . . . Mk): U. ThejudgmentEt-(nl:W1, . . . . nk:Wk).P : U must have been derived \nfrom (Proc Input) with E, nl:W1, . . . . nk:Wk k P : u, u = wlx...xwk for SOme I/ = W&#38;..xWk, and \nfor all i E I..k, if Wi = Cap [Ti] then n, occurs P I 1. The judgment Et-(Ml, . . . . Mk) : U must have \nbeen derived from (Proc Output) with Et M; : Wi for each i E I..k, for some W1 . . . wk , and U = W1 \nx...xWk . Hence, W; = Wi for each i E l..k. By k applications of Lemma 8- 14, we get E I- Q : U. Other \ncases. The other cases are almost exactly as before. cl References HI Amadio, R. An asynchronous model \nof locality, failure, and process mobility. In COORDINATIONP7, LNCS 1282, Springer. 1997. 121 Boudol, \nG., Asynchrony and the n-calculus. Technical Re- port 1702, INRIA, Sophia-Antipolis, 1992. [31 Cardelli, \nL., Abstractions for Mobile Computation. 1998. To appear. (See www.luca.demon.co.uk.) [41 Cardelli, L. \nand A.D. Gordon, Mobile Ambients. In Founda- tions of Sofmare Science and Computational Structures, Maurice \nNivat (Ed.), LNCS 1378, 140-155, Springer. 1998. 151 De Nicola, R., G. Ferrari, M. Pugliese, Coordinating \nMobile Agents via Blackboards and Access Rights. COORDINA-TION 97, LNCS 1282, 220-237, Springer. 1997. \nif51 Honda., K. and M. Tokoro, An object calculus for asynchro- nous communication. Proc. ECOOP 91, LNCS \n521, 133-147, Springer Verlag, 1991. 171 Kobayashi, N., B.C. Pierce, and D.N. Turner, Linearity and the \nPi-Calculus. Proc ACM POPL 96, 358-371. 1996. PI Milner, R., J. Parrow and D. Walker, A calculus of mobile \nprocesses, Parts 1-2. Information and Computation, 100(l), l-77. 1992. PI Odersky, M., Polarized Name \nPassing. Proc FST&#38;TCS, Springer. 1995. [lOI Pierce, B., and D. Sangiorgi, Typing and Subtyping for \nMo- bile Processes. Mathematical Structures in Computer Sci-ence, 6(5), 409-454. 1996. 1111 Riely, J. \nand M. Hennessy, A typed language for distributed mobile processes. In Proc ACM POPL 98, 378-390. 1998. \n[I21 Sewell, P., Global/Local Subtyping and Capability Infer-ence for a Distributed Ir-calculus. In Proc \nICALP 98, Springer. 1998. [I31 White, J.E., Mobile agents. In Software Agents, J. Bradshaw, ed. AAAI \nPress/The MIT Press. 1996.   \n\t\t\t", "proc_id": "292540", "abstract": "", "authors": [{"name": "Luca Cardelli", "author_profile_id": "81100123805", "affiliation": "Microsoft Research", "person_id": "PP39028545", "email_address": "", "orcid_id": ""}, {"name": "Andrew D. Gordon", "author_profile_id": "81100037731", "affiliation": "Microsoft Research", "person_id": "PP15020291", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/292540.292550", "year": "1999", "article_id": "292550", "conference": "POPL", "title": "Types for mobile ambients", "url": "http://dl.acm.org/citation.cfm?id=292550"}