{"article_publication_date": "01-01-1999", "fulltext": "\n Relevant Context Inference* Ramkrishna Chatterjee t Barbara G. Ryder t William A. Landi tDepartment \nof Computer Science $Siemens Corporate Research, Inc. Rutgers, The State University of NJ 755 College \nRoad East 110 Frelinghuysen Road Princeton NJ 08540, USA Piscataway NJ 08854-8019, USA +l 609 734 6500 \n+l 732 445 2001 laudi@scr.siemens.com {ramkrish,ryder}@cs.rutgers.edu wstract Relevant context inference \n(RCI) is a modular technique for flow-and context-sensitive data-flow analysis of statically typed object-oriented \nprogramming languages such as C++ and Java. RCI can be used to analyze complete programs as well as incomplete \nprograms such as libraries; this ap- proach does not require that the entire program be memory- resident \nduring the analysis. RCIis presented in the context of points-to analysis for a realistic subset of Cts. \nThe em-pirical evidence obtained from a prototype implementation argues the effectiveness of RCI. Introduction \nPoints-to analysis [EGH94] for statically typed object-oriented programming languages (e.g., Java, C++) \ndeter-mines, at each program point, the objects to which a pointer may point during execution. This information \nis crucial to many applications, including static resolution of dynami-cally dispatched calls, side-effect \nanalysis, data-flow-based testing, program slicing and aggressive compiler optimiza-tions. The solution \nof concrete type inference [PC94], neces-sary for object-oriented optimizations such as method spe-cialization \nand inlining, is subsumed by the solution of points-to analysis, because the concrete type of a pointer \nis the set of classes corresponding to the objects possibly pointed to by that pointer. The goal of our \nanalysis is to preserve precision as much as possible, without sacrificing scalability. Flow and context \nsensitivity affect both the precision and cost of analyses. A flow-insensitivealgorithm ignores the ordering \nof statements within a method; by contrast, a fIov+sensitive algorithm fol- lows the control flow order \nof statements within a method, and computes different solutions for a variable at distinct program points. \nA context-sensitive algorithm considers (sometimes approximately) only interprocedurally realizable paths \n[SP81, LR91, EGH94, RHS95]: paths along which *The research reported here was supported, in part, by \nNSF grant CCR-9501761, the Hewlett-Packard Corporation and Edison Design Group. f mnission to make digital \nor hard copies of all or part of this work for I. ersolJal Or &#38;lSSrooll~ LlSe iS @mted without fee \nprovided that copies are not mxk or distributed fbr prolit or colnnlcrcisl advantage alld [bat copies \nbear this notice and the full citation on rhc first page. f,, copY otherwise. to reptkGh, to post on \nsewers or to redistribute to fists, requires prior specific permission an&#38;or a fee. POPL 99 San Antonio \nTexas IJSA Copyright ACM 1999 I-581 13-095-3/99/01...$5.00 calls and returns are properly matched, while \na conterct-insensitive algorithm does not make this distinction. Existing algorithms for points-to analysis \nvary in their flow and context sensitivity; they compute approximate so-lutions which are supersets of \nthe precise points-to solu-tion. The least expensive, but most imprecise, are the flow- and context-insensitive \napproaches [Wei80, And94, Ste96, ZRL96, SH97]. In contrast, the flow- and context-sensitive techniques \n[LR92, CBC93, MLR+ 93, EGH94, Deu94, CHS95, WL95, Ruf95, PR96] are the most precise but also the most \nexpensive (in time and memory). Although most of these have been used for alias or points-to analysis \nof C, they can be adapted for points-to analysis of C++without exceptions. The precision of the solution \ncomputed for points-to analysis directly affects its utility in applications. How-ever, flow- and context-sensitive \npoints-to analysis of Ct+ is difficult, due to dynamic dispatch, objects containing pointers to subobjects \n(i.e., recursive types), and the many invocation contexts per method. In addition, flow-and context-sensitive \nalgorithms are memory intensive; they fre- quently run out of memory while analyzing even moderately \nsized programs. These difficulties were addressed in the de- sign (and implementation) of RCI, a modular \ntechnique ex-plained here as applied to points-to analysis for a subset of Ctt. By the term modular, \nwe mean a technique for whole program analysis which never requires the entire pro- gram source to be \nin memory at any one time. Since much object-oriented code is written as libraries, a goal of RCI is \nto analyze incomplete programs. An additional goal for RCI is that it maintain a sufficient degree of \nprecision in its data-flow information for intended applications. Intuitively, we analyze each method \nassuming unknown initial values for parameters and globals at method entry. The key insight is to obtain \na summary function for the data-flow effect of method execution by bottom-up infer-ence of the relevant \nconditions on the unknown initial val-ues. These conditions capture only the relevant contexts for a \nmethod, making this approach feasible, although the summary function can be used in any context. Previous \ntechniques [LR92, Ema93, Ghi96, WL95], have incorporated memoization of the data-flow solution associated \nwith a par- ticular calling context (or set of contexts). In our approach, method bodies are analyzed \nfirst sep- arately from calling context information. The effects of a method on points-to analysis information \nis calculated, sometimes dependent on certain conditions on the incoming unknown initial values for parameters \nand globals. Rather than calculate all possible conditions, the algorithm calcu-lates only those conditions \nwhich may affect points-to infor- mation, by inferring them from the code of the method and those other \nmethods it may invoke directly or indirectly dur-ing its lifetime.l Care is taken to observe those object \nfields actually used by this method directly or indirectly through calls; conditions are inferred for \nonly those fields which are usedin this sense. The results of these calculations are two-fold: (i) a \npoints-to solution at each node of the method and (ii) a summary transfer function for the method, a \nfunction expressing method invocation effects on the points-to solu-tion; both are parametrized by the \nunknown initial values and the conditions on these values. Summary functions for callees are calculated \nbefore those of their callers. Then, points-to information is propagated into a method from its callers, \nwith actual-parameter bindings accounted for. Re-cursion requires simultaneous handling of calls in the \nsame strongly connected component (SCC) of the program call graph. Finally, the required points-to solution \nat a state-ment is computed on demand by instantiating the unknown initial values using the points-to \ninformation at a method entry. This entire calculation is carefully staged, so that the entire program \nsource need not be in memory at any one time, because the calculation can be done separately on the SCC \ns of the program call graph. Our algorithm is the first modular, flow-and context-sensitive algorithm \nfor points-to analysis of programs writ-ten in a realistic subset of C +. Moreover, although in this \npaper we explain RCI in the context of points-to analysis of C++ programs, the technique can be extended \nto han-dle libraries, Java programs with exceptions (but without threads), and to solve other data-flow \nanalysis problems. The main results in this paper are: . An algorithm for modular points-to analysis \nof pro-grams written in a realistic subset of Ctt. . Empirical evidence for the effectiveness of RCI \nas ap-plied to points-to analysis of C++. Further details on this research are given in [CRLgSb], in-cluding \nextensions to handle Java with exceptions and to analyze libraries with applications to testing. Definitions \n This section presents many technical definitions needed to explain the algorithm and also delimits the \nsubset of Css which is handled. C++ Subset. Given the limited space available, we de-fine a significantly \nrestricted subset of C++. In this paper, we describe our algorithm and provide analysis (e.g., com-plexity \nresults) on this simple subset. This allows us to simplify the presentation while demonstrating the interest-ing \nparts of our algorithm. The subset is defined in Figure 12. It includes single inheritance, dynamic dispatch, \nrecur-sive types and pointer assignment statements with a single This approach is analogous to the way \npointer aliases are cal-culated in [LRSZ]. The possible reaching aliases (RA s) used in the a&#38;sing \nalgorithm are those which actually are propagated to pro-cedure entry, rather than all those aliases \nwhich possibly might be propagated to the entry. Likewise, RCI solves for conditions that po-tentially \naffect the data-flow solution, rather than for all conditions. Ezpcpr is any side-effect-free expression \nthat does not have any function call and that can be ignored for points-to analysis. (pattern] means \nat most one occurrence of the pattern. {pattern}+ means one or more occurrences of the pattern. {pattern}* \nmeans zero or more occurrences of the pattern. {a 1 b} means a or b. The terminal symbols are underlined. \nProgram3 (Class I Procjf Class j class ClassBame [I public ClassBamel { {DataHemberI H&#38;hod}+ } DaiaHember \nj Protection [static] Type FieldBame i Type j ClassBame L 1 PrimitiveType PrimitiveType 3 int I char \nI float I boo1 Method j Protection [static 1 virtualI [void I Type1 HethodBame i [Param RestParam l 1 \n{ Body } Param a Type VarBame RestParam j , Param Proc 3 {v&#38;-l Type} ProcBame I [Param RestParam*l \n1 { Body } Body 3 Decls Stmnt+ Decls 3 Decl* Decl 3 Type VarBame ; Stmnt 3 AssignmentSt&#38;t I BerrStmnt \nI Call I If I While1 ReturnStmnt 1 i ReturnStmnt j return VarBame i AssignmentStmnt 3 Lhs : Rhs i Lhs \nj VarBame I VarBameFieldBame Rhs j VarHame I VarBame~FieldBame I 0 I Expr Call 3 CVarBame : 1 {VarBame~HethodBameIHethodBame \nlClassBame::HethodBameIProcBame} i [VarBame RestVar*I 1 ; BeuStmnt 3 VarBame f &#38;v-classBame < CVsrBame \nRestVar l 1 -i RestVar 3 L VarBame If j g ( Expr j_ {Stmnt+ } [else { stmnt+ } 1 While j while ( EGpr \n2 1 &#38;nnt+ i-varname * Bame FieldBame j Bame ProcBame j Bame HethodBame =$ Bame ClassHame * Bame Protection \ns public i I protected i I private 2 Figure 1: Simpler subset of Cts level of dereferencing.3 It excludes \nmultiple inheritance, an explicit address operator (i.e ., pointers to the stack), ref-erence type, function \npointers, data members of structure types (note this does not exclude data members of pointers to structure \ntypes), general pointer assignment statements, arrays (array elements are mapped to a single representative \nelement) and exceptions. Many of these constructs can be easily accommodated by extending the algorithm; \nwe will briefly indicate these extensions where relevant. If the algorithm is understood fully for the \nsimple subset, then handling of most of C++ requires handling of details but not any changes to the fundamental \nideas of the al-gorithm. The subset of Cts that can easily be handled by the modular points-to analysis \nalgorithm excludes arbitrary casting, uninstantiated templates, pointers to data members and pointers \nto member methods (which are different from ordinary function pointers). Up-cast of a derived class to \na base class and down-cast of a base class to a derived class can be handled. Our implementation of the \nalgorithm is consistent with this bigger subset, only excluding in addi-tion, multiple inheritance and \nexceptions. Precision and Safety. At each program point, points-to analysis calculates the set of objects \nto which a pointer may point during some execution. Any static analysis technique for points-to analysis \nneeds to represent a potentially infi-nite number of heap-allocated, run-time objects with a fi-nite \nnumber of names. Following [LR92, CBC93, MLRt93, WL95, Ste96], we represent all the run-time objects \ncreated lhs = rhs, where lhs is p or p*fl and rhs is q or q*f2. at a program point n with the single \nname object,,, a heap-name. A pair (ptr,object, )belongs to the precisesolution of points-to analysis \nat a program point m if and only if there exists an execution path from the start node of the program \nto m, such that when this path is executed, at m the pointer ptr points to an object created at program \npoint n. A safe solution of points-to analysis is one that is a superset of the precise solution. Our \nmodular points-to analysis algorithm calculates a safe solution. Data Representations. RCI stores the \ndata-flow facts together with corresponding alias and type context con-ditions (inferred by the analysis) \nin data-flow elements or dfelms. The initial phase of the algorithm examines each method, presuming unknown \ninitial values for each of its parameters and any global variables. Depending on the pointer assignments \nin that method, these unknown initial values may appear as variable names in the points-to re-lations \nand/or in corresponding conditions associated with such relations. We use aarinit to represent the unknown \ninitial value for the global or parameter var. Note that va+init de-notes the unknown initial object \nto which var points and not the address of that object. vaT;,it.neztin;t rep-resents the unknown initial \nvalue to which var+next points. var;,;t .neZt;,;t.ne&#38;nit represents the unknown ini-tial value to \nwhich var+next+nezt points. Obviously, in the presence of recursive types, the number of unknown ini-tial \nvalues accessed in a method could be unbounded. To overcome this problem, unknown initial values are \nmapped into a finite number of sets. All the elements in a set are represented by a single, representative \nname. RCI uses pat-terns in the access paths [Deu94] of unknown initial values to form these sets[CRL9&#38;3b]. \nFor points-to analysis, each dfelm propagated by RCI has the form: (relevant context, points-to), where \npoints-to represents a pair of the form: (var, object). vur is a local pointer variable, a global pointer \nvariable, an unknown initial value s field of pointer type or a heap-name s field of pointer type; and \nobject is an unknown initial value or heap-name. object can also be null, which is treated as a special \nheap-name. A relevant context has the form: (alias context, type context ). An alias context is empty \nor it is a conjunction of potential aliases and potential non-aliases between unknown initial values. \nEach potential alias has the form: (uiv~ eq IL&#38;) and each potential non-alias has the form: (uivl \nneq uivz). Here uivl and uivu~ are unknown initial values. These po-tential aliases and potential non-aliases \nare inferred by the algorithm during analysis; some data-flow facts are depen-dent on specific conditions \nof this sort. A type context is a conjunction of type constraints or empty. Each type constraint has \nthe form: (uv.A::x), where u2r is an unknown initial value, A is a class and x is a dynamically dispatched \nmethod defined in A (a virtual method in Ctt). A ::x represents the set of classes contain-ing A and \nall the subtypes of A for which a virtual invocation of method x will be resolved to the definition of \nmethod x in class A, A::x. The constraint means that the associated dfelm is valid only in those contexts \nin which the concrete, run-time type of uv (not the declared type) belongs to A::x. As with reaching \naliases in our earlier work on flow-sensitive aliasing[LRI)%], the relevant context of a dfelm pro-vides \na good approximation for a calling context. This al-lows data-flow information to be propagated along \ngood ap-proximations of realizable paths.  3 Modular Points-to Analysis In this section, we explain \nRCI as applied to points-to anal-ysis. 3.1 Four Phases of RCI RCI is an iterative worklist algorithm \nthat is flow-and context-sensitive. RCI takes as input a statement-level in-terprocedural control flow \ngraph or ICFG [LR92]. From this, an initial approximate call graph is formed and decom-posed into SCC \ns. The following phases are performed using the SCC condensation (SCC-DAG). Phase 0: In this phase, RCI \nconstructs a safe overes-timate of the call graph called the initial call graph by resolving dynamically \ndispatched calls using hierar-chy analysis [DMM96].4 Then RCI uses a linear-time algorithm[CLR92] to \nconstruct the SCC-DAG of the initial call graph. Note that the initial call graph need not be precise, \nit only needs to be a safe overestimate; the precision of any safe initial call graph only affects the \nefficiency of RCI, and not the safety of the com-puted solution. The initial call graph can be made more \nprecise (e.g., by using [BSSS]); however, in prac- tice we have found hierarchy analysis to be adequate. \nPhase I: RCI traverses the SCC-DAG in a re-verse topological order (bottom-up) and analyzes each method \nassuming parameters and global variables have unknown initial values. For each method RCI com-putes, \nin terms of unknown initial values, a safe ap-proximation to the method s complete transfer func-tion \nfor pointers. We will call this approximation, the summary transfer function. The summary transfer function \nof a method Mis the set of dfelms that reach the exit node of M and that do not represent values of local \nvariables of 1M. This function summarizes the possible effects of method invocation on dfelms. The summary \ntransfer functions of methods in the same SCC have cyclic dependences, so they are computed simultaneously \nby fixed point iteration. In contrast, the summary transfer functions of methods in differ-ent SCC s \nhave hierarchical dependences (or no depen-dence at all), and hence are computed by bottom-up traversal \non SCC-DAG, without iteration. After Phase I, the summary transfer function of each method and the points-to \nsolution at each node in the method are expressed in terms of the dfelms, defined in Section 2, which \nmay contain unknown initial values. 41n the initial call graph, function pointer call targets can be \nap-proximated by those functions whose addresses have been stored and whose signatures match with the \ntype of the called function. s Phase II: RCI traverses the SCC-DAG in a topolog-ical order (top-down) \nand propagates concrete values of unknown initial values to the entry nodes of meth-ods. This phase involves \nonly the entry nodes and call nodes, and as our empirical results show, it is ex-tremely fast. RCI considers \nonly reachable methods during this phase. s Phase III: This phase involves only nodes that are not entry \nnodes. In this phase, the unknown initial values in the #elms computed during Phase I are instantiated \nby their concrete values computed in Phase II. This phase is completely demand-driven, and needs to be \nperformed only at those nodes where the final solution is needed. After this phase, the points-to solution \nat each node is expressed entirely in terms of program variables and heap-names. During the construction \nof the initial call graph using hierarchy analysis, each method needs to be in memory once. After this, \neach node of SCC-DAG (and hence each method) needs to be in memory only three more times, once during \neach of the phases I, II and III. The rest of the time, only a method s summary transfer function or \nthe Phase II solution at the entry node of a method needs to be in memory. Hence, this is a modular approach \nand requires less memory than other whole-program-analysis techniques, in which a method cannot be moved \nout of memory without the possibility of it being needed again, until the final solution is computed. \nIn these techniques, if the whole program is not kept in memory, there is no a priori constant bound \non the number of times a method needs to be moved into or out of memory. Of course, in the worst case, \nthe entire initial call graph may be a single SCC and RCI may need to keep the whole program in memory. \nHowever, our empirical results show that SCC s are quite small in practice and RCI is able to analyze \nalmost a method at a time. In some very specific domains (e.g., recursive descent parsing), SCC s may \nbe oc-casionally large, however, even in these cases the entire ini-tial call graph is unlikely to be \na single SCC. For example, in parsing, the SCC s of methods dealing with statements are likely to be \ndifferent from the SCC s of methods dealing with types. 3.2 Phase I In Phase I, RCI analyzes each method \nusing the unknown initial values of parameters and global variables. By an-alyzing a method, it infers \nthe relevant potential aliasing between unknown initial values and their relevant potential concrete \n(not declared) types. RCI computes a dfelm condi-tioned on such potential aliases (i.e., dfelm s alias \ncontext) and concrete types (i.e., dfelm s type context). Propagation in this phase occurs in reverse \ntopological order on the SCC-DAG; the objective is to calculate the points-to solution at each node in \nterms of unknown initial values and to calculate a summary transfer function for each method in the program, \nso it can be used to compute the summary transfer function of the callers of the method. In- tuitively, \na dfelm d at the exit node of a method M is valid at a call site that invokes Mif and only if all the \nconjuncts of the relevant context of d are true at the call site. In gen- eral, at a call site that invokes \nM, one of the following three things happens for a conjunct of the relevant context of d: the conjunct \nevaluates to true, it evaluates to false, or it is translated into a similar conjunct involving the unknown \ninitial values of the caller. For propagation of dfelms between methods in different SCC s, no iteration \nis necessary. Using actual-parameter bindings, the summary transfer function of the called method can \nbe used to calculate the dfelms returned from the call. However, to obtain the proper propagation of \ndfelms through a non-trivial SCC, it is necessary to propagate dfe2ms on the graph of the SCC itself. \nSince there are cyclic dependences, iteration must be performed until a fixed point is reached. During \nthis iteration, only a partial sum-mary transfer function may be available at a method s exit node; this \nis used when processing same-SCC callers of this method. Whenever a new dfelm is added to the partial \nsum-mary transfer function of a method, the same-SCC callers of this method are informed about this dfelm, \nso that corre-sponding call sites can process this new dfelm. The calculation of the points-to solution \nin terms of un-known initial values and the calculation of the summary transfer function of a method \nare accomplished by the prop- agation of dfelms from method entry to exit using a worklist algorithm. \nInitially the solution at each node is empty; it grows monotonically as new dfelms are added. The code \nof the method is represented in the ICFG. Points-to infor-mation which reaches an ICFG node serves as \ninput to its node transfer function which embodies the data-flow effect of the semantics of code corresponding \nto that node. We will specify the statement transfer functions for points-to analy-sis at pointer assignments \nand call statements. In the next section, we present examples showing these transfer func-tions and how \nrelevant contexts are manipulated; we give pseudocode for Phase I in Appendix A. 3.2.1 Examples of dfelm \nPropagation Figure 2 shows the final Phase I solution computed by RCI at the top of each of the statements \n1, 2, 3 and 4 (i.e., program points 1,2,3,4). The dfelms at program point 1 say that all the variables \nhave the same values as at the entry node of methodl. Since statement 1 assigns the value of a3 to the \nnezt field of the value of al, 2:1, the first dferm at program point 2, says that the next field of the \nunknown initial value of al points to the unknown initial value of a.?. The relevant context (empty, \nempty) means that both alias context and type context are empty, and therefore this dfelm is valid in \nall contexts. At an assignment statement, for each set s of dfelms that gives the values of the left \nand right hand sides, the relevant context of the corresponding dfelm (implied by s) resulting from the \nassignment is the conjunction of the relevant con- texts of the dfelms of s. For statement 1, there is \nonly one such s which consists of 1:1 and 1:3, and the conjunction of the relevant contexts of the dfelms \nof s is (empty, empty). If the unknown initial values of al and a2 are the same, state- ment 1 also modifies \nthe nezt field of the unknown initial value of a2. The dfelms 2:2 and 2:3 keep track of this po- tential \nmodification. 2:2 is applicable to only those contexts in which alin;* and u2init are equal, while 2:3 \nis applicable to only those contexts in which olinit and u2init are not equal. The dfelms 3:l and 3:2 \nare implied respectively by 2~2 and 2~3. RCI does not consider as;,;t.nezt for potential modifi- cation \nat statement 1 because it is not used in methodl. RCI generates fields of unknown initial values lazily \n(as ex- plained in Section 3.2.3), only inferring relevant potential aliases and potential non-aliases. \nFor example, the rela- tionships of o3init with olinit and o2init are not relevant class A { 1:1 ((empty, \nempty), (al, alinit)) public: A* next; public: A0 { next = 0; }; 1:2 (( emPtY3 empty), (as, azinit)) \npublic: virtual A* choosef A* al. A* a2 1 { 1:3 ((empty, en@y), (a3, a3init)) return al; 1:4 ((empty, \nempty), (&#38;Ml, glObolli,it)) j;}i 1~5 lr6 ((empty, ((empty, empty), empty), (glob&#38;, globallinit)) \n(Uli,i*.n&#38;, Ulini*.neZti,i*)) class B: public A { lr7 ((empty, empty), (a2i,it.?IeZYt, a2init.?IeLTti,it)) \n1; class C: public A { 2:l ((empty, empty), (ali,i*.TIeZt, a3i*it)) public : A* choose( A* al, A* a2 \n1 { 2:2 (((alinit eq a2init)temPfY), (a2init.nez4 asinit)) return a2; 2~3 (((olinit neq a2init),empty), \n(a2i,it.nezt, a2i,it.ncZti,it)) 2: + (1:l to 1:5} 1;); class test { 3:l (((olinit eq o2i,it)Tempfy), \n(globa[l, o3init)) public: static A* globali; 3~2 (((olinit ueq a2init),empty), (globall, o2init.neZtinit)) \npublic : static A* global2; 3: + (1:l to 1:3,1:5, 2:l to 2:3 } public : static void methodic A* al, A* \na2, A* a3 1 { 1: al + next = a3; 4:l ((empty,(ali,it.A::choose)), (glob&#38;, alimit)) 2: global1 = a2 \n+ next; 4~2 ((cmpty,(ali,it.C:rchoose)), (globaI&#38;, a2init)) 3: global2 = al -+ choose( al, a2 1; \n4: + {l:l to 1:3,2:1 to 2:3, 3:1, 3:2 } );4: Figure 2: Phase I Solution to method1 because first, a3init.next \nis not used in method1 and second, a2iait.next is not directly modified in methodl. Statement 3 is a \ndynamically dispatched call site. It can invoke either A::choose or C::choose depending upon the concrete \ntype of olinit. As a result, RCI computes the values of global2 at program point 4 conditioned on the \npotential concrete types of olinit. The dfelm 4:l says that global2 points to ulinif in those contexts \nin which the concrete type of olinit belongs to the set of types represented by A::choose (i.e., {A,B}). \nThe meaning of 4:2 is similar. As before with aliases, RCI only infers relevant potential concrete types; \nfor example, the concrete types of o%init and o3init are not relevant to methodl.5 RCI does not kill \nany dfelm at a call site unless the dfelm represents a value of the variable in which the result of the \ncall is stored, so the dfelms {l:l to 1:3, 2:l to 2:3, 3:1, 3:2} go across the calI in statement 3. The \nsummary transfer function of method2 consists of the dfelms at program point 4 except l:l, 1:2 and 1:3, \nas these three dfelms represent values of variables local to methodl. Now consider the call sites that \ninvoke method1 from another static method method2 of test. static void method2( A* a4, A* a5, A* a6 1 \n{ A *p. *q; 5: methodi(a4,a5,a6); 6: p = neo BO; 7: q = nes CO; 8: methodi(p,q,q);  9: } At call site \n5, RCI translates the dfelms at the exit node of method1 by replacing the unknown initial values of al, \na2 and a3 with their values at call site 5 (i.e., the unknown initial values of a+$, 05 and a6 respectively). \nNote: this is propagating data-flow information from callee back to caller. For example: In C++, a call \nthrough an unknown initial value of a function pointer can be handled similarly by conditioning on the \nrelationships between the unknown initial value (of the function pointer) and the functions that can \nbe potentially invoked, that is, functions whose addresses have been stored in a function pointer and \nwhose signatures match with the type of the call. For libraries, we assume that no function external \nto the library is invoked through a function pointer in the library (see [CRL98b] for details). . (((alinit \neq a2init),emptY), (&#38;ball, is translated to a3iait)) (((adinit eq &#38;nit),em&#38;), (dobaI1, a6init)). \n. ! tre.nslLedntb empty (al f. C::choose)), (g[ob&#38;?, a2init)) ((empty,(o4i,it. C::choose)), (g[ob&#38;, \na5init)). At call site 8, RCI evaluates the relevant contexts of the dfelms at the exit node of method1 \nusing objects as olinit and object7 a~ a2init and o3init. For example: (((alin;* eq a%nit),emptY), (Wall, \n&#38;nit)) is not applicable to this call site as (objects eq object,) is false. (((alimit neq a2init),empty), \n(&#38;ball, a2init.neztinit)) is translated to ((empty, empty), (globaI1, null)) because (objects neq \nobjectr) is true and the value of objectT.next is null at program point 8. empty (ali,it.A::choose)), \n(g[ob&#38;, olinit)) ! translated to ((empty, empty), (glob&#38;, objects)) because B, the concrete type \nof alin;*, belongs to A::choose, i.e., {A,B}. To summarize, at each call site RCI stores the bindings \nbetween the actuals and the unknown initial values of the methods invocable from the call site and the \nrelevant con- texts of the dfelms that imply these bindings. At call sites 5 and 8, these relevant contexts \nhappen to be (empty, empty). When the actual-to-uiv bindings are used for replacing un-known initial \nvalues with actuals in a dfelm dl, each result- ing dfelm d2 is associated with a new relevant context. \nThis context is the conjunction of the contexts of the bindings used in generating d2 and the context \nof dl, instantiated with the actuals. Although the example in Figure 2 has recursive types, only a finite \nnumber of unknown initial values are accessed in it, so representative names are not needed.  3.2.2 \nLazy Strong Update context sensitivity). Many heuristics can be used for choos- An assignment to a local \nor global variable can be safely killed at a subsequent assignment to the same variable. In contrast, \nan assignment to a field of a heap-name can-not be killed (without computing additional information), \nbecause a heap-name may represent more than one run-time object. RCI sometimes is able to kill assignments \nto the fields of unknown initial values because for a par-ticular call to a method, an unknown initial \nvalue repre- sents the same run-time object throughout that method execution[WL95, CRL98b]. When a points-to \nset of a pointer is of cardinality one, then may points-to information is effectively mvst points-to \ninformation (remember we explicitly track null). This forms the basis on which our algorithm performs \nlcills of dfelms. RCI performs kills for the fields of unknown initial values lazily. During Phase I, \nwhen a dfelm d representing the value of a field of an unknown initial value reaches a pointer assignment \nnode n that can kill d according to the current points-to solution (i.e., the current solution implies \nthat n mvst update that field of the unknown initial value), the decision for killing d cannot be made \nimmediately. Until a fixed point is reached, only a partial solution is available at n and the mvst update \ncould change to a may update according to a potentially larger fixed-point solution. In this situation, \nRCI does not propagate d immediately to the successors of n; instead, it marks n and d. After the worklist \nfor a SCC becomes empty, RCIrevisits the marked nodes to check if the marked dfelms are killed according \nto the current solution. If not, it unmarks the dfelms that should not be killed, and restarts iteration \nto propagate these unmarked dfelms. The propagation stops for a SCC when none of the remaining marked \ndfelms require repropagation (i.e., the marked nodes kill the marked dfelms according to the fixed- point \nsolution). In practice, we have found this scheme to be quite effective. This lazy propagation is efficient \nbecause the nodes that need to be revisited belong to the same SCC and their num- ber is bounded by the \nsize of the SCC. As shown in Section 5, the SCC s are usually small. 3.2.3 Optimizations of Phase I There \nare several optimizations used in Phase I to mini-mize the amount of data-flow information which needs \nto be propagated by the algorithm, as this directly affects its cost. Limiting relevant context. Let \nd be a dfelm at the exit node of a method M, C be a call site that invokes Mand I% be the relevant context \nof d. If rc evaluates to true at C, any relevant context t that is contained in rc (i.e., the set of \nconjuncts of t is a subset of the set of conjuncts of rc) also evaluates to true at C. As a result, we \nhave the following theorem? Theorem 1 For any dfelm with relevant context r , it is safe to replace r \nwith a relevant context s that is contained in r. Due to Theorem 1, instead of the complete relevant \ncon-text, RCI can use any subset of these conjuncts without compromising safety, although this may cause \npropagation of spurious dfelms to call sites where only a part of the orig- inal relevant context is \nvalid (i.e., we are using approximate This is similar to the use of one reaching alias instead of a set \nof reaching aliases in [LR92]. ing the part of the complete relevant context that is stored. At present \nwe use a simple heuristic: if the user specifies a bound of k on the number of conjuncts of a specific \nkind, we store the first X: conjuncts of this kind associated with a dfelm; the rest of the conjuncts \nare dropped. This bound is imposed uniformly for all dfelms; however, RCI allows different bounds for \ndifferent dfelms. Reduction of alias context. Let tl and t2 be two classes. If tl and t2 satisfy any \nof the following: (i) tl is same as t2, (ii) tl is a subtype of t2 or (iii) tl is a supertype of t.2, \nthen tl and t2 are called compatible. Two unknown initial values are called compatible if and only if \ntheir de- clared classes are compatible. For the concrete values of two unknown initial values to be \nthe same, the unknown initial values must be compatible. Thus, only compatible unknown initial values \ncan participate in a potential alias or a potential non-alias. Whenever a field of an unknown ini-tial \nvalue is modified, the same field of another compatible unknown initial value can also be potentially \nmodified, and for safety, dfelms with appropriate alias contexts need to be generated to record this \npotential modification. However, the following three optimizations enable RCI to avoid the generation \nof some of these dfelms without compromising safety. Lazy Generation of Fields. RCI considers only those \nfields of an unknown initial value that are used in a method M, either directly at pointer assignment \nstatements in M or indirectly, through actual-to-uiv bindings, at pointer as-signment statements in methods \ninvoked from M through a series of calls. For example, in Figure 2, the next field of a3i,;* is not considered \nbecause it is not used in methodl. When a field f of an unknown initial value is found to be used for \nthe first time in M, this fact is propagated to the callers of Min the same SCC as M. If through actual-to-uiv \nbindings, access to f causes access to other fields for the first time in same-SCC callers, facts representing \naccess to these fields are also propagated iteratively using a worklist. At an assignment statement, \nthe fields that are considered for po- tential modification and generation of alias contexts are the \nfields that are used in the method. For example, the next field of a3init is not considered for potential \nmodification at statement 1 of methodl, although 03in;t has the same type as alinit. Write-only Fields. \nConsider the following method which is part of class test defined in Figure 2. void mathod3( A* prml, \nA+ prm2, A* prm3 ) { 1: prmi -+ next = prm3; 2: global1 = prm2 + next; 3: prm3 + next = global2; ) This \nmethod uses the next fields of the unknown ini-tial values prmlinit, prm2i,it and pT7dinit. Thus, the \nnext fields Of pTm2init and prm3init should be considered for PO-tential modification at statement 1. \nHowever, the next field of pTWd;nif is only used for writing and it is never read in method3. As a result, \nat statement 1, it is unnecessary to generate a dfelm to represent the potential modification of the \nnext field of prm3init. This modification will be auto-matically seen at a call site of method3 where \nthe values of pTmlinit and pTm3init are the same. On the other hand, consider a call site C that invokes \nmethod3 and where it 7Multiple inheritance can be easily accommodated by extending the definition of \ncompatible classes so that two classes are compatible if either one of the above three conditions hold \nor these two classes have a common derived class. is possible for the values of prmli,it and prm3init \nto be distinct unknown initial values. Suppose C is contained in method M. Further, let uvl and UVZ be \ntwo distinct un-known initial values that are respectively values of ptmlinif and prm3init at C. If the \nnext field of uv.2 is read in M, RCI will generate a #elm with appropriate alias context in M to record \nthe potential modification to the next field of uv2 due to the modification of the next field of uvl \nat the statement 1 of method3. Initially, RCI considers all the fields of unknown initial values to be \nwrite-only. When a field is found to be read for the first time, it is made read/write and a candidate \nfor potential modification; thereafter, it will be considered for the generation of alias context. Restricting \nalias context to unknown initial val-ues. At a pointer-assignment statement, RCI only consid-ers the \nfields of unknown initial values (not heap-names) for potential modification and the generation of alias \ncontext. This is safe because for anv oarticular call to a method. the run-time objects represented by \na heap-name in the method during Phase I are different from the run-time objects rep-resented by any \nof the unknown initial values. Although a heap-name appearing in a method during Phase I could be associated \nwith an unknown initial value of the method in Phase II, for any particular call to the method, the run-time \nobjects represented by the heap-name in the two cases are different. Consider the following methods which \nare part of class test defined in Figure 2: A* methodd( A prm ) { void method50 { A *p, *q; A +r, *s; \n1: p = ado A(); 4: r = new A(); 2: prm-+ne*t=o; 5: s = method4(r); 3: q=p--,next; 6: I = methodrl(s); \n} return p; } The heap-name objecti is a value of the unknown initial value prm;,it and it is also used \nin method4 during Phase I. The next field of object1 is read at statement 3 and the type of object1 \nis the same as the type of prminif. However, at statement 2, when the next field of pminit is modified, \nthe nezt field of object1 need not be considered for potential modification. This is safe because at \nstatement 6, where object1 is the value of prm; it, object1 represents run-time objects created at statement \n1 when method4 is called from statement 5; and for the call to method4 at statement 6, object1 appearing \nin the Phase I solution of method4 repre-sents run-time objects created at statement 1 when method4 is \ncalled from statement 6.8  3.3 Phase II For each concrete value of an unknown initial value, com-puted \nat the entry node of a method M during this phase, RCI visits each of the call sites in M and does the \nfollowing: s For each dynamically dispatched call site Cin M, RCI incrementally computes the set of methods \ninvocable from C. Suppose the receiver at C is the value of a pointer variable p. Let S be the set of \n#elms computed during Phase I that represent the values of p at C. RCI evaluates the #elms of S by instantiating \nunknown ini-tial values with their concrete values computed at the entry node of M. Those dfelms whose \nrelevant con-texts evaluate to trve yield the concrete values of p In C++ a pointer to a global can \nbe created and hence a global can be a value of an unknown initial value. Therefore, a global can be \nused in a method either directly or through an unknown initial value, and thus a global can also be part \nof alias context. at C, which are used to determine the set of methods invocable from C. Thus, at the \nend of Phase II, RCI produces the final call graph which is a significant refinement of the initial call \ngraph. At a dynamically dispatched call site in the final call graph, the only tar-gets considered invocable \nare those that are invocable using the concrete values of the receiver computed at the call site during \nPhase II. . At each call site C, RCIuses the actual-to-uiv bindings computed during Phase I (see Section \n3.2.1) to propa-gate concrete values to the methods invocable from C. RC1evaluates the relevant contexts \nassociated with an actual-to-uiv binding by substituting the unknown ini-tial values in the relevant \ncontexts with their concrete values computed at the entry node of M. A binding is used for propagation \nif and only if at least one of the relevant contexts associated with the binding evaluates to true. \nFor methods in the same SCC, the concrete values are propagated iteratively until a fixed point is reached, \nwhile for methods in different SCC s, the propagation is done in a top-down manner without iteration. \nIn order to avoid propagation of concrete values from un-reachable methods, RCI computes an initial set \nof reachable methods, and then incrementally expands this set during Phase II. For complete programs, \nthe initial set consists of only ma&#38;.g When RCI visits each node of SCC-DAG in a topological order \nduring Phase II, it considers only those methods in the current SCC that have been marked reach-able. \nWhenever RCI finds an unmarked method to be in-vocable from a call site in a reachable method, it marks \nthe new method also as reachable. For example, consider Phase II for the example given in Figure 2 and \nmethod2 (see Section 3.2.1). For simplicity, assume that method2 is reachable. As a result, method1 is \nalso reachable as it is invoked from method% At call site 8, RCI stores an actual-to-uiv binding between \nobjects and olinit, and the only relevant context of this binding is (empty, empty). Since the relevant \ncontext (empty, empty) trivially evaluates to true, Phase II propagates objects as a concrete value of \nolinit to the entry node of methodl. At the call site in statement 3, the value of the receiver is the \nvalue of al, and the value of al is given by the dfelm ((empty, empty), (al, olinit)). Phase II substitutes \nobjects for olinit in this dfelm to obtain objects as a concrete value of the receiver. This implies \nthat A::choose is invocable from statement 3 and the final call graph has an edge from statement 3 to \nA::choose. 3.4 Phase Ill Let n be a non-entry node in a reachable method M. If the solution of points-to \nanalysis is needed at n, each dfelm com-puted at II during Phase I is instantiated with the concrete \nvalues computed at the entry node of M during Phase II. Those instantiations for which relevant contexts \nevaluate to trve yield the solution of points-to analysis at n. After in-stantiation with concrete values, \na dfelm yields a points-toof the form (TJU~,object), where var is a local pointer variable, a global \npointer variable or a heap-name s field of pointer type, and object is a heap-name. For incomplete programs \nlike libraries, the initial set consists of all the methods that could be directly invoked from outside \nthe in-complete program. Consider Phase III for the example in Figure 2 and methods (see Section 3.2.1). \nSuppose, Phase III needs to be done at program point 4. For this, each dfelm at program point 4 is instantiated \nwith the concrete values computed at the entry node of method1. For example, when alinit is instantiated \nby objects in the first dfelm at program point 4, the relevant context of the dfelm evaluates to true \nand the dfelm yields the points-to (glob&#38;, objects).  3.5 Complexity In this section, we briefly \ndiscuss the complexity of the var-ious steps of RCI. We will focus on the important, dominat-ing terms \nand, for simplicity, ignore less important terms. The analysis is for the subset of Ctt in Figure 1, \nbut this does not significantly impact the final results. Phase 0. Let T,,,,, be the maximum number of \ntargets of a call site intheinitial call graph, let &#38; be the to-tal number of call nodes and let \nN,,,, be the total num- ber of procedures/methods. The complexity of Phase 0 is O(T,,, N, + N,X.,). Phase \nI. The scheme for dealing with recursive types en-sures that the total number of unknown initial values \nand hence the total number of possible dfelms is finite, even if no bound is imposed on the number of \nconjuncts in a relevant context. Since RCI does only a finite amount of work for each dfelm at a program \npoint and at each step RCI consid-ers a new dfelm at a program point, RCI always terminates. Let the \ntotal number of unknown initial values generated by RCI be Nui., the number of user-defined pointer variables \nbe NV,,, the maximum number of fields of a class (includ-inginherited fields) be F,,,, the total number \nof classes be Nelasr, the number of ICFG nodes be Nnodea, the total number of heap-names be Nh and the \nbound on the number -of conjuncts in a relevant context be &#38;. Let N,, be the number of possible relevant \ncontexts. N,, is at most O((pa + tc) ), where {pa = 2N~i,, tc = NuioTmar} Here pa is an upper bound on \nthe number of possible po-tential aliases and potential non-aliases, and tc is an upper bound on the \nnumber of possible type constraints. Let Npt be the number of possible points-tos. Npt is at most fm \n= (Nh + Nviv)Fmaz + Near O(fm * sm), where sm = Nh + Nviu Here fm is an upper 6ound on the number of \npointers &#38;at can be the first member of a points-to pair and sm is an upper bound on the number of \nvalues for the second mem-ber. Now, let Ndfe be the total number of possible dfelms. Ndfe is at most \nO(N,,N,t). Hence the total number of pos- sible dfelms is polynomial in N~i~,N~,,,Nh, T,,, and F,,,,,, \nassuming Ic is constant. Now consider the work done by RCI at a pointer as-signment node. For each dfelm \nreaching such a node, O(n2 * ny), where {nl = (N,;, + Nh) * N,,, no = nl}, is an upper bound on the work \ndone for dfelms directly gener-ated by the pointer assignment statement. Here nl is an upper bound on \nthe number of elements in Ihs_rc_Zoc_peirs (see Appendix A) and similarly, no is an upper bound on the \nnumber of elements in P-hs_rc_loc_pairs. O(Nui, * cs), where {cs = NrcNui,(Nui, + Nh)}, is an upper bound \non the work done in generating dfelms due to potential aliases. Here cs is an upper bound on the number \nof dfelms in new_generated_dfes (see Appendix A) that may generate dfelms due to potential aliases. Finally, \nO(nl* cs) is an upper bound on the work done in generating dfelms due to potential non-aliases. Here \ncs is an upper bound on the number of dfelms in the current solution of the pointer as-signment node \nthat may generate dfelms due to potential non-aliases. Similarly, it can be shown that at any node, for \neach dfelm reaching that node, the work done by RCI is poly-nomial in Nvia, Nh, N,,,,T,,, and Fm,, (assuming \nk is constant and a constant bound on the number of intrapro-cedural successors of a node). Let NwO,.~ \nbe the maximum amount of work done by RCI for a dfelm at a program point. Since at each step RCI considers \na new dfelm at a pro-gram point, the total amount of work done by RCI is o(Ndj, *Nnodes * NWOTk). Hence \nthe total work done by RCI is polynomial in Ntii,, Nh, N,,,,T,,,, F,,, and Nnodell, as-suming L is constant. \nNh, N,,,,T,,,,F,,, and Nnodes are obviously bounded by the size of the program. However, in theoretically \ncon-trived cases, RCI can generate an exponential number of un-known initial values (see Appendix B). \nAlthough we never encountered this in practice, it can be easily avoided by en-forcing a bound t on the \nlengths of access paths of unknown initial values (analogous to k-limiting [JM82]). Among the unknown \ninitial values accessible from a root unknown ini-tial value, all the unknown initial values of the same \ntype and having access paths longer than t will be represented by the same representative name. This \nwill ensure that Nviv is polynomial in N,,,,, N,,,, F,,, and Nclass. Phase II. Let C,,,,, be the maximum \nnumber of call nodes in a procedure/method. Let Nmap be the maximum number of actual-to-uiv mappings \nstored at a call node. N,,, is at most O(np * nr), where {np = (Nh + Nuio)Nuis, nr = N,.,}. Here np is \nthe maximum number of pairs of ac-tuals and unknown initial values and the term nr counts the relevant \ncontexts associated with each actual-to-uiv map-ping. Let Npzop be the maximum amount of work done by \nRCI at a call node for a concrete value of an unknown initial value. Nprop is at most O(Nmap * (ce + \ncp)), where {ce = Niklc * Nh, cp = Nh}. Here ce is the worst case cost of evaluating a relevant context \nand the associated actual. This is because each unknown initial value can have at most Nh concrete values. \ncp is the worst case cost of propagat-ing concrete values to the entry node of a target procedure. So \nthe total amount of work done during this phase in the worst case is O((N,;,Nh)C,,,N,,,). Here O(N,,i,Nh) \nis an upper bound on the number of pairs of unknown initial values and their concrete values. Phase II \nI. The worst case of evaluating a dfelm during this phase is O(er * ep), where (e7 = Niklc, ep = Ni}. \nHere er is the worst case cost of evaluating the relevant context of the dfelm and ep is the worst case \ncost of evaluating the points-to of the dfelm. Hence the worst case cost of this phase is O(Nikt2k * \nNnoded * Ndfe). 4 Extensions In this section, we briefly describe some extensions of RCI whose details \nare given in [CRL98b]. RCI has been designed to work on both C++ and Java, as our subset of C++contains \nthe essential features of both languages except threads. Modular points-to analysis has been extended \nto handle Java exceptions. The essential idea is to store additional information in the relevant context \nthat summarizes control-flow due to exceptions. The modular nature of RCI is unaffected and its overall \nstructure remains the same. Only the definition of the #elms computed by Phase I must be extended to \naccount for the possible control-flow due to exceptions. Under the same assumptions as in Section 3.5, \nRCI is polynomial-time even in the presence of exceptions. A complexity classification of doing analysis \nin the presence of exceptions is given in [CRL98a]. Another important property of RCI is that incomplete \nprograms such as libraries can be analyzed. A unknown ini-tial value at the entry node of a method of \na library, that can be directly invoked from a call site outside the library, is called an interface \ninitial value. When RCI is used for analyzing a library L, during Phase II RCI treats an inter-face initial \nvalue like a concrete value and similarly propa-gates an interface initial value to the entry nodes of \nother methods. During Phase II or III, when RCI instantiates an unknown initial value in a conjunct with \nan interface initial value, conservative worst-case assumptions are made about the interface initial \nvalue for evaluating the conjunct. Relevant contexts computed by RCI can be used for generating relevant \ntest cases for libraries. These contexts provide valuable information about how a library may be used \nin general; this information cannot be obtained from a whole-program-analysis of a particular driver \nwith the li-brary. These contexts suggest a new coverage measure for the unit testing of libraries that \ncan be used with other stan-dard coverage measures. Implementation Our implementation has been built \nusing the PROLANGS Analysis Framework (PAF) which incorporates the Edison Design Group front end for \nANSI C++. Our initial empir-ical results with modular points-to analysis are encouraging; however, this \nis a proof-of-concept implementation and there is scope for optimization. Table 1 contains some characteristics \nof the thirteen Ctt programs we have analyzed. These are some of the bench-marks used in [PR96, BS96, \nCGZ951. The columns lines, ICFG nodes, methods, virtual calls, SCC s and Max SCC respectively show the \nnumber of lines of code, ICFG nodes, methods, dynamically dispatched call sites, nodes in SCC-DAG and \nmethods in the maximum-sized SCC for each pro-gram. Table 2 contains the timings using a Spare-20 with \n352 megabytes of memory. These timings do not include time for scanning, parsing or I/O. The column Bounds \ncontains pairs (i, j) which mean that the bounds on the number of potential aliases and type constraints \nof each relevant context were i and j respectively. We analyzed richards, derivl, FeynLib, opProd, penguin, \nBdecay and electron with more than one set of bounds. The second row of (1,l) for richards corresponds \nto an analysis that only allowed either one potential alias or one type con-straint per relevant context. \nDifferent bounds yielded mea-surable variations in those characteristics shown in Tables 2 and 3, but \nthere was no difference in the information re-ported for the two applications in Table 4. We analyzed \nwith See http://www.prolangs.rutgers.edu/public.html. trees implements trees, de&#38;l implements arithmetic \nexpression trees, employ implements a class hierarchy for different kinds of em-ployees in a company, \nRichards is an operating system scheduler, deltabhe is a symbolic constraint solver, sampleldv, vmatriz \nand vvector perform matrix computations, and FeynLib is a library for drawing Feynman Diagrams for which \nBdecay, electron, opProd and pengain are drivers for different kinds of elementary particles. smaller \nbounds those programs with large running times for higher bounds, and studied the cost-precision tradeoff \nwith respect to the applications reported in Table 4. Although Phase III is demand-driven, for these \nexperi-ments Phase III was performed at all non-entry nodes. The Phase I solution of a library can be \nshared by different driver programs. This is illustrated by the Phase I timings of Bdecay, electron, \nopProd and penguin. For these programs, tl + tz means the time for the driver code is tl and the time \nfor the library code is tz, a shared cost which is only incurred once. Although trees and employ are \nsmall benchmarks, these are important to show the two orders of magnitude tim-ing improvement over a \nprevious flow-and context-sensitive, whole-program-analysis technique [PR96], which took 690 and 450 \nseconds for these benchmarks. In Table 3, the columns PA s and TC s show the total number of potential \naliases and type constraints generated. The column Max Size Relevant Context shows the maximum number \nof conjuncts in any non-empty relevant context. In order to get an estimate of the memory saving obtained \nby using summary transfer functions, we normalized the size of the summary transfer function of each \nmethod with the size of the complete Phase I solution of the method. To compute the latter, we considered \nonly those nodes which are relevant for points-to analysis: we excluded those nodes which pre-serve points-to \ninformation. Then we averaged these nor-malized sizes over all methods in a program to compute the average \nsize of a summary transfer function for a program; results are presented as a percentage in column Ave \nSize Summ Fen. Another possibility would have been to com-pare the sizes of the summary transfer functions \nwith the number of nodes in the corresponding methods. But this is not reasonable because the cost of \nreanalyzing a method de-pends upon the size of the points-to solution of the method and the number of \nnodes reachable from the method during an invocation (not just the number of nodes in the method). Our \ncomparison gives a better indication of the reduction in memory requirement achieved, as RCI needs to \nkeep in memory only the summary transfer functions of the meth-ods called from the current SCC, rather \nthan the complete solution of those methods. No counts are reported for potential non-aliases because \nat present, our implementation does not generate any poten-tial non-aliases. By Theorem 1, this does \nnot affect safety of the computed solution. The impact of potential non-aliases on the precision of points-to \nanalysis is likely to be small, because a potential non-alias must evaluate to false to in-crease precision, \nand this will only occur if both aivl and uivz map to the same unknown initial value during Phase I. \nIf they both map to the same heap-name, the potential non-alias evaluates to true because the heap-name \ncan represent more than one run-time object. We have chosen to describe RCI as including calculation \nof potential non-aliases, be-cause we believe they can be useful for other applications (e.g., analyzing \nlibraries, testing etc). In order to test the quality of the solution computed by RCI, we used the solution \nfor two different applications: side-eJgect analysis or MOD [LRZ93, SRLZ98] and virtual fin&#38;on resolution \n[PR96]. The results for MOD are shown in Table 4. The column AvConcrete MOD shows the av-erage number \nof heap-names whose fields are modified by a pointer-assignment statement according to the Phase III \nsolution. In object-oriented programs, since a method is usually called from many different contexts, \nthe number of heap-names modified at a statement could be large even in the precise solution. We verified \nby inspection that multiple p*Ogl-t%UlS lines 1 ICFG methods 1 virtual SCC s I Max calling contexts is \nthe reason why some of the AvConcrete nodes calls see MOD numbers are high. Therefore, we used the Phase \nI solution to compute the average number of unknown initial values or heap-names whose fields are modified \nat a pointer- assignment statement. This factors out the effect of expan-sion of an unknown initial value \ninto multiple concrete values because of the invocation of a method from multiple con- texts. Column \nAwAbstract MOD shows this second average over all pointer-assignment statements for each benchmark. \nTable 4 and Figure 3 show our results for virtual func-tion resolution. RCI is probably more precise \nthan neces-sary for solving virtual function resolution for Cts, because it is really aimed at problems \nwhere there is more gain from flow and context sensitivity; nevertheless, our results show that there \nare calls for which RCI enables much better res-olution, with concomitant opportunities for aggressive \nopti-mizations such as instruction scheduling and specialization. Column Reachable Virtual Calls shows \nhow many of the vir- tual calls in each program, are actually reachable (with the given drivers for libraries). \nColumn Unique Hierarchy shows the number of reachable calls which are uniquely resolved by hierarchy \nanalysis. Column Differences RCI-Hierarchy shows the number of those reachable calls for which the number \nof targets found by RCI is less than the number of targets found by hierarchy analysis. In Figure 3 we \nshow the number of these differing calls in each program and the sizes of the differences. As noted above, \nchanging bounds made no difference in these results. The possible loss of pre-cision due to imposing \nbounds on the number of conjuncts in a relevant context, was not observed in the applications we considered. \nFor them, using lower bounds improved run-ning time significantly. However, for other applications and \nbenchmarks, the situation might be different. Related Work Wilson and Lam [WL95] have also used unknown \ninitial val-ues in their algorithm for points-to analysis of C programs; however, there are significant \ndifferences between RCI and their approach. Their algorithm needs to know the exact alias relationships \nbetween the unknown initial values be-fore a procedure can be analyzed. Their algorithm keeps the whole \nprogram in memory and cannot analyze incom-plete programs. They construct partial transfer functions, \nwhile RCI constructs summary transfer functions that ap-proximate complete transfer functions. As their \nalgorithm is for C, they handle neither dynamic dispatch nor exceptions, however, they do handle function \npointers. Sometimes, if there are very few calls to a method in a complete pro-gram and very few of the \npossible relevant contexts occur, using summary transfer functions instead of partial transfer functions \ncould be more costly. Unknown initial values are similar to non-visible vari-ables used in [LR92] and \ninvisible variables used in [EGH94] for summarizing the values of pointers that point to out-of-scope \nvariables. Moreover, there are aspects of hybrid data-flow analysis [MR90] in which unknown initial values \nare used to model representative external values in a local analysis. In [FF97], the authors present \na method for doing set-based analysis in a component-wise manner for Scheme pro-grams. Since this is \nnot a data-flow analysis and is not aimed at an object-oriented language, it is difficult to directly \ncom-pare this work to RCI. Essentially, [FF97] describes an opti-mization technique for set-based analyses, \nwhen it is known trees derivl employ richards deltablue s-pleAdv vmatrix vvector FeynLib opProd penguin \nBdecay electron program trees d&#38;v1 derivl employ richards richards richards deltablue s-pleAdv vmatrix \nvvector opProd opProd penguin penguin Bdecay Bdecay electron electron p=ogr- trees derivl derivl employ \nrichards richards richards deltablue s-pleAdv vmatrix vvector FeynLib FeynLib opProd opProd penguin penguin \nBdecay Bdecay electron electron 3 217 280 25 21 3 23 3 60 1 87 1 112 1 130 1 128 1 138 1 219 4 219 4 \n219 4 219 4 219 4 Bounds jE$$ (c+) (=J!W) (DYE) (1J) W) (,=1~) (cwQ) (owe) (m+) (1J) [X] (212) (l,l) \n(272) (111) (272) Bounds 192 947 987 1509 3130 3607 3681 6222 6289 6313 6293 6321 PhO 0.01 0.02 0.01 \n0.02 0.03 0.03 0.04 0.05 0.08 0.09 0.08 0.09 320 463 918 1471 2203 2783 3401 7247 7340 7450 7465 7502 \nI 27 60 87 112 130 128 138 229 230 230 230 230 Table 1: Benchmarks Phi Ph II 0.64 0.05 5.95 0.05 2.42 \n0.06 0.76 0.05 33.50 0.16 17.56 0.15 9.87 0.17 4.33 0.24 4.42 0.03 6.98 0.12 10.27 0.16 3.21+99.52 2.74 \n5.38+437.72 1.64 3.98+99.52 2.14 5.25+437.72 1.52 4.15+99.52 2.10 7.24+437.72 1.41 5.06+99.52 2.18 4.25+437.72 \n1.50 28 4 82 185 9 9 9 47 47 47 47 47 Ph III 0.30 0.66 0.52 0.31 9.99 8.38 6.22 1.84 0.79 4.07 5.87 \n34.46 68.38 30.29 51.70 29.92 51.54 33.41 61.59 Table 2: Timings in Seconds PA s TC s Max Relevant Context \n4 12 1 0 116 3 0 116 1 0 36 1 85 5 3 84 5 2 77 5 1 1 12 1 11 5 2 10 2 2 10 6 2 115 535 1 245 579 2 115 \n535 1 245 579 2 115 535 1 245 579 2 115 535 1 245 579 2 115 535 1 245 579 2 Table 3: Performance Ave \nSize Sums Fen 8.7% 6.4% 6.3% 5.8% 9.0% 9.0% 9.0% 3.9% 7.4% 7.4% 7.2% 3.5% 3.7% 3.5% 3.7% 3.5% 3.7?&#38; \n3.5% 3.7% 3.5% 3.7% Data p=ogr-AvAbstract AvConcrete Reachable Unique Differences I Bounds 1 MOD MOD \ntrees 1 1.54 derivl 1 3.67 employ 1 2.60 richards 1.100 2.48 deltablue 1.062 2.50 s-pleAdv 1 5.14 vmatrix \n1 15.14 vvector . 9.40 opProd 2.54 1 .oo; penguin 1.007 1.88 Bdecay 1.007 1.98 electron 1.007 2.17 Table \n! Virtual Calls Hierarchy 1 0 20 10 4 0 82 81 133 132 2 0 6 5 2 0 5 0 6 0 4 0 7 0 4: Applications 14 \n12 10 / 0 differ by 1 . by 2 differ by 3 0 differ by 5 . by 6 W differ by 7 0 differ by 9 differ . differ \nr Figure 3: Differences in Precision between RCI and Hierarchy Analysis that different sets of constraints \ncorrespond to separate mod-ules of the program. It is modular in the sense that the sim- plified constraint \nsets can be obtained separately. Using the terminology of Section 1, the algorithm of [FF97] is flow- \ninsensitive and therefore, does not perform strong updates. Concrete type inference and call graph construction \nfor object-oriented languages are subsumed by our analysis. There are many non-modular whole-program-analysis \nap-proaches for these two problems. Most use constraint-based analysis [Suz81, PS91, PC94, Age95, GDDC97, \nDGC98], but a few [CHS95, PR96, DMM96] are data-flow-based. Both [CHS95, PR96] are flow-and context-sensitive \nalgorithms for Ctt ; we have compared our empirical results with those in [PR96] which were non-scalable. \nNo implementation is reported in [CHSSS]. [DMM96] presents different type anal-ysis techniques for Modula-3, \nincluding hierarchy analysis, flow-sensitive intraprocedural type propagation and context-insensitive \ninterprocedural type propagation. [GDDC97] presents a more complex notion of context which subsumes calling \ncontext and type context for some program variables. It presents a general framework for call graph construction \nof object-oriented programs. Among constraint-based ap-proaches, [Suz81, DGC98] are flow-and context-insensitive, \nwhile [PS91, PC94, Age951 are flow-insensitive, but context-sensitive. None of the above approaches handle \nexceptions. [BS96] is an extension of hierarchy analysis for Ctt and thus it is flow- and context-insensitive. \nConclusions A new technique called RCI for mod&#38;r flow-and context-sensitive data-flow analysis has \nbeen presented, in the con-text of its application to points-to analysis for a substantial subset of \nC++. This scalable algorithm does whole program analysis without needing the entire program source in \nmem-ory; each method must be in memory only four times during algorithm execution. Initial empirical \nresults attest to the effectiveness of this technique on moderate sized programs. Extensions for Java \nwith exceptions (but without threads) and analysis of libraries also were discussed. Acknowledgements. \nWe thank the anonymous reviewers for their helpful comments, Tom Marlowe for reviewing an earlier draft \nof this paper, and Atanas Rountev and Matt Arnold for helping with the implementation. References [+%951 \nOle Agesen. The Cartesian product algorithm: Simple and precise type inference of parametric polymorphism. \nIn Proceedings of European Conference on Object-oriented Programming (ECOOP 95), 1995. [And941 L. 0. \nAndersen. Program Analysis and Specialization for the C Progmmming Laagaage. PhD thesis, DIKU, University \nof Copenhagen, 1994. Also available as DIKU report 94/19. [BS96] David F. Bacon and Peter F. Sweeney. \nFast static analysis of c++ virtual function calls. In Proceedings of theACM SIGPLAN Conference on Object-Oriented \nProgramming Systems, Languages and Applications, 1996. [CBC93] Jag-Deok Choi, Michael Burke, and Paul \nCarini. Efficient flow-sensitive interprocedural computation of pointer-induced aliases and side effects. \nIn Proceedings of the ACM SIGPLAN/SIGACT Symposium on Princi-ples of Programming Languages, pages 232-245, \nJanuary 1993. [CGZ95] B. Calder, D. Grunwald, and B. Zorn. Quantifying be- havioural differences between \nC and C++ programs. Jorr- nal of Programming Languages, 2:313-351, 1995. [CHS95] [CLR92] [CRL98a] [CRL98b] \n[Deu94] [DGC98] [DMM96] [EGH94] [Ema93] [FF97] [GDDC97] [Ghi96] [~~82] [LR91] [LR92] [LRZ93] [MLR+93] \n[MR90] P. Carini, M. Hind, and H. Srinivasan. Flow-sensitive interprocedural type analysis for ct+. Technical \nReport RC 20267, IBM T.J. Watson Research Center, 1995. T. H. Cormen, C. E. Leiserson, and R. L. Rivest. \nIntro-duction to algorithms. The MIT Press and McGraw-Hill Book Company, 1992. Ramkrishna Chatterjee, \nBarbara Ryder, and William Landi. Complexity of concrete type-inference in the pres-ence of exceptions. \nIn LNCS 1381, Proceedings of EUTO-pean Symposium on. Programming, April 1998. Ramkrishna Chatterjee, \nBarbara Ryder, and William Landi. Relevant context inference. Technical Report DCS-TR-360, Dept of CS, \nRutgers University, August 1998. A. Deutsch. Interprocedural may alias for pointers: Be-yond k-limiting. \nIn Proceedings of the SIGPLAN 94 Conference on Programming Language Design and Im-plementation, pages \n230-241, June 1994. Greg DeFouw, David Grove, and Craig Chambers. Fast in-terprocedural class analysis. \nIn Proceedings of the A CM SIGPLAN/SIGACT Symposium on Principla of PTO-gramming Languages, pages 222-336, \n1998. Amer Diwan, J.Eliot B. Moss, and Kathryn S. McKin-ley. Simple and effective analysis of statically-typed \nobject-oriented programs. In Proceedings of the ACM SIGPLAN Conference on Object-Oriented Programming \nSystems, Langwges and Applications, 1996. Maryam Emami, Rakesh Ghiya, and Laurie J. Hendren. Context-sensitive \ninterprocedural points-to analysis in the presence of function pointers. In Proceedings of the ACM SIGPLAN \nConference on Programming langwge design and implementation, pages 242-256, 1994. Maryam Emami. A practical \ninterprocedural alias anal-ysis for an optimiaing/parallelizing c compiler, master s thesis. Technical \nreport, School of Computer Science. McGill University, August 1993. Cormac Flanagan and Matthias Fell&#38;an. \nComponential set-based analvsis. In PToceedinos of the ACM SIGPLAN Conference on. Programming Zakgahge \ndesign and imple-mentation, pages 235-248, 1997. D. Grove, G. DeFouw, J. Dean, and C. Chambers. Call \ngraph construction in object-onented languages. In Pro-ceedings of Conference on Object-Oriented Program-ming \nSystems, Languages, and Applications (OOP-SLA 97), pages 108-124, October 1997. Rakesh Ghiya. Connection \nanalysis: A practical inter-raocedural hear, analvsis for c. International Journal of >araZZel Prog&#38;mmi~g, \n24(6):547-578, 1996. N. D. Jones and S. Muchnick. Flow analysis and optimiza-tion of lisp-like structures. \nIn S. Muchnick and N. Jones, editors, Program Flow Analysis: Theory and Applica-tions, pages 102-131. \n1982. W.A. Landi and Barbara G. Ryder. Pointer-induced alias-ing: A problem classification. In Proceedings \nof the ACM SIGPLAN/SIGACT Symposium, on Principles of Pro-gTamming Languages, 1991. W.A. Landi and Barbara \nG. Ryder. A safe approxima-tion algorithm for interprocedural pointer aliasing. In Proceedings of the \nACM SIGPLAN Conference OR PTO- gramming Language Design and Implementation, 1992. W.A. Landi, Barbara \nG. Ryder, and Sean Zhang. Inter-procedural modification side effect analysis with pointer aliasine. In \nProceedinaa of the ACM SIGPLAN Confer-  - mace on Programming Language Design and Imp&#38;en-tation, \n1993. T. J. Marlowe, W. A. Landi, B. G. Ryder, J. Choi, M. Burke, and P. Carini. Pointer-induced a&#38;sing: \nA clar- ification. ACM SIGPLAN Notices, 28(9):67-70, Septem-ber 1993. Thomas. J. Marlowe and Barbara \nG. Ryder. An efficient hybrid algorithm for incremental data flow analysis. In Proceedings of the ACM \nSIGPLAN/SIGACT Sympo-sium on Principles of Programming Languages, pages 184-196, January 1990. [PC941 \nJ. Plevyak and A. Chien. Precise concrete type infer-then lhs-rc-lot-pairs would be ence for object oriented \nlanguages. In Proceeding of Con- ference on Object-Oriented Programming Systems, Lan- gmzga and Applications \n(OOPSLA 94), pages 324-340, ((empty, empty), 4, October 1994. (( (Pinit eq Pinit),emPtY), Pinit) 1 1 \n[PR96] Hemant Pande and Barbara G. Ryder. Data-flow-based virtual function resolution. In LNCS 1145, \nProceedings of the Third International Symposiwn on Static Analy-sis, 1996. [PS91] J. Palsberg and M. \nSchwartzbach. Object-oriented type inference. In Proceedings of Conference OR Object-Oriented Programming \nSystems, Languages, and Appli-cations (OOPSLA 91), pages 146-161, October 1991. [RHSSS] T. Reps, S. Horwitz, \nand M. Sagiv. Precise interproce-dural dataflow analysis via graph reachability. In Pro-ceedings of the \nACM SIGPLAN/SIGACT Symposiwm on Principles of Programming Languages, pages 49-61, 1995. [Ruf95] E. Ruf. \nContext-insensitive alias analysis reconsidered. In Proceedings of the ACM SIGPLAN Conference OR PTO- \ngramming langnage design and implementation, pages 13-22, June 1995. [SH97] M. Shapiro and S. Horwita. \nFast and accurate flow-insensitive points-to analysis. In Proceedings of the ACM SIGPLAN/SIGACT Symposium \non Principles of PTO-gmmming Languages, pages l-14, 1997. [SPSl] M. Sharir and A. Pm&#38;. Two approaches \nto interproce-dural data flow analvsis. In S. Muchnick and N. Jones. editors, Program Flow Analysis: \nTheory and Applica: tions, pages 189-234. Prentice Hall, 1981. [SRLZ98] P.4. Stocks, B.G. Ryder, W.A. \nLandi, and S. Zhang. Comparing flow-and context-sensitivity on the modifi-cation side-effects problem. \nIn Proceedings of the Inter-national Symposium on Software Testing and Analysis, pages 21-31, March 1998. \nAlso available as DCS-TR-335. [Ste96] Bjarne Steensgaard. Points-to analysis in almost linear time. In \nProceedings of the ACM SIGPLAN/SIGACT SympoJium on Principles of PTogTamming Languages, pages 32-41, \n1996. [SuzSl] N. Suzuki. Inferring types in smalltalk. In Proceedings of the ACM SIGPLAN/SIGACT Symposium \non Principles of Programming Languages, pages 187-199,198l. [WeiSO] W. E. Weihl. Interprocedural data \nflow analysis in the presence of pointers, procedure variables and label vari-ables. In Confemnce Record \nof the Seventh Annual ACM Symposium on Principled of Programming Languages, pages 83-94, January 1980. \n[WL95] Robert P. Wilson and Monica S. Lam. Efficient context-sensitive pointer analysis for c programs. \nIn Proceed-ings of the ACM SIGPLAN Conference on Pmgram-ming language design and implementation, pages \n1-12, 1995. [ZRL96] S. Zhang, B. G. Ryder, and W. Landi. Program decom-position for pointer a&#38;sing: \nA step towards practical analyses. In Proceedings of the 4th Sympmium on the Foundations of Software \nEngineering, October 1996. A Pointer Assignment The data-flow transfer function, apply, for a pointer \nassign- ment node n, is defined in Figures 4 and 5. n.lhs, n.rhs and n.sol are respectively the left \nhand side expression, the right hand side expression and the current solution at n. rdje is a new djelm \n(rc, (5 y)) reaching the node n (i.e., rdfe @ n.sol). lhs_rc_loc_pairs is the set of pairs of relevant \ncontexts and objects that are modified by node n. Note that if n.lhs has a dereference, lhs-rc-locgairs \nis initially 4. Oth- erwise, it is initially ((empty, empty), n.lhs). Consider the following example. \nLet n.lhs be p+jl. A rdje ((rc, (z, y))) can imply a new lhs-P-c-lot-pair if and only if x is p. Thus \nif the on top solution for this assignment was ((empty, empty), (P, 0) (( (Pinit eq Pinit),emPQ?/), (P, \nPiait)) ((ew%, empty), (4, m)) If n.lhs does not have dereference (i.e., n.lhs is a vari-able name p), \nthen lhs_rc_loc_poirs contains a single ele-ment ((empty, empty), p) and new_lhs_rc_loc_pairs is always \nI$. rhs-rc-lot-pairs is very similar to lhs-rc-lot-pairs except it is for n.rhs (i.e., the set of pairs \nof relevant contexts and objects that are values of n.rhs). pot-aliases computes djelms that need to \nbe generated due to potential aliases. pot_non_aliases computes djelms that need to be generated due \nto potential non-aliases. The ijstatement at program point 3 checks if rdje is killed by node n. kills \nreturns true if rdje represents the value of a pointer variable and n directly updates this pointer variable. \nIf n does not directly kill rdje, there are two cases: The assignment kills rdje if certain unknown initial \nvalues are not distinct. Consider when n.lhs is of the form p+jl, rdje represents the value of fl field \nof an unknown initial value s and p can point to a loca-tion that can be the concrete value of s (i.e., \nif p is of type A*, A and the type of s are compatible). In this case, pot-non-aliases is called to generate \ndjelms that condition the propagation of rdje across n on potential non-aliases. These djelms require \nthat s is not equal to any of the unknown initial values that are compatible with s and to which p currently \npoints. If p points to an object that cannot be same as s, rdje is propagated unconditionally across \nn. n.lhs cannot update the location whose value rdje rep-resents. In this case, rdje is propagated across \nn uncon- ditionally. Here RCI makes conservative assumptions about heap-names. Since, a heap-name can \nrepresent more than one run-time object, RCI propagates rdje unconditionally across n if rdje represents \nthe value of a field of a heap-name. B Complexity of RCI In the following example, at program point s, \npn points to an exponential number of unknown initial values. class Al { void method( Al *a) { public: \nA2 *fl ; A1 ~1; public: A2 *fz; . . . ); Ai *pii . . . . . . class Ai { An *pm; public: A;+1 *fl; Pl \n= a; public: Ai+l *fi; if (J p2 = pl+fr ; 1; else pz = Pl-+hi . . . . . . class A,_1 { if (-) Pi = Pi-l+fl \n; public: A, *fl; else pi = pi_1--*fz; public: A, *fi; . . . if (-1 p, = p,-1 +fr ; class A, { }; else \npn = Pn-l+f2; ); S: 1 apply( rdfe, n ) { // rdfe = (rc, (z, y)) is a new dfelm kills( n, rdfe ) { // \nreaching the pointer assignment node n. // rdfa = (rc, (5 y)) if (n.lhs does not have dereference) { \noldlhszc_loc_pairs = lhsrclocpairs; if (3: and n.lhs are the seme variable) oldlhsrcloc-pairs = rhszclocpairs; \nreturn true; ) nev-lhsrc_loc_pairs = return false; new rclocpairs for lhs implied by rdfe; I newlhsrcloc-pairs \n= can_update( x, n ) { new rclocpairs for rhs implied by rdfe; if (n.lhs does not have dereference) return \nfalse; lhsrclocpairs = oldlhsrcloc-pairs U newlhsrc-loc-pairs; // else say n.lhs is p-+fl and p is of \ntype A + if (z is s.fl and s is an unknown initial value whose rhsxcloc_pairs = type is compatible with \nA) oldrhsrcloc-pairs U newrhsrcloc-pairs; rdturn true; else neo_generateddfes = 4; return false; // folloving \nloop is executed only if n.lhs ) // has dereference. Otherwise neolhsrc_loc_pairs // is 4. pot-aliases( \ndfes, n ) { 1: for (each (~1, u) in neolhszcloc-pairs) { if (n.lhs does not have dereference) if (71 \n!= null) { return 4; for (each (rc.2, v) in rhs-rclocpairs) { rc3 = rcl and ret; // else say n.lhs is \np-+fl rc4 = impose user defined bounds on ~3; generateddfespa = 4; // assuming n.lhs is of the form p+fi \nfor (each dfe (~1, (a.ff, y)) in dfes) { nea_dfe = (9x4, (u.fl, v)); if (21 is an unknown initial value \n) { nevgenerateddfes U (newdfe}; for (each z,ff such that t is an unknown initial value compatible with \nu and zfl has been found ) to be used) { 1 1 ~c.2= xl and (z eq u); TCJ = impose user defined bounds \non TC~;  2: for (each (rc.2, v) in new-rhsrclocpairs) { nerr_dfe = (TcJ, (zfl, y)); for (each (rcl, \na) in oldlhszclocpairs) { generateddfes_pa U {newdfe}; if (u != null) { 1 TCJ = rcl and rc.2; 1 7~4 \n= impose user defined bounds on rc3; 1 if (n.lhs has dereference) return generateddfespa; // assuming \nn.lhs is of the form p+fi ) nerr_dfe = (rc4, (u.fI, 9~)); else potnonaliases( rc_loc_pairs, dfes, n \n) { new-dfe = (024, (u, if (n.lhs does not have dereference) newgenerateddfes U return 4; 1 // else \nsay n.lhs is p-f1 and p is of type A + I generateddfespna = 4; 1 for (each dfe (~cl,(u,fl, y)) in dfes \nsuch that u is a newgenerateddfes = nevgenerateddfes U unknown initial value whose type is compatible \nwith A) { pot-aliases(nevgenerateddfes, n); for (each (~2, v) in rcloopairs) { if (v is an unknown initial \nvalue compatible with u) { neogenerateddfes = nesgenerateddfes U if (v != n) { pot_non_aliases(newlhsrclocpairs, \nn. sol, n); TCJ = rcl and TC% and (u neq v); rc4 = impose user defined bounds on TCJ; 3: if ( !kills(n, \nrdfe) ) { newdfe = (rd. (u.fi, ?I)): if (can_update(x,n)) { generateddf&#38;&#38; nevgenerateddfes = \nneogenerateddfes U 1 potnon_aliases(lhsxclocpairs. {rdfe}, n); 1 1 else { else { generateddfes-pna U \nnevgenerateddfes U {rdfe}; 1 1 ) 1 1 return generateddfes-pna; return newgenerateddfes; 1 1 Figure \n5: apply2 Figure 4: apply1    \n\t\t\t", "proc_id": "292540", "abstract": "", "authors": [{"name": "Ramkrishna Chatterjee", "author_profile_id": "81100050772", "affiliation": "Department of Computer Science, Rutgers, The State University of NJ, 110 Frelinghuysen Road, Piscataway NJ", "person_id": "P238875", "email_address": "", "orcid_id": ""}, {"name": "Barbara G. Ryder", "author_profile_id": "81100632248", "affiliation": "Department of Computer Science, Rutgers, The State University of NJ, 110 Frelinghuysen Road, Piscataway NJ", "person_id": "PP14217204", "email_address": "", "orcid_id": ""}, {"name": "William A. Landi", "author_profile_id": "81452618010", "affiliation": "Siemens Corporate Research, Inc., 755 College Road East, Princeton NJ", "person_id": "P299387", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/292540.292554", "year": "1999", "article_id": "292554", "conference": "POPL", "title": "Relevant context inference", "url": "http://dl.acm.org/citation.cfm?id=292554"}