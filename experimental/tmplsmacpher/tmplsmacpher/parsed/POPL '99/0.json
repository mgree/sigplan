{"article_publication_date": "01-01-1999", "fulltext": "\n AnnoDomini: From Type Theory to Year 2000 Conversion Tool Peter Harry Eidorff Fritz Henglein Christian \nMossin Henning Niss Morten Heine Sprrensen Mads Tofte Dept of Computer Science, Univ. of Copenhagen (DIKU) \nand Hafnium ApS Email: {phei,henglein.mossin,hniss,rambo,totte}Odiku.dk WWW:http://www.diku.dk, http://www.hafnium.com \nAbstract AnnoDomini is a source-to-source conversion tool for mak-ing COBOL programs Year 2000 compliant. \nIt is techni-cally and conceptually built upon type-theoretic techniques and methods: type-based specification, \nprogram analysis by type inference and type-directed transformation. These are combined into an integrated \nsoftware reengineering tool and method for finding and fixing Year 2000 problems. Ann-oDomini s primary \ngoals have been flexibility (support for multiple year representations), completeness (identifying all \npotential Year 2000 problems), correctness (correct fixes for Year 2000 problems) and a high degree of \nsafe automation in all phases (declarative specification of conversions, no second-guessing or dangerous \nheuristics). In this paper we present the type-theoretic foundations of AnnoDomini: type system, type \ninference, unification the-ory, semantic soundness, and correctness of conversion. We also describe how \nthese foundations have been applied and extended to a common COBOL mainframe dialect, and how AnnoDomini \nis packaged with graphical user interface and syntax-sensitive editor into a commercially available soft-ware \ntool. 1 Introduction 1.1 The Year 2000 Problem The Year 2000 (MK) Problem refers to the inability of \nsoft- ware and hardware systems to process dates in the 21st cen-tury correctly. The problem arises from \nrepresenting calen-dars years by their last two digits and thus restricting range of representable years \nto 1900-1999 A.D.. Starting some 40 years ago, this convention was established as one of numer-ous techniques \nfor conserving precious memory space and has evolved into a de facto standard for representing and exchanging \ndates containing years. The most widespread Year-&#38;OOO-unsafe date representa-tion consists of six \ncharacters. It has two characters each for the day of the month, the month of the year, and the calen-dar \nyear, often in the order year-month-day (YYMMDD). The string 981106 , for example, represents November \n6th, 1998, The problem, of course, is that no provision is made for representing years in the 21st century: \n00 represents 1900 A.D., not 2000 A.D.. We adopt the popular convention of viewing the year 2000 A.D. \naa belonging to the 21st century. The Y2K Problem affects countless systems at all lev-els: embedded \nsystems, operating systems, applications and data bases that process or contain dates. Both its size \nand consequences are staggering. Cost estimates vary widely, but most of them predict global direct and \nindirect costs on the order of US$lOO, 000, 000, 000. Capers Jones writes that the costs of fixing the \nyear 2000 problem appear to consti-tute the most expensive single problem in human history [Jon98]p. \nxxiii. 1.2 Remediation Depending on consequential and repair costs, systems can be put into one of three \ncategories: Remediate. Systems that can be and need to be fixed, or systems that are too expensive or \ndifficult to replace by the Year 2000. Replace. Systems that either cannot be fixed or where fix-ing \nwould be too expensive. Ignore. Systems that need not be fixed, either because they are Y2K-safe or because \nthey are not used, useless, dispensible or have little impact. Y2K repairs ( remediation ) usually involve \na combina-tion of (date field) expansion and masking. Expansion refers to expanding unsafe a-digit years \nto I-digit years in appli-cations, data bases, files, etc., ideally as part of adopting a standardized \ndate representation (e.g. IS0 8601). Expan-sion can be expensive, however: it requires that not only \nap-plication programs be changed, but also data bases, files and all other programs communicating dates. \nMasking denotes a variety of methods for extending a-byte year representa-tions into the 21st Century; \ne.g. windowing, compression and encapsulation. These techniques aim at extending the lifetime of existing \ndata in data bases and files as well as screen and print maps into the 21st Century. In windowing, for \nexample, a pivot year determines whether a two-digit year belongs to the 20th or the 21st century. For \nexample, with pivot 50, 59 represents 1959 A.D. and 41 represents 2041 A.D..  1.3 The AnnoDomini Approach \nAnnoDomini2 is a method and tool for making COBOL pro-grams Year 2000 compliant by source-to-source transforma-tion. \nIt processes one program at a time and allows for in-cremental conversion and testing of large applications. \nThe AnnoDomini is a registered trademark of Hafnium ApS. converted programs do not require special compiler \nsupport, but compile and execute in their existing operating environ- ment . In COBOL programs, dates \nare represented using the data types and operations of the source language: numbers, strings of characters \nand flat records. Their intensional in-terpretation as representations of dates is not explicit. The \nAnnoDomini approach is based on reverse engineering the programmer-intended year interpretations as abstract \ntypes. This is done in three conceptual phases: seeding, type check- ing, and conversion. 1.3.1 Seeding \nIn the first phase the user seeds the program with year (and possibly nonyear) information about some \nof its variables, inputs and outputs; that is, they are annotated with Qpe System 2000 (TS2K) types that \nspecify where years occur in them, if at all. TSZK types are concatenations of WW (two-digit, win-dowed \nyear), YYYY (four-digit year), N (single nonyear char- acter) and crcn) (type variable denoting an unknown \nTSBK type with n characters). Annotations are special COBOL comment lines starting with +TSPK in column \n7. For exam- ple, *TSZK WWNNNN 01 DATA-l PIC XXXXXX.  is an annotation that says that the six-character \nvariable DATA-l contains a windowed year in its first two bytes. Seed-ing can be done automatically or \nmanually. Automatic seeding works by scanning variable names in a program, including all the libraries \nit imports, and looking for matches according to both lexical and data description criteria. Informally, \nfor each program variable the user asks: Could this variable contain a calendar year, based on its name \nand its data description? For example, a variable named DEP-DAT and occupying 6 bytes, might represent \na B-digit date ( departure date ). Then again, it might not ( deposition data ). Automatic seeding is \nspecified by a combination of lexical inclusion and exclusion criteria and a list of target date types. \nThese specifications can be config- ured interactively, and they can be stored in separate files for \nfuture use. Automatic seeding is known to be quick, but also error-prone since it depends exclusively \non nomen- clature for variable names. AnnoDomini presents a list of all matches along with annotation \nsuggestions, but does not automatically accept the results as bona-fide year annota- tions. Instead, \nit expects the user to explicitly accept or reject them, possibly after inspecting the variable declara-tions \nthrough a point-and-click interface. Manual seeding works by systematically checking the in- terfaces \nof a program; e.g., data base, file, terminal and print map descriptions, In COBOL, these are typically \nlo-calized in shared libraries that are copied into programs by COPY statements, COBOL s macro expansion \nand source li-brary access mechanism. Manual seeding is less error-prone since it reduces guesswork. \nSince data base, file, and map descriptions need to be annotated only once, but are typi- cally used \nby multiple programs, manual seeding need not be done for each program and is thus often a quite efficient \nand safe seeding method. 1.3.2 Type checking In the second phase AnnoDomini propagates the seeding in- \nformation to other data by type inference. For example, if the program contains the MOVE statement *TS2K \nWWNNNN 01 DATE-l PIC XXXXXX. 01 DATE-2 PIC XXXXXX. MOVE DATE-2 TO DATE-i the type of DATE-l is propagated \nto DATE-2, and AnnoDo- mini suggests that DATE-2 be given the same type. During propagation AnnoDomini \nalso checks that the seeded and propagated types are consistentwith each other. For example, in *TSZK \nWWNNNN 01 DATE-l PIC XXXXXX. *TS2K YYYYNNNN 01 DATE-2 PIC XXXXXXXX. MOVE DATE-2 TO DATE-l DATE-l and \nDATE-2 have different TSZK types (DATE-2 has a four-digit year in its first four bytes), and AnnoDomini \nsignals an error. In general, type errors may signal: Seeding error. Seeding might be wrong; e.g., for \nDATE-l, DATE-2 above or even another variable whose type has been propagated to DATE-l or DATE-2. Not \na Year 2000 problem. The type system does not allow both years and and nonyears to occupy the same storage \nat different times, such as when printing both years and nonyears through the same print buffer. Year \n2000 Problem. The error might signal a Year 2000 Problem or other questionable computations on dates. \nAnnoDomini does not attempt to guess what the real cause of a type error is and how to eliminate it. \nIt suggests a num- ber of plausible corrective actions, however. In the example above, for the first \ncase it suggests changing either the type annotation for the declaration of DATE-i or DATE-2. For the \nsecond case it suggests annotating the MOVE statement with an ASSUME annotation; e.g., *TSSK ASSUME DATE-2 \nIS WWNNNNNN MOVE DATE-2 TO DATE-l The ASSUME annotation tells the type checker that X should be treated \nas having type WWNNNNNN in this statement only. (This is dangerous, of course, and therefore requires \nan ez-plicit annotation in the source code.) Finally, for the third case it suggests specifying a coercion; \ne.g., . BY D4T02N4 TS2K COERCE DATE-2 TO WWNNNN MOVE DATE-2 TO DATE-l. The coercion D4T02N4 converts \nan eight-digit value start-ing with an four-digit year to a value with the same year in windowed representation, \nfollowed by the four nonyear bytes. The coercion is specified as an annotation -the actual conversion \ncode is inserted fully automatically in the conversion phase. AnnoDomini also provides point-and-click \naccess to the MOVE statement causing the type error and to the declarations of the variables DATE-i \nand DATE-2 oc- curring in it for manual browsing and editing of the source code. AnnoDomini issues warnings \nfor all relational and arith-metic operations for which there is insufficient type infor-mation to determine \nwhether their operands contain years or not. This is a case where seeding is incomplete, with potentially \ndangerous consequences. The user is expected to check the warnings to determine whether they cover over \nany potential Year 2000 problems. They can also be elim- inated by strengthening the seeding to resolve \nthe operand types. Phases 1 and 2 are repeated, possibly interchangeably, until all type errors are eliminated \nand the program is type correct. 1.3.3 Conversion The third and final phase consists of virtual conversion \nand actual conversion. During virtual conversion the user spec-ifies Year-2000-safe types for each variable. \nFor example . -> TS2K WWNNNN YYYYNNNN 01 DATE-l PIC XXXXXX. specifies that the variable DATE-l should \nbe expanded from a six-digit to an eight-digit date representation. Each variable can have its own year \nrepresentation. AnnoDomini has built-in support for four-digit years, de-noted by YYYY, and fixed windowed \ntwo-digit years, WW.3 Apart from YYYY and WW, it allows abstract, user-defined two-digit years. These \nare denoted AA(t), where t is the name of a user-defined library, which must contain the re-quired arithmetic \nand relational operations. These can be type-checked on a par with the built-in year types. Finally, \nactual conversion is fully automatic: at the push of a button, data declarations are expanded as desired, \ncalls to the specified coercions are inserted, and arithmetic and relational operations involving two-digit \nyears are replaced by calls to Year-2000-safe library routines. 1.4 Related Work There is a vast literature \non type theory and type-based program analysis. There are also numerous Year 2000 tools. Very few of \nthose are semantics-based, however, and of those only AnnoDomini appears to be type-based with integrated \nautomatic analysis and conversion. The value of working with type notions in software un-derstanding \nand reengineering has been observed previously by O Callahan and Jackson [OJ97]. Van Deursen and Moo-nen \n[vDM98] describe type inference rules for COBOL for classifying data into sets of data representations. \nSubtyping is interpreted as subsumption of value sets. Their system specifies type equivalences, and \nit allows subtyping steps at assignments. Intuitively, this specifies a flow-insensitive data flow analysis, \nrefined by data flow sensitivity at assign- ments. The unification theory described in Section 3.2 is \na spe- cial and feasible case of associative unification (word unifica- tion, solving of word equations) \n[AP89] that, however, does not seem to have been treated in the literature before. Inde-pendently of \nus, Ramalingam, Field and Tip have developed Year 2000 unsafe years in the range 1900-1999 are considered \na special case of windowed years with pivot 00. prog ::= dec stmt dec ::= e 1 dec dn: elem r 1 dec dn: \ngroup(dec) stmt ::= E 1 stmt stmt PERFORMstmt UNTIL condexp I I MOVEsender TO receiver IF condexp stmt \nELSE stmt ENDIF I exp ::= lit 1 pqdn 1 assume exp is T coerce exp by c I exp binop exp I sender ::= \nexp I padl~,,,)(evcp) I padr(,,,)(ev:p) I takel(,,,)(exp) I taker(,,,)(ewcp) receiver ::= pqdn I assume \nreceiver is r pqdn ::= dn I dn IN pqdn binop ::= +WN I +NW I +YN 1 +NY 1 +NN ..- 7 ..-v I 7-7 I e ..- \n 71 ..-WWl YYYY ] N ( cr+) condexp ::= exp relop exp relop ::= WW I YY 1 NN Figure 1: Grammar for COBOLsooo. \nbasically the same unification algorithm [RFT99] as ours in Section 3.2. They also demonstrate how their \nanalysis is applicable to Year 2000 program analysis. 1.5 Outline In the remainder of the paper we first \npresent the core theory of AnnoDomini: a skeletal language (Section 2), type sys-tem and type inference \n(Section 3), dynamic semantics and soundness (Section 4), and safety of expansion (Section 5). Then we \ndescribe how salient features of a full COBOL di-alect are treated (Section S), and we briefly describe \nthe system architecture of AnnoDomini (Section 7). Finally we discuss the potential of applying the general \nprinciples em-bedded in AnnoDomini as a general software reengineering methodology (Section 8). 2 A Skeletal \nLanguage Our skeletal language is called COBOLseoe. While much simplifed, compared to full COBOL, it \ncontains some of the key ingredients of COBOL, including moves involving padding and truncation of data. \nWe assume a set Lit of (decimal) numeric literals, ranged over by lit; a set Dn of data names, ranged \nover dq4 for each natural number n 2 1, a set TyVar( ) of type variables of size n, ranged over by czln); \nand a set C of coercion names, ranged over by c. TyVar = Ur,r TyVar( ). The grammar for COBOLxooc appears \nin Figure 1; an example program appears in Figure 2. A program (prog) consists of a declaration (dec) \nfollowed by a statement (stmt). A declaration can be empty (c), or a declaration followed by a declaration \nof an elementary item 4The COBOL term data name corresponds to variable in other programming languages. \n YRl : elem WW annotate the arithmetic operators (and we only have one)YR2: elem WW by type information. \nSimilarly for relational operators. MYDATE : elem WWNNNN The assume and coerce constructs represent AnnoDo-LONGDATE: \ngroupf mini s *TS2K annotations ASSUME and COERCE, respectively.YEAR: elem YYYY We impose the monoid \nlaws on types: er = re and MONTH: elem NN (Tl72) 73 = ~1 (~3 73). Thus every type can be written in DAY: \nelem NN) the form ~1 . . . qke, k 2 0. we write r(n) to mean r-.-r, (nBUF: elem NC801 times). The size \nof a type is defined inductively as follows: MOVE assume 94 is WWTO YR1 COMPUTE YR2 = YRI +WN 10 size(q) \n= size(r) = PERFORM case q of case 7 of COMPUTEYRl = YRl +UN i ww* 2 e*O UNTIL YR2 <ww YRl 1 YYYY* 4 \nI 117 * MOVE assue 940203 is WWN(4) TO MYDATE size(v) + size(+) MOVE coerce MYDATE by D2T04N4 TO LONGDATE \nIF YEAR IN LONGDATE <YY assume 2000 is YYYY MOVE padr(,,,z)(assume LONCDATEis N(8)) TO BUF ELSE MOVE \npadl(,,,) (5) TO DAY IN LONGDATE 3 Type System 2000 ENDIF COBOLzeee has two kinds of data items: numetic \nelemen-tary items and group items: Figure 2: A COBOLZOOO program k E Kind = {e, g} or a group item. \nIn COBOLzeac, all elementary items are numeric. A statement can be empty (e) or the sequen-tial composition \nof two statements. Next, PERFORMstmt UNTIL wndexp corresponds roughly to repeat stmt until condexp in \nother languages. MOVE TO receiver sender moves the value of sender to receiver. A sender may be an ex-pression \nor a padded or truncated expression. The sender padl(,,,)(exp) can only be used when ezp is an elemen- \ntary item; it pads the value of exp with n leading zeros. The sender padr(,,,) (ezp) can only be used \nwhen exp is a group item; it pads the value of exp with m trailing zeros.7 The sender takel(,,,) (exp) \ncan only be used when exp is a group item; it extracts the leftmost n digits of the value of exp. The \nsender taker(,,,)(exp) can only be used when exp is an elementary item; it extracts the rightmost m digits \nof the value of exp. Padding and truncation are implicit in COBOL, but it simplifies the formal treatment \nto make them explicit. The front end of a COBOL compiler can insert padding and trun-cation operations. \nInspired by COBOL syntax, we write COMPUTEreceiver = sender for MOVE sender TO receiver, when sender \nis an arithmetic expressions A perhaps qualified data name (pqdn) is either an unqual- ified data name \ndn or a qualified data name (dn INpqdn). In the latter case, pqdn must denote a group item and dn a data \nname declared in that group item. In AnnoDomini, addition and subtraction are overloaded. Overloading \nis resolved using an overloading scheme simi-lar to the one used in some Standard ML compilers. For the \npurpose of the present paper, however, we assume that overloading has already been resolved, so in COBOLzeee \nwe The COBOL term group item corresponds to the term record in other programming languages. COBOL allows \nseveral other kinds of elementary items. In COBOL group items are regarded as alphanumeric data and \npadding is with spaces, but since COBOLzooo has only numeric ele-mentary items, we pad with zeroa. In \nCOBOL, the two statements are not generally equivalent, not even when both are syntactically correct. \nWe assume a function, TypeOf, from coercion names to function types, which must all be monotypes. (A \nfunction type is a type of form r + r , and a monotype is a type that contains no type variables.) We \ndefine environment types (a) and type environments (TE) as follows: u ::= r 1 TE TE ::= e ) TE,dn:a \nIntuitively, a type environment is a finite map from (un-qualified) data names to environment types. \nIt maps data names that denote elementary items to types and it maps data names that denote group items \nto type environments. Whenever A is a type or an object constructed out of types (e.g., a type environment), \nwe write tyvars(A) for the set of type variables that occur in A. We define a function flat from type \nenvironments to types as follows: flat(TE) = case TE of e=%e 1TE, dn : T =S flat(TE) r I TE, dn : TE \n=S flat(TE) flat(TE ) The type inference rules appear below. The turnstile (I-) is overloaded on different \nsyntactic categories. There is a small number of inference rules (usually one) for each pro-duction in \nthe grammar of COBOLzeec. Rules in which the premise appears to be identical to the conclusion stem from \nproductions where the right-hand side consists of a single non-terminal. Perhaps Qualified Data Names \nITEI-pqdn:ol TE I- dn : u dn # dn (1) TE, dn : u l- dn : u (2) TE, dn : u I- dn : u TE I- pqdn : TE \nTE I- dn : CT (3)TE I- dn IN pqdn : u Expressions [TE[ r = N(size( lit)) (4)TE I- lit : r :: e (5) TE1 \nI- pqdn : TE2 ( 5) TEI I- pqdn : flat(TE2) :: g TE I- exp : T :: k size(T) = size(#) (7)TE I- assume \nexp is r : r :: k TE k exp : T :: k TypeOf = 7 --t f (8) TE I- coerce exp by c : r :: e TE I- expl : \n71 :: e TE I- exp2 : 72 :: e ~1~72 I-binop : ~3 TE I- expl binop exp2 : 73 :: e (9) Sending item TE \nI- sender : r TEI-exp:::::k (10) TE I- exp : r TEI-expcp::::e size(#) = n size(T) = m (11) TE t- padl(,,,) \n(exp) : T T TEI-exp::::g size(T) = n size(+) = m 02) TE I- padr(,,,)(exp) : TT TEI-exp:r::g 7 = TITr \nsize(n) = n size(r7) = m TE I- takelt,,,)(exp) : TI (13) TEI-exp::::e T = ~7~ size(n) = n size(r,) = \nm TE I- taker(,,,)(exp) : T? (14) Receivers TE I- receiver : r TE I- pqdn : r (15) TE I- pqdn : r 5 \nTE I- pqdn : TE (16) TE I- pqdn : flat(TE) TE I- receiver : 7 size(T) = size(#) (17) TE I- asauna receiver \nis r : r -1Statements TE I- sender : r TE I- receiver : r (18) TE I- MOVE sender TO receiver TE I- wndexp \nTE I- stmtl TE I- stmtz (19) TE I- IF condexp stmtl ELSE stmtz ENDIF TE I- stmt TE I- condexp (20) \nTE I- PERFORMstmt UNTIL condexp (21) TE I- e TE I- stmtl TE I- stmta (22) TE I- stmtl stmtz Declarations \n[dee] (23) I--e:e I-dec : TE (24) I- dec dn: elem r : TE, dn : r t-decl : TE1 I- decz : TE2 (25) I- \ndecl dn: group(dec2) : TE1, dn : TE2 Programs FJ I-dec : TE TE I- stmt (26) I- dec stmt Binary Operators \n-binOp (27) W,N(i) I- +w : WW (28) YYYY, N(i) I- +YN : YYYY (29) N(i),N(j) I- +NN : N(l + max(i,j)) (30) \nN(i), w b +NW : ifw (31) N(i), YYYY i- +Ny : YYYY Conditional Expressions 1TE I- condexp 1 TEI- expI \n: 71 :: e TE I- exp2 : ~2 :: e 71,~ F relop TE I- expcp, relop exp2 (32) Relational Operators 1~1~~2 \nI- relop 1 (33) ww,uw I- <w (34) YYYY, YYYY I- <yy (35) N(i),N(j) f- NN Rules l-3 describe how perhaps \nqualified data names are looked up in the type environment. In rule 3, the first premise expresses that \np&#38;z must be bound to a type en-vironment (TE ), i.e., it must denote a group item, and the second \npremise expresses that dn must be declared in this group item. The rules for expressions (4-9) allow \none to infer state-ments of the form TE I- exp : r :: k, read: in TE, exp has type 7 of kind k. The kind \ndetermines how the value of exp may be padded, as explained later. In rule 4, we use the notation size(lit), \nby which we mean the number of (decimal) digits in it, including any leading zeros. Rule 5 gives kind \ne to elementary items, while rule 6 gives kind g to group items. Rule 7 shows that applying assume to \nan expression makes it possible to change the type of the expression to any other type with the same \nsize; the kind is preserved. Rule 8 shows that coerce can be applied to an expression of either kind \n(elementary or group). Somewhat arbitrarily, we say that the result is always an elementary item. Rule \n9 concerns binary operators; the relation ~1, ~2 I- binop : 7 holds if 71 and 72 are legal types of the \nleft and right arguments of binop, respectively, and r is the type of the result of applying binop, see \nrules 27-31. The rules for senders (10-14) allow one to infer state-ments of the form TE I- sender : \nT, read: in TE, sender has type 7. Note that the sender does not have a kind; expres-sions have a kind, \nhowever, and this kind is used for deter-mining how the expression can be padded in order to con-struct \na sender. Rule 10 is the case where the expression is neither padded nor truncated; the kind is simply \ndiscarded. Rule 11 concerns the case where a value is padded with n zeros on the left; note that the \nexpression must have kind e, but the zeros may be given any type of size n (including types involving \nyears). Padding on the right (rule 12) requires group kind; trun-cation which discards rightmost digits \nrequires group kind (rule 13); and truncation which discards leftmost digits re-quires kind e (rule 14). \nThe identifier which is assigned a value in the MOVE state-ment is called a receiver. Receivers are typed \nmuch like perhaps qualified data names in expressions, except that no kind is needed (rules 15-17). In \nrule 18, notice that the sender and the receiver must have exactly the same type. The sender must be \npadded or truncated, if necessary, to achieve this. The rules for binary operators (27-31) impose a certain \ndiscipline on the use of arithmetic. Assume, for example, that MYYEAR MYDATE have types WW and respec- \nand WWNNNN, tively. Then COMPUTEMYYEAR= MYYEAR + 1 is well-typed, but COMPUTE = (a COBOL MYDATE MYDATE+iOOOO \ncommon idiom!) is not. Similarly, LONCDATE: group( YEAR: YYYY MONTH: NN DAY : NN) SHORTDATE: WWNNNN MOVE \nLONGDATE TO SHORTDATE is not well-typed, although COBOL permits it: the types YYYYNNNNand WWNNNNare not \nequal, not even after any padding or truncation (compare rule 18). Instead, Type System 2000 provides \ncoercions for conversions between dif-ferent date formats. In Figure 2, D2T04N4 is a coercion of type \nWWNNNN YYYYNNNN. + Rules 33-35 show a rather limited set of comparisons. AnnoDomini supports a wider \nrange, including, for example comparison on types WWNNNN. An expression is well-typed in TE, if there \nexists a type r and a kind k such that TE I- exp : r :: k. Well-typedness of other phrase forms in a \ntype environment is defined sim-ilarly. 3.1 Type Checking By type checking we mean using an algorithm, \ncalled the type checker, which checks, given a type environment and a phrase, whether there exists a \nsubstitution instance of the type environment in which the phrase is well-typed. As is the case with \nStandard ML, type checking is based on unification [Mi178, DM82]. However, because our types obey the \nmonoid laws and because type variables have sizes associated with them, ordinary term unification is \nnot a suf- ficient base for type checking in COBOLzoos. We there-fore develop a different unification \nalgorithm and prove that there exists a form of most general unifier in this setting. The fact that types \nhave known sizes are essential for this result, which appears to be new.g 3.2 Unification A substitution \nis a map S from type variables to types sat-isfying VnVd ) E TyVar( ). size(S(a )) = n The support of \nS, written Supp(S), is the set Supp(S) = U,tr{cP 1 S(P) # ce} The yield of S, written Yield(S), is defined \nby Yield(S) = U{tyvars(S(cr( ))) 1 acn) E Supp(S)} It turns out that Ramalingam, Field, and Tip independently \nhave developed essentially the same algorithm, see elsewhere in these pro- ceedings. Further, the set \nof type variables involved in S, written Inv(S) is defined by Inv(S) = Supp(S) U Yield(S) By natural \nextension, substitutions may be applied to types and to objects constructed out of types (for example \npro- grams). Substitution preserves equality: if two types ri and rz are equal under the monoid laws, \nthen S(ri) and S(rz) are also equal under the monoid laws. Substitution pre- verves size: Lemma 3.1 Fz;w;{l \nq~and 7, size(S(7)) = size(q) and size(S(r)) = Substitutions compose: (S~oSi)(c&#38; )) = Sz(Si(c~(~))). \nNote that, by Lemma 3.1, the composition is a substitution. The identity substitution is denoted I. \n A unifier for types ri and 72 is a substitution S satisfying S(ri) = S(Q). A substitution S is a most \ngeneral unifier for 71 and ~2 if S*(ri) = S (Q) and for every unifier S for ri and 72 there exists an \n5 with S = S o S . Interestingly, not all pairs (71,~~) have a most general unifier. For example, let \n71 = or)@) and rz = @or). In order to unify these two types, without committing the two middle digits \nof the six digits to a monotype, we intro-duce a fresh type variable, say c$). Consider the natural candidate \nfor a most general unifier, namely S = ( 14) I+ f$)@, ($ I+ @ok } We have S*(ri) = cr~)c$)@ = S(Q), \nso S unifies ri and ~2. However, 5 is not a most general unifier. To see this, consider S = (~~14) c) \n@NN, cry c) NN@, c@ c) WW} Note that S is a unifier for 71 and 72; but there exists no S such that S \n= S o S (consider what crp should be mapped to); the best we can achieve is S J- U = (S o S*) 1 U, where \nU is a set of type variables satisfying of) $ U. (We write S .J U for the restriction of S to U.) To \nmake this precise, we introduce a notion called U-unification. We use U to range over finite subsets \nof TyVar. (U stands for used .) A substitution S is a most gen-eral U-unifier for ~1 and 72, if tyvars(ri) \nU tyvars(rz) c U; s (~1) = S (72); and for all substitutions S, if S(ri) = S(Q) then there is a substitution \nS with S J- U = (S o S ) .J. U. We now present a unification algorithm and a theorem to the effect that \nthe algorithm finds most general U-unifiers. The algorithm either raises an exception, FAIL, or re-turns \na substitution. It uses two auxiliary functions: fun unify,(qi,qz) = (* size(qi) = size(gz) *) case (711,~2) \nof (cp, _) =k-{al ) H 72) I (-,cp) * {&#38; c-) 171) 1 (_, _) =S if ~1 = 712 then I else raise FAIL. \n fun splitl(v, i, U) = (* 0 < i < size(n) *) case n of ocn) =+ let of), &#38; - ) be distinct type variables \nnot in U in ({aCn) +j Gus- )}, {a,), apmi)}) end 1 _ + raise FAIL  The unification algorithm relies \non the fact that every type can be written in the form 71 . . . nkc, (Ic 2 0). The algorithm is: fun \nunify(ri, ~2,U) = case (71, ~22)of (c, e) * (I, 0) I (~1~11,772~22) =9 if size(qi) = size(vz) then let \nSl = unify, (171,92) (572, UZ) = unify(Sl(nl), S1(722), U) in (Sz o Si , Uz) end else if size(vi) > \nsize(q2) then let (Si, Ul) = splitl(vi, size(vz), U) (572, UZ) = unify(Sil(T&#38; Sl(T2), U U Ul) in \n(Ss o Si, Ul U Uz) end else unify(r2, ~11) 1 _ + raise FAIL  Lemma 3.2 Assume size(ni) = size(nz). If \nthere exists a unifier for 71 and 5~2then S = unify,(~i,~z) succeeds and S is a most general unifier \nfor qi and 1,72.If there exists no unifier for q1 and 172, then unify,,(,) 72) raises FAIL. Theorem 3.1 \nAssume tyvars(ri) U tyvars(T2) C U. If there exists a unifier for 71 and 72 then (9, U ) = unify(ri, \n72, U) (36) succeeds and S*(T~) = S*(72), for any unifier So of ~1 and 72 there is an S with So J- U \n= (S o S ) J. U, Inv(S*) tyvars(Tl) U tyvars(rz) U U , and U rl U = 8. If there is no unifier for 71 \nand rz, then (36) raises FAIL. 3.3 A Type Checker We now present a type checker which is sound and complete \nfor the type inference rules in Section 3. The soundness relies on the following result: Lemma 3.3 A \nk phrase : B implies S(A) I- S(phrase) : S(B). For brevity, we show only the part of the type checker \nthat is necessary for type checking expressions and phrases that are part of expressions. (The remaining \nrules are treated analogously.) Concerning rules 1-3, let TE be a type envi-ronment and let y be a perhaps \nqualified data name. Note that there exists at most one u such that TE I- y : CT. Define lookup(TE, y) \nto be this u, if it exists, and let lookup(TE, y) terminate with FAIL otherwise. Next, rules 27-32 are \nchecked by the following function: BinOp(ri, 72, binop, U) = case binop of +WN + let (Sl, ul) = unify(rl,WW, \nU) (SZ, UZ) = unify(S1(7i),N(size(Tz)), U U Vi) in(SzoSi,~~,UiUUz)end 1 +yN =$ let (&#38;, &#38;) = unify(ri, \nYYYY, U) (S2,U2) = unify(Sl(Tz),N(size(Tz)),UUUl) in (Sz o Si,YYYY, Ul U U2) end I +NN * let (S1,Ul) \n= unify(Tl,N(size(Tl)), U) (SZ, UZ) = unify(Sl(Tz),N(size(Tz)), U U VI) in (SZ o SI, N(l + max(size(Tl), \nsize(T2)), VI U UZ) end I +NW =+ let (Si, VI) = unify(T1, N(size(Tl)), U) (SZ, UZ) = unify(Sl(Tz),WW, \nU U Ul) in(SzoSi,~~,UiUUz)end 1 +~y * let (&#38;, &#38;) = unify(Tl,N(size(Tl)), u) (SZ, UZ) = unify(&#38;(Tz),YYYY, \nU U VI) in (SZ 0 S1, YYYY, lJ1 U U2) end This algorithm satisfies the following soundness and com-pleteness \nproperties. Lemma 3.4 Assume that tyvars(rl, 72) C U and (S, 7, U ) = BinOp(rl, 72,binop, U) succeeds. \nThen S(71), S(72) I- binop : 7, Inv(S) C tywars(~l,~2) U U and unu =0. Lemma 3.5 Assume tyvars(Tl,Tz) \nC U. If there exist So and and ~0 such that So~l, So-r2 I- binop : TO (37) then (S, 7, U ) = BinOp(Tl, \n~2, binop, U) (38) succeeds and for every SO and TO satisfying (37) there exists an S such that So J- \nU = (SOS) 1 U and 70 = r. Moreover, if there is no So and ro satisfying (37), then (38) terminates with \nFAIL. The proof is by cases on binop using Theorem 3.1. The following functions check rules 4-9. (In \nthe last case, we assume that the function raises FAIL, if the pattern matching on e fails.) Exp(TE, \nexp, U) = caSe exp of lit =$ (I,N(size(lit)),e, 0) 1 pqdn + (case lookup(TE,pqdn) of 7 * VT.,e,0) I TE \n+ (I,flat(TE ),g,O)) 1 assume expl is r * let (SI, ~1, kl, Ul) = Exp(TE, expl, U) in if size(Tl) = size(r) \nthen (Sl, sl(~),IEl, S) else raise FAIL end I coerce expl by c + let (SI,TI,~I,UI) = Exp(TE, expl,U) \nin let TypeOf = 72 + 7; in let (S2,U2) = unify(Tl,Tz,UU Ul) in (572 oSl,S2(4),e,Ul UU2) end end end \nI expl binop exp2 + let (Sl, 71, e, Ul) = Exp(TE, expl, U) (S2,72,e,U2) = Exp(S1(TE),Sl(exp2),U U Ul) \n(&#38;,~a, Us) = BinOp(&#38;(71),72, binop, U U Ul U U2) in(S3o&#38;oS1,r3,e,UlUU2UU3) end The algorithm \nExp satisfies the following soundness and completeness properties: Theorem 3.2 Assume tyvars(TE) U tyvars(exp) \nC U. If (S, 7, k, U ) = Exp(TE, exp, U) succeeds then S(TE) I- S(exp) : T :: k, Inv(S) U tywars(r) c \ntywars(TE) U tywars(exp) U U , and U n U = 8. Theorem 3.3 Assume tyvars(TE) U tyvars(exp) E U. If there \nexist So, ro and ko satisfying So(TE) t- So(exp) : ~0 :: ko (39) then (S , T , k , U ) = Exp(TE, exp, \nU) (40) succeeds and for all So, ro and ko satisfying (39) there exists an S such that So 1 U = (S o \nS ) 1 U, S (r ) = 70 and ko = k . Moreover, if there is no So, TO and ko satisfying (39), then (40) terminates \nwith FAIL. The proofs are by induction on the structure of exp, using Lemmas 3.4, 3.5. 4 Dynamic Semantics \nand Soundness In this section we give a dynamic semantics for COBOL2000 and prove that the static semantics \nis sound with respect to the dynamic semantics. We use d to range over decimal digits. We distinguish \nbetween numerals (a) and numbers (a). A value, v, is a numeral, i.e., a sequence of digits. The size \nof a value a, written size(a), is the number of digits in a. O(n) denotes the sequence of n zeros. For \nevery value v and n 2 0 satisfying size(v) 5 n, we define fill(n, v) to be O(n -size(v))v. Evaluation \ncan fail. The semantics distinguishes between the following failures: Y2K (Year 2000 failure), Arith \n(arith-metic failure), and Wrong (other failure). A store (of size n) is a map from (0, . . . , n - 1) \nto digits. We use s to range over stores. We define extract(s,Z,u) to be the value s(~)...s(u -l), if \n0 5 I 5 2~ 5 size(s), and the failure Wrong otherwise. Further, we define update(s, I, LL, v) to be the \nstore s defined by s (i) = s(i) if 0 5 i < 1 or u 5 i < size(s) di-1 if 1 5 i < u provided 0 5 I 5 21 \n5 size(s) and v = do+.-d,-I-l; otherwise, we define update(s, 1, u, v) to be the failure Wrong. We define \n(dynamic) environments (E) and denotable values (dval) as follows: E ::= e I E, dn = dval dval ::= (E,l, \nu) where 1 and u range over non-negative integers. Intuitively, given store s, E(dn) = (E , 1, u) means \nthat dn represents the value s(l)...s(u -1). Further, E is empty, iff dn is an elementary item. The evaluation \nrelation takes the form A I- phrase =+ B, where A is an environment or a pair of an environment and a \nstore and B is a result, whose kind depends on the kind of phrase. An environment result (e) is either \na denotable value of Wrong. An expression result (r) is either a value, Y2K, Wrong, or Arith. A statement \nresult (t) is either a store, Y2K, Wrong, or Arith. In the evaluation of relational expressions, we use \nbooleans (true, false); a condition result (b) is either true, false, Wrong, Arith or Y2K. We assume \na function Apply with the following property: for all c, letting 7 -_) 7 = TypeOf( for all v, if size(r) \n= size(v) then Apply(c, v) either results in Y2K or in a value v of size 7 . Finally, initstore(z) denotes \na store of size z consisting of zeros only. The dynamic semantics is defined as a big step seman-tics, \nwith a small number of rules for each production in the grammar. The rules appear below. Many of the \nrules have associated with them one, two or three failure propagation rules, which describe that once \nthe evaluation of a phrase fails, the evaluation of the entire program fails. For example, rule 48 has \nthe following two associated failure rules: E I- pqdn =+ f (41) s,Ekpqdn+ f E I- pqdn =S (_, I, u) Wrong \n= extract(s, 1, U) (42) s, E k pqdn =S Wrong where f ranges over {Wrong, Y2K, Arith}. For brevity, we \nomit the failure propagation rules (although they are used in the proof of Theorem 4.1.) Perhaps Qualified \nData Names IEI-pqdn+eI (43) e I- pqdn + Wrong E I- dn =+ dval dn # dn (44) E, dn = dval l- dn + dval \n(45) E, dn = dval l- dn j dval E k pqdn =S (E , _, _) E I- dn =+ dval (46) E k dn IN pqdn =S dval Expressions \nIs,El-exp:prl (47) s, E t lit =F. lit E I- pqdn + (_, I, u) v = extra&#38;(+ 1, U) (48) s,El-pqdn=+v \ns,El-expcpv (49) s,Ekassume expiisr:v s, E I- exp =S v Apply(c, v) = v (50) s, E I- coerce exp by c : \nv s, E I- expl =S VI s, E I- exp2 =+ v2 211,212t-binop + v s, E k expcp, binop exp2 + v (51) Sending \nitem s, E t- sender + r s,E I- exp *v (52) s,El-expcpv s, E I- exp + v (53) s, E I- pac+,,)(exp) * O(n)v \ns, E I- exp =+ v (54) s, E I- padr(,,,)(exp) * v O(m) s,El-exp=+d~...d,d~...d~ (55) s, E i- takelc,,,)(exp) \n: dl . . . d, 3, E I- exp * dl . , . d,d; . . . dh (56) s t- taker(,,,)(exp) : di . . . dL, Receivers \n1E k receiver =+ (1, u)/Wrong 1 E I- pqdn =S (E , 1, u) (57) E I- pqdn + (1,~) E I- receiver =S (1, \nu) (58) E I- assume receiver is r =+ (1,~) Statements s.El-stmt+t s, E I- sender =s- v s, E I- receiver \n=+- (1,~) (59)8, E i- MOVEsender TO receiver + update(s, 1, u, v) s, E I- condexp * true s, E k stmtl \n+ s (SO)s, E t- IF condexp stmtl ELSEstmtz ENDIF =k 3 s, E I- condexp j false s, E I- stmt2 =+ s (61)s, \nE I- IF condexp stmtl ELSEstmtz ENDIF + s/ s, E I- condexp + true s, E k stmt =S s s , E I- PERFORMstmt \nUNTIL condexp =+ a (62)s, E k PERFORMstmt UNTILcondexp =k- s s, E I- condexp * false (63) s, E I- PERFORMstmt \nUNTILcondexp =S s (64) 3,El-C=+S s,Ekstmtl+-sl sl,El-stmt2*s2 (65) s, E I- stmtl stmtz, =+ 32 Declarations \nIIk dec+ E,zl (66) ll-e*e,O 4.1 Soundness 1 I- decl =+ El, ~1 I t- decl dn: elem r * El, dn = (E,1 + \nx1,1 + z1 + s&#38;(-r)), 21 + size(T) (67) 1 I-decl =+ El, z1 I+ 11 I- decz + Ez, .z2 1 I- decl dn: \ngroup(dec2) j El, dn = (Ez, I+ zl,l+ z1 + zz), a + z2 633) Programs 0 I- dec + E, z initstore(z), E \nk atmt * s (69)I- dec atmt =+ a Binary Operators Iv,1 a+b<99 a+b>99 (70) g,b t +WN + fill(2,a a,bk+WNjY2K \na + b 5 9999 a + b > 9999 (71) ~3,b k +yN + fill(4,&#38;) $,&#38;h t- +YN =S Arith i = 1 + max(size(a, \nb)) (72) a, b t- +NN + fill(i, a + b) a+b<99 a+b>99 (73) a, b b +NW =+ fill(2, a) a, b k +NW =+ Y2K a \n+ b 5 9999 a + b > 9999 (74) Conditional Expressions a, E I- condexp + b a, E I- expcp, =+ VI a, E I- \nexp2 + v2 v1,v2 I-relop * b a, E I- expcpl relop exp2 * b Relational Operators a<99bs99a<b a,b I- <WW \n=S true a 5 9999 b 5 9999 a < b a,hl-<fl *true a>99Vb>99 a,&#38;t- ww=$Y2K a<b ~3, b t <NN * true (75) \nIi, v I-relop + b 1 a<99b<99a>b (76) a, a I- <ww * false a 5 9999 b 5 9999 a 1 b (77) g, b t <yy * false \na > 9999 V b > 9999 (78) a,!! k <YY * Wrong a>b (7% a, b I- <NN 3 false A store typing, ST, is a sequence \nof triples satisfying 1. size(T;) = U; -li, for all i = 0.. .n; and 2. li=Ui-1,fOralli=1...n.  The \naddreaa apace of 5T, written addr(SZ ), is the interval {i 1 11 5 i < u,}. Given 1 and U, we define the \nrestriction of ST to (1, u) to be the subsequence which satisfies li = 1 and Ui+j = u, if one exists; \nfurther we define the store type of (ST,l,u), written sttyp(SZ ,l,u), to be ri...ri+j. We say that an \nenvironment E matches type environ-ment TE in ST, if ST + E : TE, where ST k E : TE is defined thus: \nStore Typing VI ST + E : TE sttyp(fl, 1, u) = T STj=e:c ST+E,dn=(e,l,u):TE,dn:r ST + ~~ : TEl ST k E2 \n: TE2 sttyp(fZ,l,u) = flat(TEz) ST+E1,dn=(E2,l,u):TE1,dn:TEz The following soundness theorem states that \nif an expres- sion is well-typed and is evaluated in an environment and a store that match the type environment, \nthen the result of the evaluation is not Wrong, although it may be a Year 2000 failure. Furthermore, \nif the result is not a failure, it is a value of the size predicted by the type system. Theorem 4.1 Zf \nTE I- exp : r :: k and 5T k E : TE and Dam(s) = addr(SZ ) and a, E !- exp * r then r is not Wrong (although \nit may be Y2K) and if r is a value v then size(v) = size(T). 5 Expansion In this section we formalize \ntransformations that fix Year 2000 problems using expansion and show that, informally speaking, all computations \nthat succeed using the original program will still succeed (with a related result) after expan- sion. \nA similar result is difficult to obtain for windowing, for as one moves a window, some Year 2000 problems \nare fixed while others may be introduced (because the new window does not represent all the years that \ncould be represented with the old window). To prove our result, we shall interpret WWas representing \nthe years 1900-1999 by their last two digits. Further, we consider only coercions which expand two-digit \nyears to four digit years (by adding 1900). Formally, we introduce type environments, written respectively, \nas the smallest satisfying: 1. ww 5 YYYY, a subtyping relation on types and 9 5 q , r 5 r, and TE 5 TE \n, reflexive and transitive relation 2. 71 5 ri and 72 5 r; implies rirz 5 7174; 3. TE < TE and r 5 r \nimplies TE, dn : T 5 TE , dn : T ; 4. TE1 5 TE: and TE2 5 TE , implies TE1, dn : TE2 5 TE;, dn : TE \n,;  A store expander is a finite map from store indices to store indices. (A store index is a non-negative \ninteger.) Let 5T and ST be store typings and let cp be a store expander. We say that ST expands ST via \ncp, if cp I- ST 5 ST , where _I-___isdefinedby For example, one has cp I- (0,5,N(5))(5,7,WW)(7,9,WW) \n5 (0,5,N(5))(5,9,YYYY)(9,11,WW), where cp = (0 I+ 0,5 c) 5,7 I+ 9,9 I+ 11). Note that expansion allows \nsome of the two-digit years to be expanded to four digits while leaving other years in two-digit form. \nThe application of a store expander cp to an environment E, written cp. E, is defined inductively: cp. \nE = E; and cp. (E, dn = (E , 1, u)) = (P . E), dn = ( P. E , ~(0, V(U)). Given two types r and r with \nr 5 r and a value v with the same size as r we define expand(r, T , v) to be the following value: fun \nexpand(r, r , v) = case (7, r , v) of (c, e, e) * e 1 [;?kYTYy, d;d$)~~gdl&#38; expad(n,, T[,, v ) 71, \nT2, l... n . ..d.expand(r1,r2,v) where n = size(n)  Note that 7 5 7 and size(v) = size(r) implies that \nv = expand(r, r , v) succeeds and size(v ) = size(#). Assume cp I- ST 5 ST and Dam(s) = addr(S2 ); we \nsay that store s expands s, written cp I- s : ST < s : ST , if Dom(s ) = addr(SZ ) and for every (I, \nU, r)-in ?I? and corresponding (v(l), V(U), 7 ) in ST we have extract(s , q(l), V(U)) = expand(r, r , \nextract(s, 1, u)). We say that a coercion c is expansive if, letting r + 7 = TypeOf( we have T 5 7 and, \nfor all values v of size size(r), Apply(c, v) = expand(r, r , v). Henceforth, we require that all coercions \nbe expansive. We now define how programs may be transformed in or-der to fix Year 2000 problems using \nexpansion. The trans-formation is not a function but a binary relation (-) on judgements of the form \nA F phrase : B. For example, TE F exp : r :: k u TE t- exp : r :: k is read: the judgement TE F exp \n: r :: k is transformed into TE I- exp : 7 :: k . We first state the expansion theorem and then define \nand explain the transformation. For brevity, we show only the theorem for expressions. Theorem 5.1 If \nTE I- exp : r :: k -TE t- exp : 7 :: k and cp + s : ST 5 s : ST and ST k E : TE and ST + ycl a E : TE \nand s, E I- exp * v then s , cp s E I- exp =S expand(r, r , v). Informally, the theorem states that a \ntranslated expression returns the year expanded value of the original expression, if the translated expression \nis evaluated in a year expanded version of the store and environment that the original ex-pression is \nevaluated in. Data Names TEl-pqdn:u-+TE l-pqdn:a dn # dn TE I- dn : u - TE I- dn : a u1 <u; (82) TE,dn \n:alt-dn:uuTE ,dn :a;i-dn:u TE 5 TE u 5 u (83)TE, dn : u l- dn : u u TE , dn : u l- dn : CT TE I- pqdn \n: TE1 u TE l- pqdn : TE: TEll-dn:u-TE;l-dn:u (84) TE I- dn INpqdn : u u TE I- dn IN pqdn : u Expressions \nTEl-exp:r::kuTE l-exp :r ::k r = N(size(lit)) TE 5 TE 035) TE~lit:r::euTE ~llit:r:e TE I- pqdn : r u \nTE I- pqdn : r (86) TEl-pqdn:r::e-uTE l-pqdn:r :e TE1 I- pqdn : TE2 -TE; I- pqdn : TE; TE1 F pqdn : flat(TEz) \n:: g u TE: t- pqdn : flat(TE ,) :: g (87) size(rr) = size(r) TE l- expl : ~1 :: k +L+ TE I- exp; : \nTI :: k TE I- assume exp, is r : 7 :: k u TE I- assume e&#38;&#38; is T : r :: k (88) TypeOf = 7 + 7 \nTE l- exp : r :: k - TE F exp : r :: k (89) TE t- coerce exp by c : r' :: e u TE l- coerce exp by c : \nr' :: e TypeOf = r + r TEl-exp:::k~cTE Fexp :~ ::e (90) TE k coerce exp by c : T' :: e cu TE l- exp : \nT' :: e TypeOf = T' + T\" TEI-expcp:::: e u TE I- exp : T' : k (91) TEkexp::::e-TE k coerce exp by c \n: T\" : e TE l- expl : TI :: e - TE I- expi : ri :: e TE I- exp2 : 72 :: e u TE l- expcp z : 7: :: e rl,72 \nI- binop : r r;, ri I-binop : r (92) TE l- expl binopexp2 : r :: e - TE I- expi binop expcp ,: r : e \n The only interesting rules are the ones involving assume and coerce. In rule 88, note that the type \nof expl must be the same before and after transformation and that the type of the whole assume expression \nmust remain unchanged too. This is used in an essential way in the proof of Theorem 5.1. In rule 89, \nnote that we can only keep the coercion, if the type of exp equals the type of exp. Rule 90 says that \na coercion in the original program may be cancelled by an expansion in the resulting program. Such an \nexpansion can come about for example because exp is a data name dn with TE(dn) = WW but TE (dn) = YYYY. \nRule 91 says that one can add a coercion in the resulting program. One can prove Theorem 5.1 using the \nfollowing lemmas. Lemma 5.1 If TE I- exp : r :: k -TE I- exp : T : k then TE k exp : r :: k and TE I- \nexp : r :: k Lemma 5.2 If TE t- exp : T : k u TE I- exp : T : k then TE 5 TE , r 5 r , and k = k . Lemma \n5.3 If ~1 5 72 5 ~3 and size(Ti) = size(v) then expand(Tz, ~3, expand(Tl, ~2, v)) = expcpand(Tl, r3, \nv). 6 Extension to Full COBOL The conceptual and technical core of AnnoDomini s type system has been \ndescribed in Sections 3, 4 and 5. In this section we describe how AnnoDomini addresses a number of COBOL \nfeatures not found in COBOLXJ~~, but of relevance to Year 2000 remediation. 6.1 Storage model Data representation, \nalignment, synchronization, truncation, padding, and editing rules for COBOL are very complex. Here we \nshall give only a glimpse of how they are modeled in AnnoDomini. For a more thorough description we refer \nto the OS/VS COBOL Application Programmer s Reference [IBM86], AnnoDomini User s Guide [Haf98b] and AnnoDo-mini \nReference Manual [H&#38;gal. 6.1.1 Internal representation In the standard representation of data in \nCOBOL each char- acter position in an elementary data item requires one byte of storage. In this representation, \neven numeric data are stored in the form of contiguous decimal digits; e.g., the numeral 98 is stored \nin two contiguous bytes, the first of which contains the EBCDIC representation for the character 9 , \nand the second contains the corresponding representa-tion for 8 .l Numeric data, however, can also be \nstored in binary or packed form. In COBOL, there is a difference between moving a binary or packed item \nby directly referring to it or by moving it For simplicity, we assume that EBCDIC is the underlying char- \nacter set here. Other possibilities, not covered here, are short and long internal floating point representations. \nAnnoDomini does not allow year data in those, though. as part of a group item that contains it. In the \nfirst case the item is first transformed into its standard representation before its value is moved. \nIn the latter case the item is moved in its binary or packed form as part of the group item, without \nprior transformation. AnnoDomini models binary and packed representations by adding ~::=B<T> 1 P<T> to \nthe language of TS2K type expressions and reflecting their implicit transformations in the type inference \nrules. 6.1.2 Editing COBOL specifies the format of elementary data items by a number of clauses. The \npicture-string clause determines the class of allowable characters for each character position of a data \nitem in standard representation. In particular, it determines the information-carrying character positions \nand the editing character positions in the data item. Data from another data item is written only into \nthe information- carrying character positions. The editing positions are filled independently. For example, \nconsider *TS2K WWNNNN 01 DATE-i PIC XXXXXX VALUE IS 981106 . 01 DATE-2 PIC XX/XX/XX. MOVE DATE-l TO \nDATE-2 The two occurrences of 1 in the declaration for DATE-2 are editing characters. They are, in a \nsense, hardwired into 2 of the 8 bytes at the positions indicated. During the MOVE the six digits 981106 \nare moved into the remaining character positions. As a result, DATE-2contains the string 98/11/06 . AnnoDomini \nkeeps track of storage at the byte-level and captures faithfully the effect of editing. In particular, \nit infers the type WWNNNNNNfor DATE-2,where the 1st and the 4th N are derived from the editing for DATE-2. \nThe other N s stem from the type for DATE-l. 6.1.3 Data alignment Numeric data are aligned on an assumed \ndecimal point be-fore they axe moved. We have generalized the notion of as- sumed decimal point to a \nreference point, which also applies to nonnumeric data. The reference point indicates where the data \nshould be logically aligned and, if necessary, where padding and truncation is necessary during a MOVE. \nAnnoDomini models each data item by (k, T, q, T,.), where k, r correspond to r :: k in Section 3, and \nq and 7, describe the type information of the information-carrying character positions to the left and \nto the right of the data item s ref-erence point, respectively. The Ctuple contains sufficient information \nto determine how the bytes of a data item are processed both as a sender and as receiver in a MOVE state-ment. \n6.2 Aliasing COBOL provides a number of facilities for accessing the same storage using multiple data \nitem definitions. Explicit redefinition. A REDEFINES clause in the work- ing storage section of a COBOL \nprogram expresses that the storage area associated with a data item defi-nition can be accessed using \nanother data item defini-tion. Implicit redefinition. Multiple 01-level record definitions for a single \nfile are implicit redefinitions for the file buffer area shared by all records from the file. Renamings. \nConsecutive storage inside a single 01-level storage can be can be (re)named by a RENAMES clause and \naccessed through it. These forms of aliasing are usually used for two distinct purposes: 1. to provide \ndifferent views of the same data; 2. to reuse storage area for efficiency purposes or to pro- cess different \nrecords contained in the same file.  In the first case the program interleaves reads from and writes \nto the shared storage area using different views. For example, in 01 DATE-l PIC X(6). 01 DATE-2 REDEFINES \nDATE-l. 02 YY PIG 99. 02 MM PIC 99. 02 DD PIC 99 VALUE IS 31 . MOVE 981106 TO DATE-l. DISPLAY DD OF DATE-2. \nthe program writes 981106 into the shared storage area using the view of DATE-l, and consequently reads \nit from the same storage area using the view of DATE-2. (Thus the program displays 06 , not 31 .) In \nthe second case the program uses the shared data stor-age primarily to conserve storage space: the shared \nstorage area is always read using the same view as when last written to. In this case the storage areas \ncan be treated as concep-tually separate (unshared). By default, all views of shared storage must have \nthe same TSSK type in AnnoDomini. If, in the above example, YY is annotated with WW and both MM and DDwith \nNN, then DATE-l is inferred to have TS2K type since DATE-2 WWNNNN, has type WWNNNN,and DATE-l and DATE-2 \nare aliased. Requiring that all views of shared storage have the same TSPK type leads to propagation \nof type information from one view to the others also in cases where the different views are used conceptually \nseparately. AnnoDomini allows anno- tating each both implicit and explicit redefinitions with *TSPK ASSUME \nSEPARATE which expresses that the redefinition should be treated as a separate, unshared definition. \nThus type information from one view is not propagated to the other. AnnoDomini takes ASSUMESEPARATEannotations \nat face value. Since it is control- flow insensitive it does not check whether read-accesses to shared \nstorage are always performed using the same view as the (dynamically) most recent, write access. 6.3 \nKey fields AnnoDomini identifies and warns of two-digit windowed and user-defined years in key fields \nof index-sequential files. This is because, for windowed years, dates in the 21st Century appear before. \ndates in the 20th Century in the standard (EBCDIC or ASCII) sorting orders. 6.4 Program Constants Since \nmoving literals into dates is a potential Year 2000 problem, literals both in the data division and procedure \ndivision sections are typed to be nonyears in AnnoDomini. Thus the MOVEstatement in *TSPK WWNNNN 01 DATE-l \nPIC XXXXXX. MOVE 990909 TO DATE-l causes a type error as it is an apparent Year 2000 Problem (990909 \nis often used as a special value, not a regular date). If, however, the literal is a correct date literal \nit can be given the desired type by an explicit ASSUME annotation, which eliminates the type error: +TSZK \nASSUME 990909 IS WWNNNN MOVE 990909 TO DATE-l 6.5 Arrays Arrays, called tables in COBOL, have program-static \nlength in COBOL. AnnoDomini treats them a8 group items with re-peated element types. For example an array \nof length 4 with element type has type WWNNNN WWNNNNWWNNNNWWNNNNWWNNNN. 6.6 Call statements COBOL programs \ncan call other COBOL programs in one of two ways: by static calls or by dynamic calls. Static calls are \nlinked at compile time, whereas dynamic calls are resolved at run-time. In the latter case it is statically \nevident which program is called. AnnoDomini issues warnings if arguments of calls have year types, but \ndoes not itself propagate the types across call boundaries. 6.7 Nonuniform language features There are \na number of language features in COBOL that make correct conversion complex: e.g., impossibility of call- \ning programs in PERFORM statements; nondistributivity of size error handling in ADD/SUBTRACT state- CORRESPONDING \nments; COPY statements with a REPLACING phrase; variable-sized arrays. To a large degree these can be \nattributed to a nonuniform language design. AnnoDomini is designed to preserve the semantics of the underlying \nprogram as much as possible. Where this is impractical or impossible Ann-oDomini warns of and describes \npotential problems. 7 AnnoDomini System Components AnnoDomini 1.0 for OS/VS COBOL runs on Windows NT \n4.0 and Windows 9X. It is commercially available from Com- puter Generated Solutions, Inc.; see http: \n//www. cgsinc . corn or http: //ww . haf nium. corn. AnnoDomini consists of 3 com- ponents: 1. the analysis \nand conversion engine (ACE), 2. the graphical user interface (GUI), and 3. IBM s Live Parsing Editor \n(LPEX).  ACE is the heart of AnnoDomini. It is written in Stan- dard ML and consists of about 60,000 \nlines of code, of which about 25,000 are generated from lexing and parsing speci- fications using ML-Lex \nand ML-Yacc. LPEX is a syntax- sensitive program editor developed by IBM and delivered with its VisualAge \nseries of software development tools. The GUI is written in Visual Basic and consists of about 10,000 \nlines of code. It interacts with the user and provides ac-cess to both ACE and LPEX. Communication with \nACE is through files that pass parameters from the GUI to ACE and return results to the GUI for presentation \nto the user. Com-munication with LPEX is through REXX macros, which po- sition the cursor in LPEX at \na particular source code line. They are also used to insert TS2K annotations and to gen- erate the code \nduring actual conversion. Every time the GUI invokes ACE, ACE processes the whole program under consideration \nfrom scratch. This batch architecture makes AnnoDomini fault-tolerant and allows for a simplified software \narchitecture. It also means that the state of a conversion project is completely represented -and documented \n-by the annotated programs themselves. The cost is that a complete pass with lexing, parsing and type \nchecking is required each time a type check is initiated. This appears to be acceptable in practice since \nAnnoDomini operates on one program at a time and Year 2000 problems discovered are eliminated in groups. \nAn untuned version of AnnoDomini takes about 30 seconds to process a 10,000 line program on a 133MHz \nPC with 64 MBytes of RAM. Conclusion We have presented the type-theoretic foundations and asso- ciated \npractical aspects of AnnoDomini, an integrated find- and-fix tool for making COBOL programs Year 2000 \ncom-pliant. The underlying software reengineering method consists of identifying and isolating potentially \nproblematic data and their associated operations according to their intended use (here as calendar years), \nencapsulating them as abstract types, and finally replacing their implementation by safe, improved code \nwith the same interface. This method ap-pears to be eminently applicable to other problems than Year \n2000 remediation, such as reengineering financial sys-tems for the introduction of the Euro or for the \nDow Jones Index passing the 10,000 mark. References [AP89] Habib Abdulrab and Jean-Pierre Pecuchet. Solv-ing \nword equations. Journal of Symbolic Compu-tation, 8(5):499-521, November 1989. [DM82] L. Damas and R. \nMilner. Principal type schemes for functional programs. In Proc. 9th Annual ACM Symp. on Principles of \nProgramming Languages, pages 207-212, January 1982. [Haf98a] Hafnium ApS. AnnoDomini Version 1.0 for \nIBM OS/VS COBOL -Reference Manual, 1st edition, 1998. See http://www.hafnium.com. [Haf98b] Hafnium ApS. \nAnnoDomini Version 1.0 for IBM OS/VS COBOL -User s Guide, 1st edition, 1998. See http://www.hafnium.com. \n[IBM861 IBM. IBM VS COBOL for OS/W, Release 2.4, 5th edition, September 1986. Dot. no. GC26-3857- 4. \n[Jon981 Capers Jones. The Year 2000 Software Problem -Quantifying the Costs and Assessing the Conse- \nquences. Addison-Wesley, ACM Press, 1998. ISBN o-201-30964-5. [Mi178] R. Milner. A theory of type polymorphism \nin programming. J. Computer and System Sciences, 17:348-375, 1978. [OJ97] R. 0 Callaha.n and D. Jackson. \nLackwit: A program understanding tool based on type infer-ence. In Proc. 1997 International Conference \non Software Engineering (ZCSE 97), Boston, Mas-sachusetts, pages 338-348, May 1997. [RFT99] G. Ramalingam, \nJohn Field, and Frank Tip. Ag-gregate structure identification and its application to program analysis. \nIn These proceedings, Jan-uary 1999. [vDM98] Arie van Deursen and Leon Moonen. Type infer-ence for COBOL \nsystems. To appear in Proc. 5th IEEE Working Conference on Reverse Engineer-ing, Honolulu, Hawaii, October \n1998. Permission to make digital or hard copies ofall or par! of this work for pcrwnal or classroo~~~ \nuse is granted withc~t fee procided that copies are not made or tlistrihutcd Or prolit or commercial \nadvantage and that topics bear this notice and the full citation on the first page. fo copy otherwise. \nto republish. to post on sewers or to redistribute to lists, require5 prior specific prrrnisswn anJ:or \na Tee. POPL 99 San Antonio Texas USA Copyright ACM 1999 l-581 13-095-3199/01...$5.00   \n\t\t\t", "proc_id": "292540", "abstract": "", "authors": [{"name": "Peter Harry Eidorff", "author_profile_id": "81100036922", "affiliation": "Dept of Computer Science, Univ. of Copenhagen (DIKU) and Hafnium ApS", "person_id": "P223978", "email_address": "", "orcid_id": ""}, {"name": "Fritz Henglein", "author_profile_id": "81100104232", "affiliation": "Dept of Computer Science, Univ. of Copenhagen (DIKU) and Hafnium ApS", "person_id": "PP39027309", "email_address": "", "orcid_id": ""}, {"name": "Christian Mossin", "author_profile_id": "81100661856", "affiliation": "Dept of Computer Science, Univ. of Copenhagen (DIKU) and Hafnium ApS", "person_id": "P46745", "email_address": "", "orcid_id": ""}, {"name": "Henning Niss", "author_profile_id": "81100420380", "affiliation": "Dept of Computer Science, Univ. of Copenhagen (DIKU) and Hafnium ApS", "person_id": "PP31088641", "email_address": "", "orcid_id": ""}, {"name": "Morten Heine S&#248;rensen", "author_profile_id": "81100494138", "affiliation": "Dept of Computer Science, Univ. of Copenhagen (DIKU) and Hafnium ApS", "person_id": "PP31055088", "email_address": "", "orcid_id": ""}, {"name": "Mads Tofte", "author_profile_id": "81100142765", "affiliation": "Dept of Computer Science, Univ. of Copenhagen (DIKU) and Hafnium ApS", "person_id": "PP39029504", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/292540.292543", "year": "1999", "article_id": "292543", "conference": "POPL", "title": "AnnoDomini: from type theory to Year 2000 conversion tool", "url": "http://dl.acm.org/citation.cfm?id=292543"}