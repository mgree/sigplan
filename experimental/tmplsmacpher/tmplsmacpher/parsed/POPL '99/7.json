{"article_publication_date": "01-01-1999", "fulltext": "\n Trust and Partial Typing in Open Systems of Mobile Agents (Extended Abstract) James Riely* Matthew Hennessy+ \nAbstract We present a partially-typed semantics for D~c, a distributed n-calculus. The semantics is designed \nfor mobile agents in open dis- tributed systems in which some sites may harbor malicious inten-tions. \nNonetheless, the semantics guarantees traditional type-safety properties at good locations by using a \nmixture of static and dy- namic type-checking. We show how the semantics can be extended to allow trust \nbetween sites, improving performance and expres- siveness without compromising type-safety.  Introduction \nIn [12] we presented a type system for controlling the use of re- sources in a distributed system, or \nnetwork. In particular it guar- antees that resource access is always safe, e.g. integer resources are \nalways accessed with integers and string resources are always accessed with strings. While this property \nis desirable, it is a prop- erty of the network as a whole. In open systems it is impossible to verify \nthe system as a whole, e.g. to type-check the web . In this paper, we present type systems and semantics \nwhich guarantee safe resource access for open systems in which some sites are untyped. Any treatment \nof open systems must assume some underlying security mechanisms for communication between sites, or loca- \ntions. One approach would be to add security features directly in the language, as in Abadi and Gordon \ns Spi calculus [2]. In such languages code signatures and nonces are directly manipula- ble as program \nobjects. Here we take a more abstract approach, presenting a secure semantics for a language without \nexplicit se- curity features. Of the underlying communication mechanism, we assume only that it delivers \npackets uncorrupted and that the source of a packet can be reliably determined. We start our development \nfrom the following principles: 1. Sites are divided into two groups: the good, or typed, and the bad, \nor untyped, the latter of which may harbor malicious agents. *http://rrvu.csc.ncsu.edu/eos/users/r/riely/uuu/. \nDepartment of Computer Sciencess, North Carolina State University, Raleigh, NC 27695-7534 USA. rielyQcsc \n.ncsu. edu. Research funded by NSF grant EIA-9805604. +http: //www. cogs. susx. ac .uk/users/matthewh/. \nSchool of Cognitive and Computing Sciences, Univ. of Sussex, Falmer, Brighton, BNl 9QH UK. matthavh@cogs. \nmsx. ac .uk. Research funded by CONFER II and EPSRC project GRIK60701. Permission to make digital or \nhard copies ofall or part of this work for personal or classy-oom use is granted without fet: provided \nthat copies arc not made or distributed rhr prolit or commercial advantage and Ihal topics bear this \nnotice and the full citation on the first page. TO copy otherwise. to republi&#38; to post on servers \nor to redistribute to lists, requires prior specific permission an&#38;or a Tee. POPL 99 San Antonio \nTexas USA Copyright ACM 1999 I-581 13-095-3/99/01...$5.00 Malicious agents should not be able to corrupt \ncomputation at good sites; however, not all agents at bad sites are malicious. Thus, the static notions \nof good and bad should not be used to prevent actions by an agent; rather, some form of dynamic typechecking \nis necessary. Because agent interaction is commonplace, agent movement, rather than interaction, should \nbe subject to dynamic type- checking. In practice, the distinction between good and bad sites is made \nrelative to a particular administrative domain. In the narrowest set- ting, only one particular virtual \nmachine (VM), or location, might be considered good, or well-typed, whereas all other machines on the \nnetwork are considered potentially malicious. In this case, the goal of a security mechanism is to protect \nthe local machine from misuse, while at the same time allowing code from other machines to be installed \nlocally. More generally, the distinction between good and bad might be drawn between intra- and inter-net, \nwith corporate or departmental machines protected by well-typing. Here we are interested in preventing \nmisuse based on type-mismatching -for example, a foreign agent attempting to access an area of memory \nwhich is unallocated, or is allocated to a dif- ferent VM; or an agent attempting to read an integer \nlocation as an array, and thus gaining access to arbitrarily large areas of memory. Such type violations \nmay lead to core dumps, information leakage or the spread of viruses and other virtual pestilence. We \nstudy these issues in the formal setting of Dx, a distributed variant of the ~-calculus [17]. The calculus \nwas introduced in [23], but here we use the more recent formulation given in [12]. In Dn; resources reside \nat locations and mobile agents may move from site to site, interacting via local resources to affect \ncomputations. The typing system of Dn is based on location types which describe the resources available \nat a site. For example loc{puri:res(int), geti:res(int),putZ:res(loc), getl:res(loc)} is the type of \na location with four resources, two for manipulating integers and two for manipulating location names. \nA feature which distinguishes m from related languages [ 10,4,25] is that resource names have only local \nsignificance, i.e. resource names are unique locally, but not globally across the network. To formalize \nthe notion of bad sites in DK, we add a new location type, Ibad, to the language. Agents residing at \nlocations of type lbad are effectively untyped, as are references to resources at bad locations, regardless \nof where these references occur. This weaker form of typing is achieved by adding a new inference rule \nto the typing system and a new form of subtyping. We call the result- ing typing system a partial typing \nsystem, as agents and resources at bad sites are untyped. Nevertheless partial typing ensures that resources \nat good sites are not misused. The weakness of partial typing allows for the existence of ma- licious \nagents at bad sites. Further, since agents can move, unpro- tected good sites can easily be corrupted; \nan example of this phe- nomenon is described in Section 3.2. Technically this means that partial typing \nis not preserved by the standard reduction semantics of DTC; a good site will cease to be well-typed \nif an untypable agent moves there from an untyped site. The object of this paper is to formalize a protection \npolicy for good sites against such malicious attacks. As in [27, 19, 15, IS], the basic idea is to require \nthat code be verified before it is loaded locally. Unlike these references, however, our work is explicitly \nagent-based, and allows incoming agents to carry references to resources distributed throughout the network; \nfurther, our approach supports the introduction of trust between sites, as described below. Verification \nof incoming agents takes the form of dynamic type- checking, where incoming code is compared against \nafilter for the target site. Filters provide an incomplete, or partial, view of the types of the resources \nin the network, both local and remote. Since the information in filters is incomplete, the dynamic typechecking \nalgorithm must be able to certify agents even when the filter con- tains little or no information about \nthe agent s site of origin; other- wise, it would forbid too many migrations. But this is potentially \nvery dangerous, as malicious agents may lie about resources at their origin or at a third-party site. \nWe avoid this danger by developing an adequate semantics based on the notion of authority. An agent moving \nfrom location k to C is dynamically typechecked under the authority of k, using the filter for C; every \nresource access must be verified either by the filter or the authority. The full development is given \nin Section 4, where we prove Subject Reduction and Type Safety theorems for this semantics, ensuring \nthat resource access at good locations is always type-safe. This approach should be contrasted with that \nof [ 131, which gives an adequate semantics for networks in which the authority of incoming agents cannot \nreliably be determined. One drawback of this framework is that every agent must be dynamically typechecked \nwhen moving from a site to another. To alleviate this burden, in Section 5 we introduce a relationship \nof trust between locations, formalized using the location type Itrust. We then modify the operational \nsemantics so that agents originating at trusted locations need not be typechecked. Although technically \nthis is a simple addition to the type. system, it is also very expres- sive. The result is that the network \nis divided into webs of trust and agents can only gain entry to a web of trust via typechecking. Once \nentry to a web of trust has been earned, however, an agent can move freely around the web; it will only \nbe typechecked again if it leaves a web and subsequently wishes to reenter. Moreover these webs of trust \nmay grow dynamically as incoming agents inform sites of other sites that they can trust. The paper proceeds \nas follows. In Section 2 we review Dn and its standard semantics, including the standard typing system. \nSection 3 introduces the notion of partial typing and shows that partial typing is not preserved by the \nstandard reduction relation. Section 4 presents the formalization of filters and dynamic typing, showing \nhow these are incorporated into the run-time semantics. In Section 5 this framework is extended to include \ntrust. The paper ends with a brief discussion of related work. In this extended abstract all proofs are \nomitted, as is much of the discussion. The full version [22] is available at f tp ://f tp. cogs.susx.ac.uk/pub/reports/compsci/cs0498.ps.Z. \n Table 1 Syntax Names: e ::= k Location Resource I a Values: u,v,w ::= bv Base Value Name Variable \nI (ul, ..,u,) Tuple Patterns: X,Y ::=x Variable I (Xl, ..,&#38;) Twle Threads: P,Q,R ::= stop Termination \nI PIQ Composition i p:,P Restriction Movement 1 .I-)&#38;, output f $(X:T)P Input Replication I zu=vthenPelseQ \nMatching Networks: M,N ::= 0 Empty I MIN Composition I (vke:T) N Restriction I WI Agent 2 The Language \nand Standard Typing In this section we review the syntax and standard semantics of Dn, extended with \nbase values. For a full treatment of the language, including many examples, see [121. 2.1 Syntax The \nsyntax is given in Table 1, although discussion of types, T, is postponed to Section 2.3. The syntax \nis parameterized with respect to the following syntactic sets, which we assume to be disjoint: . Base, \nof base values, ranged over by bv, . Lot, of location names, ranged over by k-m, . Res, of resource names, \nranged over by a-d, . Var, of variables, ranged over by x-z.  The main syntactic categories of the language \nare as follows: Threads, P-R, are terms of the ordinary polyadic x-calculus [16] with additional constructs \nfor agent movement and re- striction of locations. Agents, k[P], are located threads. Networks, M-N, \nare collections of agents combined using the static combinators of composition and restriction.  These, \nin turn use Names e, which include location names and re- source names, Values, u-w, which include base \nvalues, names, vari- ables and tuples of values and Patterns, X-Y, which include vari- ables and tuples \nof patterns; we require that patterns be linear, i.e. that each variable appear at most once. As an example \nof a network, consider the term: WDIWV (eUQ1Ikl[RB) This network contains three agents, e[P], e[Q] and \nk[R]. The first two agents are running at location C, the third at location k. More-over Q and R share \nknowledge of a private resource a of type T, allocated at e and unknown to P. In the sequel we use fv(N), \nrespectively fn(N), to denote the set of variables, respectively names, that occur free in N. A term \nwith no free variables is closed. We write PQ~xD for the capture- avoiding substitution of u for X in \nP. We adopt standard abbrevi- ations from the rc-calculus [17], e.g. dropping final occurrences of stop, \nwriting u,, .., u,, as i7, and identifying terms up to renaming of bound names and variables. We also \nsystematically omit type annotations when they play no role in the discussion, for example rendering \nu?(X:T) P as U?(X) P. 2.2 Standard Reduction The standard reduction semantics is defined using two relations \nover closed network terms, a reduction relation (M +-+ N) and a structural equivalence (M E N). The relations \nare defined using a set of axioms. So that these axioms may be applied anywhere within a network context, \nwe introduce the idea of a network pre- congruence. A relation > over networks is defined to be a network \npre-congruence if N + N implies . NIM > N IM, . MIN + MIN ,and . (vke:T)N > (vke:T)N . The reduction \npre-congruence is formalized as the least net- work pre-congruence which satisfies the axioms given in \nTable 2. The reduction axioms for communication (r-comm) and matching (r-eq) are taken directly from \nthe n-calculus, with a few changes to accommodate the fact that agents are explicitly located. Note that \ncommunication can only occur between colocated agents. The most important new rule is (r-move), k[gol.P] \n+-+ t?[Pjj, which states that an agent located at k can move to e using the move operator go!. P. Also \nsignificant is (r-new), k[(ve:T)P]I ++ (vke:T) k[P], which states that a name created by a thread can \nbe- come available across the network. Note that when a new name is lifted out of an agent, the network-level \nrestriction records the name of the location which allocated the name; these location tags are used only \nfor static typing. Finally, the rule (r-split), k[P 1 Qj +S k[P]I 1 kl[Ql, allows an agent to spawn off \nsubagents which are able to move around the network independently. The only reduction rules that vary \nsignificantly in later sections are (r-move) and (r-new). The structural congruence is defined similarly; \nit is the least net- work pre-congruence that satisfies the axioms of Table 2, together with the laws \nfor equivalences and the standard monoid laws for parallel composition. The axioms given in Table 2 provide \nmeans for the extension of the scope of a name, for garbage collection of unused names and terminated \nthreads, and for the replication of agents. The main reduction relation we are interested in is (---+) \n= (E . +-+ z); this allows structurally congruent networks to be considered the same from the point of \nview of reductions. As an example, suppose that we wish to write a network with two agents, one at k \nand one at !. The agent at k wishes to send a fresh inte- ger channel a, located at k, to the other agent \nusing the channel c, located at C. This network could be written:   4k?cz,4QnIkuw(pIgowwn (r-new) \n -+%?(z,x)Qni &#38;.wd) 1 @!d(w -+ e[c?(z,x)Q] 1 (WZ) (k[Pn I k[gol.c!(k,a)l) (r-split) (r-move) -+ \n4kfwQn (wnI4kvwn) I b-4 -+ (vka) e[QQk$J~n I k[P]I (s-extr) (r-comm) (s-grbgz) The equivalence laws are: \nM I M, M EN implies N s M, and M EN and N 3 0 implyMz0. Themonoidlawsare: MIOEM,MINZNIM,~~~MI(NIO)E (MIN)IO. \n Table 2 Standard Reduction Reduction pre-congruence: (r-move) k[goe.P] t--+ epq (r-new) k[(ve:T)Pn r--+ \n(vke:T)k[Pn if e #k (r-split) WIQD *W'JllkUQD (r-comm) k[u!(v)Pn I k[a?(X)Q] +--+ k[P] I k[[QjyxD] (r-eql) \nk[if u = u then P else Qn H k[P] (r-eqz) k[if u = v then P else Qn ++ k[Q] if u # v Structural congruence: \n(s-extr) M 1(vke:T) N % (vke:T) (M 1 N) if e $! fn(M) (s-grhgl) (vke:T) 0 z 0 k[stopl) E 0 s co k[*Pn \nE kI[Pn 1k[*P]  (ty$;j Beside each reduction, we have written the axioms used to infer it, omitting \nmention of the monoid laws. An example of a process Q that uses the received value (z,x) is goz.n!(l) \n, which after the communication becomes go k. a! (1) 2.3 Types and Subtyping The purpose of the type \nsystem is to ensure proper use of base types, channels and locations. In this paper we use the simple \ntype language from [12, $51. We use uppercase Roman letters to range over types, whose syntax follows: \nRes: A-D ::= res(T) Lot: K,L ::= loc{a,:A,, .., an:An,x,:B,, .., xn:Bn} Val: S,T ::= BT 1 K 1A I K[A,, \n.., A,] 1(T,, .., T,) The syntax provides types for base value_s, locations, local re-sources and tuples. \nTypes of the form K[A] are dependent tuple types, which allow communication of non-local resources; we \ndis- cuss these further in the next subsection. We require that each resource name and variable in a \nlocation type appear at most once. Location types are essentially the same as standard record types, \nand we identify location types up to re- ordering of their fields . Thus loc{a:A, b:B} = loc{b:B, CA}. \nWe write lot for lot{ } . Note that in general location types may contain variables. This is convenient \nfor typing, but in the syntax of threads and networks, given in Table 1, we restrict all types to be \nclosed, i.e. no variables can appear in location types in terms. The subtyping preorder (T <: S) is discussed \nat length in [12]. On base types and channel types there is no nontrivial subtyping; for example, res(T) \n<: res(T ) if and only if T = T . On location types, the subtyping relation is similar to that traditionally \ndefined for record or object types: loc{ii:A, EI3) <: loc{u:;i} On tuples, the definition is by homomorphic \nextension: s<: T if V i: Si <: Ti K[A] <: L[G] if K <: L and x <: I!I An important property of the subtyping \npreorder is that it has a partial meet operator n, which will enable us to accumulate typing information \nassociated with identifiers. Table 3 Standard Tvuing Here r and A range over type environments, which \nmap location names to location types and variables to base types or location Values (rules for base values \nnot shown): r(u) <: T r(w) <: loc{u:A} r b u:T r b u:A r b u:K l? t-, uj:Tj (V i) rhiG t-, K[@ rl&#38;_,u:T \nr (u,?): Threads: r bus r t-,v:T  r h ~OC rn{,u:T}n{,v:s} b_,p rbp rt-,Q r t-, r b if u = v then P \nelse Q g0u.p r b u:res(T) r b u:res(T) r I-, fv (X) disjoint fv(r) v:T rbp rfl{,X:T} b Q r b U!(V)P r \nr-, u?(X:T) Q rbp e $ fn(r) rhle rn{,e:T} b P r t-,stop,PlQ,*P r b (ve:T) P Networks: rhp feWr) rn {ke:T} \nI- N l-l-M TFN r tkl[PJ r t-(vke:T) N I-FO,MlN Definition 1. A partial binary operator n on a preorder \n(S, 5) is a partial meet operator if it satisfies the following for every r, s, t E s: (a) rdtandr<simplytllsdefined \nandrstns (b) t n s definedimplies t n s 5 t  (c) (tns)nr=tn(snr) (d) tns=snt  In the last two conditions \n= refers to partial equality; if one of the expressions is defined the other must also be defined. 0 \nProposition 2. The set of types, under the subtyping preorder, has a partial meet operator. ProoJ: (Outline) \nOn location types this operator is induced by the following equation: l~c{iiZ} n t~c{a:ii} = Ioc{~:~ \nui;:ii} if V&#38;j: uj = vj implies Ai = Bj For example: loc{a:A, b:B} n loc{b:B, c:C} = loc{a:A, b:B, \nc:C} 0  2.4 Standard Typing Judgments in the typing system take three forms: rFN Network N is well-typed \nrbp Thread P is well-typed to run at location w r b v:T Value v can be assigned type T at location w \ntypes2 For example, the following is a type environment: r = {~?:Ioc{u:A,x:B}, y:int, z:loc{a:A }} We \nwrite r(u) to refer to the type of identifier u in r. So for r as defined above, T(z) = loc{a:A } whereas \nl?(u) is undefined. The standard typing system is defined in Table 3. We presup- pose a set of rules \nfor base values, which, for example, say that integer constants have type int and the boolean constants \nt and f have type bool. In Table 3, there are two rules for identifiers. The first applies to universal \nidentifiers in the domain of the type en- vironment: location names and variables of location or base \ntypes. The second applies to local identifiers in location types: resource names and variables of resource \ntype. Universal identifiers have a consistent meaning across all sites, whereas local identifiers do \nnot; e.g. the location name e refers to the same thing no matter where it occurs, whereas the resource \nname a does not. Note that when typing a dependent tuple (u,q, the typing of i7 is deduced with respect \nto the location identifier u. Thus if r b (k,a) : (K,A) then k anda are two independent values whose \ntype consistency is checked independently. On the other hand if r t, (k,a) :K[A] then u is considered \nto be a resource at the loca- tion k, and this judgment depends on a be well-typed at k, r k a:A. We \nemphasize this use of dependent types with some notation: Notation. In examples, we use u[^;Lg (u,7) \nto indicate that the tuple (u,-;) has a dependent type, K[A]. 0 For networks and threads, the main rules \nof interest are for agents and movement, respectively. For the agent e[Pl to be well- typed, P must be \nwell-typed at location e; whereas for the thread go u. P to be well-typed at some location w, P must \nbe well-typed at the target location u. The rules for input and restriction are intuitive, although they \nmake use of some notation for updating environments, defined in Appendix A. Suppose, for example, we \nwish to infer the judgment r b u?(X:T) Q. By a-conversion we may assume that the variables in the pattern \nX are distinct from those in the environment r. So we need to establish two facts: . relative to r, the \nidentifier u is a resource at the location w, i.e. r t-, u:res(T), and . the continuation Q is well-typed \nrelative to lY augmented with the typing information in X:T. This extension of the type environment is \nrepresented as r il (,X:T}, the meet of lY and the environment constructed from X and T relative to w, \n{,X:T}. For example if X:T has the form x:A then the extra information added to lY is the environment \n{,x:A} = {w:loc{x:A)}; in typing Q we are therefore allowed to assume that x is a resource of type A \nlocal to w. On the other hand if X:T has the form z[x]:K[A] then the extra information added to r is \nthe environment {w~[~]:K[A]} = {z:Kn loc{x:A}}. Here when typechecking Q we can assume that x is a resource \nof type A at location z, which in turn has the type K n loc{x:A}. Similarly the network (vka:A) N is \nwell-typed with respect to r if (I does not appear in r and N is well-typed with respect to r ll {k:loc{a:A}}, \nsince {ka:A} works out to be {k:loc{a:A}}. Also proving r b (v&#38;L) N involves establishing rtl {e:L} \nb N since {&#38;L} = {C:L}. *Forsimplicity, the typing system defined here requires that every tople \nbe folly decomposed upon reception; i.e., terms of the form a?(~: (int, inr)) P are not typable. The \nmore general case is straightforward, but requires a more complex treatment of location types. The rule \nfor matching allows the combination of capabilities available on different instances of a location name. \nNote that the rule may only be applied when S fl T is defined. In the case that S = T, the rule degenerates \nto the standard rule for conditionals: I- b XT, v:T, P, Q rbifu=vthenPelseQ The extra generality of \nthe rule is necessary to type threads such as the following: n?(z[x]) b?(wb]) if z = wthen goz. (X?(U) \ny!(u)) This thread receives two remote channels from different sources, then forwards messages from \none channel to the other. Further examples are given in [12] where we argue that the more general rule \nis crucial for typing many practical applications. The typing system satisfies several standard properties \nsuch as type specialization, weakening and a substitution lemma, as de- scribed in [12]. The following \nresult establishes the fact that well- typedness is preserved by reduction. Together with a Type Safety \ntheorem, again described in [12], this ensures that well-typed terms are free of runtime errors throughout \ntheir execution. Theorem 3 (Subject Reduction for the Standard Semantics). If lYkNandN--+N thenrl-N . \ncl 3 Partial Typing The purpose of this paper is to study systems in which only a sub- set of agents \nare known to be well typed. Since agents themselves are unnamed and can move about the network, we draw \nthe distinc- tion between the typed and the untyped worlds using locations, or sites. In this section \nwe first define a partial typing system which allows agents at certain untyped, or bad, locations to \nhave arbitrary, potentially malicious behavior. We then present an example which shows that the standard \nsemantics is inadequate for partially typed systems and finally point to the solution proposed in later \nsections. 3.1 The Partial Typing Relation To capture the notion of a untyped locations formally, we introduce \na new location type, Ibad, into the type language. We use the terms untyped and bad interchangeably, \nsimilarly typed and good. Loca-tion types are now defined: K,L ::= loc{ii:&#38;E6} 1lbad We sometimes \nrefer to types in the augmented language as partial types. The subtype relation is extended to partial \ntypes by adding the following subtyping rule: lbad <: loc{Z:A) This reflects the fact that channels \nat an untyped location may have any type and consequently behavior at bad locations is un- constrained. \nWith the addition of Ibad, the partial meet operator becomes total on location types3 loc{iidUi?i} if \nVij:u, = vj implies S, = Tj 3 loc{ii:S}rl loc{v:T} = ,bad otherwise Ibad n loc{a:T} = ibad loc{ii:T} \nn lbad = lbad  Table 4 Partial Tvnina Relation All rules from Table 3 but those for restriction (v) \n T # lbad e $ fn(r) (t-bad) r(w) = rbp lbad (t-new rn{,e:T} b P )B r b (ve:T) P r(k) = lbad T # lbad \ne $ fn(r) e $ W) (n-newb) Type environments are now more expressive. A typical exam- ple is given by: \nk : lot { a: res(int)} b:res(loc[res(bool)]) r = e : lot c: res(loc[res(int)]) ( ) { d: res(lbad) 1 m \n: lbad }I Here we have three locations, k, .! and m, the first two of which are typed, and the last \nuntyped. Of the good (typed) sites, we know that k has an integer channel a, and e has three channels: \nc, which communicates dependent tuples with the second element being an integer channel; b, which communicates \ndependent tuples with the second element being boolean channels; and d which communi- cates untyped locations. \nWe will use this environment in most sub- sequent examples in this section and the next. The typing relation \ngiven in Table 3 may now be applied to this extended language of partial types with the result that untyped \nlocations enjoy many expected properties. For example, since lbad <: loc{a:res(int)} and lbad <: loc{a:res(bool)}, \nwe can in-fer {mlbad} t, (a,a):(res(int),res(bool)) In general we can infer that a resource at an untyped \nlocation has any resource type, meaning that local computations at these loca- tions are unconstrained \nby typing considerations; this is the case even if the resource is restricted. Agents can also use the \ntype information to infer that a remote location is untyped. For example consider the network  e[b?(z) \nc?(w) if z = w then d!(z)] which is well-typed with respect to r, from (*). If an agent receives the \nsame dependent pair (say n[a]) on both the channels b and c, then it can determine that location n is \nuntyped. Thus the agent can subsequently output n on d, a channel that transmits locations of the type \nIbad. Despite these examples, the standard typing system does not quite capture the notion of untyped \nlocation , even with the addi- tion of Ibad. Most important, the standard typing rule for move- ment \ndoes not allow untyped locations to send malicious agents to typed locations. We would like to have that \nr F m[gok. a!(t)!. Here an untyped agent at m attempts to move to k and misuse the integer channel a \nby sending on it the boolean value t. The standard typing rule for movement, however, does not allow \nthis judgment, since it requires that a!(t) be well-typed at k, which definitely is not the case. The \npartial typing relation is defined in Table 4. All of the rules of the standard type system carry over \nto the partial typing system but for those concerning restriction, which require an additional side condition. \nThe introduction of the rule (t-bad) allows untyped locations to have truly arbitrary behavior, including \nthe ability to (attempt to) send malicious agents to good locations. Thus the par- tial typing relation \nvalidates the judgment r t- m[gok.a!(t)l; here the malicious site m attempts to send to the good site \nk an agent which will misuse the resource a. The rule (n-newb) says that locations created at untyped \nloca-tions should themselves be untyped. This rule is required to main- tain well-typing under reductions \nsuch as: kf(veqgOe.q c--t (~~e:~)k[~~e.~]+-+ (vke:L)e[pl The rules (t-newg) and (n-newg) are as in the \nstandard type sys-tem, but require that typed locations not create untyped ones. This reasonableness \nrequirement is necessary to establish Type Safety, as formulated in Theorem 12. 3.2 An Example Consider \na system with two agents at C, waiting to receive data on channels c and b, respectively. The first agent \nwill expect, as the second element of the tuple it receives, the name of an integer chan-nel, whereas \nthe second will expect the name of a boolean channel. In addition suppose that there are agents at k \nand m poised to send data to C on channels c and b, respectively. Such a system is the following: N= \neI[c?(wM)   g0w.Ywn 1 e~b?(z[xl) goz.xqt)n I4bwwn  I4k~wwn Here the agents at e ar td k are all \nquite reasonable; they could be typed using the standard type system of Table 3. The final agent, at \nm, however, flagrantly violates the types of channels n and b; this agent intends to send an integer \nchannel (a) where a boolean channel is expected (on b). One can easily see that, using the standard typing \nsystem (with-out Ibad), for no A do we have A t-N. This is because channel a at k may be bound to either \ny or X, and these identifiers are subject to conflicting uses. There is no assignment of standard types \nto a, b and c that satisfies all of the constraints given in N. On the other hand, using the partial \ntyping system, we have r E N, where I- is as in (*). This well typing, however, is not preserved by reduction. \nThe agents communicating on c reduce unproblematically, first with a move from k to !?, then a communication, \nthen a move from C to k. All of these reductions preserve well-typing under r. The agents communicating \non b evolve in the same way, the only difference being that the first move is from m, rather than from \nk. Using standard reduction (Table 2), we have: e[[b?(+]) goz.xqt)n 1m[goe.b!(k[a])n (1) t e[bqz[.qgOz.xqt)n1e[b!(k[qn \n(2) -+ e[gok.uqt)~ (3) -+ kp(t)n (4) Here, however, (2)-(4) are not well-typed under r. This fact is \nob- vious when considering (4) where an agent at k attempts to send a boolean on an integer channel. \nAlready in (2), however, typing un- der r fails. In order to infer r t-I[b!(k[u])B we must establish \nthat for some T, r k b:res(T) and r bk[u]:T. Given the type of b ate, we would have to take T = loc[res(bool)], \nbut r ek[u]:loc[res(bool)], since a is an integer channel at k. The semantics presented in the following \nsection will prevent the reduction of (1) to (2) by dynamically typing certain agents when they move \nfrom one location to another. To accomplish this, we augment the standard reduction semantics with type \ninforma-tion detailing the resources available at each site. Significantly, this type information is \nheld ZocaZZy at each site, and thus sites will have different views of the network. Crucial to this semantics \nis the abil- ity of a location to determine the authority of an incoming thread, i.e. the location from \nwhich the thread was sent. This semantics is improved in Section 5 by adding trusted locutions to the \ntype system. In each of these sections, the main results are Subject Re-duction (for the partial typing \nrelation) and Type Safety. It is worth contrasting this approach with the purely local ap-proach adopted \nfor anonymous networks in [131. In anonymous networks, the authority of incoming threads is not known. \nThe se-mantics of [131 uses a weaker typing system requiring consistency only of local resource types. \nThus, in that work, (2) is taken to be well-typed, with subject reduction failing only in the move from \n(3) to (4). The chief advantage of the current work is that it permits the use of trust, which appears \nto be incompatible with terms such as (2). 4 Filters and Authorities In this section we propose a semantics \nwhich recovers subject re-duction for partially-typed networks. The solution assumes that the origin, \nor authority, of incoming agents can be reliably determined. 4.1 Syntax and Semantics To accomplish dynamic \ntypechecking, it is necessary to add type information to running networks. We do this by adding a _fiZter \nk((A)) for each location kin a network. The filter includes a type en-vironment A which gives k s view \nof the resources in the network. Suppose that in a network N, location kknows that there is resource \nnamed a of type A at location !. This intuition is captured by re-quiring that N have a subterm k((A)) \nsuch that A(e) <: loc{u:A}. Formally we extend the syntax of networks (Table 1) to include filters, as \nfollows: N ::= 1k((A)) We say that a term k((A)) is afilterfor k. Intuitively each location k should \nhave exactly one filter associated with it. This constraint could be formalized within the typing system, \nbut for simplicity we prefer to treat it separately. Definition 4. We say that a network N is well formed \nif for every k E fn(N) there is exactly one subterm of N which is a filter for k, and for every subterm \n(v,I:L)M of N there is exactly one subterm of M which is a filter for e. 0 We refer to networks with \nfilters as open networks and for the rest of the paper, we assume they are always well-formed. Static \nTyping The static typing relation extends that of Tables 3 and 4 with the two rules for filters, given \nin Table 5. The rule (n-fiIter,J requires that a filter for a good location kmust have full knowledge \nof the resources at k (r(k) = A(k)) and a view of the rest of the world that is consistent with reality \n(r <: A). The rule (n-filterb) indicates that filters for bad locations may be arbitrary. These typing \nrules guarantee that whenever a filter exists, it must have a reasonable view of the world. Table 5 Typing \nand reduction using filters relation: (I$) = ( bw). In effect, this would limit incoming agents to include \nonly names of resources that are known in advance. While Static typing: all rules from Table 4 this is \ncertainly sound, it is much too restrictive; for example, new resources could only be used by agents \nthat originated locally. Con- I-<: A sider the system (where the filter at k is omitted): r(k) = A(k) \nT(k) = lbad (n-filterg) r k +)) (n-filterb) r k k(Ajj Reduction: (r-split), (r-eql) and (r-eqa) from \nTable 2 (rf-move) k[goC.P]I 1e((A)) ++ @D I W) ifk=CorAI$P (rf-newr) Wa:A)PlI I d(A)) ++ bw:N (kIP]I \nI W-J {I&#38;#)) if a $ fn(A) (rf-newl) W WPIi I d(A)) +-+ (v&#38;L) @@ ]I I k@n {e:Ll)) I %&#38;:L)))) \nif!$!fn(A)U{k} (rf-comm) k[a!(v)Pn 1k[a?(X:T)Qn 1k((A))    w4w.w4ni 4kfwi)pn i w9 (3 Here k creates \na new resource and wishes to communicate it to e. However with (16) = (b) the move from k to I is refused \n-(rf-move) cannot be applied -since the filter A at e can have no knowledge of the new resource a. At \nthe opposite extreme, we might allow threads to include any reference to non-local resources. However, \nthis approach is clearly unsound from the counter-example given in the last section. The difficulty is \nthat threads from bad locations may provide incorrect information about good locations, breaking subject \nreduction. To straddle the gap between sound-but-useless and unsound-but-expressive, we introduce the \nnotion of authority. We say that an agent leaving a location k acts under the authority of k. When an \nagent with authority k enters another location, we say that k is the authority of the agent. * W'DI \nkUQQ?'xH While it is not safe to allow incoming agents to refer to any I ~@'-'{,wT~)) Dynamic typing: \nall rules from Table 4, I$ replacing by,, lbad <: K (vf-selfl) (vf-self2) - A It k:K A I$ u:A (tf-return) \nA I$ gok.P Reduction The reduction relation for open networks is also given in Table 5. The purpose of \nfilters is to check that incom-ing agents are well-typed. Thus, the main change to the semantics is the \nreplacement of the reduction rule (r-move) with: 1((A)) I k[go!. pn t-+ [((A)) 1 epg if k = e or A I$ \nP Here A I$ P is a dynamic typing relation, discussed below, which intuitively says that P is well-formed \nto move to location e, if acting under uuthority ofk. Agents originating locally are assumed to be well-typed \nand therefore need not be checked dynamically. As a network evolves, the filter at a site should be augmented \nto reflect that sites increasing knowledge of the network. At the very least this should include updates \nwith information about new local resources. The rule (rf-newr) says that when a new resource u is created \nat k, the type of that resource is recorded in the filter fork. This ensures that k continues to have \nfull knowledge of local resources. Similarly when a new location e is created by k, a new filter should \nbe created for I and the filter for k updated to establish a view of e. This is achieved by the rule \n(rf-newl). In addition, filters may take other measures to increase their knowledge of the network. One \npossibility is that information is extracted from values which are communicated at the site: when a value \nis received at a site, the site s filter is augmented to include any new information that can be gleaned \nfrom the communicated value. The rule (rf-comm) formalizes this idea. Alternatives are discussed in the \nfull version. Dynamic Typing One approach to dynamic typing would be to take the dynamic typing relation \nto be the same as the static typing non-local resources, it is safe to allow them to refer to resources \nlocated at their authority, i.e. at their home location. Intuitively this is true because, under this \ndiscipline, bad agents can only lie about resources located at their authority, which must have been \na bad location to begin with. Lies about bad locations don t hurt well-typing, since bad locations are \nuntyped. Formally, the rules for runtime typing extend those of the static type system given in Tables \n3 and 4 with two additional rules for values and one for threads. These rules allow references to an \nin- coming agent s authority to go unchecked. The rule (vf-selfl) al-lows an incoming agent to refer \nto its authority k, regardless of whether the filter environment A contains any information about k. \n(Note that the condition lbad <: K is vacuously satisfied; we include it here only for reference in the \nnext section.) The rule (vf-selfz) allows an incoming agent to refer to resources at its authority. As \nan example, let Al = {fZ:loc{u:res(K[B])}}. Although we cannot infer that he b u!(k[b]) using the static \ntyping system, we can de- duce Al I$ u!(k[b]) using the dynamic typing relation. Thus the following reduction \nis allowed by the semantics:  4k~wk~~i~n-+ wwi)n I wd) I e(w) The rule (tf-return) allows a thread \nto return to its home loca-tion without subjecting the returning thread to further typecheck-ing. This \nrule allows some additional expressiveness and reduces the burdens of typechecking somewhat. Note that \nwhile the static typing system interprets the rules of Tables 3 and 4 with respect to an omniscient authority \n(IJ, the dy- namic type system interprets these rules with respect to the knowl- edge contained in a \nfilter (A, where r <: A). Whereas untypability with respect to r indicates that a network is malformed, \nuntypa-bility with respect to A may simply indicate that A has insufficient information to determine \nwhether an agent is malicious or not. 4.2 Examples Example 5. First we show how filters are updated \nvia communi- cation with imported agents. Consider the open network (5) dis- cussed above, where the \nlocation k wishes to transmit to e the name of a new local resource CI of type A. Suppose the filter \nat e is A = {!:loc{b:res(K[A])}}, so that e has no information about location k. Then we have the following \nreductions (we use r to represent the For example suppose e s filter is extended so that e knows the \ntype filter at k, the contents of which are not important for the example): of resource a at k, that \nis A(k) = loc{u:res(int)}. Then we have the reduction kV)) I kU(vu:A)goe.b!(k[ul)l I W(zbl:KlAI)PIl 1 \nW)) ;a:A) k((I+)) / k[gol.b!(k[a])l / e[b?(z[x]:K[A])Pl 1e((A)) ;a4 W )) I WWl)n I WW4N-W n I W))  --t \n(~4 WY) I wpnI w4%sDn I W )) where JJ = rrl {k:loc{a:A}} and A = All {k:loc{a:A}}. The first move, using \nthe rule (rf-newr), extrudes the local re-source a at k, updating the filter at k accordingly. Using \nthe struc-tural congruence, the scope of a can be extended to inclup the en- tire network. Then (q-move) \nmay be employed since A I$ b!(k[u]). Here the dynamic typing by the filter A at e of the incoming thread \nb!(k[u]) succeeds essentially because of the rule (vf-self*); the thread only communicates the names \nof resources at k, its author- ity. Finally a local communication at e is performed, using rule (rf-comm). \nNot only is the value communicated to P, but the filter at e is also updated; after the communication, \nthe filter for e con- tains information about the type of resource a at k. 0 Example 6. Let us now revisit \nopen network (1) discussed in Section 3.2, which shows that partial typing is not preserved by the standard \nreduction relation. To use the new semantics, we must add a filter for each location. Here we show only \nthe filter for I, e((A)), where A satisfies the constraints of (n-filterp). Thus, let us consider the \nopen network r I w.))  ~4wwkbl~n where I- is given by (*) in Section 3.1. Note that the agent at m \nattempts to misinform and agent at e about the type of the resource a at k. In the revised reduction \nsemantics the move from m to C is allowed only if AIF b!(k[u]), that is if we can dynamically typc-check \nb!(k[u]) using the filter A under the authority m. But this is impossible, given the constraint that \nl? t- .!((A)). To see this, first note that e has full self-knowledge, i.e. A(e) = r(e), and therefore \nA(!) must have the entry b: res(loc[res(bool)]); therefore to type the term we must be able to deduce \nAlfu:res(bool). Next note that A must be consistent with reality, namely r. This means that if A has \nknowledge of the resource a at k then it must be at the conflicting type res(int); therefore the rules \nof Table 3 cannot be used to infer Alcu:res(bool). Finally, since k is not the authority of the thread, \nneither can the additional rules of Table 5 be used to justify the claim that Al$u:res(bool). It follows \nthat the inference Alr b!(k[u]) is impossible. 0 Example 7. Let us now modify the previous example so \nthat m attempts to relate information about its own resources, rather than those of k. In such cases, \nmovement always succeeds, whether or not the source site is bad. As an example suppose the thread at \nlocation m is changed to m[goe. b!(m[u])n, i.e. m wishes to inform e of a resource local to m. Then we \nhave the reduction: dbW~k4)n I WV) -+ W++4)n I W) Thisfollows since AlkT m[u]:loc[res(bool)] can be inferred \nusing (vf-selfl) and (q-selfz), regardless of the type assigned to m in A. 0 dk~~4+4)n-4w4nI w4 Ie((a \n because of the inference A IT c! (k[u]). Of course the authority of m plays no role in this judgment. \nExample 9. The information in filters determines which migra-tions are allowed and reductions in turn \nmay increase the infor-mation in filters. This means that certain migrations can remain blocked until \nthe appropriate filter has been updated. Consider the following open network, again typed using the environment \nr given in (*), where A is the restriction of l? onto C, i.e. A = {W(e)}: 4wWWn t hb~.w4n I 4b~w~pn 1 \nem) Here the migration from m to e is not immediately possible, since Aff c!(k[u]). However the migration \nfrom k is allowed since Al6 c!(k[u]), and the network reduces, after communication on c, to: 4goWWll \nI w'n I e44wnI e(W) where P = P@ /z,x~ and A = An {k:loc{u:res(int)}}. The mi-gration from m to e can \nnow take place, allowing the network to reduce, after a further communication, to: amI wn1wkwn I w ~ \nsince A $ c!(k[u]) . In the absence of other agents, the migrations can only be executed in one order \n(k first). cl Example 10. As a filter is updated, contradictory evidence may be obtained about a site, \nin which case the site must be untyped and can safely be assumed to be bad. As an example let r and the \nfilter A = {!:I (!)} be as before, and consider the open network: m([goC. b!(m[dj)c!(m[d])Jj ( C[b?(z[x]:T)c?(wM) \nPI ( e((A)) where T is the same type as b at 1, res(loc[res(bool)]). After the migration from m to e \nand one communication this reduces to W44)II I4k+4wn I W)) where A = Afl{m:loc{d:res(bool)}}. After the \nsecond communi-cation, the network reduces to  eup\"n  I e(w) where A =A il{m:loc{d:res(int)}} = An{m:Ibad}. \n0 4.3 Subject Reduction and Type Safety As we have seen in Section 3.2 partial typing is not preserved \nby the standard reduction relation. However this property is regained by the revised reduction relation \nof Table 5. Theorem 11 (Subject Reduction for Open Networks). For the inference systems of Table 5: If \nr E N and N --+ N then r t- N . cl Example 8. An untyped site will also succeed in sending an agent if \nthe reception site already knows the information being received. Table 6 Runtime Error and others for \nhandling untrusted location names. In a similar vein @z?(X:T)P] 1!((A)) a ifA 9 loc{a:res(T)} j[[a!(v)P]I \n) C((A)) a ifA 9 loc{a:res(T)}, allT @z!(v) PI/ 1[((A)) a if A(l) <: loc{a:res(T)} and Afl {ev:T} undef \n[[if u = v then P else Ql errl, if {eu:T} undef or {tv:T} undef, all T Nerre, Nerre, N=M MerrL, Nerre, \n(vke:T)Ne N/Ma A typing system is only of interest to the extent that it guaran- tees freedom from runtime \nerrors. Here we describe the runtime errors captured by our system, which can be informally described \nas misuse ofresourcesat good sites. Often the formulation of run- time errors is quite cumbersome as \nit involves the invention of a tagged version of the language, see [12, 211. However in this case the \npresence of filters makes it straightforward. In Table 6 we define, for each location e a unary predicate \n-over networks. The judgment N &#38; should be read: in the net- work N there is a runtime error at location \n! . There are two kinds of errors which can occur. The first occurs when an agent attempts to use a resource \nthat has not been allocated at the agent s current location, as formalized in the first two clauses of \nthe definition in Table 6. The second kind of error occurs when there is a local in-consistency between \nvalues being manipulated by an agent. These may occur in either of two ways. The first, accounted for \nin the third clause in Table 6, is when a value is about to be transmitted locally which is inconsistent \nwith the current contents of the filter. The second, accounted for in the fourth clause, is when the \nvalues in a match cannot be assigned the same type. Finally, note that in the case that a location name \nm is restricted, errors at m are attributed to the site which created m (given as k in Table 6). This \nfact explains the need for the side condition T # Ibad on the rules (t-news) and (n-news) in Table 4. \n Theorem 12 ( Ijpe Safety for Open Networks). For the inference systems of Tables 5 and 6: lfr k N and \nr(e) of Ibad then N a. Trust In the semantics of the last section all agents moving to a new site are \ndynamically typechecked before gaining entrance. In this sec-tion we consider an optimization which allows \nfor freer and more efficient movement across the network. The idea is to add trust between locations; \na trusted site is guaranteed never to misbehave and therefore agents moving from a trusted site need \nnot be dynam- ically typechecked. Formally we introduce a new type constructor for trusted Zoca- tion \ntypes, Itrust{ii:A}. The extended syntax of rypes with trust is obtained by replacing the clause for \nlocation types with: K, L ::= lbad 1loc{Z~;,~~} 1Itrust{Z:&#38;ZB} Note that (as with the addition of \nIbad) this extension increases the set of possible resource types. For example the type res(ltrust{a:res(int)}) \nis the type of a resource for communicating trusted locations which have an integer resource named a. \nThus we may have trusted lo-cations with certain resources for handling trusted location names we may \nhave untrusted locations containing resources that commu- nicate trusted location names. As we shall \nsee, these resources at untrusted locations cannot be used to increase the level of trust in a network. \nThe extension of the subtyping relation to these new types is based on two ideas: . Every trusted location \nis also a location. . Every trusted location guarantees good behavior; therefore, a bad or untyped location \ncan never be trusted by a good site. This means that the type lbad is no longer the minimal location \ntype in the subtyping preorder. The subtyping relation is therefore built up using the ordering: loc{iZA} \n?Z loc{ii:;i, v:B} Itrust{ii:ii} /z/ lbad Itrust{Z&#38;v:B} The formal definition is given in the full \nversion of the paper. Proposition 13. The set of types with trust, under the subtyping preordel; has \na partial meet operator: . With the addition of Itrust, the filters in a network may contain more detailed \ninformation about remote sites. Consider a network N which contains a filter !((A)). As before, if k \nis not mentioned in A, this means that e has no knowledge of k. But now there are now three possibilities \nwith respect to a remote location k mentioned in [((Al: A(k) <: Ibad, which means that e has accumulated \nsufficient contradictory information about k to conclude that k is un- typed. A(k) <: Itrust, which means \nthat L trusts k. Note that this no- tion of trust is asymmetric; e may trust k without k trusting e. \nAlso note that in well-typed systems, the rule (n-filter) in Table 5 ensures that k, trusted by e, cannot \nbe an untyped location unless e itself is untyped; this is enforced by the re- quirement that T(k) <: \nA(k), since lbad $ Itrust. A(k) <: lot, which means that L knows of k, but cannot deter-mine whether \nor not k is well-typed. As we have seen in the previous section, the information in a filter may increase \nas the network evolves, i.e. e((A)) may evolve to e((A )), where A <: A. But the subtyping relation between \ntypes en-sures that once a location k is deemed bad in !!((A)) it will remain so forever, and similarly \nwith sites that are deemed trusted . It is only the third category which may change. In Example 10 we \nhave seen that new information may result in A(k) changing from lot to Ibad. We shall soon see that new \ninformation can also improve the status of k from lot to Itrust. With the addition of trust, we can revise \nthe reduction rela-tion of the previous section to eliminate dynamic typechecking of agents arriving \nfrom trusted sites. We adopt the semantics of Table 5, replacing (rf-move) with: (rt-move) kUgoe.FD I \nW)) - euq I e(A)) ifA <: ltrust or A I$ P Note that the presence of ltrust changes the importance of \nthe con- dition lbad <: K in the dynamic typing rule (vf-selfl). Whereas this condition was tautological \nin Section 4, here it i$ not. The side condition precludes the use of (vf-selfl) to infer Al&#38;ltrust. \nThis is important, as it prevents bad sites from becoming trusted. Example 14. LetA= {~:loc{d:res(ltrust)},k:ltrust} \nandconsider the open network !((A)) 1 L [d?(z)P] 1k[goe.d!(m)] 1m[gol.d!(n)l Here the locations m and \nn are unknown to C, i.e. A(m) and A(n) are undefined. In addition, d is a resource at e for communicating \ntrusted locations. The migration from m to e is not immediately allowed since A IF d!(n) cannot be inferred, \nm does not have suffi- cient authority to convince I that location n is to be trusted. The move from \nk to C, however, is allowed, without dynamic typechecking, since e trusts k. After the movement and communi- \ncation on d, the resulting network is  W )) I ww4n I mUgoe.d!(n)D where A = AII {m:ltrust}. Thus, after \ncommunication with the agent from k, e trusts m. At this stage the migration from m to e is allowed, \nfree of typechecking, and m can inform e of another trusted site, n. In this way the web of trust containing \nf? grows dynamically as the network evolves. Note it is crucial that e trust k initially; if this were \nnot the case then the original migration from k to C would have been prevented by dynamic typechecking. \nThere is no way for a site to prove its trustworthiness ; the web of trust can only grow by communication \nbetween trusted sites. 0 Example 15. Consider the network m[goe~.go~l.goW llI 4((b)) where there is \na web of trust among ei; that is Ai <: ltrust for all i, j. Suppose further that Au(m) is undefined, \nin particular that !u does not trust m. The migration from m to Co is allowed only if the following judgment \ncan be verified: Note that this checks not only the potential behavior of the incom- ing agent at the \ninitial site eu but also at the other sites er, e2. So an agent is allowed into the web of trust between \nto, !r and f$ only if can be assured not to harm any resources at any of the locations in the web. Moreover \nthis check is made against the knowledge at the incoming site ee. Even if P intends to respect all the \nresources at &#38;, if it mentions a resource at e2 of which Au is unaware, entry will be barred. If \nthe typecheck against Au succeeds then we obtain the network where the agent from m has gained entry \nto the web of trust. The subsequent movements, from eu to et and from et to C2, are allowed freely because \nof the relationship of trust between these sites. If P moves outside the web of trust, however, say to \nm, and then wishes to return to some ei, then it will be typechecked again before reen- try. In Section \n4, we gave an example which shows that such type- checking is necessary for agents which wish to reenter \na web of trust. 0 Example 16. As a final example, suppose that the set of locations is static and all \nsites are mutually trusted. In this case we recover the standard semantics (module the presence of filters), \nas given in Section 2. 0 The main results of the previous section extend to the new set- ting. Theorem \n17. For the inference systgms of Tables 5 and 6, aug- mented with trusted (rf-move): location types \nand using (rt-move) instead of . If rkNandN-+N thenI?tN . . If r t N and l?(e) # lbad then N 3%. cl \n6 Conclusions We introduced the notion of partial typing, which captures the in- tuition that bad sites \nin a network may harbor malicious agents while good sites may not. We demonstrated that in the presence \nof partial typing, some form of dynamic typechecking is required to ensure that good sites remain uncorrupted. \nWe presented a seman- tics for Drc incorporating such dynamic typechecking, showing that it prevented \ntype violations at good sites. Finally, we added webs of trust to the language, reducing the need for \ndynamic typechecking while retaining type safety at good sites. The presentation of D7r given here is \nvery different from that in [23] but is only a minor variant on that in [ 121; for example, we have added \nbase types and moved some of the semantic rules from the structural equivalence to the reduction relation. \nMost of the changes are stylistic rather than substantive. Two of the changes, however, are essential \nfor the treatment of partial typing. First, we have moved the rule (r-new) from the structural equivalence \nto the reduction relation; this is necessary to allow filter updating. Sec-ond, we have split the space \nof names in two, syntactically distin-guishing locations from resources; this is necessary to prevent \nthe filter updating rules from producing nonsense environments such as {e:loc{e:res()}}. Several other \ndistributed variants of the ~-calculus have been defined, and it is informative to see how partial typing \nmight be added to these languages. Syntactically, I% is most similar to the language of Amadio and Prasad \n[3, 41, which also uses a goto operator for thread movement, written spawn(C,P) . However, in Amadio \nand Prasad s language, the set of resources available to a thread does not vary as the thread moves about \nthe network. This means that an agent at e can access resources at a different loca- tion k without requiring \nthread movement. To add partial typing to such a language, one would need to typecheck message move-ment \ndynamically, rather than thread movement, violating the third principle given in the introduction. The \nfact that resource names are allowed to occur at multiple locations is crucial to the success of our \nstrategy for dynamic type- checking. It would be difficult to formulate our approach under the assumption \nthat each name has a unique location (as, for example, in [4]). For example, suppose that the resource \na was uniquely lo- cated at k. Then the agent m[goe. b!(m[a])] at the bad site m could hijack a using \n(t-selfz), convincing e that a was uniquely located at m, rather than some good location k. In particular \nentry to e by an agent from k may subsequently be blocked because C mistakenly believes that the unique \nlocation of a is m. The join calculus of Foumet, Gonthier, Levy, Marganget and Remy [lo] shares many \nof these properties. Whereas Amadio s language adds thread movement to message movement, however, the \njoin calculus adds location movement. Unfortunately this does not help combat the problems outlined above, \nwhich result from the universal extent of resource names in both subject and object PO- sition. In m, \nthe type system ensures that the extent of resource names in subject position is local, i.e. resources \nmay be referenced at remote sites, but may only be used locally. Cardelli and Gordon s ambient calculus \n[5], on the other hand, appears to be amenable to partial typing since ambient movement is a local operation; \nthus the problem of universal extent does not arise. The typing system of D I[. is based on the original \nsorting system of the ~-calculus [16], and this sorting system has recently been extended to the ambient \ncalculus [7]. Whereas locations in Dn have a straightforward analog in implementations -they cor- respond \nto address spaces -the notion of ambient is more gen- eral, adding expressiveness while blurring the \ndistinction between agent movement and agent interaction. In the ambient calculus it is the open operator, \nrather than the in or out operators, which en- ables interaction between two threads (or thread collections). \nThus a first attempt at partial typing for the ambient calculus would dy- namically typecheck thread \ncollections whenever they are opened. Since each ambient has only one resource (h), however, this im- \nplies that dynamic typechecking must occur before every interac- tion, again violating our thud principle. \nTo get around this, one might introduce a type system for ambients which distinguished two types of ambients: \nthose which typecheck incoming ambients and those which do not. The former would be similar to our lo- \ncations, the later, our resources. This discipline would open the possibility of typing code during in \nand out operations, rather than open. Several studies have addressed the issue of static typing for lan- \nguages with remote resources; some recent papers are [20, 6, 241. Perhaps the work closest to ours is \nthat of Knabe [14], who has implemented an extension of Facile which supports mobile agents. The main \nextensions are remote signatures and proxy structures, which are somewhat related to our location types. \nNone of these works address open systems, however. On the other hand, Necula s proof carrying code [19] \nand related techniques [27,15,18] address the problem of dynamic typechecking in open systems, but do \nnot consider the subject of remote resources. Another area of related work has to do with static methods \nfor analyzing the security of information flow [9, 1, 8, 26, 111. Al- though this area of research share \nour general aims there is very little technical overlap with our approach to resource protection in open \nsystems. Acknowledgments We wish to thank Alan Jeffrey for many in- teresting conversations and the referees \nfor their close reading of the text. A Environment Extension Both subtyping and the partial meet operator \nextend pointwise to environments in the obvious manner: For subtyping we have: A <: P iff VW E dam(r) \n: A(w) <: r(w) The partial meet operator An r is undefined if A(w) n T(w) is un- defined for some w \nE dam(A) ndom(r), otherwise: AI-IT= {w:KIA(w)tlr(w)=K} u {w:K 1 A(w) = K and w $! dam(r)} u {w:K 1 r(w) \n= K and w qi dam(A)} New environments are created from values using the notation {,u:T}, where w E Lot \nU Var. The definition is given by induction on u and T: {wbv:BT} = 0, if bv E valset(BT) {,x:BT} = { \nx:BT} {,k:K} = { k:K} {,x:K} = { x:K} {+A} = {w:loc{a:A}} {,x:A} = {w:loc{x:A}} {,(u,?):K[@} = {,u:K} \nn {, ii:i} {,;;:T} ={,ul:T,}n ~~n{,u :T } For example: {W(O,a):(int,A)} = {w:loc{a:A}} {&#38;k[c]):(loc{u:A},loc[C])} \n= {k:loc{u:A,c:C}}  References HI M. Abadi. Secrecy by typing in security protocols. In Proceedings \nof TACS97, volume 1218 of Lecture Notes in Computer Science, pages 61 l-637. Springer-Verlag, 1997. [21 \nM. Abadi and A. D. Gordon. A calculus for cryptographic protocols: The spi calculus. Information and \nComputation, To appear. Available as SRC Research Report 149 (1998). f31 R. Amadio and S. Prasad. Localities \nand failures. In Proc. 14th Foun- dations of Software Technology and Theoretical Computer Science, volume \n880 of Lecture Notes in Computer Science. Springer-Verlag, 1994. [41 Roberto Amadio. An asynchronous \nmodel of locality, failure, and process mobility. In COORDINATION 97, volume 1282 of Lecture Notes in \nComputer Science. Springer-Verlag, 1997. r51 L. Cardelli and A. D. Gordon. Mobile ambients. In Maurice \nNivat, editor, Proc. FOSSACS 98, International Conference on Foundations of Software Science and Computation \nStructures, volume 1378 of Lecture Notes in Computer Science, pages 140-155. Springer-Verlag. 1998. El \nLuca Cardelli. A language with distributed scope. Computing Sys- tems, 8(1):27-59, January 1995. A preliminary \nversion appeared in Proceedings of the 22nd ACM Symposium on Principles of Program- ming. r71 Luca Cardelli \nand Andrew Gordon. Types for mobile ambients. Draft, 1998. Available from http://wwu. luca.demon. co \n.uk/. f81 Mads Dam. Proving trust in systems of second-order processes. In Hawaii International Conference \non Systems Science. IEEE Com-puter Society Press, 1998. f91 D. Denning. Certification of programs for \nsecure information flow. Communications of the ACM, 20:504-513, 1977. [toI C. Foumet, G. Gonthier, J.J. \nLevy, L. Marganget, and D. Remy. A calculus of mobile agents. In U. Montanari and V. Sassone, editors, \nCONCUR: Proceedings of the International Conference on Concur- rency Theory, volume 1119 of Lecture Notes \nin Computer Science, pages 406-421, Pisa, August 1996. Springer-Verlag. [ill Nevin Heintz and Jon G. \nRiecke. The SLam calculus: Programming with secrecy and integrity. In Conference Record of the ACM Sympo- \nsium on Principles of Programming Languages, San Diego, January 1998. ACM Press. [I21 Matthew Hennessy \nand James Riely. Resource access control in systems of mobile agents. Computer Science Technical Report \n2/98, University of Sussex, 1998. Extended abstract in HLCL 98. Available from http://vuv.elsevier.nl/locate/entcs/ \nvolumel6.3.html. [I31 Matthew Hennessy and James Riely. Type-safe execution of mo-bile agents in anonymous \nnetworks. Computer Science Technical Report 3198, University of Sussex, 1998. Available from http: //wwu.cogs.susx.ac.uk/. \nH41 Frederick Coleville Knabe. Language Support for Mobile Agents. PhD thesis, Carnegie-Mellon University, \n1995. H51 Dexter Kozen. Efficient code certification. Technical Report 98-1661, Cornell University, Department \nof Computer Science, 1988. Avail-able from http: //vvv. cs . Cornell. edu/kozen/secure. [16] Robin Milner. \nThe polyadic n-calculus: a tutorial. Technical Re-port ECS-LFCS-91-180, Laboratory for Foundations of \nComputer Science, Department of Computer Science, University of Edinburgh, UK, October 1991. Also in \nLogic andAlgebra of Spec$cation, ed. F. L. Bauer, W. Brauer and H. Schwichtenberg, Springer-Verlag. 1993. \n [17] Robin Milner, Joachim Parrow, and David Walker. A calculus of mo- bile processes, Parts I and II. \nInformation and Computation, 100: l- 77, September 1992. [18] Greg Morrisett, David Walker, Karl Crary, \nand Neal Glew. From Sys-tem F to typed assembly language. In Conference Record of the ACM Symposium on \nPrinciples of Programming Languages, pages 85-97, San Diego, January 1998. ACM Press. [19] George Necula. \nProof-carrying code. In Conference Record of the ACM Symposium on Principles of Programming Languages. \nACM Press, January 1996. [20] Atsuhi Ohori and Kazuhiko Kato. Semantics for communication primitives \nin a polymorphic language. In Conference Record of the ACM Symposium on Principles of Programming Languages, \nCharleston, January 1993. ACM Press. [21] Benjamin Pierce and Davide Sangiorgi. Typing and subtyping \nfor mobile processes. Mathematical Structures in Computer Science, 6(5):4&#38;I-454, 1996. Extended abstract \nin LICS 93. [22] James Riely and Matthew Hennessy. Trust and partial typing in open systems of mobile \nagents. Computer Science Technical Report 4/98, University of Sussex, 1998. Available from http: //vvv. \ncogs. susx.ac.uk/. [23] James Riely and Matthew Hennessy. A typed language for distributed mobile processes. \nIn Conference Record of the ACM Symposium on Principles of Programming Languages, San Diego, January \n1998. ACM Press. [24] Tatsurou Sekiguchi and Akinori Yonezawa. A calculus with code mo-bility. In FMOODS \n97, Canterbury, July 1997. Chapman and Hall. [25] Peter Sewell. Globahlocal subtyping and capability \ninference for a distributed n-calculus. In Proceedings of ICALP 98: International Colloquium on Automata, \nLanguages and Programming (Aarhus), number 1443 in LNCS, pages 695-706. Springer-Verlag. July 1998. \n[26] Geoffrey Smith and Dennis Volpano. Secure information flow in a multi-threaded imperative language. \nIn Conference Record of the ACM Symposium on Principles of Programming Languages, San Diego, January \n1998. ACM Press. [27] Frank Yellin. Low-level security in Java. In WWW4 Confer-ence, 1995. Available \nfrom http://vvv. javasoft. com/sfaq/ verifier .html.  \n\t\t\t", "proc_id": "292540", "abstract": "", "authors": [{"name": "James Riely", "author_profile_id": "81100072255", "affiliation": "Department of Computer Sciences, North Carolina State University, Raleigh, NC", "person_id": "PP39082385", "email_address": "", "orcid_id": ""}, {"name": "Matthew Hennessy", "author_profile_id": "81100207163", "affiliation": "School of Cognitive and Computing Sciences, Univ. of Sussex, Falmer, Brighton, BN1 9QH UK", "person_id": "PP39073053", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/292540.292551", "year": "1999", "article_id": "292551", "conference": "POPL", "title": "Trust and partial typing in open systems of mobile agents", "url": "http://dl.acm.org/citation.cfm?id=292551"}