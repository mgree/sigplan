{"article_publication_date": "01-01-1999", "fulltext": "\n A Compositional Account of the Java Virtual Machine Phillip M. Yelland Sun Microsystems Laboratories \n910 San Antonio Road, MS MTV29-117 Palo Alto, CA 94303-4900. +l 650 336 2542 phillip.yelland@sun.com \nABSTRACT The Java Virtual Machine (or JVM) is central to the system s aim of providing a secure program \nexecution environment that operates identically on a wide variety of computing platforms. To be most \neffective in this role, the JVM needs a rigorous, complete description, to specify precisely the behavior \nrequired of implementations. In response, a number of researchers have produced formal accounts of the \nJVM that seek to define it in an unambiguous and comprehensible manner. Unfortunately, the size and complexity \nof the JVM means that many of these for-mal accounts must either restrict their scope substantially, \nor risk becoming unwieldy and intractable. This paper suggests an al- ternative approach to the specification \nof the JVM that seeks to ameliorate such problems by composing together a small set of microinstructions \nto produce the full bytecode set. These mi-croinstructions are encapsulated as functions in the polymorphic \nfunctional programming language Haskell, using the familiar mechanisms of Hindley-Milner type inference \nto characterize the JVM s rather thorny verifier. In this way, its is hoped that a foundation will be \nlaid for formal descriptions of the Java Vir- tual Machine that need not trade tractability for completeness. \n Keywords Java Virtual Machine, Java bytecode, verification, Haskell. 1. Introduction The write once, \nrun anywhere claim attached to Sun s Java technology rests on the abstract computing architecture specified \nby the Java Virtual Machine (or JVM). The JVM details a secure execution environment for programs encoded \nas bytecodes that operates identically across the entire spec-trum of host platforms. The consistency \nof implementations on these different platforms is clearly promoted by a precise, accurate description \nof the JVM. As the scope of the Java application environment expands, and as a growing number of vendors \nother than Sun produce clean room implemen-tations of the system without reference to Sun s source code, \nthe need for a rigorous specification of the JVM grows in-creasingly exigent. The JVM is quite complex, \nsporting as it does over 200 CISC-style bytecode instructions. Furthermore, the progeni-tors of the Java \nprogramming language sought to expedite program execution by incorporating a verifier into the JVM, to \nreject errant programs on the basis of a (fairly compli-cated) static code examination. The complexity \nof the JVM bedevils the task of producing a description. Perhaps unsur-prisingly, therefore, the original \nnarrative account of the JVM published in [LY96] is ambiguous and incorrect in a number of respects [SA98]. \nOn the other hand, the only in-controvertibly accurate description of the architecture -the source code \nfor the JVM interpreter itself -hardly admits ready inspection. In order to address these shortcomings, \na number of re-searchers [C97] [FM981 [G97] [Q98] [S97] [SA98] [HT98] have formulated mathematical descriptions \nof the Java Vir-tual Machine, yielding valuable insights into its performance. Unfortunately, the size \nand complexity of the JVM means that most of these accounts must either restrict their ambit to one or \ntwo facets of the Virtual Machine or risk becoming unwieldy and intractable. This paper propounds a different \napproach to the formal de-scription of the JVM, resting on the specification of a core micro-JVM (the \npJVM) that specifies the primitive opera-tions elicited by the bytecodes. The bytecodes themselves are \nspecified by composing together the microinstructions fur-nished by the PJVM. The specification is rendered \nas a pro- gram written in the functional programming language Haskell [P+97], yielding a description \nthat is executable, as well as modular. It is also attractive as regards formal rea-soning, since it \ncaptures the knottier features of the verifier using the familiar mechanisms of Hindley-Milner type infer-ence. \nThe actual account of the Java Virtual Machine presented here is far from comprehensive; a more complete \ntreatment - currently in preparation -is described in [Y99]. The in-tent of this paper is merely to illuminate \nthe thesis that it is possible to structure a compositional description of the JVM using well-established \nprogramming techniques. For a fuller discussion of related work, see section 8. 1.1 Overview of the Paper \n The next section gives an informal sketch of the Java Virtual Machine, highlighting those features that \nare tricky to char-acterize formally. A discussion of the l.tJVM follows, starting with its dynamic behavior \nand continuing with its static se-mantics. A soundness result shows that for any instruction set (and \nby extension, program) composed of pJVM microin-structions, type-checking in Haskell corresponds to verifica-tion. \nThen a sample of the Java bytecodes is specified using the microinstructions. Finally, comparisons are \ndrawn with related work, and some indications are given of possible fu-ture development.  2. Highlights \nof the Java Virtual Machine 2.1 Overall Structure Most readers are doubtless familiar with the role of \nthe JVM as envisioned by its original designers: Class files -com-prising bytecodes and linkage information \n-are assembled from a variety of sources and passed over a network to the host machine, where they are \nexecuted by an implementation of the JVM. Since the JVM has no indisputable information concerning the \nprovenance of the class files it is executing, it must examine the bytecodes therein to ensure that they \ndo not perform illegal operations. To speed execution, almost all existing implementations of the Java \nVirtual Machine use a verifier to perform the bulk of this examination statically. Given that a class \nfile has passed muster, its execution need not be encumbered by many time-consuming run-time checks. \n 2.2 Features of the Architecture The JVM is a stack machine that manipulates data repre-sented by words. \nA word is an abstract quantity that may rep-resent primitive values of byte, char, short, int or float \ntypes, ref-erences to objects, code addresses or native pointers. Words are used in pairs to represent \nvalues of type long or double. A JVM stuck comprises a collection of frames, each associated with the \nexecution of a single method. A frame in turn con-sists of two components: a collection of local variables \nand an operand stuck. Local variables are accessed directly by index, and hold values specific to a given \nmethod invocation. An operand stack contains a number of words that are ac-cessed implicitly on a last-in-first-out \nbasis by the JVM bytecodes. Finally, the VM incorporates a heap that contains objects. 2.3 Characteristics \nof the Verifier A majority of the JVM bytecodes have operands and results of specified types. Therefore, \nthe fundamental responsibility of the verifier is to ensure that all the methods in a class file respect \nthe typing constraints of their constituent bytecodes. Two other features of the verifier have proven \nof particular interest to researchers; its treatment of subroutines (used in the compilation of the try...finally \nclause of the Java program-ming language [SA98] [HT98]), and the restrictions it ap-plies to the initialization \nand use of objects [FM98]. Subroutines in a method are simply sequences of bytecodes, distinguished in \nthat control passes into them by way of the jsr instruction. The verifier allows the types of local vari-ables \nto vary between different invocations of the same sub-routine, provided those variables are not accessed \nfor the du-ration of the subroutine. This is of some convenience to the compiler, though it significantly \ncomplicates the verifier - see [LY96], [SA98] and [HT98] for more details. To preserve the integrity \nof objects, the verifier requires that a newly created object be initialized prior to its first use.3 \nAgain, proper treatment of object initialization in the verifier is complicated; indeed, as [FM981 point \nout, at least one ver-sion of Sun s own implementation performed incorrectly in this regard.  3. Preliminaries \n3.1 Omissions Paucity of space means that the account of the JVM given in this paper is necessarily simplified. \nFor example, the PJVM described here supports only two primitive data-types (inte-gers and floating-point \nnumbers), rather than the full panoply of primitive types in the real JVM. It only provides for the most \nbasic manipulations of objects (viz. creation, initializa-tion and virtual method invocation) -omitting, \nfor example, static method invocation and direct field access. All methods in this account return integers, \nwhereas in actuality, of course, object references and values of other primitive types may be returned. \nThe specification leaves out the JVM s ex-ception facility, and classes have been simplified -rather \nthan distinguishing proper classes from interfaces, only classes with multiple inheritance are described. \nNo attempt has been made to give an account of multi-threading capa-bilities, or of native method invocation. \nExperience devel-oping the more complete account in [Y99] and related work by Jones [J98] suggest that \namending most of these omis-sions (barring multi-threading) is tedious but not technically infeasible. \n 3.2 Haskell Syntax Only a subset of Haskell is used for the definitions in this paper, and some typographic \nlicense has been applied (hope-fully not too egregiously) in an attempt to render it more widely accessible. \nNonetheless, since much of the following discussion centers on a Haskell program, a few explanatory remarks \nfor the benefit of non-aficionados may be found in the appendix. 3.3 Methods and Contexts The account \ncenters on the verification and execution of a single method termed the current method.4 It is assumed \nthat the de-scription of the program surrounding the current method is given exogenously by a context. \nIn addition to specifying the class hi- 2 Control normally returns from a subroutine by way of the ret \ninstruction to the point of invocation, though abnormal exit is also possible. 3 Using an object may \ninvolve invoking a method on it or ac-cessing one of its fields. 4 The current method must not be a constructor, \nsince this would involve further verification restrictions; coverage of such methods is discussed in \n[Y99]. erarchy of the surrounding program, the context defines the local it simply refers to the run-time \nrepresentation of the respec- variables and a number of other entities required by the current method. \nFor this exposition, a particularly simple context has been chosen.  4. Dynamic Semantics of the pJVM \nThe specification of the l_tJVM is divided into two parts: In this section, the intent is to capture \nthe dynamic behavior of the JVM as a series of Haskell functions. The next section shows how the static \ntypes of these functions can be arranged to characterize the verifier. 4.1 Datatypes Declarations of \nthe datatypes underpinning the pJVM are given in figure 1. At this stage, apparently superfluous type \nvariables appear in some of the declarations; their use should become evident when static semantics are \ndiscussed in the next section 4.1.1 Words The datatype Word corresponds directly to the JVM s funda-mental \ndata unit. It is defined as a tagged variant, containing integers or floating-point numbers, code addresses, \nor refer-ences to objects. Integers and floats are represented directly by their Haskell equivalents, \ncode addresses by values (actu-ally, function values) of (variable) type k, and references by integers \nidentifying the location of the object referred to in the heap. In common with elements of the other \npJVM datatypes, words are abstract, manipulated only by using microinstruc-tions.5 Figure 2 displays \nmicroinstructions for composing and decomposing words containing integers and floating point numbers. \nThere are no microinstructions that provide direct access to words containing code addresses or object \nrefer-ences, since they could compromise the integrity of the VM. 4.1.2 Classes and Objects The illustrative \ncontext used in this pa- per (featured in figure 3) describes four classes in the inheritance hierarchy \nde- picted opposite. Each class is repre- C sented by two Haskell values that em- body the dynamic and \nstatic aspects of the class respectively. The Haskell data-structure implement-ing the dynamic behavior \nof classes -JClassRT -simply defines a collection of constants used to identify the classes in the context. \nFurther definitions (not shown) define an op-erator I on these constants, describing the subtype rela-tionships \nof the corresponding classes (so that we have Tagn< Taga, for example, but not Tagc I Taga). The data-structure \nrepresenting the static aspects of each class is JClaas; from the point-of-view of dynamic semantics, \nTechnically speaking, the Haskell module defining the pJVM exports no constructors of type Word. tive \nclass.6 The Haskell value representing a method -an instance of the datatype Method -indicates its implementing \nclass and the integer value it returns (recall that in this account, a method simply returns an integer). \nObjects are represented by a Haskell record with three named fields. The field tag contains one of the \nrun-time class identi-fiers described above, specifying the class of which the ob-ject is an instance. \nThe initialized field is used to enforce the restrictions on the use of new objects described in section \n2.3. The site field specifies the code position of the object s allocation, and is bound to a value provided \nby an instance of the Site datatype -its purpose is explained further in section 5.  4.1.3 Machine State \nThe yJVM state describes the operand stack, the local vari-ables and the object heap. Each component \nof the machine state comes with its own type, resulting in the Haskell decla-ration of VMState shown. \nThe operand stack is described simply by series of words, nested in pairs, LISP-fashion; the empty stack \nconsists of the trivial tuple 0 . Thus a stack consisting of the three integer words 1, 2 and 3 is denoted \n(Wlnt 1, (Wlnt 2, (Wlnt 3,()))) . The values of local variables used in a method are repre-sented by \ntuples of values. The length of these tuples (and hence the number of local variables available) is fixed \nfor a particular method (in this case, the are three local variables). For each local variable, the context \nprovides a value of type Local that permits retrieval and update of the appropriate ele-ment of these \ntuples (see figure 3 for an example). The heap has two constituents: a function store mapping ref-erences \n(i.e. integers) to objects, and a high watermark (hwm) recording the integer value of the last reference \nallo-cated in the heap.7  4.1.4 Encapsulating State Transformations A straightforward representation \nof instructions would be as functions mapping one machine state to another. Unfortu-nately, couching \nthe pJVM specification in this style would make it impossible to use Haskell s type system to track the \nuse of object references. Therefore the ,uJVM follows estab-lished practice in the functional programming \ncommunity by employing a monadic style of presentation [W92] [PJW93]. Actually, the need to account for \njumps and subroutine calls and the complex type structure of the microinstructions make it expedient \nto use a mutable abstract datatype, which Hudak derives from the monadic approach in [H92]. 6 Note that \nthe representation of a Java class in the pJVM is un- related to Haskell s own class construct as described \nin [P+97]. 7 The pJVM allocates references sequentially from 1. 8 See [W92] and [H92] for details.  \ndate Wordtk = Wlnt Int ) WFloat float 1WAddr k 1WRef Int data JClassRT = TagA I Tag6 I Tasc I TagD data \nJClass t = Ml&#38;lass JClassRT data Metiodpn = MkMethcd (JClass @, n)) Int data Site t = MkSie Int \n data Object = MkObject {tag :: JClassRT, initialized :: BOOI, site :: lnt} data VMStateslh = MkVMState \n{stack :: s, locals :: /, heap :: h) data Localgs = MkLocalgs data Heap t = MkHeap {store :: Int -+ Object, \nhwm :: Int) data contslh = MkCont{cfn::VMStateslh-+Int) Figure 1: Datatypes in the yJVM inlnt v = Wlnt \nv inFloat v = WFloat v outlnt (Wlnt v) = v outlnt _ = error Verifv error: Integer word expected  outFloat \n(WFloat v) = v outFloat _ = error Verifv error: Floating-point word expected Figure 2: Microinstructions \ncomposing and decomposing words classA = MkJClass Tag, . . . -ho, Cks%, chs~, ClassI, metho&#38; = MkMethod \nclassA 0 . . . -Also, methods, methodc, method0 I%= k&#38;Local (Uv,, &#38;, v2).vo, h(vo, v~, v~) v. \n(v, v~, v~)) . . . -Also, Iv,, Iv* site, = MkSite 1 . -Also, site2, sites Figure 3: Context definitions \nExpression.. . . . .denotes a continuation that.. . result w Simply returns the word w when invoked. \npushs want Pushes the word w onto the stack before executing cont. popsfn Pops the value of the stack \nand passes it to fn before executing the continuation that results. getl I fn Extracts the value of local \nvariable /, passes it to fn and then executes the resulting continuation. set1I w cod Sets the value \nof local variable I to w and then executes cant jump amt mt Transfers control to continuation cant when \ninvoked; continuation conf is ignored. link fn ant Forms a word from continuation cent and passes it \nto f?~, executing the resulting continuation. unlink w cant Extracts a continuation from word wand executes \nit; continuation cantis ignored. allocate s d fn Allocates an object with site s and class cl and passes \na reference to the new object to function fn, executing the resulting continuation. initialize w cmt \nInitializes the object referred to by word wand executes continuation conf. call m wf% Invokes method \nm on the object referred to by word w, passing the result to function fin executing the continuation \nreturned. Figure 4: @VM microinstructions manipulating continuations result w = MkCont (hvms w) pushs \nw (MkCont cfn) = MkCont (hvms let MkVMState (stack = s} = vrn.s in ch vms(stack t (w, s)}) pops fh = \nMkCont ( hvms. let MkVMState (stack = (w, s)} = vms (MkCont cfn) = fn w in cfh vms(stack = s}) set1 \n(Local gfrsfr) w (MkCont cfn) = MkCont (hvms let MkVMState (locals = /} = vrns in crh vms(locals t sfrl \nw)) get1 (Local gtr sfr) fn = MkCont ( hVt?JS. let MkVMState (locals = I ) = vrns (MkCont crb) = fn(gfr/) \nin cfilvIns) jump I k= I link fn cant= th (inAddr cant) update store ref ot$ = htef . if ref == ref \nthen obj else store ref -Auxiliary function; not public allocate (MkSite o&#38;e) (MkJClass c&#38;g) \nfn = MkCont ( Avms. let MkVMState( heap = hp) = vms MkHeap (store = s, hwm = hi) = hp newref= hi+ 1 \nS = update s newref(MkObject (tag = Crag, initialized = False, site = o&#38;e)) (MkCont &#38;I) = fn \n(WRef newrel) in ch vms( heap = hp( store = s , hwm = newrel))) initialize (WRef ret) (MkCont ch) = MkCont \n( hvms. let MkVMState ( heap = hp) = vms MkHeap (store = s, hwm = hi) = hp in if (refc 0 11 ref> h4 then \nerror Yerifv error: Illegal reference else let obj= sfefin if initialized objthen error Verifv error: \nIllegal initialization else let .4 = update s refobj(initialized = True) in dn vm.s( heap = hp( store \nt S ))) call (MkMethod (MkJClass imptag) m&#38;t) (WRef ret) fn= MkCont ( hvms. let MkVMState ( heap \n= MkHeap (store = s, hwm = hi)) = vms in if ( ref < 0 11 ref > hi) then error Verifv error: Illegal reference \n else case (s ref) of MkObject ( initialized = True, tag = otag) 1 otag < imp&#38;g -+ let (MkCont cfn) \n= fn (inlnt mrsk) in cfn vms _+ error Verifv error: Illegal method invocation ) evaluate (MkCont &#38;) \n= I&#38;I initialstate where initialstate = MkVMState () (Wlnt 0, Wlnt 0, Wlnt 0) emptyHeap emptyHeap \n= MkHeap (store = (hi. undefined), hwm = 0) Figure 5: Dynamic description of microinstructions Thus instead \nof exporting the representation of the machine instruction evaluate, which applies the enclosed function \nto an state itself, the pJVM provides a type representing an en- initial machine state. capsulated continuation. \nof type Cant -contains Such a continuation a function (cfn) that -an instance maps a machine 4.2 Instructions \nstate to the final answer produced by a computation. To exe- The majority of the microinstructions provided \nby the FJVM cute an encapsulated continuation, it is passed to the pJVM are functions that manipulate \nencapsulated continuations. Descriptions of these functions are given in figure 4, with implementations \nin figure 5. To see how the implementations operate, consider as an ex-ample the call instruction, used \nto invoke a method on an ob-ject. The three arguments to this instruction represent -re-spectively -the \nmethod to be invoked, a reference to the object upon which the invocation is to take place and a func- \ntion that returns a continuation when supplied the result of the invocation. The continuation created \nin the body of the instruction retrieves the object from the heap, verifies that it is initialized and \nthat the class indicated by its tag field im-plements or inherits the method. If so, the execution contin-ues \nwith the continuation returned by the application of the function argument to the result of the method \n(the latter is incorporated into a Word using the inlnt function). Otherwise, an error is reported. 5. \nStatic Semantics of the pJVM This section shows how types may be assigned the pJVM microinstructions \nto emulate the actions of the verifier in the JVM. 5.1 Outline Essentially, each microinstruction is \ngiven a Haskell type that specifies the transformations it effects on the machine state.g For example, \npushing an integer onto the operand stack might be specified by the type VMState s I h + VMState (Int, \ns) I h, and popping an integer by VMState (Int, s) I h + VMState s I h. Bytecode verification then amounts \nto checking the compatibility of instruction types. To return to the example, the legality of pushing \nan integer onto the stack and then popping an integer off again follows from the le-gality of composing \nfunctions with the types given. Were the second type instead to be VMState (Float, s) I h + VMState s \nI h, say -indicating the popping of a floating-point number -the two types would be incompatible, and \nthe corresponding code would be rejected. The treatment of method invocations, the proper typing of words, \nand the features of the verifier outlined in section 2.3 complicate the process of giving types to instructions, \nas the following sections illustrate. 5.2 Encoding Subtype Relationships The verifier is required to \nsafeguard all method invocations by ensuring that the class of the object upon which a method is invoked \nimplements or inherits that method. This can be accomplished by associating a type with each object refer-ence, \nindicating the class of the referee. If the type of a method indicates the class that implements it, \nestablishing the legitimacy of a method invocation amounts to verifying a subtype relationship between \nthe types of the method and the reference involved. Haskell s type system provides no direct means of \nrecording subtype relationships, but there is a well-established device Lay aside for the moment the \nenvelopment of state transfor-mations in continuations and regard microinstructions simply as functions \nfrom states to states; the treatment of continua-tions is taken up later on. that allows such relationships \nto be encoded. This device originated in the work of Remy [R89] dealing with the type-checking of variants \nand records; the adaptation outlined in [CF91] proves meet for the purposes of the l.tJVM. The encoding \nmay be motivated by considering the addition of a number of basic type symbols, c,, . . . , c,, , to \nthe Haskell type system. These symbols represent classes in a hierarchy, partially ordered by a subtype \nrelation, 5. [M91] shows how this subtype relation may be canonically extended to permit subtype judgements \nbetween matching higher types. RCmy s device allows type expressions in this enriched lan-guage to be \nencoded in the original Haskell type system so as to reflect this extended subtype relation. Let T and \nF be two distinct (Haskell) type constants. The en-coded representation of each class ci symbol consists \nof two tuple types, ci+ = (c,: ,,... ,c:,,) and c,-= (cl: ,,... ,c,,), where for llj<n: 1T iffc;Ic: CiT,= \nI 6 v (where v is a fresh type variable) otherwise V iff cj 5 ci c,{j = F otherwise  At higher types, \nthe encoding is extended according to the variances of the type constructors involved wrt. the subtype \nrelation. So for example, the function type constructor (which is contravariant in its first argument) \nis encoded: (z, --;, r2)+ = z; -+ z; (r, + r2)-= z: + z, For types zand a, let z = cr be true iff there \nis a substitution on type variables, S, such that the action of S on both types produces the same result \n-i.e. S(z) = S(o). Structural in-duction on types establishes that: = 0; iff 0, 5 u2 of One consequence \nof this is that if an expression f in Haskell (representing a method, for example) has the type (a,+p)+=o;+p+, \nand expression e (an object refer- ence, say) has type al, then Haskell s type system will ad- mit the \napplication f e precisely when the required subtype relationship (viz.0, 2 a,) holds. As RCmy indicates, \nthis technique can also be used to type variants, such as the datatype Word used in the PJVM. In ef- \nfect, the required encoding repre- sents the contents of Words using the type hierarchy de- WRef pitted \nopposite. WFloat WAddr Types Wlnt, WFloat, WAddr and WRef are disjoint types representing words containing \nintegers, floating-point numbers, return linkages and object references Operation Precondition Postcondition \nAllocation of an object at site i AI(i) 7 AI(i) Initialization of an object with site i 7 AI(i) AI(i) \nUse of an object with site i AI(i) AI(i) Figure 6: Initialization and operations on objects respectively. \nType o represents words whose contents are This encoding of AI(i) in the type of the heap permits the \nindeterminate in nature. pre-and postconditions listed in figure 3 to be reflected in the types of the \noperators to which they apply. Picture allo- These types are encoded as pairs of quadruples, again using \ncation, for instance, as a function from heaps to heap. Thenthe flag types T and F. For example, Wlnt \ngives rise to the given three possible allocation sites, allocation of an objectfollowing pair: at site \n1 would have type: Wlnt = (T, vf, v, v.), Wlnt-= h F, F, 6 Heap Cr, SZ, 53) + Heap (F, SZ, ~3)   5.3 \nInitialization Since the allocation operation is parameterized by site, this type information is actually \ncarried by the Site values definedThree kinds of instruction affect or are affected an object s in the \ncontext. Some microinstructions are not provided di- rectly with the site at which an object was allocated \n-. Allocation of an object at site i, which results in the initialization: merely a reference to the \nobject in question. Therefore, the creation of an uninitialized object. reference itself carries the \ntype information associated with . Initialization of a (necessarily uninitialized) object. the site. \n. Use of an object, which requires that the object be ini- 5.4 Polymorphic Subroutines tialized. A pleasant \nconsequence of using Haskell s type system is The pJVM ensures that at any point in the execution of \na that no special provision is required to deal with polymor-method, only one object with a given site \nmay be uninitial-phism in Java bytecode subroutines; one simply defines a ized.12 To maintain this invariant, \nand the provisos attached bytecode subroutine as a polymorphic Haskell function com-to the operations \nlisted above, pre-and post-conditions are posed of pJVM microinstructions. In fact -though space imposed \non each operation. These are tabulated in figure 6, limitations preclude a detailed discussion -it is \npossible to where the predicate AI(i) indicates that all objects in the use Haskell s reordering of top-level \ndeclarations [P+97] to heap with site i are initialized. identify subroutines in a method automatically. \nThis parsi- mony of effort concerning subroutines contrasts with otherThe value of AI(i) may be coded \nin the type of the heap -research in the area -such as [SA98] or [HT98] -which once again, using tuples \nof types T and F. The declaration of has centered on the construction of frameworks for just thisthe \ndatatype Heap in figure 1 parameterizes the datatype with purpose. a type variable. For heaps created \nduring program execution, this type variable is instantiated with a tuple of types, It not without attendant \nliabilities, however. For instance, the (0 i, . . . , 0,) , where n is the number of allocation sites \navail-polymorphism accorded bytecode subroutines with this ap- proach is considerably more general than \nthat originally de- able. Furthermore, for any heap of type Heap z, the pJVM scribed in [LY96]. In [LY96], \nfor example, the height of the ensures that: operand stack must be equal at every call to a given subrou-AI(i) \n@ z = (a ,,..., oi_,,T ,..., a,) tine; by contrast, the pJVM allows stack heights to vary. Whether this \nadded generality constitutes a significant disad-vantage is not clear. Certainly, the pJVM s verification \nmechanism is sound, in as far as it prohibits unsafe code. Furthermore, this is not the first formal \naccount to generalize lo In actual fact, the type Wtnt depicted here represents a family the description \nin [LY96] (see [Q98] or [FM98], for exam-of types, indexed by the type of the continuation contained \nin ple), though it is substantively more general in this respect the word. Likewise, WRef also comprises \na family of types, in-than those that preceded it. dexed by class and site encodings. Additionally, an \nML-style type inference system like i Recall from the earlier discussion that each object created in \nHaskell s has exponential complexity in the worst case, the current method is associated with a site \nthat uniquely whereas the dataflow analysis used to analyze the more re-identifies the instruction that \nallocated it. stricted polymorphism allowed in [LY96] appears to be worst-case polynomial. However, ML \ntype inference is al- * This stricture is the same as that advanced in [FM98]. Note most always well-behaved \nin realistic applications, and this that this does not preclude two or more objects allocated at certainly \nseems to be the case for all of the (admittedlydifferent sites being uninitialized at the same time. \nsmall) Java programs verified to date using the framework described here. inlnt :: Int + Word (Wlnt \n, ch) k outlnt :: Word (Wlnt-, ch) k-+ Int inFloat :: Float + Word (WFloat , ch) k outFloat :: Word (WFloat-, \nch) k-t Float result :: Int -3 Cont s I h pushs :: Wordtk+Cont((Wordtk),s)/h+Conts/h POPS :: (Word t \nk+ Cont s I b) -+ Cont (Word f k, s) I h  allocate :: Site (It, H, r) -3 Class (CT, cm) -3 (Word (WRef \n, (cr, r)) k+ Cont s /(Heap If)) --f Cont s I (Heap b) initialize :: Word (WRef -, (c, (h, n))) k-t \nCont s I (Heap b ) + Cont s I (Heap b) call :: Method n m--f Word (WRef _, (m, (II, H))) k+ (Word (Wlnt \n, ch) K -+ Cont s /(Heap H)) + Cont s I (Heap /I ) evaluate :: Cont ( ) (co, co, co) (Heap (T, T, T)) \n-+ Int Figure 7: Static types for microinstructions classA :: Class ((T, T, T, T), (a, b, c, d)) classs \n:: Class ((a, T, c, T), (F, b, F, d)) c1ass.c :: Class ((a, b, T, T), (F, F, c, d)) classD :: Class ((a, \nb, c, T), (F, F, F, d)) site1 :: Site UT, sr,~3)~(F,sr,~3)~W, s,f), CL s,0)) site2 :: Site (61, T, SJ), \n@I, F, %3), ((s, F, 0, (s, T, f))) sites::Site ((~1, ~2,T), 61, 4, 0 ((s, t, 0 (s, t TIN  Figure 8: \nStatic types for context definitions example, the first continuation in the type of the operation 5.5 \nTypes for the Microinstructions pushs -of type Cont (Word f k, s) I h -must be applied to a Figure 7 \nshows how the techniques discussed above are machine state in which there is a word of type Word fkon \ntop combined to produce static types for the microinstructions of the stack. whose dynamic semantics \nwere defined in section 4.2.13 An- cillary type assignments to the definitions in the context are Using \nthe call instruction once again as an example, observe disolaved in figure 8. how its static type reflects \nthe dynamics of the operation. The method to be invoked carries with it both components In the real pJVM, \nmicroinstructions effect transformations (i.e. cf and c-) of the encoding of the class that implements \non encapsulated continuations, rather than directly on the it; these are bound to the type variables \nn and m in the type of machine state as was supposed in the above discussion. Like call. The second argument \nto the instruction is an object ref- machine states, encapsulated continuations are associated erence; \nit is typed with the variant encoding for words con- with three types, but rather than describing directly \nthe dis- taining references according to the method laid out in section positions of the stack, local \nvariables and heap, these types 5.2. The type of the reference incorporates the encoding of determine \nthe configuration of those components in any ma- the class implementing the method, too. Thus any object \nref- chine state to which the continuation may be applied. For erence presented to the instruction must \nbe of the imple- menting class or one of its subclasses. The reference s type also includes site information \nas described in 5.3; in any heap whose type matches h: all objects (including this one) I3 For clarity, \nthe type expressions in figure 7 use the unex- allocated at the same site as the object must be initialized. \npanded forms of the variant encodings introduced in section The type of the third argument -the rest \nof the method - 5.2. indicates a function accepting an integer-valued word (the result of the method \ninvocation) and a heap matching H. pWoW lnt+. I,) 11(W,nt A i), for all i E Int\\{ VError) pW~ dCWF ~~ \n+ .f,)r, (,,,,,=,oat f), A for allf E Float\\{VError} pWoW Addr+.W, (WAddr ,_), A for all c E t,\\(VError) \n,~~2~~~~~~~ass~ ~J ( WRef i), for all i E Int\\{VError), c E (A,B,C,D), and 1 I j < 3, where , . classes \n= [i H Tag,], sites = [i i+ j], x, = ((F, s, f), (T, s, t)), z, = ((s,F, t), (s, I-, t)), C, = ((s, t, \nF), (s, t, T)) S (( )) A spq@v, s)) H PJ (Iv) A s? (s) L~ . z. 3 ((w,,w,,w,)) iff PiI A P2(w2) A P$(w3) \nallot G [ 1,. . . , h], and H~~~~~~Is3,$,,,(MkHeaph S) iff v i E allot. tag(si) E classi A site(si) = \nsite(i), and I for 1 I i 5 3, si = T iff Vj E (1,. . , h]. site(s j) = site, + initialized(s j) v,VMStaterl \nZr~(MkVMState s I h) iff S,$ (s) A 4 (1) A H:(h) Conttl 2 ) (MkCont cfi) iff VpStatefl fz 3 (vms) * (cfi~ \nvms) # VError ps P;(v), for t P (Word t, t2, Cont t, t, tg] and v # VError, otherwise Figure 9: Indexed \npredicates Lastly, the type of the fourth argument -the method up to the instruction -specifies (by virtue \nof its heap type) that the object must be initialized prior to the invocation.  6. Soundness for the \npJVM The soundness proof outlined in this section demonstrates that for a fairly extensive class of expressions \nwritten using the pJVM microinstructions (appropriately combined, if de- sired, to produce bytecodes), \nendorsement by the Haskell type-checker eliminates the possibility of verify errors during execution. \nUnfortunately, space constraints permit only a sketch of the full proof, and a number of significant \nformal details have been omitted -a full account may be found in [Y99]. The proof relies on two assumptions \nA denotational interpretation is provided for Haskell, comprising a Henkin model [M96] with a (pointed) \ncom-plete partial order (CPO) for each type. By abuse of no-tation, a closed type expression will often \ndenote its cor-responding CPO in this model. In the Haskell language definition [P+97], the result of \ninvoking the error function is deemed formally equivalent to non-termination. 4 However, almost all implementa-tions \nof the language actually terminate a program in-voking error, printing out (at least) the string passed \nas an argument to the function. The proof assumes that it is in- deed possible to distinguish errors \nof the form Verifv emor: . . . raised by microinstructions in the pJVM. Technically, I4 This is convenient \nin establishing the soundness of the Haskell type system. this is expressed by adding the element Error \nto the sets representing types Int and Float (since all instructions pro-ducing verify errors result \nin values of those types). If a program is formally non-terminating as a result of pro- ducing a verify \nerror, its denotation is VError. Assume a set of typed term constants containing the usual arithmetic \nand fixed point operators, and all the 1JVM mi-croinstructions (typed according to figure 7) except evaluate.16 \nThen for constants c in this set and variables X, define a set of method expressions, m and evaluation \nexpressions, e : m ..- .-cJxIm,~Ihx.mIletx=m,inm, .._ e ..-evaluate m 1let x = m In e The denotation, \n[ en, of an evaluation expression may be de-rived using the model specified in assumption 1 above, inter- \npreting each microinstruction using its definition in figures 2 and 5. The assertion r 1 e indicates \nthat expression e is well-typed wrt. the Haskell type system given an assignment r of types to variables; \nif r is empty, this is abbreviated be. The soundness result may be stated: Proposition. For any closed \nevaluation expression e, I_e * [el]#VError. I5 VError must be incomparable with any other element except \n1. This rather informal treatment of errors glosses over issues of origination and propagation, as discussed \nin [GR93], for in- stance. I6 ClJVM types in figure 1 should not appear in the types of any constants \nother than microinstructions. -Auxiliary functions; not public load ! fst k = get1 I $ hw. pushs (tst \nw) $ k store I kt k = pops $ hw. set1 I (tst w) $ k konst con vk = pushs (cm v) $ k plnt w = inlnt (outlnt \nw) pFloat w = inFloat (outFloat wj -JVM bytecodes iload I = load I plnt fload I = load I pFloat istore \nI = store lplnt fstore I = store I pFloat iconst = konst inlnt fconst = konst inFloat invoke mefb k= \npops $ hw. call meth w $ hw . pushs w !$ k Figure 10: Sample bytecode implementations Proof: (sketch) \nBegin by defining a set of heap descriptions, 6 E A, as follows: d = (allot, classes, sites), where allot \nc N, classes :: allot + (TagA, Tags, TagC, TagD ) , sites :: allot + (1,2,3) Define a partial ordering \non heap descriptions such that: 6 I 6 iff allot c_ allot and \\Ji E allot. classes(i) = classes (i) and \nsites(i) = sites (i) Figure 9 defines a number of predicates indexed by heap de-scriptions and types. \nNote: . For a heap description S, s? is the set (s 16 5 6 ) . For predicate 0, type (T and set S, the \nexpression 0, (v) denotes the assertion t/s E S. 19: (v) . . Free type variables in clauses are assumed \nto range over all non-polymorphic types in the model. . [x H v] is the function with domain (x) whose \nvalue at x is v. . With the exception of bottom elements of each type (whose inclusion is mandated by \nthe extension referred to below), all predicates are assumed false by default for any semantic value. \nBroadly speaking, the predicate P characterizes the values that may be produced by composing microinstructions. \nMore precisely, P may be extended in canonical fashion to a form This convention also applies where the \ntype expression en-codes a class or variant. an l-predicate [P80] 8 -also denoted P -that preserves the \nterm constants used in method expressions. This results in the following form of the Basic Lemma for \nlogical relations [M96] : Lemma: For any method expression m, let I be a type as-signment st. r 1 m:: \nCont a, a2 CJ~, and ?J a variable envi-ronment satisfying r st. for any free variable x of m, Ffr nrl(q(x)). \nThen ffConto~a203D~(~m~~). From the definition of P given in figure 9, this implies that any method expression, \nevaluated in a suitable environment and applied to a machine state of the appropriate configura-tion \n(as characterized by predicate V), yields an integer re-sult without eliciting any verifier errors. Structural \ninduction demonstrates that the evaluation of a method expression in a closed evaluation expression occurs \nin a suitable environ-ment. To complete the proof, it only remains to observe that the evaluate microinstruction \nconstrains its continuation ar-gument to a type compatible with the initial machine state.  7. The Full \nBytecode Figure 10 presents a smattering of the full JVM bytecode set specified using the pJVM microinstructions. \nNote how some of the more routine but tedious aspects of the JVM bytecode -such as the replication of \nessentially the same operation for different operand types (iload, fload, etc.) -are s Technically, a \npointed directed-complete second-order I-predicate [M96] [MM85]. In the taxonomy of [MM91], P is a Kripke \nlogical predicate over a classical applicative structure. I9 The 3 symbol used in the figure represents \nfunction compo-sition: (t$g) x = t(gx). Also note that a lambda abstraction extends as far to the right \nas possible, so that for example, f $ hx g x = f$W.gx). expressed economically using combinations of \nthe more ge-[B97], which also conflates verification and execution in the neric microinstructions. JVM. \nAny method composed of these bytecodes may be accommo-dated in the syntactic structure of the soundness \nresult of the last section, so the type-checking of such a method corre-sponds to verification, as required. \n8. Related Work [Q98] recapitulates an early and notably comprehensive for-mal account of the JVM. Like \nthe specification in this paper, Qian s description treats the dynamic and static aspects of the JVM \nseparately, relating the two with a succession of soundness results. In contrast to the approach taken \nhere, however, he uses a rule-based operational semantics to de-scribe the dynamic behavior of the JVM, \nand a type infer-ence system -also rule-based -to capture the static se-mantics. Qian s specification \nis based closely on the informal VM specification given in [LY96], though it does incorpo-rate some minor \ngeneralizations. Qian s work exposed an implementation bug in Sun s JVM, though -possibly partly as a \nresult of its size, which Qian concedes made validation difficult -an early version of Qian s specification \nsuffered from a bug itself. An influential body of work in this area (here termed the SAFM framework \n) is developed in [SA98] and [FM98]. The approach is similar to Qian s, but these authors concen-trate \non a greatly restricted subset of the JVM bytecode. This restricted scope allows them to conduct extensive \ninvestiga-tions, and to produce very detailed proofs of correctness. Freund and Mitchell s careful investigation \nof subroutines and object initialization while formulating the specification in [FM981 brought to light \na fault in Sun s verifier imple-mentation -a fault shared by Qian s specification, as noted above.2 The \nobverse of the restricted scope of the SAFM investigations is a failure to give an account of many features \nof the JVM. For example, unlike Qian s apparatus (and that proposed in this paper), the SAFM framework \ncannot ac-commodate abnormal exits from bytecode subroutines -a feature not unknown in class files generated \nfrom actual pro-grams. Another approach to the problem of bytecode verification uses the dataflow analysis \nlike Sun s verifier implementa-tion. [G97] is one example of this approach; it is a fairly far-reaching \ntreatment, though it omits some features of the JVM bytecode -such as subroutines -that are covered here. \nThe specification in [HT98] is also based on dataflow analy-sis, but it is much closer in spirit to the \nmore narrowly fo-cused study in [SA98]. Cohen s defensive JVM -documented in [C97] -does not attempt \nto describe a distinct verification mechanism in the JVM. Rather, the specification comprises a formally \nveri-fied interpreter (written in Common Lisp) that includes the appropriate run-time checks to ensure \nsafe execution. A similar vein is followed in Bertelsen s operational semantics 2o The ostensibly otiose \nidentify functions pint and pFloat are used to enforce static type restrictions on their arguments. 2 \nThe specification given in this report avoids this problem. An entirely different tack is taken in [S97], \nan approach based on deriving concurrent constraint programs from byte-codes. The liveness properties \nof the former reflect the safety properties of the latter. As yet, this approach is still in the early \nstages of development. With the exception of Cohen s defensive JVM and Saraswat s forthcoming concurrent \nconstraint compiler, none of the formal specifications above is executable, though Freund and Mitchell \ndo announce their intention to develop a means of deriving an executable bytecode verifier automati-cally \nfrom the type rules in their specification. Also, none of the foregoing seeks to tackle the JVM s complexity \nusing modularity, though again, Freund and Mitchell report ongo-ing investigations in this regard. Produced \nindependently and roughly contemporaneously, [J98] is an account of the JVM founded on much the same \nbasis as that here. Jones specification is also expressed in Haskell using a monadic style of presentation, \nbut it relies on extensions to the standard Haskell type system (as described in [GJ96]) to deal with \nlocal variables. The result is clearer and more economical, but it requires a non-standard Haskell implementation \nto execute. At the time of writing, Jones published work does not deal with object initialization.  \n9. Conclusion Hopefully, the discussion outlined in this paper is sufficient to establish at least the \npromise of an effective approach to the formal specification of the Java Virtual Machine. One concern \nwith this approach is that the pJVM (in particular in respect of verification) conforms only approximately \nwith existing JVM implementations. For example, it was pointed out in section 5.4 that the use of Haskell \ns type-checking fa-cilities to validate subroutines in the Java bytecode admits a wider class of programs \nthan is the case with current verifier implementations. Conversely (as was observed by one of the referees), \nit is possible to construct bytecode sequences that are rejected by the framework set out for object \ninitialization in section 5.3, even though many verifiers would allow them. By way of rejoinder, it should \nbe remarked that there exists (at least currently) no synoptic statement of the precise be-havior actually \nexpected of a JVM and its verifier. [SA98], for example, notes that the description of the JVM given \nin [LY96] actually disagrees with Sun s reference JVM imple-mentation in a number of significant respects. \nAnd while the account of the JVM given here differs from current imple-mentations, it does maintain all \nof the significant invariants (such as those regarding object initialization and method in-vocation) \nstipulated in [LY96]. Furthermore (based on cur-rent experience), it appears not to exclude any JVM program \nencountered in practice. Nonetheless, it is true that more explicit rule-based descrip-tions such Qian \ns or those in the SAFM framework are able to mirror the behavior of cnrrent implementations with greater \naccuracy. However, such accounts require the estab-lishment and manipulation of more technical detail \nthan is required in the approach advocated here. As yet they also lack the same degree of compositionality \nand modularity, nor are they currently executable. Such considerations notwithstanding, final ratification \nof the approach proposed in this paper will only issue from more-or-less complete specification of the \nJVM. In particular, the omitted features listed in section 3 need to be described for-mally. Some of \nthese features are indeed tackled in [J98] and [Y99], but others -notably multithreading -require fur-ther \nwork. Also, while the current pJVM fits conveniently within the standard Haskell type system, alterations \nto the type-checker would yield valuable information. For example, access to the types derived for encapsulated \ncontinuations would allow the verifier safely to approximate the maximum stack-height that might occur \nduring a method s execution. In a similar vein, we intend (in collaboration with the latter author) to \ncombine the approach taken in this paper with that advanced by Jones in [J98]; the result should blend \nthe cov-erage of the specification described here with the notational cleanliness of Jones . Acknowledgements \nIt is a pleasure to acknowledge the support of Tobias Nipkow and Mark Jones to the work described here. \nTobias perused my earlier (and even less lucid) renditions, suggested emen-dations and clarifications, \nand to drew parallels with other research in the field. One of the researchers to whom he re-ferred was \nMark Jones, who conceived independently (and approximately concurrently) many of the ideas underlying \nthe account detailed herein. Mark was gracious enough hap-pily to accede to the independent publication \nof my work. I m also greatly indebted to the staff and management of Sun Microsystems Laboratories -particularly \nNeil Wilhelm and my colleagues in the Kanban project group -without whose encouragement and indulgence \nthis work would have been impossible. Finally, I m grateful to the conference referees, whose rec-ommendations \nsignificantly improved this presentation. 10. References [B97] Bertelsen, P., Semantics of Java byte \ncode. Student project at Department of Information Technology, Technical University of Denmark, 1997. \nAvailable from: http:llwww.dina.kvl.dW-pmb. [C97] Cohen, R., The Defensive Java Virtual Machine Specification \nVersion 0.5, Computational Logic, Inc., 1997. [CF91] Cartwright, R., Fagan, S. Soft typing. In Proceedings \nSIGPLAN 91 Conference on Progamming Language Design and Implementation, June 1991. [FM981 Freund, S., \nMitchell, J. A Type System for Object Initialization in the Java Bytecode Language, Techni-cal Note STAN-CS-TN-98-62, \nStanford Computer Science Dept., 1998. [GJ96]Gaster, B., Jones, M., A polymorphic type system for extensible \nrecords and variants. Technical Report NOTTCS-TR-96-3, Department of Computer Science, University of \nNottingham, November 1996. [G97] Goldberg, A., A Specification of Java Loading and Bytecode Verification. \nKestrel Institute, 1997. [GR93] Gunter, C., RCmy, D., A Proof-Theoretic Assessment of Runtime Type Errors. \nAT&#38;T Bell Laboratories Technical Memo, 11261-921230-43TM, 1993. [H92] Hudak, P., Mutable Abstract \nDatatypes -or -How to Have Your State and Munge it Too. Research Report YALEU/DCS/RR-914, Yale University \nComputer Science Dept., 1992 (r. 1993). [HT98] Hagiya, M., Tozawa, A., On a new method for da-taflow \nanalysis of Java Virtual Machine subroutines, submitted for publication, 1998. Available from: http://nicosia.is.s.u-tokyo.ac.jp/members/hagiya.html \n [J98] Jones, M., The functions of the Java bytecode. In Pro- ceedings of the OOPSLA Workshop on the \nFormal Underpinnings of Java, 1998. [LY96] Lindholm, T., Yellin, F., The Java Virtual Machine Specification. \nAddison-Wesley, 1996. [M91] Mitchell, J. Type inference with simple subtypes. Journal of Functional Programming, \n1(3):245-286, 1991. [M96] Mitchell, J. Foundations for Programming Lan-guages. MIT Press, 1996. [MM851 \nMitchell, J., Meyer, A. Second-order logical rela-tions. In Logics of Programs, Berlin 1985. Springer-Verlag \nLNCS 193. [MM911 Mitchell, J., Moggi, E., Kripke-style models for typed lambda calculus. Ann. Pure and \nApplied Logic, 51, 1991. [P+97] Peterson, J., Hammond, K., Augustsson, L., Boutel, B., Burton, W., Fasel, \nJ. Gordon, A., Hughes, J., Hu-dak, P., Johnsson, T., Jones, M., Meijer, E., Peyton Jones, S., Reid, A., \nWadler, P. Report on the Pro-gramming Language Haskell; A Non-Strict, Purely Functional Language (Version \n1.4), April 1997. Available from: http://www.haskell.org [P80] Plotkin, G. Lambda-definability in the \nfull type hier- archy. In To H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, \nAcademic Press, 1980. [PJW93] Peyton Jones, S., Wadler, P., Imperative .functional programming. In Proceedings \n20th Symposium on Principles of Programming Languages, ACM, 1993. [Q981 Qian, Z., A formal specification \nof Java Virtual Ma- chine instructions for objects, methods and subrou-tines. To appear in Jim Alves-Foss \n(ed.) Formal Syn-tax and Semantics of Java, Springer Verlag LNCS, 1998. N391 RCmy, D., Records and variants \nas a natural exten-sion of ML. In Proceedings 16th Annual Symposium on the Principles of Programming \nLanguages, ACM, 1989. rs971 Saraswat, V., The Java bytecode vertfication problem. Available from http://www.research.att.coml-vj, \n1997. [SA98] Stata, R., Abadi, M., A type system for Java bytecode subroutines. In Proceedings 25th Annual \nSymposium on Principles of Programming Languages, ACM, 1998. [W92] Wadler, P., The essence of functional \nprogramming. In Proceedings 19th Annual Symposium on Principles of Programming Languages, ACM, 1992. \n[Y99] Yelland, P., A Formal Specification of the Java Vir-tual Machine, Sun Microsystems Laboratories \nTech-nical Report 98-0359, 1999 (forthcoming). Appendix: Haskell Haskell is a polymorphic functional \nlanguage in the tradition of ML. Unlike ML, however, Haskell uses lazy evaluation (in contrast to ML \ns eager evaluation); it also eschews ML s imperative features such as references and exceptions. Like \nML, Haskell allows function definition using pattern matching. For example, consider the datatype Vec2D, \ncom-prising a pair of integers: data Vec2D = MkVec2D Int Int The following function is defined on instances \nof Vec2D; it uses pattern matching to extract the components of its argu-ment: IengthVecPD (MkVeQD xy) \n= sqrt (P2 + y 2) As in ML, the wildcard pattern _ matches any value. Haskell patterns may be supplemented \nwith a Boolean guard; a match against a pattern of the form p 1 g takes place only if the guard g is \ntrue. Haskell s case expression also uses pat-tern matching; the value of the expression case v of p1 \n+ el . . pn + e, is the first ei such that pi matches the value v. Datatypes may contain named fields; \nfor example, the datatype defined above might be rendered rather more sug-gestively as: data VecPD = \nMkVeQD {x :: Int, y :: Int] Fields may be named in the allocation of a new value -for example, a new \nvector with x and y components 1 and 2 re- spectively might be denoted Mk2DVec {x = 1, y = 2). One or \nmore named fields of a record may be specified in a pattern. In the following function, the variable \nx&#38;o/r/is bound to the x field of the Vec2D value passed to the function: projXVec2D (MkVedD (x = \nx&#38;o&#38;}) = x&#38;o/d For a value v with named fields, the expression v(fl te,, . . . . f, t e,} \ndenotes a copy of v in which fields fl, . . . . f, have been replaced with the values of expressions \nel, . . . . e,. Each field of such a value names a function that retrieves the corre-sponding field, \nso that for example, x (MkVec2D {x = 1, y = 2)) is Finally, Haskell datatypes may comprise tagged variants; \nfor example, the following datatype encompasses vectors with two or three components: data Vet = MkVeQD \nInt Int 1MkVec3D Int Int Int In the context of this declaration, the function lengthVec2D defined above \nis partial, since its application to a value of the form MkVec3D i, h .$ causes an error.   \n\t\t\t", "proc_id": "292540", "abstract": "", "authors": [{"name": "Phillip M. Yelland", "author_profile_id": "81100634004", "affiliation": "Sun Microsystems Laboratories, 910 San Antonio Road, MS MTV29-117, Palo Alto, CA", "person_id": "PP31101084", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/292540.292548", "year": "1999", "article_id": "292548", "conference": "POPL", "title": "A compositional account of the Java virtual machine", "url": "http://dl.acm.org/citation.cfm?id=292548"}