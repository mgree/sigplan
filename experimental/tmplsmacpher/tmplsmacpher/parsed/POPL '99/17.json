{"article_publication_date": "01-01-1999", "fulltext": "\n JFlow: Practical Mostly-Static Information Flow Control Andrew C. Myers Laboratory for Computer Science \nMassachusetts Institute of Technology http://www.pmg.lcs.mit.edu/*andru Abstract A promising technique \nfor protecting privacy and integrity of sensi- tive data is to statically check information flow within \nprograms that manipulate the data. While previous work has proposed program-ming language extensions \nto allow this static checking, the resulting languages are too restrictive for practical use and have \nnot been im- plemented. In this paper, we describe the new language J&#38;w, an extension to the Java \nlanguage that adds statically-checked in-formation flow annotations. JFlow provides several new features \nthat make information flow checking more flexible and convenient than in previous models: a decentralized \nlabel model, label poly-morphism, run-time label checking, and automatic label inference. JFlow also \nsupports many language features that have never been in- tegrated successfully with static information \nflow control, including objects, subclassing, dynamic type tests, access control, and excep- tions. This \npaper defines the JFlow language and presents formal rules that are used to check JFlow programs for \ncorrectness. Be-cause most checking is static, there is little code space, data space, or run-time overhead \nin the JFlow implementation. Introduction Protection for the privacy of data is becoming increasingly \nimpor-tant as data and programs become increasingly mobile. Conven-tional security techniques such as \ndiscretionary access control and information flow control (including mandatory access control) have significant \nshortcomings as privacy-protection mechanisms. The hard problem in protecting privacy is preventing private \nin-formation from leaking through computation. Access control mech-anisms do not help with this kind \nof leak, since they only control information release, not its propagation once released. Mandatory access \ncontrol (MAC) mechanisms prevent leaks through propaga-tion by associating a run-time security class \nwith every piece of computed data. Every computation requires that the security class of the result value \nalso be computed, so multi-level systems using this approach are slow. Also, these systems usually apply \na security class to an entire process, tainting all data handled by the process. This coarse granularity \nresults in data whose security class is overly restrictive, and makes it difficult to write many useful \napplications. This research was supportedin partby DARPA Contract F30602-96-C-0303, monitored by USAF \nRome Laboratory, and in part by DARPA Contract F30602-98-I-0237, also monitored by USAF Rome Laboratory. \nA promising technique for protecting privacy and integrity of sen- sitive data is to statically check \ninformation flows within programs that might manipulate the data. Static checking allows the fine-grained \ntracking of security classes through program computations, without the run-time overhead of dynamic security \nclasses. Several simple programming languages have been proposed to allow this static checking [DD77, \nVS196, ML97, SV98, HR98]. However, the focus of these languages was correctly checking information flow \nstatically, not providing a realistic programming model. This paper describes the new language JFlow, \nan extension to the Java language [GJS96] that permits static checking of flow annotations. JFlow seems \nto be the first practical program-ming language that allows this checking. Like other recent ap-proaches \n[VSI96, ML97, SV98, HR98, ML98], JFlow treats static checking of flow annotations as an extended form \nof type checking. Programs written in JFlow can be statically checked by the JFlow compiler, which prevents \ninformation leaks through storage chan-nels [Lam73]. JFlow is intended to support the writing of secure \nservers and applets that manipulate sensitive data. An important philosophical difference between JFlow \nand other work on static checking of information flow is the focus on a usable programming model. Despite \na long history, static information flow analysis has not been widely accepted as a security technique. \nOne major reason is that previous models of static flow analysis were too limited or too restrictive \nto be used in practice. The goal of the work presented in this paper has been to add enough power to \nthe static checking framework to allow reasonable programs to be written in a natural manner. This work \nhas involved several new contributions: JFlow extends a complex programming language and supports many \nlanguage fea-tures that have not been previously integrated with static flow check- ing, including mutable \nobjects (which subsume function values), subclassing, dynamic type tests, and exceptions. JFlow also \npro-vides powerful new features that make information flow checking less restrictive and more convenient \nthan in previous programming languages: It supports the decentralized label model [ML97, ML98], which \nallows multiple principals to protect their privacy even in the presence of mutual distrust. It also \nsupports safe, statically- checked declassijcation, or downgrading, allowing a principal to relax its \nown privacy policies without weakening policies of other principals. It provides a simple but powerful \nmodel of access control that allows code privileges to be checked statically, and also allows authority \nto be granted and checked dynamically. It provides label polymorphism, allowing code that is generic \nwith respect to the security class of the data it manipulates. . Run-time label checking and first-class \nlabel values provide a dynamic escape when static checking is too restrictive. Run-time checks are statically \nchecked to ensure that information is not leaked by the success or failure of the run-time check itself. \nAutomatic label inference makes it unnecessary to write many of the annotations that would otherwise \nbe required. The JFlow compiler is structured as a source-to-source translator, so its output is a standard \nJava program that can be compiled by any Java compiler. For the most part, translation involves removal \nof the static annotations in the JFlow program (after checking them, of course). There is little code \nspace, data space, or run time overhead, because most checking is performed statically. The remainder \nof this paper is structured as follows: Section 2 contains an overview of the JFlow language and a rationale \nfor the decisions taken. Section 3 discusses static checking, sketches the framework used to check program \nconstructs in a manner similar to type checking, and both formally and informally presents some of the \nrules used. This section also describes the translations that are performed by the compiler. Section \n4 compares this work to other work in related areas, and Section 5 provides some conclusions. The grammar \nof JFlow is provided for reference in Appendix A. 2 Language overview This section presents an overview \nof the JFlow language and a rationale for its design. JFlow is an extension to the Java language that \nincorporates the decentralized label model. In Section 2.1, the previous work on the decentralized label \nmodel [ML97, ML981 is reviewed. The language description in the succeeding sections focuses on the differences \nbetween JFlow and Java, since Java is widely known and well-documented [GJS96]. 2.1 Labels In the decentralized \nlabel model, data values are labeled with se-curity policies. A label is a generalization of the usual \nnotion of a security class; it is a set of policies that restrict the movement of any data value to which \nthe label is attached. Each policy in a label has an owner 0, which is a principal whose data was observed \nin order to create the value. Principals are users and other authority entities such as groups or roles. \nEach policy also has a set of readers, which are principals that 0 allows to observe the data. A single \nprincipal may be the owner of multiple policies and may appear in multiple reader sets. For example, \nthe label L = { 01: r-1, ~2; 02: Q, ~3) has two policies in it (separated by semicolons), owned by 01 \nand 02 respectively. The policy of principal 01 allows ri and r2 to read; the policy of principal 02 \nallows r2 and rs to read. The effective reader set contains only the common reader ~2. The least restrictive \nlabel possible is the label {}, which contains no policies. Because no principal expresses a privacy \ninterest in this label, data labeled by {} is completely public as far as the labeling scheme is concerned. \nThere are two important intuitions behind this model: first, data may only be read by a user of the system \nif all of the policies on the data list that user as a reader. The effective policy is an intersection \nof all the policies on the data. Second, a principal may choose to relax a policy that it owns. This \nis a safe form of declussi$cation -safe, because all of the other policies on the data are still enforced. \nA process has the authority to act on behalf of some (possibly empty) set of principals. The authority \npossessed by a process determines the declassifications that it is able to perform. Some principals are \nalso authorized to act for other principals, creating a principal hierarchy. The principal hierarchy \nmay change over time, but revocation is assumed to occur infrequently. The meaning of a label is affected \nby the current principal hierarchy. For example, if the principal T can act for the principal T, then \nif T is listed as a reader by a policy, r is effectively listed by that policy as well. The meaning of \na label under different principal hierarchies is discussed extensively in an earlier paper [ML98]. Every \nvariable is statically bound to a static label. (The altema- tive, dynamic binding, largely prevents \nstatic analysis and can be simulated in JFlow if needed.) If a value v has label Li and a vari- able \nz has label L2, we can assign the value to the variable (Z := V) only if Li can be relabeled to Lz, which \nis written as Li &#38; Lz. The definition of this binary relation on labels is intuitive: LI L L2 if \nfor every policy in Li, there is some policy in L2 that is at least as restrictive [ML98]. Thus, the \nassignment does not leak information. In this system, the label on z is assigned by the programmer who \nwrites the code that uses 2. The power to select a label for z does not give the programmer the ability \nto leak w, because the static checker permits the assignment to z only if the label on x is sufficiently \nrestrictive. After the assignment, the static binding of the label of x prevents leakage. (Changes in \nwho can read the value in x are effected by modifying the principal hierarchy, but changes to the principal \nhierarchy require appropriate privilege.) Computations (such as multiplying two numbers) cause joining \n(U) of labels; the label of the result is the least restrictive label that is at least as restrictive \nas the labels of the values used in the computation; that is, the least upper bound of the labels. The \njoin of two sets of policies is simply the union of the sets of policies. The relation E generates a \nlattice of equivalence classes of labels with U as the LUB operator. Lattice properties are important \nfor supporting automatic label inference and label polymorphism [ML97, ML98]. The notation A z B is also \nused as a shorthand for A C: B A B E A (which does not mean that the labels are equal [ML98]). Declassification \nprovides an escape hatch from strict information flow tracking. If the authority of a process includes \na principal p, a value may be declassified by dropping policies owned by principals that p acts for. \nThe ability to declassify provides the opportunity for p to choose to release information based on a \nmore sophisticated analysis. All practical information flow control systems provide the ability to declassify \ndata because strict information flow control is too restrictive to write real applications. More complex \nmechanisms such as inference controls [Den821 often are used to decide when declassification is appropriate. \nIn previous systems, declassification is performed by a trusted subject: code having the authority of \na highly trusted principal. One key advantage of the new label structure is that it is decentralized: \nit does not require that all other principals in the system trust a principal p s declassification decision, \nsince p cannot weaken the policies of principals that it does not act for.  2.2 Labeled types This section \nbegins the description of the new work in this paper (the JFlow programming language), which incorporates \nthe label model just summarized. In a JFlow program, a label is denoted by a label expression, which \nis a set of component expressions. As in Section 2.1, a component expression of the form owner: readerl, \nreaderz, . . . denotes a policy. A label expression is a series of component expressions, separated by \nsemicolons, such as (01: ~1, ~2; 02: r2, ~3). In a program, a component expression may take additional \nforms; for example, it may be simply a variable name. In that case, it denotes the set of policies in \nthe label of that variable. The label {a} contains a single component; the meaning of the label is that \nthe value it labels should be as restricted as the variable a is. The label {a; o: r} contains two components, \n int{public} x; label{L lb; booiean{secret} . . . int x = 0; b; int *lb int I ! x; p:} y; switch label(x) \nif (b) { x= 1; case (int{y} z y = z:r else throw new UnsafeTransfer(); I 1 Figure 1: Implicit flow example \nFigure 2: Switch label indicating that the labeled value should be as restricted as a is, and also that \nthe principal o restricts the value to be read by at most r. In JFlow, every value has a labeled type \nthat consists of two parts: an ordinary Java type such as int, and a label that describes the ways that \nthe value can propagate. The type and label parts of a labeled type act largely independently. Any type \nexpression t may be labeled with any label expression {I). This labeled type expression is written as \nt{ 1); for example, the labeled type int{ p:} represents an integer that principal p owns and only p \ncan read (the owner of a policy is always implicitly a reader). The goal of type checking is to ensure \nthat the apparent, static type of each expression is a supertype of the actual, run-time type of every \nvalue it might produce; similarly, the goal of label checking is to ensure that the apparent label of \nevery expression is at least as restrictive as the actual label of every value it might produce. In addition, \nlabel checking guarantees that, except when declassifica-tion is used, the apparent label of a value \nis at least as restrictive as the actual label of every value that might ufSect it. In principle, the \nactual label could be computed precisely at run time. Static check-ing ensures that the apparent, static \nlabel is always a conservative approximation of the actual label. For this reason, it is typically unnecessary \nto represent the actual label at run time. A labeled type may occur in a JFlow program in most places \nwhere a type may occur in a Java program. For example, variables may be declared with labeled type: int{p:} \nx; int{x} y; int z;  The label may always be omitted from a labeled type, as in the declaration of z. \nIf omitted, the label of a local variable is inferred automatically based on its uses. In other contexts \nwhere a label is omitted, a context-dependent default label is generated. For example, the default label \nof an instance variable is the public label {}. Several other cases of default label assignment are discussed \nlater. 2.3 Implicit flows In JFlow, the label of an expression s value varies depending on the evaluation \ncontext. This somewhat unusual property is needed to prevent leaks through implicitflows: channels created \nby the control flow structure itself. Consider the code segment of Figure 1. By examining the value of \nthe variable x after this segment has executed, we can determine the value of the secret boolean b, even \nthough x has only been assigned constant values. The problem is the assignment x = 1, which should not \nbe allowed. To prevent information leaks through implicit flows, the compiler associates a program-counter \nlabel (pcJ with every statement and expression, representing the information that might be learned from \nthe knowledge that the statement or expression was evaluated. In this program, the value of ez during \nthe consequent of the if statement is {b}. After the if statement, E = {}, since no information about \nb can be deduced from the fact that the statement after the if statement is executed. The label of a \nliteral expression (e.g., 1) is the same as its pc. or {b} in this case. The unsafe assignment (x = 1) \nin the example is prevented because the label of x ({public}) is not at least as restrictive as the label \nof 1 in this expression, which is {b}, or {secret}. 2.4 Run-time labels In JFlow, labels are not purely \nstatic entities; they may also be used as values. First-class values of the new primitive type label \nrepresent labels. This functionality is needed when the label of a value cannot be determined statically. \nFor example, if a bank stores a number of customer accounts as elements of a large array, each account \nmight have a different label that expresses the privacy requirements of the individual customer. To implement \nthis example in JFlow, each account can be labeled by an attached dynamic label value. A variable of \ntype label may be used both as a first-class value and as a label for other values. For example, methods \ncan accept arguments with run-time labels, as in the following method decla-ration: static float{*lb} \ncompute(int x{*lb}, label lb) In this example, the component expression *lb denotes the label contained \nin the variable lb, rather than the label of the variable lb. To preserve safety, variables of type label \n(such as lb) may be used to construct labels only if they are immutable after initialization; in Java \nterminology, if they are final. (Unlike in Java, arguments in JFlow are always final.) The important \npower that run-time labels add is the ability to be examined at run-time, using the switch label statement. \nAn example of this statement is shown in Figure 2. The code in this figure attempts to transfer an integer \nfrom the variable x to the variable y. This transfer is not necessarily safe, because x s label, lb, \nis not known statically. The statement examines the run-time label of the expression x, and executes \none of several case statements. The statement executed is the first whose associated label is at least \nas restrictive as the expression label; that is, the first statement for which the assignment of the \nexpression value to the declared variable (in this case, z) is legal. If it is the case that {*lb} &#38; \n{p :}, the first arm of the switch will be executed, and the transfer will occur safely via z. Otherwise, \nthe code throws an exception. Since lb is a run-time value, information may be transferred through it. \nThis can occur in the example by observing which of the two arms of the switch are executed. To prevent \nthis information channel from becoming an information leak, the E in the first arm is augmented to include \nlb s label, which is {L}. The code passes static checking only if the assignment from y to z is legal; \nthat is, if G-j&#38; {Y). Run-time labels can be manipulated statically, though conserva-tively; they \nare treated as an unknown but fixed label. The presence of such opaque labels is not a problem for static \nanalysis, because of the lattice properties of these labels. For example, given any two labels LI and \nLz where L1 5 Lz, it is the case for any third label L3 that LI U L3 E L2 LJ L3. This implication makes \nit possible for an opaque label L3 to appear in a label without preventing static analysis. Using it, \nunknown labels, including run-time labels, can public class Vector[label L] extends AbstractList[L] { \nprivate int{L} len th; be propagated statically. private Object(L) B j(L) elements; 2.5 Authority and \ndeclassification JFlow has capability-like access control that is both dynamically and statically checked. \nA method executes with some authority that has been granted to it. The authority is essentially the capability \nto act for some set of principals, and controls the ability to declassify data. Authority also can be \nused to build more complex access control mechanisms. At any given point within a program, the compiler \nunderstands the code to be running with the ability to act for some set of principals, called the static \nauthority of the code at that point. The actual authority may be greater, because those principals may \nbe able to act for other principals. The principal hierarchy may be tested at any point using the actsFor \nstatement. The statement actsFor(pr, ~2) S executes the statement S if the principal pr can act for the \nprincipal pz. Otherwise, the statement S is skipped. The statement S is checked under the assumption \nthat this acts-for relation exists: for example, if the static authority includes pr, then during static \nchecking of S, it is augmented to include ~2. A program can use its authority to declassify a value. \nThe ex-pression declassify(e, L) relabels the result of an expression e with the label L. Declassification \nis checked statically, using the static authority at the point of declassification. The declassify expression \nmay relax policies owned by principals in the static authority. 2.6 Run-time principals Like labels, \nprincipals may also be used as first-class values at run time. The type principal represents a principal \nthat is a value. A final variable of type principal may be used as if it were a real principal. For example, \na policy may use a final variable of type principal to name an owner or reader. These variables may also \nbe used in actsFor statements, allowing static reasoning about parts of the principal hierarchy that \nmay vary at run time. When labels are constructed using run-time principals, declassification may also \nbe performed on these labels. Run-time principals are needed in order to mode1 systems that are heterogeneous \nwith respect to the principals in the system, without resorting to declassification. For example, a bank \nmight store bank accounts with the following structure, using run-time principals rather than run-time \nlabels: class Account { final principal customer; String{customer:) name; float{customer:} balance: ] \nWith this structure, each account may be owned by a different principal (the customer whose account it \nis). The security policy for each account has similar structure but is owned by the principal in the \ninstance variable customer. Code can manipulate the account in a manner that is generic with respect \nto the contained principal, but can also determine at run-time which principal is being used. The principal \ncustomer may be manipulated by an actsFor statement, and the label {customer:} may be used by a switch \nlabel statement. 2.7 Classes Even in the type domain, parameterizing classes is important for building \nreusable data structures. It is even more important to have polymorphism in the information flow domain; \nthe usual way to oublic Vector0 . . . bublic Object &#38;ementAt(int throws (ArraylndexOutOf return elementslil: \n L 1. pukic void setElementAt{L}(Object } o, into i) . . . public int{L} size0 return length; \\ public \nvoid clear{L}( . . .  \\ ] Figure 3: Parameterization over labels handle the absence of statically-checked \ntype polymorphism is to perform dynamic type casts, but this approach works poorly when applied to information \nflow since new information channels are created by dynamic tests. To allow usable data structures in \nJFlow, classes may be pa-rameterized to make them generic with respect to some number of labels or principals. \nClass and interface declarations are extended to include an optional set of explicitly declared parameters. \nFor example, the Java Vector class is translated to JFlow as shown in Figure 3. Vector is parameterized \non the label L, which represents the label of the contained elements. Assuming that secret and public \nare appropriately defined, the types Vector[{secret}] and Vector[{ pu blic}] would represent vectors \nof elements of differing sensitivitv. Without the abilitv to parameterize classes on labels, it would \nbe-necessary to reimplemen;Vector for every distinct element label. The addition of label and principal \nparameters to JFlow makes parameterized classes into simple dependent types [t&#38;91], since types contain \nvalues. To ensure that these dependent types have a well-defined meaning, only immutable variables may \nbe used as parameters. Note that even if {secret} E {public}, it is not the case that Vector[{secret}] \n5 Vector[{public}], since subtyping is invariant in the parameter L (the subtype relation is denoted \nhere by 5). When such a relation is sound, the parameter may be declared as a covariant label rather \nthan as a label, which places additional restrictions on its use. For example, no method argument or \nmutable instance variable may be labeled using the parameter. A class always has one implicit label parameter: \nthe label {this}, which represents the label on an object of the class. Because Lr C Lz implies that \nC{Lr} acts like a subtype of C{&#38;}, the label of this is necessarily a covariant parameter, and its \nuse is restricted in the same manner as with other covariant parameters. A class may have some authority \ngranted to its objects by adding an authority clause to the class header. The authority clause may name \nprincipals external to the program, or principal parameters. If the authority clause names external principals, \nthe process that installs the class into the system must have the authority of the named principals. \nIf the authority clause names principals that are parameters of the class, the code that creates an object \nof the class must have the authority of the actual principal parameters used in the call to the constructor. \nIf a class C has a superclass C,, any authority in C, must be covered by the authority clause of C. It \nis not possible to obtain authority by inheriting from a superclass. 2.8 Methods Like class declarations, \nJFlow method declarations also contain some extensions. There are a few optional annotations to manage \ninformation flow and authority delegation. A method header has the following syntax (in the form of the \nJava Language Specifica-tion [GJS96]): MethodHeader: Modifiers,,, LabeledType Identifier BeginLabel,pt \n( FormalParameterListO,,t ) EndLabel,p, Throws,,, WhereConstrain&#38;, FormalParameter: LabeledType \nIdentifier OptDims The return value, the arguments, and the exceptions may each be individually labeled. \nOne subtle change from Java is that arguments are always implicitly final, allowing them to be used as \ntype param- eters. This change is made for the convenience of the programmer and does not significantly \nchange the power of the language. There are also two optional labels called the begin-label and the end-Znbel. \nThe begin-label is used to specify any restriction on g at the point of invocation of the method. The \nend-label -the final E -specifies what information can be learned by observing whether the method terminates \nnormally. Individual exceptions and the return value itself also may have their own distinct labels, \nwhich provides fine-grained tracking of information flow. The following examples of JFlow method declarations \nare ex-plained below: static int{x;y) add(int x, int y) { return x + y; } boolean comparestr(String name, \nString pwd):{name; pwd} throws(NullPointerException) { . . . } boolean store{L)(int{} x) throws(NotFound) \n{ . . . } When labels are omitted in a JFlow program, a default label is assigned. The effect of these \ndefaults is that often methods re-quire no label annotations whatever. Labels may be omitted from a method \ndeclaration, signifying the use of implicit label poly- morphism. For example, the arguments of add and \ncompare_str are unlabeled. When an argument label is omitted, the method is generic with respect to the \nlabel of the argument. The argument label becomes an implicit parameter of the procedure. For exam-ple, \nthe method add can be called with any two integers x and y, regardless of their labels. This label polymorphism \nis important for building libraries of reusable code. Without it, a math routine like add would have \nto be reimplemented for every argument label ever used. The default label for a return value is the end-label, \njoined with the labels of all the arguments. For add, the default return value label is exactly the label \nwritten ({x;y}), so the return value could be written just as int. The default label on an exception \nis the end- label, as in the compare-str example. If the begin-label is omitted, as in add, it becomes \nan implicit parameter to the method. Such a method can be called regardless of the caller s E. Because \nthe s within the method contains an implicit parameter, this method is prevented from causing real side \neffects; it may of course mod-ify local variables and mutate objects passed as arguments if they are \nappropriately declared, but true side effects would create static checking errors. Unlike in Java, the \nmethod may contain a list of constraints prefixed by the keyword where: WhereConstraints: where Constraints \nConstraint: authority ( Pnincipals ) caller ( principals ) actsFor ( Principal , Ptincipal ) There are \nthree different kinds of constraints: class passwordFile authority(root) { public boolean check (String \nuser, Strin password) where authority(root)   ? // Return whether password is correct boolean match \n= false; try { for (int i = 0; i < names.length; i++) { if (names[i] == user &#38;&#38; passwords[i] \n== password) { match = true: . break; 1 NuIIPointerException e) {j IndexOutOfBoundsExceptlon e) } return \ndeclassify(match, {user; password} ; 1 private String ] names; private String root: } [ ] passwords; \n t Figure 4: A JFlow password file authority@*, . . . ,pn) This clause lists principals that the method \nis authorized to act for. The static authority at the beginning of the method includes the set of principals \nlisted in this clause. The principals listed may be either names of global principals, or names of class \nparameters of type principal. Ev-ery listed principal must be also listed in the authority clause of \nthe method s class. This mechanism obeys the principle of least privilege, since not all the methods \nof a class need to possess the full authority of the class. caller(pl, . . . , p,) Calling code may also \ndynamically grant authority to a method that has a caller constraint. Unlike with the authority clause, \nwhere the authority devolves from the object itself, authority in this case devolves from the caller. \nA method with a caller clause may be called only if the calling code possesses the requisite static authority. \nThe principals named in the caller clause need not be constants; they may also be the names of method \narguments whose type is principal. By passing a principal as the corresponding ar-gument, the caller \ngrants that principal s authority to the code. These dynamic principals may be used as first-class principals; \nfor example, they may be used in labels. actsFor (pl,pz) An actsFor constraint may be used to pre- vent \nthe method from being called unless the specified acts-for relationship (pl acts for ~2) holds at the \ncall site. When the method body is checked, the static principal hierarchy is as-sumed to contain any \nacts-for relationships declared in the method header. This constraint allows information about the principal \nhierarchy to be transmitted to the called method with-out any dynamic checking.  2.9 Example: passwordFile \nNow that the essentials of the JFlow language are covered, we are ready to consider some interesting \nJFlow code. Figure 4 contains a JFlow implementation of a simple password file, in which the passwords \nare protected by information flow controls. Only the method for checking passwords is shown. This method, \ncheck, accepts a password and a user name, and returns a boolean indicating whether the string is the \nright password for that user. class Protected { final label this} lb; Object{*lb \\ content; puy:iLP$ected \nLL}(Object{*LL} x, label LL) { $  / must occur before call to super0 super(); // content = x; // checked \nassuming lb == LL kublic Ob ect{*L} get label L):(L) throws IllegalAccess d I { switch label(content) \n{ case Object{*L} unwrapped return unwrapped; else tr, row new IllegalAccess 1 , !y~~;cu~ b~~get_label() \n{ Figure 5: The Protected class The if statement is conditional on the elements of passwords and on the \nvariables user and password, whose labels are implicit parameters. Therefore, the body of the if statement \nhas E = {user; password; root:}, and the variable match also must have this label in order to allow the \nassignment match = true. This label prevents match from being returned directly as a result, since the \nlabel of the return value is the default label, {user; password}. Finally, the method declassifies match \nto this desired label, using its compiled-in authority to act for root. Note that the exceptions NullPointerException \nand IndexOutOfBoundsException must be explicitly caught, since the method does not explicitly declare \nthem. More precise reasoning about the possibility of exceptions would make JFlow code more convenient \nto write. Otherwise there is very little difference between this code and the equivalent Java code. Only \nthree annotations have been added: an authority clause stating that the principal root trusts the code, \na declassify expression, and a label on the elements of passwords. The labels for all local variables \nand return values are either inferred automatically or assigned sensible defaults. The task of writing \nprograms is made easier in JFlow because label annotations tend to be required only where interesting \nsecurity issues are present. In this method, the implementor of the class has decided that declassification \nof match results in an acceptably small leak of information. Like all login procedures, this method does \nleak in- formation, because exhaustively trying passwords will eventually extract the passwords from \nthe password file. However, assuming that the space of passwords is large and passwords are difficult \nto guess, the amount of information gained in each trial is far less than one bit. Reasoning processes \nabout acceptable leaks of information lie outside the domain of information flow control, but in this \nsys- tem, such reasoning processes can be accommodated in a natural and decentralized manner. 2.10 Example: \nProtected The class Protected provides a convenient way of managing run-time labels, as in the bank account \nexample mentioned earlier. Its implementation is shown in Figure 5. As the implementation shows, a Protected \nis an immutable pair containing a value content of type Object and a label lb that protects the value. \nIts value can be extracted with the get method, but the caller must provide a label to use for extraction. \nIf the label is insufficient to protect the data, an exception is thrown. A value of type Protected behaves \nvery much like a value in dynamic-checked information flow systems, since it carries a run-time label. \nA Protected has an obvious analogue in the type domain: a value dynamically associated with a type tag \n(e.g., the Dynamic type [ACPP91]). One key to making Protected convenient is to label the instance variable \nlb with {this}. Without this labeling, Protected wouldneed an additional explicit covariant label parameter \nto label lb with.  2.11 Limitations JFlow is not completely a superset of Java. Certain features have \nbeen omitted to make information flow control tractable. Also, JFlow does not eliminate all possible \ninformation leaks. Certain covert channels (particularly, various kinds of timing channels) are difficult \nto eliminate. Prior work has addressed static control of timing channels, though the resulting rules \nare restrictive [AR80, SV98]. Other covert channels arise from Java language features: Threads. JFlow \ndoes not prevent threads from communicating covertly via the timing of asynchronous modifications to \nshared objects. This covert channel can be prevented by requiring only single-threaded programs. Timing \nchannels. JFlow cannot prevent threads from improp-erly gaining information by timing code with the system \nclock, except by removing access to the clock. HashCode. In Java, the built-in implementation of the \nhash-Code method, provided by the class Object, can be used to commu- nicate information covertly. Therefore, \nin JFlow every class must implement its own hashcode. Static variables. The order of static variable \ninitialization can be used to communicate information covertly. In JFlow, this channel is blocked by \nruling out static variables. However, static methods are legal. This restriction does not significantly \nhurt expressive power, since a program that uses static variables usually can be rewritten as a program \nin which the static variables are instance variables of an object. The order ofinitialization of these \nobjects then becomes explicit and susceptible to analysis. Finalizers. Finalizers are run in a separate \nthread from the main program, and therefore can be used to communicate covertly. Finalizers are not part \nof JFlow. Resource exhaustion. An OutOfMemoryError can be used to communicate information covertly, by \nconditionally allocating objects until the heap is exhausted. JFlow treats this error as fatal, preventing \nit from communicating more than a single bit of infor- mation per program execution. Other exhaustion \nerrors such as StackOverflowError are treated similarly. Wall-clock timing channels. A JFlow program \ncan change its run time based on private information it has observed. As an extreme example, it can enter \nan infinite loop. JFlow does not attempt to control these channels. Unchecked exceptions. Java allows \nusers to define exceptions that need not be declared in method headers (unchecked exceptions), although \nthis practice is described as atypical [GJS96]. In JFlow, there are no unchecked exceptions, since they \ncould serve as covert channels. Type discrimination on parameters. JFlow supports the run- time cast \nand instanceof operators of standard Java, but they may only be invoked using classes that lack parameters. \nThe reason for this restriction is that information about the parameters is not available at run time. \nThese operators could be permitted if the parameters were statically known to be matched, but this is \nnot currently supported. Backward compatibility. JFlow is not backward compatible with Java, since existing \nJava libraries are not flow-checked and do not provide flow annotations. However, in many cases, a Java \nlibrary can be wrapped in a JFlow library that provides reasonable annotations. 3 Static checking and \ntranslation This section covers the static checking that the JFlow compiler performs as it translates \ncode, and the translation process itself. 3.1 Exceptions An important limitation of earlier attempts \nto create languages for static flow checking has been the absence of usable exceptions. For example, \nin Denning s original work on static flow checking, excep-tions terminated the program [DD77] because \nany other treatment of exceptions seemingly leaked information. Subsequent work has avoided exceptions \nentirely. It might seem unnecessary to treat exceptions directly, since in many languages, a function \nthat generates exceptions can be desug- ared into a function that returns a discriminated union or oneof. \nHowever, there are problems with this approach. The obvious way to handle oneofs causes all exceptions \nto carry the same label -an unacceptable loss of precision. Also, Java exceptions are actually objects, \nand the try.. . catch statement functions like a typecase. This model cannot be translated directly into \na oneof. Nevertheless, it is useful to consider how oneof types might be handled in JFlow. The obvious \nway to treat oneof types is by analogy with record types. Each arm of the oneof has a distinct label \nassociated with it. In addition, there is an added integer field tag that indicates which of the arms \nof the oneof is active. The problem with this model is that every assignment to the oneof will require \nthat {tag} Qc, and every attempt to use the oneof will implicitly read {tag}. As a result, every arm \nof the oneof will effectively carry the same label. For modeling exceptions, this is unacceptable. For \neach expression or statement, the static checker determines its path labels, which are the labels for \nthe information transmitted by various possible termination paths: normal termination, termination through \nexceptions, termination through a return statement, and so on. This fine-grained analysis avoids the \nunnecessary restrictiveness that would be produced by desugaring exceptions. Each exception that can \nbe raised by evaluating a statement or expression has a possibly distinct label that is transferred to \nthe= ofcatch statements that might intercept it. Even finer resolution is provided for normal termination \nand for return termination; for example, the label of the value of an expression may differ from the \nlabel associated with normal termination. Finally, termination of astatement by a break or continue statement \nis also tracked without confusing distinct break or continue targets. The path labels for a statement \nor expression are represented as a map from symbols to labels. Each mapping represents a termination \npath that the statement or expression might take, and the label of the mapping indicates what information \nmay be transmitted if this path is known to be the actual termination path. The domain of the map includes \nseveral different kinds of entities: . The symbol ri, which represents normal termination. . The symbol \n1, which represents termination through a return statement. Classes that inherit from Throwa ble. A mapping \nfrom a class represents termination by an exception. . The symbols nv and rv represent the labels of \nthe normal value of an expression and the return value of a statement, respectively. They do not represent \npaths themselves, but it is convenient to include them as part of the map. Their labels are always at \nleast as restrictive as the labels of the corresponding paths. . A tuple of the form (goto C) represents \ntermination by exe-cuting a named break or continue statement that jumps to the target C. A break or \ncontinue statement that does not name a target is represented by the tuple (goto E). These tuples are \nalways mapped to the label T since the static checking rules do not use the actual label. Path labels \nare denoted by the letter X in this paper, and members of the domain of X (paths) are denoted by s. The \nexpression X[s] denotes the label that X maps s to, and the expression X[s := L] denotes a new map that \nis exactly like X except that s is bound to L. Path labels may also map a symbol s to the pseudo-label \nfi, indicating that the statement cannot terminate through the path s. The label @ acts as the bottom \nof the label lattice; fl U L = L for all labels L, including the label {}. The special path labels Xa \nmap all paths to @, corresponding to an expression that does not terminate. 3.2 Type checking vs. label \nchecking The JFlow compiler performs two kinds of static checking as it compiles a program: type checking \nand label checking. These two aspects of checking cannot be entirely disentangled, since labels are type \nconstructors and appear in the rules for subtyping. However, the checks needed to show that a statement \nor expression is safe largely can be classified as either type or label checks. This paper focuses on \nthe rules for checking labels, since the type checks are almost exactly the same as in Java. There are \nseveral kinds of judgements made during static check-ing. The judgment A I-T E : T means that E has type \nT in environment A. The judgment A t- E : X is the information-flow counterpart: it means that E has \npath labels X in environment A. The symbol tT is used to denote inferences in the type domain. The environment \nA maps identifiers (e.g., class names, parameter names, variable names) to various kinds of entities. \nAs with path labels, the notation A[s] is the binding of symbol s in A. The nota-tion A[s := B] is a \nnew environment with s rebound to B. In the rules given here, it is assumed that the declarations of \nall classes are found in the global environment, Ag. A few more comments on notation will be helpful \nat this point. The use of large brackets indicates an optional syntactic element. The letter T represents \na type, and t represents a type expression. The letter C represents the name of a class. The letter L \nrepresents a label, and I represents a label expression. T represents an labeled type expression; that \nis, a pair containing a type expression and an optional label expression. The function intepT(t, A) converts \ntype expressions to types, and the function interp-L(Z, A) converts label expressions to labels. The \nletter v represents a variable name. The letter P represents a formal parameter of a class, and the let- \nter Q represents an actual parameter used in an instantiation of a parameterized class. 3.3 Subtype \nrules There are some interesting interactions between type and label checking. Consider the judgment \nA ET S 5 T, meaning S is a subtype of T . This judgement must be made in JFlow, as in all languages with \nsubtyping. Here, S and T are ordinary unlabeled types. The subtype rule, shown in Figure 6, is as in \nJava, except that it must take account of class parameters. If S or T is an instantiation A [C] = (class \nC[[.. Pi..]] . . . {. . .}) (A k Qi M Q:) V (Pi = (covariant label id) A A t- &#38;i E &#38;)  A k-T \nc[..ei..] 5 C[.&#38;?:..] Ag[C] = (class c [[..~i..]] extends t, . . . {. . .}) T, = inferp-T(t,,cluss-env(C[..Qi..])) \nA ET T, 5 c [..e:..] A kT C[..Qi..] 5 C [..&#38;?: ..] Figure 6: Subtype rules of a parameterized class, \nsubtyping is invariant in the parameters except when a label parameter-is declared to be covariant. This \nsubtyping rule is the first one shown in Figure 6. The function class-env, used in the figure, generates \nan extension of the global environment in which the formal parameters of a class (if any) are bound to \nthe actual parameters: Ag[..purumid(Pi) := Q;..] Using this rule, Vector[L] (from Figure 3) would be \na subtype of AbstractList[L ] only if L M L . Java arrays (written as T{L}[ 1) are treated internally \nas a special type with two parameters, T and L. As in Java, they are covariant in T, but like most JFlow \nclasses, invariant in L. User-defined types may not be parameterized on other types. If S and T are not \ninstantiations of the same class, it is necessary to walk up the type hierarchy from S to T, rewriting \nparameters, as shown in the second rule in Figure 6. Together, the two rules inductively prove the appropriate \nsubtype relationships. 3.4 label-checking rules Let us consider a few examples of static checking rules. \nSpace restrictions prevent presentation of all the rules, but a complete de-scription of the static checking \nrules of JFlow is available [Mye99]. Consider Figure 7, which contains some of the most basic rules for \nstatic checking. The first rule shows that a literal expression always terminates normally and that its \nvalue is labeled with the current pc, as described earlier. The second rule shows that an empty statement \nalways terminates normally, with the same er. as at its start. The third rule shows that the value of \na variable is labeled with both the label of the variable and the current E. Note that the environment \nmaps a variable identifier to an entry of either the form (var T(L) uid) or (var final T(L) c&#38;f), \nwhere T is the variable s type, L is its label, and uid is a unique identifier distinguishing it from \nother variables of the same name. The fourth rule covers assignment to a variable. Assignment is allowed \nif the variable s label is more restrictive than that of the value being assigned (which will include \nthe current &#38;. Whether one label is more restrictive than other is inferred using the current environment, \nwhich contains information about the static principal hierarchy. The complete rule for checking this \nstatement would have an additional antecedent A k_T E : T, but such type-checking rules have been omitted \nin the interest of space. The final rule in Figure 7 covers two statements Si and SZ per- formed in sequence. \nThe second statement is executed only if the first statement terminated normally, so the correct s for \nchecking the second statement is the normal path label of the first statement (Xi [n]). The function \nextend extends the environment A to add any local variable declarations in the statement Si. The path \nlabels of the sequence must be at least as restrictive as path labels of both true A t- literal : X,[c \n:= A[pcJ, no := A[pcJ true At; :X@[L!:=A[pcJ] A[v] = (var [final] T(L) uid) X =X,~::=A[pcJ,~:=LuA[pcJ] \nAt-v:X Al-E:X A[v] = (var T(L) uid) -Pik X[nv] &#38; L - Al-v=E:X A t S, : X, extend(A, S,)[E := XI [nJ \nt- &#38; : X2  x=xl[n:=8]@X2 AkS,;S2:X (X = xi $X2) E vs (X[s] = Xi[S]LJX&#38;]) Figure 7: Some simple \nlabel-checking rules statements; this condition is captured by the operator @, which merges two sets \nof path labels, joining all corresponding paths from both. Figure 8 contains some more complex rules. \nThe rule for array element assignment mirrors the order of evaluation of the expres- sion. First, the \narray expression E, is evaluated, yielding path labels X,. If it completes normally, the index expression \nEi is evaluated, yielding Xi. Then, the assigned value is evaluated. Java checks for three possible exceptions \nbefore performing the assignment. The function exe, defined at the bottom, is used to simplify these \ncondi-tions. This function creates a set of path labels that are just like X except that they include \nan additional path, the exception C, with the path label L. Since observation of normal termination (n) \nor the value on normal termination (nv) is conditional on the exception not being thrown, exe joins the \nlabel L to these two mappings as well. Finally, avoiding leaks requires that the label on the array elements \n(L,) is at least as restrictive as the label on the information being stored (X,, [nv]). The next rule \nshows how to check an if statement. First, the path labels XE of the expression are determined. Since \nexecution of Si or S2 is conditional on E, the E for these statements must include the value label of \nE, XE [A. Finally, the statement as a whole can terminate through any of the paths that terminate E, \nSI, or St-except normal termination of E, since this would cause one of Si or S2 to be executed. If the \nstatement has no else clause, the statement S2 is considered to be an empty statement, and the second \nrule in Figure 7 is applied. The next rule, for the while statement, is more subtle because of the presence \nof a loop. This rule introduces a label variable L to represent the information carried by the continuation \nof the loop through various paths. L represents an unknown label that will be solved for later. It is \nessentially a loop invariant for information flow, L may carry information from exceptional termination \nof E A t_~ E : class C {. .} A t Ea : X, AI-E:XE A[= I= Xo[nJ] k Ei : Xi x = exc(XE,XE~,C)[lJ := gJ \nAk := Xi[nJ] t E, : X, A t- throw E : X XI = exc(X, @Xi $X,,, Xa[d, NullPointerException) X2 = exc(X~, \nXaw U X;[nv], OutOfBoundsException) X = erc(X2, X, [d ii X, [nv], ArrayStoreException) AtS:Xs A F-T Ea \n: T{L}[ ] pci = exe-label(Xs, Ci) A I- X,[nvJuXxW C L, AL := pci, V; := (var final C{p&#38;}fresh-uid())] \nI- Si : Xi A t E,[Ei] = E, : X X = ($, Xi) @ uncaught(Xs, (.., C;, ..)) A t try {S} ..catch(Ci vi) {Si}.. \n: X AtE:XE A k Sl : Xl A t S2 : X2 A[= := X,b]] t- S1 : X1 x =X,~:=fl@Xz A[@ := X,[d] t S2 : X2 A t try \n{Sl} finally (S2) : X X=Xfl[~:= ~@X*f3X* A k if (E) SI else S2 : X exc-label(X,Cl = ucticc, <cvc<c,j \nXV 1 L = fresh-variable0 A = A[E := L, (goto e) := L] A tE:XE A [eS. := X,w] t- S : Xs A k X,[nJ &#38; \nL x = (xE e3xsj[&#38;Oto e) := 8] A t- while (E) S : X A I- do S while (E) : X A t Am &#38; A[(goto \nL)] A t continue L : X@[(goto L) := T] A k break .C : Xo[(goto L) := T]   AI-S:X 5 E {n,zl V(s ) 8 \nE path.9 A 8 # 8) X[s ] = @ X = X [s := A[d] At-S:X paths = all symbols except E, 2 exc(X, L, C) = X \n$ X,[c := L, nv := L, C := L] Figure 8: More label-checking rules or S, or from break or continue statements \nthat occur inside the loop. An entry is added to the environment for the tuple (goto E) to capture information \nflows from any break or continue statements within the loop. The rules for checking break and continue, \nshown below the rule for while, use these environment entries to apply the proper restriction on information \nflow. Assuming that L is the entering E label, XS[E] is the final ez label. The final condition requires \nthat L may be at most as restrictive as L, which is what establishes the loop invariant. The last rule \nin Figure 8 applies to any statement, and is important for relaxing restrictive path labels. It is intuitive: \nif a statement (or  (X = uncaughr(X, (..,C;, ..))) = X [S] = (if (3 (s 5 Ci)) then g else X[s]) Figure \n9: Exception-handling rules a sequence of statements) can only terminate normally, the E at the end is \nthe same as the E at the beginning. The same is true if the statement can only terminate with a return \nstatement. This rule is called the single-path rule. It would not be safe for this rule to apply to exception \npaths. To see why, suppose that a set of path labels formally contains only a single exception path C. \nHowever, that path might include multiple paths consisting of exceptions that are subclasses of C. These \nmultiple paths can be discriminated using a try.. . catch statement. The unusual Java exception model \nprevents the single-path rule from being applied to exception paths. However, Java is a good language \nto extend for static flow anal- ysis in other ways because it fully specifies evaluation order. This \nproperty makes static checking of information flow simpler, because the rules tend to encode all possible \nevaluation orders. If there were non-determinism in evaluation order, it could be encoded by adding label \nvariables in a manner similar to the rule for the while statement. 3.5 Throwing and catching exceptions \nExceptions can be thrown and caught safely in JFlow using the usual Java constructs. Figure 9 shows the \nrule for the throw state-ment, a try.. . catch statement that lacks a finally clause, and a try. . . \nfinally statement. (A try statement with both catch clauses and a finally clause can be desugared into \na try.. . catch inside a try. . . finally.) The rule for throw is straightforward. The idea behind the \ntry.. . catch rule is that each catch clause is executed with a E that includes all the paths that might \ncause the clause to be executed: all the paths that are exceptions where the exception class is either \na subclass or a superclass of the class named in the catch clause. The function exe-label joins the labels \nof these paths. The path labels of the whole statement merge all the path labels of the various catch \nclauses, plus the paths from Xs that might not be caught by some catch clause, which include the normal \ntermination path of Xs if any. The try. . . finally rule is very similar to the rule for sequencing two \nstatements. One difference is that the statement S2 is checked with exactly the same initial s that 5 \n1 is, since S2 is executed no y = true; A k call-begin(C[Q;], (..,I$, ..),S, A ,LI,L$) try { A F call-end(CIQi],S,A \n,Ll,LdRe,f) :X if(x) throw new E(); A t- call(C[Q;], (..,Ej, ..),S) : X y = false; c)atch (E e) { } Figure \n10: Implicit flow using throw AI- E:XE Li = inferp-L(Zi, A) A k X,[WJ E L~LJLRT ANT E:T A I-T T 5 iflterp-T(ti, \nA) &#38;,=XE[d pCi = PC;_, U label(XE [d U Li) Ak := pci,v; := (var final Ti{L;}fresh-uid())] k S; : \nX; x=xE@(@;xi) A k switch label(E)(..case (ti{li} Vi) Si..} : X Figure 11: Inference rule for switch \nlabel matter how Si terminates. To see how these exception rules work, consider the code in Figure 10. \nIn this example, x and y are boolean variables. This code transfers the information in x to y by using \nan implicit flow resulting from an exception. In fact, the code is equivalent to the assignment y = x. \nUsing the rule of Figure 9, the path labels of the throw statement are {E + {x}}, so the path labels \nof the if statement are X = {E -+ {x},n + {x}}. The assignment y = false is checked with E = X[n] = {x}, \nso the code is allowed only if {x} C {y}. This restriction is correct since it is exactly what the equivalent \nassignment statement would have required. Finally, applying both the try-catch rule here and the single-path \nrule from Figure 8, the value of ez after the code fragment is seen to be the same as at its start. Throwing \nand catching an exception does not necessarily taint subsequent computation.  3.6 Run-time label checking \nAn interesting aspect of checking JFlow is checking the switch label statement, which inspects a dynamic \nlabel at run time. The inference rule for checking this statement is given in Figure 11. In- tuitively, \nthe switch label statement tests the equation XE [fi 5 Li for every arm until it finds one for which \nthe equation holds, and executes it. However, this test cannot be evaluated either statically or at run \ntime. Therefore, the test is split into two stronger condi-tions: one that can be tested statically, \nand one that can be tested dynamically. This rule naturally contains the static part of the test. Let \nLRT be the join of all possible run-time-representable com-ponents (i.e., components that do not mention \nformal label or princi- pal parameters). The static test is that XE[E] U LRT C Li U LRT (equivalently, \nXE[~] C Li U LRT); the dynamic test is that XE[IIJ~I~LRTCL~ITLRT. Together, these two tests imply the \nfull condition XE [E] &#38; Li. The test itself may be used as an information channel, so after the check, \nthe s must include the labels ofXE [nv] and every Li up to this point. This rule uses the label function \nto achieve this. When applied to a label L, it generates a new label that joins together the labels of \nall variables that are mentioned in L. However, the presence of label in constraint equations does not \nchange the process S = ([static] To m [{z>] (..~j aj..) [:{R}] throws(..Tk..) where I&#38;) X0 = XQ[c \n:= A[pcJ] A[= := X+,[nJ] I- Ej : Xj Lj = fresh-variable0 uidj = fresh-uid() AC = class-env( C[ Q;]) Aa \n= AC[..a, := (var final type-part(Tj,A=){Lj} uidj)..] LI = (if [{I)] then interp-L(l, A ) else X,,,ax(j) \n[I$ A k Lj % (if labeled then label-part(rj, Aa) U LI else Lj) A I-X,M L Lj A 1 Xm&#38;l 5 Lr Lg$ = \n(if (TV = void) then {} else uIXj [nvJ) sarisfies-consrruinfs(d, An, A[..oj := Ej . .I, (.&#38;..)) \nA k call-begin(C[Qi],(..Ej..),S,AO, Ll, L , ,f) let inrerp(p) = inferp-P-caN(p, A, A , Am) in case Ki \nOf authority(. . .) : true caller(..pj..) : V(pj)Z(p E A[&#38;) A k p k interp(pj) actsFor(pl,pz) : A \nI- inferp(pl) k inrerp(pz) end end  saris~es-consrraint(A, Aa, Am, (..&#38; ..)) S = ([static] 7r m[{I}] \n(..Tj q..) [:{RJ] throws(..Tk..) where ICI) LR = LI u (if [ : {RI] then interp-L(R, Aa) else {}) LRV \n= LR U (if labeled then label-parr(T,.,A ) else L , ) Ck = type-part(Tl,, class-env(C[QJ)) X = (@; Xj)[fi \nI= LR, nv := LRV] X = X @Xi[.:Ck := label-parr(rk,A ) U LR..] At call-end(C[Qi],S,Aa,Lr,Lz$) :X Figure \n12: Checking calls of solving label constraints in any fundamental way.  3.7 Checking method calls \n Let us now look at some of the static checking associated with objects. Static checking in object-oriented \nlanguages is often com-plex, and the various features of JFlow only add to the complexity. This section \nshows how, despite this complexity, method calls and constructor calls (via the operator new) are checked \nstatically. The rules for checking method and constructor calls are shown in Figures 12 and 13. Figure \n12 defines some generic checking that is performed for all varieties of calls, and Figure 13 defines \nthe rules for checking ordinary method calls, static method calls, and constructor calls. To avoid repetition, \nthe checking of both static and non-static method calls, and also constructor calls, is expressed in \nterms of the predicate call, which is defined in Figure 12. This predicate is in turn expressed in terms \nof two predicates: call-begin and call-end. A b-T E, : c[..&#38;.] T [actsFor(pl ,pT) S] = A bT Ei :Ti \nif (_dynamic_PH.actsFor(T[plT],TO[p;!l])) T[Sj signarure(C[..&#38;;..], m(..Ti..), S) A t E, : X, A[= \nI= X,[d] k cUll(C[..Qi..], (..Ei..),S) : X A I- Es m(..Ei..) : X T = interp-T(t, A) AFT Ej :Ti signature(T,m(..T~..),S) \nA I- call(T, (..E3 ..), S) : X A t t m(..Ei..) : X T = C[..Q,..] = interp-T(t,A) Ag[C] = (class C [[..P,..]] \n. . [authority(..pi..)] . .) AI-T Ei :Ti signature(T, C( ..Tj ..), S) S = (C[{Z}] (..Ti ai..) [:(R} throws(..q..) \nwhere Xl) S = (staticTO m[{Zj](..~i oi..) 1:{R}] throws(..Tb..) where&#38;) At cd(T,(..E,..),S ) :X \nV(parameters pl) 3(p E A[a) A t p k interp-P(pl, class-em(T)) A b new t(..Ei..) : X Figure 13: Rules \nfor specific calls The predicate call-begin checks the argument expressions and establishes that the \nconstraints for calling the method are satisfied. In this rule, the functions type-part and label-part \ninterpret the type and label parts of a labeled type 7. The rule determines the begin label Lr, the default \nreturn label L , ,f, and the argument environment A , which binds all the method arguments to appropriately \nlabeled types. Invoking a method requires evaluation of the arguments Ei, producing corresponding path \nlabels Xj . The argument labels are bound in A to labels Lj, sothe line (Xj [A _CLj) ensures that the \nactual arguments can be assigned to the formals. The begin-label LI is also required to be more restrictive \nthan the E after evaluating all of the arguments, which is Xm,(i)b]. The call site must satisfy all the \nconstraints imposed by the method, which is checked by the predicate satisjies-constraints. The rule \nfor this predicate, also in Figure 12, uses the function interp-P-call, which maps identifiers used in \nthe method constraints to the corresponding principals. To perform this mapping, the func- tion needs \nenvironments corresponding to the calling code (A), the called code (A ), and a special environment that \nbinds the actual arguments (A ). The environment entry A[d contains the set of principals that the code \nis known statically to act for. The judge- ment A k pl k p:! means that pl is known statically to act \nfor pz. (The static principal hierarchy is also placed in the environment.) Finally, the predicate call-end \nproduces the path labels X of the method call by assuming that the method returns the path labels that \nits signature claims. The label L,, def is used as the label of the return value in the case where the \nreturn type, T,., is not labeled. It joins together the labels of all of the arguments, since typically \nthe return value of a function depends on all of its arguments. The rules for the various kinds of method \ncalls are built on top of this framework, as shown in Figure 13. In these rules, the function signature \nobtains the signature of the named method from the class. The rule for constructors contains two subtle \nsteps: first, T[switch label(E) { ..case( t;{l;}) Si.. else S, }I = TV = TUE]; if (T[[x~wn L~~B.relabelsTo(TULl \nfl LRTJ~)) {     TUSlJl } else . if (T[xE[fin LRTn.relabelsTo(TILin LRTn) ( T/l&#38;n } . . . else \n{ T[S,J} Figure 14: Interesting JFlow translations constructors are checked as though they were static \nmethods with a similar signature. Second, a call to a constructor requires that the caller possess the \nauthority of all principals in the authority of the class that are parameters. The caller does not need \nto have the authority of external principals named in the authority clause. 3.8 Constraint solving As \nthe rules for static checking are applied, they generate a constraint system of label variables for each \nmethod [ML97]. For example, the assignment rule of Figure 7 generates a con-straint X[d CL. All of the \nconstraints are of the form A,u . . . uA,&#38;B,U . . . uB,,. These constraints can be split into individual \nconstraints Ai L B1 U . . . U B, because of the lat- tice properties of labels. The individual terms \nin the constraints may be policies, label variables, label parameters, dynamic labels, or expressions \nlabel(L) for some label L. The constraints can be efficiently solved, using a modification to a lattice \nconstraint-solving algorithm [RM96] that applies an ordering optimization [HDT87] shown to produce the \nbest of sev-eral commonly-used iterative dataflow algorithms [KW94]. The approach is to initialize all \nvariables in the constraints with the most restrictive label (T) and iteratively relax their labels until \na satisfying assignment or a contradiction is found. The label does not create problems because it is \nmonotonic. The relaxation steps are ordered by topologically sorting the constraints and looping on strongly-connected \ncomponents. The number of iterations re-quired is O(nh) where h is the maximum height of the lattice \nstructure [RM96], and also O(nd) where d is the maximum back edges in depth-first traversal of the constraint \ndependency graph [HDT87]. Both h and d seem likely to be bounded for reasonable programs. The observed \nbehavior of the JFlow compiler is that constraint solving is a negligible part of run time. 3.9 Translation \nThe JFlow compiler is a static checker and source-to-source trans-lator. Its output is a standard Java \nprogram. Most of the annotations in JFlow have no run-time representation; translation erases them, leaving \na Java program. For example, all type labels are erased to produce the corresponding unlabeled Java type. \nClass parameters are erased. The declassify expression and statement are replaced by their contained \nexpression or statement. Uses of the built-in types label and principal are translated to the Java types \njflow.lang.Label and jflow.lang.Principal, respectively. Variables declared to have these types remain \nin the translated pro-gram. Only two constructs translate to interesting code: the actsFor and switch \nlabel statement, which dynamically test principals and labels, respectively. The translated code for \neach is simple and efficient, as shown in Figure 14. Note that the translation rule for switch label \nuses definitions from Figure 11. As discussed earlier, the run-time check is XE[E] fl LRT E LI n L&#38;W, \nwhich in effect is a test on labels that are completely representable at run time. The translated code \nuses the methods relabelsTo and a&#38;For of the classes jflow.lang.Label and jflow.lang.Principal, respectively. \nThese methods are accelerated by a hash-table lookup into a cache of results, so the translated code \nis fast. Related work There has been much work on information flow control and on the static analysis \nof security guarantees. The lattice model of informa- tion flow comes from the early work of Bell and \nLaPadula[BL75] and Denning [Den76]. Most subsequent information control mod-els use dynamic labels rather \nthan static labels and therefore cannot be checked statically. The decentralized label model has similarities \nto the ORAC model [MMN90]: both models provide some approx- imation of the originator-controlled release \n labeling used by the U.S. DOD/Intelligence community, although the ORAC model is dynamically checked. \n Static analysis of security guarantees also has a long history. It has been applied to information flow \n[DD77, AR80], to ac-cess control [JL78, RSC92], and to integrated models [Sto81]. There has recently \nbeen more interest in provably-secure pro-gramming languages, treating information flow checks in the \ndo- main of type checking. Some of this work has focused on for-mally characterizing existing information \nflow and integrity mod-els [PO95, VSI96, Vol97]. Smith and Volpano have recently ex-amined the difficulty \nof statically checking information flow in a multithreaded functional language [SV98], which JFlow does \nnot address. However, the rules they define prevent the run time of a pro- gram from depending in any \nway on non-public data. Abadi [Aba97] has examined the problem of achieving secrecy in security proto-cols, \nalso using typing rules, and has shown that encryption can be treated as a form of safe declassification \nthrough a primitive encryption operator. Heintze and Riecke [HR98] have shown that information-flow- \nlike labels can be applied to a simple language with reference types (the SLam calculus). They show how \nto statically check an in-tegrated model of access control, information flow control, and integrity. \nTheir labels include two components: one which enforces conventional access control, and one that enforces \ninformation flow control. Their model has the limitation that it is entirely static: it has no run-time \naccess control, no declassification, and no run-time flow checking. It also does not provide label polymorphism \nor ob- jects. Heintze and Riecke prove some useful soundness theorems for their model. This step would \nbe desirable for JFlow, but im- portant features like objects, inheritance and dependent types make formal \nproofs of correctness difficult at this point. An earlier paper [ML971 introduced the decentralized label \nmodel and suggested a simple language for writing information-flow safe programs. JFlow extends the ideas \nof that simple language in several important ways and shows how to apply them to a real program-ming \nlanguage, Java. JFlow adds support for objects, fine-grained exceptions, explicit parameterization, and \nthe full decentralized la-bel model [ML98]. Static checking is described by formal inference rules that \nspecify much of the JFlow compiler. The performance of the label inference algorithm (the constraint \nsolver) also has been improved. 5 Conclusions Privacy is becoming an increasingly important security \nconcern, and static program checking appears to be the only technique that can provide this security \nwith reasonable efficiency. This paper has described the new language JFlow, an extension of the Java \nlanguage that permits static checking of flow annotations. To our knowledge, it is the first practical \nprogramming language that allows this checking. The goal of this work has been to add enough power to \nthe static checking framework to allow reasonable programs to be written in a natural manner. JFlow addresses \nmany of the limitations of previous work in this area. It supports many language features that have not \nbeen previously integrated with static flow checking, including mutable objects (which subsume function \nvalues), subclassing, dynamic type tests, dynamic access control, and exceptions. Avoiding unnecessary \nrestrictiveness while supporting a com-plex language has required the addition of sophisticated language \nmechanisms: implicit and explicit polymorphism, so code can be written in a generic fashion; dependent \ntypes, to allow dynamic label checking when static label checking would be too restrictive; static reasoning \nabout access control; statically-checked declassification. This list of mechanisms suggests that one \nreason why static flow checking has not been widely accepted as a security technique, de-spite having \nbeen invented over two decades ago, is that program- ming language techniques and type theory were not \nthen sophis-ticated enough to support a sound, practical programming model. By adapting these techniques, \nJFlow makes a useful step towards usable static flow checking. Acknowledgments I would like to thank \nseveral people who read this paper and gave useful suggestions, including Sameer Ajmani, Ulana Legedza, \nand the reviewers. Kavita Bala, Miguel Castro, and Stephen Garland were particularly helpful in reviewing \nthe static checking rules. I would also like to thank Nick Mathewson for his work on the PolyJ compiler, \nfrom which I was able to steal much code, and Barbara Liskov for her support on this project. A Grammar \nextensions JFlow contains several extensions to the standard Java grammar, in order to allow information \nflow annotations to be added. The fol- lowing productions must be added to or modified from the standard \nJava Language Specification [GJS96]. As with the Java grammar, some modifications to this grammar are \nrequired if the grammar is to be input to a parser generator. These grammar modifications (and, in fact, \nthe code of the JFlow compiler itself) were to a con- siderable extent derived from those of PolyJ, an \nextension to Java that supports parametric polymorphism [MBL97, LMM98]. A.1 Label expressions LabelExpr: \n{ Components,,, } Components: Component Components ; Component Component: Principal : PrincipalsOP, this \nIdentidier * Identifier Principals: Principal Principals , Principal Principal: Name A.2 Labeled types \nTypes are extended to permit labels. The new primitive types label and principal are also added. LabeledType: \nPrimtiveTyge LakIExprOp, ArrayType LabeJExpr,, Name LabeJExprOpt TypeOrIndex LabeJExprop, PrimitiveType: \nNumericType boolean label principal The TypeOrIndex production represents either an instantiation or \nan array index expression. Since both use brackets, the ambiguity is resolved after parsing. TypeOrJndex: \nName [ ParamOrExprList ] Armylndex: TypeOrJndex PrimaryNoNewArmy [ Expression ] CJassOrlnterfaceType: \nName TypeOrlndex ParamOrExprList: PafamOrExpr ParamOrExprList , ParamOrExpr ParamOrExpr: Expression LabeJExpr \nArrayType: LabeledType [ ] ArmyCreationExpression: new LabeledType DimExprs OptDims A.3 Class declarations \nCJassDecJaration: Modifiersop, class Identifier ParamsO~~ Super,, Interfaces,,,, optA utbority CJassBody \nJnterfaceDecJaration: Modifiers,,, interface Identifier Params,,, ExtendslntertkesO~, Interfaces,,, InterfaceBody \n Params: [ ParamererList ] ParameterList: Parameter ParameterList , Parameter Parameter: label Identifier \ncovariant label Identifier principal Identifier Authority: authority ( Principals ) A.4 Method declarations \nMetiodHeader: Modifier+,, LabeJedType Identifier BeginLabeJopl ( FormafParameterLisb~, ) EndLabel,pr \nThrows,,, WhereConstraink+ Modifiers,,, void Identifier BeginLabeJO,,, ( FormalParameterLisb~, ) EndLabeJop, \nThrows,,, WhereCons&#38;ain&#38;,~t ConstructorDeclaration: ModifiersOpt Identifier BeginLabeJop, ( \nFormalParameterList ) EndLabel,,* Throws,,, WhereConstmi&#38;,~~ FormalParameter: LabeledType Identifier \nOptDims BeginLabel: LabeJExpr E&#38;Label: : LabeJExpr WhereConstraints: where Constraints Constraints: \nConstraint Constraints , Constraint Constraint: Authoti ty caller ( Principals ) acts-For ( Principal \n, Principal ) To avoid ambiguity, the classes in a throws list must be placed in parentheses. Otherwise \na label might be confused with the method body. Throws: throws ( ThrowList )  A.5 New statements Statement: \nStatementWithoutTraiJingSubstatement . . existing productions . . ForStatement SwitcbLabeJStatement ActsForStatement \nDeclassifyStatement SwitcMabeJStatement: switch label ( Expression ) { LabeJCases } LabeJCases: LabelCase \nLabeJCases LabelCase LabelCase: case ( Qpe LabeJExpr JdentiJier ) OptBJockStatements case LabclExpr OptBlockStatements \nelse OptBJockStatements ActsForStatement: a&#38;For ( Principal, Principal ) Statement The declassify \nstatement executes a statement, but with some restrictions removed from E. DeclassifyStatement: declassify \n( LabcJExpr ) Statement A.6 New expressions Literal: existing productions . new labelLabelExpr DeclassifyExpression: \ndeclassify( Expression , LabelExpr) References [Aba97] Martin Abadi. Secrecy by typing in security protocols. \nIn Proc. Theoretical Aspects of Computer Software: Third International Conference, September 1997. [ACPP91] \nMartin Abadi, Luca Cardelli, Benjamin C. Pierce, and Gordon D. Plotkin. Dynamic typing in a statically \ntyped language. ACM Transactions on Programming Lan-guages and Systems (TOPLAS), 13(2):237-268, April \n1991. Also appeared as SRC Research Report 47. [AR801 Gregory R. Andrews and Richard P. Reitman. An ax-iomatic \napproach to information flow in programs. ACM Transactions on Programming Languages and Systems, 2( 1):56-76, \n1980. [BL75] D. E. Bell and L. J. LaPadula. Secure computer system: Unified exposition and Multics interpretation. \nTechni-cal Report ESD-TR-75-306, MITRE Corp. MTR-2997, Bedford, MA, 1975. Available as NTIS AD-A023 588. \n[Cull Luca Cardelli. npeful programming. In E. J. Neuhold and M. Paul, editors, Formal Description of \nProgram- ming Concepts. Springer-Verlag, 1991. An earlier ver-sion appeared as DEC Systems Research Center \nRe-search Report #45, February 1989. [DD77] Dorothy E. Denning and Peter J. Denning. of programs for \nsecure information flow. ACM, 20(7):5W513, 1977. Certification Comm. of the [Den761 Dorothy E. Denning. \nA lattice model of secure mation flow. Comm. of the ACM, 19(5):236-243, infor-1976. [Den821 Dorothy E. \nDenning. Cryptography and Data Security. Addison-Wesley, Reading, Massachusetts, 1982. [GJS96] James \nGosling, Bill Joy, and Guy Steele. The Java Language Specification. Addison-Wesley, August 1996. ISBN \n0-201-63451-l. [HDT87] Susan Horwitz, Alan Demers, and Tim Teitelbaum. An efficient general iterative \nalgorithm for dataflow analy-sis. Acta Informarica, 24:679-694, 1987. [HR98] Nevin Heintze and Jon G. \nRiecke. The SLam calculus: Programming with secrecy and integrity. In Proc. 25th ACM Symp. on Principles \nof Programming Languages (POPL), San Diego, California, January 1998. [JL78] Anita K. Jones and Barbara \nLiskov. A language exten-sion for expressing constraints on data access. Comm. of the ACM, 21(5):358-367, \nMay 1978. [KW94] Atsushi Kanamori and Daniel Weise. Worklist manage-ment strategies for dataflow analysis. \nTechnical Report MSR-TR-94-12, Microsoft Research, May 1994. [Lam731 Butler W. Lampson. A note on the \nconfinement problem. Comm. of theACM, 16(10):613-615, October 1973. [LMM98] [MBL97] [ML971 [ML981 [MMN90] \n[We991 [PO951 [RM96] [RSC92] [Sto81] [SV98] [Vo197] Barbara Liskov, Nicholas Mathewson, and Andrew C. \nMyers. PolyJ: Parameterized types for Java. Software release. Located at http://www.pmg.lcs.mit.edu/polyj, \nJuly 1998. Andrew C. Myers, Joseph A. Bank, and Barbara Liskov. Parameterized types for Java. In Proc. \n24th ACM Symp. on Principles of Programming Languages (POPL), pages 132-145, Paris, France, January 1997. \nAndrew C. Myers and Barbara Liskov. A decentralized model for information flow control. In Proc. 17th \nACM Symp. on Operating System Principles (SOSP), pages 129-142, Saint-Malo, France, 1997. Andrew C. Myers \nand Barbara Liskov. Complete, safe information flow with decentralized labels. In Proc. IEEE Symposium \non SecuriQ and Privacy, Oakland, CA, USA, May 1998. Catherine J. McCollum, Judith R. Messing, and LouAnna \nNotargiacomo. Beyond the pale of MAC and DAC -defining new forms of access control. In Proc. IEEE Symposium \non Security and Privacy, pages 190-200,199o. Andrew C. Myers. Mostly-Static Decentralized Infor-mation \nFlow Control. PhD thesis, Massachusetts Insti-tute of Technology, Cambridge, MA, 1999. In progress. Jens \nPalsberg and Peter 0rbek. Trust in the X-calculus. In Proc. 2nd International Symposium on Static Analy- \nsis, number 983 in Lecture Notes in Computer Science, pages 314-329. Springer, September 1995. Jakob \nRehof and Torben W. Mogensen. Tractable con-straints in finite semilattices. In Proc. 3rd International \nSymposium on Static Analysis, number 1145 in Lecture Notes in Computer Science, pages 285-300. Springer-Verlag, \nSeptember 1996. Joel Richardson, Peter Schwarz, and Luis-Felipe Cabr-era. CACL: Efficient fine-grained \nprotection for objects. In Proceedings of the I992 ACM Conference on Object- Oriented Programming Systems, \nLanguages, and Appli- cations, pages 154-165, Vancouver, BC, Canada, Octo-ber 1992. Allen Stoughton. \nAccess flow: A protection model which integrates access control and information flow. In IEEE Symposium \non SecuriQ and Privacy, pages 9-18. IEEE Computer Society Press, 1981. Geoffrey Smith and Dennis Volpano. \nSecure infor-mation flow in a multi-threaded imperative language. In Proc. 25th ACM Symp. on Principles \nof Program- ming Languages (POPL), San Diego, California, Jan-uary 1998. Dennis Volpano. Provably-secure \nprogramming lan-guages for remote evaluation. ACM SIGPLAN Notices, 32(1):117-l 19, January 1997. Dennis \nVolpano, Geoffrey Smith, and Cynthia Irvine. A sound type system for secure flow analysis. Journal of \nComputer Security, 4(3):167-187, 1996.  \n\t\t\t", "proc_id": "292540", "abstract": "", "authors": [{"name": "Andrew C. Myers", "author_profile_id": "81100011022", "affiliation": "Laboratory for Computer Science, Massachusetts Institute of Technology", "person_id": "PP14016809", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/292540.292561", "year": "1999", "article_id": "292561", "conference": "POPL", "title": "JFlow: practical mostly-static information flow control", "url": "http://dl.acm.org/citation.cfm?id=292561"}