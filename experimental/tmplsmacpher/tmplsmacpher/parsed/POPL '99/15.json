{"article_publication_date": "01-01-1999", "fulltext": "\n Extending the Scope of Syntactic Abstraction* Oscar Waddell R. Kent Dybvig University of Kansas Indiana \nUniversity owaddellQittc.ukans.edu dyb@cs.indiana.edu Abstract The benefits of module systems and lexically \nscoped syntac- tic abstraction (macro) facilities are well-established in the literature. This paper \npresents a system that seamlessly in- tegrates modules and lexically scoped macros. The system is fully \nstatic, permits mutually recursive modules, and sup- ports separate compilation. We show that more dynamic \nmodule facilities are easily implemented at the source level in the extended language supported by the \nsystem. Introduction The benefits of module systems and lexically scoped syn-tactic abstraction (macro) \nfacilities are well-established [l, 2, 3, 6, 7, 8, 12, 10, 11, 15, 16, 181. Over the past several years \nthere has been increasing interest in combining lexi-tally scoped macros and modules [2, 16, 171. Building \non this work we present here the first fully implemented system that allows arbitrary composition of \nmodule and macro facilities, supports separate compilation, and supports fully general macro transformations \nwhile maintaining lexical scoping for all macros. Our design derives from the philosophy that a program- \nming language should be based on a small core language aug- mented by a powerful syntactic abstraction \nfacility. The core language should have simple constructs and a straightfor- ward semantics, and the \nsyntactic abstraction facility should permit the definition of new language constructs whose mean- ings \ncan be understood in terms of their static translation into the core language. Our system extends the \nsmall core language and powerful syntactic abstraction mechanisms of the syntax-case sys-tem [4, 61 with \nsupport for modules. A module is a named scope that encapsulates a set of identifier bindings. Im-porting \nfrom a module makes these identifier bindings vis-ible in the importing context. Modules control visibility \nof bindings and can be viewed as extending lexical scoping to *This material is based on work supported \nin part by the Na- tional Science Foundation under grants CCR-9623753 and CCR- 9711269. Permission to \nmake digital or hard copies of all or part ofthis work for personal or ck~ss~ oom use is granted without \nfez probided that copies are not made or distrihutcd fbr profit or commercial advanragc a1v.i that topics \nbear this notice and the full citation on the first page. fo copy otherwise. to republish. to post on \nsc~wrs or to distribute to lists, require5 prior specific permission and!or a fee. POPL 99 San Antonio \nTexas USA Copyright ACM 1999 l-58113-0953/99/01...$5.00 allow more precise control over where bindings \nare or are not visible. Modules export identifier bindings, i.e., vari-able bindings, keyword bindings, \nor module name bindings. The primitive module and import forms are simple, may be extended via syntactic \nabstraction, and may appear at top level, within local scopes, or nested within other modules. A program \ncontaining module and import forms may be un- derstood statically in terms of a straightforward translation \nto core language forms. The remainder of this paper is organized as follows. Sec-tion 2 describes an \nextended language that supports both modules and syntactic abstraction. Section 3 demonstrates the synergy \nbetween modules and syntactic abstraction with a series of short examples. Section 4 describes the implemen- \ntation. Section 5 addresses practical concerns such as sepa- rate compilation and supporting static program \nanalysis in the presence of powerful macro systems. Section 6 discusses related work, and Section 7 presents \nour conclusions. 2 Language 2.1 Syntax The core language of the syntax-case system is the core language \nof the Revised5 Report on Scheme [9]. In the core language, a program consists of a sequence of definitions \nand expressions. (program) + (form)* (form) + (definition) 1(expression) A definition is a variable \ndefinition or a sequence of defini- tions (definition) --+ (define (variable) (expression) > 1 (begin \n(definition)*) (variable) --+ (identifier) An expression is a constant, a quoted datum, a variable reference, \nan abstraction, an application, a conditional, or an assignment. (expression) -+ (constant) 1 (quote \n(datum)) 1 (variable) I (lambda expression) ) ((expression) (expression) *) 1 (if (expression) (expression) \n(expression) ) I (set ! (variable) (expression)) (lambda expression) --+ (lambda (formals) (body) 1 (definition)* \n(expression)+ (body) - Thus, definitions may appear both at the top level of a pro- gram or nested within \na lambda body. Support for syntactic abstraction is provided by extend- ing the set of definition forms \nto include both keyword defi- nitions and definitions derived via syntactic abstraction, i.e., macro \ncalls that expand into definitions. (definition) --+ (define (variable) (expression) 1 1 (define-syntax \n(keyword) (expression) > 1 (begin (definition)*) 1 (derived definition) (keyword) + (identifier) (derived \ndefinition) --+ (macro call) In addition, the set of expression forms is extended to in-clude derived \nexpressions. (expression) ---+ (constant) 1 (quote (datum)) (variable) (lambda expression) ((expression) \n(expression) *) (if (expression) (expression) (expression) 1 (set ! (variable) (expression)) 1 (derived \nexpression) (derived expression) ---+ (macro call) As in the core language, definitions may appear at \ntop level or nested within lambda bodies. They may also appear nested within the bodies of derived expressions \nthat ex-pand into lambda expressions, such as let, which expands as shown below. (let ((z e> . ..) formi \nform2 . ..> -+ ((lambda (2 . ..> formi form2 . ..I e . ..) The language is further extended to support \nmodules by the addition of two new definition forms, module and import. (definition) --+ (define (variable) \n(expression) ) 1 (define-syntax (keyword) (expression)) 1 (begin (definition)*) 1 (derived definition) \n1 (module (module name) (interface) (definition) * (expression) * 1 1 (import (module name)> (interface) \n-+ ((identifier)*) (module name) + (identifier) A module consists of a (possibly empty) set of definitions \nand a (possibly empty) sequence of initialization expres-sions. Each identifier listed in a module s \ninterface must be defined within that module. Because module and import are definitions, they may appear \nwherever other definitions may appear: at top level, nested within a module or lambda body, or nested \nwithin derived forms that expand into module or lambda forms. Although the language does not provide \nprimitive con-structs for separating interfaces from implementations, im-porting only selected identifiers \nfrom a module, or renaming exported identifiers, Section 3 demonstrates how such con-structs may be obtained \nvia syntactic abstraction. The syntax of macro calls traditionally subsumes that of variable reference \nonly in the operator position of an appli- cation. We generalize the concrete syntax of macro calls to \n(macro call) --+ ((keyword) (form)*) 1 (keyword) 1 (set ! (keyword) (expression)) I (import (keyword)) \nConsequently, the syntax of macro calls subsumes that of variable reference, variable assignment, and \nmodule import, resulting in a significant increase in expressive power.  2.2 Scope Except where shadowed, \nidentifiers defined at top level are visible throughout the program, while identifiers defined within \na body are visible only within that body. A module definition introduces a named lexical scope. Module \nnames occupy the same namespace as other iden-tifiers and follow the same scoping rules. Unless exported, \nidentifiers defined within a module are visible only within that module. Identifiers exported from a \nmodule are visi- ble within the module and where the module is imported. A module is imported via an \nimport of the module s name. An identifier made visible by import is scoped as if its defini- tion appears \nwhere the import form appears. The following example illustrates these scoping rules. (let ((x 1)) (module \nM (x setter) (define-syntax x (identifier-syntax z> > (define setter (lambda (x> (set! z xl>> (define \nz 5)) (let ((y x> (z 0)) (import M) (setter 3) (list x y z>)) * (3 I 0) The inner let expression binds \ny to the value of the x bound by the outer let. The import of M makes the definitions of x and setter \nvisible within the inner let. In the expression (list x y z> , x refers to the identifier macro exported \nfrom M, while y and z refer to the bindings established by the inner let. The identifier macro x (defined \nusing the syntactic abstraction identifier-syntax) expands the reference to x into a reference to the \nvariable z defined within the module.  2.3 Semantics Before it is compiled, a source program is translated \ninto a core language program containing no syntactic abstrac-tions, syntactic definitions, module definitions, \nor import forms. Translation is performed by a syntax ezpunder that processes the forms in the source \nprogram via recursive de- scent. The semantics of the core language is defined in the Revised5 Report \non Scheme. A define-syntax form associates a keyword with a trans- former in a translation-time environment. \nWhen the ex- pander encounters a keyword, it invokes the associated trans- former and reprocesses the \nresulting form. A module form associates a module name with an interface. When the expander encounters \nan import form, it extracts the cor- responding module interface from the translation-time en- vironment \nand makes the exported bindings visible in the scope where the import form appears. Definitions within \na lambda or module body are processed from left to right so that a module s definition and import may \nappear within the same sequence of definitions. Ex- pressions appearing within a body and the right-hand \nsides of variable definitions, however, are translated only after the entire set of definitions has been \nprocessed, allowing full mutual recursion among variable and syntactic definitions. Module and import \nforms affect only the visibility of identifiers in the source program, not their denotations. In particular, \nvariables are bound to locations whether defined within or outside of a module, and import does not intro-duce \nnew locations. Local variables are renamed as necessary to preserve the scoping relationships established \nby both modules and syntactic abstractions. Thus, the module program in Sec- tion 2.2 is equivalent to \nthe following program in which iden- tifiers have been consistently renamed as indicated by sub- scripts. \n  (let (CXO 11) (define-syntax xi (identifier-syntax zi)) (define setter1 (lambda (XZ) (set! ZI XZ))) \n(define zi 5) (let ([y3 x01 Ez3 01) (setteri 3) (list xi y3 23) )> Both programs are equivalent to the \ncore-language program below in which syntactic abstractions have been expanded. ((lambda (x01 (define \nsetter1 (lambda (x3) (set! zr x3))) (define zi 5) ((lambda (~3 ~3) (setteri 3) (list zi y3 ~3)) x0 0)) \n1) The mechanisms by which expansion and renaming occur are described in Section 4. Although definitions \nwithin a lambda or module body are processed from left to right by the expander, the order of evaluation \nof variable definitions is not specified. Ini-tialization expressions appearing within a module body \nare evaluated in sequence after the evaluation of the variable definitions. 3 Examples The examples in \nthis section show that many useful module constructs can be derived from the primitive module and import \nforms via syntactic abstraction. 3.1 Qualified reference It is often convenient to refer to one export \nof a module without importing all of its exports. While our system does not provide an explicit construct \nfor this purpose, a qualified reference macro can easily be defined and used as follows. (define-syntax \nfrom (syntax-rules 0 ((-M id) (let (> (import M) id) 1)) (let ((x 10)) (module ml (x> (define x 1)) (module \nm2 (x) (define x 2)) (list (from ml x) (from m2 x>)) + (1 2) 3.2 Anonymous modules Often it is convenient \nto avoid naming a module that is im- ported only in the block where it is defined. The following macro \nsupports anonymous as well as named modules. An anonymous module definition expands into a sequence con-taining \nthe definition and immediate import of an equivalent module named tmp. Because the macro expander automati-cally \nrenames introduced identifiers, the name tmp is visible only to the import form introduced by the macro. \n(define-syntax module* (sETa;-rles 0 . ..) form . ..) (begin (module* tmp (id . . .) form . . .> (import \ntmp))] I(_ name (id . ..I form . ..) (module name (id . ..) form . ..>I>)  3.3 Selective import and \nrenaming While the import construct of the core language does not directly support renaming of imported \nbindings or selective import of specific bindings, the following macro does provide these capabilities. \n(define-syntax import* (syntax-rules 0 CC- M) (begin11 I(_ M (new old)) (module* (new) (define-alias \nnew tmp) (module* (tmp) (import M) (define-alias tmp old)))] I(_ M id) (module* (id) (import M))] [(_M \nspec0 speck . ..> (begin (import* M spec0) (import* M specl . ..>>I>) To selectively import an identifier \nfrom module M, the macro expands into an anonymous module that first imports all exports of M then re-exports \nonly the selected identifier. To rename on import, the macro expands into an anony-mous module that instead \nexports an alias bound to the new name. The alias is simply an identifier macro that ex-pands into a \nreference to the old name visible where the alias is defined. If the macro placed the definition of new \nin the same scope as the import of M, and new is also present in the interface of M, a naming conflict \nwould arise. To prevent this, the macro instead places the import within a nested anonymous module and \nlinks old and new by means of an alias for the introduced identifier tmp. The macro expands recursively \nto handle multiple import specifications. Thus the following construct imports x, y (renamed as z), and \nz (renamed as y) from module m. (import* m x (y z) (z y)) The define-alias macro is given below. Since \naliases are resolved at translation time, programs using define-alias and import* incur no run-time penalty. \n(define-syntax define-alias (syntax-rules 0 CC- x y) (define-syntax x (identifier-syntax y)) I)) 3.4 \nMultiple views on modules Because a module can re-export imported bindings, it is quite easy to provide \nmultiple views on a single module, as (module A (x y) (define x 1) (define y 2)) (module B (y z) (define \ny 3) (define z 4)) (module C (a b c d) (import* A (a x) (b y>) (import* B (c y) (d z>)> (module D (a \nc> (import C)) (module E (b d) (import C)) 3.5 Mutually recursive modules several modules (define-syntax \ndefine-interface (syntax-rules 0 [(-name (export . ..I) (define-syntax name (lambda (x1 (syntax-case \nx 0 [(-n defs) (with-implicit (n export . . . > # (module n (export . . . > . defs))l))>l)> (define-syntax \ndefine-module (syntax-rules 0 [(_ name interface defn . ..) (interface name (defn . ..)>I)> Mutually \nrecursive modules can be defined in several ways (see also Section 3.8). In the following program, A \nand B are mutually recursive modules exported by an anonymous module whose local scope is used to statically \nlink the two. For example, the free variable y within module A refers to the binding for y provided by \nthe import of B in the enclosing module. (module* (A B) (module A (x) (define x (lambda 0 y))) (module \nB (y) (define y (lambda 0 x>)) (import A) (import B)) The following syntactic abstraction generalizes \nthis pattern to permit the definition of multiple mutually recursive mod- ules. (define-syntax ret-modules \n(syntax-rules 0 ((-(module N (id . ..) form . ..I . ..) (module* (N . . .) (module N (id . . .) form \n. . .) . . . (import N) . ..)))) Recursive modules residing in different source files can be combined \nusing the include macro. For example, if a program consists of two modules, ml and m2, residing in files \nml .ss and m2.ss, they can be combined as follows: (module* (ml m2) (include ml .ss > (include m2.ss \n) (import ml> (import m2) > As shown below, the ret-modules macro can be adapted to support modules located \nin different source files. (define-syntax ret-modules (syntax-rules 0 I(-include (m file) . ..) (module* \n(m . . .) (include file) . . . (import m> . ..>I)> Using this version of ret-modules, the example given \nearlier can be written as follows. (ret-modules include (ml ml ssl > (m2 mZ:ss )) 3.6 Separating interface \nfrom implementation To allow interfaces to be separated from implementations, the following macros support \nthe definition and use of named interfaces. define-interface creates an interface macro that, given a \nmodule name and a list of definitions, expands into a module definition with a concrete interface. These \nmacros can be used as follows. (define-interface simple (a b)) (define-module M simple (define-syntax \na (identifier-syntax 1) 1 (define b (lambda 0 c)) (define c 2)) (let 0 (import M) (list a (b))) + (I \n2) 3.7 Compound interfaces It is sometimes convenient to combine several interfaces into a compound \ninterface as shown below. (define-interface one (a b)) (define-interface two (c d)) (define-interface \nboth (compound-interface one two)) The separate interface abstraction defined in Section 3.6 can be \nextended to support compound interfaces by introducing a limited reflection mechanism. When expanded, \nthe follow- ing define-interface macro defines a macro representing the interface as before. (define-syntax \ndefine-interface (syntax-rules (compound-interface) [(_ name (compound-interface i0 il . ..>> (d-i-help \nname (i0 il . ..> ()>I I(_ name (export . ..)> (define-syntax name (lambda (x> (s ;;t_ax-;a;;,x (expand-exports) \n(wi:h-Implicit (n export . ..) # (module n (export . ..> . defs))] I(-(expand-exports i-name mat)) (with-implicit \n(i-name export . ..I # (mat i-name export . ..>>]>>)I>> For example, the definition (define-interface \none (a b) > expands into the following macro definition. (define-syntax one (lambda (x1 (sr ;t_ax-y;se,x \n(expand-exports) (with-ymplicit (n a b) # (module n (a b) . defs)>l I(-(expand-exports i-name mat>) \n with-implicit, used here to ensure that the introduced export identifiers are visible in the same scope \nas the name of the module in the define-module form, is implemented in terms of datum->syntax-object \n[4, 61. The reader syntax # (form) expands into (syntax (form)). (with-implicit (i-name a b) (define-syntax \nabstract-module # (mat i-name a b))]))) (syntax-rules 0 The second clause of this macro provides a simple \nmecha-nism for reflecting on the interface. When invoked with the expand-exports auxiliary keyword, the \nname of the inter- face i-name, and the name of a macro mat, this interface macro now expands into the \nmacro call (mat i-name a b). By analogy with continuation-passing style (CPS), the macro mat supplied \nas an argument to the interface macro is a continuation that takes as input the set of exports in the \ninterface. To construct a compound interface, define-interface calls upon the d-i-help macro, defined \nbelow, to collect the exports of the constituent interfaces. (define-syntax d-i-help (syntax-rules 0 \nCc_ name 0 (export . ..)I (define-interface name (export . . . ) ) 1 [(-name (i0 il . ..) (e . ..>> (begin \n(define-syntax tmp (syntax-rules 0 Cc_ name expt (... . ..)I cd;:-help name (il . . .) . . . expt (... \n. ..)))I>) (i0 (expand-exports name tmp) ) )I 1) The d-i-help macro takes the interface name, a list \nof con- stituent interfaces, and a list of exports collected so far. When it has finished processing \nall constituent interfaces, d-i-help simply calls define-interface with the list of exports collected. \nIn the recursive case, d-i-help uses the reflective facility of the first constituent interface, i0. \nThe continuation macro, tmp, extends the list of exports collected so far and invokes d-i-help recursively \nto process the re-maining interfaces. It is not always convenient to define a compound inter-face explicitly. \nThe following version of define-module al-lows a compound interface to be specified directly. (define-syntax \ndefine-module (syntax-rules (compound-interface) [(-name (compound-interface i . ..) defn . ..> (begin \n(define-interface tmp (compound-interface i . ..)I (define-module name tmp defn . ..>)I [(-name interface \ndefn . . .) (interface name (defn . ..))I)) (define-module M (compound-interface one two) (define a 1) \n(define b 2) (define c 3) (define d 4)) (let (> (import M) (list a b c d)) + (1 2 3 4)  3.8 Satisfying \ninterfaces incrementally The abstract module facility defined below allows a module interface to be satisfied \nincrementally. This permits flex-ibility in the separation between the interface and imple-mentation, \nand it supports separate compilation of mutually recursive modules. 2The pattern (. . . . . .) produces \na single ellipsis in the output of the macro. Thus the input pattern specification of the tmp macro introduced \nin the expansion of d-i-help is (_ name expt . ..I. ((_ name (ex . . .> (mat . ..> defn . ..> (module \nname (ex . . . mat . . .> (declare ex) . . . defn . ..))I> (define-syntax implement (syntax-rules 0 ((-name \nform . ..) (module* 0 (import name) form . ..)>)> The following example illustrates the use of abstract \nmod-ules to define mutually recursive modules. We first define two abstract modules, E and 0. (abstract-module \nE (even?) 0) (abstract-module II (odd?) (pred) (define-syntax pred (syntax-rules 0 ((_ exp) (-exp 1))))) \nWe then define implementations of these modules, each of which imports from the other. (implement E (import \n0) (satisfy even? (lambda (x) (or (zero? x) (odd? (pred x)1>)>) (implement 0 (import E) (satisfy odd? \n(lambda (x1 (not (even? x))))) declare and satisfy may simply be define and set!, al-though a single-assignment \nsemantics may be more appro-priate for satisfy. The interfaces of these abstract modules can be sep-arately \ncompiled. Because the modules are mutually re-cursive, the compiled interfaces of both modules must be \nloaded in order to compile either implementation. Subject to this restriction, the implementations may \nbe separately compiled. The compiled interface of an abstract module must be loaded before attempting \nto use its compiled im-plementation.  4 Implementation The module system is implemented by extending \nthe syntax- case macro system [6]. Section 4.1 describes the existing macro system, and Section 4.2 shows \nhow the macro system is extended to support modules. 4.1 The syntax-case system As described in Section \n2.3, a source program is translated into the core language before it is compiled. To preserve lexical \nscoping during translation, the syntax-case macro system consistently renames bound variables (cr-conversion). \nThis substitution process is fully automated by the system and is transparent to the user. During translation, \nidentifier references are resolved via a two-level map consisting of a substitution environment and a \nstore. The substitution environment maps symbols to labels in the store. It is represented as a sequence \nof sub-environments called ribs, each of which corresponds to a single lexical contour. When searching \nthe substitution environment, the ribs corresponding to the innermost con-tours are consulted first in \naccordance with lexical scoping. As this example illustrates, the role of an input expression describe \nthe roles of the corresponding identifiers in the in- cannot be determined until macro expansion of surrounding \nput program. For example, if the environment and store forms is complete. map a symbol to a macro transformer, \nthe symbol represents a syntactic keyword. The store is used to detect attempts 4.2 Adding modules to \nreference run-time bindings within code that is evaluated at translation time. Macro transformers operate \non syntax objects. In ad- dition to the usual list-structured source expression, a syn- tax object contains \nthe substitution environment and marks, collectively referred to as the wrap, that apply to the entire \nexpression. Substitutions are introduced by core binding forms. For example, the lambda transformer creates \na substitution rib mapping each formal parameter to a fresh label, and extends the store to map each \nlabel to a fresh variable. This rib is added to the substitution environment of the syntax object representing \nthe lambda body before the body is processed recursively by the macro expander. Marks are introduced \nwhen the expander invokes a macro transformer. A fresh mark is applied to the input of the transformer \nand the same mark is applied to the output of the transformer. Because identical marks cancel when they \nmeet, marks adhere only to expressions introduced in the expansion of a macro. Substitutions are keyed \nwith marks to prevent substitutions for identifiers introduced in the ex- pansion of a macro from affecting \nidentifiers not introduced by the macro. An identifier is renamed only when the set of marks on that \nidentifier is identical to the set of marks associated with the symbol in the substitution environment. \nWithin programs, macro transformers are simply lambda expressions whose chief distinction is that they \nmay be eval- uated and applied at translation time. Syntax objects com-monly appear in the expanded code \nof these transform-ers. For example, a syntax object representing the iden- tifier lambda appears within \nthe expanded code for the let transformer. This syntax object contains the substitution environment and \nmarks in effect where let was defined. Therefore let expands into a reference to the binding for lambda \nvisible in the scope where let was defined. Using syntax objects as the input and output of macro transformers \nenables the system to perform o-conversion lazily. In addition, this representation allows the system \nto correlate program source and object code through arbi-trary user-defined transformations. Macro transformers \nde- structure their input using a pattern-matching facility that exposes list structure within a syntax \nobject and propagates the wrap to the exposed subforms. Syntax objects are de- structured only as far \nas is necessary for pattern matching. The lazy substitution model is important for two reasons. First, \napplying substitutions on demand is far more efficient than repeatedly traversing subexpressions to apply \nsubsti-tutions eagerly. In fact, lazy substitution maintains lexical scoping with constant overhead on \nmacro expansion. Sec-ond, by delaying substitution until it can determine the role of an input expression, \nthe system avoids traversing (poten- tially cyclic) structured constants, and it avoids renaming identifiers \nused as symbolic data. For example, in the body of the following lambda expression, the two occurrences \nof x have different roles: the first refers to the formal parameter, and must be renamed, while the second \nis used as symbolic data, and must retain its original name. (lambda (x1 (define-syntax f (syntax-rules \n0 ((-e) (quote e)>)) (cons x (f x>)) The module system uses the a-conversion machinery de-scribed in \nSection 4.1 to control the visibility of identifiers. To support modules, the rib structures contained \nin substi- tution environments are modified so that they may be ex-tended incrementally, and an interface \nstructure (described below) is added to the set of translation-time bindings to which the store maps. \nWhen processing a lambda expression or module form, the expander creates an extensible rib in the substitution \nenvironment. This rib is part of the wrap pushed down on the form (and propagated to subforms) by the \npattern matcher. Definitions within the lambda body or module form extend this rib with substitutions \nrenaming the iden- tifiers they bind. Internal definitions extend the store with translation-time bindings \nsuch as local macro transformers and module interfaces. To determine the set of internal definitions, \nthe system partially expands each subform in the body of the lambda or module form until it finds the \nfirst non-definition. When it encounters a macro call, the system expands the macro and processes any \ndefinitions in the resulting output. For define, define-syntax, and module forms, the system ex-tends \nthe substitution rib of the local scope with a fresh label for the defined variable, keyword, or module \nname. For a define form, the system defers expansion of the ex-pression on the right-hand side and extends \nthe store with a mapping from the fresh label to a translation-time structure representing the lexical \nvariable. For define-syntax forms, the transformer expression is expanded and evaluated to ob- tain a \nprocedure that is installed in the store as the binding for the fresh label. For module forms, the store \nis extended with a mapping from the fresh label to an interface structure listing the exports of the \nmodule. The sequencing construct, begin, is treated as a splicing form: its subforms are simply added \nin its place to the list of subforms to be processed. The system processes module forms recursively to \ncollect the set of internal definitions. Definitions inside and outside the module are identical except \nthat the substitution rib ex- tended by definitions inside the module is present only in the wrap pushed \ndown on syntax objects representing ex-pressions within the module. Because internal definitions extend \na local substitution rib introduced by the module, substitutions for the defined identifiers are not \nvisible out-side the module. Bindings in the enclosing scope are visible within the module because the \nsubstitution environments inside and outside the module share a common tail. Definitions within the module \nextend the store of the en- closing lambda or top-level module form. These bindings are accessible only \nwhere the substitutions introduced by defi- nitions within the module are in effect. The import form \nmakes available the substitutions introduced for identifiers exported from the module. An exported macro \ncan intro-duce valid references to other bindings in the module where it is defined even when those bindings \nare not visible or are shadowed where the macro is used. This is possible because syntax objects inserted \nby the macro close over the substi- tution environment in effect where they are constructed. In particular, \nthe module rib extended by internal definitions is present in the wrap of each syntax object constructed \nwhile processing the module. When the expander encounters an import form, it looks up the module name \nin the substitution environment and then looks up the resulting label in the store to obtain the module \ninterface. The module s interface structure contains syntax objects naming the exports. These syntax \nobjects contain the module s substitution rib within their wraps. To import a module, the system extends \nthe substitution rib of the enclosing lexical scope with the substitutions extracted from the exported \nidentifiers. After processing the internal definitions of a lambda or module form, the system expands \nthe expressions on the right-hand sides of variable definitions and expands any non- definition forms \nfollowing the definitions. For lambda it then wraps the body in a letrec form binding variables defined \nlocally. For top-level module forms it produces a series of top-level definitions for the renamed identifiers. \nTo aid static analysis we improve on this expansion for top-level module forms in Section 5.2.  5 Practical \nConsiderations This section discusses extensions to the language and trans- lation mechanism to support \nseparate compilation, static program analysis, and isolated scopes. 5.1 Separate compilation The implementation \ndescribed in Section 4 supports both in- ternal and top-level modules. For internal modules, the new \nnames generated by the expander must be locally unique, i.e., not otherwise visible within the same top-level \nexpres-sion. For top-level modules within a single compilation unit, the names must be unique within \nthe compilation unit. When multiple compilation units may be linked together, the names must be unique \nacross compilation units. Our system supports both incremental compilation and linking of compilation \nunits compiled by different runs of the compiler. Since the compiler may be invoked simulta- neously \non the same or different physical hardware, global name generation factors in the host s network interface \niden- tifier, process identifier (PID), and compiler invocation time. Some operating systems provide \nsystem calls that generate unique names in much the same fashion. If a module m2 imports from a module \nml, the compiler must have the interface for ml in order to compile m2. When a source file containing \nml is compiled, the resulting object file contains the compiled code for ml, its interface, and com- \npiled code for any macro transformers defined by ml. Before compiling m2, it is necessary to first load \nor visit ml s ob- ject file to install its interface and transformers. While both load and visit install \nthe interface and transformers, load also loads the compiled code and evaluates the initialization expressions. \n 5.2 Static program analysis One benefit of modular program structure is that it may im- prove the results \nof static analysis. In the presence of sep- arate compilation, global variables are subject to arbitrary \nmanipulation by compilation units that may be unavailable for scrutiny by the compiler. Variables not \nexported from a module, however, are effectively local and may therefore present opportunities for analysis \nand optimization. The ability to export macros complicates the situation, since exported macros may expand \ninto references or assign- ments to nonexported variables. It is tempting to believe that a straightforward \nanalysis of the transformer expres-sion can determine the set of these implicit exports. Even with the \nconstrained syntax-rules transformers, however, such an analysis is necessarily conservative. For example, \nconsider the following definition for module M. (module M (a b) (define-syntax a (syntax-rules 0 [(-e0 \nel . ..I (e0 (quote c) el . ..)I)) (define b (lambda (> c)) (define c 3)) It appears that c is not referenced \noutside the definition of b. The only other occurrence of c is within the macro a, where it is apparently \nused as symbolic data. As the following program demonstrates, however, code outside the module may not \nonly reference but also assign c. (let 0 (define-syntax f (syntax-rules 0 [(_ (any id)) id1 [(-(any id) \nvalue) (set! id value>])> (import M) (lyt : C;;iginal (a f >I ) a (list original (b)))) + (3 4) Here \n(a f> expands to (f (quote c> ), which further ex-pands to the reference c. Similarly, (a f 4) expands \nto (f (quote c) 41, which further expands to the assignment (set ! c 4). Because the compiler does not \nknow how the macro a will be used in separately compiled code, it must conservatively assume that the \nvariable c is assigned and that its value escapes. Even conservative analysis is impossible if transformers \nare able to synthesize new identifiers from existing identi-fiers, e.g., using datum->syntax-object [4, \n61. For example, consider the following module definition. (module f oo (access) (define a 123) (define-syntax \nb (identifier-syntax 456)) (define-syntax access (lambda (x1 (syntax-case x 0 I(-exp) (datum->syntax-object \n# b (syntax-object->daturn # exp) >I 1) )) The access macro returns its argument expression intact but \nfor one key difference: the wrap on the input is re-placed with the wrap from the identifier b bound \ninside the module.3 Consequently, expanding (access exp) has the effect of expanding exp within the module \nscope. For exam- ple, (access b) constructs a reference to the private syntax binding b and (access (set! \na 3)) constructs an assign-ment to the private variable binding a. In fact, the access macro need not \nbe defined within the module that is violated. A module boundary can be breached if any syntax object \nconstructed within the module may arrive at a call to the procedure datum->syntax-object. For instance, \nthe expose macro below is virtually identical to the access macro defined earlier except that it transplants \nthe wrap from an identifier in its input onto exp. 3The choice of b here is arbitrary. Each syntax object \nin the module carries in its wrap sufficient information to access any module binding. (begin (&#38;e-install! \nms interface #(interface #<import-token> (#<syntax-object ac> #<syntax-object cs>))) (cte-install! as \ntransformer (identifier-syntax br)) (cte-install! bl transformer (identifier-syntax ~2)) (letrec ([es \n(lambda (~4) (* x4 2))]) (set! cz (lambda (xg) (ea xg))) (set! c6 (lambda (~7) (es (+ x7 i))))))  Figure \n1: Sample expansion of a module that exports a macro with implicit exports. (define-syntax expose (lambda \n(x) (syntax-case x 0 CC- (any n . ..) exp) (datum->syntax-object # any (syntax-object->datum # exp)))))) \nNow consider the module defined below and observe that the macro a contains no occurrences of the identifier \nb. In fact, b is not even referenced within the module. (module foo (a) (import scheme) (define-syntax \na (syntax-rules 0 CC- e0 ei . ..I (e0 (quote 3) el . ..)I)) (define b 1)) The expose macro provides \narbitrary access to bindings within the foo module, including b, as illustrated below. (let 0 (import \nf 00) (a expose (let ((old b)) (set! b 5) (list old b)))) 3 (1 5) One partial solution is to disallow \nassignments outside the module to unexported variables. This limits the ex-pressive power of exported \nmacros and does not address the problem of escaping values. Another partial solution is to introduce \na define-constant form that establishes im-mutable bindings. This does not inherently limit the ex-pressive \npower of exported macros but leaves the problem of escaping values. We have chosen instead to require \nthat implicit exports be explicitly declared in the interface for top-level modules* using the following \nsyntax. (interface) + ((export)*) (export) --+ (identifier) ( ((identifier) (export) *) Declarations \nof implicit exports are propagated to enclosing interfaces where an identifier is exported. For example, \nthe module m defined below exports only a and c, but the export of a causes the implicit export of b \nand c from module n. (module m ((a b) c) (define-syntax a (identifier-syntax b) ) (module n ((b c> \n(d e)) (define-syntax b (identifier-syntax c)) (define c (lambda (x1 Cd x1>> (define-syntax d (identifier-syntax \ne)) (define e (lambda (x) (* x 2)))) (import n) (define c (lambda (x) (d (+ x 1))))) *The declarations \nare permitted but not required for internal modules. Because e is not exported, explicitly or implicitly, \nit is bound locally in the output of the expander. Thus the preceding program is equivalent to the code \nin Figure 1. Because e is not assigned, it can be integrated by a later pass of the compiler. 5.3 Isolated \nscopes Expressions within a module can reference identifiers bound outside of the module. For example, \nthe following expression evaluates to 8. (let ((x 3)) (module m (plusx) (define plusx (import m> (let \n((x 4)) (plusx (lambda 5))) (y) (+ x y) 1)) The system also supports a variant of import, called import-only, \nthat creates an isolated scope, in which the only visible identifiers are those exported by the imported \nmodule. This is useful for static verification that a module does not access identifiers that are not \nexplicitly provided by the import. For example, the following expression generates a translation-time \nerror. (let ((x 3)) (module m 0 1 (import-only m) x) By using import-only to implement the qualified \nreference macro of Section 3, we ensure that it introduces a reference to the intended export and not \nto some local binding. (define-syntax from (syntax%-ules 0 Cc_. M id) (let 0 (import-only M) id)))) When \na module is imported via import-only, subse-quent imports are not possible unless this module exports \nthe name of at least one module and import or import-only. To create an isolated scope containing the \nexports of more than one module without making import or import-only visible, it is necessary to create \na single module that con-tains the exports of each of the other modules. (module m2 (y) (define y y)) \n(module ml (x) (define x x)) (module compound-module (x y cons) (import ml> (import m2) (import scheme)) \n(let ((x 3)) (import-only compound-module) (consxy)) * (x .y> Like the module and import forms, the \nimport-only form is a primitive language construct treated specially by the macro expander. The macro \nexpander makes the ex-ports of a module imported via import-only visible in the same manner as for import. \nIn addition, the expander adds to the local substitution rib a fail token, keyed with the set of marks \nthat apply to the import-only identifier. To determine the role of a source-program identifier, the ex-pander \nconsults the substitution environment and the store as before. An error is signalled if the expander \nencounters a matching fail token while searching the substitution envi-ronment for the symbol and marks \nrepresenting that iden- tifier. To match, the set of marks associated with the fail token must match \nthe set of marks on the identifier.  6 Related Work Our system is similar in some respects to systems \ndescribed by Curtis and Rauen [2] and Rees [16]. Our system is based on simpler core module constructs, \nhowever, and derives its expressive power largely via syntactic abstraction. While the other systems \nbuild in support for separation of inter- face from implementation, for example, our system allows multiple \ninterface separation mechanisms to be created via syntactic abstraction. Curtis and Rauen forbid the \ndefini- tion and import of modules in local scopes, a feature we have found quite useful. It is not clear \nwhether Rees intends to permit local module definitions. Although the implementa- tion (in Scheme 48) \ndoes not forbid the such definitions, it provides no apparent way to use them. In both systems, the use \nof syntactic abstractions expressed in terms of modules is limited. Neither system implements separate \ncompilation. Rees points out that prohibiting assignment to imported bindings permits the compiler to \nassume that any variable not assigned within a module is never assigned. The cur-rent Scheme 48 implementation, \nhowever, does not enforce this restriction. In particular, a Scheme 48 transliteration of the first example \nin Section 5.2 shows that code outside a module can assign an apparently unassigned variable, even if \nthat variable is not exported. To avoid this, the implemen- tation would have to prevent exported macros \nfrom expand- ing into assignments to either exported or nonexported vari-ables, limiting expressiveness. \nCurtis and Rauen describe a similar restriction but give few details and no implementa- tion. Curtis \nand Rauen propose a meta-module facility that permits the modularization of the code used in transformer \nexpressions. In particular, they allow macro transformers to share code. Meta-modules are similar to \nordinary modules except that they export only variable bindings and they are evaluated at translation \ntime. This is a useful feature that our system currently lacks, although nothing in our system precludes \nsupport for such a feature. Queinnec and Padget describe a module language for controlling the visibility \nof sets of named locations [13, 141. They describe a high-level macro expansion protocol in-tended to \nsupport various macro system implementations such as expansion-passing style [5] or hygienic systems \nbased on syntactic closures [l] Because their system is not tightly integrated with the macro expander \nthey do not permit nested modules, nor do they permit macros to expand into module constructs. The Dylan \nprogramming language [17] supports both modules and lexically scoped macros. Their macro system is more \nrestrictive in its treatment of symbols and identi- fiers. Macro and module definitions can appear only \nat the top level of a compilation unit (library), and import is tied to the module syntax, limiting expressiveness. \nTo deter-mine the set of identifiers implicitly exported by macros, the body of each macro transformer \nis analyzed. Because it is generally impossible to compute the precise set of im- plicitly exported bindings, \nan upper bound is computed by assuming exported any binding with the same name as an identifier appearing \nin the right-hand side of a rewrite rule. We considered implementing a similar analysis in our system \nbut ultimately dismissed this approach for two rea- sons. First, by foiling the conservative analysis, \nseemingly innocent edits can have unanticipated performance conse-quences. For example, inserting a quoted \nsymbol in the wrong place can cause the like-named identifier to be implic- itly exported. Second, our \nmechanism for intentional cap-ture, datum->syntax-object, is sufficiently powerful that all identifiers \nare potential implicit exports, as demonstrated in Section 5.2. While Dylan provides a limited form of \ninten- tional capture via the macro template modifier ?=, this is insufficient to express macros such \nas include [4]. Flatt and Felleisen propose a system for dynamically linking separately compiled program \nunits [7, 81. While it does not permit the export of macros, the unit facility is interesting as representative \nof systems providing both higher-order modules and programmatic control over link-ing. They argue against \nmodule linkage via static import and instead propose a mechanism that provides program-matic control \nover module linkage. We believe that the in- terfaces should be specified statically whenever possible \nas an aid to static program analysis (both by the programmer and by the compiler). However, the static \nnature of our sys- tem does not preclude support for dynamic module linkage. As demonstrated in Figure \n2, the unit module system can be implemented entirely at the source level in our language.  7 Conclusion \nWe have presented a language design that augments a small core language with simple module and import \nforms and a powerful syntactic abstraction facility that permits the con- struction of new language features, \nincluding richer module constructs. The module language is based entirely on ma-nipulation of static \nscope. A program containing modules can therefore be understood in terms of a straightforward translation \ninto the core language without module forms. We have demonstrated how syntactic abstractions can be defined \nto support anonymous modules, qualified module ac-cess, mutual recursion, multiple views on a single \nmodule, arbitrary combination of modules, separate interfaces, com-pound interfaces, and incrementally \nsatisfiable interfaces. Module definitions and imports may appear in any con- text where variable or \nkeyword definitions may appear, al-lowing modules to be nested or to be used locally. Modules are therefore \nuseful not only for large-scale software develop- ment but also at a micro-modular level within expressions. \nWe have fully implemented the features described in this paper and incorporated the implementation into \nthe front end of the Chez Scheme compiler. The system supports both incremental and separate compilation. \nA portable im-plementation of the module system is freely available via ftp5.  Acknowledgements Comments \nfrom Mike Ashley, Bob Burger, Dan Friedman, Brian Moore, and anonymous reviewers improved the pre- sentation \nof the paper. (module Unit ((unit make-unit) (compound-unit make-unit) invoke-unit) (define-syntax \nmake-unit (syntax-rules 0 [iva:A;; ~;I.;~ icoLs(iv . ..) form . ..I  'ev eloc) . ..I (lambda (iv . \n..) form . . . (void)))])) (define-syntax unit (lambda (x) (syntax-case x (import export)  ((- (import \niv . ..) (export ev . ..) form . ..> (with-syntax (((eloc . ..> (generate-temporaries (syntax (ev . \n..))>>> #'(lambda 0 (let ((eloc (box 'undefined)) . ..) (make-unit ((ev eloc) . ..) (iv . ..)  (module* \n0 (set-box! eloc ev) . ..> (let-syntax ((iv (identifier-syntax (_ (unbox iv)) ((set! _ val) (set-box! \niv val)))) . . . form . ..NA (define-syntax compound-unit (lambda (x) (syntax-case x (import link \nexport)  CC_ (import iv . ..I (link (Itag (expr linkage . ..>I . ..> (export (etag ev) . ..>) (with-syntax \n(((1.110~s . ..I (generate-temporaries (syntax (ltag . ..I>)> ((uimp . ..I (generate-temporaries (syntax \n(ltag . ..)I))) #'(lambda 0 (mvlet* ([(ulocs uimp) (expr)] . ..) (define-syntax ltag (syntax-rules \n0  ((- id) (cdr (assq 'id ~10~s))))) . . . (make-unit ((ev (etag ev)) . ..I (iv . ..> (uimp linkage \n. ..> . ..)>)>))>) (define-syntax invoke-unit (syntax-rules 0  [(_ expr) (mvlet* ([(ulocs uimp) (expr>I) \n(uimp))]))) Figure 2: An implementation of the UNITY module facility of Flatt and Felleisen. A unit \nis a procedure that returns an interface and an implementation procedure that is parameterized over its \nimports. A unit interface associates variable names with first-class reference cells. Within a unit implementation, \nreferences and assignments to imported variables are rewritten (via identifier-syntax) as explicit operations \non the reference cells passed in as arguments. A group of units is linked by obtaining the interfaces \nand implementations of each and invoking each implementation procedure with an appropriate set of reference \ncells from the various interfaces as determined from the linkage specification. A fully linked unit is \ninvoked by invoking its implementation procedure. References [l] William Clinger and Jonathan Rees. \nMacros that work. In Conference Record of the Seventeenth Annaual ACM Symposium on Principles of Programming \nLanguages, pages 155-162, January 1991. [2] Pave1 Curtis and James Rauen. A module system for Scheme. \nIn Proceedings of the 1990 ACM Conference on LISP and Functional Programming, pages 13-19, June 1990. \n[3] Harley Davis, Pierre Parquier, and Nitsan Seniak. Talk- ing about modules and delivery. In Proceedings \nof the 1994 ACM Conference on LISP and Functional Pro-gramming, pages 113-120, 1994. [4] R. Kent Dybvig. \nThe Scheme Programming Language. Prentice-Hall, second edition, 1996. [5] R. Kent Dybvig, Daniel P. Friedman, \nand Christo-pher T. Haynes. Expansion-passing style: A general macro mechanism. Lisp and Symbolic Computation, \n1(1):53-75, 1988. [6] R. Kent Dybvig, Robert Hieb, and Carl Bruggeman. Syntactic abstraction in Scheme. \nLisp and Symbolic Computation, 5(4):295-326, 1993. [7] Robert Bruce Findler and Matthew Flatt. Modular \nobject-oriented programming with units and mixins. In Proceedings of the 1998 ACM SIGPLAN International \nConference on Functional Programming, pages 94-104, September 1998. [8] Matthew Flatt and Matthias Felleisen. \nUnits: Cool modules for HOT languages. In Proceedings of the A CM SIGPLAN 98 Conference on Programming \nLanguage Design and Implementation, pages 236-248, June 1998. [9] Richard Kelsey, William Clinger, and \nJonathan A. Rees (Editors). Revised5 report on the algorithmic language Scheme. SIGPLAN Notices, 33(9):26-76, \n1998. [lo] Eugene Kohlbecker, Daniel P. Friedman, Matthias Felleisen, and Bruce Duba. Hygienic macro \nexpansion. In Proceedings of the 1986 ACM Conference on LISP and Functional Programming, pages 151-161, \n1986. [ll] Eugene E. Kohlbecker. Syntactic Extensions in the Pro- gramming Language Lisp. PhD thesis, \nIndiana Univer-sity, Bloomington, Indiana, 1986. [12] David MacQueen. Modules for standard ML. In Con- \nference Record of the 1984 ACM Symposium on LISP and Functional Programming, pages 198-207, 1984. [13] \nChristian Queinnec and Julian Padget. A deterministic model for modules and macros. Bath Computing Group \nTechnical Report 90-36, University of Bath, Bath (UK), 1990. [14] Christian Queinnec and Julian Padget. \nModules, macros and Lisp. In Eleventh International Confer-ence of the Chilean Computer Science Society, \npages 111-123, Santiago (Chile), October 1991. Plenum Pub- lishing Corporation, New York NY (USA). [15] \nJonathan Rees. Modular macros. Master s thesis, Mas- sachusetts Institute of Technology, May 1989. [16] \nJonathan Rees. Another Module System for Scheme. Massachusetts Institute of Technology, 1994. Scheme \n48 documentation. [17] Andrew Shalit. The Dylan Reference Manual. Addison Wesley Longman, 1996. [18] \nSho-Huan Simon Tung and R. Kent Dybvig. Reliable interactive programming with modules. Lisp and Sym- \nbolic Computation, 9(4):343-358, 1996. \n\t\t\t", "proc_id": "292540", "abstract": "", "authors": [{"name": "Oscar Waddell", "author_profile_id": "81100242452", "affiliation": "University of Kansas", "person_id": "P212431", "email_address": "", "orcid_id": ""}, {"name": "R. Kent Dybvig", "author_profile_id": "81100181541", "affiliation": "Indiana University", "person_id": "PP14073331", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/292540.292559", "year": "1999", "article_id": "292559", "conference": "POPL", "title": "Extending the scope of syntactic abstraction", "url": "http://dl.acm.org/citation.cfm?id=292559"}