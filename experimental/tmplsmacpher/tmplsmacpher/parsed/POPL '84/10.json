{"article_publication_date": "01-15-1984", "fulltext": "\n Constraining-Unification and the Programming Language Unicorn Robert G. Bandes Computer Science Department, \nFR-35 University of Washington Seattle, Washington 98195 Abstract Up to this point direct implementations \nof axiomatic or equational specifications have been limited because the implementation mechanisms used \nare incapable of capturing the full semantics of the specifications. The programming language Unicorn \nwas designed and implemented with the intention of exploring the full potential of programming with equations~ \nUnicorn introduces a new language mechanism, called constraining-unification. When coupled with semantic \nunification, constraining-unification closely models the semantics of equational specifications thereby \nallowing for the implementation of a wider class of specifications. Unlike the language mechanisms of \nrewrite-rule and logic programming, constraining-unification is free of order dependencies. The same \nresults are produced regardless of the order in which the axioms are stated. The use of viewpoints contributes \nto the flexibility of the Unicorn language. Preconditions for partial operations can be specified without \nadded machinery. 1. Introduction Unicorn represents a new approach to the implementation of equational \nspecifications. It employs a new language mechanism, called constraining-unification. In constraining- \nunification an axiom is thought of as stating constraints on the results of applications of the operations \nmentioned in the axiom. With the aid of semantic unification, this mechanism is capable of capturing \nmuch of the semantics of equational specifications. At the same time, constraining-unification solves \nthe problem of order dependency that occurs in logic This research was supported in part by a gift from \nAtari, Incorporated, and in part by National Science Foundation Grant No. MCS-8202520. Permission to \ncopy without fee all or part of this material is granted provided that the copies are not made or distributed \nfor direct commercial advantage, the ACM copyright notice and the title of the publication and its date \nappear, and notice is given that copying is by permission of the Association for Computing Machinery. \nTo copy otherwise, or to republish, requires a fee and/or specific permission. &#38;#169; 1983 ACM 0-89791-125-3/84/001/0106 \n$00.75 and rewrite-rule programming, languages which have both been used to implement equational specifications. \nUnicorn also incorporates a new concept called viewpoints. A viewpoint is used to give an interpretation \nof the axioms that insures termination of the implementation. The examples in section 5 demonstrate the \nflexibility provided by viewpoints. The first example shows how the same specification can be used to \ndefine preconditions for partial operations that must be checked by the user and preconditions that are \nautomatically checked by Unicorn. An interpreter for Unicorn has been written in Prolog [11] that implements \nall the features mentioned here. 1.1. Relations to Previous Work OBJ [4] and AFFIRM [9] explore a particular \napproach into the implementation of algebraic specifications, that of treating the axioms as rewrite-rules. \nIn this technique, axioms are used in a left-to-right manner to perform pattern matching reductions. \nAn input expression is successively transformed by finding an axiom whose left-hand-side unifies with \nsome subexpression of the input expression and then replacing the matched subexpression with the corresponding \nright-hand-side of the axiom. Prolog has also been used for the implementation of algebraic specifications \n[1]. The approach is essentially the same; the axioms are translated into Prolog clauses which mimic \nthe rewrite.rule approach. Hoffman and O'Donnell use the rewrlte-rule approach for the implementation \nof equational programming [7]. They show that the resulting language is useful for, among other things, \nthe concise description of programming language interpreters and data abstractions. However, it is not \npossible to implement all algebraic specifications (or equational programs) by treating the axioms (or \nequations) as rewrite-rules. Thus this implementation technique is only suitable for a subset of the \npossible equational programs. For example, the axiom square(square-root(X))--X says as much about the \ndefinition of the operation square.root as it says about the definition of the operation square. However, \nthe rewrite-rule implementation technique would only treat this as part of the definition of the operation \nsquare. 106 Constraint programming languages, such as those developed by Borning [2] and Steele [12]. \nalso deal with axioms. In constraint languages, axioms are treated as producing constraints on the values \nof the variables mentioned in those axioms. Thus, in a constraint language, the axiom Fahrenheit -~ plus(32,times(9,divide(Centigrade,5))) \n is treated as a constraint on the values of the variables Fahrenheit and Centigrade. It says as much \nabout the value of Centigrade as it does about the value of Fahrenheit. Variables in constraint languages, \nhowever, have a different status from variables in equational languages. In constraint languages the \nscope of a variable may extend beyond the given constraint, while in equational languages the scope of \na variable is the axiom in which it is used. The principal difference between constraining-unification \nand the mechanisms used in constraint languages is that in constraining-unification, an axiom is treated \nas producing constraints on the operations rather than the vnrinbles mentioned in the axioms. Thus the \nequivalent statement for temperature conversion in Unicorn would be centigrade(X) = fahrenheit (plus(32,times(9,divide(X,5)))). \n This axiom states the desired relationship between quantities of the form centigrade(X) and fahrenheit(Y). \nNote that we could treat this axiom as a rewrite-rule to convert from centigrade to fahrenheit. But the \nrewrite-rule approach would be useless if we wanted to use this axiom to convert from fahrenheit to centigrade. \nSemantic unification allows constraints to be produced in situations that would normally not be considered \nin standard unification. In Unicorn we could use the above axiom to transform the expression fahrenheit(32) \nsince it is possible to find a value for the variable X such that plus(32,times(9,divide(X,5))) transforms \nto 32. This is similar to the way that equality theorems are used in Prolog-with- Equality [8] (the differences \nwill be discussed in section 3). In Prolog-with-Equality, if two terms do not unify syntactically then \nan attempt is made to use equality assertions to prove that the two terms are equal. If this attempt \nsucceeds, then the original unification succeeds with the variable bindings introduced by the equality \nproof. In standard Prolog, one would make explicit use of a predicate to perform the conversion between \ncentigrade and fahrenheit. The following is an example of such a Prolog predicate: convert(C,F) :- var(F) \n-> (nonvar(C), F is 32+(9\"(C/5))); C is ((F-32)/9)'5.  In Unicorn, preconditions can be specified for \nthe definition of partial operations. This technique, which has been advocated by Guttag [6], is an alternative \nto the use of complicated error algebras [3] for totalizing partial operations. Guttag introduces a special \nconstruct for the specification of preconditions. This is not necessary in Unicorn. As is demonstrated \nin section 5, preconditions for partial operations can be succinctly stated in the existing language. \n2. Constraining-Unification In constraining-unification, axioms are used to constrain the possible transformation \nof input expressions to result expressions. Given a particular input expression and set of axioms, constraining-unification \nproduces a set of constraints, called transformation constraints, that any allowable transformation of \nthe input expression must satisfy. There may be more than one expression that satisfies the transformation \nconstraints. In this way nondeterministic operations are permitted. On the other hand, if the transformation \nconstraints are inconsistent, then no expression can satisfy all of the constraints, hence there will \nbe no allowable transformation of the input expression. We now describe how an input expression and a \nset of axioms combine to produce a set of transformation constraints, and how these transformation constraints \ncan be used to find allowable transformations of the input expression. A transformation constraint is \nproduced by unifying the input expression with a subexpression of some axiom and then replacing the matched \nsubexpression with a special variable. There is no restriction as to where in the axiom the unification \ncan be made. For example, the input expression square-root(4) unifies with the subexpression square-root(X) \nin the axiom X=square(square-root(X)) thereby producing the transformation constraint 4=square(V) where \nV is a special variable not occurring elsewhere in the transformation constraint. Each possible unification \nwith each axiom produces exactly one transformation constraint, and the same special variable is used \nin each constraint. If a value can be found for the special variable such that all of the transformation \nconstraints are simultaneously satisfied, then that value is an allowable transformation of the original \ninput expression. Referring to the above example, any value of V for which square(V) transforms to 4 \nsatisfies the transformation constraint and is therefore an allowable transformation of the original \ninput expression uluare-root(4). A transformation constraint is satisfied by recursively transforming \nboth sides of the transformation constraint and then checking that the results are identical. The problem \nwith this definition is that in general there is no end to the recursive transformation of the sides \nof the transformation constraints. This problem is solved in section 4 by introducing the concept of \na viewpoint. If the expression to be transformed contains variables, there may be more than one possible \nset of transformation constraints depending on the bindings of the variables. For example, suppose we \nwish to transform the expression plns(A,succ(zero)) given the peano axioms: 1) plus(zero,X) = X 2) plus(succ(X),Y) \n= succ(plus(X,Y)) 107 Two sets of transformation constraints are produced. The first set consists of \nthe singleton Vl=succ(zero), produced by unifying with the left-hand.sicle of axiom 1, where zero has \nbeen substituted for the variable A. The second set consists of the singleton V2=succ(plus(X,succ(zero))), \nproduced by unifying with the left-hand-side of axiom 2, where succ(X) has been substituted for the variable \nA. When more than one set of transformation constraints exists, the sets are checked in parallel. Within \na particular set, the transformation constraints must be simultaneously satisfied. Thus the ordering \nof axioms 1 and 2 is irrelevant. This checking of transformation constraints for different values of \nthe variables in the expressions to be transformed replaces the order dependent evaluation schemes of \nlogic and rewrite- rule programming. In logic and rewrite-rule programming, results may vary depending \non the order in which clauses or rewrite-rules are stated. For example, in standard Prolog the equivalent \ndefinition of addition would be: plus(zero,X,X). plus(succ(X),Y,succ(Z)) :- plus(X,Y,Z). Evaluation \nof the predicate plus(A,succ(zero),Z) succeeds with the bindings A=zero and Z--succ(zero) by unifying \nwith the first clause. If the order of the clauses had been reversed, however, no results whatsoever \nwould have been produced. Besides the fact that constraining-unification involves no order dependency, \ntransformation in constraining-unification generalizes on the notions of evaluation used in logic and \nrewrite-rule programming. The expression to be transformed may contain variables (as in logic programming) \nand in performing a transformation it may be decided to first transform subexpressions (as in rewrite-rule \nprogramming). In rewrite-rule programming, different results may be obtained depending on the order in \nwhich subexpressions are evaluated. This problem is avoided by assuming a fixed evaluation strategy, \nsuch as an innermost or outermost strategy [10]. In Unicorn we use an outermost transformation strategy \nin which the outermost possible subexpression is always transformed first. 3. Semantic Unification Semantic \nunification in Unicorn differs from equality in Prolog-with-Equality [8] (see section 1.1) in two ways. \nFirstly, in Unicorn, two expressions are considered semantically unifiable if their principal functors \n(their outermost operators) are identical and if corresponding arguments transform to identical primitive \nexpressions. In Prolog-with-Equality, two expression are considered equal if one of the expressions unifies \nwith the left-hand-side of an equality assertion having identical principal functor and it is possible \nto show that the corresponding right-hand-side of the equality assertion is equal to the other expression. \nThus a one-way chain of equality assertions is used to relate the two expressions. The other difference \nis that in Unicorn, semantic unification may be used to produce transformation constraints only when \ntransformation is otherwise impossible. Since transformation in general is undecidable, semantic unification \nis undecidable as well. When semantic unification is used there may be more than one semantic unification \nattempted before transformation can proceed since all transformation constraints must be simultaneously \nsatisfied. Some of these semantic unifications may terminate while others may not. If any of these semantic \nunifications are non-terminating, this would cause non-termination of the entire transformation. However, \ntransformation without the use of semantic unification may be possible, hence avoiding the non-terminating \nsemantic unifications. In practice, the cases where this has been beneficial have outweighed the cases \nwhere a violation of intended semantics occurs.  4. Viewpoints It is useful to think of a viewpoint \nas a mapping from equational specifications to Unicorn programs. Two different viewpoints map a specification \nonto different, but usually related, Unicorn programs. A viewpoint gives more specific information for \neach axiom about which operations are being defined. Visualize the viewpoint as overlaying an equational \nspecification with marks that highlight the operations being defined. A new viewpoint is established \nby overlaying the specification with a new set of marks. This is essentially how viewpoints are implemented \nin Unicorn. A particular occurrence of an operation that is marked within the current viewpoint is called \na marked operation. Any subexpression of any axiom whose principal functor is a marked operation is called \na marked subexpression. Those operations that appear in the equational specification but are nowhere \nmarked within the viewpoint are called primitive operations. A primitive expression is any expression \nconsisting of only primitive operations and variables. When producing transformation constraints, the \nexpression to be transformed may only be unified with marked subexpressions. Therefore primitive expressions \ncan never be transformed. Transformation proceeds until the constraints are expressed in terms of primitive \nexpressions only. Thus, under a particular viewpoint, the axioms demonstrate how any expression can be \nrepresented in terms of the primitive operations. The concept of primitive operations corresponds very \nclosely to the concept of constructor operations in algebraic specifications [5]. Note that if the viewpoint \nbeing used marks only the principal functor of the left-hand-side of each axiom, then, except for the \nlack of order dependency, the result is a Unicorn program that behaves the same as a rewrite-rule implementation \nof the same specification. As defined so far, the set of possible transformations of an input expression \nmight contain non-primitive as well as primitive expressions. Those transformations that produce primitive \nexpressions are the transformations that are of interest. By allowing only those unifications that substitute \nprimitive expressions for variables, we guarantee that only those transformations of interest are generated. \n 108 5. Examples It turns out that the viewpoint technique lends itself quite nicely to the definition \nof preconditions for partial operations [6] without the need for added machinery. Consider the stack \nspecification appearing in figure 5.1. 1) pop(push(S,X)) : S 2) top(push(S,X)) = X 3) notempty(new) = \nfalse 4) notemtpy(push(S,X)) = true 5) pre(pop(S)) = notempty(S) 6) pre(top(S)) = notempty(S) 7) pre(X) \n= true Figure 5-1: Stack Specification with Preconditions Say that in our viewpoint, 'pre' is the only \nmarked operation in axioms 5 and 6, and that no operations are marked in axiom 7. Then it is up to the \nuser to make use of the operation 'pre' to insure that only legal calls to the operations 'pop' and 'top' \nare made. However, if in our viewpoint 'pop' and 'top' as well as 'pre' are marked in axioms 5 and 6, \nand 'pre' is marked in axiom 7, then the preconditions will be maintained automatically by Unicorn. For \nexample, suppose we want to transform the expression top(new). This expression unifies with axiom 6 producing \nthe transformation constraint pre(V)=notempty(new). Because of axiom 7, the left-hand-side of this transformation \nconstraint transforms to the primitive expression true. Because of axiom number 3, the right-hand-side \nof this transformation constraint transforms to the primitive expression false. Thus there is no way \nto satisfy the transformation constraint and hence there are no allowable transformations of the original \ninput expression top(new). Note that we excluded pre(V) from unifying with either of the expressions \npre(pop(S)) or pre(top(S)) in axioms 5 and 6 since that would involve the substitution of a non-primitive \nexpression for the variable V. Suppose we want to transform the expression top(push(new,apple)). This \nexpression unifies with both axioms 2 and 6 producing the two transformation constraints V=apple and \npre(V)--notempty(push(new,apple)). Since these constraints are simultaneously satisfied by the substitution \nof the primitive expression apple for the special variable V, apple is an allowable transformation of \nthe input expression top(push(new,apple)). So, depending on the viewpoint that we use, the same specification \ncan be used to define preconditions that must be checked by the user, or preconditions that are automatically \nchecked by the system. In order to define a precondition on a predicate in standard Prolog, in general \none would be forced to make an explicit call to the precondition in each clause defining that predicate. \nAs another example of the flexibility provided by the use of viewpoints, consider the specification appearing \nin figure 5-2. 1) boilingpoint(ammonia) = centigrade(-33) 2) boilingpoint(krypton) = kelvin(121) 3) freczingpoint(ammonia) \n= fahrenheit(-103) 4) meltingpoint(krypton) = centigrade(-157) 5) info(X) = tu pie (tuple(boilingpoint,boilingpoint \n(X)), tuple(freezingpoint,freezingpoint(X)), tuple(meltingpoint ,meltingpoint(X))) 6) centigrade(X) \n= fahrenheit(plus(32,times(9,divide(X,5)))) 7) centigrade(minus(X,273)) = kelvin(X) Figure 5-2: Temperature \nData and Conversion Factors Axioms 1 through 4 provide some temperature data for the substances ammonia \nand krypton. Our viewpoint considers the operations 'boilingpoint,' 'freezingpoint' and 'meltingpoint' \nto be the marked operations in these axioms. Axiom 5 provides another way to access this data; 'info' \nis the marked operation in our viewpoint. Depending on the viewpoint that we use for axioms 6 and 7, \nwe can have our results expressed in terms of either centigrade, fahrenheit, or kelvin. The fahrenheit \nviewpoint would consider 'centigrade' to be the marked operation in axiom 6 and 'kelvin' to be the marked \noperation in axiom 7. The centigrade viewpoint would consider 'fahrenheit' to be the marked operation \nin axiom 6 and 'kelvin' to be the marked operation in axiom 7. The kelvin viewpoint would consider 'fahrenheit' \nto be the marked operation in axiom 6 and 'centigrade' to be the marked operation in axiom 7. If we transform \nthe expression iofo(ammonia) using the kelvin viewpoint, we get the result t uple(tuple(boilingpoiot \n,kelvin(240)), tuple(freezingpoiot,kelvin(195)), tople(meltingpoint ,meltingpoint (ammonia))). However, \nif we transform the expression info(krypton) using the fahrenheit viewpoint, we get the result tuple(tuple(boilingpoint,fahrenheit(-238)), \ntuple(freezingpoint,freezingpoint(krypton)), tuple(meltingpoint,fahrenheit(-247))). This example has \ndemonstrated the general technique for using viewpoints to tailor the form of transformation results. \nViewpoints may also be used to alter the algorithms used for obtaining results. For example, different \nviewpoints might be used to switch from an abstract implementation to a more concrete implementation \nof the same abstraction. 6. Conclusions We have given an informal description of Unicorn, a programming \nlanguage based on the technique of constraining-unification. Although constraining-unification is a generalization \nof the mechanisms used in logic and rewrite-rule programming, the order dependency problems inherent \nin those languages are avoided. Constraining-unification closely models the semantics of equational 109 \n specifications. As a result, it is possible to implement 1O. MJ. O'Donnell. Computing in systems described \nby equational specifications of nondeterministic operations in equations. Lecture Notes in Computer Science, \nvol. 58, 1977. Unicorn. The use of viewpoints and semantic unification in 11. L.M. Pereira. User's Guide \nto DECsytem-10 Prolog. conjunction with constraining-unification results in an Divisio de Informatica, \nLab. Nac. de Engenharia, Lisbon, expressive and flexible programming language. Preconditions 1977. for \npartial operations can be specified in Unicorn. By employing different viewpoints, the same specification \ncan be 12. G.L. Steele. The Definition and Implementation of a used to require the user to check the \npreconditions or to Computer Programming Language Based on Constraints. PhX). have Unicorn automatically \nmaintain the preconditions. In Th., Dep. Electrical Engineering and Computer Science, addition, Unicorn \nwould be suitable for a parallel processing M.I.T., Cambridge, Mass., Aug. 1980. implementation since \ntransformation constraints can be concurrently checked. Acknowledgements Thanks are due to Professor \nAlan Borning for making helpful comments on earlier versions of this and related papers. He was initially \nresponsible for stirring my interest in logic and constraint programming and specification languages \nin general. Robert Bandes died in a skydiving accident on August 21, 1983, shortly after this paper was \nwritten. References 1. R.G. Bandes. Algebraic Specification and Prolog. Tech. Rept. 82-12-02, Department \nof Computer Science, University of Washington, December, 1982.  2. A.H. Borning. \"The programming language \naspects of ThingLab, a constraint-oriented simulation laboratory.\" ACM Trans. on Programming Lang. and \nSystems 3, 4 (Oct. 1981), 353-387.  3. J~A. Goguen. Abstract errors for abstract data types. In Formal \nDescription of Programming Concepts, EJ. Neuhold, Ed.,North Holland, 1978, pp. 491-525.  4. J.A. Goguen \nand JJ. Tardo. An introduction to OBJ: A language for writing and testing formal algebraic program specifications. \nPrec. IEEE Conference on Specification of Reliable Software, 1979, pp. 170-189.  $. J.V. Guttag and \nJJ. Homing. \"The algebraic specification of abstract data types.\" Acta lnformatlca 10 (1978), 27-52. \n6. J.V. Guttag. \"Notes on type abstraction (version 2). \u00b0 IEEE Transactions on Software Engineering SE-6, \n1 (January 198o), 13-23.  7. CJd. Hoffman and MJ. O'Donnell. \"Programming with equations.~ ACM Trans. \non Programming Lang. and Systems 4, 1 (January 1982), 83-112.  8. W.A. Kornfeld. Equality for prolog. \nPrec. Eighth IJCAI, 1983.  9. D3R. Musser. \"Abstract data type secification in the AFFIRM system: IEEE \nTransactions on Software  Engineering SE-6, I (January 1980), 24-32. 110   \n\t\t\t", "proc_id": "800017", "abstract": "<p>Up to this point direct implementations of axiomatic or equational specifications have been limited because the implementation mechanisms used are incapable of capturing the full semantics of the specifications. The programming language Unicorn was designed and implemented with the intention of exploring the full potential of programming with equations. Unicorn introduces a new language mechanism, called <italic>constraining-unification.</italic> When coupled with <italic>semantic unification</italic>, constraining-unification closely models the semantics of equational specifications thereby allowing for the implementation of a wider class of specifications. Unlike the language mechanisms of rewrite-rule and logic programming, constraining-unification is free of order dependencies. The same results are produced regardless of the order in which the axioms are stated. The use of <italic>viewpoints</italic> contributes to the flexibility of the Unicorn language. Preconditions for partial operations can be specified without added machinery.</p>", "authors": [{"name": "Robert G. Bandes", "author_profile_id": "81100541741", "affiliation": "Computer Science Department, FR-35, University of Washington, Seattle, Washington", "person_id": "P333349", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800017.800521", "year": "1984", "article_id": "800521", "conference": "POPL", "title": "Constraining-unification and the programming language unicorn", "url": "http://dl.acm.org/citation.cfm?id=800521"}