{"article_publication_date": "01-15-1984", "fulltext": "\n The Semantics of Local Storage, or What Makes the Free-List Free?* (Preliminary Report) Joseph Y. Halpern, \nIBM Research, San .lose Albert R. Meyer, Laboratory for Computer Science, MIT B. A. Trakhtenbrot, Dept. \nof Computer Science, Tel Aviv ~lniv. Abstract. Denotational semantics foran ALGOL-like language with \nfinite-mode procedures, blocks with local storage, and sharing (aliasing} is given by translating programs \ninto an appropriately typed X-calculus. Procedures are entirely ezplained at a purely functional level \n-independent of the' interpretation of program constructs -by con-tinuous models for X-calculus. However, \nthe usual (cpo) models are not adequate to model lo- cal storage allocation for blocks because storage \noverflow presents an apparent discontinuity. New domains of store models are offered to solve this problem. \n1. The Problem of Free Locations. ALGOL-like languages obey a \"stack discipline\" in which lo- cal storage \nfor blocks is allocated from the top of a memory stack on block entry. For object- oriented languages \nlike LISP or CLU requiring heap storage, new locations (aka program vari- ables) are usually allocated \nfrom a linked list of free locations. * This research was supported in part by NSF Grants MCS80-10707, \nMCS-8304498, and ,~ grant to the MIT Lab. for Computer Science from the IBM Corporation. Permission to \ncopy without fee all or part of this material is granted provided that the copies are not made or distributed \nfor direct commercial advantage, the ACM copyright notice and the title of the publication and its date \ntppcar, and notice is given that copying is by permission of the Anoeiation for Computing Machinery. \nTo copy otherwise, or to republish, requires a fee and/or specific permiuion. &#38;#169; 1983 ACM 0-89791-125-3/84/001/0245 \n$00.75 In both cases, there is a simple idea behind local variables in blocks: execution of a block \nbegin new z in Body end causes allocation of a \"new\" storage location denoted by the identifier z which \nis used in the body of the block. In ALGOL-like languages obeying stack discipline, the location is moreover \ndeallocated upon exit from the block. Understood in this way, stack dim cipline is a language design \nprinciple - encourag- ing modularity in program construction - rather than an implementation technique \nfor efficient storage management. It is better called the local storage discipline to avoid misunderstanding, \nand we do so henceforth. There is a problem in explaining this ap-parently simple idea behind local storage, \nnamely, what is a \"new\" location? The mathemati-cal models of storage allocation which appear in the \ndenotational semantics literature [Milne and Strachey 76; Stoy 77; Gordon 79] do not adequately address \nthis problem; instead they directly reflect the bookkeeping mechanisms used in implementations. Thus, \nnew storage allocation is typically modeled denotationally by enriching the notion of stores to include \nwith each location an indication of whether the location is \"active\". Execution, starting on some store, \nof a block with local storage involves selccting the first \"free\" (i. e., not marked \"active\"} location \nof the store as the one to be allocated. The problem with this approach is that the locations designated \nby the store as free may al. ready be accessible from the body of the block, and so may not in fact be \nfree. For example, let z be an identifier of location (aka reference) type, and let p be an identifier \nof parameterless pure procedure type. Then, the block  begin new z in z :-'- O; p; ifcont(z) --0 then \nskip else diverge fl end ought to be equivalent to skip since the \"new\" location allocated for x should \nnot be affected by the call to p. But if p happens to denote the program which assigns a nonzero value \nto some location l, and this block is executed on a store in which location l happens to be desig- nated \nas the first free location, then the block will diverge. Validity of the expected properties of blocks \nthus hinges on hypotheses about how the locations designated as active by the store re- late to the locations \nwhich really are active, and we are in any case still left with the problem of explaining what a free \nlocation \"really\" is. The semantics using activity marks does be- have properly on programs without calls \nto global (undeclared) procedure identifiers. For example, the block above will behave like skip in any \npro- gram context in which the global identifier p is declared (in a declaration which itself does not \ncontain global procedures). In this case, execution of the overall program will correctly update the \nfree list so that the locations affected by p will be marked as active by block execution time. This \ncan be proved by induction on the length of com- putation of programs without procedure globals. However, \nthis observation leaves several matters unresolved: (1) Suppose we add some new command to the language \n-say one which initializes some special portion of the store? This enriches the possible ways p might \nbe declared, requiring reverification of the allocation mechanism for the richer class of p's. (In fact, \nthis enrichment invalidates the mechanism unless all locations in the special por- tion of the store \nare permanently marked active). (2)More generally, suppose p is a call to a pro- gram written in another \nlanguage - say a system program in machine language? Allocation from the free list will not be safe. \n (3) The simple reasoning that goes with the idea that \"new\" storage is allocated at block entry must \nbe replaced by reasoning about the details of particular allocation mechanisms. We address these problems \nby explaining semantically when a location is active or free with respect to a procedure. In general, \nwe define how a set of locations cover8 a procedure of finite type, by induction on types. The locations \noutside the cover of a procedure are the free ones for it. The desired semantical explanation of new \nstorage al- location is then simply that any location free for the block body is to be allocated -no \nother details of the allocation mechanism need be considered. An amusing technical problem must be faced \nwith this approach. Some kind of continuity condition is normally required of the functions defining \nthe semantics of procedures in order to ensure that the fixed-points necessary to explain recursive definitions \nexist. Unfortunately, in the usual formulations the operation of allocating and later de-allocating \"new\" \nstorage turns out not to be continuous, essentially because of the theoreti- cal possibility of running \nout of storage - even if we assume there are an infinite number of loca- tions in memory! For example, \nsuppose ~r is a store to store mapping whose only cover is the set of all locations - Ir might be the \ndenotation of a procedure which \"sweeps\" memory searching for an untagged location. Now ~ can be expressed \nas the limit of a sequence of approximating mappings ~r~ which only sweep the first i locations. Since \nstorage is infinite but a finite number of locations cover ~r~, there is always a location free to allocate \nfor a block whose body behaves like Ir~. On the other hand, allocating new storage for Ir yields an overflowed \nerror, viz., allocating local storage and taking limits do not commute as required by the definition \nof continuity. (The discontinuity of new storage allocation was noted in [Milne and Strachey, 76], with \na reference to further discus- sion in Milne's thesis.) In general, objects with \"large\" covers force \nus to face the discontinuity of storage overflow. We would like to rule out such objects, especially \nin view of the fact that definable objects, viz., objects which are the denotations of phrases in ALGOL-like \nlanguages, can be proved to depend on only finitely many locations. However, once we have mappings (like \n~r~) which depend on only finitely many locations, the usual requirement that semantical domains be complete \npartial or-ders (cpo's) which are closed under taking least upper bounds of all increasing chains forces \nus to admit programs (like lr) with infinite covers [Stoy 77; Scott 81, 82]. Difficulties of this sort \nhave led [Reynolds, 81] and [Oles, 83] to consider more sophisticated functor categories as domains of \nin- terpretation. For further discussion see [Meyer, 83; Trakhtenbrot, Halpern and Meyer, 83]. Our solution \nis to relax the requirement that domains be closed under all (increasing) limits. We require closure \nonly under certain \"algebraic\" limits sufficient to ensure that domains will obey the fixed-point and \nother properties required for program semantics. This theory of algebraically~ closed partial orders \nis less well known than the cpo theory, but has been developed extensively [Nivat, 75; Guessarian 81; \nGuessarian 82; Gal-lier, 1983; Courcelle, 1983]. In this framework, we give a general definition of the \nnotion of cover- ing, and define afore models: systems of algebrai- cally closed partial orders containing \nonly ele- ments with proper covers but including enough elements to interpret all the programming con-structs \nof ALGOL-like languages. Store models justify all the intended properties of new-declarations. For example, \nin store models the block mentioned above with global call to p is indeed equivalent to skip in all environments. \nAnother illustrative equivalence is: begin new x in if z ----Y then Cmdz else Cmd= fl end ----- y :--cont(y);Cmd=. \n (The \"useless\" assignment to 9 appears in case ~/ denotes the divergent (1) location.) 2. ALGOL-like \nLanguages. The focus of our proof-theoretic studies has been on the family of idealized ALGOL-like languages. \nWe review several of the principles which characterize this class of languages [cf. Reynolds, 81; Meyer, \n83; Trakhtenbrot, Halpern, and Meyer, 83; Halpern,  83]: (1) Commands, which alter the store but do \nnot return values, are distinguished from ezprea-8ion8, which return values but have no side-effects. \n (2) Calling is by-name. (Calls by-value, etc., are treated as syntactic sugar.) (3) Higher-order procedures \nof all finite types (in ALGOL 68 jargon, modes) are allowed. (4) The local storage discipline is an \nexplicit aspect of the semantics.  In this section we sketch a few of the features of an illustrative \nALGOL-like language we call PROG. Types in PROG. The distinction between locations and storable values \n- in our semantics they be- have as disjoint domains -is one of several struc- tural restrictions on \nALGOL-like languages im- plied by local storage discipline. For example, it is well-known that locations \n(and likewise pro- cedures) cannot be storable without restriction, since otherwise locations allocated \ninside a block might be accessible after exit from the block via the stored objects. For simplicity, \nwe consider storable values of only one type. The two basictypes -storable values and locations -- are \nabbreviated int and Ioc, respectively. PROG syntax mandates an ezplicit type distinction between locations \nand storable values (also called \"left\" and aright\" values of expressions), using the token cont for \nexplicit dereferencing. Thus, cont(z ~\u00b0=) denotes the ele- ment of type int which is the contents of \nz, and as- signment commands take the form LocE :---- IntE where LocE is a location-valued expression \nand IntE is an int-valued expression. Equality tests in PROG can only be between elements of basic type. \nWe do allow explicit equality testing between locations, \"z Ioc = ymoe,,, in addition to the usual test \nof equality between storable values, \"a -\" f(cont(yloe)) \". Expressions which evaluate to locations are \nallowed, as in the \"conditional variable\" expression on the lefthand side of the assignment command ira \n= f(cont(y)) then y rise z fi :~--- a. The other primitive types are prog, intexp, and loeexp. The domain \nprog is the domain of program meanings, namely, mappings from stores to sets of stores. (PROG has a nondeterministic \nchoice construct. Since we do not attempt to dis- tinguish \"failing\" from diverging, nondeterminism is \nadequately modeled with mappings to sets as opposed to the more complex power-domains of [Plotkin, 76,82; \nSmyth, 78].) The other two \"expression\" types are the denotations of expres- sions whose evaluation yields \nbasic values, viz., the elements of intexp (locexp) are functions from stores to int (loc), i.e., \"thunks\" \nin ALGOL jargon. Blocks and Binding in PROG. Procedures of all higher finite types formed from the five \nprimitive types may be declared, passed as parameters, and returned as values. Procedure identifiers \nare bound in PROG via procedure declarations occurring at the head of a procedure block, e.g., proc \np(z) \u00a2= DeclBody do BlockBodT/end. Identifiers of basic type are bound by either let- declarations or \nnew-declarations at the head of basic blocks of the form let z mat be IsLE in Cmd tel, let ylo\u00a2 be LocE \nin Cmd tel, begin new 7/I\u00b0e in Cmd end. The let-declaration causes the evaluation of the expression \nIntR in the declaration-time store and causes identifier z to denote the result of the evaluation. (A \ncall-by-value of the form p(BasE) can be simulated by the basic block let n be Base in p(n) tel.) Basic \nand procedure declarations have quite different scopes and mean- ing, as will be revealed below. 3. Syntax-Preserving \nTranslation to X-Calculus. We formalize the assignment of semantics to pro- grams in two steps: (1) a \npurely syntactic translation from PROG to a fully-typed X-calculus enriched with a letree- construct \nas in [Damm and Fehr, 1980; Datum, 1982; of. Landis, 65], and (2) assignment of semantics to the k-calculus \nin a standard referentially transparent way [Barendregt, 81; Meyer, 82].  Our X-calculus is chosen so \nthat its constants correspond to program constructors, its binding operations, letrec and X, correspond \nto program declarations and procedure abstraction, and its types are the same as those of the programming \nlanguage. In fact, the abstract syntax, viz., parse tree, of the translation of a program is actually \nidentical to that of the program; the translation serves mainly to make the variable binding con- ventions \nof PROG explicit. Procedure blocks are translated using letree, so for example, Tr(pro\u00a2 p(z) \u00a2== DeclBod~/ \ndo BlockBody end) --'d,t ietree p --- kz.Tr( DeclBod~/) in Tr( BlockBody) . This recursive declaration \nof p binds occurrences of p in both the declaration and the block bodies. Procedure declarations in this \nway inherit the static seoping rules of X-calculus. Basic blocks are handled with constants and X's, \ne.g., Tr(let z Int be IsLE in Cmd tel) --de/ Dint (Xz.Tr(Cmd)) (Tr(IntE)) where Dint is a constant of \ntype (int --, prog) --. intexp --. prog. Note that the binding effect of the block on z int is reflected \nin the binding effect of kz on Tr(Cmd), namely, the declaration binds z in Cmd, but does not bind z in \nISLE, in contrast to the case for procedure declarations. Similarly, Tr(begin new z in Cmd end) --'de/ \nNew(kz.Tr(Cmd)) where New is a special constant of type (loc --, prog) --, prog. The semantics of New \nwill be defined so that Cmd runs in an environment in which z is bound to some location outside a cover \nof Cmd. The contents of this new location are initialized to some standard value denoted by the constant \na0 at the beginning of the computation of Cmd and restored to their original value at the end. Other \ncommands and expressions are trans- lated directly by introducing suitable constants (but no binding \noperators), e. g., Tr(ifTerra~ --- Term~ then Terra~ else Term~ t) ----4,1 (If..# (Tr(Term?)) (Tr(Tervn~)) \n (Tr(Term~)) (Tr(Term~})), Tr(cont(LocE)) =d,! (Cont{Vr(LocE))), Tr( Cmd return IntE) -- ~ ! (Return(Tr(Cmd))Tr(Ir~tE})), \nTr(LocE :-~ IntE) --~1 (Update (Tr(LocE)) (Tr(IntE))), Tr(Cmds; Cmd2) \"-~! , ,(8eq(Tr(Cmdl))(Tr(Cmda))), \n etc. The principal consequence of this syntax-preserving translation is that all the properties of procedure \ndeclarations in ALGOL-like languages such as renaming rules associated with static scope, declaration \ndenesting rules, and expan-sions of recursive declarations, can be recog-nized as direct consequences \nof the correspond- ing purely functional properties of the ietree-X- calculus -which have nothing at \nall to do with side-effects. Before elaborating this point, we review the properties of the letrec-calculus. \n4. Typed Lambda Calculus. Let T be a set of primitive type symbols, C be a set of typed con- stants, \nand X be a set of typed variables. Type ezpresaiona are defined inductively: the primitive type symbols \nare type expressions, and if a, ~ are type expressions, then so are ~ ~ ~ and a X 8. With each type expression \n~ we associate a (possibly empty) set of constants Ca, disjoint from C# for ~ ~ 8. With each c~ we also \nassociate an infinite set of variables Xa, disjoint from Xp for a ~/~. We use the notation z a when we \nwish to emphasize x E X=. By definition, C = U=C= and X --U,Xa. We define L a, the terms of letree-k-calculus \nof type a, by induction. (1) CoUXo c_ L o. (2) Application: If u E L ~-'/j, v E L ~, then (u E LP. (3) \nAbstraction: If z E Xa, u E L p, then )~x.u E L a-*p. (4) Block with mutual procedure declarations: \nIf z~ E X a~', uj E L a~, j --1,...,k, x i all distinct, and v E L D then (letrec zl --- ul and.., and \nzt = u~ in v) E L p. We say z~ is declaredin this block with declaration body us, and v is the block \nbody. Free and bound occurrences of variables are defined as usual [Hindley, Lercher and Seldin, 1972; \nStoy, 1977; Barendregt, 1081]. Note we are allowing recursion here: the variables zj may oc- cur in u, \nas well as v. In particular, \"letree z~\" binds all free occurrences of zj in ul,..., u~, v. As usual, \nwe omit parentheses in compound applications with association to the left being un- derstood. In contrast, \nthe operation --, associates to the right in compound type expressions. Thus uvw abbreviates ((u v)w) \nwhile ~ --. fl -~ ~ ab-breviates (a --. (fl ~ ~)). We let [v/x]u denote the result of substituting the \nterm v for free oc- currences of x in u subject to the usual provisos about renaming bound variables \nin u to avoid cap- ture of free variables in v [Stoy, 1977, Def. 5.7; Barendregt, 198i, Appendix C]. \nA term u is in normal form ifffor every applica- tion (Ul u2) which is a subterm of u, the operator Ul \nis neither an abstraction nor a block. The fol- lowing result is well-known for typed X-calculus (cf.[Barendregt, \n1981, Appendix C]), and extends directly to include letrec. 249  Normal Form: Every term u is effectively \ntransformable using (cf. \u00a75) a,/%conversion, dec- laration distributivity and the replacement rule to \na normal form NF(u) which is unique up to ~-conversion. 5. Cartesian Closed Models. For any sets Dx,...,D,, \nlet D, X ... \u00d7 D, be the set of all ordered n-tuples (d,,..., d,) of elements d~ 6 D~. Let tupleD~ .... \n,v. : D, --* ... --* D, ~ (D, X .\" X D,) be defined by: tuple d,. . . d, --(dl, . . . , dn), and letproj~ \n..... D, : (D1 X ... X Dn) -* D, be projection on the i th coordinate. A Cartesian Closed type-frame \nconsists of a family of sets { D~ } Called domains or types, one for each type expression a, such that \n(1) D~._.~ consists of some nonempty family of functions from Do to Dp and Daxp --Da X D~, and (2) there \nare dements Sa,~,~ 6  D(~.--,(~-,~))_,(Ca..,~)_., (a~)), and Ka,~ 6 Da-*0s-~a) for every a,/~, 7 such \nthat Sc~,p,~dod, d~ --(dodu)( d, dz), Ka,pdsd4 --ds. (3) tupleDo, .....Do, 6 Da,-....-.a.-.(o,x...xa.), \nand similarly pr02~)o ' ...Do. 6 D(c,, x ...\u00d7o.)~a,- An environment for a type-frame D is a mapping e \n: X --. D --[.JoDa which respects types, i. e., e(z \u00b0) 6 Do. Given an environment e, let e[d/z] denote \nthe en-vironment which differs from e only at z, and (e[d/x])(z) = d. Let e[dl/pl,...,dJ,+l/pt+l] abbreviate \ne[d, /p,, . . . , d~/Pklld~ + xlpt+ ,]. (We define the \"patch\", fib~a], of any function f : A --* ]3, \nat a 6 A, by b 6 B similarly.) Let Envv be the set of all environments for D. A Cartesian closed model \nconsists of a Car-tesian closed type frame together with an in-terpretation of the constants, i. e., \na map-ping [[~0 : C --* D which respects types. The model is standard iff the constant symbols S~,~s,~ \n6 C(~_.(~_.~))_.((~_.~)_,(~_.~)) and K~,~ 6 Ca-.(#-~) are interpreted as the corresponding .S and K \nfunctions, and similarly for the constants tuple and proj ~. Let L, C L be the usual typed k-calculus \n(without letrec). The justification for this peculiar definition is that for any Cartesian closed model \nD, there exists a unique mapping a liD : L1 --* EnVD --* D which respects types such that (a) adds = \neBo, (b) = e(x),  (c) a( v) De = (b,O e)(avl d. (d) for all d 6 Do, (OXza.u~De)d ---~U~DCeld/z]). \nA fixed-point frame is a Cartesian closed frame such that there is an element Yo 6 D(a-.~)-.a such that \nY ! =/(Yf) for all f 6 Do-,a and all type expressions a. A fixed-point model is a model whose type frame \nis a fixed-point frame; it is standard iff the constants above have the standard interpretation and the \nconstant symbols Ya 6 C(a-.a}--,a are interpreted as fixed point operators Ya. Let k(zl,..., x,).u abbreviate \nkz.([Cproj I z)lx,]...[(proj\" z)/x,]u) for z not free in u. For any Cartesian closed fixed-point model \nD, there exists a unique mapping a ~D : L --* EnvD -* D which respects types, satisfies (a-d) above, \nand such that (e) ~letree P] --u, and...and P. --u. in vide =de! ~V]D(e[dl/pl,...,dn/Pn]) where (dl,..., \ndn) = ~(Y X(pl,  pn).tuple ul'.. un)]De. Terms u and v are equivalent for some model D, written u \n~D v, iff ~U]D = aViD. If )~ is a class of models, u and v are N-equivalent iff u =--D v for all models \nD 6 Y,t. We abbreviate a mutual procedure declaration of the form (letre\u00a2 p, = ul and ... and p, --- \nu. in v) by (letrec Dec in v), where Dec --~ {pl = ul,...,p, = u,). The following fundamental inference \nrule verifies the referential transparency of L. It is sound in any Cartesian closed model when we merely \nregard letrec Dec in v as an abbreviation for (X{pl,..., p,).v)(c (k{pt,...p,).tuple ul'\" u,)) without \nassuming any facts (such as fixed-point properties) about the constant c. Replacement Rule. If u ----- \nv and 102 is the result of literally replacing (without renaming bound variables) an occurrence of u \nby v in wl, then 101 !--- 102. The following equivalences hold in any Car- tesian closed model. Variable \nrenaming, viz., wconversion: (i) Xx.u -- XY.IY/xlu , where y is not free in u, and (ii) (letrec { p --body \n) 0 Dec in u) = (letrec { q = [q/p]body ) U [q/p]Dec in [q/p]u) , where q is not free in u, body, or \nDec, and is not declared in Dec. Evaluation by substitution, via., fl-conversion: (xx.u),J -_- Declaration \ndistributivit~ ( letree Dec in uv) = ( letree Dec in u)( letrec Dec in ~). Declaration elimination: (letre\u00a2 \nDec in u) ---- u providing no variable declared by Dec is free in u. Variable binding commutativity: \nkz.(letrec Dec in u) ---- (ietrec Dec in Xz.u ), providing z is neither free nor declared in Dec. Eztensionality, \nvia., 17-conversion: xx.(u z) ffi u providing u fi L a''p for some types ai ft. Normal Form: u ~ NF(u). \nThe fixed-point property justifies declaration- expanding transformations. Declaration ezpanaion: (letrec \n{p = body ) k) Dec in [p/q]v) (letrec {p = body) U Dec in [body/q]v). 6. Algebraically Closed Models. \nCartesian closed fixed-point models are still too general even to jus- tify routine transformations of \ndeclarations. To establish soundness of such transformations, it is necessary that the fixed point operators \nbe chosen consistently with the structure of the type frame; for example, designated fixed-points should \nbe preserved under isomorphisms induced by reas-sociating Cartesian products. Frames whose types have \nsome order structure which ensures the ex- istence of least fixed-points can provide a har-monious system \nof fixed-point operators. One well-known least fixed-point frame is the frame of complete partial orders \n(cpo's) with continuous functions. However, we need more general classes of least fixed-point frames \nwe call algebraicallll closed frames. If D and E are partially ordered, then a func- tion f : D -. E \nis monotone iff dx ~ da implies f(d,) if_. f(d2). If a subset Z _ D has a least upper bound, L.J z, then \nf : D --. E is continuous along Z iff it is monotone and f([.] Z) = [..J{ f(z) ] An algebraically closed \n(ael) type frame is a Cartesian closed type frame { Da ) such that (1) each primitive domain D is partially \nordered with least element .LD, (2) function and product domains of higher type are partially ordered \nby the inherited point-wise and eoordinatewise partial orders, (3) for all types a and functions f E \nDa-.a, the least upper bound ]J~ fk(_L) exists, where f\u00b0(z) ffi z and yk+l(z) --f(f~(z)) (sequences of \nthis form 1, f(I), f(f(.L)), .. are called algebraic), (4) for all types a, every function in Da-,p \nis con- tinuous along every algebraic sequence of elements in Da,  251 (5) for all types a, the least \nfixed point operators Y~ defined by Ya(f) --II~fk(/v\u00b0) are in D(a-~a)-.o~. An (ac 0 model is a fixed \npoint model with an acl type frame; it is standard iff the constants S, K, tuple, proj i have the standard \ninterpretation, the constants Ya are interpreted as the corresponding least fixed-point operators Ya, \nand for all primitive a, the constants diverge a E Ca are interpreted as -I-Do. We let diverge a-'\u00b0 abbreviate \nkzP.diverge \u00b0 and handle/~ \u00d7 a similarly so that in standard acl models, [ldivergeaB --\u00b1D\u00b0 for all ~. \nThe following equivalences connect fixed-points between distinct domains and hence depend on choosing \nfixed-points harmoniously, viz., choosing least fixed-points. We refer to properties like these which \nare valid for all acl models as acl properties. Declaration collection: (letrec Dec in (letrec Dec' in \nu)) ----- (letrec Dec U Dec' in u) providing none of the variables declared in Dec' occurs free or has \na distinct declaration in Dec. E=plicit parameterization: (letrec { p -- body} U Dee in u) = (letree \n{ q = kx.[qz/p]body } t.J [qz/p]Dec in [qx/plu) providing q does not appear in u, Dec, or body, and p \nis not declared in Dec. Declaration denestin9: (letrec { p = letrec Dec in body } U Dec' in u) -~ (letrec \n{ p --body } (.J Dec U Dec ~ in u) providing none of the variables declared in Dec is free in u or Dec' \nor declared in Dec ~, and p is not declared in Dec or Dec ~. A term u E L is denested iff neither the \nbody of any variable declaration nor the body of any block in u contains a declaration. Every term can \nbe effectively transformed into an equivalent denested term using the equivalences above. The following \ngeneral induction principle is a basis for induction rules about programs. A predi- cate P on a domain \nDo in an acl frame is acl. inclusive iff (Vi > 0. p(f(O(/))) =~ p(y(f)) for all f 6 D.__... Fixed-point \nInduction: Let Da be a domain in an ael frame, P be an inclusive predicate on Da and f E Da-,a. If P(-LD\u00b0) \nA Vd E D. (P(d) =* P(f(d))), then P(Y(f)) holds. The equivalances and rules for k-terms im- mediately \nyield rules for PROG phrases; we indi- cate a few. Let E (possibly primed or subscripted) represent a \nfinite system of mutual PROG proce- dure declarations; procedure blocks of the form proc E do ProcT end \nwill be abbreviated as E I ProcT where ProcT is a procedure term. Declaration distributivity in PROG: \n(E l (ProcT1ProcT2)) = (E I Procrl)(E i ProcT ), (E I ProcTPrOS;ProcT p~s) ~_ ((E I ProcTP'\u00b0g);(E I ProcTp'offi)), \netc. Note that declaration distributivity depends crucially on the fact that E denotes a set of procedure \ndeclarations, whose meaning is neces- sarily store-independent. So the declaration distributivity rule \nis valid despite the possible side-effects on the store between evaluations of different copies of E. \nIn contrast, distributivity fails for basic declarations because the value bound to an identifier by \na basic declaration depends on the store \"at declaration time\". This contrast was reflected in the use \nof constants in translating basic blocks, compared to the letree construct used to translate procedure \nblocks. Variable binding commutativity in PROG: (E I let z ,= Base in ProcT pros tel ) let z \u00a2= Base \nin (E I Pr\u00b0cTpros) tel, (E I begin new y in ProcT pros end) -----begin new y in (E I ProcTPr\u00b0S) end providing \nz, 1/do not occur free in E. Fixed-Point Induction for Approximation in PROG: Let p be an identifier \nand ProcT a PROG term, both of the same type, such that p is not free in ProcT2. Then [diverge/p]ProcT1 \nE ProcT2 , ProcTl if_ ProcT21- [ProcT/p]ProcT1 if_ ProcT2 proc p \u00a2:: ProcT do ProcTl end ~ ProcT2 7. \nThe Equivalence of Fixed-Point and Com-putational Semantics. The most fundamental acl property is that \nevery term in L can be under- stood as a limit of finite letrec-free terms (in normal form if desired) \nwhich approximate the given term. These finite approximations are Ob- tained by repeatedly \"unwinding\" \nthe letrec dec- larations using the declaration expansion rule. This provides an effective computational \nrule for simulating the effects of letrec's and the cor-responding procedure declarations in PROG. It \nalso shows that two procedures which expand to the same infinite declaration-free procedures are equivalent \nin all acl models for PROG, indepen- dent of the meaning of any PROG constructs. The original ALGOL 60 \nreport [Naur, et. al., 1963] gave a \"copy-rule\" semantics for the lan- guage. The copy-rule can be understood \nas par- ticular computational strategy for generating the infinite expansion of a command. Another acl \nproperty is that fixed-point and copy-rule seman- tics {appropriately extended to letrec-terms and FROG \ncommands with free variables) assign the same meanings to terms [cf., Damm 82]. This confirms that our \nchoice of denotational \"fixed- point\" semantics is consistent with the usual operational understanding \nbased on the copy-rule. For the development here, however, we have no need of these facts, and so we \nomit further ex-planation. Thus procedure declarations of ALGOL-like languages are entirely explained \nby acl semantics for L. On this basis we assert that the typed )~- calculus is the true mathematical \nsyntax for these languages. For example, several of the language design principles of [Tennent, 81] can \nbe recog- nized as proposing that syntactic restrictions of programs to subsets of L be removed. 8. Store \nSemantics of FROG. Particular instances of ALGOL-like languages are determined by their types and the \ninterpretations of their constants. Properties related to stores and side-effects appear only at this \nlevel. We now specify the domains and constants which determine FROG. Store Frames: Given an infinite \nset Loc [of loca- tions) and a set Int (of storable values) we define the domains DI.~ =d,/Loc U { li,~ \n}, Di,t =d,/ Int U {-Lint ) to be the fiat epo's. For sets A, B, let A B =d,/ the set of all total functions \nfrom B to A. For the other primitive domains, we select some subset, Store C_ 1at z'*c. Store must be \nclosed under finite patching. (Note that no store maps a location to lint. There is no need to introduce \nsuch \"partial\" stores in modeling the behavior of sequential languages like PROG.) Then Dintexp _~ (Dint)St\u00b0rel \nDIocexp ___(DIoc) St\u00b0re, Dpros C (fl(Store)) 8tor'. Here P(Store) denotes the power-set of stores {ordered \nby containment), so elements of Dpr.s correspond to nondeterministic mappings between stores. A Store \nmodel is any standard acl model with the above five primitive types such that there are elements in the \ndomains of the frame which in- terpret the constants required in the translation of PROG to L as specified \nbelow. These constants are: If, Mkexp, Cont, Update, diverge, Ifprog, Secb Choice, Return, Dint, Dloc, \nand New. The constant Ifa,a for basic types a, fl has type --. c~ --, ~ --./~ --./~. A store model interprets \nIf so that ~If ~d a~-~a /_J_p if da -- ~ or d2 -\" -La, ,,,#11% 2 a3-4 = d3(d4 if dl --d2 ~ otherwise. \n-J-, Any first order function f of type 5 = int ~ --. int can be coerced into a mapping Mkezp(f) tak-ing \nas arguments functions from stores to int. Namely, the coercer Mke=p6: A4kexp6 f6 (~ntexp --intexp ,...,a \nk s--f(dl(8),...,dk(a)) : 253  for any store s. The constant Mkexp~ of type --, (intexp --, ... --, \nintexp) is interpreted as Mkexp~. The constant Cont of type locexp --) intexp is defined in store models \nso that 'C\u00b0nt] d'\u00b0e'xPs = (~J~)) otherwise,~ -[4o,, if d(,) For assignments, the constant Update of \ntype iocexp --, intexp --* pros: ~Update~d~ \u00b0eexpdintexp8 .__ (~ ,[d~(s)/dl(S)]} if d~(s),d~(s) ~ _l_ \notherwise. For conditional commands, Ifprog of type ~-exp --. ~-exp -* prog -. pros --. pros: ~Ifprogo \n~ d~ \".xp d~ \"ezp d~ r\u00b0sd pr\u00b0s S --'~ /~ if d~(s)-- .J~ or d~(s)--- _[.~, ds(s) if d~(s) -- d~(s) # \n_1_, (d4(s) otherwise. Command constructors Choice, Seq of type pros ~ pros --* pros: ~Seq~dPr\u00b0Sd~r\u00b0ss \n= V{ d~(s~) [ s ~ E ds(s) }, ~Choice~d~P~\u00b0sd~r\u00b0ss= dz(s)U d~(,). For let blocks, Dint of type (int ~ \npros) intexp -,. pros: ~Dint~ d~ nt -\" pros d~nt.fp a : {(dl (d2(s)))(a) if d:~(s) # J-I.t, otherwise. \nWe translate basic blocks with declarations of location type similarly, using a correspond- ing combinator \nDioc. (The simpler definition which omits the \"otherwise\" clause seems to imply unavoidable implementation \ninefficiencies and (presumably for that reason) does not cor- respond to the behavior of actual languages.) \nReturn of type pros --, intexp --, intexp: ~Returu]d~ d~ s \"-- d2(dl s). The semantics of the constant \nNew of type (loc -. pros) --* pros is handled in the next sec- tion. 9. Domains for the Local Storage \nDiscipline To explain the semantics of New, we must define the notion of covering. For primitive types \nthis is fairly straightforward. Let L be a subset of Loc. Two stores s, t agre~ on L, written s --t. \nt, iff Y/ E L. 8(1) = t(0. Similarly, two sets S, T C_. P(Stores) agree on L if there is a bijection \nf : 8 -* T such that Vs E S. s --,/(s). For each primitive type a, define the unary predicate Access~ \non Da by the rules belogl. If AccessL(d) holds, we say that d accesses onll/ the locations in L. Note \nthat AceessL(d) will imply AceessLUL' (d). (1) Aecess~oe(l ) iff l E LU { -LIoe }, (2) Ac-,s~,t(d) --true, \n (3) AecessLp,os(~r) iff Vs, t E Store.(s \"-L t =~ ~(,) =~ ~(t)) A (t ~ ~(s) =, =Loo-, t), (4) AccessLntexp(7 \n\") iff Ys, t E Store. s =/. t =~ 1.0) = 1.(t), (5) AccesS[o~,=p(a ) iff Vs, t E Store. s --L t =~ ~(s) \n= o(0 ~ LU{\u00b1,.). For higher-type objects, we also need a notion of uniformity with respect to \"new\" locations. \nDefinition. Let ~ : Lo\u00a2 --. Loc be a per-mutation; extend ~ to Dloe so that ~(_[.) ----- .L. Let ~Store \n: Store --, Store be the permutation defined by the rule ~sto,.(s) : s o ~-1 where o denotes functional \ncomposition, and let /~p(Store) : P(Store) ~ })(Store) be the permuta- tion defined by applying ~Sto,e \nelementwiso. For each primitive type ~, define a permutation/~a : Da --, Da by the rules: (1) ~lo~ -- \n#, (2) ,,.t(~\") = d, --1 0) ~,-,(~) = ~,cs,o.,) o ~ o ~s,.,., (4) ~intexp(1.) \"-\" 1\" 0 ~$tor. ' --1 \n (5) ~ioeexp(O) --.loco O' o ~Stor,\"  Note that (~-1)o = (pa) -1, so the notation ~-1 is unambiguous. \nWe now proceed to define the unary predicates Access~ on Do and the permutations #o : Do --. Da for higher-order \n~ by induction on types. Definition. At higher types define Access _. (/) ier L' Vd E Dp, L' C_ Loc.Accessp \n(d) =~ Access~ uL' (f(d)) , Access~\u00d7.l(dl, d2) iff (Access~(dt) ^ Access~(d2)), ~#.~(f) --lz.t o f o \nI~ t , = A permutation ~ : Loc ---, Loc fizes L iff #(1) = l for all l E L. Define the unary predicate \nUnif~ on Do by the rule: Unify(d) iff V/~ fixing L.l~,.(d)= d. If Unify(d) holds, we say that d is uniform \noff L. We henceforth omit subscripts c~ when they are clear from context. Definition. A set L C Loc cover8 \nan element d iff AccessL(d) A UnifL(d). Note that for primitive types, AccessZ'(d) iff L covers d. Some \nkey properties of covering are (1) if L covers d, then L t.J L I covers d, (2) if L covers f'~--,D, \nd ~, then L covers (f d), (3) if L covers all d E Z __. Do and U Z exists, then L covers LJ Z, (4) \nThe functions K, S, Y, tuple, proj' have empty covers.  These facts immediately imply that for any environment \ne and term u E L, the element ~u~e is covered by a union of covers for [c~ and e(z) for all the constants \ne and free variables z in u. It not hard to show that all the constants other than New are continuous \nand have empt~/covers. To ensure that New is interpretable, we impose a further condition on store models: \nCovering Restriction: Every element has a finite cover. Definition. A function Select : Dloe~pros \"-~ \nLoc will be called a selection function iff Vp E Dioe.~pros:lcover L of p. Select(p) f~ L. (Selection \nfunctions exist because of the covering restric- tion.) For each selection function Select, let ]Vewsetece \n: Dloc--.pros ~ Dpros be defined by NeWsdect p \"- ~Tr(let z int \u00a2= cont(y) in y := a0; p(y); y := z tel)~e, \nwhere e(~) = Select(p), e(p) = p. Lemma. Let Select1, Select2 be selection func- tions. Then (a) Newsetectl \n= Newsegecta, (b) Newsetectl is continuous along algebraic sequences and has an empty cover. It follows \nthat if we take any selection function Select, then Newsete~t unambiguously determines a meaning for \nNew in store models -which we require to be in D(Ioe-*pros)--*prog. To demonstrate rigorously that the \ntheory of PFtOG is consistent, we must show that store models exist. Let Loc be uncountable. An w-cpo \nmodel [Meseguer 78; Plotkin 82] with the five store-model base types (and with higher func- tion domains \nconsisting of all w-continuous func- tions) is an also an acl model which satisfies all the conditions \nfor store models -including the existence of an w-continuous function which behaves like ~New~ on elements \nwith countable covers -except for the covering restriction. For each domain of the w-cpo model, we take \nthe subdomain of those elements which have a finite cover. Using the method of logical relations of [Plotkin, \n80;Statman, 82] these subdomains can be taken together to form an acl frame which can be demonstrated \nto be a store model. We can further justify our store model seman- tics by demonstrating that it coincides \nwith familiar operational semantics based either on stack implementations or on copy-rule semantics in \nwhich new declarations are explained through renaming of local identifiers (cf. [Langmaaek and Olderog, \n80; Olderog, 82]). 11. Reasoning about Covers. Because all the PROG constants have empty covers, a cover \nfor (the meaning of) any PROG phrase is easily characterized: take the union of covers for the free procedure \nand location identifiers. In par- ticular, if the phrase has no global calls -so the only free identifiers \nare of location type - then a cover is available by inspection: the union of the (denotations of) the \nfree location variables in the phrase. This follows because a cover for any loca- tion I E Loc is the \nsingleton {l}. (In general, a minimal cover of a command is strictly smaller than the covers of its free \nidentifiers, e.g., z :~ cont(z) has an empty cover.) These observations are the basis for a variety of \naxioms for program correctness suggested in [Meyer, 83; Trakhtenbrot, Halpern, and Meyer, 83; Halpern, \n83]. CHtique of PROG. PROG fails as an example of satisfactory lan- guage design in many ways, even \nwith respect to the limited set of features it is intended to model, For example, (1) there are no Boolean \ntypes, (2) there is no while command or other struc- tured control statement, (3) only one identifier \nat a time can be declared in a basic declaration, (4) there are no let blocks of basic expression type. \n (5) Conditionals are not uniformly available at all types [cf. Reynolds, 1981a l.  However, these pragmatic \nfeatures are all in- essential for our purposes since they can be simulated at the level of uninterpreted \nprogram schemes by commands already in PROG, i. e., each of the constants corresponding to these con- \nstructs is directly X-definable in terms of the con- stants already introduced. Therefore they raise \nno semantical or proof-theoretical issues beyond those already treated. An important feature in actual \nALGOL-like languages but missing from PROG is that loca-tions can be storable subject to restrictions \n(as in ALGOL 68) to ensure local storage dis-cipline is preserved. Another extension improv- ing uniformity \ninvolves introducing ~-exp types for a other than int and Ioc (with a correspond- !ng block let z a be \nProcT a'exp in ProcT/~'exp tel). Other significant language features compatible with ALGOL-like principles \nbut omitted from PROG include exit control, arrays and user-defined data-types, own-variables, polymorphism, \nimplicit coercion (overloading) and concurrency. These will have to be the subject of future studies. \nReferences H. P. Barendregt, The Lambda Calculus: Its Syn- tax and Semantics, Studies in Logic 103, North \nHolland, 1981. B. Courcelle, Fundamental properties of infinite trees, Theoretical Computer Science 25, \n1983, 95- 170. W. Datum, The IO- and OI-hierarchies, Theoreti-cal Computer Science 20, 1982, 95-207. \nW. Datum and E. Fehr, A schematological ap- proach to the procedure concept of ALGOL-like languages, \nProc. 5ieme colloque sur lea arbres en algebre et en programmation, Lille, 1980, 130-134. J. De Bakker, \nMathematical Theory of Program Correctness, Prentice-Hall International, 1980, 505pp. J. H. Gallier, \nn-Rational algebras, Parts I and II, Technical Report, Dept. of Computer and Infor- mation Sciences, \nUniv. of Pennsylvania, Philadel- phia, 1983, 55pp. and 65pp. M. J. C. Gordon, The Denotational Description \no.f Programming Languages, Springer, 1979. I. Guessarian, Algebraic Semantics, Lecture Notel in Computer \nScience 99, Springer, 1981, 158pp. I. Guessarian, Survey on some classes of interpretations and some \ntheir applications, Laboratoire Informatique Theorique et Program- mation, 82-46, Univ. Paris 7, 1982. \nJ. Y. Halpern, A good Hoare axiom system for an ALGOL-like language, ACIVl Syrup. on Principles of Programming \nLanguages, 1983 (this volume). R. Hindley, B. Lercher, and J. Seldin, Intro-duction to Combinatory Logic, \nLondon Math. Soc. Lecture Note Series 7, Cambridge University Press, 1972. J. Lambek, From X-calculus \nto Cartesian closed categories, To H.B. Curry: Essays on Combinatory Logic, Lambda Calculus and Formalism, \nJ. P. Sel- din and J. R. Hindley, eds., Academic Press, 1980, 375-402. P. J. Landin, A correspondence \nbetween ALGOL 60 and Church's lambda notation, Comm. ACM 8, 1965, 89-101 and 158-165. H. Langmaack and \nE. R. Olderog, Present-day Hoare-like systems, 7thlnt'l. Coll. Automata, Languages, and Programming, \nLecture Notes in Computer Science 85, Springer, 1980, 363-373. J. Meseguer, Completions, factorizations \nand colimits of w-posets, Coll. Math. Soc. Janos Bolyai 26. Math. Logic in Computer Science, Sal-gotarjan, \nHungary, 1978, 509-545. A. R. Meyer, What is a model of the X-calculus? Information and Control 52, 1982, \n87-122. R. E. Milne and C. Strachey, A Theory of Pro- gramming Language Semantics, 2 Vols., Chapman and \nHall, 1976. P. Naur et al., Revised report on the algorithmic language ALGOL 60, Computer J. 5, 1963, \n349- 367. M. Nivat, On the interpretation of recursive polyadic program schemes, Symposia Mathe. matica, \n15, Academic Press, 1975, 255-281. E. R. Olderog, Sound and complete Hoare-like calculi based on copy \nrules, Acta Informatica 16, 1981, 161-197. F. J. Oles, Type algebras, functor categories, and block structure, \nComputer Science Dept, Aarhus Univ. DAIMI PB-156, Denmark, Jan. 1983. G. D. Plotkin, A powerdomain construction, \nSIAM J. Comp. 5, 1976, 452-487, 1976. G. D. Plotkin, Lambda-definability in the full type hierarchy, \nin To H. B. Curry: Essays on Com-binatory Logic, Lambda Calculus and Formalism, J. P. Seldin and J. R. \nHindley, eds., Academic Press, 1980, 363-373. G. D. Plotkin, A Powerdomain for countable non- determinism, \n9 t~ Int'l. Coll. Automata, Lan-guages, and Programming, Lecture Notes in Com- puter Science 140, Springer, \n1982, 412-428. J. C. Reynolds, The essence of ALGOL, Interna. tional Symposium on Algorithmic Languages, \nde Bakker and van Vliet, eds., North Holland, 1981a, 345-372. J. C. Reynolds, The Craft of ProgramminwPren- \ntice Hall International Series in Computer Science, 1981b, 434pp. J. C. Reynolds, Idealized ALGOL and \nits specification logic, Syracuse University, Technical Report 1-81, 1981c. D. S. Scott, Lectures on \na Mathematical Theory of Computation, Technical Monograph PRG-19, Oxford Univ. Computing Lab., 1981. \nD. S. Scott, Domains for Denotational Semantics, 9 th Int'l. Conf. Automata, Languages, and Pro- gramming, \nLecture Notes in Computer Science 140, Springer, 1982, 577-613; to appear, Informa-tion and ControL M. \nB. Smyth, Powerdomains, J. Computer and System Sciences 16, 1978, 23-36. R. Statman, Logical relations \nand the typed lambda-calculus, to appear, 1982. J. E. Stoy, Denotational Semantics: The Scott. Strachey \nApproach to Programming Language Theory, MIT Press, Cambridge, Massachusetts, 1977. R. D. Tennent, Principles \nof Programming Lan- guages, Prentice-Hall International Series, 1981, 271pp. B. A. Trakhtenbrot, J. Y. \nHalpern, and A. R. Meyer, From denotational to operational and axiomatic semantics: an overview: Proc. \nLogics of Programs, Carnegie-Mellon Univ., Pittsburgh, 1983, to appear, Lecture Notes in Computer Science, \nD. Kozen and E. Clarke, eds., Springer, 1983. 257  \n\t\t\t", "proc_id": "800017", "abstract": "<p> <italic>Denotational semantics for an ALGOL-like language with finite-mode procedures, blocks with local storage, and sharing (aliasing) is given by translating programs into an appropriately typed &#955;-calculus. Procedures are entirely explained at a purely functional level - independent of the interpretation of program constructs - by continuous models for &#955;-calculus. However, the usual (cpo) models are not adequate to model local storage allocation for blocks because storage overflow presents an apparent discontinuity. New domains of store models are offered to solve this problem.</italic> </p>", "authors": [{"name": "Joseph Y. Halpern", "author_profile_id": "81100537160", "affiliation": "IBM Research, San Jose", "person_id": "P149011", "email_address": "", "orcid_id": ""}, {"name": "Albert R. Meyer", "author_profile_id": "81100572937", "affiliation": "Laboratory for Computer Science, MIT", "person_id": "PP15036546", "email_address": "", "orcid_id": ""}, {"name": "B. A. Trakhtenbrot", "author_profile_id": "81100515810", "affiliation": "Dept. of Computer Science, Tel Aviv Univ.", "person_id": "PP31034896", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800017.800536", "year": "1984", "article_id": "800536", "conference": "POPL", "title": "The semantics of local storage, or what makes the free-list free?(Preliminary Report)", "url": "http://dl.acm.org/citation.cfm?id=800536"}