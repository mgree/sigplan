{"article_publication_date": "01-15-1984", "fulltext": "\n Grids: A New Program Structuring Mechanism Based on Layered Graphs Harold L. Ossher Computer Science \nDepartment Stanford University, Stanford, CA94305 1. Introduction The structure of a computer program, \nand the extent to which that structure is visible, dramati- cally affect the clarity of the program. \nClarity, in turn, affects other important attributes such as reliability and modifiability. For this \nreason, structure and the specification of structure are of central importance to programming. Programming \nlanguages contain structuring mechanisms to provide a framework within which to structure programs. One \nof the primary pur- poses of a structuring mechanism is to document structure in a clear and concise \nmanner. Equally important, the structuring mechanism must en-force the documented structure, ensuring \nthat the program does indeed conform to the structure specified. A structuring mechanism should also \nbe sufficiently rich to cope with the wide diversity of program structures that rise in large systems. \nTradition ! structuring mechanisms fall into two categories: nesting schemes and mechanisms in- volving \nseparate modules. Nesting schemes can specify and enforce hierarchical structures, and document them \nreasonably well. They cannot, however, specify more general structures. Mechanisms involving separate \nmodules can specify and enforce ~rbitr ry structures, provided module interconnections are specified \nexplicitly by some means such as import and export lists. They do not, however, make the specified structure \nreadily visible, primarily due to excessive com-plexity and lack of explicit grouping. The tradi-tional \nmechanisms thus have largely complemen- tary strengths and weaknesses, which suggests the possibility \nof single mechanism that has the strengths of both: the ability to specify and enforce Permtnnton to \ncopy vithout fee all or part of thin material il granted provided that the copien are not made or distributed \nfor direct comaercinl mivantage, the ACll copyright notice and the title of the publi-cation and itn \ndate appear, and notice in given that copying in by permission of the Ansociation for Computing Machinery. \nTo copy otherwine, or to republish, requires fee and/or npecific perainelon. &#38;#169; 1983 ACM 0-89791-125-3/84/001/001 \n! $00.75 11 arbitrary structures, and to document them in a clear and concise manner. This paper proposes \nsuch a mechanism, called the grid. The grid mechanism was designed as part of the Fable language for \nspecifying integrated circuit fabrication processes [7]. Such processes, as well as the fabrication equipment \nthat performs them, are best described at multiple levels of abstraction. At the same time, each step \nof a process and each piece of equipment is complex and structured, and is best treated as n object. \nA Fable program is thus an object-oriented program in which objects are described at multiple levels \nof abstraction. A natural and convenient model for the structure of such a program is a layered graph, \nin which each layer corresponds to an abstraction level. Layered graph structures occur whenever levels \nof abstrac- tion are used; other areas in which they are com- mon are VLSI design and communication protocols. \nThe grid mechanism is based on the layered graph model, and is able to specify ar-bitrary layered graph \nstructures in a clear and con- cise manner. The grid mechanism has a number of additional important features, \nmany of them novel. It is able to specify multiple views of objects, multiple im- plementations of specifications, \nand multiple relationships between the parts of a program. It is language-independent, and can be used \nunchanged to specify the structure of programs in different programming languages. A grid is textually \nsup rate from the program whose structure it specifies, so it can be created before the program is written, \nand then used to check that the develop- ing program conforms to the specified structure at all times. \nThese features enhance the usefulness of the grid, though its chief advantage rum ins its ability to \nspecify layered graph structures in a con- cise and read hie fashion. The remainder of this section introduces \nsome important concepts and terminology, as well as a This research was supported in part by the Defense \nAd- vanced Research Projects Agency under Contract No. MDA 003-80-C-0432. running example that is used \nthroughout this paper. Section 2 describes other work related to the grid mechanism. Section 3 then discusses \nthe specification of layered graph structures, and sec- tion 4 gives details of the grid mechanism itself. \n 1.1. Structure and Structuring Mechanisms A computer program is a collection of textual constructs, \nsuch as modules, procedures, state-ments and expressions. The structure of the program is determined \nby the organisation and in-teractions of its constructs. There are many dif- ferent types of interaction \nbetween constructs: one construct may contain another, refer to a type defined in another, invoke a procedure \ndefined in another, etc. It is convenient to characterise each type of interaction as a separate relation, \nallowing familiar notation and terminology to be used. The task of a structuring mechanism is to specify \nthe organisation and interactions of program constructs. The most critical issue in the specification \nof oiganisation is grouping: identifica-tion of collections of constructs that form cohesive groups is \na great aid to apprehending structure. The most critical issues in the specification of in- teractions \nare generality and complezity: it must be possible to specify the wide variety of inter- actions that \noccur in large programs, yet in such a way that the specification is not unintelligibly complex. This \npaper is concerned with structuring mechanisms appropriate for use with object-oriented programs in which \nmultiple views of ob- jects are specified. Such programs describe and manipulate a large number of objects, \nsome or all of which are described from multiple points of view. For example, objects in an electronic \nmail system include messages and name tables; from the point of view of the user a message is a piece \nof text, from the point of view of the mail system it might be a structure consisting of a source, routing \ninformation, time stamp and text, and from the point of view of the underlying network software it might \nbe a collection of packets. Multiple views of objects arise whenever multiple levels of abstrac- tion \nare used: each level of abstraction corresponds to a viewpoint. Multiple views also arise when a shared \nobject is used in different ways by different users: each user has its own view of the shared ob- ject. \nEach view of an object is specified by means of a programming language construct called a specification, \nand is implemented, in terms of other views of the same object, or perhaps in terms of other objects, \nby means of one or more con-structs called bodies. Examples of specifications are Ada package specifications \nand Mesa interface modules; examples of bodies are Ada package bodies and Mesa program modules [6, 12]. \nThe no-tion of separating specification and implemerit~/tion was pioneered in the data abstraction languages \nCLU and Alphard, and has since been widely adopted [5, 13]. Multiple bodies associated with a single \nspecification describe alternative implemen- tations of that specification. A single specification together \nwith all the bodies that implement it are collectively referred to as a unit. The structure of an object-oriented \nprogram with multiple views is determined by the organisation and interactions of its units. Fable programs \ndescribing integrated circuit fabrication processes are object-oriented programs with multiple views, \nand the paper introducing Fable contains some further discussion and ex-amples of such programs [7]. \nFurther discussion and an extensive bibliography appear in the paper introducing the Paragon language \n[11]. Multiple views of objects can be specified in Paragon using refinement of specifications, and the \nlanguage al- lows great flexibility in specifying their implemen- tation,   osaI DB Figure 1-1, Two \nPackages Sharing a Database Example 1-1: An object-oriented program with multiple views is described \nhere and used as a running example throughout this paper. It is a simple case of a shared resource being \nused in different ways by different users. The program consists of ten objects: An extremely simple, \nin-core database, db, consisting of a network of named, at-tributed nodes. It provides operations create, \ndestroy, fetch and store, and sup- ports attributes p, q and r. * Two users of db, a and b: a can use \nall the operations provided by db, and can manipulate properties p and q; b can use the fetch and store \noperations only, and can manipulate properties p and r. Two objects, hash and random; used to implement \ndb. , Objects values, alists, lists, pairs and strings that export data types for general use and are \nreferred to as utilities. The interactions between a, b and db are il-lustrated in fig. 1-1. Three different \nviews of db are thus present in this example: e The complete view, DB, containing details of all the \noperations and attributes. 12  a's view, DBA, containing just those as-pects of db that are visible \nto a.  b's view, DBB, containing just those as-pects of db that are visible to b.  Three units describe \nthese views, each consist- ing of an Ads package specification and a single body. The specifications \nare shown in fig. 1-2. The bodies of DBA and DBB implement their views in terms of the complete view, \nDR, and the body of DB implements the complete view in terms of the objects hash, values, alist~ and \nstrings. Each of the other objects is described by means of a single unit: the names of these units are \nA, B, 1t, R, V, AL, L, P and S, corresponding to objects a, b, hash, random, values, aliats, lists, pairs \nand strings, respec-tively. These units are not shown, due to lack of space. with V, S; use V, S; package \nDB is type attribute is (p, q, r); procedure create(node: string); procedure destroy(node: string); function \nfetch(node: string; star: attribute) returns value; procedure store(node: string; attr: attribute; yah \nvalue); end DB; with V, S; use V, S; package DBA is type attribute is (p, q); procedure create(node: \nstring); procedure destroy(node: string); function fetch(node: string; attr: attribute) returns value; \nprocedure store(node: string; afar: attribute; val: value); end DBA; with V, S; use V, S; = package DBB \nis type attribute is (p, r); function fetch(node: string; attr: attribute) returns value; procedure store(node: \nstring; star: attribute; val: value); end DBB; Figure 1-2: Specifications of DR, DBA and DBB Two relations \non units are of importance in this example, and indeed in most programs in which specifications and implementations \nare separated. The relation spec uses relates the unit containing a specification to all units used by \nthat specification, and the relation body uses relates the unit containing a body to all units used by \nthat body. These relations are il- lustrated graphically in figs. 1-3 and 1-4, primarily to show their \ncomplexity and the in- adequacy of direct graphical representations. Though this program is almost trivial \nby modern standards, the traditional structuring mechanisms cannot specify its structure both accurately \nand clearly. Nesting schemes cannot specify its structure accurately, because it is impossible to arrange \nthe units A, B, DBA, DBB and DB in such a way that A can access only DBA, B can access only DBB, and \nyet DBA and DBB can access DR. Separate packages with import or export lists can specify its structure \naccurately, but not clearly: the im- port or export lists are a direct textual encod- ing of the graphs \nin figs. 1-3 and 1-4, and like the graphs are sufficiently complex that their structure cannot be readily \napprehended. \u00ae \u00ae\u00ae Figure 1-3: The spec uses Relation Figure 1-4: The body use8 Relation I.S. Graphs \nPlanar graphs are commonly used to model and illustrate program structure, as in the example above. The \nnodes of the graph represent program units, and the edges represent interactions between units. Since \nmultiple interactions between units can occur and each is characterised by a relation, the following \ndefinition of a planar graph is ap-propriate in the context of structuring mech-anisms: A planar graph \nis a pair {N, R), where N is a set of nodes, and R is a set of relations on N specifying interactions \nbetween the nodes. A more natural and convenient model for the structure of an object-oriented program \nwith mul- tiple views, however, is a layered graph. A layered graph consists of a number of horizontal \nlayers, each of which is a planar graph. Each node in the graph represents the unique unit describing \na specific object from a specific point of view. Each 13 layer corresponds to a viewpoint, and is called \na view: the nodes in a view describe different objects, but from the same point of view. All nodes in \nthe various views that describe a single object can be arranged on a vertical plane orthogonal to the \nviews. Each such plane corresponds to an object, and is called a group: the nodes in a group describe \nthe same object, but from different points of view. Edges in the graph represent interactions between \nunits, and can cross group and view boundaries ar- bitrarily. Example 1-I= A layered graph that models \nthe structure of the shared database program is shown in fig. 1-5. There are four views, called a, b, \ndb and u. View a specifies the program structure from A's point of view: it contains nodes representing \nA and all units used by A, and shows how they interact. Similarly, views b and db specify the program \nstructure from B and DB's points of view. The fourth view, u, contains nodes representing the utility \npack- ages, and shows how they interact. There are ten groups, called a, b, db, h, r, v, al, l, p and \na, corresponding to the objects a, b, db, hash, ran- dom, values, alists, lists, pairs and strings, respectively. \nAll nodes and all views are shown in full, but only four groups, in order to keep the diagram intelligible. \nThe omitted groups h and r contain just single nodes, and the omitted groups v, al, l and p are similar \nto group s. The arrows represent pairs in the relation body uses; for simplicity, this single relation \nis used in all examples appearing before section 4.2, which deals with the simultaneous specification \nof multiple relations. As expected from the description of the ex-ample, three different views of the \ndatabase are present in the graph. Less expected, perhaps, are the multiple views of the utilities. Consider \nthe utility strings, which is typical. Its group, a, contains four nodes, corresponding to four units \ncalled SA, SB, SDB and S. Each unit describes a distinct view of strings. Since all these views are in \nfact identical, they were not distinguished in the original description of the program; they are introduced \nhere in order to ensure that each layer in the graph presents a complete picture of the program structure \nfrom the appropriate point of view: since A, for ex- ample, uses otrings, a view of strings must aw pear \nin layer a. Each of SA, SB and SDB con-sists of the same specification as $, and a trivial body implementing \nthe specification in terms of S. These bodies account for the arrows lying within group 8 in the figure. \n(An alter- native approach is also possible, in which only a single view of each utility, the u view, \nis present, and users in all views use this single view. No additional units are introduced in this case, \nbut a view can no longer be said to con- tain a complete picture of the program struc-ture from a particular \npoint of view.) In this example, each interaction crosses ei- ther a group boundary or a view boundary, \nbut not both. This is quite common in well-structured layered graphs, but is not necessarily the case. \nIn general, interactions can be ar-bitrary. {An example of this more general be- haviour occurs if the \nalternative approach to the handling of utilities is used: in that case, all arrows from user nodes to \nutilities lead down to the u view, crossing both group and view boundaries.) b db h r v at t p s b db \nh r v I1! I p I Figure 1-6: Layered Graph A layered graph as used in this context is defined as follows: \n A layered graph is a quadruple {N, (7, V, R), where N is a set of nodes, G and V are par-titions of \nN, and R is a set of relations on N specifying interactions between the nodes. The members of G are called \ngroups, and the mem- bers of 1:, views. The partitions G and V are such that the intersection of any \ngroup and any view contains either zero or one node. An important consequence of the restriction on G \nand V is that any node can be uniquely identified by specifying its group and view. The syntax g/v is \nused to denote the node in group g and view v. The only formal difference between the layered 14 graph \n(N, G, V, R) and the planar graph (IV, R)is that the groups and views are identified explicitly. This \nis a crucial difference, however, as specifica- tion of grouping is one of the most important aspects \nof documenting structure. 2. Related Work Little research on structuring mechanisms as such has been \ndone by programming language designers since the advent of the traditional mechanisms. Designers have \ntended, instead, to concentrate on other related aspects of language design, most notably abstraction \nmechanisms, and to use variations of nesting and separate modules for program structuring. Ada, for example, \nuses a combination of static nesting and separate modules with explicit import lists (with clauses) [12]. \nThe recent work most closely related to the grid comes from the areas of version control and 8oftware \nengineering. Version control is con-cerned with the problem of maintaining consis- tency in a software \nsystem under development. The issues of version control and structuring mechanisms are largely orthogonal, \nsince a struc-turing mechanism deals only with a single version of a program, and only with the source \ncode, whereas a version control system deals with mul- tiple versions of a program, including intermediate \nand object files. Version control systems are con- cerned with program structure, however. The cul- mination \nof recent work in the area of version con- trol is the thesis work of Eric Schmidt on control- ling the \nsoftware development of Cedar [1, 10]. Schmidt developed two languages for describing in- terconnections \nbetween Cedar modules: simple description file8 (DF files) and the much more sophisticated system modeling \nlanguage, SML. Descriptions in these languages are used very effec- tively to manage multiple versions \nof software and to control releases, but they do not, and are not intended to, document program structure \nin a readily perceivable fashion. Another version con- trol system of interest is PIE, which was designed \nfor the Smalltalk environment [3, 4]. It has a dis- tinctive feature, perspectives, that allows objects \nto be viewed in different ways. Software engineering is concerned with systems analysis and design, as \nwell as with programming, and notations and methodologies have been developed for use in these processes. \nThey tend to be greatly concerned with documenting structure, but not with enforcing it. The most complex \nand sophisticated such notation is Structured Analysis (SA) [2, 8, 9]. SA is not intended as a program \nstructuring mechanism, and its diagrammatic na-ture makes it unsuitable for automatic processing as it \nstands. It also has no means, other than dis- cipline, of enforcing the specified structure. 15  3. \nSpecifying Layered Graph Structures The interactions between nodes in a layered graph can be so complex \nthat any direct represen- tation of them would be unintelligible. The processes of factorisation, clu~tering \nand ap- proximation, described in this section, provide a means of specifying them clearly. Only interactions \ndescribed by a single relation are considered here; section 4.2 deals with the specification of multiple \nrelations. 3.1. Factorisation Interactions between nodes in a layered graph can be arbitrary, and can \ncross group and view boundaries. However, the organisation of the layered graph suggests the possibility \nof factoring these interactions into two orthogonal components: interactions between groups, and interactions \nbe- tween views. Two groups (views) interact if any node within the first interacts with any node within \nthe second; the interactions between groups and views thus subsume all interactions between nodes. This \ncan be illustrated by adding a new view, called the group graph, that specifies the in- teractions between \ngroups, and a new group, called the view graph, that specifies the interactions be- tween views. The \ngroup and view graphs are im-portant, because they form the basis of an effec-tive means of specifying \nthe interactions within a layered graph. Example 3-1: The group and view graphs of the shared database \nexample are illustrated within the framework of the layered graph in fig. 3-1. Note that, even in this \nsmall example, they are considerably simpler than the original layered graph. The factorisation process \nis now described more rigorously. Let L ~ (N, G, V, R) be a layered graph, and let Ro E R. Then relations \nRg and Rv on groups and views, respectively, can be derived from L and Ro as follows: Rg---- { (g=, g=) \nE G x G I 3 Vl, v26- V such that (gl/vl, g2/v2) 6. Ro } Rv = ( (v~, v2) 6- v x v l 3 g~, o2 6- G such \nthat (gl/vl, g2/v2) 6- Ro } Rg is called the group relation and describes the group graph; Rv is called \nthe view relation and describes the view graph. A new relation on nodes can be derived from Rg and Rv \nby attributing to every node all the relationships in which its group and view are in-volved. The new \nrelation is referred to as the derived relation after factori~ation, Rf, and is defined as follows: a \nb db h r v sl I p s views b db h \u00a2 v al t p s views b clb h r v at t p S views Figure 3-I: Group and \nView Graphs Rf = { (gl/Vl, g2/v2) E N X N I (gl, g2) E Rg and (vl, v2) ERv }  A consequence of this \ndefinition is that Rf ~ Ro. Further define Df : Rf -Ro Then Df is the set of interactions specified by \nRf that are not present in Ro, and is referred to as the set of deviation8 associated with the factorisation \nprocess. Example 3-2: The derived relation after factorisation in the shared database example is illustrated \nwithin the framework of the layered graph in fig. 3-2. In order to keep the diagram intelligible, only \na few nodes appear, but all in- teractions between those nodes are shown. Dotted arrows represent interactions \nthat are present in body uees, as canbe seen by compar- ison with fig. 3-1. Solid arrows represent devia- \ntions. The deviations shown fall into three categories: 1. Interactions that cross both group and view \nboundaries. 2. Interactions between utilities. 3. The interaction between db/b and alists/b. This is \na representative sample of the types of deviations that are frequently a~sociated with the factorisation \nprocess.  16 a b db h r v at L p s views Figure 3-2\" Derived Relation after Factorisation The set of \ndeviations, D f, is a set of pairs of nodes that do not interact in the original layered graph. It can \nbe characterised by a sequence of one or more qualifiers, such as the following: The qualifier except(e \nz, s2), where s I and 8 2 are sets of nodes, is used to specify deviations directly. It states that all \npairs in the set { (hi, n2) E Rfl n: E 8z and n 2 E e2 } are deviations. Both e 1 and 8 2 can be any \nof the following: a node name denoting a singleton set; a group, view or cluster name denoting all nodes \nin that group, view or clusterl; a set of any of the above; or an as-terisk, denoting all nodes in the \ngraph. The qualifier only(v 1, v 2, S), where S is a set of pairs of nodes, is used to specify that \nthe only interactions between nodes in views v 1 and v 2 are those specified by S. More precisely, it \nstates that all pairs in the set { (nz, n2) E Rf[ nl E vz, n2 C v2 and  -2) s } are deviations. As a \nconvenient abbreviation, vz and/or v~ can be replaced by sets of views,  IA cluster is a set of groups, \nviews or clusters; see section 3.2. including clusters and asterisks. The qualifier can also be used \nin analogous fashion with groups replacing views. The qualifier same-group(v 1, v2), Vl ~ vs is used \nto express succinctly that no interactions between nodes in views v I and v2 cross group boundaries. \nMore precisely, it states that all pairs in the set { (gl/vl, g2/v2) E Rfl gl ~ g2 } are deviations. \nAs a convenient abbreviation, either or both of v I and v 2 can be replaced by sets of views, including \nclusters and asterisks. The qualifier same-view{gl, g2) is analogous. The qualifier home-view{g, v} is \nused to specify that all views of group g, other than g[v itself, interact with g/v only. More pre-cisely, \nit states that all pairs in the set {(g/vl, g2/v2) e Rf l V 1 ~ Vand g2/v2 ~ g/V } are deviations. As \nan abbreviation, g can be replaced by a set of groups. Qualifiers handle many important special cases, \nand allow even a large set of deviations to be characterised succinctly. Example 3-3\" Each of the three \ncategories of deviations identified in example 3-2 can be characterised by means of a single qualifier, \nas follows: 1. same-group(*,*) and/or same-view(*,*} 2. home-group({v, utilities}, u), where util-ities \nis a cluster consisting of groups al, l, p and s (see section 3.2). 3. exeept(db/b, alists/b} It follows \nfrom the definitions of Rf and Df that Ro ffi Rf -. Df Since Rf can be derived from Rg and Rv in a simple \nand direct manner, and Df can be charac- terised by a sequence Qf of qualifiers as described above, it \nfollows that Ro can be accurately and completely specified by the triple {Rg, Rv, Q f}, which is referred \nto as the factored form of Ro. This is the key result concerning factorisation. Specifying relations \nin factored form has the fol-lowing important advantages: Rg and Rv are usually much simpler than Ro, \nand Qf is usually short. The factored form of Ro is therefore usually a more concise specification of \ninteractions than Ro itself.  Identifying and exploiting logical groupings of nodes is, perhaps, the \nmost important factor in documenting structure. The factored form specifies interactions in terms of \nthe two im-portant groupings, groups and views.  If no qualifiers are required, the layered graph is \nreferred to as regular; the simpler the se-  quence of qualifiers, the more nearly regular the graph. \nRegular layered graphs are par-ticularly easy to comprehend, and can be specified particularly well using \nthe technique of factorisation. Specifying interactions in factored form encourages the programmer in \na practical way to strive for regularity, yet provides a means of handling non-regular structures when \nthey are truly necessary. The first step in specifying the structure of a layered graph is therefore \nto specify the inter-actions in factored form, as a group graph, a view graph and a sequence of qualifiers. \nThe second step is to specify the group and view graphs in a clear and concise manner, as described in \nthe next sec-tion. 3.3. Clustering The group and view graphs produced by the process of factorisation \nare planar graphs. Direct representations of planar graphs, such as import or export lists, do not work \nwell because they are too complex in the case of large graphs, and they fail to specify grouping. The \nprocess of clustering al-lows planar graphs to be specified in a concise and readabJe fashion, largely \nas a result of making grouping explicit. It is similar to the process of grouping pieces of program into \nmodules. Consider a complex planar graph consisting of many nodes, and involving many interactions be- \ntween the nodes. The process of clustering involves grouping the nodes into clusters, and replacing all \ninteractions between nodes in different clusters by interactions between the clusters themselves. The \nresult is a graph of clusters, each of which is a graph of nodes. Example 3-4: Consider applying clustering \nto the group graph of the shared database ex-ample (fig. 3-1). There are various ways of grouping the \nnodes (groups) into clusters. Since a and b in this example are users, and the other groups exist solely \nto provide them with the services they require, one grouping that im-mediately comes to mind consists \nof just two clusters, users and servers, as follows: users = { a,b } servers = { db, hash, random, values, \nalists, lists, pairs, strings } Fig. 3-3 shows these clusters. The result of replacing all interactions \nbe-tween nodes in different clusters with inter-actions between the clusters themselves is shown in fig. \n3-4. The clustering process can be repeated recur-sively. If the graph of clusters is complex, it can \nbe clustered further: this is the bottom-up approach. Alternatively, any subgraph that is complex can \nbe 17 clustered: this is the top-down approach. Which-ever approach is used, the result is an hierarchy \nof graphs in which all the graphs are simple and all interactions are between siblings in the hierarchy. \nFigure 3-3: Group Graph Showing Clusters I I / \\ I I / \\ I I / \\ Figure 3-4: Partially Clustered Group \nGraph Example &#38;-St The cluster utilities in fig. 3-4 is sufficiently complex to warrant recursive \nclustering. Once again, many different group-ings are possible; one possible result is shown in fig. \n3-5. All subgraphs are now sufficiently simple that no further clustering is necessary. The clustering \nprocess is now described more rigorously. Let P ----(N, R) be a planar graph, and let Ro E: R. The first \nstep of the clustering process consists of choosing a partition C of N into dusters Cl, C2 ..... Ck of \nnodes. Then Ro can likewise be partitioned into sets Rii , i, j ~ 1, 2 ..... k, as follows: n,j = { (hi, \nnil 6. no I n, ~ C, and ni E 6'/} For each i, the pair S i ~ (Ci, Ril) is a closed subgraph of P. Let \n I I / \\ I I I N / / \" // \\   it I ill~ \\\\ Figure ~-5i Fully Clustered Group Graph I I / \\ I I i \n\\ f I / \\ G Figure 3-6t Derived Relation after Clustering Sf { S~l i---1,2 ..... k} A relation on S, \ncalled the subgraph relation, Rs, can be derived from the Rii, i ~ j, to describe the relationships between \nthese subgraphs, as follows: ns = { (S~, Sj) I i # J and Rii Y~ ~ } Note that Rs is, by definition, non-reflexive. \nRs is a relation on subgraphs, whereas Rii and Ro are relations on the original nodes. A new rela- tion \non the original nodes, called the derived rela- tion after clustering, Re, can be derived from S and \nRs as follows: nc = U R. u { (n~, n i) I i # ~, ,,~ e e~, nj e Cj and (s~, si) e Rs } 18 Thus, if two \nsubgraphs are related by Rs, then all nodes in the first are related to all nodes in the second by Re. \nA consequence of this definition is that R\u00a2~ Ro. Further define Dc ~ Re -Ro Then Dc is the set of interactions \nspecified by Re that are not present in Ro, and is referred to as the set of deviations associated with \nthe clustering process. Example 3-6: Consider the clustering process described in example 3-5 that trans-formed \nthe partially clustered group graph of fig. 3-4 into the fully clustered group graph of fig. 3-5. The \nrelation after clustering is shown within the framework of the partially clustered graph in fig. 3-6. \nLight arrows represent inter- actions that are present in the original graph, as can be seen by comparison \nwith fig. 3-4. Heavy arrows represent deviations. The devia- tions arise because the derived relation \nafter clustering specifies that db interacts with all nodes in clusters hash and utilities, whereas, \nin the original graph, it interacts with only some of them. This type of deviation is typical of the \nclustering process. As in the case of factorisation, the deviations as- sociated with clustering can \nbe characterised by a sequence of one or more qualifiers. Permissible qualifiers include the following: \n Qualifiers except and only, analogous to those described in section 3.1. The only qualifier in this \ncase is a form of detailed import/export list.  The qualifier ezports(c, E), where E is a set of nodes, \nis used to specify that cluster c exports the nodes in E for use by other clusters, and no others. More \nprecisely, it states that all pairs in the set  { (hi, n2) ERc I nl ~ c and n 2 E c - E } are deviations, \nThe set E can be specified as any combination of individual nodes and cluster names, where a cluster \nname stands for all nodes exported by that cluster. Though the deviations in this case are effectively \nimport/export lists, they apply only to small sub graphs rather than to the entire original graph. Example \n3-7: The deviations identified in example 3-6 can be characterised by the follow- ing sequence of qualifiers: \nonly(db, utilities, {(db, al), (db, s)}); ezports( hash, h} There are many possible abbreviations of \nthis sequence, and many other legitimate sequences. It follows from the definitions of Rc and Dc that \nR ----Re -De Since Rc can be derived from S and Rs in a simple and direct manner, and Dc can be characterised \nby a sequence Qc of qualifiers as described above, it follows that P, the original planar graph, can \nbe specified accurately and completely by the quad- ruple Pc ffi (N, S, Rs, Qc), which is called the \nclustered graph derived from P. This is the key result concerning clustering. Specifying planar graphs \nas clustered graphs has the following impor- tant advantages: The graph of clusters and its subgraphs \nare simpler than the original planar graph. There are two primary reasons for this: multiple in- teractions \nbetween nodes in different clusters are replaced and subsumed by single inter-actions between the clusters \nthemselves, and a single large graph is replaced by a number of smaller graphs. Also, as in the case \nof fac- torisation, the sequence of qualifiers is usually short. The clustered graph is therefore usually \nmore concise than the original planar graph.  The clusters are explicit, and the information they convey \nabout grouping is an important aid to understanding.  If no qualifiers are required, the clustered graph \nis referred to as uniform; the simpler the sequence of qualifiers, the more nearly uniform the graph. \nUniform graphs are par- ticularly easy to comprehend, and can be specified particularly well using the \ntechnique of clustering. Specifying planar graphs in clus- tered form encourages the programmer in a \npractical way to strive for uniformity, yet provides a means of handling non-uniform structures when \nthey are truly necessary.  The clustering process can be applied recursively to the clustered graph, \nPc, itself, and/or to any of the subgraphs within S, eventually producing a fully clustered graph in \nwhich all subgraphs are small and simple. 3.3. Approxlmatlon All deviations add complexity to a structure \nspecification, and therefore reduce its readability. This is true even of deviations that can be charac- \nterised by short sequences of qualifiers, though the simpler their characterisation the less serious \ntheir effect. Also, in many cases the deviations correct trifling inaccuracies that are not material \nto an un- derstanding of the program. The process of ap- proximation exists in recognition of the fact \nthat not all deviations are material, and it consists solely of discarding them. This has the effect \nof approximating the actual structure of the program by a structure that is more regular and/or more \nuniform, and that differs from the actual structure only in unimportant respects. The programmer has \nthe choice of which devia- 19 tions to consider important enough to include, and which to discard. It \nis important to note, however, that discarding deviations can never result in omit- ting from the specification \ninteractions that ac-tually occur in the program. Example 3-8: The only qualifier in ex-ample 3-7 specifies \nthat db does not use certain of the utilities. This type of deviation is typical, and is a good candidate \nfor omission: it is usually sufficient to know that db uses some of the utilities, without knowing the \ndetails. The deviation specified by the ezcept qualifier in ex- ample 3-3 is unimportant for similar \nreasons, and can be discarded.  4. The Grid Mechanism The grid is a program structuring mechanism based \ndirectly on the results of the previous sec- tion. It specifies layered graph structures using the techniques \nof factorisation, clustering and ap-proximation, but in a non-graphical form that is suitable for computer \nprocessing. 4.1. Abstract Syntax A grid corresponds to a layered graph that has undergone the processes \nof factorisation, clustering and approximation. It consists of a two-dimen-sional matriz of units and \ntwo directories, called the group directory and the view directory. The matrix specifies the organisation \nof units into groups and views, the group directory is a non-graphical representation of the fully clustered \ngroup graph, and the view directory is a similar non-graphical representation of the fully clustered \nview graph. The matrix is a projection of the layered graph onto a plane orthogonal to both the groups \nand the views. Each row of the matrix is called a view, and corresponds to a view of the graph: the units \nin a view describe different objects, but from the same point of view. Each column of the matrix is called \na group, and corresponds to a group of the graph: the units in a group describe the same ob- ject, but \nfrom different points of view. Example 4-1: The grid matrix correspond- ing to the layered graph of fig. \n1-5 is shown in fig. 4-1. The matrix is obtained from the graph by dragging each node along the line \nof inter- section between its group and its view until it reaches the front of the diagram. The unit \nnames correspond to those listed in examples 1-1 and 1-2. Note that no arrows are shown in the matrix, \nsince the matrix specifies organisa- tion only; all interactions are specified in the directories. a \nb db h r v Id I p A DBA VA ALA LA PA 8A b S OBB V1B ALB LB PB 88 db OB H R VOB ~OB LOB POB SOB u V AL \nL P S Figure 4-1: The Matrix Each directory is a tree of named node8 representing a clustered graph. \nIn the group direc- tory, leaves represent groups; in the view directory they represent views. In both \ncases, internal nodes represent subgraphs produced during the clustering process. Interactions and deviations \nare rep-resented by means of information in fidd8 at-tached to directory nodes; direct representations \nof qualifier sequences, not sets of pairs, are used to specify deviations. A wide variety of other infor- \nmation, including documentation, can also be placed in these fields. A directory thus resembles an hierarchy \nof configuration files in C/Mesa, or of DF files in Schmidt's scheme, but contains more information [6, \n10]. Example 4-2z Group directories cor-responding to the group graphs in figs. 3-4 and 3-5 are shown \nin figs. 4-2 and 4-3. Interactions are illustrated by means of arrows; qualifiers specifying deviations \nare not shown. Note that the final group directory contains far fewer ar- rows than the partially clustered \none, making it easier to read. Also, more grouping information is given, which is an important aid to \nunder-standing. Indeed, the hierarchical structure of the directories, even without the arrows and qualifiers, \ntells a good deal about the structure of the group graph. For completeness, the view directory of the \nshared database example is shown in fig. 4-4. Figure 4-2: Partially Clustered Group Directory 2O Figure \n4-3: The Group Directory Figure 4-4: The View Directory The semantics of the grid are derived directly \nfrom the results of section 3, and are not described further. Though the abstract syntax and seman-tics \nof the grid have been described briefly and in- formally here, the grid can be defined formally as an \nabstract data type, with all details specified in full. Such a type then provides a uniform interface \nfor all software associated with grids, such as editors, compilers and browsers. 4.2. Specifying Structure \nAccording to Multiple Relations Thus far, all discussion of the specification of in- teractions has been \nin terms of a single relation. As indicated in section 1.1, however, multiple rela- tions often exist \nbetween units, and they all con-tribute to the overall structure of the program. Two approaches to specifying \nstructure according to multiple relations are possible. The first approach is to use the same groups, \nviews and clusters for the specification of all the relations; this means that all the relations will \nbe specified within the framework of single grid. The fields associated with directory nodes are, in \nfact, able to specify an arbitrary number of different relations. The second approach is to use multiple, \nseparate grids; this is analogous to multiple indexes associated with a single database. The first ap-proach \nis generally preferable, as it provides a unified description of program structure, but there are cases \nwhen the second is necessary. directory views is view a spec uses u; view b body uses a, db, u; spec \nuses u; body uses b, db, u; view db spec uses u; body uses db, u; view u spec uses u; body uses u; same \ngroup only; end views; directory groups is subdir users body uses servers; subdir servers; end groups; \ndirectory users is group a; group b; end users; directory servers is group db spec uses v, utilities; \nbody uses db, hash, v, utilities; subdir hash; group v spec uses utilities; body uses v, utilities; home \nview u; subdir utilities; end servers; directory hash group h body uses r; group r; exports h; end hash; \ndirectory utilities is group al body uses al, 1, p; group 1 body uses I, p; group p; body uses p; group \ns; body uses s; home view u; end utilities; Figure 4-5: The Directories in Textual Form Example 4-3: \nThe relation spec use8 was introduced in example 1-1, and then ignored. It can easily be specified together \nwith body use8 in a single grid. The directories specifying both relations are shown in textual form \nin fig. 4-5. These directories omit the deviations that were discarded by the process of approximation \nin example 3-8, and others like them, but show the important ones. An Ads-like syntax is used, for compatibility \nwith the rest of the example. 4.3. Syntax The matrix of a grid can be specified using any simple notation \nor naming scheme that is able to specify the position of units in the matrix. The directories can be \nspecified using any notation that is able to represent networks of nodes with ar-bitrary fields in a \nclear and concise manner. Qualifiers can be specified using any notation that provides simple and clear \nabbreviations for all im- portant special cases. 21 If the grid is to be used to structure programs \nin a particular programming language, there is much merit in choosing a syntax for it that is consistent \nwith that of the language. The specification of the grid mechanism in abstract terms facilitates this \nflexibility. Example 4-4: The matrix of the shared database program, illustrated in fig. 4-1, can be \nspecified by a sequence of statements such as db/a -~- DBA; db/b ~ DBB; db/db == DB;... The directories \nare specified using an Ada-like syntax in fig. 4-5; the qualifiers denoting devia- tions are specified \nin a short and simple form that makes their meaning clear. The matrix and two directories constitute \na complete grid describing the structure of the program.  5. Conclusion Many large programs, most notably \nthose struc- tured on the basis of levels of abstraction, have a structure that is most naturally viewed \nas a layered graph. The grid is a convenient mech- anism for specifying such layered graphs. It uses \nthe techniques of factorisation, clustering and ap- proximation in novel ways to achieve clear and concise \ndocumentation of structure, and its seman- tics specify precisely how to determine whether a program \nconforms to the specified structure. A grid is textually separate from the program it structures, and \ncan be used to specify the structure of programs in any language. The grid mechanism has proven convenient \nfor structuring Fable descriptions of integrated circuit fabrication processes and equipment. Experience \nhas yet to be gained of its use in other areas. The importance of abstraction levels as a structuring \nprinciple, and hence of layered graph structures, however, suggests that it will have general useful- \nness and wide applicability. References 1. L.P. Deutsch and E.A. Taft. Requirements for an Experimental \nProgramming Environment. Tech. Rept. CSL-80-10, Xerox Palo Alto Research Center, June, 1980. 2. M.E. \nDickover, C.L. McGowan and D.T. Ross. Software Design using SADT. Proceedings 1977 Annual Conference, \nACM, October, 1977, pp. 125-133. 3. I.P Goldstein and D.G. Bobrow. A Layered Approach to Software Design. \nTech. Rept. CSL-80-5, Xerox Palo Alto Research Center, December, 1980.  d. D.H.H. Ingalls. The Smalltalk-76 \nProgramming System Design and Implementation. Xerox Palo Alto Research Center, 1976. 5. B.H. Liskov, \nA. Synder, R. Atkinson, and C. Schaffert. =Abstraction mechanisms in CLU. = Comm. ACM/~0, 8 (August 1977), \n564-576. 6. J.G. Mitchell, W. Maybury and R.E. Sweet. Mesa language manual. Tech. Rept. CSL-79-3, Xerox \nPalo Alto Research Center, April, 1979. 7. H.L. Ossher and B.K. Reid. =Fable: a pro- gramming language \nsolution to IC process automa- tion problems. = SIGPLAN Notices 18, 6 (June 1983}, 137-148. Proceedings \nof the SIGPLAN '83 SympOMum on programming language issue8 in software systems. 8. D.T. Ross. \"Structured \nAnalysis (SA): A Lan- guage for Communicating Ideas.\" IEEE Trans- action~ on Software Engineering SE-3, \n1 (Jan 1977), 16-34. 9. D.T. Ross and K.E. Schoman, Jr. \"Structured Analysis for Requirements Definition.\" \nIEEE Transactions on Software Engineering SE-8, 1  (Jan 1977), 6-15. 10. E.E. Schmidt. Controlling Large \nSoftware Development In a Distributed Environment. Tech. Rept. CSL-82-7, Xerox Palo Alto Research Center, \nDecember, 1982. 11. M. Sherman. Paragon: Novel Uses of Type Hierarchies for Data Abstraction. Conference \nRecord of the Eleventh Annual ACM Symposium on Principles of Programming Languages, ACM, January, 1984. \n 12. Reference Manual for the Ada Programming Language. U.S. Department of Defense, 1980. 13. W.A. Wulf, \nR.L. Landon, and M. Shaw. \"An introduction to the construction and verification of ALPHARD programs.\" \nIEEE Transadions on Software Engineering SE-~ (1976). 22  \n\t\t\t", "proc_id": "800017", "abstract": "", "authors": [{"name": "Harold L. Ossher", "author_profile_id": "81100333974", "affiliation": "Computer Science Department, Stanford University, Stanford, CA", "person_id": "P107700", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800017.800512", "year": "1984", "article_id": "800512", "conference": "POPL", "title": "Grids: A new program structuring mechanism based on layered graphs", "url": "http://dl.acm.org/citation.cfm?id=800512"}