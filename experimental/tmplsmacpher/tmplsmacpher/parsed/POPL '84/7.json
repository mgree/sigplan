{"article_publication_date": "01-15-1984", "fulltext": "\n STOP ID~BINC [~L]'JJ~ ) OVER INCO~PL]'I~E DATA TYPE GPECIFICATIONU Jean Jn,cq~en Thiel Centre de l{echercho \nen in1nrmatique de N~Jlcy C,~npus Ucientil'iquc I~.P. 239 54506 Vandoeuvre Cedex ~.~Eg~: completeness, \nequation~l theories, data types sI~eci~ications, substitutions, term rewritin~ systems, unification. \n Abstract: We give an algorithm to test the completenecs o~ definitions holdin/~ on the rewrite systems \nthat they generate. At the opposite oI existin~ techni- ques that are very restrictive (left-hand sides \noC definitions must be linear) or rather inc~icient our solution is both powerful and efficient. Also, \nthe e~goritD~n thaZ we cive detects ambigous or/and incomplete definitions and c~n tell you why they \nare ambigous or/and incomplete. It applies too to definitions in presence oI\" equn~ions. I. INTRODUCTION \n Al~ebraic speciTications are powerful tools to del\"ine data structures. They have a large applica- tion \narea (specification of software, programming semantics, programming languages) and can use the Permission \nto copy without fee all or part of this material is granted provided that the copies are not mad\u00a2 or \ndistributed for direct commercial advantage, the ACM copyright notice and the title of the publication \nand its date appear, and notice is given that copying is by permission of the Association for Computing \nMachinery. To copy otherwise, or to republish, requires a fee and/or specific permission. powerful methods \nprovided by equational theories [][UL,80] [}~0,80], liEe inductionless induction. In nearly all e~es, \nespecially in software specifications, one needs to have complete defini-tions for each operator. Unfortunately \nthere are no general alF,orithms to decide completeness. Thus one h~ to de~'ine suf~'icient conditions \nthat worR in practice. ~any criteria have been pro- posed, especially by Huet and Hullot LI~l,8oJ, Uidoit \nLBID,81], Dershowitz LD]~,82J, P~lawitz [PAD,83J. These methods are based on the use oi\" term rewriting \nsystems (T}~ in short): a de,fi- Proving the completeness of definitions is important because, as Huet \nand Hullot demonstrated, it is one of the prerequisites of the induction- less induction method. They \ngive an inductive definition of a sufficient condition of the completeness property. Unfortunately they \nconsider only those definitions whose left-hand sides are linear terms containing only one defined symbol \nat the root. This linearity ~ypothesis is rather restrictive since non-linear definitions are quite \nThis research was supported by ADI under contract no 82/767, and Greco de Programmation.  &#38;#169; \n1983 ACM 0-89791-125-3/84/001/0076 $00.75 76  :]ome examples are presented in :a:u,endi:<. frequenZ \nin practice. ~Dr i,~sZance : false &#38; x = false x &#38; false = false x &#38; X = X is a complete \nbut non-linear definition of ~he boolean 1hnction &#38;. Thus Huet and tlullot's criterion doesn't apply \nhere. Dershowitz introduces t2e notion oi\" a test set for a THS R. The test set that he proposes is composed \nof those terms that contain constructors and variables at a depth equal to the maximum depth of the leZ%-hand \nsides of R and only one defined symbol at the root. A definition is complete if each term in the test \nset of the corresponding TRS is reducible. 2Dr instance the TRS: x + succ(y) -> succ(x+y) x+O->x defined \non the constructors 0 and succ has a test set containing the terms : 0 + 0 , O+ s(x) , s(x) + 0 , s(x) \n+ s(y) . This method ta~es into account definitions that are not left linear, but it is rather inefficient \nsince the test set gene- rally contains many terms (its size increases exponentially with the depth oi\" \nthe left-hand sides of the definitions). Our tecnnique w~_ll be both powert%~ and effi-cient: a test \nset that contains only a few terms is built dynamically by using unification and linearity is not required. \nAlso, our method can be applied to equational TRS [JOU,83] (i.e. mixed sets of rules R and equatioms \nE) simply by using: an E-unification procedure. We have implemented this completeness test in the R~ \nterm rewriting system environment LL~,83J, and it is actually the first time suc~ a test has been implemented. \n2. PRL~5~dIU~d~ We assume that the operators are divided into constructors and defined operators. We \nsuppose that there are at least two constructors. We call: - X the set of variables. - TC the set of \n~]round terms build onlv with constm~tors. - TCX the set of terms built with both const~;c- tots and \nvariables. - Roo~ed...~gr..o.und....}e[ms the terms whose leadin~ th/nction s~nnbol is a defined operator \nand whoSe suDterms are in TC. - Rooted terms the terms whose leadinc function symbol is a defined operator \nand whose subterms are in Tt0(. - Ground instances oi' a term t, denoted G(t), the set of ground terms \nthat are instances oi\" t. This definition extends to a set of' terns : t; = ~sl,...,snl. Thus G(S) = \nU G(~i). instances oi\" its left-hr~d sides. Ve s~v that D Ambil'.ous ~ul v set oi' rooted terms such \ntP~t there :ire at Io:,.~t two terns in ~t tho.t have COr~mom /[ronr~d i,~stances. A,.ib~i'ous snv de~'~uit~o:', \nwhocc left-hand sides ~re an r~nbib,ous set. Domain of a substitution s, denoted D(s), the ~]et OY v:%riables \nx such that s(z) is not variable. 3. I.DIU~ ~AIN CONC],PT We consider only defirdtior,s thqt er~zj be \n regarded as noetherian TRS and we assume that their left-hand sides are rooted terms. This is not too \nrestrictive since in practice it is a natnAral way to specify operations. A definition can De characterized \nby its application domain. Thus it seems natulral to compare definitions by evaluating their application \ndomains. To do this we define an ordering on the sets oi' rooted terms: Given S~ and 82, two sets of \nrooted terms, we say that Sl covers S2, denoted b~ Z ~., if and only if G(S2) ~G(SI ). We sh~9.11 use \nthis ordering to define a simple decision procedure for proving and disproving completeness of definitions. \nIt appears that a definition D oi\" an operator f is complete if its left-hand sides cover the term f(xl \n,... ,xn), where xl, ...,xn are distinct variables. G(f(xl,... ,xn) ) is indeed the set oi\" all rooted \nground terms, l~ut in practice this technique would induce manipula- tions of infinite sets oi\" rooted \nground terms. To Keep clear o~ this drawDack we have introduced the following notions that enable us \nto deal only with finise sets oi\" rooted terms: A complement of a term t of TCX is any finite set T \nof terms oi\" T\u00a39[ such that G(T) ~)G(t) is equal to TC. If t is linear then we can constructively \n de1\"ine a complement of t and we denote it C(t). Let the constructors be ci, ... ,cm and t be the \nterm cj(tl,...,tnj), then : c(t) = l ci(xl .....xn i) s.t. xl,...,xn i EX a i#j I U I cj(tl,...,tK-1,u,x~+1,...,xnj) \ns.t. tK ~X u \u00a3 c(tk) I e.g. let f, g, o be the constructors respectively of arity I, 2, 0 and t be \ng , then C(t) contains /\\ f o x  the terms : f g g g g I /\\ /\\ /\\ /\\ x o x g z f f ~ g I\\ I I I I\\ \nx y x y xy z This notion extends to linear substitutions. Given a linear substitution s, we call complement \nof s the set: C(s) = ~ r s.t. D(r)=i x E D(s) s.t.  s(x) ~X i  Yx E D(r), r(x) ~ C(s(x)) e.g. let \ns be u<~ , then C(s) is the set : /\\ f o i x 11<-o , u<-f , u(-g , u<-g , u<-g , u(-g l /\\ /\\ /\\ \n/\\ x o x g z f I\" I\" g /\\ I l I /\\ x y x y xy z Complements of substitutions have the following property: \n~ery rooted term t and every linear substitution s verify : G(t) = G( U ~r(t)~ ) @G(s(t)). r E c(s) \nThis result is a straight-forward consequence oi\" the above definition. Thus given two rooted terms t' \nand t\" one can build two sets S' and S\" such that: G(t') \\ G(t\") = G(3') and G(t\") \\ G(t') = G(S\") simply \nby applying the substitutions of C(s) on t' and t\". On the other hand suppose that t' and t\"  can be \nunified Dy a substitution s, i.e. s(t') is equal to s(t\"). The ground instances of the unified term, \ni.e. s(t') or s(t\"), are equal to the common part oi\" t' and t\"'s ground imstances. For instance consider \nthe terms t' = f(o,x) and t\" = f(x,o) build on the constructors o and h of arities 0 and I. One can unily \nthem with the substitution x<-o. Its complement is x<-h(y). Thus S' is the set { f(o,h(y)) ] and S\" is \nthe set f(h(y),o) J. Also, f(o,o) is the only ground instance of the unified term of t' and t\". We sD~l \nuse this result to define a decidable covering test Zbr sets of rooted terms that can also be regarded \nas a completeness test for definitions as we shall see. First let us look at t~e IDllowing proposition \nwhich is the basis of our algorithm : Assume A is an unambigous set of rooted terms, ~ is a set of rooted \nterms, V(A) and V(~) are the variables that appear respectively in A and ~ and X = XAq)X~ is a partition \noi\" the variables such that V(A) ~XA and V(B) _~X/~. Then ~ covers A if and on/y if one of following \nassertions is true: A =~J There exists a substitution s that unifies a in A and b in ~, ie s(a) = s(b), \nsuch that the term s(a) is linear, and:  \\ ~bJ U ~r(b) J covers A \\ ~aJ U ~r(a) J r EC(s) r \u00a3C(s) \n The proof of this result is easy since it is a consequence of the previous property of the complements \nof substitutions. We give now an iterative procedure that is derived from this result. The sets A and \n~ are denoted Ai and ~i at the i-th iteration : COVB~S = PROC (Ai, ~i : set of_rooted_terms) R~S (boolean) \n VARfound: boolean; s, r: substitution; sigma: set of substitutions; a, b: rootedterm; BEGIN wiIII~ \ntrue DO TI[EN R~-TU~ (t rue) EI~E found, s, a, b := BEARCH(Ai, /~il IF not found TItaN RETUFdl (false) \nELSE sienna := COMPLY(s); ~OREACH r in sigma DO Ai := Ai + r(a); ~i := /~i + r(b); END DO Ai+1 := Ai \n-a; ~i+I := ~i -b;  END IF; END IF; kWD DO; END; SF~CH loo~s for a substitution s that unifies a in \nAi and b in Bi. If the unified term is linear then found will be true else it will 1~ false. COMPI~T \nreturns the complement of a substitu- tion. The correctness of this procedure is a conse- quence oi\" \nthe last proposition. An the other hand consider the strict ordering < 1~hat is associated to <, i.e. \nthe covering ordering on the sets of rooted terms. The sets Ai are such that Ai+1 < Ai. Thus the procedure \nwill always terminate. Now suppose that J~ is initialized with the left- hand sides oi\" a definition \nD of an operator f and that A is initialized with the term f(xl ,...,xn). Then the procedure will detect \nwhether D is u + v and x + succ(y). C(s} = { v<-o I. complete or not. Indeed i~~it{s..com!)letethen....the \n A2= {u+o I ~2= |o+x I 2-nd iteration: The substitution s = ~ u<-o , x<-o I unifies u + o procedure..re.~t~.~.ns..,.tr~.e, \ni.e. there is an iteration  i such that Ai is empty. If not it returns false, and o + x. C(s) = ~ u<-succ(w) \n, x<-succ(z) J. i.e. the unifiers of terms in Ai and ~i, if some A3 = ~ succ(w) + o ~ U3 = ~ o + succ(z) \nI exist, are not linear. Thus the application domain of D doesn't contain G(Ai) since the unified terms \n 3-rd iteration: The procedure stops since the term in A3 does not unily with the one in I~3. Thus the \ndefinition of in Ai and ~i are not linear. More precisely if the algorithm stops at iteration i, the \nIbllowing + doesn't hold on G(A3) and is ambigous on G(S3).  assertion is true: This may help you to \nmake a \"good one\" that is If Si is empty then D doesn't hold on complete and unambigous. In this case \nit is enough G(Ai), to invert the left-hand side and the right-hand side of one of the rules. Also, \nnotice that the terms in the test set that is generated are more if Ai is empty then D is smbigous on \n G(~i), general than those built by Dershowitz. Thus we if neither ~i nor Ai are empty and if do only \ntwo unifications , one on the terms there are no b in ~i and no a in Ai that x + succ(y) and u + v, \nand one on the terms o + x can be unified then f doesn't hold on and u + o. Generally the larger the \ndepth of the G(Ai) and f is ambigous on G(Si). leZt-hand sides of the deZ'initions is, the more efficient \nthe procedure is. These results are consequences of the last proposition. 4. OTHER ASPECTS Thus the \nprocedure is a help for the user who wants to write complex specifications since the I. The test set \nthat the procedure constructs depends only on unification. Indeed we get the  .plete. or/and..amb.i.gous. \nIt is tile first such a tool terms in the test set by computing complements oZ\" to be proposed. Let us \ndemonstrate this on an substitutions that are uniZ\u00b0iers and by applying example : m~i..n.e..c~..~ei.Lh.~..w~..,a... \nd.e.~'i.n!t.~\u00b0n.....i..s......i.nc..\u00b0.~ these new substitutions on terms of the test set, x + succ (y) \n-> succ(x + y) i.e. the terms in A that are found by SEAHCH. For that purpose a minimal unifier is not \nreally o+x->x necessary. A non-minimal one would only increase is a TRS that det'ines + on the constructors \no and the number of terms to be examined. SUCC. The algorithm is initialized with : AI = ~ u+v I \n2. The properties of the algorithm are preserved m = ~ x + succ(y) , o + x J. when wori~ing with definitions \nthat can be regarded l-st iteration: as equational TP~. It is enough to do unification The substitution \ns = I u<-x , v<-succ(y) ~ unifies  modulo the equations. This is generally time constu~ing bu~ the cost \nmay De reasonable if the search is limited to only one unifier instead oi\" a complete set oi\" minimal \nunifiers. The ef1\"iciency of our algorithm allows t~s to do this since there are never many terms in \nthe test set. Let us demonstrate it on the previous exsmple. We shall do unification modulo the comamtativity \naxiom : x+y=y+x. The al~rithm is initialized with AI = { u + v andS1 = I x+succ(y) , o+x ~. l-st iteration: \nThe substitution s = { u<-x , v<-succ(y) ] unifies u + v and x + succ(y). C(s) = ~ v<-o ~. A2 = I u+o \nI ~2= I o+x 2-nd iteration: The substitution s = ~ u<-x ] unifies u + o and o + u. C(s), A3 and 293 are \nempty. Notice that at iteration 2 one could choose the uniZ'ier s = ~ u<-o , x<~ | which is no% minimal. \nThis would cost a t~ird iteration. 3. In the case where the left-hand sides of the definitions are rooted \nterms the coverin~ test can s/so be regarded as a decision procedure for proving and disproving that \nany ground term has it's normal form built only on constructors (Guttsg's normal Ibrm lemm~ [GHM,78J). \nIndeed it is enot~oht to test that all non-constructor s3m~ols are \"well defined\", i.e. that their definitions \nare complete. [BID,81J Bidoit M. \"Une Methode de Presentation des Types Abstrsdts : Appllcatlons\" These \nde ~-eme cycle Unlversite de Paris B~ad, Ors~ -1981 - LD,~,82J Dershowitz N. \"Computing with Rewrite \nb~stems\" -196~- LGl~,78J Guttag~ J.V. -llorowftz E. -Musser D.M. \"The Desil~n oi\" Data T~jpes Specifications\". \nIn: b~rrent Trend in Programming Methodo-Io~, Vol 4. Yen H., ed. Prentice He/1 [PAD,83] P~aw/tz P. \"Correctness, \nCompleteness and Consistency of F~uations/ Data i%ype b~ecifications\" Ph.D. Thesis Technische Universitat \nh~rlin -1983 - LI~L,80J Hullot J.M. \"Compilation de ~rmes Canoniques dans les Theories ]fquationnelles\" \nThese de 3-eme cycle Universite de Paris bud, Orsay- 1980- [ I~!, 80J Huet G. -Hullot J.M. \"Proofs by \ninduction in equational theories with constructors\" Proc. 21th ~OCS -196~- Also, JCSS 25-2 -1982 - Huet \nG. -Oppen D.C. \"h~luations and Rewrite hkdes: a b~rvey\", In 9Drmal Imn~sges: Perspectives and open Problems \n~. /~ook H., Academic Press -19~ - Also, Tech. Report CSI,-111, SRI Interna- tional -19~- [JOU,83J Jouannaud \nJ.P. \"Church-Rosser Computation with Equations/ Term He~n'itlng B~stems\" Centre de Recherche en Informatique \nde Nancy-1983 - [Lm,s3J Lescanne P. \"Computer Experiments with the ~ Term Rewriting Generator\" Centre \nde Recherche en Ird'ormatique de Nancy and La~ratory of Computer Science, M.I.T. - 1983 - APPhNDIX \n-THR~ ~D(AMPI~ ]~I~ I : A specification of the boolean fkmc- tions + (OH) and * (AND). The constructors \nare 'true' and 'fs/se'. Your system is now: I (x + true) -> x 2 (true + x) -> x 3 (x+x) -> x 4 (x \n* false) -> false 5 (x * x) -> x What do you want to do no~. (Type ? for help) completeness The definitions \nof  '*' is not sui'ficiently complete. I suggest to add rules with following, left-hand sides: false \n* true EXAMPLE 2 : A specification of = (EQUAL) for the natu~ral m~mbers. The constru cto rs are 'o' \nand tsucot. Your system is now: I (succ(x) = succ(yT) -> (x = y) 2 (x = x) -> true 3 (o = succ(x)) \n-> false 4 (succ(x) = o) -> false What do you want to do now? (Type ? for help) completeness 'false' \n'true' are undefined. Your definitions are sud'ficiently complete. EXAMPLE 3 : Two deXinitions.of an \n\"Ackerman-liEe\" function. The constructors are 'o' and 'succ'. Your system is now: I a(o, o, x7 -> \nsucc(x) 2 a(o, x, o) -> succ(x) 3 a(x, o, o) -> succ(x) 4 a(succ(x), succ(y), o7 -> a(x, y, succ(o)) \n5 a(succ(x), o, succ(y)) -> a(x, succ(o), y) 6 a(succ(o), x, y) -> a(o, succ(x), succ(y)) 7 a(succ(x), \nsucc(y), succ(z)) -> a(x, y, a(succ(x), succ(y), z)) 8 a(o, succ(o), succ(o)) -> succ(succ(o)) 9 a(o, \nsucc(succ(x)), succ(o)) -> a(o, x, succ(o)) 10 a(o, succ(oT, succ(succ(x))) -> a(o, succ(o), x) 11 a(o, \nsucc(succ(x)), succ(succ(y))) -> a(o, x, a(o, succ(succixT), succ(y)))  What do want to do now?. (Type \n? for help) completeness Your definitions are sufficiently complete Your systen is now: I a(o, o, \nx) -> succ(x) 2 a(o, x, o) -> suet(x) 3 a(succ(x), succ(y), o) -> a(x, y, succ(o)) 4 a(succ(x), o, succ(y)) \n-> a(x, succ(o), y) 5 a(succ(o), x, y) -> a(o, succ(x), succ(y)) 6 a(o, succ(o), succ(o)) -> succ(succ(o)) \n7 a(o, succ(o), succ(succ(x))) -> a(o, succ(o), x) 8 a(o,eucc(succ(x)), succ(succ(y))) -> a(o, x, a(o, \nsucc(succ(x)), succ(y)))  9 a(o, succ(succ(xT), succ(o)7 -> a(o, x, succ(o)) What do you want to do \nnow? (Type ? for help7 completeness The definitions o5 'a' are not su1\"1\"iciently complete. I suggest \nto add rules with following left-hand sides: a(succ(succ(z)7, succ(y), succ(x)) a(succ(succ(xT), o, \no7    \n\t\t\t", "proc_id": "800017", "abstract": "<p>We give an algorithm to test the completeness of definitions holding on the rewrite systems that they generate. At the opposite of existing techniques that are very restrictive (left-hand sides of definitions must be linear) or rather inefficient our solution is both powerful and efficient. Also, the algorithm that we give detects ambigous or/and incomplete definitions and can tell you why they are ambigous or/and incomplete. It applies too to definitions in presence of equations.</p>", "authors": [{"name": "Jean Jacques Thiel", "author_profile_id": "81332531620", "affiliation": "Centre de Recherche en Informatique de nancy, Campus Scientifique, B.P. 239, 54506 Vandoeuvre Cedex, France", "person_id": "P331326", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800017.800518", "year": "1984", "article_id": "800518", "conference": "POPL", "title": "Stop losing sleep over incomplete data type specifications", "url": "http://dl.acm.org/citation.cfm?id=800518"}