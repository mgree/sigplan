{"article_publication_date": "01-15-1984", "fulltext": "\n A Less Dynamic Memory Allocation Scheme for ~gol-li~e Languages Thomas P. Murtagh Department of Compoter \nSciences Purdue University West Lafayette, IN 47907 A~ran: The conventional storage allocation scheme \nfor block structured languages requires the allocation of stack space and the building of a display with \ne~.h procedure call. This paper describes a technique for analyAng the call graph of a IXogram in a block \nstructured language that makes it possible to elim- inate these operations from many call sequences, \neven in the presence of recm~on. L Intraductim Current progranar~ng methodologies 4,11 recommend that \nprograms be decon'q3osed into fairly small procedures that each perform simple a~tract operations. This \napproach to program design makes the efficiency with which transfers can be made between procedures critical \n7. Unfortunately, a cons/derable amount of overhead is associated with procedure calls in current implementations \nof languages like Algol and Pascal,, even on machine architectures designed to support such languages \n5,6. This paper describes a new approach to memory management for procedure activation records that may \nsignificantly reduce this overhead. The code generated for a procedure call by a typical translator of \na language like Algol includes instructions to: (1) Calculate the values of the actual parameter, (2) \nSave register values and other components of the caller's state,  Permission to copy without fee all \nor part of this material is granted provided that the copies are not made or distributed for direct commercial \nadvantage, the ACM copyright notice and the title of the publication and its date appear, and notice \nis given that copying is by permission of the Association for Computing Machinery. To copy otherwise, \nor to republish, requires a fee and/or specific permission. &#38;#169; 1983 ACM 0-89791-125-3/84/001/0283 \n$00.75 (3) Allocate space on a stack for the local variables and parameters of the called procedure, \nand (4) Build a \"display\" of pointers to the stack segments con- talning non-local variables that may \nbe referenced by the called procedure 2.  Operations 3 and 4 are included in call sequences to support \na language feature that is not used by all pro~dures -the abil- ity to make recursive calls. If none \nof the procedures in an Algol program are called recursively, a translator could allo- cate all variables \nfor the program statically. This would make it po~ible to efininate operations 3 and 4 from all call \nsequences for the program. Even if some of the procedures in a program are called recursively, it is \noften possible to eliminate operations 3 and 4 from many of the call sequences generated by a tt,mslator. \nFor example, suppose the main procedure in a program, P, contains declarations for two procedures Q and \nR such that P may call O, O may call R, R may call P, and no other calls are possible. Because all three \nof these procedures may be called recursively, this looks like an example in which dynamic allo- cation \nis required with each procedure call. If, however, a translator generates code to allocate the local \nvariables for all three procedures each time P is called, then calls can be to O and R without allocation. \nThis will reduce the execution lime of the p~gram, since the allocation of space for all three procedures \ntakes no more time than the allocation of space for P alone. The signifr, ance of this example is that \nsuch o~-~tions of stack space allocation can be made automatically. Walter 8 refers to the property that \nmakes such ol~n~mtions possible as \"relative nonrecu~veness\" and provides a method for recogniTing cases \nof it based on the static nesting of pro- cedures. It is possible, however, to do better by directly \nanalyAng a program's call graph. Tne key is to recogn/ze 283 groul~ of procedures in which the task of \nallocating space for all of them can be shifted to just one of them. The next sec- tion presents a tedmiq/~e \nfor recognizing such groups of pro- cedures. ,Section three explains how to perform storage allo- cation \nu~g this information. Section four presents algorithms that make a further optim/mtion when procedures \nare recog- ni~d to be absolutely nonrecurs/ve. Sections five, mx and seven explain how these optin/mtions \nof stack space aIloca- tion affect the building of displays. Finally, section eight sum- marines the \ntechniques presented. 2. lnta'vals iu a Call Graph A call graph for a program P is a directed graph with \none node for each procedure in P and an edge between two nodes O and R if the procedure corresponding \nto Q may call the procedure corresponding to R. The node corresponding to the main program is called \nthe initial node. We assume that all nodes in the call graph are re~e from the initial node. The wurd \nmay in this description of a call graph is critical It is impc~ble to detern~ne whether one procedure \nwill call another, even under very weak assumptions about the language involved 9,10. Weih]9 and Walter \n$ present algo- rithtm for congmting call graphs. An interval I with bender h in a directed gral~ G is \ndefined to be a connected set of nodes in G such that: (1) The node h is contmned in every path from \na node not in I to a node in I. (2) t- 0,} is acycUc The notion of an interval was lust used by Allen \nand Cocke 3 to recogni,e loops in wogram flow graphs, but it is also exactly what we need to recognize \ngroups of relatively nonrecun/ve procedures in a can graph. If storage is allocated for all of the procedures \nin an interval each time the header is called, then calls to all of the other procedures in the interval \ncan be made without doing any storage allocation. Furthermore, a  call graph can be partitioned into \nmaximal intervals by a ran- ple algorithm. One version of this algorithm is shown in H&#38; 1. A more \ndetailed vers/on of the algorithm that runs in time proportional to the number of edges in the can graph \ncan be found in ~. 3. Memory A~catiou fm\" ~ When a ca]] is made to the header of an interval, stack space \nshould be allocated for all the procedures in the inter- val. Th/s does not, however, mean that the amount \nof space allocated must equal the sum of the amounts required for the individual procedures, For exmnl~, \nif the subsnOl for ms interval takes the form shown below, the space allocated for B can overlap that \nfor C. In this case, the space allocated for the interval need only equal the sum of the s/~ of A and \nthe larger of B and C. let the sO.e M\" a pa~h in a call gmph be the mun of the simes of the ectivation \nrecords for the procedures on the palh. 1\"hen, the space allocated for an interval need only be as as \nthe si~ of the largest acyclic path in the interval. \"[his can % G/yen a call gra~ with initial node \nno, this progrmn % will set INTS equal to the set of sets of nodes that % form the m~mal interval partition \nof the call Sraph. % % H is the set of nodes known to be the heads of % intervals that have not yet \nbeen co.tiered. % DONE is the set of nodes that have been placed in % intervals. % % SIll denotes the \nset of ~,_~mots of nodes in L % P[x] denotes the set of predecessors of the node x. INTS :,= 0 H := \n(n0} lX3~ \"= 0 while H ~0 do x := any element of H call MAXX(xJ) INTS := INTS U {I} ~:= DONE U 1 H := \n(H- {x}) U ( SIll - I - DONE) od ~cedure ~CI(h,X) % This procedure sets I equal to the set of nodes \nin % the ~ interval with header h. % be~n I :=(h} while there exim x in (S[I] - I) such that P(x) C [ \ndo I :=I U(x} od end Figure L The Allen. ~ Inroad Partition Alsvrltbn. 284 be accomplished by allocating \nspace for each procedure in the interval at a displacermm equal to the ~e of the larsest acy- clic path \nfrom the header to the im3cedure. Thus, the dis- placemem for the header is zero and the d/splacement \nfor any other procedure is equal to the largest of the d/splacements at which the spaces allocated for \nits predecessors end. These displacements can be corrqmted emily during the construction of the interval \npartition, beca-~ a node is added to an inter- val only after all of its predecessors have been added. \nThe space allocated in this way is the ninirnmn that must be allocated when the header is called. In \nsome instances, however, some of it may be wasted. Consider the call graph in Fig. 2. A, B, C, D and \nE form one nmin~ interval. F alone forms another. Assuming that each procedure takes one unit of space, \n4 units must be allocated for the first interval whenever A is called. If the path (A,C,D,E) is followed, \nthen all of this space is actually required. If the path (A,B,E) is followed, however, only three units \nare actually used. Worse yet, if C calls F, only two Units are actually used. Fortunately, in this last \ncase, the unused units can be recovered by simply allocating space for F inenediately after the space \nfor C instead of at the end of the space for the interval. Thus, as a rule, space for a new interval \nshould be allocated at the end Flgwe 2. of the space allocated for the procedure that called its header, \nrather than at the end of the space for the interval conta/nin8 the caller. 4. Slatk Aaecmim The call \ngraph of a progrem is a representafioa of the relation \"A nay call B directly.\" 1\"he transitive cloture \nof this relation is the relation \"A may precede B in a sequence of calls.\" Using the u'anMtive ~, cm \ncan detem/ne that a procedure is nonrecarsive by asking whether \"A may precede A in a sequence of calls\" \nThe fact that a procedure is nonre- cursive is stronger than the fact that a group of procedures forms \nan interval in the call graph. It implies that space for the procedure can be allocated statically. In \na conventional implementation of an Algol-like language, it would be advantageous to statically allocate \nactiva- tion records for all nonrecursive procedures detected in this way. With an interval based allocation \nscheme, static alloca- tion of a procedure is only worthwhile if all of the procedures in the same interval \nare nonrecursive. This is because the main savings obtained through static allocation is the cost of \nstack space allocation, which is zero for all procedures except headers in the interval based scheme. \nThe advantase of limit- in s static alkr.ation to procedures that fall in intervals that are nonrecm~ve \nis that it is generally less expen~ve to deteragne which intervals are nonrecu~ve than to determine which \nixo- cedures are nonre~usive. It can be done by computing the tran~tive closure of the der/ved ca//grCph \ndefined as follows: (1) For each interval in the call graph there is one node in the derived call gaph. \n (2) If A and B are two intervals, there is an edge from A to  B in the derived call graph if and only \nif there is a path from some node in A to the header of B in the caU graph. In most cases, the derived \ncall graph will contain fewer nodes than the call graph. Therefore, computing its tran~t/ve clo- sure \nwill not be as expenave as computing the tran~tive clo- sure of the full call graph. When nonrecurs/ve \nintervals are allocated statically, the space used need not equal the sum of the amotmts of space needed \nfor the individual intervals. Instead, space for many intervals can be overlapped by allocating each \nnonrecursive interval at a displacement equal to the maximum of the end- ing addresses of the storase \nsegments allocated for procedures in nonrecursive intervals that precede its header. These dis- placelmnts \ncan be computed by first constructing a uaph with: (I) one node for each lXocedure in a nonrecun~e interval, \n (2) an edge from A to B if there is a path from A to B in the original graph such that all nodes on \nthe path except A and B fall in recur~ve intervals,  and then visiting the nodes of the graph in topological \nsort order setting each node's allocation displacement equal to the maximmn of the ending displacements \nof its predecessors. 285 In the case of a program in which all procedures are non- recur~ve, this scheme \nwill lead to the static allocation of space for all procedures. Th/s is a satisfying result, since it \nimplies that this scheme leads to the best pos~ble allocation of storage in what is probably the most \nco~n case it will encounter. On the other hand, the savings obtained by static allocation in this case \nare in~gnif~ant. The use of intervals will have 'already elin'/nated all but one allocation of stack \nspace in such a program. Static allocation is more significant in the case of a pro- gram in which a \nnonrecurs/ve pro~dure is called from recur-dye procedures in different intervals. For example, in a corn- \nIdler udng a recursive descent parser, many of the recursive routines in the parser would call some sort \nof 'geLlexeme ' routine, which is likely to be nonrecun/ve. If the parser pro- cedures that call 'get..lexeme' \nfall in distinct intervals, then 'get..lexeme' will be the header of a separate interval. There-fore, \nif nonrecursive intervals are not allocated statically, every call to 'geLlexeme ' will involve stack \nspace allocation. \"Ibis overhead can be eli~nated by u~ng static allocation. The notion of an interval \nin a call graph also provides a way to reduce the overhead associated with display building. This can \nbe seen fairly easily by temporarily assuming that the language being con~dered supports neither procedure \nvari- ables nor the use of procedures as parameters. Recall that the display associated with a procedure, \nP, is just a sequence of pointers to instances of the procedures that statically sttrround P. \"lhe first \nelement of this sequence points to the outenuost surrounding procedure. The last ele- ment points to \nthe irmnediately surrounding procedure. In the absence of Ixocedure variables and parameter, a pnx~dure's \ndisplay can always be built from the display of its caller. If a procedure is called by the procedure \nin which its definition occurs, its d/splay is constructed from its caller's d/splay by adding a pointer \nto the caller's e~dvation record. Otherwise, the called procedure's d/splay is formed by remov- ing \nero or more pointers from its caller's display. This implies that the d/splay associated with any procedure \nin an interval must con~st of some prefix of the display assc~ated with the interval's header followed \nby zero or more pointers to the activation records of other procedures in the same instance of the interval. \nFurthermore, the display associated with an interval's header cannot contain any pointers to instances \nof other pro- cedures in the interval. If it did, then such a pointer would have to be included in the \ndisplay for the first instance of the header created, which is impossible dnce the fast instance of the \nheader must be created before an instance of any other procedure in its interval can be created. Together, \nthese two facts imply that any procedure's display can be partitioned into sub-sequences of pointers \nto procedures in distinct intervals, as illustrated in Fi&#38; 3 (a). H ~ointer to [prcc. A 3ointer to \nI ' i~c. B ~ointer to [ proc. c l 't membemof interval I pointer to proc. D i tr~mber of interval 2 pointer \nto interval 1 pointer to pointer to proc. E pointer to members of interval 3 interval 2 pointer to proc. \nF interval 3 (a) Co) Figure 3. storage for all of the procedures in an interval is allocated in one \nblock, as suggested in section 2, such a display can be compressed by rep]ac/ng each subsequence of pointers \nto pro- cedures in a Oven interval by a single pointer to the block of memory allocated for the entire \ninterval. The comp/ler ~n~l. y u2ses the interval pointers together with the known displace- ment of \neach procedure from the beginning of the stora~ for the interval. Figure 3 03) shows how the display \nshown in Hg- ure 3 (a) would be compressed u.~ng this technique. Compressing displays obviously saves \nstorage. More importantly, it reduces the overhead associated with display building dnce a display change \nonly occurs when a call is made to the header of an interval. All other procedures in the interval share \nthe display built when the header is called. 6. _Pr~_~e ~ and 8imply ~ l~m~s To simplify the preced/ng \nexplanation of display sharing, we have assumed that the language involved allowed neither procedure \nvariables nor procedure parameters. We will con- tinue to assume the absence of procedure variables, \n~Jlce the wesence of both procedure variables and the ability to nest procedure definitions in a language \nwould require the reten- tion of activation records or some other mechanism to avoid dangling references. \nProcedure parameters, on the other 286 hand, a~e found in two of the best known languages to which these \ntedmiques could otherwise be applied, Algol \u00a2~0 and Pascal. The problem with procedure parameters is \nthat the display associated with a procedure called through such a parameter is detern~ed at the time \nat which the parameter is bound rather than at the time the call is made. If a call is made using a procedure \nparameter that was bound outs/de of the current instance of the current interval, the display formed \nmay not have the form described above. The skeleton of a program in which this problem can occur is shown \nin Fig- ure 4. Its ca]] graph is shown in Fif~ 5. In this example, the main program forms one interval. \nThe pro~dures R, F, G and H form another. If the recurve procedure R calls itself with G as parameter \nand the new instance of R invokes G through the parameter FP, then the display built when G calls H will \ncontain a pointer to R in the fast instance of the inter- val containing R and a pointer to G in the \nsecond instance of the interval. As a result, these two pointers cannot be replaced by a single pointer \nto either instance of the interval. This problem can be avoided by refuting the maximal interval partition \nof the call graph to obtain intervals in which the use of procedure parameters is approwiately restricted. \nbegin procedure R(FP); procedure FP; bep procedure G( ); begin ... H( ) ... end; procedure H( ); begin \n... end; if ... then R(FP);  it ... then S(G); FP() end; procedure F( ); begin ... end; R~; ... end \nFisure 4. Figure 5. We define a singly scoped interval to be an interval I with header h such that the \nset of formal parameter names that may be bound to any procedure in I - Or} is a subset of the formal \nparameter names declared by the procedures in I - (It}. The following lemma implies that the pnx~dures \nin a ~ply scoped interval can all share the display built for the header if storage for all the procedures \nin the interval is allocated together. Lemma: If I is a simply scoped interval in a call graph with header \nh, then the dlsi~ay associated with any instance \u00a2g a procedure 0 in I at nmtime will ~-~st of some weRx \nof the display associated with the most recently created active instance of h followed by zero or more \npointers to the most recently created active itmtances of other procedures in I that fall on acydic paths \nfrom h to Q. The lenuna can be proven by induction on the length of the longest acyclic path from the \nheader to a particular pro- cedure in 1, which we call the distance from h to the pro- cedure. The displays \nof all i~x~dures at distance zero from the header dearly have the required form. Now, a~ume that the \ndisplays of all procedures at a distance less than n from the header have the de,red form. If P is a \nprocedure at dis- tance n from the header, then any procedure Q that calls P must be at a d/stance less \nthan n from h. Therefore, by assumption, the display of 0 has the desired form. But, unless 0 calls P \nthrough a formal parameter name, the display of P will be built either by adding a pointer to 0 to the \ndisplay of 0 or by removing a suf~ from the display of O. In both cases the resulting display will have \nthe required form. If a procedure calls P through a formal parameter name, the d/splay associated with \nP is not detem~ed at the IXXnt of call It is deterrr~ned at the points at which F is bound to for- ma] \nparameters. So, con~der all calls of the form R( ... P...) The display to be associated with\" P when \ncalled through this 287 formal parameter binding is formed from the display of the procedure Q in which \nthe call to R occurs by either adding a pointer to O's activation record to or removing a mffuc from \nO's display. We will say that Q precedes P in I if Q wecedes P on some acyclic path from h to P. If Q \nprecedes P in I, then the resulting display must have the desired form, since the distance from h to \nQ must be less than n. IfQ does not precede P in I, the form of the display associated with P does not \nmatter, because the binding made can never be used to call P. This is because no parameter, X, defined \nby a pro- cedure that does not precede P in I can be used to call P or to make a binding between P and \nany parameter, Y, defined in a procedure that precedes P in 1. To call P tLclng X, one would have to \nreference X in the caller. But the caller must precede P in L This implies that its distance from h must \nbe less than n and, by our assumption, that the only pointers to procedures in I on its display are pointers \nto procedures that precede P in I. Therefore, it cannot reference X or any other identifier defined in \na procedure in I that does not pre- cede P in 1. Similarly, to make a binding between P and Y u~ng X, \nX would have to be referenced by the procedure that called the procedure that defined Y. But, such a \npro- cedure nmst precede P in 1. Therefore, by the same argu-ment as above, X cannot be referenced by \nany such procedure. 7. Rd'm~ag the Interval ParUtlon intervals cornimted by the algorithm in Fig. 1 may \nnot be ~mply scoped. Each of the these intervals, however, can be partitioned into a set of ~mply scoped \nintervals. Hg. 6 shows an algorithm that simultaneously partitions a call graph into maximal intervals \nand partitions each mammal interval into simply scoped intervals. This algorithm may not wtxh~ maz/ma/simply \nscoped intervals when applied to programs that bind procedures to parameters that are never used. This \ndoes not seem important, however, since such binclin~ prob~iy indicate a prograrr~ng error. Given this \nlmrtition, the pro- cedures in a program are split into three dames: 1) headers of maximal intervals; \n2) headers of simply scoped intervals and 3) members of intervals other than the headers. Calls made \nto the fast type of procedure require both stack space allocation and display building. Calls made to \nthe second require only display building. Calls made to all other procedures need nei- ther. s. st=.,=ry \nWe h~ve presented a technique for organi~ng the activa- tion records of procedures in block structured \nlanguages that % Given a call graph with initial node nO, this program will % set IHTS equal to the \nset of sets of nodes that ~rm the % maximal interval partition of the call grggh and SSlICrs % equal \nto a set of sets of nodes that forms a refinement % of this ln~tition into simply axed intervals. % % \nHis the set of nodes known to be the heads of % intervals that have not yet been considered. IX)NE is \n% the set of nodes that have been placed in intervals. % % SIll denotes the set of successors of nodes \nin L % l~x] denotes the set of predecessors of the node x. := ~ := DONE := 0 H := {nO} while H * 0 do \nx := any element of H can ~(x,I) Ih'IS := INTS U (I} DONE := DONE U I  u := 0~- {x)) u (s[q - I - DONE) \nod procedure MAX](hj) % This procedure sets I equal to the set of nodes in % the maximal interval with \nheader h, % ssI-I is the set of nodes known to be the heads of ~mply % scoped subintervals of the current \nms:cimal interval. %  ~esm I:=0 ssH := {h} while ~*0do ssh := any element of ss]-I can ss](~,=~ SSINTS \n:= SSIN'rS U {ml} I :=IUssl mH := { x I l~x] C I and x E (S[I] - I)} od end wocedure SSI(ssh,ssl) % \nThis procedure sets ssl equal to the set of nodes in a % gimp]y scoped interval with header mh. % be~ \n= {~} while there exists an x in (S[ssl] - ssl) such that ssl D l~x] and ssl D { p I p defines a formal \nparameter that may be bound to x} do ~ := ssl U {x} od end Figure 6. 288 Rdm can significantly reduce \nthe overhead associated with stack space allocation. In addition we have shown how this tech- nique can \nlead to a reduction of the overhead involved in building displays in languages that allow nested IXOcedure \ndefinitions. We are confident that these techniques ~uld be of significant value, because we believe \nthat relatively few lXO -grams depend heavily upon recunion. Some experimentation is needed, however, \nto detemdne how useful these tech-niques are when applied to programs that are recursive. The author \nthanks IvL CrDormell, T. Korb, C. RaBgiefi and J. Manning for their helpful conanents on earlier versions \nof this paper. I. Aho, A.V. and J.D. Ullman, The Theory of Poising Trans- lation and Compiling, Prentice \nHall, Inc., Englewood Cliffs, New Jersey (1972). 2. Aho, A.V. and J.D. Ullman, Principles of Conp~ler \nDesign, Addison-Wesley Publishing Co., Reading, Mas- sachusetts (1979). 3. Allen, F.E. and J. Cocke, \n\"A Program Data Flow Analysis Procedure,\" Cu,,,,,~micalions of the ACM 19(3) pp. 137-147 (March 1976). \n 4. Dijkstra, E.W., \"Rotes on Structured Progranmdng,\" in Structured Progr~r~nin 8, O-j. Dahl, E.W. Dijkstra, \nand  C.A.R. Hoare,, Acaderr/c Press (1972). 5. Lampson, B.W., \"Fast Procedure Calls,\" Proceedings of \na Symposiwn on Architectural Support for Progr~ Lzmsuage$ and Operming Systems, pp. 66-76 (March 1982). \n6. Patterson, D.A. and CSL Sequin, \"RISC I: A Reduced Instruction Set VLSI Computer,\" Eigth Symposiwn \non Computer Architecture, pp. 443-457 (May 1981). 7. Tanenbaum, A.S., \"Implications of Structured Program- \nn-ring for Machine Architecture,\" C~,,\u00a2,,,mications of the ACM 21(3) pp. 237-246 (March 1978). 8. Walter, \nK.G., \"Recursion Analysis for Compiler Optimi- zation,\" \u00a2c~mications of the ACM 19(9) pp. 514-516 (September \n1976). 9. Weihl, William E., \"Interprocedural Data Flow Analysis in the Presence of Pointers, Procedure \nVariables, and l.a~l Variables,\" Conf. Rec. Seventh ACM Syn~osium on Priaei~es of Progr~,d~ lag, my.s, \npp. 83-94 (January 1~0). 10. Winklmann, K.A., \"A Theoretical Study of Some Aspects of Parameter Passing \nin ALCg)L fi0 and in S/mi- lar Progranm-/ng Languages,\" Ph.D. The=s, Purdue UBiv=r~ (~=t 1977). 11. \nW'trth, N., \"Program Development by Stepwise Refinement,\" Coii~i~ications of the ACM 14(4) pp. 221- 227 \n(April 1971).  289  \n\t\t\t", "proc_id": "800017", "abstract": "<p>The conventional storage allocation scheme for block structured languages requires the allocation of stack space and the building of a display with each procedure call. This paper describes a technique for analyzing the call graph of a program in a block structured language that makes it possible to eliminate these operations from many call sequences, even in the presence of recursion.</p>", "authors": [{"name": "Thomas P. Murtagh", "author_profile_id": "81100029912", "affiliation": "Department of Computer Sciences, Purdue University, West Lafayette, IN", "person_id": "P281295", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800017.800540", "year": "1984", "article_id": "800540", "conference": "POPL", "title": "A less dynamic memory allocation scheme for algol-like languages", "url": "http://dl.acm.org/citation.cfm?id=800540"}