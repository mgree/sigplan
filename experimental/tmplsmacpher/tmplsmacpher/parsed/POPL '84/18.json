{"article_publication_date": "01-15-1984", "fulltext": "\n Coercion and Type Inference (Summary) John C. Mitchell 1 Bell Laboratories Murray Hill, NJ 07974 70 \nNo vembt, r 198 Abstract A sinlple semantic model of automatic coercion is proposed. This modcl is used \nto explain four nlles for inferring polymorphic types and providing automatic coercions between types. \nWith the addition ofa fifth rule. the rules become semantically c',mq~lete but the set of types associated \nwith an expression may be undecidable. An cMcient type chcckio.g algorithm based on the Ih'st Ibur rules \nis presented. The algorithm is guaranteed to find a type whenever a type can be dedttccd ,sing the four \ninference rules. \"1 he type checking algorithm may be modi!icd so that calls to type conversion ftmctions \nare inserted at COmlfile time. 1. Introduction Type ilffcrence is a form of type checking. In programming \nlangt,agcs where all identifiers are given types as they are introduced, it is often a simple matter \nto check whether the types of operatom, fttnctions and pr~cedures agree with the types of operands and \nactual paranleters. For some programming applicatious, it ix convenient to be able to omit type declarations \nfrom progr-ims. This may make it easier to write or modify experimental programs quickly. More importantly, \na single untyl',ed program ,'epresents many explicitly typed programs. This givc.~ rise to an implicit \nform of polymorphisnl. When type IAmhor's prcscm mldress: MIT Lab ,%r Computt:r Science, Ctmfl~dtlg\u00a2 \nMA 02139. Permission to copy without fee all or part of this material is granted provided that the copies \nare not made or distributed for direct commercial advantage, the ACM copyright notice and the title of \nthe publication and its date appear, and notice is given that copying is by permission of the Association \nfor Computing Machinery. To copy otherwise, or to republish, requires a fee and/or specific permission. \n&#38;#169; 1983 ACM 0-89791-125-3/84/001/0175 $00.75 information is omitted I'rom program,,, there is \na type inference problem. If 9 is a typed programnfing language, then type hlferencefor ~ is the problem \nof taking any untypcd program S and finding all possible ways of inserting type declarations into S that \nrestdt in legal typed programs of~ Type inference was first considered in [3, 7] and has been developed \nfurther in [6, 10, 13]. The main advantage of languages based on type inference is that they provide \na form of polymorphism. Since a single untyped fimction, for example, may have many legal typings, it \nmay be called with actual parameters of many different types. Ideally, type inference allows a programmer \nto think of the \"type\" of a function as determined by the meaning of the function. For example, if a \nfunction f makes sense whenever its actual parameter is a pair, then an ideal type inference procedure \nwould deduce a type for f that allowed f to be applied to any type of pair. In addition to providing \nthis kind of flexibility, which is often associated with \"typeless\" languages, type inference detects \ntype errors prior to run time. This facilitates debugging and alleviates the need for costly rtm-time \ntests. Unfortunately, ideal type inference cannot be attained using efficient algorithms; it is impossible \nfor any algorithm to deduce all types that correspond to the meaning of any given function f. This point \nwill be explained more fully in Section 4. In practice, we are forced either to use some run-time checking \nor to forbid some expressions that could pass run-time type checks. The algorithm presented in this paper \nwill forbid some semantically typed expressions, rather than generate rim-time tests. Automatic coercions, \nsuch as coercions from integers to real nunlbers, are conlnloll to many programming Imlguages. 175  \nFlowevcr, automatic ct)crcions involve relationshil~s between distinct types and it is not clcal', a \nprit)ri, how coercions eft'oct type inference. One complicating I;calure of ct)crck)ns is that a single \ncoercion implies many uthcrs: if\" integers arc c()crciblc to reals, then real predicatcs (bt)t)lcan-vahled \nlhnctions ()f real arguments) arc coercible to integer predicates. This paper addresses the problem of \ninferring polymorphic types in a way which suPl)Orts automatic coercions between various types. Some \nof the b:tsic properties of coercions are closely related to type containment in more complir:~tcd type \ndisciplines. Due to space limitations, some proof.'i and tcchni,:al details are deferred to the full \npaper. In many cascs, with or without O~el'cions. a single untyped function will have infinitely many \nlegal typings. For example, the Function Apply(f,x) with body f(x) is legally typed whenever the first \nfomlal parameter f is dccktrcd to bca sing!e-argument function and the second formal parameter x is declared \nto be in the domain of f. One way of representing an infinite set of types is by using type expressions \nwith type variables. Intuitively, a type expression with variables (also called a type .~cheme) represents \nthe set of types that can bc protlttccd by substituting other type expressions for type variables. For \nexample, the type expression ((s --, 0 :'< s) ---, t represents the substitution instances (tint ~ bool) \n\u00d7 in0 -, bool, ((real -, inO x real) ---, int, and many others. 2 In the case of Apply(l;x), the body \nf(x) is legal!y typed if fhas some fimctio:ml type s -, t, fbr some types s and t, and if x has type \ns (the .same s). When f ha'.s type s ---, t ,and x has type s, the result of Apply(f.x) = f(x) will have \ntype t. Thus we can infer that Apply has type ((s -, 0 x s) --, t. Apply takes a pair of arguments, \nthe first orsome type s -, t and the second of type s, and returns a result of type t. Since this is \ntrue for auy s and t, the type expression ((s ---* t) X s) --, t 2The type operator --} means \"function \nspace\" and X me'ms \"product space.\" For example, int ~ bool is the lype of functions from integers to \nboole;.m and int X boot is the type of pairs <a.b) where a is an integer ,'rod b is a boolean. describes \nan infilaite set of types of Apply. The most I)t)pular and best known progmnnlning language based on \ntype inference is MI. [6J. In the specific type system chosen for MI.., each expression, fimction and \nprocedure has a most general t)Te. also called a principal O'pe scheme. Ibis nle~uls that for each clause \n(i.e. expre:;sion, fimction or procedure) e. there is a single I3,1)(2 expression cr (generally with \ntype variables) such that all legal typings of e are substitution instances of a. Most general type expressions \nhave the convenient property that the most general type of a clause involving clauses d and e can be \ndetermined from the most general types of d and e.'rhe efiiciency of the ML type checker seems to be \na direct consequence of the fact that MI. expressions have most general types. We will see that when \ncoercions are added to a stlbset of /vlL, type schemes alone do not characterize all possible typings \nof each term. Nonetheless, there is a concise representation for the set of legal typings of any typable \nterm. This representation uses both type schemes and coerdons between types. The simple model ofcoel'Ckm \nadopted in this paper is based on set containment: if tr is coercible to ~'. then ~.e thhlk of the semantic \nvalues associated with type tr as contained ill the set of wdues associated with type 'r. \"]'his approach \nto coercion enconlpa';,ses COlnmon coercions such :ks converting intcge:'s to reals in arithmetic expressions. \nThe set of integers may be viewed as a subset of the set of real numbers. Except brietly in a later section \non inserting calls to conversion Functions\u00b0 we ignore the fact that integers and reals are usu:dly given \ndifferent representations. We do not consider automatic conversions such as converting reals to integers \nthat cannot be viewed ,as set  containment. Many of the properties of coercion which are discussed in \nthis paper will apply to other type systems that involve somc implicit or explicit notion of type containment. \nIn particular, type containment may come up in type systcms which include type quantificrs or other bindingopcrations. \nFor example, the type V t.t--, t with a univc~al quantifier is the type of Functions which, given any \ntypc a. will behave as Functions from a to cr (of. [5, 16]). llle 176 type V t.t ---, t is essentially \n\"contained wilhin\" the type V t. (t -, t) --, (t ---, t). This st~:tcmcnt may be made precise in several \nways (cf. 114]). Thus wc expect that any untyped fuller=on which can be given the type V t. t-, t can \nalso be given the type V t. (t --, t) ---, (t --, t). In quantified type disciplines (with or without \nautomatic coercion), containments of types is a crucial issue. Automatic coercion motivates a general \nstudy of type containment and this study provides insight into type inference for more complicated type \nsystems.  2. Larnbda Calculus and its Semantics l.ambda calculus, the bilsis of MI.., is used to delnonstrate \ntype inference with coercions. The temm ofuntyped lambda calculus arc defined by the granlmar e::= x \nl ere 2 I Xx.e. A /cmbda mode/(D, Fun, Graph) is a set D togedler with mappings Fun: I) -, [D -, 13] \nand Graph: [D ---* I)] --, D such that Fun o Graph is the identity function of the range of Fun and such \nthat all functions on D that are del]nable by lambda expressions Call be \"compiled\" into elements of \n1) using Graph. See [1, 12] for more information. One useful lamhda model is the term modd. The terln \nmodel is built from eqtlivalcnce classes of terms, with application defined by I~:un(id])([e]) =ide], \n i.e. the result of applying the equivalence cl;tss of d to the equivalence class of e is Ihc equivalence \nclass of the application de. See [1, 12] for details. Given a lambda model (D, Fun, Graph) and environment \np mapping variables to elements of D, the meaning of a lambda term e is defined inductively by x ~p \n= p(x) e I e 2 llp = Fun([l e I ]]) (1[ e 2 ]]) Ax.e lip = Graph(\"the function whose value at d \u00a3 D is \nI1 e ]p(d/x)\") Again, the reader is referred to [1.12] for specifics. A few facts about the reduction \nrules of lambda calculus are assumed. See [I] for an excellent presentation. The ='eduction rules are \n(a) ~kx.e --, ~,y.(e[y/x]) ify is not free in e,  (/~) (Ax.e)f--, e[f/x], (,/) Ax.ex --~ e ifx is \nnot free in e. If a term e is of the form of the left-hand side of nile (a). ([3) or (,]), then e is \nan a-, fl- or Ti-redex. We say that e fl-reduces to fin one step if there is a subtcrm d of e which is \nan a-redex or fl- redex and fis the result of contracting this rcdex in e. The term e fl-reduces to f \nif there is a sequence offl-reductions leading from c to f. If we allow \"q-reduction in addition to a- \nand fl-reduction, then we sty ft.,l-reduces to f, A term which cannot be reduced is in normal form. \n3. Type Expressions, Coercio n Sets and Type Assignments Although product types, lists, and other kinds \nof types are useful in programming languages, these types seem to interact with automatic coerciott in \na relatively straightforwm'd way. 'File most interesting types for the our purposes are the filnctional \ntypes. Intuitively. the ftlnctional type e --, -r consists of the set of functions which take arguments \nof type or to results of type \"r. We use aC__, to denote the fact (or assumptiotl) that values of tyl)e \ncr can be cx~erccd to values of type 1\". If we think of the coercion relation between types ,as an ordering, \nthen ~ is monotonic in its second argument; ifaC_p then ~'---,a C_ 'r-,p. However, --, is ant=monotonicin \nits first argument, i.e. ifaCp then p---* ~\" C a~1\" rather than die reverse inclusion. If every value \nof type a can be treated ,as a value of type p, then every function which maps p to I\" also maps o to \n1\". While in some semantics, e.g. [19], the connective .-* is monotonic in both arguments, the antimonotonicity \nseems natural when we think of containment as the ability to coerce. If f is a function of one real argument, \nand integers are coercible to reals, then f should be applicable to integer values. It seems inappropriate \nto apply integer Functions to real numbers. Type expressions are built froln type variables ~md constants \nusing the connective -,. We adopt the notational conventions that 177 a, b .... denote type constants, \nr, s, t .... denote type variables p, o, \"r, ... denote type expressions. An atomic type is either a \ntype constant or a type vari.'tble. Greek letters or,/ff .... from the beginning of the alphabet may \nbe used to denote atomic types. The set of type expressions is defined by the grammar r::= a I t I a--,r. \nTypes will be interpreted as arbitrary sets of clemcnts of lambda models (cf. [2, 8]. A type environment \n~ Ibr a model (I), Fun, Graph) is a mapping from atomic types to subsets of.I). The meaning of a type \nexpression a in a type environment -q is defined inductively by Ilall,1 = ,7(a) [[o~vDT/ = {dlVdiEIIoB~ \nI, Ft'n(d)(dl) EII T ]'q}. Note that membership in e--,'r is determined only by the behavior of an clement \nd ,as a function (i.e. the extension of Fun(d)). Other semantics for G---,r arc proposed in [9, 14, 19]. \n A coercion set C is a set of coercions aC_fl, where a and fl are atomic types. A model (D. Fun, Graph) \nand type environment satisfy a coercion set C if ~aBrIC_.~fllrl for all aC_fl E C. Coercions like (a--, \nb) C_ c~ have complex implications. Some sets of cocr~,ions between structured types may only be satisfiable \nin special lambda models, and some coercions may drastically change the set of typable terms. For example, \nif wc assume the two coercions (a--,a)Ca and a C_ (a --, a), then every term of the untypcd lambda calculus \nwill semantically have type a. In contrast, only a subset of the set of terms with normal forms will \nhave types when no coercions are allowed. We make sure that our coercions are not restrictive \"domain \nequations\" by only considering logical consequences of coercions between atomic types. A type assignment \nA is fimction from a set of variables that may appear in hmbda terms to type expressions. Often, type \nassignments will bc functions with finite domains. A type assignment A can be written as a set of statements \nof the form x:o. A model, type environment \"q ,and environment p satisfy type assignment A if p(x) \u00a3 \nI a ]l'~ whenever A(x) = o. If x is a variable, a a type expression and A a type ~tssignment, then A[e/x] \nis a type assignment with (A[e/x]Xy) = A(y) for any variable y different from x, and (A[cr/x])(x) = 0. \nA typhtg statement describes the type of an expression, given coercions between types and the types of \nvariables, lnformaUy, the statement C,A l e: o means that if types may be coerced according to C and \nvariabl~ have the types assigned by A, then the expression e has type o. More formally, a model, type \nenvironment r/and environment p satisfy a typing e:o if I[ clip C ~ a]l'q. A st~,tement C,A I e: G is \nsatisfied in a model (l), Fun, Graph) if every environment and type environment fbr (D. Fun, Graph) which \nsatisfy C and A also satisfy e:cr. A statement is validifit is satisfied by every model. 4. Rules for \nType Inference There are five simple, semantically complete rules for deducing type statements. The completeness \ntl~corcm shows that ally valid statement C,A J e:rr may be proved. This theorem demonstrates that the \ntyping rules accurately describe the untyped semantics of lambda terms. It is possible to add rules for \nother applicative programming language constructs, cf. [6, 13]. 'The first three rules of the system \nexpress well-known facts about the functionality of lambda terms [3]. The next rule, (coerce), formalizes \nthe property that ira term e has type a, and the type a is coercible to the type r, then e also has type \nr. These four rules are straightforward oJid define a typed hulguage similar to the usual simple typed \nlambda calculus. The type checking algorithm TYPE in Section 5 will be based on these four rules. If \nwe want a semantically complete set of rules, Ihcn untyped tcrms that have the ~,me meaning inust be \ngiven the ~mle types. One naturul way to achieve this is to add a fifth rule (equal) based on equality \nof tmtyped temls. Since the equalions that are valid in all lambdu models are recursivcly entlmerable, \nthe antecedents of this rule arc recursively enumerabl., tlowever, it is not decidable whelhcr the rule \nis applicable in any given instance. When we adopt rule (equal), tile set of types associated with an \nexpression is, in general, uadccidable. The merit of completeness is that it demonstrates that the typing, \nrules give accurate infornmtion about the \"fitnctionality\" or typcless operational behavior ofprogrums, \nThe drawback ofscmantically complcte typing rules is that the types of terms becomes undecidable. \"llle \ncompleteness theorem assures us that the first four rules capture the \"functionality\" of terms, modulo \nthe problem of deciding equivalence of terms, Algorithm TYPE will bc based on the decidable proof system \nwithout (equal) that is not semantically complete. The rule (coerce) flint models automatic coercions \nwill use two subsidiary rules for deducing consequcllces of coercion sets. Although coercion sets only \ncontain coercions between atomic types, many other coercions will Ibllow as conscqvences. Two straightforward \nrules for deriving coercions are (arrow) Froln o\" 1 C o and '1\" C_ r I derive a ~ 'r C ffl -~ \"rl and \n(trans) From o C r and r C p derive o C_ p. The ~mndne'~; of these rules fl)llows easily from the definition \nof cr ]. A coercion a C_ p is provable from C, written C~-aCp, if or C. p can be derived from elements \nof C using rules (arrow) and (trans). The following Icmlna about the structure of proofs of coercions \nwill be used to prove several facts abotlt derivations of typing statements. I~emma I: Let tr and r be \ntype expressions with a = tr 1 -, tr 2 m~d \u00a2 = \"r I ---, \u00a22' Then C I--- a C_ r iffC I- \"r l C a t and \nC ~-\u00a2r 2 _C \u00a22. Now back to the lwoblenl of assigning types to lambda terms. 1 hree well-known rules \n[3, '|. 8, 9] ;ll'e (var) C,A ] x:o whenever A(x) = o, (app) From C,A [ el:o ---, '1\" and C,A I e2:o \nderive CA lel e2: r, (abs) From C,A[a/x] I e:r derive C,A I X x,e : a ---* r. The coercion rule for \ntyping lambda, terms, based on the rules for deducing inclusions, is (cocrce) From C,A l e:or and C I-- \ntrC \"r dcdve C,A ~ e:~'. It is relatively easy to see that these rules are sound. An interesting property \nof the four rules is described by the following Icmlna. Essentially. this generalization of the Subject \nReduction Theorem of [3] shows that typcs as defined by the four typing rules above arc closed under \nft.'q-reduction (n.b. not conversion). The lelnma is interesting in itsell, and will be also bc used \nin the completeness proof and its corollaries. I,emma 2: (Subject Reduction I.emnla) If C,A J e:tr is \nprovable using rules (var), (app), (abs) and (coerce), and e fl,B-reduces to f. then thcrc is also a \nproof of C,A I f:o using (var), (app), (abs) and (coerce). \"[he Ibur rules above arc not semantically \ncomplete. This follows fi'om the fact that every tenn which is typable using these rules looks just like \na term of the simple typed I~,mbda calculus, and every subterm of every tclm of that calculus has a normal \nlbrm. However. the expression (hx. ~,y.y)(~,x.xx ?~x.xx). h~s a subterm without a normal form but tile \nterm is semantically equal to the typuble term X y.y. Therefore, this term has a type sem~mtically, but \nit cannot be typed according to the rt, les above. We obtain a semantically complete set of rules if \nwe add (equal) I\"rorn C,A [ e :o and c = f derive C,A I f:o,. This rule gives us a complete system and \naccounts for the undecidability ofthc consequences of d'~e typing rules. There are 179 malty possible \ninterpretation for the symbol = in nde (eqt,al). Equality can be interpreted as equivalent under/]-conversion \n (the reflexive and transitive closure of//-reduction) or ,/].'r/- conversion. If we choose//-conversion, \nthen we obtain a system that is complete for all lambda models. If we choose ,/~Jl\" conversion instead, \nthen we have a proof system which is complete for all models of'q-reduction. 3 Note that the theory of \n/~-conversion, ~q well as the theory of [/,r/-conversion, has the property (*) ire ]~,r/-reduces to fantl \ne=e 1, then there exists e 2 such thai e I ~.~l-reduccs to e 2 and e2= f (ef. [81). The following lemm~ts \nare required if = is not closed under rl\" reduction. Both are gcneralizationsoflcmmas found in [8]. I,emma \n3: (Equality Postponement) If C,A I e:a is provable, then there is a prtx~f of C,A I e:a in which all \nuses of rules other than (equal) appear before all uses of (equal). Equivalently, ifC,A l e:a is provable, \nthen there is some f such that c=f and C,A If:or is provable without (equal). Lemma 4: If C,A I e:a is \nprovable, possibly using (equal), and e ~,'0-reduces to f, then there is a proof of C,A I f:a. A corollary \nof the subject reduction lcmma and the two lemmas above is that if = is ~-conversion or ]~,'q-conversion, \nand e is in the corresponding normal form, then C,A I e:a is provable using all five rules iff it is \nprovable without rule (equal); see Corollary 1.1. Theorem I: The five inference rules arc sound and complete \nfor deducing wtlid statements of the form C,A I e:a. ]he completeness theoren~ has two interesting corolhtries. \nThe first four rules ;ire scmzmtically complete for typing terms in normal fornt and the two containment \nrules are comp!ete for deducing consequences ofcoercion sets. Corollary i.1: Ire is in ~-nonual tbrm \nand C,A I e:a is valid in all lambda models, then C,A [ e:(r may be 3In fact. Theorem 1 holds whenever \n= is interpreted as equivalence ill any lambda theory that extcnd~ the theory ~1/J-cp=~crsi,~n (or. [l]), \nprovided that pn~peny (*) h\u00a2}lds. More precisely, let T be the cqtm!ion:d thta~ry of some ]ambd.t model \nand define e-:~ fiffe= I'C T. If = satislics prol)e;'ty (=). then the rules {vat). (app). (abs). (coerce) \nand (equal) are sound ,rod complete for deducing typing st'gemcnl,: that hold in all models of T. proved \nusing rules (va0, (app), (abs) and (coerce). Similarly, ife is in/3,rl-normal form and C,A I c:~r is \nvalid in :dl extensional lambda models, then these four rules arc sufficient to prove C,A I e:cr. Proof: \nSuppose C,A I e:a is valid. Then C,A I e:a is prowtble from the live rides, with = interpreted appropriately. \nBy the equality postponement lemma, there is some fwith f=e and C,A I f:o\" provable =,sing only rules \n(vat), (app), (abs) and (coerce). By property (*), there is some term d which both e and f reduce to. \nBut since e is in normal fornt, we conclude that f reduces to e. So by the subject rcdtlction lemma, \nit follows that C,A I e:a is provable without rule (equal).ll Corollary !.2: If \u00a2r C t holds in every \nmodel and type environment sadsfying a coercio,~ set C, then C }-- aC_. ~'. Proof: Note that ifC semantically \nimplies o C_. ~-, dlen C,{ x:cr} I x:r must bc valid lbr any variable x. Since x is in normal form, this \ntyping statement is provable using rule (vat), (app), (abs) and (coerce). But then it is easy to see \nthat the only applicable rules arc (va0 and (coerce). Thus C I--- o\" C: ~-. I The proofs of both corollaries \nrely on equality postponement ,and the subject reduction Iemma. Although rule (arrow) is not used in \nthe proof of Theorem 1, it is used critically in the proof of the subject reduction Icmma. Since Theorem \n1 depends on rule (arrow) only in that (arrow) ensures that types are closed under 0-reduction, the rule \n(eta) From C,A I hx.ex:cr with x not free in e derive C,A I e:\u00a27 eliminates the need for nile (ar,~ow). \nNote that rule (eta) is a sotmd, derived rule (by the subject reduction lemma), even for noncxtensional \nmodels. It is interesting to note that Corollary 1.2 also holds for the much more specialized \"ideal\" \nmodel of types [] l] for I,'unbda models which are complete partial orders (el. [14]). In the ideal model, \nthe only sets that are considered to be types are sets with specific order properties. 5. A Type Checking \nAlgorithm An important feature of tile four typing rules (var), (app), (abs) ,and (coerce) is that whenever \nwe can prove a typing statement C,A I e:cr, we know that all sttbterms of e are typablc. An intuitively \nappealing principal is that an expression should be typable only if all its subterms are typable. This \nprincipal, along with the fact that typing using (equal) is algorithmically intractable, suggests that \nwe should base a type checking algorithm on the proof system without rule (equal). ht the remaining sections \nof the paper, we consider typing only as defined by the first four typing rules, not semantic typing \n characterized by the system with (equal). While a statement C,A J c:or tells the type of e subject to \nsome assumptions about coercions and types of variables, it does not tell us the types of sttbterms ore. \nAs a consequencc, it is difficult to tell by inspection whether a statement is provable from rules (var), \n(app), (abs) and (coerce). Furthernlorc, a provable statement C,A I e:# does not give any information \nabout which types might have been given to bound variables in the proof of the statement. We will be \nable to analyze the type checking algorithm TYPE more easily, and associate types with binding occurrences \nof bound variables, if we use more dctai!cd formulas that include the types of all subterms. An explicitly \ntyped term ~ is a term e together with a mapping from subterms of e to type expressions. We will be informal \nabout the mapping and write types as subscripts whenever we need to mention them explicitly, i.e. 6- \n0 denotes an explicitly typed term ~\" whose type is a. Normal well-typings are defined as follow~!. C,A \n16\"0 is a normal well-typing if (i) ~\" is a x o tbr a variable x and either (a) a(x) = \u00a2ror (b) for \nsome T, we have A(x) = r and C I--- r C tr (ii) ~\" is an application ffp ..., r f\"u such that (a) both \nC,A I ffp --, ~ and C,A I f'o are normal well-typings (b) u = p   (iii) ~\" is an abstraction ~,xo.ff~., \nthe type a is p ~ T, and C, A[p/x] I fir is a normal well-typing We @line well-typings using an inductive \ndclilfition as above, but substitute the clause (iib') C I-- uC_ p for o = p in case (ii) above. Note \nthat every normal well-typing is a well-typing. Wc will see fi'om I cmma 5 that there is an efficient \nidL,,oritlml Ibr checking whether C I--- T CS .o. It follows that wc can easily decide whether a c:~udidatc \nC.A j eo is in fact a well-typing. I,emma 5: The predicate C t-- r Q or is decidable in liq,e'~r lime, \ngiven a subroutine tbr the transitive clo,;u rc of C. 'rhe i~roof is straight forw~lrd using Lcmma 1. \nWc have the following lcmma rclati1~g well-typings to provable statements. The Icmma may also be interpreted \nas a normal form Icnlnla fi)|' ploofs fi'Otll (v:.tr), (~.illp), (:.lbs) ;.lnd (coerce). I.emma 5 implies \nth:~t it is only ncccr,sary to use rule (coerce) immedhtcly Ibllowing a use of rule (var). l,emma 6\" \nA statcmc1~t C, A I e:tr is prov~ble (without the equality rule (equal)) ill\" there is ~m explicit typing \n6-aofe such dmt C.A I e-or is a l~orrn~d well-typing. Given a term e, Algorithm TYPE will deduce a well-typing \nC, A J e'a if any well-typing for c exists. The coercion set C will contain coercions between type variables. \nIt is tempting, at first glance, to try to generalize the algorithms of [7] or [13] to find typings relative \nto some given, fixed set of coercions between type constants. For cxample, given a coercion set C and \na closed term c, we luight try to compute an explicitly typed term ga such that for every well-typing \nC. A 1 6-r, the term 6-~. would be a substitution instance of 6- 0 . Without coercion sets, this is possible \n[4, 7]. I--Iowcver. this catmot bc done for all coercion sets. An example will be givcn in the final \npaper. Substitution and Coercion Set Algorithms Algorithm TYPE will use three subsidiary algorithms. \nOne computes coercions sets and the other two produce substitutions. A substitution is a timction from \ntype variables to type 181 expressions. If or is a type exprcgsion and S is a substitution, then S~r \nis the type expregsion obtained by replacing each variable t in a by S(t). If6- is an explicitly typed \nterm. then $6- is the result of applying S to every type in 6-. A substitution S applied to a type assignment \nA is the assignn~ent SA with (SA)(x) = S(A(x)). We define an equivalence relation on types before defining \nthe effect of a substitution on a coerci:m set. After these definitions, we consider the substitution \nalgorithms. Intuitively, two type expressions match if they have the same form. More precisely, (i) if \n~r is atomic, then cr matches 7. iffr is atomic (ii) ira= crl--, o 2. then \u00a2r matches 7. iff  7.= 7\"1-,7\" \n2 and or I matches r I and 0 2 matches 7.2. It is easy to verify that matching is an equivalence relation \non types. Furthermore, for any type a, there is a type p, the most general type that matches e, with \nthe property that if\" e matches 7., then 7. is a substitution instat:ce of p. The most general type that \nmatches e may be prodttced from ~r just by renaming occurrences of type variables so that no type variable \nappears twice in the expression. Recall that a coercion set C may o,lly contain coercions between type \nconstants and type variables, not type expressions. For example, the coercion set {t -, t C_ t} is not \nwell-formed. In order to use substitution as a mechanism for generating new well-typings, we have to \ndefine the action of a substitution S on a coercion set C. Given any coercion crC_7, between matching \ntype expressions a and 7., there is a unique minimal coercion set that implies ace. Lemma 7: Let a and \n7. be matching type expressions. There is a coercion set C with C I--- aC~- and such that ifC 1 I--- \nGC7., then C 1 b-- C. The lemma is proved by observing that a coercion set C implies Orl~Or 2 C_ 7.1-'7.2 \n only if C implies 7.1CGI mid C implies G2C7. 2. The minimal coercion set that implies aC'_7, will be \ndenoted COERCE(~, 7.). A linear time algorithm for COERCE(a, r) will appear in the appendix of the final \npaper. A substitution S respects coercion set C if, for every oC_~- in C, we have Sa matches $7.. if \nS respects C, then we define the action of S on C by SC = UoCjE c COERCE(a, 7.). Suppose A t and A 2 \nare type ,assignments with the same finite domain. Robinson's unification algorithm, UNIFY(A i, A2), \ncan be used to find a most general substitution S that gives SA 1 = SA 2. If no such substitution exists, \nthen UNIFY will fail. Lemma 8: There is an algorithm UNIFY(At, A2) which computes a substitution S with \nSA 1 = SA 2 if any such substitution exists. Furthermore, if R is any substitution with RAI=RA2, then \nthere is a substitution T with R = T*S. The algorithm UNIFY can be programmed to run in time O(n a(n)), \nwhere n is the sum of the lengths of the type expressions and the function a is the inverse of Ackermann's \nfunction (cf. [15D. Wewill also use a modified version of UNIFY to compute most general matchings. Two \nassignments A 1 and A 2 match if they have the same domain and, for every x in their domain, Al(X) matches \nA2(x ). The algorithm TYPE uses an algorithm MATCH to compute matching substitutions that respect certain \ncoercion sets. The algorithm MATCH(C, A 1, A 2) computes a most general substitution S that causes A \n1 to match A 2 and that respects C. The algorithm, essentially a modification of unification (cf. [15, \n18]), fails if there is no substitution S such that SA 1 matches SA 2 and S respects C. More formally, \nLemma 9: Let C be a coercion set and A 1 and A 2 b\u00a2 type assignments, lfS = MATCH(C, At, A2) , then S \nrespects C and SA 1 matches SA 2. Furthermore, if R is a substitution that respects C such that RA t \nmatches RA 2, then S = MATCH(C, AI0 A2) succeeds and R = T*S for some substitution T. The algorithm MATCH \nand the proof of the lemma will appear in the final paper. Given any finite set of type variables r. \nwe may assume that the range of S = MATCH(C, At, A2) does not use any elements of \u00a2. i.e. we may assume \nthat for all type variables t and u, tE*'m t does not appear in Su. This assumption is used in the proof \nof Theorem 3. If A is a type assignment, A \\ x denotes the assignment which is identical to A, but not \ndefined on x. If A 1 and A 2 are type assignments, then A 1 \\ A 2 is file assignment A 3 with A:t(x ) \n= a iffAt(x) = a and x is not in the domain ofA 2. Instances of Well- Typings Well-typings are preserved \nby substitutions that respect coercion sets. Let C. A 1 6-o be a well-typing. A well-typing C', A\" 16\"~. \nan instance of C, A I 6-a if there exists a substitution S which respects C such that C' I- SC, A' IFV(e) \n= SA IFV(e), and 6-~. = $6- o. Here FV(e) denotes the set of variables that apl)ear free in e. Note that \nSC, SA I S6-a is an instance ofC, A I e'o' We have l,emma 10: Let C,A I 6-a be a well-typing. Every instance \nofC.A 1 6-0 is a well-typing. The proof is by induction on the structure ore. Algorithm TYPE The algorithm \nis wdtten below in ~ applicative style. Given un~ped expm~ion e', the algorithm either ~tums a well-typing \nC, A [ ~ or fails. The \"overba~\" on cxplicitly typed ~rms a~ omitted ~r typographical ~a~ns. TYPE(e')= \ncases e\" is a variable x: let s and t be new type variables return {sct }, (x:s} I xt e' is an application \nde: let C z, At I de = TYPE(d) Cz, Az I e~ = TYPE(e) A a = At U (A z \\ At) A 4 = A z O (A 1 \\ At) R = \nMATCH(qUC2, A3[a/z ], Ad[e-~t/z]) where z and t are new variables S = UNIFY(R~, RA4) = R C = COERCE(S~, \nLefl(Sa)) return C U SC 1 U SC z, SA a I Sdoef e' is an abstraction hx.e let C, A, e t = TYPE(e) return \nC, A \\ x I ~XA(x).er end cases The fimction /.eft(tr) used in the application case returns a I if a \nis of the form o\"1-,o 2 and is undclined otherwise. It is easy to sec that the value of Le~ is defined \nin the call above. The algorithm may fail in the application case if either the call to MATCtl or to \nUNIFY fails. If 1YPt'(e) does notfitil, then it produces a well-typing. Theorem Z: I.ct C, A I 6- 'p \n= TYI't!(c'). Then every instance of C, A 16- 'p is a well-typing. Conversely, it\" there is a well-typing \nfor e, then TYPE(e) will produce a well-typing. Theorem 3: Suppose C', A' ] 6-\" 'p is a well-typing. \nThen TYPE(e') = C, A I 6 'a succeeds. Furthermore, C', A' I c-- 'p is an instance of C, A. 6- \"o. Theorem \n2 is proved by induction on the structure or'terms. Proof or Theorem 3: The theorem is proved by induction \non the structure of ter,ns. Suppose e' is a variable x and C', A' I Xa is a well-typing. The algorithm \nreturns{ set }, {x:s} I Xr [.et ~-= A'(x) and let T be the substitution [r,a/s,tl. Then certainly A'II:v(e\" \n) = ('F{x:s})lFv(e') ,and Tx t = x o, Furthermore, since C'. A\" ] x a is a well-typing, we must have \nC\" I-- T{ set }. Thus C', A\" I xo is an instance of TYPE(x). Suppose e\" is an application de. and C'. \nA' ] cT#__,u6- k is a well- typing. By the inductive hypothesis, C', A\" [ fflL_,u is an instance of C \n1, A 1 [ c]\" a and C', A\" I c-k is an instance of C 2. A 21 e-r, where C 1. C 2, etc. are as defined \nin the application case of Algorithm TYPE. Since A 1 assigns types to all free variables in d, we have \nA t IF Vtd) = A3 IFV(d). Similarly, A 2 IFV(e) = A4 [FV(e). Therefore, C', A' ] d'~...,p is an instance \nof C l, A 3 [ d\" o and C',.A' 1 6-k is an instance of C 2, A 416-r. We assume that UNIFY and MATCH always \nuse new variables, so no type variables in C 2, A 4 [ 6-,r appear in C l, A 3 [ fla. Therefore, both \ninstances above are by a single substitution T 183 that preserves C1UC 2. By the pmpertics of MA'FCH, \nwe know that T = \"I';~oR for some T R, whcrc R is as i, Algorithm TYPE. Furthe0nore, by the properties \nof UNIFY, we can see that there must be ~)mc substitution T s such that \"F = TsoS, where again S is as \nin Algorithm TYPE. We have now shown that C\" ~- Ts(SC 1 U 5C2), A\" IFV(e') = TsSAI = TsSA2. Since C', \nA' 1 6\" \"p is a well-typing we must have C\" I-- TRCOERCE(Sr, LeB(Sa)). It follows that C', A' 1 6\" 'p \nis an instance of C, A 1 6\" '~. Finally, suppose e' is an abstraction ?~x.e and C', A\" I ~,xlx.6\"~, \nis a well-typing. Then, by dclinition of well-typing, C', A'I/t/xl 1 6.u is a well-typing. By the inductive \nhypothesis, this well-typing is an instance of TYPE(e) = C, A I~,. This means that there must be a substitution \nSsuch that C' F-- SC. A[p./x] IFV(e) = SA II:v(c) and 6\"z, = S6.r, So A' IFV(e') = S(A \\ x) IFV(e') and \n~xp..6. v = S(XXA(x).6.r). This concludes the proof of Theorem 3. I A simple modification to Algorithm \nTYPE inserts calls to conversion functions. The modification does not affect the running time of the \nalgorithm. A complete description is deferred to the final paper. Conclusion A relatively simple set \nof inference ndes is sufficient to deduce all semantically valid types of any expression. However, sema, \ntic completeness is achieved at the cost of making the set of types of a term undecidable. When the inference \nrule that gives semantically equivalent expressions the ~ame set of types is removed, the consequences \nof the inference systcm become decidable. A type inference algorithm for the decidable set of inference \nrules is presented. Algorithm TYPE allows automatic coercions to be added to programming languages like \nML. It may also be used to insert calls to conve~ion fimctions at compile time. One appcali,g property \nof algorithm TYPE is that a term has a type only if all subterms have types. If we think of the typable \nexpressions ~ts the expressions that are easy for human readers to undcl~tand, then algorithm TYPE will \nforce a programmer to write code with the property that each subsection of a program is easy to understand. \nNo untypable subsections will pass the type check. The simple language of type schemes without binding \noperators does not allow some useful expressions to be typed. More complicated type disciplines, e.g. \n[5,10,14,1~], let more complicated expressions be given types, without sacrificing the principle that \nan expression is typable only if every subexpression is typable. Containment of types is a crucial issue \nin type inference for these type disciplines, It is hoped that the. study of type containment presented \nhere will be of use in developing more flexible type inference procedures. References I. Barendregt, \nH.P, The I.ambda Calculus: Its Syntax and Semantics. North Holland, 1981, 2, Barendregt, H., Coppo, M. \nand Dezani-Ciancaglini, M. A Filter Lambda Model and the Completeness of Type Assignment. J. Symbolic \nLogic (1987). to appear. 3. Curry, FI.B and Feys, R. Combinatory Logic/. North-Holland, 1958. 4. Damas, \nL. and Milner, R. Principal Type Schemes for Functional Programs. 9-th ACM Symposium on Principles of \nProgramming Languages, 1982, pp. 207-212. 5. Fortune, S., I,eivant, D. and O'Donnel, M. The Expressiveness \nof Simple and Second Order Type Structures. JACM 30, 1 (1983). pp 151-185  6, Gordon, M.J., R. Milner \nand C.P. Wadsworth. Lecture Notes in Computer Science. Vol. 78: Edinburgh LCF. Springer-Verlag, 1979, \n 7. Hindley. R. The Princip,ql 'l'ype-Scheme ofan Object in Combinatory I_.ogic. Trans. AMS 146 (1969). \npp 29-60. 8. Hindley. R. The Completeness Theorem for Typing I.,'uubda Terms. Theor. Comp. Sci. 22 (1983). \npp 1-17. 9. Hindley, R. Curry's Type Rt, lcs Are Complete with Respect to the F-Scma,ltics Too. Theor. \nComp. Sci. 22(1983). pp 127-  133. 10. Leivant, D. Polymorphic Type Inference. Proc. 10-th ACM Syrup. \non Principles of Programming Languages, 1983, pp. 88- 98. I1. MacQttcen. D. Priwite Communication. 1983. \n12. Meyer. A.R. What Is A Model ot'the I.ambda Calet, lus ?. Information and Control 52, 1 (1982). pp \n87-122. 13. Milner. R. A Theory ofType Polymorphism in Programming. JCSS 17 (1978). pp 348-375. 14. \nMacQueen, D. and Sethi. R. A Semantic Model of Types for  Applicative i.anguages. ACM Syrup. on LISP \nand Ftmctional Programming. 1982, pp. 243-252.. 15. Paterson. M.S. and Wegm,'m, M.N. Linear Unification. \nJCSS 16 (1978). pp 158-167. 16. Reynolds. J.C. Towards a Theory of Type Structure. Paris Colloq. on \nProgr,-unnling, 1974, pp. 408-425. 17. Reynolds, J.C. The Craft of Programming. Prentice Hall, 1981. \n 18. Robinson, J.A. A Machine Oriented l.ogic Based on the Resolution Principle. JACM 12. 1 (1965). pp \n23-41. 19. Scott, D. l)ata Types as l.attices. Siam11 Comput. 5, 3 (1976). pp 522-587.   \n\t\t\t", "proc_id": "800017", "abstract": "<p>A simple semantic model of automatic coercion is proposed. This model is used to explain four rules for inferring polymorphic types and providing automatic coercions between types. With the addition of a fifth rule, the rules become semantically complete but the set of types associated with an expression may be undecidable. An efficient type checking algorithm based on the first four rules is presented. The algorithm is guaranteed to find a type whenever a type can be deduced using the four inference rules. The type checking algorithm may be modified so that calls to type conversion functions are inserted at compile time.</p>", "authors": [{"name": "John C. Mitchell", "author_profile_id": "81338490160", "affiliation": "Bell Laboratories, Murray Hill, New Jersey", "person_id": "PP43125642", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800017.800529", "year": "1984", "article_id": "800529", "conference": "POPL", "title": "Coercion and type inference", "url": "http://dl.acm.org/citation.cfm?id=800529"}