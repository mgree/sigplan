{"article_publication_date": "01-15-1984", "fulltext": "\n An ideal model for recursive polymorphic types David MacQueen Bell Laboratories Murray Hill, New Jersey \n07974 Gordon Plotkin Department of Computer Science University of Edinburgh Edinburgh EH9 3J2 Ravi \nSethi Bell Laboratories Murray Hill, New Jersey 07974 1. The setting We will consider types as somehow \nbeing or generating constraints on expressions in a language. A consistent type discipline will ensure \nthat any expression satisfying the constraints will not produce a run-time error. For example during \nany evaluation of the expression f(x), the value off must be a function; otherwise, a run-time error \noccurs because the computation cannot proceed. As we want to guarantee the absence of such run-time errors, \nthe constraints on the values off and x must be spelled out further. In particular, if the value of x \nsatisfies constraint s, then it suffices that f is a function that is applicable to all such values. \nFor instance, f might satisfy the constraint of sending all values satisfying s to values satisfying \nanother constraint t. These constraints on the values off and x will bc written as: X : $ f:s-.t It follows \nfrom the above constraints that the value off(x) satisfies t. This inference can be written as the rule: \n,f : S \"*t X : S f(x) : t Inferences like the above (i.e. f(x) : t) will be made using a formal system \nof axioms and rules in which terms like s, t, and s -* t are called type expressions, or simply types. \nOne advan- tage of the formal rules is that they allow type inference to be studied separately from the \nunder- lying intuition of types being sets of values. Consider for example the expression x(x). Reason-ing \nas for f(x) above, Permission to copy without fee all or part of this material is 10\"anted publication \nand date appear, and notice is given that copying is by provided that the copies are not made or distributed \nfor direct permission of the Association for Computing Machinery. To copy commercial advantage, the ACM \ncopyright notice and the title of the otherwise, or to republish, requires a fee and/or specific permission. \n&#38;#169; 1983 ACM 0-89791-125-3/84/001/0165 $00.75 X \". 5 X : S \"*t It is natural to formulate a system \nof rules in which we equate the constraints on x, leading to s = s --- t, and wc use the notation Ixs.s-'t \nto formally denote a solution of this equation. Morris [16, pp. 122-124] observes that such rccursivc \nor circular types allow types to bc inferred for combinators like Y (scc Scction 3). However, it is nontrivial \nto model constraints as sets of values so that thcrc is a set of values s satisfying the equality s = \ns --\" t. Wc will present a model in which almost all such equations have solutious, and these solutions \nwill bc unique. Our semantic model of types, essentially that described in III I (scc also 113, 21, 22]), \nwas developed to explain the implicit form of polymorphism based on type quantification, as used in the \nprogramming languages ML 161 and I lope 131. It is a formalization of the naive view of types as sets \nof values; a value x has a type s if x is a member of the set of values modeling s. Other models (e.g. \n1121), which combine recursion with the explicit form of polymorphism expressed in terms of type parameters \n!181, do not lend themselves to such an intuitive interpreta- tion. The main technical innovatio, of \nthis paper is the use of a metric structure on types to establish the existence and uniqueness of solutions \nof most rccursivc type equations. 2. An aside on self application The expression x(x) is an example of \na se![application, because x is applied as a function to itself. Self application is essential to the \ntreatment of recursion in the lambda-calculus; this is suf- ficient motivation for studying the type \nchecking of expressions containing self application. It may however be helpful to give an example showing \nthat pure self application also occurs in languages like Pascal, C, and Lisp that allow function parameters \nwith incomplete or nonex-istent type specifications. The following definition of the factorial function \nin Pascal uses self application of the auxiliary function f and its parameter function g. function factorial(n: \ninteger): integer; function f (function g: integer) : integer ; var m: integer ; begin m := n; if \nm = 0 then f := I else begin n := n -I; f := m ~ g(g) end end; begin factorial := f(f) end; The types \nof both f and g could be given by Vs.s --int, but in fact the function compiles because the parameter \ntypes of function parameters are not checked (in the original definition of Pascal). The language in \nthis paper is based on the lambda calculus, but the results are applicable to imperative languages as \nwell. Henderson 17] relates type checking of most programming language constructs to type checking of \na functional language. 3. Examples The examples in this section suggest the typc inferences we would \nlike to make. Similar to the expressions f(x) and x(x) mentioned above, is the \"nonsensical\" expression \n3(x). The type of the subexpression 3 is int, the type of x call bc represented by a variable s, but \nit is not possible to infer a type fi~r 3(x) since an i,teger cannot be applied as a function. The remaining \nexamples hcrc consider expressions fi~r which types can be found. We return to the expression x(x) since \nmany of the questions addressed in this paper can be discussed in connection with it. Recall that the \ntype constraims on the two instances of x lead to the type s = s--,t for x. The discussion of x(x) extends \nto the larger expression hx.xx.t Sincc the type ofx is s = s--,t, xx has type t, hx.xx has type s = s--,t, \nand the type of (hx.xx)(hx.xx) is I. Two remarks provide some perspective on the above discussion. (1) \nSince there arc no constraints on the type variable t, the above discussion applies with any type expression \nsubsti-tuted for t. Thus, (hx.xx)(hx.xx) has type ~r for any type expression tr. Since the meaning of \n(hx.xx)(Xx.xx) is /, it follows that _L has every type. The sets of wducs used to model types must therefore \nalways bc noncmpty. Moreover, nontcrmitmting expressions can have well defined types. (2) Any pure lambda \nexpression has type I~t.t'-'t, i.e. t = t--,t, since the expres- sion can be used either as a function \nor as an argument. It follows that constants like 3 arc needed to construct expressions like 3(x) that \ndo not have types. A type can also be inferred for the Y combinator 116]. Recall that Y = xy. (Xx.f(xx))(Xx.f(xx)) \nThe first few lines are familiar by now: X : $ = S \"* t XX: t f: t -.t' from xx : t and f(xx) f(xx) : \nt t Xx.f(xx) : s -; t' from lambda abstraction The self application in the expression (hx.f(xx))(hx.f(xx)) \nresults in its type being s = s --t'. Faced with the equalities S \"* t = $ = 5 \"P t t we equate t and \nt'. Then.f : t --t and (as might be expected)  Y: (t't)'t 4. Relation to type checking In order to \nplace the above discussion on a precise footing, we need a formal system of axioms and rules to infer \ntypes. Wc sketch such a system in Section 7. Finding an algorithm for discovering types that can be inferred \nfrom the rules is a separate problem, it is desirable for an algorithm to discover the most general type \nfor an expression. For example, the Y combinator satisfies the constraint (t --t) --t for any type t. \nA less general statement is that Y satisfies the constraint (int --int) --int. Type expressions like \n(t--t)--t, containing type variables, are called type schemes following Hindley 18]. The type scheme \ndiscovered by an algorithm is princi-pal if it is the most general type scheme that can be inferred for \nthe expression from the rules. For the type systems of 18, 13, 16l, unification [191 can be used to construct \nlinear algorithms for discovering principal type schemes {41. We do not address the existence of principal \ntype schemes in the presence of recursivc types. However, it has been observed (e.g. 114]) that rccursive \ntypes can bc discovered using \"cir- cular\" unification in which a type variable can be unified with a \nterm containing it. in this way, the appropriate type can bc found for the Y combinator. (Such an algorithm \nhas been imple-mented for Scheme, which is a dialect of Lisp 1231.) Algorithms for \"circular\" unification \n[15] can readily be adapted from algorithms for testing the equivalence of (1) finite automata and (2) \nlinked lists with cycles [10, Section 2.3.5, Exercise 111. The almost linear algorithm for testing I \nAs usual, function application is indicated by juxtaposition attd associates to the left: both f(x)y \nand fxy are equivalent to (f(x))(y). equivalence of finite automata in [91 can be viewed as an implementation \nof the sketch in [10, p. 594]. A 0 = V A2 A1 Figure 1. The sequence A0, AI,  converges to A, yielding \na solution to the equation s = s -- t. Lines indicate inclusions between sets. 5. Informal types for \nself application The constraint f : s -\" t, requires f to map all values satisfying s to values satisfying \nt. If the constraint s is weakened to s', then, informally, s' denotes a larger set than s. Weakening \ns has the opposite effect on the type of a function from s to t, because f:s'-, t becomes a stronger \nconstraint: f is required to map a larger set to values satisfying t. Intuition on the role of-\" can \nbe provided by considering a particular sequence of sets that arises in connection with the equality \ns = s --t. The semantic counterpart of the operator --on types is the operator [] on sets of values modeling \ntypes. Informally, D [] E is the set of all functions that map elements of D to elements of E. In keeping \nwith the view of types as sets, let B bc the set of values modeling the type t. Starting with the set \nV of all values, we estimate the set A modeling s by writing the sequence: A 0 = V A1 = A0 [] B = VBB \nA2 = AjF;IB = (V B B) [] B A3 ---A2 [] B = ((VB B) B B)B n Since A0 is the entire set V of values, At \nconsists of functions that map all values in V to elements of B -a fairly restrictive condition. Since \nAI must be a subset of A0 = V, more func-tions belong to AI [] B than to A0 [] B. Therefore, A2 is a \nlarger set than AI. The inclusions we get are (see Figure 1): A0 _D A2 _D A 4 ~ At C A3 C As C_ Fortunately, \nit can bc shown that the limits of the even and odd sequences are the same, so there is a unique set \nA modeling the type satisfying the equality s -s --t. Howevcr, the techniques used to show this result \nabandon the approach based on the convergence of the unions and intersections of nested sequences. Instead, \nconverge,co is established using a metric on sets modeling types. Thc progression is as follows: 1. We \nbegin with thc spacc of values V uscd to givc the semantics of a iambda-calculus bascd language. 2. \nThe informal notion of a type as a sct of valucs is madc prccisc by considcring ccrtain sub- sets of \nV. These subscts modcl collections of structurally similar valucs, whcrc the tcrm \"structure\" refers \nto notions likc being a function, or bcing a pair. 3. The solution of recursive typc equations is facilitatcd \nby considcring thc convcrgence of particular sequences of types. Notc that thc scqucncc convcrging to \nA in Figurc 1 is neither monotonically increasing nor dccreasing. Convcrgencc of scqucnccs cannot therefore \nbe proved using monotonicity properties. Instead, wc dcfinc a metric that measures the dis- tance between \ntypes. 4. The Banach Fixed Point theorem 121 ca, bc invoked to show thc cxistcncc of unique fixed points \nfor \"contractive\" functions on metric spaces in which limits cxist. Wc show that this theorem can be \napplied to thc metric spacc of types.  Metric spaces have been used previously to invcstigatc thc scmantics \nof nondcterministic and parallel recursive programs 11, 5], whcrc thc main application was to obtain \nthc metric com- pletion of a space generatcd by finite elements. In our casc, wc start with a complete \nmetric space of types and obtain fixed points by using the Banach Fixed Point theorem. 6. Semantics of \ntype expressions 6.1. Domains. The space of values used to interpret the expressions of our language \nis V, which has an isomorphism: V ~T + N + (V--V) + (V x V) + (V + V) + {wrong}\u00b1 (6.1) This can be read \nas saying that V is (isomorphic to) the sum of the truth values T, the integers N, continuous functions \nfrom V to V, the produc~ of V with itself, the sum of V with itself, and a value wrong standing for (dynamic) \ntype-errors. The mathematics needed to solve equations like (6.1) is due essentially to Scott [20]. Details \nmay be found m many places, such as [17]. Solutions to equations like (6.1) are particular partially \nordered sets: a complete partial order (cpo) (D,_L-) consists of a set D and a partial order r- on D, \nsuch that (i) there is a least element 1 in (D,L-), and (ii) each increasing sequence xq~  ~x,/-  \n- has a least upper bound (lub) I._] x,. It will be necessary to know much more of the structure of V \nthan just that it is a cpo (in order to define a metric on sets modeling types). Well behaved cpos have \ntwo kinds of elements: finite elements; and limit elements, which arc iubs of increasing sequences of \nfinite elements. 2 The finite elements in any subset, X, of a cpo are denoted by X \u00b0. The cpos we consider \narc called domains; they have a countable number of finite elements. 3 6.2. Ideals. Type expressions \nwill bc interpreted using certain subsets of V, called ideals [13, 21, 22, 11]. Recall from the summary \nat the end of Section 6 that we think of a type as a collection of structurally similar values. The structural \ndistinctions that types are meant to cap- ture satisfy the following basic principles; (1) structure \nis preserved as we go \"downward\" to approximations, and (2) structure is preserved when wc go \"upward\" \nto limits of ascending 2 An element of a cpo is oJ-finite if and only if whenever it is less than the \nlub of an increasing sequence it is less than some element of the sequence. A set X is directed if every \nfinite subset of X has an upper bound in X. A cpo is oJ-algebraic if and only if it has countably many \nto-finite elements and given any element, the set of to- finite elements less than it is directed and \nhas that element as its least upper bound, to-algebraic cpos have lubs of arbitrary directed sets (sometimes \ncpos are taken to be partial orders with such lubs and .t); the to-finite ele- ments are even finite, \nmeaning that when one is below the lub of a directed set it is below some element. 3 A cpo is a domain \nif and only if it is consistently complete and to-algebraic. A cpo D is consistently complete, if any \nconsistent subset of D has a least upper bound; here X_CD is consistent if it has an upper bound in D, \nthat is there is a y(!D such that xr-y for all x in X. sequences of values. These notions are made precise \nin the definition of ideals. For technical rea-sons the definition is in two stages: a subset 1 of some \npartial order P is an order-ideal if and only if I. I4:O 2. Yy~l. Yx~D. xFy D x~l A subset I of a domain \nD is an ideal if and only if it is an order-ideal satisfying the additional constraint: 3. Y increasing \nsequences <x, > (Vn. x,, E 1) D LJx,, ~ I That is, ideals are the nonempty left closed sets closed under \nlubs of increasing sequences. Nonemptiness is needed becausc _L has every type (see Section 4). We write \n.~o(P) for the order- ideals of a partial order P and ~(D) for the ideals of a domain D. Ideals are determined \nby their finite elements. Regarding D* as a partial order (inherited from D) and ordering ideals by subset \nwe find: PROPOSITION. T/,e correspondence I~-.I \u00b0 is an isomorphism of <.,~(D),C> and <~0(D*),_C> with \ninverseJ+-.{lla,, I <a,,> an increasing sequence in J} n This proposition allows us to restrict attention \nto finite elements while comparing ideals. 6.3. Metric space of ideals. The idea here is to solve recursive \ntype equations by structuring the ideals as a complete metric space. The distance between two ideals \nwill be measured via a notion of the smallest rank of a finite element in one but not the other. The \nrank function will be left unspecified for the moment (except that it maps finite elements to natural \nnumbers), if I and J are ideals then a witness for I and J is any finite element that is in I but not \nin J or vice versa. The closeness c(1,J) of I and J is the least possible rank of a witness for I and \nJ, and if none exists it is 00. Given such an closeness function, one can define a metric d that measures \nthe distance between two ideals. Here we take d(I,J) = 2 -'(;d) where, by convention, 2 -\u00ae = 0. This \nis even an ultrametric meaning that d(1,K) ~< max(g(IJ),d(/,K)) holds, which is stronger than the triangle \ninequality. A sequence of ideals < li >i~ is called a Cauchy sequence if given any ~>0 there exists n \nsuch that for all i,j larger than n, d(li,li)<e. A metric space is complete if every Cauchy sequence \ncon- verges. TtJEOREM 1. The metric space of ideals is complete. D At first sight this theorem is a little \nsurprising given the arbitrary nature of the rank func- tion. But note, for example, that if the rank \nfunction is constant then the only Cauchy sequences are those which arc eventually constant. 6.4. Rank \nof an element, in order to apply this result to V we need to construct a rank function and consider its \nproperties. The domain V is constructed by a limiting process using a chain of domains V. starting from \nV0 = {_1.}: V.+I = T + N + (V.-.V.) + (VnxV.) + (Vn+V.) + ~/' The rank of a finite element is taken to \nbe the first place it appears in the chain. 6.5. Unique fixed points. In order to find ideals satisfying \nsuch equations as I = I F;I IN we use the Banach Fixed-Point Theorem [2]. A (uniformly) contractive map \nf:X -. Y of metric spaces is one such that there is a real number 0<~r<l such that for all x and x' in \nX, we have d(f(x),f(x')) <~ rd(x), and it is non-expansive if this holds but with r~<l. The generalization \nto n-variable functions requires d(l'(xl, . . . ,x,),f(x'l ..... x',)) <~ max{d(x,,x'~) I l~<i<~n} The \nBanach Fixed-Point Theorem states that if X is a nonempty complete metric space and f:X--.X is contractive \nthen it has a unique fixed point, namely limf\"(x.) where xc~ is any point in X. 6.6. Contractive maps. \nIn order to apply the Banach Fixed-Point \"l'heorem to determine ideals modeling recursive types, we need \nto consider the contractivcncss of maps on ideals. Some care is needed, since union and intersection \nhave the weaker property of being noncxpansive. Auxiliary maps. The projection functions ~ri:X~ x . \n \u00d7 X, -* Xi arc not contractive but are non-expansive. The composition ofa mapf:Xix \"  xX, -. Y with \ng,:Vix  \" \u00d7 V,, -* X, is non-expansive iff and all gi arc; iff is contractive and all g, are non-cxpansive \nthen the composi- tion is contractive and this holds also if all the gi arc contractive and f is nonexpansivc. \nFinally, we note that when Y is an ultrametric space then a map.f:XIx  \u00d7X,, --Y as abovc is con- tractive \n{non-expansive) iff it is contractive (non-expansive) m each argument taken separately. PROPOSITION. \nIntersection and union are not contractive but are non-expansive, considered as binary functions over \nideals. [] Type constructors. We define three binary functions on ideals corresponding to the three domain \nconstructions. The sum I [BJ of two ideals is defined by injecting I and J into V + V and taking the \nunion of the injections. The product 1 NIJ of two ideals I and J is simply I xJ. The exponentiation (function-ideal) \nis defined by: I [] J = {f~V--V I f(I)C_./} It is straightforward to show that, when viewed as a subset \nof V, each of these sets is an ideal. The idea behind the definition of the function-ideal appears in \nmany papers (see [13, 11] for example). The next theorem is central to the results of this paper. THEOREM \n2. All three functions, sum, product, and exponentiation, are contractive. [] The basic idea behind the \nproof of this theorem is that two distinct compound ideals (e.g. l[~J and I' NIJ') have a compound witness \nof least rank (e.g. <i,j> El[~J -1' ~zJ') whose com-ponents are simpler (i.e. lower rank) witnesses to \nthe differences between the componcnt ideals (e.g. i(l-l' and jEJ-J'). This implies that the compound \nelements are closer together than their components. Note that this theorem would fail if we kept the \nsame definition of exponcntiation but allowed arbitrary sets. Since (O[]O) = V and (V[]O) = O, cxponentiation \nis not then contrac-tive in its first argument. Quantification. Let ~(D) dcnotc the collection of all \nideals. Suppose f:~(D)\" ~I-*~(D) is a function of n + 1 arguments. Then we can produce a function of \nn arguments by \"quantifying\" its first argument. The universal quantification off relative to a given \ncollection of ideals 5YC~(D) is defined by: Ot X]')(l l ..... J.) = tg~f ( I d ,, . . . ,J.) and the \nexistential quantification by: ~xf)(]! ..... J,) = i~i(I,JI, ... ,J,) It is here that fixing on a particular \ncollection of sets as the types -the ideals -makes a difference to the definition of our operations, \nsince it affects the range of variation of the ideal I in the above definitions. THEO,EM 3. lf f :$(D)'+l-\"$(D) \nis contractive (non-expansi,,e) in its last n arguments, so are its universal and existential quantification, \no Fixed points. Our last construction makes sense in a general setting. Let f:X\u00d7 YIx  x Y, -* X be \na function of non-empty complete metric spaces which is contrac- tive in its first argument. Define the \n\"parameterized fixed-point\" function ~f:Yix  x Y, -* X by taking (~f)(Yl ..... y,) to be the unique \nelement, x, of X such that x=f(x,yl,  , y,,) as guaranteed by the Banach Fixed-Point Theorem. THEOaEM \n4. lf f is contractive (non-expansive) so is ~f . D The functions shown to be contractive/non-expansive \nin the above theorems are the seman- tic counterparts of constructors appearing in the type expressions \nbelow. The results of this sec-tion will be applied to show that the semantics of type expressions is \nwell defined. 6.7. Semantics of type expressions. The syntax of type expressions is given by an abstract \nsyntax grammar. The set of type variables TVar is ranged over by t, and the grammar is given by  ::= \nint I bool It I `'\" I ,r\u00d7,, I ,,+`\" I rrn~ I `'u,, I Vt.~ I =lt.cr J p,t.o, In fact, we cannot allow \nall such exprcssions since we can only give meaning to Ixt. cr when cr denotes a contractive function \nof t. So say `\" is (formally) contractive in t iff one of the following conditions hold: 1. `\" has one \nofthc forms int, bool, t' (with t'~t), crn--~r 2, ~rt\u00d7~r 2, or `'!+cr2. 2. cr has one ofthc forms `'nN`'2 \nor `'nUcr 2 with both cr I and cr 2 contractive in t. 3. `\" has one of the forms Vt'.`'b ::lt'.~rt, \nor Fzt'.`'l with either t' =t or `'1 is contractive in t.  Now we takc TExp to be the set of well formed \ntype expressions where cr is well formed iff one of the following conditions hold. 1. cr is int, booi, \nor t'. 2. cr has onc ofthc forms `'1--~r2, crl\u00d7cr 2, crt+cr2, criOcr2, or criLkr 2 with both ~rt and \nor2 well formed. 3. `\" has onc ofthc forms Vt. cr I or =It'.or1 with cr I well formed. 4. `\" has thc \nform I~t.`'t with ~rl well formcd and contractive in t. For the semantics wc dcfine thc semantic function \n  3\":TExp -. TEnv --#(V) where TEnv = TVar -* #(V) is the set of type environments ranged over by v. \nThe definition is by structural induction and below ~C.9(D) is the collection of ideals not containing \nwrong. ff~int~v = N ,ff~boolBv = T .~tDv = v~tB ~lIo\" I --* O'2Dl., = ,c~0\"I~V [] ,Gf~`'2]V ~rl x ~'2Dv \n= ~ll~,llv ~ ~-[tr2llv ~`'~ + ,,2ll,, = ~,,,Bv [] ~`'2]v ~t. `'],, = V~(~,t~,~(DL ~H ( vlVtl / ff~3t. \n`'fly = 3x(ht ~#(D). ~ll`'~ (vil/tl) ff~lxt. `'Iv = Fx(hl~#(D). ,\u00b0'~`'ll (vll/tl) TtlEOREM. The semantic.fio~ction \n,\u00b0'5 is well d(fined. 1:3 We prove by structural reduction on `\" that: (1) for all v, ~crllv is well \ndefined; (2) for any t, hl~$(D), ff~crll(v[l/t] ) is non-expansive, and is contractive if cr is contractive \nin t. The results of the last section make such a proof quite straightforward. It is also straightforward \nto prove that provided v(t) does not contain wrong for any t then neither does ff[erllv. 7. Rules for \ntype inference The rules for type inference are keyed to the syntax of type expressions. The rule for \nfunc- tion application is essentially like that for f(x) in Section 1, except that constraints like x \n: s and f : s --t are relative to an assignment .~ of types for the free variables in an expression: \nwritten F x : s and ~ k f : s --t. If e and e' are expressions, the rule for function application is \nas fol- lows (note that type expressions ~ and \"r are permitted instead of the type variables s and t): \n~ke : ~y ~'r ,~ke' :\u00a2y k e(e') : \"r The turnstile symbol I\" denotes a well typing relationship between \ntype assignments, value expressions, and type expressions that is defined by the inference rules: ~ k \ne :~ holds if and only if there is a proof of it using the rules. Rules tend to come in pairs, corresponding \nto the intro- duction or elimination of a type construct. For instance, the above function application \nrule could be called the --elimination rule, and its complement is the following --introduction rule \nfor typing lambda abstractions ,~,x:~y k e : 'r The rules for the usual type constructs, including universal \nquantification, are fairly standard, fol-lowing those of Hindley [8] and Milner [13, 4]. The rules for \nexistential quantification are novel, but are beyond the scope of this paper. To deal with recursive \ntype expressions, we add the following two rules that correspond respectively to \"unwinding\" and \"winding\" \nthe recursive type ,~Fe: Ia, t. cr F e: ~[p.t. Gr/t] F e : o[Izt. ~r/t ] As usual, we verify the soundness \nof these rules by proving (by structural induction on the expression e) that ~ k e :or implies that the \nvalue of e in any environment consistent with ~ is a member of the ideal denoted by o. 8. Conclusion \nThis paper justifies the extension of the type system of [11] to include recursive types. However, in \ncontrast to the type system of Milner [13, 4], it is difficult to decide in general whether a given expression \nhas a given type. It can be shown that this is a l-Ii-complete question, even when restricted to terms \nof the pure ~,-calculus and the type int-*int. It follows that no recursively enumerable axiomatic type \nsystem can be complete for the true type assertions. On a practical level, this paper justifies the extension \nof unification based type checking algorithms for the type systems of [8, 13, 4] to allow circular unification. \nSimilar algorithms can be applied to check the Algol family of languages, even though the types of procedure \nparameters are not specified. Note that dialects of Pascal that require full declaration of the types \nof pro- cedure parameters do not allow self application to be expressed since they do not support recur-sive \nfunctional types. -I0- References 1. A. Arnold and M. Nivat, \"Metric interpretations of finite trees \nand semantics of nondeter- ministic rccursive programs,\" Theoretical Computer Science 11, pp. 181-205 \n(1980). 2. S. Banach, \"Sur les operations dans les ensembles abstraits et leurs applications aux 6qua- \ntions inte'grales,\" Fund. Math. 3, pp. 7-33 (1922). 3. R.M. Burstall, D. B. MacQueen, and D. T. Saneila, \n\"Hope: an experimental applicative language,\" Lisp Conference, Stanford, pp. 136-143 (August 1980). \n4. L. Damas and R. Milner, \"Principal type-schemes for functional programs,\" Ninth Annual ACM Symposium \non Principh's qf Programmin\u00a2 Languages, Albuquerque NM, pp. 207-212 (January 1982). 5. J. W. deBakker \nand J. I. Zucker, \"Processes and the denotational semantics of con-currency,\" Information and Control \n54, pp. 70-120 (1982). 6. M.J. Gordon, A.J. Miiner, and C. P. Wadsworth, Edinburgh LCF, Lecture Notes \nin Com- puter Science 78 (1979). 7. P. Henderson, \"An approach to compile-time type checking,\" pp. 523-527 \nin Information Processing 77, ed. B. Gilchrist, North-Holland (1977). 8. R. Hindley, \"The principal \ntype-scheme of an object in combinatory logic,\" Trans. AMS 146, pp. 2%60 (December 1969). 9. J.E. Hopcroft \nand R. M. Karp, \"An algorithm for testing the equivalence of finite auto- mata,\" TR-71-114, Dept. of \nComputer Science, Cornell Univ. (1971).  10. D. E. Knuth, The Art of Computer Programming: Volume 1, \nFundamental Algorithms, Addison-Wesley, Reading MA (1968). 11. D.B. MacQueen and R. Sethi, \"A higher \norder polymorphic type system for applicative languages,\" 1982 Symposium on Lisp and Functional Programming, \nPittsburgh PA, pp. 243-252 (August 1982). 12. N.J. McCracken, \"An investigation of a programming language \nwith a polymorphic type structure,\" Ph.D. Thesis, Computer and Information Science, Syracuse Univ. (June \n1979). 13. R. Milner, \"A theory of type polymorphism in programming,\" JCSS 17(3), pp. 348-375 (December \n1978). 14. F.L. Morris, \"Automatic assignment of concrete type schemes to programs,\" unpublished (1977). \n 15. F.L. Morris, \"On list structures and their use in the programming of unification,\" Report 4-78, \nSchool of Computer and Information Science, Syracuse Univ. (August 1978). A fast algorithm for circular \nunification is credited to G. Huet, G. Kahn, and J. A. Robinson. 16. J. H. Morris Jr., \"Lambda-calculus \nmodels of programming languages,\" Ph.D. Thesis, Sloan School of Management, MIT (1968). 17. G. Plotkin, \n\"Advanced domains,\" Summer School, Pisa (1978). 18. J.C. Reynolds, \"Towards a theory of type structure,\" \npp. 408-425 in Programming Sympo- sium, Paris, 1974, Lecture Notes in:Computer Science 19, Springer Verlag, \nBerlin (1974). 19. J.A. Robinson, \"A machine-oriented logic based on the resolution principle,\"J. ACM \n12, pp. 23-41 (1965). 20. D.S. Scott, \"Continuous lattices,\" pp. 97-136 in Lecture Notes in Mathematics \n274 (1972). 21. A. Shamir and W. W~ Wadge, \"Data types as objects,\" pp. 465-479 in Automata, Languages \nand Programming, 4th Colloquium, Turku, Lecture Notes in Computer Science 52, Springer- Verlag, Berlin \n(1977).  22. W.W. Wadge, Personal communication to R. Milner, March 1978. 23. M. Wand, personal communication, \nJanuary 1983.   \n\t\t\t", "proc_id": "800017", "abstract": "", "authors": [{"name": "David MacQueen", "author_profile_id": "81100334808", "affiliation": "Bell Laboratories, Murray Hill, New Jersey", "person_id": "PP39038174", "email_address": "", "orcid_id": ""}, {"name": "Gordon Plotkin", "author_profile_id": "81100235459", "affiliation": "Department of Computer Science, University of Edinburgh, Edinburgh EH9 3J2", "person_id": "PP43117857", "email_address": "", "orcid_id": ""}, {"name": "Ravi Sethi", "author_profile_id": "81100354362", "affiliation": "Bell Laboratories, Murray Hill, New Jersey", "person_id": "PP39039094", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800017.800528", "year": "1984", "article_id": "800528", "conference": "POPL", "title": "An ideal model for recursive polymorphic types", "url": "http://dl.acm.org/citation.cfm?id=800528"}