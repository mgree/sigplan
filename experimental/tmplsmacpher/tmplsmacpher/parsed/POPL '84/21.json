{"article_publication_date": "01-15-1984", "fulltext": "\n Paragon: Novel Uses of Type Hierarchies for Data Abstraction Mark Sherman Department of Math. and \nComputer Science Dartmouth College Hanover, NH 03755 1. Introduction This paper describes the design \nof the Paragon programming language. Through the use of multiple, inherited classes, a uniform object \nnotation, separate procedure specifications and implementa- tions, and relaxed parameter matching rules, \nParagon provides better support for data abstraction than current languages. This paper first describes \nthe goals for the design of Paragon and briefly relates these goals to previous work. Then a brief introduction \nto Paragon's class structure, object notation and procedure definitions isprovided. In the next section \nI give program examples that illustrate how Paragon supports data abstraction. The last section gives \na brief status of the Paragon work. 2. Goals of Paraqon The goals of Paragon can be grouped into three \nbroad classes: abstract data type specification goals, abstract data type representation goals and automatic-processing \ngoals. These goals are listed below: This research was sponsored by the Defexme Advanced Research Projects \nAgency (IX)D), ARPA Order No. 3597, monitored by the Air Force Avionics Laboratory Under Contract F3361S-81-K-IS39. \nThe views and conclusions contained in this paper are those of the author and should not be interpreted \nas representing the official policies, either expressed or implied, of the Defense Advanced Research \nProjects Agency or the US Gov- ernment. Permission to copy without fee all or part of this material is \ngranted Abstract Data Type Specification Goals * Refinements of speclficatio_ns of abstract data types \nmay be written. * Related s~. cifleations may be combined in a single module.  Abstract Data Type Representation \nGoals * Multiple implementations of an abstract data type may be de qlared in a program. Several implementations \nof an abstract data type may be used simultaneously in a program (one implementation per variable). If \nseveral implementations of an abstract data type are used for different variables, those variables may \ninteract. * A si__ng!e__im~.nt.a_ti.on may be written for several separaLe S/~_\u00a3i_ficati.ons,  Automatic-Processing \nGoals * Static .t_ypa ..c.hecking of all variable decla- rations (object creations ) and procedure calls \nshould be supported.  * C_o..mp~le-time checkinq should ensure that al.l r_epXgsentation-selection decisions \nresult in a program that can execute without run-time errors.  Although many languages are designed \nto meet some of these goals, no language known to me can meet all of theN. After a review of how other \nlanguages only paritally meet these goals, a description of Paragon is given along with examples of \nhow a programmer can use Paragon to achieve these goals. provided that the copies are not made or distributed \nfor direct commercial advantage, the ACM copyright notice and the title of the publication and its date \nappear, and notice is given that copying is by permission of the Association for Computing Machinery. \nTo copy otherwise, or to republish, requires a fee and/or specific permission. &#38;#169; 1983 ACM 0-89791-125-3/84/001/0208 \n$00.75 The abstract data type specification goals are partially met by the object-oriented language \ndesigns in Simula [Dah168 ] and Smalltalk [GoldbergS1, Ingalls78, Ingalls8l, Morgan81, Xerox81], the \nTraits additions to Mesa [Curry82] and the Flavors facility for Lisp [WeinrebS1]. An 208 extension of \nSimula proposed by Ingargiola [Ingargiola7S] allows, in a very restricted way, layers of spacifications. \nA similar kind of hierarchy was proposed by Smith and Smith [ Smith77 ] and in Taxis [Mylopoulos80 ] \nfor organizing relations, views and objects in a database. Further, the Program Develolnent System [Cheatham79] \nuses a refinement hierarchy for writing system modules. But all of these systems use the refinements \nonly as a way to refine objects or system components, and not as refinements of specifications with the \nintention of later refining the spacifications into imple- mentations. Both sets of abstract data type \ngoals are partially met by Clu [Liskov81], Alphard [ShawSl], Enhanced C [Katzenelson83a, Katzenelson83b], \nAdapt [Archibald83, Leavenworth81] and Ada [IchbiahS0]. However, all of these languages use exactly two \nlevels of refinements, the upper level being the abstract specification and the lower level being the \nconcrete implementation. The proposed layers of specifications are a departure from most languages that \nprovide data abstraction facilities. Further, these other Im:guages place strong restrictions on how \nrepresentations of abstract data types must be related to their spacifica-lions. These restrictions limit \nthe programmers ' abilities to define and use multiple implementa-tions of abstract data types, or to \nlet different implementations interact. In contrast, Paragon provides features that allow a progrmner \nto define and use multiple implementations of an abstract data type in a program. Further, the Paragon \ndesign permits different representations to have access to additional deta/Is about their parameters \nand use of the parameters' operations. This ability represents a substantial departure from current data \nabstraction methodolo~ which insists that a representation may be used anywhere the spacification is \nused. The goal of static type checking is a departure from the procedure-call checking performed in typical \nobject-oriented, hierarchy-based systems, such as for Smalltalk's methods and Simula's virtual procedures. \nThere is a tradeoff in these designs between safety and efficiency, and flexibility. Because the parameter \nmatching for procedure calls can be verified during compila- tion, static checking is considered safer, \nand because more is known about the program being chocked, a more efficient program should result. Therefore \nParagon opts for a safe and efficient languagerather than for flexibility. In applying this philosophy \nto a language that supports multiple representations of abstract data typas, the design of Paragon enforces \ncomplle-tlme chocking of implementations, guaranteeing that all variables have a feasible representation. \nFurther the design of Paragon ensures that a program's feasibility may be checked at compile time, that \nis, that appropriate procedure implementations exist for all procedure calls as dictated by the representations \nof the actual parameters in the cal 1. Another part of this philosophy is that no run-time expanse should \nbe incurred for making a selection decision. Although Paragon allows multiple procedure implementations \nto be provided for each procedure specification, the selection of an implementation to use for each procedure \ncall must be made at compile time. These goals are met by the Paragon design, which is sketched in the \nnext section. The following section then shows how these features are used to write layers of specifications, \nmultiple implemen- tations of abstract data types and various kinds of shared representations. 3. Introduction \nto Paragon Many details of Paragon resemble a typical algebraic language. Four aspects of Paragon strongly \ninfluence its support for data abstraction: classes and inheritance, separation of procedure specification \nand implementation, a uniform object notation and relaxed parameter matching rules. The interactions \nbetween those aspacts provides a Paragon programmer with tremendous flexibility for writing abstractions. \nEach aspect is discussed below. 3.1. Classes and Inheritance Classes in Paragon are similar to classes \nin Simula: they contain declarations, statements and parameters. Unlike Simula classes, Paragon classes \nmay inherit more than one class, and an ancestor may be inherited more than once. Also unlike Simula, \nclasses declared inside of a class may be selected from that class. Variable declarations in Paragon \nnamea class that s_L~_qi~fies the variable. Only the visible declara- tions in the class or one of its \nancestors may be used by the variable. An implementation for that variable is selected from the subclasses \nof the specified class. Every class may be used as a specification, implementation or both. 3.2. Procedure \nSpecifications and Implementations Procedures (which include functions and iterators) have separate spacifications \nand implementations. A procedure spacification is the signature of the procedure: the procedure's identifier \nand list of formal parameters. A procedure implementation is a signature followed by local declarations \nand statements. Any number of implementations may be written for each specification in the class (and \nin any subclass of the class) that contains the procedure specification. Paragon will select an appropriate \nprocedure implementation given the im- plementations of the actual parameters for each procedure call. \n 3.3. Uniform Object Notation Paragon uses a uniform object notation in all expressions. Expressions \nare used as formal parameters in class and procedure declarations, as actual parameters in class instantiations \nand Procedure calls, as \"types\" in variable declara- tions and as statements. The same interpretation \nof an expression is used regardiess of where it appears. There are three interesting parts of this notation: \ndefinite objects, i.ndefinite objects and anl objects. A definite object results from the instantiation \nof a class. This is the same as object generation in Simula, and uses the same notation: new ClasslD. \nGenerated (definite) objects are usually associated with variables through a variable declaration. An \nindefinite object can be thought of as a type. Its notation is merely a class name: ClassZD. An \"any\" \nobject is a special, predefined object with the property that any object matches it. Its notation is \n\"any\". This uniform object notation allows a programmer to specify a \"type\" parameter by using an indefinite \nobject as an actual parameter, to specify a constraint by using a definite object as a formal parameter, \nand to specify a procedure parameter by declaring a procedure in a class which can then be passed. Thus \nParagon can use this single notation to provide for commonly used facilities in other languages. 3.4. \nComparing Objects A relation called matchinq may exist between an actual object and a formal object. \nThe terms \"actual\" and \"formal\" are used in the conventional sense. Unlike most languages, the matching \nrelation is not symmetric. When an actual matches a formal, there is no implication that the formal matches \nthe actual. Since the expressions used as parameters evaluate to objects, object matching is used for \ncomparing parameters. At different times, the same parameter may be used as a formal and an actual. The \nfol I owi ng table e mmari zes the kinds of comparisons that occur in Paragon. Actual Formal Proc. \nCall Param. Proc. Spec. Param, Proc. Call Param. Proc. Implem. Param. Class Instance Param. Class Decl. \nParam. Subclass Decl. Param. Class Decl. Param, Proc. Implem. Param. Proc. Spec. Param, The basis for \nmatching is the comparison of two instances of classes. Intuitively, an actual object matches a formal \nobject if the underlying class of the formal is an ancestor of, or the same as, the underlying class \nof the actual. To ensure compatibl I ity between definite and ir~efinite instances, one of the following \nconstraints must also be met: * The formal is an an~ instance, * The formal is an indefinite instance \nand the underlying class of the formal is a ancestor of, or the same class as, the underlying  class \nof the actual, or * The formal is a definite instance and the actual is the same definite instance. \nFor example, \"integer\" matches \"Integer\", \"I\" matches \"integer\" and \"i\" matches \"I\", but \"integer\" does \nnot match \"I\" and \"I\" does not match \"2\". There are also rules that ensure that any parameters of the \ninstances match, but these rules are omitted for brevity, 4. S__u~99_r_ti.nq Data Abstraction In this \nsection, the features of Paragon are use to illustrate how data abstractions may be defined in Paragon. \nThese exaraples show how Paragon can describe and use shared specifications and repre-sentations. These \nexamples are programned using a style of programming called the ob~ect-.manager .model_, which is described \nbelow. 4.1. Object Managers and Nested Classes The object-manager model divides program objects into \ntwo categories : _mana~ and individuals. The manager iS created first and contains data and procedures \nthat are shared among all individuals. For each manager, there may be any number of individuals created, \nand each individual has a single manager. Naturally, each individual may have private data and procedures \nnot shared with other individuals. As an example of this model, consider integers. Each individual integer \ncan be represented as a word in memory. Further, there exists a procedure, \"Addition\", that is shared \namong all the individual integers, and so this procedure Much of the power of multiFle procedure implemen- \ntations and subclasses comes from the fact that their parameters need only match, not be identical with, \nparameters in the corresponding procedure specification or parent class. This is a radical departure \nfrom other data abstraction lang~mges, since this ability implies that an implementation may not necessarily \nwork anywhere that the speci-fication is permitted. Instead, Paragon uses a process called e_lab@!atti_gn \nw_/t_bh .i.m/).l_ee~.ntat~ons_ that ensures that feasible representation selections have been made. This \nprocess is similar to execution simulation. belongs to the manage r of all integers. Paragon implements \nthis model by using nested classes. The outer class defines the manager and the inner class defines the \nindividual. An example of such definitions is given in Section 4.2 below. 4.2. Classes for Specifications \n Classes in Paragon are used to represent two kinds of specifications: generalizations and descrip-tions. \nGeneralizations attempt to abstract some commonly used properties that are inherited by other specifications. \nFor example, Ada provides a generalization called nonlimited private which specifies that types declared \nas nonlimited private have the assignment operation defined for them. Clu provides a generalization that \nprovides an object with the ability to be transmitted over a network (see [Herlihy80, Herlihy82]). By \nproperly defining a set of classes for each set of operations that one m/ght want to refine (i.e., inherit) \nlater, one can provide the same predefined generalization features that other languages do but without \nlimiting the choices of operations. For example, a set of declarations that simulate the concept of nonlimited \nin Ada is shown below: class AssignableManager is class Assignable is begin end; procedure Assign(Assignable,Assignable); \nprocedure Equal(Assignable,Assignable) return Booteans.Bit; ~end; A description corresponds to an abstract \ndata type specification in other languages. It too consists of nested classes, and ,~ually inherits generalization \nclasses. An object manager that inherits the AssignableManager class would then define an nonlimited \ntype. Providing some details for the integer example shows this property: class IntegerManager of AssignableManager \nis begin ! Shared data and procedures go here ; procedure Addition(Integer,lnteger) return Integer; \n ! And the class definition for [ndivid~mls ; class Integer of Assignable is begin end; end ; One could \nuse these declarations to declare variables: var AppleManager => new IntegerManager; vat Lisa :> AppleManager \n. new Integer; var Cortland => AppleManager . new integer; and perform the operations declared in the \nspecified classes or their ancestors: AppleManager.Assign(Lisa,Cortland); The distinction between generalization \nand de-scription classes is by convention alone. Paragon places no restrictions on how a class is used. \nThere do exist classes that are used both as generalization and description classes.  4.3. Classes \nfor Implementations Implementations are declared through the use of subclasses. Typically, a subclass \nthat is intended to implement an abstract data type contains the implementations for those procedures \nspecified in its ancestors and contains subclasses for the ancestors' nested classes. Assuming that a \nfull specification and implementation for computer words exists in a manager called \"04\", an imple- mentation \nfor the ~ntegerManager and Integer classes is : class WordlntegerManager of IntegerManager is begin \nI ....................................... ; procedure Assign(L :Wordlnteger, R :Wordlnteger ) return \nWordInteger is begi n CM.AsS ign(L .Rep,R .Rep ) ; end ; procedure Equal (L :Wordlnteger, R :WordInteger \n) return Booleans.Bit is begin return CM.Equal(L .Rep,R .Rep) ; end ; procedure Addition (L :WordInteger, \nR :Wordlnteger ) return WordInteger is begin return CM.Plus(L.Rep,R.Rep) ; end; ! ....................................... \n; ! And the class definition for individuals ; class WordInteger of Integer is begin vat Rep => CM \n. new Word; end; end ; The conventional methodology for implementing an abstract data type requ/res \nthat all operations in the specification must be implemented, that a rep- resentation for the object \nmust be described and that there is some way to separate the abstract object from the concrete object. \nThese three recpairements are provided above. Procedure imple- mentations for Assign, Equal and Addition \nare declared, the class Wordlnteger defines the repre- sentation of Integer and use of the n~w,e Integer \n instead of Wordlnteger separates the abstract object from the concrete object. Thus all of the requirements \nfor an abstract data type implementa- tion are met in the example. 4.4. Multiple Implementations The \nexample above also illustrates a feasible im- plementation for IntegerManager. In WordlntegerManager \n, procedure implementations are provided for the procedure specifications in all inherited ancestors: \nhere the Assign, Equal and Addition procedures from the IntegerManager and AssignableManager classes. \nThis is not required by Paragon bt,t does guarantee that this subclass may be used mr an implementation \nanywhere the specifi- cation is used. If some operation had been missing, and if a program used that \noperation on abstract integers, then this implementation subclass for the specification could not be \nused. An attempt to use such an incomplete subclass in this circumstance would render the program infc,~q \nibte. The distinction between the abstract use of a object and the concrete use of ~n object is also \nillustrated by this example. The example above specifies the class Wordlnteger in al t of the proceduze~' \npar~aneters in the VordlntegerManager class. This implies that only the WordInteger rep- resentation \nof Integer can be used with these procedures and provides a boundary between the abstract and concrete \nrepresentations. Some languages provide an operation that is supposed to translate between an abstract \nobject and a concrete one (for example, in Clu called \"cvt\" ). Within the implementation of the abstract \ndata type, one may restrict the implementation to use only the abstract properties of the object by \nomitting this special translator operation. Other languages reverse the convention and allow the programmer \naccess to the representation unless the programmer specifies that only the abstract operations should \nbe allowed. Ada uses still another approach by unconditionally permitting access to the representation \nof an object within the implementation of the abstract data type. Paragon attempts to strike a balance \nby using the names in the class declarations. Should only the abstract operations be permitted, then \nthe progrmmer may specify this by writing the name of the specification class in the parameter. If access \nto the representation is required, then the name of the class used as a representation should be written \nin the parameter. Because each procedure specifies that WordInteger objects may be used as parameters, \neach may use the details of Wordlnteger objects, such as selecting the Rep field. Had the procedures \nmerely required Integer objects, then access to the Rep field would have been denied, even if an instance \nof Wordlnteger had been given to the procedure. The use of names rather than conventions for selectin \n9 the abstract or concrete interpretation of an object permits a greater flexibility in the definition \nof implementations. This is more fully explored in the next section where some methods for providing \nmultiple implementations of abstract data types are considered. There are times when a programmer may \nwish to have more than one implementation for an abstract data type. This can be illustrated with the \npreviously specified IntegerManager. Many computers have more than one size of data representation provided \nby the hardware, so it seems reasonable that different integer variables might be able to take advantage \nof these differences in order to improve a program's performance. Each differently sized representation \nhas its own representation class and its own procedure implementations. Unfortunately, most data abstractlon \nlanguages &#38;Lion only one representation for each specifica- tion. If the one word representation \nfor integers were present in a program, such languages would prohibit the inclusion of a half word integer \nand a double word integer. Paragon does not have such a rule. A new represen-tation may be provided by \ndeclaring a new set of nested classes. For example, a program might contain the following declarations \nfor integers requiring less than a word of storage: class ShortWordlntegerHanager of IntegerManager is \nbegin ! ...................................... ; procedure Assign(L :ShortWordlnteger, R : ShortWordI \nnteger ) return Wordlnteger is begin CHSW.~ss ign (L .Rep,R .Rep) ; end; ! ...................................... \n; procedure Equal(L :ShortWordlnteger, R : Shot tWordlnteger ) return Booleans.Bit is begin return \nC~SW.Equal(L.Rep,R.Rep) ; end; ! ...................................... ; procedure Addition( L: Shor \ntWordlnteger, R:ShortWordI nteger ) return ShortWordlnteger is  begin return CMSW.Plus (L .Rep,R .Rep) \n; end; ! And the class definition for individuals ; class SbortWordlnteger of Integer is begin var Rep= \n> C14SW new ShortWord; end; end; The ShortWordlntegerHanager and ShortWordInteger classes represent \nanother implementation of the integer abstract data type. Two factors are present which allow the second \nimplementation to be declared and included in a program. First, the explicit separation of the specification \nand im- plementation of the abstract data type provides a way to bind more than one implementation to \na specification. Second, the ability to name the representation explicitly allows different procedure \nimplementations to use different concrete representations for parameters. The ability to name explicitly \nthe representations or specifications in parameters permits multiple representations to be used in a \nmore common setting: differing type parameters. Frequently cited examples include set implementations, \nwhere different representations of the set are used with different element types [Johnson76, Low74, \nSchonberg77, Wulf81]. A typical (partial) speci- fication for sets in Paragon appears below: class SetManager(T:any) \nis begin class Set is begin end; procedure Union(Set,Set ) return Set; end; The element type (T) of \nthe set may be any class. However, certain classes have special properties that an implementation may \nwish to exploit. For example, if the element type were totally ordered, a B-Tree or discrimination net \nmay be an appropriate implementation. If it can be hashed, a hash table may prove efficient. Sets of \na small number of enumerated values are usually represented as a bit vector. Thus one wants the implementation \nto be able to take advantage of knowledge of the element type. Other languages, such as Clu and Alpbard, \ndo not permit this exploitation in an implementation, Or more precisely, they insist that such requ/rements \nappear in the specification of the abstract data type. Paragon permits the specification to be as broad \nas requ/red and the implementation to be as ,arrow as required by allowing the parameters in subclasses \nmerely to match the parameters in the. parent class, and not to be identical. A discrimination-net implementation \nof the previous SetManager might look like the following:  class Dis cri mi nati onSetManager (OrderedManager \n.T :Ordered ) of SetManager is begin class DiscSet of Set is begin ! Local storage goes here i endi ! \n...................................... ; procedure Union( DiscSet ,DiscSet ) return DiscSet is begin \n! Impl. of Union operation; end ; ! ...................................... ; end; The DiscriminationSetManager \nclass may only be used as an implementation for Setaanager when the element type of the set is ordered. \nHowever, all available information about ordered objects (as expressed in the specification for OrderedManager) \nmay be used inside DiscriminationSetManager in its manipulation of the set's element type. This use of \na subclass in the parameter of the implementa-tion class also eliminates the need for procedure parameters \nsince the composed data type and its operations are combined in a class declaration. Therefore the user \ncan use the abstract data type without needing to consider the constraints required by any particular \nia~91ementation. Such considerations are automatically processed by the translation system. 4.5. Explicitly \nShared Implementations The examples given in the previous sections for integers and sets lead to the \ntopic of sharing of representations. Because the class mechanism does not restrict the way in which specifications \nand representations may be combined, several arrangements of classes prove useful in selective sharing \nbetween the specifications of abstract data types, between the representations of abstract data types, \nand between the specifica- tions and the representations of abstract data types. Each of these kinds \nof sharing is considered in turn. 4.5.1. Shared Implementations via Shared Specifications Selective sharing \nof specifications is quite common in practice and supported in some languages, such as Ads. This usually \ntaken the form of a single manager being used for several ctlfferent kinds of individuals. One example \nis a computer memory, as illustrated below: class MemoryManager is begin class Byte is begin end; class \nWord is begin end; procedure ReadByte (IM. Integer ) return Byte ; procedure Wri teByte ( IM. Integer \n,Byte ) ; procedure ReadWord(IM.Integer} return Word; procedure WrlteWord(IM. Integer ,word ) ; procedure \nLeftByte(Word ) return Byte;  procedure RightByte(Word ) return Byte ; end; The single manager HemoryManager \nprovides the shared declarations for two related individuals, Byte and Word. Words and bytes are closely \ncoupled in a memory and should be considered connected in some way. Many languages have no provisions \nfor this selective sharing. Paragon permits multiple inner classes that are declared in an outer class \nto denote different kinds of individuals for the same manager. The implementation of MemeryHanager could \ncontain further subclasses for Byte and Word and implemen- tations for ReadByte, VriteByte, ReadWord, \nWrite%k)rd, LeftByte and RightByte, each of which could access the concrete representation for both bytes \nand words. 4.S.2. Shared Implementations via Previous Imple-mentations Another way of combining classes \ngives the programmer the ability to write procedure imple-mentations that define multiple representations. \nLike the MemoryManager example above where one can write a single subclass of the specification class \nthat has access to representations of multiple kinds of objects, one can provide a subclass of subclasses \nthat permits access to multiple, concrete representations of the same abstract object. This can be illustrated \nby extending the IntegerManager implementations given in Section 4.4. To include a procedure that can \nadd integers regardless of the implementations of the abstract integer, one can write: class CombinedWordIntegerManager \nof WordIntegerManager, ShortWordIntegerManager is begin | ...................................... ; procedure \nAddition (L: ShortWordInteger, R :Wordlnteger ) return WordInteger is begin end; I ...................................... \n; procedure Addition(L:VordInteger, R:ShortWordlnteger ) return Wordlnteger is begin ... end; end; \n If Combinec~brdlntegerManager were to be selected as the implementation for an abstract IntegerManager \nobject, then abstract integers could be implemented with either the ShortWordlntsger or the Wordlnteger \nsubclasses of Integer. Regardless of the implementation selected for two abstract integers, there will \nexist an im- plementation of tile Addition procedure that can operate on them. 4.5.3. Shared Implementations \nfor Unrelated Specifications A third way of sharing in Paragon allows an imple- mentation class to be \nused as an implementation for multiple specification classes. One system that illustrates this sharing \nis SETL [I)ewar79] where sets are implemented by altering the repre-sentation of the elements of the \nset. This is a unique approach to implementing sets and their elements as it requires a shared implementation \nfor two specifications that are not otherwise related: one specification for sets, one specifi- cation \nfor the elements of the set. The use of classes and inheritance provides this capability as well. Given \ntwo separate sets of specification classes, say for integers and sets, one creates a single class that \nacts as the manager for both and that class contains the representations for the union of the inherited \nindividuals and procedures. An abbreviated illustration is given below, beginning with the specificatons \nfor integers and sets : ! .................................... ; ! Specification Classes for Integers \n; | .................................. _' ; class IntegerManager of AssignableManager is begin procedure \nAddition( Integer ,Integer ) return Integer ; class Integer of Assignable is begin end; end; I ................................ \n; ! Specification Classes for Sets ; class SetManager(T:any) is begin procedure Unlon(Set,Set ) return \nSet; class Set is begin end; end; With these following specifications, one shared implementation may \nfor write sets the and integers ( adapted from [ Dewar79 ] ) : class IntegerSetManager(IntegerManager \n.T: Integer ) of IntegerManager, SetManager is begin ! ...................................... ; class \nIntBlock is begin ! Repe for the integer and set indication ; end; I ...................................... \n; ! Shared Data for the Manager ! (uses predefined reference manager) ; ! RIBM = \"Reference to IntBlock\" \nMngr ; | ...................................... ; vat RIBM => new RefManager(IntBlock ) ; war IntValueList \n=> RIBM . new Reference; I..... . ................................ ; ? Integer Implementations ! ...................................... \n; class SharedInteger of Integer is begin war IntValueBiock => RIBM . new Reference; end; 214 ! ...................................... \n; procedure kddition(Sharedlnteger, SharedInteger ) return Sharedlnteger is begin ! Implementation \nfor Addition operation; end; ! ...................................... ; ! ...................................... \n; ! Set Implementations ! ...................................... ; class SharedSet of Set is begin \nvat SetNum => CM. new Word; end ; procedure Union(SharedSet, SharedSet) return SharedSet is begin ! \nImplementationfor Union operation; end; ! ...................................... ; end; A complete \nexample would show how the blocks of integers are linked together and shared by all set and integer variables. \nAlthough the details are missing, the example above shows that representa-tion combinations can be expressed \nvia the class mechanism whereas most approaches to data abstraction have no way of describing a combined \n representation.   4.6. Implicitly Shared Implementations Paragon also supports implicit sharing \nof repre- sentations. Such sharing comes when procedures are written that use only abstract properties \nof their parameters. For example, an implementation of the Union procedure could have been provided in \nthe SetManager as follows: procedure Union(L :Set ,R :Set ) return Set is begin vat Temp :> new Set; \nvar i => new T; for i in Elements(L) do Insert(Temp,i ) ; end for; for i in Elements(R) do Insert(Temp,i \n) ; end for ; return Tempi end; This procedure implementation assumes that an Elements iterator and \nan Insert procedure have been specified in SetManager. Note that implemen- tation uses only abstract \noperations On sets. Each call of this Union procedure may have different or even conflicting representations \nfor the parameters. Paragon permits these calls and checks that all necessary procedure implementations \nare available for use inside of Union. All of the necessary processing is performed at compile time; \nno run-time examination of representations is necessary when executing this implementation. These examples \nhave shown how multiple representa- tions for variables and procedures may be declared and used in Paragon. \nAfter a program is written, the selection of an appropriate representation must be made for each variable \nand each procedure call in the program. To satisfy this need, Paragon provides a representation selection \nmechanism that the programmer may use to guide the translator in picking appropriate implementations. \nThe discussion of this selection system is beyond the scope of this paper. The interested reader is referred \nto the complete description of Paragon [ Sherman83 ]. 5. Status of Paraqon The design of Paragon is complete \nand a prototype implementation exists. Several thousand lines of Paragon code have been programmed. Both \nabstract data types and application programs have been programmed and processed by the prototype. This \ncode also provides test cases for Performance measurements that were takenof the prototype translator. \nThe prototype did provide some lessons about implementing a language with the generality of Paragon. \nFirst, I believe that efficient code can be generated for Paragon. Although the protoype has no optimizer, \none of the outputs of the prototype is a transformed program that has specific representations for all \nvariables and procedure calls made. This transformed program has the complexity of an Algol-60 or Pascal \nprogram. Given that efficient code can he generated for these languages, efficient code can be generated \nfor Paragon. Second, the prototype was built with conventional compiler construction, therefore, no new \ncompiler technology is needed to add the type hierarchy facilities of Paragon to a language. Third, the \nprocessing of a program may take significantly longer with a Paragon compiler than with a conventional-language \ncompiler. For example, empirical measurements indicate that one of the new types of processing, feasibility \nchecking, takes about 3 times as much resources as conventional semantic analysis. Finally, separate \ncompilation may prove difficult. The prototype has no facility for separate compilation, though it became \nclear that separate compilation was needed when I was testing programs that used many different implementations \nof data abstractions. A separate compilation facility was not retrofitted becauseof some complications \nwith feasibility checking and interactions with the representation selection system. Whether a good separate \ncompilation facility can be built for Paragon remains an open question to me. Therefore, one can add \nmost of Paragon's features using conventional techniques. However, the efficient addition of representation \nselection and feasibility checking may require new compiler methods.  6. S1mry The paper demonstrates \nhow a type hierarchy (technically, a directed acyclic graph of types, but \"type hierarchy\" is a more \ncommonly used term) can be mred for writin 9 programs using the object-manger model to specify abstractions, \nrefine the specifications, write representations for the abstractions and combine representations as \ndesired. These capabilities are not available in current languages, so the Paragon design shows how type \nhierarchies can be used to improve the facilities for data abstraction in future languages. A number \nof programs were written and translated with a prototype system that processes Paragon, thus the suggested \nlanguage is not a more paper design, but a cowplete language that can he implemented and used for programming. \n7. Acknowl edqeman ts I wish to thank Andy Hisgen and Jonathan Rosenberg for many helpful discussions \nduring the time I was designingParagon. Elaine Kant, Peter Hihbard and John Nestor also provided many \nuseful comments on Paragon, representation selection and language design in general. 8. Biblioqraphy \n [Archibaid83]J.L. Archibald, B.M. Leavenworth and L.R. Power, \"Abstract Design and Program Translator: \nNew Tools for Software Design,\" ~BM System Journal, 22(3):170-187, 1983. [Cheathem79]Tbomas E. Cheatham \nJr., Judy A. Townley and Glenn H. Holloway, \"A System for Programming Refinement,\" In Proceedinqs of \nthe 4th Conference on Software gnqineerinq, pages $3-62, IEEE Computer Society, September, 1979. [curn,82] \nGael Curry, Larry Bear, Daniel Lipkie and Bruce Lee, \"Traits: An Approach to Multiple-Inheritance Subclassing,\" \nIn Limb, J.O. (editor), proceedinqs~ SIGOA Conference on Office Infora~tion S~tem, pages 1-9, ACM, SIGOA, \nJune, 1982. Also SIGOA Newsletter, Vol. 2, Nos. 1 and 2. [DahI68] O.-J. Dahl, Simula 67 Common Base \nLanqu~e, Technical Report, Norwegian Computing Center, Oslo, 1968. [Dewar79] Robert B.K. Dewar, Arthur \nGrand, Ssu-ChengLiu and Jacob T. Schwartz, \"Programming by Refinement, as Exemplified by the SETL Representation \nSublanguage,\" ACN T~ansactione on Proqrmeminq Lanquaqes and System, 1(1):27-49, July, 1979. [GoldbergSl]Adele \nGoldberg, \"Introducing the Snmlltalk-80 System,\" Byte, 6(8):14-22, August, 1981. [Herlihy80] Maurice \nPeter Herlihy, Transmittin q Abstract Values in Messaqes, Technical Report MIT/IES/TR-234, Laboratory \nfor Computer Science, Massachusetts Institute of Technology, April 1980. [Herlihy82] M. Herlihy and B. \nLiskov, \"A Value Transmission Method for Abstract Data Types,\" ACM Transactions on Proqramminq Lanquaqes \nand Systems, 4(4):$27-5S1, October, 1982. [ Ichblal~0 ] Jean Ichbiab, et ai., Reference Manual for the \nAda Proqramminq Lanquaqe, US Government, Washington, D.C., 1980. [ Ingalls78 ] Daniel H.H. Ingails, \"The \nSmailtalk-76 Programming System: Design and Imple- mentation,\" In Conference Record of the Fifth Annual \nACM STmposium on Principles of Proqram~inq Lanquaqes, pages 9-16, ACM, January 1978. [Ingails81] Daniel \nH .H. Ingails, \"Design Principles Behind Sumlltalk,\" Byte, 8(8):286-298, August 1981. [Ingargiola7S]Giorgio \nP. Ingargfola, \"Implementa-tions of Abstract Data Types,\" In Proceedinqs of the Conference on Computer \nGraphics, Pattern Recoqnition, and Data Structure, page 108-113, IEEEComputer Society, May, 197S. [Johnson76] \nRobert T. Johnson and James B. Morris, \"Abstract Data Types in the MODEL Programming Language,\" In Proceedinqs \nof Conference on Data: Abstraction, De. finition and Structure, pages 36-46, ACM, March, 1976. Also Sigplan \nNotices, Vol. 8, No. 2, 1976. [Katzenelson83a]Jacob Katzenelson, \"Introduction to Enhanced C (EC)\", Software \n--Practice and Experience, 13(7):551-576, July 1983. [Katzenelson83b]Jacob Katzenelson,. \"Higher Level \nProgramming and Data Abstractions --A Case Study Using Enhanced C,\" Software --Practice and Experience, \n13(7):S77-595, July, 1983. [LeavenworthS1 ]Butt Leavenworth, \"Adapt Reference Manual ,\" Software Technoloqy \nTechnical Memo Number 19, Computer Science Department, IBM T.J. Watson Research Center, Yorktown Heights, \nNY 10598, June 3, 1981. [ LiskovSl ] B. Liskov, E. Moss, C. Schaffert, R. Scheifler and A. Snyder, The \nCLU Reference Manual, Springer-Verlag, New York, N.Y., 1981, Lecture Notes in Computer Science No. 114. \n[Low74 ] James R. Low, Automatic Cod/nq: Choice of Data Structures, Technical Report CS-452, Stanford \nUniversity Computer Science Department, August 1974. [ Morgan81 ] Chris Morgan, \"Smalltalk: A Language \nfor the 1980s,\" Byte, 6(8):6-10, August, 1981. [Mylopoulos80]John Mylopoulos, Philip A. Bernstein and \nHarry K.T. Wong, \"A Language Facility for Designing Database-Inte~ive ARBlications,\" ACM Transactions \non Database Systems, 5(2):18S-207 i June, 1980. [Schonberg77]E. Schonberg and S. C. Liu, \"Manual and \nAutomatic Data-Structuring in SETL,\" In Jacques Andre and Jean-Pierre (editors), Implementation andDeslqn \nof Alqorithmic Languaqes: Proce~d/nqs of the 5th Annual III Conference, pages 284-304, IRISA, May, 1977. \n[ ShawOl ] Mary Shaw (ed/tor), Alphard: Form and Content, Sprlnger-Verlag, New York, New York, 1981. \n[ Sherman83 ] Mark Steven Sherman, Paraqon: A Lanquaqe Ustnq Type Hierarchies for .the Speclfication \ni Implementation and Selection O f Abstract Data Types, Technical Report CMU-CS-83-147, Department of \nComputer Science, Carnegie-Mellon University, Pittsburgh, PA., 1983.  [Smith77] John Miles Smith and \nDiane C.P. Smith, \"Database Abstractions : Aggregation and Generalization,\" ~ Transactions on Database \nSystems, 2(2 ):105-133. Jun'e, 1977. [ Weinreb81 ] Daniel Weinreb and David Hoon, Lis P Machine Manual, \nSymbolice Inc, California, 1981. Fourth Edition. [ nullS1 ] W.A. Wulf, M. Shaw, P.N. Hilfinger and L. \nFlon, Fundamental Structures of Computer Science, Add/son-Wesley, 1981. [Xerox81] Xerox Learning Group, \n\"The Small talk-80 Sys tern,\" Byte, 6(8):36-48 1 August, 1981. \n\t\t\t", "proc_id": "800017", "abstract": "", "authors": [{"name": "Mark Sherman", "author_profile_id": "81100372743", "affiliation": "Department of Math. and Computer Science, Dartmouth College, Hanover, NH", "person_id": "PP40036598", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800017.800532", "year": "1984", "article_id": "800532", "conference": "POPL", "title": "Paragon: Novel uses of type hierarchies for data abstraction", "url": "http://dl.acm.org/citation.cfm?id=800532"}