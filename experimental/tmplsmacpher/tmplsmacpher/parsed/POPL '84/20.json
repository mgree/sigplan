{"article_publication_date": "01-15-1984", "fulltext": "\n Direct Zmplementat|on of Compiler Spec|fttettons or The Pascal P-Coda Compiler Revis|ted Don Milos, \nUwe Pleban t, end George Loegel Department of Computer and Communication Sciences The University of Michtgan \nAnn Arbor, MI 48109 Abstract We have developed a complete formal specification of the translation semantics \nof the Pascal P-compiler. The specification is written as a semantic grammar (a variant of extended attribute \ngrammars), and has been extensively tested and debugged with the aid of Lawrence Paulson's experimental \nsemantics processor. The translation semantics models the operational aspects of compilation in detail. \nIt is one-pass, embodying static semantic checking, address assignment, code generation, and a certain \namount of code improvement. Our paper describes the development history of the project, compares the \nnew compi]er with the existing P-compiler, and discusses our positive experience with semantic grammars \nand Paulson's system. 1. Introduction and Overv|ew For the past two years, a number of research projects \nin the area of compiler construction and compiler generation have been under way at the University of \nMichigan. These projects range from research in parser generation [Dom83], the Implementation of practical \ncode generators from specifications [Btr82], to experimental work in the area of semantics-directed compiler \ngeneration [Bod82], [Ple83], [P1F83], [P1L]. The paper at hand is part of this comprehensive effort to \ndevelop descriptive techniques for the high level specification of complete, reasonably efficient compilers \nfor nontrivial (although relatively standard) programming languages z We have developed a complete formal \ndefinition = of a nontrivtal compiler. The specification is a translation semantics', describing syntax \nanalysis, static semantic analysis, code generation, and some code improvements. It is formulated as \na semantic grammar [Pau81], a variant of extended attribute grammars [Mad80] [WaM83]. Since there exists \nan experimental system which directly implements semantic grammars [Pau81] [Pau82]. we have been able \nto extensively test. debug, and modify our specification. 'Work partially supported by a University of \nMichigan Rackham summer fellowship and an IBM faculty development grant. 2We currently restrict our attention \nto imperative, lexically SOdDed, sequential languages, as exemplified by Pascal. ~The definition is complete \nwith respect to the limitations imposed by Paulson's system; see Section 2 for a more detailed explanation. \n\"Since the semantics describes the manipulation of a rather detalled compile time state, it can be regarded \nas a form of operational semantics. Permission to copy v,-tthout fee all or part of this material ts \ngranted provided that the copies are not made or distributed for direct commercial advantage, the ACM \ncopyright notice and the I=tlc o| the publication and its date appear, and notice is given that copying \nis by permission of the Association for Computing Machinery, ] o copy otherwise, or to republish, requires \na fee and or speclftc permission &#38;#169; 1983 ACM 0-89791-125-3/84/001/0196 $00.75 196 The compiler \nwe have chosen to model via this formal technique is the Pascal P-compiler, one of the so-called portable \ncompilers. The P-compiler accepts (with several small exceptions) the language described in the Pascal \nUser Manual and Report [jeW76], and generates P-code, a code for a hypothetical Pascal-oriented stack \nmachine [Nor75]. Our primary goal at the outset of the project was to develop a complete and useable \noperational definition of the P-compiler, and implement it with the aid of Paulson's system. We were \nfurthermore interested in comparing the specification and its implementation with the original P-compiler \nin regard to readability, modifiability, efficiency, and quality of code produced. 2. Extended Attribute \nGrammars, Semantic Grammars, and Paulson's Specification Processor In August 1982, we acquired Lawrence \nPaulson's system (which we shall ca.ll PSP), a reasonably efficient and very flexible semantics processor \n[Pau81] [Pau82]. PSP generates experimental compilers from semantic grammars, which combine extended \nattribute grammars (EAGs) [WaM83] with concepts from denotational semantics, including Scott domains \nand higher order functions [Sto?7]. In particular, arbitrary lambda expressions may be the values of \nattributes of nonterminals. PSP consists of three components. The grammar analyzer GA processes a semantic \ngrammar for a programming language and creates a language description file (LDF) consisting of LALR(I) \nparse tables and attribute dependency tables. The universal translator UT reads the LDF to initialize \nitself and parses the source program while at the same time building a directed acyclic graph (DAG) of \nattribute dependencies. The attribute evaluator (based on the one described by Madsen [Mad80]) of the \nUT simplifies the DAG by performing as many beta reductions as possible, and translates the result into \nSECD machine code. The simplified DAG is also pretty printed. Finally, the SECD machine simulator reads \nthe generated code C along with the input file I, performs applicative order reductions of the application \nC(I), and prints the resulting output file. Note that in our project, the generation of SECD code is \nbypassed, because we synthesize appropriate representations of P-code instruction sequences instead of \nthe continuation transformers of denotational semantics. For this reason we shall exclude the SECD machine \nsimulator from our subsequent discussion. 3. History of the Project The development of the specification \nwas started in September 1982 during a seminar on comptler writing tools and semantics-directed compiler \ngeneration. Our investigation was prompted by a remark in Paulson's thesis [Pau81] that his system could \nbe used to implement a variety of formal semantic definitions, including denotational, operational, and \naxiomatic specifications. As his thesis contained only examples of denotational and axiomatic descriptions, \nit was natural to design and experiment with one that had an operational flavor, Our decision to formally \ndescribe the Pascal P-compiler was motivated by several f~ctors: (i) The compiler is well-known, non-trivial, \nbut not too large (exactly 4,000 lines of dense Pascal code). (ii) One of the authors (U. Pleban) had \nprior experience with the P-code machine and had developed an operational semantics for it [Ple81]. \n J (iii) A highly informal description by means of flow diagrams of the translation semantics of the \ncompiler was available as part of the documentation in [Nor75]. (iv) Various aspects of the semantics \nof Pascal had already been described by formal techniques [HOW73] [TenY8] [Wat79] [Pau81]. (v) In case \nof unexpected problems, we would have been able to inspect the source code of the old P-compiler.  With \nrespect to the last point, we would like to stress that we never considered the source code of the compiler \nan adequate guideline for our project, not only because the code is rather unreadable, but mainly because \nit seems to be absurd to develop a specification from a very detailed implementation. Our primary reference \nwas to be (and indeed ~as) the tnformal description of the behavior of the compiler mentioned tn (iii). \nFrom the very beginning, our emphasis was on developing a specification which was as complete as possible, \nomitting only those features of the language which could not be processed by PSP. The restrictions imposed \non us concern the lack of real, character, and string literals in PSP, which, although of practical importance, \ndo not Introduce any semantic problems of interest. Since PSP's attribute evaluator can deal with any \nnonctrcular attribute grammar, we did not have to pay attention to Questions of attribute dependencies. \nAnother important aspect of our undertaking was to gain an understanding of the problems artsing In the \ndevelopment and direct Implementation of non-toy specifications of complete compilers which generate \ncode of acceptable quality, As we will point out tn the last section, very little work has been done \ntn thts area. 4. Development Phases After a short study of Paulson's system, we first delineated the \nsubset of Pascal (as described in the manual [deW?6]) accepted by the P-compiler. The main restrictions \nof P-Pascal are as follows: (t) Functions and procedures may not be passed as arguments to subprograms. \n (ii) Goto statements may not lead out of subprogram bodies.  (iiJ) Set expressions of the form [exprl..expr2] \nare not recognized. (iv) A11 packing options are ignored. (v) Files may not be declared. The compiler \nonly recognizes the four predefined text files Input, Output, PRD, and PRR. (vi) The predefined functions \nof Pascal (such as Ord, Get, Put, etc.) are hardwired into the compiler.  Unfortunately, not all the \nlimltatlons of the compiler are mentioned in [Nor?5], so that we are still not absolutely certain about \nwhat exactly constitutes P-Pascal. For example, the compiler which we used for purposes of comparison \ndoes compile goto statements out of subprogram bodies correctly. ) Wart's complete formal Oefinition \nof the syntax and static semantics of Pascal Py means of an extended attribute grammar [WatT9] was an \nobvious basis for our project. However. since we did not consider the static semantics to be a central \nportion of pup specification, we decided to defer incorporating comptle ttme type checking and testing \nfor context-sensitive constraints. Instead. we began with the development of code patterns according \nto the flow charts given tn [Nor75]. These patterns were attached to the productions of a Pascal grammar \nalong with sketchy descriptions of context information required for code synthesis. The grammar iS a \nLALR(1) grammar and is based on the one used by Paulson [Pau81]. Zt has been cross checked very carefully \nwith the Pascal g~ammar given in the manual [deW?6]. The next stage was the crucial step in the development \nof the specification, and actually involved several iterations. It dealt with identifying the structure \nof the compile time state in order to allow the generation of P-code and certain require~ compile time \ncomputations. Aside from constructing domains describing those aspects of the compiler's symbol table \nwhich concern static semantic checking (which could De lifted from Wart's EAG [Wat?9]), the compiler \nneeds to perform address assignment for all variables as well as some temporaries, e.g. for for loop \nvariables and component references mentioned in w|th statements, In addition, compile time computations \nare necessary tn order to determine the maximum growth of every stack frame ~. The development of the \nrule portion of the grammar proceeded tn several distinct phases. During each phase, new features of \nPascal were included. Some of these required a substantial redesign of certain attribute domains, as \nnoted below. The following steps summarize our development: ~A suitable instruction which tells the P-code \nmachine about the maximum amount of space required for a subprogram's activation record is part of the \nentry sequence for every subprogram. This allows the machine to check for stack overflow only once upon \nentry to a subprogram, instead of checking every push operation. 198 (i) Design of rules for simple statements, \nincluding sequencing, if, uhlle, repeat, compound, and restricted assignment statements. (ii) Addition \nof productions for simple expressions without complex components and function calls. First sucoessful \ntests.  (tit) Addition of label declarations and goto statements. This forced us to redesign one of \nthe main attribute domains in order to handle labels correctly. (tv) Development of grammar fragments \nfor complex statements (case, fop statements). (v) Development of rules for complex components (array \nreferences, record field selection, pointer dereferenctng). (vi) Addition of productions for stmple \ndeclarations (const, vat declarations).  (vii) Handling of predeftned functions and procedures. (viii) \nAugmenting the grammar by rules for the wtth statement. Specification of this feature required substantial \nredesign. (ix) Addition of complex type and object declarations (arrays, records, sets, and pointers). \n= (x) Finally, development of subprogram declarations, and procedure and function calls.  At point \n(viii), all the rules for components and expressions had to De redone. Fortunately, the result turned \nout to be much cleaner than the original rules, primarily because we had acquired a certain familiarity \nwith writing semantic grammars. When it became obvious that major changes had to be introduced, it was \ndecided to also include a number of optimizations which would allow more efficient address computation. \nThus the handling of the with statement turned out to be a major cycle in our design. In order to give \nthe reader a feeling for the progression of steps which took place during the development sketched above, \nwe have inctuded in the Appendix 1 a detailed example of how the origtnal informal description of the \ncase statement was transformed into a collection of attribute grammar rules. 5. Current Status At the \ntime of thts writing (November 1983), the specification i5 essentially complete. Only variant records \nhave not yet been incorporated into the translation semantics. Furthermore, the static semantic checking \nis still rudimentary, although a complete type checker has just been developed by one of the authors \n(U. Pleban) as part of another project dealing with the implementation of Tennent's denotational semantics \nof Pascal [Ten?8]. The type checker essentially models Wart's EAG for Pascal [Wat?9], and its adaptation \nwill be straight forward. 6. Properties of the New P-Compiler The translation semantics Is currently \nabout 2500 lines long, excluding the type checker. This Odes not seem to compare well with the length \nof the old compiler (40C~D lines of Pascal code), especially when Considering that lexical analysis is \nnot part of our specification because the universal translator has a standard lexical analyzer built \n~nto it. There are several reasons fop this bulkiness: (i) Our specification is less dense and much better \ncommenteQ than the original compiler. (it) The description of code synthesis ts extremely awkward, as \ninstructions must be built as elements of discriminated union domainS, thus requiring numerous injection \noperations. (iii) Some parts of the grammar can be shortened by extracting common actions and defining \nappropriate functions. (Recall that P-Pascal only supports four predefined text files. Also, a11 packing \noptions are ignored. (iv) The specification language is not very expressive. In partlcular, matching \nof structures ts allowed only one level deep. We. have estimated that a more expressive metalanguage \nwould allow us to compress the specification by at least 25% wtthout infringing on its readability. Testing \nand debugging was easier than expected. ~ We devised an incremental development scheme by masking those \ngrammar productions Whose semantic part was not yet complete. AS the development progressed, more and \nmore rules were uncovered and incorporated tnto the grammar. We found the applicative programming style \nvery satisfying because of the low interference between these independently developed portions of the \nspecification. There were no obscure bugs due to unwanted side-effects on global variables, reference \nparameters, etc. Problems have generally been easy to locate, as logical errors tend to be localized \nwithin attribute grammar rules. Consequently, we are convinced that the specification ts far more modifiable \nand maintainable than the original compiler, which is not an example of good compiler writing anyway. \nWe have successfully compiled several programs testing various features of the language. The largest \nprogram (file p41nt.pas) is roughly 430 lines (2343 tokens) long, and consists of large portions of the \nP-code interpreter. The code generated by our compiler is nearly identical to that produced by the ortginal \ncompiler. The differences always concern address computations, some of which are done more efficiently \nby our compiler. In terms of compile time efficiency, we have found that the new compiler currently runs \nabout 20 to 30 times slower than the olo one, depending on the size of the source program, the complexity \nof the compile ttme computations involved, and the number of garbage collections performed by the UT. \nOur measurements exclude time for initialization, static semantic checking, and pretty printing of the \nDAG. The new P-compiler spends roughly between 10% and 15% of the entire compilation time initializing \nitself, compilation. example, timings as the are it for needs Pretty timing an A to read a large language \nprinting consumes about comparisons for compiling the mdahl 580 running under the MTS operating description \nftle at another 15% of compilation file p4tnt.pas are as system): the start time. follows of For (a11 \nwith old compile time initialization compile time ratio without initialization new/ (and pretty printing) \n new P-compiler (I) 27.625 sec 20.72 sec 27.5 new P-compiler (2) 26.617 sec 19.96 sec 26.5 old P-compiler \n.754 sec .752 sec PascalVS compiler .77 sec unknown The timing differences between runs (1) and (2) \nof the UT are due to a change in the number of garbage collections performed during compilation. Normally. \nthe UT keeps allocating nodes from the PascalVS heap until the number of nodes in use exceeds the number \nof nodes used prior to the last garbage collection by a factor of 1.2. In run (2), this factor was changed \nto 3.0, thereby reducing the number of garbage collections considerably. Obviously, garbage collection \ntime can be neglected. An attempt to run the UT wtthout invoking the garbage co11ector at all failed, \nas the heap filled up before completion. Code and data space requirements have not been measured, as \nthis is not possible under MTS. However, with respect to the new P-compiler, we can provide the following \nstatistics. In run (1), whtch we consider typical0 the maxtmum number of nodes allocated at any one ttme \nwas 26,986, of which 83% were used fop storing the semantic DAG. Sixty-four garbage collections were \nperformed, each of them recovering roughly 15%-18% of the nodes. A total of 221,812 nodes were garbage \ncollected. Our compiler generates code which is at least as good as that produced by the old compiler. \nSpecifically, constant folding during the compilation of references to \"Actually. since we had never \nbefore programmed a large semantic grammar, we did not exactly know what tO expect. 200 components (such \nas Foo[1].Bar. Fie) results in much better code. 7. Ev~luation In general, we have been very pleased \nwith the results of the project. Peulson's specification processor turned out to be useable, helpful, \nand fast and friendly enough to allow extensive experimentation with the translation semantics'. We ere \nnow very confident of the correctness of the specification. Furthermore, we believe that it ts more readable \nand amenable to modifications than the original compiler. Our positive experience suggests that similar \nformal specifications should be developed and tested before embarking on the implementation of a compiler. \nThis makes it practical to experiment with new ideas at an early stage during comptler design. On the \nother hand. the specification has number of shortcomings. It is much too long and monol,ithic for our \ntaste. Obviously, splitting off the code generation activities from the Pest of the compiler would have \nresulted in a cleaner specification. Indeed, this type of modularization is possible with PSP, since \nit is possible to let separate specifications communicate via the pretty printed DAG. as long as the \nDAGs are actually trees. However, the choice of a one-pass specification was deliberate, tn order to \nallow direct comparisons wtth the o10 P-compiler, which is also one-pass.' A more expressive metalanguage \nwould have e11owed a more concise formulation of the translation semantics. Also, it would have been \nvery helpful to segment the semantic grammar into modules corresponding to declarations, statements, \nexpressions, etc., as has been proposed tn [P1L83]. Ftnally, the specification spells out all the details \nof the compilation activities. Zt would be highly desirable tf a mope abstract functional specification \n(such as e denotattonel semantics) could be converted into a comptler which generates reasonably efficient \ncode. This, however, remains a formidable problem, because no approach superior to the work of Milne \n[MiST6] has been found yet. One question which we have not considered concerns tuning of the specification. \nSO far we have not paid any attention to the relationships among attributes. ;t may be possible to apply \nthe techniques described tn [KoR82] to our specification in order to speed up the compiler. We plan to \nexplore this problem in the near future, after further polishing of the grammar. 8. Related Work Attribute \ngrammars have been successfully used in several compiler writing systems, such as HLP [RaiSO] [KoR82], \nand Linguist-86 [Far82b]. However. they are usually applied only to the development of static semanttc \ncheckers. To our knowledge, the development, testing, and debugging of a specification of a complete \ncompiler wtth the help of a system such as PSP has not been mentioned before in the literature. Farrow \n[Far82a] has recently described the use of attribute grammars as a blueprint fop a production compiler \nfor the lntel 8086. First, a specification tn the form of an attribute grammar was written, and then \nconverted by hand into a working compiler. Kesav NorJ [NoP83] has told us about a formal description \ndeveloped by him and two of his students for DEC-20 Pascal compiler. The specification, however, was \nnever implemented. 9. Acknowledgments We would like to thank Larry Peulson for sending us a tape wtth \nPSP along with his thesis. Peter Lee helped install PSP. and Laurette Bradley and Den Kaiser were the \nfirst students to use the system, clearing several hurdles in the process. 'We have ignored the shortcomings \nof Paulson's system. These are sketched tn [P1L83]. 'Actually, the implementetlon of the one-pass specification \nis not one-pass, as the UT builds the complete semantic DAG during parsing, and then simplifies it. 201 \nReferences [Bir82] Gird, P. An implementation of a code generator specification language for table driven \ncode generators. Proceedings of ACM SIGPLAN '82 Symposium on Compiler Construction. SIGPLAN Notices 17, \n6 (dune 1982), 44-55. [Bod82] Bodwin, d., Bradley, L., Kanda, K., Litle, D., and Pleban, U. Experience \nwith an experimental compiler generator based on denotational semantics. Proceedings of ACM SIGPLAN '82 \nSymposium on Compiler Construction. SIGPLAN Notices 17, 6 (dune t982), 216-229. [Dom83] Domino, K., Lee, \nP., and Pleban, U. PaGMan: A users manual for the parser generator PeG. COS Department, University of \nMichigan. Still in preparation. [Far82a] Farrow, R. Experience with an attribute grammar-based compiler. \nConference RecorO 9th ACM POPL Conference, Albuquerque, NM, danuary 1982, 95-107. [Far82b] Farrow, R. \nLINGUIST-86: Yet another translator writing system based on attribute grammars. Proceedings of ACM SIGPLAN \n'82 Symposium on Compiler Construction. SIGPLAN Notices 17, 6 (dune 1982), 160-171. [HOW73] Hoare, C. \nA. R., and Wirth, N. An axiomatic definition of the programming language Pascal. Acta Informatica 2, \n1973, 335-355. [deW?6] densen, K., and Wirth, N. Pascal user manual and report. Springer-Verlag, 1976. \n[KoR82] Koskimies, K., Rathe, K.-d., and SarJakoski, M. Compiler construction using attribute grammars. \nProceedings of ACM SIGPLAN '82 Symposium on Compiler Construction. SIGPLAN Notices 17, 6 (dune 1982), \n153-159. [Mad80] Madsen, O.L. On defining semantics by means of extended attribute grammars. In dones, \nN. D. (Ed.) Semantics-directed compiler generation. Springer LNCF Vol. 94, Springer-Verlag, 1980. [MIST6] \nMllne, R.E., and Strachey, C. A theory of programming language semantics. Chapman and Hell, London, 1976. \n[Nor75] Nori, K. V., Ammann, U., densen, K., Nageli, H. H., and dacobi, C. The Pascal P~compiler: Implementation \nnotes (rev. ed.). Technical Report No.lO, Institut fur Informatik, ETH Zurich. [Nor83] Nori, K. V. Personal \ncommunication, February 1983. [Pau81] Paulson, L. A compiler generator for semantic grammars. Ph.D. Dissertation, \nStanford University, December 1981. [Pau82] Paulson, L. A semantics-directed compiler generator. Conference \nRecord 9th ACM PDPL Conference, Albuquerque, NM, danuary 1982, 224-239. [Ple81] Pleban, U. An operational \nsemantics for the P-code machine. Unpublished lecture notes. Winter 1981. [Ple83] Pleban, U. Compiler \ngeneration based on normal form semantics. Memo UPL-83-05, CCS Department, University of Michigan, August \n1983. [PlF83] Pleban, U., and Foster, G. An implementation of Tennent's denotational semantics for Pascal. \nIn preparation. [PlL83] Pleban, U., and Lee, P. Semantics processors as a basis for a language designers \nworkbench. Memo UPL-83-04, CCS Department, University of Michigan, .August 1983. [Rai80] Raiha, K.-d. \nExperiences with the compiler writing system HLP. In: dones, N. D. (Ed.) Semantics-directed compiler \ngeneration. Lecture Notes in Computer Science, Vol. 94, Springer-Verlag, 1980. [Sto77} Stoy, d. E. Denotational \nsemantics: The Scott-Stracney apprOaCh tO programming language theory. MIT Press, 1977. [Ten?8] Tennent, \nR.D. A denotational definition of the programming language Pascal. 202 Programming Research Group, University \nof Oxford, April 1982. [Wet79] Watt, D. A. An extendeO attribute grammar for Pascal. SIGPLAN Notices \n14, (February 1979). [WaM83] Watt, D.A., and Madsen, O.L. Extended attribute grammars. The Computer dourna], \nVol. 26, No.2, 1983, 142-153. APPENDXX This appendix illustrates how the original informal descripZton \nof the compilation of the case statement was transformed into a completely formal specification. A. The \nOrtgtnal Flowgraph [Nor75,p,39/40] 23) case statement  lexpressionl ~RD type: type of case selector \nse ,bel l.t I statementl label label 1 Inotetion mine minimum value of case CHKI mln max label found \nAn the LDCX min p=ocessing above. 5BX XJP label 3 , mex$ maximum value of case label 3 ______j label \nfound \u00a3n the processing above. WC I ~( | context sens\u00a3tAve featuze /~... , L .~| end it corzssponds to \n~J~ ze\u00b0eAJI each of the case labels : :,! | found in the cozresp0ndlng case labeA Iiatl -.-,, Pr._jdicete \np: has the label ~which is between min and maxJ occured in any of the case ~obel ~ processed in the case \nbody? q: the case selector is of type integer B. Grammar Rules wtth Annotation command = \"case\"expression \n\"of\" caselist \"end\" ; # semantic checking: # (1) expression must be of an ordinal type # (2) type of \neach case label must be that of the expression # communication # (1) pass L3 and required type of case \nlabels to caselist; # (2) Pecetve list of labels from caselist # emit the following code # code for expression \n# ORDt (optional, t = C or B) # UJP LI # code for caselist # L1 # CHKI men max # LDCI men # SBI XJP L2 \n# L2 # jump table, i.e. a list of length n=max-min+l; # every entry is of the form # UdP L(n+3) if corresponding \ncase label exists # UJC otherwise # L3 caselist = caselistelem \".\" # semantic checking: # none # communication \n# (1) propagate L3 and required type to caselistelem; # (2) pass label list up # no code @enerated caselist \n= caselistelem caseltst # semantic checking: # none # communication (1) pass L3 and required type to \ncaseltst and caselistelem; # (2) concatenate label lists and pass back up # emit the following code # \nConcatenate code produced by caselistelem anO caseltst 204 C. Excerpts from Current Semantic Grammar \nDOMAIN # Types and Modes TYPE = [ scalarTy [ SIZE X RANGE X SCALID ] + realTy [ SIZE ] + arrayTy [ SIZE \nX TYPE X TYPE ] + setTy [ SIZE X SCALID ] + recordTy [ SIZE X FIELDS X NAME X FIELDMAP ] + ftleTy \n[ TYPE ] + ptrTy [ NAME ]  ] ; MODE = [ undefined + paramMocle [ TYPE X ACCESS X OFFSET ] # parameters \n + varMode [ TYPE X OFFSET ] # variables + constMode [ TYPE X VAL ] # constants + typeMode [ TYPE ] \n# types + procMode [ LABEL X PARAMS X SIZE X TYPE ] # procedures + funcMode [ LABEL X PARAMS X SIZE \nX TYPE ] # functions + labelmode [ LABEL X LABELSTATUS ] # labels + workMode [ TYPE ] w system variables \n ] ; # Environments ENVMAP = NAME -> (LEVEL X MODE): ENV = LEVEL X OFFSET X ENVMAP; # Syntax of P-code \nsequences PCODE = [ emptylnst + single [ INST ] + pair [ PCODE X PCODE ] ] ; INST = [ labelOne [ LABEL \n] # Label of form Lnnn + labelTwo [ LABEL X NAME X INT ] # Lnnn=kkk + comment [ NAME ] comments + \nquit [ NAME ] # eof marker for loader + zeroary [ NAME X INSTTAG ] # 0 arg instructions + unary [ NAME \nX INSTTAG X ARG ] # 1 arg instructions + binary [ NAME X INSTTAG X ARG X ARG ] # 2 arg instructions \n ] ; INSTTAG = NAME ; # Instr. type tag ARG = [ targetLabel [ LABEL ] # Instr. argument types + value \n[ VAL '] + stdProc [ NAME X INSTTAG ]  ] ; # For the case statement dUMPTABLE = INT -> LABEL; # Maps \ncase labels to target label # which starts the appropriate # case pcooe sequence. MINMAX= INT X INT; \nUpper and lower limits of all # case labels. DEFINE ..................................................................... \n # pn : PCODE X ... X PCODE -> PCODE (n=3,3,4,5,6.7) # # These functions combine pcode sequences into \na single pcode sequence. # (Painful) pthree = ~(pcodel,pcode2,pcode3). pair[pcodel,pair[pcode2.pcode3]] \n; pfour = ~(pcodel,pcoae2,pcode3,pcoae4). pair[pcodel,patr[pcode2.pair[pcode3,pcode4]]]; H .................................................... \no.--.--. ..... . .... o ..... # builadumpTable : dUMPTABLE X INT X INT -> PCODE # # Generate for each \ncase list element a sequence of unoondltional branch w instructions to the appropriate sequence of pcode \ninstructions for the # command associated with each case. If a case list element between the # minimum \n(intl) and the maximum (Jnt2) case 11st elements is not essoc- # iated with a command then generate a \n\"Jump on case error instruction\" (UdC) builddumpTable =A(jumpTable. intl,tnt2). IF tntl LE imt2 THEN \nLET label = jumpTable( intl ) IN LET arg = targetLabel [ label ] IN pair [ IF label EQ (\"undefined\",-1) \nTHEN single [ zeroary [ \"UOC\",\" \" ] ) # case error ELSE single [ unary [ \"UdP\",\" \",arg ] ] # unconditional \njump FI, ] buiiddumpTable( jumpTable, tntl+l, tnt2 ) ELSE emptylnst FI ; ATTRIBUTE expression < ENV, \nCMDENV. VALUETYPE :: MODE, CMDENV, PCODE> ; command < ENV, CMDENV :: CMDENV, PCODE> ; caseLtst < ENV. \nCMDENV. TYPE, LABEL, MINMAX. dUMPTABLE :: MINMAX, dUMPTABLE. CMDENV, PCODE> ; caseListElem < ENV, CMDENV, \nTYPE. LABEL, MINMAX, dUMPTABLE :: MZNMAX, dUMPTABLE, CMDENV, PCOOE> ; caseLabelList < ENV. TYPE. LABEL. \nMINMAX. dUMPTABLE :: MINMAX, JUMPTABLE> ; labelDeclPart < LABELENV, LABELLIST :: LABELENV, LABELLIST> \n; constDeclPart < ENV :: ENV> ; typeDecIPart < ENV :: ENV> ; varDeclPart < ENV :: ENV> ; block < ENV. \nLABELENV. MODE :: LABELENV, PCODE> ; program < :: PCODE> ; . . RULE program H case command commana<~env.~cmdEnv,~cmdEnv2.tpcode> \n-\"case\" expresslon<~env,~cmdEnv,#rVslue,~mode1,~cmdEnvl,~pcoUe1> \"of\" caseList<~env.~cmdEnvO.~typel,~labe1.~ninmax~J~JumpTable, \ntminmax2.~jumpTable2,~cmdEnv2.~pcode~> \"e n@\" H attributes to be passed down to caseList WITH (cmdEnvO,type1,1abel.minmax.jumpTable) \n LET (workSpacel.nestlnfol,labeIEnvl) = cmdEnvl IN LET (curWorkl,maxWorkl) = workSpacel IN LET (labeICtr1.1abeIMapl) \n= labeIEnvl IN LET type = extractType(moael) IN 206 (((O,max(maxWorkl.2 tntStze)), # cmclEnvO nestlnfol.(labelCtrl+3,1abelMapl)), \ntype, # type1 (\"L\".labelCtrl+3), # label (maxZnt,minlnt), # minmax int.(\"undefinecl\",-t)) # initial \n3umpTable # synthesizecl cocle WITH pcocle -LET (workSpace,nestInfo.labelEnv) = cmclEnv IN # get 1abe1 \ncounter LET (labelCtr,labeIMap) = labelEnv IN LET type extractType(model) IN # type of case expression \nLET label1 = (\"L\",labelCtr+l) IN # generate 3 labels LET label2 = (\"L\",labelCtr+2) ZN LET label3 = (\"L\".iabelCtr+3) \nIN LET argl -targetLabel[laba11] IN # make ~rguments LET arg2 -targetLabel[1abe12] IN LET arg3 = value[intVa1[ \nleft minmax2 ]] IN # min LET arg4 = value[intVa1[ right minmax2 ]] IN # max LET pcocle3 builddumpTable(JumpTable2, \nleft minmax2, right minmax2) IN pseven(psix( # piece together P-cocle pcoclel. # code for expression \noptOrcl(type). # ORD (optional) single[ unary[ \"UJP\". .... .argl ] ], # UJP L1 pcocle2. # cocle fop caseList \nsingle[ labe1One[ 1abe11 ] ], # LI single( binary [ \"CHK\".\"l\",arg3,arg4 ] ]), # CHKI mln max slngle[ \nunary [ \"LDC\",\"I\",aPg3 ] ], # LDCZ min single[ zeroar'y[ \"SB\",\"Z\" ] ], # SB! single[ unary [ \"XdP\", .... \n.arg2 ] ]. # XdP L2 single[ labelOne[ label2 ] ]. # L2 pcocle3. # jump table single[ labe10ne[ 'laloe13 \n] ] # L3 ) : caseList<~env,~cmclEnv,&#38;typa,~labe1,~lminmax,~jumpTable, 4~mlnmaxl,tJumpTable1.~cm@Envl,~pcoOel> \ncaseListE1em<~env,~cmclEnv,~type,~labe1,~minmax,~jumpTable. tminmax1,~jumpTaD1el.tcmdEnvl,tPcocle1> : \n caseList<~env.~cmclEnv,~type,~label.~minmax.4jumpTable, .~minmax2 , ~umpTable2,_ ,~ cmclEnv2 ,~pcocle> \n= caseListE1em<~env,~cmdEnv.~type,~label.~minmax,~jumpTable, ~mlnmaxl ~jumpTablel ~cmclEnv1,~pcocle1> \ncaseList<~env,'~cmdEnv;.~type,~lab;1.~minmaxl,\u00a2jumpTablel. Im i nmax2 .tj umpTab I e2 .~cmclEnv2 .~pcocle2 \n> WITH pcocle -pair [ pcodel,pcocle2 ] : END  \n\t\t\t", "proc_id": "800017", "abstract": "<p>We have developed a complete formal specification of the translation semantics of the Pascal P-compiler. The specification is written as a semantic grammar (a variant of extended attribute grammars), and has been extensively tested and debugged with the aid of Lawrence Paulson's experimental semantics processor. The translation semantics models the operational aspects of compilation in detail. It is one-pass, embodying static semantic checking, address assignment, code generation, and a certain amount of code improvement. Our paper describes the development history of the project, compares the new compiler with the existing P-compiler, and discusses our positive experience with semantic grammars and Paulson's system.</p>", "authors": [{"name": "Don Milos", "author_profile_id": "81100241470", "affiliation": "Department of Computer and Communication Sciences, The University of Michigan, Ann Arbor, MI", "person_id": "P329884", "email_address": "", "orcid_id": ""}, {"name": "Uwe Pleban", "author_profile_id": "81100306144", "affiliation": "Department of Computer and Communication Sciences, The University of Michigan, Ann Arbor, MI", "person_id": "P287061", "email_address": "", "orcid_id": ""}, {"name": "George Loegel", "author_profile_id": "81100554532", "affiliation": "Department of Computer and Communication Sciences, The University of Michigan, Ann Arbor, MI", "person_id": "P330483", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800017.800531", "year": "1984", "article_id": "800531", "conference": "POPL", "title": "Direct implementation of compiler specifications or the pascal p-code compiler revisited", "url": "http://dl.acm.org/citation.cfm?id=800531"}