{"article_publication_date": "01-15-1984", "fulltext": "\n Creating Elticient Systems for Object-Oriented Languages Norihisa Suzuki and Minoru Terada The University \nof Tokyo 7-3-1 llongo, Bunkyo-ku, Tokyo, Japan 113 ABSTRACT Increasingly computer science research has \nbeen done using workstations with high-resolution bitmap display systems. Smalltalk-B0t is a very attractive \nprogramming language for such computation environments, since it has very sophisticated graphical systems \nand programming environments. Unfortunately there arc still very few computer systems on which Smalltalk-80 \ncan run with satisfactory speed, and furthermore they are quite expensive. In order to make Smallt.alk-80 \naccessible to a large group of people at low cost. we have developed compiler techniques useful to generate \nefficient code for standard register machines such as MC6B000. We have also extended Smalltalk-80 to \ninclude type expressions, which allow compilers to generate efficient code 1. INTRODUCTION More and more \ncomputer science research has been conducted on high-performance personal workstations, The reasons are \nthat we can in general get more computation power per person if we use workstations instead of crowded \ntime-sharing systems, and workstations generally have bitmap display screens that allow us to communicate \nwith computers with much higher bandwidth There are, however, very few excellent programming systems \nthat utilize the full capabilities of the workstations. ,Smalltalk-80 is one of such programming systems; \nit has a number of attractive features for experimental programming such as polymorphism, late bindi.g, \nand object-oriented system structures. Smalltalk-80 has only beell successfully implemented on a very \nfew computer systems, most of which are microcoded machines. These Tnicroeoded machines are Permission \nto copy without fee all or part of this material is granted provided that the copies are not made or \ndistributed for direct commercial advantage, the ACM copyright notice and the title of the publication \nand its date appear, and notice is given that copying is by permission of the Association for Computing \nMachinery. To copy otherwise, or to republish, requires a f\u00a2\u00a2 and/or specific permission. &#38;#169; \n1983 ACM 0-89791-125-3/84/001/0290 $00.75 generally very expensive and only a very few researchers can \nafford them. In order to make Smalltalk-80 programming systems widely available, they have to run on \nstandard microprocessors such as MC68000. As the preliminary process for releasing Smalltalk-80, Xerox \nlicensed Smalltalk- 80 to a number of companies, which tried to implement it on a standard machines \nsuch as VAX and MC68000 based machines. These experim ents [6] were generally very disappointing. Therefore, \nwe decided to put our efforts in generating efficient systems on MC68000. Even though most of the attempts \nin [6] to put Smalltalk-80 on conventional computers are not successful, they have obtained extensive \nperformance measurements, which are very useful to the people like us who want to implement Smalltalk-80 \nsystems. They have found out that there are three major bottlenecks in the Smalltalk-80 systems that \nhave been implemented according to the Virtual-Machine specification written in [4]; the bottlenecks \nare caused by the necessity to find the method, which corresponds to a procedure, for each message send, \nwhich corresponds to a procedure call, dynamically, by the cost of context allocation and deallocation \nsince the contexts, which are the execution environments of procedures, are allocated on the heap, and \nby the cost of reference counting garbage collection used for memory management. We have invented techniques \nto solve these problems; we allocate contexts on the stack as long as the retention of contexts is not \nnecessary, we elidemuch of reference counting by using a transaction-based garbage collection, and we \navoid method search by compare and branch and link instructions exploiting some statistical evidence. \nWe have also concluded that type information is absolutely necessary for both documentation and generating \nefficient code. Type information may be obtained both by declarations [2] and compiler inference [7]. \nWe allow the programmer to supply as many type declarations as they wish This new language and the system \nis called Kiku (chrysanthemum). We will describe the problems and the outline of the Lechniques Lo solve \nthese problems in section 2. In section 3 we describe the language features of Kiku. In section 4 we \ndescribe the details of the compilation techniques t Smalltalk-80 is a trademark of Xerox Corporation. \n290 2. BOTTI.ENECKS AND SOLUTIONS There are three major performance bottlenecks ill the Smalltalk-80 \nsystems that are implemented according Lo the Virtual Machine specification wriLl.en in [5]. They arc \nthe dynamic method search, the context allocation in the heap. and the reference counting garbage collection. \nE.l. Dynamic Method Search Overhead The primitive computation mechanism of Smalltalk-80 is called a message \nsend. For example, an expression to tell a table Lo be moved from location locA to location loeb is table \nmoveFrom: locA to: loeb where table points to an object, which is called the receiver of the message, \nand moveFrom: locA to: loeb is the message sent to table. The entire expression is called a message send. \nThe concatenated string moveFrom:to: is called the message selector. The program that is going to be \nactivated for this message send is not determined at compile time. These special concepts and jargons \nof Smalltalk-80 can be described in terms of ordinary programming language concepts. A message send is \na procedure call. a receiver of a message is the first argument of a procedure call. a message selector \nis a procedure name, and a method is a procedure. Therefore, the above Smalltalk-80 message send can \nbe written as moveFrom:to:(tablc. IocA, loci]) in Pascal. The binding between a message and a method \nis done at run time. Therefore. depending on the classes of the receivers of the messages, the messages \nare interprelcd differently. Each object belongs to a class, which is a specification of a group of objects. \nIn particular a class has a method dictionary, which is a hash table with the message selector as a key \nand the method body as a value. When a message is sent to a receiver, the method dictionary of the class \nof the receiver is searched with the message selector. If it is found in the method dictionary, the method \nbody that is the value of the message selector is invoked. If it is not found, then the superclass of \nthe class of the receiver becomes the class to be searched, and the method dictionary is searched again. \nThus, the method body to be invoked for a message send is determined dynamically. The method search is \noptimized in Smalltalk-I|0 Virtual Machine by providing a large hash table. I\"or every message send a \nhash key is created from the message selector and the hash table is looked up. Each entry in tile hash \ntable has two values: the class and the method body. if an entry with the same selector exists, the class \nis compared with the class of the receiver. If it is the same, the method body is activated. Another \noptimization in the current Smalltalk-80 Virtual Machine is to speed up the method search for special \nmessages such as arithmetic operators. When an arithmetic operator + is sent, the probability that the \nclass of the receiver is integer is very high. When the bytecodes for arithmetic messages arc executed, \nthe classes of the receivers arc first checked. If they are Integer, addition is performed without invoking \na message send. Our strategies are the generalizaUo n of tlHs philosophy. We assume that in each message \nsend classes of the receivers that tile receiver expression denotes are very unevenly distributed, This \nassumption is confirmed by many stntisties taken at Xerox PAI~C. at (JC Berkeley, and by us. A special \ncase of tills is thal an expression always denotes an object from a unique class In such a case, we can \nstatically bind I.he rnessage send and the method so that a 1TICSSilge send call be a simple branch and \nhnk operation I[owever, without a powerful type inference algorithm, Lhere is no way for a compiler to \npredict that an expression always denotes objects of a unique class Therefore, we are introducing type \ndeclarations We specify the classes of wlrmhlcs, methods, and blocks By these declarations we can tell \nthe classes of expressions, and Lell Lhc methods in'volvcd ill. COUlpll(' I ilIl(' We are creating special \nobject code if tile messages arc sent to pseudo-variables. Pseudo-variables are identifiers that always \ndenote some special objects In Smalltalk-80 self is a pseudo-variable that denotes, within the method \nbody, the receiver of the message that has invoked the current method. A variable super is another pseudo-variable \nthat again denotes the receiver of the message that has invoked the current method, but forces the method \nsearch from the superelass of the class where the method appears. If a message is sent to self or super, \nit is relatively straightforward to find the corresponding method at compile Lime. Suppose a message \nself f: arg appears in the class A. then it is easy to think that f: has to invoke a method in the class \nA, or in the superclasses of A if f: does not appear in A This is, however, not true. Suppose this message \nis defined in the method body of g: in the class A. as g: all II self f: arg and this method is invoked \nby sending a message g: to an object of the class B that is a subclass of A, but g: is not defined in \nB. class A- -f~.... I\" superclass class 13 \" f' ----I  I_2_I Then g: invoked is the method in class \nA, but the self in the body of g: denotes Lhe object of class B. so f: invoked is the one in class B. \nTherefore, if f: is defined in the subclasses of class A, it is not always true that f: sent to self \ninvokes the method defined in A or in the superclasses of A. 291 The compiler strategy is. therefore, \nas follows. Any allocated are contexts in the Smalltaik-80 Virtual Machine messages sent to self are \ncompiled to direct branch and link implementation [6]. Therefore, the overall overhead instructions, \nif the methods are not defined in the associated with context allocation and deallocation is subclasses, \nWhcnew:r a method with the same name is tremendous. defined in a subclass, all the message sends with \nthe same message selector to self in the superclasses have to be recompiled. On the other hand message \nsends to super can be compiled easily. Suppose there is a message send super f: x in the class A, Then \nf: has to be in the superclasses of A. We can trace the superclass chain starting from the superclass \nof A at compile time. and can find the location of the method f:. As we explained before, in order to \ngenerate efficient code for message sends to self, we need to maintain a database of methods and to perform \nrecompilation Lime to time. This can be done, but may require a lot of computation. We, therefore, introduced \nanother pseudo-variable her~ which stands for the previous receiver just like self or super: but forces \nthe method search to start from the class where the pseudo-variable here appears. We can statically determine \nthe binding and do not have to recompile. The third technique to speed up ~rnethod invocation is to exploit \nstatistical facts. 1t was reported by the measurements at Berkeley that it is very likely that the message \nsends in a class will invoke methods in the same class. We describe Lhe code generation techniques that \nexploit this fact in section 4. 2.2. Context Allocation and Deallocation Overhead In Smalltalk-80 a local \nexecution environment created every Lime a method is invoked is called a context. It contains a pointer \nto the previous context called a caller, a pointer to the object code of the method, an instruction counter, \nparameters, local variables, which are called temporary variables, and an evaluation stack. These information \nare stored in the execution slack in the implementation of ordinary languages, but in SmallLalk-80 contexts \nare treated as objects and allocated in the heap. There are a number of advantages for doing this way. \nComplex control structures such as processes and coroutines can very easily be implemented because contexts \nare objects. Utility systems such as a debugger can be easily implemented, because the history of the \nexecution can be easily traced and manipulated by sending messages to contexts. However. all the overhead \nassociated with object creation and destruction has to be paid by a method activation and return. For \neach method activation, a storage area with the size of a context is allocated, and the reference count \nis incremented; for each method return the reference count is decremented and the storage is returned \nto the free list. It was reported that more than 80% of objects Our philosophy in solving this problem \nis to allocate contexts linearly in the stack as long as possible. When it becomes necessary to treat \nthe current context, which is the Lop context in the stack, as an object, or to change the current context \nbecause of a process switch, we make all the contexts in the slack objects in the heap. 2.3. Reference \nCounting Overhead Automatic allocation and deallocation of objects is a must for easy to use object-oriented \nlanguages. However, the ordinary mark-and-sweep garbage collection has a long pause when the garbage \ncollector starts, and is not suited for real-time, interactive applications. SmallLalk-t30 Virtual Machine \nuses reference counting garbage collection in order to improve the real-time response. Reference counting \ngarbage collection generally performs better than mark-and-sweep garbage collection since it requires \nless disk I/O. However, the overhead associated with reference counting is substantml. In a slack machine \nlike SmallLalk-60 Virtual Machine most of the operations are stack pushes end pops. In order to push \nan object, the reference count of the object must be incremented, and in order to pop and object the \nreference count must be decremented, According to our calculation, 807. of the computation time for pushes \nand pops spent in reference counting. We reduce the reference counting overhead by not counting if the \npointers are in the stack. This is a modificaLion to Deutseh and Bobrow [3] transaction garbage collection \nalgoriLhm, The details will he explained in a later section, 3. LANGUAGE FEATURES OF KIKU The syntax \nof Kiku is similar to Smalltslk-80; however, we fell Lhat parentheses-less syntax of message send expressions \nis very confusing if message sends are nested. Therefore, we adopted conventional notations with parentheses. \nHowever, our compiler will accept both syntax. The syntax for a message send is <expression> ! <selector> \n[ ( <.parameter list> ) ] where the <selector> is an identifier and the <parameLer list> has the following \nBNF-syntax: < parameter list > :: ---< parameter > <parameter list.> :: = <parameter> , <parameter list> \n 3.1. Typing Some work have been done to introduce types to Smalltalk. Borning and lngalls [2] introduced \ntype expressions; their compiler understands types and checks type consistency, but it does not use the \ninformation for 292 code generation. Suzuki [7] has devised an algorithm to infer types from the completely \nunlyped programs. His goal was to create effieient code as well as to locate potential bugs I~y type \ninference. This research, however, showed that if~ the language like Smalltalk-80 that allows union types, \nmany inferences are not tight enough Lo be useful for generating optimized code. We still believe, however, \nthaL in Smalltalk-80 the ultimate optimization for message sending can only be attained by knowing the \nclasses of the expressions at compile Lime either by type inference or by explicit typing. So we decided \nto introduce type expressions into Smalltslk-80. Smalltalk-80 gels much of its power from the type hierarchy \nsystem, polymorphism, and function overloading. We would not like Lo destroy the flexibility by introducing \na rigid type system. Therefore, Lhe declarations are opLional in our system; objects still carry Lype \ncodes wiLh them. Type expressions are decorations to the program, They ar~ used by an optimizing compiler \nto create a tightly bound code. The locations where we put type expressions are with variable declarations, \nmethod declarations, and block statements. 3. i.I. Type Expressions A type .expression can be a class \nname or a set of class names. A seL of class names is used Lo denote a union type. To be precise, a type \nexpression is a name of a class, or subclasses of a class, or a union of them. BNF'-syntsx for type expressions \nare: <primitive type expression> :: = <class name> I sub <class name> < type expression > :: = < primitive \ntype expression > I (< primitive type expression > ..... <primitive type expression > ) 3.1.2. Type Designations \nWe associate type expressions with variable declarations, method declarations, and block statements. \nWe call the declarations with type expressions type designations. We first explain the syntax for type \ndesignaLions by some examples. A declaration of Class Array is: Class Array ev --list of class variables \n-- era --list of class methods -- iv --list of instance variables -- ira at(index: SmallinLeger)II --method \nbody to extract an element --of the array o- the rest of instance methods. Ilere Array is the class \nname, The header im marks the beginning of the declarations of instance messages An instance message \n\"at\" is declared wiLh type designations. It lakes a parameter \"index\" of type \"Smalllnteger\", which declares \nthat \"index\" can only denote an instance of Class Smalllnteger In addition to being a class, SmalllnLeger \nserves as a type expression. We may want to declare the class of the value returned by this call, which \nis the class of the element of the array. However, Smalltslk Array can take any objects as its elements; \ntherefore, we cannot specify the resulting type of at. The besL we can do is to specify that the result \nwill belong Loa subclass of Class Object: aL(index: SmalllnLeger): sub Object, which is equivalent Lo \nhave not type expression at all. In order to create an array which takes objects of one class we have \nto define special classes such as Clas.~ SmalllntegerArray, and specify that the result of array access \nis of Class Smalllnteger and that the value to be assigned in Lhe array assignment is of Class Smalllnteger. \nllowever, since the number of classes that may be defined is unbounded, it is not practical to introduce \narray classes for all the element classes. Therefore, we have to introduce parameLerized classes in order \nto cover all the eases Then the result type of at can be defined by the parameter of the class name used \nwhen Lhe object is created. We have, however, not implemented parameterized classes, beca~Jse we have \nLo introduce new-mechanisms to the compiler and Lhe run-Lime system. In the near future we will be incorporating \nthis feaLure. BNF-syntax for type designations are: <class variable declarations> :: = evlev <variable \ndesignations> < variable designations> :: = <typed variable> J <Lyped variable> < variable designations> \n<typed variable> :: = <identifier> I ~. idenLifier> : < type expression > <inst~luce wlriable declarations> \n:: = ivl=v <variable designations> <cl~=s.~ method declar~Jtions> :: = eln J(:lu <method declaraLions> \n< m(;thod d(;clarations> :: = ~.~ method header> J < w~ri~ble designations> J <expression list> wherry, \ntlu~ rc'gular vertical bar (J) is a metasymbol denoting ~m ~lll.crn~dlv\u00a2~ choice, ~lnd the bold verLieal \nbar (I) is a symbol th~ll ;=pp(,nr.~ in Smalltalk-II0 programs. Blocks also have type cxprf~sslons, since \nthey receive arguments and returns resulL~ The syntax is: <l)loek> ::-. ( <expressions list> <result \ntype> ]J [ <parameter declarations> I <expression list> <result type> ] < parumeter declarations> :: \n= <parameLer> I <parameLer>, <parameter declarations> <parameter> :::- : <identifier> I : .c'ident.ifier> \n: <type expression> <r(;sult type> ::-' <resulL type> ::;: : <type expression> 293  3.2. Pseudo-variables \nThere are two variables, \"self\" and \"super,\" which have special meanings in Smalltalk-80. \"Self\" points \nto the receiver, when the method is executed, leer example, if we use recursion to implement multiplication, \nit can be written as: multiply: n II (n~O) ifTrue: Itself]. t(self + (self multiply: (n-l))) in Smalltalk-80. \nThen, we execute 5 multiply: 3 to obtain 15. The same method is written in Kiku as: multiply(n: sub Integer)II \n(n = 0) ! ifTrue([tself]). t(self + (self ? mulLiply(n -I))) The method Lo be invoked for the message \nsent to self cannot be determined staLically if the method is redefined in the subclasses bccause of \nthe reasons explained in section 2; thus, we have still to use slow method look up. We introduced a pseudo-variable \n\"here\" to force the search from the class whcrc the message send occurs. Thus, the static binding is \nalways possible 3.3. Multiple Value Returns from Methods It is imporl~mt for any programming languages \nto have mulLiplc-wdue-returning functions Lo simplify programs and to make programs cllicient. PASCAl, \nallows results to bc reLurned through parameters, thus multiple value returns art: possibh:. It is difficult \nto introduce this feature into Smalltalk* 80, since we cannot tell whether a particular message returns \na single result or mulUplc results because messages are overloaded. What we did was to introduce a different \nconcept a,pd solved thi.'; problem. We introduced array constructors and array extractors. When we want \nto return multiple values, we write 'r.(x. y) which creates a two-element array with x and y as elements \nand returns it. We can obtain multiple results from a message by using an array extractor as follows: \n(x, y) ~-point coordinates The expression point coordinates returns a two-element array, and the first \nelement is assigned to x and the second element is assigned to y. Semantically this solution is dilTerent \nfrom the multiple-value-returning functions, but the syntax is very similar. This feature has created \na nice side-product. We often nest the calls such that multiple values have to returned up several levels. \nIf we have not treated results as one object, we may have to extract results and construct results repeatedly. \nFor example, we can compute the remainder and quotient simultaneously by the following method: divMod: \nn II tself divMod: 0 by: n divMod: q by: n II (self < n) if'true: ft.(q, selt)]. itself -n) divMod: (sum \n+ 1) by: n Tb(; last call rel.urns mulLiple results as an array, so they are returned through all the \nlevels of divMod'by: without disassembling and assembling. 4. CODE GENERATION AND RIJN-TIME TECllNIQIJES \nIn this section we describe the code generation and run-Linle sysl.em implementation techniques we are \nusing to solve the system bottlenecks described in section 2. 4.1. Avoiding the Dynamic Search of Methods \n In Smalltalk-80 a m(:ssagc and a method are bound dynamically. The basic mechanism for binding a message \nand a method is defined in the book [5}. The expression is of the form r sol: e where r is a receiver, \nand sel: e is a message. First, scl: is looked up in the method dictionary of the class of r. If it exists \nthen the method is executed with the supplied arguments. If it does not exist, then the dictionary of \nthe suparclass of the class of r is searched. This process of looking up m the successive superclasscs \nis repeated until we come to a class which does not have a superclass, and then the massage produces \na dynamic error. Our code generation technique for the message is to speed up by avoiding the search \nwhenevcr possible. 4. I.I. Arithmetie and Other Primitive Methods In Smalltalk-80 arithmetic operators \nsuch as + are ovcrloaded just as all the other methods. However, it would be very inefficient Lo use \ndynamic binding for common arit.hmetic operators. The probability that the receivers of the arithmetic \noperators are integers is higher than 95Z [6]. Bmalltalk-80 byteeodes for arithmetic operators exploit \nthis fact; they first check the classes of the receivers. If they are class Small|ntegcr, arithmetic \noperations are executed. We use this technique to create open compiled code. We dedicate one register \nreceiverClassReg to hold the class of the receiver, and the code is if reeeiverClassReg .= Class Smalllnteger \nthen branch (GeneralSearch) else <in-line code for integer addiLion >. 4.1.2. Techniques Useful for \nGeneral Messages l,'or all the other messages we use the followm~ sl.aListieal facts More than 90% of \nl.hc messages invoke methods Lhat arc in the class where the mcssages arc written. We can exploit this \nfact Lo produce the following rode. if receiverClassReg =-methodClassRcg thcn branch (G cneralSearch) \nelse <jump to tlme place where (sel:) is defined>.  294 where rec(:iv(~rClassl~cg is a d(,diealed register \nwhich always holds the class of tile r(:cewer alld iHethodClassl\u00a2eg l,lolds the class of the method, \nthat is the class where the message is written Then the statistics tells us that the last leg of the \ncondiUonal is I~lkcn more than 907. of the cases; thus, we can eliminate most of Lhe expensive method \nlook up. 4.1.3. Messages Sent to Pseudo-variables In Kiku there are three pseudo-variables \"self\", \"super\", \nand \"here\". As explained in section 2, messages .'-;cut to \"super\" and \"here\" (:an be bound statically. \nMessages sent to \"self\" can be statically bound, it no methods with the same selector are defined in \nthe subclasses. 4.1.4. Messages Sent to Typed Expressions 'l'hc' elfccls of type designations are that \nwe will guarantee that the objects that arc pointed to by the typed variables are instances of I.he classes \nthat the type expressions denote. When a message is sent to a typed variable, we know exactly which method \nwe should invoke. It a variable is declared to be of type Integer, the method to be invoked must be declared \nin the class Integer or in its superelasses. If a variable is declared as a union of Integer and Float, \nthe object code ereated is if receiverClassReg = Class Integer then <directly call a function in Class \nInteger> else <directly call a function in Class Pleat>, where reeeiverClassReg is a register dedicated \nto hold the class of the receiver.  4.2. i.inearization of Contexts J)rocedure acLivaLJon envJrollntcnls, \nwJlJch are called eonLexL~ in Smalll.alk-80, are also objects. Therefore, contexts can be assigned to \nvariables and be sent messages. Smalltalk-80 gains much power and flexibility because el, this feature. \nV~lrious control mechanisms like coroutines and processes are implemented using this mechanism: various \nilnportant svs[cln software such as dehuggers can be very easily inlplem(:nled. IIowevcr, this int.'chanism \ndisallows the use of a smlple linear stack to allocate contexts Therefore, most of the existing SInalllalk-80 \nimplenlentalions allocate (:onLcxts frolil tile heap, Ilowever, conLcxl.s arc rl:ference-counted and \ngarbage-collected; thus, substantial part of the exectltion I.ime is spent in contexts allocation and \ndealloeation. In SmallLalk-80 Virlual Machine 8:1% of objects allocated are contexts (McthodConLext) \n16]. One candidate data structure for contexts is a spaghetti stack [1]. It is used in hiterlisp to realize \nprocesses and coroutines. However, this mechanism is not flexible enough for SmallLalk-80 which treats \ncontexts as objects. We invented a mechanism called a \"delayed retenlion\" of contexts. We have a fixed \nsize area to be used as a stack. This area may be able to hold at most t0 contexts. When a new context \nis necessary, it is always allocated on this stack. As long as a context is on the sLack, it is not an \nobject: it is not reference-counted, and it cannot be sent messages. Furthermore, all the contexts in \nthe stack are linearly ordered so that the eallee is always on top of the caller. Therefore, when a method \nreturns and there is a context in tile stack, context dealloeation is simply a slack pointer change. \nThe underlying assumptions for this mechanism to work much more efficiently than ordinary heap allocation \nare I.haL message sends and returns alternate frequently, so that it is rare that many contexts are allocated \nwithout any dealloeation in the middle. Furthermore, operations that require context retenJ.ion such \nas creation of Block contexts and message sends to contexts occur quite infrequently so that if we allocate \ncontexts in a stack, we rarely have to reorganize the stack. Therefore, contexts on the slack behave \njust like I'ramcs in the Pascal stsek In order to maintain this property we have to perform some operations. \nWhen the stack becomes full, contexts have to be swapped out in FIFO manner to make room for new contexts. \nSpace are allocated m the heap to hold the contexts being swapped out Ilowever, the conLexts are not \nswapped into lhe stack from the heap even though lhe stack becomes empty by the me.~sage relur, ffrom \nthe last context in the stack. Thcrel,ore, the current context can be either on the stack or in the heap \nWhen a context is needed to be retained, all the contexts in the st~lck are swapped out from the slack \nThen the current context is pushed on the stack. This always occurs with the execution of the bytecode \npushAcliv'oConlexL we only need Lo modify this bytecode. This is the reason why we limit the size of \nthe stack. We can pitt an upper bound on the pushActiveContexl execution lime. When there is a process \nswitch all the contexts in the stack have to be swapped out also, since a process switch may violate \nthe property that the callee is on top of the caller in tile stack. Whether this technique is practical \nor not depends on the percentage of contexts that must be retained among all the contexts. This can be \nestimated by the number of conlexLs allocated on the stack (MethodContext) versus the number of BlockContexts, \nwhich have pointers to them. ']'his ratio is 20 to 1 [6], so we predict that retention is required rarely. \n4.3. Improving Reference Counting Garbage Collection Smalltalk-80 uses reference counting garbage collection \nin order to improve the real-Lime response. However, it slows down the average operations significantly. \nConsider, as an example, the most frequently used bytecode \"PushTemporaryVariables,\" which obtains a \nlocal variable and pushes it onto the stack. This simple operation requires two reference counting operations: \nfirst, the reference count of tile object pushed on the stack must be incremented, then the rel,erence \ncount of the object replaced is decremented. In our implementation on MC68000 reference count up and \ndown take 10 instructions each. Since obtaining the value and pushing il on the stack takes 5 instructions. \n80 % of the Lime is spent in reference counting. 295 The key observations are that most of the objects \nare short lived, and that the references to them are only from stacks or from some system defined variables. \nTherefore, we try to eliminate reference counting if the objects are pointed from the stack. The statistics \non four major stack bytecodes are: Relative Number or dynamic R.efcounts frequencies PushTemporaryVariables \n20 2 Push ReceiverVaria bles ? 2 PupA ndStoreTem poraryVaria bles 4 2 Pupa ndStoreReceiverVariables 2 \n2 If no reference counting is done from the slack Number of Ref counts PushTemporaryVariables 0 Push \nReceiv erVariables 0 PupA ndStoreTemporaryVaria bles 0 PupA ndStoreReeeiverVariables 2 Simpl); not counting \ndoes not work. because an object may be. pointed from some other object, too. Even if the reference count \nof an object is deerement.ed to 0 it may not be deailocated, since the pointer from the stack still exists. \nSo what we will use is a variation of a transaction-based garbage collection by Deutsch and Bobrow [3]. \nIf a reference count becomes 0, the pointer is stored in a ZCT (zero count table), and the correct reference \ncounting is done at the end of a transaction. The entire algorithm is: (t) The transacLion begins: ZCT \ncontains all the objects whose reference counts are 0 but are pointed from the stack. These are the only \nobjects contained in ZCT. (2) If the reference count becomes 0, the pointer is stored in ZCT.  (3) \nPointer operations Lo push and pop or copy from the stack are not counted. (4) We complete a transaction \nat some point, eiLher because it runs too long since the beginning of the transaction, or ZCT becomes \nfull. At the completion of the transaction, we scan the stack and put all the pointers in a hash table. \nFor each pointer in ZCT, check whether the reference count is zero. If it is not zero, just remove it \nfrom ZCT. if iL is still zero, check whether it is in the hash table. If so, just leave it in ZCT. Otherwise \ndeallocate. Now let us consider tile performance. According to our implementation, push and pop take \n5 steps in all the cases, the reference counting 10 sLaps, and ZCT store 5 steps. Then, Steps Steps for \nthe for the New Method Old Method PushTem poraryVariables 5 25 PushReceiverVariables 5 25 Pupa ndStoreTemporaryVariables \n5 25 PopAndStoreReceiverVariables 25 + a*5 25 (2 ref count. I possible ZCT store) where c~ is tile ratio \nor decrements which result in zero reference count. Empirical data is obtained for this ratio is a=0.04 \n[6]. Therefore, the overall improvements excluding the transaction close procedure can be computed by \nmultiplying tile number of steps in the above table by the relative frequencies of operations in the \nprevious table- 20,5 + 7,5 + 4,5 + 2,(25 + 0.2) = 0.25 (20+7+4 +2),25 We can estimate the time for creating \nthe hash table and scanning ZCT aL the end of a transaction from the ratio of the dynamic frequencies \nof pushes and pops against the storage creation which is the upper bound of the number of eontexts created. \nFrom the book [6]. pushes and pops are 55X of the bytecode, whereas the message send byLecode for \"new\" \nis 0.35X. So the transaction close operation overhead is negligible compared with the reference counting \noperations eliminated from pushes and pops. 5. CONCI.USION We exLended Smalltalk-80 to create Kiku; we \ndescribed features of Kiku which help to, generate efficient objeet code. We are creating an optimizing \ncompiler and a run-Lime system for Kiku. Three major performance bottlenecks or Smalltalk-80 systems \nare: method search, context allocation and deallocation, and reference counting garbage collection. We \ninvented compiling and run-time system construcl~ion techniques to solve these problems. We analyzed \ntile performance or these techniques using statistics ~=vailable oil the current Smalltalk-80 implementation \nand concluded that each of the technique improves the system performance significantly. We learned from \nPeter DeuLsch [4] that he has created a native code compiler for MC68000, which runs very fast. Alan \nBurning told me that it is very efficient and uses techniques similar to ours. However, we did not get \na copy of Deutsch's paper in Lime to compare with our techniques. We are grateful to the comments by \nlchiro Ogata who is another implementer or the compiler, and Alan Burning. BIBI, IOGRAPIIY [I] Bobrow. \nD. and Wegbreit. B., \"A Model and Stack Implementation of. Multiple Environments,\" CACM 16, l0 (October \n1973), pp.591-603. [2] Burning, A., and lngalls, D., \"A Type Declaration and Inference System for Smalltalk,\" \nProceedings of POPL, ACM, 1982. [3] Deutsch, P., and Bobrow, D., \"An Efficient Incremental Automatic \nGarbage Collector,\" CACM, September 1976. {4] [)euLsch, P., Prec. of POPL, ACM, r984. [5] Goldberg, A. \nand Robson, D. \"Smalltalk-80: The Language and its Implementation,\" Addison-Wesley, Reading, Massachusetts, \n1983. [6] Krasner, G., \"Smalltslk-80: Bits of History, Words of Advice.\" Addison-Wesley, Reading, Massachusetts, \n1983. [7] Suzuki, N., \"Inferring Types in Smalltslk-76.\" Proceedings of POPL, ACM, 1981. 296  \n\t\t\t", "proc_id": "800017", "abstract": "<p>Increasingly computer science research has been done using workstations with high-resolution bitmap display systems. Smalltalk-80&uarr; is a very attractive programming language for such computation environments, since it has very sophisticated graphical systems and programming environments. Unfortunately there are still very few computer systems on which Smalltalk-80 can run with satisfactory speed, and furthermore they are quite expensive. In order to make Smalltalk-80 accessible to a large group of people at low cost,. we have developed compiler techniques useful to generate efficient code for standard register machines such as MC68000. We have also extended Smalltalk-80 to include type expressions, which allow compilers to generate efficient code</p>", "authors": [{"name": "Norihisa Suzuki", "author_profile_id": "81332530584", "affiliation": "The University of Tokyo, 7-3-1 Hongo, Bunkyo-ku, Tokyo, Japan 113", "person_id": "PP39079856", "email_address": "", "orcid_id": ""}, {"name": "Minoru Terada", "author_profile_id": "81546260156", "affiliation": "The University of Tokyo, 7-3-1 Hongo, Bunkyo-ku, Tokyo, Japan 113", "person_id": "PP31096863", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800017.800541", "year": "1984", "article_id": "800541", "conference": "POPL", "title": "Creating efficient systems for object-oriented languages", "url": "http://dl.acm.org/citation.cfm?id=800541"}