{"article_publication_date": "01-15-1984", "fulltext": "\n Inverse Currying Transformation on Attribute Grammars Re~nhazd WiU~lm * Department of Electrical Engineering \nand Computer Science University of California, Berkeley Berkeley, CA 947S0 ABSTRACT lnverse currying \ntransformation of an attri- bute grammar moves a context condition to places in the grammar where the \nviola- Lion of the condition can be detected as soon as the semantic information used in the condition \nis computed. It thereby takes into account the evaluation order chosen for the attribute grammar. Inverse \ncurry- ing transformations can be used to enhance context sensitive parsing using predicates on attributes, \nto eliminate sources of backtrack when parsing accord- ing to ambiguous grammars, and to facili- tate \nsemantics-supported error correction. 1. Motivation Attribute grammars have found wide acceptance as \na means to describe the static semantics of programming languages. Semantic attributes are used to carry \nscope, type and other declarative information; predicates on attribute occurrences in productions rule \nout programs, which are syntactically correct, but semantically mean- ingless, such as programs with \nmissing or double declarations, type inconsistencies, or violations of parameter passing conventions. \nSeen formally, these \"context conditions\" restrict the language as defined by the context-free grammar \nto a subset satisfying seman- tic constraints of the language. on leave from: Urfiversitat des Saarlandes, \nFachbereieh lO-lnformatik, D-~O0 Saarbr~cken, Fed, Rep, of Germany, Research reported herein was supported \nby a travel grant of the Deutsche Forschungsgemein- schaft. Permission to copy without fee all or part \nof this material is granted provided that the copies are not made or distributed for direct commercial \nadvantage, the ACM copyright notice and the title of the publication and its date appear, and notice \nis given that copying is by permission of the Association for Computing Machinery. To copy otherwise, \nor to republish, requires a fee and/or specific permission. &#38;#169; 1983 ACM 0-89791-125-3/84/001/0140 \n$00.75 [pdtanlp|e: The production ASSIGNMENT-* FAR:=EXPR might have the context condition tUpe(VAR)=t!rps(EXPR) \nor some less restrictive condition if the language allows automatic conversions. Hereby. it is assumed \nthat syn-thesized attributes t~/pe are associated with the nonter- minals in the VAR- and EXPR-subgrammars \nindicating the type of the variable or the expression. There are other ways to describe the same context \ncondition: but this seems to be the \"natural\" one. In particular, it does not contain any assumption \nabout the order in which attributes are evaluated, i,e. the order in which the VAR- and EXPR-subtrees \nare traversed by the attribute evaluator. If the evaluation order is known, e.g. left-to-right depth- \nfirst, one could transform the attribute grammar so that the VAR can tell the EXPR what types it may \nlegally havc. This might enhance the localization of semantic errors, as it allows for the detection \nof the smallest subexpression Lhat causes the expression to have the wrong type. Other interesting applications \nfor this transformation lie in the area of context-sensitive parsing [JMJ80] [WaJe0] in particular when \nworking with ambiguous grammars. The Graham-Glanville code .generation scheme [GIG78] [Hen83] works with \nan LR-parser generated from a syn- tactically ambiguous grammar. Shift-reduce conflicts are resolved \nin favour of shifts to generate \"larger\" instructions; reduce-reduce conflicts are resolved by semantic \nconstraints and/or cost criteria. A semantic constraint whose violation is discovered only after some \nreductions have been made and the corresponding instructions issued requires backup to find some other \nsequence of instructions previously ruled out in favour of a presumably better sequence. Example: The \nfollowing productions describe two addressing modes and three instructions for some machine: 140  INDEX \n-\" + REG *const PEG condition: value(const) e- ~1,2,4,8 I size(INDEX) := value(const) ADDRESS -INDEX \nsize(ADDRESS):= size(INDEX) ADDRESS -REG RVAL -. indir ADDRESS condition: size(indir) = size(ADDRESS) \nPEG -, *REGREG REG ~ +REGREG REG -, const When parsing the intermediate program representation indir \n+ REG * const REG any reductions using the last two productions would be rejected in favour of the \"larger\" \nproduction given first, if the size of the const is one out ~1,:~,4,8~. This would reduce the string \nto indir INDEX But backup is necessary, if after reduction to indir ADDRESS the size condition of \nthe production for RVAL is discovered to be violated. Again, as in the previous example, the size information \nat the indir node could be passed down the ADDRESS tree to discover the violation of the size condition \nupon shift instead of upon reduc-tion. The transformation of attribute grammars described in this paper \nwould move semantic constraints to places in the grammar where their violation could be observed earlier. \nThis eliminates sources of backup. The transfor- mation can also be used to exploit semantic information \nfor the correction of syntax errors [Sch82]. The transformation was first used in [Wi179] to show different \nattributations with different properties for the same language. We call the transformation inverse currying \nbecause of the related transformation in combinatory logic, which transforms a function into a functional \nby pulling out one of its argument domains. This was named after the logician Haskell Curry. 2. Terminology \nand Notation An attribute grammar consists of a context-free gram-mar, called its underlying context-free \ngrammar, an association of attributes with terminal and nonterminal symbols, and an extension of productions \nby semantic rules and context-c~)nditions. The set A(X) of attributes associated with a a symbol X is \nthe union of the disjoint sets ](X) and S(X) of inhsrited and synthesized attri-butes. Both, attribute \na 'bf symbol X and its occurrences will he denoted by a(X). Occurrences of inherited attributes on the \nleft side of a production n and of synthesized attributes on the right side of a pro- duction are called \nimporting attribute occurrences, since at an instance of n in a syntax tree their instances import values \nfrom the context of that instance of the production. All other occurrences of attributes in pro- ductions \nare called szporting. For any exporting occurrence of an attribute b in a production n: Xo -\" Xl  ' \nXm there must be exactly one semantic rule b(Xj) := g(ai(Xil),' ' ,~(X~j)) determining how values for \nthis attribute occurrence are computed. It is generally assumed that the arguments of g are either importing \noccurrences of attributes or constants. Also associated with a production may be context-conditions \np(al(X~l),...,a~(Xi~)), p being a k-ary boolean predi-cate. describing semantic constraints on the language \ndefined by the underlying context-free grammar. We also assume that the arguments to p are all importing \noccurrences. Fig. 1 gives a graphical representation of an attributed production. Inherited attributes \nare represented by boxes to the left of syrnbol occurrences, synthesized attributes to the right. Only \none semantic rule is depicted by function symbol g with arrows indi- cating flow from arguments and to \nthe target. A context-condition is written below the production. Heavy arrows pointing to importing and \nheavy arrows pointing from exporting occurrences indicate the interface to the upper and lower context. \n The transformation described in this paper involves manipulation of boolean predicates used as context-conditions \nand of functions used in semantic rules. Given a predicate p :Aix . \" xA~ -*~ true ,false ~ . If there \nexists l~r<k and nontrivial functions I~ : AI x '\" \"x~-l -' 2 ~'. l~ : Al x \" '\"xA.-l -\" ~* such that \np(a I, '. ,ar_l,br, ' ' \" ,b~) = true iff bl~f~(al,... ,ar_-I) for all,#:r<j<k, then we call the f~'s \ninverse curried functions for the predicate p. We call these functions nontrivial if they are not the \ncon-stant function \u00a2. Suppose some arguments to a predicate p are given. The inverse curried functions \nfor p compute for all the other argument positions the set of arguments that together with the given \narguments will satisfy the predi-cate. Given a function g :A1x .-, xA k -* B' . If there exist 1 ~: r \n<k and nontrivial functions If: 2BxAl x ' '\"x&#38;-l -' 2~' lZ: 2exAl x \"' ' &#38;-~ -' 2~' such that \nfor any b c B: g(a 1.. . \",ar_1,cr,\" ',c~) cb iff c# EfjT(b,a I. .  ,ar_~) for allj:r ~j ~k , then \nwe call the functions f~ inverse curried functions for the function g. In the following we will always \nuse letters g,h for func- tions in general and letters p,q .... for boolean predi- cates. Hence it will \nalways be clear how the actual cur- ried inverse functions are defined. In general, the inverse curried \nfunctions might not be computable, and in case they are, it might be impractical to compute or represent \nthem. But functions used in attribute gram- mars are mostly total functions on small domains. 3. The \nTransformation The transformation is based on a left-to-right depth-first evaluation order as required \nfor the evaluation of L- attributed grammars [LRS74], i.e. grammars with no right-to-left attribute dependencies. \nIt removes context-conditions replacing them by functions comput- ing the \"legal domains\" of attribute \nvalues guaranteeing the satisfaction of the removed conditions, functions propagating these domains down \nthe tree, and membership tests at those places where attribute values are computed. There will be three \nsteps constituting this transforma- tion: Steps of type (1) remove a context condition from a pro- duction, \nassociate new inherited (domain) attribul.es with nonterminals and semantic rules initializing these \ndomain attributes with the production. Steps of type (~) and (3) handle any such newly int.ro- duced \ndomain attribute. They thus have two forrnal parameters, a synthesized attribute b and the corresponding \ninherited domain attribute /._b. (~) intro- duces functions propagating domains thereby inverting semantic \nfunctions wherever possible. If there is a con-text condition involving the attribute b under considera- \nLion, the combined requirements on the legal dornains for b are propagated. If domains cannot be propagated, \nnew context conditions are introduced into productions. They check wheLher an aLLribute COnlpuLed in \nthe pro-ducLion or associated wiLh a Lerminal by Lhc scanner is an element of the corresponding domain \natLrihute. (3) takes care of occurrences of domain atLributes wit.huut initialization. The production \n~t, which we will consider, syntaeLieally always looks like n: Xo -\" X}X~\" Xm wiLh the Xi being terminal \nor nonl.erminal symbols. The transformaLion slaps are: (I) Assume that connected with production r~: \nX0 -* XI \" \" Xm there is a context condition p(a,(X,,)) ..... ak(X~)), ij ~0.....ml for l~j ~k. To \navoid some formal trouble we assurne that ij<ij,lfor l<3'~k-1 t. Let domain(aj)=A i for 1 ~ j < k. Thus \np is a predi- cate p :Alx.. xA~ -* ~true,falsel. If there exist inverse curried functions fr e ..... \nf~ for p, where we choose r minimal with /r ~e zr-i *, we transform production n in the following way: \n(o)delete p from production Iz; associate inherited (domain-) attributes i_~r,''',i a k with the nonterminals \namong the x,,. ...x,, ; associate semantic rules ~_aj(X~) := l?(a,(X,,).....=,_,(X,,_,)) for r~-:~ with \nproduction ~t. if Xt# is a nonterminal; associaLe conditions a~(X%)ef?(a}(Xt~), \" \" ,ar-.}(X%_,)) wiLh \nn, if Xt~ is a terminal. When a syntax tree is decorated according to the new production n, any instance \nof an attribute i ai at an instance of n will contain all legal values for the corresponding instance \nof al, given values for the instances of attributes a}, . . . ,av_ } . The above transformation covers \nthe general case. In practice, there are only a few realistic eases. The most common of those are depicted \nin figures 1.1 -1.5. 1\"This assumption reflects the left-to-right evaluation order, as the in- verse \ncurried functions are defined. Choosing a minimal r corresponds to computing domains for attribute occurrences \nas far left in a right side as possible; the condition trY}r_} prevents the introduction of a dependency \nof an inherited domain attribute on a synthesized attribute at the same symbol oc- currence. The legal \ndomains must be propagated down Lhe trees. Step (2) makes the necessary changes to the grammar. (2) Assume \na synthesized attribute b and a newly intro- duced inherited d()rnain al.tribuLe ~__b assoeiaLed with \nX o, and a sumanLic rule b(Xo) := g (rz}(Xt,). \"\" ,ale(X%,)) associated wilt, product, ion 'It. Assume \nas in (1) I, hat ij<i.j, t for l<~<k -I. (2.1)If inverse curried funcLions f~,' \" \",f~ exist. ( r minimal \nwith 'Lr #~r-I ), the[} we earl propagate Icgal atLr'ibute domains by the following changes I.o pro- \nd }Joliet} 'n,: associate inherited aLl.fibuLas i_a i with the non-terrninals arnong Lhc X~r, \" \" ' \n.X b ;  associate semantic rules i aj(Xij):= f?(i b(Xo)Jz,(Xq).\" \"'.av ,(Xi,.,)) for ~'<j~;k wiLh producLion \nrt. if Xij is a nonLerminal and ij ~' O;  associate a condiLion  aj(Yg)cfl(i_b(Xo).al(Xtt). \" \" \" \n.~ I(X%.,)) *'it[: .~,. if Xij is a terminal or /j=O. The most frequent examples of such (!hangcs arc \ndep-icted in figures 2.1 - 2.4. (2.2)1f t,o inverse curried funcLious exist., pr'oduetior~ n is changed \nas folh)w.~: Associate cor, dith)n g(a,(XQ,\" '',~(X~,))ci_b(Xo) wilt, produeUun .  (el. Fig. Z.5). \n(2.3)Another special case is the following: b (X0) does not depend on any aLLribute occurrences but. \nonly on constants, i.e. b(Xo):=g(cl, \"'' ,ck). In this case we associate condition g(el,... ,%)Ci_b(Xo) \nwlLh n (cf. Fig. 2.a). SLaps (I) and (2) applied to the same production in any order may introduce \nseveral semanLic rules ~: b(Xj):= f~('\" \" ) , \"i, b(X.#) := fg('' ' ) and ~._b(X~):=f~(... ) for the \nsame occurrence of attribute i_b of Xj. If this is the case, then replace them by the semantic rule \n\u00a2_b(x~) := lp(... )nl~(... ) C~ lh(\"\" ) (cf. Fig. 2.7). (a) If there are some exporting occurrences \nof domain attribute i_b without a semantic rule computing them, after all the above changes are made, \nthen associate i_b( ) := domain(b) with the productions containing these occurrences. This may happen \nif some exporting occurrences of an attribute were involved in the transformation, but others were not. \n 4. Examples Some productions from a grammar describing type cal- culation and type constraints for \nassignments, arith-metic and boolean expressions suffice to demonstrate most of the interesting cases \noccurring in inverse curry- ing transformations. Different occurrences of the same symbol in one production \nare numbered from left to right starting with I. 142 h~'b'IGNMKNT -* TARGET :-- ~OURCE condition: type(TARGET) \n= Lypt;(SOUI{C:E) Step (1), special case frorn P'ig. lAlintroduees i_ I.yl)c(SOU RCE) := ~I,ypc(TARGL, \nIT)I SOURCE RELATION Lypc(SOURCI~:) := bool SLep (2.3) (Fig. 2.61 introduces condition: bool (. i_Lype(SOURCE) \n SOURCE -* I~PR Lype(SOURCI,:) := Lype(EXPR) Step (2), special ease from I,'ig. 2.3, introduces i type(EXl'R) \n:= i_Lype(SOURCE)  IKI(PR ' E3L3Ji{ + I'I':i{M condition: Lype(EXPR,~) c lint,real I an(] type('ri,lRM) \n( [inL.rcall ahd Lype(I,;XPR,~) = type(TERM) type(EXPRi) := Lyp('(EXPRz) ~l.e l) (2), spcc:ial ease \nfrom Fig. 2.7. ird.r'oduc:es i tyl)c(l'lXPl~.~) := i_type(I,;XPl\u00a2l) i_.typc(TEI\u00a2M) := i._typt:(l,;Xl'l\u00a2l)r \nl~l.ypc(l, lXl'l\u00a2,z)lr'l~int,real I I\"I';RM * TERM-: FACTOR condition: t.ype('rERM,~) = int. and type(I\"ACTOR) \n= int Lype(TERMI) := int Steps (1) and (2), special cases from figures 1.2 and 2.6, introduce i_type('rERM2) \n:= [intl i type(FACTOR) := ~int] condition:intCi type(TERM I) FACTOR -\" id Lype(FACTOR) := type lookup(symbol(id)) \n Step (:~),speeial ease from Fig. 2.5, inLroduces condition: type lookup(symbol(id)) E i type(FACTOR) \n 5. Invariance of the language under the grammar transformation Let GI be an attribute grammar, Gz the \nattribuLe gram- mar resulting form the inverse currying transformation applied to Gp Since the transformation \ndoes not change  the syntactic part of productions, both GI and Ga have the same underlying context-free \ngrammar G. Let us define the language described by context-free grammar G, L(G), as the set of its syntax \ntrees. The language of attribute grammar G t , L(Gt), is then defined as the set of trees t E L(G), such \nthat all context-conditions of Gt are satisfied when decorating t according to Gt. Tile main result of \nthis section states that GI and G~ describe the same language, i.e. the inverse currying transforma-tion \nleaves the defined language invariant. This is the claim of Theorem 1. Theorem 2 states that the transfor- \nmation is compatible with a left-to-right evaluation stra-tegy. Theorem 1: L(Gt) = L (Gz), i.e. the inverse \ncurrying transformation leaves the defined language invariant. Theorem 2: If G l is L-attributed, then \nG~ is L-attributed. The Proofs can be found in [Wi183]. Tile following more general staternent could \nbe proved : Given a m'.mp/e multi-po.~sallribute grarnmar, i.e. attri- bute evaluution can be done in \na fixed number of left-to- right, or alternating passes, and Lhe instances of all occurrences of an atl.ribuLt: \nuf a symbol arc evalual ed in the same pass. If Lhc inv[,r'se currying transformation is applied Lo \nI.he attributes uf lcft-to-right, passcs, it will not change the cwdnation scheme for the gramrnar. One \ncould also define an analogous transformation for right- to-left cvahial,ion and apply it to right-to-left \npasses obtaining an analogous invarianee result 6. Practicality considerations There arc l.wo questions \ncon(:ernirlg the pracl.icaiity of thc transformation. The first question is. who actually performs the \ntransformation? Since the functions used in sernantic rules are user supplied (function) pro-cedures \nin some prograrnmir~g language, it is him who has I.o supply the inverse curried versions, too. But in \norder to estimate the amount of additional work thereby rc:luir'ud, one must t.akc into consideration, \nthat only the funcLions have I.o bc supplied and not the sernant.ic rules irl which I.hey occur. IIcla:e, \nthe identit.y function on stone al.l.ribld.e domain has Lo b(: inverted and not its many uccurrent;cs \nin the gra[lli'nar. The second quesl.ior~ concerns l.hc size growth of Lhe al.tril)utc grammar. Experience \nwith atLribute gram-[nars shows t.hal, very often a conLcxt condiLion \"con-stJm[:s\" arl all.tibet.e, \ni.e. ;~r, ;dtrihul.e w~lue is r'ornpuled somewhere in t.ht, trec and l.r'arlsfcrr'ed Lo Lhe insLance \nof Lhe produeLion only for the purpose of context checking. q'his attribute may become \"dead\", when Lhe \nconLext condition is removed from the grammar. In this case the attribute and the semantic rules computing \nand transferring it (:an be deleted from the grammar after Lhe Lransformation has been applLed.  Acknowledgements \n I would like to thank Phil Garrison, Robert Henry, Ulrich MSncke, Eduardo Pelegri, and Beatrix Weisgerber \nfor careful reading of previous versions of this paper and many helpful suggestions.  References [CICVS] \nR. S. Glanville and S. L. Graham, A New Method for Compiler Code Generation, PToc. 5th ACM 5~mp. Principtes \nof Programming Languages, Tuscon, Ariz., January, 1978. then83] R. R. Henry, Experience with Practical \nGraham-Glanville Codegenerators, Ph.D. Thesis, Computer Sciences Division, UC Berkeley, 1983. [JMJS0] \nN. D. Jones and M. Madsen, Attribute-Influenced I,R Parsing, in Semantics Directed Compiler Generation, \nN. D. Jones, led.), Springer LNCS, 1980, 393-407. [I,Rs74] P. M. Lewis, D. J. Rosenkrantz and R. E. Stearns, \nAttributed Translations, Journal of Computer and System Sciences 9, (1974), 279-307. [SehB2] C. Schmaueh, \nAttribute Evaluation after Recovery .from Syntax Error, Fachbereich Informatik, Universitfit Kaiserslautern, \n1982. [waJa0] D. Watt, Rule Splitting and Attribute-Directed Parsing, in Semantics Directed Compiler \nC~nermtion, N. D. Jones, led.). Springer Verlag, 1980. [Wi179] R. Wilhelm, Attributierte Grammatiken. \nlnformatik Spektrum, 1979. [Wi183] R. Wilhelm, Inverse Ou~'rying Tr,nsforr~a~ion on Attribute Grammars, \nEECS Department, UC Berkeley, 1983. X X D ~T   vO t~,O a i.~a a condition: p(a(Y)) condition: p (a \n(X0),b (Xl),b (X~)) Fig. 1.1 Fig. 1 An attributed production A condition only depending on the syntactic \ncontext X X / ,# \", p \" / / p fT ,, \"',, f~ / YO zv] b i_a a l_b b condition: p(afY).b(Z)) Fig. 1.2 \nAnother condition only depending on the myntactic context X X B ~ ff I I  p f 2 ~\" ~B [] a \"z [] b \na i_b [] b condition: p(a(Y),b(Z)) Fig. 1.3 Introducing left-to-right information flow C[]x C 7 o \n ~D zV] [] b a i_b b condition: \" p(c(X),a(Y),b(Z))  Fig. 1.4 Left-to-right and top down information \nflow X X ,t, ,\" t \",, i ,, I p ~ , I t \" \"\" f 3 ,, \"\" b ~, ,* t i t Y [] tl'-I \"z [] [] a e b \na c i_b b condition: p(a(Y),c(t),b(Z)) condltion: c(t) (f~(a(Y)) Fig. 1.5 Testing an attribute of a \nterminal symbol i_b a b i_b a b t i I i I i i i condition: a(X) E f~(i_b (X)) Fig. 2. I |ntroducing \na Membership test ( here equivalent to g(a(X)) c i b(X)) i_b i_b b D~[J 8 [3 condition: a (t) e $ ~ (i \nb (2\")) Fig. 2.2 lntroducirtg a membership test for a terminal attribute i_b b i-b b D~E id Y Y a i_a \na Fig. 2.3 The (common) case of identity transfer i--C C i--c C 2:25. a b a l_b b condition: p(a(Y).b(Z)) \nFig. ~.4 Left-to-right and top down information flow i--~l 8 i_a a g g Jl\"-, / T\",, condition: g( ... \n) E: i._a(X) Fig. 2.5 No inverse curried function 146 Dx a i_a ai_a a(c) s(c) condition: g(c) Ci a(X) \nl~g. 2.8 Rule depending only on a constant i_d d i_d d g , \", ,,V1 L \", fl c b a c i_b b condition: p(c(W).b(Z)) \nFig. 2.7 Combined effect of a \"global\" condition (its domain in i_d) and a \"local\" condition ( p ) 147 \n  \n\t\t\t", "proc_id": "800017", "abstract": "<p>Inverse currying transformation of an attribute grammar moves a context condition to places in the grammar where the violation of the condition can be detected as soon as the semantic information used in the condition is computed. It thereby takes into account the evaluation order chosen for the attribute grammar. Inverse currying transformations can be used to enhance context sensitive parsing using predicates on attributes, to eliminate sources of backtrack when parsing according to ambiguous grammars, and to facilitate semantics-supported error correction.</p>", "authors": [{"name": "Reinhard Wilhelm", "author_profile_id": "81100325916", "affiliation": "Department of Electrical Engineering and Computer Science, University of California, Berkeley, Berkeley, CA", "person_id": "PP39037801", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800017.800525", "year": "1984", "article_id": "800525", "conference": "POPL", "title": "Inverse currying transformation on attribute grammars", "url": "http://dl.acm.org/citation.cfm?id=800525"}