{"article_publication_date": "01-15-1984", "fulltext": "\n Treat --An Applicative Code Generator Jerald S. Schwarz Dean Rubine Bell Laboratories Murray Hill, \nNew Jersey 07974 ABS TRA CT Treat is a special purpose language for use in compiler writing. A Treat \nprogram translates a graph into c-trees (the intermediate language of the pcc compiler) and uses the \nback end of the C compiler to generate code. Treat has been developed specifically for use in an AdaTM \ncompiler. A Treat program consists of applicative transformation rules. Treat's distinctive aspects include \ntriggering transformations during pattern matching, a context mechanism for dynamic binding and assignment \nin a language with lazy evaluation. 1. The Story So Far In the fall of 1982 we were preparing to write \na program to generate code for an Adal[5] compiler 2 being developed by our group[13]. We already had \na program to do this but we wanted one that would be faster and generate better code. We considered writing \nth.is improved program in C (the language in which the earlier version was written), but decided it would \nbe more worthwhile to investigate a special purpose language. Designing Treat, implementing the Treat \ninterpreter, and writing the Treat program to compile Ada code (refered to in this paper as Ada.t) have \nproceeded concurrently. Each activity has benefited from the others. The overall structure of Treat was \ndetermined by our intuitions of what such a special purpose language should be like. The details are \nlargely the result of the needs of Ada.t tempered by what we hope is good taste. 1.I Compiler Structure \nA compiler translates a program in some higher level language into machine code. Most compilers are divided \ninto a front end and a back end, with the output of the front end being instructions in the machine language \nof some abstract machine. Some recent compilers I. Ada is a registered trademark of the U.S. Government \nAda Joint Programming Office 2. We refer to the compiler discussed in this paper as an Ada compiler only \nas a general description. It is not a conforming Ada compiler. Permission to copy without fee all or \npart of this material is granted provided that the copies are not made or distributed for direct commercial \nadvantage, the ACM copyright notice and the title of the publication and its date appear, and notice \nis given that copying is by permission of the Association for Computing Machinery. To copy otherwise, \nor to republish, requires a fee and/or specific permission. &#38;#169; 1983 ACM 0-89791-125-3/84/001/0133 \n$00.75 (including the our group's Ada compiler) also contain a so-called middle end that translates (or \nas we say transduces) a graph representation of the program into intermediate code. Treat is intended \nfor writing these middle ends. A Diana[2] representation of an Ada program is a labeled graph. Graph \nnodes have a kind and arcs have labels. If an arc labeled x leads from a node N to a node M we say that \nM is the value of the x attribute of N. Nodes may also have attributes with numbers or strings as values. \nAlthough throughout this paper we talk about Diana graphs and Diana nodes, Treat is intended to be usable \nwith any graph representation based on IDL[8] A Treat program translates a Diana graph into a sequence \nof trees (we call them c-trees) in the intermediate language of a recent version of Johnson's portable \nC compiler[6]. Leaves of these tree are constants, global variables or stack references. Inner nodes \ncorrespond to C operators. The c-trees can be printed or passed to the pcc code generator, a table driven \nback end that generates assembler from c-trees. 1.2 Programming Languages The most direct influences \non Treat have been equational applicative languages such as Hope[ 11, KRC[ 11 ] or Hoffman and O'Donnell's \nequation language[4]. To this base we have added operators and syntax for the special needs of compiling. \nTreat uses lazy evaluation[3], which means that reductions (substitutions of right hand 133 sides for \nleft hand sides) take place only when a need for an explicit (or solid) value is felt. Until then a value \ncan be represented by a suspension, a data structure containing an expression to be evaluated and an \nenvironment (binding of variables) in which to do that evaluation. In Treat, most needs for solid values \nare generated because the back end requires explicit c-trees. 'So, before the Treat interpreter can pass \na value to the back end it must convert any suspensions to c-trees by evaluating the expressions contained \nin them. This in turn will lead to propagation of the need for solid values to subexpressions. Other \ninfluences on Treat have been Schwarz's studies of evaluation strategies[10], and work in artifical intelligence \non production systems such as [12] 2. The Solution The central activity of a Treat program is the transduction \nof a bit of Diana graph into a c- tree. Two kinds of operations: examining the graph and constructing \nc-trees, are important enough for Treat to have special syntax to describe them. The first is embodied \nin patterns, the second in skeletons. These are combined in units of a Treat program called rules. (Other \nunits are variable and function declarations.) To initiate code generation the transducer Is invoked \nat the root of the Diana graph. It searches for an applicable rule and, when it finds, one, applies the \nrule and returns the result. The result can use values obtained by recursive invocations of the transducer \nat other nodes. When the transducer is invoked it is given a context containing bindings for context \nvariables. The node to be matched is one such variable. Others are under the control of the Treat programmer. \nWe originally intended that Treat expressions would be free of side effects (purely applicative). We \nlater added an impure feature (assignment) to solve certain coding problems in Ada.t. As far as we know, \nTreat is the first language to have an assignment and lazy evaluation. 2.1 Rules Each rule can be thought \nof as specifying the solution of a small problem. The problem is delimited by a condition part, which \ncan do the following: a. test the goal of the current transduction; b. test the nshape\" of the graph \nto any depth; c. do certain relational tests on attributes of nodes; d. an arbitrary computation to \ncompute dynamic attributes on nodes. (Dynamic attributes are defined by Treat rather than being explicitly \npresent in the graph.)  By using an appropriate set of context variables and defining an appropriate \ncollection of dynamic attributes the Treat program can extract from the graph whatever information is \nrequired to determine the applicability of a rule. The result part of a rule is an expression that evaluates \nto a c-tree or other Treat data structure (such as a list). The primary way to construct c-trees is with \nskeletons, which are a bit of C with backquoted Treat variables. For example, {/'x+'y+2/} is a skeleton \nthat is evaluated by combining the (presumably c-tree) values of the Treat variables x and y into a new \nc-tree that represents an expression to add them together and add their sum to 2. Skeletons are especially \nconvenient when dealing with such C features as structure (record) selection, and casts (type conversions). \n 2.2 Context The applicability of a rule is tested not only against a particular node, but against the \nvalues of a collection of context variables. Context variables can be characterized by their purpose. \nThey may describe a location in the graph, or they may specify details of the desired result of transduction. \nIn particular the context variable, cookie, which takes on values from a programmer defined enumeration, \ndetermines what kind of result a rule is supposed to produce and what will be done with the result. 134 \nAnother characterization of context variables is that some are used primarily to determine applicability \nof rules and some are used in the construction of results, although many context variables are used for \nboth these purposes. A new context is created for each recursive invocation of the transducer, but because \nmost context variables do not change fre, quently, recursive invocations inherit the context of the invoker \n.except for explicit changes. In effect Treat has dynamic binding of context variables. Although in recent \nyears dynamic binding has acquired a bad reputation, its use in Treat is well controlled, in particular \ncontext variables must be declared and must be distinct from other variables. 2.3 Assignment The most \nunusual feature of Treat is the presence of assignment expressions in a language with lazy evaluation. \nThe assignment expression has both a value and a side effect. Assignments are allowed only to programmer \ndesignated state variables. State variables can be used wherever context variables can, except that they \ncannot be modified for recursive invocations of the transducer. While a Treat programs creates many contexts, \nwhich once created cannot be changed, it creates only one state which can be modified by assignment expressions. \nUnder lazy evaluation the side effect of an assignment exprssion takes place not when the expression \nis incorporated into a data structure, but when a need for the explicit value of the expression is felt. \nIn effect, assignments are executed in an order determined by their position in a Treat data structure \nnot by the order in which they are incorporated in it. When state variables are used in expressions their \nvalue is determined only when it is needed and they then have the value given them in the most recent \nassignment. State variables were introduced specifically to deal with problems relating to use of use \nof temporary locations in the code generated by Ada.t. We have since found other uses for them. In general \nthey have been useful when it is desired to keep track of the state of some execution time. 3. The Nitty \nGritty Figure I contains a slightly edited rule, named GenArrayName taken from Ada.t whose purpose is \nto generate the addressing calculation for array references. We explain this rule in detail with the \nhope that such an explanation will present the general flavor Treat rules. 3.1 Condition Part The part \nof the rule between \"GenArrayName\" and \"result\" is the condition part, which limits the rules applicability \nto contexts in which cookie's value is Name Triple, and node's value satisfies certain further conditions. \nTo Treat NameTriple is just a constant. It's meaning for Ada.t is discussed below. The further conditions \non node's value is expressed with a pattern introduced by the match operator (::). This restricts the \nkind to be Indexed and, via the clauses between square brackets, places further conditions on the node's \nattributes. In this case the match operations require the following 1. node's be an Indexed Diana node. \nThis is the kind of Diana nodes that represent subscripted array references in the Ada source program. \n 2. node.name (the name attribute of node) must exist and its kind must be either Used Name ld or Funct \nCall. This attribute points to the Diana node that represents an array valued expression. (The real rule \npermits other cases that are omitted here.)  . node.name.exp_kind must exist and its kind must be Array. \nIn a Diana graph it is always possible to go from a node representing an expression to the node representing \nthe declaration of the type of the expression, although the attributes to do this vary with the expression. \nHowever exp_kind is not a true Diana attribute) Rather it is a dynamic attribute defined by Treat rules \nthat 3. This use of \"kind\" in Ada.t has nothing to do with the notion \"kind of a Diana node'. 135  rule \nGenArrayName cookie --NameTriple node :: Indexed [ name :: Used_Name Id I Funct_Call [ exp_kind :: Array \n[ dim > 1 ] ] [ J v \"-- Value exp_list I [ indexes---Value ] result let arr --NEWTEMP0 in let at -NEWTEMP0 \nin let tp -NEWTEMP0 in { { {/'art -(WORD *)'v/} ; let comp -indexComp( {/'art/}, indexes) in {/'at \n-'comp/} ; {/'tp -(((P_ARR_TYPE)*'arr)-> arrelemtype).pWord/} ; }, at ; tp ; I  end ; Figure 1. Illustrative \nTreat Rule for Subscripting select the correct path from node.name, a pointer to the data values that \nmake up and continue to traverse the graph the array. through type declarations until it can go no further. \n. indexes will be bound to a list of c-trees to evaluate the subscripts. The syntax 4. node.name.exp_kind.dim \nmust exist (as for binding v and indexes is the same, it always will if earlier conditions are but because \nnode.expJist is a list the met) and be an integer greater than I. latter gets bound to a list of results \nof In other words, GenArrayName applies transducer invocations. This is the only to arrays with more \nthan one simplest case of list extension. Match subscript. operations are also implicitly extended, 5. \nnode.exp_list (the list of representing the subscripting must exist (it always will). nodes values) as \nare the binding operations nested within them. For example if the line that begins expJist in GenArrayName \nwas replaced by Within the pattern, binding ([ J) operators can occur wherever matching operators can. \nA simple binding of the form \"[ J x\" would bind the Treat variable x to a Diana node. The more complicated \noperators in GenArrayName exp_.list :: Numeric_Literal [static_value J J indexes I bind variables to \nresults of recursive invocations of the transducer. In particular: the rule would apply only if all members \n1. v is bound to the result of transducing node.name with cookie Value. This will be a c-tree to evaluate \nthe expression. The value of an Ada array expression is of exp_list were nodes of kind Numeric_Literal, \nand indexes would be bound to a list static value attributes of these nodes. 136 Although the binding \noperations appear throughout the condition part of the rule, the implied recursive invocations of the \ntransducer do not take place during the pattern matching. Rather the Treat variables are bound to suspensions \nthat, when later coerced, will result in recursive invocations.   3.2 Cookie NameTriple The code generated \nby Ada.t manipulates Ada values and Ada type decscriptors. The latter are data structures representing \nthe kind of the value (e.g. that it is an array of integers with particular bounds). Ada.t's rules assume \nthat for any Ada \"name\" (i.e. expression that might appear on the left hand side of an assignment) the \nruntime can find or construct the address of the value and a type descriptor. Sometimes rules require \njust the address of the value, sometimes they require both the address and the type descriptor. Since \nthere can be Ada runtime side effects involved in both these computations (e.g. in evaluating subscripts) \ncare must be taken that when both address and type descriptor are required, runtime expressions with \nside effects are evaluated exactly once. To deal with this, Ada.t uses lists of three c-trees that do \nthe following: 1. An arbitrary computation that may have side effects. 2. A computation without side \neffects that, if executed after 1, will yield the address of the value. 3. A computation without side \neffects that, if executed after 1, will yield a pointer to the type descriptor.  Rules for the cookie \nNameTriple return this list for the Ada expression represented by the Diana node at which they are invoked. \n 3.3 Result Part The result part of GenArrayName, contained between \"result\" and \"end', is a Treat expression \nwhose value is a three element list as described above. Structurally it consists of several nested in \nexpressions of the form let variable -rhs in body To evaluate this rhs is evaluated (actually a suspension \nis created) and the value is substituted for variable in body. In GenArrayName the initial lets bind \neach of arr, at and tp to the results of calling the Treat function NEWTEMP. The innermost body consists \nof a list expression (semi-colon terminated expressions surrounded by curly braces) that evaluates to \nthe three components of a Name Triple. The result part contains several C-skeletons, which are the most \nconvenient construct in c for creating c-trees. These are C expressions surrounded by \"{/\" and \"/}\" with \nthe extension that backquoted Treat variables (a variable name prefixed by \"'\") can appear. When the \nC-skeleton is evaluated the values of the Treat variables, which must be c-trees, are substituted. Besides \nthe Treat program proper, the Treat interpreter reads a header file containing C declarations. Names \ndeclared in that file (e.g. the C typedef PARR_TYPE) can be used in skeletons. The definition of NEWTEMP \n(slightly different from the real one) is shown in figure 2. NEWTEMP is a function without arguments. \nIt returns the result of an assignment expression that increments the state variable nextTemp and has \na value given by a c-tree constructor (the bit of Treat contained between \"</\" and \"/>'). The effect \nof this is to allocate a temporary location on the runtime stack and return a c-tree that references \nit. Because of lazy evaluation each of the variables art, at and tp is initially bound to a suspension. \nWhen (if) the value is needed for code generation the call to NEWTEMP and the assignment expression will \nbe evaluated and will replace the suspension. Thus all occurances of each variable will be replaced by \nthe same c-tree. 4. The Experience In spring 1983 we had a Treat interpreter written in C and a moderately \ncomplete Treat program to compile Ada code. This Treat program has 213 rules and 51 functions, written \nin around 3100 lines. By comparison the original C program that does essentially the same job is about \n5800 lines and produces code that is about twice the size of that produced by the Treat version. If we \nignore the (long) time it takes the interpreter to read and parse the C version is about 3 times faster \nthan the Treat interpreter. One small 137 function NEWTEMP0 result [/nextTemp :-nextTemp+l ,, </AUTO, \nnextTemp-1 /> /] end ; Figure 2. Definition of NEWTEMP compilation of 44 lines of Ada code took 82 cpu \nseconds to do 896 rule applications on a Vax/780. 4.1 The Implementation The current Treat interpreter \nis written in C in a straight forward fashion. A YACC[7] parser constructs a syntax tree for the Treat \nprogram and the interpreter works directly from that tree. Context and local variables are kept on a \nsingle a-list. (An a-list consists of a list alternating variables and their values with more recent \nbindings toward the front of the list.) To evaluate a skeleton the Treat interpreter calls the normal \npcc parser with a modified lexical scanner to deal with backquoted variables. The most significant performance \ntechnique is used in the search for an applicable rule. The interpreter constructs a hash table of lists \nof rules indexed by a Diana node kind and possible cookie values. 4.2 The Problems Although we are pleased \nwith Treat we are not blind to certain faults. One goal in the design of Treat was to use rules as a \nmodularization technique. This has largely been successful, but there is an interaction that has been \nannoyingly pervasive. Changes to the Ada runtime structures have frequently required massive editing \nof many rules. Treats biggest handicap is that it requires a preliminary semantic analysis pass to build \nthe Diana graph, do name resolution, assign addresses, and the like. Some of these computations might \nbe done by the Treat program if Treat contained a way to modify the Diana graph. Some progress towards \nautomating name resolution has been made by Reiss[9]. A related problem is that there is no way in Treat \nto determine the result of invoking the transducer on a slightly modified Diana graph. Such an operation \nwould frequently be useful. 5. Conclusion and Plans Our original goal was to design and implement a language \nthat would be useful in compiler writing, especially in constructing compilers for large and complicated \nlanguages. While Treat is not yet a practical tool for such a task it is a step in that direction. We \nare currently engaged in a major rewrite of the interpreter that will split it into two phases. The first \n(compiling) phase will generate code in an intermediate language for a virtual Treat machine. The second \n(engine) phase will interpret that code. Ultimately we would like to have the compiling phase written \nin Treat itself, Thereby eliminating the engine phase and directly generating machine code. 138 References \n 1. R.M. Burstail and D. MacQueen, Hope: An Experimental Applicative Language, 1980 LISP Conference, \nStanford CA, August 1980. 2. G. Goos and W. A. Wulf, Draft Revised Diana Reference Manual, Rev. 2.1, \nTartan Laboratories, Inc., October 1982. 3. P. Henderson and J. M. Morris, A Lazy Evaluator, ACM Symp. \non Prin. of Programming Languages 3, Atlanta GA, 1976. 4. C.M. Hoffman and M. J. O'Donnell, Programming \nwith Equations, ACM Trans. on Programing Languages and Systems 4, 1 (Jan 1982), 83-112. 5. J.D. Ichbiah \net al, Reference Manual for the Ada Programming Language, United States Department of Defense, Washington \nDC, January 1983. ANSI/MIL-STD-1815 A.  6. S.C. Johnson, A Portable Compiler: Theory and Practice, \nProc. 5th ACM Symp. on Principles of Programming Languages, January 1978, 97-104. 7. S.C. Johnson, Yacc: \nYet Another Compiler-Compiler, Computing Science Technical Report No. 32, Bell Laboratories, Murray Hill, \nN J, 1978. 8. J.R. Nestor, W. A. Wulf and D. A. Lamb, IDL--Interface Description Language Formal Description, \nRev. 2.0, Tartan Laboratories, Inc., June 1982. 9. S.P. Reiss, Generation of Compiler Symbol Processing \nMechanisms from Specifications, ACM Trans. on Programing Languages and Systems 5, 2 (Apr 1983), 127-163. \n 10. J.S. Schwarz, Making Recursion Equations Behave, IEEE Trans. on Software Engineering SE-8, 1 (Jan \n1982),. 11. D.A. Turner, Recursion Equations as a Programming Language, in Functional Programming and \nits Applications, J. Darlington, P. Henderson and D. A. Turner (ed.), Cambridge University Press, Cambridge, \n1982, 1-28. 12. D.A. Waterman and F. Hayes-Roth, editor, Pattern-Directed Inference Systems, Academic \nPress, 1978. 13. C.S. Wetherell, The Ada BreadBoard Compiler: An Overview, Internal memorandum, Bell \nLaboratories, 1982.  139 \n\t\t\t", "proc_id": "800017", "abstract": "<p>Treat is a special purpose language for use in compiler writing. A Treat program translates a graph into c-trees (the intermediate language of the pcc compiler) and uses the back end of the C compiler to generate code. Treat has been developed specifically for use in an Ada<supscrpt>TM</supscrpt> compiler. A Treat program consists of applicative transformation rules. Treat's distinctive aspects include triggering transformations during pattern matching, a context mechanism for dynamic binding and assignment in a language with lazy evaluation.</p>", "authors": [{"name": "Jerald S. Schwarz", "author_profile_id": "81332526378", "affiliation": "Bell Laboratories, Murray Hill, New Jersey", "person_id": "PP31095740", "email_address": "", "orcid_id": ""}, {"name": "Dean Rubine", "author_profile_id": "81100497451", "affiliation": "Bell Laboratories, Murray Hill, New Jersey", "person_id": "PP31044887", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800017.800524", "year": "1984", "article_id": "800524", "conference": "POPL", "title": "Treat - an applicative code generator", "url": "http://dl.acm.org/citation.cfm?id=800524"}