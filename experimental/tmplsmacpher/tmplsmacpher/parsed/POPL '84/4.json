{"article_publication_date": "01-15-1984", "fulltext": "\n GENERALIZED FAIR TERMINATION Nissim Francez Computer Science Department Technion-lsrael Institute of \nTechnology Haifa 32000, Israel ABSTRACT: We present a generalization of the known fairness and equifairness \nnotions, called ~-fairness, in three versions: unconditional, weak and strong. For each such version, \nwe introduce a proof rule for the ,~'-fair termination induced by it, using well-foundedness and countable \nordinals. Each such rule is proved to be sound and semantically complete. We suggest directions for further \nresearch. 1, Introduction A distinctive feature of modern programming languages is the inclusion of language \nconstructs for the expression of nondeterminism and concurrency. An important aspect of the semantic \ndefinition of such constructs is that of fairness. Re-cently, several papers have dealt with the question \nof the use of direct well-foundedness arguments in proofs of program termination under fairness assumptions, \ncalled also fair termination ([AO 82], lAPS 82], [GFMR 81], [LPS 81]). As it turns out, similar proof \nmethods apply to both the standard notions of unconditional, weak and strong fairness (in [LPS 81] they \nare called impartiality, justice and fairness), as well as some strengthening of these notions, namely \nequifairness [GF 82], [GFK 83]. Furthermore, the proofs of semantic completeness of the rules for equifair \ntermination share a similarity in structure with the corresponding completeness proofs for fair termination. \nA comprehensive survey of this line of research is [F]. In this paper we propose a definition of a unifying \ncon- cept, called generalized fairness, of which all the above concepts Permission to copy without fee \nall or part of this material is granted provided that the copies arc not made or distributed for direct \ncommercial advantage, the ACM copyright notice and the title of the publication and its date appear, \nand notice is given that copying is by permission of the Association for Computing Machinery. To copy \notherwise, or to republish, rcquircs a fee and/or specific permission. &#38;#169; 1983 ACM 0-89791-125-3/84/001/0046 \n$00.75 Dexter Kozen Dept. of Computer Science Mathematical Sciences Department IBM T. J. Watson Research \nCenter Yorktown Heights, N. Y. 10598 are special cases, Furthermore, we present a sound and seman-tically \ncomplete proof rule for termination of guarded command (GC) programs under the assumption of a guard \nscheduling policy adhering to generalized fairness. The semantic complete- ness proof exploits the general \nstructure of the completeness proofs of all the special cases mentioned above. Thus, we provide a machinery \nfor future definitions of other scheduling policies that abstract properties of implementa- tions or \nof probabilistic assumptions and the study of the termi- nation properties they induce. One recent notion, \nthat of extreme fairness [P 83], tran- scends the framework proposed here in case the extreme fairness \nis with respect to an infinite set F of relativizing conditions. The study of fairness can also be carried \nout in temporal logic, which hides the well-foundedness by means of its temporal operators, the <> (eventually) \nand ~{V (until). Recently, a special temporal logic was designed to deal conveniently with fairness [QS \n82]. The generalized fairness studied in this paper remains within this framework of eventualities. Other \nfairness notions have also been considered, e.g. bounded fairness, for which there exist apriory bounds \non the number of steps until the next occurrence of an event, or \"economic\" fairness, which guaran- tees \nsome analytic properties of the integral of the event occur- rence function. One example to an \"economical\" \nfairness is [FW 82]. We shall not treat this kind of fairness in this paper. 46 2. Generalized fairness \nfor GC As the programming language for expressing nondeter- minism we use the language of guarded commands \n(GC) [DIJ 75, DIJ 761, in terms of which many of the previous studies of fair termination were carried \nout. 9._c ~ n~.\" <statement> ::= <assignment>[ skip <selection> [ <repetition> [ <composition> <composition> \n::= <statement>; <statement> <assignment> ::= <variable> := <expression> <selection> ::-- [ < Boolean-expression> \n.~ <statement > {Q <Boolean-expression>-,. <statement> ]*] <repetition> ::= *<selection> The semantics \nwe need associates with each GC program S and initial state//0 a tree Ts(,~0), the tree of all possible \ncom- putations of S, starting at ~0. This tree is defined recursively. Whenever more than one guard is \nenabled in a state, it has a subtree for every such guard. An important property of compu- tation trees \nis that they are finitely branching (actually, bounded- ly branching). Thus, by Kt~nig's lemma, a tree \nis infinite iff it contains an infinite path, representing a non-terminating compu- tation. See [F] for \na more detailed discussion of these trees. Definition: A (generalized) fairness condition ~ is a finite, \nnonempty set of pairs of (possibly augmented) state properties, --t(q~j, ~j) I 1 _< j < M}. [] Let \n~ be fixed. Definition: For a (typical) iterative statement SeGC and an infinite computation sequence \n~r of S: weakly and strongly ,~'-fair. It might be helpful to state the negation of the various .~'-fairness \ni. n is unconditionalO, ~-fair iff for each j, I < j _< M, ~j occurs infinitely often along n. it. n \nis weakly g-fair iff for each j, I _< j _< M: if ~i holds continuously (i.e. almost everywhere) along \nn, then ~j occurs infinitely often along n. iii. n is strongly ~-fair iff for each j, 1 _< j < M: if \n\u00a2p) occurs infinitely often along \u00a2, so does ~j. A finite sequence n is always unconditionally, conditions: \nAn infinite computation sequence ~ is uncondi-tionally A-unfair iff there exists a j, 1 < j < M, such \nthat ~j occurs finitely often only along ~. As a result, ~ contains an infinite tail along which ~j does \nnot occur at all. We refer to such a ~ as ej-unfair, and to the infinite tail as ~ j-avoiding. it. Similarly, \n~r as above is weakly R-unfair iff there exists a j, i _< j _< M, such that cpj holds contin- uously \nalong 9, but g,j holds finitely often only. iii. Finally, ~ as above is strongly C-unfair iff there cxistsa \nj, I < j <_ M, such that \u00a2Pih\u00b0ldsinfi\" nitcly often along ~ while ~J holds finitely often only. [] in \norder to see that ,f-fairness generalizes the notions of fairness mentioned above, we consider the following: \na. Augment each state of (typical) iterative statement S with a two state flag fl, for each direction \ntel. Augment each direction subprogram with a setting of fi and a resetting of fJ' j d= i. Then define: \n~i ~ Bi, the guard of the i'th direction, ~i ~ (fi is set) , id. By this definition, ,~'-fairness, in \nall three levels, coincides with the three levels of usual fairness. b. By taking M = 2 I~l -I, and augmenting \nthe state of S with counters ci A for every ~ # A c ! such that tel (enumerated in some fixed way); incrementing \nall c~ whenever direction i is taken and A B i holds, and tak- idA ing %=A Bk,J=l ..... M kcAj and ~k \ni (c~-c ^ =cA ),forAffili I ..... ilAi} , = --i2 = ... IiA I ,@'-fairness coincides with equifairness. \n By considering different augmentations of the proper state and appropriate ,~\"s. a variety of generalized \nfairness con- ditions are definable. Definition: A (typical) iterative statement SeGC is: i. Unconditionally \n~-fairly terminating (abbreviated ,~'-UFT), iff all its unconditionally ~'-fair sequences are finite. \nii. Weakly ~-fairly terminating (,~-WFT), iff all its weakly ,~-fair sequences are finite. iii. Strongly \n~-fairly terminating (,~'-SFT), iff all its strongly ,~'-fair sequences are finite. [] We shall use <<p>> \nS <<q>> as a generic notation u for generalized fair termination, and <<p>> S w s <<q>> , <<p>> S <<q>> \nand <<p>> S <<q>> for the more distinctive termination assertions. Lemma: ~= <<p>> S <<q>> ~ ~= <<p>> \n <<true>> ^{p} S {q}.  This is obvious from the definition, since the fairness assumptions cannot affect \npost-conditions, only termination. Thus, we focus our attention on fair termination claims only. 3. Proof \nrules for g-fair termination Let ~ be given, and let S:: *[[\"1 :: B i --.. Si] be a typical i\u00a21 GC iterative \nstatement. u To prove <p>> S<<true>> : g Find a well-founded, partially-ordered set (W, <), a parametrized \ninvariant pi: Y..sxW -,. {true,false}, a partition of {1.....M} into 4, ~ DwUS w, for each non-minimal \nw~W, satisfying: !. (INIT) p = t w: pi(w) 2. (CONT) pi(w) ~ V B i , weW not minimal 3. (TERM) pi(w) \n~ ~ V B i , w~W minimal  i\u00a21 4. (DEC) u  <<pi(w)^Bi>> Si << V ~'i = 3v:v<w^pi(v)>>, ~\" jeD w w~W not \nminimal, icl, 5. (NOINC) u <<pi(w)^Bi>> S i<<3v:v_<w^pi(v)>> ,id. gr Rule ,@'-UFT (Unconditionally g-Fair \nTermination)  Explanations: I. Note that the state argument of the invariant has been systematically \nsuppressed and left implicit, as usual in this context. 2. The intention behind the rule is the following: \nThe components of .~\" are partitioned at each intermediate stage into helpful ones (Dw), which cause \ndecrease in the parameter of pi, and the rest (Sw), which do not cause increase. Whenever a helpful g,j \n, jcD w. occurs, clause (DEC) shows the decrease. Since along uncondi- tionally '-fair infinite computations \nevery g'J occurs infinitely often, some g,j for j~D w will eventually occur, causing decrease in the \nparameter of pi, and by well- foundedness of (W, <) prevent diverging. u Theorem: (soundness of ,9\"-UFT): \nFor a (typical) iterative statement S~GC: tl if I--'-<<p>> S <<true>>, then ,~'- U FT ~t\" u I== <<p>> \nS <<true>>. Proof: Suppose an infinite computation sequence ~ of S exists, with an initial state ~0 \nsatisfying p. ,r = ~o \"\" ~t -~ 62 .... ~k ..... By clauses INIT, CONT, TERM and NOINC, there exists \nan infinite sequence of elements of W, say <Wk>, k = 0,1 ..... such that: a. w k > Wk+ I , k == 0,I .... \n b. pi ('~k' Wk) , k = 0,I .....  By the well-foundedness of (W, <_), there exists some k o _> 0, such \nthat Wk0 = Wk0+l = Wk0+2 = .... By the eontrapositive of DEC, there is a jeD w ~ {1 ..... M}, such that \n~k [= \"~'j for all k _> k 0. Hence, ~r is unconditionally ~kj- unfair. Thus, S has no infinite uncondi- \ntionally ,~'-fair computations, and hence u I= <<p>> S <<true>> holds, proving soundness of ~-UFT. [] \nWe now come to our main theorem. Theorem: (semantic completeness of ~'-UFT): For a (typical) iterative \nstatement S\u00a3GC: tl if I,= <<p>> S<<true>>, then ar s <<p>> S <<true>>. ~-OFT ~\" By semantic completeness \nwe mean that we have to show the existence of pi as a set of pairs (~, w), independent of syntactic expressibility \nin any given assertion language, and similarly for the partitions (S w, Dw). Proof: Assumel= <<p>> S \n<<true>> holds, and consider any computation tree of S, T.,.;(,~0), such that '~n l= P. We may assume \nthat \"l's(~ n) has at least one infinite path, hence is un- conditionally ,~-unfair0 otherwise there \nis nothing to prove. The general idea is to contract every such tree to another one, T*s(,~jn), which \nhas finite paths only (though it is not necessarily finitely branching), rank \"l'*s(/j 0) with countable \nordinals, and use this ranking to define the invariant and partitions. Definition: For a state occurrence \n~JeTs(,~ 0) and 1 <j<M, let ,ar.CONEffi(~j ) dl_' 17/I ~ is a state-occurrence on an infinite ffj-avoiding \npath originating at/~}. The state-occurrence ~ is the root of the cone, and ffj is its directive. [] \nSuch a cone will be contracted to a single node in T*s(~o). Lemma (cone exit): If an infinite path Ir \nleavcs ,~'-CONE?i(,~) , it contains a state-occurrence ~ s.t. ~ l= ffi holds. Proof: Immediate from the \ndefinition. [] We now proceed with an inductive definition of a hier- archy of families of nodes, either \nsingletons or cones. Induction basis: We distinguish between two subcases: a. There is an infinite ~ki-avoiding \npath originating at '~o, for some I <j~M. In this case, let A o = ,~'-CONE,ki(,~'n). b. Otherwise, let \nAt) = {~o} \" Induction step: Suppose Ai_ I was defined at level i-I. We again distinguish between subcascs. \na. Ai_ I = ,~'-CONE,t.j,_, (,~i_l). a.I. Suppose there exists an infinite path \u00a2r leaving Ai-I\" By the \ncone exit lemma, it contains an occurrence of tkh_ ] . Let ~'i be the nearest such state-occurrence. \nal.I. If there is an ~j-avoiding infinite sequence originating in ~i. let A i = ,9\"-CONEcj (~i), where \nthe directive 6j~ is taken to be that ~J appearing least recently along ~n \"\" ~l \"4\" --. ~i - In case \nof a tie, choose the ~j with the small- est index j. a.l.2. Otherwise, let A i = {~i+l} a.2. If no infinite \npath leaves Ai_t, it has no dcscen- dants.  b. Ai_ I = {~i_l} . In this case, treat ~i-t as ~o in the \ninduction basis. Clearly, the family of these Ai's covers all the nodes of  TS(,~o). Lemma: (cone chain) \n There does not exist an infinite chain of descendant < Ai>~= 0 , Proof: Suppose such a sequence st did \nexist. Then <~i>:=0 , the sequence of the corresponding roots, would lie on an infinite computation sequence \nof S, which must be unconditionally ,9\"-unfair by assumption. Let it be ~j,-unfair, for some ! _<j*<_M \n. Therefore, st would have a tail ~r*, which would be ~j.-avoiding. Hence, in the hierarchical construction, \nthere would be some level, say i0, where j* is the index of directives that appeared least recently up \nto point i0, and then *r* would remain in ,~=CONE\u00a2io(~io) , contradicting the assumption of an infinite \nchain of cones. I\"I Construction of T*s(~0): Nodes: All the Ai's in the inductive construction. Arcs: \nAll the original arcs of Ts(~o ) either entering or leaving Ai's. Lemma: T*s(~o ) is well-founded (contains \nno infinite paths paths). Proof: By the cone chain lemma. I\"I As defined, T's((0) depends on ((). For \nour needs, we may combine all these trees into another one T*s, with a ficti- tious node and all T*s(~o \n) as immediate subtrees. Clearly T* s is countably branching. We now use a standard procedure or ranking \nT* s with countable ordinals; let pO he the following ranking. I. pn(A) = 0 whenever A is a leaf of \nT* s . 2. p\u00b0(A) ~ lub pU(B)), for B a direct descendant of A in T* s . There is one final problem: it \nis our intention to take the cone directives as the helpful cj for the corresponding rank. However, this \nis not uniquely defined for pO since there may be two cones with the same rank but with different directives. \nTo avoid this, we perform a rankshift, reranking all such cones. See [F] for the details; similar shift \nwas done for the special cases of fair termination. Let p denote the shifted rank. We are now ready to \ndefine all we need for the successful application of #'-UFT. We take W as the countable ordinals with \ntheir usual ordering. The parametrized invariant is:  pi(~,a) ~cA ^ p(A) = a . Note that A may be either \na cone or {~} . ~,j, if A=.g-CONE\u00a2,)(~) ^ p(A)., a Da u J tl if A,., {~} ^ p(A),=W. S o -I-D a . By \nthe rank shift of p, the partition is well-defined. We now show that all clauses of g-UFT are satisfied: \nINIT -Take a as the rank of A 0 (containing the initial state). CONT, TERM -trivial. NOINC-Suppose pi(~,w) \n^ B i holds, and let 6' be a state re-suiting from the execution of S i on // . Let A ~ be the element \nof the cone hierarchy containing ~['. Then, either A = A', in which case p(//) = p(~'), or A' is a descendant \nof A, in which case p(~) > #(6') DEC - Similarly, only necessarily A \u00b0 is a descendant of A, since the \noccurrence of eJ left A by the cone exit lemma. u Thus, b---<<p>> S <<true>>, which completes #.-UFT \n~\" the proof. [3 We now extend the rule to deal with the weak and strong versions of at-fair termination. \nIn both cases, an extra clause is added, taking into account the extra condition guaran- teeing infinite \noccurrence. w To prove <<p>> S <<true>> : u i. prove <<p>> S <<true>> gr ii.(CE) prove pi(w) ~ q0j, \nJeDw, w not minimal. Rule #.-WFT (Weakly ~'-Fair Termination) The extra clause (CE) calls for showing, \nat each inter-mediate stage characterized by pi(w), that as long as the compu- tation did not terminate, \nall \u00a2pj, j in the helpful set D w, hold continuously. Theorem: (soundness of #.-WFT) For a (typical) \niterative statement ScGC: w if [----<<p>> S <<true>> , #.-wF'r #.9\" w then [= <<p>> S <<true>> . ~r \nProof: Similar to the soundness of ar-UFT. An infinite weakly #'-fair sequence would contradict well-foundedness \nof (W, <). El 51 Theorem: (semantic completeness of #.-WFT) For a (typical) iterativc statement SEGC \nw if I,= <<p>> S <<true>>, then #. h l-<<p>> S <<true>> . #.- WFT #. Proof: The proof proceeds along \nthe same lines as that of the completeness of #.-UFT, the only difference being in the defini- tion of \na cone, and the condition for cone exit. df #.-CONE\u00a2i (6) --{'q [ ~ is a state-occurrence on an infinite \n~j-avoiding path ~r originating at ,~ along which qJ holds continuouslyt. We leave it to the reader to \nverify that both the modi- fied cone exit lemma and the cone chain lemma hold under the modified definition \nof cones. Thus, (W,<_), pi and (D w, S w) may be defined as before, satisfying i of ~'-WFT. As for CE, \nif pi(w) holds during a computation, the computation remains within some cone, say with directive 6i' \nand then q'J holds continuously by the new definition of a cone. O To prove <<p>> S <<true>>: #. u \n i. prove <<p>> S <<true>> . #. u ii. (IO) prove <<pi(w)>> Sw <<true>>, #. w not minimal, where: \n Sw:: *l I'l (B i ^ ~ V qoj) .* si]. icl jED w Rule #.-SFT (Strongly #.-Fair Termination). Again, the \nextra clause (IO) guarantees infinite occurrence of a helpful \u00a2i' which will force ~J to occur eventual- \nly and cause decrease. Note that the eventual occurrence V qoj is reduced to #.-fair termination of a \nderived program \"Sw, jcl~ w which terminates as soon as any tpj, jeD w, holds. Theorem: (soundness of \n~-SFT) For a (typical) iterative statement S\u00a2GC: if I-<<p>> S <<true>>, then ,~'- SI:T .~ I== <<p>> S \n<<true>> . Proof: Similar to the proof of thc ~-UFT soundness theorem. [] Theorem: (semantic completeness \nof ~'-SFT) For a (typical) iterativc statement ScGC: if J= <<p>> S <<true>> , then ~r I--<<p>> S <<true>> \n, .~'- SFI'..~\" Proof: Again, all we need do is modify the definition of a cone. .~'-CONE\u00a2j (6) = D/[ \nT/ is a state-occurrence on an infi- nite ~i-avoiding path ~r originating at ~ along which 9)j holds \ninfinitely of t0nl. Again, we leave it to the reader to verify that the modi- fied cone exit Icmma and \ncone chain lemma hold. and define (W, _<), pi, (S w, D w) as before. We have to show that (IO) also holds. \nSuppose the derived program S~, for s0me w>0 does not ,~'-fairly terminate, i.e. has an infinite ,~'-I'air \ncomputation path. By the construction, along this path no ~i ' JeDw \" ever holds. This pa'th has an infinite \ntail remaining within some cone, say CONE~;j (,~). Hence, along this tail 9,i0 was not infinitely often \nenabled, and the same computation is ,~'-fair with respect to the original program, a contradiction. \nThus, [= <<pifw)^w>O>> Sw <<true>> . The whole procedure can be repeated for 'Sw. finding new w, pi, \npartitions, etc. This must eventually stop, since after a finite number of iterating these constructions, \nwe reach a situation where a derived pro- gram has as its guards B i ^ ~ V q'i'i'e'allthe~'sare jc! negated. \nFor these programs, all the cones trivialize to singletons, and T* = T. Thus. T. the original tree, is \nfinite, and wc may appeal to ordinary (fairness-independent) termination proof rule to prove it. Thus, \nafter establishing the semantic troth of the strongly-fair termination of Sw, one may use an inductive \nhypothesis to infer its provability using the S-SFT rule, terminating the proof (where the induction \nis over the number of ~'s the negation of which is implied by the guards). [] 4. Conclusion We have \nintroduced a generalized fairness notion in three versions: unconditional, weak and strong, generalizing \nthe three corresponding versions of standard fairness and those of equifairness, and many others. For \neach generalized fairness property, we presented a proof rule for the termination induced by that property, \nand proved soundness and semantic completeness for each such rule. The semantic completeness proofs capture \nthe common structure of the corresponding proofs in the special cases of fairness and equifairness. A \nsyntactic completeness proof may he obtained for a multisorted ~-ealculus (with a sort for countable \nordinals) along the line of lAP 82]. Also, one can develop a parallel theory by state-predicate directed \nchoice of \"helpful\" el'S, along the lines of [LPS 8 I], or the transformational approach [AO 82], lAPS \n821. An interesting extension of the theory is in the direction where any subset of infinite paths may \nbe excluded, while all others arc finite. It is not clear how to prove termination under such assumptions, \nwhen the subsets are not necessarily given in terms of state predicates. One attempt would be to find \na proof rule for a ~-regular subset, or a subset specified by linear time temporal logic. Another interesting \nresearch direction is to extend these ideas to full scope extreme fairness [P 83]. 52 References [AO \n821 lAP 831 [APS 821 IDIJ 751 [DU 761 IF] [FW 821 [GF 821 [GFK 831 IGFMR 811 [LPS 81] [P 83] IQS 82] \nK. R. Apt, E. R. Olderog, \"Proof rules and transformations dealing with fairness\", TR 82- 47, LITP, University \nof Paris 7, October 1982. To appear in Science Computer of Programming. K. R. Apt, G. D. Plotkin, \"Countable \nnondeter- minism and random assignment\", LITP, TR 82- 7. Univ. of Paris 7, February 1982. To appear in \nJACM. K. R. Apt, A. Pnueli and J. Stavi, \"Fair termina- tion revisited with delay\", TR 82-5 I, LITP, \nUni- versity of Paris 7, October 1982. Also in: Proc. 2nd Conference on foundations of software technology \nand theoretical computer science (FST-TCS), Bangalore, India, December 1982. To appear in TCS. E. W. \nDijkstra, \"Guarded commands, nondeter- minacy and formal derivation of programs\", CACM 18, 8, August \n1975. E. W. Dijkstra, \"A Discipline of Programming\", Prentice-Hall, 1976. N. Francez, \"Fairness\", forthcoming \nbook. R. Fagin, J. H. Williams, \"A fair carpool sched- uling algorithm\", IBM Research Report RJ 3575, \nSan Jose, June 1982. O. Grtlmberg, N. Francez, \"A complete proof rule for weak equifairness\", IBM Research \nRC- 9634, October 1982. Submitted for publication. O. GrOmberg, N. Francez, S. Katz, \"A complete proof \nrule for strong equifairness\", 2nd Work- shop on tLogics of Programs ) , CMU, June 1983. To appear in \nLNCS. Also IBM T. J. Watson Research Report RC 3996, May 1983. O. GrUmberg, N. Francez, J.A. Makowsky, \nW.P. de Roever, \"A Proof Rule for Fair Termination of Guarded Commands\", Proc. of the Int. Symp~ o._~n \nAlgorithmic Languages, Amsterdam, October 1981, North-Holland, 1981. D. Lehmann, A. Pnueli, J. Stavi, \n\"Impartiality, justice and gairness: the ethics of concurrent termination\", Proc. 8th ICALP, Acre, Israel, \nJuly 1981, LNCS 115 (O. Kariv, S. Even -eds.), Springer Verlag 198 I. A Pnueli, \"On the extremely fair \ntreatment of probabilistic algorithms\", ACM-SIGACT Sym- posium on Theoretical Computer Science (STOC), \nBoston, April 1983. J. P. Queille, J. Siffakis, \"A temporal logic to deal with fairness in transition \nsystems\", Pro- ceedings of FOCS Conference (IEEE), 1982.  \n\t\t\t", "proc_id": "800017", "abstract": "<p>We present a generalization of the known fairness and equifairness notions, called @@@@-fairness, in three versions: unconditional, weak and strong. For each such version, we introduce a proof rule for the @@@@-fair termination induced by it, using well-foundedness and countable ordinals. Each such rule is proved to be sound and semantically complete. We suggest directions for further research.</p>", "authors": [{"name": "Nissim Francez", "author_profile_id": "81100052373", "affiliation": "Computer Science Department, Technion-lsrael Institute of Technology, Haifa 32000, Israel", "person_id": "PP17013153", "email_address": "", "orcid_id": ""}, {"name": "Dexter Kozen", "author_profile_id": "81100623764", "affiliation": "Dept. of Computer Science, Mathematical Sciences Department, IBM T. J. Watson Research Center, Yorktown Heights, N. Y.", "person_id": "PP43122905", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800017.800515", "year": "1984", "article_id": "800515", "conference": "POPL", "title": "Generalized fair termination", "url": "http://dl.acm.org/citation.cfm?id=800515"}