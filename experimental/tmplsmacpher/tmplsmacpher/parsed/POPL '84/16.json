{"article_publication_date": "01-15-1984", "fulltext": "\n A Types-as-Sets Semantics for Milner-Style Polymorphism Mitchell Wand Computer Science Department Indiana \nUniversity Lindley Hall 101 Bloomington, IN 47405 USA Abstract In this paper we present a semantics \nfor Milner-style polymor- phism in which types are sets. The basic picture is that our programs are actually \nterms in a typed X-calculus, in which the type information can be safely deleted from the concrete syntax. \nIn order to allow for common programming constructs, we allow reflexive or infinite types, and we also \nallow opaque types, which have private representations. An adaptation of llindley's Principal Typing \nTheorem then asserts that the (ype information can be reconstructed. Thus expressions are polymorphic, \nsince they may have more than one correct typing, but values are not. Expressions that are not well- \ntyped arc syntactically ill-formed, as they are in conventional mathematics, rather than having the meaning \n\"wrong\". The resulting semantics is simpler than that for fully poly- morphic models [Leivant 83], and \ngeneralizes (,he standard con- structions, such as retracts and ideals. 1 Introduction In conventional \nmathematical discourse, the intuitive notion of \"type\" seems much better founded than it is in computer \nscience. In general, one can regard types as sets of objects, and a function may only be applied to an \nobject from its domain. If one has a function j\" whose domain is the integers, and one attempts to apply \nit to a real number, say e, then one says that the expression f(~) is meaningless because of an error \nin types. Thus we hold with Reynolds [83] that type structure is a syntactic discipline: terms which \nare not well-typed are considered to be ill-formed and therefore meaningless. This situation is muddied \nin computer science because our machines always do something with every input, including our f(~). One \nis then led to the notion of types as predicates on some universal domain: an integer is an object passing \nthe integer predicate, and a function from integers to integers is an object which, when supplied with \nan object passing the integer predi- cate, produces another object passing the integer predicate. One \n........... = .......... This Material is based on work supported by the National Science Foundation \nunder grant number MCS79-04183. Permission to copy without fee all or part of this material is granted \nprovided that the copies are not made or distributed for direct commercial advantage, the ACM copyright \nnotice and the title of the publication and its date appear, and notice is given that copying is by permission \nof the Association for Computing Machinery. To copy otherwise, or to republish, requires a fee and/or \nspecific permission. &#38;#169; 1983 ACM 0-89791-125-3/84/001/0158 $00.75 then proves by induction that \nUwell-typed\" expressions produce \"well-typed\" answers, but expressions that are not \"well-typed* may \nproduce any answer at all. As Reynolds points out, these predicates inevitably overlap, leading to problems \nwhen an ob- ject may be both an integer and a function, etc. [Reynolds 83] attempts to deal model-theoretically \nwith these issues. In keeping with the spirit of [Wand 82, 83], we attempt to deal proof-theoretically \nwith these issues. This is the tradi- tional mathematical approach to abstraction and representation \nindependence. Our starting point is the typed ),-calculus, which is the epitome of a well-understood \ntheory of type. In order to invest this formulation with enough power to prove any useful theorems, we \nmust supply it with some additional structure: I. We need to allow the use of types other than functional \ntypes. We present the definition of a typed X-calculus with such an expanded system of types. These types \npermit the use of arbitrary type constructors other than \"--*\" and so-called \"reflexive\" types rather \nthan just the finite types typically considered in the typed X-calculus. 2. We then show how such a language \naccounts for programs written under Milner's type discipline, including the expand- ed notion of type. \nWe prove an extension of the Principal Typing Theorem to show that it is decidable whether a term is \ntypable, and that its principal type may be deduced by a simple extension to the usual unification algorithm. \n 3. We need to account for some primitive type constructors, such as products and sums, that do not seem \nto be definable in our general paradigm. We give a treatment of these; the treatment of sums, in particular, \nbased on Reynolds, seems to be better than the ones usually used. 4. We then present our formalization \nof user-defined types. We model such types by including primitive constants which provide the isomorphism \nbetween a public type (such as, say, Complex.) and its private representation (say (pair Real ReaO). \nSuch type constructors may also be parameterlsed to account for type abstraction, such as the type of \n(liet-ol a} for any type a. 5. We present a definition of model for our theories. To ac-complish this, \nwe show that Meyer's combinatory model theorem [Meyer 82] extends to any set of types which is closed \nunder \"--* \", including reflexive types.  8. This formulation, however, does not allow induction on \nap- proximate solutions, as do the standard limit constructions. We remedy this to some extent by using \na suitably modified notion of the theory of Boehm-trees. Using the resulting theory, we prove some benchmark \nresults. Our formulations should be regarded us preliminary: we have included just the axioms needed \nto prove the desired theorems, subject only to the existence of reasonable models. 158 2 Language and \nTheories Deflnltlom A lype discipline A is a set of trees (possibly including some infinite trees) closed \nunder --., that is, if a, $ E A then (o -. $) E A. Examplea: (1) Let E be a ranked set. Then the set \nof all finite trees built from ~-.\" and elements of E (i.e., the initial algebra generated by EU{-.}) \nis a type discipline. (2) Same, but all finite and infinite trees with nodes labelled by r.u{--.}. (3) \nSame, but all finite and rational trees (i.e. only a finite number of elements of E appear, and the set \nof occurrences of each label is a regular set). (4) The set consisting of a single tree: the complete \ninfinite binary tree in which every node is labelled by \"~ .\"  We omit parentheses and associate arrows \nto the right, as usual. We say a type discipline is effective iff there exists a set of finite representations \nfor the elements of A such that the construction of a tree from its subtrees and the decomposition of \na tree into its root and its subtrees are both recursive. Examples (1), (3), and (4) are effective, llenceforth, \nwe assume whenever necessary that the type disciplines arc effective. For eve/)' type a E A, we assume \na countably infinite supply of variable symbols z~', z~ ..... We also allow a countable set (\" of constants \nwith associated types. Generally such constants come in families, e.g. tense : a ~ (listaJ ~ (tista) \nfor each type a. We now'formulate the notion of a typed X-term. This defi- nition is standard, except \nthat it is relative to a type. discipline A. In fact, it follows exactly the definition in [Barendregt \n81, p. ~ool. Deflnltlom The language A(C) of A-typed X-terms consists of a set of strings with associated \ntypes in A. We write M : a to indicate that string M has type a. The terms are defined as follows: (1) \nIf z \u00b0 is a variable of type a, then z ~ : a is a term. (2) If c: a E C, then c:a is a term.  (3) If \nM : a -~ /~ and N : a are terms, then (MN) : ~ i:~ a term. (4) If xo is a variable of type a, and M \n: ~ is a term, then (Xx\u00b0.M) : a --~ is a term.  (5) Nothing else is a term. The notion of a theory is \nalso standard: Deflnltiom A A.theory is a set of pairs of A(C)-terms closed under a-conversion, 0-conversion, \nreflexivity, symmetry, transi- tivity, congruence (from M =~ M' and N = N' deduce MN ----M~N~), and the \n~-rule (from M ~- N deduce X~.M ffi Xz.N). 3 Polymorphism A A-theory constitutes a strongly-typed programming \nlan- guage, like PASCAL. A program is just a term in the language, and we compute by ~ reducing the term \nto normal form. This is not, however, a particularly convenient language to program in, because one must \nput in too much type information: one needs a separate mapcar function for lists of every type (just \nas in PASCAL one needs separate routines for arrays of every size). In practice, one does not need all \nthese separate routines for two reasons, one pragmatic and one mathematical. The pragmatic reason is \nthat representations of related types share facets of their representation in a computer. Thus arrays \nof various sizes are all implemented as linear sequences of locations, and lists of booleans, integers, \netc., are all typically implemented as linked lists of cells. Thus procedures such as mapc~r can be imlymorphic \nbecause they only manipulate the portion of the representation which is shared among the various instances. \nIn this analysis, polymorphism is a syntactic phenomenon: expressions are polymorphic because we are \ntoo lazy to put in all the subscripts on the combinators, and it so happens that we can get away with \nthis because of standard implementation conventions. Values are not polymorpbic. This seems to be the \nanalysis of polymorphism implicit in the discussion, though not in the theory, of [Milner 78]. It is \nto be contrasted with the full polymorphism or [Reynolds 74, l,eivant 83] where values can be truly polymorphic. \nIn Milner- s,yle polymorphism, the type structure is weaker, but in compen- sation, it has a simpler \nsemantics, as we will show. Furthermore, it seems adequate for a large number of applications, including \na system for semanlic prototyping [Wand 83a], whose construction motivated us to examine this question. \nThe mathematical reason is given by the Principal Typing Theorem of [[lindley 09], which states that \ngiven an arbitrary string M, it is decidable whether that string was obtained By removing the type superscripts \nfrom some term of the typed x-calculus. If A! was obtained by removing the type information from a term \nof type cz, we sift that c~ is a possible type of M. Furthermore, one can effectively find a unique \n\"type scheme,\" called the principal typing of AI, such that every possible type of AI is an instance \nof that scheme. The proof utilizes the unification algorithm of [Robinson O5]. Ilindley's proof allowed \nonly finite types (not necessarily restricted to functional types, however), llis proof, however, relies \nonly on the decidability of the unification problem, so it goes through whenever the set of type schemes \nhas a decidable unification problem. In particular, it goes through for the set of rational schemes. \nThere the unification algorithm is just the conventional one, except that the so-called \"occurrence check\" \nis omitted [Robinson, personal communication]. DIgrenlon: In order to apply llindley's proof, we need \nto take care of a few details. First, we need to extend the notion of a type discipline, as defined above, \nto a discipline of type schemes, which are like types except they may contain type variables. A discipline \nmust be closed under --. and under substitution of schemes for type variables. The types, as defined \nabove, then become just the type schemes with no variables (i.e. the ground type schemes). Also, in place \nof the treatment of constants above, we associate with each constant symbol a principal type scheme, \nso rule (2) in the definition of terms becomes: \"if c : ~ E C, and r is an instance of rl, then c, : \nr is a term ~. Also, tlindley's proof is in terms of combinatory logic rather than the lambda- calculus, \nbut Theorem 2 in his paper shows that this difference is inessential (see, for example, the statement \nof llindley's theorem in [Barendregt 81, Proposition A.I.10]). End of Dlgrenlon Thus, given a term without \ntype information, we can recon- struct, the type information, and do so in the \"most general\" way. This \nallows us to program without giving types (though exactly where one should specify types anyway is a \nlanguage design question). We can rely on the principal typing theorem to assure us that we will get \nanswers of the right type, and on our shared representations to share object code. Again, we see that \nexpressions are polymorphic, but values are not. When we introduce a new constant, say c0nz, we actually \nare introducing an infinite family of typed constants cons~ : ~ (listaj ~ (listaJ for each type a. Furthermore, \na -. (lista I -.* (lisla) is a principal type scheme for cons. What about generics? This is a troubling \nsubject for conven- tional analyses. We account for generics, either local or global, by regarding them \nas merely syntactic sugar for their definition expressions. Thus something like \" let f = AI In N\" in \nML 159 [Gordon st. at. 78] is syntactic sugar for N[M/I], which hgs quite a different principal type \nfrom (Xf.N)M. 4 Products and Sums In order to do any useful examples, we need some additional type structure \nbeyond the pure typed X-calculus. We will assume the following: I. We have some ground types, atnong \nwhich are the type Triv with element triv. 2. We assume that for certain types ~, there will be const:tnts \nd~ : a --- # anti eo,~ : /~ -. a. at most one such pair per a, subject to the axioms: dc,~leo,s z) = \nz These symbols are the key to the solution of domain equa- tions, as discussed in the following section. \n3. Our types are closed under the 2-place type constructors pair and union, and for all types a,#, 7, \nwe have constants pairc,~ : a -.. B -'* pair a# Ison~ : pair ai5 ~ a rsona# : pair a15 ~ # inLo~ : a \n-.., union a~ inRao :/3 --* union ctl3 caseoo. ~ : union a# -.. (c~ .--. 7) \"\" (15 --* \"r) \"-* \"r subject \nto the following axioms: Ison(pairx y) = z rson(pairr y} = y pair(lson z, rson z) : x case{inL z)f g \n= f z case(inR x)fg = g~ Our treatment of sums is motivated by the definition of a coproduct in a category, \naml was anticipated by Reynohls [75]. It allows expressions involving sum types to be well- typed, and \navoids the introductions of canonical error ele- ments, as required by the conventional treatment via \n\"re-strictions? 4. We need in addition to postulate that these constants inter- act nicely. An appropriate \nset of axioms seems to be the following: at(ease rfg)y) = (casez (a o f)(a o g))y where a is lson, rson, \nd, or e (but not pair) (ease(case y i j) f g) = (casey Xu.casc (iu)fg Xu.case (ju)fg) 5 User-defined \ntypes In programming languages such .~s CI,U or Simula, one can create %paque\" types, whose representation \nis known only in a small scope, though functions which manipulate that represen- tation may be known \nin the rest of the program. This device allows a cleaner interface between types and their users. To \nformalize this, let Pub be an opaque type with represen- tation Priv. We add two constants to the typed \n),-calculus: d : Pub -.. Priv (decode) and c : Priv -. Pub (encode), subject to the axiom that these \nconstants are two-sided inverses. We can then define the \"public\" operations on Pub in terms of d and \ne. This makes Pub a type that is isomorphic to Priv but distinct from it: one cannot manipulate an element \nof Pub except by using the decode anti encode operations explicitly. Thus, the resulting cal- cult,s \nmay be modelled by interpreting Pub as any set isomorphic to l'riv, but not necessarily the same as Pr/v. \nWe are now in a position to do some examples. We introduce a bit of syntax: '/deftype typerep type definitions \nend This defines a new type in terms of its representation, and gives the definitions of the functions \nfor manipulating it in terms of d and c. As a programming language construct, de~pe ought to restrict \nthe scope of d and e, but we will not do so, since that is an issue of language design, not of semantics. \ndeftype Boolrep union Triv Triv true = c(inL triv) false = e(inR triv) ifo : Bool--* a \"-'* ct --* cl \n= k zyz.case(dz)(Xu.y)(Xu.z) end This defines Booi as an opaque type, represented by the disjoint sum \nof two copies of Triv, with constants true and false, and a family or functions if o : Bool-. a -. a \n-. a, one for each a. Thus, if (without the subscript) becomes a global generic symbol for the code above, \nso that one may have multiple occurrences of if, with different types, in a single scope. Note also that \nin keeping with our philosophy, we have suppressed the subscripts wherever possible. The same machinery \nallows us to specify reflexive types. I lets we introduce stream as atype constructor by simultaneously \ndefining (streama) for all a: deftype (stream a) rep pair a (stream a) firsto, : (streama) .--, a : )~s.lson(d \ns) retto : (stream ct) --(stream or) = Xs.rson(d s) cons-slreama : a ---, (stream a) -.* (stream a) ----Xas.c(pair \na 8) end As in the case of Bool, we have introduced a family of operators first, rest, and cons-stream, \none for each type a. This is quite similar to the definition of an abareetype in ML [Gordon 78]. We can \nbuild streams without using a stream constant by using }60 fixed points, e.g.: stream-o/-lalsc = fiz(Xs.cons.stream \nSalse s) which builds an infinite stream of raise's. (Note that since we have allowed rational types, \nfiz is definable). Now let us do something slightly more complicated: a data type of lists. deftype (list \na) rep union Triv(pair a (list a)) nil~ : (list a) e{inL triv) coast, :el -. (list a)--* (list a) = \nXal.c(inR(pairal)) list-caSCoa : (list c 0 ~ B \"-\" (ct -- (list a) --* IJ) -\" i~ -~-xln/.( case (d l) \n(Xn.a)(X,,./(lson u)(rso, n))) end ilere we have homogeneous lists, with nil anti cons as the usual \nlist construction functions; the ilL and inR serve to inject values into the appropriate summand of the \nrepresentation. The list decomposition, however, is not the usual one: list-casc takes a list anti two \nmore arguments. The first extra argument is returned if the list is empty; otherwise the second argument \nIf above) is applied to the first eleme,t and the remainder of the list. Like if, list-ease has an additional \ndegree of genericity. We have used this style of programming extensively. It turns out to be quite pleasant \n{and rather reminiscent of ItOPE [13urstall, MacQueen, &#38; Sannella 80 D. To illustrate this programming \nstyle, we can write the func- tion reduce (seej e.g., [Henderson 80, p. 41D as follows: A reduce = X \nf al.fi.z(XO.lisl-casc I a (Xxy.f ~(Oy))) As a second example, consider the case of stacks. deftygm (stock \na) rep (list a) push\u00b0 : a -. (stacta) -.. (aacka) = Xas.e(consu s) popo~ : (slacka) --((aack a) -,. #) \n-,. ,0 -,. # = Xsf errt,aluc, list-case (d s)errvalue (Xal.f(*'l)) top.~ : (stacka)-.. (a -. #1 ..-. \n# --,/~ = Xsfcrrvaluc. lisl-case(ds)errt,aluc(Xal.fa) end Again, pop and top have additional genericity: \nthe type scheme of toe, for example, is (stacka) -.-. (a -. ~) -. ~ --. ~. Ilence, to take the top of \na stack of a, one supplies the function tol,,~ with the stack, an error value of type ~ to be returned \nin ease the stack is empty, and a function (of type c~ --, t~) to receive the top element in case the \nstack is non-empty. Such functions are ubiquitous in this programming style. They are analogous to Reynolds' \naccepters [Reynolds 81], and provide a smooth, type- checkable treatment of error conditions. 0 Models \nWe now present the definition of a model for our theories. The definition is adapted from [Meyer 82]. \nDefinltlom A model \u00a3 of A(CJ consists of the following data: ~. for every a E A, a set D~. b. for every \ne: o E C, an element c C E D,,. e. for every c~, B, E A, a function \",,n : Do--a X D~, --* D,, d. for \nevery a,B,7 E A, elements eoa E /)(o--a)~{c,~/~) such that 1. for allzEDo, yEDa, koa.zV=r. 2. for all \nz E D,,~a--~, Y E Do-a, anti z E I),,, s,,a~ r. V' z = z.-\" .(V. :}. 3. for allzEDo_~,vED~, eo~.z.y=z.v. \n 4. for all z,y E Do-a,((\u00a5 ~ E D~){z. z = V\" :) D (eoa \" X = e,~ a . v)) End of definition Given a model \n~', we can extend it to a valuation, which we will also call \u00a3, on A{C)-terms. To do this, let an environment \np be any type-preserving function from variable symbols to U Do. Then tile valuation is defined in the \nusual way, letting when ^! is of type /~ and dMa, has the property that for all de 0,, d^fp,, d--- \u00a2[~qa[d/, \nI. It is easy to show that the stan- dard bracket-abstraction algorithm preserves types, from which it \nfollows that the dm~, exist. Given a model \u00a3, the theory of \u00a3, Th{3) is defined as {hi = N I t~^fl = \n\u00a3UN]). It is easy to show that Th(\u00a3) is always a A-theory. Further- more, we call state Theorem 1. ((?omplctcness \nTheorcm}. If T is a A.theory, then there is a modrl \u00a3 such that Th(\u00a3) ~ T. Proof: We construct the term \nmodel: choose Do = {[AI]T [ M : ~}, that is, the set of T-equivalence classes of terms of type c~. l,et \nfar l [N] = [(Af N)], and let tile s,k,e be the denotations (independent of environment) of appropriately \ntyped versions of X~.vz.r~(y:), Xzy.~, and X~y.Tg. Then Th(C) = T; the proof, as sketched in [Meyer 82] \ngoes through in the typed version a.s well. | With these models, we complete the semantics for reflexive \ntypes in Mihwr's polymorphic system, in which expressions but not wdnes are polymorpiii\u00a2. Terms in the \nsystem are terms in the typed X-calculus, without the type subscripts, which can then be inserted by \nthe principal typing algorithm. The fully typed terms can then be interpreted in the model. It is e:my \nto construct models of the sort we have described. Hcsides the tertn moclels constructed in the proof, \nthe standard universal model constructions, with retracts, provide many such models ]Scott 80]. The Semantic \nSoundness Theorem in [Milner 78] essentially shows that the ideals are a model of the finite functional \ntypes; this result has recently been extended to ra-tional and other types by McQueen, Plotkin, and Sethi \n[83]. 7 Representation Independence Reynolds, i)onahue, and others have discussed the notion of representation \nindepenclence. The idea is that the result of a computation involving opaque types, such as stacks, should \nnot depend on how they are actually represented, that is, upon the model chosen. Our picture provides \na simple treatment of this idea. One cannot talk about the first component of a complex 161 number; \none can merely talk about the first component of the Cartesian representation of ~ complex number, beenuse \ntyping provides the syntactic discipline. Whatever one can prove about the complex numbers will be true \nin any model, so it must be independent of the actual representation of the complexes. This provides \na notion of representation independence that seems to be adequate for implementation; the results of \n[Donahue 79, Fokkinga 81, llaynes 82, etc.] remain of interest, however, ~s studies in model theory. \n8 Restoring induction Our treatment of opaque (ypes deals with them ~ solutions to domain equations. \nThough our treatment is proof-theoretic, it of course relies on the work of Scott [72, 76], I,ehmann \nand Smyth [81], and others who established the existence of such solutions by model-theoretic means, \nprimarily using the notion of limits. (Lehmann and Smylll even pointed out (hat operations on data types \ncould be defined in terms of the isomorphisms; this is implicit ~-s well in the standard implementations, \ne.g. [Gordon 78], [Liskov a. at. 77]. llow are solutions constructed by limits different from ar-bitrary \nsolutions of domain equalions? By analogy with the case of fixed points, one finds that limit solutions \nadmit proofs by induction. The natural proof-theoretic analog of an induction rule is the use of Boebm \ntrees [Barendre~ 81]. The Boehm tree of a X-term is constructed, roughly, by taking the leftmost reduction \nuntil one gets a term of the form Xr~...~,,.~tM~ M~...Mp, and then proceeding similarly with the Mj; \nin general this gives an infinite tree. In our c~se, one needs to add the axioms of section ,5 ~q reduction \nrules as well. One then adds all the equations of the form M = N when llTIM) = IIT(N). This technique \nw,~ used for compiler optimization in [Wand 83]. We conclude by showing some examples of theorems that \ncan be proved by this principle. Consider the following definitions: succs: int --* (stream int) = fiz{Xfn.cone-strramn(fll+ \n'1)11 mop: (~ -. a) -. ((stre,,~ ~) -. (strcom,~)) = ]i:(xo/s. ,'o,)s. st re o m (/(first .,))(Of( rest \ns))) ints = ft.z(Xe.cone-strea,,',O (map 1+ s)) Ilere succs is a function which, given an integer n, \nproduces the stream consisting of n followed by its successors in order. Thus (succsO) produces the stream \n0, i, 2 ..... The function map is like mapcar for streams. Last, ints is the stream which begins with \n0, and whose rest is obtained from ints by adding 1 to each element. Thus ints is also the stream 0, \ni, 2, .. Theorem 2. ints= (euccsO). Proof: Both have Boehm tree c(pairO(c(pair I .. ))). (See Figure \n1). To conserve space, we have omitted the rather mechanical deduction. This example requires the use \nof the rules for d and e as reduction rules. II Theorem 3. map(fog) = (map f)o(rnapg). Proof: Both Boehm \ntrees look like e I pair 0 / ~e I pair/\\  1 e I Figure 1. Boehm tree for ints ~ (eucceO). ~. s.e I pair \nf/  I I. g pair f/\" Islon I i I. d g pair \\ I s Islon f/ e I I I d g I ,Ioo rson d i I s rson I rson \nI d $I X,,.e (pair (f(a(18on(d a))))(c (pair (f(g(lson(d( rson (ds))))))...))) Fioure E. noehm tree \nfor map(f o g) = (map f) o (map g}, (See Figure 2) I 162 A similar result can be shown for mapcar; in \nthat case the use of the rewriting rules for case is necegsary. 9 Open Problems A variety of extensions \nand open problems suggest them- selves: Our construction of term models extended that of Meyer to reflexive \ntypes. Leivant's construction of term models for Rey- nolds-style polymorphism [Leivant 83] also does \nnot involve induction on type, and hence the same extensions should work to get an analog of our Theorem \nI for the logic of full polymor- phism.  If the set of types is closed under product as well as -,, \nthen our models form Cartesian closed categories in the obvious way. Can one characterize the CC(\"s formed \nin this way?  It may be posited that the theory of Boehm trees is the \"real\" theory that we are interested \nin, rather than simply the theory of 0-conversion. Can we characterize the models of Boehm-tree theories \nin the same way that we now know how to characterize the models of lambda4heories?  What are the Church-Rosser \nproperties of these systems? Our system includes the surjective pairing axiom, pair(Isonz, rsonz) = z, \nalthough this rule was not used in any of the examples in Section 8. While this axiom causes the Church-Rosser \ntheorem to fail for the untyped calculus, it is known that the  pure typed )`-calculus with surjective \npairing is Church-Rosser [Pottinger 81]. The situation for the typed ),-calculus with infinite types \nis unknown. Nothing is known about the Church- Rosser properties of typed X-calculi with case operators, \nthough in our examples we could interpret sums as products in the usual way. Another problematic axiom \nis the surjective sum axiom, essex inL inR ~ z. 10 Conclusions We have presented a simple picture for \nMilner-style polymor- phism. The picture accounts for type inference (polymorphism), type abstraction \n(opaque types) including reflexive types, and representation independence in a single framework. We use \nproof theory to get abstraction, both as type abstrac- tion and abstraction from representations; this \nis the traditional mathematical approach to abstraction. Our treatment of reflex- ive types is just a \nproof-theoretical counterpart to the model-the- oretic approach of Scott, Plotkin, Lehmann and Smyth, \nct. al.; our work would be semantically vacuous without the hard-won knowledge that our theories had \ntractable models. Auk nowledgements A preliminary version of this paper was presented at the Workshop \non Types and Polymorphism in Programming Lan- guages, at Carnegle-Mellon University. We thank Ravi Sethi, \nDavid MacQueen, and Daniel Leivant for the opportunity to present the paper on very short notice. They, \nDana Scott, and Albert Meyer provided useful discussion. References [Barendregt 81] Barendregt, I l.P. \nThe Lambda Calculus: Its Syntaz and Semantics, North-Ilolland, Amsterdam, 1981. [Burstall, MacQueen, \n&#38; Sannella 80] Burstall, R.M., MacQueen, D.B., and Sannella, D.T. \"HOPE: An Experimental Applicative \nLanguage,* Conf. Rec. 1980 LISI\" Conference, 136-143. [Donahue 79] Donahue, J. \"On the Semantics of 'Data \nType',\" SlAM J. ('omput. S (1979), 546 560. [Fokkinga 81] Fokkinga, M.M. \"On the Notion of Strong Typing,\" \nin At. gorithmic Languages (deBakker and van Vliet, eds.), North-ltolland, 1981, pp. 305--320. [Gordon, \nst. o178] Gordon, M., Milner, R., Morris, L., Newsy, M., and Wads- worth, C. \"A Metalanguage for Interactive \nProof in LCF,\" Proe. 5lh Annual ACM Syrup. an Principles of Programming Lan- guages (1978) i 19-130. \n [Ilaynes 82] Iiaynes, C. T. \"A Theory of Data Type Representation Inde- pendence,\" University of Iowa \nComputer Science Department Technical Report Numer 82-04, December, 1982. [llenderson 80] llenderson, \nP., Functional Programming: Application and lmple- m~:ntation, i'rentice-llall International, Englewood \nCliffs, N J, 1980. [I lindley 09] ltindley, R. \"The Principal Type-Scheme of an Object in Combinatory \nLogic,\" Trans. Am. Math. Sou. 146 (1969) 29-60. [Lehmann &#38; Smyth 81] Lehmann, D.J. and Smyth, M.B. \n\"Algebraic Specification of Data Types: A Synthetic Approach,\" Moth. Sye. Th. 14 (1981), 97-139. [Leivant \n83] l,eivaat, D. \"Structural Semantics for Polymorphic Data Types (preliminary report),\" Conf. Rec. lOth \nACM Symposium on Principles of Programming Languages (1983), 1,55-166. [Liskov et. al 77] Liskov, B., \nSnyder, A., Atkinson, R. and Schaffert, C. ~Ab- stractlon Mechanisms in CLU,\" Comm. ACM eO (1977), 564- \n'576. [MacQueen, PIotkin, &#38; Sethi 83] MacQueen, D.B., PIotkin, G., and Sethi, R. \"An Ideal Model \nfor Recursive Polymorphic Types, ~ presentation at Workshop on Data Types, Carnegie-Mellon University, \nJune 9-10, 1983. [Meyer 82] Meyer, A.R. \"What Is a Model of the Lambda Calculus,\" Information and Control \n5e (1982), 87-122. [Milner 78] Milner, R. \"A Theory of Type Polymorphism in Program- ruing,\" J. Camp. \nO Sys. Sci. 17(1978), 348-37'5. [Pottinger 81] Pottinger, G. \"The Church-Rosser Theorem for the Typed \n),-Calculus with Snrjective Pairing,\" Notre Dame Journal of Formal Logic gg (1981) 204-268. [Reynolds \n74] Reynolds, J.C. \"Towards a Theory of Type Structures, ~ in Programming Symposium (Colloque sur la \nProgrammation, Paris) Springer Lecture Notes in Computer Science, Vol. 19, Berlin, 1974, pp. 408-425. \n 163 [Reynolds ;'5] Reynolds, J.C. \"User-Defined Types and Procedural Data Structures as Complementary \nApproaches to Data Abstrac- tion\" Conf. on New Directions on Algorithmic Languages, IFIP WG 2.1, Munich, \nAugust, 1975. [Reynolds ~:1] Reynolds, J.C. ~The Essence of Algol,\" in Alyorithmic Lan- guages, (J. W. \ndeBakker and J.C. van Vliet, eds.) North-Holland, Amsterdam, 1981, pp. 345-372. [Reynolds 83] Reynolds, \nJ.C. \"Types, Abstractions, and Parametric Poly- morphism,\" Pros. lbTP 88. [Robinson 65] Robinson, J.A. \n\"A Machine-Oriented Logic Based on the Res- olution Principle,\" J. Assoc. Comput. Mach. 1\u00a3 (1965), 23-41. \n[Scott 72] Scott, D. \"Continuous Lattices\" in Toposes, Algebraic Geometry, andLogic (F.W. Lawvere, ed.), \nLecture Notes in Mathematics. vol. 274, Springer-Verlag, New York, pp. 97-130. [Scott 70] Scott, D. \"Data \nTypes as Lattices\" SIAM J. Comput. 5 (1976], 522-587. [Scott 80] Scott, D. \"Relating theories of the \nX-calculus,\" in To H.ll. Curry: Essays on Combinatory Logic, Lambda-Calculus and For- malism (ilindley \nand Seldin, eds.) Academic Press, New York and London, 1980, pp. 403-450. [Wand 82] Wand, M. \"Semantics-Directed \nMachine Architecture\" Conf. Rec. 9th ACM Symp. on Principles of Prog. Lang. (1982), 234- 241. [Wand 83] \nWand, M. \"Loops in Combinator-Based Compilers,\" Conf. Rec. lOth ACM Symposium on Principles of Programming \nLan- guages (1983), 190-196. [Wand 83a] Wand, M. ~A Semantic Prototyping System,\" June, 1983. \n\t\t\t", "proc_id": "800017", "abstract": "<p>In this paper we present a semantics for Milner-style polymorphism in which types are sets. The basic picture is that our programs are actually terms in a typed &#955;-calculus, in which the type information can be safely deleted from the concrete syntax. In order to allow for common programming constructs, we allow reflexive or infinite types, and we also allow opaque types, which have private representations.</p> <p>An adaptation of Hindley's Principal Typing Theorem then asserts that the type information can be reconstructed. Thus expressions are polymorphic, since they may have more than one correct typing, but values are not. Expressions that are not well-typed are syntactically ill-formed, as they are in conventional mathematics, rather than having the meaning &#8220;wrong&#8221;.</p> <p>The resulting semantics is simpler than that for fully polymorphic models [Leivant 83], and generalizes the standard constructions, such as retracts and ideals.</p>", "authors": [{"name": "Mitchell Wand", "author_profile_id": "81100072594", "affiliation": "Computer Science Department, Indiana University, Lindley Hall 101, Bloomington, IN", "person_id": "PP39025873", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800017.800527", "year": "1984", "article_id": "800527", "conference": "POPL", "title": "A types-as-sets semantics for milner-style polymorphism", "url": "http://dl.acm.org/citation.cfm?id=800527"}