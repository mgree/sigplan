{"article_publication_date": "01-15-1984", "fulltext": "\n A GOOD llOARE AXIOM SYSTEM FOR AN ALGOL-LIKE LANGUAGE Joseph Y. ilalpern IBM Research Laboratory Sat) \nJose, California 9S193 Abstract: Clarke has shown that it is impossible to obtain a relatively complete \naxiomatization of a block-structured programming language if it has features such as static scope, reeursive \nprocedure calls with procedure parameters, and global variables, provided that we take first-order logic \nas the underlying assertion language [CI]. We show that if we take a more powerful assertion language, \nand hence a more powerful notion of expressiveness, such a complete axiomatization is possible. The crucial \npoint is that we need to be able to express weakest preconditions of commands with free proeedure parameters. \nThe axioms presented here are natural and reflect the syntax of Ihe programming language. Such an axiom \nsystem provides a tool for understanding how to reason about languages with powerful eontrol features. \n1. INTRODUCTION In a paper entitled \"Programming languages for which it is impossible to obtain good \nHoare axiom systems\" [CI], Clarke showed that it is impossible to obtain a \"good\" Hoare axiom system \nfor a block-structured programming language with the following features: (i) procedure names as parameters \nof procedure calls, (ii) reeursion, (iii) static scope, (iv) global variables, and (v) internal procedures. \n In this paper, we give a \"good\" Hoare axiom system for PROG 83, a large subset of PROG, the ALGOL-like \nlanguage introduced and studied in [THMI,THM2]. PROG 83 allows nondeterminism and sharing of variables \n(aliasing) and has all five features mentioned above. Permission to copy without fee all or part of this \nmaterial is granted provided that the copies are not made or distributed for direct commercial advantage, \nthe ACM copyright notice and the title of the publication and its date appear, and notice is given that \ncopying is by permission of the Association for Computing Machinery. To copy otherwise, or to republish, \nrequires a f\u00a2\u00a2 and/or specific permission. &#38;#169; 1983 ACM 0-89791-125-3/84/001/0262 $00.75 To explain \nthis paradox, we must look a little more carefully at the meaning of \"good\". Of course, we expect a good \nHoare axiom system to be sound (everything which is provable should be true) and complete (every partial \ncorrectness assertion which is true should be provable). It should also be \"natural\"; i.e., the axioms \nshould in some sense reflect the syntax of the programming language. From the G0dcl incompleteness theorem, \nwe know that for sufficiently rich interpretations, such as arithmetic, it is impossible to obtain a \nsound and complete axiomatization for first-order formulas, lot alone for partial correctness assertions \ninvolving first-order formulas, In order to talk about the completeness of a Hoare axiom system independent \nof the underlying interpretation, Cook ICe/ proposed the notion of relative completeness: under the assumplion \nthat for a given interpretation 1 and assertion language ..~'., we are given an oracle for the formulas \nof ~' which are truc in I, and that .~ is expressive for 1, then every true partial correctness assertion \nis provable. Expressivenesx means thal for every program g in the programming language and formula P \nin .if, there is a formula in .~ equivalent to the weakest precondition (ef. [DiD of g with respect to \nP. Taking .ff to be first-order logic, Cook gave a relatively complete axiomatization of a subset of \nALGOL with a while-statement and nonreeursivc programs. Gorelick [Go] extended Cook's work to include \nrccursive procedures. On the other hand, Clarke [CI] showed that if we take a language with the five \nfeatures mentioned above, no relative completeness proof is possible provided ~w take first-order logic \nas the underlying assertion language. The work of papers such as [GCH,THM,DJ] shows that in order to \nreason about programs in languages with rich control structures, it is also necessary to be able to reason \n262 about commands with possibly free procedure identifiers, in order to facilitate reasoning about such \ncommands, we will require that our assertion language be powerful enough to express the weakest precondition \nof g with respect to P even if g has some occurrences of free procedure identifiers. Thus, our assertion \nlanguage is a higher order one, in much the same spirit as that of [DJ]. We present a natural axiomatization \nof PROG 83 which is sound and, under our stronger expressiveness hypothesis, relatively complete. The \naxiom system presented here draws heavily on those of [GCH] and [THMI]. From [GCHI we get the style of \nthe axiom system, which is presented in terms of (possibly nested and universally quantified) sequents \nof partial correctness assertions, and the recursion rule. The completeness result presented here seems \nto be convincing evidence that this rule is indeed the \"right\" way to reason about reeursion. Following \nITHMi], we distinguish locations and their contents, allowing us to deal with aliasing in a clean way. \nThe assignment axiom is taken directly from [THMI], as well as techniques for reasoning about invariance. \nThis last point deserves some further discussion. In papers such as [CI, Go, OI], one sees a variant \nof the following axiom: P[g}P, provided the free variables of P arc disjoint from those of g. Intuitively, \nthis is sound because a program can only affect the values of its free variables. Since the truth of \nP only depends on the values of its free variables, if P is true before g is run, then it will still \nbe true afterwards. However, thv statement, \"a program g can only affect the values of its frce variables,\" \nno longer holds if we allow free procedure identifiers with global variables. For example, if q is the \nparameterless procedure x:=3 and cent(x) denotes the value stored at location x, then cont(x)--2{q}eont(x)ffi2 \n is clearly not valid. In order to deal with this problem, we introduce a new class of assertions called \ncovering assertions. In our notation, the partial correctness assertion abnve becomes: c\u00b0v(q.{Yl ..... \nYk}) \"* (x#YtA .,. AX#ykAcont(x)ffi2)~qleont(x)=2. i.e., if q is covered by the locations Yl ..... Yk \n(roughly speaking, if q \"reads\" and \"writes\" at most these locations) and x is distinct from Yl ..... \nYk, then if the contents of location x is 2 before we run q, thcn it will bc 2 afterwards. Covering assertions \nprovide a general technique for dealing with global variables; moreover, no special axioms are required \nfor them. The rest of this paper is organized as follows. In Section 2, we give the syntax and semantics \nof PROG 83, while in Section 3, we give the syntax and semantics of the assertion language, covering \nassertions, and partial correctness formulas. In Section 4, we present the axiom system, and prove its \nsoundness and completeness. We conclude in Section 5 with a discussion of further applications of these \nresults. 2. SYNTAX AND SEMANTICS OF PROG 83 To illustrate our axiom system, wc use the programming language \nPROG 83, a subset of the language PROG described in greater detail in ITHMI,THM2]. PIT, OG 83 is a fully-typed, \nblock-structured programming language, with a number of non-trivial features including nondeterminism, \nshared variables, nondeterminism, and procedure parameters nested to arbitrary depth. We have omitted \na number of features found in PROG, including lambda abstraction and higher order declarations. Moreover, \nprocedures in PROG 83 can only take identifiers as parameters, rather than arbitrary expressions of the \nright type. Although it is straightforward to give such features semantics in the framework developed \nin [THMi, THM2], axiomatizing them seems a bit more complicated. We hope to axiomatize more features \nof PROG in future work. The primitive types of PROG 83 are int, lee. prog. intexp, and Ioeexp. A store \nis a mapping from locations to their values. The types int and lee are intended to be the domains of \nstorable values and the locations in which these values are stored. The domain prog is that of program \nmeanings: nondeterministic mappings from stores to sets of stores. Elements of type intexp and Ioeexp \nare exprcsslons which evaluate to values and locations respectively in a given store, i.e. functions \nfrom stores to int (rcsp. lee) (in ALGOL jargon, these are \"thunks\"). We call 1o\u00a2 and in! basic o'pes. \nFor ease of exposition, the only tests we allow are cquality tests between expressions of basic type. \nProcedure o'pes arc defined inductively to be of the form al--'\"--ak-*prog , where =1 ..... a k are either \nof procedure type or of basic type. As in ALGOL 68, starting with variables of basic type, we can form \nmore complicated location and integer expressions. We use the notation x a to indicate that variable \nx has type a. 263 We brie!Ily review the syntax of PROG 83, and refer the reader to [THMI,THM2] for more \ndetails. Integer expressions: IntE::---- a (where a is a constant symbol) I x int I cont(LocE) I f(lntE \n1 ..... IntEk) (where f has type intk--int) [ if Booll= then IntE 1 else lntE 2 ft. Location expressions: \nLocE::= x I\u00b0c ] if BoolE then LoeE t else LocE 2 ft. Boolean expressions: BoolE::=lntE l =IntE 2 [ LocE \nt =LocE 2. Procedure expressions: ProcEa:: -- p\u00b0l ProcEl~'~\u00b0ProcI~ll)rocE>~\u00b0x~ (where a, ,8 are procedure \ntypes, y is a basic type). ProcE= uaPE a. Calls: Call::= ProcEPr\u00b0g (a pr(~cedure expression of type prog). \n Commands: Corn::= CallldivergelLocE:=lntEIComi;Com 2l Corn I or Corn 2 ] BBI [PBI I if Boule then Corn! \nelse Corn 2 ft. Basic Blocks: BBh:= let xint~IntE in Cmd tcl lnew x Ioc in Cmd ~en[ let xiO\u00a2~=LocE in \nCmd tel. Procedure Blocks: PBh:= proc PDeel do Cmd end. Procedure Declarations: PDecl::=pl x t 1 ...x \ni nl~=Com 1 ..... pmXm | ...Xmn, ~=Conlrn, where Pi,Xil ..... Xin i are distinct for i = I ..... m, \nPi has procedure type a i. and xij has type aij, where n i -- ail'~ai2\"'\"~nini~prog, i = I ..... m. We \nsay Pi is declared in this finite system of mutual procedure declarations with formal parameters Xil \n..... Xin ~ and declaration body Corn i. Notation: We often use the letter E (possibly primed or subscripted) \nto represent a finite system of mutual procedure declarations. Procedure blocks of the form proc E do \nCorn end will usually be abbreviated as EICom. For readability, we will usually write p(x t ..... Xk) \nrather than PXl...x k in procedure calls and on the left side of the ~= in procedure declarations. Note \nthat PROG 83 allows recursion in procedure declarations, procedures of arbitrarily high finite type, \nunrestricted procedure nesting, and arbitrarily complex calls. Explicit sharing is possible by use of \nthe declaration x I\u00b0\u00a2 Lute in a basic block. Commands in PROG 83 may have free procedure identifiers. \nA program is a command without free procedure identifiers. We give semantics to expressions of PP, OG \n83 by mapping them into elements of an algebraic swre model D. An algebraic store model D consist of \na collection of partial orders [Da], one for each type a, such that each element of D .,#is a monotonic \nfunction from Dn--Dfj. There is a least element z. a \u00a2 D., and for each function f \u00a2 D . the sequence \nJ.Q, f(.La), f(f(la)) ..... has a least upper bound in D a. Finally, for each dcD o, there is a finite \nset of locations which covers d. The properties of store models, the method of assigning semantics, and \nthe precise definition of the covering relation is given in detail in [THM2]. We give a brief sketch \nhere. We have a meaning function ,.4'\u00a2 such thai for each constant c of type n, ,X\u00a2(c) \u00a2 D a, An environment \nc gives meaning to the variables: if x is a variable of type a, e(x)\u00a2D a. To every PROG 83 expression \nv of type a there corresponds an element ,#\u00a2(v)eeD a which is the meaning of v in environment e. With \neach element of Da, we can define what it means for a set of locations L c DIe c to corer if. Some important \nproperties of the covering relation include: I. If p \u00a2 Dprog, then p is covered by L iff (cf. [MM]): \n(a) for any store s, for all s'cps, s and s' agree off L; i.e., for all h~L, s'(h)=s(h). Thus, p does \nnot change the contents of locations not in L. (b) if s and s' agree on L, then ps and ps' agree on \nL.  2. If h \u00a2 Die c, then h is coveredby L iff h \u00a2 L. 3. If d \u00a2 Din t, then d is covered by L for all \nsets L. 4. If p is covered by L and q is covered by L', then p(q) is covered by LuL'.  Crucial use \nis made of the covering relation when defining the semantics of the new declaration. Roughly speaking, \nto run new x in g wen in environment e and store s, we proceed as follows. We first find a set L which \ncovers g (or, more accurately, ,,\u00a2(g)e), chobsc a location h not in L, run g in environment e' and store \ns' which are identical to e 264 and s except that x is set to h with its contents initialized to a \n0' and then reset the contents of h after the computation of g has ended. In this way we maintain the \nstack discipline and use a truly \"new\" location for x. Again, we refer the reader to [THM2] for more \ndetails. As a consequence of the semantics, we get the following proposition, which shows that every \ncommand is equivalent to one in which the procedure declarations arc \"pushed in\" so that they only occur \nin front of procedure calls. This proposition will be useful in our axiomatization, by enabling us to \nrestrict attention to commands in this special form. Proposition 1 (cf. [THM I,GCH]): The following equivalences \nhold: (a) El(gl;g2) ---(E[gl);(E[g2) , (b) EI(gt or g2) -= (Elgl) or (Fig2), (c) El(if BooIE then gleise \ng2 fi) ---if BooIE then Elg I else EIB 2 fi, (d) If x does not appear.free in E, then  El(new x in \ng wen) - new x in Elg wen,  (e) If x is of basic type, Base is a basic expression of the same type. \nand x does not appear free in E, then El(let x ~= Base in g tel) m let x ~= Base in EIg tel,  (f) If \nE l and E 2 do not contain distinct declaration for the same procedure identifier, then EII(E21g) = ((E \nt oE2)Jg), (g) If none of the procedures declared in E appears free in g, then EIg - g,  (h) If g \nand g' are identical up to renaming of bound variables, then  g_g'.  From Proposition I we immediately \nget the following Corollary: Every command g is equivalent to a command g' in a normal form, where the \nsubcommand EIh occurs in g' only if h is a procedure call. 3. THE ASSERTION LANGUAGE AND PARTIAL CORRECTNESS \nFORMULAS To permit as much generality as possible, we do not describe the assertion language .~f in \ndetail hero, but state some abstract properties it must satisfy: (a) &#38;f is many-sorted. Among its \nsorts arc int and Ioc. To every integer (respectively, location) cxprcssion Base in PRO(3 83, there is \na corresponding term Base t in .Z with the same meaning (we shall omit the superscript t when it is clear \nfrom context). The assertions X=lin t and y=zto e are definable in -(g.. (b) Formulas in ~' are closed \nunder the first-order connectives ~, A, and V, which arc defined in the usual way. Truth for formulas \nof ..\u00a2e is defined relative to a model D, an environment e, and a store s. For a formula P of ~ce, we \nwrite D,e,s I=P if P is true with respect to D,e,s and D,e I=P iff for all stores s, D,e,s I= P. (c) \nA formula has a certain set of frec variables, and the truth of a formula depends only on the values \ngiven to its free variables. More precisely, if the free variables of P are among x 1 ..... x m, and \ne(xi)=e'(xi), i=l ..... m, then D,e,s I=P iff D,e~,s I= I )  (d) If P is a formula in -.~', lntE is \nan integer expression, and LocE is a location expression, then we can effectively find a formula I LocE-intE]P \nsuch that  D,e,s I = [LocE-lntEII ) iff D.e,slLoeE/IntE1 I =P, where s[LocE/IntE] is identical to s \nexcept that the value it assigns to (the meaning in D,e,s el) location expression LocE is (the meaning \nin D,e,s of) integer expression lntE. The first-order language defined in ITHM] has all the properties \nof (a)-(d) above. The model D is said to be strongly expressive if for all commands g (even those with \nfree procedure parameters), and formulas Pc.~ there is a formula WP(g,P)cL\u00a3, called the weakest precondition \nof P with respect to g, such that D,e,s I,=WP(g,P) iff for all s'c,J\u00a2(g)es we have D,c,s' I=P. Remark: \nNote that Dynamic Logic (cf. IHa]) is an example of an assertion language for which all models arc strongly \nexpressive in this sense, since, by definition, the Dynamic Logic formula [g]P is the weakest precondition \nof g with respect to P. In Dynamic Logic, we can find weakest preconditions effectively, but we do not \nrequire this for our results. 265 A partial correctness assertion is a triple PIglQ, where P and Q are \nformulas of .~' and g is a command. We define D,e,s pP{g}Q iff (D,e,s h P implies Vs' \u00a2..\u00a2'/(g)es, D,e,s' \nk Q), and D,e PP{g]O iff Ys(D,e,s kPlglQ). (Note our definition of D,ePPIg} is slightly different from \nthat of [THMI] in that with our formalism we do not need the notion of matching environments; i.e, environments \nwhich agree in the meanings that they give to all procedure identifiers.) in order to deal with global \nvariables we use covering assertions, which have the form cov(p.X), where p is a variable of procedure \ntype or of basic type, and X= Ix I ..... xk} is a finite set of location variables. For covering assertions \nwe define: D,e [=cov(p,X) iff e(p) is covered by {e(xl),...,e(Xk) }. From the properties of the covering \nrelation it follows that if y has type int, then cov(y,X)-true, while if z has type Ioc, then cov(z,{x \nI ..... Xk} ) --- z=x I V ... V z=x k. The set of partial correctness formulas is defined inductively \nas follows (of. [GCH]): (a) If H is a formula of .f~, or a covering asserti{m, or a partial correctness \nassertion, then H is a partial correctness formula. (b) If H l ..... H n are partial correctness formulas, \nthen so is {H 1 ..... Hn}- (e) If HI, H 2 are partial correctness formulas, then so is HI-*H 2. (d) \nIf H is a partial correctness formula and x \u00b0 is a variable (of any type a), then VxaH is a partial correctness \nformula.  We define the truth of a partial correctness formula relative to D,e. We have already done \nthis for formulas of .~, covering assertions and partial correctness assertions. For the other types \nof partial correctness formulas, we define: D,e]={H l ..... H n} iff D,e]~H i, i-~1 ..... n, D,e [= H \nt -* H 2 iff (D,e ]= H I implies D,e ]= H2), D,e [~ YxaH iff D,e[d/x] [~ H for all dcD e. A formula H \nis valid in D, written D I=H, iff for all environments e, D,e p H. If g is a command with free identifiers \nPl ..... Pit and X is a finite set of location identifiers, wc take cov(g,X) to bc an abbreviation for \nthe partial correctness formula: {Cov(p I,X),...,cov(Pk,X) }. Note that if g has no free procedure identifiers \nand all its free location identifiers are contained in X then cov(g,X) is vacuously true. Before we can \ngive our axiomatizati.n of PROG 83, we shall need several more definitions. if E is a set of procedure \ndeclarations, we will say that the variable q is reachable from p via E iff q=p or, inductively, if p \nis declared in E with declaration body Corn and q is reachable from r via E for some free variable r \nin Com. For example, if E consists of the procedure declarations p <- if w=z then q else p(r) q ~. x:=y, \nthen p, q, r, w, z, x, and y are reachable from p via E, while q, x, and y are reachable from q via E, \nand only r is reachable from r via B. If X is some finite set of location variables, we define eov(E[p,X) \nto bc an abbreviation for {cov(q,X)[q is reachable from p via E and q is not declared in El Thus coy(Hip,X) \nholds exactly if p is covered by X when it is bound to its declaration body in E. If H is a partial correctness \nformula such that no procedure declared in E occurs free in any of the subformulas of H which are formulas \nof .~, then we define EIH to be an abbreviation for the formula which results when we replace each subformula \nof H of the form cov(p,X) by cov(Eip,X), and replace each partial correctness formula of the form PIgIQ \nby P{E[g}Q (subject to the usual provisos about renaming any bound variables in H so that they have names \ndistinct from any variables free in E, and renaming the declared variables in E so that they have names \ndistinct from the free variables in H, in order to avoid capture of free variables). EIH is undefined \nif some .ftf-subformula of H has a free occurrence of a variable declared in E. Roughly speaking, E[H \nis the result of binding the meanings of free variables in H which are declared in E to their declarations \nin E. Note that we can find EIH effectively given E and H. If the assertion language .~\" were Dynamic \nLogic, we could also effectively transform any formula P in .f~ to a formula EIP, again binding procedures \nto their declarations in E, but for arbitrary .~' this in general cannot 266 be done. For this reason \nwe have not allowed procedures variables declared in E to appear free in .W.-subformulas of H. If P is \na formula of .W, we define [LocE:flntE]P to be an abbreviation for [LocE-,-IntE]P V LocE= .t.lo r V lntE= \n~Lia ,. As shown in [THMI], [LocE:=IntE]P is the weakest precondition of P with respect to the assignment \nLocE:=IntE. Finally, let w in* be a variable which does not appear in P, and let x I\u00b0\u00a2 be any location \nvariable. Then we define lnv(P,x) ==def (P ffi Vw([x--wlP)). Inv(P,x) says that P is invariant under \nchanges to the contents of x. If X is a finite set of location variables, let Inv(P,X) =def Ax,xlnv(P,x) \n Inv(P,X) holds exactly if P is invariant under changes to the contents of all the location variables \nin X. 4. A SOUND AND RELATIVELY COMPLETE AXIOMATIZATION OF PROG 83 Consider the following collection \nof axioms and rules of inference for partial correctness formulas. Axioms 1-7 are variants of the corresponding \naxioms in [THM l ], expressed in our formalism, and successfully capture the semantics of all the constructs \nin PROG 83 other that procedure declarations. Rule 8 is the recurslon rule of [GCH], reformulated here \nto allow us to deal with global variables. Axiom 9 alh)ws us to reduce consideration to commands in normal \nform when doing the completeness proof. Axioms and rules 10-14 are again quite standard and are used \nto prove arbitrary valid partial correctness formulas once we have the \"most general\" partial correctness \nformula. This technique goes back to [Go], and has also been used in many other papers, (eg. [THMI,CI,OI,GCH,..,]). \nThe remaining rules and axioms simply allow us to manipulate partial correctness formulas. 1. Assignment \naxiom: ([LocE:=IntElP) {LocE:=Int E }P.  2. Axiom of divergence: true(divergelfalse.  3. Sequencing \naxiom: IPIgIQ. QIg'}R} .* Plg;g'lR.  4. Choice axiom: {Pig}Q, PIg'}Q} \"*' Pig or g'lQ. 5. Conditional \naxiom: [(PABoolE){gtIQ, (PA~BoolE)Ig21Q l -, Plif BoolE then gt else g2 filQ.  6. Axiom of let declarations: \nIf x is a variable of basic type,  Base is an expression of the same type, and y a variable of the same \ntype which is not frcc in P. O, BasE, or g, then (P A y=BasE ^ y#z)|[y/xJgIo P~let x~=BasE in g tell(.,). \n Axiom of new declaration: Let yloc and z int be variables not free in P, Q, or g, and let X be a finite \nset of location variables. Recall that a Ois the constant used to initialize the new location in a new \ndcclaration. Then ~Axd:Xx~Y, cov(g,X), ([Y:fz]PAcont(y)=ao)lly/xlglly:= z]OI \"* Plnew x in g wenlQ. g. \n Recursion rule: Suppose E is a set of procedure declarations of the form Pl(rl l ..... rlkt)~b\u00b0dYl ..... \nPn(rn i ..... rnkn)'~bodYn- Suppose Pl ..... Pn do not appca~ free in H i. Pi, or Oi, i = 1 ..... n, \nand only appear frec in subformulas of H which are covering formulas. Then H'*[{Yril ..... rikl(Hi'*PilPi(ril \n..... rikl)lOi), i = I ..... nt-* IVrit,...rik,(Hi'*Pilbodyi|Qt), i= 1 ..... nil EIH\"[Vril ..... riki(Hi-'Pi{E \nI Pi(ri] ..... rik )}Qi), i = l ..... n}] Suppose we are given some set of procedure declarations E. \nIntuitively, the recursion rule says that if, whenever we can prove from some hypothesis H i somulhing \nabout each of the calls Pi in E for all possible values of their parameters, we can also prove the same \nthing about the corresponding body i of Pi (for all possible values of the parameters, and from the same \nhypothesis Hi) , then we can conclude the partial correctness assertion holds of Pi when it is declared \nin the environment E (again for all values of the parameters and under hypothesis Hi). 9. Normal form \naxiom: if g and g' are provably equivalent using the equivalences of Proposition I, then P{gIQ .,. p{g'~Q. \n 10. Axiom of coaseq~ence: {P'~P, Pig}Q, Q~Q'} -P'IglQ'. 11. Axiom 04\" conj~tcNo-m {P|gIQ, P'{gIQ'} \n~ (PAP')IgI(QAQ').  267 12. Invariance axiom: Let X bca finite set of location variables. Then {co,,'(g,X), \nInv(P,X)} ~ PigIP. Intuitively, the invarianec axiom says that if g is covered by X and P is a formula \nwhose truth is independent of the contents of these locations, then if P is true before we run g then \nP will be true afterwards. 13. Substitution rule: Let o be any mapping on variables which respects types \n(i.e., o(x) has the same type a,~ x). Let He be the result of replacing x by o(x) wherever x occurs in \nH. Then H He\" Note we allow arbitrary substitutions here, not just injections. This will enable us to \ndeal with sharing. 14. Rule of quantification introduction: If xdoes not appear free in g or H, then \nH -* P{g}Q H \"* :ixP{g}]xQ Note that the H appears here as a hypothesis in both the antecedent and the \nconclusion of this rule. This gives us a more powerful rule than the corresponding rule without the H, \nsince we can apply the rule relative to the hypothesis H. A similar phenomenon occurs in the rccursion \nrule (rule 8 above) and in rules 15 and 22 below. 15. Rule of universal quantification: If x does not \nappear free in H 1, then H 1 ~ H 2 H 1 --~VxH 2  16. Rule of declaration binding: If none of the procedures \n declared in E appear [rec in .~-subformulas of H, then H  ~lB\" 17. Implication axiom: If P and Q \narc formulas of .~', then (p=Q) -. (p --Q).  18. Instantiation axiom:  Vrtl -* H. 19. Axiom of transitivity: \n{HI-*H 2,H2~H 3] ~ (HI~H3). 20. Modus ponens: H l, HI'*H 2 H2  21. Axiom of trivial implication: {H \n1 ..... HnJ -* H i ,i ffi 1 .... n.  22. Set formation rule: For all n>_.0 H-~H 1 ..... H-*H n  H.~ \n[H 1 ..... Hn] Note that H --~ is a special case of this rule (taking n=0). 23. Empty set introduction \naxiom: (a) H --(~ --H), (b) (~b --H) --H. 24. Currying axiom: (|H1, H21 -* H 3) -* (H 1 -* (H 2 -* H3)). \nTheorem I: The axiom system presented above is sound; i.e. for any model D and any environment e, D,e]ffiH \nfor every axiom scheme H above, and for every rule of inference with antecedents H t ..... Hk, and conclusion \nH, if D,e [-Hi, iffil ..... k, then D,e ]m H. Proof: The soundness of axioms and rules 1-7 and 9-13 \nfollows from the soundness of the corresponding axioms and rules of [THMI]. We refer the reader there \nfor details. The recursion rule is just a reformulation of the well-known fixed-point induction rule, \nand unlike the recursion rule of [THMI] or [Oi], its soundness follows immediately from the denotational \n(fixed-point) semantics, and does not require copy-rule semantics (and thus a tedious proof of the equivalence \nof fixed-point and copy-rule semantics; of. [THMI,THM2]). The soundness of the remaining axioms and rules \nis almost an immediate consequence of the definitions. We leave details to the full paper. I\"l Let Th*(D) \nconsist of all the partial correctness formulas of the form cov(g,X)-*P which are valid in D, where P \nis a formula of ,~. We can now state our relative completeness theorem. Theorem 2: If D is strongly expressive, \nthen the axiom system above is complete relative to Th*(D) for partial correctness assertions involving \nprograms; i.e., if g is a program (with no free procedure identifiers) and D [-P{g]Q. then Th*(D) I'- \nP{gJQ. In order to prove the completeness theorem, we need to develop an analogue for the '*most general \npartial correctness 268 formula\" of [Go, OI]. Let X be the set of location variables {x 1 ..... Xk}, \nand Y be the set of integer variables {Yt ..... Yk I\" Let U(X,\u00a5) be the formula eont(xl)=y I A ... A \neont(xk)=y k. For each variable of basic or procedure type p and set of procedure declarations I::. \nwe define the most general partial correctness formula of p with respect to U(X, Y) and E, written mg(p,U(X,Y),E), \nby induction on the type of p as follows: (a) if p is of basic type, then mg(p.U(X,Y),E)) --def cov(p,X) \n (b) if p has type at-'..,.'.'am\"~prog, re>O, let r t ..... rra be variables of type al,...,n m, respectively. \nThen mg(p,U(X.Y),E) =def Vr I ..... rm[ {mg(rl,U(X,Y),E) ..... mg(rm.U(x,y),E) I --(Icov(p,X).cov(EIp,X) \n} --WP(Elp(r I ..... rm),U(X,Y))lp(r ! ..... rm)IU(X.Y))I. Roughly speaking, mg(p.U(X,y).E) says that \np \"acts right\" provided that that it is covered by the locations in X and all of its parameters (if any) \nact right (where \"acting right\" in the case of procedure identifiers means that WP(EIp(r I ..... rra),U(X,Y))lP(r \nt ..... rrn) |I.J(X,Y) is true). If g is a command with free identifiers Pl ..... Pn, we take mg(g.U(X,Y),E) \nto be an abbreviation for the partial correctnessformula [mg(pI,U(X,Y),E) .....mg(pn,U(X,Y),E) I. The \ncore of the relative completeness proof consists of the following two lemmas. Lemma I: If cov(h,X)-P|hlQ \nis valid, then Th*(D) l- [cov(h,X),cov(g.X).WP(h,U(X.Y))lglU(X,Y) ]  -*P{g]O. Lemma 2: If X = {x I \n..... xk} is a set of location variables, and Y = {YI ..... Yk| is a set of integer variables which do \nnot appear in g, then I-mg(g,U(X,Y)),E) -. [Icov(g,X),cov(l::lg.X)} \" YYl ..... Yk(WP(t=Ig,U(X,Y)) Ig} \nU(X,Y))]. Lemma 1 is just a variant of the observation that any valid partial correctness assertion \nabout g can be obtained from the most general partial correctness assertion about g (cf. [Go,el.eli). \nLemma 2, which is proved by a straightforward induction on the structure .f commands, intuitively says \nthat o,lce weknow the most general partial correctness formulas for all the free w~riables in g then \nwe can prove the most general partial correctness formula for g. We leave details of the proofs of Lcmmas \nI and 2 to the full paper. With these Lcmmas in hand. the remainder of Ihe proof of Theorem 1 is straightforward. \nN.tt: that if g is a program (with no free procedure identifiers) whose free location identifiers are \ncontained in X, taking E to be empty, we have mg(g,O(X,Y),\u00a2) m eov(g,X) --true. Thus by Lemma 2, we have \n(*) ]-- WP(g,U(X,Y)) t g I U (X,Y). And if PIgIQ is valid, by Lemma I with g=h we have (**) Th*(D) I-WP(g,U(X.Y))IglIJ(X,Y) \n~ Plglt). Then from (*) and (**) we can conclude, as dcsired. Th*(D) I- P[g}Q. 5. CONCLUSIONS We have \nprovided an axiomatization of PROG 83 which is sound and relatively complete, which for the first time \ndeals with global variables in a natural way. by means of covering assertions. There is only one drawback \nto the results presented here, namely, that we require a higher-order oracle: Th*(D). By Clarke's results \nwe know that this is in some sense necessary: we cannot hope to obtain a complete axiomatization for \na language as rich as PP.OG 83 by restricting ourselves to just having an oracle for the first-order \ntheory of the interpretation, Th(D). Using a rich oracle such as Th*(D) enables us to factor out certain \ndifficulties in order to gain insight into how to reason about programming languages which allow procedures \nas parameters. Nevertheless. it is worth trying to understand just how far we can get using only Th(D) \nas an oracle. First note that if wc restrict to the subset of PROG 83 in which procedures only take basic \nvariables as parameters (and thus no procedure parameters), then the above axiomatization is complete \nfor the resulting language relative to Th(D). Several previous papers on Hoarc logics have given complete \naxiomatizations for subsets of ALGOL-like languages consisting of programs with the finite range property \n269 ('cf. [CI,OI,I.O,THMI]). (Roughly speaking, a program has the finite range property if there is \na bound on the number of distinct procedure environmcnts which can bc rcachcd when it is run.) Indeed, \nas OIderog has shown loll, the standard Hoare axiom systems based on thc copy rule cannot deal with programs \nwhich do not have the finite range property. A program with the finite range property can be shown to \nbe equivalent to a program with no proccdurc parameters. Using this fact, we can show that by adding \none axiom to our system,, we can obtain a complete axiomatization for finite range programs relative \nto Th(D). (This result was obtained jointly with A. Meyer and will appear in the full paper.) This observation \nconfirms the conjecture made in [THM I] we can replace copy-rule induction (the usual rulc used to reason \nabout recursion, which is shown in [THMI] to be semantically unsound) by the semantically sound fixcd-point \ninduction rule, and still get a complete axiomatization relative to Th(D) for finite range programs. \nWe can also adapt our proof system to yield an axiomatization for L4 (the language with no global variables \nintroduced in [CI]) which is complete relative to Th(D) in Herbrand definable domains (domains in which \nevery value is representable as some term in the Hcrbrand univcrsc). The proof of completeness is essentially \nthe same as that given in [GCH]. (Note that with L4 covering assertions are unnecessary, since the variablcs \nthat any procedure depends on are explicit. Moreover, with our prcscnt formalism we can avoid the use \nof environment ~'ariables which seemed to be necessary in [GCH].) The crucial point in the proof of completeness \nis that in Herbrand definable domains, we can transform an L4 program (which may not have finitc range) \ninto a program with no procedure parameters (which clearly does). We can see that the finite range property \nis the common thread running through all the proofs of completeness relative to Th(D). But now consider \ntht: problem of finding a complete axiomatization for the type of modcls considered in [Cr], where not \nonly is the domain finite, but there arc only finitely many distinct memory h)cations. For such models, \nClarke's incompleteness results do not hold since they depend crucially on a recursive procedure being \nable to gcncrate an unbounded number of distinct locations. But the standard Hoare axiom systems based \non the copy rule cannot lead to a relative completeness result in this model because the programming \nlanguage still lacks the finite range property. However, it is relatively straightforward to transform \nthe zxio.~a system presented here to get a axiom system which is complete relative relative to Th*(D) \n(we must only modify the axioms slightly to deal with the fact that there arc only finitely many locations). \nAnd note that for such models, Th*(D) is decidable. We believe there will be many other situations where \nthe style of axiomatization presented here will also lead to interesting completeness results not obtainable \nby other means. There still remains the problem of finding a concrete assertion language ,W satisfying \nthe abstract properties pointed out, Dynamic Logic is nnc candidate, but in DL we can effectively find \nthe weakcst preconditions. It would be worthwhile to find a possibly wcaker language in which weakest \npreconditions exist, but cannot always bc found effectively. ACKNOWLEDGMENTS ! would like to thank my \ncoauthors on several other papers in this area, Albert Meycr, Boris Trakhtenbrot, Steve German, and Ed \nClarke, for many stimulating conversations on this material. The notion of \"covered by\" was worked out \nin conjunction with Albcrt and Boris, while Steve was in large part responsible for the form of the recursion \nrule. would also like to thank Sylvia Fujii for her help in preparing the manuscript. REFERENCES fell \nE.M. Clarke, Programming language constructs for which it is impossible to nbtain good Hoare axiom systems. \nJACAf 26, 129-147 (1979). [Col S.A. Cook, Soundness and completeness of an axiom system for program verification, \nSI..IM J. Comput. 7, 70-90 (1978). [Cr] F. Cristian, Correct and robust programs, IBM RJ3753, 1983i to \nappear in IEEE Trans. on Software Engineering. [DJ] W. Datum and B. Josko, A sound and relatively complete \nHoare-logie for a language with higher type procedures, Bericht No. 77, Lehrstuhl for informatik If, \nRWTH, Aachen, 1982. [Di] E. W. Diikstra, A Discipline of Programming, Prentice-Hall, 1976. [GCH] S. M. \nGerman, E. M. Clarke, aml J. Y. Halpcrn, 270 Reasoning about procedures as parameters, to appear in \nProceedings of CMU Workshop on Logics on Programs, Springcr-Verlag, 1983. [Go] G.A. Gorelick, A complete \naxiom system for proving assertions about reeursive and nonrecursive programs, TR75, University of Toronto, \n1975. [Ha] D. Harel, First-order Dynan, ic Logic, Lecture Notes in Computer Science 68, Springcr-Vcrlag, \n1979. [LO] H. Langmaack and I/. R. Olderog, Present-day Hoare-Iike systems for programming languages \nwith procedures: power, limits, and most likely extensiohs, in Proceedings of 7th International Colloquium \non Automata, Languages, and Programming, 1980, pp. 363-373. [MM] A. R. Meyer and J. C. Mitchell. Axiomatic \ndefinability and completeness for recursivc programs, in Proceedings of the Ninth Annual Symposium on \nPrinciples of Programming Languages, 1982, pp. 337-346. [OI] E.R. Olderog, Sound and complete Hoarc-likc \ncalculi based on copy rules, Acta Informatica 16, 161-197 (1981). [THM1] B. A. Trakhtenbrot, J. Y. Halpcrn, \nand A. R. Meyer, From denotational to operational and axiomatic semantics for ALGOL-like languages: an \novcrvicw, to appear in Proceedings of the CMU Workshop on Logics of Programs, Springer-Vcrlag, 1983. \nITHM2] B. A. Trakhtenbrot, J. Y. Halpcrn, and A. R. Meyer, The semantics of local storage, to appear \nin Proceedings of the IZlevcnth Annual ACM Symposium on Principles of Programming Languages, 1984. \n\t\t\t", "proc_id": "800017", "abstract": "<p>Clarke has shown that it is impossible to obtain a relatively complete axiomatization of a block-structured programming language if it has features such as static scope, recursive procedure calls with procedure parameters, and global variables, provided that we take first-order logic as the underlying assertion language [Cl]. We show that if we take a more powerful assertion language, and hence a more powerful notion of expressiveness, such a complete axiomatization is possible. The crucial point is that we need to be able to express weakest preconditions of commands with free procedure parameters. The axioms presented here are natural and reflect the syntax of the programming language. Such an axiom system provides a tool for understanding how to reason about languages with powerful control features.</p>", "authors": [{"name": "Joseph Y. Halpern", "author_profile_id": "81100537160", "affiliation": "IBM Research Laboratory, San Jose, California", "person_id": "P149011", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/800017.800538", "year": "1984", "article_id": "800538", "conference": "POPL", "title": "A good Hoare axiom system for an ALGOL-like language", "url": "http://dl.acm.org/citation.cfm?id=800538"}