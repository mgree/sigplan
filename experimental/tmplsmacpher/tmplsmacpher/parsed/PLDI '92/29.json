{"article_publication_date": "07-01-1992", "fulltext": "\n Eliminating Branches using a Superoptimizer and the GNU C Compiler Torbjorn Granlund Logic Programming \nand Parallel Systems Laboratory Swedish Institute of Computer Science BOX 1263 S-164 28 K&#38;t, Sweden \nteget?sics. se 1. Introduction In 1987, Henry Massalin, of Columbia University, described a super-optimizer \nthat generates optimal instruc\u00adtion sequences given a function to be performed [1]. The sequences are \nfound by doing an exhaustive search over a subset of the instructions of the machine for which the optinkation \nis made. Little or no mention of this impor\u00adtant technique has occurred since, In the present work, we \ndescribe an alternative technique for constructing a superoptimizer, which will call the GNU Superoptimizer \nor GSO. We,believe this optimizer is faster and more versatile than Massalin s original work. We show \nhow GSO was used to add patterns to GCC, the GNU C compiler, so it can eliminate many branch instructions \nwhen generating code for the IBM RS/6000. A number of surprising results were obtained many of which \nwere unknown to the architects of the RS/6000 processor. In the first section we present some sample \nresults of the superoptimizer. The next section discusses the basic design and structure of the GNU C \ncompiler. Subse\u00adquently, we show how the results of the superoptimizer were used to enable the GNU C \ncompiler to produce very compact code sequences on the RS/6000. After a brief dis\u00adcussion of the use \nof some specitic RS/6000 instructions, the final two sections discuss how the GNU superoptimizer works \nand the litations of superopdmization, and present a large number of instruction sequences generated \nby the superoptimizer for the RS/6000. Although this paper uses the RW6000 for all its examples, the \ntechniques described here are applicable to Permission to copy without fee all or part of this matarial \nis grantad provided that the copies are not made or distributed for direct commercial advantage, the \nACM copyright notica and the title of the publication end ita date appear, end notice is given that copying \nis by permission of the Association for Computing Machinary. To copy otharwise, or to republish, raquiras \na fae and/or specific permission. ACM SIGPLAN 92 PLD1-6/92/CA a 1992 ACM 0.8979J-476-7\\92/00061034~ \n.=.$7 .50 Richard Kenner Ultracomputer Research Laboratory New York University 715 Broadway, 10th Floor \nNew York, NY 10003 Icenner@vlsil ultra .nyu. edu most machines. 2. Sample Results of GSO We lirst study \nthe output produced by the superopthnizer when it searches for sequences that compute the value of the \nC expression (signed int ) a >= O. The input is assumed to be in register 3 and the output is placed \nin register 5, The RS/6000 is a three-operand machine. Usually the presence of the letter i in an operation \ncode signifies an immediate constant, il , means that the operation is performed on the low-order 16 \nbits of a quantity, and iu means that the operation is performed on the high-order 16 bits. Here is the \nsuperoptimizer output for the C expres\u00adsion (signed int ) a >. 0 on the RS/6QO0. 1: sri r4, r3,31 xoril \nr5, r4,1 2: arai r4, r3,31 a~ r5, r4,1 3: srcd r4r x3,31 cal r5,1(r4) 4: xoriu r4rr3r Ox8000 ari r5, \nr4,31 !5: nand r4rr3, r3 Sri r5, r4,31 6: afi r4, r3, -1 sri r5, r4,31 GSO found six ways to perform \nthe operation, each of which takes two instructions. The first sequence com\u00adputes (a < o) by shifting \nthe sign bit to the low-order bit, and then complements it by doing an xor with the con\u00adstant one. The \nsecond and third sequences first duplicate the sign bit into the entire word (thus yielding 1 if a is \nnegative, and O if a is greater than or equal to O) and then add 1 to get the desired result. The difference \nbetween sequence two and three is in the instruction used to add 1. In the fourth sequence, the sign \nbit is first inverted and then shifted right into the low-order bit. The fifth and sixth sequences one \ns complement the entire value and then shift the sign bit into the low-order bit. They differ only in \nthe manner in which the one s complement is computed. In the fifth sequence a logical opemtion is used, \nwhile an arith\u00admetic operation is used in the sixth sequence. These sequences do not use the carry bit. \nTherefore they are machine-independent and can be used on any machine that has logical negation and logical \nright shift instructions. Indeed, this particular method for computing (s ianed int) a >. 0 has been \nknown for quite some time. It is included here as an example of the superoptim\u00adizer output. More interesting \nsequences involve use of the carry bit of a machine. On the RS/6000, the carry bit is simply the carry \nout of the high-order bit of the adder. A subtrac\u00adtion is defined as an addition of the rninuen~ the \none s complement of the subtrahend, and either the carry bit or the constant one. The result of this \naddition determines the generated value of the carry bit, When GSO is asked to compute the value of the \nexpression r3 s= 0, a single two-instruction sequence is found. It is 1: Sfi r4,r3,0 ae r5,r4,r3 This \nsequence is quite typical of the type of carry-bit manipulations that occur in these types of conditional \nexpressions. It works as follows: The first instruction com\u00adputes the sum of the one s complement of \nrs and 1. It sets rd to the result of this addition, which is -rs, and sets the carry bit to the carry \nout of the high-order bit of the addi\u00adtion, which, in this case, has the effect of setting the carry \nbit to 1 if r3 equals zero, and to O otherwise. The second instruction sets r5, the final result, to \nr4 + r3 + carry . rs + rs + carry, which is equal to the carry bit from the first instruction, or our \ndesired final result. More sequences will be presented throughout this paper and a large listing of sequences \nis presented in Sec\u00adtion 8. 3. The GNU C Compiler The GNU C compiler (GCC) is a highly portable, retarget\u00adable, \noptimizing C compiler. The recently released GCC version 2 supports virtuatly all general-purpose micropro\u00adcessors \ncurrently in use and includes front ends for C, C++ and Objective-C, with front ends for FORTRAN and \nAda under development. The code quaMy of GCC is quite competitive with commercial C compilers; in most \ncases the code produced for the Spare and Motorola 88100 (and possibly others) runs faster than code \nproduced by any other compiler. At least two vendors (NeXT and Data Gen\u00aderal) distribute GCC as the C \ncompiler for their systems. Rather than using a fixed intermediate language and compiling it for a variety \nof machines, GCC instead defines a representation called R TL, for register transfer language, in which \nthe actual instructions of the target machine are represented. The source program is initially compiled \ndirectly into RTL representing the target machine instruc\u00adtions and using an unlimited number of registers. \nThe remaining compilation phases perform opdmizations and register allocation. The idea of using RTL \nand some of the optimization came fkom the Portable Optimizer (PO), writ\u00adten at the University of Arizona \nby Jack Davidson and Christopher Fraser [3]. The implementation of GCC is much more fully described in \n[2]; here we summarize the points of interest to the remainder of the present paper. Instructions in \nGCC, referred to as insns, are represented in RTL and are an expression tree consisting of the various \nRTL operators along with pointers to the next and previous insns and some data.flow information. RTL \nis usually written in a LISP-like notation; a typical add insn looks likez (insn 11 10 12 (set (reg/i.:SIO) \n(PIus:SI (reg:SI 22) (const_int 10))) 152 {addsi3} (insn_list 9 (nil)) (expr_list:REG_DEAD (reg:SI \n22) (nil) ) ) This indicates that register O is set to the sum of register 22 and the constant integer \n10. The unique number assigned to the insn is 11, the next insn is nnmbercd 12, and the previous insn \nis 10. This insn matches pattern number 152 (named addsi3 ) in the machine description file. The value \nused in this insn (register 22) was set in insn number 9 (and this is the tirst use) and register 22 \ndies in this insn. Machine description files contain a list of patterns, which describe the instructions \navaitable on the machine and how to generate code for basic operations. A typical pattern, if named, \nsays what RTL to generate for a particu\u00adlar operation (for example, addsi3 means to do a three\u00adoperand \naddition of 4-byte integem). All patterns are used to specify what insns are valid and how to generate \nassem\u00adbly code for the insn. Each insn generated must match some pattern. The compiler ensures that all \ntransformations applied to the insn chain as part of the optimization process continue to allow each \ninsn to match some pattern. The addsi3 pattern from the description file for the AMD 29000 (the patteru \n for the RS/6000 is slightly more complex) is as follows: complex and is described in more detail in \n[4]. Basically, (clefine_insn ,,addsi3,, [(set (match_operand: S1 O ,4gen_reg_operand*, ,,=r, r,,) (plus \n*S1 (mtch_opere.nd: S1 1 a0gen_reg_operand88 ,%x,r,,) (match_operand: S1 2 Ladd_operandmO 88rl,N,,)))J \n ,,,, ,,@ add %0, %1, %2  sub %0, %1, %n2i,)  Since insns are represented as expression trees, the \nresult of one insn can be substituted directly into its use in a second insn. If the insn that results \nfrom such a substitu\u00adtion matches a pattern in the machine description file, we are able to save an instruction \nin the compiled program. This transformation was originally done by the University of Arizona compiler \nand in GCC is done in a phase called the combiner. The combiner is also able to perform a wide variety \nof algebraic simplifications. Typically, merging two or more insns together into one insn forms complex \naddressing modes on CISC machines. It is also used to form specialized instructions such as NOR or the \nvarious multiply-accumulate instruc\u00adtions that have become common. Optimization phases of GCC which run \nbefore the combiner perform jump optimizations, common\u00adsubexpression elimination, and loop optimization \ninclud\u00ading strength reduction and loop unrolling. Foltowing the combiner is instruction scheduling (to \nreduce data\u00addependent stalls on pipelined machines), register a.ltocation, another jump optimization \nand instruction scheduling pass, and delay-slot filling. 4. Elimination of Conditional Jumps In this \nsection, we discuss the cost of conditional jumps, general methods used to eliminate them, and how we \nused the superoptimizer to produce efficient code on the RS/6000 that avoids jumps.  4.1. Costs of Jumps \nFundamentally, jumps interfere with the pipelined execu\u00adtion of instructions. Most modern processors \nhave features that minimize t.hk COSLfor example by using delayed\u00adbranches, which require the compiler \nto find instructions to place in delay slots. The RS/6000 uses a different, and quite novel, tech\u00adnique \nto streamline the execution of branch instructions. There me four execution units on the RS16000: an \ninteger unit, a floating-point unit, a condition-code uni~ and a branch processor. Each cycle can fetch \nfour instructions and dispatch them to the appropriate unit, Because of this structure, unconditional \nbranches can be performed in paratlel with other instruction execution at a net cost of zero cycles. \nConditional branches, however, often have a non\u00adzero cost. The timing of conditional branches is quite \nthe cost of a condkional branch depends on the number of cycles between the setting of the condition \nflag and the branch that tests it. If sufficient time has elapsed, the branch takes zero cycles. Otherwise, \nthere is a delay of three cycles between the setting of the condition flag and the branch for taken branches \nand zero cycles for not taken branches (however, in the case of not taken branches, there must be a total \nof five cycles of instructions between the compare and the next branch after the not-taken branch to \navoid additional delays). On the RS/6000, instruction scheduling can some\u00adtimes be used to reduce the \nrequired delay, although this is usually not successful since most basic blocks are short and many scheduling \nalgorithms only operate within one basic block. For machines with delay slots, delay slot scheduling \ncan be used to reduce the cost of delay slots. GCC per\u00adforms both optimizations. Even when the cost of \na branch can be reducxx%it is nevertheless useful to eliminate as many jumps as possible. Not only has \nthe branch cost not been reduced to zero by architectural features but it is desirable to increase the \nlength of basic blocks. This is because optimization are easier to perform within a single basic block; \nmost of the optimization in GCC, such as the combiner and instruction scheduling, only operate with a \nbasic block. The newly-announced DEC Alpha uses neither the technique used by the RS/6000 nor delay slots. \nInstead, it relies on branch-prediction techniques, and DEC warns that mis-predicted branches can cost \nten cycles. Eliminat\u00ading conditional jumps on the machine is therefore quite important. 4.2. Techniques \nfor Elimination of Jumps The techniques for eliminating jumps rely on the fact that jumps are often used \nto skip a relatively short section of code. These methods often involve what are sometimes called set-condition \ncode (SCC)instructions, which set a data register to one value if a comparison is true and tQ another \nvalue if the comparison is false. Machines that include instructions specifically for this purpose are \nthe Motorola 68k and 88k families, the Intel i386 family, the AMD 29k family, the MIPS processors, and \nthe newly-announced Alpha from DEC. The true value is usually either plus or minus one but is sometimes \na value consisting of just the sign bit. We sometimes want scc instructions that produce plus one for \ntrue and zero for false and sometimes want versions that yield minus one or zero. The following table \nshows how to obtain these values from all three versions of hardware instructions. Each entry shows the \ninstruction required to convert the h,ardw,are true value into the desired representations. applied in \nsequence (we will represent logical right shifts as Hardware Desired Truth Value 1>> and arithmetic right \nshifts as a>> and assume 32-bit Value +1 -1 words): +1 no-op negate . To obtain a one if a single-bit \nvalue is not equal to zero -1 negate no-op and a zero if it is, we shift the value to the low-order sign \nbit logical right shift arithmetic right shift bit. Theexpression isnow 4 &#38; -((a &#38; 8) 1>> 3). \nIn this section, we assume that all scc instructions return either plus one or zero, i.e., the value \nreturned from a C relational expression. The most straightforward application of scc instruc\u00adtions is \nto generate code for C relational operators assigned to a variable, for example, a = (b >. c). To compile \nthis statement, we simply apply the ge scc operation to b and c and place its output in a. The compiler \ncan also do this transformation if the statement is coded as a . ( (b >= c) ? 1 : o) orbya series of \nstatements such as if (b>= C) a-l; else a= (); This transformation is actually a special case of a more \ngeneral principle. If an expression is to have the value zero if some condition is true and some other, \npossi\u00adbly its previous, value if the condition is false, an scc instruction can also be used. For example, \nconsider the expression a>. b?c : 0. We can evaluate this expression by taking a value consisting of \nall one bits when the condition is true and zero when it is false and performing a logical and of this \nvalue with c. That is, the given expression is equivalent to c&#38; -(a >. b). The transformation can \nalso be done if the equivalent If statement is used. Even more generally, code such as if (cond) foo \n=o; is equivalent to foo &#38;= -( ! cond). The next section will show how this general principle along \nwith the use of GSO-generated sequences can result in quite compact code for some conditional expressions. \nHowever, this principle can be used even in the absence of scc operations, because of the algebraic simplifications \ndone by the GCC combine phase. Consider what happens when the expression (a &#38; 8)!=0?4 : 0 is compiled \nfor the RS/6000 (the first operand of the conditional operator might be the result of testing a single-bit \nfield). Using the transformation dis\u00adcussed above, this expression is equivalent to A &#38; -( {a &#38; \n8) != o). The following transformations are then A single-bit value can be negated by shifting that bit \nto the sign bit and then arithmetically shifting it back (to the low-order bit in this case). The expression \nis now 4 &#38; ((((a &#38; 8) 1>> 3) << 31) a>> 31). The two logical shifts are equivalent to a single \nright shift of 28 bits, yielding 4 &#38; (((a &#38;8) << 28) a>> 31). Logically and ing a sign-extended \nvalue with a single-bit constant in the range of the extended sign bits can be done by a logical shift \nof the sign bit to the desired position. The expression is now ( ( (a &#38; 8 ) << 26) 1>> 29) Finally, \nthe two logical shifts can be merged into one logic~ shift and one logical and operation. The origi\u00adnal \nexpression is thus equivalent to (a 1>> 1 ) &#38; 4. This expression can be evaluated in one instruction \non the RS/6000. The rl~nm instruction rotates a register by a specified constant number of bits and logically \nand s it with a mask, where a mask is either a single consecutive group of one bits in a word of zeros \nor vice versa. This sin\u00adgle rl i.nm instruction is the code generated by GCC for the original expression. \nNot only does using these transfor\u00admations convert what would otherwise be four instructions (which are \ngenerated by IBM s compiler) into a single instruction, it has eliminated an expensive branch, yielding \nanaverage-case savingsofmore thanafactorof four. 4.3. SCC Instructions for the IUIV6000 Most of the transformations \nshown above assume the existence of short sequences of instructions that set a regis\u00adter to 1 or O depending \non the result of a comparison. On the RS/6000, this can be done by doing a compare, possibly performing \na logical operation on the condition register bits, copying the condition register into a general register \n(mfcr), and extracting the relevant bit. Unfortunately, there is a two cycle delay between the compare \nand the mf cr and an additional single cycle delay before the result of the mfcr can be accessed to extract \nthe desired bit. Thus, these operations take 6 or 7 cycles, which is more than code using branch instructions \nwould take. (It might be possible to move other instructions to hide the latencies, but these instructions \ncould also be used in the delay between compare and branch.) If we use these code sequences, the advantage \nof having longer basic blocks would be outweighed by the factor of two cost in cycles. For this reason, \nit was recommended by researchers at IBM that this method not be used in GCC. To see if better sequences \nexis~ we had GSO search for the shortest sequences implementing the ten binary comparisons and the six \nunary comparisons with zero (the unsigned comparisons with zero are degeneratti for a unsigne&#38; a \n< 0 is always false, a >= 0 is always true, a > 0 is equivalent to a != O,and a <= o is equivalent toa \n==0), We found that all 16 operations can be done in no more than 3 instructions, three of the comparisons \nwith zero (=., 1., and >.) cm be done in two ins~uctions, and one comparison with zero (<) can be done \nin one instruc\u00adtion (the sequences for >. 0 and == o were shown earlier and all of these sequences are \nshown in Section 8). None of the instructions used in these sequences require any communication outside \nthe integer execution unit (such as compare and the mfcr instruction discussed earlier); indeed only \ninstructions executed by the integer unit were included in GSO. The fact that such sequences exist was \nan unexpected result since discussions with some of the architects of the RS/6000 at IBM led us to believe \nthat no such sequences existed for many of these operations (some of these sequences, such as those for \n< 0 and !=, were well-known previously). These sequences enable us to produce code for C statements of \nthe form a = b rel-op c; for M 16 rel-op s that contain at most three instructions and execute in no \nmore than three cycles. Recall from the previous section that we often need variants of these operations \nthat produce a value of minus one for true and zero for false. One way to obtain such a result is to \nsimply negate the result of the sequences that produce positive one for true and zero for false. However, \na close look at the first example in Section 2 suggests that we might be able to End smaller sequences. \nIn that example, one of the ways we computed ( signed int) a >= O was by complementing A and shifting \nthe sign blt to the low-order bit. If a logical shift is use@ as in that code sequence, this produces \na value of positive one for true and zero for false. On the other hand, if an arithmetic shift were used, \nit would produce negative one for true and zero for false, which is the required result. In this case, \nat leas~ the cost was the same whether a true value was represented by positive or negative one. To see \nif thk was the case in general, we used GSO to find the shortest sequences that compute C expressions \nof the form -(a rel-op b). The result was that in 14 of the 16 cases, sequences were found of the same \nlength as func\u00adtions that computed the non-negated condMonal valu~ in the remaining two cases, unsigned \n> and unsigned <, the sequences computing the negated result were one instruc\u00adtion shorter (two instructions \ninstead of three). Expressions of the form shown above are rarely encountered in C programs. However, \nas discussed above, code that conditionally clears a register can be transformed into expressions of \nthe form a &#38; -(b rel-op c). These can be implemented by using the sequences for the previ\u00adous set \nof operations and performing the indicated logical and operation.Inspectionof some of these sequences \nshowed that they often end with nand instructions, so we wondered if it might be possible to perform \nthe required and operationwithoutaddingmoreinstructions butinstead modifyingthesequence. We therefore \n addedcode to GSO to search for the shortest sequences of the form a &#38; -(b rel-op c ) for all 16 \ncomparison operations. The result was that in two cases, unsigned >= and <=, the sequences including \nthe and had the same length as those without i~ namely three instruc\u00adtions. In the other 14 cases, an \nadditional instruction was required, as expected. The most interesting result was obtained when we looked \nat the sequences for the 16 basic comparison opera\u00adtions and noticed that there was a sequence for almost \nall of them that ended with an add or subtract instruction. We were curious whether this instruction \ncould also be used to add another value to the result of the comparison, i.e., how many instructions \nwould be needed to compute a + (b rel-op c). This operation is rather common, especially when written \nin its equivalent form as if (b rel-op c) a~~; After adding code to GSO to search for the shortest sequences \nimplementing these expressions, we discovered that in only two cases (< o and >= o) dld the addition \nlengthen the sequence. Even more surprisingly, in two other eases (unsigned <. and unsigned >=), the \ncode to compute the sum was shorter than that to compute the basic comparison. ( (unsigned) tions For \nexample, to b <= (unsigned) c), compute the two k@UC\u00ad a + Sf aze rO,r4,r5 r6,r3 are used. (a is in r3, \nb in r4, c in r5, and the result is in r6.) The first instruction subtracts b from c and the second instructions \nadds the carry flag to zero plus A using an aze instruction. The RS/6000 has no single instruction to \ncopy the carry flag into a general register, so the sequence for com\u00adputing the comparison must use an \nextra instruction to set a register to zero. That is why including the addition pro\u00adduces a shorter code \nsequence. To take advantage of the surprising fact that the addi\u00adtion has no cost, we added code to GCC \nS jump optimization routine to convert the if statement to the equivalent conditional expression shown \nabove. 5. Adding GSO-produced Sequences to GCC Getting GCC to produce the code sequences we presented \nis a fairly straightforward task. The first step is to choose the appropriate sequence to use, since \nmany of these opera\u00adtions can be implemented by a number of different code sequences. We used three criteria \nto choose the best sequence: (1) Some of the instructions on the RS/6000, particu\u00adlarly arithmetic instructions \ninvolving the carry bit, do not permit immediate operands. Some operands of these functions (such as \nthe second operand being compared and the value added to the com\u00adparison result) will often be immediate \nconstants. Sequences that only use these operands in contexts where immediate forms of the instruction \nexist are preferred to sequences that do not. (2) The fewer scratch registers a sequence required, the \nmore preferred the sequence. (3) A sequence that could put its output in the same register as an input \nis preferred to one that requires the input and output to be in different registers.  The second step \nis to add the instruction patterus to generate the code sequences. Because of the way GCC S combiner \nphase operates, this is a straightforward, though sometimes tedious, task. For example, to generate the \ncode for the case shown above, the following pattern was added to the RS/6000 definition file: (define_insn \n,, , [(set (match_operand: S1 O ,Lgen_reg_operand.,, ,,=r$l) (plus, sl (le.J:sl (m.atch_operand: \nS1 1 ,,gen_reg_ope!?and C,,,z,,) (match_operand: SI 2 ,!xeg_or_short_ope rand,, ,$rl,,)) (match_operand \nzS1 3 Egen_reg_operand,, a,r,,))) (clobber (match_scratch: S1 4 ,,=&#38;r,J))] ,,,,  ,,=f%12 *4, \n%1, %2; aze %Oj%3 ~ )  This pattern matches the RTL resulting from compil\u00ading the expression a+((unsigned) \nb <= (unsigned) c.OperandO(theresult), operand 1 (b), and operand 3 (a) are all required to be in general-purpose \nregisters. Operand 2 (c) can be either in a register or be a constant short enough to fit in the immediate \nfield of an arithmetic instruction. One scratch register is needed for this instruction, specified by \noperand 4, The last line of the pattern lists the assembler instructions this pattern should generate. \nThe string %nmeans that the assembler text for operand n should be output. %12 isreplaced by the single \nletter i if operand 2 is an immediate constant, otherwise nothing is output. As an example of the use \nof this pattern, we com\u00adpiled the function int subl (a, b, c) int a; unsigned b, c; { if (b<= C) a++; \n return a; }  with GCC. This program produced a single insn in GCC s internal representation: (Insn \n21 13 22 (parallel[ (set (reg/i:SI 3) (PIus:SI (leu:SI (reg:SI 4) (reg:SI 5)) (reg:SI 3))) (clobber (reg:SI \nO)) 1 ) 264 {sleu+30} (nil) (expr_list:REG_DEAD (reg:SI 4) (expr_lfst:REG_DEAD (reg:S1 5) (expr_list:REG_UNUSED \n(re9:S1 O) (nil)))))  The callingsequenceon theRS/6000 has input parameterspassedin successive registers, \nstarting with register 3; the result is returned in register 3. In this case, register O (a normal register \non the RS/6000 for all pur\u00adposes except as a memory address) is used as a scratch register, The generated \ncode for the entire sub1 function consists of the following three instructions: Sf rO, r4, r5 aze rli, \nr3 br The lirst two instructions were generated by the pat\u00adtern shown above and the third instruction \nreturns from the function. 6. The doz, abs, and nabs Imatructims One of the more interesting instructions \non the RS/6000 is the Difference or Zero (doz) instruction. The instruction doz rt, ra, rb computes the \nC expression rt = (ra > rb) ?O: rb -ra. This instruction has the potential to eliminate a number of branch \ninstructions. The signed max of two vatues can be obtained by following this instruction with an add \nof ra, computing rt = (ra > rb) ? ra : rb. To compute the signed min of two values, the result of the \ndoz instruction can be subtracted from rb, computing rt = (ra > rb) ? rb : ra.By having GCC detect the \nidiom ofa>b?a : b ,and convert it into a max operation (similarly for rnin), we ccan emit this two\u00adiustruction \nsequence, ag,ain avoiding branches. For unsigned min and max, GSO produced a 7.1.1. Goal Functions in \nGSO number of four-instruction sequences, some of which involve the doz instruction. These are also generated \nby GCC. The idiom a > 0 ? a : -a is also detected and the abs instruction is generated. Similarly a > \n0 ? -a ~ a produces the nabs instruction, again eliminating potential branches. We were recently informed \nthat the upcoming RS/6000-based processor being designed by the new IBM/AppIe/Motorola consortium will \nnot support the doz, abs, and nabs instructions in hardware (they will trap and be emulated in software) \nand it was suggested that GCC should therefore avoid these instructions. To evaluate the impact of the \nabsence of these instructions, we created a variant of GSO that did not have these instructions and reran \nGSO on alt the expressions described above. We reproduced the VVell-kUOWUthat can reS@ abs be done in \nthree instructions and signed rninand rnaxcan be done in four. More surprisingly, we found that all four \nof the signed comparisons (>=, >, <=, and <) use doz, abs,or nabs and require a fourth instruction if \nthese are not available. 7. Operation of the GNU Superoptimizer Massalin s superoptimizer accepts a sequence \nof assembler instructions describing a function and exhaustively gen\u00aderates all sequences of instructions \nof increasing length until one is found that performs the desired computation. Several heuristics prevent \ntesting clearly impossible sequences. His superoptimizer is written in the assembler language for the \ntarget machine and operates by executing the sequences on the target. The GNU superoptimizer (GSO) has \nimprovements in the areas of portability, configurability and search strategy.   7.1. Portability and \nConfigurability of GSO GSO is approximately 3000 lines of C code and is host\u00adindependent. Unlike Massalin \ns superoptimizer, GSO searches for sequences of instructions that compute one of several goal functions \nthat have been compiled into GSO. The desired goal is selected with a command-line option with a mnemonic \nname. GSO generates code sequences for many different target machines and is designed so that additional \ntargets can easily be added. Currently, GSO supports the IBM RS/6000, the Spare, the Motorola 68k and \n88k, the AMD 29k, and the Intel 80386. Portability is accomplished by defining generic operations which \ninclude the union of all instructions supported by GSO for all supported machines. C code is written \nto simulate each of these operations. One example of a goal function is eqo,which returns the value 1 \nif its single argument is equal to zero and O other\u00adwise. To implement this goaI function, the routine \neval_goal_functioninGSO contains: case EQO: ~=vo..o; break;  Another goal function discussed above was \nthe result of performing a logical and between one value (in this case the third operand) and the negation \nof the comparison of the first two operands. This goal function for a signed <. comparison is called \nnalesand is implemented as: case NALES: r = ( ((signed) VO <= (signed) vI)) &#38; v2; break; Hereisa \nlistofsome ofthegoalfunctionssup\u00adcurrently ported eq and ne. Two-operand equality comparisons. les, ges, \nits, and gts. Two-operand signed inequality comparisons. leu, geu, ltu, and gtu. Two-operand unsigned \ninequality comparisons. eqo, neo, leso, geso, ltso,and gtso. Single\u00adoperand comparisons against zero. \nAs dkcussed above, the unsigned comparisons against zero are degenerate. neq, nne, riles,nges, nits, \nngts, nleu, ngeu, nltu, ngtu, neqO, nneO,rilesO,ngesO,nitsO, and rmts O. Same as above except that they \nreturn negative one for true and zero for false. e naeq, nane, nales, nages, nalts, nagts, naleu, nageu, \nnaltu, nagtu, naeqO, naneO, nalesO, nageso, naltso, and nagtso. Three\u00adoperandfunctionsthatcomputethelogicaland \nofone operandwiththenegatedresultofthecomparisonof theothertwooperands.An example was shown at the start \nof this section. peq, pne, pies, pges, pits, pgts, pleu, p9eu7 pltu, pgtu, peqO, pneO,piesO,pgesO,pitsO, \nand pgtso. These functions add one operand to the result of comparing the other two operands. E.g, pitsO(a, \nb, c) would rewritten ( (signed) a < (signed) b) + c inc. . reins, maxs, minu, and maxu. Signed and \nunsigned min and max operations. sm. Returns positive one if the single operand is posi\u00adtive, zero if \nthe operand is zero, and negative one if the operand is negative. e abs. Absolute value function. . \nnabs. Negated absolute value function. New god functions are included by adding a tag to an en-adding \nthe name and tag to a table used to parse command line options, and adding a case to the switch on goal \ntags to compute the desired function. 7.1.2. Target Machine Operations in GSO This version of GSO was \nwritten to find instruction sequences for code involving condh.ionrit operations. The parts of the machine \nthat are known to GSO are the carry bit and a set of registers. All operations manipulate these objects. \nWe do not support operations referencing memory since these will not be part of an optimal sequence of \ninstructions that compute functions on registers. If an input or an output is actually in memory, the \nsequence produced will normally have to be augmented with load or store instructions on RISC machines. \nOn CISC machines, it may be possible to perform an operation directly on operands in memory. In both \ncases, the essence of the instruction sequence is not effected. The operations that GSO uses to create \nsequences are expressed in terms of generic operations, each of which is available on some subset of \nthe supported machines. Twelve addition operations are provided, divided into three groups of four. We \nbelieve that these operations are general enough to describe the addition operations on all current processors. \nWithin each group, an operation can either use or not use the value of the carry bit, and either update \nthe carry bit or leave it unchanged. The three groups are addition (ADD),subtraction (SUB), and the addi\u00adtion \nof one value to the complement of the other (ADC). A typical operation is denoted by ADC_CIO, which com\u00adputes \nthe sum of the carry bi~ one operand and the com\u00adplement of the other and sets the carry bit corresponding \nto the result of the addition. Each machine has either ADDand or SUB operations ADDandADCoperations.betweentheSUB \n The distinctionand ADC operationsisinthemeaning of the carry bit. On machines with an ADC operation,bit \nis the carry thecarry out of the high-order bit when the ALU performs the sub\u00adtraction, which it does \nby adding the first operand, the one s ,complement (bit-wise inverse) of the second operand and the constant \n1. An ADC_CIoperation computes the sum of the first operand, the one s complement of the second operand, \nand the carry bit. on machines with a SUBoperation, the carry bit is negated during subtractions so that \nit represents borrow . A SUB_CI operationsubtractsthecarry (really bor\u00adrow ) from the difference of \nthe two operands. Of the machines supported by GSO, the Spare, 68k, andi386haveSUBoperationshaveADC \nandtheremainder  operations. It is interesting to note that this difference in behavior of the i386 \nand RSJ6000 was a surprise to at least one quite proficient assembler language progrmer who has written \ncompilers for both machines. These operations are executed by a block of C code. Here is the code for \nthe ADC_CIO operation, which is the same as the ADC_CI operation mentioned above, except thatit also \nsets the carry bit as an outputi #clef ~ne PERFORM_ADC_CIOco, rl, r2, (d, cl) ( word _d = (rl) + (r2) \n+ (cl); (co) = (ci) ? _d <= (rl) : _d < (rI); (d) = _d; } The following is the complete list of operations \nin the current version of GSO: copy. Copy one register to another, or move an immediate value into a \nregister. EXCHANGE. Exchange two registers.on Used only two-operandmachines.  ADD, ADD_CI, ADD_CO, \nADD_CIO, ADC, ADC_CI, ADC_CO, ADC_CIO, SUB, SUB_CI, SUB_CO, and SUB_CIO. These are the additionand subtraction \noperations dkcussed above. CMP. Set carry bit true if the tist operand is less than the second, when \ninterpreted as unsigned numbers. COMCY. Complement the carry bit. AND, IOR, XOR, ANDC, IORC, EQV, NAND,and \nNOR. Various logical operations. The carry bit is not affected. AND_RC, IOR_RC, XOR_RC, ANDC_RC, IORC_RC, \nEQV_RC, NAND_RC,and NOR_RC. Similar,butreset the carry bit. LSHIFTR. Logicalrightshift. ASHIFTR. Arithmeticshift. \n rightLSHIFTR_CO and ASHIFTR_CO. Logical and arith\u00admeticrightshif~butcopylastbitshifted out into the \ncarry bit. ASHIFTR_CON. ArithmeticrightshiftoftheRS/6000. Set carry bitiftheshiftedvalueisnegativeandifany \nbitsshiftedout were non-zero,otherwiseclearthe carry bit. ABS and NABS. Unary absolutevalueand negative \nabsolutevalue,respectively. Doz.TheRS/6000dozinstruction,above. described CPEQ, CPGE, CPGEU, CPGT, \nCPLE, CPLEU, CPLT, CPLTU,and CPNEQ. Ifthespecifiedoftwo comparisonoperandsistrue,settheresulttoa value \nthat contains just the sign bi~ otherwise set the result to zero. These instructions are present in the \nAMD 29k family processors. The search routines know which machmes have which operations and what operands \nare supported for each operation. A target-specific (via if clef) function in GSO produces assembler-language \noutput of the sequences for the selected target machine. To add support for a new machine, the following \nmust be done: Define generic operations for any instructions present on the new machine but on no previous \nmachme and write C code to emulate them. Modify the conditionalization of the search routines to reflect \nwhich operations are present in the new machine and add any new operations. Write code to output the \noperations in tile assembly language of the target machine. 72. Search strategy of GSO Both Massalin \ns superoptimizer and GSO search for the shortest sequence by first searching for sequences of length \n1, then sequences of length 2 and continuing until a sequence is found, or a specified bound is exceeded. \nThe strategies used when searching for a sequence of a given length differ. Massalin s superopdmizer \ngenerates every possible sequence of the desired length. For each sequence it applies a pruning procedure \n(described in his paper) tQ eliminate obviously incorrect sequences and then tests the sequence for correctness. \nLike Massalin s superoptimiier, GSO initially gen\u00aderates random arguments for all input operands of the \ngoal function. All computations are performed on these values and values computed by instructions GSO \nhas generated for a putative sequence. No symbolic manipulations are per\u00adformed. GSO searches for instruction \nsequences using a recursive iterative-deepening metho&#38; and avoids generat\u00ading clearly useless instructions \nthat would otherwise have to be pruned later. Only operands that are either inputs to the sequence or \nhave been generated by previous instruc\u00adtions are tried. Similarly, if the carry bit has not yet been \nse~ an instruction that uses it will not be generated. If the iterative-deepening search has reached \na leaf node, the ulti\u00admately computed value is compared to the value returned by the goal function for \nthe same input operands. If the values are not equal, the generated sequence is immediately dkcarded. \nInitially the sequence consists of no instructions, the carry flag is undefined, and the only available \noperands are the inputs to the sequence. At each level of recursion, the search function, Swtl% scans \nthe list of all available operations for the target machine, adds an operation to the sequence, and makes \na recursive call to add more opera\u00adtions if a leaf node is not reached. The operation is also Goal Generated \nCode eq Sf r5,r3,r4 sfe r6,r4,r3 ae r7,r6,r5 ges doz r5,r3,r4 ges O sri r4,r3,31 sfi r6,r5,0 xori1 r5,r4,1 \nae r7,r6,r5 F geu Sf r5,r4,r3 gtu Sf r5,r3,r4 rlinm r6,r5,0,0,0 sfe r6,r6,r6 ae r7,r6,r6 neg r7,r6 gts \ndoz r5,r4,r3 gtso sfi r4,r3,0 nabs r6,r5 ame r5,r4 sri r7,r6,31 sri r6,r5,31 F les doz r5,r4,r3 les \nO ai r4,r3,-1 sfi r6,r5,0 aze r5,r4 ae r7,r6,r5 sri r6,r5,31 1eu Sf r5,r3,r4 ltu Sf r5,r4,r3 rlinm r6,r5,0,0,0 \nsfe r6,r6,r6 ae r7,r6,r6 neg r7,r6 lts doz r5,r3,r4 ltsO sri r4,r3,31 nabs r6,r5 sri r7,r6,31 + ne \nxor r5,r4,r3 nabs r6,r5 sri r7,r6,31  Table 1: Sequences for Simple Comparisons, (A rel-op B) simulated \nand the resulting value is saved. Two versions of synth areprovided, one for 2-operand machines (the \n68k and i386, of those supported) and one for 3-operand machines. On 3-operand machines, register move \ninstruc\u00adtions are never present in an optimal instruction sequence, so they need never be generated. \nAt each leaf of the search tree, the result of the last operation is compared with the result of the \ngoal function applied to the random input values. If they agree, a poten\u00adtially valid sequence has been \nfound and a more exhaustive test will be performed to see if the sequence is most likely to be correct. \nThk testis similar to that used by Massalin: tint some typical operand values are tried and then rwdom \nvalues are tested. If the sequence passes, it is printed. To reduce significantly the amount of searching \nrequired, the choices of opemnds are limited to values gen\u00aderated by previous instructions. Operations \nthat accept the carry bit as an input will not be generated unless a previ\u00adous operation set the carry \nbit. For commutative opera\u00adtions, only one ordering of the operands will be tried. The destination of \nall operations is always the next available register for a 3-operand machine, and one of the input operands \nfor a 2-operand machine. When generating the last instruction even more restrictions are made. SpecificaUy, \nthe last instruction must use the output or carry bit produced by the penultimate instruction, other\u00adwise \nthe penultimate instruction would not have been needed. These techniques allow for quite rapid generation \nof sequences. All the sequences shown in this paper were generated in only a few seconds on a modern \nworkstation, although searching for sequences of five instructions for goal functions with three inputs \ncan take a good part of an hour. 7.3. Limitations of Superoptimizers A fundamental problem with the technique \nof superoptimi\u00adzation is that the search space is approximately exponential in the sequence length, and \nthat the branching factor, i.e., the number of instruction choices at each point, is relatively l,arge. \nThe approximate number of tested sequences is bk, where b is the branching factor and k is the number \nof insns generated in an output sequence. If b is large, the number of tested sequences becomes huge, \nand the search space will be too large for any longer sequences. Keeping the branching factor as small \nas possible is the most important way to make a superoptimizer able to Goal I Generated Code Goal Generated \nCode I neq xor r5rr4rr3 ai r6,r5,-1 sfe r7,r7rr7 nges doz r5,r3,r4 nges O sfi r4,r3, 1 al r6,r5, 1 sral \nr5,r4,31 sfe r7,r7,r7 ngeu Sf r5,r4,r3 sfe r6,r6,r6 nand r7,r6,r6 ngts doz r5,r4,r3 nabs r6,r5 srai r7,r6,31 \nriles doz r5,r4,r3 rilesO ai r4rr3, 1 al r6,r5,-1 aze r5,r4 sfe r7,r7,r7 sraI r6,r5,31 nleu Sf r5,r3,r4 \nnltu Sf r5,r4rr3 sfe r6,r6,r6 sfe r6,r6,r6 nand r7,r6,r6 nits doz r5,r3,r4 nits O srai r4,r3,31 nabs \nr6,r5 srai r7,r6,31 nne xor r5rr4,r3 nne O nabs r4,r3 nabs r6,r5 sraI r5,r4,31 srai r7,r6,31 generate \nlonger sequences. GSO S approach is to avoid instructions with constants, with the exceptions of 1, O, \n+1, 231, and 231 1, As a result, the branching factor lies between 100 and 1000, depending on the target \ninstruction set and the current search depth, If all possible 32-bit con\u00adstants were used blindly, the \nbranching factor would exceed 232 and superoptimization would become impractical. For the kind of goal \nfunctions currently defined in GSO, the limited set of constants is not believed to be a problem. For \nother goal functions, we would have to be smarter. To adequately choose the right set of constants for \na particular goal function is an interesting area for future work. Aside from the intentional omission \nof constants, it is possible that instructions have been omitted unintention\u00adally, and hence some of \nthe sequences produced may not be optimal. For example in Massalin s superoptirnizer, which tries a significant \nnumber of machine instructions, non\u00adoptimal sequences have been produced. Massalin shows sequences on \nthe 68020 for computing do *. 29, do *= 39, dO *= 156, and dO *= 625. The first three USe5 instructions, \nwhile the last uses 7. What was not noticed is that lea (load effective address) instructions can be \nused to perform multiplications by 3, 5, and (sometimes) 9. Since 625 is the fourth power of 5, it can \nbe computed with four consecutive lea instructions. Because lea only operates on address registers, another \ntwo instructions are required to copy between an address register and dO. Thus, the shortest sequence \nfor multiplication by 625 has 6 instructions. However, if the statement of the prob\u00adlem is weakened to \nthe problem of taking a value in an arbitrary register and putting the result into any register, multiplication \nby 29, 39, and 625 can all be done in four Goal Generated Code Goal Generated Code naeqO al Sf a and \nr5,r3, 1 r6,r6,r6 r7,r6,r4 nages O srai andc r5,r3,31 r6,r4,r5 nageu sf r6,r4,r3 nagtu Sf r6,r3,r4 sfe \nr7,r7,r7 sfe r7,r7,r7 andc r8,r5,r7 and r8,r7,r5 naleu sf r6,r3,r4 nalts O srai r5,r3,31 sfe r7,r7tr7 \nand r6,r5,r4 andc r8,r5,r7 I  m I  l-t---- Table 2: Negated Comparisons, -(A rel-op B) Table 3: Negated \nComparisons with and. instructions. If one wishes to include all machine instructions in a superopdmizer, \nthe GSO approach makes it slightly harder to ensure that all irMructions are included, because of the \nintroduction of the abstract operations. If actual machine instructions were used, it would be possible \nto check them off against a list of all valid machine instructions. With GSO, there is a level of indirection \nthat must also be checked. An early version of GSO demonstrated an interesting case of an omitted operation. \nThat version of GSO did not try operations that set a register to a constant value but it did try logical \noperations between previous values and the constants listed above, In several sequences, an and that \ncleared everything but the sign bit was generated. How\u00adever, in the sequences in question, the subsequent \nuse of the result was in a context where the sign bit was irrelevant. A more straightforward sequence \nwould have been to set a register to O,but this was not one of the operations synth tried in that version. \nGoal Generated Code peq Xor r6, r4, r3 sfi r7, r6,0 aze r8,r5 pges doz r6,r3,r4 pges O dozi r5,r3,0 sfi \nr7,r6,0 sfi r6,r5,0 aze r8,r5 aze r7,r4 pgeu Sf r6,r4,r3 pgtu Sf r6,r3,r4 aze r7,r5 sfe r7,r5,r6 Sf r8,r7,r6 \npgts doz r6,r4,r3 pgtso a r5rr3,r3 ai r7,r6,-1 sfe r6,r3,r5 aze r8,r5 aze r7,r4 pies doz r6,r4,r3 plesO \nsrai r5,r3,31 sfi r7,r6,0 Sf r6,r3,r5 aze r8,r5 aze r7,r4 pleu Sf r6,r3,r4 pltu Sf r6,r4,r3 aze r7,r5 \nsfe r7,r5,r6 Sf r8,r7,r6 pits doz r6,r3,r4 pltso a r5,r3,r3 ai r7,r6,-1 aze r6,r4 aze r8,r5 --i pne Xor \nr6,r4,r3 ai r7,r6,-1 aze r8,r5 Table 4 operations of the form (A rel-op B) + c. 7.4. Correctness of \nthe Sequences One must be careful in using the results of a superoptim\u00adizer, either GSO or Massalin s \noriginal work. Neither pro\u00adgram exhaustively tests the resulting code sequences. Although it is highly \nlikely that they are correct, and an incorrect sequence has never been foun&#38; each sequence should \nbe checked manually to ensure its correctness. 8. Complete Superoptimizer Results for the RS/6000 This \nsection contains tables showing the shortest code sequence for every goal function described in Section \n7.1.1. We list only one of multiple sequences, usually the one that GCC will generate. Table 1 shows \nthe code generated for the 16 simple comparisons. Table 2 shows the same comparisons, but returning a \nnegative one for true and zero for false. In some cases, we can 10giCdlyand thereSU]tOfthe pIW iOUS operations \nwith another value at no extra cosc Table 3 shows those operations. Entries that are missing cannot be \ndone any cheaper than the code in Table 2 followed by an and instruction.oftheform TableA showstheoperations(A \nrel-opB) + C. Fhmlly, Table 5 shows the code sequence for miscellaneous operations.  9. Conclusions \nand Future Work We have described a variation of Massrdin s Superoptim\u00adizer and shown how it can be used \nto produce extremely efficient code sequences that do not contain jumps from Goal Generated Code ~ abs \nabs 4,3 nabs nabs 4,3 maxs do z a r5rr3, r4 r6, r5, r3 maxu xoriu xoriu doZ a r5, r4,0x8000 r6,r3, 0x8000 \nr7, r5, r6 r8, r7, r4 reins doZ Sf r5, r3, r4 r6, r5, r4 minu xoriu xoriu do Z Sf r5, r4,0x8000 r6, r3, \n0x8000 r7, r5, r6 r8, r7, r3 sgn a sfe sfe r4, r3rr3 r5, r3, r4 r6, r5, r3 Table 5: Code Sequences for \nMiscellaneous Operations code that initiatly has jumps. We have shown that instruc-September 1984. tion \nsimulation techniques-can be used to make a superop\u00ad[4] Henry Warren, predicting Execution Tme on the \nIBM timizer both efficient and easily portable. RISC Systern/6000, Preliminary Version, IBM, 1991. There \nare many possible areas for future work. Clearly, more operations and goal functions can be added to \nGSO, and this work is currently in progress. SimiJarly, more machines can be supported, Another interesting \narea for future work is the possi\u00adbility of integrating GSO into the configuration process of GCC. This \nwould allow the compiler to produce these optimal sequences without the manuaJ process of convert\u00ading \nGSO-produced code sequences into instruction patterns for the GCC configuration file. Acknowledgments \nRichard Kenner was supported by the U.S. Department of Energy under grant number DE-FG02-88ER25052. Torbjom \nGranlund was supported by Sits research pro\u00adgram sponsored by the Swedish National Board for Techni\u00adcal \nDevelopment (NUTEK), Swedish Telecom, Ericsson Group, ASEA Brown Boveri, IBM Sweden, Nobel Tech System \nAB, and the Swedish Defence Material Administra\u00adtion (FMV). This work would not have been possible without \nthe original idea of a superoptimizer suggested by Henry Mas\u00adsatin. We also wish to thank Robert Dewar \nof New York University for his urging that these results be published. Christopher Fraser, the Program \nChair of this conference provided considerable advice on how to improve this paper from the initial extended \nabstract. The GNU C compiler was written mostly by Richard Stalhnanandisbeing developed anddistributedbytheFree \nSoftwme Foundation, to which numerous people and organizations have contributed. The League for Program\u00ad \nming Freedom (LPF) is an organizationthatisfighting user interfacecopyrightsand softwarepatents,both \nof which would prevent the development of software like GCC. Contact the LPF for more information at \nleague@prep.ai-mit.edu or at 1 Kendall Square #143, Cambridge, MA 02139. References [1] Henry Massalin, \nSuperoptimizer: A Look at the Smal\u00adlest Program, in Proceedings of the Second International Conference \non Architectural Support for Programming Languages and Operating Systems (ASPLOS II), pages 122-126, \n1987. [2] Richard Stallman, Using and Porting GNU CC, Free Software Foundation, 1992. [3] Jack W. Davidson \nand Christopher W. Fraser, Register Allocation and Exhaustive Peephole Optimization, Sojtware Practice \nand Experience 14(9):857-865,  \n\t\t\t", "proc_id": "143095", "abstract": "", "authors": [{"name": "Torbj&#246;rn Granlund", "author_profile_id": "81100039099", "affiliation": "", "person_id": "P284519", "email_address": "", "orcid_id": ""}, {"name": "Richard Kenner", "author_profile_id": "81332508395", "affiliation": "", "person_id": "PP31084154", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143095.143146", "year": "1992", "article_id": "143146", "conference": "PLDI", "title": "Eliminating branches using a superoptimizer and the GNU C compiler", "url": "http://dl.acm.org/citation.cfm?id=143146"}