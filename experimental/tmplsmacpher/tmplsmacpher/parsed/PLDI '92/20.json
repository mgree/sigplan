{"article_publication_date": "07-01-1992", "fulltext": "\n A Safe Approximate Algorithm for Interprocedural Pointer Aliasing William Landi Barbara G. Ryder (landi@cs.rutgers.edu) \n(ryder@cs.rutgers.edu) Department of Computer Science Rutgers University, New Brunswick, NJ 08903 Abstract \nDuring execution, when two or more names exist for the same location at some program point, we call them \naliases. In a language which allows arbitrary pointers, the problem of determining aliases at a program \npoint is P-space-hard [Lan92]. We present an algorithm for the Conditional May Alias problem, which can \nbe used to safely approximate Interprocedural May Alias in the presence of pointers. This algorithm is \nas precise as possible in the worst case and has been implemented in a prototype analysis tool for C \nprograms. Preliminary speed and precision results are presented. 1 Introduction Programming language \nenvironments feature software tools that improve the quality, efficiency, understand\u00adability, and reusability \nof code. Optimizers, debug\u00adgers, testers and parallelizers use data flow analysis to statically extract \nsemantic information from programs to increase their eflicacy. Aliases represent impor\u00adtant semantic \ninformation whose precision can greatly affect the quality of optimized code and the preci\u00adsion of various \ncompile-time interprocedural analyses [Ca188, CK89, PRL91]. An alias occurs at some program point during \npro\u00adgram execution when two or more names exist for the *The researeh reported here was supported, in \npart, by Siemens Research Corporation and NSF grant CCR8920078. Permission to copy without fee all or \npart of this material is granted provided that the copias ara not mada or distributed for direct commercial \nadvantage, the ACM copyright notioe and the title of the publication and its date appaar, and notice \nis given that copying is by permission of the Association for Computing Machinery. To copy otherwise, \nor to republish, requires a fee and/or specific permission. ACM SIGPLAN 92 PLD1-6/92/CA 01992 ACM 0-89791 \n-476-71921000610235 . ..$1 .50 same location. The aliases of a particular name at a program point t are \nall other names that refer to the same memory location on some path to t.When this execution path traverses \nmore than one procedure, we are solving the Interprocedural May Alias Problem. While the calculation \nof aliases for FORTRAN is well understood [Ban79, CO085, CK89, Mye81], aliasing in C is different than \naliasing in Fortran in two respects. First, aliases can change due to side effects of intrapro\u00adcedural \nexecution flow. Second, aliases created dur\u00ading execution of a called procedure can affect aliases which \nhold on return to the calling procedure. Arbi\u00adtrary pointers cause the problem of computing aliases to \nbecome ?-space-hard; currently, there are no good approximation algorithms. In this paper, we present \nan approximation al\u00adgorithm for interprocedural pointer-induced aliasing based upon Conditional May Alias \ninformation that describes aliasing within a procedure assuming certain conditions hold at its entry. \nWe report data on algo\u00adrithm performance and accuracy on real C programs. We define a appropriate precision \nmeasure and show that our algorithm is as precise as possible in the worst case.  2 Related Work Weihl \ndevised an approximation algorithm for finding aliases in the presence of pointers [Wei80], which unfor\u00adtunately \nwas very imprecise. Our attempts to use his algorithm for interprocedural analysis of C programs in \nISMM [Ryd89] were unsuccessful because of the de\u00adgree of imprecision in the reported aliases. Chow and \nRudmik [CR82] also presented an algorithm for finding aliases in the presence of pointers; however, their \nalgo\u00adrithm traced non-executable interprocedural execution paths and handled local variables incorrectly. \nCoutant [COU86] extended Weihl s work by keeping his restric\u00adtion of finding program aliases, but allowing \nthe tracing of aliases through more than one level of dereference and adding additional language constructs \n(e.g., struc\u00adtures and arrays). Benjamin Cooper [CO089] developed an algorithm which used alias histories \nto insure that a procedure returns to the call site that invoked it. There also has been some work [Deu90, \nDeu92, NPD87] in detecting aliases in higher order program\u00adming languages. [NPD87] only considers programs \nwith single level dereferences and has the added dif\u00adficulty of tracking the binding of functions to \nnames. The problem addressed by [Deu90] is an order of mag\u00adnitude complication over general aliasing; \nhe allows clo\u00adsures (partially evaluated functions) and continuations (storing of runtime environment \nfor later reuse). In [Deu92], an algorithm for finding aliases in polymor\u00adphically typed programs is \npresented. The work done on dependence analysis and con\u00adflict detection in programs with recursive structures \n[CWZ90, Gua88, HA90, HN89, HPR89, JM82, LH88] is also related, although it is directed at finding access \npatterns into structures rather than explicitly finding aliases. A conflict [LH88] occurs between two \nstate\u00adments when one statement writes a location and the other accesses (reads or writes) the same location \n(ioc), thus preventing the possibility of those statements be\u00ading executed in arbitrary order. A data \ndependence ex\u00adists between two statements iff they conflict and there is an execution path from one program \npoint to the other on which 10Cis not written.   l:? int *gl, gz; 4 ng: P() na: callp entryp { !71= \n&#38;92; I } na: returnp main () { 1 nlo: + int **II, *12 ns: 12 = &#38;gz; 91 = &#38;92; II = &#38;gl; \nP(); I 12= &#38;g2; n6~ callp P(); } / I \\ nil: , * \\ Figure 1: A program and its ICFG 3 Problem Representation \nWe analyze C-like imperative programming languages with sophisticated pointer usage and data structures, \nno type casting, explicit function calls (without func\u00adtion variables), and arrays which we treat as \naggre\u00adgates. We represent a program by an .lnterprocedural Control Flow Graph or ICFG[LR91] which intuitively \nis the union of statement-level control flow graphs for each procedure augmented by call, return, entry \nand exit nodes. Call nodes are connected to the entry nodes of procedures they invoke; exit nodes are \nconnected to return nodes corresponding to these calls. A sample ICFG can be found in Figure 1. Objects \nare locations that can store information, and object names provide ways to refer to objects. An ob\u00adject \nname is a variable and a (possibly empty) sequence of dereferences and field accesses. Object names can \nbe defined by three simple BNF rules: . object-name + *object-name e object.name * object-name. field.of-structure \no object-name + variable If there are any recursively defined data structures (e.g., linked lists) then \nthe number of object names is potentially infinite. We will limit to some constant, k, the number of \ndereferences allowable in any object name and obtain a finite number of potential object names. We consider \nany object name with 1> k deref\u00aderences to be represented by the object name obtained by ignoring the \nlast 1 k dereferences yielding a unique k-limited name. Thus, for k= 1, p> fl-> fz would be represented \nby p> fl (and not by *p). We borrow ter\u00adminology from [JM79] and call this k-limiting, because their \nprocess is analogous even though they k-limit dy\u00adnamic structures while we k-limit object names. We need \nthe following functions for object names: is-prefix (onl, on2) returns tmte iff onl can be trans\u00adformed \ninto on2 by a (possibly empty) sequence of dereferences and field accesses. apply .tran$(onl, onz, on3): \nis-pref iz(onl, 0n2) must be true, The function applies to ons the se\u00adquence of dereferences and field \naccesses necessary to transform onl into on2 and returns the result. For example, app@trans(p >n, p >n \n>d, ~) returns r >d. As in [LR91] we will represent aliases by unordered pairs of object names (e.g., \n(v, *P)). The order is unimportant because the alias relation is symmetric. Since we have k-limited objectnames, \nto safely repre\u00ad sent aliases we must assume that (a, b~) with k-limited component bk, represents not \nonly (a, b~) but also any alias (a, b~) such that b~ can be transformed into ~j by a sequence of dereferences \nand field accesses. Also (a~, b~) with two k-limited components represents itself and all aliases (aj, \nb!) such that ak isa Prefi of a~ and bkis a prefix of b~. The following definitions will be used throughout \nthe paper: realizable: A path is realizable iff it is a path in the ICFG and whenever a procedure on \nthis path returns, it returns to the call site which invoked it. holds: Alias (a, b) holds on the realizable \npath p1n2...ni iff a and b refer to the same location &#38; execution of program point ni whenever the \nexecution defined by the path occurs. Interprocedural May Alias: The precisel solution for Interprocedural \nMay Alias is {[n, (a, b)] I3 a realizable path, gmln2...ni_ln, in the ICFG on which (a, b) holds}. visible: \nAt a call site, an object name (e.g., *z) of the calling procedure is visible in the called pro\u00adcedure \niff the called procedure is in the scope of the object name and at run time the object name refers to \nthe same object in both the calling and called procedure. (e.g., If z is a local variable of procedure \nP, then the z in P before a recursive call is not visible after the call, since at execution time it \nis a different instantiation,) 4 Approximating May Alias The may-hold Relation We have used our pre\u00ad \ncise algorithm for computing aliases in the presence of single level pointers [LR91] as a basis for a \nsafe in\u00ad terprocedural aliasing algorithm for arbitrary pointers. The key idea in both algorithms is \nto use Conditional May Alias information that answers the question: If there is a path from pTogram entry \nto the entTy node of the procedure containing ni on which every alias in the set AA holds, then may object \nname a be aliased to ob\u00ad ject name b on some path to ni ? Fortunately, it is safe to consider only AA \n(sets of aliases) with cardhality less than or equal to one [Lan92]. To insure efficiency, we only concern \nourselves with Ad sets that actually occur. We use may-hoid([(w, .4..4),(a, b)]) to encode the answer \nto the Conditional May Alias question: may-hoid([(~i, U), (a,b)]) is true iff (a, b) holds on some path \nfrom entry(ni ), the entry of the proce\u00addure containing ni, to ni assuming there is a path from entry \nof main to entTy(?Q) on which the as\u00adsumed alias AA holds and there is a path from entry of main to the \nentry(ni ) on which dd holds. 1We are using the standard data flow definition of precise which means \nprecise up to symbolic execution , assuming all paths through the program are executable [Bar78]. For \neven further efllciency gains we have designed our algorithm so that work is performed only when mag-hoht([(nj, \nU), (a,~)]) is twe. Since most of the may-holds will be false, this improves the average time complexity \nof our algorithm considerably. Finally, given Conditional May Alias, May Alias is easily computable; \nrnay-aiias(node) = {7A!(3ti)may-hoid(node, AA, PA) = -hue}. This can be computed in time linear in the \nsize of the may-hold solution; thus, we will only concern ourselves with the computation of may-hold. \nComputing may-hold The algorithm for comput\u00ading may-hoid is simple at a high level. First, we find all \nthe may-hold relations which are trivially true, (e.g., rnay-hold([( P= &#38;d ,O), (*p,v)]) is true). \nOnce we have this initial set of true may-holds, we compute the set of all true may-holde using a worklist \nalgorithm (Fig\u00adure 2) which propagates alias information from exits of nodes to their immediate successors \nin the ICFG. The remainder of this section gives details of this algorithm. We discuss our implementation \nof may-hold, parameter binding, and the functions used in Figure 2. We will use the following macro throughout: \nmake-true (node ,AA, PA) { if may-hoM([(node, AA),? A]) is false { set may-hold([(node, AA), P.4]) to \ntrue add (node ,dd, PA) to the worklist } } Representation In order to have an efficient im\u00ad plementation \nfor our alias algorithm, we must be able to do the following operations in constant time: o Set may-hold([(nocle, \n.4.4),PA]) to false for all POS\u00adsible node, A4, and PA e Find the value of may-hold([(node, &#38;t), \nPA]) for a given node, U, and PA. e Set the value of may-hold([(node, U), PA]) for a given node, AA, \nand PA. We use dynamic hashing [KS86] to do this, giving us constant time operations in the average case. \nWe f indaliases ( ) { worklist = f! /* Alias Introduction */ for each node (N) in the ICFG { if N is \nan assignment to a pointer alias es-intro.by-ass ignment (N) if N is acall node alias esintro.by-call \n(n) } /* Implied Aliases */ while worklist is not empty { remove (N ,AA,?d) from worklist if N is acall \nnode alias es=t.callimplies (N, A4, ?A) else if N is an exit node aliasat.exitimplies (N, A4, ?A) else \nany.otheraliasimplies (N, &#38;l, Pd) Figure2: Computing may-hold assume may-hold for any [(node,fi), \nPA] triple is false if it is not in the hash table; otherwise it is true [Lan92]. Implicit Assumptions \nConsider the assignment p = q where p and q are pointers to linked lists, This assignment results in \nthe following: :~ ~ Thus yielding the aliases (*p, *q), (p->nezt, q->nezt), (p->next->next, q->next->next), \nand so on. How\u00ad ever, these aliases depend on *q, q->nezt, and q->nezt->nezt being non-NULL before the \nassign\u00ad ment. Our algorithm implicitly assumes that this is the case, and we would create all of the \nabove aliases that k-limiting allows. This assumption is not an inherent part of our algorithm and can \nbe removed, but we use it here because it is generally reasonable and increases efficiency of the algorithm. \nFor conciseness, through\u00ad out this paper, whenever we create an alias (*p, *q) we assume that the aliases \n(p->nezt, q->nezt), (P>ne~t->neat, q->nezt->nez%), ... are also created although we do not explicitly \nstate this everywhere. Modeling Parameter Bindings For interproce\u00ad dural analysis, we need to model \nthe affects of param\u00ad eter bindings on aliases. We do this with a function bindCall(PA). Intuitively, \nMndcall(o) will be all the aliases on entry of a called procedure that must ex\u00adist because of parameter \nbindings, while bindc=ll((a, b)) will be the set of aliases at entry ofa called procedure whose existence \nis implied by a being aliased to b at call. Unfortunately, this definition is not sufficient be\u00adcause \na procedure call can both create and destroy an alias in the calling procedure, involving an object name \nnot visible in the called procedure. For example, the first call of P in Figure 1 creates the alias (**Zl, \ng2) in main even though 11is not in the scope of P. However, only references to the visible object name \nin an alias pair can affect whether the alias holds on a path. A pro\u00adcedure has the same effect on all \nalias pairs which con\u00adtain visible object name w and any non-visible object name. Therefore, we use the \nobject name nonvisible to represent all non-visible object names2. In the bind function, if any of the \naliases in the bind set involve non-visible, we need to know the corre\u00adsponding object name in the calling \nprocedure. For example, assume q is global to P, r is not visible to I , and q,r, and f are all type \nint * : example, if P is a function with formal * and call is an invocation of P with (*f, *a)3 is in \nbindcall(o). The second distinct formals are passed two actuals f of type int actual a then occurs if \ntwo where one ac\u00ad tual is a prefix of the other, For example, if P is a function with two formals ~1 \n(type int ** ) and f2 (type int * ) and call is P(a,*a) then (**fl, *f2) is in bindc=/l(@). Computing \nbindcalr((x, y)): There are three ways that an alias at a call site may imply an alias on entry to a \nprocedure. The first is trivial: if the two object names are global to the called procedure then they \nare also aliased on entry to the called procedure. The other two can be illustrated by the following \nexample (both al and tz2are global to P): f2 a2  ~ y cab(al, a2) entrYP(fl J2) In this example, since \n*a2 is aliased to **al at callP(a1,a2)t *f2 is aliased to **al. This example can be generalized to the \nsecond way an alias at a call site can imply an alias at the entry of a procedure. Whenever an actual \nhas an alias to an object name, its corre\u00adsponding formal picks up an alias to that object name &#38;~nOn-vi \nib e ((*f, *q) , -), bindCalrF(Q((*q, *r))= ((*q, non-visible), *r), ((*f, non-visible) , *r) { } The \noccurrence of ((*q, non-visible) , w) in bindc~liP(q) ((*q, *r)) represents the fact that *q is aliased \nto non\u00advisible object name *T at the entry of the called proce\u00addure P, Computing bindca//(0): There are \ntwo ways aliases can be implied by parameter bindings. The first alias corresponds to a simple formal \nto actual pairing. For 2h [LR91] we ~~emed to non-visibk * . 239 or non-visible, if the object name \nis not visible in the called procedure. Also in the example, since *a2 is aliased to **al at callp(al,.,), \n*f is aliased to ** fl at entryp(f, ,t,). This is typical of the third case; when two actuals are aliased \nat a call site, the correspond\u00ading formals are aliased on entry to the called proce\u00addure. The algorithm \nfor computing bind.all ((z, y)) is a straightforward encoding of these three cases. The remainder of \nthis section gives a more detailed description of the algorithm in Figure 2 by discussing which may-holds \nare set to true by each its functions. 3((*j, non-visible),w) if a is not visible in P. 4.1 Aliasesintro.by \n.assignment(node) Let mxiebe the pointer assignment p=q .4 Clearly, may-ho?d([(nocle, O),(*p,*q)]) is \ntrue unless p is a prefix ofq. To understand this exception, consider the as\u00adsignment p = p >nezt . It \ndoes not create an alias (*p, *(p >next)) because p and p >next both refer to different objects after \nthis assignment but their alias relationship does not change. 4.2 Aliases_intro_by.call (node) For each \nalias (a, i5) in bindcall(O), nmlce.true (entry, (a, b), (a, b)) where entry is the entry node correspond\u00ading \nto call.  4.3 Alias_at.ca113rnpHes( call,&#38;l,T/1) A may-hold at a call node has effects on the corre\u00adsponding \nentry and return nodes. E#ects on corresponding entry node (entry): For each alias (a, b) in bindcall(PA), \nrnake.true (entry ~ (a, b), (a, b)). Eflects on corresponding return node (return): For simplicity assume \nthat we are dealing with a pro\u00adgramming language that has no local variables, and thus no formal parameters. \nWe are interested in the relationship between may-hold at a return node and may-hold at its predecessors. \nClearly, may-hold ([(~e~~~%AA), (a,b)]) is true if (a, b) holds at the corre. spending exit node, conditional \non AA holding at its entry and AA , conditional on AA, holds at the cor\u00adresponding call node. This situation \ncan be generalized resulting in the equation in Figure 3. We have to intreduce the func\u00adtions back-bind \nand back-bind which have the following definitions:5 back-bindcall((a, b)) specifies the alias on any \npath to call that guarantees a is aliased to b after control flows to corresponding entry node, 4 p = \n&#38;z is handled similarly. Simply consider q~ &#38;z and treat*&#38;z S x. 5Thesef~ctions recoverthe \nPA aliasesfrom call-siteso back-bind~all((a, non-visible) , o) specifies the alias on any path to call \nthat guarantees a is aliased to the non-visible object name o after control flows to corresponding entry \nnode. These definitions imply: back-bindcail((a, b)) = (c, d) iff (a, b) c bindcall((c, d)) back-bind~all((a, \nnon.wisible) , o) = (c, d) iff (a, non-visible) E bindcatl((c, d)) and nonvisible represents o. We can \nnow proceed to describe the effects of may-hold ([(C4AA),PAI) at the corresponding return. To do a case \nanalysis, let PA = (a, b): 1. Ifaand b are both not visible in the called proce\u00addure then the procedure \ninvocation does not af\u00adfect this alias. The desired action is obviously make-true (return ,AA, (a, b)). \n 2. aand b are both visible in the called procedure. We know may-hold([(.at~, AA), PA]) ( PA E back\u00adbindc.ll \n(AA )) and we consider its relationship to Rule 2. From call we can get exit and return of Rule 2. From \nPA we can get AA .G This leaves Rule 2 with one free variable (x, y), so the obvious action for may-hold([(cal~, \nu), (~,b)]) would be7:  For each (AA , -) in bind=~~j((a, b)) for every possible (z, y): if may-hoid([(ezit, \nu ), (~,y)]) is true make-true (return ,AA, (z, y) ) However, this is not acceptable because it requires \nwork to be done for every possible (z, y) even though most (x, y) are not necessary. since in Rule 2 \nwe are performing a conjunction in which we know one half is true, instead of doing work for all (x, \ny), we would prefer to only do work for (z, y) such that may-hold([(ezit, .4.4 ), (~, v)]) is i%ue. This \ncan be done at the cost of maintaining an additional data structure [Lan92], 6bi7dcaZI(back-bkfdcaf~ \n(AA )) = 4 . Strictly speakingthis means if rnag-hold([(erit,0), (C,~)]) wastrue, we make mag-hold([(retumz, \nAA), (z, g)]) t~ue for all possibleAA. However,in practiceit is sutiicientto only make rnag-hokt([(return, \n0), (z, g)]) true. Rule 1 If x and y are both not visible in the called procedure: ?7W&#38;hOM([(ret7mn, \nAA), (e, ~)]) = T7tc&#38;h0M([(ealt, AA), (m,v)]) Rule 2 If x and y are both visible in the called procedure: \n~~y-hdd([(ed, AA ), (iz,~)]) A ? nay-hoki([(return, AA), (23,v)])= ?7my-hold([(ed, 0),(at,y)])V v AAJ \ncASSUMP~t ( ?7Wy-hO?d([(ca~~, AA), back-bindcalj (AA )]) ) Rule $ If z is visible but y is not (the symmetric \ncaee is similar): t ASSUMED is the set of all possible assumed aliases. Figure 3: may-hold relation at \nreturn nodes 3. Assume a is not visible in the called procedure but This represents the fact that if \n01 is aliased to non\u00adb is. visible object name 11 and 02 is aliased to non-visible This corresponds to \nRule 8 in Figure 3 and is anal-object name 12on a path to the entry of the procedure ogous to the case \nwhere a and b are both visible in then, on some path to ewit, nvl (where the non-visible the called procedure, \nexcept now we need to fill in portion represents 11) is aliased to nv2 (where the the nonvisible at exit \nwith a. Thus we would get non-visible portion represents 12). Thus, the following action for may-hoid([(.atl, \nAA), (a, b)]): (gl, .rwn-visible) ma~-hotd([(nll, (L72,*n~-visible~ ( nw-vi i~le, n~-visibl.)]) For \neach (AA , nv ) in bindc.zl ((a, b)), for every possible (z, y): represents the alias (**11, *12) at \nnll because (assume x contains non-visibles) : . gl is aliased to Waon.visibte (non-visible 41) at if \nmay-hoid([(ezit, AA ), (r, v)]) is t~ue ng when called from n6 and { let z =nv . g2 is also aliaeed \nto *non-visible (non-visible 42) apply _trans(non.visible ,Z ,Z ) at ng when called from nG. make-true \n(return ,AA, (z , y) } The action for Case 3 given above must be mod- More Complex Effects on Return \nNode8 in Case $ : ified to handle the special case where ma~-holds While the action described above is \nsufficient if only ([(cd, AA), PA]) implies one of the two assumed aliases single level pointers are \nallowed, it is not sufficient in needed for an alias with two non-visibles, Details can the general case. \nIn general, it is possible to have an be found in [Lan92]. alias between two non-visible s. For example, \nthe sec\u00adond call of P in Figure 1 creates the alias (**11, *22) at 4.4 Alias_at-exitjmplies (ezit,AA,T~) \nnlo even though neither 11nor i2 are visible in P. Thus An exit node can have any number of successors, \nhow\u00adwe must handle the case of creation in the called proce\u00adever they are all return nodes. This function \nencodes dure of an alias between two non-visible object names. the rules for return nodes in Figure 3 \nwith the ad-We will do this with a special case of may-hold with ditional case of aliases between two \nnon-visible ob\u00adtwo assumed aliases: ject names. The encoding is analogous to that for (01,non-visible) \nmay-hold([(enit, (02, ~.visible) )? (nUl , nvz)]) Alias-at -callfimpli.es and we omit a formal descrip\u00ad \n8For example, z *non-visible. tion of this routine. 4.5 Any.other.alias-.implies(node,A~,T~) can occur \nin conjunction with the third). They The implications of may-hohl([(node, d.A), PA]) depend on its successors \nand must be considered separately for each successor. Since we have examined the cases where node is \na call or exit node, the successors must be either a call, an exit, or a statement in the program. Successor \n(SUCC) is a call node, exit node, or a program statement which is not an assignment to a pointer: These \nnodes simply collect may-hold infor\u00admation from their parents. When succ is of one of these types, the \naction for may-hold([(node, .4.A),7.4]) is simply nmke.true(succ, ti,?~). Successor (succ) is an assignment \nto a pointer: This case encompasses the major intraprocedural af\u00adfects of pointers on aliasing. The effects \nof may-hold ([(~o~e,AA), PA]) depend on the relationship of the ob\u00adject names in PA and the object names \ninvolved in the pointer assignment. In the following discussion we will consider succ to the be statement \np = q , where p and q are arbitrary object names of pointer type, What fol\u00adlows is a case analysis; the \nalgorithm applies all suitable cases. The cases are: 1. Does the assignment preserve the alias? 2. What \nare the effects of an alias of *q? 3. What are the effects of an alias of p? 1. PA = (v, z) where P is \na prefix of neither y nor z. (preserves the alias) In all cases, y and z point to the same object after \nthe assignment as before since only p changes its value and the assignment has no effects on (v, z). \nThe action in this case is simply make-true ( succ, Ad,PA). This is clearly safe, but it can also be \napproximate. 2. PA= (Y, Z) where is.prefix-with.deref( q,y)g (effects of an alias of *q). There are 3 \ndifferent cases that need to be handled (the first two are mutually exclusive, but either 9is-prefix-with.deref( \ng,~) is the same as is-prefix (q,y) ex\u00adcept that y must have at least one more deference than g. are: \n(i) not is-prefix(p,z), (ii) is-prefix(p,z), and (iii) the interaction of (*q, Z) with other known aliases. \nIn general, the effects of the assignment on this alias depend on whether or not is-prefix(p,z) is true. \nThe two types of effects are characterized by the following examples: Case 2.i: y Z *q node; u P --mhm+- \n,..  qz Succ: p=q;  (A) P cE-cEl- \\ ,.. q-gcm+E- In case 2.i, may-hoid([(node, A), (X9,.)]) implies \nmay-hold([(sticc, .4A), (*9, z)]) and may-hold([(succ, .4A), (*P,z)]). Case 2.iti y S *q, z S *(p-> \nnezt) ,2 node: ... (?  i -P uCc:G@ *... qef- In case 2.ii, ma~-hoki([(node, &#38;t), (*g, *(P>newt))]) \ngives no information about the aliasing that occurs at SUCCIo.Thus the action when may-hold([(node, old), \n(v, z)]) is true forsucc = p= q where is-prefix-with-deref( q,y) would appear to be: if ! is-prefix \n(p, z) { apply _trans (q ,y,p ) make_true(suCc,4, (P , z) ) } 10Theo~Yd~s thatholdsatsuccincase2ii,is(*P,*q)which \nholdsregardlessof thealiassituationatnode. This can miss some aliases when p is not a prefix of z. Consider \nthe following case 2.iii: u-p q t.bWp q Q T G1T \\ J \\/ The problem is that the existence of the alias \n(**u, z) at succ does not necessarily follow from a single alias at node. Instead, (**u, z) can hold \non [entrymain ]...[node] [SUCC]if both (*u, p) and (z, *q) hold on the path [ent~yma~n]...[node]. Unfortunately, \nwe do not keep any information about pairs of aliases holding on the same path. Whenever we have ma~-hold([(node, \nA.4), (*u,P)]) and may-hoid([(node, old ), (z, w)]) we have to as\u00ad sume may-hoki([( P= ~ ,U), (**w z)]) \nin order for our solution to be safe. We must extend the above action to account for this situation. \nOne notable feature of this extension which deserves mention is how to handle the case when AA # AA when \nboth occur on the same path. We do not allow multiple assumptions, so we must safely approx\u00ad imate this \nsituation. Clearly both assumptions are individually necessary and either can be safely chosen. In general, \nif one assumption contains non.visdde, then use that one (so that we remem\u00ad ber how to instantiate nonvisible); \notherwise use either. 3. PA= (p, v) (effects of an alias of p) Again there are three cases to consider; \n(i) simple effects of (p, v), (ii) secondary effects of (p, W),and (iii) interaction of (p, v) with other \nknown aliases. The effects of p= q on (p, *u) (i.e., w -*u) are characterized by: Case 3.i: ma~-hokl([(node, \nAA), (p,w)]) implies may-hohl([(svcc, ..4.4),(P,w)]) and, unless u or p is a prefix of qll, may-hoki([(awc, \nAA), (w, **u)]), Case 3.ii: An alias (*p, o) at node is, in general, im\u00adplicitly killed. However, in \nthe case where (p, *u) holds on some path to node, (*p, **u) will not be killed by the assignment p = \nq and we have to account for this.. Case 3.iii: The only other effect of may-hold([(no~, a), (P, *ti)I) \ncomes from handling the other half of case 2.iii and is handled in the same way.  5 Empirical Results \nThis section starts with a theoretical examination of the worst case precision of our algorithm. We next \ndiscuss our implementation of the algorithm and em\u00adpirically compare our solution to Weihl s solution. \nWe then report empirical data on algorithm precision. Precision Throughout this paper we have used k\u00adlimiting \nto deal with infinite sets of object names, and we now apply that notion to precision. &#38;7J dk(SOIUt~O?J)= \n(node, (a, b)) c solution, a is the k-limited representation (node, (a , b )) for a, and b is the k-limited \nrepresentation for b { We use the following definition for the precision of a safe algorithm A when \nanalyzing program P: p~e(%~onk (A,P) = l/imitk({A s solution for ~})1 llimit~({precise solution for P})l \n Consider the program all-or-none in Figure 4 for any given n. Thk program has the unfortunate property \nthat if no aliases hold before it is executed then the pre\u00adcise solution under the common assumptions \nof static 11when ~ or p is~~refix of q, we do not want to creak (*%*4 for the same reason we do not want \nto create (*P, *(p->mzt)) for p= p->next . while (-) {#for allk, l~k~n: if (-) { v~=b; b= NULL ; ) #end \nfor all if (-) {b=d; d= NULL; Figure 4: Program cdl-or-none(n); n is a parameter determining the size \nof the program analysis has n + 1 program point aJiases. However, if justthe alias (*b, *d) holds before \nprogram all-or-none then, for all i and j (1 ~ i, j ~ n), *vi is aliased to *vj on some path to all program \npoints (0(n3) of them). Any approximate algorithm can erroneously produce the aliaa (*b, *d). Thus when \nalz-or-none(n) follows the creation of the erroneous (*b, *d) alliaa, the algorithm will report 0(n3) \naliases12 even though there are only Q(n) aliases. For our algorithm, using the the precision measurement \nWeci.$ionk this is the worst case. Prototype Our prototype implementation, written in C, finds aliases \nfor a reduced version of C that ex\u00ad cludes: union types, nested structures, casting, point\u00aders to functions, \nand exception handling. The first three of these omissions are not theoretically difficult to handle, \nbut complicate the implementation. The other two require more theoretical examination. We do allow arrays \nand pointer arithmetic; however, we deal with these on a very simple and naive level and treat them as \naggregates. For building ICFGS, we were fortunate to have access to ptt, a program developed by Siernens \nResearch Corporation. Empirical Comparison to Weihl s Algorithm Unfortunately, we can not directly compare \nour alias 12the Cqn3 ) from ~ll-or.none(n) plus some comtant n~nber form the program that erroneously \ngenerates (*b,*d) solution to Weihl s solution because we find program. point specific aliases and Weihl \ndoes not. Therefore let us define programaliases as: {(a, b) l(~n)a ICFG node and (a, b) ~ may-alias(n)} \n In Table 1 we compare our solution versus Weihl s so\u00adlution, As expected Weihl s algorithm reports more \nprogram albees than our algorithm. The timing for Weihl s algorithm is approximate because in our im\u00adplementation \nof his algorithm, we were only able to time the second stage of his calculation (the transitive closure \npart) and not the total time taken. On av\u00aderage Weihl reported 30.7 times as many aliases and the timings \nare more or less comparable. The numbers reported here are based on an improved implementa\u00adtion of our \nalgorithm. make was included in the origi\u00adnal data set, but the new implementation does not yet handle \nit. Measurement of Empirical Precision There are four distinct approximations in our alias algorithm \n(this is proved in [Lan92]). Our first source of approxi\u00admation, k-limiting, is discussed in Section \n2. A second source of approximation is illustrated by the following scenario. Suppose there is an assignment \np = z at pro\u00adgram point t, alias pair (p, *q) holds on some path13 to an immediate predecessor of t and \n(*z, *y) also holds on some path to an immediate predecessor of t.Does (**q, *y) hold on some path to \nt? (*x, *y) (P, *9) -t: p=z w (**q, *y)? If both (p, *q) and {KC,*y) occur on the same path, then (**q, \n*y) holds on that path extended by t;our algorithm safely concludes this, even though it may not be true. \n13Remember that may-hold is defined after execution of the last statement on the path. Program Lines \nWeihl program-aliases Number Time Number Time U1 523 4,851 3s 349 26s pokerd 1,354 62,225 84s 352 4s \ncompress 1,488 6,316 4s 341 2s loader 1,522 39,059 36s 496 7s learn 1,642 61,845 46s 883 27s ed 1,772 \n1,796 6s 1,455 42s cliff 1,793 44,366 58s 1,444 43s tbl 2,545 4,401 10s 1,065 85s lex 3,315 9,490 18s \n1,240 50s Weihl program program-aiiases aliases Weihl Number Time 13.8 8.7 176.7 0.1 18.5 0.5 78.7 0.2 \n70,0 0.6 1.2 1.4 30.4 0.7 4.1 8.5 7.6 2.7 Wograrmaliases = {(a, b) l(3n)n is a node of the ICFG and \n(a, b) c may-alias(n)} Table 1: Comparison to Weihl The third source of approximation is similar to the \nsecond. Consider the assignment p = x at program point t. Suppose (p, *q) holds on some path to an im\u00admediate \npredecessor of t and (**q, *z) holds on some path to an immediate predecessor of L Does (**q, *z) hold \non some path to t? E/ (**q, *Z) (P, *q) t: p=x (**q, *z)? If on at least one path to an immediate predecessor \nof t (**q, *z) holds, and neither (p, *q) nor (p, z) does, then (**q, *z) holds on that path extended \nby L However, if on all those paths (**q, *z) and (p, *q) both hold, then (**q, *z) does not necessarily \nhold on any path tot. Here, our algorithm safely assumes that (**q, *z) holds on some path to t. The \nfourth approximation results from two distinct aliases of the LHS of an assignment. Normally, (*(u-> \nn), *(v >n >n)) should hold on a path to tbecause assigning v >n >n to p.n is also an assignment to u \n>n on paths on which (p, *u) holds. This, however, is not necessarily the case. If, for example, on the \nsame path (p, *v) holds then (*(u >n), *(v >n >n)) does not necessarily hold: before: after: U*?) u \np.n = v >n >n; L % We ve modified our algorithm to count the last three approximations. An alias is \ncounted as possibly impre\u00ad cise if it is the result of any of the last three types of the approximations \nor depends on the existence of an\u00adother alias that is counted as possibly imprecise. In [Lan92], we prove \nthat the four cases given above are the only base sources of imprecision in a variant our algorithm.14 \nThere is one other source of approximation that is not a base source of approximation. Consider the fol\u00ad \nt: lAThe ~~orit~ pres~ted here has the implicit ass~Ption  p * )\\..p*v) p.n = v->n->~ that the RHS \nof an assignment is not NULL on some path to the assignment,whichcan lead to imprecision.We considerthis \n(*(u- >n), *(v-> n->n))? assumptionreasonable,andhavenot countedthisimprecision. lowing (where s is \nsome immediate predecessor of t): k may-hohi([(., (p, WI)), (P, w)]) may-hold([(~, (w, w)), (w, w)]) \n t: p=x may-hoki([(t, (P, *g)), (**~, *V)]) This is the second source of approximation mentioned above. \nNote that since may-hold at tdepends on two assumptions we arbitrary chose one. Assume that the may-hold \nat treaches the exit of the procedure so that we get may-ho~d([(eait, (P, *q)), (**q, *v)]). It is possible \npossible that the alias (**q, *u) does indeed hold on some path to t (and some path to exit) and hence \nis not imprecise. However, we will propagate (**q, *y) to a return if only the alias (p, *q) holds at \nthe cor\u00adresponding call. This can be inaccurate even though the original may-hold at tis accurate. Notice, \nhowever, that any such inaccuracies will be counted, because the may-hold at t will be counted as possibly \ninaccurate and since the may-hold at exit depends (indirectly) on may-hold at t,it too will be counted \nas possibly inac\u00adcurate. Define %YEf$k (P) for may-hold computed from P as in Figure 5. Given that there \nare only the aforemen\u00adtioned four types of approximations, we claim that L ~ ~imitk (precise solution). \nThus %YESk (P) < 100* (l/precisionk (landi, P)) and can be used to bound precision.15 Table 2 presents \nempirical precision results for 18 C programs with the k-limit constant equal to three16. This suite \ncontains all the programs that we compared to Weihl s algorithm in Section 5. These programs came from \na pool of available C programs that was collected for an ongoing empirical study of the struc\u00adture of \nC programs [RP88]. The sample is by no means large enough to draw general conclusions about algo\u00ad 15 \nzand~refers tO o~ approximate ~i%orithm. 1srn [Lm92] We ~ve &#38;.o exaruined these programs for k= 1 \nto 4. 246 rithm behavior, but it is large enough to indicate that our algorithm performs well over \na limited domain of C programs. 6 Conclusions Our development of an approximate algorithm for solv\u00ading \nfor Interprocedural May Alias has been promis\u00ading. It justified the use of Conditional May Alias as a \nmethod for the interprocedural aspects of the alias problem. While it is not precise in the presence \nof ar\u00adbitrary pointers, it is safe, erring conservatively. We showed that for at least one definition \nof precision, in the worst case no algorithm can be more precise than our algorithm. Our empirical investigations \nyielded en\u00adcouraging precision results and showed great improve\u00adment over the extant technique [Wei80]. \nOur idea of us\u00ading a conditional version of aliasing to solve for aliases has been extended to the Interprocedural \nReaching Definitions Problem in C [PRL91]. Acknowledgments We thank our colleagues at Siemens Corporate \nResearch, Hemant Pande, Michael Platoff, and Michael Wagner, for their assistance with ptt. We also thank \nSiemens for allowing us to use their optimized implementation of our algorithm. The timings for Siemens \nimplementation are on average 13 times faster than our initial ones. Rlta Altucher, Bruce Ladendrof, \nand William Landi17 are primarily respon\u00adsible for the improvements.  References [Ban79] J. Banning. \nAn efficientway to fmd the side effects of procedure calls and the aliases of variables. In Con~er. ence \nRecord of the Sixth Annual ACM Symposium on P~i?w@les of Programming LangGages, pages 29 41, January \n1979. [Bar78] J. M. Barth. A practical interprocedmal data flow analysis algorithm. Communications of \nthe A CM, 21(9):724-736, 1978. [Ca188] D. Callahan. The program smnmary graph and flow\u00adsensitive interprocedural \ndata flow analysis. In Pro. ceedings of the SIGPLAN 88 Conference on ProgTam. ming Language Design and \nImplementation, pages 47 56, June 1988. 17while worfing for Siemens (M4)may-hold([(nde, A.,4),1 A]) \n= YES L = (node, PA) and not directly or indirectly the result %YEsk(P) = 100* of a type 2, 3 or 4 approximation \n(node, PA) I (3ti)mag-ho?d([(~ode, fi),pA]) = YES  (,{{ },} ) Figure 5: Definition of %YESk(P) I ICFG \nI May I %YES~ I 1 ICFG May %YESk Program Nodes Ali~es (PTogTam) Time Program Nodes Aliases (PTogTam) \nTime allroots 407 257 loof 1s Dokerd. 1.936 54.819 45 7s fixoutput 615 1,937 loot 1s learn 2:781 179;844 \n98t 27s dii?ih 647 8,046 loot 1s ed 3,299 127,502 loot 41s poker 896 3330 loot 2s assembler 3,631 1,260,582 \nlot 396s U1 1,625 101,273 loot 26s cliff 3,926 89,056 88t 40s lex315 1,204 5,163 loot 2s simulator 5,305 \n241,621 98t 31s loader 1,596 119,259 78t 24s football 5,910 232,913 loot 23s compress 1,914 8,656 67t \n2s tbl 5,960 400,464 loot 80s tD [CK89] [CO085] [CO089] [COU86] [CR82] [CWZ90] [Deu90] [Deu92] 1.710 \n96.098 loot 9s lex 6,792 420,268 96t 44s t %yE&#38;(~TOgTUm) < 100* (1/PTeC~S~Onk (Iundi Program)) Table \n2: Precision of our May Alias Solution (k = 3) K. Cooper and K. Kennedy. Fast interproceduralalias analysis. \nIn Conference Record of the Sixteenth An\u00adnual ACM Symposium on Principles of Programming Languages, pages \n49 59, January 1989. K. Cooper. Analyzing ahzes of referenceformal pa\u00adrameters. In Conference Record \nof the Twelfth Annual ACM Symposium on Principles of Prognanwning Lan\u00adguages, pages 281-290, January \n1985. B. G. Cooper. Ambitious data flow analysis of pro\u00adcedural progrsme. Mast er s thesis, University \nof Min\u00adnesota, May 1989. D. S. Coutant. Retargetable high-level alias analysis. In Conference Record \nof the Thirteenth Annual A CM Symposium on Principles of Programming Languages, pages 110-118, January \n1986. A. Chow and A. Rudmik. The design of a data flow an\u00adalyzer. In Proceedings of the ACM SIGPLAN Sympo\u00adsium \non Compiler Constmtction, pages 106 113, June 1982. D. R. Chase, M. Wegman, and F. K. Zadeck. Analysis \nof pointers and structures. In Proceedingsof the SIG-PLAN 90 Conference on Programming Language .De\u00adsign \nand Implementation, pages 296 310, June 1990. SIGPLAN Notices, Vol 25, No 6. A. Deutsch. On determining \nlifetime and ahssing of dynamically allocated data in higher-order functional specifications. In Conference \nRecord of the Seven\u00adteenth Annual ACM Symposium on Principles of Pro\u00adgranwningLangwages,pages 157 168, \nJanuary 1990. Alain Deutsch. A storeless mode of aliasing and its abstractionsusingtiniterepresentationof \nright-regular equivalencerelations. In Proceedingsof the IEEE 1992 Conference on Comptiter Language8, \nApril 1992. [Gua88] C. A. Guarna. A technique for analyzing pointer and structure references in parallel \nrestructuring compil\u00aders, In %oce.di?ag$ of the Intewationai Conference on Parallel Processing, pages \n212 220, 1988. [HA90] W .L. Harrison III and Z. Amrusrguellat, Parcel and miprac: Parallelizers for symbolic \nand numeric pro\u00adgrams. Tn International Workshop on Compilers jor Parallel Computers, December 1990. \n[HN89] L. J. Hendren and A. Nlcolau. Parallelizing programs with recursive data structures. In Proceedings \nof the 1989 International Conference on Pavallel Processing, pages 49 56, August 1989. [HPR89] S. Horwitz, \nP. Pfeiffer, and T. Reps. Dependence analysis for pointer variables. In P~oceedings of the ACM SIGPLAN \nSvmposium on Compiler Construc\u00adtion, pages 28 40, June 1989. [JM79] N. Jones and S. Muchnick. Flow analysis \nand opti\u00admization of lisp-like structures. In S. Muchnick and N. Jones, editors, ProgTamFlow Analysis: \nTheory and Applications, pages 102-131. Prentice Hall,1979. [JM82] N. D. Jones and S. S. Muchnick. A \nflexible approach to interprocedural data flow analysis and programs with recursive data structures. \nIn Conference Record of the Ninth Annual ACM Symposium on P%tciples of Programming Languages, pages 66-74, \nJanuary 1982. [KS86] H. Korth and A. Silberschatz. Database System Con. cepts. McGraw-Hill, New York, \nNY, 1986. [Lan92] W. Landi. Intevpvocedwal Aliasing in the Presence of Pointers. PhD thesis, Rutgers \nUniversity, January 1992. LCSR-TR-174. [LH88] J. R. Lams and P. N. Hilfinger. Detecting conflicts between \nstructure accesses. In Proceedings of the SIGPLAN 88 Conference on Programming Language Design and In@etnentation, \npages 21 34, July 1988. SIGPLAN NOTICES, Vol. 23, No. 7. [LR91] W. Landi and B. G. Ryder. Pointer-induced \naliasing: A problem classification. In Conference Record of the Eighteenth Annual ACM Symposium on Principles \nof Programming &#38;anguage8,pages 93 103, January 1991. [Mye81] E, M. Myers. A precise interprocedural \ndata flow al\u00adgorithm. In Conference Record of the Eighth Annual ACM Symposium orLPrinciples of PTogravnming \nLan\u00adguages, pages 219 230, January 1981. [NPD87] A. Neirynclc, P. Panangaden, and A. Demers. Com\u00adputation \nof aliases and support sets. In Confe~ence Record of the Fourteenth Annual A CM Symposium on Principles \nof ProgvamvningLanguages,pages 274 283, January 1987. [PRL91] H.D. Pande, B. G. Ryder, and W. Landi. \nInterproce\u00addural clef-use associations in c programs. In Proceed. ings of the Fifth Testing, Analysis, \nand VeTijication Symposium, October 1991. [RP88] B. G. Ryder and H. Pande. The interproceduralstrut. \nture of c programs: An empirical study. Labora. tory for Computer Science Research Technical Report LCSRTR99, \nDepartment of Computer Science, Rut\u00adgers University, February 1988. [Ryd89] B. G. Ryder. Isnun: Incremental \nsoftware mainte\u00adnance manager. In PToceeding8of the IEEE Computer Society Conference on Softwa~e Maintenance, \npages 142 164, October 1989. [Wei80] W. E. Weihl. Interproceduml data flow analysis in the presence of \npointers, procedure variables and la\u00adbel variables. In Con.fe~ence Record of the Seventh Annual ACM Symposium \non P~inciples of Pvog~am. ming Languages, pages 83 94, January 1980.  \n\t\t\t", "proc_id": "143095", "abstract": "<p>During execution, when two or more names exist for the same location at some program point, we call them <italic>aliases</italic>. In a language which allows arbitrary pointers, the problem of determining aliases at a program point is &rgr;-space-hard [Lan92]. We present an algorithm for the Conditional May Alias problem, which can be used to safely approximate Interprocedural May Alias in the presence of pointers. This algorithm is as precise as possible in the worst case and has been implemented in a prototype analysis tool for C programs. Preliminary speed and precision results are presented.</p>", "authors": [{"name": "William Landi", "author_profile_id": "81452618010", "affiliation": "", "person_id": "PP31085922", "email_address": "", "orcid_id": ""}, {"name": "Barbara G. Ryder", "author_profile_id": "81100632248", "affiliation": "", "person_id": "PP14217204", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/143095.143137", "year": "1992", "article_id": "143137", "conference": "PLDI", "title": "A safe approximate algorithm for interprocedural aliasing", "url": "http://dl.acm.org/citation.cfm?id=143137"}