{"article_publication_date": "01-01-2004", "fulltext": "\n An Abstract Interpretation-Based Framework for Software Watermarking Patrick COUSOT and \u00c9cole Normale \nSup\u00e9rieure 75230 Paris cedex 05, France Patrick.Cousot@ens.fr Abstract Software watermarking consists \nin the intentional embedding of in\u00addelible stegosignatures or watermarks into the subject software and \nextraction of the stegosignatures embedded in the stegoprograms for purposes such as intellectual property \nprotection. We introduce the novel concept of abstract software watermarking. The basic idea is that \nthe watermark is hidden in the program code in such a way that it can only be extracted by an abstract \ninterpretation of the (maybe non-standard) concrete semantics of this code. This static analysis-based \napproach allows the watermark to be recovered even if only a small part of the program code is present \nand does not even need that code to be executed. We illustrate the technique by a sim\u00adple abstract watermarking \nprotocol for methods of JavaTM classes. The concept applies equally well to any other kind of software \n(in\u00adcluding hardware originally speci.ed by software). Categories and Subject Descriptors: D.2.9 Software \nEngineer\u00ading/Management: Copyrights. General Terms: Algorithms, Reliability, Security, Languages, Theory, \nLegal Aspects, Veri.cation. Keywords: Abstract Interpretation, Authentication, Copyrights Protection, \nFingerprinting, Identi.cation, Intellectual Property Pro\u00adtection, Obfuscation, Software Authorship, Software \nWatermark\u00ading, Static Analysis, Steganography, Stegoanalyst, Stegoattacks, Stegokey, Stegomark, Stegosignature, \nTamper-proo.ng, Trustwor\u00adthiness, Validation Watermarking. 1. Introduction Digital information hiding \ntechniques such as steganography, dig\u00adital watermarking and .ngerprinting have received much attention \nfrom the research community and industry. With few notable ex\u00adceptions [4, 15, 16], relatively little \nwork has been done on software watermarking that consists in embedding (that is the indelible un\u00adobtrusive \n.xing of invisible stegosignatures1 or watermarks, such as cryptographic signature and timestamp, in \nsubject programs) and extraction (that is the detecting) of the stegosignatures) embedded in the stegoprograms \n(that is watermarked program sources). 1 stego-xxx means xxx in the context of hiding some em\u00adbedded \nsecret information. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. POPL 04, January 14 16, 2004, Venice, Italy. Radhia COUSOT CNRS &#38; \u00c9cole Polytechnique \n91128 Palaiseau cedex, France Radhia.Cousot@polytechnique.fr Digital watermarking is to be contrasted \nwith public-key encryp\u00adtion, which also transforms subject .les into another form so that they become \nunusable without the decryption key. Once the soft\u00adware is decrypted, it is free of any residual effect \nof encryption. Hence, licit use can only be ensured by keeping a list of certi.ed customers of the decrypted \nsoftware, by using licensing informa\u00adtion, by hardware monitoring of the program execution or by link\u00ading \nthe software to the hardware of a speci.c machine or to a spe\u00adci.c movable piece of hardware such as \na dongle [4, 16] or to a speci.c user public key. An alternative would be to use encrypted execution \nso that code never executes in-the-clear thus requiring a customized encrypted execution mechanism. These \ntechniques are in.exible (e.g. for software to be downloaded from a web page). Unlike encryption, digital \nwatermarking leaves the subject object basically intact, recognizable and usable. Further, whereas de\u00adcrypted \ndocuments are free of any residual effects of encryption, digital watermarks are on the contrary designed \nto be persistent in viewing, printing, or subsequent re-transmission or dissemination [10]. Watermarking \ndoes not aim so much to stop illicit use, but to prove ownership of the software and the algorithms used \nin the software [16]. Notice that in general the watermark may hide an en\u00adcrypted signature, a problem \nthat we handle by taking the signature to be an arbitrary number within an arbitrary large bound. We \nillustrate our approach on the watermarking of methods in JavaTM classes. Complete sophisticated JavaTM \napplications can be easily constructed from sets of JavaTM classes including reusable methods with high \nproprietary content (such as licence control code or original algorithms) which one might want to watermark. \nJavaTM classes are easy to decompile and reverse engineer since they are distributed in hardware independent \nvirtual machine code retaining almost all the information of the original JavaTM code. Obfusca\u00adtors and \ncode transformers can be used to make reverse engineer\u00ading more dif.cult [6] but also to hide the origin \nof JavaTM classes. In this case indelible watermarking is an appealing complementary solution. Two types \nof digital watermarks may be distinguished. Visible wa\u00adtermarks (such as a logo placed in a corner of \nthe screen image by the TV industry) discourage the illicit use by immediately claiming ownership. Invisible \nwatermarks, on the other hand, are potentially useful as a means of identifying the source, author, creator, \nowner, distributor or authorized consumer of a multimedia object (image, audio, video, text, etc). For \nthis purpose, the objective is to perma\u00adnently and unalterably mark the object. Since the watermark is \nnot visible, a special detection software is needed to extract the original signature. In the event of \nillicit use, the watermark would facilitate the claim of ownership. Copyright 2004 ACM 1-58113-729-X/04/0001 \n...$5.00 According to Collberg and Thomborson s informal taxonomy of software watermarking techniques \n[3], one can distinguish between static and dynamic watermarking. Static watermarking stores signatures \nin the program source either as data (e.g. an image, a string, etc) or code (e.g. in the code control \nstructure). So, the stegosignature can be extracted from the text of the program (or the program syntax), \nwithout any need for execution.  Dynamic watermarking stores signatures in the program ex\u00adecution state \nand so requires the program to be executed in order to extract the stegosignature. [3] distinguishes \nbetween:  Easter egg watermarking stores signatures in a piece of code exe\u00ad cuted for a highly unusual \ninput to the application. Dynamic data structure watermarking stores signatures in the pro\u00adgram data \nif and when executed with particular inputs. The signa\u00adture is exhibited by a watermark extraction routine \nexamining these signed program data. Dynamic execution trace watermarking stores signatures in the program \nexecution trace when executed with special inputs. The ex\u00adtraction consists in recognizing speci.c properties \nof the addresses or operations on the trace. One dif.culty with dynamic watermarking is that the special \ninput revealing the watermark can be localized by monitoring program execution using standard instrumentation \ntechniques and removed by debugging techniques in which case it must be considered in\u00adeffective. Dynamic \ndata structure watermarking can be obliter\u00adated by program transformations such as variable splitting/merging \nwhile dynamic execution trace watermarking can be erased by pro\u00adgram optimization and transformation. \nThis pessimistic view dis\u00admisses all current and future dynamic watermarking schemes as completely ineffective. \nAbstract watermarking is the new framework that we intro\u00adduce for software watermarking. Abstract watermarking \nis fully automatic and different from both static and dynamic watermark\u00ading. Abstract watermarking is \na static watermarking in that the extrac\u00adtion of the signature requires no execution of the program. \nIt fol\u00adlows that no easily recognized special input is needed for extraction. Abstract watermarking is \na dynamic watermarking in that the stegosignature is hidden in the concrete semantics of the program \n(which may be a non-standard one). However execution of the ste\u00adgoprogram (or just of the stegomark inserted \nin the subject pro\u00adgram) will not reveal the stegosignature. Abstract watermarking is different from \nexisting static or dynamic watermarking methods in that the stegosignature extraction is by static analysis \nof the stegoprogram that is by abstract interpreta\u00adtion of its (non-standard) concrete semantics (whence \nthe abstract quali.er of this watermarking method). Moreover the abstract ex\u00adtractor can be parametrised \nby a stegokey to .x the speci.c abstract domain used for the signature extraction. Enriching the terminol\u00adogy \nof [15], this is a semi-visible watermarking in that even if the presence of a stegomark may be visible \n(e.g. by making public the watermark embedding algorithm), the watermark or signature will be invisible \nto those not owning the detection software and the cor\u00adresponding secret stegokey. 2. Principle of Software \nWatermarking We let P be the set of considered programs and S be the set of stegosignatures. The watermark \nembedder is W .P . S.P . The watermark extractor is E .P . P(S). The principle of soft\u00adware watermarking/.ngerprinting \nis that the stegosignature can be extracted from the stegoprograms, that is for all s .S and P .P , s \n.E[W[ P](s)]. (Following the conventions of denotational se\u00admantics for the application, syntactic arguments \nare between dou\u00adble square brackets [...] while semantic/mathematical arguments are between round brackers \n(...).) The stegomark approach to software watermarking .rst consists in de.ning a stegomarker Mr .S \n.P to encode the signature s into a program Mr (s) called the stegomark. Second, a stegoinlayer I .(P \n\u00d7P ) . P is used to compose the stegomark Mr (s) with the subject program P .P to get the watermarked \nstegoprogram:  W[ P](s) =I[ P, Mr (s)]. 3. Abstract Software Watermarking In abstract software watermarking, \nthe signature is hidden in the se\u00admantics of the stegomark embedded in the subject program, whence in \nthe semantics of the stegoprogram. The signature extraction is by static analysis of the stegoprogram \nusing some abstract interpreta\u00adtion of the stegoprogram semantics. 3.1 Concrete Semantics Since the stegosignature \nis hidden in the program semantics, we must de.ne a collecting semantics [7], at some level of abstraction \nsuch as sets of traces, sets of reachable states, etc. In this applica\u00adtion, we consider the set of reachable \nstates that is the set of possible descendants of the initial states during program execution. Formally, \nthe small-step operational semantics of the program P is a triple (2[ P], I[ P],t[ P]) where 2[ P] is \na set of (memory and control) states, I[ P] .2[ P] is the set of initial states and t [ P] .2[ P] \u00d72[ \nP] is the transition relation relating a state s to a possible successor s' whenever (s, s').t [ P]. \nThe semantics S[ P] of the program P is the set of execution traces generated by (2[ P], I[ P],t[ P]). \nWe consider the reachable states abstraction of this semantics [7]. Formally, given a set S and relations \nt, t'. S \u00d7S, we let t0 . = {(s, s)|s .S}be the identity, t ot' .'')|.s').t . ={(s, s'.S :(s, s ', tn+1 \n. (s, s'')}.t'}be the composition of relations t and t'=t otn  be the powers of t, t * .tn be the transitive \nre.exive closure of = n=0 t and post[t](X) ={s'|.s .X :(s, s').t}be the right image of X by t (also called \nthe strongest post condition of X for t). The set of reachable states of program P is:  . (r n R[ P] \n. = post[t [ P]*](I[ P]) = lfp F [ P] = F [ P](\u00d8) n=0 where F [ P](X) = I[ P] .post[t[ P]](X). and lfp= \nf is the =-least .xpoint of f (the existence of which is guaranteed above by Tarski s .xpoint theorem). \nR[ P] is, gener\u00adally, not computable. 3.2 Abstract Semantics Using abstract interpretation, concrete \nprogram properties (that is subsets of 2[ P]) are approximated in an abstract domain L[ P] through an \nabstraction function a and a concretization function . chosen such that we have the Galois connection \n[7]: . (P(2[ P]),.) --.(L[ P], ) . (1) .-- a By de.nition of Galois connections, this means that (P(2[ \nP]),.)is a partially ordered set (it is indeed a complete lattice), (L[ P], )is also a partially ordered \nset and for all X . 2[ P] and X . L[ P]: a(X) X .. X . .(X). Given an abstract transformer Fa[ P] such \nthat for all X . L[ P]: F [ P] o .(X) . . o Fa[ P](X) the abstract semantics is de.ned as: Ra[ P] = \nlfpFa[ P] . (2) If (L[ P], ) is computer representable and satis.es the ascending chain condition then \nRa[ P] is computable iteratively as: rn Ra[ P] = Fa[ P] (.) (3) n=0 where .= a(\u00d8) is the in.mum and the \njoin  X = a( .(x)) x.X abstracts set union. The abstract semantics Ra[ P] is an approxi\u00admation of the \nreachable states of program P in that: R[ P] . .(Ra[ P]). (4) A static analyser is a terminating program, \nwritten for a given ab\u00adstraction a, which, given a program P as input, outputs Ra[ P]. The static analyser \ncan be made parametric in a computer repre\u00adsentation of the abstract domain (L[ P], ,.,u) and the abstract \ntransformer Fa[ P] so that e.g. the .xpoint computation: (rn lfpFa[ P] = Fa[ P] (.) n=0 can be generated \nautomatically. Static analyser generators contain generic abstractions a which are prede.ned in terms \nof simpler ones. For a simple example, let us consider that the states (c,m). 2[ P] = C[ P] \u00d7 M[ P] are \nmade up of a control state c . C[ P], and a memory state m . M[ P] as\u00adsigning values m(X). V[ P] to program \nvariables X . X[ P] so that M[ P] = X[ P] . V[ P]. Assume that we are interested in analy\u00adses recording \ninformation for a subset V of the program variables only (for example V might be the set of variables \nof a given type, such as the integer variables). Static analyser generators such as SOOT [20] provide \na non-relational abstraction as a prede.ned ab\u00adstract domain L[ P] that is parametrised by an abstract \ndomain D abstracting the values of variables: . (P(V[ P]),.)--.(D, ) . .-- a .P,V Then, we have (P(2[ \nP]),.)-(L[ P], ) by de.ning the .---- ----. aP,V global abstraction aP,V (X) of X . 2[ P] as: aP,V \n(X) =a({m(X) |(c,m). X}). c.C[ P]X.V This global abstraction aP,V , which we implicitly use in the fol\u00adlowing, \ncollects for each program point c and each variable X . V we are interested in, an abstraction, by the \nelementary a, of the set of values of this variable (which is reachable in some execution of P from the \ninitial states). The abstract transformer Fa[ P] can then be prede.ned in terms of basic abstract operations \nof the language P . The abstraction 0 of a k-ary concrete operation \u00b7 (with domain dom(\u00b7) and codomain \ncodom(\u00b7)) should satisfy for all x1 . L[ P], ..., xk . L[ P] [7]: {\u00b7(x1,...,xk )| x1 . .(x1). .... xk \n. .(xk ). (x1,...,xk ). dom(\u00b7)}. .(0(x1,...,xk )) . 3.3 Abstract Software Watermarking The principle \nof abstract software watermarking is to choose a particular abstraction a as well as an abstract extractor \nE(Q) . L[ Q] . S to extract the stegosignatures of a program Q . P : E[ Q] = E(Ra[ Q]). (5) The correctness \nconditions of Sec. 2 must be satis.ed, so: s . E(Ra[W[ P](s)]). Informally stated, we can watermark the \nsubject program P with stegosignature s by transformation of the program P into the ste\u00adgoprogram W[ \nP](s) where s is invisible. The signature can be ex\u00adtracted from the stegoprogram W[ P](s) by extraction \nwith E from its abstract semantics Ra[W[ P](s)] which is entirely speci.ed by the abstraction a. By maintaining \na and E secret, it is computation\u00ad ally hard, if not impossible to extract the stegosignature. The method \nis not static in that the stegosignature is not directly hid\u00adden in the program syntax that is the data \nor the control structure of the stegoprogram W[ P](s)nor dynamic since it is not hidden in the concrete \nsemantics R[W[ P](s)] of the stegoprogram (which need not be executed to extract the signature from an \nexecution trace). It is abstract, that is hidden in the abstract semantics Ra[W[ P](s)] of the stegoprogram, \nwhich is computable by static analysis of this stegoprogram. In particular, the concrete semantics which \nis used, need not be the collecting semantics for the standard semantics as considered up to now. For \nexample, if we want to watermark a method M of a program P, we can use the semantics of M where the parameters \nand global variables are all unknown as in a so-called monovari\u00adant intraprocedural static analysis. \nThe semantics of M can also be chosen to be non-standard and kept as an additional secret. A simple example \nwould be a non-standard interpretation of .oating point constants and operations as integer constants \nand operations. 3.4 Principle of Parametrised Abstract Software Watermarking and Fingerprinting In order \nfor the public to be con.dent in the robustness of the pro\u00adposed abstract software watermarking method, \nit is necessary to publish the watermarking method, including the speci.c abstrac\u00adtion a and abstract \nstegosignature extractor E which are used. Therefore in practice it is more convenient to have the abstraction \nan and abstract extractor En be parametrised by a secret stegokey n. The abstraction .n \u00b7an and the abstract \nkey extractor .n \u00b7En can be made public provided the abstract semantics En(Ran [ P]) is hard, if not \nimpossible to compute when n is unknown. Moreover, the abstract software watermarking embedders and ex\u00adtractors \nwill produce different stegosignatures for different ste\u00adgokeys as if we had different watermarkers, \nwhich can therefore be utilized separately and independently. We now illustrate this principle of parametrised \nabstract software watermarking by a particular instance.  4. Abstract Software Stegosignature Embedding \n4.1 Signatures A secret signature will be an arbitrary large natural number c . N so that S = N. In practice \nthe natural numbers representable within the numeric primitive types must be less than or equal to a \ngiven maximum m (e.g. MAX_VALUE for long in JavaTM). In order to bypass the implementation requirement \nc =m, we use the Chinese remainder theorem stating that: Let n1, ..., ne be e =1 positive integers which \nare pairwise co\u00adprime (meaning gcd(ni,nj)=1 whenever i= j) then Z/n1...neZ is isomorphic to the cartesian \nproduct Z/n1Z \u00d7... \u00d7Z/neZ. So in order to embed a secret signture c of size strictly bounded by n1 ...ne \nwith 1 <ni =m for all i =1,...,e we can isomorphically embed e keys (c1,...,ce).[0,n1 -1]\u00d7...\u00d7[0,ne-1]such \nthat: e i-1 e e c = nj.ci .nj(mod nj ). (6) i=1j=1 j=i+1 j=1 So the secret key can be assumed to be \na tuple (c1,...,ce).[0,n1 -1]\u00d7...\u00d7[0,ne -1] to be embedded/extracted in a pro\u00adgram by successively embedding/extracting \nci , i =1,...,e. The principle of stegosignature embedding is to add a stegomark to the program in order \nto hide the constant ci while the extrac\u00adtion consists in a static analysis of the program revealing \nthis con\u00adstant ci . Not knowing the secret factor ni it is computationally hard if not impossible to \nretrieve ci . However knowing the e-ary ste\u00adgokey (n1,...,ne), the static analysis can be repeated e \ntimes to retrieve the secret signature c. After explaining signature embed\u00adding in Sec. 4.3 and signature \nextraction in Sec. 5.1, we will show that the above restriction to a maximal value m can be lifted. \n4.2 Stegomark We let c .Z be a stegosignature satisfying (6) to be embedded in a program (indeed a JavaTM \nmethod). As explained in Sec. 4.1, we successively embed ci , i =1,...,e. Each ci , i =1,...,e is hidden \nin a stegomark Mr (ci ). The stegomark is built up in three parts, the stegomark declaration part (introducing \na new auxiliary stegovari\u00adable, say W, hiding the value of the secret key ci .): int W; the stegomark \ninitialization part: W = P(1) in Z and the stegomark iteration part: W = Q(W) in Z such that: P(1) = \nci in Z/ni Z and ci = Q(ci ) in Z/ni Z that is once initialized, the stegovariable W is constant in Z/ni \nZ. This property will be used to extract the stegosignature ci . Al\u00adthough it is constant in Z/ni Z the \nvalue of W will appear to be stochastic in successive executions of the stegomark iteration part W =Q(W). \n 4.3 Stegomark Inlaying The watermarking W[ P](ci ) of the program P consists in .rst choosing a method \nM, and in watermarking M. Formally W[ P](ci ) is P where the chosen method M is replaced by W[ M](ci \n).In JavaTM, the method seems to be the smallest unit of algorithmic interest, hence our choice. It is \ntrivial to generalize the approach to the case where the stegosignature is spread over a class or the \nfull program. The watermarking W[ M](ci ) of a method M consists in inlaying the stegomark Mr (ci ) in \nthe method M with I[ M,Mr (ci )] de.ned as follows: the stegomark declaration part is included among \nthe local dec\u00adlarations of the method M;  the stegomark initialization part is embedded at a random \nposi\u00adtion of the initial basic block of the method M;  the stegomark iteration part is inserted later \nat a random position in the body of the method, preferably within a loop.  4.4 Obfuscating the Stegomark \nThe stegomark should be obfuscated in order to hide the stegosig\u00adnature ci . First, the auxiliary variable \nW can be any integer program variable which is dead at the initialization point, in which case the extra \ndeclaration of W is not necessary. The initialization assignment W = P(1) uses a (e.g. second-degree) \npolynomial P of the form: P(x) = x2 +k1.x +k0 with the coef.cients k1 =-(1 +ci ) and k0 =2.ci . In order \nto hide the secret signature ci , these coef.cients are incremented, within the limit m, by a random \nnumber of times the modulo ni . Therefore: k1 =-(1 +ci )+r1.ni k1 = ci +r2.ni where integers r1 and r2 \nare random integers. Observe that in Z/ni Z, we have P(1) = ci . Indeed, the polynomial value P(1) is \nbetter computed by Horner s method: P(x) = (x +k1).x +k0 by successive assignments (where T is another \nnew temporary vari\u00adable2): W =1; ... T =W+k1; ... T =W*T; ... W =T+k0 introduced at random successive \npoints in the method s initial basic block. A polynomial of higher degree can also be used if necessary. \nIn the iteration assignment W= Q(W) of the stegomark, Q is chosen to be of the second degree (or higher), \nof the form: Q(x) = a.x2 +b.x +c where a and b are (not too large) non-zero random numbers and c is chosen \nto ensure that ci =Q(ci ): c = ci -(b.ci +a.ci 2) 2 T can also be another program variable which is dead \nat that point. Again, we use Horner s method: (x) = (a.x +b).x +c to compute Q(W), by introducing the \nfollowing sequence of assign\u00adments at random positions in the body of the method: T =W*a; ... T =T+b; \n... T =T*W; ... W =T+c . The last instruction is inserted only if c =0. If c is negative, we use the \ndifference -instead of addition +for naturalness.  5. Abstract Stegosignature Extraction By de.ning \nai such that Rai [ P] performs constant propagation in Z/niZ for all methods M of P, a static analysis \nwill be able to recognize that some variable (i.e. W) has the constant value ci in Z/niZ once initialized \n(or ultimately if a dead variable has been reused) thus indicating that the method M had been watermarked. \nWe now explain the technical details of this static analysis. 5.1 Abstract Domain and Operations Let \nn be some n1, ..., ne (or their product n1 ...ne in case n1 ...ne = m). We now introduce a program static \nanalysis, parametrised by n and to be repeated e times for n = n1, ..., ne, in order to retrieve the \nsecret signature c by successively discover\u00ading c1, ..., ce. Basic Abstract Domains: We let Z/nZ ={{hz \n|h .Z}|0 = z < n}~ =[0,n -1]be the ring of integers modulo n > 1. The unit element for addition is 0 \nand that for multiplication is 1. The basic abstract domain is that of constant propagation [13] for \nthe ring Z/nZ that is the complete lattice: Ln ={.,T}.Z/nZ where .abstracts the empty set (that is unreachable \ncode), Tab\u00adstracts Z/nZ (that is an unknown value) and c .Z/nZ abstracts the congruence class {hc |h \n.Z}. The set Ln is ordered by: .x .Z/nZ :. .c xx c T T which abstracts set inclusion. Ln is a complete \nlattice where the join u(abstracting set union .) and the meet n(abstracting set in\u00adtersection n) are \nde.ned, for all x .Ln, y .Z/nZ such that x =y, by: .ux = x u.= xx ux = x Tux = x uT= T x uy =T .nx = \nx n. = . x nx = x Tnx = x nT = xx ny =.. Basic Abstractions: We let .n .Z .Z/nZ de.ned as: .n(z) = let \nr =zmod n in if r =0 then r else r +n be the canonical embedding of the set Z of integers onto [0,n -1]isomorphic \nto the quotient ring Z/nZ . The abstraction an speci.es how a subset of Z/nZ should be approximated. \nThe intuition is that the empty set (\u00d8represented by .) and equivalence classes ({hc |h .Z} represented \nby .n(c) where c .Z) are preserved exactly while any other subset is approximated by Z/nZ (represented \nby T). Formally, an is de.ned by: an(Z) ={.n(z) |z .Z}. The concretization .n speci.es which subsets \nof Z/nZ are repre\u00adsented by elements of the abstract domain Ln: .n(.) =\u00d8, .n(z) ={hz |h .Z} if z .[0,n-1], \n.n(T) = Z . We obtain a Galois connection [7]: .n (P(Z),.)-.-.(Ln, )---- --. an such that for all Z .P(Z) \nand Z .Ln: (an(Z) Z) .. (Z ..n(Z)) . Basic Abstract Operations: The abstraction 0of a k-ary con\u00adcrete \noperation \u00b7 (with domain dom(\u00b7) and codomain codom(\u00b7)) should satisfy for all x1 .Ln, ..., xk .Ln [7]: \n{\u00b7(x1,...,xk)|x1 ..n(x1).....xk ..n(xk). (x1,...,xk).dom(\u00b7)}. .n(0(x1,...,xk)) . The abstract unary (k \n=1) operation 0(such as the abstract inverse e) abstracting the concrete operation \u00b7(of the inverse -) \nis de.ned as follows: 0. =., 0T=T, 0z = an({\u00b7x |x ..n(z)ndom(\u00b7)}) if z .[0,n-1] = .n(\u00b7z). The abstract \nbinary (k =2) operations 0(of addition ., subtraction eor multiplication .) for the concrete operation \n\u00b7(of addition +, subtraction -or multiplication \u00d7) are de.ned as follows: .0z =., 0.=., if z .Ln, z1 \n0z2 = an( {x1 \u00b7x2 |x1 ..n(z1).x2 ..n(z2). (x1,x2) .dom(\u00b7)}) if z1,z2 .[0,n-1] = .n(z1 \u00b7z2), T0z =T, z0T=T \nif z .Ln . Abstract Integer Variable Domain: Let n1, ..., ne be e =1 positive integers which are which \nare pairwise coprime. The ab\u00adstract domain is the product e (L, . ) =( Lni , .) (7) i=1 smashed for .and \nTwhich, by the Chinese remainder theorem, is isomorphic to the abstract domain: (L, ) = ({.,T}.Z/n1...neZ \n, ). (8) When n1 ...ne> m the analysis on (8) cannot be directly imple\u00admented using machine integers. \nIt can be replaced by an analysis with abstract domain (7), which is always more precise (and even strictly \nmore precise since one can discover that a variable is con\u00adstant modulo some nj although it might not \nbe constant modulo the product n1 ...ne). Moreover a static analysis with (7) is equivalent to e successive \nanalyzes with Ln =Ln1, ..., Ln =Lne . Abstract Environment Domain: Given the set X[ P] of vari\u00adables \nof program P, the abstract domain is extended pointwise to environments mapping variables to integer \nvalues. Recall that the set of memory states is M[ P] = X[ P] .V[ P]. We let Xint[ P] . X[ P] be the \nsubset of program variables which are of integer type. We have: ..n1...n e .------- ( P(M[ P]), .).------.( \nM[ P], \u00a8 ) -. a.n1...n e e where M[ P] = Xint[ P] . Lni i= 1 and for all m . M[ P] and m . M[ P]: e a.n1...ne(m) \n= . X . Xint[ P] \u00b7 ani ({ .(X) | . . m} ) i= 1 ..n1...ne(m) ={ . . M[ P] |. X . Xint[ P] :.i .[ 1,e]: \n.(X) . mni (m(X)i )} . All information on non-integer variables is lost while the informa\u00adtion on integer \nvariables is restricted to modular constant informa\u00adtion. Abstract Reachability Domain: Given the set \nC[ P] of con\u00adtrol points c of a program P, the abstract environment domain is extended pointwise to all \nprogram points (recall that 2[ P] = C[ P] \u00d7 M[ P]). The abstract domain L[ P] which is used for sig\u00adnature \nextraction in a program P is therefore: L[ P] = C[ P] . M[ P] satis.es the requirement (1) since: .\u00a8n1...n \ne .------- . ( P(2[ P]), .) ------.( L[ P], \u00a8 ) (9)-. a\u00a8n1...n e where given S . 2[ P] and S . L[ P]: \na\u00a8n1...ne(S) = a.n1...ne({ m |( c, m). S} ), c. C[ P] .\u00a8n1...ne(S) ={( c, m)| c . C[ P] . m . S(c)} . \n Static Analysis: Collecting Semantics: The considered concrete collecting se\u00admantics R[ P] of each \nmethod P is the set of descendants of the ini\u00adtial states of the method P with an initial environment \n.X\u00b7.V[ P] where all variables are unde.ned.  Abstraction: The extraction of the secret signature for \nthe ste\u00adgokey ( n1, ..., ne) starts with the computation of an overapprox\u00adimation of the abstract semantics \nR[ P] that is by constant  a\u00a8n1...n e propagation in the abstract domain L[ P] for each method P of \nthe program. Therefore the static analysis is purely intraprocedural on local variables of integer type \nusing the abstraction (9). In prac\u00adtice, this is equivalent to the successive (or simultaneous or paral\u00adlel) \nstatic analyses propagating constants in the abstract domains corresponding to the individual Lni , i \n= 1,...,e since: e R [ P] = R [ P] . a\u00a8n1...na\u00a8ni e i= 1 Abstract Transformer: To simplify the abstract \ntransformer F\u00a8[ P] is de.ned using the following approximations (fur\u00ad an1...n e ther re.nements to deter \nobfuscation may be necessary as discussed later): the initial state of the integer local variables is \nunde.ned (T );  the only operations taken into account in the control .ow graph are the addition, the \nsubtraction and the multiplication;  tests as well as other operations such as procedure and function \ncalls are simply ignored;  for loops, tests and branching the environment pointwise union is used at \ncontrol junction points.  Abstract Semantics: The abstract semantics  R [ P] a\u00a8n1...n e of the method \nP is de.ned as the least .xpoint of the abstract trans\u00adformer F\u00a8[ P] as de.ned in (2). It can be computed \niteratively an1...n e (3) using any chaotic or asynchronous iteration strategy, as usual in abstract \ninterpretation. The result of the analysis is the set of constants belonging to the ring Z/ni Z which \nare the constant values of local integer variables of the method P for i = 1,...,e. Application of Static \nAnalysis to Validation Watermarking: Validation watermarking [15] consists in embedding a watermark in \na software, which may be visible hence simply concatenated to the software, and yields the essence of \nthe software. This digest can be used to verify that the software is still essentially the same as when \nauthored. The essence extraction process can be (a cryp\u00adtographic digest of) the abstract reachability \nanalysis Ra[ P] for a secret abstraction a chosen such that it is essentially invariant for all versions \nof the subject software. Then a publicly available veri.er can detach the watermark from the software, \nmake the static anal\u00adysis of the software and compare the result with the watermark to check that the \nsoftware (hence, its abstract semantics) have not been modi.ed. Observe that the veri.er itself must \nnot be faked whence its integrity should be ensured by a signature or a MD5 checksum. Signature Extraction: \nThe extractor (5) uses the result R [ P] of the static analysis of the method P to extract the a\u00a8n1...n \ne stegosignature. The stegosignature c is extracted by the abstract extractor E if and only if all ci \n, i = 1,...,e are extracted from the abstract semantics R [ P] of the method P. a\u00a8n1...n e To extract \nci , the abstract extractor E has to determine whether the static analysis has detected that some local \ninteger variable of the method P has the abstract value ci at two program points at least (at least one \nshould appear after the stegomark initialization part and another one the stegomark iteration part). \nDespite the overapproximation (4), signature extraction from the watermarked method always succeeds: \nTHEOREM 1(CORRECTNESS). For all methods P . P , stegokey n1 ...ne, stegosignature c = c1 ...ce, the ab\u00adstract \nextractor En1...ne will extract the stegosignature c from the watermarked method Wn1...ne [ P](c) that \nis c . En1...ne(Ra\u00a8n1...n[Wn1...ne [ P](c)]). e More generally, we would like to prevent attacks by pro\u00adgram \ntransformation. Ideally, the probability that there ex\u00adist a polynomial syntactic program transformation \nalgorithm T that preserves the semantics S[ P] of program P (may be up to some observational abstraction \naO : . P . P : aO (S[ P]) = aO (S[T [ P]])) and that can attack the watermarked program (i.e. c . En1...ne(R \n[T [Wn1...ne [ P](c)]])) should be very low. a\u00a8n1...n e The characterization of all such transformations \nT is quite dif.cult. Hence such an ideal theorem would be hard to prove. Potential attacks are further \ndiscussed in Sec. 7, 8 and 9.  5.2 Example Subject Program: Let us consider the embedding of the stegosignature \nin the main method of the following sample pro\u00adgram: public class Fibonacci { public Fibonacci() {} \n public static void main(String[] args){ int n=Integer.parseInt(args[0]); int a=0; int b=1; for (int \ni=1;i<n;i++) { int c=a+b; a=b; b=c; } System.out.println(\"Fib(\"+n+\") = \"+b);}} For this program, we \nare only interested in the values of n and b at the .nal states reachable from the initial states as \nde.ned by its operational semantics (and this de.nes its observational abstraction aO ). Stegokey and \nStegosignature: The secret stegokey is assumed to be e =2, n1 = 30001 et n2 = 5421. The stegosignature \nis c1= 21349 and c2 = 3012. Stegomark: The stegoprogram is obtained by inclusion of the following stegomark \n(where, for clarity, the variables W and T are given explicit names of the form <W:ni :ci > and <T:ni \n:ci >,1 = i = e which, for discretion, should be chosen as more anonymous identi.ers by obfuscation). \nStegomark for c1: int <W:30001:21349>, <T:30001:21349>; <W:30001:21349> = 1; <T:30001:21349> = <W:30001:21349> \n-111353; <T:30001:21349> = <W:30001:21349> * <T:30001:21349>; <W:30001:21349> = <T:30001:21349> -47305; \n <T:30001:21349> = <W:30001:21349> * 4; <T:30001:21349> = <T:30001:21349> + 1566; <T:30001:21349> = <T:30001:21349> \n* <W:30001:21349>; <W:30001:21349> = <T:30001:21349> + 21494; Stegomark for c2: int <W:5421:3012>, <T:5421:3012>; \n <W:5421:3012> = 1; <T:5421:3012>=<W:5421:3012>+-35539; <T:5421:3012>=<W:5421:3012>*<T:5421:3012>; <W:5421:3012>=<T:5421:3012>+11445; \n <T:5421:3012>=<W:5421:3012>*658; <T:5421:3012>=<T:5421:3012>+971; <T:5421:3012>=<T:5421:3012>*<W:5421:3012>; \n<W:5421:3012>=<T:5421:3012>+4623; Stegoprogram: public class FibonacciWatermarked { public FibonacciWatermarked() \n{} public static void main(String[] args){ int n=Integer.parseInt(args[0]); int a=0; int b=1; int \nd=1; int e=35538; int f=1; int g=-111353; e=d*e; d=e+11445; g=f*g; f=g-47305; for (int i=1;i<n;i++) \n { int c=a+b; e=d*658; f=f*4; a=b; g=g+1566; e=e+971; g=g*f; e=e*d; b=c; d=e+4623; f=g+21494; } System.out.println(\"Fib(\"+n+\") \n= \"+b); }}  5.3 Lifting the Data Size Physical Limitation The physical data size limitation, as given \nby the maximal integer m which can be represented by the type int in our sample abstract watermarking \nalgorithm, can be lifted by considering integers of arbitrary size in the stegomark and stegoprogram \nnon-standard se\u00admantics whence in the abstract semantics R\u00a8[ P] computed an1...nby the static analyser. \ne For the static analyzer, the concrete interpretation of modulo arith\u00admetic operations is in Z (whence \nnon-standard for the program se\u00admantics). To handle this non-standard semantics correctly, the static \nanalyzer must use libraries of big numbers. Of course such big numbers could also have been used in the \nstegomark but this would be too easily recognizable. The concrete execution of the instructions of the \nstegomark inlaid within the stegoprogram may over.ow. Fortunately this is com\u00adpletely harmless with the \nstandard integer modulo arithmetic. The only limitation to be taken into account is for the constants \n(like k0, k1, a, b, c) appearing in the text of the stegomark, which must be within the physical limitation \nimposed by the language. When too large in the standard concrete semantics, these constants can be computed \nin the non-standard semantics by program expressions using only constants satisfying the physical limitation \nimposed by the language standard semantics. Actual evaluation of the stego\u00admark (with over.ow in the \nstandard concrete semantics but not in the non-standard one) will then be harmless thanks to modulo arith\u00admetic. \nIn case m is chosen much larger than the physical limitation and is kept secret, the stegosignature extraction \nis even harder if not impossible.  6. Requirements Satis.ed by Abstract Software Watermarking Our abstract \nsoftware watermarking method satis.es a number of criteria discussed below which are advisable for all \nsoftware wa\u00adtermarking methods (e.g. to be effective in the protection of the ownership of intellectual \nproperty). 6.1 Practical Requirements Satis.ed by the Watermarks Functionality Preservation: The watermarking \nshould preserve the functionality of the subject program and so the semantics of the stegoprogram W[ \nP](s) should be identical as that of the subject program P 3. Formally, this means that up to some observational \nabstraction aO , the operational/denotational semantics S are the same and so for all P . P and s . S: \naO (S[ P]) = aO (S[W[ P](s)]) = aO (S[I[ P, Mr (s)]]). Typically the abstraction aO gets rid of the auxiliary \nvariables and the effect of the code which are inlaid in the subject program to encode the signature. \nPerformance Preservation: The performance of the subject program should not be signi.cantly degraded. \nOur abstract soft\u00adware watermarking method preserves execution time up to some small constant factor \n(which is negligible for large programs). 3 up to e.g. a little more time and memory consumption for \nex\u00adecution of the stegomark. Universality Preservation: If the subject program is universal (i.e. can \nbe executed on any hardware with appropriate compiler or interpreter) then no special hardware should \nbe required for ex\u00adecuting the stegoprogram (contrary to native code with encrypted signatures [6]). \nUnbounded Signature Size There should be no bound on the size of the signature (or it should be very \nlarge) thus allowing embedded signatures to be arbitrarily encrypted unique identi.ers. This is achieved \nboth by decomposition of signatures c of size strictly bounded by n1 ...ne into e keys (c1,...,ce).[0,n1 \n-1]\u00d7...\u00d7[0,ne -1] [Sec. 4.1] and by choosing large ni , i =1,...,n beyond the machine limitation m thanks \nto a non-standard reinter\u00adpretation of modulo arithmetic in Z [Sec. 5.3]. Credibility and False Recognition: \nSince the signature uniquely identi.es the copyright owner, the watermarking should provide an authentic, \nclear, secure and indubitable proof that the stegoprogram is protected (as opposed to a false recognition \nor a probabilistic detection). For the watermarking to be credible, most programs should be unmarked \nthat is the extraction of stegosig\u00adnature from programs in which no signature has been embedded should \nnot produce a false recognition. Formally, for all P, Q .P and s .S such that Q =W[ P](s), we should \nhave: s . E[ Q] . (10) Of course, theorem 5.1 does not exclude false positives (since we want to be able \nto watermark the same method several times with the same stegokey). This means that it is possible to \n.nd a sub\u00adject program variable which happens to be a constant . in Lni for some i .[1,e]. This constant \n. might create an ambiguous result at extraction time whenever 0 =. =ci in contradiction with (10). A \nsimple solution is to perform a signature extraction just af\u00adter signature embedding to check that this \ndoes not happen. If this happens one can either change the stegokey ni used for em\u00adbedding/extraction, \nor change the stegosignature ci in the secret database of stegosignatures (for the given stegokey ni \n), or main\u00adtain . as invalid for the stegosignature ci for the program P in the secret database for the \nstegokey ni , etc. Secrecy: The watermark, i.e. the stegomark inlaid in the subject program, should not \nreveal the signature when discovered by the average observer (but should be readily detectable by the \nproper authorities). In case the stegomark can reveal the signature, it is a good practice to encrypt \nthe signature encoded within the stego\u00admark. Extracting the Signature from the Stegomark: It should be \nimpossible, or at least computationally hard, to extract the stegosig\u00adnature s .S from the stegomark \nMr (s). As in many cryptographic methods, this is based on the use of a random stegokey n .N which is \nkept secret, so that the stegomark: int W; ... W = P(1); ... W =Q(W) can hardly reveal the signature \nwhich is left invariant by the stego\u00admark computation. Indeed, given polynomials P and Q, the ques\u00adtion \nis to solve for the unknown x, n where: x = P(1)mod n x = Q(x)mod n . Following [12], let us set Q ' \n(X)= Q(X)-X,sowenow have x = P(1)mod n 0 = Q ' (x)mod n or equivalently 0 = Q ' (P(1))mod n. Anyone can \ncompute Q ' (P(1)), which is some number i, and the problem is now to .nd n such that i =0 mod n which \nessentially amounts to factor i in order to .nd one factor of i (or even all of them). Factoring can \nreasonably be assumed to be hard for large factors. Hence one might want to check that i has large factors \n(which is easier when already knowing the factor n) and consider lifting the data size physical limitation \nas explained above. In prac\u00adtice extracting the stegosignature s without knowing the secret ste\u00adgokey \nn then essentially amounts to randomly trying all possible stegokeys n .N (or, at least a very large \nnumber of the possible stegokeys). Extracting the Stegomark from the Stegoprogram: Finally, it should \nbe impossible, or at least computationally hard, to auto\u00admatically discover the stegomark within the \nwatermarked program W[ P](s) = I[ P, Mr (s)]). Obfuscation methods are helpful for that purpose. Again \nthe static analysis method for signature ex\u00adtraction proposed in Sec. 5.1 En[Wn[ P](s)] depends on the \nsecret stegokey n so that when n is unknown, the signature extraction es\u00adsentially amounts to randomly \ntrying all possible stegokeys. Robustness/Perenniality: The watermarks should be perma\u00adnent. If visible, \nthey should be hard or impossible to remove with\u00adout investing a lot of time and/or without severely \ndamaging the ste\u00adgoprogram so much that it becomes hardly usefully usable or leave traces on the modi.ed \nstegoprogram which can be immediately de\u00adtected by comparison with the undamaged subject program. If \nnot impossible, it should be computationally hard to re\u00adcover the subject program P from the stegoprogram \nW[ P](s) = I[ P,Mr (s)]. One solution is for the software watermarker W[ P](s) to include an obfuscation \nof the stegoprogram. However this is not mandatory since obfuscation pursues different objectives. Moreover, \nand contrary to [2], we do not aim at obfuscating the observable semantics aO (S[ P]) of the program \nP (which can be speci.ed e.g. in a publicly available reference manual). Multiple Watermarks: Abstract \nsoftware watermarking allows several different signatures to be embedded in the stegoprogram hence is \nrobust against rewatermarking. Formally, marking with a new signature should not delete previous signatures: \n' if s .E[ P] then s .E[W[ P](s )] . The number of signatures should be unbounded (or very large) at \nthe time that the subject program is created. Indeed the value of the stegokey n .xes the number of possible \nstegosignatures for that ste\u00adgokeys, but the number of stegokeys is itself unbounded. Moreover if a program \nis signed several times, the extractors are only able to recover the signatures for which they are authorized \nprovided they are given different stegokeys n. Fingerprinting: The abstract software watermarking method \ndoes allow .ngerprinting to uniquely mark each program for ev\u00adery buyer by a unique licence number. If \nthat buyer then makes an illicit copy, the illicit duplication may be convincingly demon\u00adstrated by extracting \nthe stegosignature which is the given licence number. 6.2 Practical Requirements Satis.ed by the Abstract \nEmbedding/Extraction Algorithms Our stegosignature embedding/extraction algorithms satisfy the fol\u00adlowing \nrequirements which are desirable for all software water\u00admarking tools. Automaticity: Signature embedding \nand extraction are fully au\u00adtomatic and require no manual preparation of the subject program. Hence they \nare usable on a large scale and allow for checking of legal use, e.g. on the web. Low Cost: Signature \nembedding and extraction have a low com\u00adputational complexity, comparable to compilation. Resistance \nto Counterfeiting: The watermark should withstand direct and automatic attacks (e.g. by creation of counterfeit \nof the subject program using typical automatic program transformations that are common to program manipulation \napplications such as ob\u00adfuscation) but not disallow the copying of the signed .le. Formally, the watermarking \nshould resist program transformations T . P . P that do not change the observable abstraction of the \nsubject program semantics. This means that for all P . P , s . S: if aO (S[W[ P](s)]) = aO (S[T [W[ P](s)]]) \nthen E[W[ P](s)] = E[T [W[ P](s)]] . In our case, the static analysis can be made more dif.cult so this \nproblem is further discussed in Sec. 9. Resistance to Fraudulent Reuse Including with Hardware Protection: \nSince extraction requires no execution of the stego\u00adprograms at all, it is possible to extract the signature \nof the stego\u00adprogram if only part of it is available but not executable (provided obviously that the \navailable part of this stegoprogram contains the stegosignature). This makes possible the tracking of \nstegoprograms on the web or of parts of the stegoprogram included in another pro\u00adgram itself protected \ne.g. by a hardware dongle. Public Domain: The embedding/extraction algorithms can be made public since \nthey require a secret stegokey (but not the sub\u00adject program) for extraction. Moreover different extractors \ncan be authorized owning different stegokeys without possible interactions between them. Pervasion: The \nembedding/extraction of the signature in the ste\u00adgomark is symmetric since both depend on the same secret \nstegokey (n in Sec. 6.1). As noted by [12], it may be absolutely necessary to disclose information from \ntime to time which may require, in ab\u00adsence of trusted third authority, to make public the secret stegokey. \nIn this case, copies of the software previously watermarked using the same stegokey, will be unprotected \nafter the .rst action taken to enforce the watermark. One solution is to use .ngerprinting, that is a \nunique stegomark for each copy of the software with different stegokeys or to insert several stegomarks \nin all copies. A complementary solution is to choose the stegosignature s and the stegokey n as large \nprimes (assuming again that the data size phys\u00adical limitation is lifted for unbounded signature size \nas in Sec. 5.3). The stegoprogram is marked with s by inserting the stegomark ini\u00adtialization part: W \n= P(1) in Z and the stegomark iteration part: W = Q(W) in Z such that: P(1) = s in Z/nZ and s = Q(s) \nin Z/nZ as discussed in Sec. 4.2. The stegoprogram is then deposited with accompanying signatures s.pi \nwhere the pi , i = 1,...,k are large prime numbers for safekeeping by one or better several trusted third \nparties. In order for an unbiased third party to equitably verify that the stegoprogram is signed, the \nveri.er is given (at the i-th veri.ca\u00adtion): the stegosignature s.pi ;  the abstract stegosignature \nextractor E;  the stegokey n.pi .  By ensuring that P(1) = s.pi in Z/n.pi Z and s.pi = Q(s.pi ) in \nZ/n.pi Z the veri.er can check that the stegoprogram is signed by s.pi and can do the same with the originally \nsigned program. If the information (E,s.pi ,n.pi ) is made public, claimants might be able to discover \nthe signature s.pi by designing their own pro\u00adgram analyser. This may be a good reason to keep the extractor \nE private, or at least to have the extractor not reveal where the ste\u00adgomark is within the stegoprogram, \nand shows the necessity for deterring attacks on stegomarks as discussed in next Sec 7. Never\u00adtheless, \nneither s nor n can be computationally discovered so that (s.pi+1,n.pi+1) can be used for the next veri.cation \nof stegopro\u00adgrams whose stegomark is persistent.  7. General Attacks on Signatures and Stegomarks Manual \nattacks against watermarked programs can hardly be avoided if enough manpower and time are available, \nso we con\u00adcentrate on automatic attacks. Let us recall the various attacks con\u00adsidered by [3]: Subtractive \nattacks detect the presence and approximate location of the stegosignatures and eliminate the part of \nthe program where it is supposed to be located. Examples of subtractive attacks in\u00adclude static dead \ncode elimination in case the stegosignatures are supposed to be hidden in dead code (see e.g. [14]) or \ndynamic ob\u00adservation of the dead code in case the dead code is protected by an opaque predicate (opaque \nmeans that the outcome of the predicate is known at watermarking time but the predicate is dif.cult for \nan adversary to resolve i.e. to .nd the truth value solution of [1, 6, 14]). Distortive attacks apply \ntransformations to the object so that the stegosignatures can no longer be extracted. Obfuscation and \nop\u00adtimizing compilation to generate machine code are such distortive attacks. Another example is [19] \nwhere secrets are hidden in se\u00adquences of machine code, which can be easily distorted by replac\u00ading machine \ninstructions by equivalent ones. Additive attacks watermark with new signatures so that one can\u00adnot be \nproved that the original mark temporally precedes the pirate ones. Collusive attacks remove signatures \nby comparison of different versions of the same program watermarked by different .nger\u00adprints. An example \nwould be diff (which is na\u00efve since it can be easily defeated by obfuscation). For example [3, 16] encodes \nsignatures into graphs generated when executing the program for special inputs. Program monitoring or \na probabilistic static analysis can be used to discover the parts of the program that are seldom executed. \nThen a dependence analysis as in program slicing can be used as a subtractive attack eliminating the \npart of the program producing the graph. A distortive attack would modify the graph whence the signature. \n 8. General Attack Deterrence Subtractive attacks are made dif.cult if the elimination of the sig\u00adnature \nchanges/destroys the semantics of the program so that it be\u00adcome unusable. Therefore a good strategy \nis to make the stegomark dependent upon the subject program and reciprocally e.g. by trans\u00adforming the \nsubject code so that some values are computed as func\u00adtions of the stegomark or have original and stegovariables \nmerged, a well-known distortive attack! Distortive attacks may not all be disturbing. For example ob\u00adfuscation \nmakes reverse engineering even more dif.cult so might sometime be considered helpful. The same way code \ngeneration prevents easy redistribution hence is also a form of protection. Some distortive attacks can \nbe prevented by considering only part of the code to extract signatures. Many of the obfuscation methods \nconsidered in [5, 6] can be defeated in this way. For example in\u00adtroducing dead and irrelevant code or \nconverting a reducible to an irreducible .ow graph does not change the abstract interpretation of the \nuseful code. The same way, opaque test and loop predi\u00adcates [1, 6, 14] is no problem if the signature \nextraction does not depend upon predicates. However the embedding might include such opaque predicates \nfor obfuscation purposes. Restructurations of classes (such as modifying inheritance relations, extending \nthe inheritance hierarchy tree, false refactoring, method inlining, clone methods as considered in [5]) \nare ineffective if the signatures are embedded at the method level and the signature extraction is purely \nlocal, not depending on global variables. Some other distortive attacks can be prevented by considering \nonly part of the program data to extract signatures. Among the obfus\u00adcation methods, array restructuration \nconsidered in [5] and object aliasing considered in [6] can be simply defeated by putting no data in \nstructured static or dynamic data. Additive attacks are dif.cult to .ght in particular if the embed\u00adding \nalgorithm is made public. Note however that unique signatures as well as original and signed programs \ncan be revealed to trust\u00adworthy authorities at the embedding time to authenticate temporal precedence \nwhence determine the actual owner of the program. Collusive attacks can be prevented by allowing the \nembedding of multiple signatures. A common initial watermark can be embedded in all copies. Moreover \nobfuscation of the copies using different program transformations (including e.g. different code reorderings) \nwould make comparisons very dif.cult. Obviously not all possible attacks have been considered. The most \nharmful ones will be discussed in next Sec. 9. 9. Possible Harmful Speci.c Attacks The considered signature \nembedding and extraction methods dis\u00adarm the general attacks considered in Sec. 7. We now consider spe\u00adci.c \nattacks against the protocol as described in [3, 6] that might be harmful. Obfuscation methods are obvious \ncandidates for pre\u00adventing signature extraction by making static analysis dif.cult, if not impossible. \nFirst note that if the protection is required at the method level we might be happy to consider only \nattacks which affects a method at a time. Otherwise the method is no longer ex\u00adtractable from the whole \nprogram, which can be considered as a form of protection against illicit use. However most attacks aims \nat hiding the copyright so that masked signature redistribution in the large should be considered harmful. \nCounter-attacks may be classi.ed as follows: Light-weight counter-attacks essentially consist in improving \nthe general-purpose abstract signature extractor for routine use (or us\u00ad ing several ones with different \nanalysis strategies according to the possible obfuscation strategies). Heavy-weight counter-attacks \nmay need human help and the sub\u00adject program in order to built a speci.c abstract signature extractor \nfor a case study (e.g. to prove copyright infringement). 9.1 Subtractive Attacks and Tamper-Proo.ng \nCounter-Attack One can easily design a dependence analysis to discover which lo\u00adcal variables of the \nmethod will have no effect on the method com\u00adputation. The auxiliary variables W and T could be located \nin this way and the corresponding embedding instructions eliminated by program dependence analysis and \nslicing. Classical tamper-proo.ng methods can detect if the program has been altered and cause the program \nto fail when. tampering is evi\u00addent [4]. They can therefore be used to prevent subtractive attacks. A \nsimple tamper-proo.ng method to avoid automatic subtractive attacks consists in creating dependencies \nbetween the subject pro\u00adgram and the inserted code. We consider three examples: 1. values can be allocated \non the heap instead of in variables which make live/dead variable analysis much more dif.cult; 2. one \nmay, on one hand, have the random values a and b be chosen as values of the program integer constants, \nhave c be computed in terms of a and b and then a recomputed back in terms of b and c and b recomputed \nback in terms of a and c. This false dependency could only be discovered by symbolic computation which \nis beyond the scope of most compilers and obfuscators; 3. since the static analysis does not take tests \ninto account, opaque predicates [1, 6, 14] can be used to anchor the stegomark statements inlaid in the \nstegoprogram by creating interferences between the two which spuriousness or genuineness is computationally \ndif.cult, if not impossible to detect. Let W be an integer variable used in the stegomark, V be a variable \nused in the subject program, let B(V, W) be an opaque predicate which is always false (like B(x, y) =7y2 \n- 1 = x2 where x, y . Z [1]) and g(V, W) be any integer expression depending upon V and W. Then a stegomark \nstatement of the form W = f (W) can be anchored in the stegoprogram in the form:  if (B(V, W)){W= f \n(W);V= g(V, W) } Since the value of the subject program variable V depends upon the value of the stegovariable \nW, it is hardly possible for an obfuscator to determine that the opaque predicate B is always false and \nso the value of W is thought to be indispensable so that the stegomark can\u00adnot be eliminate. If this \nunexecuted code can be located by run-time observations, then variants can use an opaque predicate B \nwhich is not identically false as in: if (B){V ' = V; W = f (W);V= g(V, V ' , W) } ... if (B){V=V ' \n} Just in case, we propose a more advanced and original method to create a dependence between the stegomark \nand that of the subject method. For that purpose, we can use properties of the stegovariable W which \nhold in the standard semantics (more precisely signed 32 bits arithmetic). This is possible, for example, \nwhen the stegokey n is a power of 2. Indeed, assume that n = 2k . Then, we have: W = v + a.2k in Z . \nWe also have, always in Z, that, for all j . k : W%2 j = v %2 j where x%y denotes the operation returning \nthe rest of the euclidean division of x by y. Observe that this property remains trivially true in Z/232Z \nwhich is the domain of value of integer variables in JavaTM. We can therefore use these arithmetic properties \nto mod\u00adify the computations of the subject method in which the stegomark is inlaid. For example, assume \nthat n =216 and that v =18. Then whichever the value of the variable W is, we always have: W%4 =2 . If, \nfor example, the constant 1 appears explicitly in the subject pro\u00adgram, then it can be replaced by W%4 \n-1. Now, if the variable W is dynamically modi.ed using the techniques developed in Sec. 4, the variable \nW takes values during program execution which apparently stochastic, but have a hidden invariant which \nis used for stegomark anchoring. The stegoprogram thus modi.ed preserves its original concrete semantics \nbut would be irreversibly damaged if the stego\u00admark is eliminated. An involved static [11] or dynamic \nanalysis of the behaviour of the variable W is necessary to detect the invariant on which relies the \ndissimulation. Moreover, such constant dis\u00adsimulations can be automatically generated at random points \nof the program. 9.2 Subtractive Attacks on Low Stealthiness and Counter-Attacks Static Attack on Low \nStealthiness: As shown in the example of Sec. 5.2, this watermarking scheme often results in very unusual \ninteger literal constants being inserted into the program. Literal constants with 5 or 6 digits as in \nthe example can be extremely rare in real programs. An anonymous referee collected and classi.ed all \nthe integer literals from some 600 Java programs, 1.4 million lines in all and observed that 80% of all \nliteral integers are between 0\u00ad99, 95% are between 0 and 999, 92% are powers of two or powers of two \nplus or minus 1. Because of this lack of stealthiness, the anonymous referee suggested that an attacker \ncould expect to be able to locate the watermark code simply by looking for large literal constants. A \nlight-weight counter-attack would be to compute large constants in term of small ones privileging powers \nof two or powers of two plus or minus 1 in this computation. A diversion would consists is spreading \nlarge integers elsewhere in the code, may be with dependences so that there elimination would make the \ncode inoperative. In the same line one can try to detect the iterations of polynomials of degree greater \nthan or equal to 2, which are operations rarely occuring in practice. When the stegokey n =2k is a power \nof 2, a static attack consists in extracting modulo n ' where n ' is is the greatest power of 2 dividing \n'' i =Q ' (P(1)). This yields c =P(1)mod n such that the value of ' the signature c corresponds to the \nk lower bits of c . Since k is un\u00adknown, this provides only partial information on c, maybe too much \nfor this choice to be considered safe. This shows that in all cases the stegosignature c should be an \nencryption of the information not to be revealed. In all cases, an obvious counter-attack on low stealthiness \nwould be to hide the stegomark using a non-standard concrete semantics for signature extraction. Dynamic \nAttack on Low Stealthiness: In Sec. 4.2, we observed that the variable W will take on values that are \nstochastic . An anonymous referee suggested to monitor the program execution to look for integer variables \nupdated within loops whose values are random. A light-weight counter-attack consists in making the stegomark \nseldom executed together with pseudo-random number generators spread in the program for diversion. Other \nappropriate datatype obfuscations are considered in Sec. 9.5, including using a nonstandard semantics \nof (e.g. heap-allocated) .oating point num\u00adbers for which such dynamic attacks would be much harder. \nDynamic Attack on Unusual Variable Values: An anonymous referee suggested to monitor the execution to \nkeep track of the se\u00adquence of values i0, i1, ..., ik successively taken by all integer variables I of \nthe program. If I is a watermark variable then nj |g for some j .[1,e]where g =gcd(i1 -i0,i2 -i0,...,ik \n-i0).A large g is an indication that I might be a watermark variable and provides information on nj for \nfactoring. A light-weight counter-attack consists in exploiting the random\u00adness in tests so that some \nassignments to watermark variables are rarely executed whence leading to a small k. Extraction is un\u00adchanged \nsince tests are ignored. Another counter-attack is to rely on a non-standard semantics for the static \nanalysis as considered e.g. in Sec. 5.3 since the above reasoning assumes the concrete values of watermark \nvariables that are abstracted for extraction to be their execution values. 9.3 Reinterpretation and \nCounter-Attack Reinterpretation or table interpretation consists in reencoding the program for a different \nvirtual machine code. If the virtual machine speci.cation is secret then again signatureless redistribution \nis im\u00adpossible in the large whence might be considered harmless. Otherwise this may require the redesign \nof the abstract interpreter used for signature extraction in order to take the virtual machine code into \naccount. This might require rewriting the abstract signa\u00adture extractor for all (known) JavaTM virtual \nmachines, an obviously heavy weight counter-attack. 9.4 Control Obfuscation and Counter-Attack The objective \nof control obfuscation is to obscure the control .ow without changing what the code does at runtime. \nTypically, selec\u00adtion and looping constructs are changed so that they no longer have a direct JavaTM \nsource code equivalent. Let us consider several clas\u00adsical such transformations. Sequential Code Reordering \nand Counter-Attack: Reorder\u00ading of the code sequential composition, test and loop statements must preserve \nthe order in which the elementary statements are ex\u00adecuted in a method (unless this order is irrelevant) \nand so the static analysis of Sec. 5.1, which does not take the control structure of the method into \naccount, is insensible to this transformation. If neces\u00adsary, goto statements can easily be handled in \nstatic analysis. Proceduralization and Counter-Attack: Conversion of static to procedural data (make \na procedure to compute a value instead of original constant). Constant propagation can be trivially extended \nfrom the intrapro\u00adcedural case considered here for stegosignature extraction to the interprocedural case \n[18], in which case the extraction technique remains the same. Outlining and Counter-Attack: Splitting \na method into several disjoint methods (e.g. by inlining and different reproceduraliza\u00adtion). Again the \ncounter-attack is interprocedural constant propagation. Parallelization and Counter-Attack: Conversion \nof sequential to parallel programs. Again the transformation must preserve the order in which the ele\u00admentary \nstatements are executed so the static analysis of Sec. 5.1 is insensible to this transformation. Otherwise, \nthe static analysis can be extended to parallel programs (see e.g. [8]). 9.5 Data Obfuscation and Counter-Attack \nAnother form of obfuscation is data obfuscation where the program global, local and heap data are reallocated \nin more complex struc\u00adtures. We now consider a few examples. Globalization and Counter-Attack: Replaces \nall or some local variables into global variables. This might be easily taken into account by the analyser \nwhich could also consider global integer variables, either all possible global vari\u00adables or only the \nnecessary ones, which may not be very dif.cult to detect for those possessing the subject code (the list \nof such global variables might be a parameter of the static analysis). Built-in Datatype Reallocation \nand Counter-Attack: Put all data in arrays or heap allocated structures. First note that the ab\u00adsence \nof simple datatype variables is quite suspect. But not moving all simple variables means that the ones \nused to hide watermarks might be omitted. Using arrays means that constant propagation can detect indices \ndesignating simple variables so heap allocated structures should be preferred. But then note that if \nthe obfuscator is likely to create a small dynamically allocated structure so that its shape might be \neasily determined by analysis algorithms using a threshold widening [17]. Otherwise cache behaviour and \naddi\u00adtional garbage collection might severely worsen the program per\u00adformance. Then note that this idea \nmight be used to hide the stegovariables in dynamically allocated data structures which could hardly \nbe modi\u00ad.ed by obfuscating by fear of modifying the program semantics but for which the signature extraction \nwould be possible by designing analysers speci.cally for the type of structure which is used (e.g. balanced \ntrees [9]). Built-in Datatype Obfuscation and Counter-Attack: Obfus\u00adcating built-in datatypes (such as \nintegers and strings) by variable splitting and merging. To do so, obfuscators routinely use the alge\u00adbraic \nlaw of integer arithmetic to transform the code. For a trivial example, consider the assignment: e=35538; \nwhich can be transformed into: f=71077; e=(f-1)/2; Since the integer division is not used in the stegomark, \nthe static analyser need not implement the abstract version of integer divi\u00adsion, which will be simply \nignored, whence obliterating the signa\u00adture extraction. An obvious riposte is for the static analyser \nto anticipate all such possible obfuscating transformations and to: 1. use non-standard semantics which \nare invariant under such transformations (which, e.g. might not be the case when interpret\u00ading modulo \narithmetic as integer arithmetic); 2. implement all abstract operators corresponding to the concrete \noperators that can be used for program transformation by obfusca\u00adtors; 3. obfuscate the code in order \nto prevent further obfuscations.  A complementary solution consists in relying on program con\u00adstructs \nfor which data and operation transformation is very dif.cult. This is the case for example for .oating \npoint arithmetic which does not satisfy the usual mathematical identities (such as associativity, commutativity, \netc) which are valid for the reals. It follows that obfuscators will have more dif.culties to modify \nall .oating point operations, except trivially. Consequently, a simple riposte to obfuscation is to implement \nthe stegomark with .oating point arithmetic. Care must be taken to prove the absence of over.ow (since \n.oating point arithmetic is not modular) or to catch all potential exceptions that can be raised in the \nstegomark and to annihilate their effect. It follows that the stegomark does not perturb the normal stegoprogram \nexecution. Now in the non-standard semantics which is used for signature ex\u00adtraction, and therefore in \nthe abstract semantics for the static anal\u00adysis, all .oating point operations of the stegoprogram can \nbe inter\u00adpreted as integer operations. The translation is simply one to one for arithmetic operators. \nFloating point constants must be converted into integers (may be up to some secret factor). 10. Implementation \nThe abstract software watermarker that we have designed and used for our experimentation is based on \nSOOT [20] which is a static analyser generator for JavaTM itself written in JavaTM. The SOOT optimizing \nframework offers different possible interme\u00addiate representations of JavaTM source programs. For simplicity, \nwe assume that the subject program P . P is represented in Jim\u00adple style [20] , that is unstructured \nstackless 3-address code using typed auxiliary variables. Moreover, we can also assume that the jsr bytecode \nhas been eliminated and the intermediate code is or\u00adganized as a control .ow graph of basic blocks. A \ndecompiler is necessary to see the Jimple code in JavaTM form. The stegosignature embedder is implemented \nas speci.ed in Sec. 4. The implementation of the extractor essentially amounts to that of the basic abstract \ndomain, as well as the abstract environments, of the corresponding basic abstract operations and those \nused in the abstract transformer in SOOT. Then SOOT can generate automati\u00adcally the static analyser described \nin Sec. 5.1. Finally, the abstract software watermarker has essentially to maintain a database of own\u00aders \nof stegokeys and corresponding stegosignatures and provides an elementary user interface. 11. Experiments \nEf.ciency: The abstract software watermarking takes no addi\u00adtional developer time (but to choose which \nmethods should be wa\u00adtermarked, to choose a stegosignature and to submit the subject software to the \nautomatic stegosignature embedder). The recogni\u00adtion time to extract the stegosignature is comparable \nto compilation time and so is ef.cient. The runtime costs are also negligible since for medium and large \nprograms we could not observe signi.cant modi.cations in the re\u00adquired memory and computation time resources. \nRobustness: We have conducted several experiments which con\u00adsist in watermarking one method in a class, \nthen in obfus\u00adcating the class with JavaTM obfuscators (JcloakTM and Zelix klassmaster) and then in extracting \nthe signature from the ob\u00adfuscated class. After a few improvements of the static analyser as described \nin Sec. 9, these obfuscators mainly using name obfusca\u00adtion, .ow obfuscation and string encryption could \nnot disarm the stegosignature extraction. Consequently, obfuscators can be used after signature embedding \nto obscure the work of stegoanalysts. 12. Conclusion We have proposed a new class of software watermarking \nand .n\u00adgerprinting methods called abstract software watermarking. The key idea is to anchor a stegomark \nin the program, that is state\u00adments which static analysis will reveal the stegosignatures. We exempli.ed \nan instance based on modular constant propagation parametrised by a secret stegokey, which is equivalent \nto in.nitely many distinct instances of the abstract watermarker. The key idea is that the stegosignature \nextraction is neither static (it is based on the semantics of the program not on its syntax), nor dynamic \n(pro\u00adgram execution does not reveal the stegosignature) but abstract (the stegosignature is revealed \nby abstract interpretation of a (may be non-standard) state or trace-based collecting semantics of the \npro\u00adgram). Since static analysis is undecidable (even for simple anal\u00adyses like constant detection), \nthe static analyser which is used for extraction can be designed to be involved enough so that extrac\u00adtion \nis impossible if the extraction algorithm is not perfectly known. Even if the signature extractor is \nmade public, it is still possible to use abstract domains parametrised by secret stegokeys which make \nsignature extraction computationally hard, if not impossible. It is clear that stegoanalysis against \nthis new class of abstract soft\u00adware watermarkers will improve. In response, the abstract soft\u00adware watermarking \nframework allows considering more sophisti\u00adcated abstract interpretation-based static analysers thus \nmaking ste\u00adgoattacks even more dif.cult. As is the case in cryptography, the rivalry between watermarkers \nand attackers may be endless and the source of much progress. Acknowledgements: This work was supported \nby the RNRT ( R\u00e9seau National de Recherche en T\u00e9l\u00e9communications of the french Minist\u00e8re de la Recherche \nand the Minist\u00e8re de l \u00c9conomie, des Finances et de l Industrie ), project n. 95 Tatouage \u00e9lectronique \ns\u00e9mantique de Code Mobile Java , 1999 2002. We thank J. D. GUTTMAN for his help with Sec. 6.1 and for \ninspiring Sec. 6.2, M. RIGUIDEL for bringing our attention to software watermarking, A. VENET for his \nparticipation in the early stage of the project, the Sable Research Group at McGill Univer\u00adsity, Montreal, \nCanada, in particular L. HENDREN,P. LAM and F. QIAN, for their help in the use of SOOT, especially during \nP. COUSOT s visit at McGill in September 2000, B. BLANCHET,J. FERET,A. MIN\u00c9,D. MONNIAUX,X. RIVAL and \nthe anonymous referees for their shrewd comments. 13. References [1] ARBOIT, G. A method for watermarking \nJavaTM programs via opaque predicates. In Proc. Int. Conf. Electronic Commerce Research (ICECR-5) (Montreal, \nCA, 23 27 Oct. 2002). [2] BARAK, B., GOLDREICH, O., IMPAGLIAZZO, R., RUDICH, S., SAHAI, A., VADHAN, S., \nAND YANG,K. On the (im)possibility of obfuscating programs. In Proc. CRYPTO 2001, Santa Barbara, CA, \nLNCS 2139 (19 23 Aug. 2001), J. Kilian, Ed., Springer, 1 18. [3] COLLBERG, C., AND THOMBORSON, C. Software \nwater\u00admarking: Models and dynamic embeddings. In 24th POPL (San Antonio, TX, 20 22 Jan. 1997), ACM Press, \n311 324. [4] COLLBERG, C., AND THOMBORSON, C. Watermarking, tamper-proo.ng, and obfuscation tools for \nsoftware protec\u00adtion. IEEE Trans. Software Engrg. 28, 8 (Aug. 2002), 735 746. [5] COLLBERG, C., THOMBORSON, \nC., AND LOW, D. Break\u00ading abstractions and unstructuring data structures. In Proc. 1998 ICCL (Chicago, \nIL, 14 16 May 1998), IEEE Comp. Soc. Press, 28 38. [6] COLLBERG, C., THOMBORSON, C., AND LOW, D. Manu\u00adfacturing \ncheap, resilient, and stealthy opaque constructs. In 25th POPL (San Diego, CA, Jan. 1998), 184 196. [7] \nCOUSOT,P., AND COUSOT, R. Systematic design of program analysis frameworks. In 6th POPL (San Antonio, \nTX, 1979), ACM Press, 269 282. [8] COUSOT,P., AND COUSOT, R. Invariance proof methods and analysis techniques \nfor parallel programs. In Automatic Program Construction Techniques, A. Biermann, G. Guiho, and Y. Kodratoff, \nEds. Macmillan, 1984, ch. 12, 243 271. [9] GHIYA, R., AND HENDREN, L. Is it a tree, a dag, or a cyclic \ngraph? a shape analysis for heap-directed pointers in C. In 23rd POPL (St. Petersburg Beach, FL, 1996), \nACM Press, 1 15. [10] GOSLER, J. Software protection: Myth or reality? In Proc. Advances in Cryptology \n CRYPTO 85, LNCS 218 (Santa Barbara, CA, 18-22 Aug. 1985, 1986), H. Williams, Ed., Springer, 140 157. \n[11] GRANGER, P. Static analysis of arithmetical congruences. Int. J. Comput. Math. 30 (1989), 165 190. \n[12] GUTTMAN, J. D. Private communication. 21 Jan. 2003. [13] KILDALL, G. A uni.ed approach to global \nprogram opti\u00admization. In 1st POPL (Boston, MA, Oct. 1973), ACMpress, 194 206. [14] MONDEN, A., IIDA, \nH., MATSUMOTO, K., INOUE, K., AND TORII, K. A practical method for watermarking JavaTM pro\u00adgrams. In \n24th IEEE Computer Software and Applications Conf. , Compsac 2000 (Taipei, Taiwan, 25 29 Oct. 2000), \n191 197. [15] NAGRA, J., COLLBERG, C., AND THOMBORSON,C. A functional taxonomy for software watermarking. \nIn 25th Aus\u00adtralasian Computer Science Conf. (ACSC 2002) (Melbourne, Australia, Jan. 2002), M. J. Oudshoorn, \nEd., Conferences in Research and Practice in Information Technology, ACS. [16] PALSBERG, J., KRISHNASWAMY, \nS., KWON, M., MA, D., SHAO, Q., AND ZHANG, Y. Experience with software water\u00admarking. In Proc. 16th ACSAC \n00, New Orleans, LA (11 15 Dec. 2000), IEEE Comp. Soc. Press. [17] SAGIV, M., REPS,T., AND WILHELM, R. \nShape analysis. In Proc. Int. Conf. CC 2000, LNCS 1781 (Berlin, DE, 25 Mar. 2 Apr. 2000), D. A. Watt, \nEd., Springer, 1 17. [18] SAGIV, M., REPS,T., AND HORWITZ, S. Precise interpro\u00adcedural data.ow analysis \nwith applications to constant propa\u00adgation. Theoret. Comput. Sci. 167, 1&#38;2 (1996), 131 170. [19] \nSTERN, J., HACHEZ, G., KOEUNE,F., AND QUISQUATER, J.-J. Robust object watermarking: Application to code. \nIn Proc. 3rd Int. Work. on Information Hiding, IH 99 (Dresden, DE, 29 Sep. 1 Oct. 1999), A.P.tzmann, \nEd., vol. 1768 of LNCS, Springer, 368 378. [20] VALL\u00c9E-RAI, R., HENDREN, L., SUNDARESAN,V., LAM, P., \nGAGNON, \u00c9., AND CO, P. Soot a JavaTM optimiza\u00adtion framework. In CASCON 99 (IBM Center for Advanced \nStudies Conference) (Toronto, Ontario, CA, 8 11 Nov. 1999), 125 135.   \n\t\t\t", "proc_id": "964001", "abstract": "Software watermarking consists in the intentional embedding of indelible stegosignatures or watermarks into the subject software and extraction of the stegosignatures embedded in the stegoprograms for purposes such as intellectual property protection. We introduce the novel concept of <i>abstract software watermarking</i>. The basic idea is that the watermark is hidden in the program code in such a way that it can only be extracted by an abstract interpretation of the (maybe non-standard) concrete semantics of this code. This static analysis-based approach allows the watermark to be recovered even if only a small part of the program code is present and does not even need that code to be executed. We illustrate the technique by a simple abstract watermarking protocol for methods of Java&#8482; classes. The concept applies equally well to any other kind of software (including hardware originally specified by software).", "authors": [{"name": "Patrick Cousot", "author_profile_id": "81100592699", "affiliation": "&#201;cole Normale Sup&#233;rieure, Paris cedex, France", "person_id": "PP39049972", "email_address": "", "orcid_id": ""}, {"name": "Radhia Cousot", "author_profile_id": "81100592574", "affiliation": "CNRS & &#201;&#201;cole Polytechnique, Palaiseau cedex, France", "person_id": "PP14204543", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/964001.964016", "year": "2004", "article_id": "964016", "conference": "POPL", "title": "An abstract interpretation-based framework for software watermarking", "url": "http://dl.acm.org/citation.cfm?id=964016"}