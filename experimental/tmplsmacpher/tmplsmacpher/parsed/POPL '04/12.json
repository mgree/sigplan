{"article_publication_date": "01-01-2004", "fulltext": "\n Channel Dependent Types for Higher-Order Mobile Processes [Extended Abstract] Nobuko Yoshida Department \nof Computing, Imperial College London yoshida@doc.ic.ac.uk Abstract This paper introduces a new expressive \ntheory of types for the higher-order p-calculus and demonstrates its applicability via two security analyses \nfor higher-order code mobility. The new theory signi.cantly improves our previous one presented in [55] \nby the use of channel dependent/existential types. New dependent types con\u00adtrol dynamic change of process \naccessibility via channel passing, while existential types guarantee safe scope-extrusion in higher\u00adorder \nprocess passing. This solves an open issue in [55], leading to signi.cant enlargement of original typability. \nThe resulting typing system is coherently integrated with the linear/af.ne typing dis\u00adciplines as well \nas state, concurrency and distribution [53, 5, 56, 22], allowing precise analysis of software behaviour \nwith higher\u00adorder mobility. As illustration of the usage of the typed calculus, two basic security concerns \nfor mobile computation, secrecy for data con.dentiality and r ole-based access control for authorised \nre\u00adsources, are analysed in a uniform type-based framework, leading to the noninterference theorem and \nauthority-error freedom in the presence of higher-order code mobility. Categories and Subject Descriptors: \nF.3.2 [Semantics of Pro\u00adgramming Lanugages]:Process models General Terms: Theory, Security Keywords: \nTypes, Mobile Processes, the Higher-Order p-Calculus, Secrecy, Access Control 1. Introduction Background. \nNowadays the use of mobile code is widespread throughout computing scenes, from intra-net applications \nin corpo\u00adration to migrating code in active network to dynamic content in the world-wide web. One of \nthe principal bene.ts of mobile code (as found in Java [15, 28] and CLR [32, 8]) is to allow extensibil\u00adity \n[14, 48], where a piece of code migrates from a source node to a target node and gets linked to the run-time \nenvironment of the target, to serve its purposes. Such extensibility leads to rich reper\u00adtoire of new \nfunctionalities, including dynamic, tightly-coupled use of remote computational resources not restricted \nby network band- Permission to make digital or hard copies of all or part of this work for personal or \nclassroom use is granted without fee provided that copies are not made or distributed for pro.t or commercial \nadvantage and that copies bear this notice and the full citation on the .rst page. To copy otherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. POPL 04, January 14 16, 2004, Venice, Italy. Copyright 2004 ACM 1-58113-729-X/04/0001 ...$5.00. \n width/latency, multi-media applications where real-time interaction with resources are essential, and \nincremental software/service ad\u00addition/update. It also poses a new challenge in software safety: the \ninfrastructure is required to manage security mechanisms by which pieces of code with different origins \nand functionalities, embodying different principals, can safely interact in the presence of mobility \nand dynamic linkage. One of the promising analytical tools in this regard is the use of formal calculi \nof computation analysing and ensuring key security concerns such as integrity and con.dentiality [1, \n2, 12, 38, 22, 25, 16, 36, 45, 46, 56]. The higher-order p-calculus [40] is a general formalism of inter\u00adaction \nin which two kinds of mobility, name passing and process passing, are integrated in a simple, universal \nform. In the untyped (or weakly typed) setting, it is one of the most well-studied and un\u00adderstood formalisms \nfor mobility, starting from Sangiorgi s thesis [40] and reaching a recent work by Jeffrey and Rathke \n[29]. Inher\u00aditing from CCS and the p-calculus, its dynamics centres on interac\u00adtion at channels, where \nprocesses communicate not only (possibly new) channel names, as in the p-calculus, but also parameterised \nprocesses, i.e. processes that can be instantiated by names and other processes just like a piece of \nmobile code is instantiated with lo\u00adcal capability after migration. This addition to the already high \nexpressiveness of the p-calculus, offers a powerful basis for de\u00adscribing, analysing and understanding \nmobile computation, since moving data and behaviour from one place (context) to another place (context) \nis a key feature of general mobility. The simplic\u00adity and generality of the calculus make it a promising \ncandidate as a core formalism for modelling distributed mobile computation. One issue when considering \nthe applicability, however, is the lack of expressive type structure for the calculus. Types play an \nimportant r ole when applying computational cal\u00adculi such as the .-calculus to the study of programming \nlanguages and systems. Not only many modern programming languages them\u00adselves are richly typed, but also \ntypes are the basis of various pro\u00adgram analysis/reasoning methods. In the context of language-based \nsecurity, type soundness gives foundations for various security mech\u00adanisms by offering unforgeable references \nto resources. Further, in the context of the p-calculus, strong type structures are essential for precisely \nmodelling language dynamics [5, 53, 56, 35, 50, 22, 19, 6]. The .-calculus has function-based notions \nof types, while the p-calculus has name-based notions of types, both with rich theo\u00adries and powerful \napplications [36, 12, 38, 2]. Being a combination of these two formalisms, can we .nd a basic type structure \nfor the higher-order p-calculus that would serve as a basis of modelling, analysing and developing extensible \nlanguage infrastructure? This paper introduces a new theory of types that can assign ex\u00adpressive interface \ntypes to higher-order mobile processes, and demon\u00adstrates its applicability in two areas of security \nin mobile code. At the heart of the formalism is a new form of dependent types, called channel dependent \ntypes, that can represent, intuitively speaking, communication of typed anonymous names in carried code. \nThe resulting theory is a signi.cant improvement on the author s pre\u00adceding work with Matthew Hennessy \n[55]. Let us illustrate the key ideas with simple examples, starting from a brief review of our pre\u00advious \nwork in [55]. Assigning Types to Processes. We use the call-by-value ver\u00adsion of the higher-order p-calculus, \n.p [55, 54]. In the calculus, not only names but also arbitrary higher-order abstracted processes are \npassed around along communication channels. As a simple exam\u00adple, a thunked process .(x:unit).P, abbreviated \nto .P., can be sent and received as a value. The following expresses a server which repeatedly receives \nthunked processes via port a. def Server(a)=!a(y:t).run y (1) Here run stands for a function .y.y()which \nexecutes a thunked process by applying the unit (). Since accepting arbitrary processes for execution \nobviously breaks access control of local resources [15, 28], one might wish to restrict the behaviour \nof incoming code so that it can only access some speci.ed channels. In [55], Matthew Hennessy and the \npresent author introduced a type discipline which can control the effect of migrating code, by assigning \na different type to each process depending on its intended use, so that a process can use a typed inputting \nchannel (t at a in (1) above) to detect, for example, malicious behaviour of received code via static \ntype checking. A type is given as a .nite channel environment ., prescribing channel usage of each process. \nG -P : . (2) This judgement means P accesses channels at most as speci.ed by . under global environment \nG . For example, under appropriate G{b:(nat)o,c:(nat)o}(where b:(nat)omeans a channel b can output values \nof type nat), a message carrying a natural number may be assigned a different type depending on its destination. \nG -b(1): b:(nat)o and G -c(1): c:(nat)o (3) Now the following indicates a server only accepts a process \nwhich accesses at most the speci.ed resource. !a(y:.b:(nat)o.).run y where ...stands for an abbreviation \nof unit-..Using the type system in [55], one can check Server(a)Ia(.b(1).)is typable while Server(a)Ia(.c(1).)is \nnot. Note that if we use the non\u00addifferentiating constant type pro(also written o or ok in the lit\u00aderature), \nas found in all work [40, 54, 29, 30, 41] before [55], t can be assigned only to .., hence parallel composition \nwith both promessages in (3) become only typable with type pro, thus losing all type information. Issue: \nScope Opening and proType. The typing sys\u00adtem in [55] can assign non-trivial types to a variety of forms \nof higher-order code; however it has one basic limitation, in that it cannot assign a non-trivial type \nwhen a process demonstrates, in higher-order code passing, scope extrusion, i.e. sending a local name \nacross a local boundary (which is a common practice in stan\u00addard distributed object-oriented programming \n[57]). Consider the following sender to the above server, which wishes to get the ac\u00adknowledgement akat \nthe time P is executed in the remote site. Naturally, this acknowledgement will be sent via a private \nchannel to ensure its safe delivery.    def Send(a)=(.ak)(a(.P Iak.)Iak.Q) (4) Here akis a trigger \ncarrying the empty vector, hence typed by s = ()o. But how can we type a when akis restricted? In the \nsystem in [55], the only possible typing for a is (pro.)o, using the most .uninformative type pro, so \nthat, for composition with Send(a), Server(a)can only be assigned the type pro. But if we wish to control \nthese processes by types following a natural speci.cation, one should be able to say a can output a thunked \nprocess which contains some anonymous channel of type ()o, together with the type of P. A general solution \nto this issue is dif.cult due to a subtle interplay between a process type and a name hiding: in particular, \nan ad hoc solution such as erasing the type of a from the typing leads to an inconsistent system (see \n[55] for more discussions). A related case is non-deterministic name instantiation: e(x).a(.x(1).)Ie(e1)Ie(e2) \n(5) Note this process includes another sender to Server(a)under input pre.x. Since we cannot decide \nwhich of e1 and e2 may be instan\u00adtiated, the system in [55] can only assign (..)oto a, hence pro Server(a)again \nends up with pro. Channel Dependent Types. In this paper we introduce chan\u00adnel dependent types as an \neffective solution to this problem. As the name suggests, these types introduce quanti.cation on names \nrather than on types. For example, if we assume a type of P is ., the new typing system assigns to the \nchannel a of Server(a)in (1), the following type: (.[x :s].x :s,..)! Here the occurrences of x in the \nthunked type .x:s,..are bound by the preceding dependent quanti.er. The type indicates that a chan\u00adnel \ninputs a thunk process which contains some unknown channel name of type s and the known channels speci.ed \nby ..When the communication takes place, a parameter is dynamically instan\u00adtiated into x in .x : s,..at \nthe time of code passing, just as in function application of channel dependent types (which essentially \ncorrespond to type instantiation in reduction of explicitly typed .\u00adcalculi with dependent/polymorphic \ntypes). As we shall see in the main sections, the server (1) can now be given a non-trivial type {a : \n(.[x : s].x : s,..)!,.}. A special case of channel dependent types is also worth mentioning, called channel \nexistential types, where an abstracted name is ensured not to be touched by the re\u00adceiver. Since this \nrequirement is met in the above server example, it can also be typed as (:[x : s].x : s,..)!. Many examples, \ninclud\u00ading an example in (5), can be typed with existential types, which satisfy stronger properties \nsuch as a type erasure theorem and an encapsulation of higher-order code with hidden names. The introduction \nof channel dependent/existential types dramati\u00adcally increases the expressiveness of process types, opening \na broad range of applications. The type prois no longer necessary for typing well-behaved agents. As \nin the .rst-order (name passing) setting [5, 6, 18, 31, 51, 52, 53, 56], assigning appropriate types \nto extruded names is crucial for having signi.cant behavioural con\u00adstraint by, and based on, types. Since \nit allows organised treatment of hidden channels, the type discipline as a whole becomes simpler. It \nalso leads to a novel type-preserving encoding of higher-order processes into the p-calculus, an effective \ntool for reasoning. We next present a brief preview of the integration of linear/af.ne types [5, 6, 22, \n52, 53, 56], which, among others, enables precise modelling of various programming language constructs \n[22, 57], leading to many applications. This integration was practically im\u00adpossible in the foregoing \ntype disciplines for higher-order mobile processes [40, 41, 54, 55], due to the issue of protype.  \n Integration with Linear/Af.ne Types. Ensuring unique\u00adness of resource name usage is important in both \nprocesses and functions [31, 18, 5, 6, 53, 56, 25, 43, 51]. In distributed system, this condition also \nguarantees determinacy of the message delivery and preservation of locations. The notion also works in \nharmony with channel dependently typed higher-order mobile processes. Recall the previous Sender(a) in \n(4). In a re.ned typing, the sender may wish to specify akis used at most once, which is a natural constraint \nfor remote com\u00admunication such as RMI and is also useful for resource usage pre\u00addiction. We may call \nthis name discipline af.ne [5], and denote the type of this trigger as ()t. For example, in the following \nprocesses: Server(a)Ia(.P1 Iak.)Ia(.P2 Iak.)(6) the server violates af.nity since it should repeatedly \naccept an af.ne message ak.However if we hide akat the sender side: Server(a)I(.ak)(a(.P1 Iak.)Iak.Q1) \n(.ak)(a(.P2 Iak.)Iak.Q2)(7) this process should be typable with af.ne types, since hidden ak now denote \ndistinct names. This becomes possible by the use of the new dependent types, so that the server now has \nthe type {a : (.[x : ()t].x : ()t,..)! ,.}with . a type of P1,2 (! indicates a is replicated, cf. Section \n3). Af.nity is useful for guaranteeing the unicity of channels and resources: a stronger constraint, \nlinearity, also has a bene.t when a precise embedding of language constructs is necessary. A general \nintegration of linear/af.ne types in the de\u00adpendently typed .p is discussed in Section 3, whose use is \nessential for two basic security analyses, which we discuss next. Secrecy and Mobility. Secrecy in general \nmeans a program does not transform high-level information to effects at low-level channels [11, 2, 16, \n22, 33, 45]. In the context of processes, inter\u00ad l L action carries information, so, for example, a process \na.b(where we attach secrecy labels to channels) .rst has secret interaction at a, then less secret interaction \nat b, which may be known by a wider public. Then this process is insecure, since any process observing \nb, which can be done by low-level process, has the possibility to know interaction at a, which should \nbe kept secret. In the pres\u00adence of higher-order mobility, we can consider a process carrying another \nprocess which is assigned some secrecy level: P a l(.bL .) (8) where a thunk of a low level program .b.is \ntransfered via the high channel a. In the .ne-grained types, the safety of this code depends on the receiver. \nLet us consider the following two receivers: Q1 al(x :t).run x IbL.cL (9) bLL Q2 al(x :t).((.y.0)x)I.c \nNote Q1 does use the thunk while Q2 does not. Since our .ne\u00adgrained process typing can detect this distinction, \nthe secrecy anal\u00adysis based on them can indicate Q2 is safe while Q1 is not. This observation leads to \nmore .exible and host-oriented protection than deciding the safety/unsafety at the sender side, presenting \na general and clear framework for secrecy assurance. In Section 4, we shall clarify how this framework \nwith integrating linear/af.ne structures leads to greater typability than some of the possible alternatives. \n    Access Control and Mobility. Access control, a traditional subject in security, is a means to \ncontrol execution of operations on sensitive resources by principals following a speci.ed (and often \nchangeable) security policy. In the context of extensible architec\u00adture, one basic topic is how to set \na current authority level of a thread depending on which pieces of code (coming from different origins) \nit has executed [48, 49, 14, 3]. Recently several analyses of this concept appear, using the .-calculus \nas a central formalism [12, 38]. In this paper we show how the typed linear/af.ne .p can precisely model \naccess control mechanisms in the presence of code mobility, concurrency and distribution, including nested \ninstantia\u00adtion of channels and code. Due to interaction with resources man\u00adaged by OSs and databases, \nas well as policy change, self-contained static checking of mobile code in this regard would be generally \ninfeasible. Yet when it is possible, it can lead to substantial optimi\u00adsation [12]. We show the typed \n.p-calculus allows clean modelling of different access control mechanisms for extensible architecture \n[48, 49, 38, 12, 14, 3], which scales to a simple but realistic lan\u00adguage with code mobility leading \nto new insights on this topic. We leave concrete discussions to Section 5. Summary of Contributions. \nWe summarise the main tech\u00adnical contributions of the present work. 1. Introduction of channel dependent/existential \ntypes for the .p\u00adcalculus, a higher-order p-calculus .rst presented in [55], sig\u00adni.cantly enlarging \ntypability and offering a general basis for applications. Type-safety is proved by extending the technique \ndeveloped in [55]. 2. Consistent integration of linear/af.ne type disciplines [53, 5, 56, 22] on the \nbasis of channel dependent types, allowing the calculus to be used for re.ned behavioural modelling and \nse\u00adcurity analyses. Key properties such as strong normalisation in the linear .p and encapsulation of \nhigher-order mobile code by existential names are proved (Theorems 3.1 and 3.2). 3. Type-based analyses \nof two basic security concerns in mobile code, secrecy [11, 2, 16, 22, 33, 45] and r ole-based access \ncon\u00adtrol of resources [3, 12, 14, 38, 48, 49], as example applica\u00adtions of the typed formalism, leading \nto noninterference and authority-error freedom for well-typed processes in the pres\u00adence of higher-order \ncode mobility.  Structure of the Paper. Section 2 introduces the .p with channel dependent/existential \ntypes. Section 3 shows a consistent integration of the linear/af.ne types. Section 4 models and analyses \nsecrecy and Section 5 studies r ole-based access control with code mobility. Section 6 discusses extensions, \nrelated work and further topics. Due to the space limitation, auxiliary de.nitions, proofs and further \napplications are relegated to the full version [57] which is available from http://www.doc.ic.ac.uk/ \nyoshida. 2. Processes and Types 2.1 Processes The syntax of processes [54, 55] is given in Figure 1, \nwhich is the p-calculus augmented with the call-by-value .-calculus primitives. We assume an in.nite \nset of channels or names N, ranged over by a,b,..., and an in.nite set of variables V, ranged over by \nx,y,... t and s denote value and channel types which will be given later. Type annotations are often \nomitted unless they are relevant and we often write a(c)P for the abbreviation for (.c)(a(c)IP). The \nreduction rules of .p is simply the combination of those of the p-calculus and the call-by-value .-calculus. \nThe main rules are  (Term) P,Q,...::=V value I0 nil I PIP parallel I u(V1,...,Vn)output Iu(x1:t1,...,xn \n:tn).P input I !u(x1:t1,...,xn :tn).P replicator I (.a:s)P restriction IPP application (Identi.er) u,v,w,...::=x,y,z,... \nvariable Ia,b,c,... channel (Value) V,W,...::=u,v,w,... identi.er I(),1,2,.. unit,numbers,.. I.(x :t)P \nabstraction (Abbreviation) def .P. =.(x :unit)Px rfv(P)thunk def run =.(x :unit-.)x () run Figure 1: \nSyntax the following \u00df-reduction rule and communication rules. (\u00df) (.(x :t)P)V --P{V /x} (com) a(x1:t1,...,xn \n:tn).P Ia(V1,...,Vn) --P{V1,...,Vn/x1,...,xn} (rep) !a(x1:t1,...,xn :tn).P Ia(V1,...,Vn) --P{V1,...,Vn/x1,...,xn}I!a(x1:t1,...,xn \n:tn).P Other rules are standard using the structural equivalence (denoted by ), hence omitted (cf. [57, \nFigure 2] and [55, Table 4]). We also def denote multi-step reduction as - =U--*. Note that substitu\u00adtion \nof channels P{u/x}affects not only terms but also types which annotate bound variables.  2.2 Types \nSyntax. The grammar of types are given in Figure 2. These types are from [54, 55] except for the introduction \nof channel dependent types. We use a simpler form of IO-modes based on duality [5, 22, 19, 18, 22, 53]. \nThere is unit, nat, .., higher-order function type t -td, (functional) name dependent type .(x : s)t, \nprocess type . and channel type s. The last one incorporates dependent quanti.cation on which we shall \ndiscuss soon. In .(x : s)t,we allow the type t to contain occurrences of the channel variable x; then \nx in t is bound. A process type ., assigned to a process, is a mapping from a .nite subset of N UV to \nchannel types. Unlike in [54, 55], we no longer have protypes, which are now unnecessary due to the introduction \nof channel dependent types. Channel Dependent Types. A channel type incorporates de\u00adpendent quanti.cation \nof the form (.[x1:s1,...,xn :sn]t1,...,tm)p. This indicates: A channel is used with IO-modes p (!for \ninput, ofor output).  A channel carries a vector of channels typed by s1,..,sn and a vector of higher-order \nvalues typed by t1,..,tm;and  Value: t ::=unit Inat It -tdI.(x :s)t I. Is Channel: s ::=(.[x1:s1,...,xn \n:sn]t1,...,tm)p I(d) s,sEnvironment: . ::=0/ I.,x :t I.,u:s Abbreviation: def (.[x1:s1,...,xn :sn]t1,...,tm)p \n=(s1,...,sn,t1,...,tm)p (if x1,...,xnr fv(s1,...,sn,t1,...,tm)) def thunk: ...=unit-. Figure 2: Types \nFree occurrences of xi in si+1,...,sn as well as in t1,...,tm are bound occurrences, just as in a functional \nname depen\u00addent type .(x1:s1)(.(x2:s2)...(.(xn :sn)ti)...). By the abbreviation in Figure 2, we can \nwrite, for example, (st)p for (.[x : s]t)p if x does not occur in t. This is similar to the stan\u00addard \nconvention in the functional dependent type where nat-nat is a degenerate case .x : nat.nat. Thus we \ncan write simple chan\u00adnel types (without dependency) using the standard notation. Let (.[Gx :Gs]Gt)p \nbe (.[x1: s1,...,xn : sn]t1,...,tm)p.If m =0, this becomes (.[Gx:Gs])p (where only channels are carried); \nwhile if n =0, it becomes (Gt)p (where only higher-order values are carried); andif bothare 0thenit becomes \n()p (where nothing is carried). (s,s d)indicates the unordered pair type, one is input and the other \nis output. The mode of (s,s(input and output). d)is de.ned as !os,the dual of s, is the result of dualising \nall action modes in s as: (.[x1:s1,...,xn :sn]t1,...,tm)p =(.[x1:s1,...,xn :sn]t1,...,tm)p where ! =and \no =!. The sets of free names/variables in term P, owritten fn(P), fv(P)and fnv(P), respectively, incorporate \nthose oc\u00adcurring in annotating types. For example, we have fv(.(x : t).P)= (fv(t)Ufv(P))\\x (see [57] \nfor the formal de.nition). Examples of types follow. EXAMPLE 2.1. (types) 1. (simple IO-types) A channel \nwhich outputs a natural number has type (nat)o . Its dual is (nat)! . Then a channel which outputs this \ntype has type (.[x : (nat)!])o, which is written as ((nat)!)o, using the abbreviation in Figure 2. 2. \n(higher-order type) A thunked process which can output nat at a has type .a : (nat)o .. The higher-order \nidentity for this type has type .a : (nat)o .-.a : (nat)o .. A dependent func\u00adtion type which constructs \nsuch a thunked process from a given name has type .(x :(nat)o).x :(nat)o  .. 3. (channel dependent type) \nA process which inputs an output name b with type (nat)oand a thunked process .a : (nat)o . has type \n((nat)o ,.a : (nat)o .)! . On the other hand, a pro\u00adcess which inputs an anonymous name a with type (nat)o \nand its thunked process .a : (nat)o .has a dependent type (.[x:(nat)o].x:(nat)o .)!. Both types input \ntwo arguments, a channel and a value. We then have (.[x :(nat)o].x :(nat)o.)!=(.[x :(nat)!].x :(nat)o \n.)o . Following [54, 55], we use a partial commutative operator s 8sd to control composition of processes \n(see Figure 3). We write s : sdif s 8sdis de.ned. For example, we have (nat)o:(nat)! , so (nat)o8(nat)!is \nde.ned and has the value ((nat)! ,(nat)o). Also (nat)o:(nat)oand (nat)o8(nat)o=(nat)o . 8and :are pointwise \nextended to the composition of channel environments. When the name u is substituted for x in a process \ntype ., then the types s of x and sdof u are composed by 8, resulting in u : s 8sd . For example, we \nhave: {a:(nat)o ,x :(nat)!}{b/x}={a:(nat)o ,b:(nat)!}and {a:(nat)o ,x :(nat)!}{a/x}={a:((nat)o ,(nat)!)}, \nwhile {a : (nat)o ,x : (unit)!}{a/x}is unde.ned. We can apply the same rule to the substitution into \nterms [54, \u00a7 2]. For example, given .(x :(nat)o)..(y:.x :(nat)o ,b:(unit)o .).y we can observe: (.(y:.x \n:(nat)o ,b:(unit)o .).y){a/x}is de.ned but (.(y:.x :(nat)o ,b:(unit)o .).y){b/x}is unde.ned. Our typing \nsystem shall ensure such an unde.ned substitution never happens during interaction between typable terms. \n 2.3 Typing with Channel Dependent Types The typing system for .p is given in Figure 5, which uses the \ntwo kinds of judgements: G -P:t aterm P has a type t under G G -u:s a channel u has a type s under G \nIn the inference rules we also use the standard judgements for the well-formedness in Figure 4 where \nEnvmeans an environment, tpH (resp. tpP) means HO-value (resp. process) type and s : p means a channel \ntype with mode p. The inference rules coming from [55] except (In) and (Out) rules which use new channel \ndepen\u00addent types, are divided into three categories. The .rst group, (Com\u00admon), is standard rules for \nvariables, channels and constant. The second one, (Function), comes from the simply typed .-calculus \n(where the rules for channel abstraction, (AbsN ) and (AppN ),and those for the higher-order abstractions, \n(AbsH ) and (AppH ),are sep\u00adarately given). The .nal group, (Process), are about processes. In (Nil), \nwe start from the empty interface, and in (Par), we merge two interfaces together. The rule (Weak) corresponds \nto the process subsumption rule in [55]; since G -P : . means P would access channels speci.ed at most \nby . , we can increment its interface. (Res) hides a name.1 We shall now illustrate the two main rules, \n(In) and (Out), followed by simple examples of inference. (In) We illustrate the rule assuming we wish \nto type an input that receives a single channel and a single higher-order value. G -u:(.[x :s]t)! G,x \n:s,y:t -P : x :s,. G -u(x :s,y:t).P : u:(.[x :s]t)!8. The assumption G -u : (.[x : s]t)!ensures u can \ninput a channel typed by s and a higher-order value typed by t. In the conclusion, the free occurrences \nof x in both P and t are bound (in the assump\u00adtion, we can ensure x does not appear in .). The resulting \nprocess type is a union of . and the input capability of u. Finally note (In! ) is derived from (In). \n(Out) Again we illustrate the rule considering an output of one channel and one higher-order value. G \n-u:(.[x :s]t)o G -v : sG -V : t{v/x} G -u(v,V ): u:(.[x :s]t)o ,v:s We discuss each assumption and conclusion. \n1In [55], we used the operator t \\a which deletes all free occur\u00adrences of a : s form t in order to gain \nthe typability. Using more informative dependent/existential types, we can dispense with this operator; \ninstead we can simply erase a which does not appear in ., keeping information of a in . as an quanti.ed \nname. G -u : (.[x : s]t)oensures u outputs a pair of a name typed by s and a higher-order value typed \nby t. s is dualised because v is used in the input with type s [5, 53, 56, 22].  if the .rst argument \nis v, then the second argument should have type t{v/x}since x binds free occurrences of x in t.  the \neffect of channel u and v should be recorded as a type of u(v,V )because they will be used by the opponent \ninput after interaction (note that we do not have to record the effect of V ).  Below we show an example \nof inference which uses channel de\u00adpendent type non-trivially. def EXAMPLE 2.2. Let P =c(x,y).(run yIx(1)).We \nshow how we can give different constraints on the behaviour of P depending on type assignment. First \nlet us assume c has the following input type: def .)!sc =(.[x :(int)o].x :(int)o and G ={c:sc,x :(int)o \n,y:.x :(int)o .}. Then we can infer: G -run y : x :(int)o G -x(1): x :(int)o (Par) G -run yIx(1): x :(int)o \n(In) c:sc -c(x,y:.x :(int)o .).(run yIx(1)): c:sc Hence this input process can only get a thunked value \nwhich has the same interface as the .rst argument. On the other hand, suppose c has the following channel \ntype where x does not appear in the carried higher-order value type. def s d =(.[x :(int)o].b:(int)o \n.)! c This is written as ((int)o .b:(int)o .)!by using the abbreviation in Figure 2. Then we have: b:(int)o \n,c:sd -c(x,y:.b:(int)o .).(run yIx(1)): {c:scd ,b:(int)o} c Here c can only input a thunked process \nwhich has less than b\u00adaccessibility, i.e. having either or .b:(int)o .as its type. .. The difference \nbetween sc and sdabove will become clearer by c composing the opponent message, given in the next example. \nEXAMPLE 2.3. Now let us revisit the two examples discussed before. Then we obtain the following typed \nterms. . -c(v,.v(2).): {c:sc,v : (int)o} .d-c(v,.b(2).): {c:sd c,v : (int)o ,b : (int)o} with . ={v:(int)o \n,c:(sc,sc)}and .d={v:(int)o ,b:(int)o ,c: (sd c,scd)}.Then we have: . -PIc(v,.v(2).): ., which reduces \nto v(2)Iv(1). .d-PIc(v,.b(2).): .d, which reduces to b(2)Iv(1). Now we analyse the scope opening rule \nusing these examples. Let us compose the above messages with environment processes !v(z : int).Rz and \n!b(z : int).Rz for some z : int-Rz : 0/, respec\u00adtively. Then (.v)(c(v,.v(2).)I!v(z : int).Rz)is typable \nwhile (.b)(c(v,.b(2).)I!b(z : int).Rz)is not. We can easily check the former can be inferred by (Res) \nafter (Par) as follows. . -c(v,.v(2).)I!v(z).Rz : {c:sc,v:sv} (Res) ./v -(.v)(c(v,.v(2).)I!v(z).Rz): \nc:sc with sv =((int)! ,(int)o).Note sc is an dependent type with v rfn(sc), hence this satis.es the \nside condition of (Res).On the other hand, we cannot apply (Res) to obtain the latter since name b appears \nfree in sd c. If we had allowed to type the latter, the ill behaviour occurs in the following processes \nPI(.b)(c(v,.b(2).)I!b(z).Rz) mode of s: md((.[Gx:Gs]Gt)p)=p md((s,sd))=md(s)8md(sd)with p8p =p and !8=!o. \no 8on s:(1) if md(s)=o,then s8s=(s,s)=(s,s)and; (2) s8s=s, s8(s,sd)=s8(sd ,s)=(s,sd)=(sd ,s). def 8on \n.: .1 8.2 ={x:s1 8s2 Ix:s1 r.1,x:s2 r.2}U(.1 \\dom(.2))U(.2\\dom(.1)) s:sdmeans s8sdis de.ned; and .1 :.2 \nmeans x:s1 r.1 and x:s2 r.2 imply s1 8s2 is de.ned. Figure 3: IO-Algebra on Types and Environments (Well-Formed \nEnvironment) G-t: tpHx rdom(G) G-s: pu rdom(G) (e-nil) 0/-Env (e-val) (e-chan) G,x:t-Env G,u:s-Env (Well-Formed \nTypes) G-Env G-t1:tpH G-t2:tp G,x:s-t:tp (t-base) (t-absH) (t-absN) G-unit: tpH G-t1 -t2: tpH G-.(x:s)t: \ntpH (t-emp) (t-pro) (t-input) (t-dual) (t-pair) G-Env G-.: tpP G-u : su rdom(.)G,x1:s1,..,xn:sn -tj :tpH \nG-s:! G-s:o G-0/: tpP G-.,u:s: tpP G-(.[x1:s1,...,xn:sn]t1,...,tm)!: ! G-s:o G-(s,s):!o Figure 4: Well-Formed \nHigher-Order IO Types (Common) ddd G,x:t,G-Env G,u:s,G-Env G,u:(s,sd),G-Env G-Env (Val) (Chan) (Pair) \n(Base) etc. ddd G,x:t,G-x : tG,u:s,G-u : sG,u:(s,sd),G-u : sG-(): unit (Function) (AbsH) (AppH) (AbsN) \n(AppN) G,x:t-P: td G-P: t-td G,x:s-P: tG-P: .(x:s)t G-t-td: tpH G-Q : tG-.(x:s)t: tpH G-u : s G-.(x:t)P: \nt-td G-PQ : td G-.(x:s)P: .(x:s)tG-Pu: t{u/x} (Process) (Nil) (Par) (Res) (Weak) G-Env G-P1,2: .1,2 \nG,a:s-P : .,a:sG-u:sG-P: . G-0 : 0/G-P1 IP2: .1 8.2 G-(.a:s)P : .G-P: .8u:s (In) (Out) G-u:(.[Gx:Gs]Gt)! \n(In! ) G-u:(.[Gx:Gs]Gt)o G,Gx:Gs,Gy:Gt-P: Gx:Gs,.G-u(Gx:Gt).P : .G-Vj : tj{Gv/Gx}G-vi : si{Gv/Gx} G-u(Gx:Gs,Gy:Gt).P: \nu:(.[Gx:Gs]Gt)!8.G-!u(Gx:Gt).P : .G-u(Gv,GV): u:(.[Gx:Gs]Gt)o ,Gv:Gs{Gv/Gx} Figure 5: Higher-Order IO \nTyping System (Well-Formed Environment and Types) G,x:s-t: tpH G-:[x:s]t: tpx,y rdom(G) G-t: tp: : (t-exist) \n(t-pack) (t-in:) G-:[x:s]t: tp: G,{x:s,y:t}-Env G-(t)!: ! (Typing System) (Pack) (Tupl:) G-v : s (Var:) \nG,{x:s,y:t},Gd-Env G-V : t{v/x} G,{x:s,y:t},Gd-Env G,{x:s,y:t},Gd-{x,y}: :[x:s]tG-{v,V}: :[x:s]tG,{x:s,y:t},Gd-y:t \n(In:) (Out:) G-u:(:[x:s]t)! G-u:(:[x:s]t)o G,{x:s,y:t}-P: .,x:sG-{v,V}: :[x:s]t G-u(y::[x:s]t).P: u:(:[x:s]t)!8.G-u(V): \nu:(:[x:s]t)o ,v:s Other rules are from Figure 5.  Figure 6: Existential Typing System The annotated \ntype sdin P no longer guarantees c will receive a c thunk of process less than b-accessibility. Actually \nthe above unty\u00adpable term is not closed under the scope opening rule. On the other hand, the reader can \ncheck PI(.v)(c (v,.v (2).)I!v(z).Rz)behaves correctly and closed under the scope opening rule. We list \nbasic syntactic properties of typed processes. First, the proof of the following follows the routine \nin [55]. THEOREM 2.4. Suppose G -P : t and P - Pd.Then G -Pd: t. The following properties do not hold \nin the original system [55]. PROPOSITION 2.5. (minimum/maximum interface types) Given G and P, suppose \nP is typable under G. Then: 1. (the minimum) (a) there exists . such that G -P : .. (b) Assume G -P : \n.. Then there exists the unique .min such that .min S. and G -P : .min. 2 2. (the maximum) G -P : .max \nwith .max ={u:s Iu:s rG}. COROLLARY 2.6. 1. (type checking) Given G, t and (anno\u00adtated) term P, it is \ndecidable whether one has G -P : t. 2. (typability) Given G and (annotated) term P, it is decidable whether \nthere exists a type t such that G -P : t Next we examine the relationship between process types and process \nbehaviour. De.ne: P .ao9:R,Gc,GV .s.t. P - (.Gc)(a(GV )IR)(a r{Gc}) Dually we de.ne P .a!.Below md(s)denotes \nthe mode of s.The proof follows [55, Proposition 5.2]. PROPOSITION 2.7. Suppose G -P : .. 1. Ifa rdom(.),then \n-P .a!and -P .ao . 2. If md(.(a))=!,then -P .ao. Dually for o.   2.4 Channel Existential Types Channel \ndependent types allow names in dependent binding to oc\u00adcur both in the (receiving) process and in the \ncarried type. Often this generality is unnecessary: by restricting the bound names to occur only in carried \ntypes, we arrive at channel existential types. As an example, recall the input process in the previous \nsection where c has type (.[x :(int)o].x :(int)o .)!: c(x,y:.x :(int)o .).(run yIx (1)) Here x appears \nin x (1)and types of y, hence the opponent output process always needs to send the value V together with \nbinding name v as in c (v,V ). We can, however, erase names x and v for binding if they are used only \nas linking into interface types; that is, the scope of existential quanti.ed name is limited to the communi\u00adcated \nvalue V . For example, in the following term, the output can safely send V without attaching v. c(y).(y()Ia(y))I(.v)(c \n(V )I!v(z).R) (10) Following existential types in polymorphic ., we extend the syn\u00adtax of type by adding \n:[x : s]t to t in Figure 2 where :[x : s]t is an existential type with name x and value type t (its binding/free \nnames/variables are de.ned as .[x : s]t). We also use {v,V },a pair of name v and value V as a package, \nwhich appears only dur\u00ading type inference. The extended rules for well-formedness and 2.1 S.2 means for \nall u rdom(.1), .1(u)=.2(u)or .2(u)= (s,s)with s =.1(u). typing are listed in Figure 6. In the environment, \n{x :s,y:t}guar\u00adantees that x only appears in t, i.e. its scope is in t. In the typ\u00ading rule, (Tupl:)/(Val:) \nis an introduction of a pair of variables/a variable. (Pack) is a packing construction rule. (In:) and \n(Out:) can be regarded as a special case of (In) and (Out) of the depen\u00addent typing system in Figure \n5 where scope of x is restricted in t. Then the term in (10) above has a type {c : (sa,sa),a : sa}where \nsa =(:[x : sx].x : sx.)o , V =.v (2).and sx =(int)o(assuming !v(z).R has type v:(int)!). Many examples \nof higher-order code mobility can be typed using only channel existential types.3 Not only does it satisfy \nthe stan\u00addard erasure theorem (for existentially quanti.ed names), but also it expresses a stronger contract \nbetween a sender and a receiver, en\u00adsuring the opaqueness and inaccessibility of the abstracted names \nat the receiver s side. 2.5 Example: Remote Procedure Migration We conclude this section with a larger \nexample which use several elements of the typed .p. Consider a data server at location l, which .rst \nchecks accessibility of incoming code, and if it is safe, it provides a value n to it repeatedly to a \nlocal channel c inside its location. This server can be written as: def Server(l)=(.c)(!l(y:t).(yc)I!c(x).x \n(n)) Then the following parameterised code inputs the server s data twice and returns the .nal result \nto e. def returntwietoe =.(c)c (f )f (z1).c (f )f (z2).e (z1 +z2) This function has the following functional \nname dependent type: t d =.(x :sx){x :sx,e:(nat)o} where sx =((nat)!)o. A client can send this higher-order \nrequest to the server, and wait for the result at the hidden name e: def  letx =l(twie)inR =(.e)(l(returntwietoe)Ie(x).R) \nThis process can be composed with Server(l)if t annotating y in Server(l)is speci.ed as: t =:[e:(nat)o]td \n The example shows that the combination of types in the .p offers: (1) protection for the server against \nthe client (by t,which maybe checked at the time of arrival of the code), (2) the invisibility (hence \ninaccessibility) of the local service point c in the server to the client; (3) ensuring that the returned \nmessage to e has not been touched (by existential type :[e : (nat)o]td, the server will not touch e (z1 \n+z2) if it is well-typed), and safe return to the destination speci.ed by the client (see Theorem 3.2 \nfor a stronger formal statement). The constructions and applications in the following sections are built \non the basis of these features.   3. Integration with Linear/Af.ne Types In this section we brie.y \nsummarise the integration of linear/af.ne types (which are originally introduced for the p-calculus [5, \n6, 22, 52, 53, 56]) into the .p. We also augment the calculus with branch\u00ading and subtyping. While the \nfull integration of linear/af.ne types involves stateful computation and synchronisation [22], we do \nnot treat these features in the present paper for simplicity, which is enough for our applications later. \nThe full account of linear/af.ne types in .p, including these features, is given in [57, Part I]. 3The \ngenerality of channel dependent types becomes important in some signi.cant theoretical and pragmatic \nsettings. Such instances are discussed in [57, 17]. 3.1 Linearity and Af.nity As noted in Introduction, \naf.nity means possibly diverging be\u00adhaviour in which a question is given an answer at most once; while \nlinearity means a question is always given an answer precisely once. Further these types can be mixed, \ncalled linear/af.ne types.As we discussed in Introduction, the typability of extruded names, made possible \nby channel dependent types, is essential for fully incorpo\u00adrating these notions. For integration, all \nwe need to do is to enrich the mode p in channel types. For af.ne types we consider: +A Af.ne input tA \nAf.ne output !A Unique af.ne server ?A Client requests to !A We also use tto indicate uncomposability \nat af.ne channels. +A ,!A are input modes, while tA ,?A are output modes, and the left is dual of the \nright. The composition of types s 8sdnow incorporates the following algebra of these enriched modes: \n+A 8tA =t,!A 8?A = !A and ?A 8?A =?A. The .rst rule says an af.ne input can only be composed with an \naf.ne output, with no further connection, while the last two say a server can be composed with zero or \nmore clients. If all common ports of two processes are pairwised composable, then their parallel composition \nis de.ned. For example, if a has a tA-mode, a Ia.0 is typable, while a Ia is not. For linearity, the \nonly addition is causality edges from input to output, e.g. a : ()+L -b : ()tL . Edges prevent circular \ncausality in composition. For example, a.b Ib.a is typable in the af.ne sys\u00adtem, but not in the linear \none. We use +L ,tL ,!L ,?L to denote linear modes. We can then combine the linear and af.ne typings by \nin\u00adcorporating the simple conditions given in [22, 5, 53, 56, 52]. The typing rules are de.ned by replacing \n(Process) in Figure 5 with the corresponding rules of the af.ne, linear, and linear/af.ne p\u00adcalculus \n[22]. For the full presentation of the typing rules, see [57]. We call the resulting calculi .pA , .pL \nand .pLA, respectively. The following lists the basic properties of .pA , .pL and .pLA.Below .ap is de.ned \nas .in Proposition 2.7, and . is closed means ao {!L ,!A ,t}md(.). (2) solves the open problem posed \nin [42]. THEOREM 3.1. (1) (subject reduction) Suppose G -P : t.Then P - Pdimplies G -Pd: t. (2) (strong \nnormalisation) --in .pL is strong normalising. (3) (linear liveness) Suppose G -P : .,e:s and fv(P)=0/ \nin .pLA with md(s)=tL and . closed. Then for all Pdsuch that P - Pd, we have Pd .etL . (2) is proved \nby .rst translating .pL into pL using a type-directed encoding (on which we shall discuss in \u00a7 4.2), \nthen applying the result in [53]. This is used for proving (3), reducing transitions of pLA into pL by \nthe result in [52]. Intuitively, (3) says that, when composed with all complementary processes, a linear \nchannel even\u00adtually .res even in the presence of non-termination. The property is essential in the secrecy \nanalysis in Section 4. Another interest\u00ading liveness property comes from existential channel types. Below \nl P --Pdis a standard typed transition relation (l is either t (tau), u(GV )(input) or (.Ga)u(GV )(output)) \n[40, 57]. THEOREM 3.2. (encapsulationofmobilecodebyexistentialnames) Suppose G -P : . and fv(P)=0/ in \n.pLA with . closed. Assume u(.c (n).)G -u:(:[c:(nat)tL ].c:(nat)tL.)!L .Then P --Pdimplies there c (n)exists \nQ such that Pd- Q --. This theorem means an acknowledgement bound by existential lin\u00adear name is eventually \nreturned to the sender without being touched by the receiver. The encapsulation property plays a signi.cant \nr ole in the type-based security analyses in the subsequent sections. As an illustration of Theorems \n3.1 (3) and 3.2, suppose, in Ex\u00adample 2.5, t in Server(l)is typed as t =:[e:(nat)tL ].(x :sx){x :sx,e:(nat)tL \n} with sx =((nat)+L )?L . Thenevenif Rdcontains non-terminating behaviour, the remote call to the server \ncan always succeed: Rdd) Server(l)Iletx =l (twie)inRIRd - (Server(l)IR{2n/x} Next recall (6) in \u00a7. 1. \nThis term is not typable by assigning ()tL to ak. To accept outputs with ak, runy in Sever(a)should have \ntype {ak: ()tL ,.}which contains the free linear output; hence it cannot be pre.xed by the replication \n!a(x)(if we do so, the linear channel can repeatedly appear, cf. [31, 5, 56]). On the other hand, the \nserver in (7) is typable since the channel ak: ()tL in the type {ak: ()tL ,.}of runy is going to be bound \nby :. Hence a can have type (:[x : ()tL ].x : ()tL ,..)!L . Note all these arguments are inapplicable \nif we only have pro-types. 3.2 Branching and Subtyping We augment the .pLA with branching and selection \nfor representing conditionals, methods for objects and atomic data, as done for the p-calculus in [5, \n53, 56, 22]. The integration is straightforward, extending the grammar as follows. P ::=...Iu[&#38;iEI \n(Gyi).Pi]Iuini(GV ) We often omit the indexing set I. u[&#38;iEI (Gyi).Pi]is branching, while x ini(GV \n)is selection. The reduction is de.ned as: u[&#38;i(Gyi).Pi]Iuinj(GVj)--Pj{GVj/Gyj} !u[&#38;i(Gyi).Pi]Iuinj(GVj)--!u[&#38;i(Gyi).Pi]IPj{GVj/Gyj} \n The reduction for branching involves selection of one branch, dis\u00adcarding the remaining ones, as well \nas name passing. As simple examples, boolean agents are de.ned as: def def [[true]]u =!u(e).e in1 and \n[[false]]u =!u(e).e in2 They acts as servers which necessarily select the .rst/second branch of the \nreceived channel, c. Similarly we encode natural number n def as [[n]]u =!u(c).c inn.Then ifstatement \nis represented as: def ifu thenP1 elseP2 =u(c)c[.P1&#38; .P2] The channel types are extended by the \nfollowing syntax. s ::=...I[&#38;iEI .[Gxi :Gsi]Gti]pI I[EiEI .[Gxi :Gsi]Gti]pO pI /pO denotes an input/output \nmode. [&#38;ti]pI/[Eti]pO is branch\u00ading/selection, and they are dual each other. We also de.ne the sub\u00adtyping \non selection as: G -[t1 Et2...Etn]pO :[td 1 Et2d ...Etd n...Etn+k]pO with G -ti :tid . The subtyping \nof branching type is de.ned du\u00adally. Intuitively if t :td,then t has more restricted behaviour def than \ntd . For example, u in the boolean agents have type bool\u00c6= def ([EiE{1,2}]tL )!L , while u in [[n]]u \nhas type nat\u00c6=([EiEN]tL )!L , and we have -bool\u00c6:nat\u00c6 . The full de.nition of branching is left to [57]. \nThe basic properties such as subject reduction and the minimum interface theorem, as well as the same \nliveness properties on the linear channels are proved in this system. As we noted at the outset of this \nsection, the type structures can further be augmented with those for state and concurrency, though the \nabove is all we need for our present purposes. We call the typed calculus integrated with the linear/f.ne \ntype disciplines .pLA ..  4. Secrecy and Code Mobility 4.1 General Idea In this section and the next, \nwe illustrate applications of .ne-grained process types enabled by channel dependent types, taking as \nexam\u00adples type-based analyses of two security concerns in mobile code, secrecy and access control. This \nsection treats the former. In systems with mobile code, secrecy analysis means ensuring that coordination \nof pieces of code which can be distributed, communicated and instantiated in different nodes in the \ntype-safe manner does not reveal sensitive information to low-level out\u00adlets. Following [19, 22], we \nmodel .ow of information as trans\u00adformation of behaviour by interaction. Levels of information be\u00adcome \nlevels attached to channel types. When carrying out this pro\u00adgramme in .pLA, two subtleties arise: 1. \nInterplay between linear/af.ne modes and secrecy analyses. 2. The added typability relative to trust \non other code/channels.  The point (1) is already observed in [19, 22] as well as many earlier work \nin programming languages [2, 46, 45]. Here we merely point out that, for example, the secrecy analysis \nof such a simple com\u00admand as xl:=yl;zL:=wLdemands distinction between linearity and af.nity (i.e. if \nwe only use af.ne channels, this obviously safe command becomes unsafe, see [19, 22]; in particular, \nTheorem 3.1 (3) and Theorem 3.2 are essential for the point (1)). The point (2) is proper to .pLA, and \ndemonstrates a real bene.t in using .ne-grained higher-order process types for ensuring secu\u00adrity in \nmobile code. Let us consider the following variation of the secrecy example in Introduction; here a client \nprocess wishes to download an application for calculating a sensitive datum. def lient=a(c)c(x).(.cd)(((xnl)cd)I!cd(y).R) \nThe process asks for the code via a, receives it as x, instantiates it with a local secret datum n and \na local channel cd, and receives the result via cd. As a corresponding server we consider: def def L \nserver=!a(c).c(P)with P =.z..cd .(cd(z +z)Ib(z)) The behaviour of the carried code P is best illustrated \nusing its higher-order process type: ?A ?A tA natl -.(cd:(natl)){cd:(natl),b:(natl)}(11) llL Does this \ntype represent secure behaviour? At .rst sight, the an\u00adswer seems no, since it sends a high-level datum \nto a low-level channel. However, as illustrated in Introduction, our secrecy anal\u00adysis can take into \naccount not only senders but also receivers. In fact, suppose, at b, the following process is located: \nb(y:natl).e l(y) The low-level datum is just forwarded to a high-level channel, so no real low-level \neffects come out. If a process at b uses the received datum insecurely (e.g. transforms it to a low-level \ndatum), or there are eavesdroppers at b, secrecy is compromised. Note when a com\u00adplex data structure \n(including mobile code) is exchanged, its part may contain a datum too sensitive for a receiver. The \nabove discus\u00adsion suggests this would be safe as far as the receiver is ensured to behave well. We can \nsummarise these observations as follows. A For a relatively low-level channel, if (1) each code listening \nto it is secrecy-safe, and (2) no other principals have access to it, one can safely send a high-level \ndatum to the channel. B If these assumptions are not met, then sending a high-level datum to the channel \nshould be prohibited. In the following we outline how these two principles can be simply speci.ed and \nensured using .ne-grained process types. 4.2 Secrecy Typing System We now outline the instrumentation \nof .pLA with secrecy concerns. Let L be a complete lattice of secrecy levels (higher means more secret) \nand let s,sd ,...range over L. Then we de.ne: ppI pO s ::=(t)s I[&#38;iEI ti]s I[EiEI ti]s I(s,sd) with \nt =.[Gx:Gs]Gt and ti =.[Gxi :Gsi]Gti. Base types are also annotated by secrecy levels as nats, but function \ntypes are not. The duality is de.ned preserving secrecy levels. Pair types are as before. Following [22], \nwe take the approach that the level of effects of a process is calculated from its process type. For \nthis purpose we de.ne the tamper level tamper(t)of type t at which the process may affect or tamper the \nenvironment. First we say t is imme\u00addiately tampering if t emits non-trivial information at the time \nof interaction; either t =[EiGti]s tL, md(t)=tA or nats is immediately tampering, so we set tamper(t)=s.We \nsay t is innocuous and set tamper(t)=Tif it never affects environment, i.e. t =unit or md(t)r{?L ,?A \n,t}. For processes, we calculate its effect di\u00adrectly from its interface type, tamper(.)=nuEdom(.){.(u)}.As \nan example, the tamper level of code .bL .in (8) in Section 1 is L because b s tamper level is L. While \nthe tamper level of P in (8) is l, because a is immediately tampering, we can ignore the level of b. \nThe secrecy-enhancement of the typing rules is straightforward integration of the rules in [22]; we only \nhave to change those rules which receive non-trivial information (i.e. the af.ne inputs and the linear \nbranching), saying the tamper level of the body is no lower than that of the received information. For \nexample, in (9) in Section 1, run x in Q1 has type .1 ={b : ()tLA }. Thus we conclude Q1 is untypable \nsince tamper(.1)=Lis not lower than a s level, l(as al .bLis unsafe). On the other hand, Q2 is typable \nsince the body has type 0/ (hence tamper(0/)=T), thus it is safe (as al .0). Note this analysis is never \nderived if Q1 and Q2 are only typed by pro (see [57] for the rest of de.nitions). The principle (B) is \nalso simply formalised by precluding output types of the form (.[Gx:Gs]Gt)spO such that tamper(ti).s \nwhere ti is a higher-order value type. In this principle, lient/serverbecome untypable since the type \nin (11) is not well-formed. 4.3 Proving Non-Interference For proving the non-interference of securely \ntyped higher-order processes, a natural idea is to use a type-preserving translation into the corresponding \nsecurely typed p-calculus. But known transla\u00adtions from HOp into p by [40, 41, 29] cannot be directly \nused since they are not type preserving with respect to .ne-grained interfaces. In [40], a message which \ncarries a value .(x).P is translated into def [[a(.(x).P)]]=a(c)!c(x).[[P]] where a process actually \nused in a receiver stays in the sender side. Hence if P has a type ., then the mapping of the sender \ngains the accessibility ., unlike the source process. Symmetrically for a re\u00adceiver: for example, assuming \n. isa type of P, the original higher\u00adorder processes are typed as: G -a(.P.): a:sa and G -!a(x :...).run \nx : {a:sa,.}, with G =.,a:(sa,sa)and sa =(...)o. However using a mapping in [40], they are translated \ninto G\u00c6-[[a(.P.)]]: a:sa\u00c6 ,.\u00c6and G\u00c6-!a(x).x : a:sa where s\u00c6=(()!)oand .\u00c6is a translation of P s process \ntype. Basic a properties such as linearity and af.nity are not preserved either. Fortunately, the .ne-grained \nprocess types in .pLA enable a rad\u00adically new encoding of higher-order mobile processes into the .rst \norder ones, which is indeed type-preserving. In the new translation, names in process type in P above \ninitially occur bound, and are eventually instantiated when x .nally migrates from the receiver. Note \nx knows free names of P because of its assigned type ....As\u00adsuming {Gb}=dom(.), the new translation becomes: \ndef def [[a(.P.)]]=a(c)!c(Gb).[[P]]and [[!a(x).runx]]=!a(x).x (Gb) where .\u00c6is recorded in the receiver \nside this time. Note this encod\u00ading is unconceivable without the .ne-grained process type. Com\u00adbined \nwith Milner s encoding of the call-by-value .-calculus [22, Figure 7], we can now translate each .pLA-process \ninto a securely typed p-process in [22]. The translation preserves not only typa\u00adbility but action modes, \ntermination and tampering levels. Thus the security-sensitive contextual congruence for .pLA (see below) \nis soundly embedded in the corresponding congruence for the secure p-calculus in [22], whose de.nitions \nare found in [57]. De.ne on securely-typed .pLA-processes as the maximum = s typed congruence which satis.es: \n(i) reduction-closure, i.e. P = sQ and P --Pdimplies Q - Qdand Pd= sQd; and (ii) if -P1= sP2: x :()s \ntA and P1 .xtA then P2 .xtA [20, 22]. The [[]]and ()\u00c6are embeddings of terms/types from .pLA to the secure \np-calculus [22]. PROPOSITION 4.1. 1. (adequacy of the translation) Suppose G -P : . with fv(P)=0/.Then \nG\u00c6-[[P]]: .\u00c6and tamper(.)= tamper(.\u00c6). Moreover P .ap iff [[P]].ap . =sQ if [[P]] 2. (soundness) P =s \n[[Q]]. The noninterference says that two processes with a secrecy level incompatible with s can always \nbe equated by =s. THEOREM 4.2. (non-interference in .pLA) If G -P1,2: . such that tamper(.)=sands sd,then \nG -P1= s'P2: .. For both principles (A) and (B), we can prove the non-interference theorem uniformly \nvia the same translation as follows. The .rst implication is by Proposition 4.1 (1), the second implication \nis by Proposition 6.8 in [22] (non-interference theorem), and the third is by Proposition 4.1 (2). Below \nwe assume tamper(.)=s. G -P1,2: . G\u00c6-[[P1,2]]: .\u00c6with tamper(.\u00c6)=s d [[P1]] [[P2]]with s = s's P1= s'P2 \nhence done (one due remark here is that existence of a sound encod\u00ading does not mean the secrecy analysis \nin .pLA is super.uous; while .ne-grained types in .pLA can specify the different two principles, they \nbecome the same principle in translation into the p-calculus due to the decomposition into name-passing; \nin particular since a distinction between values and channels disappears, the principle (B) is no longer \nspeci.able in the given form). Finally we conclude this section with a small example. Recall Example \n2.5. Assume Server(l)wishes the result of remote pro\u00adcedure call by the client never reveals the private \ninformation n to public channels. Then y is annotated as tL tL t =:[e:(natl)].(x :sx){x :sx,e:(natl)} \nl l +L def with sx =((natl)l)?L . Assume R =ifx >100 thensig with sig typed as ss =()LtA. Then composition \nwith the client and the server is detected by type-checking (remember ifis encoded into the input branching \nhence receiving level at x should be lower than def the level of sig). Next suppose R =sig. Then this \ntime a composi\u00adtion is safe since the linear type ensures the remote call can always succeed, its effect \nis never transfered to R. However if we change linear modes to af.ne ones (i.e. tL /?L to tA /?A) in \nthe guardian type t, saying the remote call may not terminate, then its termina\u00adtion effects to R; in \nthis case, a composition is unsafe because the high level af.ne input suppresses the low level channel, \nsig.  5. Access Control and Code Mobility 5.1 General Idea Suppose a portion of a memory (e.g. a large \narray) is shared by a resident high-level program (P) and a visiting medium-level pro\u00adgram (Q). Assume \nthe write access level of the array is set to high , while the read access level, and practically the \nsecrecy level, is set to medium . Then Q cannot write on the array, but can read from it. Note that even \nif P is secrecy-wise safe, it can still write on the array: as far as it does not write in the way its \nprevious reads at a level higher (or incompatible) than medium level are re.ected, no insecure information \n.ow to Q occurs. Thus secrecy and access control are in principle distinct concerns; this section discusses \nhow the latter can also be cleanly modelled in .pLA . In the context of extensible architecture such \nas SPIN [14], Java [15, 28] and CLR [8], a couple of key mechanisms to smoothly administer access control \nhave been identi.ed (and implemented). Some of them are: 1. Safe access to resources through well-typed \nreferences, which should be maintained through dynamic linkage (possibly com\u00adbining name-space control). \n 2. Dynamic, and often automatic, update of current access rights when crossing a boundary of protection \ndomains (i.e. pieces of code from distinct origins and static authority levels). 3. Primitives to alter \none s own current access right, as far as it does not exceed its static authority level.  Variations \nof these and other mechanisms and their combinations are surveyed in [14, 38, 3, 12]. Our aim in the \nsubsection is to use type structures of .pLA for proposing a simple, yet powerful modelling framework \nof these access control mechanisms. 5.2 Modelling Authorities A Calculus with Authorities. We represent \naccess rights by authority levels, written a,ad ,.., which form a complete lattice. They can be, for \nexample, the set of subsets of all principals, or\u00addered by reverse inclusion. We write a1 a2 if a1 is \nlower than a2. The .rst step to model running code with an authority level is to augment .pLA with a \nframed process following [3, 12, 14]. The extended syntax is given as follows. P ::=..Iset(a){P}I!u[&#38;hii \n(Gyi).Pi] P::=0 I{P}hIP1 IP2 I(.a:s)P A framed process, ranged over P,Q,R,..., is simply a process en\u00adclosed \nby an authority level boundary. As an example, def P={(.c)(bin2(V2c)Ic(x).Pd)}h  (Stack Inspection Approach) \n(set) {set(a){P}}h'--{P}h (com-&#38;) {u[&#38;i(Gyi :Gti).Pi]}hI{uinj(GVj)}h '--{Pj{GVj/Gyj}}h (rep-&#38;) \n{!u[&#38;hii (Gyi :Gti).Pi]}hI{uinj(GVj)}h' --{!u[&#38;i(Gyi :Gti).Pi]}hI{Pj{GVj/Gyj}}hnh' P--Pd P--Pd \n(par) (res) PIQ--PdIQ(.a:s)P--(.a:s)Pd Pd --QdQ (str) PP--Q (History-Based Approach) We replace (com-&#38;) \nby: (com-&#38;-h) {u[&#38;i(Gyi :Gti).Pi]}hI{uinj(GVj)}h '--{Pj{GVj/Gyj}}hnh ' Similarly for other input \nrules. (Structure Rules for Principals) {0}h0 {P IQ}h{P}hI{Q}h{(.a:s)P}h(.a:s){P}h Figure 7: Reduction \nfor Access Control is a thread4 which tries to output via b at the second branch, running at the level \nalie . The boundary as above distributes over parallel composition and restriction (see in Figure 7).5 \nGiven a thread, we next model resources, which include data structures, objects and code bases (linked \nclasses). They in gen\u00aderal have static authorities [33, 14]. A key observation underlying our modelling \nframework is that all these resources are uniformly representable as replicated processes. For example, \nconsider: def hoh(yz).S1&#38; u s (yz).S2]} R={!b[oh h Ris an object with two methods: one can be invoked \nby those whose current levels are higher than bob; the other by those higher than guest. Assuming guestbob, \nthe code has the static level bobsince it may run as bob.If we have guestalietoo, then the access by \nPto Ris safe. Modelling Authority Change. Both stack-inspection [12, 38] and the history-based access \ncontrol [3] offer a mechanism to automatically update a current authority level. The linear/af.ne types \nin .pLA can elegantly model both of these mechanisms via simple instrumentation of operational semantics. \nFirst we de.ne the reduction rules for the stack inspection in Figure 7. Let us see how it works using \nPand Rabove. Assume bob and alie have the meet usr , and let S2{V2c/yz}--* c (W ). PIR(.c)(RI{bin2(V2c)}hI{c(x).Pd}h) \n--(.c)({S2{V2c/yz}}usrI{c(x).Pd}h)IR --*(.c)({c (W )}usrI{c(x).Pd}h)IR(12) --{Pd{W /x}}hIR (13) Thus \nthe rules simulate the principle of stack-inspection (note the .nal reduction restores the original level \nwhen the value is returned, corresponding to discarding all frames when the value is obtained in the \noperational semantics of .s [38]). This is because lin\u00adear/af.ne type structure enables a precise simulation \nof stack disci\u00adpline (cf. bracketing condition of game semantics [4, 24, 21]), even 4In the linear/af.ne \ntype discipline, a process with an active output or an internal t-action can be considered as one thread \n[5]. 5For simplicity, we do not explicitly annotate the frame by a static level, which can be directly \ncalculated from the interface type [57]. G -P : .,a G -P : .,a (Set) (Principal) G -set(a){P}: .,.G -{P}h: \n. G -u:[&#38;hiEiI ti]!A ti =.[Gxi :Gsi]Gtd i (Bra!A ) G,Gxi :Gsi,Gyi :Gti d-Pi :Gxi :Gsi,?.-u ,ai G \n-!u[&#38;hiEiI (Gxi :Gsi,Gyi :Gtid).Pi]: u:[&#38;hiEiI ti]s !A ,.,Uai G -u:[Ehl tl ]pO pO r{?A ,?L }tl \n=.[Gxl :Gsl ]Gtd lEI (Sel) G -vi : sil {Gv/Gxl }G -Vj : td jl {Gv/Gxl } hl G -uinl (Gv,GV ): u:[El tl \n]pO ,Gv :Gsl {Gv/Gxl },al ?.-u means u rfnv(.)and md(.)S{?A ,?L }. (Bra!L ) is similarly de.ned. For \nthe principals, we also add (Par), (Res) and (Weak). Figure 8: Authority Typing System though .pLA includes \nhigher-order code passing and non-determinism. Further the framework is extensible: if we lower the level \nof the resulting process (i.e. ato anadas in (com-&#38;-h) in Figure 7), then the automatic update mechanism \nmatches the history-based [3]. Then when usrand alieinteract in (12), the result in (13) becomes {Pd{W \n/x}}usrsince the current level is always inserted. Both stack-based and history-based approaches also \nhave a mech\u00adanism to freely change (usually raise) the authority level. This is incorporated by the rule \n(set) in Figure 7: the following example illustrates this rule in action. {set(b){(set(a){P}IQ)}} --{set(a){P}}hI{Q}h--{P}hI{Q}h \n Note the authority change occurs only when the set construct (which freezes the body as input pre.x) \nis precisely wrapped by an authority boundary. This is essential for having consistent oper\u00adational semantics. \n 5.3 Static Typing for Access Control We can instrument the type discipline of .pLA to statically ensure \nthe lack of access error. While access levels to resources may be dynamically decided in practice, static \nchecking offers potential for optimisation and suggests .exible combination with dynamic checking [14]. \nWe start with de.ning a notion of access errors which is natural to the present framework (for an alternative \nfor\u00admulation which uses a check privilege primitive, see [57]). The Aerr relation {P}h--(read: {P}hdoes \na dangerous thing ) is gener\u00adated by closing the following rule under parallel composition and restriction. \ni (Gyi).Pi]}hAerr {!b[&#38;hi I{bink(GV )}h'--if ak ad , We outline how we can prevent processes from \ndoing dangerous things by static typing. Typewise, we attach an authority level to each branch/selection; \nand a process type . becomes a pair .,a. pI hipO s ::=..I[&#38;hiEiI ti]s I[EiEI ti]s t ::=..I.,a The \ncomposition 8is rede.ned as .1,a1 8.2,a2 =.1 8.2,a1 Ua2. Further we have a covariant subtyping .,a:.d \n,adiff . :.dand aad. Figure 8 lists the extended typing system, where the follow\u00ading two judgements are \ninvolved: G -P : .,a, and G -{P}h: . The former says the highest level of P s actions (calculated under \nG, which records the access levels of resources) is a.In (Princi\u00adpal),after G -P : .,ais statically checked, \nwe can move to the second judgement, safely enclosing it with a-boundary. (Set) says that set(a){P}is \ntypable only when the highest level of P is a,and the result is the lowest authority. (Sel) means ?-mode \nactions raise the current level. Finally, in (Bra!A ) and (Bra!L ), we ensure that the level of the body \nof each replicated branch is the same as, or lower than, its invocation level: the resulting level should \nbe more than the join of all invocation levels of its branches. In the stack-based approach, for all \nother rules the authority level does not change. We can also mimic a signed code by a variation of (Set)/(Principal) \n[57], which we omit for simplicity of presentation. We list the key properties of the typing system. \nTHEOREM 5.1. (subject reduction) Suppose G -P: ..Then P- Pdimplies G -Pd: .. COROLLARY 5.2. (Access Safety) \nSuppose G -P: .. Then for Aerr all Pdsuch that P- Pd, we have Pd--. These properties are also proved \nin the history-based approach: .rst we add the same rules for all input pre.xes as in (Bra!A ) and delete \npO r{?A ,?L }from (Sel) in Figure 8. Then we add the error predi\u00adcate for all input pre.xes. We give \none example of a typable process. Assuming r (resp. g) has the level root(resp. guest)in G and guestalieroot, \nG -!b[h u s (y).set(root){r (y)}&#38;(yd).g(yd)]: .,a is type-safe iff a;alie, noting the sensitive operation \nat r is pro\u00adtected by set(we may raise ato rootto mimic a signed code). We u s now derive {!b[h(y).set(root){r \n(y)}&#38;(yd).g(yd)]}h, obtain\u00ading the process with level a.  5.4 Example Access Control (1): Untrusted \ncalls Trusted. Assume appletrootfor authority levels. The following program is a clas\u00adsical example (taken \nfrom [3, \u00a7 4.1]) which shows how a call to trusted code by untrusted code results in access violation. \nLocation (1) Applet class BadApplet{ public static void main(){ Library.clean( ..\\\\passwd );}}  Location \n(2) Root public class Library{ public static void clean(string s){File.del(s);}} In .pLA, class loading \nis simply represented by thunked process passing, so that Location (1) is represented as: def def P={l(.A.)}hppwith \nA =Library : lean(pwd) where, as in [47], we represent a method invocation with explicit la\u00adbels a : \nli(GV ), instead of ainji(V ). Similarly we write !a[&#38;li(Gyi).Pi] for branching. The caller in Location \n(2) is simply de.ned as a par\u00adallel composition of a secure loader and a program: {!l(x).run x I!Library[lean(x).File \n: del(x)]}roo Now to perform static type checking, we assign authority levels to the above code. The \nthunk is loaded with respective static permis\u00adsion applet,and lean-method is protected by root. def Q1 \n={!l(x :t1).set(applet){run x} I!Library[leanroo(x).File : del(x)]}roo Above we can observe the guardian \ntype t1 protects leanfrom applet. Suppose t1 =..,a.. Then we must have aappletby (Set) in Figure 8. On \nthe other hand, A must own a higher authority than rootby (Sel) (because leanis annotated by root). Hence \nwe conclude A does not conform to t1, to be rejected by the loader. Access Control (2): Trusted calls \nUntrusted. The next example is a symmetric case, which is also taken from [3, \u00a7 4.1]. This time, trusted \ncode (root) calls untrusted code (a plug-in), then proceeds with the result of the call, leading to access \nviolation. Location (1) Applet class PlugIn(){ string tempfile(){return ..\\\\passwd ;}}  Location \n(2) Root class Naive{ public static void main(){ string s = PlugIn.tempfile(); File.del(s);}}  This \nis an example where the stack-inspection cannot prevent the deletion of the .le, while the history-based \none can. We model this situation in .pLA . A new class created on the remote site is sim\u00adply represented \nby passing a channel abstracted functional process. Code in Location (1) is translated into: def A =.(x).x \n(e)!e[terpfile(c).c (pwd)] Then the code in Location (2) is described as: def Q2 ={(.p)(!l(x :t2).set(applet){xp} \nIp(e).e : terpfile(c)c(x).File : del(x))}roo In the stack-based approach, the above code is type-safe, \nand the deletion of the .le occurs without authority error. This is because when result pwd is returned \nvia linear name c from applet,the current authority is not inserted by appletas shown in the following \nreduction (cf. (13) in \u00a7 5.2). {c (pwd)}hppI{c(x).File : del(x)}roo --{File : del(pwd)}roo However if \nwe use the history-based type-checking, channel c in the above process must be guarded by at least authority \nrootsuch as croo (x).P. Hence A must have rootprivilege, which contradicts with the guardian type t2 \n=.(x : s)({x : s},a)with aapplet. Thus the composition between Pand Q2 is prevented in the history\u00adbased \napproach type-checking. Finally we show information .ow needs to track the data de\u00adpendency which cannot \nbe completely ensured even by the history\u00adbased access control. We modify the body of BadAppletin the \n.rst example as follows. Location (1) Applet s = Library.read( ..\\\\tax ); if s > 100 then File.display( \nrich );  This time we assume the authority level of readand display methods is applet, hence in both \nof the stack inspection and the history-based, it is safe. The process representation of the above code \nis much similar with the example in \u00a7 4.3. (.c)(Library : read(tax,c)I c(s).ifs >100 thenFile : display(rich)) \n Assume x s secrecy level is high and channel File is low. Then essentially by the same reasoning as \nthe example in \u00a7 4.3, this code is rejected by our secrecy typing. See [57] for further examples. 6. \nRelated Work and Extensions Dependent Types of the p-Calculus. This paper proposes new channel dependent \nand existential types for higher-order code mo\u00adbility and demonstrates its usage in the two areas of \nsecurity. In the .rst-order p-calculus, different variants of dependent types are used for ensuring well-formed \ncausal dependency. [51] .rst intro\u00adduced a typing system for ensuring linear causal behaviour, where \ninput object name binds free occurrences x in a type of P,as in a(x)-T . A different typing system in \n[26] uses CCS-like pro\u00adcesses as types to allow more general composition of processes, which however \ndoes not use input object names for quantifying names in types. More recently, [13] proposes a dependent \ntyping system to ensure well-formed patterns of protocols for a special form of the p-calculus where \na(x).P is given a type of the form a(x)T , similar to [51] mentioned above. The main difference of the \npresent type discipline from these work is that channel depen\u00addent types are for higher-order mobile \nprocesses, whose aim is to modularly integrate various advanced type disciplines (in particu\u00adlar those \ndeveloped for the p-calculus) into the higher-order mobile processes. In our dependent types, input object \nname x only binds higher-order type t carried by the same channel such as (.[x:s]t)p; hence if we restrict \nour syntax to the .rst order p, channel depen\u00addent quanti.ers disappear (like (s)p). From our experience \nso far, for integrating an enhanced typing system of the p-calculus into the higher-order processes on \nthe basis of our dependent types, one only needs to extend the syntax of channel types and typing rules \njust following its .rst-order counterpart. This modularity automat\u00adically leads to such basic properties \nas the minimum interface the\u00adorem (Proposition 2.5). As signi.cant examples, we can similarly extend \n.p to the polymorphism [6] and re.ned subtyping [55], ei\u00adther with or without linearity/af.nity. Types \non Distributed Mobile Processes. In the area of the dis\u00adtributed mobile processes, Dp [39] proposed a \nframework where partial type checking prevents migration of code from untrusted locations using location-based \ntypes. M-calculus [43] is a typed version of the higher-order distributed join calculus with hierarchi\u00adcal \nlocations where the type represents access rights of a process as a set of channels, which is more closely \nrelated to our early work in [54]; the channel types in [43] can control higher-order communication and \nguarantee the unicity of local names (which is essentially a similar condition guaranteed by our replicated \naf.ne channels). The typing framework with functional/channel depen\u00addent and existential types in the \npresent work allows more detailed speci.cation of access rights (as shown in Sections 3 and 4) and a \nmore general form of parameterised code with .ne-grained process types. The Seal calculus [9] uses named \nprocess types for rep\u00adresenting agents accessibility in the presence of nested locations. Their typing \nsystem only allows input channel types appears in the process types, hence is unable to control the .ne-grained \noutput ac\u00adcessibility like ours. Also due to the similar typability problem with our previous work [55] \n(which was solved by channel dependent types in this paper), the resulting typed calculus disallows input \non channel names bound by an input action (note that our simple IO\u00adtyping system in Section 2 does not \nrequire this constraint). [17] also shows the new dependent/existential types in this paper can statically \nobtain the dynamic program detection enabled by partial type checking in [39] in a non-trivial higher-order \nextension of Dp. We believe our general type theory, together with new channel de\u00adpendent/existential \ntypes, are applicable to the formalisms where agents movements between hierarchical locations are controlled \nby types with names [9, 43]. See also [57, 17] for more comparison with other distributed calculi. Secrecy \non Mobile Processes. The boxed p-calculus [44] studies a causality based typing to control dynamic composition \nof untrusted components; they annotate output processes with a set of princi\u00adpals. Their causal .ow is \nanalysed by coloured lts. The work does not include higher-order process passing, which is the main aim \nof using the .p in the present work. In distributed mobility, [10, 30] proved the noninterference result \nwith May and barbed equiva\u00adlences (which are weaker properties than our noninterference stated in Theorem \n4.2) in the boxed ambient and Facile based language, respectively. Our framework differs from them in \nthat they do not directly pursue integration of information .ow analysis and autho\u00adrised access control. \nThe typability of our system is larger than that in [10, 30] due to the distinction between linearity \nand af.nity (for example, see \u00a7 4.1), which is crucial to preserve the semantics of programming phrases \nand secrecy analysis (also see \u00a7 8 in [22] and [23] for more comparison with secure typing systems of \nthe .rst\u00ad order p-calculus). Integrity and Access Control. The SLam-calculus [16] is one of the .rst \nwork which integrates secrecy and integrity concerns in a single formalism. The sequential part of SLam \nis encodable into Dependency Core Calculus [2] which in turn can be encoded into the linear/af.ne p-calculus \n[22] (a subcalculus of the .pLA). The concurrency framework in SLam is based on shared variables with\u00adout \ncommunication on channels, while, in p and .p,shared vari\u00adables are simulated using interaction. The \ndevelopment in Sections 4 and 5 may suggest that our approach would scale more easily to the modelling \nof realistic distributed languages than the approach based on shared-variable concurrency. The access \ncontrol mechanisms for extensible language archi\u00adtectures such as Java [28] and CLR [8] are studied in \n[3, 14, 38, 48, 49]. The present work has shown that the use of linear/af.ne type structure allows us \nto simply model both stack inspection and history-based mechanisms (we expect we have a fully abstract \nen\u00adcoding of .s into .pLA [5, 6, 22, 52, 53, 56] augmented with the check privilege primitive). In comparison \nwith the studies based on the .-calculus [12, 38], .pLAM (.pLA with reference agents [57]) can uniformly \ntreat access control in the presence of, among oth\u00aders, name/code-parameterised code, channel-based interaction \nand concurrency, which would be dif.cult in the function-based model [3, 14]. The presented type discipline \ncaptures access to resources as static interface. On its basis, incorporation of more re.ned be\u00adhavioural \nspeci.cations, such as treatment of dynamic resource us\u00adage patterns studied by [25], would be feasible. \nA Distributed Language with Code Mobility. The examples in Sections 5.4 and in 4.3 brie.y show the use \nof higher-order mobile processes for an analysis of behavioural safety of programs with code mobility. \nIn [57], we further applied the type structures of .pLAM to the design of a secure typing system of a \nsimple distributed class-based language with dynamic code distribution. A language is an extension of \nFJ [27]/MJ [7], equipped with the two new prim\u00aditives, seriali.ationand deseriali.ation. Security annota\u00adtions \nare designed following JFlow [33], which can specify some of the key security aspects for code distribution \nin e.g. Java [28] and CLR [8]. In this language, inter-host communication is done via remote method invocation, \nwhich may carry marshaled (serialised) code. Marshalling is done explicitly for arbitrary expressions, \ncar\u00adrying local classes as necessary, and are explicitly unmarshaled. The non-interference property and \nauthorisation error freedom of the language are proved via a translation into .pLAM. To ensure safe scope \nopening of object-ids between serialised code and local ob\u00adject heaps (a similar situation is found in \nExample 2.5), channel existential types are introduced at the language level, demonstrat\u00ading its possible \nuse in type disciplines for high-level languages. See [57] for details. Encodings and Equations. In the \nforegoing studies of the higher\u00adorder mobile processes [29, 40, 41], tractable higher-order behavioural \nequivalences are de.ned via encodings of a higher-order calculus into the .rst-order one. The type-preserving \nencoding proposed in \u00a7 4.2 shows this methodology can be inherited in the setting of strong type discipline, \nwith an added bene.t of more faithful op\u00aderational correspondence including localities and effects of \nmobile code [44, 50], which may be useful for various applications. Acknowledgements: The author thanks \nMatthew Hennessy for his comments and discussions on the channel dependent/existential types, Julian \nRathke for an ongoing collaboration on SafeDpi, Ko\u00adhei Honda for his comments and discussions on applications \nand anonymous referees for their helpful comments. She is partially supported by EPSRC GR/R33465 and \nGR/S55538.   References [1] Abadi, M., Secrecy by typing in security protocols. Journal of the ACM, \n46(5):749 786, 1999. [2] Abadi, M., Banerjee, A., Heintze, N. and Riecke, J., A core calculus of dependency, \nPOPL 99, ACM, 1999. [3] Abadi, M. and Fournet, C., Access Control based on Execution History, NDSS 03, \nCalifornia, 2003. [4] Abramsky, S., Jagadeesan, R. and Malacaria, P., Full Abstraction for PCF, 1994. \nInfo. &#38; Comp. 163 (2000), 409-470. [5] Berger, M., Honda, K. and Yoshida, N., Sequentiality and the \np-Calculus, TLCA01, LNCS 2044, 29 45, Springer, 2001. [6] Berger, M., Honda, K. and Yoshida, N., Genericity \nand the p-Calculus, FoSSaCs 03, LNCS 2620, 103 119, Springer, 2003. [7] Bierman, G.M., Parkinson, M.J \nand Pitts, A.M., MJ: an imperative core calculus for Java and Java with effects, UCAM-CL-TR-563, Cambridge, \n2003. [8] Box, D., Essential .Net Volume I: The Common Language Runtime. Addison Wesley, 2002. [9] Castagna, \nG., Vitek, J. and Zappa, F., The seal calculus, 2003, available from ftp://ftp.di.ens.fr/pub/castagna/. \n [10] Crafa, S., Bugliesi, M. and Castagna, G., Information Flow Security in Boxed Ambients, ENTCS 66 \nNo. 3, 2003. [11] Denning, D. and Denning, P., Certi.cation of programs for secure information .ow. Communication \nof ACM, ACM, 20:504 513, 1997. [12] Fournet, C. and Gordon, A.D., Stack Inspection: theory and variants, \nPOPL, 307 318, ACM, 2002. [13] Gordon, A. and Jeffery, A., Typing correspondence assertions for communication \nprotocols, TCS, 300(2003):379-409. [14] Grimm, R. and Bershad, B., Separating Access Control Policy, \nEnforcement, and Functionality in Extensible Systems, ACM Transactions on Computer Systems, 19(1):36 \n70, Feb., 2001. [15] Gong, L., Inside Java TM 2 Platform Security, Addison Wesley, 1999. [16] Heintze, \nN. and Riecke, J., The SLam Calculus: Programming with Secrecy and Integrity, POPL 98, pp.365-377. ACM \nPress, 1998. [17] Hennessy, M., Rathke, J. and Yoshida, N, SafeDpi: a language for controlling mobile \ncode, Sussex Technical Report, 2003/02, 2003. [18] Honda, K., Composing Processes, POPL 96, pp.344-357, \nACM, 1996. [19] Honda, K., Vasconcelos, V. and Yoshida, N, Secure Information Flow as Typed Process Behaviour, \nESOP 00, LNCS 1782, pp.180 199, Springer, 2000. [20] Honda, K. and Yoshida, N., On Reduction-Based Process \nSemantics. TCS, pp.437 486, No.151, North-Holland, 1995. [21] Honda, K. and Yoshida, N. Game-theoretic \nanalysis of call-by-value computation. TCS Vol. 221 (1999), 393 456, North-Holland, 1999. [22] Honda, \nK. and Yoshida, N., A Uniform Type Structure for Secure Information Flow, POPL 02, 81 92, ACM Press, \n2002. The full version: a DOC technical report, Imperial College London, revised August 2003, available \nat: www.doc.ic.ac.uk/ yoshdia. [23] Honda, K. and Yoshida, N., Noninterference through Flow Analysis, \n40 pages, Sep 2003, available at: www.doc.ic.ac.uk/ yoshdia. [24] Hyland, M. and Ong, L., On Full Abstraction \nfor PCF : I, II and III. Info. &#38; Comp. 163 (2000), 285-408. [25] Igarashi, A. and Kobayashi, N., \nResource Usage Analysis, POPL 02, 331-342, Portland, OR, ACM, 2002. [26] Igarashi, A. and Kobayashi, \nN., A Generic Type System for the Pi-Calculus, POPL 01, 128-141, ACM, 2001. To appear in TCS. [27] Igarashi, \nA., Pierce, B. and Wadler, P., Featherweight Java: A Minimal Core Calculus for Java and GJ. TOPLAS, 23(3):396-450, \nMay 2001. [28] Java, Sun Microsystems Inc., http://www.javasoft.com/. [29] Jeffrey, A. and Rathke, J., \nContextual equivalence for higher-order pi-calculus revisited, MFPS XIX, Montreal, 2003. [30] Kirli, \nD., Con.ned Mobile Functions, 14th CSFW, 2001. [31] Kobayashi, N., Pierce, B., and Turner, D., Linear \ntypes and the p-calculus, TOPLAS, 21(5):914 947, 1999. [32] Microsoft Corporation, .NET Framework Developer \ns Guide, http://msdn.microsoft.com, 2003. [33] Myers, M., JFlow: Practical mostly-static information \n.ow control. POPL 99, 228 241, 1999. [34] Milner, R., Polyadic p-Calculus, Logic and Algebra of Speci.cation, \nSpringer, 1992. [35] Milner, R., Parrow, J.G. and Walker, D.J., A Calculus of Mobile Processes. Info. \n&#38; Comp., 100(1), pp.1 77, 1992. [36] Necula, G., Proof-carrying code. POPL 96, ACM, 1996. [37] Pierce, \nB.C., Types and Programming Languages, MIT, 2002. [38] Pottier, F., Skalka, C. and Smith, S., A systematic \napproach to access control. ESOP01, LNCS 30 45, Springer, 2001. [39] Riely, J. and Hennessy, M., Trust \nand partial typing in open systems of mobile agents. POPL 99, ACM Press, 1999. [40] Sangiorgi, D., Expressing \nMobility in Process Algebras: First Order and Higher Order Paradigms. Ph.D. Thesis, University of Edinburgh, \nCST-99-93, 1993. [41] Sangiorgi, D., Asynchronous process calculi: the .rst-order and higher-order paradigms, \nTCS, 1999. [42] Sangiorgi, D., Termination of Processes, CONCUR 02, 2002. [43] Schmitt, A. and Stefani, \nJ.-B., The M-calculus: A Higher-Order Distributed Process Calculus, POPL03, ACM, 2003. [44] Sewell, P. \nand Vitek, J., Secure Composition of Untrusted Code: Box pi, Wrappers, and Causality Types. Vol. 11, \nNumber 2, 135 188, Journal of Computer Security, 2003. [45] Smith, G., A New Type System for Secure Information \nFlow, CSFW 01, IEEE, 2001. [46] Smith, G. and Volpano, D., Secure information .ow in a multi\u00adthreaded \nimperative language, pp.355 364, POPL 98, ACM, 1998. [47] Vasconcelos, V., Typed concurrent objects. \nECOOP 94, LNCS 821, pp.100 117. Springer-Verlag, 1994. [48] Wallach, D.S, et al., Extensible security \narchitectures for Java. SOSP, 116 128, IEEE, 1997. [49] Wallach, D.S, et al., Safkasi: A security mechanism \nfor language-based systems. ACM transaction on software engineering and methodology, 9(4):341 378, 2000. \n[50] Unypoth, A. and Sewell, P., Nomadic Pict: Correct Communication Infrastructure for Mobile Computation, \nPOPL01, ACM, 2001. [51] Yoshida, N., Graph Types for Monadic Mobile Processes, FSTTCS 16, LNCS 1180, \npp. 371 386, Springer, 1996. Full version as LFCS Technical Report, ECS-LFCS-96-350, 1996. [52] Yoshida, \nN., Type-Based Liveness Guarantee in the Presence of Nontermination and Nondeterminism, April 2002. MCS \nTechnical Report, 2002-20, University of Leicester, available at www.mcs.le.ac.uk/ yoshida. [53] Yoshida, \nN., Berger, M. and Honda, K., Strong Normalisation in the p-Calculus, LICS 01, 311 322, IEEE, 2001. Full \nversion: to appear in Journal of Info. &#38; Comp., available at www.dos.ic.ac.uk/ yoshida. [54] Yoshida, \nN. and Hennessy, M., Subtyping and Locality in Distributed Higher Order Processes. CONCUR 99, LNCS 1664, \npp.557 573, Springer, 1999. [55] Yoshida, N. and Hennessy, M., Assigning Types to Processes, Info. &#38;. \nComp., Volume 174, Issue 2, 143-179, Academic Press, 2002. Extended abstract appeared in LICS 00. [56] \nYoshida, N., Honda, K. and Berger, M. Linearity and Bisimulation, FoSSaCs 2002, LNCS 2303, pp.417 433, \nSpringer, 2002. [57] The full version of this paper, Part I, II and III, available at www.doc.ic.ac.uk/ \nyoshida.  \n\t\t\t", "proc_id": "964001", "abstract": "This paper introduces a new expressive theory of types for the higher-order &#960;-calculus and demonstrates its applicability via two security analyses for higher-order code mobility. The new theory significantly improves our previous one presented in [55] by the use of <i>channel dependent/existential types</i>. New dependent types control dynamic change of process accessibility via channel passing, while existential types guarantee safe scope-extrusion in higher-order process passing. This solves an open issue in [55], leading to significant enlargement of original typability. The resulting typing system is coherently integrated with the linear/affine typing disciplines as well as state, concurrency and distribution [53, 5, 56, 22], allowing precise analysis of software behaviour with higher-order mobility. As illustration of the usage of the typed calculus, two basic security concerns for mobile computation, secrecy for data confidentiality and r&#244;le-based access control for authorised resources, are analysed in a uniform type-based framework, leading to the noninterference theorem and authority-error freedom in the presence of higher-order code mobility.", "authors": [{"name": "Nobuko Yoshida", "author_profile_id": "81100632656", "affiliation": "Imperial College London", "person_id": "PP39051644", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/964001.964014", "year": "2004", "article_id": "964014", "conference": "POPL", "title": "Channel dependent types for higher-order mobile processes", "url": "http://dl.acm.org/citation.cfm?id=964014"}