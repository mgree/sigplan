{"article_publication_date": "01-01-2004", "fulltext": "\n Polymorphic Typed Defunctionalization Franc\u00b8ois Pottier* Nadji Gauthier* Francois.Pottier@inria.fr \nNadji.Gauthier@inria.fr Abstract Defunctionalization is a program transformation that aims to turn a \nhigher-order functional program into a .rst-order one, that is, to eliminate the use of functions as \n.rst-class values. Its purpose is thus identical to that of closure conversion. It differs from closure \nconversion, however, by storing a tag, instead of a code pointer, within every closure. Defunctionalization \nhas been used both as a reasoning tool and as a compilation technique. Defunctionalization is commonly \nde.ned and studied in the set\u00adting of a simply-typed .-calculus, where it is shown that semantics and \nwell-typedness are preserved. It has been observed that, in the setting of a polymorphic type system, \nsuch as ML or System F, defunctionalization is not type-preserving. In this paper, we show that extending \nSystem F with guarded algebraic data types allows recovering type preservation. This result allows adding \ndefunction\u00adalization to the toolbox of type-preserving compiler writers.  Categories and Subject Descriptors \nD.3.3 [Programming Languages]: Language Constructs and Features Polymorphism; Procedures, functions, \nand subroutines; D.3.4 [Programming Languages]: Processors Compilers; F.3.3 INRIA, BP 105, F-78153 Le \nChesnay Cedex, France. [Logics and Meanings of Constructs Type structure Programs]: Studies of Program \nGeneral Terms Languages, Theory. Keywords Defunctionalization, preservation. * closure conversion, polymorphism, \ntype Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n04, January 14 16, 2004, Venice, Italy. Copyright 2004 ACM 1-58113-729-X/04/0001 ...$5.00 1 Introduction \nDefunctionalization, due to Reynolds [13, 14], is a program trans\u00adformation that aims to turn a higher-order \nfunctional program into a .rst-order one, that is, to eliminate the use of functions as .rst\u00adclass values. \nLet us begin with a rough, machine-oriented descrip\u00adtion of it. Under the assumption that the entire \nsource program is available, a distinct tag is associated with every .-abstraction, or, in other words, \nwith every code block. Then, a function value is represented by a closure composed of the tag associated \nwith its code and of a value environment. The generic code in charge of function application, which we \nrefer to as apply in the following, performs case analysis on the tag and jumps to the associated code \nblock, making the contents of the value environment available to it. The reader may notice that defunctionalization \nis a close cousin of closure conversion. In fact, to a certain extent, closure conversion may be viewed \nas a particular implementation of defunctionaliza\u00adtion, whereby tags happen to be code pointers, and \ncase analysis of a tag is replaced with a single indirect jump. One reported advan\u00adtage of defunctionalization \nover closure conversion is that, due to the idiosyncrasies of branch prediction on modern processors, \nthe cost of an indirect jump may exceed that of a simple case analysis followed by a direct jump. Closure \nconversion versus defunctionalization in a typed setting Even though defunctionalization and closure \nconversion appear conceptually very close, they differ when viewed as transformations over typed programs. \nMinamide, Morrisett, and Harper [8] have shown how to view closure conversion as a type-preserving trans\u00adformation. \nThere, the type of a closure is a pair of a .rst-order func\u00adtion type and of a record type, packed within \nan existential type, so that closures whose value environments have different structure may still receive \nidentical types. Minamide et al. deal with both simply-typed and type-passing, polymorphic .-calculi. \nThe case of a type-erasure polymorphic .-calculus has been addressed in [10]. Defunctionalization, on \nthe other hand, has been studied mainly in a simply-typed setting [11, 1]. There, closures receive sum \ntypes: closure construction becomes injection, while the case analysis in\u00advolved by application becomes \nelimination. (If one wishes to avoid recursive types, one must in fact employ algebraic data types, rather \nthan anonymous sum types.) When the source language is ML, the source program is typically turned into \na simply-typed program by applying monomorphization prior to defunctionalization [15, 16, 3]. However, \nmonomorphization involves code duplication, whose cost may be dif.cult to control. Bell, Bellegarde, \nand Hook [2] pro\u00adpose a combined algorithm that performs on-demand monomor\u00adphization during defunctionalization. \nThis may limit the amount of duplication required, but performs identically in the worst case. When the \nsource language is ML with polymorphic recursion or System F, monomorphization becomes impossible, because \nan in\u00ad.nite amount of code duplication might be required. In that case, no type-preserving de.nition \nof defunctionalization was known to date. The dif.culty with polymorphism Why is it dif.cult to de.ne \ndefunctionalization for a typed, poly\u00admorphic .-calculus? The problem lies in the de.nition of apply, \nthe central function that remains in the defunctionalized program, whose task is to perform dispatch \nbased on tags. Its parameters are a closure f and a value arg; its task is to simulate the application \nof the source function encoded by f to the source value encoded by arg, and to return its result. In \nother words, if [eDdenotes the image of the source expression e through defunctionalization, we intend \nto de.ne [e1 e2Das apply [e1D[e2D. Now, assume that de\u00adfunctionalization is type-preserving, and that \n[tDdenotes the image of the source type t through defunctionalization. Then, if e1 has type t1 . t2 and \ne2 has type t1, we .nd that, for apply[e1D[e2D to be well-typed, apply must have type [t1 . t2D. [t1D. \n[t2D. Furthermore, because e1 may be arbitrary, this should hold for all types t1 and t2. The most natural \nway to satisfy this requirement is to arrange for apply to have type .a1a2.[a1 . a2D. a1 . a2 and to \nensure that [ \u00b7Dcommutes with substitution of types for type variables. Now, what is the code for apply? \nIt should be of the form .a1..a2..f : [a1 . a2D..arg : a1.casef of c\u00af where c\u00afcontains one clause for \nevery tag, that is, for every .\u00adabstraction that appears in the source program. The right-hand side of \nevery such clause is the body of the associated .-abstraction, renamed so that its formal parameter is \narg. For the sake of il\u00adlustration, let us assume that the source program contains the .\u00adabstractions \n.x.x + 1and .x.not x, whose types are int . int and bool . bool, and whose tags are succ and not, respectively. \n(These are closed functions, so the corresponding closures have an empty value environment. This does \nnot affect our argument.) Then, the de.nition of apply should contain the following clauses: succ arg \n+ 1 . not not arg . However, within System F, these clauses are incompatible: they make different assumptions \nabout the type of arg, and produce val\u00adues of different types. In fact, for apply to be well-typed, every \n.-abstraction in the source program must produce a value of type a2, under the assumption that its argument \nis of type a1.In the absence of any further hypotheses about a1 and a2, this amounts to requiring every \n.-abstraction in the source program to have type .a1a2.a1 . a2, which cannot hold in general! This explains \nwhy it does not seem possible to de.ne a type-preserving notion of de\u00adfunctionalization for System F. \nThe standard, limited workaround The workaround commonly adopted in the simply-typed case [2, 15, 16, \n3, 11, 1] consists in specializing apply. Instead of de.ning a single, polymorphic function, one introduces \na family of monomor\u00adphic functions, indexed by ground types t1 and t2, eachofwhich has type [t1 . t2D. \n[t1D. [t2D. The point is that the de.nition of applyt1.t2 lists only the tags whose associated .-abstractions \nhave type t1 . t2. Continuing our example, the de.nition of applyint.int should contain a case for succ, \nbut none for not.Con\u00adversely, the de.nition of applybool.bool deals with not, but not with succ. It is \nnow easy to check that all clauses in the de.nition of applyt1.t2 are type compatible, so that the function \nis well-typed. Then, exploiting the fact that e1 must have a ground type of the form t1 . t2, one de.nes \n[e1 e2Das applyt1.t2 [e1D[e2D. Thus, defunc\u00adtionalization in a simply-typed setting is not only type-preserving, \nbut also type-directed. We note that [no longer commutes with \u00b7Dsubstitution of types for type variables. \nIndeed, every distinct arrow type in the source program must now map to a distinct algebraic data type \nin the target program. As a result, there is no natural way of translating non-ground arrow types. These \nremarks explain why the approach fails in the presence of polymorphism. Our solution In the present paper, \nwe suggest another way out of this prob\u00adlem. We keep a single apply function, whose type is .a1a2.[a1 \n. a2D. a1 . a2, as initially suggested above. We also insist that the translation of types should commute \nwith type substitutions, so [t1 . t2Dmust be Arrow [t1D[t2D, for some distinguished, binary algebraic \ndata type Arrow. There remains to .nd a suitable exten\u00adsion of System F where the de.nition of apply \nis well-typed, that is, where every clause does produce a value of type a2, under the assumption that \narg is of type a1. The key insight is that, in order to make this possible, we must acquire further hypotheses \nabout a1 and a2. For instance, in the case of the succ branch, we may reason as follows. If this branch \nis taken, then f is succ,so succ has type Arrow a1 a2, that is, it encodes a source function of type \na1 . a2. However, we know that the .-abstraction associated with the tag succ, namely .x.x + 1, has type \nint . int, so it is natural to assign type Arrowintint to the data constructor succ. Combining these \ntwo facts, we .nd that, if the branch is taken, then we must have Arrowa1 a2 = Arrowintint,that is, a1 \n= int and a2 = int. Under these extra typing hypotheses, it should be possible to prove that arg + 1 \nhas type a2 under the assumption that arg has type a1. Then, by dealing with every clause in an analogous \nmanner, it should be possible to establish that apply is well-typed. The ingredients that make this solution \npossible are simple. First, we need the data constructors succ and not, which are associ\u00adated with the \nalgebraic data type Arrow, to be assigned types Arrowintint and Arrowboolbool, respectively. Please note \nthat, if Arrow was a standard (ML-style) algebraic data type, then the nullary data constructors succ \nand not would necessarily have type .a1a2.Arrowa1 a2. Second, when performing case analysis over a value \nof type Arrowa1 a2, we need the branch associated with succ (resp. not) to be typechecked under the extra \nassumption Arrowa1 a2 = Arrowintint (resp. Arrowa1 a2 = Arrowboolbool). Such a mechanism is quite natural: \nit is reminiscent of the induc\u00adtive types found in the calculus of inductive constructions [12], and \nis known in a programming-language setting as guarded recursive data types [18] or as .rst-class phantom \ntypes [4]. We refer to it as guarded algebraic data types. The term guarded stems from Xi, Chen, and \nChen s observation that they may encoded in terms of recursive types, sum types, and constrained existential \ntypes. Contributions The main contribution of this paper is a proof that defunctional\u00adization may be \nviewed as a type-preserving transformation from System F, extended with guarded algebraic data types, \ninto itself. We also observe, but do not explicitly prove, that the same property holds of ML, extended \nwith polymorphic recursion and guarded al\u00adgebraic data types. It is interesting to note that, because \nour version of defunctionaliza\u00adtion employs a single, polymorphic apply function, it is not type\u00addirected. \nIn other words, type information in the source program is used to construct a type derivation for the \ntarget program, but does not in.uence the latter s structure. Put another way, it is possible to prove \nthat our version of defunctionalization coincides with an un\u00adtyped version of defunctionalization, up \nto erasure of all type anno\u00adtations. This makes it possible to .rst prove that the transformation is \nmeaning-preserving in an untyped setting, then lift this result to the typed setting. These proofs form \nthe paper s second contribu\u00adtion. They appear to be new: indeed, previous proofs [11, 1] were carried \nout in a simply-typed setting. Road map The paper is laid out as follows. Section 2 de.nes an extension \nof System F with guarded algebraic data types. Section 3 de.nes de\u00adfunctionalization of well-typed programs. \nIn Section 4, we prove that defunctionalization preserves well-typedness. In Section 5, we de.ne defunctionalization \nof untyped programs, prove that it pre\u00adserves their meaning, and prove that this result carries over \nto de\u00adfunctionalization of typed programs. Section 6 contains some clos\u00ading remarks.  2 The type system \nIn this section, we de.ne an extension of System F with guarded algebraic data types, which serves both \nas the source and target language for our version of defunctionalization. Our presentation of the type \nsystem is identical to Xi, Chen, and Chen s [18], with a couple of super.cial differences. First, we \nreplace pattern matching with a simple case construct, which is suf.cient for our purposes. Second, we \nadopt an implicit introduction style for type variables, so that type variables are not explicitly listed \nin typing environ\u00adments, and types or typing environments do not have a notion of well-formedness. A \ntype signature T consists of an arbitrary set of algebraic data type constructors T , each of which carries \na nonnegative arity. The de.nitions that follow are relative to a type signature. We let a range over \na denumerable set of type variables and r range over an arbitrary set of record labels. The syntax of \ntypes is as follows: t ::= a |t .t |.a.t |{r\u00af: t\u00af} |T t\u00af Types include type variables, arrow types, universal \ntypes, record types, and algebraic data types. In the universal type .a.t, the type variable a is bound \nwithin t. In the record type {r\u00af: t\u00af},\u00afr must be a vector of distinct record labels, while t\u00afis a vector \nof types of the same length. We write \u00afr : t\u00affor the vector of bindings obtained by associating elements \nof r\u00af, in order, to elements of t\u00af. Vectors of bindings are identi.ed up to reordering. (In the following, \nwe employ similar notation for vectors of bindings of the form \u00afx : t\u00af,\u00afe : t\u00af,\u00afc : t\u00af, and for conjunctions \nof equations t\u00af1 = t\u00af2.) In the algebraic data type T t\u00af, the length of the vector t\u00afmust match the arity \nof T . A constraint C or D is a conjunction of type equations of the form t = t.An assignment is a total \nmapping from type variables to ground types. An assignment satis.es an equation if and only if it maps \nboth of its members to the same ground type; an assignment satis.es a conjunction of equations if and \nonly if it satis.es all of its members. A constraint C entails a constraint D (which we write C D) if \nand only if every assignment that satis.es C satis.es D. Two constraints are equivalent if and only if \nthey entail each other. Constraints serve as hypotheses within typing judgements; entail\u00adment allows \nexploiting them. Entailment is decidable; see e.g. [18]. A data signature D consists of an arbitrary \nset of data construc\u00adtors K, each of which carries a closed type scheme of the form .a\u00af[D].t\u00af.T t\u00af1. \nIn such a type scheme, the type variables a\u00afare bound within D, t\u00af,and t\u00af1. The length of the vector \nt\u00afis the arity of the data constructor K. The de.nitions that follow are relative to (a type signature \nand) a data signature. Let x and y range over a denumerable set of term variables.The syntax of expressions \ne, also known as terms,and of clauses c is as follows: e ::= x c |.x : t.e |ee |.a.e |et |let x = e in \ne |letrec \u00afx : \u00aft = \u00afein e |{\u00afr = \u00afe}|e.r |K \u00aft \u00afe |case e of [t] \u00afc ::= K \u00afa \u00afx .e The language is \nan extension of the polymorphic .-calculus with recursive de.nitions, constructs for creating and accessing \nrecords, and constructs for building and inspecting algebraic data structures. (In Section 5, where we \npresent an operational semantics for this programming language, type abstractions and recursive de.nitions \nare restricted to values; for the moment, however, this is irrelevant.) The injection construct K t\u00afe\u00afrequires \nthe data constructor K to be fully applied. Thus, partial applications of K are not valid expres\u00adsions: \nthey must be encoded via .-expansion. This choice simpli\u00ad.es the de.nition of defunctionalization, because \nit means that only .-abstractions have arrow types. In case constructs, the clauses re\u00adsult type t is \nexplicitly given, so as to preserve the property that ev\u00adery expression has at most one type, up to equivalence, \nwith respect to a given typing environment. (We do not, however, make use of that property.) We assume \nthat, for some algebraic data type con\u00adstructor T , every data constructor K associated with T is selected \nby one and only one clause in c\u00af. In a clause Ka\u00afx\u00af.e, the type variables a\u00afand the term variables \u00afx \nare bound within e. A typing environment G is a mapping of term variables to types, typically written \nas a sequence of bindings of the form x : t.A typing judgement is of the form C, G fe : t. We identify \ntyping judgements up to constraint equivalence. A typing judgement is valid if and only if it admits \na derivation using the rules of Figure 1. In TABS, the notation a # C,G requires the type variable a \nnot to appear free within C or G. All rules but DATA, CLAUSE, CONV,and WEAKEN are standard (System F) \nrules. DATA s .rst premise looks up the type scheme associated with the data constructor K in the current \ndata signature. Its second and third premises check that the constraint D is satis.ed and that the arguments \ne\u00afhave type t\u00af,as required by the type scheme. Both of these checks are in fact rel\u00adative to an instance \nof the type scheme where the type arguments t\u00af2 are substituted for the quanti.ers a\u00af, as well as to \nthe current hypothesis C. DATA may be viewed as a combination of the stan\u00addard rules for (constrained) \ntype application and value application. CLAUSE s .rst premise looks up the type scheme associated with \n APP VAR C,Gfx : G(x) ABS C,G;x : t1 fe : t2 C,G f.x : t1.e : t1 .t2 C,G fe1 : t1 .t2 C,G fe2 : t1 C,G \nfe1 e2 : t2 TABS C,G fe : t a # C,G C,G f.a.e : .a.t TAPP C,G fe : .a.t C,G fe t1 : [a .t1]t LET LETREC \nRECORD PROJ C,G fe1 : t1 C,G; x : t1 fe2 : t2 C,G flet x =e1 in e2 : t2 C,G;\u00afx : \u00aft f\u00afe : \u00aft C,G;\u00afx : \n\u00aft fe : t C,G fletrec \u00afx : \u00aft = \u00afe in e : t C,G f \u00afe : \u00aft C,G f{\u00afr = \u00afe}: {\u00afr : \u00aft} C,G fe : {r : t;\u00afr \n: \u00aft}C,G fe.r : t DATA CLAUSE K :: .a\u00af[D].t\u00af.T t\u00af1 CASE K :: .a\u00af[D].t\u00af.T t\u00af1 a\u00af# C,G,t\u00af2,t C [a\u00af.t\u00af2]DC,G \nfe\u00af: [a\u00af.t\u00af2]t\u00afC,G fe : t1 C,G fc\u00af: t1 .t2 C .D .t\u00af1 =t\u00af2,G;\u00afx : t\u00affe : t C,G fK t\u00af2 e\u00af: T [a\u00af.t\u00af2]t\u00af1 \nC,G fcase e of [t2]c\u00af: t2 C,G fK a\u00afx\u00af.e : T t\u00af2 .t CONV WEAKEN C,G fe : t1 C t1 =t2 C,G1;G2 fe : t x \n# e C,G fe : t2 C,G1;x : t1; G2 fe : t Figure 1. The type system K and a-converts it so that its universal \nquanti.ers coincide with the type variables a\u00afintroduced by the clause at hand. Its second premise requires \nthese type variables to be fresh, so that they be\u00adhave as abstract types within the clause s right-hand \nside e, and do not escape their scope. Its third premise typechecks e under the ex\u00adtra hypothesis D .t\u00af1 \n=t\u00af2, which is obtained from the knowledge that the value being examined, which by assumption has type \nT t\u00af2, is an application of K. This extra hypothesis may provide partial or complete information about \nthe type variables a\u00af, in effect making them semi-abstract or concrete. CONV allows replacing the t1 \nwith the type t2, provided they are provably equal under the assumption C. It is analogous to the subtyping \nrule in a constraint-based type system. The presence of WEAKEN is perhaps surprising, since this rule \nis admissible. It is intended as a hint to the defunctionalization algorithm not to include the value \nof x within closures allocated inside e; see Section 3. The type system is sound [18]. Although this \nproperty is of course essential, it is not explicitly exploited in the present paper. We only make use \nof the following lemma, which allows weakening a judgement s constraint and replacing its typing environment \nwith an equivalent one. When G and G' have the same domain, we view G' =G as a conjunction of type equations. \nLEMMA 2.1. C, G fe : t and C' Cand C' G'=G imply C',G'f e : t.  3 Defunctionalization Defunctionalization \nis a global program transformation: it is neces\u00adsary that all functions that appear in the source program \nbe known and labeled in a unique manner. Thus, in the following, we con\u00adsider a .xed term p, which we \nrefer to as the source program.We require every .-abstraction that appears within p to carry a distinct \nlabel m; we write .mx : t.e for such a labeled abstraction. We re\u00adquire p to be well-typed under the \nempty constraint true and the empty environment ., and consider a .xed derivation of the judge\u00adment true,.fp \n: tp.We let T and D stand for the type and data signatures under which p is de.ned. In the derivation \nof true,.fp : tp, we require every instance of ABS whose conclusion is of the form C,G f.x : t1.e : t1 \n.t2 to satisfy dom(G)=fv(.x.e). Thanks to the presence of WEAKEN, this assumption does not cause any \nloss of generality. This restriction ensures that defunctionalization is independent of the manner in \nwhich WEAKEN is employed in the type derivation. This in turn ensures that our notion of defunctionalization \nis not type-directed, a fact which we establish and exploit later on (Lemma 5.6). The restriction is \notherwise inessential. The transformed program is de.ned under an extended type signa\u00adture T', which \ncontains T as well as a fresh binary algebraic data type constructor Arrow. The effect of the translation \non types is particularly simple: the native arrow type constructor is translated to Arrow, while all \nother type formers are preserved. [aD= a [t1 .t2D= Arrow[t1D[t2D [.a.tD= .a.[tD [{r\u00af: t\u00af}D= {r\u00af: [t\u00afD} \n[T t\u00afD= T [t\u00afD The type translation function extends in a compositional manner to vectors of types, typing \nenvironments, constraints, type schemes, and data signatures. The transformed program is de.ned under \na transformed and ex\u00adtended data signature D', which is de.ned as follows. First, D' contains [DD. Second, \nfor every .-abstraction that appears within p and whose typing subderivation ends with C,G f.mx : t1.e \n: t1 .t2, D' contains a unary data constructor m :: .a\u00af[[CD].{[GD}.Arrow[t1D[t2D, where a\u00afstands for \nthe free type variables of the above judgement, that is, ftv(C,G,t1,t2), ordered in a .xed, arbitrary \nmanner. We point out that [GDis a typing environment, that is, a mapping from term variables to types; \nwe assume that term variables form a subset of record labels, which allows us to form the record type \n{[GD}. We may now de.ne a compositional term translation as follows. In the following, let apply be a \nfresh term variable. The translation is de.ned by a new judgement, of the form C,G fe : t oe', whose \nderivation rules are given in Figure 2. It is immediate to check that C,G fe : t oe' implies C,G fe : \nt. Conversely, given a derivation ABS APP VAR ' '' C,G;x : t1 fe : t2 oe a\u00af= ftv(C,G,t1,t2) C,G fe1: \nt1 .t2 oe1 C,G fe2: t1 oe2 C,G fx : G(x) ox '' C,G f.mx : t1.e : t1 .t2 oma\u00af{G} C,G fe1 e2: t2 oapply[t1D[t2De1 \ne 2 TABS TAPP LET ' ''' C,G fe : t oe a # C,G C,G fe : .a.t oeC,G fe1: t1 oe1 C,G;x : t1 fe2: t2 oe2 \n' '' C,G f.a.e : .a.t o.a.eC,G fe t1: [a .t1]t oe ' [t1D C,G flet x = e1 in e2: t2 olet x = e1 in e 2 \nLETREC '' C,G;\u00afx : t\u00affe\u00af: t\u00afoe\u00afC,G;\u00afx : t\u00affe : t oe ' C,G fletrec x\u00af: t\u00af= e\u00afin e : t oletrec x\u00af: [t\u00afD= \ne\u00af' in e DATA K :: .a\u00af[D].t\u00af.T t\u00af1 C [a\u00af.t\u00af2]D CASE '' C,G fe\u00af: [a\u00af.t\u00af2]t\u00afoe\u00afC,G fe : t1 oe ' RECORD \nPROJ '' C,G fe\u00af: t\u00afoe\u00afC,G fe : {r : t;\u00afr : t\u00af}oe '' C,G f{r\u00af= e\u00af}: {r\u00af: t\u00af}o{r\u00af= e\u00af} C,G fe.r : t oe \n.r CLAUSE K :: .a\u00af[D].t\u00af.T t\u00af1 a\u00af# C,G,t\u00af2,t '' C,G fc\u00af: t1 .t2 oc\u00afC .D .t\u00af1 = t\u00af2,G;\u00afx : t\u00affe : t oe \n'' C,G fK t\u00af2 e\u00af: T [a\u00af.t\u00af2]t\u00af1 oK [t\u00af2De\u00afC,G fcase eof [t2]c\u00af: t2 ocase e ' of [[t2D]c\u00afC,G fK a\u00afx\u00af.e \n: T t\u00af2 .t oK a\u00afx\u00af.e CONV WEAKEN '' C,G fe : t1 oeC t1 = t2 C,G1;G2 fe : t oex # e '' C,G fe : t2 oeC,G1;x \n: t1;G2 fe : t oe Figure 2. Term translation of C,G fe : t, there exists a unique expression e 'such \nthat the judge\u00ad ' ment C,G fe : t oe is the conclusion of a derivation of the same ' shape. We refer \nto e as the image of e through defunctionalization. In the following, we refer to the image of p through \ndefunctional\u00ad ' ization as p . It is obtained from the derivation of true,.fp : tp that was .xed above. \nThe only two interesting rules in the de.nition of the translation are ABS and APP. Indeed, all other \nrules preserve the structure of the expression at hand, using the type translation de.ned above to deal \nwith type annotations. ABS translates every .-abstraction to an injection, making closure allocation \nexplicit. The data constructor (or, in other words, the closure s tag) is m, the unique label that was \nassigned to this .-abstraction. Its type arguments, a\u00af, are all of the type variables that appear free \nin the typing judgement. (By convention, these must be ordered in the same way as in the type scheme \nassociated with the data constructor m in the data signature D' .) Its value argument is a record that \nstores the values currently associated with all of the term variables that are bound by the en\u00advironment \nG. We write {G} as a short-hand for the record term {y = y}y.dom(G), where the left-hand y is interpreted \nas a record label, while the right-hand y is a term variable. This record is the closure s value environment. \nOne might think that it is inef.cient to save all of the term variables in G into the closure, rather \nthan only those that appear free in .x : t1.e. However, if WEAKEN is used eagerly in the original type \nderivation, these must in fact coin\u00adcide, so no ef.ciency is lost. This trick simpli.es our notation. \nAs announced in the introduction, APP translates function applications into invocations of apply. To \ncomplete the de.nition of the program transformation, there re\u00ad ' mains to wrap the term p within an \nappropriate de.nition of apply. Let tapply stand for .a1..a2.Arrowa1 a2 .a1 .a2. Let f and arg be fresh \nterm variables. Let a1 and a2 be fresh type variables. Then, the translation of the source program p, \nwhich we write [pD, is the target program letrec apply : tapply = .a1..a2. .f : Arrowa1 a2. .arg : a1. \ncase f of [a2]c\u00afp ' in p , where, for every .-abstraction that appears within p and whose en\u00adriched typing \nsubderivation ends with ABS ' C,G;x : t1 fe : t2 oe a\u00af= ftv(C,G,t1,t2) , C,G f.mx : t1.e : t1 .t2 oma\u00af{G} \nthe vector \u00afcp contains the clause ' ma\u00af{G}.let x = argin e . As announced in the introduction, apply \nexamines the closure s tag in order to determine which code to execute. The clause associated with the \ntag m re-introduces the type and term variables, namely a\u00af, G, and x, that must be in scope for the function \ns code, namely ' e , to make sense. (Again, the type variables a\u00afmust be ordered in the same way as in \nthe type scheme associated with m.) We write {G}as a short-hand for the record pattern {y = y}y.dom(G). \nThe use of pattern matching is not, strictly speaking, part of our language: we write K a\u00af{r\u00af= x\u00af}.e \nas syntactic sugar for K a\u00afenv .let x\u00af= env.r\u00afin e, where we use vector notation to succinctly represent \nmul\u00adtiple let de.nitions. Our de.nition of defunctionalization is now complete. Although, for the sake \nof simplicity, we have identi.ed the source and target languages, it is easy to check that every defunctionalized \nprogram is .rst-order, as desired. Indeed, all function applications in such a program must be double \napplications of apply,a letrec-bound, binary function. Example For the sake of illustration, we give \na short example program to\u00adgether with its defunctionalized version. The program, inspired from [1], \nde.nes a very simple implementation of sets as character\u00adistic functions, then builds the singleton set \n{1} and tests whether 2 is a member of it. It makes use of a polymorphic equality function = of type \n.a.a . a . bool and of the Boolean or combinator || of type bool . bool . bool. Applications of these \ntwo primitive operations are not affected by the translation. let empty = .a..m1 x : a.falsein let insert \n= .a..m2 x : a..m3 s : a . bool. .m4 y : a.(= axy) || (sy)in insert int 1 (emptyint)2 The empty set empty \nhas type .a.a . bool. The insertion func\u00adtion insert has type .a.a . (a . bool) . (a . bool). The com\u00adplete \nprogram has type bool. Its defunctionalized counterpart is de.ned under the following data signature, \nwhere set a stands for Arrowabool. m1 :: .a[true].{} . set a m2 :: .a[true].{} . Arrowa(Arrow(set a)(set \na)) m3 :: .a[true].{x : a}. Arrow(set a)(set a) m4 :: .a[true].{x : a;s : set a}. set a The type scheme \nassociated with mi speci.es the structure of the value environment found in every closure tagged mi,as \nwell as the type of the function that every such closure encodes. Closures formed using m1 or m2 carry \nan empty value environment, because they encode closed functions. On the other hand, closures formed \nusing m3 or m4 carry a nonempty value environment, because the corresponding .-abstractions have free \nterm variables. The type schemes associated with m1 and m4 are similar to those usually as\u00adsigned to \nthe data constructors nil and cons, which makes apparent the fact that sets built using empty and insert \nbecome lists after de\u00adfunctionalization. The defunctionalized program is given below: letrec apply : \ntapply = .a1..a2. .f : Arrowa1 a2. .arg : a1. casef of | m1 a{} . let x = arg in false | m2 a{} . let \nx = arg in m3 a{x} | m3 a{x}. let s = arg in m4 a{x;s} | m4 a{x;s}. let y = arg in (= axy) || (applyaboolsy) \n[a2] in let empty = .a.m1 a{}in let insert = .a.m2 a{}in apply(apply (apply (insert int)1)(emptyint))2 \n As before, we use punning, that is, we write {x} for the pattern or expression {x = x} and {x; s} for \n{x = x;s = s}. For the sake of brevity, we have omitted the type arguments to apply in the last line. \nMost of the code is straightforward, but it is perhaps worth explain\u00ading why every clause in the de.nition \nof apply is well-typed. Let us consider, for instance, the clause associated with m4. Because the type \nscheme associated with m4 is .a[true].{x : a;s : set a}.Arrowabool , the clause s right-hand side is \ntypechecked under the extra hypothesis a = a1 . bool = a2, and under a typing environ\u00adment that ends \nwith arg : a1;x : a;s : set a. After binding y to arg, the typing environment ends with x : a;s : set \na;y : a1. Thus, y has type a1, which by hypothesis equals a. Hence, by CONV, y has type a. It is then \nstraightforward to check that the expression (= axy) || (applyaboolsy) has type bool. However, by hypothe\u00adsis, \nbool equals a2, so the clause s right-hand side has the expected type a2. All other clauses may be successfully \ntypechecked in a similar manner: although not all of them have type bool, all have type a2. Lemma 4.2 \ncarries out the proof in the general case.  4 Type preservation We now prove that defunctionalization, \nas de.ned in Section 3, pre\u00adserves types. As illustrated by the above example, the proof is not dif.cult. \nIn the following, for the sake of brevity, we write apply, f , and arg for the bindings apply : tapply, \nf : Arrowa1 a2, and arg : a1, respectively. We use this notation in .-abstractions and in typing environments. \nOur .rst lemma states that if an expression e is well-typed, then its ' image through defunctionalization \ne must be well-typed as well, under a constraint, a typing environment, and a type given by the type \ntranslation. Of course, the typing environment must be ex\u00adtended with a binding for apply, which is used \nin the translation of applications. ' LEMMA 4.1. C, G f e : t oe implies [CD, apply;[GDf e ' : [tD. PROOF. \nBy structural induction on the derivation of C,G f e : t o ' e . In each case, we use the notations of \nFigure 2. We explicitly deal with value abstraction and application only; all other cases are straightforward. \n. Case ABS. The rule s conclusion is C,G f .mx : t1.e : t1 . t2 o ' ma\u00af{G} (1). Its premises are C,G;x \n: t1 f e : t2 oe (2) and a\u00af= ftv(C,G,t1,t2) (3). By (1), (3), and by de.nition of the data sig\u00adnature \nD' , we have m :: .a\u00af[[CD].{[GD}. Arrow [t1D[t2D(4). Fur\u00adthermore, by re.exivity of entailment, we have \n[CD[CD(5). Last, by VAR and RECORD, we have [CD,apply;[GDf{G} : {[GD} (6). Ap\u00adplying DATA to (4), (5), \nand (6), we .nd [CD,apply;[GDf ma\u00af{G} : Arrow[t1D[t2D, that is, [CD,apply;[GDf ma\u00af{G} : [t1 . t2D. . \nCase APP. The rule s conclusion is C,G f e1 e2: t2 o '' apply[t1D[t2De1 e2. Its premises are C,G f e1: \nt1 . t2 o '' e1 (1) and C,G f e2: t1 oe2 (2). VAR yields [CD,apply;[GDf apply : tapply. By de.nition \nof tapply and by TAPP, this implies [CD,apply;[GDf apply [t1D[t2D: Arrow[t1D[t2D. [t1D. [t2D, that is, \n[CD,apply;[GDf apply [t1D[t2D: [t1 . t2D. [t1D. [t2D(3). Furthermore, applying the induction hypothesis \nto (1) and ' (2) yields [CD,apply;[GDf e1: [t1 . t2D(4) and [CD,apply;[GDf ' e2: [t1D(5). By APP, (3), \n(4), and (5) imply [CD, apply;[GDf '' apply[t1D[t2De1 e2: [t2D. The second lemma states that apply itself \nis well-typed and has type tapply, as desired. Because apply is recursive, this assertion holds under \nthe binding apply : tapply. LEMMA 4.2. true, apply f .a1a2..f ..arg.case f of [a2]c\u00afp : tapply. PROOF. \nWe must prove that every clause in \u00afcp is well-typed. Thus, let us consider a .-abstraction that appears \nwithin p and whose en\u00adriched typing subderivation ends with ABS ' C,G;x : t1 f e : t2 oe a\u00af= ftv(C,G,t1,t2) \n. C,G f .mx : t1.e : t1 . t2 oma\u00af{G} By applying Lemma 4.1 to the .rst premise, we obtain [CD,apply;[GD;x \n: [t1Dfe ' : [t2D. Then, Lemma 2.1, CONV,and WEAKEN yield [CD.[t1D= a1 .[t2D= a2,apply;arg;[GD;x : ' \na1 fe : a2.By LET, this implies [CD.[t1D= a1 .[t2D= ' a2,apply;arg; [GDflet x = arg in e : a2 (1). Now, \nby de.ni\u00adtion of the data signature D' , we have m :: .a\u00af[[CD].{[GD}.Arrow[t1D[t2D(2). Last, by construction, \nwe have a\u00af# a1a2 (3). Applying CLAUSE to (1), (2), and (3) yields true,apply;arg f ' ma\u00af{G}.let x = arg \nin e : Arrowa1 a2 .a2. Now, because this holds for every .-abstraction that appears within p,and by de.nition \nof c\u00afp, we have established true,apply;arg fc\u00afp : Arrowa1 a2 .a2. The result follows by WEAKEN, CASE, \nABS,and TABS. It is now easy to conclude that the image of the source program p under defunctionalization \nis well-typed. THEOREM 4.1. true,.f[pD: [tpD. PROOF. Applying Lemma 4.1 to the judgement true, .fp : \ntp o ' p ' yields true, apply fp : [tpD(1). The result follows from Lemma 4.2 and from (1) by LETREC. \n 5 Meaning preservation We now prove that defunctionalization preserves the meaning of programs, as \nde.ned by a call-by-value operational semantics. Be\u00adcause our notion of defunctionalization is not type-directed, \nwe are able to proceed in two steps, as follows. First, we de.ne defunction\u00adalization of untyped programs, \nand prove that it preserves mean\u00ading. We emphasize that working in an untyped setting makes such a statement \nparticularly simple and general. Second, exploiting the fact that the two notions of defunctionalization \ncoincide mod\u00adulo type erasure, we easily lift this result back to a typed setting. This approach appears \nmore general than those found in previous works [11, 1]. In the following, we slightly amend the de.nition \nof the program\u00adming language in three ways. First, we introduce two new syn\u00adtactic classes, namely values \nv and values or variables w.The former class contains functions, records, and algebraic data struc\u00adtures, \nwhile the latter includes variables in addition. We restrict the right-hand sides of letrec de.nitions \nto be values: this restriction is standard in a call-by-value setting. Second, we place .-, let-, or \ncase-bound term variables, written x,and letrec-bound term vari\u00adables, written X, in distinct syntactic \nclasses. This choice, while not essential, simpli.es some a-conversion arguments. We refer to an expression \nthat does not have any free variables of the former (resp. latter) class as x-closed (resp. X-closed). \nLast, we restrict the syntax of programs by requiring, in many places, values or variables w instead \nof arbitrary expressions e. This design, which is reminis\u00adcent of Flanagan et al. s A-normal forms [7], \ndoes not incur any loss of expressiveness, but simpli.es our proofs by making let x =[]in e the only \nevaluation context. Because the amendments described in this paragraph have nothing to do with the type \npreservation result presented in the previous sections, we have chosen not to introduce them earlier \non. 5.1 Untyped defunctionalization We .rst de.ne the untyped language. It is the type free counterpart \nof the typed language presented in Section 2, with the amendments described above. e ::= ww ::= x | ww \n| X | let x =e in e | v \u00af | letrec X =v\u00afin ev ::= .x.e | w.r | Kw\u00af | case wof c\u00af|{r\u00af=w\u00af} c ::= Kx\u00af.eS \n::= X\u00af=v\u00af Next, we de.ne a call-by-value, small-step operational semantics. The objects of reduction \nare not expressions, but con.gurations of the form S / e, where a store S is a set of bindings of (distinct) \nletrec\u00adclass term variables to x-closed values. As usual, the term variables in the domain of the store \nS are considered bound in the con.gura\u00adtion S / e. In fact, the notation S / e may be viewed as a shorthand \nfor letrec S in e. The use of a store allows describing the dynamics of letrec de.nitions in a straightforward \nmanner. The operational semantics, a rewriting system on closed con.gurations, is de.ned by the following \nstandard rules. S /(.x.e)v .S /[x .v]e S /let x =vin e .S /[x .v]e S /{r =v;\u00afr =v\u00af}.r .S / v S /case \nKv\u00afof (Kx\u00af.e)|c\u00af.S / [x\u00af.v\u00af]e S /letrec X\u00af=v\u00afin e .S;X\u00af= v\u00af/ e if X\u00af# S S; X = v /X .S;X = v/ v S1 / \ne1 .S2 /e2 S1 /let x =e1 in e .S2 /let x =e2 in e We may now de.ne untyped defunctionalization. As in \nthe typed case, we consider a .xed closed program p, in which every .\u00adabstraction carries a unique tag. \nWe do not, however, require p to be well-typed. The translation of expressions is de.ned, in an in\u00adductive \nmanner, in Figure 3. All cases are trivial, except ABS, which translates .-abstraction to closure construction, \nand APP, which translates function application to invocations of apply. Please note that the relation \nois in fact a function, de.ned for all subexpres\u00ad ' sions of p. We write p for the image of p through \nit. Then, the complete defunctionalized program [pDis de.ned as ' letrec apply =.f ..arg.case f of c\u00afp \nin p , where, for every abstraction of the form .mx.e that appears within p,\u00afcp contains the clause ' \nm{fv(.x.e)}.let x =argin e , ' where e 'is de.ned by e oe .  5.2 Untyped meaning preservation In order \nto establish that untyped defunctionalization preserves meaning, we exhibit a simulation between closed \nsource con.gu\u00adrations and their defunctionalized versions. Roughly speaking, the desired simulation is \nthe closure of the translation ounder substi\u00adtution of (x-closed) values for (x-class) program variables. \nMore precisely, let us de.ne the relation ;by the same rules that de.ne o(that is, by the rules of Figure \n3, where every occurrence is of o is replaced with ;), extended with the following new rule, which subsumes \nABS: SIMABS .mx.e om{y\u00af} x\u00af.y\u00af'' v\u00af,v\u00afx-closed v\u00af;v\u00af ' .x.[x\u00af.v\u00af]e ;m{[x\u00af.v\u00af]y\u00af} APP LET VAR ABS '' \n'' e1 oee2 oe e1 oee2 oe 12 12 .m x oxx.e o ' '' m {fv(.x.e)} e1 e2 oapplye 1 ' e let x = e1 in e2 o \n2 LETREC RECORD PROJ '' '' v\u00afov\u00afe oe w\u00afow\u00afw ow ' ' letrec X\u00af= v\u00afin e oletrec X\u00af= v\u00af' in e {r\u00af= w\u00af}o{r\u00af= \nw\u00af'} w.r ow .r CASE CLAUSE '' ' w owc\u00afoc\u00af e oe ' ' case wof c\u00afocase w ' of c\u00af Kx\u00af.e oKx\u00af.e Figure 3. \nUntyped term translation let x = e1 in e DATA ' w\u00afow\u00af ' Kw\u00afoKw\u00af The notation {[x\u00af.v\u00af']y\u00af}stands for the \nrecord expression {y\u00af=[x\u00af. v\u00af']y\u00af}. In short, SIMABS extends ABS by translating not only func\u00adtions that \nappear in the source program, but also the functions that appear at runtime, where some of the free variables \nhave been in\u00adstantiated with runtime values, that is, x-closed values. It is imme\u00addiate to check that \n;extends o, as stated by the following lemma. ' LEMMA 5.1. e oe ' implies e ;e. Furthermore, ;is closed \nunder substitution, as desired. LEMMA 5.2. Let e ;e ' and v ;v ' , where v and v ' are x-closed. Then, \n[x .v]e ;[x .v ']e ' holds. Last, ;preserves values. LEMMA 5.3. If v ;e ' holds, then e ' is a value. \nWe extend ;to stores and to (closed) con.gurations as follows: STORE CONFIG ' ' apply .X\u00afv\u00af;v\u00af S ;S ' \ne ;e \u00af ' ' X = v\u00af;apply;X\u00af= v\u00af S /e ;S ' /e Above, and in the following, we use apply to stand for the \nstore binding apply = .f ..arg.case f of c\u00afp. We are now ready to prove that ;is a simulation. LEMMA \n5.4 (SIMULATION). This diagram commutes: S ' S1 /e11 /e1 '    + S '' S2 /e2 2 /e2 PROOF. By induction \non the derivation of S1 /e1 . S2 /e2.We give only the most interesting case, namely that of \u00df-reduction. \n. Case e1 is (.x.e)v and e2 is [x .v]e. Examining the hypoth\u00ad '' esis S1 /(.x.e)v ;S1 ' /e1, we .nd that \ne must be of the form 1 apply(m {[x\u00af.v\u00af']y\u00af})v ', where \u00afy is fv(.x.em) (2), \u00afx .y\u00afholds (3), ' e is \n[x\u00af.v\u00af]em (4), \u00afv and \u00afv are x-closed and satisfy \u00afv ;v\u00af' (5), and v ;v ' holds (6). Because we are dealing \nwith closed con.gurations, e1 is x-closed, which implies that e has no free (x-class) variables other \nthan x. Given (4), this implies that the free variables of em form a subset of x\u00af.{x}. Given (2), this \nyields y\u00af.x\u00af. Given (3), y\u00afand x\u00afmust coincide, so we may write {[x\u00af.v\u00af']y\u00af}as {y\u00af= v\u00af'}. Now, by de.nition, \n\u00afcp contains a clause of the form m {y\u00af}.let x = '' ' argin em, where em is de.ned by em oe . This allows \nus to build m the following reduction sequence: ' S ' 1 /e1 ' = S1 ' /apply(m {y\u00af= v\u00af'})v .+ S ' ' 1 \n/case m {y\u00af= v\u00af'}of (m{y\u00af}.let x = v ' in e ) |... m ' . S1 ' /let x = v ' in [y\u00af.v\u00af']em ' since v ' \nand \u00afv are x-closed and, by (2), x. y\u00afholds ' . S1 ' /[x .v '][y\u00af.v\u00af']em There remains to verify that \nthe simulation holds. By Lemma 5.1, ' we have em ;em. By (5), (6), and Lemma 5.2, this implies [x . '' \nv][y\u00af.v\u00af]em ;[x .v '][y\u00af.v\u00af']e , that is, e2 ;[x .v '][y\u00af.v\u00af']e mm. The result follows by CONFIG. Given \na closed expression e, we write e .if and only if the con.g\u00aduration 0/ /e admits an in.nite reduction \nsequence; we write e .if and only if 0/ /e reduces to a con.guration whose right-hand com\u00adponent is a \nvalue. Then, the fact that defunctionalization preserves meaning, in an untyped setting, is stated by \nthe next theorem. THEOREM 5.1. p .implies [pD..p .implies [pD.. PROOF. To begin, let us notice that, \nby de.nition, [pDis ' letrec apply in p . Thus, the con.guration 0/ /[pDreduces, in one ' step, to apply \n/p . Furthermore, by Lemma 5.1, STORE,and CONFIG, 0/ /p ;apply /p ' holds. Now, assume p diverges. Then, \n0/ /p admits an in.nite reduction sequence. By Lemma 5.4, so does apply /p ', hence so does 0/ /[pD, \nwhich proves that [pDdiverges. Last, assume p converges to a con.guration of the form S /v.By the same \nargument as above, [pDmust then reduce to a con.gu\u00adration that simulates S /v. By Lemma 5.3, the right-hand \ncompo\u00adnent of that con.guration must be a value, hence [pDconverges to a value. The theorem states that \ndefunctionalization preserves the termina\u00adtion behavior of the program. It does not apply to programs \nthat go wrong; however, they are of little interest, since, in a realistic setting, they should be ruled \nout by some sound type system. Of course, if desired, it would be possible to prove that defunctional\u00adization \nalso preserves the property of going wrong.  5.3 Typed meaning preservation We now sketch how the meaning \npreservation result may be lifted, if desired, to a typed setting. (The task is simple enough that it \ndoes not, in our opinion, warrant a detailed development.) Naturally, we consider the type system presented \nin Section 2; however, any other type system would do just as well, provided it is powerful enough to \nencode typed defunctionalization and has a type erasure semantics. We begin by restricting the typed \nlanguage de.ned in Section 2 so as to re.ect the restrictions imposed on the untyped language at the \nbeginning of Section 5. Furthermore, we restrict type abstraction to values, that is, we replace the \nconstruct .a.e with .a.v. Indeed, we do not wish .-abstractions to suspend computation, because they \nare erased when going down to the untyped language. Next, we de.ne a typed operational semantics for \nthe language, which is identical to the untyped semantics of Section 5, except type information is kept \ntrack of. The two semantics are related by a simple type erasure property, stated as follows. Given a \ntyped expression e, let .e.be its untyped counterpart, obtained by erasing all type information. Then, \nwe have: LEMMA 5.5. Let true,.fp : tp. Then, p .implies .p..,and p .implies .p... Last, we have insisted \nearlier that our version of defunctionalization is not type-directed. In other words, it commutes with \ntype erasure. This is stated by the following lemma, whose proof is straightfor\u00adward: LEMMA 5.6. Let \ntrue,.fp : tp. Then, [.p.Dis .[pD.. Using Theorem 5.1 as well as the previous two Lemmas, it is now straightforward \nto establish the correctness of typed defunctional\u00adization. To conclude, types do not help establish \nthe correctness of defunctionalization; on the contrary, we believe it is pleasant to get them out of \nthe way, so as to obtain a stronger result (Theorem 5.1).  6 Discussion It is worth noting that recursive \nor mutually recursive functions in the source program do not cause any extra dif.culty. Indeed, a set \nof mutually recursive bindings whose right-hand sides are .-abstractions is mapped to a set of mutually \nrecursive bindings whose right-hand sides are closures, that is, applications of data constructors to \nrecords of variables in other words, values. Even under a call-by-value evaluation regime, mutually recursive \nde.ni\u00adtions of values make perfect sense; see the semantics given in Sec\u00adtion 5.1. The strict functional \nlanguage Objective Caml implements such a semantics. Our treatment of mutually recursive function def\u00adinitions \ncorresponds to Morrisett and Harper s fixpack-based ex\u00adtension to closure conversion [9]. The reader \nmay notice that the simply-typed version of defunction\u00adalization described in the introduction is more \nef.cient than the one presented in this paper, because specializing apply with respect to ground types \nt1 and t2 allows setting up smaller dispatch tables. In fact, specialization is a simple way of exploiting \nthe .ow informa\u00adtion provided for the source program by the type system. Our ver\u00adsion of defunctionalization \nis na\u00a8ive, and includes no such optimiza\u00adtion. It is straightforward, however, to perform specialization \nin a similar way. Indeed, if t1 and t2 are arbitrary (non-ground) types, whose free type variables are \na\u00af, then one may de.ne a specialized function apply.\u00af, whose type is .a\u00af.[t1 .t2D.[t1D.[t2D, a.t1.t2 \nand whose code is identical to that of apply, except it contains branches only for the tags corresponding \nto source functions whose type is an instance of t1 .t2. The resulting program is still well\u00adtyped: indeed, \nas pointed out by Xi [17], a type system equipped with guarded algebraic data types supports identi.cation \nand elim\u00adination of dead branches: they are the branches whose typing hy\u00adpothesis is inconsistent. Thus, \nwhereas, in the simply-typed case, type-based specialization was mandatory in order to achieve type preservation, \nit is now optional. Another source of inef.ciency in our presentation of defunctional\u00adization is our \nna\u00a8ive treatment of multiple-argument functions. In\u00addeed, we have adopted the view that all functions \nare unary. As a result, applying a (curried) function to multiple arguments causes the allocation of \nseveral intermediate closures, which immediately become garbage. In practice, it is possible to address \nthis issue by de.ning yet more versions of apply, specialized for 2,3,... argu\u00adments, and to use these \nspecialized versions at every call site where multiple arguments are available at once. The specialization \ntechniques described in the previous two para\u00adgraphs may be combined, without compromising our type preserva\u00adtion \nresult. This yields defunctionalized programs containing many highly specialized versions of apply, each \nof which typically has few branches. Thus, this approach may allow producing reasonably small dispatch \ntables, by exploiting type information only, instead of relying on a separate closure analysis. Defunctionalization \nmay be viewed not only as a compilation tech\u00adnique, but also as a tool that helps programmers transform \nprograms and reason about them. Danvy and Nielsen [6] have pointed out that it is an inverse of Church \ns encoding, which means that it al\u00adlows reasoning in terms of data structures instead of higher-order \nfunctions. This is nicely illustrated by the case of the sprintf func\u00adtion, whose type is notoriously \ndif.cult to express in ML, because the value of its .rst argument dictates the number and types of its \nremaining arguments. Danvy [5] suggested a clever way of express\u00ading sprintf in ML by encoding format \nspeci.ers as .rst-class func\u00adtions. More recently, Xi, Chen, and Chen [18] showed that sprintf may be \nexpressed in a more direct style, whereby format speci.ers are data structures, in an extension of ML \nwith guarded algebraic data types. We point out that the latter code is but a defunctional\u00adized version \nof the former: it could, in principle, have been derived from it in a systematic manner. Thus, type-preserving \ndefunction\u00adalization may be viewed as a tool to turn existing ML programs that use clever continuation-based \ntricks to work around the limitations of ML s type system back into perhaps more natural, .rst-order \npro\u00adgrams, expressed in an extension of ML with guarded algebraic data types. 7 References [1] Anindya \nBanerjee, Nevin Heintze, and Jon G. Riecke. Design and correctness of program transformations based on \ncontrol\u00ad.ow analysis. In International Symposium on Theoretical As\u00adpects of Computer Software (TACS), \nvolume 2215 of Lecture Notes in Computer Science, pages 420 447. Springer Ver\u00adlag, October 2001. URL: \nhttp://www.cis.ksu.edu/ ab/ Publications/pcfa.ps.gz. [2] Jeffrey M. Bell, Franc\u00b8oise Bellegarde, and \nJames Hook. Type\u00addriven defunctionalization. In ACM International Conference on Functional Programming \n(ICFP), August 1997. URL: http://doi.acm.org/10.1145/258949.258953. [3] Henry Cejtin, Suresh Jagannathan, \nand Stephen Weeks. Flow\u00addirected closure conversion for typed languages. In European Symposium on Programming \n(ESOP), volume 1782 of Lec\u00adture Notes in Computer Science, pages 56 71. Springer Ver\u00ad lag, March 2000. \nURL: http://www.mlton.org/papers/ 00-esop.ps.gz. [4] James Cheney and Ralf Hinze. First-class phantom \ntypes. Technical Report 1901, Cornell University, 2003. URL: http://techreports.library.cornell.edu: \n8081/Dienst/UI/1.0/Display/cul.cis/TR2003-1901. [5] Olivier Danvy. Functional unparsing. Journal of Functional \nProgramming, 8(6):621 625, November 1998. [6] Olivier Danvy and Lasse R. Nielsen. Defunctionalization \nat work. In ACM International Conference on Principles and Practice of Declarative Programming (PPDP), \npages 162 174, September 2001. [7] Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Matthias Felleisen. \nThe essence of compiling with continua\u00adtions. In ACM Conference on Programming Language Design and Implementation \n(PLDI), pages 237 247, 1993. URL: http://www.cs.rice.edu/CS/PLT/Publications/ Scheme/pldi93-fsdf.ps.gz. \n[8] Yasuhiko Minamide, Greg Morrisett, and Robert Harper. Typed closure conversion. In ACM Symposium \non Principles of Programming Languages (POPL), pages 271 283, January 1996. URL: http://www.cs.cornell.edu/Info/People/ \njgm/papers/closure-summary.ps. [9] Greg Morrisett and Robert Harper. Typed closure conver\u00adsion for recursively-de.ned \nfunctions (extended abstract). In International Workshop on Higher Order Operational Techniques in Semantics \n(HOOTS), volume 10 of Elec\u00adtronic Notes in Theoretical Computer Science. Elsevier Sci\u00adence, 1998. URL: \nhttp://www.cs.cornell.edu/home/ jgm/papers/hootsclosure.ps. [10] Greg Morrisett, David Walker, Karl Crary, \nand Neal Glew. From system F to typed assembly language. ACM Transac\u00adtions on Programming Languages and \nSystems, 21(3):528 569, May 1999. URL: http://www.cs.cornell.edu/ talc/papers/tal-toplas.pdf. [11] Lasse \nR. Nielsen. A denotational investigation of defunc\u00adtionalization. Technical Report RS-00-47, BRICS, December \n2000. URL: http://www.brics.dk/RS/00/47/. [12] Christine Paulin-Mohring. Inductive de.nitions in the \nsys\u00adtem coq: Rules and properties. Research Report RR1992\u00ad49, ENS Lyon, 1992. URL: ftp://ftp.ens-lyon.fr/pub/ \nLIP/Rapports/RR/RR1992/RR1992-49.ps.Z. [13] John C. Reynolds. De.nitional interpreters for higher-order \nprogramming languages. Higher-Order and Symbolic Com\u00adputation, 11(4):363 397, December 1998. URL: ftp://ftp. \ncs.cmu.edu/user/jcr/defint.dvi.gz. [14] John C. Reynolds. De.nitional interpreters revisited. Higher-Order \nand Symbolic Computation, 11(4):355 361, De\u00adcember 1998. URL: ftp://ftp.cs.cmu.edu/user/jcr/ defintintro.dvi.gz. \n[15] Andrew Tolmach. Combining closure conversion with clo\u00adsure analysis using algebraic types. In Workshop \non Types in Compilation (TIC), June 1997. URL: http://www.cs.pdx. edu/ apt/tic97.ps. [16] Andrew Tolmach \nand Dino P. Oliva. From ML to Ada: Strongly-typed language interoperability via source transla\u00adtion. \nJournal of Functional Programming, 8(4):367 412, July 1998. URL: http://www.cs.pdx.edu/ apt/jfp98.ps. \n[17] Hongwei Xi. Dead code elimination through dependent types. In International Workshop on Practical \nAspects of Declar\u00adative Languages (PADL), volume 1551 of Lecture Notes in Computer Science, pages 228 \n242. Springer Verlag, January 1999. URL: http://www.cs.bu.edu/ hwxi/academic/ papers/padl99.ps. [18] \nHongwei Xi, Chiyan Chen, and Gang Chen. Guarded recursive datatype constructors. In ACM Symposium on \nPrinciples of Programming Languages (POPL), Jan\u00aduary 2003. URL: http://www.cs.bu.edu/fac/hwxi/ academic/papers/popl03.ps. \n  \n\t\t\t", "proc_id": "964001", "abstract": "<i>Defunctionalization</i> is a program transformation that aims to turn a higher-order functional program into a first-order one, that is, to eliminate the use of functions as first-class values. Its purpose is thus identical to that of <i>closure conversion</i>. It differs from closure conversion, however, by storing a <i>tag</i>, instead of a code pointer, within every closure. Defunctionalization has been used both as a reasoning tool and as a compilation technique.Defunctionalization is commonly defined and studied in the setting of a simply-typed &#955;-calculus, where it is shown that semantics and well-typedness are preserved. It has been observed that, in the setting of a polymorphic type system, such as ML or System F, defunctionalization is not type-preserving. In this paper, we show that extending System F with <i>guarded algebraic data types</i> allows recovering type preservation. This result allows adding defunctionalization to the toolbox of type-preserving compiler writers.", "authors": [{"name": "Fran&#231;ois Pottier", "author_profile_id": "81100490085", "affiliation": "INRIA, Le Chesnay Cedex, France", "person_id": "PP14171513", "email_address": "", "orcid_id": ""}, {"name": "Nadji Gauthier", "author_profile_id": "81100275732", "affiliation": "INRIA, Le Chesnay Cedex, France", "person_id": "P653512", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/964001.964009", "year": "2004", "article_id": "964009", "conference": "POPL", "title": "Polymorphic typed defunctionalization", "url": "http://dl.acm.org/citation.cfm?id=964009"}