{"article_publication_date": "01-01-2004", "fulltext": "\n A Logic You Can Count On Silvano Dal Zilio, Denis Lugiez and Charles Meyssonnier LIF, Laboratoire d \nInformatique Fondamentale de Marseille CNRS and Universit \u00b4 e de Provence Abstract We prove the decidability \nof the quanti.er-free, static fragment of ambient logic, with composition adjunct and iteration, which \ncorre\u00adsponds to a kind of regular expression language for semistructured data. The essence of this result \nis a surprising connection between formulas of the ambient logic and counting constraints on (nested) \nvectors of integers. Our proof method is based on a new class of tree automata for un\u00adranked, unordered \ntrees, which may result in practical algorithms for deciding the satis.ability of a formula. A bene.t \nof our ap\u00adproach is to naturally lead to an extension of the logic with recursive de.nitions, which is \nalso decidable. Finally, we identify a simple syntactic restriction on formulas that improves the effectiveness \nof our algorithms on large examples. Categories and Subject Descriptors: E.1 [Data Structures]: Trees; \nF.4.1 [Mathematical Logic and Formal Languages]: Mathematical Logic modal logic; F.4.3 [Mathematical \nLogic and Formal Languages]: Formal Languages classes de.ned by automata; H.2.1 [Database Management]: \nLogical Design General Terms: Algorithms, languages, theory, veri.cation Keywords: Ambient, substructural \nlogic, semi-structured data, tree automata, Presburger arithmetic 1 Introduction We prove the decidability \nof the static fragment of ambient logic [9], with composition adjunct and iteration, which corre\u00adsponds \nto a kind of regular expression language for tree-like data structures. The ambient logic is a modal \nlogic proposed to describe the struc\u00adtural and behavioral properties of mobile ambients [8]. In this \npa\u00adper, we only consider the spatial fragment of the logic and work Permission to make digital or hard \ncopies of all or part of this work for personal or classroom use is granted without fee provided that \ncopies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page. To copy otherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. POPL 04, January 14 16, 2004, Venice, Italy. \nCopyright 2004 ACM 1-58113-729-X/04/0001 ...$5.00 with .nite, static processes. This static fragment, \nalso called the tree logic (TL) in [7], is essentially a logic on .nite edge-labeled trees. The study \nof TL is motivated by a connection with type sys\u00adtems and query languages for semistructured data [1] \nexploited by Cardelli and Ghelli in their language TQL. In their approach, a for\u00admula of TL may be considered \nas a simple yes/no query against a (tree representing a) database [5], where the answer is yes if the \ntree satis.es the formula. With some extensions, a formula may also be used to extract the subparts of \na tree that match a description. In this setting, we are interested by two problems: model-checking, \nto test whether a given information tree satis.es a formula; and sat\u00adis.ability, to test if there exists \na tree that satis.es a formula. Given the parallel between TL and query languages, model-checking ap\u00adpears \nsimilar to computing the result of a query, while satis.ability is useful for query optimizations or \nto check query inclusion (this problem is also related to subtyping in the implementation of TQL). The \nmodels of the tree logic are terms of the form a1[d1] |\u00b7\u00b7\u00b7| ap[dp], called information trees, obtained \nby the parallel composi\u00adtion of a sequence of elements. Elements have a name (label), a, and a value \n(they lead to a subtree), d. Intuitively, information trees are nested multisets of labels and may be \ncompared to XML docu\u00adments, where elements are of the form <a>d<\\a>, except that the order of elements \nin a tree is not relevant. The tree logic is equally uncluttered and includes primitives for tree composition, \nA |B, for element traversing, a[A], and the implication induced by composi\u00adtion, A.B, with a simple and \nintuitive meaning: composition, A |B, is satis.ed by trees d1 |d2 where d1 satis.es A and d2 satis.es \nB; location, a[A], is satis.ed by trees with a single element a[d] where d satis.es A; composition adjunct, \nA . B, is satis.ed by trees that, when composed with any tree that satis.es A, result in trees that satisfy \nB. The decidability of the model-checking and satis.ability problems is not trivial. Indeed, the meaning \nof A . B is de.ned through a possibly in.nite quanti.cation over the set of trees satisfying A. Another \ndif.culty arises from inde.nite repetition (Kleene star) A* , which is de.ned as a form of .xed point \non the horizontal structure of a tree. We prove the decidability of the model-checking and satis.ability \nproblems for TL, as well as the decidability for the logic enriched with a limited form of .xed point \non the vertical structure of a tree, akin to path expressions, and show that these two kinds of recursion \nare indeed orthogonal.  Motivation and Related Work Our motivations for this work stand at the intersection \nof two long-term research projects in which the authors are involved: a project concerned with the study \nof logical systems for mobile dis\u00adtributed systems and a project related to languages for manipulating \nsemistructured data. In the context of the .rst research project [27], our goal is to improve our knowledge \non the complexity of the ambient logic. The choice of ambient logic is pertinent because it gives a general \nlanguage for expressing behaviors of spatially distributed systems and because its lack of sensitivity \nto the details of the underlying model makes it easily transposable to other settings (such as the p-calculus \n[6] or almost every calculus with a system of nested locations). For the same reasons, it is also a perfect \ntest bed for extensions, such as quanti.cation on fresh names [10, 20]. We only consider the static fragment \nof ambient logic on .nite pro\u00adcesses. Previous works have shown that the model checking prob\u00adlem is PSPACE \nfor the logic without adjunct [11] and that it is un\u00addecidable for the logic with name quanti.cation \nand composition adjunct [12]. In [16], the authors show decidability of the satis.a\u00adbility problem for \nthe logic without adjunct and name quanti.cation using tree automata and a logic on .nite multisets. \nThe result is ex\u00adtended to the logic with adjunct in [3]. The method used is adapted from a technique \nfor proving decidability of validity in a spatial logic for reasoning about heaps [4] and is based on \n.nite test sets for .. Since the size of a test set is not elementary in the size of the formula (it \nis not bounded by any tower of exponentials) it is not obvious that this approach may lead to a practical \nalgorithm. In this paper, we prove the decidability of the tree logic with ad\u00adjunct, iteration and a \nrestricted form of recursion along the paths of a tree. Our proof method is based on a surprising relation \nbetween TL and arithmetical constraints on vectors of integers (expressed as formulas of Presburger arithmetic). \nTo obtain our decidability results, we show the equivalence between TL and a new logic on nested multisets \nof labels, the sheaves logic, that directly includes Presburger arithmetic formulas. In our approach, \nthe sheaves logic appears more amenable to automatic processing and plays the role of a target (assembly) \nlanguage in which we compile formulas of the tree logic. The second research project is related to languages \nfor manipulating semistructured data. As remarked by Cardelli and Ghelli [7], the tree logic is analogous \nto a regular expression language for tree-like data structures and is therefore a perfect basis for typing \nlanguages manipulating semistructured data. We can draw a parallel with the use of regular tree expressions \nin the language XDuce [21], where a logic similar to TL, albeit on an ordered model, is used to type \nextended pattern matching operations over XML documents. The algorithmic methods used in the implementation \nof XDuce are based on regular tree automata [14]. Unfortunately, regular tree automata are not well-suited \nfor unranked or unordered trees. For example, regular tree languages are generally not closed under asso\u00adciativity \nor associativity-commutativity (AC) of function symbols. In this paper, we use a simple extension of \nregular tree automata that works on information trees. This class of automata, called sheaves automata, \nis expressive enough to accept the set of trees matched by an ambient logic formula. The de.nition of \nsheaves automata may be generalized to an alge\u00adbra with an arbitrary number of free function symbols \nand with any number of associative and AC operators [24]. For example, an ex\u00adtended version of sheaves \nautomata has been used by the authors to prove decidability results on a fragment of XML schema [17]. \nTherefore, the logics and the results given in this paper may be extended to a tree model with both sequential \nand parallel compo\u00adsition operators. Outline and Contributions The paper is organized as follows. In \nSection 2 and 3 we review background material on information trees, on the Tree Logic (TL) and on Presburger \narithmetic. In Section 4 we de.ne a new modal logic for information trees, the Sheaves Logic, which is \nbased on an alternative representation of multisets as the product of a sequence of multiplicities with \na sequence of elements. As it is often the case, the shift in the data-structure makes it possible to \nuse more elabo\u00adrate algorithmic methods. At this point, we can already show that the complexity of the \nlogic results equally from the use of composi\u00adtion adjunct as from the combination of composition with \nnegation. More surprisingly, we identify iteration as the most expensive primitive. In Section 5, we \nshow how to interpret every connector of TL in the sheaves logic (SL). As a result, we obtain a compositional \nencoding of TL in SL. The idea is to prove the decidability of SL instead of di\u00adrectly studying TL. To \nthis end, we de.ne (Section 6) a new class of tree automata speci.cally designed for manipulating sheaves. \nThis class of automata works directly on information trees; it is closed by the classical boolean operations \nand by tree composition; and it has a decidable test for emptiness. Before concluding, we exploit the \ninherent recursiveness of au\u00adtomata and augment the (sheaves and tree) logics with a limited form of \nrecursive de.nitions. This extension is expressive enough to include path expressions. A limitation of \nour method is that trees must be processed bottom-up, which may be very inef.cient in the case of large \ntrees. To avoid this problem, we identify a simple syntactical restriction, borrowed from a constraint \nfound in XML Schema [30], that allows for the use of a top-down version of sheaves automata. The connection \nbetween Presburger arithmetic and multiset logics was already used in previous work by the authors [16, \n17]. In this paper, we clear up the relevance of this approach in the case of TL and extend our results \nto a fragment of the ambient logic with com\u00adposition adjunct, ., and Kleene star. It is also the .rst \ntime that we consider an extension of the logic with mutual recursive de.nitions. Another contribution \nof this work is to propose an approach more directed towards practical algorithms, for instance through \nthe de.\u00adnition of bases (see Section 4 and Appendix A), with a study of the algorithmic complexity of \nour methods and the de.nition of possi\u00adble simplifying restrictions. Omitted proofs may be found in a \nlong version of this paper [18]. 2 Information Trees and the Tree Logic Our model for semi-structured \ndata is borrowed from [7]. Informa\u00adtion trees [7] provide a compact syntax for de.ning nested multisets \nof labels borrowed from the ambient calculus [8]. They correspond to the static fragment of the ambient \ncalculus, without primitives for mobility, communication and name scoping but the same frag\u00adment may \nbe found in almost every mobile process calculus with systems of nested locations. The resulting model \nis very close to the XML document model, with the difference that the order of the .elds (subtrees) in \nan information tree is irrelevant. More formally, tree composition is an associative and commutative \noperator. The following table summarizes the syntax of information trees. Given a set . of element labels, \nwe de.ne the set E of elements and the set IT of information trees. Elements and Information Trees e \n::= element a[d] element labeled a (with a ..), containing d d ::= information tree 0 empty information \ntree e element d |d' composition Trees with an equivalent structure are identi.ed. This is ex\u00adpressed \nby means of a structural congruence, the smallest rela\u00adtion on IT \u00d7IT that is a congruence and such that \nd | 0 = d, and d |d'=d'|d and d |(d'|d'') =(d |d') |d''. This relation coincides with structural congruence \nfor the .nite, static fragment of the am\u00adbient calculus. In the remainder of this paper, we work with \nterms modulo structural equivalence. Hence, we view information trees as nested multisets of elements. \nThe 0 process is often omitted in the context a[0], yielding a[]. Example 1. The following information \ntree may be interpreted as a valid entry for the bibliographical reference [8]: article[ title[Mobile \nAmbients[]] |author[Cardelli[]] |author[Gordon[]] |year[1998[]]] . To reason about the spatial and temporal \nproperties of mobile am\u00adbients, Cardelli and Gordon have introduced the modal logic of am\u00adbients [9]. \nThe static fragment of the ambient logic, which only refers to the spatial distribution of locations, \nappears particularly well-suited to describe the structure of information trees. In this paper, we study \nthe static fragment of ambient logic, also called the Tree Logic, TL. A distinctive feature of the logic \nconsidered here, compared to [3], is that we enrich the syntax with an operator for inde.nite repetition, \nA*, which captures a simple class of recursive formulas. With this operator, TL appears as a kind of \nregular ex\u00adpression language, albeit on an unordered data model. Tree Logic Formulas A,B ::= formula \nT true \u00acA negation A.B disjunction 0 empty tree a[A] location (a ..) A |B composition A . B composition \nadjunct A* iteration The denotation of a formula A is a set [[A]] of information trees. As usual, we \nsay that a tree satis.es a formula, denoted d |= A, if and only if d .[[A]]. To simplify the presentation, \nwe extend the composition operator {} to sets of trees, S |S' =def (d |d')(d,d') . S \u00d7S'. With this de.nition, \nit is easy to show that the structure (2IT ,.,0/,|,{0}) is a semi-ring, where 2IT is the powerset of \nIT (modulo =). Sticking to the multiplicative interpretation of composition, we use the nota\u00adtion Sn \nfor the composition S |\u00b7\u00b7\u00b7|S (n times), S0 for the singleton {0}, and S* for the set n;0 Sn . Finally, \nif n =(n1,...,np) is a sequence of integers, and S =(S1,...,Sp) is a sequence of sets of elements, we \nwrite n 'S for the set Sn1 |...|Snpp . The latter notation 1 will sometimes be referred to as a sheaved \ncomposition, and is at the core of the new logic presented in this paper. Satisfaction [[T]] = IT [[\u00acA]] \n= IT \\[[A]] [[A.B]] = [[A]] .[[B]] [[0]] [[a[A]]] = = {0} {a[d] d .[[A]]} [[A |B]] [[A . B]] [[A*]] = \n= = [[A]] |[[B]] {d .d' .[[A]] . (d |d') .[[B]]} [[A]]* The satisfaction rules for the propositional \nfragment are conven\u00adtional. The formula 0 only matches (trees structurally equivalent to) 0, the location \na[A] matches d if d = a[d'] with d'|= A, and the composition A1 | A2 matches d if d = d1 | d2 with di \n|= Ai for all i .{1,2}. Example 2. The following formula of TL matches valid biblio\u00adgraphical entries, \nlike the term given in Example 1: article[ title[T] |author[T] |\u00ac((title[T] .(year[T] |year[T])) |T)] \n. This formula speci.es that a valid bibliographical entry must con\u00adtain exactly one .eld labeled title, \nat least one .eld labeled author, and at most one .eld labeled year, possibly alongside some other (unspeci.ed) \n.elds. These constraints could be expressed more di\u00adrectly using sheaved composition, by saying that \na valid entry must be in one of the sets: (nt ,na,ny,no) ' ([[title[T]]],[[author[T]]],[[year[T]]],So) \n, where nt ,na,ny,no are integer variables such that (nt = 1) and (na ? 1) and (ny . 1) and (no ? 0), \nand So is the set of elements of the form x[d] with x / .{title,author,year}. One of the main contributions \nof this paper is to show that any quanti.er-free TL-formula can be expressed in the same way, that is, \nas the product of integers vectors (de.nable in Presburger arith\u00admetics) by sequences of element formulas. \nIn the next section, we recall the background on Presburger arith\u00admetic and semilinear sets that we need \nin order to de.ne the Sheaves Logic (SL) formally, and then to prove its equivalence with the quanti.er-free \nfragment of TL.  3 Background This section collects the necessary background on Presburger arith\u00admetic \nand its connection with semilinear sets. Presburger arithmetic is the .rst-order theory of equality over \nthe group (N,+) of natu\u00adral numbers with addition. Presburger formulas (also called con\u00adstraints) are \ndescribed in the following table, where M,N,... range over integer variables and m,n,... range over integer \nconstants. Presburger Constraints Exp ::= Integer expression n positive integer constant N positive integer \nvariable Exp1 + Exp2 addition f,.,...::= Presburger arithmetic formulas (Exp1 = Exp2) test for equality \n\u00acf negation f.. disjunction .N.f existential quanti.cation Presburger constraints may be used to de.ne \na substantial class of (decidable) properties over positive integers, like for example the value of M \nis strictly greater than the value of N , using the formula .X.(M = N + X + 1);or M is an odd number \n, .X.(M = X + X + 1). In this paper, we use Presburger formulas to express arithmetical constraints over \nmultiplicities of multisets of elements. Throughout the text we use the vector notation, n, for tuples \nof integers, and |S| for the size (number of elements) of S. We de\u00adnote f(N) a Presburger formula whose \nfree variables are all in N =(N1,...,Np) and we use the notation |= f(n1,...,np) when f{N1.n1}... {Np.np} \nis satis.ed. The denotation [[f(N)]] of a Presburger formula f(N) is the set of integer vectors n such \nthat |= f(n). Presburger arithmetic is an in\u00adteresting example in computational complexity theory because \nit is one of the few problem that provably need more than polynomial run time [19]: every algorithm which \ndecides the truth of a Pres\u00adburger constraint f, that is test whether [[f]] = 0/, has a runtime of at \nleast 2 (2 (cn)) for some constant c, where n is the length of f. (The expression a b stands for the \nexponentiation ab.) There is also a known triply exponential upper-bound in the worst case [26], that \nis for an unbounded alternation of quanti.ers: the complex\u00adity of checking the satis.ability of a formula \nf is in time at most 2 (2 (2 ( pn))). The problem is NP-complete for the existential fragment of Presburger \narithmetic. 3.1 Semilinear Sets Decidability of Presburger arithmetic may be proved using a con\u00adnection \nwith semilinear sets of natural numbers. A linear set of Nn , L(b,P), is a set of vectors generated by \nlinear combination of the periods P = {p1,...,pk} (with pi . Nn for all i . 1..p), with the base b . \nNn: {} L(b,P)=def b + ..ipi .1,...,.k . N. i.1..k A semilinear set is a .nite union of linear sets. Semilinear \nsets are closed under set operations and are exactly the models of Pres\u00adburger arithmetic formulas, that \nis, the set of integer vectors satis\u00adfying a formula f(N1,...,Np) is a semilinear set of Np and con\u00adversely. \nAn important result is that semilinear sets are also closed under the following typical operators of \nregular word languages: L + M =def {x + yx . L,y . M}, Ln =def L + ...+ L (n times), and L* =def n=0 \nLn . PROPOSITION 3.1 (FROM [16]). For any two semilinear sets L,Mof Np, the sets L + M,Lk (k . N) and \nL* are also semilinear sets of Np. Presburger constraints and semilinear sets are effectively equivalent, \nthat is, given a Presburger constraint f, it is possible to compute the bases and periods of a semilinear \nset representing [[f]], and con\u00adversely [15]. To build a semilinear set corresponding to a given Presburger \nconstraint, it is enough to perform quanti.er elimina\u00adtion on the constraint, a possibly expensive procedure. \n 3.2 Sum, Iteration and Derived Connectors Using the relation between semilinear sets and Presburger \nformulas, we can lift sum and iteration to the level of the logic. We also make use of the usual derived \nconnectives, conjunction ., implication ., and universal quanti.cation .. The essence of our equivalence \nresult (Section 5) is a connection between sum and tree composi\u00adtion. The sum of two formulas, f(N)+ \n.(N), is a formula such that [[f + .]] = [[f]] + [[.]]. Assume N,N1 and N2 are disjoint sequences of \nvariables. (f + .)(N)=def .N1,N2.(N = N1 + N2) .f(N1) ..(N2) As in the ambient logic, we may de.ne the \nadjunct and the dual operators for sum. We use the same notation as in TL for the adjunct, ., such that \nf + . f . if and only if f f . . . and we denote I the DeMorgan dual of sum, de.ned by the relation fI. \n=def \u00ac(\u00acf + \u00ac.). (The entailment relation, f f ., means that [[f]] . [[.]].) The following de.nition \nmakes clear the corre\u00adspondence between . and the linear implication connector of linear logic, which \nwas already mentioned in [9]. Assume M,N,N1,N2 are disjoint sequences of variables. (f . .)(N)=def .M.f(M) \n. .(N + M) (fI.)(N)=def .N1,N2.(N = N1 + N2) . f(N1) ..(N2) The following property states the soundness \nof these encodings and relates . with a subtraction operation over the powerset of Np. PROPOSITION 3.2. \nAssume f and . are two Presburger formulas with the same free variables, then for every set of integer \nvectors, S, we have: S . [[f + .]] . S . [[f]] + [[.]], S . [[f . .]] . S +[[f]] . [[.]] . It is also \npossible to derive a formula for iteration, f*, such that [[f*]]= [[f]]*, that is, |= f*(n) if and only \nif n is the sum of a .nite number of vectors satisfying f (we take the empty sum to stand for the null \nvector, 0 =(0,...,0)). Unlike the previous cases, the de.\u00adnition of f* is quite complex. One may .nd \na possible construction in [16, Section 3], which requires to compute the basis and periods of the linear \nsets associated with f. The size of the formula f* may be exponentially bigger than the size of f. Assume \nf is a formula such that [[f]] = i.1..lL(bi,Pi), with Pi = { pi,1,...,pi,li } : ( ( )) f*(N)=def . \u00b5ibi \n+ . .\u00b5i,.i,j.N = .i,jpi,ji.lj.li ((V)) .i.lj.li .i,j . \u00b5i = 0= 0 In the ambient logic, computing the \ndenotation of A . B requires a universal quanti.cation over [[A]] and it is therefore a costly op\u00aderation. \nThis complexity issue does not appear as clearly in the de.nition of subtraction. Given that an uncontrolled \nalternation of + and I produces Presburger formulas with an unbounded alterna\u00adtion of quanti.ers, the \nuse of . is not more problematic than the combination of composition (+) and negation. More surprisingly, \nwhen considering operators derived from TL, it appears that the complexity is dominated by iteration. \n 4 The Sheaves Logic The Sheaves Logic (SL) is a new modal logic for information trees that directly \nencompasses Presburger constraints. The logic, sum\u00admarized below, is built upon a very limited set of \nmodalities and does not even directly embed propositional logic. Nonetheless, we show in the next section \nhow we can derive all the modalities of TL. SL-Formulas a ::= Label expression a1,...,an .nite subset \nof . a. complement of a E ::= Element formula a[A] element with label in a A ::= Counting formula T true \n.N'f(N) 'E sheaves composition (with |N|= |E|) We use uppercase letters A,B,... to denote formulas of \nSL, but this should not cause any ambiguity with TL. We refer to the sequence, E, of element formulas \nappearing in a sheaves composition, A,as the support vector of A. Informally, an element formula a[A] \nin a support vector matches groups of elements of the form a[d], with a .a. A composition, .N'f 'E, is \na quanti.cation over the number of elements in each of these groups, constrained by the Presburger formula \nf. The last formula, T, does not constrain its model in any way. The meaning of SL-formulas is de.ned \nby means of a satisfaction relation. To simplify the presentation, we extend sheaves composi\u00adtion to \nsequences of sets, where (n1,...,np) '(S1,...,Sp) stands for |Snp the set Sn1 |\u00b7\u00b7\u00b7p . 1 Satisfaction \n[[a1,...,an]] = {a1,...,an} [[a.]] = . \\[[a]] [[a[A]]] = {a[d] a .[[a]] .d .[[A]]} [[(E1,...,Ep)]] = \n([[E1]],...,[[Ep]]) [[T]] = IT [[.N'f(N) 'E]] = n.[[f]] n ' [[E]] Label expressions represent .nite \nand co-.nite sets of elements. An interesting example of label expression is 0/., that matches every \npossible label. We use the notation AnyE for the element formula 0/.[T], matching every element in E. \nThe semantic de.nition of sheaves composition is probably easier to understand in terms of the associated \nsatisfaction relation. As\u00adsume E is the support (E1,...,Ep) and n =(n1,...,np). An infor\u00admation tree \nis in the set n '[[E]] if and only if it may be decomposed into the product of n1 elements satisfying \nE1, ..., and np elements satisfying Ep. ii d =.i.1..p(e1 |\u00b7\u00b7\u00b7|e) ni d .n '[[E]] . eij |= Ei for all i \n. 1..p, j .1..ni Then d satis.es .N' f ' E if and only if there exists a sequence of multiplicities, \nn, such that |= f(n) and d .n '[[E]]. The syntax of SL does not restrict the set of support vectors that \nmay be used in a formula. Nonetheless, some supports have bet\u00adter properties than others. For example, \na support vector may be generating, that is, n.Np n ' [[E]] = IT , or its element formulas may have \ndisjoint interpretations. In the latter case, we say that the element formulas are linearly independent. \nThis property is inter\u00adesting since, in this case, it can be proved that the decomposition of a tree \nis always unique, that is, n ' [[E]] nm ' [[E]] = 0/ if and only if n = m. Drawing a parallel with linear \nalgebra, we de.ne a notion of good support vectors, that we call bases, which are maximal sequences of \nlinearly independent element formulas. We ful.ll the canonical property of linear algebra: every information \ntree admits a unique decomposition following a given basis. DEFINITION 4.1 (BASIS). A vector (E1,...,Ep) \nis a basis if and only if i = j implies [[Ei]] n[[Ej]] = 0/ for all i, j . 1..p and [[Ei]] = E. A basis \nE is proper if and only if every support vector appearing in a subformula of E is also a basis. i.1..p \nThe simplest example of (proper) basis is the singleton se\u00adquence AnyE. Another simple example is the \nsequence (a1[T], ...,ap[T],S.[T]), where S = {a1,...,ap} is a .nite subset of .. 5 Encoding TL in SL \nIn this section, we de.ne derived formulas for every operator of TL. As a result, we obtain a compositional \nencoding from TL to SL that preserves the interpretation of formulas. 5.1 Derived Operators Let A be \nthe composition .N'f'E. If the counting constraint is only satis.ed by the null vector then A only matches \n0. Likewise, if f is a tautology and E is generating then A matches every tree in IT . Finally, we can \neasily encode the location formula, a[A], using as support vector the (size 1) sequence a[A]. 0 =def \n.N'(N = 0) 'AnyE True =def .N'(N ? 0) 'AnyE a[A]=def .N'(N = 1) 'a[A] The next proposition states that \nour encoding is faithful to the mean\u00ading of these operators in TL. PROPOSITION 5.1. The following three \nequations hold: [[0]] = {0}, [[a[A]]] = {a[d] a .a.d .[[A]]}, [[True]] = [[T]] = IT . We can as easily \ntransfer the positive composition operators of TL (disjunction, parallel composition and iteration) to \nSL if we assume that the formulas use the same support. Assume A = .N'fA 'E and B = .N'fB 'E. A.B =def \n.N'(fA .fB) 'E A |B =def .N'(fA + fB) 'E A* =def .N'(fA*) 'E The soundness of these encodings is based \non the algebraic proper\u00adties of the semi-ring (2IT ,.,0/,|,{0}), like distributivity of parallel composition \nover set union, for the encoding of disjunction, and the exponentiation rule, Sn1 |Sn2 = Sn1+n2, for \nthe encoding of compo\u00adsition. PROPOSITION 5.2. Assume A = .N'fA 'E and B = .N'fB 'E then the following \nequations hold: [[A.B]] = [[A]] .[[B]], [[A |B]] = [[A]] |[[B]], [[A*]] = [[A]]* . Encoding negative \noperators is not as simple. In particular, the complement of a composition, A = .N'f ' E, is not necessarily \nthe formula A. = .N'(\u00acf) 'E, obtained by complementing the count\u00ading constraint. Possible sources of \nproblems are non-generating support vector. A simple example illustrates this case. Let A {} be the composition \n.N ' (N = 0) ' a[T], with model 0. Then A. = .N'(N = 0) ' a[T] matches trees with only elements labeled \na at top-level, but does not match the tree a[] |b[]. In the case of sheaves formulas built from a common \nbasis, we can interpret negation and composition adjunct in a direct manner. Assume A = .N'fA 'E and \nB = .N'fB 'E where E is a basis. \u00acA =def .N'(\u00acfA) 'E A.B =def .N'(fA .fB) 'E A . B =def .N'(fA . fB) \n'E The soundness of these encodings directly relies on the canonical property of bases, that is, if E \nis a basis then for every tree d there is a unique vector of multiplicities, n, such that d .n ' [[E]]. \nIn the case of negation, for example, we obtain d .[[.N'f 'E]] if and only if |= f(n), as needed. PROPOSITION \n5.3. Assume A = .N' fA ' E and B = .N' fB ' E, with E a basis, then: [[\u00acA]] = IT \\[[A]], [[A.B]] = [[A]] \nn[[B]], [[A . B]] = {d .d '.[[A]],(d |d ') .[[B]]}. Given the encoding of negation, it is possible to \nde.ne a new en\u00adcoding of location built over a basis. Assume A = .N'fA 'E where E is a basis. a[A]=def \n.N1,N2,N3 ' (N1 = 1) .(N2 = N3 = 0) ' (a[A], a[\u00acA], a.[T]) Next, we prove our main result that for every \nformula of TL, there exists an equivalent formula in SL. To overcome a small technical dif.culty with \nthe encodings of the derived operators, namely that we should work with formulas de.ned on a common basis, \nwe show that we can always operate on formulas de.ned on a common basis. PROPOSITION 5.4 (SUPPORT REFINEMENT). \nGiven a sequen\u00adce of formulas (A1,...,An), where Ai is de.ned over a proper basis for all i .1..n, we \ncan build a sequence of formulas (B1,...,Bn), de.ned on a common proper basis, such that [[Ai]] = [[Bi]] \nfor all i .1..n. PROOF. See Proposition A.3 in Appendix A. 5.2 Equivalence Result The main theorem of \nthis section is obtained by assembling our different results. THEOREM 5.1. For any TL-formula A, there \nis a SL-formula B de.ned over a proper basis such that [[A]] = [[B]]. PROOF. By induction on the syntax \nof A. We use Proposi\u00adtions 5.1, 5.2 and 5.3 to translate every operator and, at each step, we use Proposition \n5.4 to ensure that we work with formulas de\u00ad.ned on a common proper basis. It is also possible to prove \nan inclusion in the other direction. (For the sake of brevity, we do not give the details of the reverse \nencod\u00ading here, but a complete proof may be found in [18].) THEOREM 5.2. For any SL-formula A, there \nis a TL-formula B such that [[A]] = [[B]]. Iteration is essential in the proof that TL contains SL: without \niter\u00adation, SL is strictly more expressive than TL. Conversely, we have omitted existential quanti.cation \nover names, .x.A, in the syntax of TL. Our approach does not easily extend to the logic with quanti.er. \n(Since the ambient logic with universal quanti.er and composition adjunct is undecidable [12], there \nis not much hope!) Nonetheless, we can encode a weaker form of quanti.cation using label expres\u00adsions. \nFor instance, we may encode the formula .x.x[A], with x not occurring in A, using the element formula \n0/.[A]. Label expressions may also encode a limited form of fresh quanti.cation [10, 20], Nx.A, with \nthe intuitive meaning that A is true for almost every name x, except a .nite number. The idea is to replace \nevery occur\u00adrences of x by a., where a is a set of labels containing the free names of A. 5.3 Examples \nTo illustrate our results, we use our approach to prove the validity of simple statements in TL. Our \n.rst equation below states that a single element not labeled with a is a single-threaded tree (a tree \nwith exactly one branch at the root: \u00ac0.\u00ac(\u00ac0 |\u00ac0)) that is not an element of the form a[d] (the formula \n\u00aca[T]). a.[T]= \u00ac0.\u00ac(\u00ac0 |\u00ac0) .\u00ac(a[T]) (1) We consider the basis E =(a[T],a.[T]) and only reason on the \ncounting constraints. We use the variable M for the number of el\u00adements matching a[T] and N for the number \nof elements matching a.[T]. We have that \u00ac(a[T]) corresponds to \u00ac((M = 1) .(N = 0)). Likewise, \u00ac0 corresponds \nto the formula \u00ac((M = 0) .(N = 0)) (or equivalently M + N = 0) and \u00ac0 |\u00ac0 corresponds to: .M1,N1,M2,N2.(M \n= M1 + M2) .(N = N1 + N2) . (M1 + N1 = 0) .(M2 + N2 = 0) which is equivalent to M + N ? 2. By combining \nthese three Pres\u00adburger formulas, we obtain that the right-hand side of (1) corre\u00adsponds to (M + N = \n1) .\u00ac((M = 1) .(N = 0)), which is equivalent to (M = 0) .(N = 1), as needed. The second equation states \nthat a composition of elements named a may not contain (at top-level) an element not labeled with a. \na[T]* = \u00ac(T|a.[T]) (2) We use the same basis than in the previous example and only con\u00adcentrate on the \ncounting constraints. The left-hand side of (2) trans\u00adlates to ((M = 1).(N = 0))*, that is, to (M ? 0).(N \n= 0). For the right-hand side, T|a.[T] corresponds to: .(Mi,Ni)i.1,2.(M = M1 + M2).(N = N1 + N2).(N2 \n? 1) which is equivalent to (M ? 0).(N ? 1), as needed. These examples illustrate how we can simply reduce \nthe reason\u00ading on TL to pure arithmetical reasoning. Presburger arithmetic is amenable to automatic theorem \nproving: there exist several dedi\u00adcated provers [2, 28] and many available generic theorem provers include \na decision procedure for (at least a fragment of) Presburger arithmetic. Therefore, a possible application \nof our encoding is to directly assert, or infer, valid statements in TL. In order to deal with more general \nproblems, we need a .exible framework for reasoning on the models of SL-formulas. Using the classical \nconnection between logic and automata theory, we pro\u00adpose in the next section a class of tree automata \nspeci.cally targeted at the manipulation of sheaves formulas.  6 Sheaves Automata Information trees \nare essentially trees modulo an associative\u00adcommutative (AC) theory, it is therefore natural to use tree \nautomata to reason on them. Nonetheless, regular tree automata [14] are not satisfactory in the presence \nof AC operators, such as composition |, and we need to introduce an extended class of automata tailored \nto our need. A (bottom-up) sheaves automaton A is a triple (Q,Q.n, R) where {} Q = q1,...,qpis a .nite \nset of states, Q.n is a set of .nal states included in Q, and R is a set of transition rules. Transition \nrules are two kinds: (1) a[q '] .q (2) f(#q1,...,#qp) .q Type (1) rules correspond to transition rules \nin regular tree automata (we only have unary function symbols, a[.]). A minor difference is that, in \norder to work with in.nite sets of labels, we use label expressions instead of simple labels. Type (2) \nrules allow to compute on nodes with an unbounded ar\u00adity, arising from the composition of two or more \ninformation trees. In type (2) rules, f is a Presburger formula with free variables #q1,...,#qp (one \nfor each state in Q). Intuitively, #qi is a variable that will be substituted by the number of occurrences \nof the state qi in a transition of the automata. A type (2) rule may .re if we have a term of the form \ne1 | ... | en such that ei leads to a state qji . Q for all i .1..n, and |= f(m1,...,mn), where mi is \nthe multiplicity of qi in the multiset qj1 |\u00b7\u00b7\u00b7|q jn . A particular example of transition is obtained \nif |= f(0,...,0), in which case the rule f .q may .re for the null tree, 0. Example 3. Let A be the automaton \nwith states Q = {qa,qb,qs}, set of .nal states Q.n = {qs} and the following transition rules: a[qs] .qa \nb[qs] .qb (#qa = #qb).(#qs ? 0) .qs We show in Example 4, after de.ning the transition relation, that \nA accepts exactly the set of trees with as many a s as b s at each node, like for example b[] |a[b[] \n|a[]]. 6.1 Transition Relation The transition relation of an automaton A is the transitive closure of \nthe relation de.ned by the two following rules. We use the nota\u00adtion #Q(qj1 |... | q jn ) for the multiplicities \nof the states of Q in the multiset qj1 |...|q jn . Transition Relation: . (type 1) ' d .q a[q '] .q .Ra \n.a a[d] . q (type 2) e1 .qj1 ... en .q jn f .q .R (n = 1) #Q(qj1 |...|q jn ) .[[f]] e1 |... |en .q To \navoid ambiguities, a side-condition in the rule for constrained transitions ensure that it cannot be \napplied to sequences, a[d], with a single element. It could be possible to have only one kind of transition \nrule, but it would needlessly complicate our de.nitions and proofs without adding expressivity. Example \n4. Let A be the automaton de.ned in Example 3. Since the constraint in the type (2) rule of A is satis.ed \nby (0,0,0),we have that 0 . qs. Let d be the tree a[] | b[a[] | b[]], a possible accepting run of the \nautomaton is given below: d . a[0] |b[a[qs] |b[0]] . a[qs] |b[a[qs] |b[0]] . a[qs] |b[a[qs] |b[qs]] . \nqa |b[a[qs] |b[qs]] . qa |b[a[qs] |qb] . qa |b[qa |qb] . qa |b[qs] . qa |qb .qs In transitions 7 and \n9 (marked with a -symbol), we use the only constrained rule of A. In each case, the multiset used in \nthe con\u00adstraints is qa | qb, which contains as many qa s than qb s (that is, #Q(qa |qb)=(1,1,0)). We \nsay that an automaton A is deterministic if and only if for every pair of distinct type (1) rules, a[q] \n. q1 and \u00df[q] . q2,wehave [[a]] n[[\u00df]] = 0/ and for every pair of distinct type (2) rules, f . q1 and \n. . q2,wehave [[f]] n[[.]] = 0/. A property of deterministic automata is that for each tree d there is \nat most one state q . Q such that d . q. As usual, we say that a tree d is accepted by an automaton A \nif there is a .nal state q . Q.n such that d . q. The language L(A) is the set of trees accepted by A. \nThe class of automata considered in this paper is a subset of a richer (homonym) class of tree automata \nde.ned by the au\u00adthors [16, 17, 24]. In the original version, sheaves automata may be used on terms built \nfrom an arbitrary number of free function symbols and from any number of associative and AC operators. \nTherefore, the de.nition of sheaves logic may be extended to an ar\u00adbitrary signature, giving an elegant \nway to extend our results to an algebra with sequential composition and (not only unary) function symbols. \nWhen restricted to tree composition, sheaves automata correspond to a particular instance of multiset \nautomata [13], de\u00ad.ned by Colcombet to reason on higher-order versions of Process Rewrite Systems. More \nsigni.cantly, we can draw a parallel be\u00adtween sheaves automata and hedge automata [25], an extension \nof regular tree languages at the basis of RELAX-NG [29], a schema language for XML. Whereas hedge automata \noperate on an ordered model of trees and use regular word languages to constrain ordered bunches (sequences) \nof elements, we work on an unordered model and use semilinear sets to constrain the multiplicities of \nunordered bunches (multisets) of elements. 6.2 Closure Properties Given two Sheaves Automata A = (Q,Q.n,R) \nand A' = (Q ' ,Q ' .n,R '), we can construct the product automaton, A\u00d7A', that will prove useful in the \nde.nition of the automata for union and in\u00adtersection. The product A\u00d7A' is the automaton A\u00d7 = (Q\u00d7 ,0/,R\u00d7) \n'' such that Q\u00d7 = Q \u00d7Q ' = {(q1,q1),...,(qp,q )}and: r for every type (1) rule a[q] . s . R and \u00df[q \n'] . s '. R ',if a n\u00df = 0/ then the rule (a n\u00df)[(q,q ')] .(s,s ') is in R\u00d7 ,  for every type (2) rule \nf .q .R and f'.q '.R ' , the rule f\u00d7.(q,q ') is in R\u00d7, where f\u00d7 is the product of the formulas f and \nf' obtained as follows. Let #(q,q ') be the variable asso\u00adciated to the numbers of occurrences of the \nstate (q,q '), then f\u00d7 is the formula:  ( ) f.q '.Q' #(q1,q '),...,.q '.Q' #(qp,q ') f'('' ) . .q.Q \n#(q,q1),...,.q.Q #(q,qr) The following property states the soundness of this construction. ' PROPOSITION \n6.1. We have d .(q,q ') in the automaton A\u00d7A, ' if and only if both d .A q and d .A' q. Given two automata, \nA and A', it is possible to build an automaton accepting the language L(A) .L(A') and an automaton accepting \n' L(A) nL(A'). The intersection AnA' and the union A.Amay be obtained from the product A \u00d7A' simply by \nsetting the set of .nal states to: Qn =def (q,q .n { ') q .Q.n . q .Q ' .n} Q. =def (q,q .n ') q .Q.n \n. q .Q ' .n The union automaton may also be obtained using a simpler con\u00adstruction, similar to the one \nfor .nite state (word) automata, leading to an automaton with states Q .Q ' . PROPOSITION 6.2. The automaton \nA.A' accepts L(A).L(A') and AnA' accepts L(A) nL(A'). The class of sheaves automata is also closed by \ncomplementation. The construction of the complement of an automaton is similar to a determinization procedure. \n(In particular, the complemented au\u00adtomaton may be exponentially bigger than the original). PROPOSITION \n6.3. Given an automaton A we can build an au\u00adtomaton A. such that L(A.)= IT \\L(A). The product construction \nyields an ef.cient algorithm to test the in\u00adclusion L(A) . L(A'), provided that A' is deterministic. \nIn this case, we simply need to test the emptiness of the language accepted by A\u00d7A' with .nal states \nQ.n \u00d7(Q '\\Q ' .n). Using our equivalence and de.nability results, Th. 5.1 and 6.1, we may relate this \nproblem to testing whether a formula of TL is a subtype of another for\u00admula, an important issue in the \nimplementation of the programming language TQL. 6.3 Membership and Test for Emptiness In this section, \nwe consider the problem of checking if an informa\u00adtion tree is accepted by a given automaton. Assume \nthere is a function Cost such that, for all constraints f, the evaluation of f(n1,...,np) can be done \nin time O(Cost(p,n)) whenever ni n for all i in 1..p. For quanti.er-free Presburger formula (and if n \nis in binary notation) such a function is given by K.p.log(K.p.n), where K is the greatest coef.cient \noccurring in f. For arbitrary situations, that is, for formulas with unbounded quanti.er alternation, \nevaluating a formula is as hard as testing its satis.ability and therefore the complexity is triply exponential. \nPROPOSITION 6.4. For an automaton A = the (Q,Q.n,R), model-checking problem, d . L(A), can be decided \nin time O(|d|.|R|.Cost(|Q|,|d|)) for a deterministic automaton. The prob\u00adlem is NP-complete for a non-deterministic \nautomaton. We give an algorithm for deciding emptiness based on a standard marking algorithm for regular \ntree automata. The marking algo\u00adrithm computes two sets of states, QM and QE , where QM corre\u00adsponds \nto reachable states and QE corresponds to states reachable by an element (i.e., through the application \nof a type (1) rule). The algorithm returns a positive answer if and only if there is a marked .nal state. \nIn the case of constrained rules, f .q, we need to check whether there is a multiset of marked elements \nwhose mapping satis.es f. This amounts to checking the satis.ability of the Presburger for\u00admula f(#q1,...,#qp). \nq./QE #q = 0. When this formula is satis.\u00ad able, we say that the constraint f \\QE is satis.able. In particular, \nthe constraint f \\0/ is satis.able if and only if |= f(0). Algorithm 1. Test for Emptiness  QE = 0/ \nQM = {q f .q .R.|= f(0)}  repeat if a[q '] .q .R and q '.QM and a = 0/ then QM := QM .{q} and QE := \nQE .{q}if f .q .R and f \\QE is satis.able then QM := QM .{q} until no new state can be added to QM if \nQM contains a .nal state then return not empty else return empty  PROPOSITION 6.5. A state q is marked \nby Algorithm 1 if and only if there exists a tree d such that d .q. We may prove prove this claim using \na reasoning similar to the one for regular tree automata. We can also establish a result on the complexity \nof this algorithm. Let CostA denote the maximal time required to decide the satis.ability of the constraints \noccurring in type (2) rules of A. PROPOSITION 6.6. The problem L(A)= ? 0/ is decidable in time O(|Q|.|R|.CostA). \nIn the case of regular tree automata, it is possible to .nd a more re.ned algorithm for the emptiness \nproblem, based on the satis.a\u00adbility of propositional Horn clauses, with only a linear complexity in \nthe size of A. Therefore we may hope to improve our complexity result.  6.4 Results on the Tree Logic \nWe prove our main property linking sheaves automata and the sheaves logic and use this result to derive \nseveral complexity re\u00adsults on the fragment of Ambient Logic studied in this paper. THEOREM 6.1 (DEFINABILITY). \nFor every SL-formula A, we can build an automaton A accepting the models of A. PROOF. By structural induction \non the de.nition of A. In the case A = T we can simply choose an all accepting automaton. For example, \nthe automaton with unique (.nal) state, q, and with rules 0/.[q] .q, and (#q ? 0) .q. The only other \ncase is A = .N' f ' E, where E is a support vector (a1[A1],...,ap[Ap]). By induction, there is an automaton \nAi ac\u00adcepting the models of Ai for all i . 1..p. From an automaton C accepting the models of C, we can \nconstruct an automaton Ca ac\u00ad {} cepting the set a[d] d . [[C]],a . a:if a = 0/, then [[a[C]]] = 0/ and \nwe can simply choose for Ca any automaton with an empty set of .nal states; otherwise, we obtain Ca from \nC by adding a fresh new state qs, that will be the only .nal state of Ca, and by adding one type (1) \nrule a[q] . qs for each .nal state q of C. Thus, we may build an automaton Bi accepting the models of \nai[Ai] for all i .1..p. The construction of A is similar to a determinization process. Let A be the product \nautomaton of the Bi s and let {Q1,...,Qm} be the states of A. A state Q of A is of the form (q1,...,qp), \nwith qi a state of Bi, and may represent terms accepted by several of the Bi s. We use the notation Q \n. .n(i) to say that the ith component of Q is a .nal state of Bi. The constrained rules of A are of the \nform .(M1,...,Mm) .Q, where Mi stands for the number of oc\u00adcurrences of the state Qi in a run. The idea \nis to extend A with a fresh new state, qs, that will be its only .nal state, and to add a new rule f.(M1,...,Mm) \n. qs, where f. is satis.ed by con.gurations Qj1 | \u00b7\u00b7\u00b7 | Qjn containing only states in .n(i) (for some \ni . 1..p). The formula f., given below, is obtained by decomposing Mi into a sum of integer variables \nXij, for j . 1..p, corresponding to .nal states of Bj occurring in Qi. .(). Xi i.1..mMi = . j.1..pj . \nQi..n( j) . .(Xi)\u00b7 () ji.1..m .. Xi Xi j.1..p . f. i.1..m 1, ... ,. i.1..mpQi..n(1) Qi..n( p) The property \nfollows by showing that d |= A if and only if d . L(A). A formula A of SL is basically a (syntax) tree \nwhere each node is labeled by a sheaves composition, .N'f'E, and has |E|sons. Using the underlying tree \nstructure of formulas, we can de.ne the height, h(A), and the degree, d(A), of a formula A. The construction \nof the automaton recognizing a formula A requires to compute the product of at most d(A) automata for \neach composition in A. Therefore, the size of the automaton is bounded by T (d(A) h(A)), where T is \na constant bounding the size of the automaton recognizing T. The decidability (and the complexity) of \nSL follows from Th. 6.1 and Proposition 6.6. The complexity is doubly exponential in the size of A (like \nin Proposition 6.6, we abstract over the complexity of deciding the satis.ability of the Presburger constraints). \nTHEOREM 6.2 (SATISFIABILITY). For any formula A of SL, the satis.ability problem [[A]] = 0/ is decidable \nin time O(T2 (d(A) h(A))). Combined with our previous results on the embedding of TL in SL we also obtain \ndecidability properties for the tree logic, as well as automata-based decision procedures for the model-checking \nand subtyping problems. Indeed, from a formula A of TL we can build an equivalent SL-formula with the \nsame depth (which is bounded by |A|) and with degree at most 3 |A|. The value 3 comes from the size of \nthe basis used in the encoding of location (Section 5.1). We obtain that the satis.ability problem for \nTL is in double exponential time. Once more, we abstract over the complexity of Presburger formulas. \nTHEOREM 6.3 (SATISFIABILITY). For any formula A of TL, the satis.ability problem [[A]] = 0/ is decidable \nin time O(T2 (3 |A|2)).  7 An Ef.cient Tree Logic Constrained rules of sheaves automata, f . q, are \nused to explore the horizontal structure of trees. Sheaves automata can as easily explore vertical structure \nand be used to match paths of (nested el\u00adements) labels. We can simply take advantage of the intrinsic \nre\u00adcursive nature of automata, which may contain cyclic dependencies between states, to compile path \nexpressions. In this section, we extend the syntax of SL with recursive de.ni\u00adtions. For the sake of \nbrevity, we will stay at an informal level compared to the rest of the paper. Actually, our primary goal \nis to prove that path expressions and iteration are indeed two orthogonal forms of recursion and that \nour framework can easily be enriched with path expressions. We also study a simple syntactic restriction \non formulas that improves the effectiveness of our approach. Recursive Sheaves Logic X,Y,... recursive \nvariables E ::= element formula a[X] element with label in a D ::= recursive de.nition X ..N' f(N) 'E \nsheaves composition A ::= RSL formula (D1,...,Dn;X) The syntax of formulas is even leaner than in SL \nand is reminiscent of tree grammar: location is restricted to variables and a formula is simply a set \nof recursive de.nitions with a distinguished (initial) variable. The connection with tree grammar is \neven clearer in the de.nition of the satisfaction relation. A tree d matches a formula (D;X), de\u00adnoted \nD fd : X, if and only if there is a de.nition (X ..n'f 'E) in D such that d .n '[[E]] and |= f(n), that \nis, d |= .N'f 'E in SL. We also adjust the rule for element formulas. An element a[d] matches a[Y ] (in \nthe context D) if and only if a .a and D fd : Y . For exam\u00ad ple, if AnyD is the recursive de.nition X \n..N'(N ? 0) '0/.[X] the formula (AnyD;X)matches every tree in IT (it provides a possible encoding of \nT). Granted the relation with tree grammar, it is not necessary to use tree automata to decide the logic. \nIndeed, there exist ef.cient ways to manipulate grammars that do not (explicitly) require automata\u00adbased \ntechniques. Nonetheless, the compilation from RSL to sheaves automata is straightforward and provides \na good idea of how sheaves automata combine well with recursion. An interesting property of the automaton \nA obtained from a formula A is that ev\u00adery variable of A corresponds to a single state in A, and the \nsizes of A and A are proportional. THEOREM 7.1 (DEFINABILITY). For every formula A, we can build an automaton \nA of size O(|A|) accepting the models of A. PROOF. Assume A = (D;X). For every element formula a[Y ] \nand every variable Z occurring in A we set up the states qa[Y ] and qZ . Let Q be the set of all such \nstates. Then, for every element formula a[Y ] we set up the type (1) rule a[qY ] .qa[Y ] and for every \nde.nition Y ..N'f'E in D, with E =(a1[Y1],...,ap[Yp]), we set up the type (2) rule: f(#qa1[Y1],...,#qap[Yp]) \n.qY . Let R be the set of all such rules. The sheaves automaton with states Q, rules R and .nal state \nthe singleton {qX }accepts the models of A. Using the de.nition of the derived operators given in Section \n5.1, we can prove that RSL corresponds to an extension of TL with re\u00adcursive de.nitions, where the location \noperator is limited to recur\u00adsive variable, a[X]. For example, formula (3), below, is satis.ed by trees \nwith a path (a.b)* and (4) is satis.ed by trees matching A somewhere. X .(a[Y ] |T).0 ,Y .(b[X] |T) ; \nX (3) X .(0/.[X] |T).A ; X (4) This restriction does not excessively limit the expressiveness of the \nlogic. Although the resulting extension of TL is less expressive than the logic enriched with general \nleast and greatest .xpoints, as found in [9], it is possible to encode all the path operators used in \nTQL [7]. Additionally, this simple syntactical restriction precludes the de.ni\u00adtion of degenerate recursive \nformulas, of the form \u00b5X.a[X] |a[a[X]], where variables appear at different depths and match unbalanced \nset of trees (growing as well in breadth and in depth). A limitation of our approach is that trees must \nbe processed bottom\u00adup. This strategy may be inef.cient for large information trees since, in this case, \nwe want to work on-the-.y , without com\u00adpletely loading a tree before processing it. To avoid this problem, \nwe may impose a simple syntactic restriction on RSL in order to work with top-down sheaves automata. \nWe take inspiration from a restriction on (sequential composition in) XML Schema [30, Sec\u00adtion 3.8.6], \nknown as Consistent Element Declarations. We say that a support (a1[X1],...,ap[Xp]) has consistent element \ndeclarations (CED) if every label uniquely determines a recursive variable: for all i, j .1..p,if i = \nj then Xi = Xj and ai na j = 0/.A formula (D;X)has CED if every variable is de.ned (appears at the left-hand \nside) exactly once in D and if the support of every de.ni\u00adtion in D has CED. (A formula with consistent \nelement declarations may contain two elements a[X] and a[Y ], with X =Y , provided they do not appear \nin the same de.nition.) Once more, this restriction may be transferred to TL. It corresponds to de.nitions \nX .A such that, for every pair of subformulas a[X] and a[Y ] occurring in A, we have X = Y . Formula \n(3) is an example of a TL-formula with consistent element declarations. If we restrict to formulas with \nconsistent element declarations, it is possible to construct top-down sheaves automata accepting the \nsame models. Informally, the construction is based on the fact that, given a de.nition X ..N'f ' E to \nmatch, the label of an element fully speci.es the element formula in E that we should try to satisfy. \n 8 Conclusion This paper is concerned with a fragment of ambient logic that may be seen as a kind of \nregular expression language over tree-like data structures. More formally, it is an algebra with two \northogonal com\u00adposition operators: tree composition, | , that is commutative and follows the horizontal \nstructure of a tree and location, a[], that is akin to sequential composition a. (of a letter with a \nword) and fol\u00adlows the vertical structure of a tree. In contrast to the situation found with regular \ntree expressions, there was no equivalent to regular tree automaton for accepting the languages associated \nto TL. Our contribution is a class of tree automata for processing informa\u00adtion trees and a compilation \nmethod that associates to every formula of TL an automaton accepting the same models. Our approach reveals \na connection between TL and arithmetical constraints on vectors of integers, expressed as formulas of \nPres\u00adburger arithmetic. A possible line for future work could be to ex\u00adtend this relation to other examples \nof substructural logics, like for example additive fragments of Linear Logic or versions of the logic \nof Bunched Implications [4, 22]. It is worth mentioning that some complexity results on fragments of \nlinear logic have been proven through reduction to problems on Petri Nets [23] (that is, equiv\u00adalently, \non vector addition systems), which may indicate that this relation has already been partially unveiled. \nOur automata-based approach to the manipulation of formulas in the ambient logic may be useful in the \nimplementation of query languages based on an unordered tree model, like TQL [7] for ex\u00adample. However, \nthe logic as presented in Section 4, still lacks in-depth recursion, e.g. the capacity to encode path \nexpressions, and additional work is needed to formalize the extension with re\u00adcursive de.nitions proposed \nin Section 7. Another line for future work will be to develop a method for obtaining a sheaves automa\u00adton \ndirectly from a TL-formula. Currently, the construction of a sheaves automaton corresponding to a formula \nof TL requires to build .rst an equivalent formula in SL. (In this respect, SL appears as a kind of assembly \nlanguage.) A bene.t of this simpli.cation is that it could lead to a more re.ned study of the complexity \nof TL, perhaps enabling us to isolate simple classes of queries. 9 Acknowledgments We would like to thank \nPhilip Wadler for pointing out the Consis\u00adtent Element Declarations restriction on XML Schema. This work \nis partially supported by ATIP CNRS Fondements de l Interrogation des Donn\u00b4ees Semi-Structur\u00b4ees and \nby IST Global Computing PROFUNDIS. 10 References [1] S. Abiteboul, P. Buneman, and D. Suciu. Data on \nthe Web: From Relations to Semistructured Data and XML. Morgan Kaufmann, 1999. [2] B. Boigelot, S. Jodogne, \nand P. Wolper. On the use of weak automata for deciding linear arithmetic with integer and real variables. \nIn International Joint Conference on Automated Reasoning (IJCAR), volume 2083 of LNCS, pp. 611 625. Springer, \n2001. [3] C. Calcagno, L. Cardelli, and A. D. Gordon. Deciding validity in a spatial logic for trees. \nIn ACM Workshop on Types in Language Design and Implementaion, TLDI 03, pp. 62 73. ACM Press, 2003. [4] \nC. Calcagno, H. Yang, and P. O Hearn. Computability and complexity results for a spatial assertion language \nfor data structures. In Foundations of Software Technology and The\u00adoretical Computer Science (FST &#38; \nTCS), volume 2245 of LNCS. Springer, 2001. [5] L. Cardelli. Describing semistructured data. SIGMOD Record, \n30(4), 2001. Database Principles Column. [6] L. Cardelli and L. Caires. A spatial logic for concurrency \n(part I). In Theoretical Aspects of Computer Software (TACS), volume 2215 of LNCS, pp. 1 37. Springer, \n2001. [7] L. Cardelli and G. Ghelli. A query language based on the ambient logic. In ESOP 01, volume \n2028 of LNCS, pp. 1 22. Springer, 2001. [8] L. Cardelli and A. Gordon. Mobile ambients. In Foundations \nof Software Science and Computation Structures (FoSSaCS), volume 1378 of LNCS, pp. 140 155. Springer, \n1998. [9] L. Cardelli and A. Gordon. Anytime, anywhere: Modal logic for mobile ambients. In Principles \nof Programming Lan\u00adguages (POPL). ACM Press, 2000. [10] L. Cardelli and A. Gordon. Logical properties \nof name restric\u00adtion. In Typed Lambda Calculus and Applications (TLCA), volume 2044 of LNCS. Springer, \n2001. [11] W. Charatonik, S. Dal Zilio, A. Gordon, S. Mukhopadhyay, and J.-M. Talbot. Model checking \nmobile ambients. Theoret\u00adical Computer Science, 308(1):277 332, 2003. [12] W. Charatonik and J.-M. Talbot. \nThe decidability of model checking mobile ambients. In Conference of the European Association for Computer \nScience Logic (CSL), volume 2142 of LNCS, pp. 339 354. Springer, 2001. [13] T. Colcombet. Rewriting in \nthe partial algebra of typed terms modulo AC. In International Workshop on Veri.ca\u00adtion of In.nite-State \nSystems (INFINITY), volume 68 of Elec\u00adtronic Notes in Theoretical Computer Science. Elsevier Sci\u00adence, \n2002. [14] H. Comon, M. Dauchet, R. Gilleron, F. Jacquemard, D. Lugiez, S. Tison, and M. Tommasi. Tree \nautomata techniques and applications. Available on: http://www. grappa.univ-lille3.fr/tata, 1997. release \nOctober, 1st 2002. [15] D. Cooper. Theorem-proving in arithmetic without multipli\u00adcation. Machine Intelligence, \n7, 1972. [16] S. Dal Zilio and D. Lugiez. Multitrees automata, Presburger constraints and tree logics. \nTechnical Report 08-2002, LIF, June 2002. [17] S. Dal Zilio and D. Lugiez. XML schema, tree logic and \nsheaves automata. In Rewriting Techniques and Applications (RTA), volume 2706 of LNCS, pp. 246 263. Springer, \n2003. Appears also as Technical Report 4641, INRIA, Nov. 2002. [18] S. Dal Zilio, D. Lugiez, and C. Meyssonnier. \nA logic you can count on. Technical report, INRIA, 2003. (to appear). [19] M. Fischer and M.O.Rabin. \nSuper-exponential complexity of presburger arithmetic. In SIAM-AMS Symposium in Applied Mathematics, \nvolume 7, pp. 27 41, 1974. [20] M. J. Gabbay and A. M. Pitts. A new approach to abstract syntax involving \nbinders. In Symposium on Logic in Com\u00adputer Science (LICS), pp. 214 224. IEEE, 1999. [21] H. Hosoya and \nB. C. Pierce. Regular expression pattern matching for XML. In Principles of Programming Languages (POPL), \npp. 67 80. ACM Press, 2001. [22] S. Ishtiaq and P. W. O Hearn. BI as an assertion language for mutable \ndata structures. In Principles of Programming Languages (POPL), pp. 14 26. ACM Press, 2001. [23] M. Kanovich. \nHorn programming in linear logic is NP\u00adcomplete. In Symposium on Logic in Computer Science (LICS), pp. \n200 210. IEEE, 1992. [24] D. Lugiez. Counting and equality constraints for multitree au\u00adtomata. In Foundations \nof Software Science and Computation Structures (FoSSaCS), volume 2620 of LNCS, pp. 328 342. Springer, \n2003. [25] M. Makoto. Extended path expression for XML. In Principles of Database Systems (PODS). ACM \nPress, 2001. [26] D. C. Oppen. A 222pn upper bound on the complexity of pres\u00adburger arithmetic. Journal \nof Computer and System Sciences, 16:323 332, 1978. [27] Profundis: Proofs of functionality for mobile \ndistributed sys\u00adtems. http://www.it.uu.se/profundis/. [28] W. Pugh. The omega test: a fast and practical \ninteger program\u00adming algorithm for dependence analysis. Communications of the ACM, 35(8):102 114, 1992. \n[29] RELAX-NG. http://www.relaxng.org. [30] W3C Recommendation. XML Schema Part 1: Structures, 2001. \n A Support Re.nements and Bases In this section, we prove that it is always possible to work with formulas \nde.ned over a common basis. To this end, we introduce the notion of re.nement of a support vector and \nhint at a method for building a common basis from different supports. We say that the support E re.nes \nF if from any decomposition (of a tree) over F it is possible to extract a more precise decomposi\u00adtion \nover E. We have seen an example of re.nement in the en\u00adcoding of location, a[A]. Indeed, we want to say \nthat the basis (a[A],a[A.],a.[T]) is more precise than the support (a[A]). DEFINITION A.1 (REFINEMENT). \nA re.nement from a support (E1,...,Ep) into a support (F1,...,Fq) is a relation R of 1..p\u00d71..q such \nthat [[Ei]]= (i,j).R [[Fj]] for all i . 1..p. We use the notation F jR E when there exists a re.nement \nR from E into F and simply say that F re.nes E when the relation R is obvious from the context. We prove \nthat if F re.nes E then any SL\u00adformula with support E can be rewritten into an equivalent formula with \nsupport F. PROPOSITION A.1. Assume E =(E1,...,Ep) and F =(F1,..., Fq) are two support vectors such that \nF jR E, then for every count\u00ading constraint f(N), with |N| = p, we have: [[.N'f(N) 'E]] = [[.M'.R (M) \n' F]] . where M =(M1,...,Mq)and .R (M) is the constraint: (Xi) ((Mj )) j.1..q= .(i,j).R Xij.. j(i,j).R \n. . f.(1,j).R X1 j ,...,.( p,j).R Xjp PROOF. We prove [[.N'f ' E]] . [[.M'.R ' F]]. The proof for the \nother direction is similar. Assume d . [[.N' f ' E]]. Then d is the composition of n1 elements satisfying \nE1 (say e11 ,...,e1 ), ..., and n1 pp np elements satisfying Ep (say e1 ,...,e) with |= f(n). np By \nde.nition of F jR E, we have [[Ei]] = iR j[[Fj]]. Therefore i every element ej in this decomposition \nshould also fall into one of the components of F, that is, there exists an index ri,j in 1..q such i \nthat i R ri,j and ej . [[Fri,j ]] for all i . 1..p, j . 1..ni. This gives a new decomposition of d into \nthe support F such that the cardinality of {ri,j = ki . 1..p, j . 1..ni}, say mk, is the number of elements \nmatching Fk. The relation d . [[.M'.R 'F]] follows by proving that .R (m1,...,mq) holds. i Let xk be \nthe cardinality of the set {ri,j = kj . 1..ni}, that is, the i number of elements ej, for j . 1..ni, \nassigned to Fk. Therefore i 1 ni = .iR k,k.1..q xk for all i . 1..p, which implies |= f(.1R jxj ,..., \np i .pR jxj ), and mk = .iR k,i.1..p xk for all k . 1..q, as required. Given two support vectors E and \nF, a corollary of Proposition A.1 is that from every formula .N' f ' E we can build an equivalent formula \nof the form .(N;M)'. ' (E;F), where .(N;M) is the con\u00adstraint f(N) .(M = 0). This property follows from \nthe fact that the support (E;F) clearly re.nes E. Hence, we may always work with formulas using a common \nsupport (from formulas with sup\u00adport E1,...,En, use the support E1;...;En). This property is useful when \nwe need to build the disjunction or parallel composition of arbitrary formulas. We need a stronger property \nfor the negative operators: negation and composition adjunct. PROPOSITION A.2. Assume E and F are two \nproper bases then we can build a new basis, say E \u00d7 F, that re.nes both E and F. PROOF. By induction \non the depth of E. Assume E =(E1,...,Ep) and F =(F1,...,Fq), where Ei = ai[Ai] and Fj = \u00df j[Bj] for all \ni . 1..p, j . 1..q. We choose for E \u00d7 F the support vector with element formulas Gi,j =(ai n \u00df j)[Ai \n.Bj], for all i . 1..p, j . 1..q, where Ai .Bj is de.ned as follows. If Ai = T then Ai .Bj = Bj.If Bj \n= T then Ai .Bj = Ai. Otherwise, the formulas Ai and Bj are compositions de.ned over proper bases of \nlesser depths. Let Ci (resp. D j) be the basis used in the de.nition of Ai (resp. B j). By induction \nhypothesis there is a proper basis Ci \u00d7 Dj re.ning Ci and Dj. Hence, by Proposition A.1, we may rewrite \nAi and Bj into equivalent formulas de.ned over the basis Ci \u00d7 D j and we can build a formula equivalent \nto Ai .Bj using the derived operator de.ned in Section 5.1. The proposition follows by proving that G \nis a proper basis re.ning E and F. We have [[Gi,j]]= [[Ei]] n[[Fj]]. Therefore [[Gi,j]] n[[Gk,l]] = ([[Ei]] \nn[[Ek]]) n([[Fj]] n[[Fl]]) and we have [[Gi,j]] n[[Gk,l]] = 0/ if and only if i = k and j = l. Hence, \nthe formulas in G are linearly in\u00ad dependent. Moreover, i,j[[Gi,j]] = i[[Ei]] = E, that is, G is gen\u00aderating. \nFinally, the relations R and R ' such that i R (i, j) and j R ' (i, j) for all i . 1..p, j . 1..q are \nre.nements from E and F to G, as needed. The support obtained by this operation may be further simpli.ed \nby eliminating useless components, namely formulas of the form 0/[A] obtained from the conjunction of \nelements with disjoint label expressions. We show that it is always possible to assume that a set of \nformulas is de.ned over a common proper basis. Consequently, we may extend the encodings given in Section \n5.1 to arbitrary formulas of SL. PROPOSITION A.3 (SUPPORT REFINEMENT). Given a sequence of formulas (A1,...,An), \nwhere Ai is de.ned over a proper basis for all i . 1..n, we can build a sequence of formu\u00adlas (B1,...,Bn), \nde.ned on a common proper basis, such that [[Ai]] = [[Bi]] for all i . 1..n. PROOF. By Propositions A.1 \nand A.2 using the product vector (E1 \u00d7 ...) \u00d7 En, where (Ei)i.1..n are the proper basis used in the de.nition \nof the formulas (Ai)i.1..n. We can use a similar technique to prove that, from any support E, we may \nalways obtain a proper basis re.ning E. The idea is to study element formulas BI equivalent to i.I Ei \n. i./I \u00acEi, where I is a subset of 1..p. The proof of this result is slightly more involved than the \nproof of Proposition A.2 since, in the general case, \u00ac(a[A]) is not equivalent to an element formula, \nbut rather to the disjunction of a.[T] and a[\u00acA]. This stronger property is not needed in the proof of \nour main result. Moreover, whereas the product of two bases may generate a vector of size at most quadratic, \nthe more sophisticated construction may generate an exponential number of element formulas.  \n\t\t\t", "proc_id": "964001", "abstract": "We prove the decidability of the quantifier-free, static fragment of ambient logic, with composition adjunct and iteration, which corresponds to a kind of regular expression language for semistructured data. The essence of this result is a surprising connection between formulas of the ambient logic and counting constraints on (nested) vectors of integers.Our proof method is based on a new class of tree automata for unranked, unordered trees, which may result in practical algorithms for deciding the satisfiability of a formula. A benefit of our approach is to naturally lead to an extension of the logic with recursive definitions, which is also decidable. Finally, we identify a simple syntactic restriction on formulas that improves the effectiveness of our algorithms on large examples.", "authors": [{"name": "Silvano Dal Zilio", "author_profile_id": "81100612173", "affiliation": "CNRS and Universit&#233; de Provence", "person_id": "P653515", "email_address": "", "orcid_id": ""}, {"name": "Denis Lugiez", "author_profile_id": "81100638969", "affiliation": "CNRS and Universit&#233; de Provence", "person_id": "PP17016879", "email_address": "", "orcid_id": ""}, {"name": "Charles Meyssonnier", "author_profile_id": "81100251377", "affiliation": "CNRS and Universit&#233; de Provence", "person_id": "P438622", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/964001.964013", "year": "2004", "article_id": "964013", "conference": "POPL", "title": "A logic you can count on", "url": "http://dl.acm.org/citation.cfm?id=964013"}