{"article_publication_date": "01-01-2004", "fulltext": "\n Free Theorems in the Presence of seq Patricia Johann Department of Computer Science Rutgers University \nCamden, NJ 08102 USA pjohann@camden.rutgers.edu Janis Voigtl\u00a8ander Department of Computer Science Dresden \nUniversity of Technology 01062 Dresden, Germany voigt@tcs.inf.tu-dresden.de Abstract Parametric polymorphism \nconstrains the behavior of pure func\u00adtional programs in a way that allows the derivation of interesting \ntheorems about them solely from their types, i.e., virtually for free. Unfortunately, the standard parametricity \ntheorem fails for nonstrict languages supporting a polymorphic strict evaluation primitive like Haskell \ns seq. Contrary to the folklore surrounding seq and para\u00admetricity, we show that not even quantifying \nonly over strict and bottom-re.ecting relations in the .-clause of the underlying logical relation and \nthus restricting the choice of functions with which such relations are instantiated to obtain free theorems \nto strict and total ones is suf.cient to recover from this failure. By addressing the subtle issues \nthat arise when propagating up the type hierarchy restrictions imposed on a logical relation in order \nto accommodate the strictness primitive, we provide a parametricity theorem for the subset of Haskell \ncorresponding to a Girard-Reynolds-style calcu\u00adlus with .xpoints, algebraic datatypes, and seq. A crucial \ningre\u00addient of our approach is the use of an asymmetric logical relation, which leads to inequational \nversions of free theorems enriched by preconditions guaranteeing their validity in the described set\u00adting. \nBesides the potential to obtain corresponding preconditions for standard equational free theorems by \ncombining some new in\u00adequational ones, the latter also have value in their own right, as is exempli.ed \nwith a careful analysis of seq s impact on familiar pro\u00adgram transformations. Categories and Subject \nDescriptors: D.1.1 [Programming Tech\u00adniques]: Applicative (Functional) Programming; D.3.3 [Pro\u00adgramming \nLanguages]: Language Constructs and Features polymorphism; F.3.1 [Logics and Meanings of Programs]: Specify\u00ading \nand Verifying and Reasoning about Programs; F.3.3 [Logics and Meanings of Programs]: Studies of Program \nConstructs control primitives, type structure General Terms: Languages, Theory Keywords: Controlling \nstrict evaluation, correctness proofs, de\u00adnotational semantics, Haskell, logical relations, parametricity, \npro\u00adgram transformations, short cut fusion, theorems for free .Research supported by the Deutsche Forschungsgemeinschaft \nunder grant KU 1290/2-4. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. POPL 04, January 14 16, 2004, Venice, Italy. Copyright 2004 ACM 1-58113-729-X/04/0001 ...$5.00 \n1 Introduction Ever since they were .rst popularized by Wadler [23], free theorems have been used to \nderive program equivalences involving paramet\u00adric polymorphic functions in programming languages based \non the Girard-Reynolds lambda calculus [7, 16]. A free theorem is consid\u00ad ered free because it can be \nderived solely from the type of a func\u00adtion, with no knowledge at all of the function s actual de.nition. \nIn essence, it records a constraint arising from the fact that a para\u00admetric polymorphic function must \nbehave uniformly, i.e., must use the same algorithm to compute its result, regardless of the concrete \ntype at which it is instantiated. Free theorems hold unconditionally for polymorphic functions in the \nGirard-Reynolds calculus. But for calculi that more closely re\u00adsemble modern functional languages the \nstory is not so simple. It is well known [11, 23] that adding a .xpoint primitive to a calculus weakens \nits free theorems by imposing admissibility conditions on (some of the) functions appearing in them. \nHow free theorems fare in the presence of other primitives is less well understood. We will use the following \nexample to illustrate that new primitives can break free theorems in dramatic and unexpected ways. A \nfree theorem given in Figure 1 of [23] states that for any function .lter :: .a. (a . Bool) . [a] . [a] \nand appropriately typed p, h, and l the following law holds: .lter p (map h l)= map h (.lter ( p . h) \nl) (1) Here map h applies the function h to every element of a list, and . is function composition. (See \nFigure 1.) While Haskell is a nonstrict language so that a function argu\u00adment is evaluated only when \nrequired it is sometimes desirable to explicitly force evaluation. This can be done using the polymor\u00adphic \nstrict evaluation primitive seq, which satis.es the following speci.cation:1 seq :: .a\u00df. a . \u00df . \u00df seq \n. b = . seqa b = b , if a * Here . is the unde.ned value corresponding to a nonterminating computation \nor a runtime error (such as might be obtained as the result of a failed pattern match). The operational \nbehavior of seq is to evaluate its .rst argument to weak head normal form before returning its second \nargument. It is usually introduced to improve 1Other means of explicitly introducing strictness in Haskell \npro\u00adgrams e.g., strict datatypes are all de.ned in terms of seq. data Bool = False | True data Maybe \na = Nothing | Just a map :: .a\u00df. (a . \u00df) . [a] . [\u00df] map h = f where f [] =[] f (x : xs)= hx : f xs (.) \n:: .a\u00df.. (\u00df . .) . (a . \u00df) . a . . f1 . f2 =(.x . f1 ( f2 x)) .x :: .a. (a . a) . a .x g = g (.x g) id \n:: .a. a . a id x = x (++) :: .a. [a] . [a] . [a] [] + ys = ys (x : xs)+ ys = x : (xs + ys) Figure 1. \nSome Haskell de.nitions. performance by avoiding unnecessary evaluation delay or by se\u00adquentializing \nalgorithms in parallel implementations [21]. The Haskell 98 report [12] the language de.nition warns \nthat the provision of polymorphic seq has important semantic conse\u00adquences. In fact, if we implement \na function with .lter s type using seq and a .xpoint operator .x (de.ned as in Figure 1) by .lter p = \np seq (.x g) where g f ys = case ys of [] . [] x : xs . x seq case px of True . (xs seq x) : f xs False \n. f xs then the following four instantiations break law (1), each for a dif\u00adferent reason to be discussed \nbelow: p = . h = id l =[] (./) p =(.x . True) h = . l =[0](./) p = id h =(.x . True) l =[.](./) p = id \nh =(.x . True) l = True : . (./) In each of these cases, one of the two sides of the law is less de.ned \nthan the other one, so that the equivalence (1) is incorrect. The direction in which it turns into an \ninequation with respect to the semantic approximation order is remarked at the end of each line. Launchbury \nand Paterson [11] introduced a type system that makes explicit which types contain . the so-called pointed \ntypes and therefore support the de.nition of values by recursion. This type system allows .ne control \nover where the aforementioned ad\u00admissibility conditions are required in free theorems and where they \nare not. In the above de.nition of .lter, for example, we have used explicit .xpoint recursion expressed \nvia the operator .x rather than giving a directly recursive de.nition. This makes it clear that the recursion \nhere takes place at type [a] . [a], which is pointed with\u00adout any condition on a since [a] is. The de.nition \nalso makes ap\u00adparent that the case-expressions which produce . on selectors that are themselves unde.ned \n have the return type [a], which is again pointed without any condition on a. Thus, Launchbury and Paterson \ns approach to parametricity in the presence of pointed vs. unpointed types can be used to show that law \n(1) holds without any conditions on p, h, or l, provided all invocations of seq are dropped2 2By contrast, \nif, e.g., recursion were performed at a type whose (in which case we get precisely the .lter function \nfrom Haskell s standard prelude). This shows that it is not the use of recursion or pattern matching \nin our de.nition of .lter that is responsible for the breakdown of law (1). The evil really does reside \nin seq. More precisely, different ways of using seq are responsible for the failure of law (1) for the \nfour instantiations given above. In the .rst case, the use of seq to observe termination at function \ntype makes the left-hand side . since p = ., while there is no such impact on the right-hand side because \np . h = .. id =(.x ..) * = .. In the second case, the use of seq to observe termination at the type over \nwhich .lter is polymorphic .nds h 0 = . 0 = . in the left-hand side (since the inner map applies h to \nevery list element before\u00adhand), while in the right-hand side the corresponding application is on the \nlist element 0 *. itself (to which h is applied only after\u00ad = wards by the outer map, returning an unde.ned \nlist element but not a completely unde.ned result list). So here the problem lies with h returning . \nfor a non-. argument, which makes an essential dif\u00adference for seq. Conversely, an h returning a non-. \nvalue for the argument . lets the law (1) fail the other way round for the third in\u00adstantiation. Finally, \nin the fourth instantiation, the use of seq on an unde.ned list tail as .rst argument introduces a . \nof the type over which .lter is polymorphic. So, even though as discussed above the given de.nition \nof .lter does not use recursion or pattern matching in a way that would require a to be pointed, the \nassoci\u00adated strictness condition on h creeps in through the back door here, carelessly opened by seq. \nThe failure of free theorems in the presence of seq has been noted before (see, e.g., Section 6.2 of \n[12], Section 5.3 of [13], Ap\u00adpendix B of [22], and discussions on the Haskell mailing list [1]). But \nthe extent to which Haskell s parametricity properties are actu\u00adally weakened has not been studied thoroughly. \nConventional wis\u00addom (expressed, e.g., in [13]) has it that a free theorem remains valid in the presence \nof seq if all of the functions which are chosen to instantiate relations in the statements derived from \ntypes (where one is free to make such a choice) are strict and total. For our exam\u00adple this means that \nlaw (1) should hold for every strict and total h a claim which is shown to be incorrect by our .rst \ncounterexample above. The need for valid criteria for determining when free theo\u00adrems hold in the presence \nof seq is quite dire: seq will not go away by ignoring it, and neither will the demand for rigorous semantic \narguments about Haskell programs that rely on parametricity. The major contribution of this paper is \nto provide precisely such criteria. Note that our aim here is not to provide a parametric model for full \nHaskell. This would be out of reach because there is not even a formal semantics for Haskell against \nwhich to validate a model. Rather, our aim is to investigate, under the reasonable and widely held assumption \nthat Haskell without seq is parametric, exactly how much of the power of free theorems can be retained \nwhen seq is thrown in. The assumption is justi.ed in part by the recent con\u00adstruction of a parametric \nmodel for a nonstrict polymorphic lambda calculus supporting .xpoints and lazy algebraic datatypes [14]. \nThe fundamental idea underlying the parametricity properties from which free theorems are derived is \nto interpret types as relations (as opposed to sets). It is standard to interpret the base types in a \nlanguage as identity relations and to obtain the interpretations for non-base types by propagating relations \nup the type hierarchy in a straightforward extensional manner. This builds a (type-indexed) logical relation \n[5, 15, 19], for which a parametricity theorem can support for it relied on pointedness of a, then even \nin the absence of seq we could conclude .lter s free theorem only for strict h. be proved. (See Section \n4 for details.) A parametricity theorem asserts that every closed term satis.es the parametricity property \nderived from its type, i.e., is related to itself by the interpretation of its type. Proofs of such theorems \nproceed by induction on the syntactic structure of terms, driven by type assignment rules, where the \nconstants occurring in a language form base cases. Since, in the relational interpretation of a polymorphic \ntype, bound type variables can be interpreted by arbitrary relations (or by arbi\u00adtrary strict and continuous \nrelations if the language supports pattern matching and .xpoints), the parametricity property for each \nterm of polymorphic type is quite general. This allows a richness of free theorems to be derived by instantiation. \nBut this generality is also the potential downfall of free theorems when seq is added to the language \nas a constant. The proof of the associated base case fails because, in the setting of the standard relational \ninterpretations, seq does not satisfy the parametricity property derived from its type: the encountered \nrelations are too unconstrained since they allow . and non-. values to be related arbitrarily. (See Section \n5 for why exactly this is problematic.) This observation motivates us to adapt the standard construction \nof a logical relation. As expected, bound type variables are only allowed to be interpreted by relations \nthat validate the property de\u00adrived from the polymorphic type which seq claims for itself. But the relational \ninterpretation of function types must also be modi\u00ad.ed. Indeed, it must conform to a notion of extensionality \nwhich acknowledges that, in the presence of seq, two functions can no longer be considered semantically \nequivalent simply because they map the same arguments to the same results. The need to alter the construction \nof the logical relation at function types is perhaps sur\u00adprising, given that the conventional wisdom \nhas not anticipated it. Of the different options for restricting relations to ensure the adher\u00adence of \nseq to its parametricity property, we choose one that intro\u00adduces a certain asymmetry into the logical \nrelation. Since equations proved as free theorems in the absence of seq are frequently dis\u00adproved in \nits presence by instantiations that make one of their two sides less de.ned than (but not completely \nunrelated to) the other, we de.ne our new logical relation in such a way that one of the two argument \npositions of a relational interpretation is favored with respect to de.nedness. This leads us to interpret \nbase types as semantic approximation relations rather than as identity relations. Further, we modify \nthe relational interpretations of non-base types by adopting a propagation technique which is more complex \nthan the standard one, but which preserves the chosen set of restrictions. We sketch the proof of the \nfundamental property of the new logi\u00adcal relation, establishing that it does indeed relate every closed \nterm (potentially built using seq) to itself. We use the fundamental prop\u00aderty to prove free theorems \nin which the modi.cations to the logical relation mandated by seq generate preconditions that must be \nsatis\u00ad.ed by the values over which the theorems are parametrized. This approach allows us, for example, \nto provide criteria on p and h un\u00adder which the law (1) holds for every l, even in the presence of seq. \nMoreover, assuming a weaker precondition on h and placing no restrictions whatsoever on p or l it yields \nan inequational ver\u00adsion of law (1) in which the right-hand side is at least as de.ned as the left-hand \nside. Such inequations are provable for other func\u00adtions as well, and are often suf.cient when applying \nfree theorems to transform or reason about programs. The remainder of this paper is organized as follows. \nSection 2 brie.y considers the functional language we use. Section 3 intro\u00ad duces auxiliary notions and \nde.nitions. Section 4 recalls how free theorems are obtained in the absence of seq. Sections 5 and 6 \nmo\u00ad tivate and develop our approach to parametricity in the presence of seq. Section 7 applies it to \nderive two free theorems about functions with .lter s type. Section 8 investigates how some program trans\u00ad \nformations based on free theorems [6, 20, 22] fare in the presence of seq. Section 9 concludes by proposing \nfuture research directions. 2 Functional Language We use a subset of the pure nonstrict functional programming \nlan\u00adguage Haskell [12] that corresponds to a Girard-Reynolds-style cal\u00ad culus with .xpoints, algebraic \ndatatypes, and seq. De.nitions of Haskell types and functions that are used throughout the paper are \ngiven in Figure 1. As shown there, parametric polymorphism3 is made explicit with a .-type constructor \nquantifying over types. Type instantiation, on the other hand, is most often left implicit. When instantiation \nof a polymorphic term t to a closed type (one without free variables) t is made explicit, it is denoted \nby tt. Unfortunately, there is not yet a formal semantics for Haskell, inde\u00adpendent of any concrete implementation. \nNevertheless, it is com\u00admon practice to use a denotational style [18] for reasoning about Haskell programs, \nand we do so as well. In particular, we use the semantic approximation . interpreted as less than or \nequally as de.ned as between values of the same type, and the value . interpreted as unde.ned at every \ntype. Types are taken to be pointed complete partial orders, i.e., sets equipped with the partial order \n., the least element ., and limits of all chains. Programs are taken to be monotonic and continuous functions \nbetween pointed complete partial orders. The notions of monotonicity and continu\u00adity are given in the \nnext section, together with other preliminaries. 3 Preliminaries For closed types t1 and t2 the set \nof all binary relations between their value sets is denoted by Rel(t1, t2). Functions are special cases \nof relations, i.e., a function h :: t1 . t2 is interpreted as its graph {(x, y) | hx = y}E Rel(t1, t2). \nFor every closed type t the relations .t, ./t E Rel(t, t) and the value .t :: t are the semantic approximation \n(partial) order, the strict or\u00adder induced by it, and the least element, respectively, for the inter\u00adpretation \nof t. The subscripts will often be omitted. Nevertheless, the value . :: t at a particular closed type \nshould not be confused with the polymorphic value . :: .a. a. Let t1 be a type with at most one free \nvariable, say a. For every closed type t, t1[t/a] denotes the result of substituting t for all free occurrences \nof a in t1. For every value u :: .a. t1 we have: (.t. ut = .t1[t/a]) . u = . a. t1 (2) A relation is \nstrict if it contains the pair (., .). A relation is total if, for every pair (x, y) contained in it, \nx ** = . implies y = .. A relation is bottom-re.ecting if, for every pair (x, y) contained in it, x *. \n= iff y *.. = A relation is continuous if the limits of two chains of pairwise related elements are again \nrelated. A relation is admissible if it is strict and continuous. A function h is monotonic if x . y \nimplies hx . hy. 3 The ad-hoc polymorphism also provided by Haskell in the form of type classes [24] \nis not considered here. How to handle type classes when deriving free theorems is discussed brie.y in \n[23]. The composition of two relations R E Rel(t1, t2) and S E Rel(t2, t3) is de.ned as: R ;S = {(x, \nz) |.y. (x, y) E R . (y, z) E S}E Rel(t1, t3). A relation R is left-closed if .;R = R . The inverse of \na relation R E Rel(t1, t2) is de.ned as: R -1 = {(y, x) | (x, y) E R }E Rel(t2, t1). We denote .-1 and \n./-1 by . and ./, respectively. The lifting of a relation R E Rel(t1, t2) to Maybe types, liftMaybe(R \n) E Rel(Maybe t1, Maybe t2), is de.ned as: {(., .), (Nothing, Nothing)}.{(Just x, Just y) | (x, y) E \nR }. If R is continuous, then so is liftMaybe(R ). If R is left-closed in addition, then .;liftMaybe(R \n) is also continuous. The lifting of relations R E Rel(t1, t2) and S E Rel(t. 1, t. 2) to pairs, lift(,)(R \n, S) E Rel((t1, t. 1), (t2, t. 2)), is de.ned as: . {(., .)}.{((x, x. ), (y, y.)) | (x, y) E R . (x, \ny.) E S}. If R and S are continuous, then so is lift(,)(R , S). If R and S are left-closed in addition, \nthen .;lift(,)(R , S) is also continuous. The lifting of a relation R E Rel(t1, t2) to lists, lift[](R \n) E Rel([t1], [t2]), is de.ned as the largest S E Rel([t1], [t2]) such that: S = {(., .), ([], [])}.{(x \n: xs, y : ys) | (x, y) E R . (xs, ys) E S}. Thus, two lists are related by lift[] (R ) if (i) either \nboth are .nite or partial lists of same length, or both are in.nite lists, and (ii) el\u00adements at corresponding \npositions are related by R . If R is con\u00adtinuous, then so is lift[] (R ). If R is left-closed in addition, \nthen .;lift[](R ) is also continuous. Note that in the special case that R is the graph of a Haskell \nfunction h, the relation lift[](R ) coincides with the graph of the function map h as de.ned in Figure \n1. Since . is re.exive, it is not hard to see from the above de.nitions that for all appropriately typed \nfunctions h and lists l: (map h l, l) E.;lift[](.;h-1) (3) (l, map h l) E.;lift[](h;.) (4) Moreover, \nfor all functions h and all appropriately typed lists l1 and l2 we can conclude from transitivity of \n. and the obvious inclusion of lift[](.;h-1) in .;(map h)-1 that: (l1, l2) E.;lift[] (.;h-1) . l1 . map \nh l2 (5) If h is monotonic, then from monotonicity of map h and the inclusion of lift[](h;.) in (map \nh) ;. we similarly obtain: (l2, l1) E.;lift[](h;.) . map h l2 . l1 (6) 4 Free Theorems in the Absence \nof seq As discussed in the introduction, the key to deriving free theorems from types is to interpret \ntypes as relations. Each type variable is thus interpreted as a relation, and associated with every type \ncon\u00adstructor of the calculus is a map which produces a new relational interpretation from an appropriate \nnumber of given ones. Such a map is called a relational action. We .rst recall the standard re\u00adlational \nactions for the type constructors of the Girard-Reynolds polymorphic lambda calculus. The relational \naction corresponding to the function type construc\u00adtor maps two relations R E Rel(t1, t2) and S E Rel(t. \n1, t. 2) to the following relation in Rel(t1 . t. 1, t2 . t. 2): R . S = {( f , g) |.(x, y) E R . ( fx, \ngy) E S}. In other words, two functions are related if they map related argu\u00adments to related results. \nLet t1 and t2 be types with at most one free variable, say a, and let F be a function that, for all closed \ntypes t. 1 and t. 2 and every relation R E Rel(t. 1, t2. ), gives a relation F (R ) E Rel(t1[t. 1/a], \nt2[t2. /a]). The relational action corresponding to the .-type constructor maps F to the following relation \nin Rel(.a. t1, .a. t2): .R E Rel. F (R ) = {(u, v) |.t. 1, t. 2, R E Rel(t1. , t. 2). (ut\", vt\") E F \n(R )}. 12 According to this de.nition, two polymorphic values are related if all their instances respect \nthe operation of F on relations between the types at which instantiation occurs. The relational actions \nintroduced above can be used to de.ne a log\u00adical relation by induction on the structure of types. Since \nwe will need to keep track of the interpretations of quanti.ed types, we use relation environments to \nmap type variables to relations between closed types. The empty relation environment is denoted by 0/ \nand the update, or extension, of a relation environment . by mapping a to R is denoted by .[R /a]. Let \nt be a type and . be a relation environment such that .(a) E Rel(t1a, t2a) for each free variable a of \nt. We write t'and t- -\u00ad .. for the closed types obtained by replacing every free occurrence of each variable \na in t with t1a and t2a, respectively. A relation .t,. E Rel(t'-\u00ad . , t-. ) is de.ned as in Figure 2. \n.a,. = .(a) .t-t\",. = .t,. . .t\",. .a. t,. = .R E Rel. .t,.[R /a] Figure 2. De.nition of the standard \nlogical relation. If t is a closed type, we obtain a relation .t,0/ E Rel(t, t). The abstraction or parametricity \ntheorem for . [17, 23], from which the standard free theorems are derived, then states that for every \nclosed term t :: t we have (t, t) E .t,0/ . This is also called the fundamental property of the logical \nrelation. As outlined so far, the standard logical relation is only de.ned, and its associated parametricity \ntheorem only holds, for the pure poly\u00admorphic lambda calculus. To more closely approximate modern functional \nlanguages, we must also take general recursive de.ni\u00adtions and suitable datatypes into account. Of course, \nthese features should be added without breaking the fundamental property. It is well known that the provision \nof general .xpoint recursion as is captured by the function .x from Figure 1 requires all rela\u00ad tions \nused in the de.nition of the logical relation to be admissible. In particular, in the inductive case \nfor the .-type constructor the quanti.cation of R must be over admissible relations only. The es\u00adsential \nobservations are then that admissibility is preserved by the given relational actions, and that it ensures \nthe adherence of .x to the parametricity property derived from its type. When adding base types such \nas Int or algebraic datatypes such as Bool, Maybe, pairs, and standard Haskell lists, we must de.ne for \neach new type constructor a corresponding relational action. The usual approach is to interpret nonparametrized \ndatatypes as identity relations and parametrized datatypes by structural liftings of rela\u00adtions. Illustrating \nexamples are given in Figure 3. Further, we must verify that each new constant used to construct or handle \nvalues of the new types satis.es the parametricity property derived from its type. For example, we must \ncheck that (i, i) E .Int,0/ for ev\u00adery integer literal i, (+, +) E .Int-Int-Int,0/ , ([], []) E .a. [a],0/ \n, and (Just, Just) E .a. a-Maybe a,0/ hold. This is indeed the case, and similarly for other constants. \n.Int,. = idInt .Bool,. = idBool .Maybe t,. = liftMaybe(.t,.) .(t,t\"),. = lift(,)(.t,., .t\" ,.) .[t],. \n= lift[] (.t,.) Figure 3. Standard relational interpretations for datatypes. For each algebraic datatype \nwe must also include a means of de\u00adstructing its values via pattern matching. One way to do this is to \nintroduce, as a new term-forming operation, a case-construct that can be used at every algebraic datatype.4 \nProving that the funda\u00admental property of the logical relation remains intact amounts to simply checking \nthat the relational interpretation of every return type of a case-expression is strict. That strictness \nis all that is re\u00adquired can be argued as follows. By analogy with Reynolds abstraction theorem we must \nshow that two denotations of a case-expression in related environments are related by the interpretation \nof its type whenever it is constructed from subterms whose denotations are similarly related. To this \nend, we .rst note that the relational interpretation of an algebraic data\u00adtype respects its structure. \nThus, if two denotations of the selector of a case-expression are related by the interpretation of the \nselec\u00adtor s (algebraic) datatype, then the structural nature of this interpre\u00adtation ensures that pattern \nmatching against either denotation will select the same branch, if any, of the case-expression. There \nare two cases to consider. If pattern matching against one and hence both selector denotations succeeds, \nthen, by hypothesis, the re\u00adsulting denotations of the case-expression are values that are related by \nthe interpretation of its return type. If, on the other hand, pattern matching fails on one of the selector \ndenotations (either because the value is . or because the pattern match is not exhaustive), then it also \nfails on the other one. What we need to establish then is that the interpretation determined by the logical \nrelation for the return type of the case-expression relates the two resulting .s. It clearly does if \nit is known to be strict. This strictness requirement is also re.ected in the pointedness constraint \non the result type of the prototypical case-constant given in Section 3 of [11]. Like the relational \nactions for the function and .-type constructors, the relational actions for algebraic datatypes as used \nin Figure 3 preserve admissibility. In particular, all relational actions preserve 4Other uses of pattern \nmatching in Haskell programs e.g., on left-hand sides of function equations can all be translated into \ncase-expressions. strictness, as is required for case-expressions to satisfy their para\u00admetricity properties. \nThe restricted quanti.cation over admissible relations in the .-case thus ensures that the resulting \nfree theorems are valid for programs potentially using both general recursion and the richer type structure. \nIn the next section we turn to the question of what happens when seq is also added to the language. \n5 Free Theorems Fail in the Presence of seq When adding the constant seq to the language, we must ensure \nthat it satis.es the parametricity property derived from its type: (seq, seq) E . a\u00df. a-\u00df-\u00df,0/ . (seq, \nseq) E (.R ERel. .\u00df. a-\u00df-\u00df,[R /a]) . (seq, seq) E (.R ERel. .S ERel. .a-\u00df-\u00df,[R /a,S/\u00df]) . (seq, seq) \nE (.R ERel. .S ERel. R . (S . S))  ..R ERel(t1, t2). (seqt1 , seqt2 ) E (.S ERel. R . (S . S)) ..R \nERel(t1, t2), S ERel(t. 1, t2. ). (seqt1 t\" , seqt2 t\" ) E R . (S . S)  12 ..R ERel(t1, t2), S ERel(t. \n1, t. 2), (a1, a2) ER . (seqt1 t\" a1, seqt2 t\" a2) E S . S 12 ..R ERel(t1, t2), S ERel(t. 1, t. 2), (a1, \na2) ER , (b1, b2) ES. (seqt1 t\" a1 b1, seqt2 t\" a2 b2) E S. 12 But even if we restrict ourselves to admissible \nrelations, the result\u00ading statement is not true. As a counterexample, consider the fol\u00adlowing instantiation: \nR = .Bool-Bool E Rel(Bool, Bool) S = idBool E Rel(Bool, Bool) (a1, a2)=(False, .Bool) E R (b1, b2)=(False, \nFalse) E S. Although R and S are admissible, the claimed membership (seq False False, seq .Bool False) \nE S does not hold. Since seq violates the parametricity property dictated by its type, other terms that \nare built using seq might do so as well. The prob\u00adlem lies with relations, such as R above, that relate \n. to non-. values. It has therefore been proposed (e.g., in [11]) that quan\u00ad ti.ed relations should be \nfurther restricted by requiring bottom\u00adre.ectingness. But the .rst counterexample in the introduction \nshows that, contrary to conventional wisdom, this is not quite enough to recover valid free theorems \nin the presence of seq. (The requirement that relations be admissible and bottom-re.ecting be\u00adcomes a \nstrictness and totality requirement on Haskell functions which instantiate those relations.) The catch \nis that we must not only impose appropriate restrictions on the quanti.ed relations, but must also ensure \nthat these restrictions are preserved by all rela\u00adtional actions. This is crucial because during the \nproof of the para\u00admetricity theorem, in the inductive case for type instantiation, a uni\u00adversally quanti.ed \nrelation that is subject to the imposed restrictions is instantiated with the relational interpretation \nof an arbitrary type to establish the induction conclusion. If that interpretation is not guaranteed \nto ful.ll the necessary restrictions, then this use of the induction hypothesis is impossible, and the \nentire proof breaks. The proof of the parametricity theorem breaks in precisely this way if one subjects \nquanti.ed relations to bottom-re.ectingness but sticks to the standard relational action for the function \ntype constructor. To see why, consider that for every relation R and every strict re\u00adlation S, the relation \nR . S contains the pair (., (.x ..)) and consequently since (.x ..) is different from . in the presence \nof seq is not bottom-re.ecting as would be required. In the next section we solve this problem by modifying \nthe action of . on relations to take into account the difference between an unde.ned function and a de.ned \nfunction that always returns an unde.ned value. This is done by explicitly adding a condition on the \nde.nedness of related functions similar to that in the lazy logical relation (in the absence of polymorphism \nand algebraic datatypes) of [4]. But rather than requiring bottom-re.ectingness, we impose other restrictions \non relational interpretations. In contrast to only recovering the usual equational free theorems under \nquite severe preconditions, these restrictions additionally allow us to derive in\u00adequational versions \nof these theorems under weaker preconditions. 6 Recovering Free Theorems in the Presence of seq As demonstrated \nin the previous section, the presence of seq causes problems if relational interpretations of types are \nallowed to relate . and non-. values. One way to accomodate seq would thus be to require all encountered \nrelations (those used to interpret bound type variables and those obtained via the relational actions) \nto be bottom-re.ecting in addition to being admissible. This is a dras\u00adtic restriction, however, because \nit entails that the statements that are .nally obtained as free theorems will only capture situations \nin which either both of the sides of a law are unde.ned or neither is. But as we have seen in the introduction, \nthe very nature of seq s impact on free theorems provable in its absence is to potentially make one of \nthe two sides of a law less de.ned (indeed, potentially .), while the other one remains unchanged. To \nderive interesting statements for such situations, we should therefore be more liberal. We introduce \nan asymmetry into relational interpretations by allow\u00ading relations R surfacing in the new logical relation \nto contain pairs (., y) with y ** = ., but forbidding pairs (x, .) with x = .. Thus, in\u00adstead of requiring \ntotality of both R and R -1 which amounts to bottom-re.ectingness we require only totality of R . One \nset of restrictions that encompasses this asymmetry idea and ensures the adherence of seq to the parametricity \nproperty derived from its type was proposed in Appendix B of [22]. However, the same lapse occurred there \nas in the conventional wisdom mentioned in the previous section: that those restrictions are preserved \nby all rela\u00adtional actions was never veri.ed. Unfortunately, they are not so preserved, and their ad-hoc \nnature makes it uncertain whether they would provide a good starting point for putting things right by \nad\u00adjusting the relational actions. It is our desire to account for the fact that one of the two terms \nre\u00adlated by a free theorem can become strictly less de.ned than the other in the presence of seq. This \nmotivates turning our attention to relations which are left-closed in addition to being admissible and \ntotal. The need to ensure that all relational actions preserve these restrictions forces us to adjust \ntheir de.nitions. But preserv\u00ading admissibility, totality, and left-closedness is not the only con\u00adcern \nwhen adjusting the de.nitions of the relational actions. The new relational actions must also lend themselves \nto proving a para\u00admetricity theorem, and must therefore have an extensional .avor which ties them to \nthe semantics of the language.5 Extensional\u00adity here is with respect to semantic approximation. For example, \nthe new relational action for the function type constructor applied to relations .t and .t\" will capture \nexactly the conditions under which a function f :: t . t. approximates a function g :: t . t. in the \npresence of seq. 5In the absence of this consideration, every relational action could simply return the \ntrivial relation {(., .)}. But this is clearly not what we want. In the remainder of this paper the set \nof all admissible, total, and left-closed relations between values of closed types t1 and t2 is denoted \nby Relseq(t1, t2). The relational action correspond\u00ading to the function type constructor is adapted to \nmap relations R E Relseq(t1, t2) and S E Relseq(t. 1, t. 2) to the following relation in Relseq(t1 . \nt. 1, t2 . t. 2): R .seq S = {( f , g) | ( f ** = .. g = .) ..(x, y) E R . ( fx, gy) E S}, i.e., we explicitly \nadd the totality restriction. That the resulting re\u00adlation is admissible follows from monotonicity and \ncontinuity of function application in Haskell and from admissibility of S. To show that it is also left-closed, \nwe need to establish that from f . . f and ( f , g) E R .seq S it follows that ( f . , g) E R .seq S, \ni.e., ( f . ** x, gy) E S. = .. g = .) ..(x, y) E R . ( f . The .rst conjunct follows from f . . f and \nf *.. g = .. The = *second conjunct follows by left-closedness of S from the facts that, for every (x, \ny) E R , we have f . x . fx by monotonicity of function application in Haskell, as well as ( fx, gy) \nE S. The relational action corresponding to the .-type constructor is adapted by quantifying only over \nadmissible, total, and left-closed relations as follows. Let t1 and t2 be types with at most one free \nvariable, say a. In addition, let F be a function that, for all closed types t. 1 and t2 . and every \nrelation R E Relseq(t. 1, t2. ), gives a rela\u00adtion F (R ) E Relseq(t1[t. 1/a], t2[t. 2/a]). The new relational \naction maps F to the following relation in Relseq(.a. t1, .a. t2): .R E Relseq. F (R ) = {(u, v) |.t. \n1, t2. , R E Relseq(t. 1, t. 2). (ut\" , vt\" ) E F (R )}. 12 That the resulting relation is admissible \nfollows from monotonic\u00adity and continuity of type instantiation in Haskell and from ad\u00admissibility of \nall the F (R ). That it is total can be shown by indirect reasoning as follows. Assume (u, . a. t2 ) \nE (.R E Relseq. F (R )) for some u *= . a. t1. Since for every closed type t we have .t E Relseq(t, t), \nthis means that for every such t we have (ut, (. a. t2 )t) E F (.t), i.e., (ut, .t2[t/a]) E F (.t). By \ntotality of F (.t) it follows that for every such t we have ut = .t1[t/a], and thus by law (2) we derive \nthe contradiction that u = . . To a. t1 show left-closedness of .R E Relseq. F (R ), we need to establish \nthat from u. . u and (u, v) E (.R E Relseq. F (R )) it follows that . (u, v) E (.R E Relseq. F (R )), \ni.e., . .t. 1, t2. , R E Relseq(t. 1, t. 2). (u, vt\" ) E F (R ). t\" 2 1 This follows by left-closedness \nof all the F (R ) from the facts that, . for every t. 1, t2. , and R E Relseq(t. 1, t2. ), we have ut\" \n. ut\" by mono\u00ad 11 tonicity of type instantiation in Haskell, and (ut\" , vt\" ) E F (R ). 12 The relational \ninterpretations of datatypes are left-composed with .. It is not hard to see (from the facts that .;R \nis always strict, total, and left-closed for a strict and total R and that the standard re\u00adlational interpretations \nfor datatypes are strict and total by construc\u00adtion) that this gives strict, total, and left-closed relations \nonly. Fur\u00adther, . is a continuous relation, and for continuous and left-closed relations R and S the \nrelations .;liftMaybe(R ), .;lift(,)(R , S), and .;lift[] (R ) are also continuous. Hence, all relations \nthat turn up in the de.nition of the new logical relation as given in Figure 4 will in fact be admissible, \ntotal, and left-closed. In particular, .seq t,0/ E Relseq(t, t) for every closed type t. .seq = .(a) \n.seq = .seq a,. t,. .seq .seq t-t\" ,.t\" ,. .seq . .seq = .R E Relseq a. t,.t,.[R /a] .seq Int,. = .Int \n.seq Bool,. = .Bool .seq Maybe t,. = .;liftMaybe(.seq t,.) .seq t,., .seq = .;lift(,)(.seq (t,t\"),.t\" \n,.) .seq = .;lift[](.seq t,.) [t],. Figure 4. De.nition of the logical relation in the presence of seq. \nWe claim that our changed logical relation still has the following fundamental property (from which the \nnew free theorems will be derived): if t is a closed type and t :: t is a closed term, then: (t, t) E \n.seq (7) t,0/ The .rst thing to check is that this is true for seq: (seq, seq) E .seq a\u00df. a-\u00df-\u00df,0/ ..R \nERelseq(t1, t2), S ERelseq(t. 1, t. 2). ) E R .seq (S .seq S) (seqt1 t\" , seqt2 t\" 12 ..R ERelseq(t1, \nt2), S ERelseq(t. 1, t. 2). (seqt1 t\" ** = .. seqt2 t\" = .) 12 a2) E S .seq S ..(a1, a2) ER . (seqt1 \nt\" a1, seqt2 t\" 12 ..R ERelseq(t1, t2), S ERelseq(t. 1, t. 2). (seqt1 t\" ** = .. seqt2 t\" = .) 12 ..(a1, \na2) ER . (seqt1 t\" a1 *= .. seqt2 t\" a2 * = .) 12 ..(b1, b2) ES. (seqt1 t\" a1 b1, seqt2 t\" a2 b2) E \nS. 12 The two implications arising from totality can be discharged be\u00adcause both seqt2 t\" and seqt2 t\" \na2 are only partially applied and 22 hence are weak head normal forms different from .. The state\u00adment \n(seq a1 b1, seq a2 b2) E S under the assumptions (a1, a2) E R and (b1, b2) E S is veri.ed by case distinction \non a1 and a2: a1 **. (seq a1 b1, seq a2 b2)=(b1, b2) = .. a2 = . a1 = .. a2 =*. . (seq a1 b1, seq a2 \nb2)=(., b2) a1 = .. a2 = .. (seq a1 b1, seq a2 b2)=(., .) The case a1 *. and a2 == . cannot occur due \nto totality of R . In the other cases, (seq a1 b1, seq a2 b2) E S follows from (b1, b2) E S and left-closedness \nand strictness of S. We also need to establish that each constant associated with a data\u00adtype ful.lls \nthe parametricity property derived from its type. For a nonparametrized datatype such as Int this means \nwe must con\u00ad.rm that for every literal i :: Int, (i, i) E .seq = holds. This Int,0/ .Int is obviously \ntrue, and so are the parametricity properties derived for integer operations such as +. For lists, we \nmust con.rm that a. [a],0/ and ((:), (:)) E .seq ([], []) E .seq The latter re\u00ad a. a-[a]-[a],0/ . quires \nus to establish that certain de.nedness conditions which arise on partial applications of (:) are satis.ed \nand that for every admissi\u00adble, total, and left-closed relation R it follows from (x, y) E R and (xs, \nys) E.;lift[](R ) that (x : xs, y : ys) E.;lift[] (R ). The former is obvious; to prove the latter is \nan easy exercise using the monotonic\u00adity of (:). Similar arguments work for the other data constructors. \nWhat remains to be done is to mirror Wadler s sketched proof [23] that the term-forming operations of \nthe polymorphic lambda cal\u00adculus i.e., .-abstraction, function application, type abstraction, type instantiation \n as well as the case-construct behave accord\u00ading to the (new) logical relation. As usual, this proof \nrequires a generalization from the statement about closed types t and closed terms t :: t to types and \nterms potentially containing free variables. It proceeds by induction over the structure of typing derivations. \nFor the new logical relation, we changed the standard relational ac\u00adtion corresponding to the .-type \nconstructor by imposing admissi\u00adbility, totality, and left-closedness on the relations over which quan\u00adti.cation \ntakes place. This means that, in comparison to the stan\u00addard proof, the hypothesis in the induction step \nfor the typing rule in whose premise a .-type appears i.e., the induction hypoth\u00adesis for the rule for \ntype instantiation now provides a weaker statement concerning restricted relations only. But since the \nnew relational actions are constructed precisely so that the relational in\u00adterpretations of all types \nsatisfy the required restrictions, this is just enough to prove the induction conclusion. For the other \ninduction step involving a .-type i.e., for the step corresponding to type abstraction no additional \narguments are necessary. The only change to the relational action corresponding to the func\u00adtion type \nconstructor is a strengthening due to the added totality re\u00adstriction. Thus, of the two type inference \nrules involving a function type, only the induction step for the rule in whose conclusion the function \ntype appears differs from that for the standard logical rela\u00adtion. For an abstraction of the form (.x \n. t) appearing in the con\u00adclusion of that rule we must show in addition that (.x . [[t]].1 )=*. implies \n(.x . [[t]].2 )=*. for every pair of type-respecting environ\u00adments .1 and .2 mapping the free type variables \nof t to types and the free object variables of t other than x to values. Here [[t]].1 and [[t]].2 denote \nthe values of t in the environments .1 and .2, respec\u00adtively, where the value of a term in an environment \nis de.ned in the usual way. The implication in question obviously holds because .-abstractions are weak \nhead normal forms distinct from .. The induction step for case-expressions amounts to considering the \ndifferent ways in which the denotation, in one environment, of the selector of such an expression can \nbe related to its denotation in a related environment. We must show that for each such possibility the \ndenotations of the whole case-expression in the two environ\u00adments are correspondingly related by the \ninterpretation of its return type. The argument proceeds along the same lines as the corre\u00adsponding one \nfor the standard logical relation in Section 4. Since each new interpretation of an algebraic datatype \nis the composition of the semantic approximation ordering and its standard structural interpretation, \nthe argument additionally uses the fact that the rela\u00adtional interpretations of all types are left-closed. \nFinally, since admissibility is included among the restrictions we impose on all relations, the arguments \nfrom Section 7 of [23] en\u00ad sure that . and .x also ful.ll their parametricity properties with respect \nto the new logical relation. Putting everything together, we conclude that (7) holds in the presence \nof both seq and general .x\u00adpoint recursion. 6.1 Manufacturing Permissible Relations An oft-followed strategy \nwhen deriving free theorems is to special\u00adize quanti.ed relations to functions. Since the only functions \nthat are strict and left-closed are constant functions mapping to ., and since such a function is total \nonly when its domain consists solely of ., this is not very useful in the presence of seq and its attendant \nrestrictions on relations. There are, however, two canonical ways to manufacture admissible, total, and \nleft-closed relations out of a function. These are considered now and put to good use in the next two \nsections. On the one hand, for every monotonic and admissible function h the relation .;h-1 = {(x, y) \n| x . hy} is admissible, total, and left-closed. On the other, for every mono\u00adtonic, admissible, and \ntotal function h the relation h;. = {(x, y) | hx . y} is admissible, total, and left-closed. Note that \nthe monotonicity and admissibility requirements on h above are essential. But since we will only consider \nfunctions de.nable in Haskell below, and these are always assumed to be monotonic and continuous, we \nwill only explicitly record the strictness precondition in the following.  7 Two Free Theorems about \n.lter In this section we show how the fundamental property of our modi\u00ad.ed logical relation can be used \nto derive free theorems in the pres\u00adence of seq. THEOREM 1. For every function .lter :: .a. (a . Bool) \n. [a] . [a] and appropriately typed p, h, and l the following hold: if h is strict, then: .lter p (map \nh l) . map h (.lter ( p . h) l) (8) if p * = . and h is strict and total, then: .lter p (map h l)= map \nh (.lter ( p . h) l) (9) PROOF. The parametricity property for .lter s type is the following instance \nof law (7): (.lter, .lter) E .seq a. (a-Bool)-[a]-[a],0/ . Expanding this statement following the de.nition \nfrom Figure 4 yields that for every choice of closed types t1 and t2, an admis\u00adsible, total, and left-closed \nrelation R E Relseq(t1, t2), functions p1 :: t1 . Bool and p2 :: t2 . Bool, and lists l1 :: [t1] and \nl2 :: [t2] the following holds: (.ltert1 ** = .. .ltert2 = .) . (( p1 **p1 x1 . p2 x2) = .. p2 = .) . \n(.(x1, x2) E R . p1 = .. .ltert2 . (.ltert1 *p2 *= .) . ((l1, l2) E.;lift[] (R ) . (.ltert1 p1 l1, .ltert2 \np2 l2) E.;lift[](R ))). Dropping two conjuncts from the above and strengthening one pre\u00adcondition, we \nobtain the following weaker statement: p2 * p1 x1 . p2 x2) = .. (.(x1, x2) E R . . ((l1, l2) E.;lift[](R \n) . (.ltert1 p1 l1, .ltert2 p2 l2) E.;lift[] (R )). We consider two instantiations of this. First, we \ninstantiate R = .;h-1 , p1 = p, p2 = p . h, l1 = map h l, l2 = l for a strict function h :: t2 . t1, \ngiving: p . h * x1 . hx2 . px1 . p (hx2)) = .. (.x1 :: t1, x2 :: t2. . ((map h l, l) E.;lift[](.;h-1) \n. (.ltert1 p (map h l), .ltert2 ( p . h) l) E.;lift[] (.;h-1)). Since p . h has a weak head normal form \nand hence is not ., and since the second conjunct of the precondition follows from mono\u00adtonicity of p, \napplications of laws (3) and (5) yield (8). Second, we instantiate R = h;., p1 = p . h, p2 = p, l1 = \nl, l2 = map h l for a strict and total function h :: t1 . t2, giving: p *= .. (.x1 :: t1, x2 :: t2. hx1 \n. x2 . p (hx1) . px2) . ((l, map h l) E.;lift[](h;.) . (.ltert1 ( p . h) l, .ltert2 p (map h l)) E.;lift[](h;.)). \nSince the second conjunct of the precondition follows from mono\u00adtonicity of p, applications of laws (4) \nand (6) yield p * = .. map h (.lter ( p . h) l) . .lter p (map h l) , which together with the previously \nproven (8) gives (9). To illustrate the roles of the restrictions on p and h required in the previous \ntheorem, we consider the instantiations for p, h, and l that were used in the introduction together \nwith the particular func\u00adtion de.nition for .lter presented there as counterexamples for the unrestricted \nequational law (1). While the .rst two of these instantiations satisfy law (8), which states that strictness \nof h is suf\u00ad.cient to guarantee that the right-hand side is at least as de.ned as the left-hand side, \nthe fourth instantiation demonstrates that strict\u00adness of h is not a necessary condition for this. On \nthe other hand, the third instantiation shows that a proof of law (8) without the strict\u00ad ness of h cannot \nexist. Further, the .rst two instantiations show that neither the restriction that p *. nor totality \nof h can be omitted = when recovering the equality in law (9). Another illustrative take on laws (8) \nand (9) is to argue on an in\u00ad tuitive level why they hold for the particular function de.nition of .lter \nfrom the introduction. We consider only the impact of seq, as opposed to why law (1) would hold in the \n.rst place, i.e., assuming all invocations of seq were dropped. First, for law (8), we need to establish \nthat rhs = map h (.lter ( p . h) l) is always at least as de\u00ad.ned as lhs = .lter p (map h l) for strict \nh. To do so, we consider all uses of seq in the de.nition of .lter. The one on .lter s .rst argument \nturns lhs into . if p = ., but never has an impact on rhs because p . h is always different from .. If \nthe application of seq on some list element x of l .nds a . in rhs, then by strictness of h the corresponding \nelement in map h l is also ., and hence the corresponding application of seq in lhs has the same outcome. \nA similar observation holds for the application of seq on some tail xs of l because map h . = .. Turning \nto law (9), we must argue that under the additional restric\u00ad tions p *. and totality of h, lhs is also \nat least as de.ned as rhs. = This argument breaks naturally into three parts. First note that the new \ncondition on p guarantees that the application of seq on p does not result in lhs being .. Second, totality \nof h guarantees that the application of seq to some list element of map h l in lhs only en\u00adcounters . \nif the corresponding list element of l in rhs is itself .. Strictness of map h thus ensures that rhs \nis never any more de.ned than lhs as a result of an application of seq to an element of map h l. Finally, \nthe application of seq on xs leads to no difference between lhs and rhs because map h is total in addition \nto being strict, and be\u00adcause applying the strict function h to all list elements necessarily preserves \nany resulting unde.ned list element. Note that Theorem 1 is really much more general than described in \nthe above discussions because it holds for every function .lter of appropriate type and does not require \nany knowledge of the con\u00adcrete function de.nition. This wide applicability is what has earned free theorems \ntheir name. They are now restored to their former glory, even in the presence of seq. The proof of the \ninequational free theorem (8) was made possible by the asymmetry built into the new logical relation. \nIn particular, if we were to replace the totality and left-closedness requirements on relational interpretata\u00adtions \nwith bottom-re.ectingness, and if we were to properly con\u00adstruct a logical relation that preserves these \nrestrictions (which can be done), then we would only be able to obtain law (9).  8 Program Transformations \nFree theorems have found an important application as justi.cations for various kinds of program transformations \nfor nonstrict func\u00adtional languages [3, 6, 9, 20, 22]. The presence of seq, however, threatens the claimed \nsemantics-preserving character of such trans\u00adformations. Fortunately, one often needs to know only that \na pro\u00adgram resulting from a transformation is at least as de.ned as the program from which it was obtained. \nIn such situations the inequa\u00adtional free theorems derived from our new asymmetric logical rela\u00adtion \nand its associated parametricity theorem come to the rescue. In this section we apply them to evaluate \nthe effect of seq on program transformations founded on the polymorphic types of arguments to the functions \ndestroy, build, and vanish+ given in Figure 5. unfoldr :: .a\u00df. (\u00df . Maybe (a, \u00df)) . \u00df . [a] unfoldr f \nb = case fb of Nothing . [] Just (a, b.) . a : unfoldr f b. destroy :: .a.. (.\u00df. (\u00df . Maybe (a, \u00df)) . \n\u00df . .) . [a] . . destroy g = g listpsi where listpsi [] = Nothing listpsi (a : as)= Just (a, as) foldr \n:: .a\u00df. (a . \u00df . \u00df) . \u00df . [a] . \u00df foldr c n [] = n foldr c n (a : as)= ca (foldr c n as) build :: .a. \n(.\u00df. (a . \u00df . \u00df) . \u00df . \u00df) . [a] build g = g (:) [] vanish+ :: .a. (.\u00df. \u00df . (a . \u00df . \u00df) . (\u00df . \u00df . \u00df) \n. \u00df) . [a] vanish+ g = g id (.x h ys . x : h ys)(.) [] Figure 5. Functions for program transformations. \n8.1 The Dual of Short Cut Fusion Svenningsson [20] considered the destroy/unfoldr rule as a dual to the \nfoldr/build rule used in short cut fusion [6] (considered in the next subsection). It solves some problems \nthat short cut fusion has with list consumption by zip-like functions and by functions de.ned using accumulating \nparameters. The destroy/unfoldr rule can be used to eliminate intermediate lists in compositions of list \nproducers written with unfoldr and list consumers written with destroy. Svenningsson describes the rule \nas an oriented replace\u00adment transformation, but makes no precise statement about its semantics. He only \nsuggests that correctness of the transformation might be provable using a free theorem. In order for \nthe rule to be safely applicable i.e., to produce a program that is at least as de.ned as the original \none we must at least have the following for appropriately typed g, psi, and e:6 destroy g (unfoldr psi \ne) . g psi e (10) While [20] proposes the destroy/unfoldr rule for the lan\u00adguage Haskell and even contains \nan example involving seq, the possible impact of seq on the correctness of the transformation is ignored. \nBut the following two instantiations using seq break conjecture (10), making the right-hand side less \nde.ned than the left-hand side: g =(.xy . seq x []) psi = . e = [] g =(.xy . seq y []) psi =(.x . Nothing) \ne = . Thus, in the presence of seq the transformation is unsafe. To .nd conditions under which (10) holds \nand (potentially differ\u00adent) conditions under which the converse inequation holds (which together would \ngive conditions for semantic equivalence), we de\u00adrive the parametricity property for terms of g s type \nin the de.ni\u00adtion of destroy and instantiate it in such a way that the result relates the two sides of \nthe destroy/unfoldr rule. While doing so, we keep track of conditions to impose so that the chosen instantiation \nis per\u00admissible (cf. Section 6.1). This process does not immediately yield the inequations we seek, but \ninstead gives free theorems relating the two sides of the destroy/unfoldr rule by the interpretation \nof g s return type according to our logical relation. The inequations are then obtained from these theorems \nunder a certain (reasonable) as\u00adsumption about the interpretations of closed types according to the logical \nrelation, to be discussed below. THEOREM 2. For all closed types t and t., every function g :: .\u00df. (\u00df \n. Maybe (t. , \u00df)) . \u00df . t, and appropriately typed psi and e the following hold: if psi * = . and psi \nis strict, then: (destroy g (unfoldr psi e), g psi e) E .seq (11) t,0/ if psi is strict and total and \nnever returns Just ., then: (destroy g (unfoldr psi e), g psi e) E (.seq (12) t,0/ )-1 PROOF. The parametricity \nproperty associated with g s type is the following instance of law (7): (g, g) E .seq \u00df. (\u00df-Maybe (t\" \n,\u00df))-\u00df-t,0/ . Expanding this statement according to Figure 4 yields that for every choice of closed types \nt1 and t2, an admissible, total, and left-closed relation R E Relseq(t1, t2), functions psi1 :: t1 . \nMaybe (t. , t1) and psi2 :: t2 . Maybe (t. , t2), and values e1 :: t1 6 The instantiation g =(.xy . case \nxy of Just z . []), psi = (.x . case x of [] . Just .), and e = [] demonstrates that (even in the absence \nof seq and even for strict psi) semantic equivalence does not hold in general. Svenningsson s paper does \nnot mention this. and e2 :: t2 the following holds: (gt1 ** = .. gt2 = .) . ((psi1 *= .. psi2 *= .) . \n(.b1 :: t1, b2 :: t2. (b1, b2) E R . (psi1 b1, psi2 b2) E.;liftMaybe(.;lift(,)(.seq , R ))) t\" ,[R /\u00df] \n. (gt1 psi1 *= .. gt2 psi2 * = .) . ((e1, e2) E R . (gt1 psi1 e1, gt2 psi2 e2) E .seq )). t,[R /\u00df] Using \nthe fact that for the closed types t and t. we have .seq = t,[R /\u00df] .seq .seq t,0/ and .seq = ,0/ , dropping \ntwo conjuncts from the above, t\" ,[R /\u00df] t\" and strengthening one precondition, we obtain the following \nweaker statement: psi2 * = . . (.b1 :: t1, b2 :: t2. (b1, b2) E R . (psi1 b1, psi2 b2) E.;liftMaybe(.;lift(,)(.seq \n,0/ , R ))) t\" . (e1, e2) E R . (gt1 psi1 e1, gt2 psi2 e2) E .seq t,0/ . We consider two instantiations \nof this. First, we instantiate t1 =[t.], psi1 = listpsi, e1 = unfoldr psi e, R = .;(unfoldr psi)-1 , \npsi2 = psi, e2 = e for strict psi :: t2 . Maybe (t. , t2). Note that the instantiation for R is permissible \nbecause unfoldr psi is a strict function for strict psi. We obtain: psi * = . . (.b1 :: [t.], b2 :: t2. \nb1 . unfoldr psi b2 . (listpsi b1, psi b2) E.;liftMaybe(.;lift(,)(.seq ,0/ , R ))) t\" . unfoldr psi \ne . unfoldr psi e . (g[t\" ] listpsi (unfoldr psi e), gt2 psi e) E .seq t,0/ . Since listpsi is monotonic, \nso that b1 . unfoldr psi b2 implies listpsi b1 . listpsi (unfoldr psi b2), and since . is transitive, \nwe can prove that the second conjunct of the precondition holds by showing that (listpsi (unfoldr psi \nb2), psi b2) E.;liftMaybe(.;lift(,)(.seq ,0/ , R )) t\" for every b2 :: t2. By the de.nitions of unfoldr \nand listpsi the ele\u00adment in the left position is equal to: case psi b2 of Nothing . Nothing Just (a, \nb.) . Just (a, unfoldr psi b.). By case distinction on the value of psi b2 :: Maybe (t. , t2) we can \ncheck that this is indeed always related to psi b2 by .;liftMaybe(. ;lift(,)(.seq ,0/ , R )) as follows. \nThe cases . and Nothing are straight\u00ad t\" forward, using the re.exivity of . and the de.nition of liftMaybe. \nSimilarly, the proof obligation in the case psi b2 = Just (a, b.) for some a :: t. and b. :: t2 reduces \nto: ((a, unfoldr psi b.), (a, b.)) E.;lift(,)(.seq ,0/ , R ). t\" But this follows from re.exivity of \n., the de.nition of lift(,), law (7) for the closed type t., and the instantiation of R . Finally, in \nthe case psi b2 = Just ., (., Just .) E.;liftMaybe(.;lift(,)(.seq ,0/ , R )) t\" follows from .. Just \n., the de.nition of liftMaybe, the re.exivity of ., and the de.nition of lift(,). The third conjunct \nof the precon\u00addition in the above implication is trivially true, hence we obtain: psi *psi e) E .seq \n= .. (g[t\"] listpsi (unfoldr psi e), gt2 t,0/ , from which law (11) follows by the de.nition of destroy. \nSecond, we instantiate t2 =[t.], psi1 = psi, e1 = e, R =(unfoldr psi) ;., psi2 = listpsi, e2 = unfoldr \npsi e for strict and total psi :: t1 . Maybe (t. , t1) that never returns Just .. Note that the instantiation \nfor R is permissible because the conditions on psi guarantee that unfoldr psi is a strict and total function. \nWe obtain: listpsi * = . . (.b1 :: t1, b2 :: [t.]. unfoldr psi b1 . b2 . (psi b1, listpsi b2) E.;liftMaybe(.;lift(,)(.seq \n,0/ , R ))) t\" . unfoldr psi e . unfoldr psi e . (gt1 psi e, g[t\" ] listpsi (unfoldr psi e)) E .seq t,0/ \n. The .rst and the third conjuncts of the precondition in this impli\u00adcation obviously hold. To establish \nthe validity of the second con\u00adjunct, we note that for every b1 :: t1 and b2 :: [t.], unfoldr psi b1 \n. b2 and monotonicity of listpsi imply the following inequation: listpsi (unfoldr psi b1) . listpsi b2. \nBy the de.nitions of unfoldr and listpsi its left-hand side is equal to: case psi b1 of Nothing . Nothing \nJust (a, b.) . Just (a, unfoldr psi b.). Bearing in mind that neither psi nor listpsi ever returns Just \n. (the former by assumption, the latter by de.nition), it is easy to see from this that the inequation \nconstrains the values of psi b1 :: Maybe (t. , t1) and listpsi b2 :: Maybe (t. , [t.]) to one of the \nfollow\u00ading combinations: psi b1 listpsi b2 .. . Nothing Nothing Nothing . . Just (a, as.) .. Just (a, \nb.) Just (a, as.) | a . a. . unfoldr psi b. . as It remains to be checked that in each of these cases \nthe two values are related by .;liftMaybe(.;lift(,)(.seq ,0/ , R )). This is an easy ex\u00ad t\" ercise using \nthe re.exivity of ., the facts that .. Nothing and . .. Just (a, .) for every a. :: t., the de.nitions \nof liftMaybe and lift(,), law (7) for the closed type t., the instantiation of R , and strictness of \nunfoldr psi. Having established the validity of all three conjuncts of the precon\u00addition in the above \nimplication, its conclusion gives law (12) by the de.nition of destroy. The laws (11) and (12) are not \nyet the desired inequational ver\u00ad sions of the destroy/unfoldr rule. This is because they depend on the \nrelational interpretation of the closed type t. In previous proofs of program transformations based on \nthe fundamental property of a logical relation (e.g., in [6, 22]), such interpretations of closed types \nhave silently been assumed to coincide with the relational in\u00adterpretations of base types, i.e., with \nidentity relations. This cannot be justi.ed solely based on Wadler s parametricity theorem [23], from \nwhich these proofs claim to be derived, but rather requires Reynolds identity extension lemma [17]. Reynolds \nalso considered an order-relation semantics in which the interpretations of base types are semantic approximation \nrelations, and noted that a corresponding extension lemma holds for it (prior to the inclusion of polymorphic \ntypes). This motivates the following conjecture: if t is a closed type, then: .seq = .t (13) t,0/ .seq \nCoincidence of and .t is easily established by induc\u00ad t,0/ tion for types t not containing .-quanti.cations. \nThis is be\u00adcause our logical relation interprets nonparametrized datatypes as ., and because its relational \nactions for function types and parametrized datatypes preserve . (i.e., .t .seq .t\" = .t-t\" and, e.g., \n.Maybe t ;liftMaybe(.t)= .Maybe t). To show that conjecture (13) also holds for types involving poly\u00admorphism \nis more complicated. Indeed, we encounter a problem analogous to that which arises in Section 8 of [17] \nfor the identity extension lemma. To complete the induction step for .-types, one needs to assume the \nvalidity of a statement relating instances of a polymorphic value by the logical relation, interpreting \nthe quan\u00adti.ed type variable by an arbitrary (in our case: admissible, to\u00adtal, and left-closed) relation \nbetween the types at which instanti\u00adation occurs. Since in Section 2 we have not been explicit about \nwhich functions from types to values our semantic model contains at polymorphic types, this statement \nis not known to hold a pri\u00adori. Reynolds solves the problem by incorporating precisely the required statement \ninto the de.nition of the set of values a poly\u00admorphic type contains.7 That no values of terms expressible \nin the underlying language are unduly excluded by doing so is then argued by appealing to the identity \nextension lemma itself, as well as to the abstraction theorem. Since the latter corresponds to the general\u00adized \nform of Wadler s parametricity theorem in Section 6 of [23] and thus to the generalization of the fundamental \nproperty (7) for types and terms potentially containing free variables mentioned in our sketched proof \nin Section 6, the same approach is also expected to work in our setting. Another approach would be to \nmirror Pitts operational tech\u00adniques [14]. He constructed a logical relation for a calculus very similar \nto the one without seq handled in Section 4 and proved that it interprets arbitrary closed types as contextual \nequivalence relations. This was used in [8, 9, 10] to give proofs of program transformations based on \nfree theorems that make explicit the pre\u00adviously implicit use of the coincidence of relational interpretations \nof closed types with identity relations. In a message on the Types mailing list [2], Pitts suggested \nthat changing the interpretations of base types to semantic approximations would give an analogue of \n(13). However, seq was not considered in that discussion. Using the plausible assumption (13), the laws \n(11) and (12) turn into the following: if psi * = . and psi is strict, then: destroy g (unfoldr psi e) \n. g psi e (14) if psi is strict and total and never returns Just ., then: destroy g (unfoldr psi e) . \ng psi e (15) According to law (14), the destroy/unfoldr transformation is safe in the presence of seq \nif the .rst arguments of all occurrences of unfoldr in the original program are strict functions different \nfrom .. Most of the examples given in [20] satisfy this restriction, with the notable exceptions of a \n rather toy de.nition of the empty list as an unfoldr and the following function de.nition: repeat x \n= unfoldr (.a . Just (x, a)) . Fusion with this function as a producer can be problematic. If psi is \nstrict, total, distinct from ., and never returns Just ., then laws (14) and (15) together guarantee \nthat the destroy/unfoldr transformation is a semantic equivalence. 8.2 Short Cut Fusion The classical \nprogram transformation proved with a free theorem is the foldr/build rule [6]. It states that for appropriately \ntyped g, c, and n: foldr c n (build g)= gcn (16) In the presence of seq this law fails, e.g., for the \ninstantia\u00adtion g = seq, c = ., and n = []. But under the assumption (13) we can prove that the following \nlaws hold even when seq is present: foldr c n (build g) . gcn (17) if c .. ** = . and n = ., then: foldr \nc n (build g)= gcn (18) Law (17) gives only partial correctness of the foldr/build rule in general because \nthe transformed program may be less de.ned than the original one. To recover total correctness in law \n(18), c and n must be restricted so that foldr c n is total (in addition to being strict). This coincides \nwith what the conventional wisdom has to say about foldr/build.  8.3 The Concatenate Vanishes For Free \nIn [22] the function vanish+ was given together with a proof of the following law for appropriately typed \ng, in the absence of seq: g [] (:) (++) = vanish+ g (19) Read from left to right, this law can be considered \nas a pro\u00adgram transformation that eliminates concatenate operations from uniformly abstracted list producers. \nIn Appendix B of [22] it was noted that in the presence of seq the transformation might improve the termination \nbehavior of programs. The sketched proof that the converse cannot happen anticipated some of the ideas \nfrom the present paper, but did not correctly handle all the subtleties that the presence of seq entails \nfor proofs based on free theorems. With the logical relation constructed in Section 6, the fundamental \nproperty (7), and assumption (13), we now more rigorously obtain: g [] (:) (++) . vanish+ g (20) 7In \nfact, Reynolds considers the added condition to draw the Analogous inequational laws for other vanish-combinators \ndividing line between parametric and ad-hoc polymorphism. given in [22] can also be proved in the presence \nof seq. 9 Directions for Future Research In this paper we have investigated the impact that a polymorphic \nstrict evaluation primitive, such as Haskell s seq, has on free the\u00adorems derivable from polymorphic \ntypes in a nonstrict functional language. The lessons learned may aid in determining the effects that \nthe addition of other primitives, such as the ones used to incor\u00adporate I/O and stateful references in \nHaskell, has on free theorems. To contain the weakening of free theorems due to seq so that it impacts \nonly those functions that actually use seq, a quali.ed type system along the lines of [11] could be devised. \nThe basic challenge here is to determine when to use the standard relational actions for interpreting \nfunction types or algebraic datatypes and when to use appropriately adapted relational actions for doing \nso. While free theorems derived from our new logical relation also hold for programs which do not contain \nseq at all, they may be overly restrictive in such situations compared with free theorems obtained from \nthe standard logical relation. On the other hand, using a (different) asymmetric logical relation could \nprove worth\u00adwhile also in that setting. For example, the strongest justi.cation for the destroy/unfoldr \nrule in a nonstrict language without seq that could be proved in [8] was semantics-preservation for strict \npsi that never returns Just .. But by employing the asymmetry idea it should also be possible to establish \nthe inequational law (10) with\u00ad out preconditions. Similarly, it would be interesting to investigate \nwhat our approach has to contribute to the study of functional lan\u00adguages where strict rather than lazy \nevaluation is the default. An alternative to the denotational approach taken in the current pa\u00adper is \nPitts operational semantics-based approach to constructing parametric models of higher-order lambda calculi \n[14]. The deli\u00ad cate issue which arises in Pitts approach to parametricity is tying the operational semantics \nof a calculus supporting new primitives into the relational interpretations of its types. The present \npaper can be seen as providing insight into the issues which are likely to arise when modifying the operational \napproach to accommodate seq, but the precise connections between the denotational style restrictions \non relations re.ected in our adapted logical relation and operational style closure operators as employed \nby Pitts remain topics for fur\u00adther investigation. 10 Acknowledgments The ideas presented in this paper \ntook shape during a visit of Pa\u00adtricia Johann to Dresden University of Technology, funded by the Graduiertenkolleg \n334 of the Deutsche Forschungsgemeinschaft . 11 References [1] The Haskell Mailing List Archive (http://www.mail-archive.com/haskell@haskell.org \n).  [2] The Types Forum List Archive (http://www.cis.upenn.edu/.bcpierce/types/archives ), message /current/msg00847.html \n. [3] O. Chitil. Type inference builds a short cut to deforestation. In ICFP 99, Proc., pages 249 260. \nACM Press. [4] S. Cosmadakis, A. Meyer, and J. Riecke. Completeness for typed lazy inequalities. In LICS \n90, Proc., pages 312 320. IEEE Computer Society Press. [5] H. Friedman. Equality between functionals. \nIn Logic Collo\u00adquium 72 73, Proc., pages 22 37. Springer-Verlag. [6] A. Gill, J. Launchbury, and S. Peyton \nJones. A short cut to de\u00adforestation. In FPCA 93, Proc., pages 223 232. ACM Press. [7] J.-Y. Girard. \nInterpr\u00b4 \u00b4 etation functionelle et elimination des coupures dans l arithm\u00b4etique d ordre sup\u00b4erieure. \nPhD the\u00ad sis, Universit\u00b4e Paris VII, 1972. [8] P. Johann. On proving the correctness of program transfor\u00admations \nbased on free theorems for higher-order polymorphic calculi. To appear in Math. Struct. in Comp. Sci. \n[9] P. Johann. A generalization of short-cut fusion and its cor\u00adrectness proof. Higher-Order and Symb. \nComp., 15:273 300, 2002. [10] P. Johann. Short cut fusion is correct. J. Funct. Prog., 13:797 814, 2003. \n[11] J. Launchbury and R. Paterson. Parametricity and unboxing with unpointed types. In ESOP 96, Proc., \npages 204 218. Springer-Verlag. [12] S. Peyton Jones, editor. Haskell 98 Language and Libraries: The \nRevised Report. Cambridge University Press, 2003. [13] S. Peyton Jones, J. Launchbury, M. Shields, and \nA. Tolmach. Bridging the gulf: A common intermediate language for ML and Haskell. In POPL 98, Proc., \npages 49 61. ACM Press. [14] A. Pitts. Parametric polymorphism and operational equiva\u00adlence. Math. Struct. \nin Comp. Sci., 10:321 359, 2000. [15] G. Plotkin. Lambda-de.nability and logical relations. Mem\u00adorandum \nSAI-RM-4, University of Edinburgh, 1973. [16] J. Reynolds. Towards a theory of type structure. In Colloque \nsur la Programmation 74, Proc., pages 408 423. Springer-Verlag. [17] J. Reynolds. Types, abstraction \nand parametric polymor\u00adphism. In Information Processing 83, Proc., pages 513 523. Elsevier Science Publishers \nB.V. [18] D. Schmidt. Denotational Semantics: A Methodology for Language Development. Allyn and Bacon, \n1986. [19] R. Statman. Logical relations and the typed lambda-calculus. Inf. and Control, 65:85 97, 1985. \n[20] J. Svenningsson. Shortcut fusion for accumulating parame\u00adters &#38; zip-like functions. In ICFP \n02, Proc., pages 124 132. ACM Press. [21] P. Trinder, K. Hammond, H.-W. Loidl, and S. Peyton Jones. Algorithm \n+ Strategy = Parallelism. J. Funct. Prog., 8:23 60, 1998. [22] J. Voigtl\u00a8ander. Concatenate, reverse \nand map vanish for free. In ICFP 02, Proc., pages 14 25. ACM Press. [23] P. Wadler. Theorems for free! \nIn FPCA 89, Proc., pages 347 359. ACM Press. [24] P. Wadler and S. Blott. How to make ad-hoc polymorphism \nless ad hoc. In POPL 89, Proc., pages 60 76. ACM Press.   \n\t\t\t", "proc_id": "964001", "abstract": "Parametric polymorphism constrains the behavior of pure functional programs in a way that allows the derivation of interesting theorems about them solely from their types, i.e., virtually for free. Unfortunately, the standard parametricity theorem fails for nonstrict languages supporting a polymorphic strict evaluation primitive like Haskell's <i>seq</i>. Contrary to the folklore surrounding <i>seq</i> and parametricity, we show that not even quantifying only over strict and bottom-reflecting relations in the $\\forall$-clause of the underlying logical relation --- and thus restricting the choice of functions with which such relations are instantiated to obtain free theorems to strict and total ones --- is sufficient to recover from this failure. By addressing the subtle issues that arise when propagating up the type hierarchy restrictions imposed on a logical relation in order to accommodate the strictness primitive, we provide a parametricity theorem for the subset of Haskell corresponding to a Girard-Reynolds-style calculus with fixpoints, algebraic datatypes, and <i>seq</i>. A crucial ingredient of our approach is the use of an asymmetric logical relation, which leads to \"inequational\" versions of free theorems enriched by preconditions guaranteeing their validity in the described setting. Besides the potential to obtain corresponding preconditions for standard equational free theorems by combining some new inequational ones, the latter also have value in their own right, as is exemplified with a careful analysis of <i>seq</i>'s impact on familiar program transformations.", "authors": [{"name": "Patricia Johann", "author_profile_id": "81100058482", "affiliation": "Rutgers University, Camden, NJ", "person_id": "P220019", "email_address": "", "orcid_id": ""}, {"name": "Janis Voigtl&#228;nder", "author_profile_id": "81100011863", "affiliation": "Dresden University of Technology, Dresden, Germany", "person_id": "P394765", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/964001.964010", "year": "2004", "article_id": "964010", "conference": "POPL", "title": "Free theorems in the presence of <i>seq</i>", "url": "http://dl.acm.org/citation.cfm?id=964010"}