{"article_publication_date": "01-01-2004", "fulltext": "\n A Bisimulation for Dynamic Sealing Eijiro Sumii Benjamin C. Pierce University of Pennsylvania University \nof Pennsylvania sumii@saul.cis.upenn.edu bcpierce@cis.upenn.edu Abstract We de.ne .seal, an untyped call-by-value \n.-calculus with primi\u00adtives for protecting abstract data by sealing, and develop a bisim\u00adulation proof \nmethod that is sound and complete with respect to contextual equivalence. This provides a formal basis \nfor reason\u00ading about data abstraction in open, dynamic settings where static techniques such as type \nabstraction and logical relations are not ap\u00adplicable. Categories and Subject Descriptors D.3.3 [Programming \nLanguages]: Language Constructs and Fea\u00adtures abstract data types; D.3.1 [Programming Languages]: Formal \nDe.nitions and Theory; F.3 [Theory of Computation]: Logics and Meanings of Programs; E.3 [Data]: Data \nEncryption; C.2.2 [Computer-Communication Networks]: Network Proto\u00adcols protocol veri.cation General \nTerms Theory, Languages, Security 1 Introduction Dynamic sealing: Birth, death, and rebirth Sealing \nis a linguistic mechanism for protecting abstract data. As originally proposed by Morris [18, 19], it \nconsists of three con\u00adstructs: seal creation, sealing, and unsealing. A fresh seal is created for each \nmodule that de.nes abstract data. Data is sealed when it is passed out of the module, so that it cannot \nbe inspected or modi.ed by outsiders who do not know the seal; the data is unsealed again when it comes \nback into the module, so that it can be manipulated concretely. Data abstraction is preserved as long \nas the seal is kept local to the module. Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. POPL 04, January 14 16, 2004, Venice, Italy. Copyright 2004 ACM 1-58113-729-X/04/0001 \n...$5.00 Originally, sealing was a dynamic mechanism. Morris also pro\u00adposed a static variant [19], in \nwhich the creation and use of seals at module boundaries follow a restricted pattern that can be veri.ed \nby the compiler, removing the need for run-time sealing and unsealing. Other researchers found that a \nsimilar effect could be obtained by enriching a static type system with mechanisms for type abstraction \n(see CLU [13], for example). Type abstraction became the primary method for achieving data abstraction \nin languages from CLU to the present day. It is also well understood via the theory of existential types \n[16]. Recently, however, as programming languages and the environ\u00adments in which they operate become \nmore and more open e.g., addressing issues of persistence and distribution dynamic sealing is being rediscovered. \nFor example, Rossberg [26] proposes to use a form of dynamic sealing to allow type abstraction to coexist \nwith dynamic typing; Leifer et al. [12] use hashes of implementations of abstract types to protect abstractions \namong different programs running on different sites; Dreyer et al. [7] use a variant of sealing (somewhere \nbetween static and dynamic) to give a type-theoretic account of ML-like modules and functors; .nally, \nwe [21] have proposed a translation (conjectured to be fully abstract) of System\u00adF-style type abstraction \ninto dynamic sealing. Another reason for the renewal of interest in sealing is that it hap\u00adpens to coincide \nwith perfect encryption (under shared-key cryp\u00adtography), that is, with an ideal encryption scheme where \na cipher\u00adtext can be decrypted only if the key under which it was encrypted is known explicitly. Perfect \nencryption is a common abstraction in current research on both systems security and programming lan\u00adguages, \nfor example in modeling and reasoning about cryptographic protocols (e.g., the spi-calculus [3]). Problem \nAlthough interest in dynamic sealing is reviving, there remains a signi.cant obstacle to its extensive \nstudy: the lack of suf.ciently powerful methods for reasoning about sealing. First, to the best of our \nknowledge, there has been no work at all on proof techniques for sealing in untyped sequential languages. \n(There are several ver\u00adsions of bisimulation for the spi-calculus, but encoding other lan\u00adguages such \nas .-calculus into spi-calculus raises the question of what abstraction properties are preserved by the \nencoding itself.) Second, even in statically typed settings, the published techniques for obtaining abstraction \nproperties are in general very weak. For instance, the .rst two [12, 26] of the works cited above use \n(variants of) the colored brackets of Zdancewic et al. [8, 32] but only prove (or even state) abstraction \nproperties for cases where abstract data is published by itself with no interface functions provided \n(i.e., once sealed, data is never unsealed). Abstraction as equivalence We aim to establish a method \nfor proving abstraction of programs using dynamic sealing in an untyped setting. To this end, let us \n.rst consider how to state the property of abstraction in the .rst place. Take, for example, the following \nmodule implementing complex numbers in an imaginary ML-like language. module PolarComplex = abstype t \n= real * real let from_re_and_im : real * real -> t = fun (x, y) -> (sqrt(x * x+y* y), atan2(y, x)) \nlet to_re_and_im : t -> real * real = fun (r, t) -> (r * cos(t), r * sin(t)) let multiply :t*t-> t = \nfun ((r1, t1), (r2, t2)) -> (r1 * r2, t1 + t2) end Using dynamic sealing instead of type abstraction, \nthis module can be written as follows for some secret seal k. module PolarComplex = let from_re_and_im \n= fun (x, y) -> let z = (sqrt(x * x+y*y), atan2(y, x)) in <seal z under k> let to_re_and_im = fun \nz -> let (r, t) = <unseal z under k> in (r * cos(t), r * sin(t)) let multiply = fun (z1, z2) -> let \n(r1, t1) = <unseal z1 under k> in let (r2, t2) = <unseal z2 under k> in let z = (r1 * r2, t1 + t2) in \n<seal z under k> end Now, the question is: Is this use of sealing correct? That is, does it really \nprotect data abstraction? In particular, can we show that this module has the same external behavior \nas another sealed module that also implements complex numbers, e.g., the following module with another \nsecret seal k ? module CartesianComplex = let from_re_and_im = fun (x, y) -> <check that x and y are \nreal numbers>; let z = (x, y) in <seal z under k > let to_re_and_im = fun z -> let (x, y) = <unseal \nz under k > in (x, y) let multiply = fun (z1, z2) -> let (x1, y1) = <unseal z1 under k > in let (x2, \ny2) = <unseal z2 under k > in letz=(x1 *x2-y1*y2, x1*y2+ x2*y2) in <seal z under k > end Formally, \nwe want to show the contextual equivalence [17] of the two modules PolarComplex and CartesianComplex. \nIn general, however, it is dif.cult to directly prove contextual equivalence be\u00adcause it demands that \nwe consider an in.nite number of contexts. Equivalence by bisimulation To overcome this dif.culty, we \nde.ne a notion of bisimulation for our language (by extending applicative bisimulation [4]) and use it \nas a tool for proving contextual equivalence. Essentially, a bisimulation records a set of pairs of corresponding \nvalues of two different programs. In the example of PolarComplex and CartesianComplex, the bisimulation \nis (roughly): {(PolarComplex,CartesianComplex)}. {(PolarComplex.from_re_and_im, CartesianComplex.from_re_and_im), \n(PolarComplex.to_re_and_im, CartesianComplex.to_re_and_im), (PolarComplex.multiply, CartesianComplex.multiply)}. \n{((x,y),(x, y)) |x,y real numbers}. {({(r,.)}k,{(r cos ., r sin.)}k') |r =0} The .rst part is the modules \nthemselves. The second part is the individual elements of the modules. The third is arguments of from_re_and_im \nas well as results of to_re_and_im. The last is the representations of complex numbers sealed under k \nor k', where {}denotes sealing. From the soundness of bisimulation, we obtain the contextual equivalence \nof the two modules. Furthermore, our bisimulation is complete: if two programs are contextually equivalent, \nthen there always exists a bisimulation between them. This means that (at least in theory) we can use \nbisimulation to prove any valid contex\u00adtual equivalence. Contribution The main contribution of this \nwork is a sound and complete bisimu\u00adlation proof method for contextual equivalence in an untyped func\u00adtional \nlanguage with dynamic sealing. Along the way, we are led to re.ne the usual contextual equivalence to \naccount for the vari\u00adations in observing power induced by the context s knowledge (or ignorance) of the \nseals used in observed terms. Parts of our theory are analogous to bisimulation techniques de\u00adveloped \nfor the spi-calculus [1, 2, 5, 6]. However, our bisimulation is technically simpler and thus more suitable \nfor reasoning about dynamic sealing for data abstraction in sequential languages. Fur\u00adthermore, our setting \nrequires us to extend even the de.nition of contextual equivalence in a natural but signi.cant way, as \ndiscussed in Section 3. Structure of the paper The rest of this paper is structured as follows. Section \n2 formal\u00adizes the syntax and the semantics of our language, .seal. Sec\u00adtion 3 de.nes a suitable notion \nof contextual equivalence. Sec\u00adtion 4 presents our bisimulation and gives several examples, includ\u00ading \nthe complex number packages discussed above and an encoding of the Needham-Schroeder-Lowe key exchange \nprotocol. Section 5 proves soundness and completeness of the bisimulation with re\u00adspect to contextual \nequivalence. Section 7 discusses related work, and Section 8 sketches future work. d,e ::= term x variable \n.x.e function e1 e2 application c constant op(e1,...,en) primitive if e1 then e2 else e3 conditional \nbranch (e1,...,en) tupling #i(e) projection k seal .x.e fresh seal generation {e1}e2 sealing let {x}= \ne2 in e3 else e4 unsealing e1 u,v,w ::= value .x.e function c constant (v1,...,vn) tuple k seal {v}sealed \nvalue k Figure 1. Syntax of .seal Notation Throughout the paper, we use overbars as shorthands for sequences \ne.g., we write x and ( v, v) instead of x1,...,xn and (v1,v1'),...,(vn,v') where n =0. Similarly, {k \n}is a shorthand for nthe set {k1,...,kn}where ki= kj for any i and j. When s and t are sets, s t is de.ned \nto be s .t if s nt = 0/, and unde.ned otherwise. 2 Syntax and Semantics .seal is the standard untyped, \ncall-by-value .-calculus extended with sealing. Its syntax is given in Figure 1. Seal k is an element \nof the countably in.nite set K of all seals. We use meta-variables s and t for .nite subsets of K . Fresh \nseal generation .x.e generates a fresh seal k, binds it to x and evaluates e. The meaning of freshness \nwill soon be clari.ed below. Sealing {e1}evaluates e1 to value e2 v and e2 to seal k, and seals v under \nk. Unsealing let {x}= e1 e2 in e3 else e4 evaluates e1 to seal k1 and e2 to sealed value {v}.If k1 = \nk2, the unsealing succeeds and e3 is evaluated with x k2 bound to v. Otherwise, the unsealing fails and \ne4 is evaluated. The calculus is also parametrized by .rst-order constants and prim\u00aditives such as real \nnumbers and their arithmetics. We use in.x no\u00adtations for binary primitives like e1 + e2. We assume that \nconstants include booleans true and false. We also assume that op includes the equality = for constants. \nWe adopt the standard notion of variable binding and write FV(e) for the set of free variables in e. \nWe also write Seals(e) for the set of seals that appear in term e. We write let x = e1 in e2 for (.x.e2)e1. \nWe also write .for (.x.xx)(.x.xx) and .{x}k.e for .y.let {x}= y in e else . k where y .FV(e). Furthermore, \nwe write .(x,y).e for .z.let x = #1(z) in let y = #2(z) in e where z .FV(e). We use similar no\u00adtations \nof pattern matching throughout the paper. The semantics of .seal is given in Figure 2 by big-step evaluation \n(s)e .(t)v annotated with the set s of seals before the evaluation and the set t of seals after the evaluation. \nIt is parametrized by the meaning [[op(c1,...,cn)]] of primitives. For example, [[1.23 + 4.56]] = 5.79. \nFor simplicity, we adopt the left-to-right evaluation order. As usual, substitutions [e/x] avoid capturing \nfree variables by implicit a-conversion. The meaning of freshness is formalized by requiring k. s in \n(E-New). We write (s)e .if (s)e .(t)v for some t and v. Because of fresh seal generation, our evaluation \nis not quite de\u00adterministic. For instance, we have both (0/).x.x .({k1})k1 and (0/).x.x .({k2})k2 for \nk1= k2. Nevertheless, we have the follow\u00ading property: Property 2.1. Evaluation is deterministic modulo \nthe names of freshly generated seals. That is, for any (s)e .(t)v and (s)e . '(t')v', we have v =[k/x]e0 \nand v' =[k/x]e0 for some e0 with Seals(e0) .s, some k with {k}.t \\s, and some k'with {k'}.t'\\s. PROOF. \nStraightforward induction on the derivation of (s)e . (t)v. In what follows, we implicitly use the following \nproperties of eval\u00aduation without explicitly referring to them.   Property 2.2. Every value evaluates \nonly to itself. That is, for any s and v with s .Seals(v), we have (s)v .(s)v. Furthermore, if (s)v .(t)w, \nthen t = s and w = v. PROOF. Straightforward induction on the syntax of values. Property 2.3. Evaluation \nnever decreases the seal set. That is, for any (s)e .(t)v, we have s .t. PROOF. Straightforward induction \non the derivation of (s)e . (t)v.  3 Contextual Equivalence In standard untyped .-calculus, contextual \nequivalence for closed values1 can be de.ned by saying that v and v' are contextually equivalent if [v/x]e \n... [v'/x]e .for any term e.In .seal, however, contextual equivalence cannot be de.ned for two values \nin isolation. For instance, consider .{x}k.x + 1 and .{x}k'.x + 2. Whether these values are equivalent \nor not depends on what val\u00adues sealed under k or k' are known to the context. If the origi\u00adnal terms \nwhich created k and k' were .z.({2}z,.{x}z.x + 1) and .z.({1}z,.{x}z.x+2), for example, then the only \nvalues sealed un\u00adder k or k' are 2 and 1, respectively. Thus, the equivalence above does hold. On the \nother hand, it does not hold if the terms were, say, .z.({3}z,.{x}z.x + 1) and .z.({4}z,.{x}z.x + 2). \nThis ob\u00adservation that we have to consider multiple pairs of values at once leads to the following de.nition \nof contextual equivalence. De.nition 3.1. A value relation R is a set of pairs of values. De.nition 3.2. \nThe contextual equivalence =is the largest rela\u00ad tion among seal sets s and s' and value relations R \n, such that for ' any (s,s,R ) .=and for any (v,'v) .R , we have the following properties. ' 1. Seals(v) \n.s and Seals('v) .s. 1For the sake of simplicity, we focus on equivalence of closed values (as opposed \nto open expressions) in this paper. For open expressions e and e'with free variables x1,...,xn, it suf.ces \nto con\u00adsider the equivalence of .x1.....xn.e and .x1.....xn.e'instead.  Seals(e) .s (s)e1 .(s1).x.e \n(s1)e2 .(s2)v (s2)[v/x]e .(t)w (E-Lam) (E-App) (s).x.e .(s).x.e (s)e1 e2 .(t)w (s)e1 .(s1)c1 ... (sn-1)en \n.(sn)cn [[op(c1,...,cn)]] = c (E-Const) (E-Prim) (s)c .(s)c (s)op(e1,...,en) .(sn)c (s)e1 .(s1)true \n(s1)e2 .(t)v (s)e1 .(s1)false (s1)e3 .(t)v (E-Cond-True) (E-Cond-False) (s)if e1 then e2 else e3 .(t)v \n(s)if e1 then e2 else e3 .(t)v (s)e1 .(s1)v1 ... (sn-1)en .(sn)vn (s)e .(t)(v1,...,vn) 1 =i =n (E-Tuple) \n(E-Proj) (s)(e1,...,en) .(sn)(v1,...,vn) (s)#i(e) .(t)vi k .s (s {k})[k/x]e .(t)v (s)e1 .(s1)v (s1)e2 \n.(s2)k (E-Seal) (E-New) (E-Do-Seal) (s)k .(s)k (s).x.e .(t)v (s){e1}.(s2){v}k e2 (s)e1 .(s1)k (s1)e2 \n.(s2){v}k (s2)[v/x]e3 .(t)w (E-Unseal-Succ) (s)let {x}= e2 in e3 else e4 .(t)w e1 (s)e1 .(s1)k1 (s1)e2 \n.(s2){v}k2 k1 = k2 (s2)e4 .(t)w (E-Unseal-Fail) (s)let {x}= e2 in e3 else e4 .(t)w e1 Figure 2. Semantics \nof .seal '' 2. (s)[v/x]e ...(s )[v /x]e .for any e with Seals(e)= 0/. ''' '' We write (s)v1,...,vn =(s \n)v1,...,v for (s,s ,{(v1,v1),..., n ' (vn,v )}) .=. In order to lighten the notation, we do not en\u00ad n \n'' close these v1,...,vn and v1,...,v in parentheses. We also write n ''' (s)v =R (s )v ' when (v,v ) \n.R and (s,s ,R ) .=. Intuitively, it ' can be read as value v with seal set s and value v ' with seal \nset s are contextually equivalent under contexts knowledge R . Note that no generality is lost by requiring \nSeals(e)= 0/ in the def\u00adinition above: if e needs its own seals, it can freshly generate an arbitrary \nnumber of them by using .;if e knows some of the seals k ' ' ' in s and k in s , it suf.ces to require \n(k,k ) .R . Thus, our contex\u00adtual equivalence subsumes standard contextual equivalence where a context \nknows none, all, or part of the seals (or, more generally, values involving the seals). Example 3.3. \nLet s = {k} and s ' = {k '}. We have (s){2}k = ' (s ){1}k' since the context has no means to unseal the \nvalues sealed under k or k '. (A formal proof of this claim based on bisimulation ' will be given later.) \nWe also have (s).{x}k .x+1 =(s ).{x}k' .x+2 'since the context cannot make up any values sealed under \nk or k . Furthermore, we have ' (s){2}k,.{x}k.x + 1 =(s ){1}k' ,.{x}k' .x + 2 because applications of \nthe functions to the sealed values yield the same integer 3. Similarly, ' (s){4}k,.{x}k.x + 1 =(s ){5}k' \n,.{x}k' .x holds. However, (s){2}k ,.{x}k.x + 1,{4}k,.{x}k.x + 1 ' =(s ){1}k' ,.{x}k' .x + 2,{5}k' ,.{x}k' \n.x does not hold, because applications of the last functions to the .rst sealed values yield different \nintegers 3 and 1. '' As the last example shows, even if (s,s ,R1) .=and (s,s ,R2) .=, ' we do not always \nhave (s,s ,R1 .R2) .=. Intuitively, this means that we should not confuse two worlds where the uses of \nseals are different. This is the reason why we de.ned =as a set of triples '' (s,s ,R ) rather than just \na function that takes a pair (s,s ) of seal sets and returns the largest set R of pairs of equivalent \nvalues. Conversely, again as the examples above suggest, there are cases '' where (s,s ,R1) .= and (s,s \n,R2) .= for R1 .R2. This im\u00adplies that there is a partial order among the value relations R in contextual \nequivalence. We could alternatively de.ne contextual equivalence only with such value relations that \nare maximal in this ordering, but this would just complicate the technicalities that fol\u00adlow. We will \nuse the following lemmas about contextual equivalence in what follows. Lemma 3.4. Application, projection, \nfresh seal generation, and unsealing preserve contextual equivalence. That is: ''' 1. For any (u,u ) \n.R and (v,v ) .R with (s,s ,R ) .=,if ''' ' (s)uv .(t)w and (s)uv .(t)w , then (t,t ' ,R .{(w,w )}) . \n=. '' ' 2. For any ((v1,...,vn),(v1,...,v )) .R with (s,s ,R ) .=,we n '' have (s,s ,R .{(vi,vi)}) .=for \nany 1 =i =n. ' ' 3. For any (s,s ,R ) .=, we have (s {k},s {k '},R ' {(k,k ')}) .=for any k .s and k \n'.s . ' ' 4. For any ({v}k,{v }k') .R and (k,k ') .R with (s,s ,R ) .=, '' we have (s,s ,R .{(v,v )}) \n.=. PROOF. Take e as let z = xy in e0, let y = #i(x) in e0, .x.e0, ' and let {z}x = y in e0, respectively, \nin the de.nition of (s,s ,R ) . =. Lemma 3.5. Contextually equivalent values put in the same value context \nyield contextually equivalent values. That is, for any '' ' = ' '' (s,s ,R ) .=and (v,v ) .R , and for \nany w =[v/x]e0 and w [v /x]e0 with Seals(e0)= 0/,wehave (s,s ,R .{(w,w )}) .=. PROOF. Immediate from \nthe de.nition of contextual equivalence, using the property of substitution that [[ v/ x]e0/x]e =[v / \nx]([e0/x]e) when { x}n FV(e)= 0/. Lemma 3.6. Any subset of contextually equivalent values are con\u00ad ' \ntextually equivalent. That is, for any (s,s ,R ) .=, we have ' (s,s ,S) .= for any S . R . PROOF. Immediate \nfrom the de.nition of contextual equiva\u00adlence.  4 Bisimulation Giving a direct proof of contextual equivalence \nis generally dif.\u00adcult, because the de.nition involves universal quanti.cation over an in.nite number \nof contexts. Thus, we want a more convenient tool for proving contextual equivalence. For this purpose, \nwe de.ne the notion of bisimulation as follows. De.nition 4.1. A bisimulation X is a relation among seal \nsets s and '' s and value relations R such that every (s,s ,R ) . X satis.es the following conditions. \n' 1. For each (v,v ') . R , we have Seals(v) . s and Seals(v ') . s . ' 2. For each (v,v ') . R , v and \nv are of the same kind. That is, both are functions, both are constants, both are tuples, both are seals, \nor both are sealed values. ' 3. For each (c,c ') . R , we have c = c . '' ' 4. For each ((v1,...,vn),(v1,...,vn \n' )) . R , we have n = n and '' (s,s ,R .{(vi,vi)}) . X for every 1 = i = n. 5. For each (k1,k1' ) . \nR and (k2,k2' ) . R ,wehave k1 = k2 .. k1 ' = k2' . 6. For each ({v}k,{v '}k' ) . R , we have either \n(k,k ') . R and '  (s,s ,R .{(v,v ')}) . X, or else (k,k '') . R and (k '' ,k ') . R for every k '' \n. ' ' 7. Take any (.x.e,.x.e ) . R . Take also any k and k with s n ' {k } = s 'n{ k } = 0/. Moreover, \nlet v =[ u/ x]d and v ' =[u ' /x ]d ' for any (u, u ') . R {(k,k )} and Seals (d)= 0/. Then, we ' ' \nhave (s {k})( .x.e)v ...(s {k })(.x.e ')v '.. Further\u00ad' ' ' more, if (s {k})(.x.e) v .(t)w and (s {k \n})(.x.e ')v . ' (t ')w ', then (t,t ' ,R {(k,k )}.{(w,w ')}) . X. ' For any bisimulation X, we write \n(s)vXR (s ')v when (v,v ') . R '' and (s,s ,R ) . X. This can be read values v and v with seal sets s \n' and s are bisimilar under contexts knowledge R . The intuitions behind the de.nition of bisimulation \nare as follows. Each of the conditions excludes pairs of values that are distin\u00adguishable by a context \n(except for Condition 1, which just re\u00adstricts the scoping of seals). Condition 2 excludes pairs of val\u00adues \nof different kinds, e.g., 123 and .x.x. Condition 3 excludes pairs of different constants. Condition \n4 excludes pairs of tuples with distinguishable elements. Condition 5 excludes cases such as (k,k ') \n. R and (k,k '') . R with k ' = k '', for which contexts like let {x}y = {()}z in x else . can distinguish \nthe left-hand side (setting y = z = k) and the right-hand side (setting y = k ' and z = k ''). Condition \n6 excludes cases where (i) the context can un\u00adseal both of two sealed values whose contents are distinguishable, \nor (ii) the context can unseal only one of the two sealed values. Condition 7, the most interesting one, \nis about what a context can do to distinguish two functions. Obviously, this will involve ap\u00adplying them \nto some arguments but what arguments? Certainly not arbitrary terms, because in general a context has \nonly a par\u00ad ' tial knowledge of (values involving) the seals in s and s . All that a context can do for \nmaking up the arguments is to carry out some computation d using values u and u ' from its knowledge. \nTherefore, the arguments have forms [ u/ x]d and [ u ' /x ]d. An important and perhaps surprising point \nhere is that it actually suf.ces to consider cases where these arguments are values. This restriction \nis useful and even crucial for proving bisimulation of functions: if the arguments [ u/ x]d and [ u ' \n/x ]d were not values, we should evaluate them before applying the functions; in particular, if evaluation \nof one argument converges, then evaluation of the other argument must converge as well; proving this \nproperty amounts to proving the contextual equivalence of u and u ', which was the whole purpose of our \nbisimulation! Fortunately, our restriction of the arguments to values can be jus\u00adti.ed by the fundamental \nproperty proved in the next section, which says that the special forms [ u/ x]d and [ u ' /x ]d are preserved \nby evaluation. The only change required as a result of this restric\u00ad ' tion is the addition of {(k,k \n)} to knowledge R in Condition 7: it compensates for the fact that d can no longer be a fresh seal gen\u00aderation, \nwhile the context can still generate its own fresh seals k ' and k when making up the arguments. Without \nsuch a change, our bisimulation would indeed be unsound: a counter-example would be (0/,0/,{(.x.{true}x,.x.{false}x)}), \nfor which contexts like .y.let {z}y =[]y in if z then () else . can distinguish the two functions. ' \nThe rest of Condition 7 is straightforward: the results w and w of function application should also be \nbisimilar. ' Example 4.2. Let s = {k}, s = {k '}, and R = {({2}k,{1}k' )}. ' Then {(s,s ,R )} is a bisimulation, \nas can be seen by a straightfor\u00adward check of the conditions above. Example 4.3. Let s = {k1,k2}, s ' \n= {k '}, and R = {(({2}k1 ,{4}k' ),({1}k2 ,{5}k' )), ({2}k1 ,{1}k' ), ({4}k2 ,{5}k' )}. ' Then {(s,s \n,R )} is a bisimulation. This example illustrates the fact that the number of seals may differ in the \nleft-hand side and in the right-hand side of bisimulation. Note that the closure con\u00addition (Condition \n4) in the de.nition of bisimulation demands that we include not only the original pairs, but also their \ncorresponding components. Example 4.4. Suppose we want to show that the pair ({2}k,.{x}k.x + 1) is bisimilar \nto ({1}k' ,.{x}k' .x + 2)), as\u00adsuming that seals k and k ' are not known to the context. Again, the closure \nconditions in the de.nition force us to include the corresponding components of the pairs (Condition \n4), as well as the results of evaluating the second components applied to the .rst components (Condition \n7); moreover, since Condition 7 allows the context to enrich the set of seals with arbitrary seals of \nits own, our bisimulation will consist of an in.nite collection of similar sets, differing in the context \ns choice of seals. Formally, let G be the following function on sets of pairs of seals: G{(k0,k0)} = \n{(({2}k, .{x}k.x + 1), ({1}k', .{x}k'.x + 2)), ({2}k, {1}k'), (.{x}k.x + 1, .{x}k' .x + 2), (3 , 3 )} \n' .{(k0, k0)} Then '' ' X = {({k,k 0}, {k ' ,k 0}, G{(k0,k0)}) |k .{k 0}.k '.{k 0}} is a bisimulation. \nThe only non-trivial work required to show this is checking Condition 7 for the pair  (.{x} k.x + 1, \n.{x}k ' .x + 2) . '' ' G{(k0,k0)}, for each k0 and k0 with k .{k0}and k '.{k0}. ' Consider any v =[ u/ \nx]d and v =[u ' /x ]d with (u , u ') . '' ' G {(k 0,k0)}{(k1,k 1)}and Seals(d)= {k, k0}n{k 1}= {k ' ,k \n0}n' ' {k1}= 0/. If the evaluations of (.{x}k.x + 1)v and (.{x}k' .x + 2)v diverge, then the condition \nholds. Let us focus on cases where the evaluation of (.{x}k.x + 1)v con\u00adverges (without loss of generality, \nthanks to symmetry), that is, where v is of the form {w}k. Then, either d is of the form {d0}xi and ui \n= k, or else d is a variable xi and ui = {w}k. However, the former  ' case is impossible: k is not \nin the .rst projection of G{(k0,k0)} or ' {(k1,k1)}by their de.nitions. So we must be in the latter case. \nSince the only element of the form  {w}k in the .rst projection of '' G{(k0,k0)}{(k1,k1)} is {2}k where \nthe corresponding element ' in its second projection is {1}k', we have v = {2}k and v = {1}k'. ' Then, \nthe only evaluations of (.{x}k.x + 1)v and (.{x}k' .x + 2)v are ({k,k0}{k1})(.{x}k.x + 1)v .({k,k0,k1})3 \nand '' '' ' ({k ' ,k 0}{k1})(.{x}k' .x + 2)v .({k ' ,k 0,k1})3. Thus, the condition follows from '' '' \n1)} and ({k,k0,k1},{k ' ,k0,k1},G{(k0,k0),(k1,k1)}) .X. Example 4.5 (Complex Numbers). Now let us show \na bisimula\u00adtion relating the two implementations of complex numbers in Sec\u00adtion 1. First, let v =(.(x,y). \n{(x + 0.0,y + 0.0)}k , .{(x,y)}k .(x,y), .({(x1,y1)}k,{(x2,y2)}k). {(x1 \u00d7x2 -y1 \u00d7y2,x1 \u00d7y2 + y1 \u00d7x2)}k \n' v =(.(x,y).{(sqrt(x \u00d7x + y \u00d7y),atan2(y,x))}k' , .{(r,.)}k' .(r \u00d7cos .,r \u00d7sin .), .({(r1,.1)}k' ,{(r2,.2)}k').{(r1 \n\u00d7r2,.1 + .2)}k'). The .rst component of each triple corresponds to the from_re_and_im functions in 1. \nThe implementation in v just seals the x and y coordinates provided as arguments, after checking that \nthey are indeed real numbers by attempting to add ' them to 0.0. The implementation in v performs an \nappropriate change of representation before sealing. The second components correspond to the to_re_and_im \nfunctions in 1, and the third components to the multiply functions.  The construction of the bisimulation \nfollows the same pattern as Example 4.4, except that the operator G is more interesting: G{(k0,k0)}= \n{(v,v ')} .{(.(x,y).{(x + 0.0,y + 0.0)}k , .(x,y).{(sqrt(x \u00d7x + y \u00d7y),atan2(y,x))}k'), (.{(x,y)}k .(x,y), \n.{(r,.)}k' .(r \u00d7cos .,r \u00d7sin .)), (.({(x1,y1)}k,{(x2,y2)}k). {(x1 \u00d7x2 -y1 \u00d7y2,x1 \u00d7y2 + y1 \u00d7x2)}k, .({(r1,.1)}k' \n,{(r2,.2)}k').{(r1 \u00d7r2,.1 + .2)}k')}.{((x,y),(x, y)) |x and y are arbitrary real numbers}.{({ (r cos \n., r sin.)}k,{(r,.)}k') |r =0} ' .{(k0,k0)} Example 4.6 (Applicative vs. Generative Functors). In this \nex\u00adample, we use bisimulation to show the equivalence of two instan\u00adtiations of a generative functor, \nwhere generativity is modeled by fresh seal generation and the equivalence really depends on the gen\u00aderativity. \nA functor is a parameterized module a function from modules to modules. For example, a module implementing \nsets by binary trees can be parameterized by the type of elements and their comparison function. In the \nsame imaginary ML-like language as in Section 1, such a functor might be written as follows: functor \nSet(module Element : sig type t val less_than : t -> t -> bool end) = type elt = Element.t abstype set \n= Element.t tree let empty : set = Leaf let rec add : elt -> set -> set = fun x -> <check that x has \ntype elt>; fun Leaf -> Node(x, Leaf, Leaf) | Node(y, l, r) -> if Element.less_than x y then Node(y, \nadd x l, r) else if Element.less_than y x then Node(y, l, add x r) else Node(y, l, r) let rec is_elt_of \n: elt -> set -> bool = fun x -> fun Leaf -> false | Node(y, l, r) -> if Element.less_than x y then is_elt_of \nx l else if Element.less_than y x then is_elt_of x r else true end Now, consider the following three \napplications of this functor: module IntSet1 = Set(module Element = type t = int let less_than : t -> \nt -> bool = funx-> funy-> (x<int y) end) module IntSet2 = Set(module Element = type t = int let less_than \n: t -> t -> bool = funx-> funy-> (x<int y) end) module IntSet3 = Set(module Element = type t = int \n let less_than : t -> t -> bool = funx-> funy-> (x>int y) end) If the functor Set is applicative, the \nabstract type IntSet3.set becomes compatible with IntSet1.set and IntSet2.set,even though the comparison \nfunction of IntSet3 is not compatible with that of IntSet1 or IntSet2. As a result, (part of) their abstraction \nas sets of integers is lost: for instance, IntSet2 and IntSet3 are distinguished by a context like C[] \n= lets= [].add 7 ([].add 3 [].empty) in IntSet1.is_elt_of 7 s while they should be equivalent if considered \njust as two different implementations of integer sets. This situation can be translated into .seal as \nfollows. First, the applicative functor can be implemented by the following function f , using a standard \ncall-by-value .xed-point operator fix (which is de.nable since the language is untyped). .lt. ({nil}k, \nfix(.add..(x,{y}k). if lt(x,x) then . else if y = nil then {(x,nil,nil)}k else if lt(x,#1(y)) then {(#1(y),add(x,#2(y)),#3(y))}k \nelse if lt(#1(y),x) then {(#1(y),#2(y),add(x,#3(y)))}k else {y}k), fix(.is elt of. .(x,{y}k). if y = \nnil then false else if lt(x,#1(y)) then is elt of(x,#2(y)) else if lt(#1(y),x) then is elt of(x,#3(y)) \nelse true)) Next, we translate the three applications of the functor into three applications of f to \nappropriate comparison functions: ({k}) f (.(x,y).x <int y) .({k})v1 ({k}) f (.(x,y).x <int y) .({k})v2 \n({k}) f (.(x,y).x >int y) .({k})v3 The values v2 and v3 are not contextually equivalent when the con\u00adtext \nknows v1. That is, ({k},{k},{(v1 ,v1),(v2,v3)}) .=. To see this, take e = #3(x)(7, #2(y)(7, #2(y)(3, \n#1(y)))), setting x = v1, y = v2 in the left hand side and x = v1, y = v3 in the right hand side. Note \nthat v2 and v3 are contextually equivalent if the context knows neither v1, f , nor any other values \ninvolving the seal k. That is, ({k},{k},{(v2 ,v3)}) .=. Indeed, the context C[] above uses IntSet1 to \ndistinguish IntSet2 and IntSet3. Our de.nition of contextual equivalence as a set of relations (annotated \nwith seal sets) gives a precise account for such subtle variations of contexts knowledge. On the other \nhand, if we take the Set functor to be generative, then IntSet2 and IntSet3 are contextually equivalent \neven if the con\u00adtext also knows IntSet1, since all the abstract types are incompat\u00adible with one another. \nThis case can be modeled in .seal by the following function g, which generates a fresh seal for each \napplica\u00adtion instead of using the same seal k for all instantiations. .lt..z. ({nil}z, fix(.add..(x,{y}z). \n...), fix(.is elt of..(x,{y}z)....)) Consider the following three applications of g. (0/)g(.(x,y).x <int \ny) .({k1})w1 ({k1})g(.(x,y).x <int y) .({k1,k2})w2 ({k1})g(.(x,y).x >int y) .({k1,k3})w3 Now w2 and w3 \nare bisimilar even if the context knows w1. That is, there exists a bisimulation X such that ({k1,k2},{k1,k3},R \n) . X with {(w1,w1),(w2,w3)}. R . It is straightforward to construct this bisimulation in the same manner \nas Examples 4.4 and 4.5. Example 4.7. Let us show that .x.(3,x) is bisimilar to itself. This example \nis technically tricker than previous ones, because arbitrary values provided by the context can appear \nverbatim within results. These results can again be passed as arguments and thus appear within yet larger \nresults, etc. To achieve the required closure condi\u00adtions, we need to reach a limit of this process. \nThis can be accom\u00adplished by de.ning a bisimulation X inductively. We require (0/,0/,0/) . X as the (trivial) \nbase case. The induction ' rule is as follows. Take any (s,s ,R ) . X.Take any w =[ v/ x] e and ' w =[v \n' /x ]e with (v ,v ') . R and Seals( e)= 0/.Take any t . s and ' t '. s of the forms {k} and {k }. Let \nS = {(.x.(3,x),.x.(3,x)), ((3,w),(3,w ')), (3,3), (w,w '), ' (k,k )}. We then require that (t,t ' ,T \n) . X for any T . S. The bisimulation we want is the least X satisfying these conditions. Intuitively, \nwe have de.ned X so that the conditions of bisimulation Condition 7, in particular are immediately satis\u00ad.ed. \nThe .nal technical twist T . S is needed because the clo\u00adsure conditions in the de.nition of bisimulation \nadd individual pairs of elements rather than adding their whole deductive closures at once. Example 4.8 \n(Protocol Encoding). As a .nal illustration of the power of our bisimulation technique (and .seal itself), \nlet us con\u00adsider a more challenging example. This example is an encoding of the protocol below, which \nis based on the key exchange protocol of Needham, Schroeder, and Lowe [14, 20]. 1. B . A: B 2. A . B: \n{NA,A}kB 3. B . A: {NA,NB,B}kA 4. A . B: {NB}kB 5. B . A: {i}NB  In this protocol, A is a server \naccepting requests from good B and evil E. It is supposed to work as follows. (1) B sends its own name \nB to A. (2) A generates a fresh nonce NA, pair it with its own name A, encrypts the pair with B s public \nkey, and sends it to B. (3) B generates a fresh key NB, tuples it with NA and B, encrypts the tuple with \nA s public key, and sends it to A. (4) A encrypts NB with B s public key and sends it to B. (5) B encrypts \nsome secret integer i with NB and sends it to A.  The idea of the encoding is as follows. We use sealing, \nunsealing and fresh seal generation as (perfect) encryption, decryption, and fresh key generation. The \nwhole system is expressed as a tuple of (functions representing) keys known to the attacker and terms \nU and V representing principals B and A. W =(.x.{x}kA ,.x.{x}kB ,kE ,U,V ) Each principal is encoded \nas a pair of the last value it sent (if any) and a continuation function waiting to receive a next mes\u00adsage. \nWhen the message is received, the function returns the next state of the principal. Communication occurs \nby a context apply\u00ading these functions in an appropriate order (when the environment is behaving normally) \nor perhaps in some strange, arbitrary order (when the environment is under the control of a malicious \nattacker). Thus, contexts play the role of the network, scheduler, and attack\u00aders. More details about \nthe encoding including a more detailed justi.cation of the claim that it is a reasonable encoding of \nthe protocol above can be found in previous work [30]. We write assert(e1);e2 as syntactic sugar for \nif e1 then e2 else .. U =(B, .{(x,y)}kB .assert(y =A); .z.({(x,z,B)}kA , .{z0}kB .assert(z0 =z); {i}z)) \nV = .x.let kx =(if x =B then kB else if x =E then kE else .)in .y.({(y,A)}kx , .{(y0,z,x0)}kA .assert(y0 \n=y); assert(x0 =x); {z}kx )) Now, take any integers i and j. We prove that the system W above ' (where \nthe secret value sent from B to A is i) and the system W below (where the secret is j) are bisimilar, \nwhich means that the protocol keeps i and j secret against attackers. ' U =(B, .{(x,y)}k' .assert(y =A); \nB .z.({(x,z,B)}k' , A .{z0}k' .assert(z0 =z); B {j}z)) ' V = .x.let kx =(if x =B then kB ' else if x \n=E then kE ' else .)in .y.({(y,A)}kx , .{(y0,z,x0)}k' .assert(y0 =y); A assert(x0 =x); {z}kx )) '' W \n=(.x.{x}k' ,.x.{x}k' ,kE ' ,U ,V ') AB The construction of the bisimulation X is by induction, following \nthe same basic pattern as Example 4.7. The base case is (0/,0/,0/). ' X. The induction rule is as follows. \nTake any (s,s ,R ).X. Take any w =[v/x]e and w ' =[v ' /x]e with (v,v ').R and Seals(e)=0/. Take any \nt .s and t '.s ' of the forms {kA,kB,kE ,kAB,kAE ,kB,k} '' '' ' and {kA' ,kB' ,kE ' ,kAB,kAE ,kB,k }. \nThen, (t,t ,T ).X for any subset T of the set S given in Figure 3. It is routine to check the conditions \nof bisimulation for this X. It is well known that the secrecy property does not hold for the original \nversion of this protocol (i.e., without Lowe s .x), in which the third message is {NA,NB}kA instead of \n{NA,NB,B}kA (i.e., the B is missing). This .aw is mirrored in our setting as well: if we tried to construct \na bisimulation for this version in the same way as above, it would fail to be a bisimulation for the \nfollowing reason. Since we would have ' ' ({(w,kB)}kA ,{(w ,kB)}k' ).S A instead of ' ' ({(w,kB,B)}kA \n,{(w ,kB,B)}k' ).S A ' along with (kAE ,kAE ) . S, we would have ({(kAE ,kB)}kA , '' ' ' {(kAE ,kB)}k' \n).S by taking w =kAE and w =kAE in the de.- A nition of X above. Since we would have (.{(y0,z)}kA .assert(y0 \n=kAE );{z}kE , ' .{(y0,z)}k' .assert(y0 =kAE );{z}k' ).S AE as well instead of (.{(y0,z,x0)}kA .assert(y0 \n=kAE );assert(x0 =E);{z}kE , ' .{(y0,z,x0)}k' .assert(y0 =kAE );assert(x0 =E);{z}k' ).S AE ' we should \nalso have ({kB}kE ,{kB}k' ).S by applying these func- E tions to the previous ciphertexts, according \nthe condition of bisim\u00adulation for functions (Condition 7). Furthermore, since (kE ,kE ' ). ' S, we would \nneed (kB,kB). S as well, according to the condi\u00adtion of bisimulation for sealed values (Condition 6). \nThen, since ({i}k B ,{j} ' ).S, we should require (i, j).S. This contradicts k B with the condition of \nbisimulation for constants (Condition 3) if i = j. Observe how the same attack is prevented in the .xed \nver\u00adsion of this protocol: the assertion assert(x0 =E)fails since x0 is bound to B.  5 Soundness and \nCompleteness Bisimilarity, written ~, is the largest bisimulation. It exists because the union of two \nbisimulations is always a bisimulation. We will need several simple lemmas about bisimulation in the \ndevelopment that follows. Lemma 5.1 (Monotonicity). Take any bisimulation X. For any ' (s,s ,R ).X and \n(t,t ' ,S).X with R .S,if (s)vXR (s ')v ', then ' (t)vXS (t ')v . ' PROOF. Immediate from the de.nitions \nof (s)vXR (s ')v and ' (t)vXS (t ')v . Lemma 5.2 (Addition of Constants). Take any bisimulation X '' \nand (s,s ,R ).X. Then, X .{(s, s ,R .{(c, c)})} is a bisimula\u00adtion for any constant c. PROOF. Straightforward \nby checking the conditions of bisimula\u00adtion. Lemma 5.3 (Addition of Fresh Seals). Take any bisimulation \nX '' and (s,s ,R ).X. Then, X .{(s {k},s {k '},R {(k, k ')})}' is a bisimulation for any k .s and k '.s \n. PROOF. Straightforward by checking the conditions of bisimula\u00adtion. We want to show that the bisimilarity \n~coincides with the contex\u00adtual equivalence =. Since we de.ned ~ by co-induction, the easy direction \nis showing that contextual equivalence implies bisimilar\u00adity. Lemma 5.4 (Completeness of Bisimilarity). \n=.~. PROOF. Since ~is the greatest bisimulation, it suf.ces to check that =is a bisimulation, which is \nroutine using the lemmas about contextual equivalence. Next, we need to prove soundness, i.e., that bisimilarity \nimplies contextual equivalence. For this purpose, we de.ne the following relation. De.nition 5.5 (Bisimilarity \nin Context). We de.ne ~ =as '' ' {(s,s ,R ,[v / x]e0,[v /x ]e0)|(s)v ~R (s )v '.Seals(e0)=0/} ' '' where \n(s) v ~R (s )v ' is a shorthand for (s)v1 ~R (s )v1 ..... '' (s)vn ~R (s )vn. ' '' We write (s)e ~(s \n)e ' for (s,s ,R ,e,e ). ~. The intuition of this de.nition is: ~ =R = =relates bisimilar values v and \nv ' put in context e0. The two lemmas below are the key properties of our bisimulation. The .rst states \nthat evaluation preserves ~=, the second that ~ =im\u00adplies observational equivalence (i.e., if evaluation \nof one expression converges, then evaluation of the other expression also converges). Lemma 5.6 (Fundamental \nProperty, Part I). Suppose '' ''' (s0)e ~ (s0)e . If (and (s0)e .(t ')w , then =s0)e .(t)w R0 ' (t)w \n~ =R (t ')w for some R .R0. PROOF. See the full version [31]. ~ Lemma 5.7 (Fundamental Property, Part \nII). If (s0)e = R0 '' '' (s0)e , then (s0)e ... (s0)e .. PROOF. See the full version [31]. An immediate \nconsequence of the previous property is that bisimu\u00adlation implies contextual equivalence. Corollary \n5.8 (Soundness of Bisimilarity). ~.=. PROOF. By the de.nitions of =and ~ =with Lemma 5.7. Combining soundness \nand completeness, we obtain the main the\u00adorem about our bisimulation: that bisimilarity coincides with \ncon\u00adtextual equivalence. Theorem 5.9. ~==. PROOF. By Lemma 5.4 and Corollary 5.8.  6 Extension with \nEquality for Sealed Values A number of variants of .seal can be considered. For example, the version \nof .seal in this paper does not allow a context to test two sealed values for equality. This is reasonable \nif the environ\u00adment is a safe runtime system (where sealing can be implemented just by tagging) which \ndisallows comparison of sealed values. It is unrealistic, however, to expect such a restriction in an \narbitrary (perhaps hostile) environment, where sealing must be implemented by encryption. Fortunately, \nour technique is extends directly to such a modest change as adding equality for sealed values. For instance, \nit is straightforward to extend .seal with syntactic equal\u00adity =1 for .rst-order values (including sealed \nvalues) along with '' an additional condition of bisimulation: v1 =1 v2 .. v1 =1 v2 for '' every (v1,v1).R \nand (v2,v2).R . Then, it is also straightforward to prove the soundness and completeness of bisimilarity \nunder this extension, with an additional lemma that ~1 (which can =respects =be proved by induction on \nthe syntax of values being compared). Of course, the more observations we allow, the more dif.cult it \nbe\u00adcomes to establish the equivalence of two given modules. For ex\u00adample, the two implementations of \ncomplex numbers given in the introduction are no longer equivalent (or bisimilar) under the exten\u00adsion \nabove, because there are many polar representations of 0 +0i while there is only one cartesian representation. \nSo, for example, a context like C[] = let x = [].from_re_and_im(0.0, 0.0) in let y = [].from_re_and_im(-1.0, \n0.0) in x =1 [].multiply x y would distinguish CartesianComplex and PolarComplex. To re\u00adcover the equivalence, \nthe polar representation of 0 +0i must be standarized and checks inserted wherever it can be created: \nlet from_re_and_im = fun (x, y) -> let z = if x = 0.0 &#38;&#38; y = 0.0 then (0.0, 0.0) else (sqrt(x \n* x+y* y), atan2(y, x)) in <seal z under k> let multiply = fun (z1, z2) -> let (r1, t1) = <unseal \nz1 under k> in let (r2, t2) = <unseal z2 under k> in let z = if r1 = 0.0 || r2 = 0.0 then (0.0, 0.0) \nelse (r1 * r2, t1 + t2) in <seal z under k>  7 Related Work As discussed in the introduction, sealing \nwas .rst proposed by Mor\u00adris [18, 19] and has been revisited in more recent work on extending the scope \n(in both informal and technical senses) of type abstrac\u00adtion in various forms [7, 12, 26, 28]. Bisimulations \nhave been studied extensively in process calculi. In particular, bisimulations for the spi-calculus [1, \n2, 5, 6] are the most relevant to this work, because the perfect encryption in spi-calculus is very similar \nto dynamic sealing in our calculus. Our bisimulation is analogous to bisimulations for spi-calculus in \nthat both keep track of the environment s knowledge. However, since processes and terms are different \nentities in spi-calculus, all the technicalities i.e., de.nitions and proofs must be developed separately \nfor pro\u00adcesses and terms. By contrast, our bisimulation is monolithic and more straightforward. Furthermore, \nit is possible even to encode and verify some (though not all) security protocols in our frame\u00adwork. \nThe encoding naturally models the concurrency among prin\u00adcipals and attackers (including so-called necessarily \nparallel at\u00adtacks) by means of interleaving. Thanks to higher-order functions, we can also imitate public-key \nencryption without extending the calculus. See our previous work [30] for further discussion about this \nencoding of security protocols. Another line of work on bisimulations in process calculi con\u00adcerns techniques \nfor lightening the burden of constructing a bisimulation e.g., Milner and Sangiorgi s bisimulation up \nto [27]. It remains to be seen whether these techniques would be use\u00adful in our setting. Note that our \noperational semantics is built upon big-step evaluation (as opposed to small-step reduction) in the .rst \nplace, which cuts down the intermediate terms and reduces the size of a bisimulation. Abramsky [4] studied \napplicative bisimulation for the .-calculus. For functions .x.e and .x.e ' to be bisimilar, it requires \nthat (.x.e)d and (.x.e ')d are observationally equivalent for any closed d, and that they evaluate to \nbisimilar values if the evaluations converge. Thus, it requires the two arguments to be the same, which \nactually makes the soundness proof harder [9]. We avoided this problem by allowing some difference between \nthe arguments of functions in our bisimulation. Jeffrey and Rathke [10] de.ned bisimulation for .-calculus \nwith name generation, of which our seal generation is an instance. Al\u00adthough their theory does distinguish \nprivate and public names, it lacks a proper mechanism to keep track of contexts knowledge of name-involving \nvalues in general, such as functions containing names inside the bodies. As a result, they had to introduce \naddi\u00adtional language constructs such as global references [10] or com\u00admunication channels [11] for the \nbisimulation to be sound. We solved this problem by using a set of relations (rather than a sin\u00adgle relation) \nbetween values as a bisimulation, i.e., by considering multiple pairs of values at once. A well-known \nmethod of proving the abstraction obtained by type abstraction is logical relations [15, 25]. Although \nthey are tradi\u00adtionally de.ned on denotational models, they have recently been studied in the syntactic \nsetting of term models as well [22, 23]. In previous work [30], we have de.ned syntactic logical relations \nfor perfect encryption and used them to prove secrecy properties of se\u00adcurity protocols. Although logical \nrelations are analogous to bisim\u00adulations in that both relate corresponding values between two dif\u00adferent \nprograms, logical relations are de.ned by induction on types and cannot be applied in untyped settings. \nMoreover, logical rela\u00adtions in more sophisticated settings (such as recursive functions and recursive \ntypes) than simply typed .-calculus tend to become rather complicated. Indeed, keys encrypting keys (as \nin security proto\u00adcols) required non-trivial extension in the logical relations above, while they imposed \nno dif.culty to our bisimulation in this paper. 8 Conclusions We have de.ned a bisimulation for .seal \nand proved its soundness and completeness with respect to contextual equivalence. There are several directions \nfor future work. One is to apply our bisimulation to more examples, e.g., to prove the full abstraction \nof our translation of type abstraction into dynamic sealing indeed, this was actually the original motivation \nfor the present work. When the target language is untyped, the translation of source term . M : t can \nbe given as let x =erase(M)in E0/ +(x,t), where E+ is de.ned like Figure 4 along with its dual E- in \na type-directed manner. In\u00adtuitively, E+ is a .rewall that protects terms from contexts, where E- is \na sandbox that protects contexts from terms. Bisimulation would help proving properties of this translation. \nWe may also be able to use such an interpretation of type abstraction by dynamic sealing as a (both formal \nand informal) basis for reasoning about type abstraction in broader settings. Another possibility is \nto de.ne and use bisimulation for other forms of information hiding, such as type abstraction. Our treatment \nof seals are analogous to the treatment of generative names in general [24, 29], of which abstract types \nare an instance as soon as they es\u00adcape from their scope (by communication [28], for example). Thus, \nE. +(x,bool)= x E. +(x,t1 \u00d7 ...\u00d7 tn)= let (y1,...,yn)=x in (E. +(y1,t1),...,E. +(yn,tn)) E. +(x,t . \ns)= .y.let z =xE. -(y,t)in E. +(z,s) E. +(x,.a.t)= .y.let z =x()in E. +(z,t) E. +(x,.a.t)= .z.E.+ ,a(x,t) \n.z E. +(x,a)= {x}.(a) E. +(x,a)= x if a . Dom(.) E. -(x,bool)= if x then true else false E. -(x,t1 \u00d7 \n...\u00d7 tn)= let (y1,...,yn)=x in (E. -(y1,t1),...,E. -(yn,tn)) E. -(x,t . s)= .y.let z =xE. +(y,t)in E. \n-(z,s) E. -(x,.a.t)= .y..z.E.- ,a(x,t) .z E. -(x,.a.t)= E. -(x,t) E. -(x,a)= let {y}.(a)=x in y else \n. E. -(x,a)= x if a . Dom(.) Figure 4. Translation of type abstraction into dynamic sealing it would \nbe possible to de.ne bisimulation for type abstraction in a similar manner to the de.nition of our bisimulation \nfor dynamic sealing. This is interesting because such bisimulation may be com\u00adplete with respect to contextual \nequivalence as in this work, while it is dif.cult to obtain complete logical relations for type abstraction \n[22, 23]. Mechanical support for bisimulation proofs is also of natural inter\u00adest. Full automation is \nhopeless, since general cases subsume the halting problem (i.e., whether the evaluation of a .-expression \ncon\u00adverges or diverges), but many of the conditions of bisimulation are easy to check or satisfy by adding \nelements to the bisimulation. One challenging point would be the case analysis on function arguments \n[u/x]d and [u ' /x]d in Condition 7, shown in detail in Example 4.4. Acknowledgements We would like to \nthank Mart\u00b4in Abadi, Andre Scedrov, Naoki Kobayashi, and the members of Programming Language Club at \nthe University of Pennsylvania for suggestions and support throughout the development of this work. \n9 References [1] Mart\u00b4in Abadi and C\u00b4edric Fournet. Mobile values, new names, and secure communication. \nIn Proceedings of the 28th ACM SIGPLAN-SIGACT Symposium on Principles of Program\u00adming Languages, pages \n104 115, 2001. [2] Mart\u00b4in Abadi and Andrew D. Gordon. A bisimulation method for cryptographic protocols. \nNordic Journal of Computing, 5:267 303, 1998. Preliminary version appeared in Program\u00adming Languages \nand Systems ESOP 98, 7th European Sym\u00adposium on Programming, Lecture Notes in Computer Science, Springer-Verlag, \nvol. 1381, pages 12 26, 1998. [3] Mart\u00b4in Abadi and Andrew D. Gordon. A calculus for cryp\u00adtographic protocols: \nThe spi calculus. Information and Com\u00adputation, 148(1):1 70, 1999. Preliminary version appeared in Proceedings \nof the 4th ACM Conference on Computer and Communications Security, pp. 36 47, 1997.   [4] Samson Abramsky. \nThe lazy lambda calculus. In David A. Turner, editor, Research Topics in Functional Programming, pages \n65 117. Addison Wesley, 1990. [5] Michele Boreale, Rocco De Nicola, and Rosario Pugliese. Proof techniques \nfor cryptographic processes. SIAM Jour\u00adnal on Computing, 31(3):947 986, 2002. Preliminary version appeared \nin 14th Annual IEEE Symposium on Logic in Com\u00adputer Science, pp. 157 166, 1999. [6] Johannes Borgstr\u00a8om \nand Uwe Nestmann. On bisimulations for the spi calculus. In 9th International Conference on Alge\u00adbraic \nMethodology and Software Technology, volume 2422 of Lecture Notes in Computer Science, pages 287 303. \nSpringer-Verlag, 2002. [7] Derek Dreyer, Karl Crary, and Robert Harper. A type sys\u00adtem for higher-order \nmodules. In Proceedings of the 30th ACM SIGPLAN-SIGACT Symposium on Principles of Pro\u00adgramming Languages, \npages 236 249, 2003. [8] Dan Grossman, Greg Morrisett, and Steve Zdancewic. Syn\u00adtactic type abstraction. \nACM Transactions on Programming Languages and Systems, 22(6):1037 1080, 2000. [9] Douglas J. Howe. Proving \ncongruence of bisimulation in functional programming languages. Information and Com\u00adputation, 124(2), \n1996. [10] Alan Jeffrey and Julian Rathke. Towards a theory of bisimu\u00adlation for local names. In 14th \nAnnual IEEE Symposium on Logic in Computer Science, pages 56 66, 1999. [11] Alan Jeffrey and Julian Rathke. \nA theory of bisimulation for a fragment of concurrent ML with local names. Theoretical Computer Science, \n2003. To appear. An extended abstract appeared in 15th Annual IEEE Symposium on Logic in Com\u00adputer Science, \npp. 311 321, 2000. [12] James J. Leifer, Gilles Peskine, Peter Sewell, and Keith Wans\u00adbrough. Global \nabstraction-safe marshalling with hash types. In Proceedings of the Eighth ACM SIGPLAN International \nConference on Functional Programming, pages 87 98, 2003. [13] Barbara Liskov. A history of CLU. In The \nSecond ACM SIG-PLAN Conference on History of Programming Languages, pages 133 147, 1993. [14] Gavin Lowe. \nAn attack on the Needham-Schroeder public\u00adkey authentication protocol. Information Processing Letters, \n56(3):131 133, 1995. [15] John C. Mitchell. On the equivalence of data representations. In Arti.cial \nIntelligence and Mathematical Theory of Compu\u00adtation: Papers in Honor of John McCarthy, pages 305 330. \nAcademic Press, 1991. [16] John C. Mitchell and Gordon D. Plotkin. Abstract types have existential types. \nACM Transactions on Programming Languages and Systems, 10(3):470 502, 1988. Preliminary version appeared \nin Proceedings of the 12th ACM SIGACT-SIGPLAN Symposium on Principles of Programming Lan\u00adguages, pages \n37 51, 1985. [17] James H. Morris Jr. Lambda-Calculus Models of Program\u00adming Languages. PhD thesis, Massachusetts \nInstitute of Tech\u00adnology, 1968. [18] James H. Morris Jr. Protection in programming languages. Communications \nof the ACM, 16(1):15 21, 1973. [19] James H. Morris Jr. Types are not sets. In Proceedings of the 1st \nAnnual ACM SIGACT-SIGPLAN Symposium on Prin\u00adciples of Programming Languages, pages 120 124, 1973. [20] \nRoger Needham and Michael Schroeder. Using encryption for authentication in large networks of computers. \nCommunica\u00adtions of the ACM, 21(12):993 999, 1978. [21] Benjamin Pierce and Eijiro Sumii. Relating cryptography \nand polymorphism, 2000. Manuscript. http://www.yl.is.s. u-tokyo.ac.jp/ sumii/pub/. [22] Andrew M. Pitts. \nExistential types: Logical relations and operational equivalence. In Proceedings of the 25th Inter\u00adnational \nColloquium on Automata, Languages and Program\u00adming, volume 1443 of Lecture Notes in Computer Science, \npages 309 326. Springer-Verlag, 1998. [23] Andrew M. Pitts. Parametric polymorphism and operational equivalence. \nMathematical Structures in Computer Science, 10:321 359, 2000. Preliminary version appeared in HOOTS \nII Second Workshop on Higher-Order Operational Techniques in Semantics, Electronic Notes in Theoretical \nComputer Sci\u00adence, vol. 10, 1998. [24] Andrew M. Pitts and Ian Stark. Observable properties of higher \norder functions that dynamically create local names, or: what s new? In Mathematical Foundations of Computer \nScience, volume 711 of Lecture Notes in Computer Science, pages 122 141. Springer-Verlag, 1993. [25] \nJohn C. Reynolds. Types, abstraction and parametric poly\u00admorphism. In Information Processing 83, Proceedings \nof the IFIP 9th World Computer Congres, pages 513 523, 1983. [26] Andreas Rossberg. Generativity and \ndynamic opacity for ab\u00adstract types. In Proceedings of the 5th International ACM SIGPLAN Conference on \nPrinciples and Practice of Declara\u00adtive Programming, pages 241 252, 2003. [27] Davide Sangiorgi and Robin \nMilner. The problem of weak bisimulation up to . In CONCUR 92, Third International Conference on Concurrency \nTheory, volume 630 of Lecture Notes in Computer Science, pages 32 46. Springer-Verlag, 1992. [28] Peter \nSewell. Modules, abstract types, and distributed ver\u00adsioning. In Proceedings of the 28th ACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages, pages 236 247, 2001. [29] Ian Stark. Names and Higher-Order \nFunctions. PhD thesis, University of Cambridge, 1994. http://www.dcs.ed.ac. uk/home/stark/publications/thesis.html. \n[30] Eijiro Sumii and Benjamin C. Pierce. Logical relations for en\u00adcryption. In 14th IEEE Computer Security \nFoundations Work\u00adshop, pages 256 269, 2001. Long version to appear in the Journal of Computer Security. \n[31] Eijiro Sumii and Benjamin C. Pierce. A bisimulation for dynamic sealing. http://www.cis.upenn.edu/ \nsumii/, 2003. [32] Steve Zdancewic, Dan Grossman, and Greg Morrisett. Prin\u00adcipals in programming languages: \nA syntactic proof tech\u00adnique. In Proceedings of the Fourth ACM SIGPLAN Interna\u00adtional Conference on Functional \nProgramming, pages 197 207, 1999.  \n\t\t\t", "proc_id": "964001", "abstract": "We define &#955;<inf>seal</inf>, an untyped call-by-value &#955;-calculus with primitives for protecting abstract data by <i>sealing</i>, and develop a bisimulation proof method that is sound and complete with respect to contextual equivalence. This provides a formal basis for reasoning about data abstraction in open, dynamic settings where static techniques such as type abstraction and logical relations are not applicable.", "authors": [{"name": "Eijiro Sumii", "author_profile_id": "81100019964", "affiliation": "University of Pennsylvania", "person_id": "P75950", "email_address": "", "orcid_id": ""}, {"name": "Benjamin C. Pierce", "author_profile_id": "81100303310", "affiliation": "University of Pennsylvania", "person_id": "PP14111353", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/964001.964015", "year": "2004", "article_id": "964015", "conference": "POPL", "title": "A bisimulation for dynamic sealing", "url": "http://dl.acm.org/citation.cfm?id=964015"}