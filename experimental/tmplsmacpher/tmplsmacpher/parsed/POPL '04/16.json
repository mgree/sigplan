{"article_publication_date": "01-01-2004", "fulltext": "\n A Semantics for Web Services Authentication C\u00b4Microsoft Research Microsoft Research Microsoft Research \nKarthikeyan Bhargavan edric Fournet Andrew D. Gordon Abstract We consider the problem of specifying and \nverifying cryptographic security protocols for XML web services. The security speci.ca\u00adtion WS-Security \ndescribes a range of XML security tokens, such as username tokens, public-key certi.cates, and digital \nsignature blocks, amounting to a .exible vocabulary for expressing protocols. To describe the syntax \nof these tokens, we extend the usual XML data model with symbolic representations of cryptographic values. \nWe use predicates on this data model to describe the semantics of security tokens and of sample protocols \ndistributed with the Mi\u00adcrosoft WSE implementation of WS-Security. By embedding our data model within \nAbadi and Fournet s applied pi calculus, we for\u00admulate and prove security properties with respect to \nthe standard Dolev-Yao threat model. Moreover, we informally discuss issues not addressed by the formal \nmodel. To the best of our knowledge, this is the .rst approach to the speci.cation and veri.cation of \nsecu\u00adrity protocols based on a faithful account of the XML wire format. Categories and Subject Descriptors: \nF.3.2 [Theory of Computa\u00adtion]: Logics and meanings of programs Semantics of Program\u00adming Languages General \nTerms: Security, Languages, Theory, Veri.cation Keywords: Web Services, Applied Pi Calculus, XML Security \n 1 Motivations and Outline Over the past few years, a growing list of speci.cations has been de.ning \naspects of XML web services. Security is a serious con\u00adcern and is addressed, in particular, by the recent \nWS-Security spec\u00adi.cation [3]. This speci.cation provides an XML vocabulary for designing cryptographic \nprotocols, is widely implemented, and is undergoing standardization at OASIS [28]. Still, it provides \nno for\u00ad mal basis for stating security goals or reasoning about correctness. The trouble is, new cryptographic \nprotocols are often .awed, XML or no XML. Meanwhile, there has been a sustained and successful effort \nto de\u00advelop formalisms for expressing and verifying cryptographic proto\u00adcols ([5, 9, 10, 19, 22, 24, \n31, 35] etc). Formal methods can verify various security properties against a standard threat model based \non an opponent able to monitor and manipulate messages sent over the network. Such veri.cations are typically \nof abstract versions of pro- Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \npro.t or commercial advantage and that copies bear this notice and the full citation on the .rst page. \nTo copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. POPL 04, January 14 16, 2004, Venice, Italy. Copyright 2004 ACM 1-58113-729-X/04/0001 \n...$5.00 tocols, expressed using .xed, high-level, ad-hoc message formats, rather than the ordered-tree-with-pointers \nsyntax of XML. This paper brings these developments together. We introduce a language-based model for \nXML security protocols, and establish process calculus techniques for verifying authentication properties \nfor a wide class of WS-Security protocols. Background: Web Services Security. Web services are a dis\u00adtributed \nsystems technology based on network endpoints exchang\u00ading SOAP [6] envelopes XML documents with a mandatory \nBody element containing a request, response, or fault element, together with an optional Header element \ncontaining routing or security information. SOAP allows for network intermediaries such as routers or \n.rewalls to process an envelope, by adding or modify\u00ading headers. Examples of web services include Internet-based \nser\u00advices for ordering books or invoking search engines, and intranet\u00adbased services for linking enterprise \napplications. A common technique for securing SOAP exchanges is to rely on a lower-level secure tunnel \nbetween the endpoints, typically an SSL connection. This works well in many situations, but has the usual \ndisadvantages of transport-level security: the secrecy or integrity of messages can be guaranteed while \nin the tunnel, but not subse\u00adquently in .les or databases, and they may not match the security re\u00adquirements \nof the application. Pragmatically, client authentication is often performed by the application rather \nthan by SSL. Besides, SSL does not .t SOAP s message-based architecture: intermedi\u00adaries cannot see the \ncontents of the tunnel, and so cannot route or .lter messages. To better support end-to-end security \n[32], WS-Security de.nes how to sign or encrypt SOAP messages without relying on a se\u00adcure transport. \nA central but informal abstraction is the security token, which covers data making security claims, such \nas user iden\u00adti.ers, cryptographic keys, or certi.cates. WS-Security provides a precise syntax for multiple \ntoken formats, such as XML username tokens and XML-encoded binary tokens conveying X.509 public\u00adkey certi.cates \nor symmetric keys. It also speci.es syntax for ap\u00adplying encryption and signature to selected elements \nof SOAP mes\u00adsages. Like many traditional protocol speci.cations, WS-Security details message formats \nsuch as the names of XML tags rather than security goals and their enforcement, thereby focusing on in\u00adteroperability \nrather than security. Although it gives a syntax for a broad range of protocols, WS-Security also emphasizes \n.exibility, and does not de.ne any particular protocol. As a result, for each given WS-Security compliant \nprotocol, security goals still have to be carefully speci.ed and validated. Background: Security Protocol \nVeri.cation. This paper ad\u00addresses authentication properties of XML-based security protocols against \na standard threat model: an opponent able to read, replay, redirect, and transform messages, but who \ncannot simply guess se\u00adcrets. Needham and Schroeder describe such an opponent in their pioneering work \non cryptographic protocols [29]. The .rst formal\u00ad ization was by Dolev and Yao [15]. A great many formal \nmethods have been deployed to verify protocols against this threat model, with particular progress in \nthe past few years. This paper uses Abadi and Fournet s applied pi calculus [1, 18] as the underlying \nspeci.cation language for protocols, and relies on proof techniques from concurrency theory. In this \napproach, the opponent is simply an arbitrary context within the calculus; the scoping rules of the pi \ncalculus ensure that the opponent cannot learn names representing secrets such as passwords. We formalize \nauthentication properties using standard correspon\u00addence assertions [37], as embedded within the pi calculus \nby Gor\u00ad don and Jeffrey [19]. These assertions are based on two kinds of events, which can be thought \nof as log.le entries by protocol par\u00adticipants. A begin-event marks the initiation of a run of a protocol, \nwhile an end-event marks the commitment that a run has correctly completed. Event labels include data \nidentifying the run, such as the names of the client and server, message identi.er, and payload. A protocol \nis safe if in every run, every end-event corresponds to a previous begin-event with the same label. Moreover, \na protocol is robustly safe if it is safe in the presence of an arbitrary oppo\u00adnent process. Robust safety \nestablishes message authentication, and rules out a range of attacks. This Paper. We tackle the problem \nof formal reasoning about XML-encoded cryptographic protocols. The interest and novelty in this problem \narises not from the XML syntax itself, but from the need to model low-level detail, in particular, the \n.exibility and hierarchical structure of XML signatures [17], designed to tolerate changes to the headers \nof a SOAP message over its lifetime. We base our approach on three formalisms: a symbolic syntax for \nXML with cryptography and a predicate language for de.ning ac\u00adceptable messages both de.ned in Section \n2 and a specialized version of the applied pi calculus. We explain the purpose of each of these in turn. \nFirst, to represent XML messages with embedded cryptography, we enrich the standard XML data model with \nan abstract syntax for embedded byte arrays and cryptographic functions. Formally, we de.ne a many-sorted \nalgebra with sorts for the usual constructs of XML strings, attributes, and so on plus a new sort of \nsym\u00adbolic byte arrays, in the style of Dolev and Yao, to represent cryp\u00adtographic materials embedded \nin XML. Second, to de.ne the semantics of security tokens and validity con\u00additions on messages, we introduce \na Prolog-like language of predi\u00adcates on XML data. By insisting on .delity to the low-level XML format, \nwe are confronted with the dif.culty of de.ning rather intri\u00adcate conditions of message acceptability, \nand hence we need some language of predicates on XML. It may be possible to extend some standard type \nsystem or query language for XML (such as DTDs, XML Schema, or XPath) to express conditions on cryptographic \nvalues. Instead, for the sake of simplicity and being self-contained, we rely on a fairly standard Horn-clause \nlogic. Third, to describe complete protocols, we embed these messages and predicates within the applied \npi calculus. We state and prove protocol properties against a large class of contexts representing at\u00adtackers. \nApplied pi is parameterized in general by an arbitrary equa\u00adtional theory of terms, which we specialize \nto our data model for XML with cryptography. We obtain a calculus expressive enough to implement our \npredicates, and to describe complex protocol con\u00ad.gurations. In Section 3, given these notations, we \nformalize the security goals and message formats of a series of sample protocols. These proto\u00adcols illustrate \na range of WS-Security concepts including message identi.ers, password digests, username tokens, X.509 \npublic-key certi.cates, XML signatures based on both password-derived keys and certi.cates, and processing \nby SOAP intermediaries as well as end-points. For each protocol, we give predicates describing ac\u00adceptable \nmessages, and state authentication goals using the usual message-sequence notation. WS-Security itself \nde.nes a formal syntax for messages, but gives only an informal account of the secu\u00adrity checks performed \nby compliant implementations, as each token is processed in the SOAP protocol stack. Through formalizing \nthe series of protocols, we accumulate a collection of re-usable predi\u00adcates re.ecting the semantics \nof these tokens. Hence, we obtain a .rst formal semantics for a signi.cant fragment of WS-Security. In \nSection 4, we formalize the message-sequence notation within the applied pi calculus so as to verify \nour authentication goals. We explain the structure of the proof of one of the sample protocols from Section \n3. The proofs are compositional, and rely on identi\u00adfying a trusted computing base embodying the essential \nchecks underlying the protocol. In Section 5, we conclude, and discuss related and future work. A technical \nreport [4] provides details omitted in this version of the paper, including sample SOAP messages obtained \nexperimentally for the protocols of Section 3, a brief overview of the applied pi calculus calculus, \nand detailed proof of all our protocols. Contributions. In summary, we make three main contributions: \n(1) A new data model and predicate language for describing XML-level cryptographic protocols. Fidelity \nto the detailed messaging format enables us to ad\u00address its subtleties, such as the interpretation of \ncompound signatures. (2) A collection of predicates de.ning a semantics for the security tokens of WS-Security \nand related speci.cations. We cover only a substantial fragment of WS-Security, but our semantics does \nestablish the feasibility of applying our formal developments to a large class of protocols. (3) Proofs \nfor a series of concrete protocols drawn from the WSE distribution.  At an abstract level, the protocols \nwe consider are quite sim\u00adple. Still, we have encountered vulnerabilities to XML rewrit\u00ading attacks in \nimplementations of these conceptually simple protocols. So it is worth establishing correctness at this \nlevel, and indeed the formal Dolev-Yao properties are non-trivial.  2 Symbolic Cryptography in XML The \ncore of our data model or abstract syntax for XML trees is adapted from Sim\u00b4 eon and Wadler s grammar \nfor XML [34]. XML Data Model: Standard Core Tag ::= anyLegalXmlName XML name str:string ::= any legal \nXML string XML string a : att ::= Tag=\"str\" attribute as : atts i:item is:items Elem ::= a as | e ::= \nElem | str ::= i is | e ::= <Tag as>is</Tag> attribute sequence item item sequence element Our data \nmodel represents valid, parsed XML. It resembles the XML infoset recommendation [11] but with some differences. \nFor  the sake of clarity, we completely suppress information about XML namespaces, and the document \n<?xml ...> directive. As a minor technical convenience, we model an element s attributes as an or\u00addered \nsequence rather than a set. (This also re.ects the capability of an attacker to observe ordering information.) \nOur syntax is intentionally close to the standard XML wire for\u00admat, but for brevity we rely on three \nnotational conventions. First, although formally an element s attributes as and body is are re\u00adcursively \nde.ned lists, we typically use a standard tuple notation for .xed-length sequences. Second, instead of \nwriting an element <Envelope></Envelope>, say, in full, we drop the tag from the closing bracket, and \nsimply write <Envelope></>. Third, when writing an element that spans several lines, we rely on indentation \n(as in Haskell or Python) to delimit the body, and so omit the clos\u00ading bracket. Conventions for Sequences \nand Elements: D a1 ... an = a1 (... (an e)):atts for n = 0; similarly for items. D <Tag as>is</> = <Tag \nas>is</Tag> . <Tag as> . . i1 D . = <Tag as>i1 \u00b7\u00b7\u00b7in</> . . . . in Formally, our data model is a many-sorted \nalgebra, based on the sorts string, att, atts, item, items, plus a sort bytes for binary data. We embed \nthis algebra within the applied pi calculus as described in Section 4. The complete algebra is given \nby the XML Data Model table above plus two more below. We need the following general de.nitions. We let \nT , U, V range over terms of arbitrary sort in the algebra, and write T : string, for example, to mean \nthat T belongs to the sort string. Throughout we assume that terms, predicates, and equations are well-sorted, \nbut for the sake of brevity keep the details implicit. In addition to the syntax de.ned in this section, \nterms include sorted variables, x,y,z,... .We let fv(T ) be the set of variables occurring in a term \nT . We say a term T is closed if and only if fv(T )= \u00d8. Otherwise, we say the term is open an open term \nrepresents a closed term with some undetermined subterms, represented by the variables. We let s range \nover parallel substitutions {xx = Vx} of the terms Vxfor the variables xx, and we de.ne dom({xV }) Dx}. \nWe say that a x = x= {xsubstitution s is closed if and only if s(x) is a closed term for each x . dom(s). \nWe let Vxrange over vectors V1, ..., Vn of terms, and similarly xx ranges over vectors x1, ..., xn of \nvariables. We often treat such vectors as sets. Next, we extend the standard data model with a symbolic \nrepre\u00adsentation of cryptography and related operations. We introduce a sort bytes representing byte arrays, \nand extend string with Base64\u00adencoded arrays (base64(x)). We assume there is an in.nite set of atomic, \nabstract names, ranged over by s. Each name is either of sort bytes or string. We use these names to \nrepresent arbitrary, un\u00adstructured cryptographic materials such as passwords and keys. We let fn(T ) \nbe the set of names occurring in a term T . XML Data Model: Byte Arrays, Symbolic Cryptography x: bytes \n::= byte array (not itself XML) s abstract name (key, nonce) concat(x1, x2:bytes) array concatenation \nc14n(i:item) canonical bytes of an item utf8(str:string) UTF8 representation of strings sha1(x:bytes) \ncryptographic digest p-sha1(pwd: string,salt:bytes) key from salted password hmac-sha1(key,x : bytes) \nkeyed hash pk(kpriv :bytes) map from private to public key rsa-sha1(x,kpriv :bytes) public key signature \nx509(sr :bytes,u:string,a : string,kpub :bytes) X.509 certi.cate str:string ::= XML string s abstract \nname (password) base64(x:bytes) Base64-encoding of byte array principal(pwd:string) map from password \nto principal The exact choice of primitives is a little arbitrary; we include enough operations here \nfor the protocols of Section 3. The term concat(x1,x2) represents the concatenation of the two arrays \nx1 and x2. The term c14n(i) represents the array obtained by canonical\u00adizing the XML represented by i, \naccording to some standard algo\u00adrithm [7, 8]. (In fact, for our purposes, c14n is simply a way of symbolically \ntreating an XML item as a byte array; our c14n does not sort attribute lists, for example.) The term \nutf8(str) represents the UTF8 encoding of the XML string str. The term sha1(x) repre\u00adsents the one-way \nSHA1 hash of the x array. The term p-sha1(pwd, salt) represents a key obtained by hashing the pwd password \nand the salt array [14]. The term hmac-sha1(key,x) represents a keyed hash of the x array using the key \narray as the key [23]. The term pk(kpriv) represents the public key associated with a private signing \nkey kpriv. The term rsa-sha1(x,kpriv) is a public-key signature of x under the private key kpriv [21]. \nThe term x509(sr,u, a,k) repre\u00adsents a basic X.509 public-key certi.cate, where sr is the private signing \nkey of the certi.er and u, a, k are the signed user name, algorithm, and key for a given principal. (Such \nbinary certi.cates can be embedded as XML items; they are used here to carry public keys for the asymmetric \nsigning algorithm rsa-sha1.) Finally, the term principal(pwd) is used to represent a database of user \nnames associated with secrets, such as passwords, and is explained in Sec\u00adtion 3.2. Our threat model \nis that SOAP messages may be intercepted, de\u00adcomposed, modi.ed, assembled, and replayed by the attacker \n[15, 29]. The following selector functions and inverses symbolically represent the ability of the attacker \nto decompose messages. It is deliberate that there are no inverses for the three hash functions (sha1, \np-sha1, and hmac-sha1), and for the public-key (pk) and user name (principal) maps; the attacker cannot \nreverse these one\u00adway functions. XML Data Model: Selectors and Inverses x: bytes ::= byte array fst(x \n: bytes) left part of concat snd(x:bytes) right part of concat i-base64(str:string) inverse of base64 \nx509-key(cert :bytes) public key in X.509 certi.cate check-x509(cert,kr : bytes) X.509 certi.cate veri.cation \ncheck-rsa-sha1(x,sig, kpub : bytes) public key veri.cation str:string ::= XML string Tag.parm(a:att) \nstring param of Tag-attribute i-utf8(x:bytes) inverse of utf8 x509-user(cert :bytes) name in X.509 certi.cate \nx509-alg(cert :bytes) algorithm in X.509 certi.cate a : att ::= attribute hd(as : atts) head of a sequence \nas : atts ::= attributes Tag.att(i:item) attributes of Tag-element tl(as:atts) tail of a sequence i:item \n::= item hd(is:items) head of a sequence i-c14n(x : bytes) inverse of c14n is:items ::= items Tag.body(i:item) \nbody of Tag-element tl(is :items) tail of a sequence Most of these selectors are straightforward inverses \nwith single ar\u00adguments. The two exceptions are check-x509 and check-rsa-sha1. The term check-x509(cert,kr) \nchecks that the certi.cate cert is signed with a private key associated with the public key kr, and yields \nkr if this succeeds. The term check-rsa-sha1(x,sig, kpub) checks that sig is the rsa-sha1 signature of \nx under the private key corresponding to the public key kpub and yields kpub if this succeeds. (Some \nof the inverses, such as the functions fst and snd, would be impossible to implement in general, and \nwe do not rely on them to program compliant principals; they exist to represent the possibil\u00adity of the \nattacker correctly guessing, for example, how to divide an array obtained by concatenation into its original \ntwo halves.) We represent evaluation of selectors and inverses by an equivalence, U = V , the least \nsort-respecting congruence induced by the follow\u00ading axioms. Equivalence of Terms of the Data Model: \nU = V hd(a as)= a tl(a as)= as hd(i is)= i tl(i is)= is Tag.att(<Tag as>is</>)= as i-base64(base64(x)) \n= x Tag.body(<Tag as>is</>)= is i-utf8(utf8(str)) = str Tag.parm(Tag=\"str\")= str i-c14n(c14n(i)) = i \nfst(concat(x1,x2)) = x1 snd(concat(x1,x2)) = x2 x509-user(x509(sr,u,a, k)) = u x509-alg(x509(sr,u, a,k)) \n= a x509-key(x509(sr,u,a,k)) = k check-x509(x509(sr,u,a,k), pk(sr)) = pk(sr) check-rsa-sha1(x,rsa-sha1(x,kpriv),pk(kpriv)) \n= pk(kpriv) In the absence of additional equivalences between terms, we im\u00adplicitly assume that our cryptographic \noperations have no addi\u00adtional interactions. For instance, the hash functions sha1, p-sha1, hmac-sha1, \nand rsa-sha1 are independent here. This can be infor\u00admally checked from their cryptographic speci.cations \n[16, 14, 23, 21], or modelled as a re.nement of the term equivalence, as in [1]. We end this section \nby de.ning a logical notation for predicates on XML terms. Formally, we present a Horn logic over our \nmany\u00adsorted algebra, with primitive formulas for equality and list mem\u00adbership, but no recursively-de.ned \npredicates. Our notation is sim\u00adple, and suf.ces for reasoning about security; other languages fea\u00adture \nmore expressive pattern-matching for XML, but their seman\u00adtics would be harder to formalize. We assume \nthere is a .xed, .nite set of predicates, ranged over by p. For each predicate p, we assume there is \na single de.nition p(x ) :-F1 .\u00b7\u00b7\u00b7.Fn, where each Fi is a formula, and n > 0. (When n > 1, we usually \npresent each clause p(x ) :-Fi separately, in the style of Prolog.) Next, we de.ne the syntax of formulas. \nSyntax of Formulas and Predicate De.nitions: F ::= formula V = T term comparison U . V list membership \np(Vx) predicate instance F1,F2 conjunction p(x ) :-F1 .\u00b7\u00b7\u00b7. Fn de.nition of predicate p with n > 0 We \nassume that formulas are well-sorted according to the following rules: in V = T both terms belong to \nthe same sort; in U . V either U : item and V : items or U : att and V : atts; in p(Vx) when p(x ) :\u00ad \nF1 .\u00b7\u00b7\u00b7. Fn, the length and sorts of Vxmatch the length and sorts of x . Let p contribute to q if and \nonly if an instance p(Vx) occurs in one of the disjuncts de.ning q. We stipulate that this relation is \nwell\u00adfounded, to avoid recursively-de.ned predicates. We let fv(F) be the free variables of all the terms \noccurring in F, and in particular, fv(p(V1,...,Vn)) D \u00b7\u00b7. fv(Vn). In any clause p(x ) :-F, = fv(V1) .\u00b7we \nsay that each z . fv(F) \\ x is a local variable. By convention, each occurrence in a clause of the wildcard \nsymbol is short for the only occurrence of a fresh local variable. Local variables are existentially \nquanti.ed in our semantics; we identify clauses up to the consistent renaming of local variables. Semantics \nof Formulas: |= F where fv(F)= \u00d8 D |= V =T =(V =T ) D |= U . V =(V = U1 ... Ui U V \") for some U1, \n..., Ui, V \", with i = 0 V ) D x |= p(x= |= Fi{x = Vx}{xz = U} for some i . 1..n and closed terms Ux \nwhere p(x ) :-F1 .\u00b7\u00b7\u00b7. Fn and xz = fv(Fi) \\ x D |= F1,F2 = |= F1 and |= F2 A formula F is valid if \nwe have |= Fs whenever fv(Fs)= \u00d8. For open formulas, we introduce a logical equivalence. Logical Equivalence \nof Formulas: Two formulas F, F\" are logically equivalent when, for all substitu\u00adtions s such that Fs \nand F\"s are closed, we have |= Fs iff |= F\"s.  3 Example Protocols This section describes some WS-Security \nprotocols, whose goal is to authenticate access to a basic web service. We .rst present a typical (unauthenticated) \nweb service, then successively re.ne it by introducing password-based digests, signatures, X.509 certi.cates, \nand a .rewall intermediary. The .rst four protocols are taken from the samples provided with WSE 1.0 \n[26]; we used the actual SOAP messages produced by this implementation to experimentally val\u00adidate our \nmodel. (The technical report includes sample messages produced by WSE.) 3.1 An (Unauthenticated) Web \nService We consider a typical e-commerce website application where cus\u00adtomers can browse and purchase \nitems [25]. The orders are stored on a database server, and can be retrieved and viewed on later vis\u00adits. \nFor security, customers are required to login, with username and password, before placing and retrieving \norders. In addition to the standard website interface, the server provides a SOAP web ser\u00advice GetOrder \nthat a customer may invoke to retrieve their order in XML format, to save it as a receipt, for instance. \nOur aim is to pro\u00advide the same level of security for this web service as the website login. A call to \nGetOrder consists of a SOAP request and a SOAP re\u00adsponse. We introduce predicates to describe these messages. \nAs a .rst example, a valid SOAP message is an XML Envelope, con\u00adtaining a Header and a Body. The predicate \nhasBody(e, b) below means b is the body of envelope e (the wildcard matches any\u00adthing): hasBody(e : item,b \n: item) :\u00ad e = <Envelope><Header> </>b</>, b = <Body > </>. The SOAP request for GetOrder is an envelope, \nwhere the body encodes the parameters of the call. The resulting SOAP response has a body containing \nthe order, in XML: isGetOrder(b : item,OrderId : string) :\u00adb = <Body > <GetOrder> <orderId>OrderId</> \n isGetOrderResponse(b : item,OrderId : string, u : string) :\u00adb = <Body > <GetOrderResponse> <orderId>OrderId</> \n<date> </> <userId>u</> We suppose there is a single server, identi.ed by the URL S, hosting the GetOrder \nweb service, identi.ed by the URI W, and multiple client computers that may connect to S on behalf of \nusers. Here is a protocol for a client computer, identi.ed by its IP address I, to request information \nabout order number OrderId from the web service W on server S, on behalf of a human user u. Message 1: \nI . S,We where hasBody(e,b), isGetOrder(b,OrderId) Message 2: S . Ie\" where hasBody(e,b\"), and isGetOrderResponse(b\" \n,OrderId,u\") Message 1 is an HTTP POST request to the URL S, with an HTTP header SOAPAction: W, and \nwith the SOAP en\u00advelope e as its content. The predicates hasBody(e,b) and isGetOrder(b,OrderId) specify \nthe behaviour of both client and server: that is, a client will only send Message 1, and a server will \nonly accept it, if the message e is a suitably for\u00admatted request for some order OrderId. We implicitly \nspecify that if the server receives a message that does not satisfy these predicates, it will reject \nthe message.  Message 2 is the HTTP response, containing the SOAP en\u00ad  velope e. The predicates hasBody(e,b\") \nand isGetOrder\u00adResponse(b\" ,OrderId,u\") constrain the server to send a reply that concerns the order \nOrderId requested in Message 1. In this .rst protocol, the user u whose client computer sends the request \nneed not be the same as the user u\" who is associated with the order. It is not a goal here to fully \nspecify the correct behaviour of ei\u00adther client or server. We are only concerned about security prop\u00aderties, \nand authentication in particular, and suppress other infor\u00admation. For example, we suppress the rest \nof the response, which includes details such as the credit card type, number and expiration date, billing \nand shipping addresses, and the sequence of line items in the order. Our predicates express constraints \non messages sent and received by compliant implementations of our protocols. On the sender side, they \nexpress post-conditions for every outgoing message. On the receiver side, they express pre-conditions \nthat must be checked be\u00adfore incoming messages are processed. In the presence of an active attacker, \nit is essential that the receiver dynamically check these conditions, even if the sender enforces them. \nOur .rst protocol offers no protection against active attacks, since any well-formed envelope is accepted \nby the server.  3.2 Password Digest Username tokens with a cryptographic digest provide a .rst, basic \nmechanism for authenticating web service requests. Such tokens include a username identity u, together \nwith a digest of a password and a fresh timestamp. We assume that each password pwdu is a shared, unguessable \nsecret between u and S, so that only u (or S, in principle) can generate a valid digest this hypothesis \nexcludes dictionary attacks, for instance. (To justify this assumption, pass\u00adwords need to be strong \ncryptographic secrets; one might also mod\u00adify the protocol to encrypt the digest of a weak password, \nbut we do not pursue this alternative.) Moreover, as in other applications of the applied pi calculus, \nwe abstractly relate the password and the user using the special one-way function principal from passwords \nto users: we let u stand for principal(pwdu). To model this protocol, we develop predicates for describing \nWS-Security headers and embedded username tokens. (Our predicate de.nitions are not speci.c to this protocol, \nand can be re-used for any protocol relying on these tokens.) First, we de.ne a predicate to extract \nthe security tokens from some security header of the enve\u00adlope: the predicate hasSecurityHeader(e, toks) \nmeans that toks is a sequence of security tokens attached to message e. The .rst formula in the predicate \nbody extracts the list of headers (headers : items) from the envelope. The second formula, header . headers, \nmeans that header is some member of the header list. The third formula means that header must be a security \nheader, and extracts the secu\u00adrity tokens from it. hasSecurityHeader(e : item,toks : items) :\u00ade = <Envelope><Header>headers</> \n</>, header . headers, header = <Security>toks</>. With username tokens, the unique identi.er of a message \nis a pair (n : bytes,t : string) where n is a nonce some byte array and t is a timestamp represented \nas a string. The predicate isDigest-UserToken(tok, u,pwd,n,t) means that tok is a username token for \nuser u with password pwd, identi.er (n,t), and a valid digest. isDigestUserToken(tok : item,u,pwd : string,n \n: bytes,t : string) :\u00ad tok = <UsernameToken > <Username>u</> <Password Type=\"PasswordDigest\">base64(d)</> \n<Nonce>base64(n)</> <Created>t</>, u = principal(pwd), d = sha1(concat(n,concat(utf8(t),utf8(pwd)))). \n Finally, a top-level authentication predicate, hasUserTokenDigest, gathers all the conditions checked \non envelopes received by the server. hasUserTokenDigest(e,u,pwd,n,t,b) means that the enve\u00adlope e with \nbody b contains a valid username token for u,pwd,n,t. hasUserTokenDigest(e : item,u,pwd : string, n : \nbytes,t : string,b : item) :\u00ad hasSecurityHeader(e,toks), utok . toks, isDigestUserToken(utok,u,pwd,n,t), \nhasBody(e,b). The following protocol description includes both SOAP messages and additional begin-and \nend-events, in the style of Woo and Lam [37]. We use these events to express the authentication guar\u00ad \nantee obtained by the server from running this protocol. Event 1: I logs <Begin>unt</> Message 1: I . \nS,We where hasUserTokenDigest(e,u, pwd,n,t,b), and isGetOrder(b,OrderId) Event 2: S logs <End>unt</> \nMessage 2: S . Ie. where hasBody(e,b\"), and isGetOrderResponse(b\" ,OrderId,u) We interpret events in \nthe abstract log as follows: before issuing a request, the initiator logs its intent as an entry <Begin>unt</> \nthat contains the user name u and the message identi.er. Conversely, af\u00adter checking an envelope, the \nserver logs <End>unt</> to manifest that it accepts a request with these parameters. In any case, the \nat\u00adtacker cannot log entries. Ideally, begin-and end-events should be in direct correspondence, but this \nis clearly not the case if the at\u00adtacker can delete, reorder, or replay u s messages. Instead, we have \nthe following correspondence property: CLAIM 1. In the presence of an active Dolev-Yao attacker, if <End>unt</> \nis logged by S, then <Begin>unt</> has been logged by I. This is a fairly weak authentication property, \nwhich can be read as if S accepts a request from u, then u recently sent some re\u00adquest . The two requests \nare not necessarily the same: for in\u00adstance, an active attacker can intercept the envelope, modify its \nbody, and pass it to the server. In many settings, it may be suit\u00adable to have a richer correspondence \nbetween u and S s actions, for example between entries <Begin>u S W n t OrderId</> and <End>u S W n t \nOrderId</>. Although the password digest is optional in WS-Security username tokens, our claim would \nclearly not hold if the server accepted tokens without checking the digest, since the attacker could \nthen forge a message with any identi.er (n,t) irrespective of the user s requests. In itself, our protocol \ndoes not eliminate replays. (Technically, our correspondence assertion is non-injective.) However, since \nthe identi.er is authenticated, the application can safely use it to .lter duplicate or expired messages. \n 3.3 Password-based Signature In order to achieve more precise authentication properties under the same \nassumptions a shared password between u and S one can use an XML digital signature on selected elements \nof the enve\u00adlope [17]. In addition to the username token, we add a signature token that signs (for instance) \nthe envelope body, with a signing key derived from the password and the username token. A hash-based \nsignature of items x1, ..., xn using a key k, may be roughly pictured as follows. <Signature> <SignedInfo> \n<Reference> ... hash of x1 ...</> ... <Reference> ... hash of xn ...</> <SignatureValue> ...hash of SignedInfo \nelement with key k ... See Section 4.3 for a full example of a signed envelope. Next, we de.ne the additional \npredicates needed for our modi.ed protocol, including predicates de.ning the various parts of a signature. \nisUserTokenKey(tok,u,pwd, n,t,k) means that tok is a user\u00adname token for user u with password pwd, unique \nidenti.er (n,t), and derived key k. The key derivation uses a p-sha1 keyed hash salted with the message \nidenti.er. isSigVal(sv, si,k,a) means that sv is the digital signature com\u00adputed on the item si with \nkey k using algorithm a (which for password-based signatures is hmac-sha1).  ref(t,r) means that the \nitem r is a reference containing the digest of item t. (We use the three wildcards to match certain attributes \nand elements irrelevant to security here.)  isSigInfo(si, a,x1,...,xn) means that the signed information \nsi, for signature algorithm a, contains a list of references of which the .rst n are for the items x1,...,xn. \nAfter these refer\u00adences, si may contain any number of references to other items (represented in the predicate \nby an ). This .exibility in the predicate enables the client to sign additional items even if not required \nby the server (to conform to a uniform send policy, for example).  isSignature(sig,a,k,x1,...,xn) means \nthat the signature sig signs x1,..., xn with algorithm a and veri.cation key k.  hasUserSignedBody(e,u,pwd,n,t, \nb) is the top-level predi\u00adcate. It means that the envelope e contains a username token for u,pwd, n,t, \nand that the body b of e is signed by the key derived from the token.  isUserTokenKey(tok : item, u,pwd \n: string, n : bytes,t : string,k : bytes) :\u00ad tok = <UsernameToken > <Username>u</> <Nonce>base64(n)</> \n<Created>t</>, u = principal(pwd), k = p-sha1(pwd,concat(n,utf8(t))). isSigVal(sv : bytes,si : item, \nk : bytes,a : string) :\u00ada = hmac-sha1, sv = hmac-sha1(k, c14n(si)). ref(t : item,r : item) :\u00adr = <Reference \n> <DigestValue>base64(sha1(c14n(t)))</>. (for each n = 1) isSigInfo(si : item,a : string, x1,...,xn : \nitem) :\u00adsi = <SignedInfo> <SignatureMethod Algorithm=\"a\"></> r1 ... rn , ref(x1, r1),...,ref(xn, rn). \nisSignature(sig : item,a : string,k : bytes,x1,...,xn : item) :\u00adsig = <Signature>si <SignatureValue>base64(sv)</> \n</>, isSigInfo(si, a,x1,...,xn), isSigVal(sv, si,k,a). hasUserSignedBody(e : item,u : string,pwd : string, \nn : bytes,t : string, b : item) :\u00adhasBody(e,b), hasSecurityHeader(e,toks), utok . toks, isUserTokenKey(utok, \nu,pwd, n,t,k), sig . toks, isSignature(sig,hmac-sha1,k, b).  The message exchange is much as in Section \n3.2, with two differ\u00ad ences: each log entry now contains u n t OrderId instead of just unt; we use the \ntop-level predicate hasUserSignedBody(e,u,pwd, n,t,b) instead of hasUserTokenDigest(e, u,pwd,n,t,b). \nWe obtain a similar, but stronger authentication property: CLAIM 2. In the presence of an active Dolev-Yao \nattacker, if <End>u n t OrderId</> is logged by S, <Begin>u n t OrderId</> has been logged by I. This \nclaim can be read as if S accepts a request from u, then u recently sent this request . As before, we \ncan rely on the identi.er (n,t) for replay protection. We make two observations concerning these predicates. \nFirst, isUserTokenKey does not check the presence or validity of the op\u00adtional username token digest. \nIn fact, checking the password digest would not provide any additional authentication guarantee here. \nConversely, its (potential) occurrence in the envelope slightly com\u00adplicates our proofs in the next section. \nArguably, the initiator should not include both a digest and a signature, since this may facilitate a \ndictionary attack on the password, unless it does not know which evidence will be considered by the server. \nSecond, although each reference r typically provides a pointer to the digested element, either as a fragment \nURI or as an XPath expres\u00adsion, we do not rely on this information in the ref predicate. Instead, we \ncheck that the actual item we are interested in the body b is targeted by the reference. In general, \nthis approach is preferable, since it leaves the resolution of pointers outside the trusted com\u00adputing \nbase. Otherwise, one should also carefully check that these pointers are well-de.ned and unambiguous. \nOur speci.cation captures the .exibility of WS-Security signatures. The predicates for key derivation \n(isUserTokenKey) are indepen\u00addent from those interpreting the signature. So, we can compose isSignature \nwith some other keying material, such as an X.509 cer\u00adti.cate. Similarly, we can support additional algorithms \nfor com\u00adputing the actual signature by adding alternatives to the predicate isSigVal see Section 3.4. \nFurthermore, isSignature allows additional elements of the message to be signed. Signing the username, \nnonce, or timestamp elements is not necessary with this particular signing-key derivation, but is harmless, \nand becomes necessary with other kinds of keys (see Sec\u00adtion 3.5). In case there are several actions \non the same server, or if the same password is shared with two different (honest) servers, then the path \nheader (S,W) should also be signed (as in the next section). Otherwise, the attacker might redirect an \nenvelope from one web service to another.  3.4 X.509 Signature The next protocol does not depend on \npassword-based authentica\u00adtion. Instead, it uses public-key signatures based on X.509 certi.\u00adcates. We \nassume that the user u has a public/private key pair and keeps the private key secret. We also assume \nthat u and S agree on the public key kr of some X.509 certi.cation authority, and that this authority \nissued only one certi.cate for u, with u s public key. In contrast with password-based signatures, X.509 \nsignature tokens cannot use fragments of the username token as message identi\u00ad.er. Instead, they can \nsign the globally unique identi.er included in the path header of every SOAP message, as de.ned in WS-Routing \n[30]. This is re.ected by the following additional predi\u00ad cates: isX509Token(tok,kr, u,a,k) means that \ntok is a binary token that contains a certi.cate x509(sr,u,a,k) with certi.er s pub\u00adlic key kr = pk(sr). \n isSigVal(sv, si,k,a) is extended with a clause that checks sig\u00adnatures using the rsa-sha1 algorithm. \n  hasPathHeader(e,ac,to,id,ea,et,ei) means that envelope e has a path header with action ac, destination \nto, and message identi.er id in elements ea, et, and ei, respectively.  hasX509SignedBody(e,kr,u, ac,to,id,b,ea,et,ei) \nis the top\u00adlevel predicate. It means that the envelope e has an X.509 token for u certi.ed by kr whose \npublic key signs the body b and a path header ea,et,ei containing ac,to,id.  isX509Token(tok : item,kr \n: bytes,u : string,a : string,k : bytes) :\u00ad tok = <BinarySecurityToken >base64(xcert)</>, check-x509(xcert,kr)= \nkr, u = x509-user(xcert), a = x509-alg(xcert), k = x509-key(xcert). isSigVal(sv : bytes,si : item, k \n: bytes,a : string) :\u00ada = rsa-sha1, check-rsa-sha1(c14n(si), sv,k)= k. hasPathHeader(e : item, ac,to, \nid : string,ea,et, ei : item) :\u00ade = <Envelope><Header>headers</> </>, header . headers, header = <path \n>ea et ei</>, ea = <action >ac</>, et = <to >to</>, ei = <id >id</>. hasX509SignedBody(e : item,kr : \nbytes, u,ac,to,id : string, b,ea,et,ei : item) :\u00ad hasBody(e,b), hasPathHeader(e, ac,to,id, ea,et,ei), \nhasSecurityHeader(e,toks), xtok . toks, isX509Token(xtok,kr,u, rsa-sha1,k), sig . toks, isSignature(sig,rsa-sha1, \nk,b,ea,et,ei). The message exchange for the X.509 signature protocol is al\u00admost the same as the one \nin Section 3.3, with two differences. First, the contents of the log entries is now u W S id OrderId \n(instead of u n t OrderId). Second, we use the top-level pred\u00adicate hasX509SignedBody(e,kr, u,W,S,id,b, \nea,et,ei) instead of hasUserSignedBody. We now obtain the authentication property: CLAIM 3. In the presence \nof an active Dolev-Yao attacker, if <End>u W S id OrderId</> is logged by S, then <Begin>uWS id OrderId</> \nhas been logged by I. This claim can be read as if S accepts a request from u, then u, at some point, \nsent this request to S . So by signing the path header, we obtain an additional authenticity guarantee \nas regards u s in\u00adtended target (S, W), and thus prevent some redirection attacks. One can easily implement \nreplay protection using the authenticated message identi.er. This supposes that clients do generate globally \nunique id s (although this is not actually required to obtain our cor\u00adrespondence property). Alternatively, \none may use a custom unique identi.er in the envelope body. 3.5 Firewall-Based Authentication By specifying \nthe structure of security tokens, rather than their use, WS-Security encourages a .exible approach to \nweb service secu\u00adrity. For instance, a server may naturally accept both password\u00adbased and X.509-based \nsignatures for authentication, leaving that choice to the client. This .exibility yields useful compositional \nproperties in our formal developments. For instance, a web service that runs both protocols is formally \nequivalent to two web services in parallel, one for each authentication mechanism. In this section, we \nillustrate this .exibility with a different com\u00adposite architecture that chains WS-Security authentication \nschemes along a WS-Routing path. In addition to a server S and a client I acting on behalf of u, we consider \nan intermediate SOAP-level .re\u00adwall F. The .rewall holds the password database, and is responsi\u00adble for \nauthenticating access to S (and possibly other servers). The client I sends a GetOrder request with a \nusername signature (for u) to S via F. The path header indicates to F that the message is in\u00adtended for \nS. The .rewall F checks the password-based signature, adds a new firewall header indicating that it has \nauthenticated u, signs the message using its X.509 certi.cate, and forwards the mes\u00adsage to S. The server \nS checks the X.509 signature, and thus authen\u00adticates the original sender u without knowledge of u s \npassword. Next, we de.ne (predicates on) the message forwarded by the .re\u00adwall. To indicate to the server \nthat it has checked the credentials of the user, the .rewall adds a new .rewall header containing the \nuser\u00adname token, but with the password digest deleted. It then embeds an X.509 signature that includes \nthis header as well. The predicates for this message are: isFirewallHeader(h,u,n,t) means that the envelope \nh is a .re\u00adwall header with the username token u,n,t.  hasFWHeader(e,h, u,n,t) means that the envelope \ne has a .rewall header h with u,n,t.  hasX509SignedBodyFw(e,kr, f ,u,n,t, b) is the top-level predicate \nchecked by the server. It means that the envelope e has a .rewall header with u,n,t, body b, and is signed \nwith a valid certi.cate for f issued by kr.  isFirewallHeader(h : item,u : string,n : bytes,t : string) \n:\u00ad h = <firewall >utok</>, utok = <UsernameToken> <Username>u</> <Nonce>base64(n)</> <Created>t</>. hasFWHeader(e,h \n: item,u : string,n : bytes,t : string) :\u00ade = <Envelope ><Header>headers</> </>, h . headers, isFirewallheader(h,u,n,t). \n hasX509SignedBodyFw(e : item, kr : bytes, f ,u : string, n : bytes,t : string,b : item) :\u00ad hasBody(e,b), \nhasFWHeader(e,h,u,n,t), hasSecurityHeader(e,toks), xtok . toks, isX509Token(xtok,kr, f ,rsa-sha1, p), \nsig . toks, isSignature(sig,rsa-sha1, p,b,h). The protocol involves three messages, as follows: Event \n1: I logs <Begin>u n t OrderId</> Message 1: I . F,We where hasUserSignedBody(e,u,pwd,n,t,b) \" Message \n2: F . S, We \" where hasX509SignedBodyFw(e,kr, f , u,n,t,b) and isGetOrder(b,OrderId) Event 2: S logs \n<End>u n t OrderId</> \"\" Message 3: S . Ie \"\" where hasBody(e, b\") and isGetOrderResponse(b\", OrderId, \nu) CLAIM 4. In the presence of an active Dolev-Yao attacker, if <End>u n t OrderId</> is logged by S, \nthen <Begin>u n t OrderId</> has been logged by I. Thus, we obtain the same end-to-end authenticity \nguarantee as with the password-based signature protocol of Section 3.3, but for a dif\u00ad ferent implementation \nthat does not require S to know u s password. We prove this claim by composing the correspondence property \nfor the password-based signature in Message 1 with that for the X.509 signature in Message 2.  4 A Pi \nCalculus Semantics In order to validate the claims of Section 3, we specify the be\u00ad haviour of the participants \n(and in particular their implementation of predicates) as processes in the applied pi calculus. We refer \nto [1] for a general presentation of the calculus, and rely on their de.ni\u00adtions for processes and their \nsemantics. Here, we use the sorts, terms, and equations described in Section 2, with coercion func\u00ad tions \nfrom strings to items, and with additional sorts for commu\u00adnication channels [27]. We always assume that \nterms, formulas, processes, and contexts are well-sorted, but usually keep sort infor\u00admation implicit. \nThis section divides into the following parts. Section 4.1 describes our computational interpretation \nof formulas as certain nondeter\u00administic processes in the applied pi calculus. Section 4.2 introduces \nformal notions of robust safety that embedded correspondence as\u00adsertions hold in spite of the presence \nof an attacker and functional adequacy that a protocol may run to successful completion in the absence \nof an attacker. Section 4.3 uses these de.nitions to state results about the username-signing protocol \nof Section 3.3. The\u00adorem 1 asserts that a process formalizing this protocol is robustly safe our previous \nclaim is a corollary. Moreover, Theorem 2 as\u00adserts the formalization is functionally adequate. Section \n4.4 gives the structure of our proof for Theorem 1, which relies on a decom\u00ad position of the protocol \ninto simpler components. The technical report contains a brief overview of the applied pi cal\u00adculus, \ndetailed proofs of these two theorems and of their counter\u00adparts for the other protocols of Section 3, \nand an account of how to generalize our results to a situation with multiple servers and users. 4.1 Interpretation \nof Formulas We describe a (partial) implementation of our logic in the applied pi calculus. We inductively \nde.ne processes of the form .lter F . xy are bound in P and get assigned to y in P, where the variables \nxterms making the formula F true. When the formula is an equality V = T we assume that one of the terms \nis known, and that the other can be treated as a pattern, matching variables to known subterms in the \nknown term. In the following formal de.nitions, we always assume that V is the known term, and that T \nis the pattern, but in our example predicates we allow either of the terms to be the pattern. For a pattern \nto be implementable, there must be an inverse term for each bound variable, able to compute the value \nof the variable from the known term. Patterns: The equality V = T binds variables yxwith pattern T , \nwritten V =T . yx, when (1) yx. fv(T ) \\ fv(V ), and (2) T has inverse terms Sx, with fv(Sx) .{x}, fn(Sx)= \n\u00d8, and, for all terms V,W , if x= x V = T {yx= W }, then WxS{x = V }. D For instance, the pattern base64(y) \nhas inverse S = i-base64(x); for all V and W , if V = base64(W ) then W = S{x = V } = i-base64( base64(W \n)). On the other hand, the pattern sha1(y) has no inverse, and therefore would not satisfy point (2). \nThe following table is the partial inductive de.nition of .lter F . xIf such a process is de.ned by the \nfollowing rules, we say y in P. that the formula F is implementable with bound variables yx. When .lter \nF . x y in P is de.ned and closed, we intend that it seeks closed terms Vxsuch that |= F{yx= Vx}, and \nacts as P{yx= Vx}. We refer to the technical report for a formal statement of this property.  Formula \nImplementation: .lter F . xy . fv(F) y in P when x .lter V = T . x= y in P D let yx= Sx{x = V } inif \nV = T then P when V = T . yxwith inverse terms Sx D .lter x . V . x in P = .s, c.(c(x).P | s(V )| !s(z)..lter \nz= ht . h,t in (c(h)| s(t))) when x . fv(V ) and with {s,c}n fn(P)= \u00d8 .lter p(Vx) . x=y in P D .s.(s(e)| \n.i.1..ns()..lter Fi{x = Vx} . yx,xzi in P) when p(x ) :-F1 .\u00b7\u00b7\u00b7. Fn, s ./fn(P) and, .i . 1..n,fv(Fi)= \nx xzi and (fv(Vx) . fv(P)) nxzi = \u00d8 .lter F1,F2 . x= y in P D .lter F1 . (yxn fv(F1)) in (.lter F2 . \n(yx\\ fv(F1)) in P) When V = T . xS, .lter V =y in P binds y, with inverse terms xT . xthe variables yxof \nthe pattern T to components of the term V , and veri.es that hence the pattern matches the term. If so, \nthe match succeeds, and P runs. Otherwise, the match fails, and the imple\u00admentation deadlocks. When x \n. fv(V ), .lter x .V . x in P outputs V on a fresh channel s, and runs the process !s(z)..lter z=ht . \nh,t in (c(h)| s(t)) which binds h = V1 and t = V2 ... Vn e, provided V = V1 V2 ... Vn e with n = 1, then \noutputs h on c, and t on the fresh channel s. The effect of this replication is to output each of the \nterms V1, ..., Vn on the fresh channel c. The process c(x).P is the only listener on c; so the outcome \nis P{x = Vi} for some i . 1..n. If, in fact, V is the empty list, the implementation deadlocks. When \np(x ) :-F1 .\u00b7\u00b7\u00b7. Fn, .lter p(Vx) . x y in P generates a sep\u00adarate process s()..lter Fi{x = V } . yx,xzi \nin P) for each clause x i . 1..n, where xzi are the local variables for clause i. We make an internal \nchoice of which to run by arranging all to listen on the fresh channel s, on which only a single message \nis sent. The implementation .lter F1,F2 . x yin P works by evaluating F1 then F2 before running P. As \nan example, we show an implementation of hasBody(e,b): .lter hasBody(e,b) . b in [-] = .s.(s(e)| s(). \n.lter e = <Envelope><Header>y1</>b</> . y2, b in .lter b = <Body y2>y3</> . y2, y3 in [-]) = .s.(s(e)| \ns(). let y1: items = Header.body(hd(Envelope.body(e))) in let b : item = hd(tl(Envelope.body(e))) in \nif e = <Envelope><Header>y1</> b e</> then let y2: atts = Body.att(b) in let y3: items = Body.body(b) \nin if b = <Body y2>y3</> then [-])  4.2 Safety Properties, Functional Properties To formalize the authenticity \nproperties claimed in Section 3, we mark the progress of the client and server processes with begin-and \nend-events, represented as message outputs on the channels begin and end, respectively. Hence, our authenticity \nproperties become non-injective correspondence assertions [37] between messages. To capture the occurrence \nof one of these events, we de.ne a notion of observation of messages on free channels. We write for \n(weak) observational congruence in applied pi. Observation: A> a(V ) A outputs V on channel a, written \nA >a(V ), when A a(V )| A \" . Much as in Gordon and Jeffrey s formulation of correspondence assertions \n[19], we de.ne safety and robust safety: a process is safe if every end-event has a matching begin-event, \nand is robustly safe if it is safe in the presence of any opponent. We write .* for a series of reduction \nsteps. Safety and Robust Safety: A is safe if and only if, whenever A .* B, B >end(V ) implies B> begin(V \n). A is robustly safe if and only if, for all evaluation contexts E where the channels begin and end \ndo not occur, E[A] is safe. Intuitively, E represents any active attacker (in the applied pi cal\u00adculus) \nthat controls both the network and the client application be\u00adhaviour, A is the initial con.guration of \nthe protocol being con\u00adsidered, and B represents any reachable state of the protocol, after interleaving \nany number of sessions. In addition to security properties such as robust safety, one should check that \nthe protocol works as intended and may indeed succeed, at least in the absence of an attacker: Functional \nAdequacy: A is functionally adequate for V when A .* B with B >end(V ) for some B. The next lemma states \nthat our main security properties can be es\u00adtablished using the theory of observational equivalence in \nthe ap\u00adplied pi calculus. LEMMA 1. Suppose A B. If A is robustly safe then so is B. Moreover, if A is \nfunctionally adequate for V then so is B. Moreover, logical equivalence, when lifted to processes, also \npre\u00adserves robust safety. Logical Equivalence of Processes: Two processes are logically equivalent when \nthey only differ in their choices of implementable, logically-equivalent predicates. LEMMA 2. Logical \nequivalence preserves robust safety.  4.3 Stating Password-Based Authentication We are now ready to \nformulate and prove Claim 2 of Section 3.3 for envelopes with password-based signatures, with or without \na password digest. (The other claims in the paper are handled simi\u00adlarly.) For the sake of simplicity, \nwe focus on protocol con.gura\u00adtions Q with a single user u, with initiator process Iu and a single server \nSu that share a secret password with that user, represented as a restricted name spwd . The two parts \nof the protocol also share a communication channel, http. Since http is not restricted, an envi\u00adronment \nthat encloses Q can also read, modify, and write any SOAP message. Protocol Con.gurations: Q (parameterized \nby Envelope) D Q = .spwd .{u = principal(spwd )}| Iu | Su D Iu = !initu(n,t,b).(begin(unt b)| http(Envelope)) \nD \" Su = !http(e)..lter hasUserSignedBody(e,u ,spwd ,n,t,b) \"\" . u ,n,t,b in end(u ntb) The initiator, \nIu, repeatedly receives high-level requests on a con\u00adtrol channel initu. Using that control channel, \nthe environment can thus initiate any number of requests on behalf of u, for any terms N,T,B. These requests \nare genuine : they are echoed on channel begin. The process Iu is also parameterized by a term Envelope \nthat determines the actual SOAP envelopes constructed and sent by the initiator. The server repeatedly \nreceives low-level envelopes on channel http, .lters them using the top-level predicate de.ned in Section \n3.3 (one easily checks that this predicate is implementable) and .nally sends a message on channel end \nfor each accepted envelope. (More gen\u00aderally, we would represent a server that accepts requests from \nusers u1,..., un as a parallel composition .i.1..n Sui .) The scope restriction on spwd models our secrecy \nassumption on the password, essentially supposing that it is a strong secret shared between the initiator \nand the server and used only in this kind of envelope. The active substitution {u = principal(spwd )} \nbinds the variable u to the expression principal(spwd ), and exports u (but not spwd ) to the environment. \nCrucially, we do not want our robust safety result to depend on every detail of the envelope. Instead, \nwe express minimal require\u00adments as follows:  Safe Envelopes: A safe envelope is a term of the form \nEnvelope = T . with D . = {d = sha1(concat(n,concat(utf8(t), utf8(spwd )))), sv = hmac-sha1(p-sha1(spwd \n, concat(n,utf8(t))), c14n(SI))} for some terms T,SI such that spwd . fn(T,SI) and isSigInfo(SI,hmac-sha1,b) \nis valid. To elaborate, as regards safety properties, Envelope may be any XML term, as long as the password \noccurs at most in the digest and signature values. Similarly, most of the subterms in the signa\u00adture \ninformation are irrelevant for safety, even if they happen to be signed in SI. THEOREM 1. For any safe \nenvelope, the con.guration Q is ro\u00adbustly safe. From this theorem and the de.nition of isGetOrder(b,orderId), \nwe easily derive the more speci.c claim of Section 3.3. For functional adequacy, the structure of the \nenvelope is more con\u00adstrained. For example, T and SI can be instantiated as follows: D T = <Envelope> \n<Header> <Security> <UsernameToken Id=\"utoken\"> <Username>u</> <Password Type=\"PasswordDigest\"> base64(d) \n<Nonce>base64(n)</> <Created>t</> <Signature> SI <SignatureValue>base64(sv)</> <KeyInfo> <SecurityTokenReference> \n<Reference URI=\"#utoken\"></> b D SI = <SignedInfo> <CanonicalizationMethod Algorithm=\"c14n\"></> <SignatureMethod \nAlgorithm=\"hmac-sha1\"></> <Reference URI=\"#body\"> <Transforms> <Transform Algorithm=\"c14n\"></> <DigestMethod \nAlgorithm=\"sha1\"></> <DigestValue>base64(sha1(c14n(b)))</> THEOREM 2. The envelope T . with T and SI \nde.ned above is safe and, for any ground terms N : bytes,T : string,B : item with B = <Body Id=\"body\"> \n</>, the con.guration initu(N,T,B)| Q with that envelope is functionally adequate for the term u N T \nB. Conversely, by Theorem 1, if we have initu(N,T,B)| Q .* A and \"\" \"\" N \" A> end(u TB \"), then u , \nN \" ,T ,B \" = u, N,T,B.  4.4 Proving Password-Based Authentication We present the structure of the proof \nfor Theorem 1. We refer to the technical report for additional lemmas and proofs. An intuition behind \nthe proof is that the security property relies only on a few elements in the envelope. For instance, \nthe signature bytes are suf.\u00adcient for authentication, whereas the other elements in the envelope only \nprovide the server with (untrusted) hints to verify the signa\u00adture. Hence, to establish robust safety, \nwe rely on a stronger, more speci.c lemma about a core protocol that explicitly deals only with these \nbytes. The proof is in two stages. First, we show how the password-based signature protocol can be decomposed \ninto a core protocol that deals with authentication and an XML wrapper. The XML wrap\u00adper has no access \nto the password, and need not be trusted: for\u00admally, it becomes part of the hostile environment. We show \nthat it is enough to prove robust safety for the core protocol (Lemma 4). In the second stage, we prove \nthat the core protocol itself is robustly safe (Lemma 7) by exhibiting an invariant on its reachable \nstates (Lemma 6). We decompose hasUserSignedBody(e,u,pwd,n,t,b) . u,n,t, b into two implementable formulas \nhasUserSignatureEvidence(e, u,n,t,b, sv,si) . u, n,t,b,sv,si, checkEvidence(sv, si,u, pwd,n,t, b) . \u00d8 \n hasUserSignatureEvidence parses the envelope and extracts the bits that are needed to verify the signature; \nit has no access to the password. (We refer to the technical report for details.) All the authentication-related \nchecks are contained in checkEvidence, which is de.ned as follows: checkEvidence(sv : bytes, si : item, \nu,pwd : string,n : bytes, t : string, x1,...,xm : item) :\u00adisSigInfo(si,hmac-sha1,x1,...,xm), u = principal(pwd), \nk = p-sha1(pwd,concat(n,utf8(t))), isSigVal(sv,si,k,hmac-sha1). We can state the correctness of this \ndecomposition in terms of logi\u00ad cal equivalence. LEMMA 3. The formula hasUserSignedBody(e,u,pwd,n,t, \nb) and its decomposition de.ned above are logically equivalent. Using this decomposition, we de.ne the \ncore protocol con.guration Q ., a counterpart of Q for the simpler predicate checkEvidence that binds \nno variables, and for replicated processes I. and S. that com\u00ad uu municate with the environment on channels \nc and s, respectively, instead of channel http. Core Protocol Con.gurations: Q . D Q .[-]= .spwd . {u \n= principal(spwd )}| Iu .| S. u | [-] D I. = !initu(n,t,b).(begin(unt b)| c(d,sv, SI,u, n,t,b).) u S.D \n \" = !s(sv,si,u ,n,t, b)..lter checkEvidence u \" \" (sv,si,u ,spwd ,n,t, b) . \u00d8in end(u ntb) We write \nQ . for Q .[0] (the initial state of the core protocol). Lemma 4 shows that this core protocol is logically \nequivalent, un\u00adder an evaluation context, to the original protocol. This implies that if Q . is robustly \nsafe, so is Q . LEMMA 4 (XML/CORE). For any safe envelope, there exists an evaluation context EQ [-] \nwhere the names begin, end do not oc\u00adcur and a process Q logically equivalent to Q such that Q EQ [Q \n.]. To prove robust safety for the core protocol, we .rst de.ne the valid states of the core protocol \nin an evaluation context. Valid states are our correctness invariant. They describe protocol states reachable \nfrom Q . in which no secrets have been leaked and only messages sent by the client have been accepted \nby the server.  Valid States for the Core Protocol: (1) .i is adapted from . in the de.nition of safe \nenvelopes with variables di,svi,ni,ti, bi and term SIi instead of d, sv,n,t, b and SI. (2) A session \nstate is a process of the form Ci = begin(u ni ti bi)| .i | Ji where Ji is any parallel composition of \nprocesses from  LL {end(u ni ti bi)}. {end(u ni ti bi)}. {} (with free variables L ni,ti,bi and de.ned \nvariables di,svi). (The operator represents internal choice over a set of processes.) (3) An internal \nstate is a parallel composition of session states C = .i<nCi, for some n = 0.  (4) A valid state is \na closed process of the form A = E[Q .[C]] where E[-] is an evaluation context where begin and end do \nnot occur and C is an internal state.  For a given internal state C, let sC be the (ordinary) substitution \nobtained by composing {u = principal(spwd )} and each .i for i = 0 ... n - 1. By de.nition, the frame \nobtained from Q .[C], which represents the attacker s knowledge about spwd , is .C = .spwd .sC. The next \nlemma states that if a message is received in a valid state of the protocol, and it satis.es the predicate \ncheckEvidence, then it must have been sent by the client. LEMMA 5 (checkEvidence IS SAFE). Let C be an \ninternal state with n = 0 sessions. Let s\" be a substitution that ranges over open terms where the name \nspwd does not appear such that s D| sC = s\" is closed. \" If |= checkEvidence(sv,si,u ,spwd ,n,t,b)s, \nthen there exists i < n \" such that (u ,sv, si,n,t,b = u,svi,SIi, ni,ti, bi)s. Using this lemma, we can \nshow that all reachable con.gurations of the core protocol are valid states. LEMMA 6 (INVARIANT LEMMA). \nIf A is a valid state and A . T then T ~ A \" for some valid state A \" . As a corollary, we can show \nrobust safety for the core protocol. LEMMA 7 (CORE ROBUST SAFETY). Q . is robustly safe. Theorem 1 follows \nas a corollary. By Lemma 7, Q . is robustly safe (RS). By Lemma 4, Q EQ [Q .] and, by hypothesis on \nEQ , EQ [Q .] is RS. By Lemma 1, Q is RS. Finally, Q is logically equivalent to Q , and thus, by Lemma \n2, Q is RS.   5 Conclusions and Future Work In this paper, we introduced a framework for reasoning \nabout the security of SOAP protocols and their cryptographic implementa\u00adtions in terms of WS-Security \ntokens. We illustrated our framework using a series of simple authentication protocols. Surprisingly, \nper\u00adhaps, these XML-based protocols can be studied at the same (syn\u00adtactic) level of abstraction: formally, \nusing a faithful, predicate-based implementation in the applied pi calculus with proofs of correspondence \nproper\u00adties against a Dolev-Yao adversary;  experimentally, using sample programs and SOAP traces on \n  top of the WSE toolkit [26]. This should provide a principled basis for testing compliant imple\u00admentations, \nand also reduce the risk of attacks in concrete re.ne\u00adments of correct, abstract protocols. As can be \nexpected, this also complicates the formal model, with for example a large syntax and equational theory \nfor terms in the applied pi calculus. However, our experience suggests that a mod\u00adular de.nition of predicates, \ntogether with standard compositional techniques in the pi calculus, should enable a good reuse of the \nproof effort for numerous WS-Security protocols. Our choice of authentication protocols stresses that \nsmall varia\u00adtions in WS-Security envelope formats may lead to much weaker correspondence properties. \nEach service should therefore clearly prescribe (and enforce) the intended property. Speci.cally, a pru\u00addent \npractice in the selection of XML signatures is to request that all potentially relevant headers be jointly \nauthenticated not just the message identi.er or its body. In the case authentication relies on username \ntokens, this strongly suggests the use of a signature instead of a digest. Moreover, XML signatures have \na complex structure, which should be used with caution. Speci.cally, authen\u00adtication should not rely \non signed elements whose interpretation depends on an unsigned context. Related Work. There have been \nmany formal studies of remote procedure call (RPC) security mechanisms. The earliest we are aware of \nis the formalization within the BAN logic [9] of Secure RPC [33] in the Andrew distributed computing \nenvironment. More recently, process calculi [2] have been used to formalize the secure implementation \nof programming abstractions such as communica\u00adtion channels and network objects [36]. We are aware of \nvery little prior formal work on XML security pro\u00adtocols. Gordon and Pucella [20] implement and verify \nattribute\u00ad driven SOAP-level security protocols, but do not use the WS-Secu\u00adrity syntax. Their representation \nof SOAP messages abstracts many details of the XML wire format, and hence would be blind to any errors \nin the detailed structure of names or signatures. Damiani et al. [12] describe an access control model \nfor SOAP messages, but rely on a secure transport rather than WS-Security; a subsequent paper [13] discusses \nconnections between SOAP security and au\u00ad thorization languages such as SAML and XACML. Future Work. \nOur approach to authenticity properties should eas\u00adily extend to complementary security properties, such \nas secrecy and anonymity. Similarly, we should be able to deal with more complex protocols (with series \nof related messages) and con.gura\u00adtions (with more principals and roles). Our predicate structure is \nquite modular, with predicates being re-used in different protocols. Hence, we are hopeful that the method \nwill scale up. Moreover, our semantics appears to be suitable for automation, and we are investigating \nhow to automate the proofs using Blanchet s recent logic-based tool for applied pi [5]. At this stage, \nwe are exploring the range of WS-Security protocols, rather than attempting its thorough description. \nOur fragment of WS-Security omits certain features such as Kerberos tokens and encryption but we see \nno fundamental barrier to modelling all of WS-Security. Finally, although all the protocols are implemented \nusing WSE, our goal has not been to verify the WSE implementation itself. Still, we are investigating \nways of verifying at least parts of that implemen\u00adtation by relating it to our semantics. Acknowledgements. \nWe thank Tony Hoare, Riccardo Pucella, and the anonymous reviewers for their comments.  6 References \n[1] M. Abadi and C. Fournet. Mobile values, new names, and secure communication. In 28th ACM Symposium \non Principles of Program\u00adming Languages (POPL 01), pages 104 115, 2001. [2] M. Abadi, C. Fournet, and \nG. Gonthier. Authentication primitives and their compilation. In 27th ACM Symposium on Principles of \nPro\u00adgramming Languages (POPL 00), pages 302 315, 2000. [3] B. Atkinson, G. Della-Libera, S. Hada, M. \nHondo, P. Hallam-Baker, C. Kaler, J. Klein, B. LaMacchia, P. Leach, J. Man\u00adferdelli, H. Maruyama, A. \nNadalin, N. Nagaratnam, H. Pra\u00adfullchandra, J. Shewchuk, and D. Simon. Web services secu\u00adrity (WS-Security), \nversion 1.0. http://msdn.microsoft.com/ library/en-us/dnglobspec/html/ws-security.asp. Draft sub\u00admitted \nto OASIS Web Services Security TC, April 2002. [4] K. Bhargavan, C. Fournet, and A. D. Gordon. A semantics \nfor web services authentication. Technical Report MSR TR 2003 83, Mi\u00adcrosoft Research, 2003. [5] B. Blanchet. \nFrom secrecy to authenticity in security protocols. In Proceedings of the 9th International Static Analysis \nSymposium (SAS 02), volume 2477 of LNCS, pages 342 359. Springer, 2002. [6] D. Box, D. Ehnebuske, G. \nKakivaya, A. Layman, N. Mendelsohn, H. Nielsen, S. Thatte, and D. Winer. Simple Object Access Proto\u00adcol \n(SOAP) 1.1, 2000. W3C Note, http://www.w3.org/TR/2000/ NOTE-SOAP-20000508/. [7] J. Boyer. Canonical XML, \n2001. W3C Recommendation, http:// www.w3.org/TR/2001/REC-xml-c14n-20010315/. [8] J. Boyer, D. E. Eastlake, \nand J. Reagle. Exclusive XML Canonicaliza\u00adtion, 2002. W3C Recommendation, http://www.w3.org/TR/2002/ \nREC-xml-exc-c14n-20020718/. [9] M. Burrows, M. Abadi, and R. Needham. A logic of authentication. Proceedings \nof the Royal Society of London A, 426:233 271, 1989. [10] E. Cohen. TAPS: A .rst-order veri.er for cryptographic \nprotocols. In 13th IEEE Computer Security Foundations Workshop, pages 144 158. IEEE Computer Society \nPress, 2000. [11] J. Cowan and R. Tobin. XML Information Set, 2001. W3C Recommendation, http://www.w3.org/TR/2001/ \nREC-xml-infoset-20011024/. [12] E. Damiani, S. De Capitani di Vimercati, S. Paraboschi, and P. Sama\u00adrati. \nSecuring SOAP e-services. International Journal of Information Security, 1(2):100 115, 2002. [13] E. \nDamiani, S. De Capitani di Vimercati, and P. Samarati. Towards securing XML web services. In ACM Workshop \non XML Security 2002, pages 90 96, 2003. [14] T. Dierks and C. Allen. The TLS protocol: Version 1.0, \n1999. RFC 2246. [15] D. Dolev and A. Yao. On the security of public key protocols. IEEE Transactions \non Information Theory, IT 29(2):198 208, 1983. [16] D. Eastlake and P. Jones. US Secure Hash Algorithm \n1 (SHA1), 2001. RFC 3174. [17] D. Eastlake, J. Reagle, D. Solo, M. Bartel, J. Boyer, B. Fox, B. LaMacchia, \nand E. Simon. XML-Signature Syntax and Process\u00ading, 2002. W3C Recommendation, http://www.w3.org/TR/2002/ \nREC-xmldsig-core-20020212/. [18] C. Fournet and M. Abadi. Hiding names: Private authentication in the \napplied pi calculus. In M. Okada, B. Pierce, A. Scedrov, H. Tokuda, and A. Yonezawa, editors, Software \nSecurity Theories and Sys\u00adtems. Mext-NSF-JSPS International Symposium, Tokyo, Nov. 2002 (ISSS 02), volume \n2609 of LNCS, pages 317 338. Springer, 2003. [19] A. Gordon and A. Jeffrey. Authenticity by typing for \nsecurity proto\u00adcols. Journal of Computer Security, 11(4):451 521, 2003. [20] A. Gordon and R. Pucella. \nValidating a web service security abstrac\u00adtion by typing. In ACM Workshop on XML Security 2002, pages \n18 29, 2003. [21] J. Jonsson and B. Kaliski. Public-Key Cryptography Standards (PKCS) #1: RSA Cryptography \nSpeci.cations Version 2.1, 2003. RFC 3447. [22] R. Kemmerer, C. Meadows, and J. Millen. Three systems \nfor crypto\u00adgraphic protocol analysis. Journal of Cryptology, 7(2):79 130, 1994. [23] H. Krawczyk, M. \nBellare, and R. Canetti. HMAC: Keyed-hashing for message authentication, 1997. RFC 2104. [24] G. Lowe. \nBreaking and .xing the Needham-Schroeder public-key protocol using CSP and FDR. In Tools and Algorithms \nfor the Con\u00adstruction and Analysis of Systems, volume 1055 of LNCS, pages 147 166. Springer, 1996. [25] \nMicrosoft Corporation. Microsoft .NET Pet Shop, 2002. http:// www.gotdotnet.com/team/compare/petshop.aspx. \n[26] Microsoft Corporation. Web Services Enhancements for Microsoft .NET, Dec. 2002. http://msdn.microsoft.com/webservices/ \nbuilding/wse/default.aspx. [27] R. Milner. Communicating and Mobile Systems: the p-Calculus. Cambridge \nUniversity Press, 1999. [28] A. Nadalin, C. Kaler, P. Hallam-Baker, and R. Monzillo. Web Services Security: \nSOAP Message Security, Aug. 2003. Avail\u00adable from http://www.oasis-open.org/committees/tc_home. php?wg_abbrev=wss. \n[29] R. Needham and M. Schroeder. Using encryption for authentication in large networks of computers. \nCommun. ACM, 21(12):993 999, 1978. [30] H. F. Nielsen and S. Thatte. Web services routing protocol (WS-Routing). \nhttp://msdn.microsoft.com/library/en-us/ dnglobspec/html/ws-routing.asp, October 2001. [31] L. Paulson. \nThe inductive approach to verifying cryptographic proto\u00adcols. Journal of Computer Security, 6:85 128, \n1998. [32] J. H. Saltzer, D. P. Reed, and D. D. Clark. End-to-end arguments in system design. ACM Transactions \nin Computer Systems, 2(4):277 288, November 1984. [33] M. Satyanarayanan. Integrating security in a large \ndistributed system. ACM Trans. Comput. Syst., 7(3):247 280, 1989. [34] J. Sim\u00b4eon and P. Wadler. The \nessence of XML. In 30th ACM Sym\u00adposium on Principles of Programming Languages (POPL 03), pages 1 13, \n2003. [35] F. Thayer F\u00b4abrega, J. Herzog, and J. Guttman. Strand spaces: Proving security protocols correct. \nJournal of Computer Security, 7:191 230, 1999. [36] L. van Doorn, M. Abadi, M. Burrows, and E. Wobber. \nSecure net\u00adwork objects. In IEEE Computer Society Symposium on Research in Security and Privacy, pages \n211 221, 1996. [37] T. Woo and S. Lam. A semantic model for authentication protocols. In IEEE Computer \nSociety Symposium on Research in Security and Privacy, pages 178 194, 1993.  \n\t\t\t", "proc_id": "964001", "abstract": "We consider the problem of specifying and verifying cryptographic security protocols for XML web services. The security specification WS-Security describes a range of XML security tokens, such as username tokens, public-key certificates, and digital signature blocks, amounting to a flexible vocabulary for expressing protocols. To describe the syntax of these tokens, we extend the usual XML data model with symbolic representations of cryptographic values. We use predicates on this data model to describe the semantics of security tokens and of sample protocols distributed with the Microsoft WSE implementation of WS-Security. By embedding our data model within Abadi and Fournet's applied pi calculus, we formulate and prove security properties with respect to the standard Dolev-Yao threat model. Moreover, we informally discuss issues not addressed by the formal model. To the best of our knowledge, this is the first approach to the specification and verification of security protocols based on a faithful account of the XML wire format.", "authors": [{"name": "Karthikeyan Bhargavan", "author_profile_id": "81100070918", "affiliation": "Microsoft Research", "person_id": "PP14035027", "email_address": "", "orcid_id": ""}, {"name": "C&#233;dric Fournet", "author_profile_id": "81100547450", "affiliation": "Microsoft Research", "person_id": "PP14190247", "email_address": "", "orcid_id": ""}, {"name": "Andrew D. Gordon", "author_profile_id": "81100037731", "affiliation": "Microsoft Research", "person_id": "PP15020291", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/964001.964018", "year": "2004", "article_id": "964018", "conference": "POPL", "title": "A semantics for web services authentication", "url": "http://dl.acm.org/citation.cfm?id=964018"}