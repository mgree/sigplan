{"article_publication_date": "01-01-2004", "fulltext": "\n Formalization of Generics for the .NET Common Language Runtime Dachuan Yu * Andrew Kennedy Don Syme \nYale University Microsoft Research Microsoft Research New Haven, CT, U.S.A. Cambridge, U.K. Cambridge, \nU.K. yu@cs.yale.edu akenn@microsoft.com dsyme@microsoft.com Abstract We present a formalization of the \nimplementation of generics in the .NET Common Language Runtime (CLR), focusing on two novel aspects of \nthe implementation: mixed specialization and sharing, and ef.cient support for run-time types. Some crucial \nconstructs used in the implementation are dictionaries and run-time type rep\u00adresentations. We formalize \nthese aspects type-theoretically in a way that corresponds in spirit to the implementation techniques \nused in practice. Both the techniques and the formalization also help us understand the range of possible \nimplementation techniques for other languages, e.g., ML, especially when additional source lan\u00adguage \nconstructs such as run-time types are supported. A useful by-product of this study is a type system for \na subset of the poly\u00admorphic IL proposed for the .NET CLR. Categories and Subject Descriptors: D.3.3 \n[Programming Lan\u00adguages]: Language Constructs and Features Polymorphism, Classes and Objects; D.3.1 [Programming \nLanguages]: Formal De.nitions and Theory General Terms: Languages Keywords: Polymorphism, Generics, Run-time \nTypes, CLR, .NET  Introduction Parametric polymorphism, also known as generics , is an im\u00adportant new \nfeature of Version 2.0 of the C. programming lan\u00adguage [10, 11] and also the .NET Common Language Runtime \n(CLR) [18, 6] that underpins C. and other languages. In previous work, two of the authors presented informally \nthe design and im\u00ad *This work was undertaken during Dachuan Yu s internship at Microsoft Research, Cambridge, \nUK. Dachuan Yu s research is supported in part by DARPA OASIS grant F30602-99-1-0519 and NSF grant CCR-0208618. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n04, January 14 16, 2004, Venice, Italy. Copyright 2004 ACM 1-58113-729-X/04/0001 ...$5.00 plementation \nof generics for C. and the .NET CLR [14]. The pri\u00admary novelty of the design is the integration of parameterized \ntypes and polymorphic methods into the type system of the intermediate language (IL) implemented by a \nvirtual machine, or runtime. The implementation techniques described there are novel in many ways: they \ninclude just-in-time specialization of classes and code, code\u00adsharing between distinct instantiations \nof generic classes, and the ef.cient implementation of runtime types using dictionaries of type representations \nand computations. There has also been much recent work [1, 20, 22, 21, 3, 4, 27] on adding generics to \nthe Java programming language [8], most of which compiles away generics by translation into the JVM [17]. \nThe fact that type loopholes were identi.ed [13] in Generic Java suggests we pay close attention not \nonly to genericity itself as a language feature [12], but also the underlying implementation tech\u00adniques. \nIn particular, the generics implementation for the CLR is of unique interest because better expressivity \nis achieved with ex\u00adtended support from the virtual machine, which contrasts with most work on Java genericity \nwhose design space is limited by targeting the JVM. In this paper we formalize the generics design of \nthe CLR via a type system and operational semantics for a subset of IL with generics, and formalize two \nnovel aspects of the implementation: specializa\u00adtion of generic code up to data representation, and ef.cient \nsupport for run-time types. We do not attempt to formalize dynamic class loading or just-in-time compilation \n(which is a challenging topic on its own), instead presenting a static compilation scheme, thus demonstrating \nthat some of the techniques employed by the im\u00adplementation could be utilized by more conventional compilers \nfor polymorphic languages. As far as possible, the formalization is faithful to the implemen\u00adtation whose \nprototype was described in [14]; this contrasts with other work on IL (sans generics) [29] in which the \ntarget of a trans\u00adlation from IL is a foundational calculus based on F.. Our target language corresponds \n(in spirit, at least) to the output of the .rst stage of JIT-compilation. It does differ, however, in \nthat the transla\u00adtion preserves static types, and at the same time the use of types as runtime entities \n(e.g. in checked casts) is separated off using type\u00adreps `a la Crary et al. [5]. This lets us prove an \nerasure theorem for the target ( static types do not affect evaluation ) and makes it a good basis for \nfurther work on optimization. Indeed it could form the core of a typed intermediate language used by \nan optimizing JIT compiler for the CLR. We also discuss brie.y how an alterna\u00adtive target language that \nis more foundational in .avour (e.g. with structural subtyping and recursive types) would offer both \noppor\u00adtunities for expressing interesting optimizations and challenges for ef.cient implementation in \na virtual machine. (type) T,U ::= X | int32 | int64 | I (inst type) I ::= C<T> (class) cd ::= class C<X>: \nI {Tf ; md}(method) md ::= static Tm<X>(Tx) { e}| virtual Tm<X>(Tx) { e}(mdesc) M ::= TI::m<T>(U) (exp) \ne ::= ldc.i4 i4 | ldc.i8 i8 | ldarg x | e newobj I | e ldfld TI::f | e call M | ee callvirt M | e isinst \nI or e (value) v, w ::= i4 | i8 | I(f . v) (type env) E ::= X,x : T Field Lookup: .elds(object)= {} D(C)= \nclass C<X>: I {U1 f1; md}.elds([T/X]I)= U2 f2 .elds(C<T>)= U2 f2,[T/X]U1 f1 Method Lookup: D(C)= class \nC<X>: I {Uf ; md}m not de.ned in md mtype(C<T1>.m)= mtype([T1/X]I.m) .elds(I)= ... mtype(I.m)= ... mbody(I.m<T>)= \n... mbody(C<T1>.m<T2>)= mbody([T1/X]I.m<T2>) Figure 1. Syntax of BILG. The paper is structured as follows. \nIn Sections 2 and 3 we present our source and target languages, and in Section 4 we formalize the translation \nbetween them. To better demonstrate the key ideas for supporting specialization and run-time types, we \nmake simpli.ca\u00adtions with regard to the modelling of other features, such as shar\u00ading and cycles in dictionaries \nof types, the possibility of an in.nite graph of dictionaries, and support for polymorphic virtual methods. \nThe handling of these features, together with other language con\u00adstructs including value classes, is \ndiscussed in detail in Section 5 along with related work. Section 6 concludes. Interested read\u00aders are \nrefered to our companion technical report [28] for a type\u00aderasure semantics of the target language and \nthe soundness proof of the translation.  Source Language Our formalization starts from a purely-functional \ncore of the ver\u00adi.able IL with generics, which we call Baby IL with Generics (BILG:-). Following Baby \nIL [7], BILG speci.es the instruction set as tree-structured applicative expressions. In BILG, we sup\u00adport \nprimitive types of various sizes, parameterized reference types with general instantiations, polymorphic \nstatic and virtual methods, and exact run-time types. The support for mutable .elds, man\u00adaged pointers \nand value types (structs) is largely orthogonal from the translation s point of view, hence it is omitted, \nalthough exten\u00adsions for supporting value types will be discussed later. The syntax of BILG is shown \nin Figure 1. The types (T or U) in\u00adclude formal type parameters (X or Y), primitive types, and type instantiations \nof classes (I). The type arguments of class instantia\u00adtions are uncurried and denoted using vectors T. \nA class de.nition (cd) contains the name of the class and its super\u00adclass, a sequence of .eld declarations, \nand a sequence of method declarations. FJ-like systems [12] usually de.ne for every class a single constructor \nwhose behavior is .xed. In BILG this behavior is built-in, hence the constructor is omitted from the \nsyntax. We take the liberty of using vector notation when there is no confusion. For example, the list \nof .eld declarations is abbreviated as Tf . For simplicity we assume no .eld hiding, i.e., all .elds \nin a class are distinct from those in its superclass. The top of the class hierarchy is handled specially \nand referred to as object. Methods are either static (statically dispatched based on the class instantiation) \nor virtual (dynamically dispatched based on the ob- D(C)= class C<X>: I {Uf ; md}static/virtual U2 m<Y>(U1 \nx) { e}. md mtype(C<T1>.m)=[T1/X](<Y>U1 . U2) mbody(C<T1>.m<T2>)= (x, [T1/X,T2/Y]e) Figure 2. Macros \non .elds and methods look-up for BILG. ject). A method descriptor (M) provides the signature of a method. \nAs is the case of the implementation [14], we require that the type instantiation of the class is speci.ed, \nand the signature must be ex\u00adactly that of the de.nition. This is only to maintain the .avor of the actual \nIL. For BILG, the argument and return types in the method descriptors are of little importance due to \nthe omission of overload\u00ading. Method descriptors are used in method invocation expressions (call and \ncallvirt). Field access expressions (ldfld) refer to .eld descriptors which also specify the type instantiations \nof the classes. Since .eld de\u00adscriptors are simpler constructs, we inline them in the correspond\u00ading \nexpressions. Actual IL accesses method arguments by specify\u00ading an offset (ldarg j). In BILG we use argument \nnames (ldarg x) for ease of understanding (this syntax is also supported by the .NET IL assembler). The \nrun-time type test e isinst I or e' returns e if e is an instance of I; otherwise it returns e', which \nis of type I. In contrast, the actual IL returns null when the test fails. We use the default branch \ne' to avoid introducing null. The remaining expressions are standard; they include loading of constants \n(the ldc family) and object creation (newobj). The val\u00adues (v or w) are either integers or objects. Besides \nthe labelled .elds, an object value contains also a name of the class instanti\u00adation for dynamic dispatch. \nA typing environment E has the form X,x : T with free type vari\u00adables in T are drawn from X. Our semantics \nare in the style of Featherweight GJ [12]. We use the following judgment forms to de.ne the static semantics: \nE f T ok (T is well-formed in context E) E f I <: I' (I is subtype of I' in E) E f e : T (e has type \nT in E) f md ok inC<X> (md is well-formed in C<X>) f cd ok (cd is well-formed) f v : T (v has type T) \nType Formation: X, x : T f Xiok E f int32 ok E f int64 ok D(C)= class C<X>: I {...} E f T ok E f T ok \nE f C<T> ok Subtyping: E f I1 <: I2 E f I2 <: I3 E f I <: I E f I1 <: I3 D(C)= class C<X>: I {...} E \nf C<T> ok E f I <: I ' E f C<T> <: [T/X]I Typing: E f e : T E f e : I E f I <: I ' E f e : I ' E f ldc.i4 \ni4 : int32 E f ldc.i8 i8 : int64 X,...x : T ... f ldarg x : T E f I ok .elds(I) = T f E f e : T E f \ne newobj I : I E f e : [U/X]T mtype(I.m)= <X>T . T ' ' E f e call T ' I::m<U>(T) : [U/X]T ' E f e0: IE \nf e : [U/X]T mtype(I.m)= <X>T . T ' E f e0 e callvirt T ' I::m<U>(T) : [U/X]T E f e : I .elds(I)= Tf \nE f e : I ' E f e ' : I E f e ldfld Ti I::fi : Ti E f e isinst I or e ' : I Method and Class Typing: \nf md ok in C<X> f cd ok D(C)= class C<X>: I {U1 f1; md} X, Y,x : T f e : T f static Tm<Y>(Tx) { e} okin \nC<X> D(C)= class C<X>: I {U1 f1; md} X,x : T,this : C<X> f e : T f virtual Tm<Y>(Tx) { e} ok inC<X> .elds(I)= \nUg f and g disjoint f md ok in C<X> f class C<X>: I {Tf ; md} ok Value Typing: f i4 : int32 f i8 : int64 \n.elds(I)= Tf f v : T f I(f . v) : I Figure 3. Typing rules of BILG. f v : T Evaluation: fr f e . v (frame) \nfr ::= (x = v) fr f ldc.i4 i4 . i4 fr f ldc.i8 i8 . i8 (x = v) f ldarg xi . vi fr f e . v .elds(I)= \nTf fr f e newobj I . I(f . v) mbody(I.m<U>)= (x,e ') fr f e . v (x = v) f e '. v fr f e call T ' I::m<U>(T) \n. v fr f e0 . I ' (f . w) mbody(I ' .m<U>)= (x,e ') ' fr f e . v (this = I ' (f . w), x = v) f e . v \nfr f e0 e callvirt T ' I::m<U>(T) . v fr f e . I ' (f . v) fr f e ldfld TI::fi . vi fr f e . I ' (f . \nv) {} f I ' <: I fr f e isinst I or e '. I ' (f . v) ' fr f e . I ' (f . v) {} f I ' /<: I fr f e '. \nv ' fr f e isinst I or e '. v Figure 4. Evaluation rules of BILG. The typing rules are largely standard \nand shown in Figure 3. Fig\u00adure 2 de.nes some macros to help manipulate .elds and methods. In the interest \nof modelling the observable behaviours of BILG pro\u00adgrams, as opposed to a particular implementation, \nwe use a big-step evaluation semantics as shown in Figure 4. The variable this is re\u00adserved for self \npointers; it corresponds to argument 0 in the actual IL. A single stack frame suf.ces in de.ning the \nevaluation (most interestingly for the cases of method invocations) because of the simplicity of BILG. \nA generalization using a full-.edged stack of frames appeared in Gordon and Syme s Baby IL [7]. All of \nthe judgment forms and helper de.nitions assume a class table D. When we wish to be more explicit, we \nannotate judgments and helpers with D. We say that D is a valid class table if fD cd ok for each class \nde.nition cd in D. Theorem 1 (BILG evaluation preserves typing) Suppose that D is a valid class table, \nX,x : T fD e : T and fD vi : [U/X]Ti holds for all vi . v and Ti . T. If (x = v) fD e . w then fD w : \n[U/X]T. Proof sketch. By induction on the structure of the evaluation deriva\u00adtion. .  3 Target Language \nWhat makes the implementation of generic IL unique is that it com\u00adbines exact run-time types, shared \ncode and code specialization for non-uniform instantiations. To focus on these issues without be\u00ading \ndistracted by the largely orthogonal handling of object-oriented (type) T,U ::= X | int32 | int64 | I \n(inst ty) I ::= C<T> (ext ty) t ::= T | Rep(T) | Rep(M) (cnstrnt) s ::= ref | i4 | i8 (class) cd ::= \nclass C<X > s>:I {Tf ; md} with t (meth) md ::= static Tm<X > s>(t x) { e} with t | virtual Tm<X > s>(Tx) \n{ e}(mdesc) M ::= I::m<T> (desc) D ::= T | M (exp) e ::= i4 | i8 | x | I(e,e) | e call M | ee callvirt \nM | e ldfld I::f | e isinstIe or e | RT | RM | mkrepIe | mkrepM (e,e) | objdictie | mdictie (value) v \n::= i4 | i8 | I(v, v) | RT | RM (ty env) E ::= X > s,x : t Figure 5. Syntax of BILC. features [29], we \ndesigned our target language, Baby IL with Con\u00adstraints (BILC), to contain counterparts for all the expressions \nof BILG. The novelty of BILC lies in its support for constraints, term representations of types (or type-reps \nfor short), and dictionaries. The syntax of BILC is shown in Figure 5. Its type language is strati.ed \ninto types (T or U), which consist of all BILG types, and extended types (t), which support type-reps. \nExtended types oc\u00adcur explicitly in the syntax of static method de.nition, because our translation passes \na type-rep as an extra argument in static method calls. Type environments map type variables to constraints, \nand term variables to extended types. The remainder of BILC is best learnt by comparison with BILG, with \nan emphasis on the new fea\u00adtures. Constraints The implementation handles specialization and sharing based \non compatibility of instantiations. Two instantia\u00adtions are compatible, and their code can be shared, \nif for any pa\u00adrameterized class its compilation at these instantiations gives rise to identical code \nand other execution structures (e.g., .eld layout and GC tables), except for the instantiation-speci.c \ndictionaries de\u00adscribed below. A piece of specialized code is generated for each set of compatible instantiations \nreached in the program. To prevent specialized code from being instantiated with improper type argu\u00adments, \nconstraints on the representation of terms inhabited by types (not to be confused with type-reps) are \nintroduced. For instance, a natural choice is to let all reference types be compatible with each other, \nbecause objects of reference types are represented as point\u00aders, so no distinction is made for .eld layout \nor code generation; hence a natural constraint ref for all (terms of) reference types is useful. In BILC, \ntype parameters in generic class and method de.nitions are quali.ed with constraints (s) to limit the \ntype arguments with which the class or method can be instantiated. Besides the con\u00adstraint ref used for \nall reference types, there are two singleton constraints i4 and i8, satis.ed by int32 and int64 respectively. \nType-reps To support exact run-time types without using a type\u00adpassing interpretation, we represent run-time \ntype information by ordinary terms. These type-reps are analyzed by those expressions that require run-time \ntype information, such as object creation and type test. Value RT is the type-rep for T, for closed T. \nFor a type C<U> where U are open, the type-rep can be constructed using expression mkrepC<U>e, where \ne are the type-reps of U. We also introduce type-reps for method descriptors (M). They sim\u00adply provide \na means for referring to method descriptors at run-time. Value RM is the type-rep for closed M, and the \ntype-rep of open method descriptors can be constructed using a mkrep expression. We use the Rep type \nconstructor to assign types to type-reps. A type-rep of T or M has the type Rep(T) or Rep(M) respectively. \nDictionaries Type-reps are used by operations that require run\u00adtime type information. Inside a piece \nof shared code, the type-reps of open types cannot be determined statically they can only be constructed \nafter the type arguments are given. To avoid costly rep\u00adetition of these constructions, the implementation \nuses dictionaries to store type-reps for open types, which are pre-computed when a generic class or method \nis instantiated. Syntactically, a dictionary is simply a vector of values. In BILC, dictionaries for \nclasses and methods are accessed using expressions objdictie and mdictie respectively. Given e as an \nobject of the class instantiation or a type-rep of the method descriptor, the above two expressions fetch \nthe ith element out of the corresponding dic\u00adtionary. The type of the dictionary elements are explicitly \nspeci.ed by the with clause in the class and method de.nitions. The type system al\u00adlows these de.nitions \nto specify arbitrary dictionary types, as long as the dictionary elements are type-rep values. A dictionary \nmap d (mapping instantiated types and method descriptors to dictionar\u00adies) contains all the dictionaries \nthat the program may refer to, and their types match those speci.ed by the corresponding class and method \nde.nitions. Virtual methods do not take dictionaries, sim\u00adply because we do not make use of dictionaries \nto translate virtual methods. The remainder of BILC is relatively easy to understand. The types of BILC \ndo not affect evaluation, and run-time type information is acquired from type-reps. An object creation \nexpression I(e,e ' ) creates a new object whose type I has the type-rep e. A type test ' expression e \nisinstTe or e '' tests e against the type-rep e ' of type T. Types still occur inside this type test \nand some other expressions but only to enable BILC to be statically typed. For conciseness, we safely \nomit the argument and return types from method descriptors since we do not support overloading. Field \ntypes are also omitted from .eld access expressions. A new syntactic category of descrip\u00adtors is introduced \nto cover both types and method descriptors. As in BILG, the top of the class hierarchy object is handled \nspe\u00adcially. We use Rob j as the type-rep of object. Aside from the extra handling of constraints, type-reps, \nand dictionaries, the semantics are still in the style of Featherweight GJ. We use the following judg\u00adment \nforms to de.ne the static semantics. E f T > s (T satis.es constraint s in E) E f D ok (D well-formed \nin E) E f I <: I ' (I is subtype of I ' in E) E f e : T (e has type T in E) f md ok inC<X > s> (md well-formed \nin C<X > s>) f cd ok (cd well-formed) Macros for manipulating .elds and methods (Figure 6) are formu\u00ad \nField Lookup: .elds(object)= {} D(C)= class C<X > s>: I {U1 f1; md} with t .elds([T/X]I)= U2 f2 .elds(I)= \n... .elds(C<T>)= U2 f2, [T/X]U1 f1 Method Lookup: mtype(I.m)= ... mbody(I.m<T>)= ... D(C)= class C<X \n> s>: I {Uf ; md} with t m not de.ned in md mtype(C<T1>.m)= mtype([T1/X]I.m) mbody(C<T1>.m<T2>)= mbody([T1/X]I.m<T2>) \nD(C)= class C<X > s1>: I {Uf ; md} with t' static/virtual U ' m<Y > s2>(t x) { e} with t'' . md mtype(C<T1>.m)=[T1/X](<Y \n> s2>t . U ') mbody(C<T1>.m<T2>)= (x, [T1/X,T2/Y]e) Dict Type: dictty(I)= t dictty(M)= t D(C)= class \nC<X > s>: I {Uf ; md} with t dictty(C<T>)=[T/X]t ' D(C)= class C<X > s1>: I {Tf ; md} with t' static \nU ' m<Y > s2>(t x) { e} with t'' . md dictty(C<T>::m<U>)=[T/X,U/Y]t'' Figure 6. Macros on .elds and methods \nlookup for BILC. lated in largely the same way as those of BILG. The de.nitions are based on substitutions \nof types. Since types do not affect evalua\u00adtion, these substitutions can be viewed as no-ops at run-time. \nThe macro dictty simply collects the types of the dictionary elements to help ease the presentation of \nthe typing rules. The typing rules are shown in Figure 7 and Figure 8. A type is well\u00adformed in an environment \nonly if the environment contains all the type variables used in the type. An instantiated type or method \nde\u00adscriptor is well-formed if the type arguments satisfy the constraints as speci.ed by the judgment \nof constraint satisfaction. Class typ\u00ading makes sure that any type argument of a class which satis.es \nthe constraints can be safely used to instantiate the superclass; it also enforces that dictionaries \nonly contain type-reps. Method typings are straightforward extensions of those of BILG. The expression \ntyping takes into account the constraint satisfaction for method instantitations. Types of type-reps \nare checked to en\u00adsure that they indeed represent the types of interest. Typing the dicitionary access \nis straightforward given the macro dictty. As in the implementation, dictionaries of objects are accessed \nthrough the object record. Hence we choose to let objdictie obtain the dictio\u00adnary through the object \ne, instead of directly taking the correspond\u00ading type-rep. To obtain a modelling closer to the implementation \nand achieve more appealing erasure properties, we give a small-step reduction Subtyping: E f I <: I \n' <: I '' E f I <: I ' E f I ' E f I <: IE f I <: I '' D(C)= class C<X > s>: I {...} E f C<T> ok E f \nC<T> <: [T/X]I Expression Typing: E f e : IE f I <: I ' E f i4 : int32 E f e : I ' E f i8 : int64 X \n> s,...x : t... f x : t E f Iok E f e : Rep(I) .elds(I)= Tf E f e ' : T E f I(e,e ' ) : I mtype(I.m)= \n<X > s>t . TE f U > s E f e : [U/X]t E f e : t E f e call I::m<U> : [U/X]T ' mtype(I.m)= <X > s>T . TE \nf U > s E f e0: IE f e : [U/X]T ' E f e0 e callvirt I::m<U> : [U/X]T E f e : I .elds(I)= Tf E f e ldfld \nI::fi : Ti '' : I E f e : I ' E f e ' : Rep(I) E f e ' '' : I E f e isinstIe or e E f Tok E f M ok E \nf RT : Rep(T) E f RM : Rep(M) E f C<T> ok E f e : Rep(T) E f mkrepC<T>e : Rep(C<T>) E f C<T>::m<U> ok \nE f e : Rep(T) E f e ' : Rep(U) E f mkrepC<T>::m<U> (e, e ') : Rep(C<T>::m<U>) E f e : I dictty(I)= \nt E f objdictie : ti E f e : Rep(M) dictty(M)= t E f mdictie : ti Figure 7. Expression typing for BILC. \n Constraint Satisfaction: E f T > s X > s,x : t f Xi > si E f I > ref E f int32 > i4 E f int64 > i8 \nDescriptor Formation: E f D ok X > s,x : t f Xiok E f int32 ok E f int64 ok D(C)= class C<X > s>: I {...} \nwith t E f Tok E f T > s E f C<T> ok ' t' D(C)= class C<X > s1>: I {Tf ; md} with static/virtual U ' \nm<Y > s2>(t x) { e} with t'' . md E f C<T> ok E f Uok E f U > s2 E f C<T>::m<U> ok Class and Method \nTyping: f cd ok f md ok inC<X > s> X > s f I ok .elds(I)= Ug f and g disjoint f md ok in C<X > s> ti \n= Rep(...) f class C<X > s>: I {Tf ; md} with t ok D(C)= class C<X > s>: I {...} with t' t'' X > s,Y \n> s ' ,x : t f e : Ti = Rep(...) f static Tm<Y > s ' >(t x) { e} with t'' ok in C<X > s> D(C)= class \nC<X > s>: I {...} with t X > s,Y > s ' ,x : T,this : C<X> f e : T f virtual Tm<Y > s ' >(Tx) { e} ok \nin C<X > s> Figure 8. Class and method typing for BILC. ' semantics for BILC (Figure 9). The judgment \nd f e . e means under dictionary map d the expression e reduces to expression e ' . Substitutions of \nterms should be viewed as local bindings in an im\u00adplementation. We omit the usual congruence rules due \nto space constraints. A well-formed dictionary map is required for the safe execution of BILC programs. \nA dictionary map d is well-formed, written f d, if it maps every closed descriptor D to a vector of values \nd(D)= v such that {} f v : dictty(D). In practice, of course, one cannot im\u00adplement such an in.nite map \ndirectly; but observe that any partic\u00adular terminating program execution will only touch a .nite number \nof entries in the map. This can be implemented by lazy lookup and creation of dictionaries, as is the \ncase in the CLR. The most interesting reduction rules are those for type test; they show that type-reps \nare inspected at run-time. We use a rule for re.ected subtyping to handle these cases, lifting the static \nsub\u00adtype relation over closed types to a relation over type-reps. The reduction rule for object dictionary \nlookup (objdictiv) in\u00adspects the type-rep stored in the object for fetching a dictionary out of d. Although \nthe class instantiation also appears as the type tag of the object, it is not accessible at run-time \nwhen all types are Re.ected Subtyping: {} f I <: I ' RI . RI' Reduction: (congruence rules omitted) \nmbody(I.m<T>)= (x,e ') ' d f v call I::m<T> . [v/x]e v0 = I ' (v ' ,v '' ) mbody(I ' .m<T>)= (x,e ') \n' d f v0 v callvirt I::m<T> . [v0/this,v/x]e ' v = I ' (v ,v) .elds(I)= Tf d f v ldfld I::fi . vi v1 \n= I(v, v ' ) v . v2 v1 = I(v,v ' ) v ./ v2 d f v1 isinstTv2 or v3 . v1 d f v1 isinstTv2 or v3 . v3 vi \n= RTi d f mkrepC<T>v . RC<T> ' vi = RTi vi = RUi d f mkrepC<T>::m<U> (v, v ') . RC<T>::m<U> v = C<T>(RC<T>, \nw) d(C<T>)= v d f objdictiv . vi d(C<T>::m<U>)= vv = RC<T>::m<U> d f mdictiv . vi Figure 9. Reduction \nrules of BILC. erased. The reduction rule for method dictionary lookup (mdictiv), in contrast, directly \ninspects the type-rep argument. An inspection of the reduction rules shows that types are irrelevant \nfor the evaluation. A type-erasure semantics [5], in which all type\u00adrelated operations and parameters \nare erased, is presented in the companion technical report [28]. As in BILG, we annotate judgments and \nhelpers with the class table D when we wish to be more explicit. We say that D is a valid class table \nif fD cd ok for each class de.nition cd in D. Lemma 1 (BILC substitution) Suppose that D is a valid class \ntable. If X > s,x : t'fD e : t, f T > s, and fD v : [T/X]t' then fD [v/x,T/X]e : [T/X]t. Proof sketch. \nBy induction on the structure of the derivation X > s,x : t'fD e : t. . Theorem 2 (BILC progress) Suppose \nthat D is a valid class table. If fD d and {} fD e : t then either e is a value or there exists '' e \nsuch that d fD e . e . Proof sketch. By induction on the structure of the typing derivation. RI . RI \n' d f e . e class C<X>: C ' <X> { Xf ; static int32 m<Y>(Xx,Yy) { ... e1 newobj C1<> ... ' e2 isinst \nC2<X> or e2 ... e3 call int32 C3<X>::m3<Y>(int32) ... }} Figure 10. Example source program. Theorem 3 \n(BILC evaluation preserves typing) Suppose that D is a valid class table, X > s,x : t fD e : t, fD vi \n: [U/X]ti holds for ' all vi . v and ti . t, and fD d. If d fD [v/x,U/X]e . e then X > s,x : t fD e ' \n: t. Proof sketch. By induction on the structure of the evaluation deriva\u00adtion. .  4 Translation 4.1 \nOverview BILC as introduced in the previous section is expressive enough to demonstrate most of the key \nideas used in the implementation of generic IL. Run-time type information is captured using type\u00adreps. \nObjects contain the type-reps of their class instantiations; thus the class type-parameters can be accessed \nat run-time. To share code as much as possible and at the same time ef.ciently support exact run-time \ntypes, type-reps of open types are pre-computed and stored in dictionaries, which are passed in as an \nextra parameter for static methods, and accessed through the self pointer for non\u00adgeneric virtual methods. \nFor generic virtual methods, type-reps for open types can be constructed at run-time. All these features \nare studied in our formal translation. Based on the type arguments, every generic class or method is \ntrans\u00adlated into several specialized versions, with some of them shared by different instantiations. \nFollowing the current implementation, we use a global policy, generating unshared code for primitive \ninstan\u00adtiations and shared code for the rest. One can think of this policy as a partition {ref,i4,i8} \nof all closed types, with every type satis\u00adfying exactly one constraint. 4.2 Example We .rst give an \nexample to illustrate the idea of static method trans\u00adlation. The source program that we are compiling, \nas shown in Figure 10, is a simple generic class C<X> which de.nes a generic static method m<Y>. The \nbody of the method refers to an open type C2<X> and an open method descriptor C3<X>::m3<Y>. The translation \nspecializes the class C and its method m into sev\u00aderal versions in the target language, one for each \nconstraint in the partition, based on their type arguments. Given the above partition {ref, i4,i8}, we \nuse C@r as the class name for the specialized version of C where the type argument satis.es ref, and \nC@i4 and C@i8 for those where the type argument satis.es i4 and i8 re\u00adspectively. Similar mangling applies \nto the method name m. To access open descriptors inside static method bodies whose code is shared between \ndifferent instantiations, we let static methods take an extra argument as the type-rep of its own instantiation. \nThe callers of the method must provide the actual type-rep given the instantiation information. The type-rep \nof a static method instantiation contains enough infor\u00admation about the type arguments, which is suf.cient \nin constructing the type-reps of open descriptors. However, if the construction hap\u00adpens repetitively, \nextra overhead is incurred. We apply a lifting optimization where all the type-reps of open descriptors \nform a dic\u00adtionary which is constructed only once on the caller s side. Dictionary constructions are \nabstracted using the dictionary map (d) in our formalization. For any particular BILG method, all the \nsites where open types will be needed can be determined statically, and furthermore these type expressions \nare fully known statically with respect to the type parameters in scope. Our translation puts the types \nof the dictionary elements in the class or method de.nition for static type-checking. Based on these \ntypes and the fact that ev\u00adery representation type is inhabited by exactly one type-rep values, the dictionary \nmap simply maps any given class instantiations or method descriptors to their dictionaries. The statically \ndetermined dictionary layout indicates that one can access the dictionary for open descriptors by specifying \n.xed off\u00adsets. This is a much cheaper operation than the run-time construc\u00adtion of type-reps. Based on \nthis scheme, a translation of the above class C is shown in Figure 11, where we use |ei| to stand for \nthe translation of ei. Class C is specialized into three different classes C@r, C@i4 and C@i8. As indicated \nby the with clauses of the class de.nitions, the dictionaries of these specialized classes are empty. \nThis is be\u00adcause our translation makes use of dictionaries of classes for virtual methods only. Take \nthe de.nition of C@r as an example, the super class C ' is specialized based on the type argument. In \ncorrespondence with the method m in the source program, we now de.ne three special\u00adized versions. Method \nm@r suf.ces in explaining the idea of static method translation. Assuming C2<X> and C3<X>::m3<Y> are \nthe only open descriptors in the source program, the dictionary type is as shown in the with clause. \nWe let the method de.nition take an extra parameter xd , whose type dictates that only the actual type\u00adrep \nof the method can be passed in. Inside the method body, we use the dictionary lookup expression mdictixd \nto access for open type-reps. For the closed type C1<> in the source program, the cor\u00adresponding type-rep \nis statically known as RC1 <>. The remainder of the code is generated following similar ideas. In relation \nwith an actual implementation, the argument passed to static methods as xd can be understood as a pointer \nto the method s dictionary. The dictionary lookup operation mdict consists of de\u00adreferencing the dictionary \npointer and fetching an element based on a .xed offset. The potentially in.nite nature of the dictionary \nmap is handled by constructing dictionaries on-demand.  4.3 Formal Translation The above example illustrates \nthe translation of static methods, which makes use of a dictionary for each method instantiation. Al\u00adthough \nnon-generic virtual methods could use the same scheme, its non-generic nature allows optimizations. We \nlet the dictionary of a Specializing at ref class C@r<X > ref> : C '@r<X> {Xf ; static int32 m@r<Y > \nref> (Rep(C@r<X>::m@r<Y>) xd ,Xx,Yy) { ... C1<>(RC1<>,|e1|) ... class instantiation be a combined dictionary \nfor all its non-generic virtual methods. Inside a virtual method body, this dictionary can be accessed \nthrough the self pointer; thus there is no need to carry an extra argument. Generic virtual methods are \naltogether more challenging. The dic\u00adtionary map cannot generate an appropriate dictionary from the caller \ns side, because it is unknown statically which method body will be called. In our formalization, we fall \nback to construct type\u00adreps of open descriptors at run-time. This provides a good compari\u00adson with, and \ndemonstrates the advantage of, the dictionary-passing scheme used for static methods. We will discuss \nmore ef.cient im\u00adplementations for generic virtual methods in section 5. For simplicity, we omit the \nspecial treatment of non-generic classes, |e2| isinstC2@r<X> (mdict1xd ) or ' e 2 for which optimizations \nare straightforward. ... (mdict2xd ) |e3| call C3@r<X>::m3@r<Y> ... } with (Rep(C2@r<X>),Rep(C3@r<X>::m3@r<Y>)) \nstatic int32 m@i4<> (Rep(C@r<X>::m@i4<>) xd ,Xx,int32 y) { ... C1<>(RC1<>,|e1|) The formal translation \nroughly consists of expression translation, method translation, and class translation. Expression translation \nExpression translation is shown in Fig\u00adure 12. It is parameterized on a descriptor lookup function . \nand a specialization environment .. The function . returns type-reps for all descriptors (.(D) : Rep(D)). \nThe environment . maps type variables to their constraints (. ::= X . s). These are both provided by \nthe method translation. ... |e2| isinstC2@r<X> (mdict1xd ) or  ' e 2 Most parts of the expression translation \nsimply propagate the trans\u00ad ... (mdict2xd ) |e3| lation to sub-components. The only interesting cases \nare object cre\u00ad ation, run-time type test, and method invocation. Object creation call C3@r<X>::m3@i4<> \n... } with (Rep(C2@r<X>),Rep(C3@r<X>::m3@i4<>)) ...code for m@i8 omitted... } with ()  Specializing \nat i4 class C@i4<> : C '@i4<> {int32 f ; static int32 m@r<Y > ref> (Rep(C@i4<>::m@r<Y>) xd , int32 x,Yy) \n{ ... C1<>(RC1<>,|e1|) and run-time type test obtain type-reps using .. Static calls obtain the type-reps \nof the method descriptors and use them as an extra argument. There is nothing special about the translation \nof non\u00adgeneric virtual calls, because the implicit self pointer suf.ces in lo\u00adcating the dictionary. \nOn contrast, generic virtual calls require pass\u00ading in the type-reps of the type arguments to the generic \nmethod, so that type-reps of open types inside the target virtual method can be constructed. We de.ne \na few helpers to abstract operations used in the transla\u00adtion. Some target class or method may expect \nless type arguments due to specialization. This is captured as argument specialization, which performs \na target-to-target transformation on vector of types by throwing away anthing that is specialized for \na singleton con\u00adstraint. Type specialization tells us which constraint a type belongs to; it refers to \n. for the specialization choices of type variables. ... |e2| isinstC2@i4<> RC2@i4<> or ' e 2 Type translation \nis mostly straightforward. To translate an instanti\u00ad ated type, we .rst translate the type arguments \nrecursively. A spe\u00adcialized version of the class is then chosen, based on the constraints of these type \narguments. Furthermore, argument specialization .l\u00adters out types that are fully-specialized. Method \ndescriptor transla\u00adtion is de.ned similarly. Class translation As shown in Figure 13 (where the trivial \ntrans\u00adlation of object is omitted), a BILG class is translated into a set of classes in BILC, based on \nthe constraints of the type arguments X. These constraints form a specialization environment .. The set \nof all possible specialization environments for X is abstracted as SEnv(X). A target class is generated \nfor each . . SEnv(X). For a specialization environment ., the translation mangles the class name with \nthe constraints of the type arguments. The argu\u00adments are specialized properly, and the super class instantiation \nand .eld types are translated using type translation. ... (mdict1xd ) |e3| call C3@i4<>::m3@r<Y> ... \n} with (Rep(C3@i4<>::m3@r<X>)) ...code for m@i4 and m@i8 omitted... } with () Specializing at i8 Omitted. \n Figure 11. Translation of the example source program. Method Translation: |md|.. ,I = md  .,I virtual \nUm<>(Tx) { e} =virtual |U|. m<>( T . x) {|e|..} .  .,I .' static Um<Y>(Tx) { e} =static |U|...' m@s<Y' \n> ref>(td xd , T ...' x) {|e|...'} with t . .'.SEnv(Y) ' ' where .(Y)= s and Y %s = Yand td = Rep(I::m@s<Y \n>) and t is the dictionary type and .' = mdictt xd :td  .,C<X> .' virtual Um<Y>(Tx) { e} . =virtual \n|U|...' m@s<Y' > ref>(t z, T ...' x) {|e|...'} .'.SEnv(Y) ' where .(Y)= s and Y %s = Yand XY' = Z1,...,Zn \nand .' = mkrepZz:t and ti = Rep(Zi) and length of Y is greater than 0 Class Translation: |cd| = cd \n ' .,C@s<X > class C<X>: I {Tf ; md} =class C@s<X' > ref> : |I|. { T . f ; md } with t . ..SEnv(X) \nwhere .(X)= s and X %s = X' and t is the dictionary type and . = objdictt this:C@s<X'> Figure 13. Class \nand method translation. Given a BILG class de.nition, the dictionary types (t) of the trans\u00adlated BILC \nclasses can be determined by walking through all non\u00adgeneric virtual method bodies in the source and \ncollecting all open descriptors. Straightforward recursion over the program structure suf.ces in de.ning \nthis operation, whose lengthy de.nition is omit\u00adted due to space constraints. Based on the dictionary \ntype, the dictionary map d can easily gener\u00adate the actual dictionary for any given class instantiation. \nFor simi\u00adlar space concerns, we also omit a formal de.nition of this map. Once the dictionary layout \nof a class is determined, the descriptor lookup function . can be de.ned by applying the object dictionary \nlookup function (objdict) on the dictionary type and the self pointer. As shown in Figure 14, for a closed \ndescriptor, objdict returns its type-rep directly; for an open descriptor, objdict returns an expres\u00adsion \nwhich queries the proper dictionary slot for its type-rep. Given the descriptor lookup function ., the \nspecialization environ\u00adment ., and the class instantiation itself, every method in the source class is \ntranslated into a set of methods, and all these sets are com\u00adbined to form the methods of the target \nclass. Method translation Similar to classes, methods are translated into sets of specialized methods. \nFor simplicity, we assume implicit convertion between our set and vector notations. The translation of \na non-generic virtual method is simply performed by translating the signature and method body, passing \non the de\u00adscriptor lookup function . and specialization environment .. A static method is translated \ninto multiple versions based on all pos\u00adsible specialization environments .' of the method type arguments. \nAside from mangling method names, specializing type arguments, and deciding dictionary types, the interesting \npart of this transla\u00adtion is that an extra parameter is introduced. The type of this extra parameter \ndictates that the actual argument passed in can only be a type-rep of the method instantiation. For the \nmethod body to be able to look up open descriptors using the extra argument, the descrip\u00adtor lookup function \n.' is de.ned using method dictionary lookup (mdict, as shown in Figure 14), which returns type-reps for \nclosed descriptors, and dictionary lookup expressions for open descriptors based on the dictionary layout. \nThe remainder of static method translation involves translating the signature and method body, and passing \non the appropriate descrip\u00adtor lookup function .' and specialization environment . . .' to ex\u00adpression \ntranslation. In contrast, the translation of generic virtual methods takes the type\u00adreps of the type \narguments themselves as extra parameters. The descriptor lookup function .' is de.ned using run-time \nlookup (mkrep), which returns expressions that construct type-reps at run\u00adtime when necessary. By comparing \nmethod dictionary lookup (mdict) and run-time lookup (mkrep), it is clear that the dictionary-passing \nscheme (which involves only de-referencing and numeric indexing) is more ef.cient than building type-reps \nat run-time (which involves the mkrep operation). In the actual implementation of generic IL, a scheme \nbased on run-time lookup is typically slower by at least an order of magnitude than one based on dictionary-passing \n[14]. Soundness of translation We .rst de.ne a translation of a type environment E given a dictionary \nenvironment . and a matching specialization environment . that covers all type variables in E. In the \ncase where . is an object dictionary lookup function, the type translation of E is unde.ned if the binding \nfor the self pointer argu\u00adment (x : t) does not occur in E. This is merely used to simply the soundness \nproof.  Exp Translation: . |ldc.i4 i4| . |ldc.i8 i8|.. |ldarg x|.. |e newobj I|.. |e call M|.. |e0 e \ncallvirt M|.. |e0 e callvirt M|.. |e ldfld TI::f |.. |e isinst I or e1|.. ' = e |e|.. = i4 = i8 = x = \n|I|.(eR,|e|.. ) where eR = .(|I|.) = ed |e|.. call |M|. and ed = .(|M|.) = |e0|.. |e|.. callvirt |M|. \nif M non-generic = |e0|. eR |e|.. callvirt |M|. . where |M|. = C<T>::m<U> and eR = .(TU) = |e|.. ldfld \n|I|.::f = |e|.. isinst|I|. eR or |e1|. . where eR = .(|I|.) Object dictionary lookup: objdictt x:t(D)= \ne if D closed objdictt x:t(D)= RD objdictix if ti = Rep(D) Method dictionary lookup: mdictt x:t(D)= \ne RD if D closed mdictt x:t(D)= mdictix if ti = Rep(D) Run-time lookup: mkrepXx:t(D)= e mkrepXx:t(Xi)= \nxi mkrepXx:t(D)= RD, if D closed mkrepXx:t(C<T>)= mkrepC<T>(e) where ei = mkrepXx:t(Ti) mkrepXx:t(C<T>::m<U>)= \nmkrepC<T>::m<U>(ee ') where ei = mkrepXx:tTi ' ei = mkrepXx:tUi Figure 14. Descriptor lookup. X,x : T \n. = X %.(X) > ref,x : T . objdictt x:t X,x : T = X,x : T . (if x : t . X,x : T .) . mdictt X,x : Tx:t \n= X,x : T . ,x : t . mkrepX % .(X) X,x : Tz:t = X,x : T . ,z : t . Based on our formal translation, a \nvalid class table D of BILG is ' translated into a valid class table Dof BILC. The following type\u00adpreservation \ntheorem on the translation of expressions can be used to derive the preservation of well-formedness on \nthat of methods and classes, and hence the above preservation of valid class tables. Note that although \nexpression typing assumes a class table, it only Type Specialization: spec.(int32) spec.(int64) spec.(X) \nspec.(C<T>)  Type Translation: |int32|. = int32 |int64|. = Arguments Specialization: T % s = T' [ ] \n%[] = [] (T, T)%(s,s) = T,T %s T % s if s = ref otherwise spec.(T)= s = = = = i4 i8 .(X) ref |T|. = \nT ' |X|. = .. int64 uses it in syntactic ways. Thus our type-preservation theorem of X if .(X)= ref \nexpression translation does not reply on the preservation theorem int32 if .(X)= i4 of valid class tables. \n. C<T> . = int64 if .(X)= i8 Theorem 4 (Type preservation) If D is a valid class table and C@s< T . %s> \nwhere s = spec.(T) ' translates to D, E fD e : T, . is a matching specialization |M|. = M '  Method \nDescriptor Translation: UI::m<T>(U) . = |I|.::m@s< T . %s> where s = spec.(T) ' Value Translation: |v|. \n= v |i4|. = i4 |i8|. = i8 I(f . v) . = |I|.(R|I|. ,|v|.) Figure 12. Expression translation. environment \nof E, and . satis.es that |E|.. fD' .(D) : Rep(D) holds for any D . dom(.), then |E|.. fD'|e|.. : |T|.. \nProof sketch. The proof is done straightforwardly by induction on the structure of the derivation E fD \ne : T, after factoring out lemmas on .eld and method lookup macros and subtyping. The key point is that \nthese lemmas only refer to the class table in syntactic ways. Expressions of BILG are all translated \ninto their counterparts in BILC. Although some of them refer to BILC expression on type\u00adreps and dictionaries, \nthey only do so through the descriptor lookup function ., whose result types are the desired ones by \nassumption. Our translation is also semantics-preserving. This theorem is for\u00admalized by assuming a correct \ndescriptor lookup function . which yields expressions that reduce to the correct type-rep. Theorem 5 \n(Semantics preservation) Suppose D is a valid class ' table and translates to D' , fD' d. Suppose X,x \n: T fD e : T , fD v : [U/X]T, . . SEnv(X), spec.(U)= .(X)= s, and . . satis.es that X, x : T . fD' .(D) \n: Rep(D) for any D . dom(.). Let X' > ref,x : t,x ' : t' = X, x : T .. and U' = U . % s. If (x = v) fD \n[U/X]e . w, and fD' v ' : [U' /X']t', then . d fD' [v ' /x ' ,|v|./x][U/X]e . .* |w|.. Proof sketch. \nThe proof is done straightforwardly by induction on the structure of the derivation (x = v) fD e . w, \nafter factoring out lemmas on .eld and method lookup macros. Translations of BILG expressions do not \ndirectly refer to d, because they do not refer to BILC expressions on type-reps and dictionaries directly. \nThey are abstracted away by the descriptor lookup function ., whose result types are the desired representation \ntypes by assumption. These result expressions reduce to the desired type-reps, because repre\u00adsentation \ntypes are singleton types. ..  Discussion and Related Work Type-reps BILC makes use of term-level type-reps \nfor opera\u00adtions that require exact run-time types, avoiding a type-passing in\u00adterpretation (that is, \none in which type parameters are interpreted both statically and as values passed at runtime). In spirit \nour type\u00adreps are similar to those of intensional type analysis (ITA) [5] in that every representation \ntype (the Rep construct of BILC) is in\u00adhabited by exactly one type-rep value, hence type-reps faithfully \nre.ect type information at run-time. However, the handling of type\u00adreps in BILC is quite different from \nthat of ITA. Most importantly, our type-reps are based on names of types, instead of structures. In particular, \nBILC does not provide a structural way of construct\u00ading and deconstructing type-reps. Instead, type-rep \nconstruction is abstracted using a primitive mkrep, and the type-rep values (RD) are inspected by expressions \nthat require types at run-time. For in\u00adstance, the type test expression (isinst) inspects type-reps based \non a re.ected subtyping relation. (It is interesting to note that the ef.cient implementation of re.ected \nsubtyping tests are the subject of much recent research [23]). We also extended the idea of name-based \ntype-reps to method de\u00adscriptors. This greatly simpli.es the handling of dictionaries. In the actual \nimplementation of IL generics, a dictionary may contain both type-reps and pointers to other dictionaries, \nexhibiting a graph structure. Our Rep and R constructs are simply based on names, relying on the dictionary \nmap (d) to provide a level of indirec\u00adtion to connect related dictionaries. This avoids the direct tackling \nof recursion and sharing in dictionaries. The dictionary map also helps to abstract away from the potential \nin.nite nature of dictio\u00adnaries due to polymorphic recursion. An implementation can pro\u00advide a map which \nbuilds these dictionaries on demand. In contrast, a model that makes explicit all these features appears \nto require higher-kinded recursive types, whose formalization is conceivable, but certainly less accessible \n(see later). Name-based type-reps may also be an appropriate model for other features that demand name \nequivalence, such as re.ection and seri\u00adalization. For example, the CLR class System.Type (equivalently, \njava.lang.Class in Java) could be modelled by the existential .X.Rep(X). Value classes Our formalization \ncan be extended to support pa\u00adrameterized value classes (called structs in C.), a distinctive feature \nof which is that runtime types are not carried by values, since sub\u00adtyping on value types is not supported. \nHence to support sharing of method code in value classes, all methods must be passed an extra method-rep \nargument providing access to a dictionary. Constraints on type parameters can be extended to support \nsharing of generic classes across distinct value class instantiations, for ex\u00adample using the same code \nfor Set<Point> and Set<Size> where Point and Size are both value classes with two int .elds. The grammar \nof constraints would be extended with syntax {s} denot\u00ading a .eld layout ; a value class would satisfy \nsuch a constraint if its constituent .elds satis.ed the constraints s component-wise. Such constraints \nlead to in.nitary class specialization; the transla\u00adtion of classes and methods as shown in Figure 13 \nthen truly ab\u00adstracts away from the implementation, which clearly cannot be re\u00adalized by static compilation! \nSpecialization policies We make the observation that the spe\u00adcialization policy need not be .xed in the \nimplementation, and fur\u00adthermore other interesting policies exist, such as generating spe\u00adcialized code \nfor type arguments that are string. In fact, our for\u00admalization can be customized using different partitionings \nof the set of all closed types. For a partitioning to be valid regarding the translation, obvious requirements \ninclude that it must be complete (covering all closed types) and disjoint (no type belongs to more than \none partitions). It must also provide constraint satisfaction, argument specialization, and type specialization \njudgments. Keen readers may have noticed that we explicitly specify constraints in BILC even though all \ntype arguments have the same constraint ref. This allows us to accomodate easily other specialization \npolicies. A less obvious necessary condition is that it must be congru\u00adent with respect to the structure \nof the types. For example, for the actual implementation we considered generating specialized code for \nall value classes, thus avoiding any dictionary lookups at runtime, but this does breaks congruence: \nfor example, string shares the same constraint as object but Pair<string,string> and Pair<object, object> \nwould be distinct, if Pair is a two\u00adparameter value class. Then a generic method m<X> that references \nPair<X,X> cannot be specialized under the constraint X > ref be\u00adcause no appropriate specialization of \nPair exists. Moving in the other direction, towards less specialization and more sharing, it is worth \nnoting that types with different constraints can be shared if coercion operations such as boxing are \nemployed. Generic virtual methods Virtual methods which are themselves generic introduces a new level \nof expressivity in the system of poly\u00admorphism that supports a kind of .rst-class polymorphism [15]. \nThe implementation of this in the presence of in.nitary code\u00adspecialization requires JIT compilation, \nand when combined with dictionaries requires some new implementation techniques. In particular an appropriate \ndictionary cannot be generated from the caller s side. Our formal translation constructs type-reps of \nopen descriptors inside generic virtual methods at run-time, to demon\u00adstrate the advantage of dictionary \npassing. Nonetheless, there are more ef.cient schemes for implementing generic virtual methods, e.g., \none may arrange to let the callee construct the dictionary and reuse it inside the method body. Although \ndifferent method calls of the same instantiation would repeat the dictionary construction, the cost is \nstill amortized inside a single method call. Structural typing Our target language BILC essentially embeds \nin its type system the source types of BILG. This simpli.es the for\u00admal type system and semantics, and \nabstracts away the complexities of inheritance and virtual method dispatch. An alternative approach is \nto encode source types in a lower-level language possessing structural type equivalence; typically this \nlan\u00adguage is based on a foundational calculus such as F.. Of course, modelling inheritance and virtual \nmethods is not trivial, for exam\u00adple involving existentials and recursive types, features that would \nnot be considered lightly by an implementer. But dispensing with nominal typing brings bene.ts: more \noptimiza\u00adtions can be expressed, and choices of representation made more explicit. For example, given \na generic class C<X> and an instanti\u00adation C<string> we might specialize the code to produce a class \nC@string, but also generate code for C@ref<X > ref> that can be used for any reference type instantiation. \nPolymorphic contexts would use the latter code, whilst the specialized code would be used when the instantiation \nis known to be string. This requires that C@ref<string> be type-equivalent to C@string. Type-theoretic \nconstructs such as \u00d7 and \u00b5 make it possible to de\u00adscribe the types of dictionaries without the use of \nnames for method dictionaries. For example: Suppose a generic method m<X> uses the open type Vec<X> \nand invokes two methods n<X> and p<X> which both in turn invoke q<X> which uses the type Set<X>. Then \nthe type of the dictionary passed to m<string> can be ex\u00adpressed as Rep(Vec<string>) \u00d7 (Rep(Set<string>) \n\u00d7 Rep(Set<string>)).  Cycles in dictionary types can be expressed using recur\u00adsive types. For example, \nsuppose m<X> uses type Vec<X> and invokes n<X> which in turn uses Set<X> and invokes m<X>. The type of \nthe dictionary passed to m<string> is \u00b5D.Rep(Vec<string>) \u00d7 (Rep(Set<string>) \u00d7 D).  Polymorphic recursion \nrequires the use of higher-kinded re\u00adcursive types. For example, suppose m<X> uses Vec<X> and then invokes \nm<Set<X>>. The type of the dic\u00adtionary passed to m<string> is (\u00b5D..X.Rep(Vec<X>) \u00d7 D(Set<X>)) string. \n Previous approaches to implementing polymorphism Tradi\u00adtionally, implementation techniques for parametric \npolymorphism have employed a uniform representation for values used in poly\u00admorphic contexts so that \neach polymorphic function is compiled to a single piece of native code. In general, this requires expensive \nboxing for primitive types such as int and float, and a great deal of research involves cunning ways \nof alleviating this cost by reposi\u00adtioning or removing altogether the box and unbox operations [16]. \nFurthermore, most research has concentrated on ML-like languages with purely static type systems in which \nsource types do not affect evaluation. Interestingly, much recent work on the implementa\u00adtion of polymorphism \nhas reintroduced types into evaluation ( in\u00adtensional type analysis ) so that polymorphic code can switch \non the type at which it is used [9, 25]. The manipulation of types at runtime can be expensive, particularly \nthe construction of types from type parameters that are not known statically. It is possible to avoid \nall runtime type construction by lifting type applications to top-level, which can be considered link-time \n[24]. This technique is similar to our use of dictionaries which can be created just once. Similar type \ndictionary techniques are employed by Viroli and Na\u00adtali [27] in their implementation of generics for \nJava. In their source-to-source translation, a single non-generic class in the tar\u00adget is used for all \ninstantiations of a generic class in the source (only reference instantiations are permitted). Dictionaries \n(which they call friend types) are manipulated using re.ection features of Java. Code specialization \n(monomorphization) is rarely used as an imple\u00admentation technique. The idea of specializing by representation \n(in\u00adstead of source type) as used in the implementation of CLR generics has also been applied to whole \nprogram compilation for Standard ML [2]. 6 Conclusion and Future Work We have presented a formalization \nof the generics implementation for the .NET Common Language Runtime, combining code shar\u00ading, code specialization \nand ef.cient support for run-time types, using dictionaries. In particular, we presented a type-preserving \nand semantics-preserving translation from BILG, which is a minia\u00adture formalization of Generic IL, to \nBILC, which abstracts the ex\u00adtended Common Language Runtime for generics. This work not only serves as \nan application of advanced type theories to a widely used industrial product and helps understanding \npossible imple\u00admentation techniques, but also yields interesting research results, such as name-based \ntype-reps. Potential future work includes extensions on other language fea\u00adtures (e.g., value types), \nfurther translation down to lower-level lan\u00adguages (e.g., TAL [19]), a separate modelling of the generics \nimple\u00admentation in a lower-level calculus with structural equivalence (e.g., FLINT [26]), and formalizing \nJust-In-Time compilation to support laziness. 7 References [1] O. Agesen, S. N. Freund, and J. C. Mitchell. \nAdding parame\u00adterized types to Java. In Object-Oriented Programming: Sys\u00adtems, Languages and Applications \n(OOPSLA), October 1997. [2] P. N. Benton, A. J. Kennedy, and G. Russell. Compiling Stan\u00addard ML to Java \nbytecodes. In 3rd ACM SIGPLAN Inter\u00adnational Conference on Functional Programming, September 1998. [3] \nG. Bracha, M. Odersky, D. Stoutamire, and P. Wadler. Mak\u00ading the future safe for the past: Adding genericity \nto the Java programming language. In Object-Oriented Programming: Systems, Languages, Applications (OOPSLA), \nOctober 1998. [4] R. Cartwright and G. L. Steele. Compatible genericity with run-time types for the Java \nprogramming language. In Object-Oriented Programming: Systems, Languages, Applications (OOPSLA), October \n1998. [5] K. Crary, S. Weirich, and G. Morrisett. Intensional poly\u00admorphism in type-erasure semantics. \nIn International Con\u00adference on Functional Programming, pages 301 312. ACM Press, Sept. 1998. [6] Ecma \nInternational. ECMA and ISO C# and Common Language Infrastructure standards. See http://msdn. microsoft.com/net/ecma/. \n[7] A. Gordon and D. Syme. Typing a multi-language interme\u00addiate code. In 27th Annual ACM Symposium on \nPrinciples of Programming Languages, January 2001. [8] J. Gosling, B. Joy, G. Steele, and G. Bracha. \nThe Java Lan\u00adguage Speci.cation (Second Edition). Addison-Wesley, 2000. [9] R. Harper and G. Morrisett. \nCompiling polymorphism using intensional type analysis. In Proceedings of the Symposium on Principles \nof Programming Languages, pages 130 141, San Francisco, California, Jan. 1995. ACM Press. [10] A. Hejlsberg. \nThe C. programming language. Invited talk at Object-Oriented Programming, Systems, Languages and Ap\u00adplications \n(OOPSLA), 2002. [11] A. Hejlsberg and S. Wiltamuth. C# 2.0 language reference. See http://msdn.microsoft.com/vcsharp/. \n[12] A. Igarashi, B. C. Pierce, and P. Wadler. Featherweight Java: A minimal core calculus for Java and \nGJ. In Conference on Object-Oriented Programming, Systems, Languages and Ap\u00adplications (OOPSLA), 1999. \n[13] A. Jeffrey. Generic Java type inference is unsound. The Types Forum, December 2001. [14] A. J. Kennedy \nand D. Syme. Design and implementation of generics for the .NET Common Language Runtime. In Programming \nLanguage Design and Implementation. ACM, 2001. [15] A. J. Kennedy and D. Syme. Transposing F to C#: Expres\u00adsivity \nof parametric polymorphism in an object-oriented lan\u00adguage. In Concurrency and Computation: Practice \nand Ex\u00adperience, to appear. [16] X. Leroy. Unboxed objects and polymorphic typing. In 19th symposium \nPrinciples of Programming Languages, pages 177 188. ACM Press, 1992. [17] T. Lindholm and F. Yellin. \nThe Java Virtual Machine Speci.\u00adcation (Second Edition). Addison-Wesley, 1999. [18] Microsoft Corporation. \nThe .NET Common Language Run\u00adtime. See http://msdn.microsoft.com/net/. [19] G. Morrisett, D. Walker, \nK. Crary, and N. Glew. From System F to typed assembly language. In 25th ACM Symposium on Principles \nof Programming Languages, pages 85 97. ACM Press, Jan. 1998. [20] A. C. Myers, J. A. Bank, and B. Liskov. \nParameterized types for java. In 24th ACM Symposium on Principles of Program\u00adming Languages, pages 132 \n145, January 1997. [21] M. Odersky, E. Runne, and P. Wadler. Two ways to bake your Pizza translating \nparameterised types into Java. Technical Report CIS-97-016, University of South Australia, 1997. [22] \nM. Odersky and P. Wadler. Pizza into Java: Translating theory into practice. In Proc. 24th ACM Symposium \non Principles of Programming Languages, January 1997. [23] K. Palacz and J. Vitek. Subtype tests in real \ntime. In European Conference on Object Oriented Programming, 2003. [24] B. Saha and Z. Shao. Optimal \ntype lifting. In Types in Compi\u00adlation Workshop, pages 156 177, Kyoto, Japan, March 1998. [25] Z. Shao. \nFlexible representation analysis. In Proc. 1997 ACM SIGPLAN International Conference on Functional Program\u00adming \n(ICFP 97), pages 85 98, Amsterdam, The Netherlands, June 1997. [26] Z. Shao. An overview of the FLINT/ML \ncompiler. In Proc. 1997 ACM SIGPLAN Workshop on Types in Compilation, June 1997. [27] M. Viroli and A. \nNatali. Parametric polymorphism in Java: an approach to translation based on re.ective features. In Confer\u00adence \non Object-Oriented Programming, Systems, Languages and Applications (OOPSLA). ACM, October 2000. [28] \nD. Yu, A. Kennedy, and D. Syme. Formalization of generics for the .NET Common Language Runtime. Technical \nreport, Microsoft Research, 2003. To appear. [29] D. Yu, V. Trifonov, and Z. Shao. Type-preserving compila\u00adtion \nof Featherweight IL. In Proc. 2002 Workshop on Formal Techniques for Java-like Programs (FTfJP 02), June \n2002.  \n\t\t\t", "proc_id": "964001", "abstract": "We present a formalization of the implementation of generics in the .NET Common Language Runtime (CLR), focusing on two novel aspectsof the implementation: mixed specialization and sharing, and efficient support for run-time types. Some crucial constructs used in the implementation are dictionaries and run-time type representations. We formalize these aspects type-theoretically in a way that corresponds in spirit to the implementation techniques used in practice. Both the techniques and the formalization also help us understand the range of possible implementation techniques for other languages, e.g., ML, especially when additional source language constructs such as run-time types are supported. A useful by-product of this study is a type system for a subset of the polymorphic IL proposed for the .NET CLR.", "authors": [{"name": "Dachuan Yu", "author_profile_id": "81100471723", "affiliation": "Yale University, New Haven, CT", "person_id": "PP28016610", "email_address": "", "orcid_id": ""}, {"name": "Andrew Kennedy", "author_profile_id": "81100450709", "affiliation": "Microsoft Research, Cambridge, U.K.", "person_id": "PP14158369", "email_address": "", "orcid_id": ""}, {"name": "Don Syme", "author_profile_id": "81100612953", "affiliation": "Microsoft Research, Cambridge, U.K.", "person_id": "P68181", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/964001.964005", "year": "2004", "article_id": "964005", "conference": "POPL", "title": "Formalization of generics for the .NET common language runtime", "url": "http://dl.acm.org/citation.cfm?id=964005"}