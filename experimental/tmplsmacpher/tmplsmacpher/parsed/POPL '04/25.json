{"article_publication_date": "01-01-2004", "fulltext": "\n Principal Typings for Java-like Languages * Davide Ancona Elena Zucca DISI -Universita di Genova `DISI \n-Universit` a di Genova Via Dodecaneso, 35 Via Dodecaneso, 35 16146 Genova, Italy 16146 Genova, Italy \ndavide@disi.unige.it zucca@disi.unige.it Abstract The contribution of the paper is twofold. First, we \nde.ne a general notion of type system equipped with an entailment relation between type environments; \nthis generalisation serves as a pattern for instan\u00adtiating type systems able to support separate compilation \nand inter\u00adchecking of Java-like languages, and allows a formal de.nition of soundess and completeness \nof inter-checking w.r.t. global compila\u00adtion. These properties are important in practice since they allow \nselective recompilation. In particular, we show that they are guaran\u00adteed when the type system has principal \ntypings and provides sound and complete entailment relation between type environments. The second contribution \nis more speci.c, and is an instantiation of the notion of type system previously de.ned for Featherweight \nJava with method overloading and .eld hiding. The aim is to show that it is possible to de.ne type systems \nfor Java-like languages, which, in contrast to those used by standard compilers, have principal typ\u00adings, \nhence can be used as a basis for selective recompilation. Categories and Subject Descriptors: D.3.3[Programming \nlanguages]: Language constructs and features classes and objects; D.3.1[Programming languages]: For\u00admal \nde.nitions and theory syntax, semantics; D.3.4[Programming languages]: Processors incremental compilers \nGeneral Terms: languages, theory, design Keywords: principal typings, selective recompilation, Java-like \nlanguages * Partially supported by Dynamic Assembly, Recon.guration and Type-checking -EC project IST-2001-33477, \nAPPSEM II -The\u00admatic network IST-2001-38957, and Murst NAPOLI -Network Aware Programming: Oggetti, Linguaggi, \nImplementazioni. Permission to make digital or hard copies of all or part of this work for personal or \nclassroom use is granted without fee provided that copies are not made or distributed for pro.t or commercial \nadvantage and that copies bear this notice and the full citation on the .rst page. To copy otherwise, \nto republish, to post on servers or to redistribute to lists, requires prior speci.c permission and/or \na fee. POPL 04, January 14 16, 2004, Venice, Italy. Copyright 2004 ACM 1-58113-729-X/04/0001 ...$5.00 \n  1 Introduction The fact that separate compilation is a highly desirable property is a generally accepted \nprinciple. However, as pointed out in the seminal Cardelli s paper [4], even though module mechanisms \nhave received considerable theoretical attention, the notion of separate compilation and the associated \nnotion of linking have not been em\u00adphasized, and there is little work on formal models for them; as a \nconsequence, despite of the popularity of the word, it is often dif.cult to establish in a precise way \nwhether a programming envi\u00adronment actually supports separate compilation or not. The mentioned paper \n[4] can be considered a milestone in this di\u00adrection and is based on the de.nition of a simple formal \nframework where separate compilation, which is there simpli.ed to typecheck\u00ading, is modeled by a judgment \nG f s : t. The intended meaning is that s is a source fragment assumed to be open, that is, to contain \nreferences to names de.ned in other fragments, t is the resulting type, and G is a type environment intuitively \ncontaining all the as\u00adsumptions on other fragments needed to typecheck s. In this paper we are also interested \nin code generation, since, as we will show later, in Java-like languages different bytecode is produced \nunder different assumptions in G; hence, we model separate compilation by a judgment Gfs:t.b where b \nis the binary fragment generated by the compilation of s. A source fragment is a compilation unit, and \nexports one or more names to other fragments. For instance, in the case of Java-like languages, the most \nelementary (non-empty) compilation unit cor\u00adresponds just to a class declaration, but several class declarations \ncan be part of the same compilation unit as well, as happens for all Java systems. Hence, in general, \ns will be a sequence of declara\u00adtions (e.g., class declarations in Java) and t a sequence of types for \nthe declared class names. At this point, given a collection of successfully compiled fragments, it is \npossible to test whether they successfully inter-check, that is, the mutual assumptions between fragments \nare satis.ed. Formally, we have a linkset Gi fsi:ti.bii.1..n and we have to check that, for each i . \n1..n, assumptions Gi required by si are matched by other fragments1, in a sense to be made precise depending \non the nature of the type assumptions. For instance, in the simple case in which a type environment is \njust 1Here we simplify the presentation by considering only self\u00adcontained linksets; in the following, \nlinksets will be possibly open, that is, they will also include a type environment containing as\u00adsumptions \non the external fragments. a sequence of pairs c : t meaning that the entity (e.g., class) named c should \nhave type t, inter-checking just amounts to check that, for each i, j . 1..n, if c : t appears in G j, \nthen t must be the same type c has in ti (as it is in [4]). However, a type environment could in general \ncontain other kinds of type assumptions, such as subtyping assumptions c1 = c2 or others depending on \nthe language we are considering. Hence, we need a de.nition of inter-checking which abstracts from the \nparticular form of type assumptions. In this paper we provide such a de.nition (De.nition 8), based on \nthe idea that an effective inter-checking procedure can be modeled by an entailment relation f on type \nenvironments, so that inter\u00adchecking succeeds if c1: t1,...cm : tm f Gi holds for all i . 1..n, where \nc1,...,cm are all the classes declared in the linkset and, for all j . 1..m, tj is the type derived for \nc j in the linkset. Intuitively, this means that it is possible to prove all the required type assump\u00adtions \nwhenever fragment types are those in the linkset. The advantages of separate compilation plus inter-checking \nw.r.t. global compilation of s1,...,sn altogether are clear. Each frag\u00adment can be compiled without inspecting \nthe fragments it depends on; then, a collection of fragments can be put together to form an executable \napplication by just considering the type information (type environment and type) of fragments, without \nany need of re\u00adinspecting code. However, in order to really offer these advantages, inter-checking should \nsatisfy some properties which ensure that it can actually replace global compilation. This issue was \nnot con\u00adsidered in [4] and its formalization in the abstract framework for inter-checking described above \nis the .rst main contribution of this paper. Of course, inter-checking should at least be sound w.r.t. \nglobal com\u00adi.1..n pilation, in the sense that, if for some linkset Gi fsi:ti bi inter-checking succeeds, \nthen we can be sure that compiling alto\u00adgether s1,..., sn we successfully get the same binary fragments. \nThis is a minimal property which we expect to be always satis.ed by separate compilation (De.nition 10), \nand which is guaranteed under the hypothesis that the entailment relation is sound (Theo\u00adrem 11). Consider \nnow the situation in which inter-checking fails. This means that there is some type assumption in some \nGi which is not satis.ed by the types of other fragments. However, this does not necessarily mean that \nthe fragments cannot be safely linked. In\u00addeed, in general for each pair (s,b), many judgments G fs:t \nb can be derived, and for some fragment we could have taken a too restrictive type environment (that \nis, containing unnecessary type assumptions). We can be sure that this is not the case only if the typing \n(G, t) gives all the type information about (s, b), that is, represents all possible typings of (s,b); \nin other words, G contains only the type assump\u00adtions that are strictly needed for compiling s generating \nb. This property can be expressed by saying that (G,t) is a principal typing of (s,b), and has been recently \nformalized in a general setting (that is, independent of the particular type system we are considering) \nin [14]. If (G1,t1), ..., (Gn,tn) are principal typings for (s1,b1), ..., (sn,bn), respectively, then \nwe can be sure that no further type infor\u00admation about fragments can be obtained by re-inspecting the \ncode, hence failure of inter-checking was not due to our particular choice of typings. Hence, we can \nconclude that global compilation would either fail as well, or would produce different binary fragments. \nWe will call completeness of inter-checking w.r.t. global compila\u00adtion the fact that, with a suitable \nchoice of typings in linksets, failure of inter-checking guarantees that we could not generate the binary \nfragments in the linkset by global compilation (De.nition 12). We show that a suf.cient condition for \nthis is that the type system sup\u00adports principal typings and complete environment entailment rela\u00adtion \n(Theorem 14). The second contribution of this paper is more speci.c, and is an instantiation of the notion \nof type system previously de.ned for Featherweight Java [8] enriched by overloading and hiding. The aim \nis to show that it is possible to de.ne type systems for Java-like languages, which, in contrast to those \nused by standard compilers, have principal typings, hence can be used as a basis for selective recompilation. \nWe brie.y explain the essence of the problem of .nding princi\u00adpal typings for Java-like languages on \na simple example (more ex\u00adtended discussions and other examples can be found in [3, 2]). Consider the \nfollowing class: class C extends Parent { ... Type1 m (Type2 x) { return new Used().g(x);} } Let us wonder \nwhich is the minimal type information on other classes needed for typechecking the class and generating \nthe cor\u00adresponding bytecode. For classes Type1 and Type2, since they are just used as pure types, it \nis enough to assume that they exist (we will model this in our type system by type assumptions .Type1, \n.Type2). Looking at the method call, we can say that the class C can be type\u00adchecked in any type environment \nwhere a class Used is available which provides, besides the default constructor, a method (either directly \ndeclared or inherited) with name g and one parameter of a supertype of Type2; moreover we have the constraint \nthat its re\u00adturn type must be a subtype of Type1. For instance, class C can be typechecked in the following \ncontext (1): class Parent{} class Type1{} class Type2 extends Type1{} class Type3 extends Type2{} class \nUsedParent { Type3 g(Type1 x) { ...}} class Used extends UsedParent {} and also in this context (2): \nclass Parent{} class Type1{} class Type2 extends Type1{} class Used { Type2 g(Type2 x) {...} int f() \n{...} } Hence, we would be tempted to express this by a type assumption expressing that class Used must \nhave a method g with one parame\u00adter of a supertype of Type2 and return type subtype of Type1. How\u00adever, \nin order to produce the corresponding bytecode, a Java com\u00adpiler must know exactly which are the parameter \nand return type of the method which will be selected, since they appear as annotations in bytecode (see \nSection 3 for more details). In the example, C can be typechecked, e.g., in a type environment G1 where \nthe method g selected for method invocations with receiver type Used and argu\u00adment type Type2 has return \ntype Type3, and parameter type Type1, as in environment (1); this constraint is formalized by the judgment \nG1 f Used.g(Type2) m-res . (Type1,Type3). As well, C can be typechecked in a type environment G2 where \nthe selected method has return and parameter type Type2, as in environment (2); this constraint is formalized \nby the judgment G2 f Used.g(Type2) m-res. (Type2, Type2). The example clearly shows that, in order to \nget a principal typing property (in particular, a minimal type environment), we must type pairs consisting \nof a source and a binary fragment. The rest of the paper is organized as follows: in Section 2 we de\u00ad.ne \nthe formal notions of type system for separate compilation and inter-checking and soundness and completeness \nof inter-checking. In Section 3 we de.ne an instantiation of the notion of type sys\u00adtem de.ned in the \nprevious section for Featherweight Java [8] with method overloading and .eld hiding. In Section 4 we \nprove that this type system satis.es the hypotheses which guarantee sound\u00adness and completeness of inter-checking. \nWe also prove that it has principal typings and that the environment entailment is complete. Finally \nin the Conclusion we summarize the contribution of the pa\u00adper and draw some direction for further work. \n 2 Type systems for separate compilation In this section we de.ne a general notion of type system for \nseparate compilation. The main motivation is reuse: this general notion of type system serves as a pattern \nto be instantiated by a real type system where all de.nitions and details which have been intentionally \nomitted here are provided (including, e.g., the syntax of terms and types, and the typing rules for judgments). \nHowever, each correct instan\u00adtiation (as we will see, there are some basic properties expected to hold) \nis guaranteed to support well selective recompilation [1]. We will denote by T a generic instantiation \nof our general notion of type system. Even though in this paper we de.ne just one instantiation (for \nFeatherweight Java [8] enriched by overloading and hiding, see Section 3), we expect our general notion \nof type system to be useful for a number of other possible instantiations including both more signi.cant \nsubsets of Java and C# and toy languages de.ned for studying the interaction of Java or C# with advanced \nfeatures like, for instance, generic types that will be soon included in Java and have been formally \nstudied with GJ [8]. 2.1 Basic notions We start by listing the basic syntax categories and typing judgments \nthat are expected to be de.ned by every instantiation. Basic syntax categories Each instantiation should \nat least de.ne the following sets (metavariables used for the elements of such sets are shown in parentheses): \n Class names (c).  (Sequences of) source class declarations (s).  (Sequences of) binary class declarations \n(b).  (Sequences of) class types (t).  Type assumptions (.). They always include the type assump\u00adtions \nof the form c:t which are called standard.  Type environments (G). An environment is just a possibly \nempty sequence of type assumptions .1,...,.n.  We assume that each (source/binary) class declaration \nintroduces a class name c that can be extracted by a function name mapping a sequence of source or binary \nclass declarations to the sequence of their corresponding names. As already explained in the In\u00adtroduction, \nbinaries are needed for modeling the situation where some source class modi.cation can change the binary \ngenerated from other source classes. Notation for sequences We denote by |s| the length of a sequence \ns, by s1,s2 the con\u00adcatenation of the two sequences s1 and s2. A sequence is written i.1..n either e1,...,en \nor ei ; however, the .rst notation is only used when there is no ambiguity with concatenation. Basic \njudgments Each instantiation should at least de.ne the following two judg\u00adments: Gfs:t b: source class \ndeclarations s compile to b and have type t in G. We assume that if Gfs:t b is valid, then |s| = |t| \n= |b| = n, name(s)= name(b)= c1,...,cn, with ci ..j. Note that for Java-like lan\u00ad = c j for all i, j \n. 1..n, i = guages the information about the inferred type t is, in a sense, redundant, since it does \nnot depend on G, but it is a function of just the source s; nevertheless, we have preferred to leave \nthis information in the judgment for readability.  G1 f G2: G1 entails G2, that is, G1 enforces stronger \ntype requirements than those of G2.  Intuitively, the notion of entailment should correspond to a com\u00adputable \nrelation (at least) sound w.r.t. the notion of stronger envi\u00adronment (see De.nition 4 in Section 2.2). \nA basic expected property of the compilation judgment is composi\u00adtionality. Let the expression env(s:t) \ndenote the type environment: i.1..n , t = ti.1..n c1:t1,...,cn:tn if name(s)= cii and s does not contain \nclass name con.icts (that is, ci = c j implies i = j, for all i, j . 1..n) otherwise, it is unde.ned2. \nDef. 1 (COMPOSITIONALITY). We say that T is compositional iff for all G, s= s1,..., sn, t = t1,...,tn, \nb= b1,..., bn: Gfs:t b. G,env(s:t)fsi:ti bi,forall i . 1..n. 2.2 Principal typings The system independent \nde.nition of principal typing given by Wells [14] .ts well our general notion of type system. We recall \n2Hence a judgment of the form G,env(s:t) f ... is valid if and only if env(s:t) is de.ned and denotes \na type environment G. s.t. G,G.f... is valid. here the basic notions and notations on principal typings \ninspired by Wells and adapted to our purposes. Def. 2 (TYPING). If Gfs:t b holds, then we say that the \npair (G,t) is a typing of (s,b). We say that (s, b) is typable iff it has a typing. Note that we could \nhave adopted Well s de.nition of typing by con\u00adsidering binary sequences as part of the type so that \n(G, (t, b)) is a typing of s if G fs:t b holds. However, this de.nition would lead to a rather strong \nde.nition of principal typing for Java-like lan\u00adguages that, in fact, would not be satis.ed by any system \nadopting the usual notion of bytecode (see the Conclusion). Def. 3 (CONSISTENT ENVIRONMENT). An environment \nis con\u00adsistent iff there exist s, t, and bs.t. G fs:t b. Def. 4 (STRONGER ENVIRONMENT). An environment \nG1 is stronger than G2 (written G1 = G2) iff G2 is consistent and for all s, t, and b, if G2 fs:t bholds, \nthen G1 fs:t bholds as well. Note that the relation of De.nition 4 is a pre-order, but, in general, is \nnot a partial order. Def. 5 (STRONGER TYPING). A typing (G1,t1) is stronger than (G2,t2) (written (G1,t1) \n= (G2,t2)) iff G2 = G1 and t1 = t2. The de.nition of stronger typing given here differs from Well s def\u00adinition \nin two respects: Well s de.nition does not require that if (G1,t1) is stronger than (G2,t2), then G2 \nis stronger than G1 and t1 equals t2. However, this stronger property clearly holds in the setting of \nJava-like languages where the type of a class is uniquely determined by the annotations contained in \nits body. Under this property, the notion of stronger typing can be simply cap\u00adtured by the notion of \nentailment between environments (see Theorem 14).  In Well s de.nition there is no notion of consistent \ntype/environment. However, if non-consistent types and en\u00advironments were not ruled out from De.nition \n4, then some expected completeness property would not hold, like, for in\u00adstance, G1 = G2 . G1 f G2; indeed, \nwe may not want a sys\u00adtem where G1 f G2 is provable for any G2, just because G1 is not consistent. On \nthe other hand, we would like to consider concatenation of environments as a total function, therefore \nnon-consistent environments cannot simply ruled out from all de.nitions.  Def. 6 (PRINCIPAL TYPING). \nA principal typing of (s,t) is a typing of (s,t) which is stronger than all typings of (s,t). We say \nthat T has principal typings iff all typable (s,b) have a principal typing. Finally, the de.nition of \nprincipal typing given here is strictly stronger than Well s de.nition; indeed, our de.nition could be \nre\u00adgarded as a re.nement of Well s principality suitable for type sys\u00adtems in the Church style (that \nis, with explicitly typed terms). 2.3 Linksets Selective recompilation tries to minimize compilation \nsteps after changes to a certain software con.guration. Software con.gura\u00adtions can be modeled by the \nnotion of linkset, which was .rstly introduced by Cardelli [4]. Def. 7 (LINKSET). A linkset is a pair, \nwritten i.1..n G|Gi fsi:ti bi consisting of a type environment and a (possibly empty) sequence of valid \ncompilation judgments s.t. s= s1,...,sn does not contain class name con.icts. Intuitively, the environment \nG contains the type assumptions on the external classes (that is, not de.ned in the linkset), whereas \nfor all i . 1..n the judgment Gi fsi:ti bi corresponds to the successful compilation of a single compilation \nunit si to bi in the type envi\u00adronment Gi. Since here the emphasis is on inter-checking, the de.nition \nof linksets assumes that the compilation judgments are valid, hence our linksets correspond to intra-checked \nCardelli s linksets [4]. Moreover, in [4] type environments are just sequences of standard type assumptions \nc : t, and class names in G need to be different from those in each Gi. Indeed, typechecking of a single \nfragment si is performed in the type environment G,Gi containing type as\u00adsumptions on external classes \nand classes in the linkset, respec\u00adtively. In our notion of linkset, instead, type environments contain \narbitrary type assumptions, each one possibly involving more than one class, and typechecking of si is \nperformed in the type environ\u00adment Gi which contains type assumptions on both external classes and classes \nin the linkset. Thus, G,Gi can contain redundant as\u00adsumptions, even though intuitively the best situation \noccurs when Gi contains exactly the minimal type assumptions on other classes needed to compile si and \nG contains exactly the minimal type as\u00adsumptions on external classes needed to compile all si. Finally, \njudgments are not named as in Cardelli s linksets, since the type environment exported by any compilation \nunit G fs:t b is simply obtained via the name function. The de.nition of inter-checking is a generalization \nof that given by Cardelli. Def. 8 (LINKSET INTER-CHECKING). Let i.1..n L= G|Gi fsi:ti bi be a linkset \nand set s= s1,...,sn, t = t1,...,tn. We say that L inter-checks (written f L0) iff G,env(s:t)fGi holds \nfor all i . 1..n. 2.4 Sound and complete inter-checking As already explained, the inter-checking procedure \nallows sepa\u00adrate compilation of the units which need to be assembled in the linkset, and prevents code \ninspection and recompilation, since the overall consistency of the linkset is checked via the entailment \nrela\u00adtion on environments which completely relies on unit interfaces. On the other hand, one could always \nadopt a brute force al\u00adgorithm by (re)compiling all units as a whole. We model global G (re)-compilation \nby a judgment Gfs1,...,sn b1,...,bn, express\u00ading that source fragments s1,..., sn are compiled altogether, \ngen\u00aderating binary fragments b1,..., bn in the type environment G (see Def. 9). Def. 9 (GLOBAL COMPILATION). \nFor all G, s, b, the judgment G Gfsbis valid iff G fs:t bcan be proved for some t. Of course we expect \nseparate compilation plus inter-checking to produce the same binaries as we would have got from global \ncom\u00adpilation; if so, we say that inter-checking is sound w.r.t. global com\u00adpilation. Def. 10 (SOUND INTER-CHECKING). \nInter-checking is sound i.1..n w.r.t. global compilation iff for all linksets L= G|Gi fsi:ti bi G if \nf L0 then Gfs1,...,sn b1,..., bn. Soundness of inter-checking is guaranteed under some reasonable conditions: \nthe type system should be compositional, and the en\u00adtailment judgment should be sound with respect to \nthe relation of stronger environment. Theorem 11 (SOUNDNESS OF INTER-CHECKING). Let T be a compositional \ntype system satisfying the following additional prop\u00aderty : (*) G1 fG2 . G1 = G2 for all G1,G2 (entailment \nis sound). Then, inter-checking is sound w.r.t. global compilation. i.1..n PROOF. Let L be G|Gi fsi:ti \nbi be a linkset s.t. f L0 holds and set s = s1,...,sn, t = t1,...,tn. Then, by De.ni\u00adtion 8, G,env(s:t) \nf Gi holds for all i . 1..n. By hypothesis (*), G,env(s:t) = Gi, therefore G,env(s:t)fsi:ti bi for all \ni . 1..n. Fi- G nally, by compositionality, Gfs1,...,sn b1,...,bn. From the point of view of selective \nrecompilation, soundness of inter-checking ensures that recompilation steps are really unneces\u00adsary in \ncase of successful inter-checking since they would lead to the same result. On the other hand, we would \nlike to be sure that if inter-checking fails, then some recompilation step is really needed, so that \nit never happens that a recompilation step turns out to be useless. This happens if inter-checking is \ncomplete w.r.t. global compilation. Def. 12 (COMPLETE INTER-CHECKING). Inter-checking is complete w.r.t. \nglobal compilation iff, for all typable (s,b), we can select a typing (G(s,b),t(s,b)) of (s,b) s.t. i.1..n \nfor all linksets L= G|Gi fsi:ti bi, with (Gi,ti)=(G(si,bi), t(si,bi)),i . 1..n, G if Gfs1,...,sn b1,...,bn \nholds, then f L0 holds. Note that the property above is weaker than the opposite implica\u00adtion of Def. \n10, which does not hold; indeed, for an arbitrary linkset, inter-checking could fail since for some fragment \nwe have taken a too restrictive type environment. However, completeness as stated above requires that \nfor each fragment we can select a priori a typ\u00ading s.t., for any possible future context, failure of \nlinking will ensure that we could not get the same binary fragments by global compi\u00adlation. Prop. 13 \n(COMPLETENESS OF INTER-CHECKING). Let T be a compositional type system satisfying the following additional \nprop\u00aderty: for all typable (s,b), there exists a provably principal typing of (s, b), that is a typing \n(G,t) of (s,b) s.t. for all typings (G. ,t.) of (s, b), G.fG and t = t. . Then, inter-checking is complete \nw.r.t. global compilation. PROOF. Let us take, for all (s,b), (G(s,b),t(s,b)) a provably prin\u00adcipal typing \nof (s, b). i.1..n Let L be G|Gi fsi:ti bi with (Gi, ti) provably principal for G (si,bi), i . 1..n, and \ns.t. Gfsb holds. By compositionality: for all i . 1..n, G, env(s1,..., sn:t. 1,...,t. )fsi:t. bi, ni \nfor some t. 1,...,t. n. Therefore, since (Gi,ti) is provably principal for (si,bi), ti = t. and G,env(s1,...,sn:t1,...,tn)fGi \nhold for all i . 1..n, hence f L0 by De.nition 8. The following is just a corollary of Theorem 13 stating \nthat com\u00adpleteness of inter-checking holds whenever T is compositional, has principal typings and the \nentailment relation is complete. Theorem 14. Let Tbe a compositional type system with principal typings, \nsatisfying the following additional property: (**) G1 = G2 . G1 fG2 for all G1,G2 (entailment is complete). \nThen, inter-checking is complete w.r.t. global compilation. PROOF. Let (s,b) be typable; then by hypothesis \n(s, b) has a prin\u00adcipal typing (G, t). By de.nition of principal typing, for all (G. ,t.) of (s, b), \nt = t. and G.= G, hence by hypothesis (**), G.fG. Fi\u00adnally, theorem 13 can be applied. 2.5 Selective \nrecompilation In this section we illustrate more in detail the role of soundness and completeness of \ninter-checking for selective recompilation. As\u00adsume that in a compositional system T some of a successfully \ninter\u00adchecked linkset has been modi.ed and recompiled, obtaining the new linkset G|Gi fsi:ti bii.1..n. \nOf course, this change could have affected compatibility with some other fragment, therefore further \nrecompilation steps could be required in principle. However, to avoid a pointless recompilation, we can \nuse De.nition 8; if all checks are passed, then by soundness we are sure that the modi.\u00adcation did not \naffect any other fragment, hence any further recom\u00adpilation step would be useless. On the other hand, \nif inter-checking is not passed, and typings in the linkset are those selected according to De.nition \n12, then, by com- G pleteness, we know that for s = s1,..., sn, b = b1,...,bn, Gfsb does not hold, hence, \nby completeness, either we simply introduced some name con.ict, hence we obtain an ill-formed linkset; \nor .i . 1..n s.t. G,env(s:t)fsi:ti bi is not valid. In this latter case we recompile the i-th unit, since \nwe are sure we will obtain either a different binary or a compilation error, but not the same result \nas before. Note that it would be even better to be able to infer, in case of failure of inter-checking, \nwhether recompilation would generate a different binary or a compilation error; indeed in this way we \ncould avoid recompilation in the latter case and get an optimal procedure of selective recompilation. \nIn languages where, differently from what happens in Java, changes to a fragment cannot affect other \nbinary fragments, this is always the case since the former possibility does not hold. For Java-like languages, \nthe same result could be achieved by introducing two different judgments, one for type-checking (not \ntaking into account code generation) and one for compilation (that s CDs ::= ::= CDs 1 ... CDs n class \nc extends c. { FDS MDSs } FDS ::= FD1 ... FDn FD ::= c f; MDSs ::= MDs 1 ... MDs n MDs ::= MH {return \nEs;} MH ::= c0 m(c1 x1,...,cn xn) Es ::= x | Es .f | Es 0.m(Es 1,...,Es n) | new c(Es 1,...,Es n) | (c)Es \nb ::= CDb 1 ... CDb n CDb ::= class c extends c. { FDS MDSb } MDSb ::= MDb 1 ... MDb n MDb ::= MH {return \nEb;} Eb ::= x | Eb .c.f c.. Eb 0 . c.m(\u00afc)c. . (Eb 1,...,Eb n) | new .c \u00afc.(Eb 1,...,Eb n) | (c)Eb \u00afc \n::= c1,...,cn Implicit assumptions: .eld names in FDS are distinct  method signatures in MDSs and \nMDSb are distinct;  parameter names in MH are distinct.  Figure 1. Syntax introduced in next section). \nSee the Conclusion for more on this point.  3 Separate compilation for FJ 3.1 Syntax The language \nwe consider at the source level is an extended version of Featherweight Java [8], shortly FJ in the following. \nMore pre\u00adcisely, we keep the same syntax, but take a more liberal type system allowing .eld hiding (a \nheir class can declare a .eld already present in the parent; the new .eld hides the inherited .eld, which \ncan only be recovered by an up cast3) and method overloading (a class can have many methods, either directly \ndeclared or inherited, with the same name and different parameter types; they are considered as different \nmethods and the right method associated to an invocation, if any, is determined by the rules for overloading \nresolution, see in the sequel). We include these features from full Java since they are signi.cant for \nthe problem we are studying. Indeed, in both cases, the type which can be assigned to an expression in \na fragment and the cor\u00adresponding generated bytecode cannot be determined by simply in\u00adspecting the fragment, \nbut depend on the context, as explained at the end of the Introduction. The syntax of the language is \nde.ned in Figure 1; metavariables c, f, m and x range over sets of class, .eld, method and parameter \nnames, respectively. A source fragment s is a sequence of class declarations, each one consisting of \nthe name of the class, the name of the superclass, a sequence of .eld declarations FDS and a sequence \nof method dec\u00adlarations MDSs . If c. is the superclass of c, then we also say that c 3Or, in full Java, \nby super. (directly) extends c., and extends any class c.. which c. (directly) extends. We assume a distinguished \nclass name Object, denoting the root of the inheritance hierarchy, which cannot be declared. A .eld declaration \nFD consists of the type and the name of the de\u00adclared .eld. A method declaration MDs consists of a method \nheader and a method body (an expression). A method header MH consists of a (return) type, a method name \nand a sequence of parameter types and names. There are .ve kinds of expression: parameter name, .eld \naccess, method invocation, instance creation and cast. Types of expressions are class names, and c is \na subtype of c. iff either c extends cor c = c. In FJ, any class c is assumed to have exactly one constructor \nKc, which takes a canonical form explained below. Let us de.ne the sequence of the .elds of c as follows: \nthe sequence of the .elds of Object is empty; if c directly extends c., then the sequence of the .elds \nof c is obtained appending to the sequence of the inherited .elds (that is, the .elds of c.) the sequence \nof the .elds directly declared in c, in the given order. Then Kc ::= c(c1 f1,...,cn+m fn+m){ KEc; } KEc \n::= super(f1,...,fn); this.fn+1 = fn+1;...this.fn+m = fn+m; where c1f1, ..., cn+mfn+m, for n,m = 0, \nare the .elds of c and, in particular, cn+1fn+1, ..., cn+mfn+m are the directly declared .elds (hence \nc1f1, ..., cnfn are the inherited .elds). Note that, if the whole FJ program is available, then the canon\u00adical \nconstructor for a class c is completely determined by the in\u00adheritance hierarchy of c, hence it is immaterial \nto either explicitly write its declaration in the class or not. However, this considera\u00adtion does not \napply to separate compilation; indeed, if constructors are explicit, then compilation of a class requires \nthe existence of all its ancestors, since we must check that the constructor matches inherited and declared \n.elds. On the other hand, if constructors are implicit, then the availability of all ancestors is not \nrequired for compiling a class. Here, we have chosen the second alternative, which allows a more modular \ntype-checking. Another alternative would consist in allow\u00ading arbitrary constructors as in full Java. \nHere we preferred to keep the simpler FJ choice, since the problem of constructor overloading is basically \nan easier version of method overloading [10]. As already mentioned, the bytecode language we de.ne for \nFJ dif\u00adfers from the source code only for .eld accesses, which contain a symbolic reference .c.f c.. \nto the .eld to be selected, method invocations, which contain a symbolic reference .c.m(c\u00af)c.. to the \nmethod to be invoked, and instance creation expressions, which contain a symbolic reference .cc\u00af. to \nthe canonical constructor. Type assumptions are de.ned in Figure 2. A standard type assumption has form \nc:(c, FS,MSS) with the mean\u00ading c extends c. and declares exactly all .elds speci.ed by FS and all methods \nspeci.ed by MSS , where FS is a set of .elds (.eld type and .eld name) and MSS is a set method signatures \n(return type, method name and parameter types). Other forms of type assumptions are listed below: . \n::= c :t | .c | c = c. | c.f f-res. c. | c.m(\u00afc) m-res. (\u00afc. ,c) | c k-res. \u00afc | cOMS | c .= c. t ::= \n(c,FS, MSS) FS ::= {F1,...,Fn} F ::= c f MSS ::= {MS1,... ,MSn} MS ::= c m(\u00afc) Figure 2. Type environments \n .c with the meaning c is declared ;  c = c. with the meaning c is a subtype of c. ;  f-res c.f . c. \nwith the meaning the access to .eld f of an object of type c is successfully resolved to a .eld (obviously \nnamed f) with type c. . c) m-res c.m(\u00af. (c\u00af, c.) with the meaning the invocation of method m of an object \nof type c and with arguments of types c\u00afis successfully resolved to a method (obviously named m) with \nparameters of types \u00afc. and return type c. . k-res c . c\u00afwith the meaning the canonical constructor \nof c has parameter types \u00afc ;  cOcm(c\u00af) with the meaning c can be extended by a sub\u00ad class with a method \ncm(c\u00af) without breaking the Java rule on method overriding ;  c .= c. with the meaning c is not a subtype \nof c. ;  Typing rules for separate compilation are given in Figure 3. The top-level rule (fragment) \nde.nes the compilation of a sequence of source class declarations s1,...,sn, whose type is t1,...,tn, \ninto a sequence of binary class declarations b1,...,bn. The provided environment, G, is enriched with \nthe standard type assumptions as\u00adsigning to classes their declared types to deal with mutual recursion. \nThe resulting environment must be well-formed; the de.nition of well-formed type environments (typing \nrules for the judgment f G0 are given in Figure 4) relies on that for well-formed standard type environments \n(that is, those which only contain standard type as\u00adsumptions, ranged over by Gs). That is, G is well-formed \niff there exists a well-formed standard type environment Gs which entails G. A standard type environment \nis well-formed if the inheritance re\u00adlation is acyclic, for each class all its ancestor classes are available \nand the Java rules on overriding are respected (that is, a class can\u00adnot declare a method with the same \nname and parameter types of an inherited method and different return type).This is modeled by means of \na judgment Gs f c:MSS0 which holds if we can calculate in Gs the set of all method signatures of class \nc (empty for Object). Rule (class), which de.nes the compilation of a single source class declaration \nfor class c, checks that the superclass c. can be safely extended with the methods declared in c and \nthat there are no cycles involving c and c. (existence of the superclass is guaranteed by this last check). \nNote that there is no constraint on the .elds declared in c since we allow .eld hiding. Compilation of \na sequence of method declarations consists in com\u00adpilation of each method declaration. Rule (method) \nfor compiling a single method declaration checks the existences of the return type and of the types of \nthe parameters and, moreover that, under the type assumptions for parameters in the method header, the \nbody is a well-formed expression of a subtype of the method return type. The judgment for separate compilation \nof expressions takes an ad\u00additional . which is a mapping from variables to class names. The rule for \nparameter is straightforward. Rule (.eld access) for compiling a .eld access Es .f checks that Es is \na well-formed expression of some type c, and an access to .eld f of an object of type c is successfully \nresolved to a .eld of some type c., which is the resulting type of the .eld access. Moreover, the corresponding \nbinary .eld access is annotated with the static type of Es and the type of the selected .eld. Rule (meth \ncall) for compiling a method invocation E0s .m(Es 1,..., Es ) checks that E0 s is a well-formed expression \nof some n type c, all arguments are well-formed expressions of some types \u00afc, and an invocation of method \nm of an object of type c and with argu\u00adments of types \u00afc is successfully resolved to a method, whose \nreturn type is the resulting type of the method invocation. Moreover, the corresponding binary method \ninvocation is annotated with the static type of the receiver and the parameter types and return type \nof the selected method. Rule (new) for compiling an instance creation new c(Es 1,...,Es ) checks that \nall arguments are well-formed ex\u00ad n pressions, an invocation of the canonical constructor of c is suc\u00adcessfully \nresolved and the argument types are subtypes of the cor\u00adresponding parameter types of the canonical constructor. \nMoreover, the corresponding binary instance creation is annotated with the pa\u00adrameter types of the canonical \nconstructor. There are two typing rules for compiling a cast expression (c)Es , which both check that \nEs is a well-formed expression of some type c.; then, the cast expression is well-formed and has type \nc if either c is a subtype of c. (down cast) or conversely (up cast). Note that up casts are removed \nfrom the binaries. In [8], also casts between classes which are not in the subtyping relation (stupid \ncasts) are allowed, in order to get the subject reduction property4, but no user\u00adde.ned expression can \nbe typed by using the corresponding rule. Here we do not deal with the reduction semantics of FJ, hence \nwe do not include stupid casts. The typing rules for entailment of type environments are given in Figure \n5. The .rst three rules for environment entailment simply say that G1 f G2 is valid if each type assumption \n. contained in G2 is entailed by G1; the remaining rules cover the cases when G2 isa single atomic type \nassumption .. Rules for class existence and subtyping are straightforward. 4Since, e.g., (B)(Object)new \nA() reduces to (B)new A() for A, B heirs of Object. f G, env(s:t)0 G,env(s:t)fsi:ti bi .i . 1..n s = \ns1,...,sn,t = t1,...,tn,b = b1,..., bn (fragment) G fs:t b .i . 1..n.ti = type(si) GfMDSs MDSb Gfc.OMSi \n. i . 1..n Gfc. .= c type(MDSs)= {MS1,...,MSn} (class) G f class c extends c.{FDS MDSs} : (c. ,FS, {MS1,...,MSn}) \ntype(FDS)= FS class c extends c.{FDS MDSb} G;x1:c1,...,xn:cn fEs:c Eb G fc = c0 (methods) GfMDs i MDb \ni .i . 1..n GfMDs 1 . . . MDs n MDb 1 ...MDb n (method) G f G f.ci . i . 0..n c0 m(c1 x1,.. . , cn xn) \n{return Es;}c0 m(c1 x1,.. . , cn xn) {return Eb;} G;. fEs:c Eb f G0 f-res .fx : c Gfc.f . c. (parameter) \n(.eld access) G; .fx:cx G; .fEs .f:c. Eb .c.f c.. G;. fEs 0:c Eb 0 G;. fEsi :ci Eib .i . 1..n Gfc.m(c1,...,cn) \nm-res. . (c\u00af,c.) (meth call) G;. fEs 0.m(Es 1,...,Esn):c. Eb 0 . c.m(c\u00af.)c.. (Eb 1,..., Eb) n G;. fEsi \n:cEbi .i . 1..n i k-res Gfc . c1,...,cn Gfci = ci .i . 1..n (new) G;.fnew c(Es 1,...,Es ):c new .cc1,...,cn.(Eb \n1,...,Eb) n n . Eb G;.fEs:cG; .fEs:c. Eb G fc.= c G fc = c. G f.c (down cast) (up cast) G; .f(c)Es:c \n(c)Eb G;.f(c)Es:c Eb type(CDs 1 ... CDs )= type(CDs 1),...,type(CDs ) n n type(class c extends c.{ MDSs \n})=(c,type(FDS), type(MDSs)) type(FD1 ...FDn)= {type(FD1),...,type(FDn)} type(c f;)= c f type(MDs 1 \n...MDs )= {type(MDs 1),...,type(MDs )} type(MH { return Es; })= type(MH) type(c0 m(c1 x1,..., cn xn)) \n= c0 m(c1..cn) n n name(CDs 1 ... CDs )= name(CDs 1),..., name(CDs ) name(class c extends c.{ MDSs })= \nc n n Figure 3. Separate compilation Gs fG f Gs0 (non standard) f G0 c1:t1,...,cn:tn f ci:MSSi 0.i \n. 1,...,nn = 0 (standard) f c1:t1,...,cn:tn0 ci = c j =. ti = t j .i, j . 1,..., n Gs f c.:MSS.0 Gs(c)=(c,-,MSS) \n(msigs obj) (msigs down) Gs f Object:0/ 0 Gs f c:MSS . MSS.0 c1 m(c\u00af) . MSS,c2 m(c\u00af) . MSS. =. c1 = \nc2 Figure 4. Well-formed type environments f G0 GfG1 Gf. f G1, .,G20 (empty) (conc) (singleton) G f.GfG1, \n.G1, .,G2 f. G fc :t f G0 (def class) (def obj) G f.c Gf.Object f G0 Gfc1 = c2 Gfc2:(c3,-,-) f G0 \n(re.) (trans) (=obj) Gfc = c G fc1 = c3 Gfc = Object G fci = ci.i . 1..n (=vector) Gfc1,...,cn = c1,...,c. \nn f-res Gfc : (-, FS,-) G fc1:(c2,FS,-) G fc2.f . c (direct .eld res) cf . FS (inh .eld res) ..c.cf \n. FS f-res f-res Gfc.f . c. G fc1.f . c Gfc2:(-,-,MSS) G fc1 = c2 (exact meth res) cm(c\u00af) . MSS c) m-res \nGfc1.m(\u00af . (c\u00af, c) applAll(G,c,m,c\u00af)= \u00b5s applAll(G,c,m,c\u00af)= \u00b5s Gfc\u00af. matchAll(G,c, m, n)= \u00b5s mostSpec(G,\u00b5s)=(c\u00af,c.) \nmostSpec(G,\u00b5s)=(c\u00af,c.) (complete meth res) (match meth res) c) m-res Gfc.m(\u00af. c, c.) . c,c.) (\u00af Gfc.m(c1,..., \ncn) m-res(\u00af . k-res f G0 G fc :(c,FS,-) Gfc. c\u00af (K obj) (K up) FS = c1 f1 ...cn fn k-res k-res GfObject \n. .Gfc . c\u00af,c1,...,cn Gfc1: (c2,-,MSS) f G0 Gfc2Ocm(c\u00af) (.obj) (.down) (cm(c\u00af) . MSS)=. c= c GfObjectOcm(c\u00af) \nGfc1Ocm(c\u00af) notSub(G,c,c.) (.=) Gfc .= c. Figure 5. Type environments entailment .. . .. . ... .. Gfc1,...,cn.= \nGfc1..... . Gfcn. .. . true if c = Object Gfc.= G fc.. if Gfc : (c,-,-) false otherwise notSub(G,c,c.)= \nGfc..c. .. supertypes(G,c) {Object} if c = Object supertypes(G,c)= {c}. supertypes(G, c.) if Gfc :(c,-,-) \n. otherwise {<c,c\u00af, c> | cm(c\u00af.) . MSS,G f c\u00af= c\u00af.} if G fc :(-,-,MSS) appl(G, c,m,c\u00af)= . otherwise \n0/ if c = Object applAll(G,c,m,c\u00af)= \u00b5s1 . \u00b5s2 if appl(G,c, m, c\u00af)= \u00b5s1, Gfc : (c,-,-), applAll(G, c,m,c\u00af)= \n\u00b5s2 . otherwise {<c,c1,...,c> | cm(c1,...,c) . MSS if G fc :(-,-,MSS) match(G,c,m,n)= n,cn . otherwise \n0/ if c = Object matchAll(G, c, m,n)= \u00b5s1 . \u00b5s2 if match(G,c,m,n)= \u00b5s1, Gfc : (c,-,-), matchAll(G,c,m,n)= \n\u00b5s2 . otherwise <c0, c\u00af0,c0> if <c0,c\u00af0,c0> . \u00b5s and G fc0,c\u00af0,c0 = c,c\u00af,c., for all <c,c\u00af,c> . \u00b5s mostSpec(G,\u00b5s)= \n. otherwise Figure 6. Auxiliary functions There are two rules which deal with resolution of .elds. Rule \n(direct .eld res) states that an access to .eld f for an object of type c can be successfully resolved \nif class c directly declares a .eld named f. Rule (inh .eld res) states that an access to .eld f for \nan object of type c1 can be successfully resolved if it can be resolved for an object of the parent type \nc2 and c1 declares no .elds named f (which would hide the inherited .eld). There are three rules which \ndeal with resolution of methods. Rule (exact meth res) covers the simple case where there exists an applicable \nmethod which perfectly matches the invocation, hence can be directly selected. Otherwise, all applicable \nmethods must be collected, and then the most speci.c method (if any) is selected [7]. The set applAll(G,c,m,c\u00af), \nformally de.ned in Figure 6, contains all methods of c (either directly declared or inherited) named \nm whose parameter types are supertypes of \u00afc in G (note that for calculating this set all ancestors of \nc are needed). However, in general we cannot be sure that this set actually con\u00adtains all the applicable \nmethods, since there could exist some m in c for which we do not have in G the type assumptions stating \nthat the parameter types are supertypes of \u00afc. We can conclude that we have collected all applicable \nmethods (hence the most speci.c, if any, can be selected) only in two cases: if we have all ancestors \nof the argument types (G f c\u00af. in rule complete meth res), or if the set applAll(G,c,m, c\u00af) coincides \nwith the set matchAll(G,c,m,n) of all methods m of class c whose number of parameters matches the number \nof arguments in the invocation (rule match meth res), hence the set of all applicable methods cannot \nbe larger. Rules (K obj) and (K up) deal with resolution of constructors. The former states that the \ncanonical constructor of class c is Object has no parameters (. denotes the empty sequence). The latter \nstates that the canonical constructor of a class c which extends c. has as sequence of parameter types \nthe sequence of the parameter types of the canonical constructor of c., followed by the types of the \n.elds directly declared in c. Rule (Oobj) states that Object can be extended by any method. Rule (Odown) \nstates that if we know that a certain class c2 can be extended by a method cm(c\u00af), then a heir class \nc1 which does not de.ne the method with a different return type can be extended with the same method \nas well. Finally, the last rule states that we can conclude that c is not a sub\u00adtype of c. if all ancestors \nof c are available and c. is not among them (see the de.nition of notSub in Figure 6).   4 Results \nIn this section we prove that the type system TFJ for FJ extended with overloading and hiding de.ned \nin the previous section satis.es the hypotheses of Theorem 11 and 13, hence supports sound and complete \ninter-checking. We also prove that it has principal typings and that the environment entailment is complete. \nIn order to prove these results, we need the following lemmas, stat\u00ading that entailment is a pre-order \non well-formed type environments and that well-formedness actually coincides with consistency. Lemma \n15. 1. If G1 fG2 holds, then f G10 holds. 2. If f G1,G20 holds, then G1,G2 fG1 holds. 3. If G1 fG2 \nand G2 fG3 hold, then G1 fG3 holds. 4. If G1 fG2 holds, then f G20 holds.  Lemma 16. G is consistent \niff f G0. Fact 17 (COMPOSITIONALITY OF TFJ ). The type system TFJ is compositional, that is, for all \nG, s= s1,...,sn, t = t1,...,tn, b= b1,...,bn: Gfs:t b. G,env(s:t)fsi:ti bi,forall i . 1..n. Theorem \n18. The environment entailment is sound, that is, for all G1,G2, G1 fG2 . G1 = G2. Theorem 19. In the \ntype system TFJ inter-checking is sound w.r.t. global compilation. Theorem 20. For all typable (s,b), \nthere exists a typing (G(s,b),t(s,b)) of (s,b) s.t. for all typings (G,t) of (s,b), GfG(s,b) and t(s,b)= \nt. Theorem 21. In the type system TFJ inter-checking is complete w.r.t. global compilation. Theorem 22. \nThe type system TFJ has principal typings. Theorem 23. The environment entailment is complete, that is, \nfor all G, G. , G = G.. GfG. . 5 Conclusion We have de.ned an abstract framework for modeling separate \ncom\u00adpilation and inter-checking, provided a formal de.nition of sound\u00adness and completeness of inter-checking, \nand proved that these properties can be guaranteed when the type system has principal typings and provides \nsound and complete entailment relation be\u00adtween type environments. The fact that a type system has principal \ntypings is often claimed to be a highly desirable feature since they allow compositional type analysis \nin the sense that the procedure of .nding types for a term uses only the analysis results for its immediate \nsubterms, which can be analyzed independently in any order [14] and never need to be inspected again \n(see also [9, 5]). Perhaps the most important result of this paper on the foundational side is that we \nare able to for\u00admally express this property in the context of separate compilation and linking and to \nprove that it is actually guaranteed by principal typings. On the side of application to Java-like languages, \nthis paper is part of a stream of work [3, 2, 10, 11] on alternative type systems for Java. In [3] we \n.rstly realized that, despite the fact that Java is consid\u00adered a paradigmatic example of language supporting \nseparate com\u00adpilation, compilation as performed by standard Java compilers and modeled in current Java \nformal de.nitions is not truly separate in the sense made precise in [4] and in this paper. Indeed, each \nclass is typechecked against the same global type environment, that is, that extracted from a particular \nprogram context. Hence, a differ\u00adent type system for a subset of Java has been designed, introduc\u00ading \ntype assumptions expressing minimal requirements needed for typechecking a class in isolation, similar \nto those shown in this pa\u00adper. In [2] it is shown that this type system actually allows stronger typ\u00adings \nw.r.t. to standard type systems for Java and that it can be the basis for selective recompilation of \nJava applications. Concerning the applicability of these results to the whole Java lan\u00adguage, [10] and \n[11] outline the extension of this type system to a large Java subset (including, e.g., constructors, \naccess modi.ers, static members, throws clauses and unreachable code) and the de\u00advelopment of a corresponding \nsmart compiler. The reader interested into aspects related to Java and selective recompilation can refer \nto these papers. Here, our aim was to formally prove a result of existence of prin\u00adcipal typings for \na Java-like language (the .rst to our knowledge), hence we have preferred to consider a simple and clean \nlanguage as Featherweight Java, enriched with the features which pose the main problems in the Java type \nsystem. We believe a nice side\u00adcontribution of this paper is that we have exported the notion of principal \ntyping, more familiar in the community of functional lan\u00adguages, to a completely different context, and \nshow that, whereas in classical type systems with principal typings they are usually ob\u00adtained by making \nthe type more general (typically by introducing polymorphism or intersection types), in Java-like languages \nthe op\u00adposite happens, that is, principal typings can be obtained by making type environments less restrictive. \nIn the notion of type system introduced in this paper, we have con\u00adsidered fragments as pairs (s,b). \nAs already mentioned, an interest\u00ading alternative would be to consider the binary as part of the type. \nIn this case, in order to get the principal typings property, we should introduce polymorphic types. \nFor instance, consider again the example in the Introduction: class C extends Parent { ... Type1 m(Type2 \nx){ return new Used().g(x);} } If we do not care about which bytecode will be generated, then class C \ncan be correctly linked with any class Used having a method a g(\u00df), for any types a,\u00df s.t. a = Type1 \nand Type2 = \u00df. Clearly, all these classes cannot be captured by a unique type environment G in our current \ntype system. In order to do that, we should in\u00adtroduce type variables in the type environments, analogously \nto the approach followed in [13]; so we could model the requirements above as follows: a = Type1,Type2 \n= \u00df,Used.g(Type2) m-res(a,\u00df) . However, in this way the compiler cannot generate bytecode for C, since \nmethod descriptors cannot contain type variables; as a con\u00adsequence, either JVM should be modi.ed, or \nwe should introduce a sort of pre-bytecode that may contain type variables that must be instantiated \nduring static inter-checking in order to produce valid bytecode (similar solutions can be found in literature \n[13, 12]). Finally, another interesting topic for further investigation is the re\u00adlation between the \nnotions of binary compatibility [6] and inter\u00adchecking. 6 Acknowledgements We would like to thank Eugenio \nMoggi for his helpful suggestions on the relation between Well s and our notion of principality. 7 References \n[1] Rolf Adams, Walter Tichy, and Annette Weinert. The cost of selective recompilation and environment \nprocessing. ACM Transactions on Software Engineering and Methodol\u00adogy, 3(1):3 28, January 1994. [2] D. \nAncona and G. Lagorio. Stronger typings for separate compilation of Java-like languages (Extended Abstract). \nIn 5th Intl. Workshop on Formal Techniques for Java Programs 2003, July 2003. [3] D. Ancona, G. Lagorio, \nand E. Zucca. True separate compila\u00adtion of Java classes. In ACM SIGPLAN Conference on Prin\u00adciples and \nPractice of Declarative Programming (PPDP 02), pages 189 200. ACM Press, 2002. [4] L. Cardelli. Program \nfragments, linking, and modulariza\u00adtion. In ACM Symp. on Principles of Programming Languages 1997, pages \n266 277. ACM Press, 1997. [5] F. Damiani. Rank 2 intersection types for local de.nitions and conditional \nexpressions. ACM Transactions On Programming Languages and Systems, 25(4):401 451, 2003. [6] S. Drossopoulou, \nD. Wragg, and S. Eisenbach. What is Java binary compatibility? In ACM Symp. on Object-Oriented Pro\u00adgramming: \nSystems, Languages and Applications 1998, vol\u00adume 33(10) of SIGPLAN Notices, pages 341 358, October 1998. \n[7] J. Gosling, B. Joy, G. Steele, and G. Bracha. The JavaTM Lan\u00adguage Speci.cation, Second Edition. \nAddison-Wesley, 2000. [8] A. Igarashi, B. Pierce, and P. Wadler. Featherweight Java: A minimal core calculus \nfor Java and GJ. In ACM Symp. on Object-Oriented Programming: Systems, Languages and Ap\u00adplications 1999, \npages 132 146, November 1999. [9] T. Jim. What are principal typings and what are they good for? In Proceedings \nof the 23rd ACM SIGPLAN-SIGACT symposium on Principles of programming languages, pages 42 53. ACM Press, \n1996. [10] G. Lagorio. Towards a smart compilation manager for Java. In Blundo and Laneve, editors, Italian \nConf. on Theoretical Computer Science 2003, number 2841 in Lecture Notes in Computer Science, pages 302 \n315. Springer, October 2003. [11] G. Lagorio. Another step towards a smart compilation man\u00adager for Java. \nIn ACM Symp. on Applied Computing (SAC 2004), Special Track on Object-Oriented Programming Lan\u00adguages \nand Systems, 2004. To appear. [12] S. McDirmid, M.Flatt, and W. Hsieh. Jiazzi: New age compo\u00adnents for \nold fashioned Java. In ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages and \nApplications (OOPSLA 2001). ACM Press, October 2001. [13] Z. Shao and A.W. Appel. Smartest recompilation. \nIn ACM Symp. on Principles of Programming Languages 1993, pages 439 450. ACM Press, 1993. [14] J.B. Wells. \nThe essence of principal typings. In Interna\u00adtional Colloquium on Automata, Languages and Program\u00adming \n2002, number 2380 in Lecture Notes in Computer Sci\u00adence, pages 913 925. Springer, 2002. A Proofs Lemma \n15 1. By induction on the derivation of G1 fG2. 2. By rules (conc) and (singleton). 3. By induction \non the derivation of G2 fG3. 4. By rule (non standard) and (3).  Lemma 16 . If G is consistent, then \nwe have applied rule (fragment), hence f G,env(s : t)0 holds for some s, t. Then by lemma 15 (2) and \n(4) we get that f G0 holds. . If f G0 holds, then we can apply rule (fragment) with n = 0.  Theorem \n18 (Sketch) The fact that G2 is consistent follows from lemma 15 (4) and lemma 16. Then, we have to prove \nthat, for all s, t, b, if G2 fs:t b holds, then G1 fs:t b holds as well. This can be shown by induction \non the derivation of G2 fs:t b, by extending the claim to all other kinds of compilation judgments and \nby using the transitivity of entailment. Theorem 19 From Theorem 11 and Theorem 18. Theorem 20 (Sketch) \nWe have to prove that, (1) for all typable (s,b), there exists G(s,b), t(s,b) s.t. G(s,b) fs:t(s,b) b \nholds and G fG(s,b), t = t(s,b) for all G s.t. Gfs:t b holds. Since (s, b) is typable, at least one compilation \njudgment G fs:t b holds. The proof is by induction on the derivation of this judgment, by extending the \nclaim to all other kinds of compilation judgments. Typings for expressions are the most interesting case. \nThen, prop\u00aderty (1) becomes, (2) for all ., and typable (Es ,Eb) w.r.t. ., there exists G(Es ,Eb) (Es \n,Eb)(Es ,Eb) , cs.t. G(Es ,Eb );.fEs:cEb holds ,Eb)(Es and GfG(Es , c = c,Eb) for all G s.t. G; .fEs:c \nEb holds, where (Es ,Eb) is typable w.r.t. . if there exist G, c s.t. G;.fEs:c Eb holds. We just outline \nthe proof for the rule (.eld access). Then we know that H1 G;.fEs:c Eb holds; f-res H2 Gfc.f . c. holds; \nH3 (from (H1) by inductive hypothesis) there exists G(Es ,Eb ) s.t. property (2) holds. .f,Eb.c.f c..)= \nG(Es ,Eb)f-res. Let us take G(Es , c.f . c. We have to prove that ,Eb)f-res. T1 G(Es ,c.f . c.;.fEs .f:cEb \n.c.f c.. holds; f-res G(Es ,Eb). T2 G.f ,c.f . cholds for all G. s.t. G;.fEs .f:c Eb .c.f c.. holds. \n,Eb)f-res First of all we prove that G(Es ,c.f . c. is consistent. Since G is consistent by hypothesis, \nG f G(Es ,Eb) holds by (H3), G f f-res c.f . c. holds by (H2), by rule (conc) we can conclude that Gf \nf-res f-res G(Es ,Eb) ,Eb). ,c.f . c. holds, and this implies that G(Es ,c.f . cis consistent by lemma \n15 and lemma 16. We prove now (T1). We can instantiate rule (.eld access) by premises: f-res G(Es ,Eb),c.f \n. c.;.fEs:c Eb (this follows from the facts ,Eb)f-res that G(Es ,c.f . c. is consistent, ,Eb ).fG(Es \n f-res hence G(Es ,c.f . c,Eb) holds by lemma 15 (2) and by soundness of environment entailment (Theorem \n18)). f-resf-res G(Es ,Eb) ,c.f . c.f c.f . c. (this follows from the fact ,Eb)f-res that G(Es ,c.f . \nc. is consistent by rule (singleton). Finally, (T2) follows from the fact that, if G.;.fEs:c Eb holds, \nthen we must have instantiated rule (.eld access), hence we can ,Eb)f-res apply to G. the previous reasoning \nand get that G.fG(Es ,c.f . c. holds. Theorem 21 From Theorem 13 and Theorem 20. Theorem 22 From Theorem \n18 and Theorem 20. Theorem 23 (Sketch) First of all note that G = G. implies that G. and G. are consistent \n(hence f G.0 holds). The proof is by induction on the length of G. . The case G. = . is trivial by rule \n(empty). Assume G = G. , .. Then G = G. and G = . by transitivity, since G. ,. = G. and G. , . = . hold \nsince G. ,. is consistent from lemma 15 (2) and soundness of environment entailment. Then, by inductive \nhypothesis G f G. holds and we can instantiate rule (conc) provided that we prove that G = . implies \nGf. for each type assumption .. This can be proved by case analysis.  \n\t\t\t", "proc_id": "964001", "abstract": "The contribution of the paper is twofold. First, we define a general notion of type system equipped with an entailment relation between type environments; this generalisation serves as a pattern for instantiating type systems able to support separate compilation and inter-checking of Java-like languages, and allows a formal definition of soundess and completeness of inter-checking w.r.t. global compilation. These properties are important in practice since they allow selective recompilation. In particular, we show that they are guaranteed when the type system has principal typings and provides sound and complete entailment relation between type environments.The second contribution is more specific, and is an instantiation of the notion of type system previously defined for Featherweight Java with method overloading and field hiding. The aim is to show that it is possible to define type systems for Java-like languages, which, in contrast to those used by standard compilers, have principal typings, hence can be used as a basis for selective recompilation.", "authors": [{"name": "Davide Ancona", "author_profile_id": "81100231663", "affiliation": "Universit&#224; di Genova, Genova, Italy", "person_id": "P452362", "email_address": "", "orcid_id": ""}, {"name": "Elena Zucca", "author_profile_id": "81100312049", "affiliation": "Universit&#224; di Genova, Genova, Italy", "person_id": "P76352", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/964001.964027", "year": "2004", "article_id": "964027", "conference": "POPL", "title": "Principal typings for Java-like languages", "url": "http://dl.acm.org/citation.cfm?id=964027"}