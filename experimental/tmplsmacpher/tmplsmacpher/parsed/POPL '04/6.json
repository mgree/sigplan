{"article_publication_date": "01-01-2004", "fulltext": "\n Isomorphisms of Generic Recursive Polynomial Types Marcelo Fiore* Computer Laboratory University of \nCambridge Abstract This paper gives the .rst decidability results on type isomorphism for recursive \ntypes, establishing the explicit decidability of type iso\u00admorphism for the type theory of sums and products \nover an inhab\u00adited generic recursive polynomial type. The technical development provides connections \nbetween themes in programming-language theory (type isomorphism) and computational algebra (Gr\u00a8obner \nbases). Categories and Subject Descriptors: F.3.3 [Logics and Mean\u00adings of Programs]: Studies of Program \nConstructs type structure; F.4.2 [Mathematical Logic and Formal Languages]: Grammars and Other Rewriting \nSystems Decision problems; F.4.3 [Mathemati\u00adcal Logic and Formal Languages]: Formal Languages Decision \nproblems; I.1.0 [Symbolic and Algebraic Manipulation]: General; F.4.1 [Mathematical Logic and Formal \nLanguages]: Mathematical Logic Lambda calculus and related systems. General Terms: Theory, Languages, \nAlgorithms. Keywords: Data structure, Type theory, Type isomorphism, Recur\u00adsive types, Semigroups, Rigs, \nWord problem, Gr\u00a8obner bases. 1 Introduction Data structure is a central theme is computer science in \ngeneral and in programming languages in particular. In programming lan\u00adguage theory there is a well-established \nbody of work on type sys\u00adtems for describing, analysing, organising, classifying, modular\u00adising, etc. \ndata and its structure [14]. Within this framework, we are concerned here with the study of the intrinsic \nstructural prop\u00aderties of data as manipulated within a programming language or type theory. Speci.cally, \nthis paper follows the line of investigation that identi.es two types as structurally equivalent if they \nare iso\u00admorphic in the sense that there are mutually inverse procedures for transforming data between \nthem; see, e.g., [4]. This notion should not be confused with the weaker one of type equality, the re.exive \nclosure of subtyping, which is typically given independently of the *Research supported by an EPSRC Advanced \nResearch Fel\u00adlowship. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. POPL 04 January 14 16, 2004, Venice, Italy. Copyright 2004 ACM 1-58113-729-X/04/0001 ...$5.00 \nprogramming language under consideration, and either neglects to incorporate data transformation in its \nde.nition altogether, or is jus\u00adti.ed by the ad-hoc notion of mutual coercion between types. For instance, \ngiven any two types T1 and T2 the product types T1 \u00d7 T2 and T2 \u00d7 T1 are clearly isomorphic; whilst, according \nto traditional subtyping, they are not subtypes of each other unless so are T1 and T2. Recent investigations \nof subtyping, however, have relaxed the view by considering it modulo associativity and commutativity \nof product types [13, 5]; broadening it towards the notion of isomor\u00adphism. But isomorphism is strictly \nmore general. Indeed, given types T, T1, T2 the types T \u00d7 (T1 +T2) and (T \u00d7 T1)+(T \u00d7 T2) (1) where +and \n\u00d7 respectively denote the sum and product type con\u00adstructors, are isomorphic but they are generally not \nconsidered sub\u00adtypes of each other. This work studies type isomorphism in the context of recursive types. \nAs explained above, the conceptual difference between type isomorphism and type equality is such that \nthe relationship of this work with that of subtyping recursive types is essentially dis\u00adjoint (see [2] \nand the line of work that arose from it and also [9]). The focus of this paper is on generic recursive \npolynomial types, by which we mean recursively de.ned types built out of sum and product type constructors \nthat are generic in the sense that the only operations for manipulating recursive types are those of \nfolding and unfolding. A motivation for restricting attention to this setting is that it amounts to considering \nisomorphisms that are realisable by .nitistic programs (given by .nite mappings between data-type pat\u00adterns, \nsee Figures 2 and 6 for examples). Thus, isomorphism in this setting implies isomorphism in the setting \nof inductive and/or coinductive types; which are, roughly, generic recursive types fur\u00adther admitting \nmanipulations by iterators and/or coiterators, respec\u00adtively (see, e.g., [1]). The converse does not \nhold; for instance, there are recursive programs establishing an isomorphism between the types of binary \ntrees and of lists of binary trees, but there is no .nitistic one. As we will see, the algebra of type \nisomorphism for generic recur\u00adsive polynomial types is extremely rich; even when restricted to just one \nrecursive type T=~ F(T) which is the case considered in the paper. We illustrate the situation with the \ntype of (unlabelled) binary trees B =~ 1+B2 (2) where 1 denotes the unit type and where the type Tn (n \n. N) de\u00adnotes the n-fold product type T\u00d7 ...\u00d7 T of the type T. The algebra of type isomorphism satis.es \ncommutative and asso\u00adciative laws for sums and products, and the distributive law of prod\u00aducts over sums \nestablishing the isomorphism of the types in (1). Thus, for instance, we have that Bn+1 =~ Bn +Bn+2 for \nall n . N. Further, Lawvere and Schanuel noted in their investigations on Ob\u00adjective Number Theory that \nother unexpected algebraic manipula\u00adtions, like the one to follow, are also valid: For the sake of argument, \nconsider (2) in the form -1= B2 -B and B-1 = B2 and by algebraic manipulation note that -1= B2 -B = B3 \n, and hence that 1 =(-1)2 = B6 (3) and so also that B= B7 . There is in principle no reason for which \nthese purely algebraic, abstract manipulations may make sense type theoretically. Indeed, the identity \n(3) does not; as there is not just one six tuple of binary trees. Astonishingly, the last conclusion \nis a valid isomorphism: B =~ B7 . (4) This can be established in the algebra of type isomorphism follow\u00ading \nan heuristic unfolding/folding procedure which proceeds to can\u00adcel a Bn summand in a polynomial by unfolding \na higher power of B in another summand until it produces Bn+2 as a summand, that is then folded together \nwith Bn into Bn+1. An application of this pro\u00adcedure deducing (4) is given in Figure 1. In it we have \nunderlined the summands being unfolded and folded in each step. Calculations in the algebra of type isomorphism \nyield isomorphisms in the type theory; one such, extracted from Figure 1, giving an explicit bijec\u00adtion \nbetween seven binary trees and one is presented in Figure 2; see also [3]. The deep reasons for which \nthe calculation of Figure 1 is possible is that the types def B3 and 0 def [-1]= = 1+[-1] satisfy the \nfollowing isomorphisms 0 \u00d7 B =~ 0 (5) B+0 =~ B (6) 0 +0 =~ 0 (7) Indeed, using the isomorphism (5) we \ncan establish the following one B+0 \u00d7 (B+B2 +B3) =~ B+0 \u00d7 B\u00d7 (B+B2 +B3) (8) =~ B+B2 +B3 +B4 +B5 +B6 +B7 \n=~ 0 \u00d7 (B+B2 +B3)+B7 from which, further using the isomorphisms (6) and (7), we can cancel out 0 \u00d7 (B+B2 \n+B3)to conclude (4). The main empirical contribution of this work is thus that: There are negative and \neven imaginary types. The main technical problem addressed by this work is that of the decidability of \ntype isomorphism in the above setting. We are not only interested in establishing whether or not two \ntypes are isomor\u00adphic but moreover in establishing their explicit decidability; i.e.,in providing non-exhaustive \nmethods for constructing explicit isomor\u00adphisms (or proof derivations in the algebraic context) whenever \nthey exist. The main technical contribution of the paper is that: In the type theory of sums and products \nwith an inhab\u00ad ited generic recursive polynomial type T=~ F(T) the type isomorphism problem between polynomial \ntypes ? F1(T)=~ F2(T) is explicitly decidable. The above introductory remarks place this work in the \ncontext of programming language theory. However, it also has a place in the context of structural combinatorics, \nwhere one is interested in in\u00advestigating bijections between combinatorial structures.  2 Type isomorphism \nThis section introduces the type theory of the paper. 2.1 The type theory The type theory of sums, products, \nand generic recursive types has types given by the following grammar T . T (V) ::= X (Type variables) \n| 0 (Empty type) | T1 +T2 (Binary sum types) | 1 (Unit type) | T1 \u00d7 T2 (Binary product types) | .X.T \n(Generic Recursive types) where X ranges over (a countable set of) type variables V. We use a non-standard \noperator for recursive types to emphasize that they are generic; rather than inductive or coinductive, \nfor instance. The recursive type constructor .X.T binds the free occurrence of X in T; accordingly types \nare identi.ed up to alpha equivalence. The ordi\u00adnary de.nitions of free variables, bound variables, and \nsubstitution apply. The raw terms associated to the above types are given by the fol\u00adlowing grammar t \n::= x (Variables) | .T (t) (Absurd) | .T (t) (First injection) 1 | .2T (t) (Second injection) | d(t,x1.t1,x2.t2) \n(Discriminator) | () (Unit) | (t1,t2) (Pairing) | p1(t) (First projection) | p2(t) (Second projection) \n| fold.X.T (t) (Fold) | unfold(t) (Unfold) ~ ~~ ~~ B =1+B2 =1+B+B3 =1+B+B2 +B4 =B+B+B4 =B+B+B3 +B5 \n  =~ B+B2 +B5 =~ B+B2 +B4 +B6 =~ B+B3 +B6 =~ B2 +B6 =~ B2 +B5 +B7 =~ =~ B2 +B4 +B6 +B7 B5 +B7 +B8 \n=~ =~ B3 +B6 +B7 B6 +B8 =~ B3 +B5 +B7 +B7 =~ B7 =~ B4 +B7 +B7 =~ B4 +B6 +B7 +B8 Figure 1. B=~1+B2 . B=~B7 \n datatypeB=e|mofB*B ;  val fold: B*B* B*B* B*B*B ->B=fn t => case t of (e, e,e,e, e,e,e )=>e | ( b1, \nm(e,e), e, e, e, e,e)=> m(b1, e) | ( m(b1,b2) , e,e,e ,e,e, e)=> m(b1,m(b2,e)) | ( b1, m(m(b2,b3),e), \ne, e, e, e, e ) => m(b1,m(b2,m(b3,e))) | ( b1, m(b2,m(b3,b4)), e,e,e ,e,e) => m(b1,m(b2,m(b3,m(b4,e)))) \n| ( b1, b2, m(b3,b4), e, e, e, e ) => m(b1,m(b2,m(b3,m(b4,m(e,e))))) | ( b1, b2, b3, m(b4,b5), e, e, \ne ) => m(b1,m(b2,m(b3,m(b4,m(m(b5,e),e))))) | ( b1, b2, b3, b4, m(b5,b6), e, e ) => m(b1,m(b2,m(b3,m(b4,m(m(b5,m(b6,e)),e))))) \n| ( b1, b2, b3, b4, b5, b6, m(b7,b8) ) => m(b1,m(b2,m(b3,m(b4,m(m(b5,m(b6,m(b7,b8))),e))))) | ( b1, b2, \nb3, b4, b5, m(b6,b7), e ) => m(b1,m(b2,m(b3,m(b4,m(b5,m(b6,b7)))))) ; Figure 2. Seven binary trees in \none where x ranges over (a countable set of) variables. As usual, terms are identi.ed up to alpha equivalence; \nthe discriminator d stands for the usual case analysis operation on sum types and binds the free occurrences \nof xi in ti (i=1,2). Again, the ordinary de.nitions of free variables, bound variables, and substitution \napply. A context is a .nite set of variables together with associated types. Well-typed terms in context \nare given by derivable judgements G ft :T, where G is a context, t is a term, and T is a type; they are \ngiven according to the typing rules of Figure 3. The equational theory that provides the notion of term \nequality in the type theory is given by the rules in Figure 4. This equational theory splits naturally \nin congruence rules, . and \u00df rules for sums and products, and the mutual inverse of folding and unfolding. \nThe notion of type isomorphism is intrinsic to the type theory and given below. DEFINITION 1. Let T .T \n(V)be a set of types. Two types T1,T2 .T are said to be isomorphic in the restriction of the type theory \nto types in T, if there exist terms x1 :T1 ft2 :T2 and x2 :T2 ft1 :T1 of this type theory such that in \nit the judgements x1 :T1 ft1[t2/x2]=x1 :T1 and x2 :T2 ft2[t1/x1]=x2 :T2 are derivable. EXAMPLE 2. 1. \nEvery type T is isomorphic to the type T +0 via the terms x :T +0fd(x,x1.x1 ,x2..T (x2)):T and x :T f.0(x):T \n+0. 1 2. For every type T, the types T \u00d70 and 0 are isomorphic via the terms x :T \u00d70 fp2(x):0 and x :0 \nf(.T (x),x):T \u00d70. 3. For all types T, T1, T2, the types (T1 +T2)\u00d7T and (T1 \u00d7T)+(T2 \u00d7T)are isomorphic \nvia the terms  x :(T1 +T2)\u00d7T fd(p1(x), x1..T2\u00d7T ((x1,p2(x))), 1 T x2..T1\u00d7((x2,p2(x)))):(T1 \u00d7T)+(T2 \n\u00d7T) 2 and x :(T1 \u00d7T)+(T2 \u00d7T) fd(x, x1.(.T2 (p1(x1)),p2(x1)), 1 x2.(.T1 x2)),p2(x2))):(T1 +T2)\u00d7T. 2 (p1( \n 2.2 The algebra of type isomorphism To understand type isomorphism, and in particular study its alge\u00adbra, \nit is convenient to consider the type theory in categorical form through its associated classifying syntactic \ncategory. G ft :0 G, x :T, G {fx :TG f.T (t):T G ft :Ti G ft :T1 +T2 G, xi :Ti fti :T (i =1,2) (i,j \n=1,2;i =.j) Tj G f.i (t):T1 +T2 G fd(t,x1.t1,x2.t2):T G fti :Ti (i =1,2) G ft :T1 \u00d7T2 (i =1,2) G f():1 \nG f(t1,t2):T1 \u00d7T2 G fpi(t):Ti G ft :T[.X.T/X] G ft :.X.T G ffold.X.T (t):.X.T G funfold(t):T[.X.T/X] \nFigure 3. Typing rules DEFINITION 3. For a set of types T .T (V), we let C (T)be the category with objects \ngiven by types in T and morphisms T1 . T2 given by equivalence classes [x :T1 ft :T2]of derivable judge\u00adments \nin the type theory restricted to types in T under the equiv\u00adalence identifying (x :T1 ft :T2)and (x{ \n:T1 ft{ :T2)iff the judgement x :T1 ft =t{[x/x{]:T2 is derivable in the type theory restricted to types \nin T. Composition is by substitution [x :T2 ft:T3].[x :T1 ft :T2]=[x :T1 ft{[t/x{]:T3] with identities \ngiven by [x :T fx :T]. Thus, two types are isomorphic in the restriction of the type the\u00adory to types \nin the set T (in the sense of De.nition 3) iff they are isomorphic in C (T)(in the categorical sense). \nBelow we will be interested in studying type isomorphism in the type theory restricted to a set of types \nclosed under sums and prod\u00aducts. It will be useful thus to introduce the following de.nition and notation: \nThe closure of a set of types T .T (V)under sums and products, is denoted [T]and is de.ned inductively \nby the following rules T .T T1,T2 .[T] 0 .[T] T .[T] T1 +T2 .[T] T1,T2 .[T] 1 .[T] T1 \u00d7T2 .[T] 2.2.1 \nSums and products Type isomorphism without generic recursive types is well\u00adunderstood. PROPOSITION 4. \nFor a set of type variables V, the category C [V] is the free distributive category on V. Type isomorphism \nfor sum and product types is completely axioma\u00adtised by the equational rules in Figure 5. The complete \nequational axiomatisation for sum and product types of Figure 5 splits into congruence rules and axioms \nstating that the structures ([V],0,+)and ([V],1,\u00d7)are commutative monoids with products distributing \nover sums; that is, that ([V],0,+,1,\u00d7)is a so\u00adcalled commutative rig (= ring without negatives). It follows \nthat every type in [V]is isomorphic to a polynomial type, and that type isomorphism is decidable. Indeed, \ntwo types are iso\u00admorphic iff they have the same polynomial form. We have the fol\u00adlowing corollary. COROLLARY \n5(DECIDABILITY). For a set of type variables V, type isomorphism in C [V]is explicitly decidable.  2.2.2 \nSums, products, and a generic recursive poly\u00adnomial type We move now to consider the algebra of type \nisomorphism for the type theory of sums and products over an inhabited generic recur\u00adsive polynomial \ntype. More precisely, we consider the categories C [R]where R = .X.F is a generic recursive type in which \nF is a type in [X]. A universal characterisation of these categories follows. PROPOSITION 6. For X .V \nand F .[X], the category C [.X.F] is the free distributive category on a generator R =.X.F equipped with \na generic isomorphism R =~ F[R/X]. For the purpose of using a result of Gates [8] characterising type \nisomorphism in the setting we are considering we need further re\u00adstrict to inhabited types. DEFINITION \n7. A type T is said to be inhabited iff there exists a term t such that the judgement ft :T is derivable. \nPROPOSITION 8. For X .V and F .[X], the type .X.F is inhab\u00adited iff the polynomial form of the type F[0/X]is \nnot the empty type 0. In the setting of this section, which is indeed the context for the rest of the \npaper, we have the following characterisation of type isomorphism. THEOREM 9(GATES [8]). Let R = .X.F \nbe an inhabited type where F .[X].In C [R], two types are isomorphic iff they are provably equal by the \nequational rules in Figure 5 from the ax\u00adiom R F[R/X]. Note the important fact that since by the equational \nrules of Figure 5 every type in [R]has a computable isomorphic polynomial form on R, the study of the \nexplicit decidability of type isomorphisms T1 =~ T2 in C [R]for inhabited R =.X.F with F .[X]reduces, \nby invoking the above theorem, to establishing the explicit decidability of P1 P2 between polynomial \ntypes P1,P2 on T =.X.P, where G ft =t{ :TG ft1 =t2 :TG ft2 =t3 :T G ft =t :T G ft{ =t :TG ft1 =t3 :T \nG ft =t:0 G f.T (t)=.T (t{):T G ft =t:Ti G ft =t:T1 +T2 G,xi :Ti fti =t:T (i =1,2) (i,j =1,2;i =.j) \ni Tj Tj {{ { G f. (t)=. (t{):T1 +T2 G fd(t,x1.t1,x2.t2)=d(t,x1.t,x2.t):T ii 12 G fti =t{ :Ti (i =1,2) \nG ft =t{ i :T1 \u00d7T2 {{ (i =1,2) G f(t1,t2)=(t,t):T1 \u00d7T2 G fpi(t)=pi(t{):Ti 12 G ft =t{ :T[.X.T/X] G ft \n=t{ :.X.T G ffold.X.T (t)=fold.X.T (t{):.X.T G funfold(t)=unfold(t{):T[.X.T/X] \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 \n{ Tj G f.T (t)=t:TG fd(. (t),x1.t1,x2.t2)=ti[t/xi]:T (i,j =1,2;i =.j) i T2 T1 {[.({[.( G fd(t,x1.t1 \nx1)/x],x2.t2 x2)/x])=t{[t/x]:T G ft =():1 G fpi((t1,t2))=ti :Ti (i =1,2) G ft =(p1(t),p2(t)):T1 \u00d7T2 \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 \nG funfold(fold.X.T (t))=t :T[.X.T/X] G ffold.X.T (unfold(t))=t :.X.T Figure 4. Equational rules P .[X]is \nthe polynomial form of F, under the equational theory of commutative rigs (Figure 5) from the axiom T \n P[T/X]. This is the situation that we will restrict to in the sequel.   3 Algebra We have just seen \nthat the key to understanding type isomorphism for sums and products over an inhabited generic recursive \npolyno\u00admial type is the algebra of commutative rigs. In fact, other related algebraic structures also \nplay a salient role here. This section gives the basic background and the necessary results on the various \ncom\u00admutative algebras that arise. Semigroups, monoids, and groups. A semigroup consists of a set together \nwith an associative binary operation. A monoid is a semigroup with a neutral element. A group is a monoid \nin which every element has an inverse. These algebraic structures are said to be commutative whenever \nthe binary operation is. Subsets of semigroups closed under the binary operation are re\u00adferred to as \nsubsemigroups. A subsemigroup that happens to be a monoid/group is referred to as a submonoid/subgroup. \nRigs and rings. A semirig (R,+,1,\u00b7)is given by an additive com\u00admutative semigroup (R,+)and a multiplicative \nmonoid (R,1,\u00b7)sat\u00adisfying the distributive laws (x+y)\u00b7z =x\u00b7z+y\u00b7z z\u00b7(x+y)=z\u00b7x+z\u00b7y for all x,y,z . R.A \nrig is a semirig for which its additive semi\u00adgroup is a monoid, say with neutral element 0, satisfying \nthe laws 0\u00b7x =0 =x\u00b70 for all elements x.A ring is a rig in which the additive monoid is a group. These \nalgebraic structures are said to be commutative whenever the multiplication is. The set of natural numbers \nN with the usual operations of addition and multiplication is a rig, but not a ring. The set of integers \nZ is a ring. For a rig/ring (R,0,+,1,\u00b7), the set of polynomials R[x]on a gen\u00aderator x with the usual \noperations of addition and multiplication is also a rig/ring. Further rigs/rings can be constructed by \nquotients: for a relation ~ on a rig/ring R, we let R/~ be the quotient rig/ring of R by the least congruence \ncontaining ~. As it is customary, for a subset S of R we write R/S for R/~S where x ~S 0 for all x . \nS. Examples of such rings are the rings of modular integers Zc =~ Z/(c)for 1 = c .N, 2 and the ring of \nGaussian integers Z[i]=~ Z[x]/(x+1). Other examples of quotient rigs that we will encounter below are \nthe rig of degrees Deg ={ -8,0,1,...,n,... } =~ N[x]/~deg where p~deg q iff deg(p)=deg(q), and the rig \nof three dimensions D3 ={ 0,1,8} =~ N[x]/~3 where p ~3 q iff either deg(p)=deg(q)=0 or both deg(p)and \ndeg(q)are positive. T T{ T1 T2 T2 T3T T T{ TT1 T3 T1 T{T2 T{T1 T{T2 T{ 12 12 T1 +T2 T{+T{T1 \u00d7T2 T{\u00d7T{ \n12 12 \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 \nT +0 T (T1 +T2)+T3 T1 +(T2 +T3) T1 +T2 T2 +T1 T \u00d71 T (T1 \u00d7T2)\u00d7T3 T1 \u00d7(T2 \u00d7T3) T1 \u00d7T2 T2 \u00d7T1 0\u00d7T 0 (T1 \n+T2)\u00d7T (T1 \u00d7T)+(T2 \u00d7T) Figure 5. Complete axiomatisation of isomorphism for sum and product types A non-standard \nexample is the rig/ring of valued monomi\u00adals RIxl in a a rig/ring R, with underlying set given by n { \ncx | c .R,n .N } .R[x], with addition given by . m . cx ,if m>n m cx +dxn = dxn ,if m<n . (c+d)xm ,if \nm = n and multiplication given as for polynomials. More rigs/rings can be constructed by the product \nof such, with operations given pointwise. In particular, the binary product of R and R{ is denoted R\u00d7R{. \nA rig homomorphism is a function between rigs that commutes with the operations. Examples are: the head \nhomomorphism h :R[x]. RIxl mapping a polynomial to its head (i.e., its val\u00adued monomial of highest degree); \nthe degree homomorphism deg : RIxl. Deg mapping a valued monomial to its degree; and the dimension homomorphism \ndim : Deg . D3 identifying all the positive degrees. For polynomials p1,p2 .N[x], there is a bijective \ncorrespondence between elements r in a rig R such that p1(r)= p2(r)and rig ho\u00admomorphisms N[x]/(p1(x)= \np2(x)) . R. Indeed, the universal rig homomorphism induced by such an element r is given by the mapping \np . p(r); whilst the universal element associated to a rig homomorphism is obtained by evaluating at \nx. 3.1 Cancellation and inverses in commutative semigroups Arguments like the passage from (8) to (4) \nin the introduction are intimately related to cancellation properties. This section studies cancellation, \nand the more general notion of invertibility, in the con\u00adtext of commutative semigroups. 3.1.1 Cancellation \nin commutative semigroups We give a cancellation lemma for submonoids of commutative semigroups. The \ncentral concept needed for this purpose is the ana\u00adlogue of the natural precongruence on a monoid induced \nby its bi\u00adnary operation. For semigroups, however, this relation is typically just a transitive congruence. \nDEFINITION 10. For elements a,x,y of a semigroup (S,+),we let a :x< y .. x+a = y and de.ne < as the transitive \nrelation on S given by x< y .. a:x< y for some a . Further, we let <> be the equivalence relation on \nS given by x<>y .. x = y or both x< y and y<x and let (x).S be the equivalence class of x under <>. (The \nequivalence relation <> corresponds to Green s relations H , L, R , J , D all of which coincide in the \ncase of commutative semi\u00adgroups; see, e.g., [11].) PROPOSITION 11. 1. In a semigroup (S,+) with a:x< \ny and b :y< z we have that a+b :x< z. 2. In a commutative semigroup (S,+) with a:x<yand b:u<v we have \nthat a+b :x+u< y+v. Further, for a semigroup (S,\u00b7)with \u00b7 distributing over +,we also have that xb+au+ab \n:xu< yv . A simple cancellation lemma follows. LEMMA 12 (CANCELLATION). Let (M,+,e) be a submonoid of \na commutative semigroup (S,+).For x,y . M and a . S such that a< e the following cancellation law holds: \nx+a = y+a =. x = y. { { PROOF.For a: a< e we have that x = x+e = x+a+a= { y+a+a= y+e = y. 3.1.2 Groups \nwithin commutative semigroups In many situations, like the ones we will encounter in Section 4, cancellation \nin semigroups is a manifestation of subgroup struc\u00adture. A fundamental general result in semigroup theory \ndue to Green [10], the commutative version of which we give below, gives an analysis of this phenomenon. \nTHEOREM 13. Let (S,+) be a commutative semigroup, and let H = (h).S for h.S. The following statements \nare equivalent. 1. The relationship h+h< h holds. 2. There are k,\u00a3 .H such that k+\u00a3 .S is in H. 3. \nH is a subsemigroup of S. 4. H is a maximal subgroup of S. 5. H contains an idempotent.  PROOF. (1. \n2)Because h and h+h are in H. (2. 3)Let k,\u00a3,k+\u00a3 .H.For x,y .H, since x+y<>k+\u00a3,we have x+y .H. (3 . 4) \nFor k,\u00a3 .H, let x : k+\u00a3< k and y : k< \u00a3, and de.ne e = \u00a3+x. We have that e .H because \u00a3< e< k. Further, \ne is idempotent because e+e = \u00a3+x+k+y+x = k+y+x = e. Thus, for d .H with z :e< d, we have that d+e = \ne+z+e = e+z = d and hence that (H,e,+) is a submonoid of S. It is also a subgroup because d< e for every \nd .H. Let H be a subgroup of a group K which is a subgroup of S.As e .H is the neutral element of K, \nwe have that e< k< e for all k.K, from which it follows that K = H. (4 . 5)As groups have exactly one \nidempotent: the neutral ele\u00adment. (5 . 1) Because for e an idempotent in H, we have that h+h<>e+e = e. \nWe extend the above result to the case of semirigs. PROPOSITION 14. Let e be an idempotent in a commutative \nsemi\u00ad group (S,+) and let (S,\u00b7,1)be a monoid with \u00b7distributing over +. The structure ((e),e,+,u,\u00b7)with \n1< u is a ring iff 1+e2 < e and u = 1+e. PROOF. (.)Since 1<u, we have that 1+e<u+e= uand hence 2 that \n1+e= 1+e .(e). Thus, 1+e =(1+e)u = u+eu = u+e = u. (.) By Theorem 13, the structure ((e),e,+) is a commutative \ngroup. Since by hypothesis 1<e, it follows that e< 1+e< e+e = e and hence that 1+e .(e). Further, we \nhave that e2 .(e)because by 2 hypothesis e2 < e and also 1< e, which yields e< e. Thus, for any x,y .(e), \nsince xy<>e2, we have that xy .(e). For x .(e), we have that xe = x(e+e)= xe+xe ex =(e+e)x = ex+ex lowing \ncalculations, with x .(e), x(1+e)= x+xe = x+e = x (1+e)x = x+ex = x+e = x show that 1+e is a neutral \nelement for multiplication. The distributivity of \u00b7over + in (e)is inherited from that of S.   4 Isomorphisms \nof generic recursive polyno\u00admial types As observed at the end of Section 2, the study of type isomorphism \nin C [.X.F]with F .[X]inhabited amounts to the study of equality of polynomials in the quotient polynomial \nrig N[x]/(x= p(x)) with p .N[x]such that p(0).0. This section studies these rigs. = The theory is developed \nin two parts. First, we deal with the case of polynomials representing generic trees. The more sophisticated \ncase of linear polynomials respectively representing generic lists, generic naturals, and generic constants \nis considered next. The development in each case follows the same outline. First, the internal structure \nof the rigs is investigated in detail; subsequently cancellation and representation results are obtained. \nThe represen\u00adtations are rig embeddings (i.e., injective rig homomorphisms) of the form N[x]/(x = . R\u00d7Z[x]/(x-p(x)) \np(x)) y where R is an appropriate parameter rig that strati.es the quotient polynomial ring Z[x]/(x-p(x)). \nFrom these representations the decidability of the word problem easily follows. Indeed, the pa\u00adrameter \nrigs R have a trivially decidable equality, whilst decision procedures for the word problem in the quotient \npolynomial ring Z[x]/(x-p(x)) are well-known from the theory of Gr\u00a8obner bases. Finally, the constructive \nnature of the methods, which provide ex\u00adplicit constructions for the provable equations in the rigs and \nhence type isomorphisms between the associated types, is illustrated with example applications. 4.1 \nGeneric trees This section is concerned with type isomorphism for the type theory of sums and products \nover a type T =~ P(T)(P .N[T],deg(P)=2,P(0).0) = of generic trees. We start with a careful analysis of \nthe relation < in the associated rigs. In particular, we .rst establish that all monomials of positive \ndegree are equivalent under the associated equivalence <>. PROPOSITION 15. Let p .N[x] be such that deg(p)=2 \nand p(0).0. = 1. For all n,m .N,  m -1 n+in+m x \u00b7q(x): x n < x i=0 from which we conclude that xe = \nex = e. Consequently, the fol-where q(x)= p(x)-1 .N[x]. 2. For n>d = deg(p), n-dn-d+1 xq(x):x n < x where \nq(x)=p(x)-xd .N[x]. 3. For a monomial xn in p and 0=\u00a3 =n, n-1 1+q(x)+ x i \u00b7(x n +q(x)):x n-. < x i=n-. \nwhere q(x)=p(x)-(1+x n).N[x]. The above proposition is extended from monomials to polynomials. LEMMA \n16. Let p .N[x]be such that deg(p)=2 and p(0)=.0. For all q,q{. N[x]with deg(q{)= 1, we have that q< \nq{ in N[x]/(x = p(x)). Further, a witness for this relationship can be computed. PROOF. We .rst observe \nthat 2x <x. Indeed, if p(0)=2, we have that xq(x):2x < x 2 where q(x)=p(x)-2.N[x], and hence we can compute \na witness for 2x < x 2 < x using Propositions 11 and 15(3). Otherwise p(0)= 1, and with respect to a \nmonomial xn with n =1 in p, we can compute a wit\u00adnesses for n+1 2x < x+x = x(1+x n)< x 2 < x again using \nPropositions 11 and 15(3). Hence, using also Proposi\u00adtions 15(1) and 15(2), we can compute a witness \nfor x ni < x < x. i.Ii.I Further, since for any q{.N[x]with deg(q{)= 1, we can easily compute a witness \nfor x < q{(x) using Propositions 11 and 15(1), we are done. We obtain the striking result, noted by Steve \nSchanuel [12], that the polynomials of positive degree form a subring of the ambient semirig. This gives \nprecise mathematical meaning to additive in\u00adverses of, or negative, types recall the introduction. COROLLARY \n17. For p.N[x]with deg(p)=2and p(0)=.0, the equivalence class (x)in the additive semigroup N[x]/(x= p(x))is \ngiven by the subset { q .N[x]/(x = p(x)) | deg(q)=1} . Moreover, for w(x):2x< x in N[x]/(x = p(x)), the \nstructure ((x), 0 , +, 1 , \u00b7) where 0 = x+w(x) and 1 = 1+0 is a ring. PROOF. The .rst part follows from \nLemma 16; the second part from Theorem 13 and Proposition 14. LEMMA 18 (CANCELLATION). Let p . N[x]with \ndeg(p)= 2 and p(0). = 0.For t1,t2,q .N[x]with deg(t1),deg(t2)=1, the following cancellation law holds \nin N[x]/(x = p(x)): t1 +q = t2 +q =. t1 = t2 . PROOF. Use Lemma 12 and Corollary 17. We now present the \n.rst representation result. The parameter rig in this case is the rig of three dimensions: one for the \nnull poly\u00adnomial, one for polynomials of degree zero, and the other one for polynomials of degree greater \nthan or equal one. THEOREM 19 (REPRESENTATION). For p . N[x] with deg(p)=2 and p(0). = 0, the universal \nrig homomorphism N[x]/(x = p(x))-. D3 \u00d7Z[x]/(x-p(x)) induced by (8,x).D3 \u00d7Z[x]/(x-p(x)) is injective. \nThat is, t1 = t2 in N[x]/(x = p(x)) iff either (1) deg(t1)= deg(t2)= 0 and t1 = t2 in N, or (2) deg(t1),deg(t2)= \n1 and t1 = t2 in Z[x]/(x-p(x)). PROOF. (.)Note that for t1,t2 .N, the equality t1 = t2 holds in Z[x](x-p(x)) \niff it holds in N. (.)Let t1,t2 .N[x]. If dim(t1)=dim(t2)=0 then t1 = t2 = 0. If dim(t1)= dim(t2)= 1 \nand t1 = t2 in Z[x]/(x = p(x)) then t1 = t2 in N. If dim(t1)=dim(t2)=8 then deg(t1),deg(t2)=1. Further, \nif t1 = t2 in Z[x]/(x-p(x))then there exist q1,q2 .N[x]such that t1 -t2 =(q1 -q2)\u00b7(x-p(x)) (9) in Z[x]and \nhence such that t1 +q1 \u00b7p(x)+q2 \u00b7x = t2 +q1 \u00b7x+q2 \u00b7p(x) in N[x]. Thus, t1 +(q1 +q2)\u00b7x = t2 +(q1 +q2)\u00b7x \nin N[x]/(x = p(x)), and by the cancellation Lemma 18, we have t1 = t2 in N[x]/(x = p(x)). PROPOSITION \n20. For p . N[x]with deg(p)=2 and p(0)=.0, we have the following description N[x]/(x = p(x)) =~ N (x) \nwhere, further, (x) =~ Z[x]/(x-p(x)) . The representation gives a simple decidability test for the word \nproblem and the method further allows the explicit construction of proof derivations in the algebra, \nand hence of isomorphisms in the type theory. COROLLARY 21 (DECIDABILITY). For p . N[x] with deg(p)= \n2 and p(0).= p(x)), = 0, the word problem in N[x]/(x and hence also type isomorphism in C [.X.F]where \nF . [X]has polynomial form p, are explicitly decidable. PROOF. Theorem 19 provides the following decidability \ntest: t1 = t2 in N[x]/(x = p(x)) iff either t1 = t2 in N,or deg(t1),deg(t2)= 1 and t1 and t2 have the \nsame normal form in Z[x]under the reduction rule h(p) x-(p(x)-h(p)) . Further, for t1 = t2 in N[x]/(x \n= p(x))we may divide t1 -t2 by x-p(x)in Z[x]to obtain the situation (9) and proceed as in there to produce \na derivation of the equality. We conclude the section with two example applications: one revis\u00aditing \nisomorphism between seven binary trees and one [3], and the other one analysing an imaginary-unit type \n[6]. EXAMPLE 22 (SEVEN BINARY TREES IN ONE). We consider 2 x7 in N[x]/(x = x+1). Under the reduction \nrule x2 x-1 we have that 7 x x(x-1)3 = x4 -3x3 +3x2 -x (x-1)2 -3x(x-1)+3(x-1)-x =-2x2 +3x-2 -2(x-1)+3x-2 \n= x 72 and hence that x= x in N[x]/(x = x+1). We will now follow the methods of the section to give a \nderivation of this identity. First observe that x4 :2x< x, as the following calculation shows 442 3 2 \nx +2x = x +x +x+1 = x +x+1 = x +1 = x so that def 4 42 3 x +x = x +x +1 = x +1 = 0 . (10) Second, the \nidentities nn x \u00b7 0 = 0 (n . N) and x+0 = xn (1 = n . N) hold, and one can easily give derivations as \nfollows: n+1 1. x\u00b7 0 = 0 as shown in (10) and, by induction, x \u00b7 0 = nn x\u00b7 (x\u00b7 0)=x\u00b7 0 = 0 for all n \n. N. 32 n+1 2. x +0 = x +x +1 = x +1 = x and x +0 = n x \u00b7 (x+0)=x n+1 for all n . N. Finally, using the \ndivision algorithm ()() 25 2 x 7 -x =(x +x)-(x +x 4)\u00b7 x-(x +1) in Z[x], and hence 43 2 x 7 +(x +x +x+1)\u00b7 \nx 5 22 = x7 +(x+x4)\u00b7 x+(x+x)\u00b7 (x+1) (11) 5 22 = x+(x+x4)\u00b7 (x+1)+(x+x)\u00b7 x 43 2 = x+(x +x +x+1)\u00b7 x in N[x]/(x \n= 1+x2). Further, since x 4 +x 3 +x+1 = 0 , the derivation (11) can be expanded to a derivation of x \n7 = x by precomposing it with 77 432 x = x +0 = x 7 +(x +x +x+1)\u00b7 x and postcomposing it with 43 2 x+(x \n+x +x+1)\u00b7 x = x+0 = x. An isomorphism obtained from this derivation is given in Figure 6. EXAMPLE 23 \n(THE IMAGINARY-UNIT TYPE). Let Z[i] be the ring of Gaussian integers, with underlying set { m+ni | m,n \n. Z } and operations as for the complex numbers. The results of this section imply that the mapping associat\u00ading \np . N[x]/(x = 1+x+xto p . N if deg(p)= 0, and to 2)p(i). Z[i]otherwise, yields a bijection N[x]/(x = \n1+x+x2)=~ N Z[i] . It follows that the isomorphisms satis.ed by the imaginary-unit type I = .X.1+X +X2 \nare characterised by the identities satis.ed by the imaginary unit i. Indeed, for X . V,if T1,T2 . [X]are \ntypes with polynomial form p1,p2 . N[X]then T1(I)=~ T2(I)in C [I] iff either deg(p1),deg(p2)= 0 or deg(p1),deg(p2)= \n1, and p1(i)=p2(i)in Z[i]. Thus, for instance, we have the following isomorphisms 1+I2 =~ I+I3 , 2+I2 \n=~ I4 , I =~ I5 in C [I].  4.2 Linear generic recursive types We turn attention to type isomorphism \nfor the type theory of sums and products over an inhabited linear generic recursive type: L=~ c+d\u00d7 L \n(1= c . N,d . N) A key difference with the previous situation of generic trees is that there are invariants \n(like having the same head or degree) that hold for the generic recursive type and its unfolding, and \nhence also for all isomorphic types. Indeed, we have the following simple prop\u00aderty. PROPOSITION 24. \nFor p,q . N[x] and for t1 = t2 in N[x]/(p(x)=q(x)),if h(p)= h(q)then h(t1)= h(t2), and if deg(p)=deg(q)then \ndeg(t1)=deg(t2). It is thus natural to consider three different subcases: when 1 = c . N and 2 = d . \nN (Section 4.2.1) in which case the degree is an invariant; when 1 = c. N and d = 1 (Section 4.2.2) in \nwhich datatypeB=e|mofB*B ;  val encode: B * B*B* B*B*B *B->B =fnt=> case t of ( e, e, e, e, e, e, e \n) => m(e,e) | ( e, e, e, e, e, e, m(b1,b2) ) => m(m(m(m(m(e,e),e),b1),e),b2) | ( e, e, e, e, e, m(b1,b2), \ne ) => m(e,m(b1,b2)) | ( e, e, e, e, e, m(b1,b2), m(b3,b4) ) => m(m(m(m(m(e,e),m(b1,b2)),b3),e),b4) | \n( e, e, e, e, m(e,e), e, e ) => e | ( e, e, e, e, m(e,e), m(b1,b2), e ) => m(m(e,b1),b2) | ( e, e, e, \ne, m(e,m(b1,b2)), b3,e)=> m(m(m(m(e,b1),b2),e),b3) | ( e, e, e, e, m(e,e), b1, m(b2,b3) ) => m(m(m(e,b1),b2),b3) \n| ( e, e, e, e, m(e,m(b1,b2)), b3, m(b4,b5) ) => m(m(m(m(e,b1),b2),m(b3,b4)),b5) | ( e, e, e, e, m(m(b1,b2),b3), \nb4, b5 ) => m(m(m(m(m(e,e),b1),b2),m(b3,b4)),b5) | ( e, e, e, m(b1,b2), b3, b4, b5 ) => m(m(m(m(m(e,m(e,b1)),b2),b3),b4),b5) \n| ( e, e, m(b1,b2), b3, b4, b5, b6 ) => m(m(m(m(m(e,m(m(e,b1),b2)),b3),b4),b5),b6) | ( e, m(b1,b2), b3, \nb4, b5, b6, b7 ) => m(m(m(m(m(e,m(m(m(e,b1),b2),b3)),b4),b5),b6),b7) | ( m(e,b1), b2, b3, b4, b5, b6, \nb7 ) => m(m(m(m(m(m(b1,b2),b3),b4),b5),b6),b7) | ( m(m(b1,b2),b3), b4, b5, b6, b7, b8, b9 ) => m(m(m(m(m(e,m(m(m(m(b1,b2),b3),b4),b5)),b6),b7),b8),b9) \n; Figure 6. Seven binary trees in one case the head is an invariant; and when 1 = c . N and d =0 (Sec\u00adtion \n4.2.3) in which case the situation is trivial. 4.2.1 Generic lists A linear generic recursive type of \nthe form: L =~ c+d\u00d7 L (1 = c . N,2= d . N) is referred to as a generic list. The structure of the rig \nN[x]/(x=c+dx)is intricate. In particular, there are different additive idempotents of each degree. These \nare de.ned below, and their properties established afterwards. DEFINITION 25. Let 1 = c . N and 2 = d \n. N.For 1 = n . N, we set n-1 0n = x \u00b7 c+(d-1)x. Note that 0n+k =xk 0n for all 1 = n . N and k . N. PROPOSITION \n26. Let 1 = c . N and 2 = d . N. 1. For every 1 = m = n. N, nn x+0m = xin N[x]/(x =c+dx) and hence for \nall p. N[x]with deg(p)= m, p+0m = p in N[x]/(x =c+dx) . 2. For every 1 = n . N, (x n) = { q . N[x]/(x \n=c+dx)| deg(q)=n} (12) is a maximal subgroup of the additive semigroup N[x]/(x =c+dx)with neutral element \n0n. n PROOF. (1) We .rst show by induction that x+01 =xn for all 1 = n. N. Indeed, x+01 =x by de.nition \nof 01 and n+1n x +01 = cx+dxn+1 +01 n = cx+dxn+1 , by induction n+1 = xfor all 1 = n . N. Thus, for \n1 = m = n . N, we have that nm-1n-m+1m-1n-m+1n x+0m =x\u00b7 (x+01)=x\u00b7 x=x. (2) By Proposition 24, the inclusion \n(.)in (12) holds. As for the reverse inclusion, we already know from the previous part that 0m < p for \nall p . N[x]with 1 = m = deg(p); further since x n < 0n , for all 1 = n . N and since by the previous \npart 0n :0m < 0n , for all 1 =m =n .N we also have that, for p=i ci x i , p <i ci 0i = 0deg(p) . The \nrest of the statement follows by Theorem 13, because for all 1 =n.N each 0n .(xn)is an idempotent. Building \non the above, we deduce cancellation, representation, and decidability results. LEMMA 27 (CANCELLATION). \nLet 1 =c .N and 2 =d .N. For t1,t2,q.N[x]with 0=deg(q)=deg(t1)=deg(t2), the fol\u00adlowing cancellation law \nholds in N[x]/(x =c+dx) t1 +q =t2 +q =. t1 =t2 . PROOF. The case in which deg(q)=deg(t1)=deg(t2)=0 holds \nbecause, for all m,n .N,wehave m=n in N[x]/(x=c+dx)iff m =n in N; for all other cases, use Lemma 12 and \nProposition 26, noticing that q< 0deg(q)< 0deg(t1). The parameter rig of the representation is the rig \nof degrees. THEOREM 28 (REPRESENTATION). For 1 = c . N and 2 =d .N, the universal rig homomorphism N[x]/(x \n=c+dx)-. Deg \u00d7Z[x]/(c+(d-1)x) induced by (1,x).Deg \u00d7Z[x]/(c+(d-1)x)is injective. That is, t1 = t2 in \nN[x]/(x =c+dx)iff deg(t1)=deg(t2)and t1 =t2 in Z[x]/(c+(d-1)x). PROOF.(.) Use Proposition 24. (.)Let \nt1,t2 .N[x]. If deg(t1)=deg(t2)=-8 then t1 =t2 =0. If deg(t1)=deg(t2)=0 and t1 =t2 in Z[x]/(c+(d-1)x)then \nt1 =t2 in N. If deg(t1)=deg(t2)=1 and t1 =t2 in Z[x]/(c+(d-1)x)then there exist q1,q2 .N[x]such that \nt1 -t2 =(q1 -q2)\u00b7(x-(c+dx)) (13) in Z[x]and hence such that t1 +q1 \u00b7(c+dx)+q2 \u00b7x = t2 +q1 \u00b7x+q2 \u00b7(c+dx) \nin N[x]. Thus, t1 +(q1 +q2)\u00b7x = t2 +(q1 +q2)\u00b7x in N[x]/(x=c+dx), and by the cancellation Lemma 27, we \nhave t1 = t2 in N[x]/(x =c+dx). PROPOSITION 29. For 1 =c .N and 2 =d .N, we have the following description \n() U N[x]/(x =c+dx)=~ N 1=n.N (xn). As in the previous case of generic trees, we also obtain an explicit \ndecidability result for generic lists. COROLLARY 30 (DECIDABILITY). For 1 = c . N and 2 =d .N, the word \nproblem in N[x]/(x = c+dx), and hence also type isomorphism in C [.X.F]where F .[X]has polynomial form \nc+dX, are explicitly decidable. PROOF. Theorem 28 provides the following decidability test: t1 =t2 in \nN[x]/(x = c+dx)iff deg(t1)=deg(t2), and t1 and t2 have the same normal form in Z[x]under the reduction \nrule (d-1)x -c. Further, for t1 = t2 in N[x]/(x =c+dx)we may divide t1 -t2 by c+(d-1)x in Z[x]to obtain \nthe situation (13) and proceed as in there to produce a derivation of the equality. To conclude the section, \nwe exemplify the theory for a negative-unit type [15]. EXAMPLE 31 (THE NEGATIVE-UNIT TYPE). The results \nof this section imply that the mapping associating p .N[x]/(x=1+2x) to p .N,if deg(p)=0, and to (deg(p)-1,p(-1)).N \n\u00d7Z oth\u00aderwise, yields a bijection ~ N[x]/(x =1+2x)=N (N \u00d7Z) . It follows that the isomorphisms satis.ed \nby the negative-unit type M =.X.1+2\u00d7X are characterised by the identities satis.ed by the negative unit \n-1. Indeed, for X .V,if T1,T2 .[X]are types with polynomial form p1,p2 .N[X]then T1(M)=~ T2(M)in C [M] \niff deg(p1)=deg(p2)and p1(-1)=p2(-1)in Z . Thus, for instance, we have the following isomorphisms n \ni=0 Mi =~ Mn (n.N even) n i=0 Mi =~ 1+Mn (n.N odd) in C [M]. 4.2.2 Generic naturals A linear generic \nrecursive type of the form: N =~ c+N (1=c .N) is referred to as a generic natural. For these types, cancellation \nand representation results can be given directly. LEMMA 32 (CANCELLATION). For p,q .N[x],if deg(p)> deg(q)then \np+cq = p in N[x]/(x = c +x)for all 1 =c .N. nn PROOF. Observe.rstthatfor 1=n.N, we have that x+c=xin \nN[x]/(x=c+x). Indeed, the assertion is trivially true for n=1, and for n>1, we have that n nn-1 x+c = \nx+cx+c nn-1 = x+cx, by induction n = x and hence that nm n-mn x +cx= xm (x+c)= x for all 0 =m<n .N. Thus, \nfor 0 =ni <n .N with i ranging over a .nite set I, nni n x +c = x i.I x and the result follows. THEOREM \n33 (REPRESENTATION). For 1 =c . N, the univer\u00adsal rig homomorphism N[x]/(x =c+x)-. NIxl\u00d7Zc[x] induced \nby (x,x).NIxl\u00d7Zc[x]is injective. That is, t1 =t2 in N[x]/(x=c+x)iff h(t1)=h(t2)and t1 =t2 in Zc[x]. PROOF.(.) \nUse Proposition 24. (.) Let t1,t2 . N[x] with h(t1)= h(t2) be such that t1 =t2 in Zc[x]=~ Z[x]/(c). There \nexist q1,q2 . N[x] with deg(qi)= deg(q1 -q2)= deg(t1 -t2)< deg(tj) for i,j.{ 1,2} such that t1 -t2 =c(q1 \n-q2)in Z[x]and hence such that t1 +cq2 =t2 +cq1 in N[x]. Thus, since deg(t1)> deg(q2) and deg(t2)> deg(q1), \nit follows by Lemma 32 that t1 =t2 in N[x]/(x =c+x). PROPOSITION 34. For 1=c.N, we have the following \ndescrip\u00adtion: N[x]/(x =c+x)is isomorphic to n i=0 ci x i .N[x]| cn .=0 and .1 =i< n.ci .Zc . The representation \ntheorem provides the following decidability test: t1 =t2 in N[x]/(x=c+x)iff h(t1)=h(t2), and t1 and t2 \nhave the same normal form in N[x]under the reduction rule c0. COROLLARY 35 (DECIDABILITY). For 1 = c \n. N, the word problem in N[x]/(x =c+x), and hence also type isomorphism in C [.X.F]where F . [X]has polynomial \nform c+X, are explicitly decidable. PROOF.Given t1,t2 . N[x],if h(t1)=.h(t2)or c does not divide every \ncoef.cient of t1 -t2 . Z[x] then t1 .t2 in = N[x]/(x =c+x). Otherwise, t1 =t2 in N[x]/(x =c+x)and a derivation \nof this identity can be obtained by expressing t1 -t2 as c(q1 -q2)for qi .N[x](i =1,2) as in the proof \nof Theorem 33 and using Lemma 32 to give a derivation of the form t1 = t1 +cq2 = t2 +cq1 = t2 in N[x]/(x \n=c+x). 4.2.3 Generic constants For completeness we include the trivial case of generic constants: C \n=~ c (1 =c .N) THEOREM 36 (REPRESENTATION). For 1 =c . N, the univer\u00adsal rig homomorphism N[x]/(x =c)-. \nN induced by c .N is bijective. That is, t1 =t2 in N[x]/(x =c)iff t1(c)=t2(c)in N. COROLLARY 37 (DECIDABILITY). \nFor 1 = c . N, the word problem in N[x]/(x = c), and hence also type isomorphism in C [.X.F]where F . \n[X]has polynomial form c, are explicitly de\u00adcidable. Acknowledgements. The results of Section 4.1, though \nnot the proofs, are from joint work with Tom Leinster [7], to whom I am grateful for our collaboration. \nI am also grateful to Bill Lawvere for inspiring conversations on Objective Number Theory, and to Jimmie \nLawson and Mike Mislove for bringing up the literature on semigroups to my attention.   5 References \n[1] M. Abadi and M. P. Fiore. Syntactic considerations on recursive types. In 11th Annual Symposium on \nLogic in Computer Science, pages 242 252. IEEE, Computer Society Press, 1996. [2] R. Amadio and L. Cardelli. \nSubtyping recursive types. ACM Transactions on Programming Languages and Systems, 15(4):575 631, 1993. \n[3] A. Blass. Seven trees in one. Journal of Pure and Applied Algebra, 103:1 21, 1995. [4] R. Di Cosmo. \nIsomorphisms of types: from .-calculus to in\u00adformation retrieval and language design. Birkhauser, 1995. \n[5] R. Di Cosmo, F. Pottier, and D. R\u00b4emy. Subtyping recur\u00adsive types modulo associative commutative \nproducts. Preprint available on-line, 2003. [6] M. P. Fiore and T. Leinster. An objective representation \nof the Gaussian integers. To appear in the Journal of Symbolic Computation. (A preliminary preprint appeared \nin arXiv:math.RA/0211454, 2002). [7] M. P. Fiore and T. Leinster. Objects of categories as complex numbers. \nTo appear in Advances in Mathematics. (A prelimi\u00adnary preprint appeared in arXiv:math.CT/0212377, 2002). \n[8] R. Gates. On the generic solution to P(X)=~ X in distributive categories. Journal of Pure and Applied \nAlgebra, 125:191 212, 1998. [9] J. Gil. Subtyping arithmetical types. In 28th ACM SIGPLAN-SIGACT Symposium \non Principles of Programming Lan\u00adguages, pages 276 289. ACM, 2001. [10] J. A. Green. On the structure \nof semigroups. Annals of Math\u00adematics, 54:163 172, 1951. [11] G. Lallement. Semigroups and combinatorial \napplications. Wiley, 1979. [12] F. W. Lawvere. Private communication. Workshop on Domain Theory (DOMAIN \n2002), Copenhagen, Denmark, July 2002. [13] J. Palsberg and T. Zhao. Ef.cient and .exible matching of \nrecursive types. In 15th Annual Symposium on Logic in Computer Science, pages 388 398. IEEE, Computer \nSociety Press, 2000. [14] B. Pierce. Types and Programming Languages. The MIT Press, 2002. [15] S. H. \nSchanuel. Negative sets have Euler characteristic and di\u00admension. In Proc. Como 1990, volume 1488 of \nLecture Notes in Mathematics, pages 379 385. Springer-Verlag, 1991.  \n\t\t\t", "proc_id": "964001", "abstract": "This paper gives the first decidability results on type isomorphism for recursive types, establishing the explicit decidability of type isomorphism for the type theory of sums and products over an inhabited generic recursive polynomial type. The technical development provides connections between themes in programming-language theory (type isomorphism) and computational algebra (Gr&#246;bner bases).", "authors": [{"name": "Marcelo Fiore", "author_profile_id": "81100192065", "affiliation": "University of Cambridge", "person_id": "PP28001652", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/964001.964008", "year": "2004", "article_id": "964008", "conference": "POPL", "title": "Isomorphisms of generic recursive polynomial types", "url": "http://dl.acm.org/citation.cfm?id=964008"}