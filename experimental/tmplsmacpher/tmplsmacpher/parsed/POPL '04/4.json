{"article_publication_date": "01-01-2004", "fulltext": "\n Semantic Types: A Fresh Look at the Ideal Model for Types J\u00b4er ome Vouillon Paul-Andr\u00b4e Melli`es  \nCNRS and Denis Diderot University {Jerome.Vouillon,Paul-Andre.Mellies}@pps.jussieu.fr Abstract We present \na generalization of the ideal model for recursive polymorphic types. Types are de.ned as sets of terms \nin\u00adstead of sets of elements of a semantic domain. Our proof of the existence of types (computed by .xpoint \nof a typ\u00ading operator) does not rely on metric properties, but on the fact that the identity is the limit \nof a sequence of projection terms. This establishes a connection with the work of Pitts on relational \nproperties of domains. This also suggests that ideals are better understood as closed sets of terms de.ned \nby orthogonality with respect to a set of contexts. Categories and Subject Descriptors F.3.3 [Logics \nand Meanings of Programs]: Studies of Program Constructs Type structure; F.3.2 [Logics and Meanings of \nPrograms]: Semantics of Programming Languages Operational semantics; D.3.1 [Programming Languages]: Formal \nDe.nitions and Theory Semantics; D.3.2 [Programming Languages]: Language Classi.ca\u00adtions Applicative \n(functional) languages General Terms Languages, Theory  Keywords Recursive types, polymorphism, subtyping, \nrealizability, ideal model, inductive/coinductive principle 1 Introduction The typing and subtyping rules \nfor powerful type systems can be rather complex and unexpected, due to interactions Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. POPL 04, January 14 16, \n2004, Venezia, Italia. Copyright 2004 ACM 1-58113-729-X/04/0001 ...$5.00 between the several kinds of \ntypes. The .rst author expe\u00adrienced this with XDuce [26], which combines union types and product types. \nA clear semantics of subtyping appears to be really helpful in those situations [15, 21, 27]. Ideally, \nit should be set-theoretic. In the case of XDuce, subtyping is simply de.ned as the inclusion of types \nas sets of values. This is quite handy: union types and product types are then directly interpreted as \nset-theoretic union and product. Unfortunately, the semantic approach becomes complicated, but hopefully \nstill intuitive, in presence of recursive types. Indeed, in this case, the denotation of a type cannot \nbe de\u00ad.ned by induction on its structure. Instead, it is generally de.ned as a .xpoint of some operator. \nThe existence of such a .xpoint is not immediate: the operator is usually not monotone, since function \ntypes are contravariant on the left and covariant on the right. MacQueen, Plotkin, and Sethi [31] proved \nthe existence of such a .xpoint when the denotations of types is taken to be ideals, that is, sets of \nelements of a semantic domain enjoying additional properties. This is .ne, but not entirely satisfac\u00adtory. \nFirst, domain theory is complex, especially if one wants to account for non-determinism. Second, there \nis often a mis\u00admatch between the operational semantics of a language and its denotational semantics, \nwhich can have an impact on the properties of types. It seems therefore important to recast this model \ninside operational semantics. Some major steps have been taken in this direction [1, 5, 12, 13, 14]. \nWe carry on, and provide here an alternative perspective, halfway be\u00adtween the work of Krivine on realizability \n[16] and the work of Pitts on logical relations [34, 35]. Our goal is to classify terms according to \ntheir types. We expect two properties of types: .rst, if a term has a type, then it evaluates without \nerror; second, it must be possible to build more complex typed terms by assembling smaller typed terms \naccording to simple (typing) rules. For instance: App Fst Snd e : t. n t e. : t. e : t \u00d7 t. e : t \u00d7 t. \nee. : t fst e : t snd e : t. Let .(t) be the denotation of type t, that is the set of terms of type t. \nLet S be the set of terms that evaluates without error. The rules above suggest to have the following \ninclusions. .(t. n t) .{e . S |Ve. . .(t.).ee. . .(t)} .(t \u00d7 t.) .{e . S |fst e . .(t) . snd e . .(t.)} \nThese inclusions ensure the soundness of the typing rules above. In order to reason about types, it is \nimportant to have a more precise characterization of types. It seems therefore natural to replace these \ninclusions by an equality. We can then view . as a .xpoint of an operator F such that: F(.)(t. n t)= \n{e . S |Ve. . .(t.).ee. . .(t)} F(.)(t \u00d7 t.)= {e . S |fst e . .(t) . snd e . .(t.)} This operator is \nneither monotone nor anti-monotone, as can be seen on the .rst equation: the set F(.)(t. n t) gets larger \nwhen the set .(t.) gets smaller and when the set .(t) gets larger. As we shall see, it turns out to be \nuseful re.ne the picture, and to de.ne an operator F with two arguments, monotone on its .rst argument \nand anti-monotone on its second argument: F(.+ , .-)(t. n t)= {e . S |Ve. . .-(t.).ee. . .+(t)} F(.+ \n, .-)(t \u00d7 t.)= {e . S |fst e . .+(t) . snd e . .+(t.)} Still, the existence of . such that F(., .)= . \nis not clear as the Knaster-Tarski .xpoint theorem does not apply. This article is organized as follows. \nWe recall some lattice theory (section 2) and provide general conditions implying the existence of a \n.xpoint of the typing operator F above (section 3). Then, we specify a type system and its denota\u00ad tion \n(section 4), from which we deduce the soundness of our subtyping system (section 5). The closure operator \ninvolved in these constructions is nicely expressed by orthogonality between terms and contexts (section \n6). We illustrate our theory by a call-by-value calculus (section 7) and its typing rules (section 8). \nWe .nish by mentioning limitations of our approach (section 9), presenting related work (section 10), \nand pointing out future directions (section 11).  2 Mathematical Background Complete Lattice A complete \nlattice is a partially ordered set such that any subset X of elements has a least upper bound sup X and \na greatest lower bound infX. Limit We de.ne the limit inferior and the limit superior of a sequence (xn)n.N \nof elements of a complete lattice, by: liminf xn = sup inf xn' n' :nn.N limsup xn = inf sup xn' n.N n' \n:n When the two limits coincide, we say that the sequence con\u00adverges and we de.ne the limit of the sequence \nby: limxn = liminfxn = limsup xn All increasing and decreasing sequences converge. The limit operator \nis order preserving: if xn : yn for all n . N, then limxn : limyn. The Sandwich Theorem holds: if a sequence \n(zn)n.N is such that xn : zn : yn for all n . N, where (xn)n.N and (yn)n.N are two sequences converging \nto a same limit, then (zn)n.N converges to this very limit. Closure A closure operator over a partially \nordered set (X, :) is a function which associates to each element x of X an element x of X such that: \nx : x (extensive); x = x (idempotent);  if x : x., then x : x. (monotone). An element x is closed \nwhen x = x. The greatest lower bound of a family of closed elements is closed. The closed elements of \na complete lattice form themselves a complete lattice. Galois Connection Let (X, :) and (Y, C) be two \npartially ordered sets. A Galois connection is a pair of two functions f : X n Y and g : Y n X such that \nfor all x . X and y . Y , x : g(y) i. f (x) C y. A Galois connection ( f , g) induces a closure operator \ng . f over the partially ordered set (X, :).  Polarity A binary relation R between two sets A and B \ninduces a Galois connection, called polarity, between the two power sets (P(A), .) and (P(B), .). The \ncomponents ( f , g) of this Galois connection are de.ned by: f (U)= {y . B|Vx . U.(x, y) . R} for U . \nA g(V )= {x . A|Vy . V.(x, y) . R} for V . B  3 Fixpoints: Existence and Properties In this section, \nwe specify some conditions ensuring the def\u00adinition of the denotation .8(s) of a family of types s as \na .xpoint of an operator F. We also state some interesting properties of this .xpoint. 3.1 Assumptions \non the Calculus The calculus is composed of a set of terms e. Before sec\u00adtion 7, we don t actually assume \nthat these are syntactic terms. They could just as well be, for instance, the elements of a semantic \ndomain. A closure operator associates to a set of terms E another set of terms E. The intuition is that \nE is the set of terms that cannot be distinguished from the terms E: a term in E will evaluate without \nerror in any context where all terms in E would evaluate without error. A possible de.nition for the \nclosure operator is proposed in section 6. We distinguish a set S of safe terms (which, intuitively, \neval\u00aduate without error) and a set B of bottom terms (which loop). These sets satisfy the following properties: \n S is closed;  B is closed;  B . S.  There exist a family ()n of approximation operators (n . N), \nfrom terms to terms, with the following properties: if e . E, then (e)n . E;  if (e)n . E for all n \n. N, then e . E;  if e . S, then (e)0 . B.  An intuition is that (e)n behaves just like e until a nested \ninteraction of depth n is reached, then loops; and that a term e is the limit of its approximations (e)n \n. In section 7, we will fully specify a calculus and provide a corresponding de.nition for the sets S \nand B, and for the approximations operators ()n .   3.2 Semantic Candidates We now de.ne more precisely \nthe domain of the operator F. We assume given a set of types s. The operator F takes as arguments two \nsemantic candidates and returns a semantic candidate. A semantic candidate . is a function from types \nto sets of terms which satis.es the following property: B . .(s) . S. In other words, a well-typed term \ndoes not fail, and a term that loops can be given any type. The semantic candidates are naturally equipped \nwith a com\u00adplete lattice structure induced by the point-wise order C: . C .. i. Vs..(s) . ..(s). The \nclosure operator on set of types induces a closure oper\u00adator on semantic candidates, de.ned by: .(s)= \n.(s).  3.3 Assumptions on the Operator F 3.4 Semantic Typing We can now state the existence of a .xpoint. \nActually, it turns out that there exists a best .xpoint, in the sense that it is the closure of any other \n.xpoint, hence the greatest one. We will only consider this particular .xpoint .8, the semantic typing, \nin the remainder of this paper. Theorem 2 (Greatest Fixpoint). The operator F has a closed .xpoint .8. \nThis .xpoint is the closure of any other .xpoint of F. Proof. Preliminary Let .B be the least semantic \ncandi\u00addate (which associates B to each type) and .S be the greatest semantic candidate (which associates \nS to each type). We de.ne two sequences of semantic candidates (.- n )n.N and (.+)n.N by: n = F(.- .- \n.- n , .+) 0 = .B n+1 n .+ 0 = .S .+ n+1 = F(.+ n ) n , .- The sequence (.- n )n.N is increasing and \nthe sequence (.+ n )n.N is decreasing. Besides, for all n, we have .- nn . C .+ So, both sequences are \nconverging to some semantic candi\u00ad 8 8 date .- and .+ .- 0 C ... C.- n and we have the following ordering: \nWe now state some properties of the operator F ensuring 88 C... C.- C.+ Furthermore, the semantic candidates \n.- and .+ are closed We de.ne a family of relations <n by: nn for all n . N, as F preserves closure. \nThe semantic candidate C... C.+ C ... C.+ n 0 . that it has a .xpoint. E <n E. i. for all e in E we have \n(e)n . E. 8 8 .+ of closed semantic candidates. The semantic candidate .- is included on the other hand, \nneed not be closed. is also closed, as it is the greatest lower bound of a set . In other words, E <n \nE. i. the image of E by ()n , in E. . We write .<n .. for the point-wise extension of the re\u00adlation \n<n to semantic candidates. We state a few interesting 8 8 Any .xpoint of F is between .- and .+ prove \nby induction that a .xpoint . satis.es .- C . C .+ nn for all n. This suggests to compare more precisely \nthese two semantic candidates. . Indeed, we can properties of the relations <n that we will use in section \n3.4. Remark 1 (Some properties of the relations <n). The following properties hold: 88 A closed .xpoint \ncandidate We are going to prove that .+ .- E <0 B if E . S; This implies that if there is a closed .xpoint, \nit = . if E1 . E1. , E. 1 <n E2. , and E2 . . E2, then E1 <n E2;  if E <n E. for all n . N, then E \n. E. .  Proof. The two .rst properties are easy to check. We prove the third one. Suppose that e . E. \nBy assumption, (e)n . E. for all n . N. So, e . E. . We conclude that E . E. . The operator F satis.es \nthe three following properties: 8 8 must be .+ First, we prove by induction that .+ <n .- This relation \nnn . holds for n = 0: .+ 0 (s) <0 B = .- 0 (s). Let us assume that it holds for some n. Then, it holds \nfor n + 1 as F is contractive: .+ = F(.+ n , .-) <n+1 F(.- n , .+)= .- n+1 n nn+1. Hence, .+ . <n .-, \nand .- nn C .+ n , .+ n <n . 88 8 C .- c .-. and .+ 88 88 So, we have .+ .- . This is true for all \nn . N, so .+ C .+ F is monotone on its .rst argument and anti-monotone on its second argument: if .1 \nC .. 1 and .. 2 C .2, then F(.1, .2) C F(.. 1, .. 2); 888 On the other hand, we have .- fore, .-C .+ \n. is closed. There\u00ad F preserves closure: 8 8 We now check that .+ , .+). 8 8 if . and .. are closed, \nthen F(., ..) is also Existence of the closed .xpoint is indeed a .xpoint, that is, .+ = F(.+ closed; \nF is contractive : 888 8 8 8 We remark that for all semantic candidate ., if .- .+, then .- C F(., .) \nC .+ . Indeed, if .- C . C .+ C . C , then if . and .. are closed and . <n .. , then F(., ..) <n+1 F(.. \n, .). 8 88 8 .- C . C .+ for all n and thus .- n+1 for all n. n+1 C F(., .) C .+ nn Hence, .- C F(.+ \n, .+) C .+ The last property plays the same technical role as contrac\u00ad tivity in [31] without requiring \na metric space. . Then, as F(.+ 8 , .+ 8 ) is closed (F preserve closure), .+ = .-8 C F(.+ 8 , .+ 8 \n) C .+ 8 8 as wanted. Greatest .xpoint Let . be a .xpoint of F. We showed in the preliminary of this \nproof that .- 8 C . C .+ 8 . Hence, . = .+ 8 .  3.5 A Reasoning Principle In order to reason about \ntypes, it is not su.cient to charac\u00adterize the semantic typing .8 as a .xpoint of F. It is also important \nto have some kind of induction principle, which takes advantage of the uniqueness of .8. We are going \nto state such a principle. We start by remarking that .8 can also de.ned by iteration. Lemma 3 (Iterations). \nAny sequence (.n)n.N of closed semantic candidates such that .n+1 = F(.n, .n) converges to the semantic \ntyping .8 in the lattice of closed semantic can\u00addidates. Proof. We consider the sequences (.-)n.N and \n(.+)n.N de\u00ad nn .ned during the proof of theorem 2. Both sequences converge to .8 in the lattice of closed \nsemantic candidates. Further\u00admore, for all n . N, we have .- n . So, by the Sand- C .n C .+ n wich theorem, \nthe sequence (.n)n.N converges to .8. The reasoning principle is a direct corollary of this lemma. We \nsay that a semantic candidate . is constant if for all types s and s. we have .(s)= .(s.). Theorem 4 \n(Reasoning Principle). Let P be a predi\u00adcate on closed semantic candidates such that: if . is constant, \nthen . satis.es P;  if . satis.es P, then so does F(., .);  if a sequence (.n)n.N converges in the \nlattice of closed semantic candidates, and all .n satis.es P, then their limit also satis.es P.  Then, \nthe semantic typing .8 satis.es P. Proof. We consider the sequence (.n)n.N de.ned by .0 = .B and .n+1 \n= F(.n, .n). By lemma 3, this sequence con\u00ad verges to .8. All .n satis.es P by the two .rst hypotheses. \nSo, their limit .+ 8 also satis.es P, by the third hypothesis.  4 Types 4.1 Syntax of Types Types are \nde.ned in two steps. First, we de.ne inductively .nite patterns called type patterns. Then, these patterns \nare assembled coinductively [8, 19, 22] into possibly in.nite trees called types. This two-step construction \nrules out ill\u00adde.ned types, such as t = t ~ t because t ~ t is not a pattern. Indeed, any occurrence \nof a type in a pattern is below a constructor n or \u00d7. The di.erent type constructions are standard. See \nsec\u00adtion 4.3 for a precise description of their meaning. We as\u00adsume given a set of type variables a and \na single constant .. Given a set of types t, we de.ne type patterns t inductively by the grammar below. \nt ::= . constant | t \u00d7 t pair type | t n t function type | a type variable |. top type | t .t intersection \ntype |Va.t universal quanti.cation |. bottom type | t ~t union type |:a.t existential quanti.cation We \nwrite t(t1,..., tk) when the pattern t has leaves t1, ..., tk, where each ti occurs linearly in t. The \n.nite patterns t are assembled coinductively as follows: t ::= t(t1,..., tk) coinductively. By coinduction, \nevery type t is of the form t(t1,..., tk). So, we can reason inductively on the structure of type patterns, \nthen coinductively on the structure of types. This turns out to be very convenient. Another point is \nthat all the con\u00adstructions n, \u00d7, ., . . . , on type patterns lift in the obvious way to constructions \non types. This enables to write types like t1 n t2, t1 . t2 or Va.t. Types are considered modulo renaming \nof their bound vari\u00adables. This does not contradict the coinductive de.nition of types on the alphabet \nof patterns since, in fact, a-conversion is only a handy presentation of de Bruijn indices. Note also \nthat we don t assume types to be regular: types may have an in.nite number of distinct subtrees. Because \nof free type variables, we cannot directly associate a set of terms to a type t. Indeed, we need to provide \nan interpretation for these variables. We use an environment ., a function from type variables to set \nof terms such that for all variable a, the set .(a) is closed and the inclusions B . .(a) . S hold. Then, \na type s of section 3 is actually a pair, written (t)., of a type t and an environment .. 4.2 Language \nRe.nements In order to give a meaning to types, we need to re.ne our de.nition of the language: the language \nhas functions, pairs and a constant. More precisely, we must specify the destruc\u00adtors corresponding to \nthese constructions: the application, the pair projections fst and snd, and a function isconst that test \nwhether its argument is the constant .. So, we have an application function which associates to two . \nterms e and eanother term noted ee., and three functions fst, snd and isconst from terms to terms. We \ndon t assume that any of theses function is a term. Let f be a function from terms to terms. We say that \nf is strict if f (B) . B (or, equivalently, B . f -1(B)). We say that f is continuous if, for all closed \nset of terms E, the set f -1(E) is closed. The functions fst, snd, and isconst are strict and contin\u00aduous. \nIf e. . S, then the function which associate to a term e the term ee. is strict and continuous. The approximation \noperators ()n are continuous. (One can prove that they are also strict.) The function fst, snd and the \napplication satisfy some com\u00admutation properties with respect to the approximation op\u00aderators: if (fst \ne)n . E, then fst (e)n+1 . E;  if (snd e)n . E, then snd (e)n+1 . E;  if (e(e.)n)n . E, then (e)n+1 \ne. . E.  4.3 De.nition of the Type Operator We discuss informally what properties of the semantic typ\u00ading \n.8 we would like to have. Since most properties can be interpreted as (reversible) elimination rules, \nwe take the freedom to write them as such. A term e has type . i. it is safe and it can safely be applied \nto the function isconst: G . e : . G . isconst e : . A term e has type t1 \u00d7t2 i. it is safe and it yields \na term of type t1 when applied to fst and a term of type t2 when applied to snd: G . e : t1 \u00d7 t2 G . \ne : t1 \u00d7 t2 G . fst e : t1 G . snd e : t2 A term e has type t2 n t1 i. it is safe and it yields a term \nof type t1 whenever applied to a term of type t2: G . e1: t2 n t1 G . e2: t2 G . e1 e2: t1 A term e \nhas type a in the environment . i. it is in\u00adcluded in .(a).  A term e has type . i. it is safe (. is \nthe greatest type).  A term e has type t1 . t2 i. it both has types t1 and t2:  G . e : t1 . t2 G . \ne : t1 . t2 G . e : t1 G . e : t2 A term e has type Va.t in the environment . i. it has type t in any \nenvironments derived from . by binding the variable a to a closed set of term E containing B and contained \nin S: G . e : Va.t G . e : t[t./a] A term e has type i. it is a bottom term ( is the least type).  \nA term e has type t1 ~ t2 i. it is in the closure of the elements of type either t1 or t2. Intuitively, \nthe need of a closure comes from the following typing rule:  G . e1: t1 ~ t2 G . e2: t1 n tG . e2: t2 \nn t G . e2 e1: t This is a Curry-style counterpart (the terms do not con\u00adtain any type) to the more usual \ntyping rule [33]: G . e1: t1 ~ t2 G;x : t1 . e2: tG;x : t2 . e2: t G . case e1 of x . e2: t The rule \ncan be read informally as: a term e1 has type t1 ~ t2 if it can be plugged in any context that accept \nany expression of type t1 or t2. The closure operator is meant to express this kind of contextual property. \nOne may have expected that a term e has type t1 ~ t2 if it has either t1 or t2. But this is clearly not \nthe right de.nition in the presence of non-determinism. A term e has type :a.t in the environment . i. \nit is in the closure of elements of type t in any environment derived from . by binding the variable \na to a closed set of terms E containing B and contained in S: G . e1: :a.t1 G;a . e2: t1 n ta .. FV(t) \nG . e2 e1: t The reason for the closure is similar as for union types. The operator F associates to a \npair (.+ , .-) of semantic candidates a semantic candidate . de.ned inductively on type patterns as follows: \n. (.). = {e . S |isconst e . S} . (t1 \u00d7 t2). = {e . S |fst e . .+ (t1). . snd e . .+ (t2). } . (t2 n \nt1). = {e . S |Ve. . .- (t2). .ee. . .+ (t1). } . (a). = .(a) . (.). = S . (t1 .t2). = . (t1). . . (t2). \nT . (Va.t). = B E S . (t).[a=.E] . (). = B . (t1 ~t2). = . (t1). . . (t2). S . (:a.t). = B E S . (t).[a=.E] \nIn order to prove the expected properties of F, it can be useful to de.ne it by the following equivalent, \nbut more al\u00adgebraic, equalities: . (.). = S . isconst-1 (S) . (t1 \u00d7 t2). = S . fst-1 .+ (t1). . snd-1 \n.+ (t2). T . (t2 n t1). = S . ..-((t2).){e|ee. . .+ (t1). } e ' 4.4 Properties of the Operator We now \nprove that the operator F indeed de.nes a best .xpoint .8, by checking all our assumptions of section \n3.3. Lemma 5 (Well-defined). The function . = F(.+ , .-) is a semantic candidate. Proof sketch. It is \nclear that .((t).) . S for all t and .. We show that B . .((t).) by induction on the type pattern t, \nusing the strictness of isconst, fst and snd and the left\u00adstrictness of application. Lemma 6 (Monotone). \nIf .1 C .. and .. 2 C .2, then 1 F(.1, .2) C F(.. 1, .. 2). Proof sketch. Let . = F(.1, .2) and .. = \nF(.1. , .. 2). We assume .1 C .. 1 and .. 2 C .2, and prove .((t).) . ..((t).) by induction on the type \npattern t. All cases are immediate. Lemma 7 (Closed). If .+ is closed, then F(.+ , .-) is closed. Proof \nsketch. We show that F(.+ , .-)((t).) is closed by induction on the type pattern t. We use the stability \nof the closure by intersection, the continuity of fst, snd and isconst, and the left-continuity of application. \nRemark 8 (Additional properties of < n). The following properties hold: E < n E;  if E1 < n E. 1 and \nE2 < n E. 2, then (E1 . E1. ) < n (E. 1 . E2. );  if E1 < n E. 1 and E2 < n E2. , then (E1 . E. 1) < \nn (E1 . . E. 2);  if E < n E., then E < n E. .  The second and third properties can be generalized \nto in.nite unions and intersections. Proof. All but the last property are easy to check. Let us consider \nthe last property. The assumption can be restated as: E is included in the inverse image of E. by ( )n \n. So, by monotony, E is also included in the inverse image of E. by ( )n . As ( )n is continuous, this \ninverse image is closed. So, it contains the closure of E. That is, E < n E. as wanted. Lemma 9 (Contractive). \nIf . < n .. and .. is closed, then F(., ..) < n+1 F(.. , .). Proof sketch. We show that F(., ..)(t) < \nn+1 F(.. , .)(t) by induction on the type pattern t. We only consider the most interesting case: t = \nt2 n t1. Let e . F(., ..)(t2 n t1).. We want to show that (e)n+1 . F(.. , .)(t2 n t1).. First, as e . \nS and S is closed, we have (e)n+1 . S. Let e. . .((t2).). By assumption, (e.)n . ..((t2).). Therefore, \ne(e.)n . .((t1).). By assumption again, (e(e.)n)n . ..((t1).). By commutation, as the semantic can\u00addidate \n.. is closed, (e)n+1 e. . ..((t1).) as wanted.  5 Subtyping Rules We have now made enough assumption \nabout the language and the types to prove the soundness of the subtyping rules given in .gure 1. These \nrules are standard. The set FV(t) is the set of free variables of t. These rules may be interpreted inductively \nor coinductively. Soundness is obvious in the inductive case, since each rule is immediately true when \ntaken in isolation. But we adopt here the coinductive interpretation [8, 22], which captures more subtyping \nrelations. Const . <: . Pair t1 <: t. 1 t2 <: t. 2 t1 \u00d7 t2 <: t. 1 \u00d7 t. 2 Fun t. 2 <: t2 t1 <: t. 1 t2 \nn t1 <: t. 2 n t. 1 Var a <: a Top t <: . Inter-R t <: t1 t <: t2 t <: t1 . t2 Inter-L1 t1 <: t t1 . \nt2 <: t Inter-L2 All-R t2 <: tt <: t. a .. FV(t) t1 . t2 <: tt <: Va.t. Union-L Union-R1 Bot t1 <: tt2 \n<: tt <: t1 <: t t1 ~ t2 <: tt <: t1 ~ t2 Union-R2 Exists-L t <: t2 t. <: ta .. FV(t) t <: t1 ~ t2 :a.t. \n<: t Figure 1. Subtyping rules We write [[t]]. for .8((t).), where .8 is the closed .xpoint of the operator \nF. Theorem 10 (Soundness of the subtyping rules). If t <: t., then for all environment . we have [[t]]. \n. [[t.]].. Proof sketch. This result is proved by applying the Rea\u00adsoning Principle (theorem 4). In order \nto use this theorem, we .rst need to de.ne the predicate P: for all type patterns t and t., for all environment \n., if t <: t., then .((t).) . .((t.).). We then need to check that each hypothesis of theorem 4 holds. \nMost hypothesis are immediate. We prove: if . is closed and satis.es P, then so does F(., .) by induction \non the type patterns t and t., and by case on the last rule of a derivation of t <: t. .  6 Orthogonality \nWe show how an appropriate choice of the closure operator implies immediately the continuity properties \nof section 4.2. We de.ne the closure operator using a polarity. Suppose we have a set of coterms , together \nwith an orthogonality relation ec. The relation induces a polarity between terms and coterms, and therefore \na closure relation on terms. The .rst component of the polarity associates to a set of terms E a set \nof coterms E = {c|Ve . E.ec}; the second component associates to a set of coterms C a set of terms C \n= {e|Vc . C.ec}. We now need to choose a set of coterms and an orthogonality relation. The key ingredient \nfor this choice is the following lemma about adjunction. Let f be a function from terms to terms, and \ng be a function from coterms to coterms. We say that g is an adjoint of f i. App e . .x.e1 e. . v2 Abs \ne1[v2/x] . vv .x.e . .x.e ee. . vv Case-Abs e1 . .x.ee4 . vv case e1 e2 e3 e4 . vv App-Error-2 e . .x.e1 \ne. . error ee. . error Fst e . (v1, v2) fst e . v1 Pair e1 . v1 e2 . v2 (e1, e2) . (v1, v2) Const . . \n. Snd Para-Left e . (v1, v2) e1 . vvsnd e . v1 e1le2 . vv Pair-Error-1 e1 . error (e1, e2) . error Pair-Error-2 \ne1 . v1 e2 . error (e1, e2) . error Snd-Error e . vv vv .= (v1, v2) Case-Const e1 . . e2 . vvcase e1 \ne2 e3 e4 . vv Para-Right Var-Error v e2 . v x . error e1le2 . vv Case-Error e1 . error case e1 e2 e3 \ne4 . error Case-Pair e1 . (v1, v2) e3 . vv case e1 e2 e3 e4 . vv App-Error-1 e . vvv .= .x.e v ee. . \nerror Fst-Error e . vvv .=(v1, v2) v fst e . error snd e . error Figure 2. Reduction rules Lemma 11. \nIf a function f has an adjoint g, then it is con\u00adtinuous. Proof. Let f be a function with an adjoint \ng. Let E be a closed set of terms. The following propositions are equiva\u00adlent: e . f -1(E) f (e) . E \nVc . E . f (e) c Vc . E .eg(c) Vc . g(E ).ec e . (g(E )) Therefore, f -1(E)=(g(E )) is closed. We therefore \nchoose the coterms and the orthogonality re\u00adlation so that we have an adjoint for fst, snd, isconst, \nthe application and the approximation operators ()n . This yields naturally to the use of contexts: C \n::= [ ] hole | Ce application | eC application | fst e .rst projection | snd e second projection | isconst \ne constant tester | (e)n approximation Indeed, let us use the following de.nition of orthogonality: \ne C i. C[e] . S. Then, all functions expected to be continuous clearly have an adjoint (for instance, \nfst e C i. e C[fst [ ]]). Besides, S is closed: S = {[]} . It is interesting to notice that the speci.cation \nof union types in section 4.3: . (t1 ~t2). = . (t1). . . (t2). can be rewritten equivalently as: . \n(t1 ~t2).= . (t1).. . (t2). which is dual to the speci.cation of intersection types: . (t1 .t2). = . \n(t1). . . (t2). A similar duality also holds for existential and universal quanti.cation. Interpreting \ntypes as closed sets of terms de.ned by orthog\u00adonality ensures that types are maximal, in the sense that, \nif we take a term e which is not of some type t, then we can .nd a context C accepting any term of type \nt but rejecting e.  7 A Simple Call-by-value Calculus In order to verify that the assumptions made in \nthe previ\u00adous sections make sense, we consider a simple call-by-value calculus and prove that it satis.es \nthese assumptions. 7.1 De.nition The terms of the calculus are given by the grammar below. We assume \nan in.nite set of variable x. There is a single constant .. e ::= x | .x.e | ee | . | (e, e) | case eeee \n| fst e | snd e | ele variable abstraction application constant pair case operator .rst projection second \nprojection non-deterministic choice We give a big step semantics to the language. Indeed, we don t need \nto capture diverging behaviors: terms that di\u00adverge are well-typed. The values are abstractions, pairs, \nthe constant and the error: v ::= .x.e | (v, v) | . v ::= v | error v Terms and values are considered \nmodulo renaming of bound variables. The convergence relation e . vv is de.ned by the inductive rules \nof .gure 2. We say that a term e diverge if there is no value vv such that e . vv.  7.2 De.ning the \nSemantic Typing We now show that this calculus satis.es all assumptions of sections 3.1 and 4.2. We .rst \nde.ne safe terms and bottom terms. The safe terms are the terms that do not converge to error. S = {e|\u00ac(e \n. error)} The bottom terms are the terms that diverge. B = {e|\u00ac(:v.e .v)} v v e .ne. n . n. e .n (e' \n.)n . e .ne . .x.e .n .x.e . e1 .ne 1 . e2 .ne 2 (e1, e2) .n (e1. , e2. ) .. .x.e .n .x.en . n x .nx \n.x.e .n .y.((.x.e.)(y)n ' )n ' .. e1 .ne1 e2 .ne2 . .n . .. e1 e2 .ne1 e 2 .. e .nee .ne .. fst e .n \nfst esnd e .n snd e The closure operator is de.ned by orthogonality using the de.nition of safe terms \nand the contexts of section 6. We can then check that the assumption on S and B of section 3.1 are satis.ed. \nLemma 12 (Properties of S and B). The sets S and B are closed, and the set B is a subset of S. Proof. \nIt is clear that B . S and S is closed (S = ([ ]) ). Let us prove that B is closed. Let e in B. We have \nfst [ ] . B and [ ] . . B . Therefore, by de.nition of the closure operator, we have both fst e . S and \ne. . S. This is only possible if e diverges. We now de.ne a number of useful terms: (.x.xx)(.x.xx) diverge \n= fail = .. isconst = .x.case x diverge error error p0 = .x.diverge .. e1 .nee2 .ne 12 .. e3 .nee4 .ne \n34 .... case e1 e2 e3 e4 .n case e1 e2 e3 e 4 .. e1 .nee2 .ne 12 error .n error e1le2 .ne1. le. 2 Figure \n3. Annotation of terms and values error). On the other hand, we have \u00ac(C[e] . error). So, it is su.cient \nto prove that if C[e] . error then C[e.] . error. We prove by induction on contexts the more general \nproperty that, for all context C, if C[e .] . v v v then C[e] .v. Lemma 15 (Commutation). The following \nproperties of pn+1 = .x.case x the approximation operator hold: x (pn (fst x), pn (snd x)) .y.pn (x (pny)) \n The term diverge is an element of B. The term fail is not an element of S (that is, fail . error). The \nterm isconst diverges when applied to the constant, and fails when applied to any other value. We de.ne \nthe approximation operators ()n by (e)n = pne.  if (fst e)n . E, then fst (e)n+1 . E;  if (snd e)n \n. E, then snd (e)n+1 . E;  if (e(e.)n)n . E, then (e)n+1 e. . E.  Proof sketch. By application of lemma \n14. For instance, for the .rst property, we prove by case on a derivation of fst (e)n+1 .v that if fst \n(e)n+1 . v v v v then (fst e)n .v. We .nish by checking the other properties of the approxi\u00admation operator \n(section 3.1). We can then check that the continuity and strictness as\u00adsumptions of section 4.2 are \nsatis.ed.  Lemma 13 (Continuity and Strictness). The opera\u00adtors fst, snd, isconst and ()n are strict \nand continuous. If e. . S, then the function which associate to a term e the . term eeis also strict \nand continuous. Proof sketch. Continuity is clear by lemma 11. Strict\u00adness is also easy. For instance, \nif e . B, then we can prove by contradiction that fst e . B. Indeed, there would other- Lemma 16 (Approximation). \nThe following properties of the approximation operators hold: if e . E, then (e)n . E  if (e)n . E \nfor all n . N, then e . E.  v v v such that fst e .v. that this is not the possible by case on a derivation \nof this proposition. We now prove the commutation properties of the approxima\u00adtion operators (section \n4.2). The proof relies on the following lemma. wise exist a valueWe can easily see if e . S, then (e)0 \n. B; The proof of the two .rst properties require some work. In\u00adtuitively, we show that if we insert \napproximation operators into a term, then we get less errors. Conversely, if a term fails, it still fails \nwhen the rank of the added approximation operators is high enough. To be precise, we de.ne an anno\u00adtation \nrelation e .ne. stating that the term e. is the term e . . Lemma 14. Suppose that, for all Then, with \nsome inserted approximation operators of rank at least if e . E then e. . E. v v v, if ev then e .Proof \nsketch. Let us assume that e . E. v v. Let C in E vv vv v n (.gure 3) and prove the two lemmas below. \n vv such that e .v andv .0v . .. ., then there exists a value Lemma 17. If e and e .0 e . . C, that is, \nC[e.] . S, or \u00ac(C[e.] . We want to prove that e AppVar-Access G . e1: t2 n t1 Abs Pair Fst Const G(x)= \ntG . e2: t2 G;x : t2 . e : t1 G . e1: t1 G . e2: t2 G . e : t1 \u00d7 t2 G . . : . G . x : tG . e1 e2: t1 \nG . .x.e : t2 n t1 G . (e1, e2) : t1 \u00d7 t2 G . fst e : t1 Union-Elim Exists-Elim G . e1 : t1 ~ t2 G . \ne1 : :a.t1 Snd Para G . e2 : t1 n t G;a . e2 : t1 n t Exists-Intro Inter-Intro G . e : t1 \u00d7 t2 G . e1 \n: t G . e2 : t G . e2 : t2 n t a .. FV(t) G . e : t[t./a] G . e : t1 G . e : t2 G . snd e : t2 G . e1le2 \n: t G . e2 e1 : t G . e2 e1 : t G . e : :a.t G . e : t1 . t2 All-Intro G;a . e : t G . e : Va.t All-Elim \nG . e : Va.t. G . e : t.[t../a] Sub G . e : t. t. <: t G . e : t Figure 4. Typing rules Proof sketch. \nThe proof is by induction on a derivation In order to prove the soundness of the typing rules, we in\u00ad \n. terpret the judgments as logical propositions: v Lemma 18. If e . v . [[. e : t]]. = e . [[t]]. v, \nthen there exists n . N such that, for . . N, if e .n+n ' v Proof sketch. The proof is by induction \non a derivation of We write [[t]]. for .8((t).). The substitution J[e./x] is the v. of e .v and on the \nsize of each intermediate value. v v v v v v v [[x : t;J]]. = Ve. . [[t]]..[[J[e./x]]]. . . v all \nn then there exists a valuesuch that e [[a;J]]. = VE.B . E . S . [[J]].[a=.E] . . .. v .n ' v and e . \nusual capture-avoiding substitution. e . The integer n depends both on the size of the derivation We \nmake use of the following lemma in order to prove the soundness of the typing rules Exists-Intro and \nAll-Elim.We can now .nish the proofs. Proof sketch of lemma 16. Let us assume that (e)n .. E and show \nthat e .. E. We know that there exists C . E such that the relation (e)n C does not hold. Therefore, \nby de.nition of nCand [()] . Ontheotherhand, have Sewe error,. v C[e] .0C[(e)n]. So, by lemma 17, there \nexists a value v such that C[e] .v andv .0 error. By inspection of v v = error. e .. E as wanted. vv \nthe de.nition of the annotation relation, we see that C does not hold: Therefore, the relation e Proof \nsketch. We simultaneously prove by induction on n that for all type t, we have [[t[t./a]]]. < n [[t]].[a=.[[t']].] \nand Lemma 19 (Type substitution). The following equality hold: [[t[t./a]]]. = [[t]].[a=.[[t']].] [[t]].[a=.[[t']].] \n< n [[t[t./a]]].. Theorem 20 (Soundness of the typing rules). If . e : t, then e . S. The proof of the \nsecond property is similar, but relies on lemma 18 instead of lemma 17.  By inspection of the reduction \nrules of .gure 2, it is clear that if e . S, then (e)0 . B.   8 Typing Rules We de.ne some typing \nrules for the calculus of section 7 and prove their soundness. The typing judgments J are de.ned by the \nfollowing grammar: J ::= . e : t | x : t;J | a;J The constructions x : t;J and a;J respectively bind \nx and a in the judgment J. Judgment are considered modulo renaming of bound variables. A typing environment \nis a context in with one can plug a judgment to form another judgment: G ::= | x : t;G | a;G We note \nG(x) the type associated to the variable x in the typing environment G. The typing rules are given in \n.gure 4.  Proof sketch. We prove that if G . e : t then for all envi\u00adronment . the proposition [[G . \ne : t]]. holds, by considering each typing rule in turn. Then, if . e : t, we have e . [[t]]. . S for \nany environment .. 9 Limits of the Approach 9.1 Proof Techniques It seems natural to replace the rules \nExists-Intro and All-Elim by subtyping rules: t.. t[t./a] <: t.. <: t[t./a] t.. Va.t <: t.. <: :a.t These \nrules would be obviously sound (by lemma 19) if our subtyping relation were de.ned inductively. Unfortunately, \nin our coinductive system, we are not able to extend the proof of our soundness theorem 10 to accommodate \nthese two subtyping rules. Indeed, the current proof is by induction on type patterns, but the type pattern \nt[t./a] is not necessarily smaller than the type patterns :a.t and Va.t. Another point is that the proof \nof lemma 19 relies on a very precise knowledge of the structure of the semantic typing (it makes uses \nof the < n relations). We don t know how to avoid this. 9.2 Approximation Operators Our results rely \ndeeply on the approximation operators ()n . However, these approximation operators do not exist for ar\u00adbitrary \ncalculi. For instance, suppose that we replace the two reduction rules App-Error-1 and App-Error-2 by \nthe rules below: e . v e. . v. e . error e . v e. . error v .= .x.e ee. . error ee. . error ee. . error \n In other words, we don t require anymore that the .rst term of an application is a function, as long \nas the second term diverges. Then, the assumption: if (e(e.)n)n . E, then (e)n+1 e. . E. does not hold \nfor E = S, since the term (.(.)0)0 diverges, while the term (.)1 . converges to error. Similarly, if \nwe extend the calculus with coinductive values, such as a value v0 such that v0 =(v0, v0), then the assumption: \nif (e)n . E for all n . N, then e . E does not hold for E = B and e = v0, since (v0)n diverges for all \nn, while v0 is a value. In the .rst case, a workaround is to modify the de.nition of the operator F for \nfunction types to: . (t2 n t1). = {e . S |isfun e . S .Ve. . .- (t2). .ee. . .+ (t1). } where isfun = \n.x.case x error error diverge. That is, we force terms of type t2 n t1 to reduce to function values. \nIn that way, we only need the following weaker assumption in our proof: if isfun e . S and (e(e.)n)n \n. E, then (e)n+1 e. . E. But this workaround is annoying because it rejects the equal\u00adity n = . which \nis intuitively appealing in this modi.ed calculus. Indeed, the application of any term of type . to a \nterm of type diverges. In fact, there seems to be no way out: de.ning a family of approximation operators \nnecessarily modi.es either the se\u00admantics of the calculus or of the typing. This approach is taken, for \ninstance, by Dami [13, 14] who adds the approx\u00ad imation operators directly in the language. In the calculus \nwith coinductive values mentioned above, this results in an altered semantics where new values are admitted \nlike a pair v1 =(O, O), where fst v1 diverges (these values are intro\u00adduced to approximate coinductive \nvalues such as v0). But, then, the type \u00d7 is inhabited by non-diverging terms such as v1, while we would \nexpect to have \u00d7 <: in a call-by-value language with coinductive values. 10 Related Work Models of Recursive \nTypes MacQueen, Plotkin, and Sethi [31] de.ne the ideal model for types by interpreting types as ideals \nof a domain V, which veri.es the isomorphism: V . = T + N +(V n V)+(V \u00d7 V)+(V + V)+ {error } . That is, \nV is isomorphic to the coalesced sum of the truth values T, the integers N, the continuous functions \nfrom V to V, the product of V with itself, the sum of V with itself, and a value error. An ideal I is \na non-empty set of elements of V which is down\u00adward closed and closed under least upper bounds of increas\u00ading \nsequences. The ideals are actually the closed sets of the Scott topology (but the empty set). Our framework \ncan be instantiated by taking S = V \\{error} so that these closed sets coincide with our closed sets \nof section 6. Indeed, a closed set I of the Scott topology is closed according to our de.nition: there \nexists a continuous function f from V to V such that fe = if e . I fe = error otherwise, and therefore \nI = { f [ ]} . Conversely, one can check that our closed sets are downward closed and closed under least \nupper bounds of increasing sequences. The three authors specify a metric on the ideals of V, such that \nthe set of ideals is a complete metric space. The deno\u00adtation of a recursive type is computed as the \n.xpoint of an operator from ideals to ideals which is shown to be contrac\u00ad n tive. In our case, this \nmetric can be de.ned using the < relations: d(I, J)= 0 if I = J; otherwise, d(I, J)= 2-n where n is the \ngreatest integer such that I < nJ and J < nI. The equiv\u00adalent of our iteration principle (lemma 3) is \nproved using the Banach .xpoint theorem. Chroboczek [12] introduces a metric in the same spirit to analyze \nrecursive types in game semantics. Damm [15] applies the ideal model to study the subtyping of union \nand intersection types and to prove the soundness and completeness of a subtyping algorithm. Cartwright \n[11] de.nes types semantically as intervals, that is, as pairs of two ideals (I, J) such that I . J. \nSuch a typing provides two pieces of information at the same time: every term e . I has type (I, J), \nand every term of type (I, J) is el\u00adement of J. The interesting point about intervals is that an operator \nF from ideals to ideals which is monotone in its .rst argument and anti-monotone in its second argument \ninduces a monotone operator from intervals to intervals: this opera\u00adtor associate to an interval (I, \nJ) the interval (F(I, J), F(J, I)). Then, by the Knaster-Tarski .xpoint theorem, this mono\u00adtone operator \nhas a least .xpoint (this correspond to the beginning of our proof of theorem 2). Unfortunately, the \ntwo bounds of the .xpoint do not a priori coincide. At this point, Cartwright uses the same metric space \nargument as in the ideal model to establish that the bounds coincide in the case of contractive operators. \nIn domain theory, a solution V of a recursive equation V = G(V) is usually obtained by bi-limit [3] of \nthe sequence de.ned inductively by V0 = {.}and Vn+1 = G(Vn). We can consider that Vn .V (the domain Vn \nis isomorphic to a sub\u00adset of V) and de.ne a family of projections pn from V to Vn+1. These projections \ncorresponds to our approximation operators. They are central to most works derived from the ideal model. \nOnly Appel and McAllester [5] take a di.erent approach: they give a small-step semantics to their calculus, \nand limit the number of steps to get an approximation of the behavior of a term. Pitts [34] is interested \nin solving general recursive equations on domains. He applies a similar technique as Cartwright, inspired \nby the work of Freyd [20] on algebraically com\u00adpact categories, but notices that the coincidence of the \ntwo bounds of the limit interval is a consequence of a so-called minimal invariant property, corresponding \nto the fact that the identity is the limit of the projections. Our proof of theorem 2 is based on this \nvery idea. Dami [14, 13] uses a notion of labelled reduction, inspired by the calculi by L\u00b4evy [30], \nHyland [28], and Wadsworth [42]. The disadvantage of instrumenting the semantics this way is that it \nmodi.es the properties of the initial calculus. Abadi, Pierce and Plotkin[1] realized that the projections \ncan be de\u00ad .ned in some well-chosen syntactic calculi, and use this idea to de.ne a faithful semantics \nof types. This idea of denotable projections appears to be fruitful. It was taken up success\u00adfully by \nSmith, Mason, and Talcott [32, 37], and Birkedal and Harper [6] to transfer approximation techniques \nfrom denotational semantics to operational semantics. In the works of Appel and McAllester [5] and of \nDami [14, 13], the semantic typing .8 does not satisfy the .xpoint property (.8 = F(.8)), but only a \npost-.xpoint property (.8 .F(.8)) corresponding to soundness. The semantic typing is de.ned as the greatest \nlower bound .8 = inf(.n) of a decreasing sequence of semantic candidates .n de.ned inductively. The advantage \nof this approach is that it is eas\u00adier to de.ne .8. But this semantic typing .8 is a priori not canonical: \nit may depend on the way the sequence (.n) is de.ned. Consequently, if one wants to prove a given prop\u00aderty \non types, one has to work on the sequence .n, instead of on its limit .8. Orthogonality, Continuity The \nnotion of polarities [18] was introduced by Birkho. [7]. The notion of closure by orthogonality appeared \nrecently in proof theory, independently in Krivine-style realizability [16] and in Girard s Ludics [23]. \nPitts [35] uses a similar notion of closure to express logical relations in operational semantics. But \nhis typed framework remains to be connected to the untyped framework favored by proof theoreticians. \nThe notion of continuity can be extended from topology to sets X equipped with a closure operator c which \nhere is simply a function from P(X) to P(X), without any other assumption: f : X nY is continuous if \nc( f -1(B)) .f -1(c(B)) for all B .Y [38, 39]. In the case of closure operators as they are de.ned in \nsection 2, this de.nition is equivalent to our de.nition of continuity (section 4.2). 11 Future Work \nThis article is only a .rst step in a wider program. We thought it was important to start with the elementary \ncase of types interpreted as set of terms (that is, unary relations on terms). The next step will be \nto study PER models and logical relations [2, 4, 9, 10, 35, 36] in the same way. We assume that the \ncalculus is extensional, and therefore has no side-e.ect. In particular, some of our typing rules are \nnot sound [17] in presence of references. It will be interesting to see what happen in a calculus with \nside-e.ect. A starting point may be di.erent work on reasoning about e.ects [25, 36, 40, 41]. 12 References \n[1] M. Abadi, B. Pierce, and G. Plotkin. Faithful ideal models for recursive polymorphic types. International \nJournal of Foundations of Computer Science, 2(1):1 21, Mar. 1991. Summary in Fourth Annual Symposium \non Logic in Computer Science, June, 1989. [2] M. Abadi and G. Plotkin. A per model of polymorphism and \nrecursive types. In J. Mitchell, editor, 5th Annual IEEE Symposium on Logic in Computer Science, pages \n355 365. IEEE Computer Society Press, 1990. [3] S. Abramsky and A. Jung. Domain theory. In S. Abram\u00adsky, \nD. M. Gabbay, and T. S. E. Maibaum, editors, Handbook of Logic in Computer Science, volume 3, pages 1 \n168. Clarendon Press, 1994. [4] R. Amadio. Recursion over realizability structures. In\u00adformation and \nComputation, 91:55 85, 1991. [5] A. W. Appel and D. McAllester. An indexed model of recursive types for \nfoundational proof-carrying code. ACM Transactions on Programming Languages and Systems (TOPLAS), 23(5):657 \n683, 2001. [6] L. Birkedal and R. Harper. Constructing interpreta\u00adtions of recursives types in an operational \nsetting. In\u00adformation and Computation, 155:3 63, 1999. [7] G. Birkho.. Lattice theory, volume 25 of Colloquium \nPublications. American Mathematical Society, 1940. [8] M. Brandt and F. Henglein. Coinductive axiomatization \nof recursive type equality and subtyping. In R. Hindley, editor, Proc. 3d Int l Conf. on Typed Lambda \nCalculi and Applications (TLCA), Nancy, France, April 2-4, 1997, volume 1210 of Lecture Notes in Computer \nSci\u00adence (LNCS), pages 63 81. Springer-Verlag, April 1997. [9] K. Bruce and J. Mitchell. PER models of \nsubtyping, re\u00adcursive types and higher-order polymorphism. In Proc. 19th ACM Symp. on Principles of Programming, \npages 316 327, 1992. [10] F. Cardone. Relational semantics for recursive types and bounded quanti.cation. \nIn Proceedings of the Sixteenth International Colloquium on Automata, Lan\u00adguages, and Programming, volume \n372 of Lecture Notes in Computer Science, pages 164 178, Stresa, Italy, July 1989. Springer-Verlag. [11] \nR. Cartwright. Types as intervals. In Proceedings of the 12th ACM SIGACT-SIGPLAN symposium on Prin\u00adciples \nof programming languages, pages 22 36. ACM Press, 1985. [12] J. Chroboczek. Subtyping recursive games. \nIn Pro\u00adceedings of the Fifth International Conference on Typed Lambda Calculi and Applications (TLCA \n01)., Krak\u00b4ow, Poland, May 2001. [13] L. Dami. Labelled reductions, runtime errors and op\u00aderational subsumption. \nIn P. Degano, R. Gorrieri, and A. Marchetti-Spaccamela, editors, ICALP, volume 1256 of Lecture Notes \nin Computer Science, pages 782 793. Springer, 1997. [14] L. Dami. Operational subsumption, an ideal model \nof subtyping. In A. D. Gordon, A. M. Pitts, and C. Tal\u00adcott, editors, HOOTS II Second Workshop on Higher-Order \nOperational Techniques in Semantics, volume 10 of Electronic Notes in Theoretical Computer Science. Elsevier \nScience Publishers, 2000. [15] F. Damm. Subtyping with union types, intersection types and recursive \ntypes II. Research Report 2259, INRIA Rennes, May 1994. [16] V. Danos and J.-L. Krivine. Disjunctive \ntautologies and synchronisation schemes. In Computer Science Logic 00, volume 1862 of Lecture Notes in \nComputer Science, pages 292 301. Springer, 2000. [17] R. Davies and F. Pfenning. Intersection types and \ncom\u00adputational e.ects. In ICFP 00 [29], pages 198 208. [18] M. Ern\u00b4e, J. Koslowski, A. Melton, and G. \nE. Strecker. A primer on Galois connections. In A. R. Todd, edi\u00adtor, Papers on general topology and applications \n(Madi\u00adson, WI, 1991), volume 704 of Annals of the New York Academy of Sciences, pages 103 125, New York, \n1993. New York Acad. Sci. [19] M. P. Fiore. A coinduction principle for recursive data types based on \nbisimulation. Information and Compu\u00adtation, 127(2):186 198, 1996. [20] P. J. Freyd. Algebraically complete \ncategories. In A. Carboni, M. C. Pedicchio, and G. Rosolini, editors, Proceedings of the 1990 Como Category \nTheory Con\u00adference, volume 1488 of Lecture Notes in Mathematics, pages 95 104. Springer Verlag, 1991. \n[21] A. Frisch, G. Castagna, and V. Benzaken. Semantic subtyping. In 17th IEEE Symposium on Logic in \nCom\u00adputer Science, pages 137 146. IEEE Computer Society Press, 2002. [22] V. Gapeyev, M. Levin, and B. \nPierce. Recursive sub\u00adtyping revealed. In ICFP 00 [29]. To appear in Journal of Functional Programming. \n[23] J.-Y. Girard. Locus solum: From the rules of logic to the logic of rules. Mathematical Structures \nin Computer Science, 11(3):301 506, June 2001. [24] A. D. Gordon and A. M. Pitts, editors. Higher Or\u00adder \nOperational Techniques in Semantics. Publications of the Newton Institute. Cambridge University Press, \n1998. [25] J. Goubault-Larrecq, S. Lasota, and D. Nowak. Log\u00adical relations for monadic types. In Proceedings \nof the 11th Annual Conference of the European Associa\u00adtion for Computer Science Logic (CSL 02), volume \n2471 of Lecture Notes in Computer Science, pages 553 568. Springer-Verlag, Sept. 2002. [26] H. Hosoya \nand B. C. Pierce. XDuce: A statically typed XML processing language. ACM Transactions on In\u00adternet Technology, \n2002. Submitted for publication. [27] H. Hosoya, J. Vouillon, and B. C. Pierce. Regular ex\u00adpression types \nfor XML. ACM Transactions on Pro\u00adgramming Languages and Systems (TOPLAS). To ap\u00adpear; short version in \nICFP 2000. [28] J. M. E. Hyland. A syntactic characterization of the equality in some models of the .-calculus. \nJournal of the London Mathematical Society, 12(2):361 370, 1976. [29] Proceedings of the the Fifth ACM \nSIGPLAN In\u00adternational Conference on Functional Programming (ICFP 00), Montr\u00b4eal, Canada, Sept. 2000. \nACM Press. [30] J.-J. L\u00b4evy. An algebraic interpretation of the lambda beta K-calculus; and an application \nof a la\u00adbelled lambda-calculus. Theoretical Computer Science, 2(1):97 114, June 1976. [31] D. MacQueen, \nG. Plotkin, and R. Sethi. An ideal model for recursive polymorphic types. Information and Con\u00adtrol, 71(1-2):95 \n130, 1986. [32] I. A. Mason, S. F. Smith, and C. L. Talcott. From operational semantics to domain theory. \nInformation and Computation, 128(1):26 47, 1996. [33] B. C. Pierce. Programming with intersection types, \nunion types, and polymorphism. Technical Report CMU-CS-91-106, Carnegie Mellon University, Feb. 1991. \n[34] A. M. Pitts. Relational properties of domains. Infor\u00admation and Computation, 127:66 90, 1996. [35] \nA. M. Pitts. Parametric polymorphism and operational equivalence. Mathematical Structures in computer \nSci\u00adence, 10:321 359, 2000. [36] A. M. Pitts and I. D. B. Stark. Operational reasoning for functions \nwith local state. In Gordon and Pitts [24], pages 227 273. [37] S. F. Smith. The coverage of operational \nsemantics. In Gordon and Pitts [24], pages 307 346. [38] B. M. R. Stadler and P. F. Stadler. Basic properties \nof closure spaces, 2002. Supplemental material for [39]. [39] B. M. R. Stadler and P. F. Stadler. Generalized \ntopo\u00adlogical spaces in evolutionary theory and combinato\u00adrial chemistry. J. Chem. Inf. Comput. Sci., \n42:577 585, 2002. Proceedings MCC 2001, Dubrovnik. [40] I. Stark. Names, equations, relations: practical \nways to reason about new. Fundamenta Informaticae, 33(4):369 396, 1998. [41] C. Talcott. Reasoning about \nfunctions with e.ects. In Gordon and Pitts [24], pages 347 390. [42] C. P. Wadsworth. The relation between \ncomputational and denotational properties for Scott s D8-models of the lambda-calculus. SIAM Journal \non Computing, 5(3):488 521, Sept. 1976.    \n\t\t\t", "proc_id": "964001", "abstract": "We present a generalization of the ideal model for recursive polymorphic types. Types are defined as sets of terms instead of sets of elements of a semantic domain. Our proof of the existence of types (computed by fixpoint of a typing operator) does not rely on metric properties, but on the fact that the identity is the limit of a sequence of projection terms. This establishes a connection with the work of Pitts on relational properties of domains. This also suggests that ideals are better understood as closed sets of terms defined by orthogonality with respect to a set of contexts.", "authors": [{"name": "Jerome Vouillon", "author_profile_id": "81100141421", "affiliation": "CNRS and Denis Diderot University", "person_id": "PP18000519", "email_address": "", "orcid_id": ""}, {"name": "Paul-Andr&#233; Melli&#232;s", "author_profile_id": "81100411479", "affiliation": "CNRS and Denis Diderot University", "person_id": "P653514", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/964001.964006", "year": "2004", "article_id": "964006", "conference": "POPL", "title": "Semantic types: a fresh look at the ideal model for types", "url": "http://dl.acm.org/citation.cfm?id=964006"}