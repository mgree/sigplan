{"article_publication_date": "01-01-2004", "fulltext": "\n Extensional Normalisation and Type-Directed Partial Evaluation for Typed Lambda Calculus with Sums \nVincent Balat Roberto Di Cosmo Marcelo Fiore* PPS -Universit \u00b4e Paris 7 PPS -Universit \u00b4e Paris 7 Computer \nLaboratory and University of Cambridge INRIA-Roquencourt Abstract We present a notion of .-long \u00df-normal \nterm for the typed lambda calculus with sums and prove, using Grothendieck logical relations, that every \nterm is equivalent to one in normal form. Based on this development we give the .rst type-directed partial \nevaluator that constructs normal forms of terms in this calculus. Categories and Subject Descriptors: \nF.3.2 [Logics and Mean\u00adings of Programs]: Semantics of Programming Languages partial evaluation; F.4.1 \n[Mathematical Logic and Formal Lan\u00adguages]: Mathematical Logic lambda calculus and related sys\u00adtems; \nD.3.1 [Programming Languages]: Formal De.nitions and Theory semantics General Terms: Languages, Theory, \nAlgorithms. Keywords: Typed lambda calculus, Strong sums, Grothendieck logical relations, Normalisation, \nType-Directed Partial Evaluation. 1 Introduction Sum types and their associated case expressions are \nan essential feature of any programming language. Taking into account the full range of commuting conversions \nin performing program optimisa\u00adtions and partial evaluation in their presence is a dif.cult, but im\u00adportant, \ntask. For example, consider the Objective Caml sum type type ( a, b) sum = Left of a | Right of b and \nthe program funf-> fung-> funz-> funx-> match ( match x with Left x1 -> Left z | Right x2 -> Right ( \ng z ) ) (1) with Left y1->f(gy1) | Right y2 -> f y2 *Research supported by an EPSRC Advanced Research \nFel\u00adlowship. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. POPL \n04 January 14 16, 2004, Venice, Italy. Copyright 2004 ACM 1-58113-729-X/04/0001 ...$5.00 of type ( a \n-> b) -> ( c -> a) -> c -> ( d, e) sum -> b This is a typical, hard to read, example of what automatically \ngen\u00aderated code looks like. Using commuting conversions, it can be transformed into the program fun f \n-> fun g -> fun z -> fun x -> match x with Left x1 -> ( match (Left z) with Left y1->f(gy1) | Right y2 \n-> f( y2 ) ) | Right x2 -> ( match Right( g z ) with Left y1->f(gy1) | Right y2 -> f( y2 ) ) which can \nbe then optimised into the program fun f -> fun g -> fun z -> fun x -> match x with Left x1->f(gz) | \nRight x2 -> f( g z ) that, by extensionality, can be transformed into the more readable and ef.cient \nfunf-> fung-> funz-> funx-> (2) f( g z ) The commuting conversions associated to case expressions are \nderivable from the (strong) sum extensionality axiom; which iden\u00adti.es the programs match e with Left \nx1 -> t[Left x1/x] and t[e/x] | Right x2 -> t[Right x2/x] Sum types satisfying this axiom are sometimes \nreferred to as strong or categorical sums. In this paper we consider sum types in the most basic foundational \ntype theory for functional programming: the typed lambda calculus with sums. In particular, we tackle \nthe problem of de.ning and computing normal forms in it; so that, for instance, the passage from (1) \nto (2) can be done automatically. Besides the interest in the typed lambda calculus with sums from the \nprogramming-language viewpoint, there is also a type theoretic one, and the study of sum types in this \nsetting has proved challenging; see [17, 13, 16, 1]. The theory of weak sums, either without the extensionality \nax\u00adiom (see [11]) or with the extensionality axiom restricted to the case t = x (see [10]), is well understood. \nHowever, there is as yet no known con.uent and strongly normalising reduction system for strong sums. \nThus, we consider below normalisation within the whole calculus in the spirit of Normalisation by Evaluation \n(NBE) and Type-Directed Partial Evaluation (TDPE). NBE is a normalisation technique introduced by Berger \nand Schwichtenberg [4] for the simply typed lambda calculus as an in\u00adverse to the evaluation function, \nmapping a semantic value into a syntactic one in normal form. Since then, NBE has been the sub\u00adject of \ninvestigation in many domains: logic, type theory, category theory, partial evaluation (see, e.g., [7]). \nPartial evaluation is a program transformation technique used to specialise functions. TDPE is a partial \nevaluator for functional lan\u00adguages invented by Danvy [5]. It is based on the same principle as NBE; \nit constructs code of compiled programs, acting as a de\u00adcompiler. An extension of NBE to the typed lambda \ncalculus with binary sums has been proposed by Altenkirch, Dybjer, Hofmann, and Scott [1]. However, normalising \ncalculi with strong sums in the style of TDPE was an open problem; to which this paper offers a solution. \nFor the typed lambda calculus, Fiore [14] showed that we can ex\u00adtract the NBE algorithm as an intentional \nversion of an extensional\u00adnormalisation result (stating that every term equals one in normal form). Here, \nin the context of the lambda calculus with sums, we start by following this analysis and present a notion \nof normal form with respect to which we establish an extensional-normalisation re\u00adsult. Afterwards, we \nproceed in a different direction and draw in\u00adsight from the proof of this result to develop a partial \nevaluator for the typed lambda calculus with binary sums that constructs normal forms; the extension \nto incorporate the empty type does not present much dif.culty. The partial evaluator, written in Objective \nCaml, can be downloaded from the web. Organisation of the paper. In Section 2, we recall the syntax and \nsemantics of the typed lambda calculus with sums. In Section 3, after recalling the construction of bicartesian \nclosed categories of Grothendieck relations, we present a basic lemma that provides both guidelines for \nde.ning the notion of normal term given in Section 4, and the proof-skeleton for establishing the extensional\u00adnormalisation \nresult of Section 5. In Section 6, we present the solu\u00adtion to normalisation via TDPE for the simply \ntyped lambda calcu\u00adlus with binary sums. Concluding remarks are offered in Section 7.  2 Typed lambda \ncalculus with sums We recall the syntax and categorical semantics of the simply typed lambda calculus \nwith (empty and binary) products and (empty and binary) sums. For details see [20]. 2.1 Syntax The set \nof types has a (countable) set of base types and two type constants 1 and 0, the unit and empty type, \nand is closed under the formation of product, function, and sum type constructors. For\u00admally, types are \nde.ned by the following grammar: t ::= . (Base types) | 1 (Unit type) | t1 \u00d7 t2 (Product types) | t1 \n. t2 (Function types) | 0 (Empty type) | t1 + t2 (Sum types) The raw terms of the calculus are de.ned \nby the following gram\u00admar: t ::= x (Variables) | () (Unit) | (t1,t2) (Pairing) | p1(t) (First projection) \n| p2(t) (Second projection) | .x : t.t (Abstraction) | t1(t2) (Application) | .t (Absurd) t1,t2 | .(t) \n(First injection) 1 t1,t2 | .(t) (Second injection) 2 | d(t,x1.t1,x2.t2) (Discriminator) where x ranges \nover (a countable set of) variables. The unit, pairing, and abstraction are respectively the term con\u00adstructors \nfor the unit, product, and function types; whilst the pro\u00adjections and application are respectively the \nterm destructors for the product and function types. The term constructors for sum types are given by \nthe injections; whilst the absurd and discriminator are respectively the term de\u00adstructors for empty \nand sum types. In particular, discriminator terms permit de.nitions by cases. The abstraction and discriminator \nare binding operators; .x : t.t binds the free occurrences of x in t, and d(t,x1.t1,x2.t2) binds the \nfree occurrences of xi in ti (i = 1,2). The notions of free and bound variables are standard, and terms \nare identi.ed up to alpha conversion Notice that we have adopted a non-standard (proof irrelevant) ver\u00adsion \nof absurd terms as .t, rather than the standard one of the form .t(t). This is important in the treatment \nof normal forms. As usual we consider typing contexts as lists of type declarations for distinct variables, \nand say that a term t has type t in the context G if the judgement G f t: t is derivable from the rules \nof Figure 1. Finally, we impose the standard notion of equality on terms, includ\u00ading the sum extensionality \naxiom, as detailed in Figure 2.  2.2 Semantics Bicartesian closed categories (BiCCCs) are categories \nwith .nite products (1, \u00d7), exponentials (.), and .nite coproducts (0, +). The typed lambda calculus \nwith sums is the internal language of BiCCCs and as such has sound and complete interpretations in them. \nWith respect to an interpretation I of base types in a BiCCC S, we write I [[t]] for the interpretation \nof the type t in\u00adduced by the bicartesian closed structure. That is, I [[.]] = I (.) (. a base type) \nI [[1]] = 1 I [[t\u00d7 t']] = I [[t]] \u00d7 I [[t']] I [[t . t']] = I [[t]] . I [[t']] ' G, x : t, G fx : t \nG fti : ti (i = 1,2) G ft : t1 \u00d7t2 (i = 1,2) G f(): 1 G f(t1,t2): t1 \u00d7t2 G fpi(t): ti G, x : t1 ft : \ntG ft : t1 . tG ft1 : t1 G f.x : t1.t : t1 . tG ft(t1): t G ft : ti G ft : t1 + t2 G, xi : ti fti : t \n(i = 1,2) G ft : 0 (i = 1,2) t1,t2 G f.t : tG f.i (t): t1 + t2 G fd(t,x1.t1,x2.t2): t Figure 1. Typing \nrules. ' G ft : tG ft = t : tG ft1 = t2 : tG ft2 = t3 : t ' G ft = t : tG ft = t : tG ft1 = t3 : t G \nft : 1 G ft = (): 1 G ft1 : t1 G ft2 : t2 G ft : t1 \u00d7t2 (i = 1,2) G fpi(t1,t2)= ti : ti G ft = (p1(t),p2(t)): \nt1 \u00d7t2 G,x : t1 ft : tG ft1 : t1 G ft : t1 . t (x .FV(t)) G f(.x : t1.t)(t1)= t[t1/x] : tG ft = .x : \nt1.t(x): t1 . t ' ' G ft : t1 . tG ft1 = t : t1 G,x : t1 ft = t : t 1 '' G ft(t1)= t(t1): tG f.x : \nt1.t = .x : t1.t : t1 . t G f.0 : 0 G ft : t G f.t = t : t ' G ft : tj G,xi : ti fti : t (i = 1,2) G \nft : t1 + t2 G,x : t1 + t2 ft : t (j = 1,2) ''' G fd(.j(t),x1.t1,x2.t2)= tj[t/xj] : tG fd(t,x1.t [.1(x1)/x],x2.t \n[.2(x2)/x])= t [t/x] : t Figure 2. Equational theory of the typed lambda calculus with sums. I [[0]] \n= 0 '' I [[t + t ]] = I [[t]] + I [[t ]] This interpretation extends to contexts in the usual manner: \nI [[x1 : t1,...,xn : tn]] = I [[t1]] \u00d7... \u00d7I [[tn]] We write I [[G ft : t]] for the morphism I [[G]] \n. I [[t]] in S inter\u00adpreting the judgement G ft : t. Syntactic BiCCC. The syntactic BiCCC induced by \nthe type the\u00adory has objects given by types and morphisms t1 . t2 given by equivalence classes [x : t1 \nft : t2] of derivable judgements under '' the equivalence identifying (x : t1 ft : t2) and (x : t1 ft \n: t2) ' iff the judgement x : t1 ft = t [x/x '] : t2 is derivable in the equa\u00adtional theory. Composition \nis by substitution '' ' [x : t2 ft : t3] .[x : t1 ft : t2]=[x : t1 ft [t/x '] : t3] with identities given \nby [x : t fx : t].  3 BiCCCs of Grothendieck relations The class of categorical models of the typed \nlambda calculus with sums needed for establishing the extensional normalisation result is that given \nby BiCCCs of Grothendieck relations [16]. These are categories de.ned over a site, a small category C \nwith a Grothendieck topology K, equipped with an arity functor s : C . S into a BiCCC. They consist of \nobjects (A,R) where A is an object of S and R is a Grothendieck relation of arity s, and have morphisms \n(A,R) . (A ' ,R ' ) given by morphisms A . A ' in S that preserve the relations. We recall the formal \nde.nitions. DEFINITION 3.1. Given a small category C,a (basis for) a Grothendieck topology K on C, is \ngiven by associating to each ob\u00adject a of C a collection K(a) of covers of a (a family of morphisms in \nC with codomain a), satisfying the following conditions: (Identity) For every a .| C |, K(a) contains \nthe family consisting of the identity morphism on a. (Stability) For every {fi : ai . a}i.I . K(a), and \nmorphism . : b . a, there exists a family {fj ' : bi . b}j.J . K(b) such that every .. fj ' : bj . a \nfactors through some fi (i.e., for every j . J there exist i . I and .ij : bj . ai such that .. fj ' \n= fi . .ij). (Transitivity) For every {fi : ai . a}i.I . K(a), and for ev\u00adery {.ij}j.Ji . K(ai)(i. I), \nthe family {fi ..ij}i.I,j.Ji . K(a). A small category together with a Grothendieck topology on it is \ncalled a site. DEFINITION 3.2. For a site (C,K) and a functor s : C . S,a (C,K)-Grothendieck relation \nR of arity s over A . | S | is a family { R(c) . S(s(c),A) }c.|C| with the following two properties. \n(Monotonicity) For every . : c ' . c in C, and every x: s(c) . A in S,if x . R(c), then x.s(.) . R(c \n' ). (Local character) For every cover { fi : ci . c }i.I . K(c) and for every x : s(c) . A in S,if x. \ns(fi) . R(ci) for all i . I, then x . R(c). DEFINITION 3.3. For a site (C,K) and a functor s : C . S, \nthe category of Grothendieck relations G(C,K,s) is de.ned as fol\u00adlows: objects are pairs (A,R) consisting \nof an object A in S and a (C,K)-Grothendieck relation R of arity s over A; morphisms (A,R) . (A ' ,R \n' ) are morphisms f : A . A ' in S such that for all objects c in C and morphisms x : s(c) . A in R(c), \nthe composite f. x is in R ' (c). We have the following important result; see [16] for details. PROPOSITION \n3.4. For a site (C,K) and a functor s : C . S into a bicartesian closed category, the category of Grothendieck \nrelations G(C,K,s) is bicartesian closed and the forgetful functor G(C,K,s) . S preserves the bicartesian \nclosed structure. The FUNDAMENTAL LEMMA OF GROTHENDIECK LOGICAL RE-LATIONS follows as a corollary. LEMMA \n3.5 (FUNDAMENTAL LEMMA). For a family of Grothendieck relations ((I [[.]],R.)). in G(C,K,s : C . S) in\u00addexed \nby base types, let ((I [[t]],Rt))t (resp. ((I [[G]],RG ))G ) be the family of Grothendieck relations \nindexed by types (resp. contexts) induced by the bicartesian closed structure of G(C,K,s). Then, the \ninterpretation of terms I [[G f t : t]] : I [[G]] . I [[t]] in S are mor\u00adphisms (I [[G]],RG ) . (I [[t]],Rt) \nin G(C,K,s). 3.1 Basic lemma Following the analysis of [14] we give a BASIC LEMMA that pro\u00advides the \nproof-skeleton for both the de.nability result of [16] and the extensional normalisation result (Theorem \n5.1) of this paper. LEMMA 3.6 (BASIC LEMMA). Consider a site (C,K), a functor s : C . S into a BiCCC, \nand an interpretation I of base types in S. Let ((I [[t]],Lt))t and ((I [[t]],Ut))t be two families of \nGrothendieck relations in G(C,K,s) indexed by types such that L0 = . U1 = . Ls\u00d7t . Ls . Lt Us . Ut . \nUs\u00d7t Ls+t . Ls . Lt Us . Ut . Us+t Ls. t . Us . Lt Ls . Ut . Us. t For a family of Grothendieck relations \n((I [[.]],R.)). in G(C,K,s) indexed by base types, let ((I [[t]],Rt))t be the family of Grothendieck \nrelations indexed by types induced by the bicartesian closed structure of G(C,K,s). If L. . R. . U. for \nall base types ., then 1. Lt . Rt . Ut for all types t, and thus 2. for all terms G f t : t (G = x1 \n: t1,...,xn : tn) and tuples ai : s(c) . I [[ti]] in Lti (c)(1 = i = n,c . | C |), we have that I [[G \nf t : t]] .(a1,...,an) : s(c) . I [[t]] is in Ut(c).  The .rst part of the lemma follows by induction \non types using the closure properties of the hypothesis and the functoriality of the categorical type \nconstructors; the second part is a consequence of the .rst and the FUNDAMENTAL LEMMA.  4 Normal forms \nWe present a notion of .-long \u00df-normal form for the typed lambda calculus with sums. The overall de.nition, \nwhich is given in Fig\u00adure 3, depends on four mutual inductively de.ned entailment sys\u00adtems: fM0 (pure \nneutral terms), fM (neutral terms), fN0 (pure normal terms), and fN (normal terms). The pure neutral \nterms are essentially given as in the typed lambda calculus; whilst the neu\u00adtral terms are obtained from \nthese by closing under discriminators. The pure normal terms are essentially given as in the typed lambda \ncalculus with the addition of the sum injections, and normal terms are obtained by closing under discriminators \nwith respect to pure neutral terms. The unique neutral and normal term in an inconsis\u00adtent context (viz., \na context G in which the judgement G f.0 : 0 is derivable) of type t is .t. The de.nition of normal forms \nhas been designed guided by that of [1] (of which the ones here are syntactic counterparts) and by making \nsure that the interpretations of neutral and normal terms provide Grothendieck relations satisfying the \nhypothesis of the BA-SIC LEMMA (see Section 3). Note that there are syntactically different, but semantically \nequiva\u00adlent normal forms; like the following ones: .g : . . .1 + .2..h : . . .3 + .4..x : .. (3) d( gx, \nx1..1() ,x2.d(hx,y1..2(),y2..1())) and .g : . . .1 + .2..h : . . .3 + .4..x : .. (4) d( hx, y1.d(gx,x1..1(),x2..2()) \n,y2..1() ) which differ only in the order in which the case analysis is per\u00adformed. This situation is \nformalised by the relation in the de.ni\u00adtion below; on which the side conditions (B) and (C) of Figure \n3, allowing the closure under discriminators of normal terms, depend. DEFINITION 4.1. We let be the \nleast congruence such that d( M, x.d(M1,x1.N1,x2.N2) ,y.N) d( M1 ,x1.d(M,x.N1,y.N) ,x2.d(M,x.N2,y.N)) \nd( M, y.N, x.d(M1,x1.N1,x2.N2)) d( M1 ,x1.d(M,y.N,x.N1) ,x2.d(M,y.N,x.N2)) where x . FV(M1) and xi . \nFV(M)(i = 1,2), and G,x :t,G 'fM0 x :t G fM0 M :t1 \u00d7t2 (i =1,2) G fM0 pi(M):ti G fM0 M :t1 . tG fN0 \nN :t1 G fM0 M(N):t G fM0 M :t G fM M :t (G inconsistent) G fM .t :t G fM0 M :t1 +t2 G, xi :ti fM Mi \n:t (i =1,2) G fM d(M,x1.M1,x2.M2):t \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 \nG fM0 M :. (. a base type) G fN0 M :. G fN0 Ni :ti (i =1,2) G fN0 ():1 G fN0 (N1,N2):t1 \u00d7t2 G fN0 N :ti \n(i =1,2) t1,t2 .(N):t1 +t2G fN0 i G fN0 N :t G fN N :t G, x :t1 fN N :t x .FV(C)for all C .Guards(N)(A) \nG fN0 .x :t1.N :t1 . t(G inconsistent) G fN .t :t S G fM0 M :t1 +t2 G, xi :ti fN Ni :t (i =1,2) i=1,2 \nGuards( M C for all C .xi.Ni)(B) G fN d(M,x1.N1,x2.N2):tN1 N2 whenever x1 .FV(N1)and x2 .FV(N2)(C) \u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7\u00b7 \n. S . { M } .i=1,2 Guards(xi.Ni) ,if N =d(M,x1.N1,x2.N2) def Guards(N)= . 0/ , otherwise def Guards(xi.Ni)=C \n.Guards(Ni)| xi .FV(C) Figure 3. Neutral and normal terms. (The context is assumed consistent unless \nstated otherwise.) N N ' d(M,x.N,y.N ' ) N where x . FV(N)and y . FV(N ' ). If desired, unique representatives \nfor normal terms can be chosen. Indeed, in [1] this is done by considering a generalised form of discriminator \nconstruct allowing simultaneous case analysis. Al\u00adternatively, one could proceed by both .xing a canonical \nnotation for binders and a linear order on pure neutral terms to be respected in nested discriminators. \nThis, we believe, yields unique normal forms. For instance, adopting the canonical notation for binders \nprovided by de Bruijn levels, the normal form for the terms (3) and (4) under the linear order in which \n0(2)precedes 1(2)is .0 :. . .1 +.2..1 :. . .3 +.4..2 :.. d(0(2),3..1() ,3.d(1(2),4..2(),4..1())) Examples. \nWe conclude the section with examples of terms and their normal forms that will help to elucidate the \nnotion. To grasp the role of the side conditions in Figure 3 note that: con\u00addition (A).xes the relative \nposition of abstractions and discrimina\u00adtors; condition (B)forbids dead branches (that is, when the same \ncase analysis is performed more than once, and hence becomes re\u00addundant); and condition (C)forbids the \ntwo branches of a discrimi\u00adnator to be the same (as in such case the discriminator is redundant). EXAMPLE \n4.2. 1. The identity term .x :..x of type . . . is a normal term. 2. The identity term .x :.1 +.2.x of \ntype (.1 +.2). (.1 +.2) is not a normal term; its normal form is .x :.1 +.2.d(x,x1..1(x1),x2..2(x2)). \n3. The identity term .x :(.1 +.2)\u00d7 (. ' +. ' ).x of type 12 (.1 +.2)\u00d7 (. ' +. ' ). (.1 +.2)\u00d7 (. ' +. \n' ) has two 1212 equivalent normal terms: .x :(.1 +.2)\u00d7 (. ' +. ' ). 12d(p1(x), x1.d(p2(x), '' x1.(.1(x1),.1(x \n)) , 1 '' x2.(.1(x1),.2(x )) ) 2x2.d(p2(x), '' x1.(.2(x2),.1(x )) , 1 '' x2.(.2(x2),.2(x )) ) 2 and .x \n:(.1 +.2)\u00d7 (. ' +. ' ). 12d(p2(x), ' x1.d(p1(x), ' x1.(.1(x1),.1(x )) , 1 ' x2.(.2(x2),.1(x )) ) 1 ' \nx2.d(p1(x), ' x1.(.1(x1),.2(x )) , 2 ' x2.(.2(x2),.2(x )) ) 2 4. The curried identity term .x :.1 +.2..y \n:. ' +.2' .(x,y) of 1 type (.1 +.2). (. ' +. ' ). (.1 +.2)\u00d7(. ' +. ' )has as 1212 unique normal form \nthe term .x :.1 +.2. d(x, x1..y :. ' +.2' . 1 d(y, y1.(.1(x1),.1(y1)) , y2.(.1(x1),.2(y2)) ) x2..y :. \n' +.2' . 1 d(y, y1.(.2(x2),.1(y1)) , y2.(.2(x2),.2(y2)) ) EXAMPLE 4.3. Let A =.1(.1()), B =.1(.2()), \nC =.2(.1()), and D =.2(.2())of type (1+1)+(1+1). 1. The term .x :.1 +.2.d(d(x,x1.A,x2.D),y1..2(y1),y2..1(y2)) \nis not a normal term because x :.1 +.2 fM0 d(x,x1.A,x2.D):(1+1)+(1+1) Its normal form is the term .x \n:.1 +.2.d(x,x1.C,x2.B) 2. The term .f :. . (.1 +.2)..x :...g :. . (. ' +. ' )..y :.. 12d(gy, x1.d(fx,y1.A,y2.B),x2.d(gx,z1.C,z2.D)) \nis not a normal term because condition (A)is not satis.ed. Its normal form is the term .f :. . (.1 +.2)..x \n:.. d(fx , y1..g :. . (. ' +. ' ). 12 d(gx , z1..y :..d(gy,x1.A,x2.C), z2..y :..d(gy,x1.A,x2.D)), y2..g \n:. . (. ' +. ' ). 12 d(gx , z1..y :..d(gy,x1.B,x2.C), z2..y :..d(gy,x1.B,x2.D))) 3. The term .f :((. \n. .1 +.2). (. . .3 +.4). . . (1+1)) . .5 +.6. d(f(.g :. . .1 +.2..h :. . .3 +.4..x :.. d(gx , x1..1() \n, x2.d(hx, y1..2() ,y2..1() ))), z1.A , z2.d(f(.g :. . .1 +.2..h :. . .3 +.4..x :.. d(hx , y1.d(gx, \nx1..1() ,x2..2() ), y2..1() )), z1.B , z2.C )) does not satis.es condition (B)and so is not a normal \nterm. Its normal forms are .f:((.. .1 + .2) . (.. .3 + .4) . .. (1+ 1)) . .5 + .6. d( f(.g : .. .1 + \n.2..h : .. .3 + .4..x: .. d( gx , x1..1(), x2.d( hx, y1..2() ,y2..1() ))) , z1.A , z2.C ) and .f:((.. \n.1 + .2) . (.. .3 + .4) . .. (1+ 1)) . .5 + .6. d( f(.g : .. .1 + .2..h : .. .3 + .4..x: .. d( hx , y1.d( \ngx, x1..1() ,x2..2() ), y2..1() )) , z1.A , z2.C ) 4. The term .f: .. 0..x: .+ 0.d( x,x1.x1 ,x2... ) \nis not normal, as f: .. 0,x: .+ 0,x1 : . fN x1 : . because the context is inconsistent. The equivalent \nterm .f: .. 0..x: .+ 0.d( x,x1... ,x2... ) is not normal either because condition (C) is not satis.ed. \nThe normal form of these two terms is .f: .. 0..x: .+ 0... EXAMPLE 4.4. The normal form of the term .f: \n.1 . 0..x: .1 + .2..g: .2 . .1..y: .. d( x,x1...1 ,x2.g(x2)) is .f: .1 . 0..x: .1 + .2. d( x,x1..(.2. \n.1). .. .1 ,x2..g: .2 . .1.... .1 )  5 Extensional normalisation Following [14], we establish the following \nextensional\u00adnormalisation result. THEOREM 5.1 (EXTENSIONAL NORMALISATION). For every term of the typed \nlambda calculus with sums G f t: t there exists a normal term G fN N : t such that G f t = N : t is provable \nin the equational theory of the calculus. The proof is along the following lines. We de.ne an appropriate \nsyntactic site (C,K) together with an arity functor I : C . S into a BiCCC canonically induced by a stable \ninterpretation I of base types. (See Section 5.1.)  We establish that the interpretation of neutral \nand normal terms de.ne Grothendieck relations in G(C,K,I ) satisfying the hypothesis of the BASIC LEMMA. \n(See Section 5.2.)  As a direct consequence we have the semantic result that for every term G f t: \ntthere exists a normal term G fN N: tsuch that I [[G f t: t]] = I [[G f N: t]] : I [[G]] . I [[t]] in \nS.  The syntactic result of Theorem 5.1 follows from the semantic one by embedding the syntactic BiCCC \ninduced by the type theory into a BiCCC in which the sums become stable.  5.1 The syntactic site and \nits arity functor The syntactic site. Following [16] in the light of [1], we will use a site of constrained \ncontexts G|.; the intuition is that we consider the context G under the constraints .. DEFINITION 5.2. \nConstrained contexts are de.ned by the follow\u00ading rules G|. ()|() G,x : t|.,x=t x G|.G fM0 M : t1 + t2 \n(i= 1,2)G,x : ti|.,.i(x)=t1+t2 M G|.G f t: t1 + t2 (G inconsistent)(i=1,2) G,x : ti|.,.i(x)=t1+t2 t where \nx. dom(G). DEFINITION 5.3. The category C has objects given by con\u00adstrained contexts and morphisms G \n' |. ' . G|. given by injective renamings . : dom(G) - - dom(G ' ) that preserve typing (i.e. if (x: \nt) . G, then (.(x): t) . G ' ) and constraints (i.e. if t=t t '. ., then t[.]=t t ' [.] . . ' ). DEFINITION \n5.4. The family of covers K(G|.) of a constrained context G|. is de.ned by the following rules: (G inconsistent) \n0/ . K(G|.) { iddom(G) } . K(G|.) { .j }j.J . { .: G ' |. ' . G|. } . K(G|.) ' |. ' { .j }j.J . { .. \n.i : G . G|.}i=1,2 i i where, for i = 1,2, the constrained contexts G ' |. ' are of the form i i ' ' \n' (G ,x : ti|. ' ,.i(x )=t1+t2 t) and the renamings .i are the in\u00ad ii clusions G ' |. ' - - G ' |. ' \n. i i PROPOSITION 5.5. The pair (C,K) is a site. The arity functor. We restrict attention to stable interpretations \nof types; i.e., interpretations I of base types in a BiCCC such that, for all pair of types t1 and t2, \nthe coproduct I [[t1]] + I [[t2]] is stable under pullbacks. For a stable interpretation, we de.ne the \nsemantic interpretation of the constrained context G|. as a subobject of the semantic interpre\u00adtation \nof the context G. DEFINITION 5.6. With respect to a stable interpretation I of base types in a BiCCC, \nwe associate to every constrained context G|. its interpretation I [[G|.]] given by the domain of a monomorphism \nmG|. : I [[G|.]] I [[G]] inductively de.ned as follows. m()|() : 11 is de.ned as id1.  : I [[G|.]] \n\u00d7 I [[t]] I [[G]] \u00d7 I [[t]] is de.ned  mG,x:t|.,x= tx as mG|. \u00d7 idI [[t]]. mG,x:ti|.,.i(x)=t1+t2 t \n: I [[G,x : ti|.,.i(x)=t1+t2 t]] I [[G]] \u00d7 I [[ti]] is de.ned as (mG|. . pi,qi) where the following square \n piI [[G,x : ti|.,.i(x)=t1+t2 t]] I [[G|.]] - mG|. qi I [[G]] I [[ti]] -i I [[Gft:t1+t2]] - I [[t1]] \n+ I [[t2]] is a pullback. By stability, the family pi { I [[G,xi : ti|.,.i(xi)=t1+t2 t]] I [[G|.]] }i=1,2 \n- is a coproduct, and for every '' G|. = (x1 : t1,...,xn : tn|t1 = ' t1,...,tn =' t ) t1 tn n we have \nan equaliser diagram ' (I [[Gfti:t ]])1=i=n mG|.i- - 1n I [[G|.]] I [[G]] I [[t ' ]] \u00d7 ... \u00d7 I [[t ' \n]] ' ' (I [[Gft :t ]])1=i=n i i The de.nition of the arity functor induced by a stable interpretation \nfollows. DEFINITION 5.7. With respect to a stable interpretation I of base types in a BiCCC S, the arity \nfunctor I : C . S is de.ned as fol\u00adlows. def On objects: I (G|.)= I [[G|.]]. On morphisms: for . : G \n' |. ' . G|., we de.ne I (.) as the unique map I [[G ' |. ' ]] . I [[G|.]] such that I [[G|.]] - mG|. \n- I [[G]] = .x.dom(G)I [[G(x)]] I (.) (p.(x))x.dom(G) I [[G ' |. ' ]] - - I [[G ' ]] = .x '.dom(G ' \n)I [[G ' (x ' )]] mG ' |. ' 5.2 Extensional-normalisation result For a stable interpretation I of base \ntypes in a BiCCC S the de.ni\u00adtions Mt(G|.)= { I [[G f M : t]] . mG|. | G fM M : t } Nt(G|.)= { I [[G \nf N : t]] . mG|. | G fN N : t } respectively identify the sets of neutral and normal morphisms in S(I \n[[G|.]],I [[t]]). PROPOSITION 5.8. Let I be a stable interpretation of base types in a BiCCC. For all \ntypes t, (I [[t]],Mt) and (I [[t]],Nt) are Grothendieck relations in G(C,K,I ). THEOREM 5.9. The Grothendieck \nrelations of neutral and normal morphisms satisfy the following closure properties. M0 = . N1 = . Ms\u00d7t \n. Ms . Mt Ns . Nt . Ns\u00d7t Ms+t . Ms . Mt Ns . Nt . Ns+t Ms. t . Ns . Mt Ms . Nt . Ns. t and M. . N. (. \na base type) The proof of the theorem relies on the next two lemmas; whose proofs embody the algorithmic \nidea underlying the normalisation program of Section 6. LEMMA 5.10. 1. For every neutral term G fM M \n: t1 \u00d7 t2 there exist neutral terms G fM M1 : t1 and G fM M2 : t2 such that G f pi(M)= Mi : ti (i = 1,2). \n2. For every neutral term G fM M : t1 . t and normal term G fN N : t1, there exists a neutral term G \nfM M ' : t such that G f M(N)= M ' : t. LEMMA 5.11. 1. For every term G fN1 C: t derivable accord\u00ading \nto the following rules G fN0 N : t (G consistent) G fN1 N : t G fM0 M : t1 + t2 G,xi : ti fN1 Ci : t \n(i = 1,2) (G consistent) G fN1 d(M,x1.C1,x2,C2): t (G inconsistent)G fN1 .t : t there exists a normal \nterm G fN N: t such that G f C = N : t. 2. For every pair of normal terms G fN Ni : ti (i = 1,2), there \nexists a normal term G fN N : t1 \u00d7 t2 such that G f(N1,N2) = N : t1 \u00d7 t2. 3. For every normal term G \nfN N : ti (i . {1,2}), there exists a normal term G fN N ' : t1 + t2 such that G f .i(N)= N ' : t1 + \nt2. 4. For every normal term G,x : t1 fN N1 : t, there exists a nor\u00ad  mal term G fN N : t1 . t such \nthat G f .x : t1.N1 = N : t1 . t. Since for G = (x1 : t1,...,xn : tn) we have that the projection I [[G \nf xi : ti]] (1 = i= n), is a neutral morphism I [[G]] . I [[ti]] in Mti (G|.G ) where .G = (x1 =t1 x1,...,xn \n=tn xn), it follows from Theorem 5.9 and the BASIC LEMMA that the interpretation I [[G f t : t]] = I \n[[G f t : t]] .(I [[G f x1 : t1]],...,I [[G f xn : tn]]) of the term G f t : t is a normal morphism I \n[[G]] . I [[t]] in Nt(G|.G ). Thus we have the following corollary. COROLLARY 5.12. Let I be a stable \ninterpretation of base types in a BiCCC S. For every term G f t: t, there exists a normal term G fN N: \ntsuch that I [[G f t: t]] = I [[G f N: t]] : I [[G]] . I [[t]] in S. Theorem 5.2 is obtained from this \ncorollary by producing a BiCCC embedding T yinto a BiCCC T , . T , of the syntactic BiCCC T mapping sums \nto stable sums, and considering the canonical inter\u00adpretation of types in T .  6 Type-Directed Partial \nEvaluation with sums We show how to build a normalisation algorithm based on Type-Directed Partial Evaluation \nthat puts terms in the normal form of Section 4. In fact, we use a version of TDPE written for the lan\u00adguage \nObjective Caml (see [2]) slightly modi.ed to allow the use of certain powerful control operators. An \ninteresting point of this work is that the optimisations we in\u00adtroduce will be usable in some other cases \nof partial evaluation. Here, however, we are only concerned in normalising functional programs corresponding \nto terms in the typed lambda calculus with binary sums with respect to the equational theory of the calculus. \nIn particular, note that the normalisation of a program may have a dif\u00adferent observational semantics \n(within the programming language that is) than the original program; as, for instance, the evaluation \norder may not be preserved. 6.1 The original TDPE We recall the basic elements of the original TDPE algorithm. \nFor details see [5, 6]. NBE is based on an .-expansion of the term using a two-level lan\u00adguage, which \nin our case is de.ned as follows: t ::= s (Static terms) | d (Dynamic terms) s ::= x | () | pair(t1,t2) \n| p1(t) | p2(t) | .x.t | t1 @ t2 | .1(t) | .2(t) | d(t,x1.t1,x2.t2) d ::= () | pair(t1,t2) | p1(t) | \np2(t) | .x.t | t1 @ t2 | .1(t) | .2(t) | d(t,x1.t1,x2.t2) where x(resp. x) ranges over (a countable set \nof) static (resp. dy\u00adnamic) variables. The s-terms are said to be static and the d-terms to be dynamic. \nIn implementations, dynamic terms are often rep\u00adresented by data structures, whereas static terms are \nvalues of the language itself. The TDPE algorithm without let insertion is presented in Figure 4. It \ninductively de.nes two functions for each type. One, written . , is called reify and the other one, written \n. , is called reflect. The functions . and . are basically two-level .-expansions. To normalise a static \nvalue V of type t, .rst apply the function .t to V, and then reduce the static part, obtaining a fully \ndynamic term in normal form. The reduction of static parts is performed automat\u00adically by the abstract \nmachine of the programming language. The control operators shift and reset are used to place din the \nright place in the .nal result.   Shift and reset. We brie.y explain the way in which shift and reset \nwork with an example. For details see [8, 9]. The operator reset is used to delimit a context of evaluation, \nand shift abstracts this context in a function. Thus the term 1+ reset (2+ shift c.(3 +(c4)+(c5))) reduces \nto 1 + 3 +(2+ 4)+(2+ 5). Indeed, the operator reset delimits the context 2 + D, which is abstracted into \nthe function c; the values 4 and 5 are successively inserted in this context and the resulting expression \nis evaluated.  6.2 Producing normal terms The original TDPE algorithm without let insertion produces \nterms following the inference system of Figure 3 without taking into ac\u00adcount the side conditions (A), \n(B), (C) there in. For example, the evaluation of the term .z..x..f.d((f@ x) ,x1.(.y..1(y)) ,x2.(.y.f@ \nz)) of type .. .. (.. .1 + .2) . .1 . (.1 + .2) yields the term d((f@ x) , (5) x1.(.y..1(y)) , ( x2.(.y.d \n(f@ z),y..1(y),y..2(y))) 1122 which does not satisfy condition (A) since f@ zdoes not contain the variable \nyIn the following, we propose three modi.cations of TDPE to take the conditions (A), (B), (C) into account. \n 6.2.1 Remove dead branches To ensure the condition (B) we will use the following derivable equations: \nd(t,x.d(t,x1.t1,x2.t2),y.t0)= d(t,x.t1[x/x1],y.t0) d(t,x.t0,y.d(t,x1.t1,x2.t2))= d(t,x.t0,y.t2[y/x2]) \nTo apply these transformations, notice that the residual program is an abstract syntax tree built in \ndepth-.rst manner, from left to right, the evaluation being done in call by value. The idea consists \nin maintaining a global table accounting for the conditional branches in the path from the root of the \nresidual program to the current point of construction. This table associates a .ag (Lor R) and a variable \n          .. V = V (. a base type) 1 . V = () .s. t V = let x be a fresh variable in .x.reset(.t \n(V @ .s x)) t1\u00d7t2 V .= pair(.t1 (p1(V)), .t2 (p2(V))) .t1+t2 V = d V,x1..1(.t1 x1),x2..2(.t2 x2) .. \nM = M (. a base type) 1 . M = () .t. s M = .x..s (M @ .t x) .s1\u00d7s2 M = pair(.s1 (p1(M)), .s2 (p2(M))) \ns1+s2 M . = let x1 and x2 be fresh variables in shift c. d( M,x1. reset(c @ .1(.s1 x1)) ,x2. reset(c@ \n.2(.s2 x2)) ) Figure 4. Type-directed partial evaluation without let insertion. to an expression in the \nfollowing way: .s1+s2 M = if M is globally associated to (L, z) modulo then .1(.s1 z) else if M is globally \nassociated to (R, z) modulo then .2(.s2 z) else shift c. let x1 and x2 be fresh variables, associate \nM to (L,x1) while computing n1 = reset(.1(.s1 x1)), associate M to (R,x2) while computing n2 = reset(.2(.s2 \nx2)), in d( M,x1.n1,x2.n2) (Note that the test of global association is done modulo ; this is explained \nin the next section.) This optimisation, associated with let insertion and other memo\u00adization techniques, \nhas been used for building a fully lazy partial evaluator from TDPE; see [3].  6.2.2 Forbid redundant \ndiscriminators To enforce the condition (C), we write a test of membership of free variables and implement \na test of the congruence of two normal terms. There are different ways in which to implement this lat\u00adter \ntest. One method is to de.ne, in a mutually recursive fashion, three tests M0 , N0 , and N that respectively \ntest the equiva\u00adlence between pure neutral terms, pure normal terms, and normal terms along the following \nlines. The test M0 is done by structural recursion, using the test N in the case of applications.  \nThe test N0 is done by structural recursion, using the test N in the case of abstractions.  The test \nN N N ' inspects the set of paths p given by all possible branchings in discriminators containing the \nguards of N, and collects the sequence of guards together with the end pure normal form Np. For each \nof these paths p,it  proceeds according to the following sub-test: if N ' is a pure normal term then \ncheck whether Np N0 N ', otherwise, for N ' of the form d(M ' ,x.N ' ,y.N ' ), there are three possibil\u00ad \n12 ities: if M ' is in the path p up to M0 and the path branches left (resp. right) the sub-test is repeated \nfor N ' (resp. N ' ) in\u00ad 12 stead of N ', however, if M ' is not in the path p up to M0 , the sub-test \nis repeated for both N ' and N ' instead of N ' , 1 2 succeeding if both of these sub-tests do. Note \nthat condition (C) does not need to be checked recursively within the branches of the discriminator; \nsince, as TDPE builds the normal form in depth-.rst manner, it is known that each branch satis.es it. \n 6.2.3 Fix the relative positions of abstractions and discriminators To obtain terms in normal form, \nwe must also check the condi\u00adtion (A) concerning the guards of abstractions. For that, let us look at \nthe example in (5). We want to introduce the d(f @ z, ...) above .y . . . However a shift always returns \nto the preceding reset. Thus, it would be necessary to be able to name each reset and to choose the best \none at the time of introducing the d. This is what the control operators cupto/set, introduced in [19], \nallow us to do. Set and cupto. The control operators set and cupto are very pow\u00aderful, and generalise \nexceptions and continuations. Here we give the idea of how they work on an example. For details see [19, \n18]. The operators set/cupto rely on the concept of prompt, that allows marking the occurrences of set. \nNew prompts can be created upon request. For two prompts p1 and p2, one can write an expression like \nthe following one 1+ set p1 in 2 + set p2 in 3 + cupto p1 as c in (4 +(c 5)) which evaluates to 1 + 4 \n+(2 + 3 + 5). Application to TDPE. To use set/cupto to address the problem of .xing the relative position \nof abstractions and discriminators, we must create a new prompt with each created dynamic .. Further, \nwe maintain a global list associating to each prompt a set of vari\u00adables. To introduce a new d, we look \nfor all the free variables of its condition, and look in this list for the last prompt introduced to \nwhich one of these variables is associated. Since the term is built in depth .rst manner and from left \nto right, one obtains a closed term. We thus modify the algorithm of TDPE in the following way: .s. t \nV = let x be a fresh variable and p be a new prompt in .x.set pin .t (V @ .s x) .s1+s2 M = let m be the \nbest prompt for M in cupto m as c in let x1 and x2 be fresh variables, n1 = set m in (c@ .1(.s1 x1)), \nn2 = set m in (c@ .2(.s2 x2)), in d ( M,x1.n1,x2.n2) The complete algorithm is presented in Figure 5. \n 6.2.4 Two examples 1. We show the application of the optimised partial evaluator to the example of \nthe introduction. # let example f gzx= match (match x with Left x1 -> Left z | Right x2 -> Right (g z)) \nwith Left y1 -> (f (g y1)) | Right y2 -> (f y2);; val example : ( a -> b) -> ( c -> a) -> c -> ( d, \ne) sum -> b = <fun> To use a type directed partial evaluator, one has to pass to the eval\u00aduator a representation \nof the type of the term to be evaluated. There are different approaches to representing types. Here we \nuse the approach pioneered by Filinski, who represents types via combina\u00adtors, so that ( a -> b) -> ( \nc -> a) -> c -> ( d, e) sum -> b becomes ((base **-> base) **-> ((base **-> base) **-> (base **-> ((sum \n(base, base)) **-> base)))) which we abbreviate below as combinatortype. The application of the partial \nevaluator based on shift/reset yields: # tdpesr combinatortype example;; -: Shiftreset.ans = (fun v0 \nv1 v2 v3 -> (match v3 with | Left v4 -> (v0 (v1 v2)) | Right v4 -> (v0 (v1 v2)))) whilst the partial \nevaluator based on cupto produces the desired result: # tdpecupto combinatortype example;; -: Normal.normal \n= (funfgz x->(f (g z))) 2. We now test the partial evaluator on an example suggested to us by Filinski. \nFor every endofunction f on a two-element set, the identity f3 = f holds. We give a proof of this fact \nin the equational theory of the typed lambda calculus with sums by establishing the identity .f:(1+ 1) \n. (1+ 1)..x: 1+ 1.f(f(fx)) = .f:(1+ 1) . (1+ 1).f in the equational theory using the partial evaluator. \nDe.ning # let fff f x = f (f (f x));; val fff : ( a -> a) -> a -> a = <fun> and # let bool = sum (unit,unit);; \n we want that the normalisation of fff of type (bool -> bool) -> bool -> bool is (the normal form of) \nthe identity. Normalising fff by the TDPE with shift/reset gives the following (uninformative) result. \n# tdpesr ((bool **-> bool) **-> (bool **-> bool)) fff;; -: Shiftreset.ans = (fun v0 v1 -> (match v1 \nwith | Left v2 -> (match (v0 (Left ())) with | Left v10 -> (match (v0 (Left ())) with | Left v14 -> \n(match (v0 (Left ())) with | Left v16 -> (Left ()) | Right v16 -> (Right ())) | Right v14 -> (match \n(v0 (Right ())) with | Left v15 -> (Left ()) | Right v15 -> (Right ()))) | Right v10 -> (match (v0 (Right \n())) with | Left v11 -> (match (v0 (Left ())) with | Left v13 -> (Left ()) | Right v13 -> (Right ())) \n | Right v11 -> (match (v0 (Right ())) with | Left v12 -> (Left ()) | Right v12 -> (Right ())))) | Right \nv2 -> (match (v0 (Right ())) with | Left v3 -> (match (v0 (Left ())) with | Left v7 -> (match (v0 (Left \n())) with | Left v9 -> (Left ()) | Right v9 -> (Right ())) | Right v7 -> (match (v0 (Right ())) with \n| Left v8 -> (Left ())  .. V = V .1 V .s. t V = = () let xbe a fresh variable and pa new prompt in .x.set \npin .t (V@ .s x) .t1\u00d7t2 V .t1+t2 V = = pair(.t1 (p1(V)), .t2 (p2(V))) d V, x1..1(.t1 x1),x2..2(.t2 x2) \n.. M = M .1 M .t. s M = = () .x..s (M@ .t x) .s1\u00d7s2 M .s1+s2 M = = pair(.s1 (p1(M)),.s2 (p2(M))) if Mis \nglobally associated to (L, z) modulo then .1(.s1 z) else if Mis globally associated to (R, z) modulo \n then .2(.s2 z) else let mbe the best prompt for M in cupto mas c in let x1 and x2 be fresh variables \nassociate Mto (L,x1) while computing n1 = set min (c@ .1(.s1 x1)) associate Mto (R,x2) while computing \nn2 = set min (c@ .2(.s2 x2)) in if x1 . FV(n1), x2 . FV(n2), and n1 n2 then n1 else d(M, x1.n1,x2.n2) \nFigure 5. Optimised type-directed normalisation. | Right v8 -> (Right ()))) | Right v3 -> (match (v0 \n(Right ())) with | Left v4 -> (match (v0 (Left ())) with | Left v6 -> (Left ()) | Right v6 -> (Right \n())) | Right v4 -> (match (v0 (Right ())) with | Left v5 -> (Left ()) | Right v5 -> (Right ())))))) \n The result of normalising fff with the partial evaluator based on cupto is the residualisation of the \nidentity: # tdpecupto ((bool **-> bool) **-> (bool **-> bool)) fff;; -: Normal.normal = (fun v0 -> \n(match (v0 (Left ())) with | Left v4 -> (match (v0 (Right ())) with | Left v6 -> (fun v1 -> (Left \n())) | Right v7 -> (fun v1 -> (match v1 with | Left v2 -> (Left ()) | Right v3 -> (Right ())))) \n| Right v5 -> (match (v0 (Right ())) with | Left v10 -> (fun v1 -> (match v1 with | Left v2 -> (Right \n()) | Right v3 -> (Left ()))) | Right v11 -> (fun v1 -> (Right ())))))   7 Concluding remarks We \nhave presented a notion of normal term for the typed lambda calculus with sums and proved that every \nterm of the calculus is equivalent to one in normal form. Further, we have used this the\u00adoretical development \nas the basis to implement a partial evaluator that provides a reductionless normalisation procedure for \nthe typed lambda calculus with binary sums. Our partial evaluator is in the style of TDPE. Thus, it can \nbe grafted on any suitable interpreter, and does not need to examine the struc\u00adture of the compiled code \nduring normalisation. Its main original\u00adity is the use of the control operators set/cupto to .x the relative \nposition of abstractions and discriminators. This is the .rst non\u00adtrivial exploitation of the extra expressive \npower of set/cupto over shift/reset. The effectiveness of the partial evaluator has been tested on the \nvery sophisticated terms that come from the study of iso\u00admorphisms in the typed lambda calculus with \nsums [15], that make previously existing partial evaluators explode. The new algorithm does not use all \nthe power of the operators set/cupto. In particular we do not use their ability to code excep\u00adtions. \nOne could thus use only a restricted version of these opera\u00adtors. There is, for example, a hierarchical \nversion of shift/reset [8], that allows several, but .xed, levels of control. An implementation with \nshift/reset (hierarchical or not) is not obvious. Acknowledgements. Thanks are due to Xavier Leroy for \nthe call/cc for Objective Caml, and to Olivier Danvy, Andrzej Fil\u00adinski, and Didier R\u00b4emy for interesting \ndiscussions about control operators. 8 References [1] T. Altenkirch, P. Dybjer, M. Hofmann, and P. Scott. \nNor\u00admalization by evaluation for typed lambda calculus with co\u00adproducts. In Sixteenth Annual IEEE Symposium \non Logic in Computer Science, pages 203 210. IEEE Computer Society Press, 2001. [2] V. Balat and O. Danvy. \nStrong normalization by type-directed partial evaluation and run-time code generation. In Second International \nWorkshop on Types in Compilation, number 1473 in Lecture Notes in Computer Science, pages 240 252. Springer-Verlag, \n1998. [3] V. Balat and O. Danvy. Memoization in type-directed par\u00adtial evaluation. In ACM SIGPLAN/SIGSOFT \nConference on Generative Programming and Component Engineering (GCSE/SAIG), number 2487 in Lecture Notes \nin Computer Science, 2002. [4] U. Berger and H. Schwichtenberg. An inverse of the evalu\u00adation functional \nfor typed .-calculus. In Sixth Annual IEEE Symposium on Logic in Computer Science, pages 203 211. IEEE \nComputer Society Press, 1991. [5] O. Danvy. Type-directed partial evaluation. In Twenty-Third Annual \nACM Symposium on Principles of Programming Lan\u00adguages, pages 242 257. ACM Press, 1996. [6] O. Danvy. \nType-directed partial evaluation. In Partial Evalu\u00adation Practice and Theory; Proceedings of the 1998 \nDIKU Summer School, number 1706 in Lecture Notes in Computer Science, pages 367 411. Springer-Verlag, \n1998. [7] O. Danvy and P. Dybjer, editors. Preliminary Proceedings of the APPSEM Workshop on Normalization \nby Evaluation, BRICS Note NS-98-1. Department of Computer Science, University of Aarhus, 1998. [8] O. \nDanvy and A. Filinski. Abstracting control. In ACM Con\u00adference on Lisp and Functional Programming, pages \n151 160. ACM Press, 1990. [9] O. Danvy and A. Filinski. Representing control, a study of the CPS transformation. \nMSCS, 4(2):361 191, December 1992. [10] R. Di Cosmo and D. Kesner. Simulating expansions without expansions. \nMathematical Structures in Computer Science, 4:1 48, 1994. [11] D. Dougherty. Some lambda calculi with \ncategorical sums and products. In 5th International Conference on Rewriting Techniques and Applications \n(RTA-93), volume 690 of Lec\u00adture Notes in Computer Science, pages 137 151. Springer-Verlag, 1993. [12] \nD. Dougherty and R. Subrahmanyam. Equality between func\u00adtionals in the presence of coproducts. In Tenth \nAnnual IEEE Symposium on Logic in Computer Science, pages 282 291. IEEE Computer Society Press, 1995. \n[13] D. Dougherty and R. Subrahmanyam. Equality between func\u00adtionals in the presence of coproducts. Information \nand Com\u00adputation, 157:52 83, 2000. (An earlier version appeared as [12]). [14] M. Fiore. Semantic analysis \nof normalisation by evalua\u00adtion for typed lambda calculus. In 4th International Confer\u00adence on Principles \nand Practice of Declarative Programming (PPDP 2002). ACM Press, 2002. [15] M. Fiore, R. Di Cosmo, and \nV. Balat. Remarks on isomor\u00adphisms in typed lambda calculi with empty and sum types. In Seventeenth Annual \nIEEE Symposium on Logic in Computer Science, pages 147 156. IEEE Computer Society Press, 2002. [16] M. \nFiore and A. Simpson. Lambda-de.nability with sums via Grothendieck logical relations. In Typed Lambda \nCalculus and Applications, number 1581 in Lecture Notes in Computer Science, pages 147 161. Springer-Verlag, \n1999. [17] N. Ghani. \u00df.-equality for coproducts. In Typed Lambda Cal\u00adculus and Applications, number 902 \nin Lecture Notes in Com\u00adputer Science, pages 171 185. Springer-Verlag, 1995. [18] C. A. Gunter, D. R\u00b4emy, \nand J. G. Riecke. Return types for functional continuations. 1998. (An earlier version appeared as [19]). \n[19] C. A. Gunter, D. R\u00b4emy, and J. G. Riecke. A generalization of exceptions and control in ML. In ACM \nConference on Func\u00adtional Programming and Computer Architecture, 1995. [20] J. Lambek and P. Scott. Introduction \nto higher order categor\u00adical logic, volume 7 of Cambridge studies in advanced math\u00adematics. Cambridge \nUniversity Press, 1986.  \n\t\t\t", "proc_id": "964001", "abstract": "We present a notion of &#951;-long &#946;-normal term for the typed lambda calculus with sums and prove, using Grothendieck logical relations, that every term is equivalent to one in normal form. Based on this development we give the first type-directed partial evaluator that constructs %able to construct normal forms of terms in this calculus.", "authors": [{"name": "Vincent Balat", "author_profile_id": "81100419337", "affiliation": "PPS - Universit&#233; Paris 7", "person_id": "PP17010093", "email_address": "", "orcid_id": ""}, {"name": "Roberto Di Cosmo", "author_profile_id": "81100092525", "affiliation": "PPS - Universit&#233; Paris 7 and INRIA-Roquencourt", "person_id": "PP28004865", "email_address": "", "orcid_id": ""}, {"name": "Marcelo Fiore", "author_profile_id": "81100192065", "affiliation": "University of Cambridge", "person_id": "PP28001652", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/964001.964007", "year": "2004", "article_id": "964007", "conference": "POPL", "title": "Extensional normalisation and type-directed partial evaluation for typed lambda calculus with sums", "url": "http://dl.acm.org/citation.cfm?id=964007"}