{"article_publication_date": "01-01-2004", "fulltext": "\n Local Reasoning about a Copying Garbage Collector Lars Birkedal Noah Torp-Smith John C. Reynolds The \nIT University of Copenhagen The IT University of Copenhagen Carnegie Mellon University birkedal@itu.dk \nnoah@itu.dk John.Reynolds@cs.cmu.edu Abstract We present a programming language, model, and logic appropriate \nfor implementing and reasoning about a memory management sys\u00adtem. We then state what is meant by correctness \nof a copying gar\u00adbage collector, and employ a variant of the novel separation logics [18, 23] to formally \nspecify partial correctness of Cheney s copying garbage collector [8]. Finally, we prove that our implementation \nof Cheney s algorithm meets its speci.cation, using the logic we have given, and auxiliary variables \n[19]. Categories and Subject Descriptors D.2.8 [Logics and Meanings of Programs]: Specifying and Ver\u00adifying \nand Reasoning about Programs Assertions, Logics of pro\u00adgrams, Speci.cation techniques General Terms \nRealiability, Theory, Veri.cation  Keywords Separation Logic, Copying Garbage Collector, Local Reasoning \n 1 Introduction Reasoning formally about low-level imperative programs that ma\u00adnipulate data structures \ninvolving pointers has proven to be very dif.cult, mainly due to a lack of reasoning principles that \nare ad\u00adequate and simple at the same time. Recently, Reynolds, O Hearn and others have suggested separation \nlogic as a tool for reason\u00ading about programs involving pointers; see [23] for a survey and historical \nremarks. In his dissertation, Yang showed that separa\u00adtion logic is a promising direction by giving an \nelegant proof of the non-trivial Schorr-Waite graph marking algorithm [28]. One of the key features making \nseparation logic a promising tool is that Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. POPL 04 January 14 16, 2004, Venice, Italy Copyright 2004 ACM 1-58113-729-X/04/0001 \n...$5.00 it supports local reasoning: when specifying and reasoning about program fragments involving \npointers, one may restrict attention to the footprint of the programs, that is, to just that part of \nmemory that the program fragments read from or write to. The aim of this paper is to further explore \nthe idea of local rea\u00adsoning and its realization in separation logic. To this end we prove the correctness \nof Cheney s copying garbage collector [8] via local reasoning in (an extension of) separation logic. \nThere are several reasons why we have chosen to focus on Cheney s algorithm: The algorithm involves \nmany imperative manipulations of data; in particular, it not only updates an existing data struc\u00adture \nas the Schorr-Waite algorithm does, but moves data around. Moreover, it simultaneously treats the same \ndata as a set of records linked by pointers and as an array of records.  Cheney s algorithm copies any \nkind of data, including cyclic data structures; to the best of our knowledge, our correctness proof is \nthe .rst such done via local reasoning for programs copying cyclic data structures.  Variants of the \nalgorithm are used in practice, e.g., in runtime systems for compilers for functional programming languages, \nso it is not a toy -example.  To the best of our knowledge, there is no formal correctness proof of \nCheney s algorithm in the literature.  Indeed, for the reasons above, proving correctness of a garbage \ncol\u00adlector, has been considered a key challenge for a long time. (In 1992 Nettles gave an informal proof \nof correctness of a copying garbage collector [17] and expressed a wish for a formal veri.cation.) There \nare two other motivating factors that we would like to call attention to. The .rst is that our analysis \nanswers a question in the literature and thus paves the way for important future work that so far has \nbeen out of reach: In [7], local reasoning and separation logic for a garbage collected language is analyzed. \nAn underlying garbage collector is presumed in the operational semantics of the language, inasmuch as \na partial pruning and a-renaming (i.e., relo\u00adcation) of the current state is allowed at any time during \nexecution of a program. In [7] it is not mentioned how this pruning and re\u00adnaming should be done, let \nalone proven that it is done correctly. A remark at the end of the paper expresses the desirability of \nsuch a proof we provide one here. The analyses in [7] and the present paper are at two distinct levels: \nthe former is at the level of a user language using a runtime system (a garbage collector), the latter \nis at the level of a runtime system providing operations for the user language (memory allocation and \ngarbage collection). We believe these analyses pave the way for an investigation of the correctness of \ncombinations of user level programs and runtime systems, a goal that so far has been unfeasible. We present \nsome preliminary ideas in this direction in Sec. 8. The additional second motivating factor is that our \nanalysis of gar\u00adbage collection should be of use in connection with foundational proof-carrying code \n[2] and typed assembly language [14]. In these settings, a memory allocation (but no deallocation) construct \nis part of the instruction set and a memory management system is implic\u00aditly assumed. We believe that \nour correctness proof can contribute to mimicking the work of [14] in a more realistic setting, for more \nmachine-like assembly languages. 1.1 Contributions and Methodology In Sec. 2 we present our storage \nmodel and the syntax and semantics of assertions. Our storage model is very concrete and close to real \nmachines; it treats locations as multiples of four. (It is assumed that all data other than locations \nare encoded as nonmultiples of four.) This is very similar to what is often used in real implementations \nof runtime systems for compilers. For simplicity we assume that heaps only consist of cons-cells, aligned \nsuch that the .rst compo\u00adnent is always on a location divisible by eight; hence pointers (to cons-cells) \nare multiples of eight. As usual in separation logic, a state consists of a stack and a heap, where a \nstack is a .nite map from variables to values, and a heap is a .nite map from locations to integers. \nA new feature is that our values include .nite sets and relations of pointers and integers, which are \nused to give the seman\u00adtics of assertions and of auxiliary variables [19]. Our assertion language, presented \nin Sec. 2.3, is an extension of separation logic [23] with new assertion forms for .nite sets and relations. \nThese new forms are crucially used to express part of the speci.cation of Cheney s algorithm; in particular \nthe existence of an isomorphism between pointers to old cells and pointers to copies of the old cells. \nWe believe this methodology of using sets and re\u00adlations can be used more widely, to specify and prove \ncorrect other programs involving shared or cyclic structures. Indeed a somewhat similar approach is being \nused by Richard Bornat [5] to specify and verify an algorithm for copying directed acyclic graphs. Moreover, \nwe have extended the iterated separating conjunc\u00adtion [23] of separation logic to arbitrary .nite sets. \nThe assertion .*x .m. A holds in a state s,h,if m denotes a .nite set {p1,...,pk}and A[p1/x] *\u00b7\u00b7\u00b7*A[pk/x] \nholds in s,h (see Fig. 1 for a precise de.nition). As illustrated in Sec. 5, one can specify a program \nby dividing the locations it manipulates into disjoint sets, using the it\u00aderated separating conjunction, \ntogether with expressions for .nite sets and relations, to express particular properties for each set \nof locations. One could argue that it is a weakness of separation logic that we had to extend it with \nthe above mentioned new constructs. Such exten\u00adsions must be expected, however, when a young logic encounters \na subtle algorithm. The real question is whether the resulting speci.\u00adcation is a natural formalization \nof the programmer s understanding of the algorithm. In Sec. 3 we de.ne the syntax and semantics of the \nprogramming language used for implementing the garbage collector. It is a simple imperative programming \nlanguage, with constructs for heap lookup and heap update (but no constructs for allocating or disposing \nof heap cells). The associated program logic is presented in Sec. 3.2. The program logic is mostly standard \nexcept for the new rules re\u00adgarding sets and relations. We include the Frame Rule of separa\u00adtion logic, \nwhich makes local reasoning possible, as explained in Sec. 3.2. In Sec. 4 we express what it means for \na garbage collector to be correct. Our de.nitions are based on the analysis in [7] (already referred \nto above) and thus involve pruning and a-renaming of pro\u00adgram states. Cheney s algorithm and the speci.cation \nof our implementation thereof are presented in Sec. 5; the implementation itself is included in Appendix \nA. We present an informal analysis of the algorithm and use it to derive a formal speci.cation of an \ninvariant. The point\u00aders manipulated by the algorithm can be naturally divided into dis\u00adjoint sets and \nthus it is natural to use the method of sets and relations together with the iterated separating conjunction \nmentioned before. The sets and relations are also used in another crucial way, namely to record the initial \ncontents of the heap (before garbage collection). This makes it possible to relate the .nal heap (after \ngarbage collec\u00adtion) to the initial heap and prove that the .nal heap is a garbage collected version \nof the initial heap. We also emphasize the following point. Cheney s algorithm as\u00adsumes two contiguous \nsemi-heaps of equal size, OLD and NEW, and works by copying all live data from OLD into NEW. One of the \nreasons for the popularity of Cheney s algorithm (and variants thereof) is that it runs in time proportional \nto the live data; it never touches dead cells. This fact is re.ected directly in our speci.cation of \nthe algorithm, which refers to the live part of OLD only. It is in the spirit of local reasoning to have \nsuch a direct correspondence between the intuitive understanding of an algorithm and its formal speci.cation. \nIn Sec. 6 we prove our implementation of Cheney s garbage collec\u00adtion algorithm correct. The proof proceeds \nby .rst showing that the proposed invariant from the previous section is indeed an invariant and then \nshowing that the invariant suf.ces to conclude correctness. We present the key ideas of the proofs and \nin particular explain how local reasoning allows us to reason locally about different fragments of the \nalgorithm, thus illustrating the power of the Frame Rule. Full proofs with all details can be found in \nthe companion technical re\u00adport [4]. In Sec. 7 we discuss some related work, besides what we have al\u00adready \ndiscussed above, and .nally we conclude and present some suggestions for future work in Sec. 8.  2 Syntax \nand Semantics In this section, we present our basic storage model and the syntax and semantics of expressions \nand assertions. The basis of the sys\u00adtem is the standard separation logic with pointer arithmetic [18], \nbut we extend the expression and assertion languages with .nite sets and relations, new basic assertions \nabout these, and the extension of the iterated separating conjunction to arbitrary .nite sets. 2.1 Storage \nModel We assume .ve countably in.nite sets Varint , Varfs , Varfrp, Varfri , Varpath of variables, and \nwe let Var be the disjoint union of these sets. We let metavariables x,y,...range over Var and assume \na type\u00adfunction t : Var .Types, where Types = {int,fs,frp,fri,path} indicating which type a given variable \nhas. The set of locations is the set of natural numbers that are divisible by 4, and the set of pointers \nis the set of natural numbers that are divisible by 8. More formally, we de.ne: Variables x,y,... . Var \nPointers Locations Finite sets p .Ptr l .Loc FS def = def = def = {8n | n .N} {4n | n .N}P fin(Ptr) Pointer \nrel ns FRP def = P fin(Ptr \u00d7Ptr) Integer rel ns FRi def = P fin(Ptr \u00d7.) Paths Values Path v .Val def \n= def = {head,tail}* ..FS.FRP .FRi .Path Heaps def = Loc -fin Z Stacks States def = def = {s : Var -fin \nVal |.x .Var. s(x) .[[t(x)]]} Stacks \u00d7Heaps, and let [[int]] = ., [[fs]] = FS, [[fri]] = FRi, [[ path]] \n= Path, and [[frp]] = FRP.  2.2 Expressions We de.ne the syntax and semantics for expressions of each \nof the types int,fs,frp,fri,path. For expressions of type int we just present the syntax; the semantics \nis standard. For expressions of the remaining types, we just present the semantics as the syntax will \nbe evident from the presentation of the semantics. Expressions of type int are de.ned by the following \ngrammar: e ::= n |xint|e1 + e2 |e1 -e2 |e1 \u00d7e2 |e mod j fs |e1 =e2 |e1 = e2 |\u00ace |e1 .e2 |#m, where n \n. .and j .N\\{0}. The semantics of #mfs is the num\u00ad fs ber of elements in the .nite set denoted by m(see \nbelow). In order to avoid introducing an explicit type of boolean values, we use a standard encoding \nof truth values, where 0 denotes false , and all other integers denote true . Although the superscript \nthat indicates the type is only meant to indicate the type of variables, we will sometimes use a superscript \nto indicate the type of composite expressions. At other times, we will omit the superscripts, even on \nvariables, if it causes no confusion. We use m to range over expressions of type fs. The semantics of \nan expression of type fs is a .nite set of pointers. The operator .adds an element to a set, if it is \na pointer, whereas e removes a pointer from a set. Itv(e1,e2) is the set of pointers in the half-open \ninterval from e1 to e2. [[0fs]]s = 0 [[xfs]]s = s(x) [[{e}]] s = {[[ e]] s}nPtr [[mfs .eint]]s =[[m]]s \n.({[[ e]] s}nPtr) [[mfs eeint]]s =[[m]]s \\{[[ e]]s} int int [[ Itv(e,e)]]s = {p .Ptr |[[e1]]s = p . p \n<[[ e2]]s} 12 fs fs [[m1 .m2 ]]s =[[m1]]s .[[ m2]] s With this, we can formally de.ne the semantics of \nexpressions of fs: the form #m [[#mfs]]s = k, where [[m]]s = {p1,...,pk}(note that k may be 0) We use \nf to range over expressions of type frp. The semantics of an expression of type frp is a .nite relation \non pointers. [[ 0frp]] s = 0 frp]] s [[x= s(x) [[ f frp .(eint ,eint)]]s =[[ f ]]s .({([[e1]]s,[[ e2]]s)}nPtr \n\u00d7Ptr) 12 ' [[ f ]] s = {( p,p) |( p,p') .[[ f ]] s} [[ f frp . f frp ' ]] s = {( p,p''') |.p. ( p,p') \n.[[ f2]] s . 12 ( p,p'') .[[ f1]]s} We use P to range over expressions of type path. The semantics for \nexpressions of type path is straightforward, in that the denotation of an expression is equal to itself: \n[[P]]s = P. To conclude our semantics for expressions, we give the semantics for expressions of type \nfri. We use g to range over such expressions. The @operator will be used to model the structure-preserving \nprop\u00aderty of a garbage collector, inasmuch as it extends a relation with the identity on non-pointers \nbefore composing it with another rela\u00adtion (cf. De.nition 6 later in this paper). fri]] s [[x= s(x) [[gfri \n. f frp]] s = {( p,n) |.p'.Ptr. ( p,p') .[[ f ]]s . ( p',n) .[[g]] s} [[ f frp @gfri]] s = {( p,n) |(( \np,n) .[[g]] s .n. Ptr) . ' (.p'.Ptr. ( p,p') .[[g]] s .( p,n) .[[ f ]]s)} We use =to denote syntactic \nequality between expressions, and we sometimes write e1 = e2 to denote that [[e1]] s =[[e2]]s, for all \nstacks s. 2.3 Assertions The assertion language is an extension of separation logic [23] with new assertion \nforms for .nite sets and relations. We just present the semantics of assertions; again the syntax is \nevident from the presentation of the semantics. We use A, B, and D to range over assertions. The set \nFV (A) of free variables for an assertion is de.ned as usual, but note that x is bound in .*x . m. A. \nSubstitution A[e/x] of the expression e for the variable x in the assertion A is de.ned in the standard \nway. We sometimes write an assertion A as A(x) to emphasize that the variable x may occur free in A. \nThe formal semantics of assertions is given by a judgement of the form s,h lA, the intended meaning \nof which is that the assertion A holds in the state s,h. We require that FV (A) . dom(s). The semantics \nis given in Fig. 1; here b ranges over the boolean expressions e1 =e2,e1 = e2, and d ranges over Types. \nIn Fig. 1, we have used the notation h1#h2 to indicate dom(h1) ndom(h2)= 0(we call such heaps disjoint), \nand if h1#h2, we de.ne the combined heap h1 *h2 by h1(n) if n .dom(h1) . n h2(n) if n .dom(h2) A brief \nexplanation of some of the clauses in Fig. 1 is appropriate here. The assertion forms emp, e1 . e2, A \n*B, and A -* B are A s,h lA if and only if A s,h lA if and only if b T F \u00acA A .B A .B A .B .xd . A .xd \n. A m1 = m2 (e1,e2) . f frp (e1,e2) .gfri [[b]] s = 0 always never s,h .A s,h lA implies s,h lB s,h lA \nand s,h lB s,h lA or s,h lB for all v .[[ d]],s[x .v],h lA for some v .[[ d]], s[x .v],h lA [[m1]]s =[[m2]]s \n([[e1]]s,[[e2]]s) .[[ f ]]s ([[e1]]s,[[e2]]s) .[[ g]]s e1 .e2 emp A *B A -*B Ptr(e) PtrRg(g,m) m .m ' \nm1 .m2 Tfun( f frp,m) Tfun(gfri ,m) h = {([[e1]]s,[[ e2]]s)}dom(h)= 0 there are heaps h1,h2 such that \nh1#h2, h1 *h2 = h,s,h1 lA, and s,h2 lB s,h *h ' lB for all h ' such that h#h ' and s,h ' lA [[ e]]s .Ptr \n.( p,q) .[[g]] s. q .Ptr .q .[[m]]s [[ m]]s n[[ m ']]s = 0 [[ m1]]s .[[ m2]]s .p .[[m]]s. .!n . .( p,n) \n.[[ f ]]s .p .[[m]]s. .!n . .( p,n) .[[g]] s A s,h lA if and only if iso( f ,m1,m2) eval(g,g ' ,Ppath,e,e \n') Reachable(g,g ' ,m,e) .*p .m. A .p1 .M1. .!p2 .M2. ( p1,p2) .f ..p2 .M2. .!p1 .M1. ( p1,p2) .f . .( \np1,p2) .f. p1 .M1 .p2 .M2, where M1 =[[m1]]s,M2 =[[m2]]s,f =[[ f ]]s (P = e and s,h le = e '), or (P \n= P ' \u00b7head and .p .Ptr. s,h leval(g,g ' ,P ' ,e,p) and s,h l( p,e ') .g),or (P = P ' \u00b7tail and .p .Ptr. \ns,h leval(g,g ' ,P ' ,e,p) and s,h l( p,e ') .g ') [[m]] s = {p .Ptr |.P .Path. s,h leval(g,g ' ,P,e,p)}s,h \nlA[ p1/p] *\u00b7\u00b7\u00b7*A[ pk/p], if [[ m]]s = {p1,...,pk}s,h lemp if [[ m]]s = 0 Figure 1. Semantics of Assertions \ntaken from separation logic. emp states that the heap is empty, and e1 .e2 states that there is precisely \none location in the domain of the heap. A *B means that A and B hold in disjoint subheaps of the current \nheap, and A -*B means that for all heaps h ' disjoint from the current heap h,if A holds in h ', the \ncombination h *h ' will satisfy B. The assertions eval and Reachable concern evaluation of paths, and \nPtrRg(g,m) says that any pointer in the range of the relation denoted g is in the set denoted by m. Finally, \n.* is an iterated separating conjunction. Informally, if s,h l.*x .m. A, and if [[m]]s = {p1,...,pk}, \nthen h can be split into disjoint heaps h = h1 *\u00b7\u00b7\u00b7*hk with s,h1 lA[ p1/x],...,s,hk lA[ pk/x]. Note that \nthe semantics is classical for the standard .rst-order logic fragment. We use the following standard \nshorthand notations def e .e1,e2 = (e .e1) *(e + 4 .e2) e1 '.e2 def = e1 .e2 *T e '.e1,e2 def = e .e1,e2 \n*T e .- def = .xint . e .x e .-,- def = .xint ,yint . e .x,y The notations e .e1,e2,e '.e1,e2,e .-,-,e \n'.-,- make sense for all locations, but we shall only use them when e denotes a pointer. We shall also \nwrite e1 = e2 for \u00ac(e1 = e2). For later use, we introduce some special classes of assertions. The de.nitions \nare taken from [28] and [23]. We call an assertion A pure if its validity does not depend on the heap, \ni.e., if s,h lA if and only if s,h ' lA, for all stacks s and heaps h,h ' .  We call an assertion A \nmonotone if, for all stacks s and heaps h,h ' ,  s,h lA and h .h ' imply s,h ' lA, where .indicates \nset-theoretic inclusion of graphs. In the literature, monotone assertions are often called intuitionis\u00adtic \n[23]. Remark 1. For a pure assertion A, .distributes over *: s,h lA .(B *C) iff s,h l(A .B) *(A .C) \nfor any assertions B,C.  Pure assertions are monotone.  Syntactically, an assertion is pure, if it \ndoes not contain any occurrences of emp, .*, and ., or the shorthand notation '..  De.nition 1. We \ncall an assertion A valid if, for all states s,h with FV (A) .dom(s), we have s,h lA. We use .to denote \nsemantic validity, i.e., A .B if s,h lA implies s,h lB, for all states s,h. One may easily verify that \na number of useful assertion schemas are valid; below we present some of the more interesting ones (and \nomit obvious assertions about .nite sets and relations, the standard rules for classical logic, and simple \narithmetic). First we present some rules for the iterated separating conjunction. '' (.*x .m. A) . m \n= m ..*x .m . A (1) m = 0.((.*x .m. A) .emp) (2) (.*x .m. x .- . A) .e .m . (3) (.*x .m. x .- . A) .(e \n'.-) (.*x .m. A) .e .m . (4) (.*x .(m ee). A) *A[ e/x] (e .m) .((.*x .(m ee).A) *A[ e/x]) . (5) .*x \n.m. A Next, we give rules involving our special operator @on relations. (e1,e2) .g .\u00acPtr(e2) ..xfrp. \n(e1,e2) .x @g (6) (e1,e2) .g .(e2,e3) . f .(e1,e3) . f @g (7) (e1,e2) . f @g .((e1,e2) .g .\u00acPtr(e2)) \n. (.x. Ptr(x) .(e1,x) .g .(x, e2) . f ) (8) Tfun(g,m) .(e2,e1) .g .e2 .m .Ptr(e1) . (e2,e3) . f @g .(e1,e3) \n. f (9) ((e1,e2) . f @g .e1 .m ' . ((.x. (e1,x) .g .x .m) .\u00acPtr(e2)) . Tfun( f ,m) .Tfun(g,m ')) .e2 \n= e3 (10) The following rules exploit that heaps are single-valued. e '.e1 . e '.e2 .e1 = e2 (11) When \nx .FV (e1,e2), (e1 '.e2) . ((.x. e1 .x .A(x)) *B) . (e1 .e2 .A[e2/x]) *B (12) If B is pure and B ' is \nmonotone, then A .B .B ' implies (A *A') .B .B' (13) The following lemmas can be applied when we reason \nabout asser\u00adtions involving .*. LEMMA 1. Suppose s,h l.*x .m. A and that .x. x .m .A .B is valid. Then \ns,h l.*x .m. B. This means that to infer .*x . m. B from .*x . m. A, it suf.ces to show that .x. x . \nm .A . B is valid. In this way, we can do implication under .* . LEMMA 2. If D is a pure assertion, and \nif D.A .A ' and D.B . B ' are valid, then D .(A *B) .D .(A '*B ') is valid. By induction, this means \nthat in order to infer D .(A1 *\u00b7\u00b7\u00b7*Ak) from D '.(A1 ' *\u00b7\u00b7\u00b7*A ' k), it suf.ces to show D '.A ' 1 .A1, \nand \u00b7\u00b7\u00b7 ,and D '.Ak '.Ak. As an example of a rule that can be derived from the rules above, we get the \nfollowing from (12) and monotonicity. When A is a monotone assertion and x . FV (e1,e2), (e1 '.e2) . \n((.x. (e1 .x .A)) *B) . (e1 .e2 .A[e2/x]) *B (14) . ((e1 .e2) *B) .A[e2/x]  3 Programming Language \nIn this section we .rst de.ne the syntax and semantics of the pro\u00adgramming language used for the implementation \nof the garbage col\u00adlector. Next, we use the assertion language de.ned above to give a program logic for \nthe language. 3.1 Syntax and Semantics De.nition 2. The syntax of the programming language is given \nby the following grammar: C ::= skip | xint := e | xfs := m | xfrp := f | xint :=[e] | [e] := e |C;C \n| while e do C od | if e then C else C . Note that there are no constructs for allocating or deallocating \nlo\u00adcations on the heap. It would be straightforward to add such con\u00adstructs to the language, but we will \nnot need them. In our speci.ca\u00adtion and implementation of Cheney s algorithm we simply assume that the \ndomain of the heap contains the necessary locations. The operational semantics is given by a relation \n.on con.gura\u00adtions. Con.gurations are either of the form s,h (these are called terminal) or of the form \nC,s,h (these are called non-terminal). De.nition 3. The relation .on con.gurations is de.ned by a number \nof inference rules, most of which are completely standard. Thus we just present the rules for assignment, \nheap lookup, and heap update: [[e]]s = vv . [[d]] xd := e,s,h .s[x . v],h [[e]]s = ll .dom(h) h(l)= n \nint ::=[e],s,h .s[x .n],h x [[e1]]s = l [[e2]]s = nl .dom(h) [e1] := e2,s,h .s,h[l .n] The semantics \nis easily seen to be deterministic. De.nition 4. We say that C,s,h is stuck if there is no con.guration \nK such that C,s,h . K.  C,s,h goes wrong if there is a non-terminal con.guration K such that C,s,h \n. * K and K is stuck.  C,s,h terminates normally if there is a terminal con.guration  ' ' s ,h ' such \nthat C,s,h . * s ,h ' . Other published de.nitions of the programming language used by separation logic \nuse a special con.guration called abort or fault instead of the concept of stuck ; we are able to avoid \nthis compli\u00adcation because we have restricted the programming language to a deterministic sublanguage. \nAs is standard, we de.ne Mod(C) for a command C to be the set of variables that are modi.ed by the command, \ni.e., those that occur on the left hand side of the forms xd := v and xint :=[e] (but not [x] := e). \nThe set FV (C) for a command is just the set of variables that occur in C. 3.2 Program Logic De.nition \n5. Let A and B be assertions, and let C be a command. The partial correctness speci.cation {A} C {B} \nis said to hold if, for all states s,h with FV (A,C,B) .dom(s), s,h lA implies C,s,h ' ' does not go \nwrong, and if C,s,h . * s ,h ', then s ,h ' lB. We refer to A as the precondition of the speci.cation \nand to B as the post\u00adcondition. We present a set of proof rules that are sound with respect to Def. 5. \nSince the rules regarding constructs from the simple while\u00adlanguage are standard [11], we only present \nrules regarding the heap. ' Rules for heap lookup. When x .FV (e ,A)and y .FV (e), ' {(.y. e .y .A).x \n=e }x :=[e] (15) ' {e[e /x].x .A[x/y]} When x .FV (e,A)and y .FV (e), {.y. e .y . A}x :=[e] (16) {e .x \n.A[x/y]} Rule for heap update. {e1 .-}[e1]:=e2 {e1 .e2} (17) The Frame Rule {A}C {B} Mod(C)nFV (A ')=0 \n{A *A '}C {B *A '} The Frame Rule makes local reasoning possible: suppose the asser\u00adtion A *A ' describes \na state in which we are to execute C, but that the footprint of C, i.e., those locations read or written \nby C,is described by A and B. Then from a local speci.cation {A}C {B}for C, only involving this footprint, \none can infer a global speci.\u00adcation {A *A '}C {B *A '}, which also involves locations not in the footprint \nof C. It is simpler to state and reason about local speci.\u00adcations, and the Frame Rule says that it is \nadequate to do so. Derived Rule for Pure Assertions {A}C {B} A ' pure, Mod(C)nFV (A ')=0 {A . A '}C {B \n. A '} As an example of another useful derived rule, we note how pure assertions can move in and out \nof the Frame Rule: When A ' is pure, and Mod(C)nFV (B ')=0, {A '.A}C {B} {A '.(A *B ')}C {B *B '} (18) \nThis follows from Remark 1 and the standard rule of consequence. We then have the expected soundness \nresult. THEOREM 1. If a speci.cation {A} C {B} is derivable by the rules above and the standard rules \nof Hoare logic, then {A}C {B}holds. Example: The following rule for lookup can be derived from (16), \nthe Frame Rule, and the standard rules of Hoare logic. If y .FV (A), and x and y are distinct variables, \n{A .(x '.-)}y :=[x] (19) {A .(x '.y)}  4 Expressing Garbage Collection In this section we de.ne what \nit means for a state to be a garbage collected version of another state. Our formulation builds upon \nthe analysis in [7] and thus involves pruning and a-renaming of states. A basic requirement is that the \nheaps of the two states are isomor\u00adphic. For simplicity, we assume that heaps only consist of cons\u00adcells. \nDe.nition 6. Let h and h ' be heaps. Call h and h ' heap-isomorphic if there is a bijection \u00df : dom(h).dom(h \n')such that for all pointers p .dom(h), h '(\u00df(p))=\u00df*(h(p))and h '(\u00df(p)+4)=\u00df*(h(p+4)). Here, \u00df* is the \nextension of \u00df to that is the identity on numbers that are not pointers. We refer to \u00df as a heap isomorphism. \nOf course, it is only necessary to have a heap isomorphism between the subheaps consisting of the live \ndata, i.e., the data reachable from agiven root set. For simplicity, we will assume that there is only \none root cell. De.nition 7. Let s, h be a state with root .dom(s). Pointer q is reachable from pointer \np in the heap h if p =q or if h(p)= p1, h(p +4)=p2, and q is reachable from p1 or p2 in h. The pointer \np is called reachable in the state s,h if p is reachable from s(root) in h. Finally, prune(s,h)=s,g, \nwhere g .h is the subheap of h restricted to those pointers reachable in s,h. ' De.nition 8. Let s, \nh and s ,h ' be states. If \u00df is a heap isomorphism ' between h and h ' , and \u00df(s(root))=s (root), then \nwe call \u00df a state isomorphism. The formal notion of garbage collection is then as follows: '' De.nition \n9. Let s, h and s ,h ' be states. We say that s ,h ' is a gar\u00adbage collected version of s,h if there \nexists a state isomorphism ' \u00df : prune(s,h)~,h '). =prune(s De.nition 10. A command GC is a correct \ngarbage collector if *' ' GC,s,h .s ,h ' implies that s ,h ' is a garbage collected version of s,h. \n 5 Cheney s Algorithm We implement and reason about Cheney s Algorithm [8]. The implementation of the \nalgorithm and the associated memory allocator is given in Appendix A. It assumes two con\u00adtigous semi-heaps \n, OLD =Itv(startOld,endOld) and NEW = Itv(startNew,endNew) of equal size. The memory allocator at\u00adtempts \nto allocate a cons-cell in OLD; if there is no space available in OLD, the garbage collector copies all \ncells in OLD reachable from root into NEW, and then the allocation resumes in NEW. The garbage collector \nis delimited by comments in the code in Ap\u00adpendix A; we refer to it as GC*. Notice that the algorithm \nis aware of the locations of the live cells only (those locations reachable from root). In the spirit \nof local reasoning, our speci.cation will there\u00adfore only involve the reachable pointers in OLD, called \nALIVE, and not the remaining (unreachable) part of OLD. Notice that the set {f, FORW, UNFORW}is an auxiliary \nvariable set for the implementation, in the sense of [19]. Thus, the assign\u00adments to these variables \nare not necessary for the program to work, but they ease the job of proving properties about the program. \nWe could have chosen to existentially quantify these variables and omit them from the program, but the \nreasoning becomes clearer when the program modi.es the auxiliary variables explicitly. root Figure 2. \nA state of execution 5.1 The Precondition Before execution of GC*, we assume that the following assertion \nholds. InitAss = Ptr(o.set) .Ptr(maxFree) .#ALIVE =#NEW . (ALIVE .NEW) .Reachable(head,tail,ALIVE,root) \n. Tfun(head,ALIVE) .Tfun(tail,ALIVE) . PtrRg(tail,ALIVE) .PtrRg(head,ALIVE) .root .ALIVE . ((.*y .ALIVE. \n((.z. (y,z) .head .y .z)* ''' (.z . (y,z ) .tail .y + 4 .z )))* (.*y .NEW.y .-,-)) Informally, the assertion, \namong other things, expresses that ALIVE is the set of pointers reachable from root, and that head and \ntail are relations recording the initial contents of the reachable cells, as can be seen from the iterated \nseparating conjunction over the set ALIVE.  5.2 The Invariant To exhibit an invariant of the while-loop, \nwe consider Fig. 2, which is a snapshot of a state during execution. Only the reachable cells in OLD \n(the part of the heap above the bold horizontal line) are shown. Three of the cells in ALIVE have been \nmodi.ed at this stage: their .rst component have been updated with forwarding pointers; these have a \nbolder appearance in the .gure. The original contents of these .rst components are indicated with dotted \nlines and parenthe\u00adsized numbers. The pointers in ALIVE naturally divide into two sets: UNFORW: The \npointers in ALIVE that point to cells not yet modi.ed by the algorithm.  FORW: The pointers in ALIVE \nthat point to cells that have their .rst component overwritten with a pointer in NEW.  The algorithm \nproceeds by scanning all the cells in between the scan and free pointers, that is, scan always points \nto the next cell to be scanned. If the cell being scanned contains a non-pointer, then the scan pointer \nis incremented; if the cell being scanned contains a pointer p in UNFORW, then the cell pointed to by \np is copied and a forwarding pointer is placed in the original cell; if the cell being scanned contains \na pointer in FORW, then the cell pointed to has already been copied and we simply update the scanned \ncell. We use the auxiliary variables f, FORW, and UNFORW to keep track of the forwarding pointers, and \nto record the live cells that have been already copied into NEW. When a cell is copied from OLD to NEW, \nthe corresponding pointer is moved from UNFORW to FORW, and f is updated. The pointers in NEW can be \ndivided into the following three sets: FIN =Itv(o.set,scan): The pointers in NEW that have been scanned. \nThese are not modi.ed further by the algorithm.  UNFIN =Itv(scan,free): The pointers in NEW that have \nnot been scanned. These point to the original contents of cells pointed to by pointers in ALIVE.  FREE \n=Itv(free,maxFree): The pointers in NEW that are available for allocation.  The .ve sets are illustrated \nin Fig. 2. Note that FIN, UNFIN and FREE are intervals, whereas this is not the case for FORW and UNFORW \nin general. We observe that there is a one-to-one correspondence, f, between the pointers in FORW and \nthose in BUSY =FIN .UNFIN = Itv(o.set,free). This bijection will turn out to be the heap isomorphism \nwe are looking for. The invariant of the algorithm has a pure and an impure part; the latter describes \nthe heap. The pure part is Ipure = iso(f,FORW,BUSY) .(ALIVE = FORW .UNFORW) . Reachable(head,tail,ALIVE,root) \n.(ALIVE .NEW) . PtrRg(head,ALIVE) .PtrRg(tail,ALIVE) . Tfun(head,ALIVE) .Tfun(tail,ALIVE) . (#ALIVE =#NEW) \n.(root .FORW) .(scan =free) . Ptr(free) .Ptr(scan) .Ptr(o.set) .Ptr(maxFree) Note in particular the \nconjunct iso(f,FORW,BUSY) expressing that f is a bijection, and the conjunct Reachable(head,tail,ALIVE,root) \n expressing that ALIVE is the set of pointers reachable via head and tail from root, i.e., the set of \ncells that were live initially. The rest of Ipure simply records basic facts about the relationship between \nthe various sets and pointers. We now describe the impure part of the invariant; we use the parti\u00adtioning \nof pointers into sets from before. The cells pointed to by pointers in UNFORW have not been mod\u00adi.ed \nby the algorithm; hence they are described by head and tail, and we thus de.ne AUNFORW =.*y .UNFORW. \n((.z. (y,z) .head .y .z) * ''' (.z . (y,z ) .tail .y + 4 .z )). Each of the cells pointed to by a pointer \nin FORW has a forwarding pointer in its .rst component. Recalling that f records the forward\u00ading pointers, \nwe de.ne AFORW =.*y .FORW. (.z. (y,z) .f .y .z,-). A cell pointed to by a pointer in UNFIN contains \nthe original con\u00adtents of a cell pointed to by a pointer in FORW. The latter pointer is recorded by the \ninverse of f, and hence we de.ne AUNFIN = .*y .UNFIN. ((.z. (y,z) .head .f .y .z) * ''' (.z . (y,z ) \n.tail .f .y + 4 .z )). The cells in FIN have been scanned. The case-distinction between pointers and \nnon-pointers during scanning is captured by the oper\u00ad q=<..(p) Figure 3. The situation for a pointer \np in FIN ator @. We de.ne AFIN =.*y .FIN. ((.z. (y,z) .f @(head .f ) .y .z) * ' (.z . (y,z ') .f @(tail \n.f ) .y + 4 .z ')). To understand AUNFIN and AFIN, it is helpful to consider Fig. 3 in which we use a \nfunctional notation for functional relations. The pointer p . FIN is the address of the rightmost bottommost \ncell. Before p was scanned, it held the original contents of a cell pointed to by a pointer q .ALIVE. \nWhen that cell was copied, it had its .rst component overwritten with the forwarding pointer p; this \nis recorded by f, hence (p,q) . f. The original contents of the cell pointed to by q is recorded by head \nand tail, so letting q ' denote the address of the rightmost uppermost cell in Fig. 3, we have (q, q \n') . head, hence (p,q ') .head.f . Before the cell pointed to by p was scanned, it had q ' in its .rst \ncomponent. Now, by scanning the .rst component in the cell pointed to by p, we copy the cell pointed \nto by q ' (if necessary), and update the component we are scanning to point to the address of the copy \nof that cell. Denoting the address ' of the copy by q '', we then have (q ,q '') .f, by the de.nition \nof f, and therefore, (p, q '') .f .(head .f ). For the pointers in FREE, we only need to know that they \nare in the domain of the heap, to allow us to safely copy cells into FREE.We therefore de.ne AFREE =.*y \n.FREE. y .-,-. Summing up, the invariant of the algorithm is I =Ipure .(AUNFORW *AFORW *AFIN *AUNFIN \n*AFREE).  6 Proofs In this section we prove that our implementation of Cheney s gar\u00adbage collection \nalgorithm is correct. We present the key ideas of the proof and refer to the companion technical report \n[4] for further details. The proof proceeds in two stages. First we show that I from Sec. 5.2 is indeed \nan invariant, and then we use the invariant to show that the algorithm is correct in the sense of De.nition \n10. We will sometimes need to consider the iterated separating conjunc\u00adtion over one of the sets from \nSection 5.2, except for one element. We therefore, for example, write AFORW-x for the assertion .*y .(FORW \nex). (.z. (y,z) .f .y .z,-). 6.1 I is an Invariant We prove two speci.cations: {InitAss}INIT {I} and \n{I .\u00ac(scan = free)}BODY {I} , where INIT is the code before the while loop, and BODY is the body of \nthe loop. The proof of the .rst speci.cation is simi\u00adlar to part of the proof of the second speci.cation, \nand we there\u00adfore omit it. Observe that BODY consists of two similar parts, ScanCar and ScanCdr (delimited \nby comments in the code). We show the speci.cation for ScanCar, the one for ScanCdr is sim\u00adilar. After \nScanCar, the cell pointed to by scan is in a mixed state , where the .rst component is .nished and the \nsecond is about to be scanned. Therefore, the speci.cation for ScanCar is {I .scan = free}ScanCar {I \n'}, where I '= Ipure .((AUNFORW *AFORW *AFIN *AFREE *AUNFIN-scan) * (.z. (scan,z) .f @(head .f ) .scan \n.z) * ' (.z . (scan,z ') .tail .f .scan + 4 .z ')). Observe that ScanCar has three branches. We only \npresent the proof of the speci.cation corresponding to the most interesting branch, CopyCell * (delimited \nby comments in the code), in which a cell is copied from OLD to NEW. Thus, we prove the speci.cation \n{I .scan = free .scan '.x .Ptr(x) .x '.y .\u00ac(y .NEW)}CopyCell * (20) {I '} To this end, we .rst show \nthat the precondition implies the assertion x . UNFORW. Next we prove a local speci.cation for the heap \nmanipulations in CopyCell *, and .nally we apply the Frame Rule to infer the required speci.cation (20). \nThis illustrates the power of the Frame Rule. LEMMA 3. The assertion I .scan = free .scan '.x .Ptr(x) \n.x '.y .\u00ac(y .NEW) .free =maxFree .x .UNFORW is valid. Using this lemma we have the following derivation, \nthe last step of which uses (4): {I .scan = free .scan '.x .Ptr(x) .x '.y .\u00ac(y .NEW)}. {I .x .UNFORW \n.scan .UNFIN .free .FREE}. .. . Ipure . . .. .. .. . ((AUNFORW-x *AFORW *AFIN *AUNFIN-scan *AFREE-free) \n* . .. ' (.z . (scan,z ') .tail .f .scan + 4 .z ') * .(.z. (x,z) .head .x .z) * . .. . ' . . ') * . .(.z \n. (x,z ') .tail .x + 4 .z . .. (scan .-) *(free .-,-)) It is straightforward to show the following local \nspeci.cation using the rules for heap lookup (16), heap update (17), the rule for pure root scan free \nFigure 4. Footprint of CopyCell root Figure 5. Footprint of ScanCdr assertions from Remark 1, and the \nFrame Rule. . . . (.z. (x,z) .head .x .z) * . ' (.z . (x,z ') .tail .x + 4 .z ') * . . (scan .-) *(free \n.-,-) t1:=[x];t2:=[x + 4]; [free] := t1;[free + 4] := t2; (21) [x] := free;[scan] := free . . . ((x \n.free,-) *(scan .free) * . (free .t1,t2)) . . . (x,t1) .head . (x,t2) .tail We write CopyCell for the \ncode fragment in (21). Notice how the speci.cation (21) only mentions the footprint of CopyCell, i.e., \nthose locations that are either dereferenced or updated by CopyCell. This is illustrated in Fig. 4, in \nwhich the footprint is shown using dotted circles. After executing CopyCell on the heap depicted in Fig. \n4, the resulting heap is the one depicted in Fig. 5, in which the footprint of the following ScanCdr \nis shown. After the execution of ScanCdr, the resulting heap will be the one depicted in Fig. 2. From \n(21) we can continue the derivation from before. .. . Ipure . . . . . . . . . ((AUNFORW-x *AFORW *AFIN \n*AUNFIN-scan *AFREE-free) * . . . ' (.z . (scan,z ') .tail .f .scan + 4 .z ') * .(.z. (x,z) .head .x \n.z) * . . . . ' . .(.z . (x,z ') .tail .x + 4 .z ') * . . . . . (scan .-) *(free .-,-)) CopyCell (22) \n. . . Ipure . . . . . . .((AUNFORW-x *AFORW *AFIN *AUNFIN-scan *AFREE-free) *. ' (.z . (scan,z ') .tail \n.f .scan + 4 .z ') * . . . . .((x .free,-) *(scan .free) *(free .t1,t2)) . . . . (x,t1) .head . (x,t2) \n.tail) FORW := FORW .x; UNFORW := UNFORW ex; f := f .(x,free); free := free + 8 {I ''} . {I '} where \nI '' is an assertion similar to I ', which we will not state here for reasons of space. The .rst speci.cation \nin (22) follows from (21) and the derived Frame Rule (18). The proof of the second speci.\u00adcation in (22) \nuses the standard rules for assignment and the impli\u00adcation I '' .I ' uses Lemma 2. To apply Lemma 2, \none must show a few implications (see the preconditions of Lemma 2); we include one of them here: (x,free \n-8) .f .x .FORW . ((.*y .(FORW ex). (.z. (y,z) .f e(x,free -8) .y .z,-)) * (x .free -8,-)) . ((.*y .(FORW \nex). (.z. (y,z) .f .y .z,-)) * (x .free -8,-.(x,free -8) .f)) .x .FORW . (23) ((.*y .(FORW ex). (.z. \n(y,z) .f .y .z,-)) * (.z. x .z,-.(x,z) .f)) .x .FORW . .*y .FORW. (.z. (y,z) .f .y .z,-) . AFORW The \n.rst implication in (23) uses the rule for pure assertions in Re\u00admark 1. The third uses the rule (5). \nThe remaining implications needed to conclude I ' via Lemma 2 can be found in the technical report [4]. \nThis completes our outline of the formal proof of the speci.cation {I .\u00ac(scan = free)}BODY {I}. 6.2 \nSuf.ciency of Invariant We show that the invariant suf.ces to prove our implementation correct. The following \nlemma expresses that the algorithm moves all reachable cells from UNFORW to FORW. LEMMA 4. I .(scan = \nfree) .Ptr(e) .(.Ppath. eval(head,tail,P, root, e)) . e .FORW This lemma is proved using an obvious \ninduction principle for paths. The next lemma expresses that upon completion of the algorithm, FORW is \nequal to ALIVE. LEMMA 5. I . scan = free . FORW = ALIVE. This is easily shown using Lemma 4. The formal \nproof of the following theorem is a bit more involved and can be found in [4]. Informally, it expresses \nthat, when we exit the while loop, all pointers in ALIVE have been scanned and thus satisfy the condition \nthat p in Fig. 3 satis.es. THEOREM 2. I . scan = free . (e . ALIVE . (e,e1) . f . (e1 '. e2 . (e,e2) \n. f @head)). The proof of this uses Lemma 5. Finally, we can prove the main theorem of the paper. THEOREM \n3. Let (s, h) be a state such that s,h lInitAss. *' ' Then, if GC* ,s,h .s ,h ' , (s ,h ') is a garbage \ncollected version of (s,h). PROOF (sketch): We argue that for all p . s(ALIVE), h '(\u00df(p)) = \u00df*(h(p)), \nwhere \u00df = s '(f) is the relation denoted by f after execution. If r = h '(\u00df(p)), then r satis.es the \ncondition of the r in Theorem 2. ' Therefore, s ,h ' l(p,r) . f @head, and since head recorded the original \ncontents of p and @models the (-)* construction, this precisely means that r = \u00df*(h(p)). Since our speci.cation \ndoes not mention the unreachable part of OLD, we also conlude that these cells are not copied by the \npro\u00adgram; thus our implementation only copies cells reachable from root.  7 Related Work There has \nbeen several proposals for using types to manage the problem of reasoning about programs that manipulate \nimperative data structures [9, 25, 1, 20]. They are based on the idea that well\u00adtyped programs do not \ngo wrong, but they are not aimed at giving proofs of correctness. In the work [9] on capabilities, traditional \nregion calculus [26] is extended with an annotation of a capability to each region, and this gives criteria \nto decide when it is safe to deallocate a region. In the setting of alias types [25], a static notion \nof constraint is used describe the shape of the heap, and this is used to decide when it is safe to execute \na program. In the work [1] on hierarchical storage, ideas from BI [22] and region calculi are used to \ngive a type system with structure on locations. In [20] Petersen et. al. propose to use a type theory \nbased on ordered linear logic as a foundation for de.ning how data is laid out in memory. The type theory \nin [20] builds upon a concrete allocation model such as the one provided by Cheney s copying garbage \ncollector. The .rst attempt of a formal correctness proof of a garbage col\u00adlector was published in [10], \nwhere the problem was selected as one of the most challenging and hopefully, most instructive! problems \n. The proof given there is informal and merely gives an idea of how to obtain a formal proof. Other informal \nproofs were published in [3] and [21]. The fact that a mechanically veri.able proof would need all kinds \nof trivial invariants was used to justify the informal approach. Russinoff [24] explored how great a \ndetail that was needed for a formal proof and demonstrated that the proofs in [3] and [21] are fallacious. \nMoreover, Russinoff gave a correct\u00adness proof of an abstract version of a mark-and-sweep collector, which, \nhowever, did not use local reasoning. In their work on a type preserving garbage collector, Appel and \nWang [27] transform well-typed programs into a form where they call a function, which acts as a garbage \ncollector for the program. This function is designed such that it is well-typed in the target language, \nand thus is safe to execute. The approach of Appel and Wang guarantees safety, but not correctness of \nthe garbage collec\u00adtor, and there is no treatment of cyclic data structures, since the user language \ndoes not create cyclic data structures. Monnier and Shao [13] combine ideas from region calculi and alias \ntypes in their work on typed regions and propose a programming language with a type system expressive \nenough to type a garbage collector, which is type preserving, generational, and handles cyclic data structures. \nRecently, there has been a lot of work on Proof Carrying Code [16, 15]. The basic idea of a code producer \nsubmitting a proof of safety along with a program could, of course, be transferred to low-level programming \nlanguages, like the one used with separation logic. Nipkow s research group in Munich has developed a \nframework for formally verifying programs in traditional Hoare logic with arrays [12], and an extension \nto separation logic is underway. This would allow one to verify our correctness proof mechanically and \nperhaps to ship that proof along with proofs of programs using the garbage collector. 8 Conclusion and \nFuture Work We have speci.ed and proved correct Cheney s copying garbage collector using local reasoning \nin an extension of separation logic. The speci.cation and the proof are manageable because of local reasoning \nand we conclude that the idea of local reasoning scales well to such challenging algorithms. We have \nextended separation logic with sets and relations, general\u00adized the iterated separating conjunction and \nshown how these fea\u00adtures can be used to specify naturally and prove correct an algorithm involving movement \nof cyclic data structures. We believe the meth\u00adods used herein are of wider use and future work should \ninclude further experimentation with other subtle algorithms, such as those analyzed in [6] (and also, \nBornat s methods might be applicable to Cheney s algorithm). Although the goal of the paper was to prove \nthe simple variant of Cheney s collector, it is natural to ask whether the approach of this work scales \nto more complex systems where the collected data have more complex types or where the collector is of \na different type than stop-and-copy. We do not have a proof of such a collector, but we believe that \nan extension of the methodology presented here will serve as a basis for proofs of such algorithms. For \nexample, in a more complex type system, the de.nition of a heap isomorphism needs to be re.ned, and it \nis likely that this will induce new notions in the logic. Future work also includes studying how to specify \nand prove cor\u00adrect combinations of user level programs and runtime systems, as mentioned in the introduction. \nIn his work on Foundational Proof Carrying Code [2], Appel suggests compiling high-level languages into \nthe Typed Assembly Language [14]. Our work offers an al\u00adternative to this. We suggest compiling types \nfrom high-level lan\u00adguages into garbage insensitive predicates, in the sense of [7], and using our memory \nallocator and garbage collector as an implemen\u00adtation of the malloc operation of TAL. By the nature of \ngarbage insensitive predicates, we would have {P} GC {P} for these pred\u00adicates, for any correct garbage \ncollector GC, and thus predicates resulting from type-safety guarantees would be preserved by the garbage \ncollector, as desired. Acknowledgments The authors wish to thank Peter O Hearn, Richard Bornat, Cris\u00adtiano \nCalcagno, Henning Niss, and Martin Elsman for insight\u00adful discussions. Lars Birkedal s and Noah Torp-Smith \ns research was partially supported by Danish Natural Science Research Coun\u00adcil Grant 51 00 0315 and Danish \nTechnical Research Council Grant 56 00 0309. John Reynolds s research was partially sup\u00adported by an \nEPSRC Visiting Fellowship at Queen Mary, University of London, by National Science Foundation Grant CCR-0204242, \nand by the Basic Research in Computer Science Centre of the Dan\u00adish National Research Foundation.  A \nImplementation of Cheney s Algorithm alloc(l,n1,n2) { if (free < maxFree) [free]:=n1; [free +4]:=n2; \nfree :=free +8; l :=free-8 else if (o.set = startOld) then o.set :=startNew; scan :=startNew; free :=startNew; \nmaxFree :=endNew else o.set :=startOld; scan :=startOld; free :=startOld; maxFree :=endOld .; // Garbage \nCollection starts f :=0; FORW :=0; UNFORW :=ALIVE; t1:=[root]; t2:=[root +4]; [free]:=t1; [free +4]:=t2; \n[root]:=free; FORW :=FORW . root; UNFORW :=UNFORW e root; f :=f . (root,free); free :=free +8; while \n\u00ac(scan = free) // ScanCar begins x :=[scan]; if (x mod 8 = 0) y :=[x]; if (y mod 8 = 0 . o.set = y . \ny = maxFree) [scan]:= y else // CopyCell * begins t1:=[x]; t2:=[x +4]; [free]:=t1; [free +4]:=t2; [x]:=free; \n[scan]:=free; FORW :=FORW . x; UNFORW :=UNFORW e x; f :=f . (x,free); free :=free + 8 // CopyCell * \nends .; else skip .; // ScanCar ends // ScanCdr begins x :=[scan + 4]; if (x mod 8 = 0) y :=[x]; if \n(y mod 8 = 0 . o.set = y . y = maxFree) [scan + 4]:= y else t1:=[x]; t2:=[x +4]; [free]:=t1; [free \n+4]:=t2; [x]:=free; [scan + 4]:=free; FORW :=FORW . x; UNFORW :=UNFORW e x; f :=f . (x,free); free :=free \n+ 8 .; else skip .; // ScanCdr ends scan :=scan + 8 od;  // Garbage Collection ends root :=o.set; \nalloc(l,n1,n2) . } B References [1] A. Ahmed, L. Jia, and D. Walker. Reasoning about hierarchi\u00adcal \nstorage. In Proc. LICS 03, 2003. [2] A. W. Appel. Foundational proof carrying code. In Proc. LICS 01, \n2001. [3] M. Ben-Ari. Algorithms for on-the-.y garbage collection. ACM Transactions of Principles on \nProgramming Languages and Systems, 6(3):333 344, 1984. [4] L. Birkedal, N. Torp-Smith, and J.C. Reynolds. \nCorrect\u00adness of a garbage collector via local reasoning. Tech\u00adnical report TR-2003-30, The IT University \nof Copen\u00adhagen, Copenhagen, Denmark, July 2003. Available at http://www.itu.dk/English/research/publications/. \n [5] R. Bornat. Correctness of copydag via local reasoning. Private Communication, Mar 2003. [6] R. Bornat. \nLocal Reasoning, Separation and Alias\u00ading. Submitted to the SPACE 04 workshop. Available at http://www.cs.mdx.ac.uk/staffpages/r \nbornat. [7] C. Calcagno, P. O Hearn, and R. Bornat. Program logic and equivalence in the presence of \ngarbage collection. Theoretical Computer Science, 298(3):557 581, 2003. [8] C. J. Cheney. A nonrecursive \nlist compacting algorithm. Comm. ACM, 13(11), November 1970. [9] K. Crary, D. Walker, and G. Morrisett. \nTyped memory man\u00adagement in a calculus of capabilities. In Proc. of POPL 99, pages 262 275, 1999. [10] \nE. W. Dijkstra, L. Lamport, A. J. Martin, G. S. Scholten, and E. M. F. Steffens. On-the-.y garbage collection: \nan exercise in cooperation. Comm. ACM, 21(11):966 975, 1978. [11] C. A. R. Hoare. An axiomatic approach \nto computer program\u00adming. Comm. ACM, 12(583):576 580, 1969. [12] F. Mehta and T. Nipkow. Proving pointer \nprograms in higher\u00adorder logic. In Automated Deduction CADE-19, 2003. [13] S. Monnier and Z. Shao. Typed \nregions. Technical Report YALEU/DCS/TR-1242, Dept. of Computer Science, Yale University, New Haven, CT, \n2002. [14] G. Morrisett, D. Walker, K. Crary, and N. Glew. From system F to typed assembly language. \nACM Transactions on Pro\u00adgramming Languages and Systems, 21(3):527 568, 1999. [15] G. C. Necula. Proof-carrying \ncode. In Proc. POPL 97, pages 106 119, 1997. [16] G. C. Necula and P. Lee. Safe kernel extensions without \nrun\u00adtime checking. In OSDI 96, pages 229 243, Berkeley, CA, USA, 1996. [17] S. Nettles. A Larch speci.cation \nof copying garbage collec\u00adtion. Technical Report CMU-CS-92-219, Carnegie Mellon University, Pittsburgh, \nPA 15213, Dec 1992. [18] P. W. O Hearn, J. C. Reynolds, and H. Yang. Local reasoning about programs that \nalter data structures. In CSL 2001, Berlin, 2001. [19] S. Owicki and D. Gries. An axiomatic proof technique \nfor parallel programs. Acta Informatica, 6(4):319 340, 1976. [20] L. Petersen, R. Harper, K. Crary, \nand F. Pfenning. A type theory for memory allocation and data layout. In POPL 03, January 2003. [21] \nC. Pixley. An incremental garbage collection algorithm for multimutator systems. Distributed Computing, \n3(1):41 50, 1988. [22] D. Pym. The Semantics and Proof Theory of the Logic of Bunched Implications, \nvolume 26 of Applied Logics Series. Kluwer, 2002. [23] J. C. Reynolds. Separation logic: A logic for \nshared mutable data structures. In Proc. of LICS 02, pages 55 74, 2002. [24] D. M. Russinoff. A mechanically \nveri.ed incremental gar\u00adbage collector. Formal Aspects of Computing, 6:359 390, 1994. [25] F. Smith, \nD. Walker, and G. Morrisett. Alias types. In Euro\u00adpean Symposium on Programming, March 2000. [26] M. \nTofte and J.-P. Talpin. Implementing the call-by-value lambda-calculus using a stack of regions. In Proc. \nPOPL 94, pages 188 201, 1994. [27] D. Wang and A. W. Appel. Type preserving garbage collec\u00adtors. In Proc. \nPOPL 01, pages 166 178, 2001. [28] H. Yang. Local Reasoning for Stateful Programs. PhD thesis, University \nof Illinois, Urbana-Champaign, 2001.  \n\t\t\t", "proc_id": "964001", "abstract": "We present a programming language, model, and logic appropriate for implementing and reasoning about a memory management system. We then state what is meant by correctness of a copying garbage collector, and employ a variant of the novel separation logics [18, 23] to formally specify partial correctness of Cheney's copying garbage collector [8]. Finally, we prove that our implementation of Cheney's algorithm meets its specification, using the logic we have given, and auxiliary variables [19].", "authors": [{"name": "Lars Birkedal", "author_profile_id": "81100622053", "affiliation": "The IT University of Copenhagen", "person_id": "PP17010344", "email_address": "", "orcid_id": ""}, {"name": "Noah Torp-Smith", "author_profile_id": "81100531911", "affiliation": "The IT University of Copenhagen", "person_id": "P653513", "email_address": "", "orcid_id": ""}, {"name": "John C. Reynolds", "author_profile_id": "81100470240", "affiliation": "Carnegie Mellon University", "person_id": "PP39044240", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/964001.964020", "year": "2004", "article_id": "964020", "conference": "POPL", "title": "Local reasoning about a copying garbage collector", "url": "http://dl.acm.org/citation.cfm?id=964020"}