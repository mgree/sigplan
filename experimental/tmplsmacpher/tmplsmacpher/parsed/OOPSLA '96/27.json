{"article_publication_date": "10-01-1996", "fulltext": "\n Architecture-Oriented Visualization Mohlalefi Sefika Aamod Sane and Roy H. Campbell Department of Mathematics \nand Computer Science National University of Lesotho P. 0. Roma 180, Lesotho Southern Africa Abstract \nTracking the changing dynamics of object-oriented frameworks[5], design patterns[7], architectural styles[8], \nand subsystems during the development and reuse cycle can aid producing complex systems. Unfortunately, \ncurrent object-oriented programming tools are relatively oblivious to the rich architectural abstractions \nin a system. This paper shows that architecture-oriented visualiza-tion, the graphical presentation of \nsystem statics and dy-namics in terms of its architectural abstractions, is highly beneficial in designing \ncomplex systems. In addition, the paper presents architecture-aware instrumentation, a new technique \nfor building efficient on-line instrumentation to support architectural queries. We demonstrate the effec-tiveness \nand performance of the scheme with case studies in the design of the Choices object-oriented operating \nsys-tem. Introduction Designers conceive complex systems as architec-tures with design patterns[7], \nframeworks[SJ, architectural styles[8], and subsystems. As the system evolves, they cus-tomize these \nlarge-grained components, tune performance, and make reuse decisions. Such complex tasks require un-derstanding \ncomponent behavior, tracking resource usage, and detecting integration problems. Program instrumenta-tion \nand visualization tools that support analysis directly in terms of higher-level, architectural abstractions \nwould markedly simplify these activities. Permission to make digital/hard copy of part or all of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor profit or commercial advantage, the copyright notice, the title of the publication and its date appear, \nand notice is given that copying is by permission of ACM, Inc. To copy otherwise, to republish, to post \non servers, or to redistribute to lists, requires prior specific permission and/or a fee. OOPSLA 96 CA, \nUSA Q 1996 ACM O-89791 -788-x/96/001 0...$3.50 Department of Computer Science University of Illinois \nat Urbana-Champaign Urbana, IL 61801 (sane,roy)@cs.uiuc.edu http:Nchoices.cs.uiuc.edu Most conventional \nobject-oriented software analysis tools, however, provide dynamic inspection primarily in terms of lower-level \nunits like classes, instances, and methods[l9, 20, 14, 15, 17, 121. Many, rich architectural abstractions \nwith a granularity that is larger than an object or class are opaque to such tools. Recent research[24,5,7] \ndemonstrates the value of gross architectural structures in the design, evaluation, and reuse of complex \nsystems. In our own studies of the customization of the Choices[4] object-oriented operating system, \nwe often needed answers to questions like: . How many times does this application process visit the file \nsystem? . Is this lock currently in use by any subframework of the virtual memory system? . Which subframework \nof the virtual memory system communicates most frequently with the file system? It is difficult to answer \nsuch architecture-level ques-tions using traditional programming tools for several rea-sons. First, flat \nmethod-level instrumentation generates too much data and excessively perturbs the system. Sec-ond, the \nmore abstract features of the software architecture of the system are opaque to instrumentation, making \nit hard to identify and control instruments associated with specific architectural entities. Third, architectural \ninvestigations often involve system analysis at multiple levels of abstrac- tion and different aspects \nof design. It is arduous to track and correlate such information with current instrumenta-tion systems \nas they seldom support multiple perspectives or aid in hierarchical system navigation. This research \ndemonstrates that architecture-oriented ui-sualization, the graphical presentation of system statics \nand dynamics in terms of its architectural abstractions, makes it considerably easier to understand and \ncustomize complex systems. Architecture-oriented visualization permits the same logical components that \nstructure the overall system *design to also serve as the fundamental units of anima-tion, offering scalable \nhierarchical inspection and multiple code perspectives. We demonstrate the utility of our visu- alization \ntechnique with real-world case studies from the Choices operating system. To address the deficiencies \nof traditional instrumenta- tion, we introduce architecture-aware instrumentation. A distinctive feature \nof architecture-aware instrumentation is that it explicitly represents architectural structures and sub- \nstructures in a running system, and exploits this knowledge to optimize instrumentation. We present performance \ndata that shows that an architecture-aware instrumentation dra- matically reduces trace data size and \nintroduces far less overhead than traditional, unstructured instrumentation. Overview Architecture-oriented \nvisualization enables the analy-sis of an object-oriented system in terms of its conceptual organization. \nObject-oriented systems are aggregates com-prised of subsystems, frameworks, patterns, classes, and objects. \nFor example, the Choices operating system is an assembly of subsystems like Process or Virtual Memory, \nwhere each subsystem is further subdivided into frame-works like the PhysicaI Memory or Logical Memory \nframe-work. In turn, each framework is organized as a collection of design patterns, class hierarchies, \nand classes. With architecture-oriented visualization, we can inspect system dynamics structured in terms \nof these architectural com-ponents. We can observe architecture-level properties like visits to the virtual \nmemory subsystem by a process , where we wish to observe interactions between the archi- tectural units \nprocess and virtual memory subsystem . We begin the paper with case studies that show that architecture-based \nanalysis arises naturally when working with large, complex systems. Our first case study (Section 3) \ndemonstrates how hier- archical and recursive visualization of the Choices system can identify the cause \nof a system-wide performance bottle- neck that reduces CPU and disk utilization. To investigate the problem, \nwe begin by querying statistics at the system level. We identify the virtual memory subsystem as a can- \ndidate for further examination. We then trace the internal details of this subsystem by zooming into \npossible prob- lematic frameworks, class hierarchies, classes, and object instances. The second study \n(Section 3.1) concerns a problem in subsystem cohesion and coupling that showed up during a routine \ncheck that we apply after every major change in system design[23, 211. The check tracks subsystem interactions \nat the subsystem-, framework-, class-, and method-levels and reveals significant architectural changes \nthat could indicate flaws in the modifications. The check is essentially a conformance test and is feasible \nbecause architecture-oriented visualization simplifies the process. Before we developed our visualization \ntools, we would of-ten be unaware of any architectural consistency problems until they affected correctness. \nIt is difficult and time con-suming to identify such problems by hand. In each study, we use information \nfrom higher levels to select lower-level components for further study. The system offers many graphical \npresentations, each suitable for viewing behavior at some abstraction level. When we want aggregate, \nrelative statistics, we use diagrams like bar charts and ternary diagrams[9]. When the information must \nbe correlated to the system structure, we use space- filling diagrams[2] that make it easy to relate \nthe run-time statistics to the relevant system parts. When we have to display pair-wise component interaction, \nwe use af/inity diagrams[23] and object interaction diagrams[3]. At each point, the user may choose from \na palette of possible di- agrams. Our system also supports multiple simultaneous diagrams and combined \nstatic and dynamic perspectives. Moreover, the diagrams are hyperlinked to one another so that information \ndisplayed on the screen can be easily used to guide system navigation. The queries used in the case studies \nmotivate the de-sign of architecture-aware instrumentation (Section 4). Architecture-aware instrumentation \nis cognizant of the soft- ware architecture of the system. The instruments gather data in a task-specific \nmanner so that data processing and manipulation is minimized. Moreover, the instrumentation run-time \nexploits knowledge about the architectural units of the system to condense data right where it originates. \nOur performance studies (Section 5) exhibit the dramatic difference between instrumentation that optimizes \ndatacol- lection on a per-architectural model basis versus one that does not. In the paper, we describe \nparts of the instrumentation architecture in terms of the design patterns used in build- ing the system. \nWe also present a simple query language (Section 4.5) for the architectural queries supported by the \ninstrumentation. 3 Case Study 1: Performance debugging This case study shows how architecture-oriented \nvisual-ization helps in identifying subtle performance bottlenecks starting from problem symptoms that \nare manifest at the system level. In one version of the Choices system, we discovered that CPU utilization \nwas reduced by 8% and disk utilization by 14%. Many parts of the system had been changed between Figure \n1: Animated process locking activity in four subsystems. The length of a bar changes to reflect the number \nof processes currently blocked in the corresponding subsystem. versions, so the cause of the degradation \nwas unknown. In examining process statistics, we discovered that the average time for which both system \nand application processes were blocked had also increased. Consequently, one possibility was a synchronization \nproblem somewhere in the system. We report the steps in our investigation below. . Subsystem: We first \ninvestigated relative process blocking across four Choices subsystems: the naming system (NS), file system \n(FS), devices system (DS), and virtual memory system had been altered in producing Figure 1 depicts processes \nsubsystem in a bar chart. (VM). These subsystems the latest version. that are blocked in each The length \nof each bar changes to reflect the number of processes currently blocked in the corresponding subsystem. \nThe dia-gram can also display a running numerical average. From the figure, it appears that on the average, \nthe virtual memory system blocks the largest number of processes. . Framework: Now we want to see which \ninternal sub-parts of the virtual memory subsystem block the pro- cesses. We select the VM bar from Figure \n1 to get the space-filling diagram[2] of Figure 2. The diagram depicts the virtual memory subsystem frameworks \nand their class hierarchy components, with filled rectangles indicating the relative number of processes \nblocked. The class hierarchies are rep-resented by rectangles whose size is proportional to the number \nof classes in the corresponding hierarchy. A rectangle label shows the most abstract class in the hierarchy. \nWe observe five frameworks: address space management (Fl), logical memory (F2), ad-dress translation \n(F3), physical memory management (F4), and caching support (F5). From the figure, it is immediately obvious \nthat the MemoryObject class hi- erarchy of the logical memory framework is currently blocking most processes. \n0 Class Hierarchy: Clicking on the MemoryObject re-gion displays Figure 3. This space filling diagram \nshows some classes in the MemoryObject hierarchy separated by thick black lines. The inner squares depict \nper-class instances. Filled squares indicate the specific instances that are blocking the processes. \nThe figure reveals that instances of MoView (MemoryOb-jectView) are blocking most processes. A MemoryObjectView \ndenotes a contiguous set of memory locations or region within a memory object and allows the data in \nthe physical pages of that region to be pinned in place so that they cannot be paged out. The I/O system \nuses the MemoryObjectView to move data between a disk and a memory object. The framework supporting caching \nhad been changed to use disk I/O in units of 64 KJ3. However, the MemoryObjectViews still supported I/O \nFigure 2: A zoomed view of the virtual memory system. The diagram reports process blocking stati sties \nin terms of subframeworks, inheritance structures, and classes, making it straightforward to relate the \nstatistics to thr : relevant system components. Figure 3: A zoomed view of theMemoryObject inheritance \nstructure. The diagram highlights the particular classes and instances where processes are blocked. in \nterms of 4KB pages. This mismatch led to a fragmen- tation of I/O across numerous small MemoryObjectViews, \nso processes waited for a long time to complete their I/O. Modifying MemoryObjectView code to use the \nlarger sizes reduced process blocking and improved CPU utilization by 5% and disk utilization by 10%. \nDiscussion The above case study shows how architecture-oriented inspection helps navigate a complex system \nto uncover subtle performance bottle-necks. We used both system-level views and lower-level views to \ndiscover indirect side-effects in the logical memory framework caused by customizing the neighboring \ncaching support framework. Architecture-aware instrumentation enabled us to track the dynamics of both \ncoarse grain and fine grain components until we identified one major cause of system-wide performance \ndegradation. 3.1 Case Study 2: Evaluating design properties Architecture-oriented visualization makes \nit easier to check complex interactions of components and subsystems. We exploit this facility to routinely \ncheck the design prop-erties of Choices after every version[23, 211. This case study considers an instance \nwhere we recognized and re-paired undesirable subsystem couplings during our system evaluation. . Subsystem: \nThe ternary diagram[9] in Figure 4 por- trays relative communication between four device driver frameworks \nand three subsystems: the naming system, the remote procedure call (RPC) system, and the device driver \nsystem. The diagram helps quickly compare the degree of interaction among each frame- work and the three \nsubsystems. A Framework is ani- mated as a moving circle. During the animation, the Figure 4: A ternary \ndiagram animating the degree of com- munication between device driver subframeworks and three subsystems. \n framework drifts towards the subsystem(s) it is cur-rently communicating heavily with. From the snap- \nshot, we observe that the Device config framework communicates intensively with the devices system, with \ncommunication ratio nearly 1. This gives a high degree of confidence that the Device config frame-work \ninteracts most with its own subsystem com-ponents. But the Devices framework communicates more with the \nremote procedure call (RPC) subsys-tem than with its own Device Driver subsystem. This coupling is probably \nundesirable. Framework Details: To examine the details of the suspicious communication, we click on the \nDevices framework circle and the RPC system axis to generate an affinity diagram[23] that shows how the \nframework and the subsystem components interact. In Figure 5, classes attract each other if they communicate \nfre-quently, otherwise they repel. The higher the com-munication between two classes, the thicker their \ncon-necting lines. The line arrows indicate the direction of calls. For the most part, the framework \nand the sub- system appear to be cohesive: intra-component inter-action is much greater than inter-component \ninterac-tion. However, Disk and RpcBuffer exhibit anoma-lous, heavy communication. Class Interactions: \nTo understand the unusual inter-action, we click on the thick arrow, generating the ob- ject interaction \ndiagram[3] of Figure 6. This diagram portrays a trace of method calls between instances of Disk and RpcBuffer. \nThe diagram statistics indi-cate that the method getState() is called with high frequency on the Disk \nobject. Code inspection revealed that getState was initially used for debugging RPC data buffering to \nand from disk (for example, for long-lived client/server connections ex-changing very large data). Therefore, \nsome RPC related state was kept in Disk. Unfortunately, this debugging re-lated implementation decision \nperpetuated in the final RPC system implementation, creating undesirable system-level dependencies. We \nremoved the erroneous coupling by fac- toring the state properly to the RpcBuffer. Figure 7 shows the \nternary diagram animation that results after correcting our design flaw. Now all the device subsystem \nframeworks communicate mostly with device subsystem components, giving a high degree of confidence that \nthe subsystem main-tains high cohesion and low coupling.  4 The design of architecture-aware instru-mentation \nWe need architecture-aware instrumentation to support various dynamic analysis tasks as exemplified in \nour case Figure 5: An affinity diagram animating the interaction between the Device subframework and \nkey classes of the RPC system. studies. The requirements for the instrumentation system are driven by \nthe information demanded by both low-level and architecture-level queries, We will derive these re-quirements \nby referring to the needs of the visualization experiments in the last section. Consider Figure 4 where \nwe examine the dynamic inter-action between selected frameworks and subsystems. To capture such interactions \nefficiently, the instrumentation system must activate only those specific Choices instru-ments dedicated \nto the objects of the target frameworks and subsystems. Thus, out of a very large number of instru- ments \nin the operating system, the instrumentation system must be able to name and identify those particular \ninstru-ments belonging to the few subsystems and frameworks of interest. This leads to our first requirement: \n. Requirement 1: The instrumentation system must know how instruments are associated with architec-tural \ncomponents. Next, observe the affinity diagram of Figure 5, where we narrow our focus of attention to \nthe Devices framework and the RPC system interactions. At this point, the instruments belonging to the \nnaming system and the other frameworks must be deactivated to reduce unnecessary system pertur-bation. \nThus we have: Figure 7: A typical ternary diagram animation after debug- ging the unwanted couplings. \nFigure 6: Animated object interactions among Disk and RpcBuffer objects. . Requirement 2: The system \nmust support dynamic control of groups of instruments associated with ar-chitectural units. Going back \nto the ternary diagram in Figure 4, to place the framework circles, we have to count the number of calls \nbetween specific frameworks and subsystems. We certainly cannot afford to send data about every call \nto the visualizer. Instead, we want to accumulate the number of calls in one running counter per pair \nof framework and subsystem. In general, we require that: . Requirement 3: The system must accumulate \naggre-gate statistics based on the architectural models. In the course of our experiments, we switch \nbetween ab-straction levels, selectively collecting data about classes, frameworks, or subsystems. But \nthe events are actually detected by per-method event sensors, so depending on our level of abstraction, \nwe may want the same sensor to update a class, framework, or subsystem instrument. Therefore, . Requirement \n4: Event sensors must be dynamically bound to instruments. In addition, we have the generic instrumentation \nrequire-ment . Requirement 5: Minimize system time and space perturbation. Traditional instrumentation \ndoes not have enough run-time information about the system structure to meet our re- quirements. For \nour first two requirements and their exam-ple uses, it will be probably impossible to efficiently name, \nselect, and animate a specific group of instruments belong-ing to a large architectural unit like an \nRPC system. The reason is because conventional instrumentation does not have knowledge about the decomposition \nof the system into its architectural components. Consequently, component-driven identification or regulation \nof instruments would be unduly difficult in real time. Similarly, the third requirement would be extremely \ndif-ficult to meet because there are no means to identify the particular objects belonging to a given \narchitectural unit. The fourth requirement is unnecessary unless multiple lev-els of abstraction are \nsupported. An alternative approach simply gathers all the data and then filters it to choose data packets \nof interest. This ap-proach, however, entails considerable I/O traffic to send the data to the visualizer \nand adds more time to filter the data. It would be better suited to post-mortem processing. 4.1 The instrumentation \narchitecture Figure 8 shows the gross design of the architecture-aware instrumentation system. We explain \nthe design by showing how event sensors detect interesting events and notify instruments, and how the \nsystem interprets inter-active user queries to collect data or control instruments. The requirements \nmet by each component are indicated in parentheses. Consider a query that generates the affinity diagram \nof Figure 5. The user specifies the framework and subsys-tem to be observed, and the visualizer formulates \na query to count inter-class method calls. The Querylnterpreter maps the framework and subsystem to the \ninstruments (Re-quirements 1 and 2) and triggers the InstrumentManager (Requirement 2) to activate all \nthe relevant instruments. The manager tells the instruments to count every inter-class call (Requirement \n3). Another data path through the architecture begins with EventSensors. Event sensors are selectively \nactivated by the InstrumentManager according to the query. They are triggered upon method entry and exit \nand generate event no- ti$cations, rather like printf debugging statements. The sensors report to the \nEventAnnouncer which directs the event notification to the instrument defined by the query (Requirement \n4). The instrument will take action accord-ing to its mode, either count the call, keep time, or maintain \nhistory. To complete query processing, data collected by the in- struments must be displayed. The QueryInterpreter \norders a DataCollector to collect method calls statistics for every pair of objects at regular time intervals. \nThe DataCollector sends data packets back to the Visualizer. In this architecture, the primary design \ndecisions are: . How should the query interpreter map architectural units to their instruments. . How \nshould Instrument managers control the instru- ments. . How might data collectors visit instruments to \ncollect data. . How should events be directed to the interested in-struments. Two primary forces govern \nthe system design. First, the system must incur low space and time overhead. Second, the system must \nbe flexible, in that the user should be able to orthogonally change instrument organization/management \nand data collection strategies. We present our design com-ponents as triples of Problem, Solution, and \nConsequences. Some components are instances of well-known design pat-terns, while others are specific \nto our system. Instruments either count, keep time, or maintain history. EventSensor I--.- I I ~ EventAnnouncer \n/ ! 1-  I ~---~- r / Querylnterpreter  User queries / from Visualizer I -L-----+ --*r-  I DataCollector \n id----...-.---.-.---..~ -.~ Data packets -i  to Visua/i~er i----..-.-----1 Informationflow direction \nb Figure 8: The components of architecture-aware instrumentation and the way they interact.  Sys tern \nChoiceslnstrument i J A Subsystem Processlnstrument : Framework Pattern LCachingMediatorlnstrument \n1 ;pagingStlategylnstrument 1  -A :  (___i___ ? Class ~MOCachelnstrument Object RootMOCachelnstrument \n] i Method Figure 9: A possible hierarchical instrument object structure in running Choices. 397  \n4.2 Architecture-directed organization of instru- ments . Problem: We want to associate system architectural \nunits with instruments. Clients of the instruments (e.g., data collectors and instrument managers) should \ntreat both ag-gregate and primitive instruments uniformly for simplicity. . Solution: Werepresent the \nhierarchical architectural com-ponents of the system with a corresponding hierarchy of instruments as \nin Figures 9 and 10. The hierarchy is built using the COMPOSITE[7] pattern. . Consequences: Using the \nCOMPOSITE-based design, it is transparent to the client code whether it is accessing aggregate instruments \nlike a Subsystem or primitive in-struments like a Method. Thus, client programs become independent of \nthe granularity of an instrument. In this way, the design achieves architecture-awareness without compli-cating \nthe program code that uses various instrumentation levels. We also have a natural data structure to support \ndata accumulation and organization within the instrument objects themselves -the composite structure. \nSince the architectural units are directly represented in the instrument hierarchy, and since all instruments \nare uni- formly accessible, mapping the units to their instruments is highly efficient. A drawback is \nthat we need run-time checks to enforce the containment constraints Subsystem > Framework > Pattern > \nClass > Object > Method. The respective in-struments must honor this ordering. 4.3 Navigating and controlling \ninstruments . Problem: The instrument managers and data collectors have to traverse the collection of \ninstruments to initiate, control, or terminate data collection. For fast response, traversal policies \nshould be tailored to queries. Moreover, the traversal strategy and instrument organization must be orthogonal \nso that either might be changed independently. For instance, a user might want to use the same traver-sal \nstrategy over multiple abstraction levels, or to rely on customized navigation policies for individual \nlevels. . Solution: We separate the responsibility for traversing the instruments in an ITERATOR[T] object. \nEach iterator has a specialized algorithm for traversing its collection of instruments. . Consequences: \nIterators know the details of the collec- tion, but the instrument managers and data collectors are isolated \nfrom those details. But the collection of instruments may grow and shrink as objects are created and \ndestroyed, so we must ensure that iterators know about these changes and adjust themselves. Luckily, \nthe instrumentation system considers object dele-tion and creation events to be significant, so the events \nare intercepted and used to keep the instrument Composite and Iterators consistent. 4.4 Dynamic binding \nof eventsensors to instru- ments . Problem: When switching abstraction levels, we want to bind event \nsensors to target instruments dynamically without undue effects on efficiency. . Solution: We exploit \nthe fact that classes (and hence objects) that contain the sensors themselves do not change their architectural \nunits dynamically. For every object (and sensor) we can statically determine a list of instruments, one \nfor every level of abstraction. Thus, we only have to indicate the level of abstraction to a sensor, \nand it can dispatch the data to the right instrument. We introduce an intermediate EventAnnouncer object \nthat knows about the abstraction level for data collection. The sensors report the event and their list \nof instruments to the announcer, and the announcer uses the abstraction level to select the right instrument. \n. Consequences The binding of sensors to instruments can be switched by visiting the announcer and changing \na single field that indicates the instrument at the desired level of abstraction. A single indirection \nsuffices to achieve this binding without significant impact on efficiency. More details of the instrumentation \nsystem organization can be found in [21]. 4.5 Queries The instrumentation and visualization system supports \nqueries about architectural concerns and their interactions. Figure 11 expresses our query syntax in \nBackus Naur form (BNF)[l]. We illustrate the language with examples from the previous case studies. . \nFrom Figure 1, the user displays all the processes that are currently blocked in the virtual memory system \nusing: ProcessClass kindreds -r state = blocked; blockingsystem = VmSystem;  display . From Figure 2, \nthe user disables all the logical mem-ory framework instruments:  LogicalMemoryFramaork subparts -r \ndeactivate . To monitor calls from the file system to the virtual memory at the subsystem-level, the \nuser enters the two queries: ~~insfrumen7 _~---.----~~~ ~ acfivafe() -1 ~ deacfivafe() / ~--.----L \n=JEvenri) 1 ~ changeFreq() ~ changeState ---~-~-~-. .- ~ flushLog : addChild I removeChild() ---.l \nI Methodlnstrument Compositelnstrument ~ I activate0 . . . changeState() activate0 1 flushLog() .,. \ni addChild ~ removeChild() I  ~ Objectlnstrument Patternlnstrument Frameworklnstrument 7 activate0 \nactivate0 . . . addChild addChild removeChild() removeChild() removeChild() -A ---..l Subsystemlnstrument \nlnterfacelnstrument I ~ Systemlnstrument activate0 activate0 , 1 activate0 . . . addChild . . . addChild \n/ . . . addChild removeChild() removeChild() I removeChild() b_ Legend: O--------t --*. , ,>- part \nof inhektance one to many Figure 10: Organizing aggregate and simple instruments for uniform accessibility \nby the client code. <Query> : := <Component> [<Selector>] <InstrumentOperation> <Component> ::= <System> \n1 <Framework> 1 <Pattern> 1 <Class> 1 <Object> 1 <Method> <System> : := system-name / * similarly for \nFramework, Pattern, Class, Object, and Method components * / <Selector> ::= <RelatedComponent> [<Per-component-state-descriptor>] \nI <Property-list> ) <BasicInstrument> iRelatedComponent> ::= subparts [<Abstraction-level> I -r] I aggregator \n[<Abstraction-level> I -rl I <ClassHierarchyr I <ClassInstances> ) <OtherRelation> <Abstraction-level> \n::= system-level I framework-level I pattern-level I class-level I object-level I method-level I <AbstractionUnit> \n<AbstractionUnit> ::= -zComponent> <ClassHierarchy> ::= ancestors [<Depth> I -r] 1 descendants [<Depth> \nI -rl 1 whole-hierarchy ( children <ClassInstances> ::= kindreds [<Depth> ( -r] I members <Depth> ::= \ninteger <OtherRelation> ::= caller [<Abstraction-level>] I callee [<Abstraction-level>] I creates [<Abstraction-level>] \nI deletes [<Abstraction-level>] I etc. <Per-component-state-descriptor> ::= [instrument-state-var <Comparison> \nvalue;]+ <Comparison> ::=  =l#l<l> <Property-list> ::= any I all / <Per-component-state-descriptor> \n<BasicInstrument> ::= counter I timer <InstrumentOperation> ::=  activate I deactivate I display I reset \nI count I etc.  Figure 11: A partial description of our query language in Extended BNF notation. VmSystem \nsubsystem-level activate VmSystem caller FileSystem count o To display the global counter instrument \nof the virtual memory system, the user enters: VmSystem global-counter display In most cases, the user \nneed not explicitly enter a query. The visualizer translates the users selection into the appropriate \nquery. However, we also allow the user to directly enter queries when necessary.  Performance evaluation \n Architecture-aware instrumentation improves upon con-ventional instrumentation in the following ways: \n. It exploits run-time knowledge about the system struc-ture to condense the amount of data it collects, \ncon-serving space. Condensation also decreases traffic to the visualizer and the need for data analysis. \n. It selectively enables instruments and event sensors in a query-specific manner, reducing the amount \nof data collected. . The instrument organization directly reflects the sys- tem structure, therefore \ndata about system compo-nents is quickly located. The first two improvements reduce the net amount of \ndata generated by architecture-aware instrumentation. To-gether, the three improvements reduce the timing \nover-head of instrumentation. In the following, we substantiate these claims by comparing traditional \ninstrumentation with architecture-aware instrumentation as regards the amount of data generated and the \nexecution overhead introduced by instrumentation. Traditional instrumentation maintains per-method instruments; \nthese instruments may be counting or timing events. In our system, method-level instruments are simply \nthe lowest instrumentation level. We conducted our performance studies on the Choices operating system \nrunning on a Sun SPARCStation 2. We collected all the numbers from the virtual memory system. This system \ncomprises 50 classes and 625 object methods. Of the 50 classes, 20 are abstract interfaces visible to \nthe neighboring systems (e.g., the file system). We ran a distributed remote procedure call (RPC) server \n as our test application. A client exercises the server by making RPCs that transfer an array of 256Kb \neach. While this application was executing, we gathered instrumenta-tion data for the query How many \nmethods of the vir-tual memory system were called by the file system? 2. The instrumentation data packets \nand execution times were measured over five second intervals. 5.1 Data generation Figure 12 compares \nthe number of data packets gen-erated by flat instruments and architecture-aware instru-ments for execution \nstatistics at different levels of detail. All data packets are of the same size. Each packet en-codes \na component identifier, a cumulative call count, and meta-information needed by the visualizer to unmarshal \nthe packet. In the performance display graph of Figure 12, the dotted bars depict trace data generated \nusing traditional instrumen-tation [15, 14,20, 19, 12, 161. Here, data packets are gener- ated on a per-method \nbasis; every data packet includes in-formation about the method that was called. Consequently, the number \nof packets equals the number of methods called regardless of the granularity of system modeling. The \nsolid bars display data collected using architecture-aware instrumentation. The query about aggregate \nsubsys-tem statistics generates a single data packet from a sub-system level instrument that keeps a \nrunning count of the method calls. If we expand the query to find the number of method calls per framework, \nclass, or method, the number of data packets increases proportionally. Thus, we exploit the knowledge \nof the virtual memory system embedded in the instrumentation system to reduce the trace data size substantially \nduring high level analysis. 5.2 Instrumentation overhead Architecture-aware instruments reduce system \nperturba-tion because (1) they reduce the data and hence the time for data collection, (2) the instrumentation \nsystem can se-lectively enable instruments depending on the components mentioned in a query. We characterize \nthe two situations with Figure 13 and Figure 14 respectively. We consider the execution time for four \nkey operations in the virtual memory system: handling page faults (repairFault ( ) ), creat- ing address \nspaces (domaincreate ( ) >, adding memory objects to address spaces (addMo ( ) ), and removing mem-ory \nobjects from address spaces (removeMo ( ) ). Figure 13 compares the execution times of the four op-erations \nwith and without instrumentation, and shows how normal execution is slowed down by instrumentation. For \nexample, repairFault is slowed down by 14% due to method-level (i.e., traditional) instruments, while \nsystem-level instruments only slow the operation down by 1%. In This query helps evaluate the degrees \nof subsystemcohesion and coupling as in Section 3.1.  Number of event packets: Flat v/s Architecture-Aware \nInstrumentation 300 250 200 Number of 150 data packets 100 50 : I nl I i 0 System Framework Class Method \nLevel of system modelling Figure 12: A comparison of flat versus architecture-aware instrumentation in \nproviding cumulative statistics of the Choices virtual memory system. Architecture-aware instrumentation \ndramatically reduces the trace data size as the level of system abstraction increases. this study, we \ninstrument the system at successively lower ily, most of the code for architecture-aware instruments \nwill instrumentation levels, each time collecting execution per-remain dormant in the system until explicitly \nneeded. We turbation statistics for each operation. feel that system size growth is an acceptable tradeoff \ngiven Figure 14 compares the performance of instrumentation the significant benefits to be gained by \nusing instruments that can enable during run-time instruments for a specific that understand the structure \nof the system, and given the framework versus one that cannot. We consider the execu- consistent trend \nof falling memory prices. tion overhead of the same four operations, first with all the method-level \ninstruments of the entire virtual memory sys-tem enabled, then with only the method-level instruments \n 6 Related research of the caching framework of this system enabled. The sec-ond case applies to flat \ninstrumentation where selective, Current dynamic visualization tools for object-oriented framework-based, \ndynamic control of instruments is diffi- programs appear to focus on animating class, object, and cult \nbecause the relevant instruments are difficult to name. method interactions[l9,20, 131. ProgramExplorer[l4, \n151, Again, it is clear that enabling few instruments reduces Pattern-Lint[23], and OS View[22] are some \nof the new sys- system perturbation due to instrumentation. tems that visualize architecture-level concepts \nlike frame- works and design patterns. However, the granularity of sys- Remark The above performance \nstudies show that tem depiction is still classes, objects, and methods. No sys- architecture-aware instrumentation \nis more efficient for tem that we know supports dynamic architecture-oriented supporting architecture-level \ninvestigations of running pro-visualization, where the graphical presentations of the run- grams. The \ncost of traditional instrumentation is simply ning system directly map to architectural abstractions \nlike too high when inspecting higher-level events, partly due to frameworks. poor information abstraction \nor condensation, partly due to Previous research on object-oriented program visual-the lack of adaptiveness. \nization has concentrated more on trace data organization Architecture-aware instrumentation, however, \nis not than on structuring the instruments that gather the data. In completely without cost. It increases \nthe size of the ap-ProgramExplorer[l4], the data is collected into a Prolog plication more than flat \ninstrumentation due to the addition database. In ObjectVisualizer[20], multi-level hash tables of more \ncode for query processing and instrument manage-organize the data, supporting data accumulation, albeit \nonly ment. In the above experiment, the Choices system exe-on a per-method basis. cutable, compiled with \na GNU gee compiler, was 14.3% Structured instruments were exploited in a limited man-bigger (worst case) \nwith architecture-aware instruments, ner in the Choices operating system[4]. Madany uses ob-but only \n7.8% bigger with conventional instruments. Luck-jectified C++ classes, called first-class Classes, to \nexam- Timing dilations on some key VM operations at various instrumentation levels 16 I I I I * System \nKY--i 14 -* Framework !+. r Class la-l 12 -9+ Method iX - : * 10 -Percentage execution 8t -I slowdown \n6 repairFault addMo removeMo domaincreate VM operation Figure 13: A comparison of the increase in execution \ntime introduced by various instrumentation levels. The higher the instrumentation granularity, the less \nthe timing perturbations. Timing dilations on some key VM operations: A comparison of adaptive versus \nnon-adaptive instrumentation 16 , I I I I Adaptive - Non-Adaptive repairFault addMo removeMo domaincreate \nVM operation Figure 14: A comparison of adaptive versus non-adaptive instrumentation. ine the run-time \nstructure and behavior of the operating system. Classes provide run-time type information, en-abling \nthe querying of class inheritance and class instance relations among objects. Instruments that are related \nby inheritance can be controlled in groups dynamically. How-ever, the instrument selection is purely \nbased on class type information[lO]. This introspection scheme does not go beyond the class level, nor \ndoes it explicitly represent re-lations among instruments other than Classes. A similar class-based approach \nis adopted by De Pauw et al.[19]. Snodgrass[25] presents a method for monitoring pro-gram execution in \nwhich a programmer uses relational alge-bra queries to track run-time dynamics. The scheme is more tailored \nfor data organization (using a conceptual, temporal database) than instrument organization. Snodgrass \ninstru-mentation is mainly targeted towards distributeddebugging and monitoring, not on analyzing the \nsoftware architecture of the system. Other related research includes work on computational reflection. \nWhile rich structures and meta-level architec-tures for reflection have previously been defined[ 18, \n11,6, 261, issues in the explicit representation of gross architec-tural abstractions appear to be under \nemphasized because the problems being investigated are different. In this paper, we discussed one way \nto reify system architectural units and subunits, and showed how to use the reified representations to \noptimize instrumentation. Conclusions Software visualization and instrumentation tools have traditionally \nrecognized classes, objects, methods, or func- tions as the basic units of analysis and animation. However, \nresearch in software architecture suggests that the more im-portant reusable components for complex systems \nare likely to be higher-level aggregates of collaborating classes such as frameworks, design patterns, \nor subsystems. With the increasing emphasis on composing systems out of large- scale components, programmers \nneed tools that elevate the granularity of analysis for operational software systems to the architecture \nlevel. In this paper, we have demonstrated through real-world case studies that architecture-oriented \nvisualization greatly simplifies structural analysis, behavioral study, and perfor- mance measurement \nof complex object-oriented systems. We have illustrated that this technique is effective in offer- ing \nscalable views of a large system, and in modeling run-time dynamics hierarchically at varying component \nlevels. Not only do we advocate the visual examination of work- ing software systems in terms of their \nconceptual architec- tural units, but we also introduce a practical instrumentation technique to support \nsuch investigations. The technique is called architecture-aware instrumentation. A distinc- tive feature \nof architecture-aware instrumentation is that it explicitly represents composite architectural structures \nin a running system and exploits this knowledge to abstract run-time information. Performance studies \nindicate that instrumentation that optimizes data collection on a per-architectural model basis generates \ndramatically less trace data and introduces far less overhead than flat, unstructured instrumentation. \nFor example, a page fault handling operation ran 13% faster with subsystem-aware instruments, an operation \nto add memory objects to address spaces ran 11% faster, an operation to delete memory objects from address \nspaces ran 10% faster, and an operation to create address spaces ran 14% faster. This indicates that \nthe system-level per-turbation effect of an architecture-aware instrumentation is substantially less \nthan that of traditional instrumentation. This work opens several avenues for future research. One interesting \napproach involves merging our system with a code refactory that would automate design repair: use vi-sualization \nto identify problems, and then use the refactory to correct them. Another possibility employs our instru-mentation \ntechniques to gather statistics about component interactions and use them in an optimizing compiler. \nWe are using the system in a project to build customizable in-frastructures for distributed objects, \nwhere the system will be extended for visualization of distributed systems. An-other area of interest \nconcerns the integration of our system with programming tools like low-level debuggers and code browsers, \nmaking visualization a daily staple in program- ming. We expect that the use of pervasive instrumentation \nwill lead to improved user interfaces and program views, especially three-dimensional views using the \nemerging vir-tual reality technology. Acknowledgments: We thank Amitabh Dave, John Coomes, Ashish Singhai, \nHoward C. Huang, and the anony- mous OOPSLA referees for their helpful comments. References VI Alfred \nV. Aho, Ravi Sethi, and Jeffrey D. Ull-man. Compilers, Principles, Techniques, and Tools. Addison-Wesley, \nReading, Massachusetts, 1986. PI Marla J. Baker and Stephen G. Eick. Visualizing Software Systems. In \nProceedings of the 16th Inter- national Conference on Software Engineering, pages 59-67,1994. [31 Grady \nBooth. Object-Oriented Analysis and Design With Applications . The Benjamin/Cummings Pub-lishing Company, \nInc., 1994. [4] R. H. Campbell, N. Islam, D. Raila, and P. Madany. Designing and Implementing Choices: \nAn Object-Oriented System in C++. Communications of the ACM, pages 117-126, September 1993. [S] L. Peter \nDeutsch. Design Reuse and Frameworks in the Smalltalk- Programming System. In Ted J. Big- gerstaff and \nAlan 9. Perlis, editors, Software Reusabil-ity, volume II, pages 55-71. ACM Press, 1989. [6] Brian Foote \nand Ralph E. Johnson. Reflective Fa-cilities in Smalltalk-80. In OOPSLA 89, Conference Proceedings, pages \n327-335. ACM, 1989. [7] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. De-sign Patterns, Elements of \nReusable Object-Oriented Sofnyare. Addison-Wesley, Reading, Massachusetts, 1994. [8] D. Garlan, R. Allen, \nand J. Ockerbloom. Exploiting Style in Architectural Design Environments. In Pro-ceedings of the 2nd \nACM SIGSOFT, pages 175-188, December 1994. 191 Philip Haynes, Tim Menzies, and Robert F. Co-hen. Visualisations \nof large object-oriented systems. Technical Report TR 95-4, Monash University, Mel-bourne, Australia, \nAugust 1995. [lo] J. A. Interrante and M. A. Linton. Run-time Access to Type Information in C++. In \nProceedings of the USENIX C++ Conference, San Francisco, California, April 1990. [l l] Gregor Kiczales, \nJim des Rivieres, and Daniel G. Bobrow. The Art of the Metaobject Protocol. MIT Press, 199 1. [ 121 D. \nR. Kohr, S. Zhang, M. Rahman, and D. A. Reed. Object-Oriented Parallel Operating Systems: A Per- formance \nStudy. In ScientiJic Programming, 1994. [ 131 C. Laffra and A Malhotra. HotWire:A Visual Debug-ger for \nC++. In Proceedings of the USENIX C++ Conference, pages 39-54, 1994. [14] Danny B. Lange and Yuichi Nakamura. \nInteractive Visualization of Design Patterns Can help in Frame- work Understanding. In OOPSLA, 1995. \n[ 151 Danny B. Lange and Yuichi Nakamura. Program Ex-plorer: A Program Visualizer for C++. In Usenix \nConference on Object-Oriented Technologies, pages 39-54, June 1995. [ 161 Rahman M. Choices Instrumentation \nSupport. Tech-nical report, University of Illinois-Urbana Cham-paign, 1992. [17] Peter W. Madany, Roy \nH. Campbell, and Panos Kou-giouris. Experiences Building an Object-Oriented System in C++. In Technology \nof Object-Oriented Languages and Systems Conference, Paris, France, March 199 1. [18] Pattie Maes. Concepts \nand Experiments in Compu- tational Reflection. In OOPSLA 87, Conference Pro-ceedings, pages 147-155. \nACM, 1987. [ 191 W. De Pauw, R. Helm, D. Kimelman, and J. Vlissides. Visualizing the Behavior of Object-Oriented \nSystems. In OOPSU, October 1993. [20] W. De Pauw, R. Helm, D. Kimelman, and J. Vlis- sides. Modelling \nObject-Oriented Program Execu-tion. In Proceedings of the 8th European Conference on Object-Oriented \nProgramming, ECOOP 94. Lec-ture Notes in Computer Science, October 1994. [21] Mohlalefi Sefika. Design \nConformance Management of Software Systems: An Architecture-Oriented Ap-proach. PhD thesis, University \nof Illinois at Urbana- Champaign, July 1996. [22] Mohlalefi Sefika and Roy H. Campbell. An Open Vi-sual \nModel For Object-Oriented Operating Systems. In Fourth International Workshop on Object Orien-tation \nin Operating Systems, Lund, Sweden, August 1995. [23] Mohlalefi Sefika, Aamod Sane, and Roy H. Camp- \nbell. Monitoring Compliance of a Software System With Its High-Level Design Models. In Proceedings of \nthe 18th International Conference on Software En-gineering (ICSE), March 1996. [24] Mary Shaw and David \nGarlan. SofrwareArchitecture: Perspectives on an Emerging Discipline. Prentice Hall, 1996. [25] R Snodgrass. \nA Relational Approach to Monitoring Complex Systems. ACM Transactions of Computer Systems 6(2):157-196, \nMay 1988. [26] Yasuhiko Yokote, Fumino Teraoka, Atsushi Mit-suzawa, Nobuhisa Fujinami, and Mario Tokoro. \nThe Muse Object Architecture: A New Operating Sys-tem Structuring Concept. Technical Report SCSL-TR-90-012, \nSony Computer Science Laboratory Inc., October 1990.  \n\t\t\t", "proc_id": "236337", "abstract": "Tracking the changing dynamics of object-oriented frameworks[5], design patterns[7], architectural styles[8], and subsystems during the development and reuse cycle can aid producing complex systems. Unfortunately, current object-oriented programming tools are relatively oblivious to the rich architectural abstractions in a system.This paper shows that architecture-oriented visualization, the graphical presentation of system statics and dynamics in terms of its architectural abstractions, is highly beneficial in designing complex systems. In addition, the paper presents architecture-aware instrumentation, a new technique for building efficient on-line instrumentation to support architectural queries. We demonstrate the effectiveness and performance of the scheme with case studies in the design of the <i>Choices</i> object-oriented operating system.", "authors": [{"name": "Mohlalefi Sefika", "author_profile_id": "81100310519", "affiliation": "Department of Mathematics and Computer Science, National University of Lesotho, P. 0. Roma 180, Lesotho, Southern Africa", "person_id": "P202534", "email_address": "", "orcid_id": ""}, {"name": "Aamod Sane", "author_profile_id": "81100180037", "affiliation": "Department of Computer Science, University of Illinois at Urbana-Champaign, Urbana, IL", "person_id": "P9947", "email_address": "", "orcid_id": ""}, {"name": "Roy H. Campbell", "author_profile_id": "81100212328", "affiliation": "Department of Computer Science, University of Illinois at Urbana-Champaign, Urbana, IL", "person_id": "P249832", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236380", "year": "1996", "article_id": "236380", "conference": "OOPSLA", "title": "Architecture-oriented visualization", "url": "http://dl.acm.org/citation.cfm?id=236380"}