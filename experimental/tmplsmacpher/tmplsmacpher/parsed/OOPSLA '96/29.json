{"article_publication_date": "10-01-1996", "fulltext": "\n Semantic-Based Visualization for Parallel Object-Oriented Programming Isabelle Attali, Denis Caromel, \nSidi 0. Ehmety, Sylvain Lippi tel: 33 93 65 INRIA Sophia Antipolis CNRS -I3S -Univ. Nice Sophia BP 93, \n06902 Sophia Antipolis 79 10, fax: 33 93 65 76 33, email: http://www.inria.fr/croap/ei#el-11 Antipolis \nCedex First.Last@sophia.inria.fr Abstract We present a graphical environment for parallel ob- ject-oriented \nprogramming. It provides visual tools to develop and debug object-oriented programs as well as parallel \nor concurrent systems. This envi- ronment was derived from a structural operational semantics of an extension \nof the Eiffel language, Eiffel//. Object-related features of the language (inheritance, polymorphism) \nare formalized using a big-step semantics, while the interleaving model of concurrency is expressed with \nsmall-step seman-tics. Without user instrumentation, the interactive envi-ronment proposes features such \nas step-by-step ani-mated executions, graphical visualization of object and process topology, futures \nand pending requests, control of interleaving, deadlock detection. 1 Introduction We present a graphical \nenvironment for parallel object-oriented programming. This environment provides visual tools to develop \nand debug ob-ject-oriented programs as well as concurrent sys-tems. This environment, has been derived \nfrom a formal semantics of an extension of the Eiffel lan-guage [41], named Eiffel// (pronounce Eiffel \nparal-lel) [17]. Permission to make digital/hard copy of part or all of this York tor personal or classroom \nuse is granted without fee provided that copies are not made or distributed for profit or commercial \nadvantage, the copyrIght nOtic% the title of the publication and its date appear, and notice is given \nthat copying is by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, or to \nredistribute to lists, requires prior specific permission and/or a fee. OOPSLA 96 CA, USA Q 1996 ACM \nO-89791 -788-W96/0010...$3.50 We adopt a structural operational semantics [55] for both the Eiffel language \nitself, and the con-current primitives. More specifically, we use the Natural Semantics [33] within the \nCentaur system [23], and the Typo1 formalism [21] which provides us with executable specifications. While \ncurrently used on a specific model of concurrency, other mod-els could be specified, and visualization \ntools would directly follow from the semantic description. More-over, the approach of applying formal \nsemantics to visualization can be used for other object-oriented languages. Graphical techniques have \nbeen used in program development in the setting of object-oriented pro-gramming on one hand [14], and \nparallel program-ming on the other [36]. C oncurrent object-oriented programming uncovers specific aspects \nsuch as the visualization of active objects, requests, futures, synchronizations, etc. Our work is specifically \nconcerned with the graphical visualization of hand-written applica-tions; method-based environments for \ninteractive design with source code generation are slightly out of the scope of this paper. Our contribution \nis first to demonstrate that it is actually possible to derive visualization and debugging tools1 directly \nfrom a formal semantics; secondly, the environment does not require any instrumentation from the user. \nThe For a color version of the figures, see at the end of this volume. outcome of such an approach is \ntwofold: (i) a ped- agogic environment to demonstrate concepts of ob- ject-oriented programming, actor \ncomputation, and formal semantics; (ii) a step towards environments for the formal study of parallel \nobject-oriented pro-gramming. Our interactive environment: based on a con-current model of execution \nof parallel activities through interleaving, presents features such as step-by-step animated executions, \ngraphical visual-ization of object and process topology, futures and pending requests, control of interleaving, \ndeadlock detection. The next section of this paper is a discussion of related work. Section 3 illustrates, \nwith a simple example; the language and model used for concur-rent programming. Section 4 focuses on \nthe op-erational semantic definition. From the formal se-mantic definition, graphical and interactive \nvisual-ization tools are derived (Section 5). In Section 6, we compare and discuss our technique and \ntools with closely-related approaches. Finally, Section 7 briefly discusses our contribution and outlines \nfu- ture work. Related Work Our system being concerned with both semantics of concurrency and program \nvisualization, related work in these two domains is presented and dis-cussed here. The seminal works \nof Hoare (CSP [30]) and Milner (CCS [42]) play a fundamental role for procedural programming, but they \noccurred to be not suited for object-oriented programming, where the config-uration of systems changes \ndynamically. Milner has then proposed the T-calculus [43] as an exten-sion of CCS; in the -ir-calculus, \nchannels (for interac- tion between agents) can be dynamically generated and transmitted from one agent \nto another. On the other hand, object-based models for concurrent systems have been explored 129, 1,731. \nThe actor model is an extension of the X-calculus (well-suited to functional programming) and is based \non the no-tion of configuration of actors. Autonomous actors communicate via asynchronous message-passing; \neach actor has its own behavior, reacts to a mes-sage and changes its configuration. Models have been \nused and extended in many dif-ferent ways: for instance, Honda and Tokoro pro-posed in [31] an object \ncalculus for asynchronous communication built on Milner 7r-calculus. On the other hand, Nierstrasz and \nPapathomas combined the concurrency models from CCS, CSP and the ac-tor models into a computational model \nof communi- cating agents [51]. More recently, Satoh and Tokoro developed RtCCS [59], a formalism for \nreal-time ob-ject-oriented computing based on CCS. For these different approaches, sound type sys-tems \nwere developed [4, 49, 65, 351 and formal semantics have been described in different, frame-works (denotational \n[6], operational [5, 48, 3, 191, based on the 7r-calculus 1671, or traces [64]). Based on a formal model \nor not, several concur-rent object-oriented programming languages have been designed, such as ConcurrentSmalltalk \n[72], Distributed Smalltalk [ll], Hybrid [45], Pool [4], ABCL [68], Eiffel// [16], DROL [63], and more \nre-cently Java [26]. Program visualization is an active research area in several domains such as software \ndesign, perfor-mance monitoring, software training. R.epresenta-tive systems are Zeus [la] for algorithm \nanimation, Polka (621 for program animation on parallel archi-tectures and Pavane [22] for visualization \nof con-current program execution (see [36] for a survey on parallel programs visualization). One interesting \nexample is ToonTalk [34]: K. Kahn shows that con-current constraint programming with an interactive animation \nbecomes suitable for children. Specifically related to the object paradigm, some systems are not directly \nlanguage-based, but rather provide independent environments for interactive visualization. For instance, \nObject Design Ex- ploratorium (ODE) [57] offers a learning environ- ment for design principles. A few \nproducts, more oriented towards modeling methodologies and inter-active environments, provide animated \nexecution and code generation. Based on the Shlaer-Mellor method [61], SES/objectbench [60] takes advantage \nof a simulation engine to provide animated simu-lations and BridgePoint [56] has a model verifier for \nexecution and a translation engine to generate source code. ObjecTime [39], using the ROOM method (Real-time \nObject-Oriented Modeling), in-cludes visualization with active and passive objects. Among systems more \ndirectly connected to pro-gramming languages, the visualization and probing of class/program structure \nrepresent a first cate-gory -the display of static program information, along the line of graphical browsers. \nCIA++ [27] builds a database of information of C++ programs which is used to display various views of \nthe pro-gram structure. GraphLog [20], a generic tool with a visual query language, allows visualizing \nand querying software structures. Object Explorer [lo] by Kent Beck is dedicated to SmallTalk. Another \nimportant category features the visu-alization of dynamic information: an actual rep-resentation of objects \ncreated when executing a program. ObjView [24], a system for the de-sign of electronic boards based on \na model writ-ten in C++, offers an interface with both a realis-tic view of problem-domain objects and \nrepresen-tation-domain C++ objects with visualization of instances, member data and functions. Haarslev \nand Moeller, in [28], propose a framework for both class hierarchies and objects using the CLOS [52] \nmeta-level architecture; an explicit association of visualization objects with application objects is \nneeded in that case. Object Visualizer [53, 541 and HotWire [37] are based on program instru-mentation \nmechanisms. Object Visualizer is accu-mulative, based on an event space, and need Ten-derer classes for \ndisplaying and changing graphical elements, while HotWire is a visual debugger for C++ with custom visualization \nbased on a script-ing language. Recently, Lange and Nakamura, in [38], proposed to use interactive visualization \nto un-derstand -and reuse -frameworks. They couple program instrumentation with a modeling of both static \nand dynamic program information (within a logical framework, using a Prolog notation). Stored in a database, \nthe information can then be selected and filtered out for specific display. Program Ex-plorer, their \nprogram visualization tool for C++, applies these principles. A state of the art of applications of visual \ntech-niques in object-oriented programming is presented in [14]. Experiences are reported concerning \ntwo or-thogonal issues: communication from the program-mer to the computer (visual syntax, language is-sues) \nand vice-versa (visual environment, presen-tation of static and dynamic information, with an emphasis \non animation). In this paper, we are only concerned with this second aspect. Providing an interactive \ngraphical environment for concurrent object-oriented programming leads to more specific visualization \nissues -e.g. how to show active objects (agents, actors), asynchronous and synchronous message passing, \nsynchronizations between objects. More fundamentally, an impor-tant issue is to be able to ensure the \nconsistency between the program execution and the visualiza-tion. A few early works can be found in [70], \nwhile a number of approaches have been explored in recent research. One orientation consists of the development \nof a library. BEE++ [13] p rovides dynamic analysis of distributed systems through a library of classes \nto be extended by the end-users in order to monitor and to visualize applications. Vion-Dury and San-tana, \nin [66], propose a 3D interactive animations for spatial visualization where objects have polyhe-dral \ncolored shapes. The system is built on top of a debugging tool of Guide [9] using record and replay. \nWith a different approach and goal, the ObjChart formalism and environment [25] proposes to specify reactive \nobjects directly in a visual framework. The environment is founded on an executable composi-tional semantics. \nBased on equations over traces, it does not allow dynamic object creation. Other systems are more integrated \nwithin a spe- cific language. Agha and Astley [2] propose a vi- sualization system for an extension of \nthe actor model [l]. An abstraction for visualization, visual- izer, monitors a list of the system components, \nand ensure consistency by calling themselves visualiza-tion functions. Implemented using synchronizers \nand reflection, the system does not require explicit modification of the application code. The system \nwe present focuses on the visualiza-tion of dynamic aspects, and shows the actual ob-jects of the program \nduring execution with two rep-resentations: textual and graphical. The system is based on a formal operational \nsemantics, needs no instrumentation, and does not require the user to write any code or script. It permits \nan interac-tive visualization of both sequential and concurrent object systems. 3 Model and Language \nfor Con-current Programming: Eiffel// In this section, we give a quick overview of a con-current language, \nEiffel// [17], defined as an ex-tension of Eiffel [40] to support programming of parallel applications. \nThese extensions are not concerned with syntax, but are purely semantic, which gives to both languages \nthe same syntactic description (see Figure 1). Both are strongly typed, statically-checked class-based \nlanguages. Our pur-pose here is not to discuss the rational of Eiffel//, and issues related to object-based \nconcurrent lan-guages (the reader can refer to a recent and re-lated design (C++// [lS]), and to related \nresearch [47, 69, 15, 50, 711). 3.1 Syntactic Constructors Syntactic constructors are presented in Figure \n1, and used in the semantic specifications in their con-crete form. An expression E E Expr is a variable, \na feature-call, an arithmetic or logic expression or a constant. A statement s E Stmt is an assignment, \na sequence of statements, a selection, an iteration, a routine ca112, including the object creation. \nThe identifier x is an attribute, a local variable, a for-mal parameter or one of the two pseudo-variables \nThe non-qualified feature-call M(E1,. , E,,) is equivalent to the qualified call current. M(EI,. , E,). \ncurrent and result. The identifier Y denotes an at-tribute or a local variable (including the result). \nK designates a constant value (integer, boolean, void (null reference), etc.) and Op, and Op, the usual \nunary and binary operators. -Expressions -Statements E::= X S ::= Y := E 1 E.M(El, . . , En) I s1; s \nI 0~1 E 1 if E then Sl else ~2 end 1 El 0p2 E2 1 until E loop s end IK (E.M(b,...,En) Figure 1: Statements \nand Expressions  3.2 Concurrent features The Eiffel// model uses the following principles: - heterogeneous \nmodel with both passive and active objects (processes, actors); -sequential processes; - unified syntax \nbetween message passing and inter-process communication; - systematic asynchronous communications towards \nactive objects; - wait-by-necessity (automatic and transparent futures); - no shared passive objects \n(call-by-value between processes); -centralized and explicit control by default; -polymorphism between \nobjects and processes. As in Eiffel, the text of an Eiffel// program (a sys- tem) is a set of classes, \nwith a distinguished class, the root class. Parallelism is introduced via a par-ticular class named PROCESS. \nInstances of classes inheriting (directly or not) from the PROCESS class are processes. Processes inherit \na default behav-ior (which ensures that requests to the process en-try points are treated in a fit0 order), \nbut this behavior can be redefined with the overriding of the live routine. All other objects are passive; \na process is an object but not every object is pro-cess. Polymorphism between objects and processes is \npossible: an entity which is not declared of a type process can dynamically refer to a process. In that \ncase, a feature-call dynamically becomes an asynchronous communication between processes (Inter-Process \nCommunication). Cohabitation of active and passive objects leads to an organization in subsystems. Each \nsubsystem contains a root process and the passive objects it references. Within a subsystem, the execution \nis se- quential and communications are synchronous: the target object immediately serves the request \nand the caller waits for the return of the result. Be-tween subsystems, the executions are parallel and \ncommunications are asynchronous: the target ob-ject (a process) stores the request in a list of pend- \ning requests, and the caller carries on execution. There is no shared object between subsystems: ref-erences \non passive objects are passed by copy be-tween subsystems. As a consequence, when poly-morphism between \nan object and a process occurs, two changes happen: asynchronous calls and copy transmission of parameters. \nOf course, this modi-fies the local semantics of the call (reflected in the formal description, Figure \n5, rules (I 11) to (I 15)). However, this is often a desired change when par-allelizing and, in many \ncases, does not affect the global semantics of the application (see for instance the speech recognition \napplication, Figure 13). Synchronization is handled via the wait-by-ne-cessity, a data-driven mechanism \nwhich automat-ically triggers a wait when an object attempts to use the result of an awaited value (transpar-ent \nfuture). The wait-by-necessity, by automati-cally adding some synchronization, tends to main-tain the \nbehavior of a sequential program when doing the parallelization. Explicit synchroniza-tions can be expressed \nwith the predefined routine Wait (v.Wait triggers a wait if v is a future). Another primitive Awaited, \nis a boolean feature with returns true when the considered object is awaited (if v.Awaited then do something \nin the meantime ). It is also possible to wait for re-quests: the predefined routine wait a-request permits \nto block a process until a new request ar-rives, e.g. inside a loop construct of a server.  3.3 An example \nAs an illustration, Figure 2 presents an Eiffel// sys-tem. It provides a parallel version of the sequen-tial \nclass BINARY-TREE, which describes the man-agement of a sorted binary tree with two routines insert and \nsearch: each node of the tree has two class BINARY-TREE export insert, search, left, right feature key \n: INTEGER; info : INTEGER; left, right : BINARY-TREE; insert (k : INTEGER; i : INTEGER) is . . . -inserts \ninformation i with key k search (k : INTEGER) : INTEGER is . . . - searches for the value of key k end \n- BINARY-TREE class P-BINARY-TREE export insert, search, left, right inherit PROCESS; BINARY-TREE redefine \nleft, right; feature left, right : P-BINARY-TREE; end - P-BINARY-TREE (a) Sequential and Parallel Binary \nTrees :lass EXAMPLE feature v: INTEGER; bt: BINARY-TREE; create is local p-bt: P-BINARY-TREE; do p-bt.create; \nbt := p-bt; - polymorphism build-binary-tree(bt); Y := bt.search(2); v.print - wait-by-necessity end; \n- Create build-binary-treecbt: BINARY-TREE) is do - building the binary tree bt.insert(3, 6); bt.insert(l, \n2); bt.insert(2, 4); bt.insert(4, 8); bt.insert(6, 12); end ; - build-binary-tree 2nd - EXAMPLE (b) \nUsing Active Objects Figure 2: An Eiffel// system children (left and right), an information (info) and \nan associated key (key); keys of the left (resp. right) subtree of a node are smaller (resp. greater) \nthan the key of this node. To parallelize the binary tree we define the P BINARY TREE class. It inherits \nfrom the PRO-CESS class and the BINARY TREE class; no other programming is necessary; the full version \nof the class is actually shown in the Figure 2.a. Poly-morphism between processes (p-bt) and objects \n(bt) makes it possible to reuse existing sequential code (here build-binary-tree for instance). In that \nexample, the default fifo behavior and the wait-by-necessity ensure that all insertions are han-dled \nin a correct order, and before the search; the parallel system preserves the semantics of the se-quential \none.   Operational Semantics In this section, we describe the operational seman-tics of Eiffel//. \nThis operational semantics simu-lates parallelism with a non-deterministic interleav-ing of (activities \nof) concurrent objects. The semantics of inheritance and dynamic bind-ing is expressed in Natural Semantics \n[33]. Al-though, the modules describing the actual exe-cution of statements (loops, feature calls, assign-ments, \n. ..) are expressed in Structural Operational Semantics (SOS) [55]). Natural Semantics (big-step semantics) \nis op-posed to SOS (small-step or transitional semantics) in the sense that intermediate steps of the \nexecu-tion of programs are hidden in a big-step semantics. The general idea of a semantic definition \nin Natural Semantics is to provide axioms and inference rules that characterize semamtic behaviors to \nbe defined on language const ructs. Behaviors are expressed with sequents in a logical style. These two \nstyles of semantic description cohabit well in the logical framework of the Typo1 formalism [al]. We \nassume that the source program, an abstract syntax tree noted II, is correctly type-checked. We briefly \npresent the semantics related to inheritance and dynamic binding (Section 4.2), as it is defined for \nEiffel (the reader can refer to a detailed version of the semantics of Dynamic Binding (71). We need \nto define some structures which describe the global configuration of a system. During exe-cution, an \nEiffel// system is composed of objects. Each object in the system has a configuration (at-tribute values, \nactivity, pending requests); the col-lection of all object configurations is the configu-ration of the \nsystem. For modeling objects (with their activity) during execution, we need a struc-ture (based on an \nabstract syntax). We also need a structure to store the futures and their values. We then describe the \noperational semantics of the language in terms of a transition system, mod-eling possible transitions \n(global actions) from one configuration to another. We present rules describ-ing global actions of a \nsystem; these global actions are expressed in terms of local actions on objects or interactions between \nobjects. 4.1 Semantic Structures We present the semantic structures used to model objects: static type, \nattributes, local variables, pending requests, and their activity (a list of clo- sures). 4.1.1 Objects \nWe model a system of objects R E Objs with a list of objects R ::= {Ri}*. Each object G!i E Obj is a \nquintuplet: sli ::= (a, K, p, C, R), defined as follows: The value Q E OName is the identifier of the \nob-ject, K E CName is the name of the object class (its static type), p is a list of pairs (attribute, \nvalue), c E Clrs is a list of closures (modeling object activ-ity) and R E Rqsts a list of requests to \nserve. A closure C; = (s,7) is defined by a sequence of statements s of Stmt and a context 77, formed \nby two lists of pairs: 77 = (pi, pz). The lists p1 and ~2, respectively manage the as-sociation between \nformal and effective parameters and local variables and their values. Finally, a request Ri E Rqst is \nmodeled by a quadruplet Ri = (M,v, 4, cy) with M the name of routine to serve, V = (VI,. . . , v,) the \neffective pa-rameters, d the future for the value of result after the routine completion and Q the sender \nidentifier. 4.1.2 Futures For modeling futures we add a new value, the awaited value $, so we can distinguish \nbetween an awaited value and the effective returned value at any time. The environment of futures + ::= \n{(ai}*, is shared by all objects; each future @pi= (4,~) is de- fined with a name 4 E FName, and a value \nv E Val, defined as an effective value v E EVal (integer, boolean, reference) or a future 4. 4.1.3 Continuations \nIn a small step operational semantics, it is necessary to describe continuations: the actions an objet \nhas to perform. This leads us to define new construc-tors. E ::= ) V 1 (r / E -.A M(E1,. . . , En) 1 \nE. ClOIle(&#38; ) S ::= 1 null 1 E + 1E + 4 1 clone-attrs(p,a) Intuitively, E + and E + are used to transmit \nthe current result between closures, in a single object; E 3 C$ returns the result of a service between \nob-jects; E -P M(E~, . . , E,,) is used for modeling the evaluation of parameters (transmitted by copy \nor by reference); we also use the notation E for the list of parameters (El, E2,. . . , E,);null is the \nstate-ment which does nothing; E*clone(a) makes a copy of the expression E and clone attrs(p, CX) makes \n-a copy of each attribute value in p.  4.2 Inheritance and Dynamic Binding We do not build, for every \nclass, an intermediate data structure for all inherited features, attributes, etc. Instead, we use the \nsource program, looking for information in the current class, or in ancestors (see [7] for more details). \nFrom the semantics of Eiffel, we use the following predicates: 0 feature(M, K, II) = M (Decsi) : T is \nlocal Decss do SM end; determines in the program II, the effective dec-laration of the routine M according \nto possible renamings and redefinitions (M is the version of the routine named M in the class 6). 0 bind(Decs, \n7) = p1 builds the p1 environment: the list of pairs (for-mal parameter, value) where each value comes \nfrom the list of effective parameters V. 0 init(Dec) = p2 builds the p2 environment: the list of pairs \n(lo-cal variable (including result), initial value) where each initial value depends on the type of the \nvariable (0 for integer, void for refer-ences, etc.). We also define a new predicate inheritpro- cess(K,II) \nsimply based on the existing predicate inherit(6, IC ) which states whether a class K. inher- its from \nclass K ; it will be used, at object creation, to specify if an object is active.  4.3 The Transition \nSystem Our operational semantics is based on a transition system whose states represent global configurations \nof a set of objects. The execution of a program is modeled by a sequence of configurations, starting \nfrom a suitable initial configuration. -4 global con-figuration changes into another global configuration \nwhen a global action is applied on the whole system of objects. A global action is for instance a commu- \nnication between objects or the creation of a new object. A global action is defined in terms of a local \naction in a given object. This object is deter- mined arbitrarily in the set of objects (see Section \n5.4 for more details) to perform some activity (this object is actually working during one elementary \nin-terleaving transition). A local action of the working object may be an internal action or an interaction \nwith another object. The semantics of a program is given by a transi- tion system which represents all \nits possible execu-tions. A global configuration of a system is a triplet PI, Q? f4 where II is the source \nprogram, a list of classes, Q, is the environment of futures and s2 is the list of objects. The transitions \nbetween configurations are given with rules which describe global actions of the system. These rules \nare of the form: (System, Ftrs, Objs) --+ (System, Ftrs, Objs) which is interpreted as follows: A system \nin a configuration (II, a , R) performs a global action and changes its configuration into (II, @ I, \n0 ). Note that during execution, the system II is never modified. Execution of a system is a sequence \nof transitions: (K @a, 00) -(K al, 01) -... where the initial configuration is given by: (n,@o,flo) \n= (IT, [ ], {(~o,ROOT, PO> {(create, (1 I, inNDecs)))), [ I)>) In the initial configuration, the list \nof objects con-tains one object (the root object, instance of the root class of II). Attribute values \nare initialized in po. The root object has to execute its create predefined routine and has no request \nto serve. 4.3.1 Global Actions The global actions of systems are given in Figure 3; they show how a configuration \nevolves according to local actions of objects. Rule (Gl) describes how the global configuration may change \nas a result of an internal action in one object. It reads as follows, from bottom to top: an Eiffel// \nsystem II, a list of futures a , a list of ob- jects s1 with a selected object (a, K, p, C, R) to be \nac-tivated, are changed into a new configuration (right of the arrow) where only p , c', R' (attributes, \nclo-sures, and requests) are possibly different if and only if the top part of the rule can be proved, \ni.e. the selected object can perform an internal action and change its state with the values p , c', \nR'. Rules (G2) and (G3) deal with the creation of ob- jects: a new identifier is generated and a new \npro-cess (resp. object) is created depending on whether the definition class ~1 of the object to create \ninher-its from the PROCESS class (the predicate ss, when applied to an object identifier, returns its \nroot pro-cess). Rule (G4) describes the deep copy of a passive object y asked by the Q object (copy of \nthe ob-ject itself and all the referenced passive objects). A new object is created in the subsystem \nof object ,D (given as a parameter of the action cln), with a new identifier X. The fields Cname, Attrs \nand Rqsts of X are those of y. The activity of the X object starts by making a copy of its attributes \n(clone-attrs(p,, P)>, and a future continuation (X + 4) for the object cr. Then, a waits for the future \n4 (see (115)), and receives the identifier X. Rule (G5) describes the synchronization be-tween send(M, \n?:, 4, /?) (action performed by cy) and rcv((u, M, V, 4) (action performed by /3). All com-munications \nare semantically specified with a new future 4 which handles the wait-by-necessity. A synchronous communication \nis then modeled with an immediate wait on the future. n, @J t (a, K, p, c, n) 2 p , c , n (Gl : internal) \n:n, a, fi u {(a, n, P, c, n.)}) -(F a, 0 u {b, K, P , c s n )>) new~xm , c, n, II, @ t (a. K. P. C, R) \n(G2 :process creation) (Jz @> i-2 u {k% 4 P? c, n)l) - (n, a., Q u {(% K> P , c , n ), (A n1, [ I, [(s, \n())I, [ 1))) provided inheritprocess(&#38;l, n), gen@) where feature(live, nl, II) = live : T is do s \nend, ss(p) = p new(n!,m , n, a t (CL K., P> c, R) p , R (G3:object creation) (n, a, R u {(a, K, p, c, \nR.)}) - (K @I Q u {(% K> P t c s n ), (P, Kl> [ 1, [ I> [ 1))) xovided not inheritprocess(Kl, II), pen(P), \nwhere ss(p) = ss(01) CwTJJ>P) , c, *,n,@t-(a,n,,p,.C,,R,) (G4 : clone) (n, a, flu{&#38; Km, Pa, cm> Ra)}) \n- (n, (4, 4). 0, flu {b, LX, Pk> ch, Rb), (A, %r P-r, C, R.7))) provided 3(y,~.,,p,,c,,n.,) E nuI(a,~~,,~,,c,,n,)},gen(X),gen(~) \nwhere c = (clone-attrs(p,,fJ); X + 4, ()), ss(X) = ss(P) n,at ((y,n,,p,,C,,R.,)Snd(~v.6)ph,Ch,nh n,* \nt P,n , ,c ,n )rcv(y+-) I pR,Cl,,R:, (G5:comm.) cn,n.,),(p,np,pp,cp,np)}) -(n,~,~u{(~>kx>Pcv, (n,~ ,nu{(a,IEol,pb,,Cb,,R.b,),(~,~p,p~,c~,n~)}) \nprovided gen(4), where a = (4, 4) @ rep(0,\\$) rI,at (ol,n,p,c,n) ----t p ,c ,n (~6 : result) (n, a> i-2 \nU ((0, K, P, C> R))) -(n,~[~+Vl,~u{(cY,~,P ,C ,~ ) Figure 3: Semantic Rules for Global Actions Finally, \nRule (G6) assigns the result value v to the associated future d in the futures environment.  4.3.2 Local \nActions Due to space limitation, we can not present the full description of local actions but focuse \non the most specific aspects. The reader can refer to [8] for more details. Semantic rules describing \nlocal actions are of the form: local System, Ftrs t- Obj --+ Pairs, Clrs, Rqsts which is interpreted \nas follows: An object performs some local action and modifies its configvl,ration (attributes, closures, \nrequests). Semantics of Statements We focus in Figure 4 on the rules for assignment, selection, and \nmessage passing, which can be de-composed into elementary actions (both internal to an object, and serving \na communication between two objects). For instance, the rule assign describes an elemen-tary step during \nthe execution of an assign state- n. + t (a, n, p, (E, 7) C, R) -L, p , (E , 7) C, R n, + t- (a, K, p, \n(Y := E, 7) .C, R) -4, p , (Y := E , 7)).C, R (assign) II, + 1 (0, K, P, (E, B) C, R) -k, P , (E , 17) \nC, R. II, @ I- (a, K, p, (if E then S1 else S2 end, 7) C, R) -f, p , (if E then s1 else s2 end, q) .C, \nR (s&#38;&#38;on) nI, @ k (a, K, P, (E, V) C, R) A P , (E , 17) C, n n, @ t-(a, K, P, (E M@, 9) C, R) \n-I, P , (E i-d% a) C, R (call-object) I-I, @ t (a, n, ~3 (E, ~7) C, R) -f+ P , (E r I)) C, R. II, @ t \n(a, K, p, (p -M@> a) C, R) -t, P , (P -M(E ), 17) C, R (call..param) n, ip t (0, n, P> (E, 7) C, R) A \nP , (E , 17) 6. R n, + t (a. K, P, (E * # > 7) C, R) A P , (E * 6 17) C, R. L (result) Figure 4: Rules \nfor statements ment: the right-hand side of the assign is still an expression to be evaluated E. An elementary \nstep consists in evaluating one step of E, which gives a new expression E , so the continuation is an \nassign statement with E in the right-hand side. Semantics of Internal Actions Axioms for internal actions \nare given in Figure 5. Axioms for evaluation (resp. assignment) of an attribute (14)(resp. (117))are \nstraightforward. The axiom (17)describes the evaluation of a fu-ture 4. This axiom does not apply if \nthe value of $ is the value 4 itself; the future is unknown. In this case, the absence of any action \nfor the object (other than receipt of requests or results) models the wait-by-necessity. Axioms (18)and \n(19)describe the local call of a routine. In this case, a new closure is created with the routine body \nplus the continuation result + with its context. After the completion of the rou-tine, the result value \nwill be sent to the next closure. The axiom (110)describes the explicit Wait: when the value of an expression \nis an effective value v the wait terminates and the value is returned. Axioms (I11) to (115)present the \ntransmission of parameters, depending on the type of the call. For a synchronous call (I 11)) parameters \nare passed by reference. For an asynchronous call (112)) pa-rameters are passed by copy. Axioms (113) \nto (115) deal with the actual copy of parameters depending on whether it is a constant (113), a process \n(114), or a passive object (115) for which a deep copy is required. The axiom (121) expresses the creation \nof an ob-ject of type ~1 (the type of Y). The new object is referenced by Y (as expressed in the assignment \nstatement returned as a continuation). The axiom (123) is a terminal action for sending back a result \n(the continuation is null).  Semantics of Communications Figure 6 gives axioms for the description of \ncommu- nications. Axioms (Cl) and (C2)may be applied when all subexpressions have been evaluated and \nrespectively describe a call between objects of two future (explicit Wait). -Axioms for expressions \nfl, @ t- (0, K> P> (1, 7) C, R) z P> (P/A], 17) c,R (14) n, * t (a, K, P> (4, 17) C, n) 2 P> (@[+$ 7) \nC, R (17) provided @[4] # 4 n, @ t (01, K, p, (a -M(G), 0) C, R.) 3 (18) P, (s&#38;f; result *? WI) (es \nv) c,nn where feature(M, K,$) = M (Decsl) : T is bcal Decs2 do SM end; iind(Decsl, v) = ~1, init(Decs2) \n= p2, r)~ = (~1, (result, void),/; n, + k (a> K, P> (V *, r7).(+, ?I)% R) z P> (V, w).C> R (19) II, @t \n(a, n, p, (x,Wait, 7) ,C, R) z p, (V, 17) .C, R. (110) n,@ t (~,K,P,(P,M(~),~).C,R) 2 P, (P-M$)>o).c,R \n(111) provided p # void, ss(cy) = ss(p) 1, + t (0, K, P, (P.M@, ~l).c, n) z P, (P -M(E CG&#38;)), d,C, \n1 provided p # void, SS((Y) # M(P) (112) II,+ t (a, ,~, (K clone(P),q) c, n) 2 P, (K,TJ) c,R (113) II, \n@ t (a, K, P, (Y clone(p), 7)) c, R.) s P, (7, a) C, 17 (114) provided y # void, ss(y) = y cln=,a)I, \nQ t- (~4 P, (-t-lone(P), 77),c, R) P, (&#38;Wait, dc n provided y # void, ss(y) # y (115) -Axioms for \ninstructions II, Z t- (0, K, p, (1 := V,g) C,R) l t p[I + V], (d&#38;q) C,R (117) new(n!,oa) n, Q t (a, \nK, p, (Y create,?)) C, R.) ~,(y:=p,rl).c,n where featw-e(~, &#38;c, II) = Decs : ~1, Y E Decs (121) rep(d,\\J) \n~I,~~((~~,K,P,(V~~,~)).C!R) -p, (nd, 7) C, R (123) Figure 5: Axioms for internal actions different subsystems \nand a call between objects of the same subsystem. In both cases, a request is created and sent to the \ncallee, and a new future 4 represents the return value. On the caller side, in the case of two different \nsubsystems, an asynchronous call occurs and the caller carries on its execution. On the other hand, within \na subsystem, a synchronous call is achieved: the caller immediately waits for the value of the On the \ncallee side, when a request is received, if it comes from a different subsystem (asynchronous call, axiom \n(C3)), the request is appended to the current list of pending requests, and will be treated later. On \nthe other hand, when the request comes from the same subsystem (synchronous call, axiom (C4)), it is \nimmediately treated. This is possible because within a subsystem, at most one object is ready for execution. \nThis technique is also used to deal with recursion within a subsystem. snd(y%) n> @ 1 (a, K, P (P -M(G), \na) C, R) P> (4, II) C, R provided ss(a) # ss(p) (Cl) snd(2,yd) n, + t (a> K, 6 s (P -M(v), v).C, R) \nP, (@Wait, v),c, n provided ss(cy) = SS(/~) cc21 rcv(\\l,v:4 p) p, C, R (M, v, 9, p} n, Q, b (a> n, P> \nC, R) (C3) provided ss(a) # ss(/3) II,,@ t (a, n, p, c, n) rcv(L1,v:+.o) P> #A4 ; result * 4, TM) c, \nR prwwted SS((Y) = ss(P) (C4) feature(M , r;,n) = M(DecSl) : T is local Decs2 do SM end; bind(Decsl,v) \n= pl, init( Decsz) = pz, 77~ = (~1, (result, void) pz} Figure 6: Axioms for communications   5 Semantics \nto Visualization From the syntactic and semantic definition of Eif- fel//, using the Centaur system and \nthe Typo1 for-malism, we derive an interactive environment for parallel object-oriented programming. \nNote that this environment is also suitable for sequential ob-ject-oriented programming and includes \nall of stan- dard Eiffel (since Eiffel// semantics includes the se-mantics of Eiffel). The principle \nwhich permits to go from seman-tics to visualization is as follows. First, the se-mantic structures (semantic \ndomains) are directly used in the visualization. The list of objects, fu-tures, and continuations (specified \nin section 4.1) will be directly used as an intermediate format by two visualization engines (one textual \nand one graphical, detailed below). Second, the seman-tics is equipped with notifications for the visual-ization \nengines. On appropriate semantic rules, when a rule is successfully applied (proved), the notification \n(if it exists) is triggered and the vi-sualization engines become aware of some modifi-cation in the \nsemantic structures. For instance, on rule (Gl) Figure 3, the new list of objects has changed and is \ntransmitted as a notification: n,~~(a,K,p,c,n)l~p ,C ,n Altogether, less than 10 semantic rules needed \nto be equipped with such notifications. The environment obtained can be used by two kinds of users: . \nnovice programmers can build basic programs (without, actually knowing the syntax of the language), compute \ntheir result using the gen-erated interpreter, and visualize program exe-cution with animation tools, \nincluding active objects; . language designers can express and understand operational semantics of various \nconcurrent ob-ject-oriented models. In this section, we focus on the functional aspects of the program \ndevelopment and debugging envi-ronment: we present the structure editor, the inter-preter, with two different \ngranularities of interleav- ing. We also describe the visualization tools that allow animation and debugging \nof programs (tex- tual and graphical presentation of objects, control over the execution, etc). Finally \nwe explain how language designers can access and visualize the se- mantic model during execution of \na given program. 5.1 Editing and Interpreting The programming environment includes a parser and a pretty-printer \nwhich compose a structure ed-itor (see Figure 7). This syntactic editor provides a guided editing mode \n(based on abstract syntax, via tree manipulation) as well as an in-line textual editing mode (based on \nconcrete syntax, using a parsing process). Figure 7: Editing and Visualizing a Program The main window \n( p-binary-paper.ep ) shows, after parsing, a concrete representation of the abstract syntax tree of \nthe example program presented in Figure 2. This concrete representa-tion uses specific fonts and colors \nfor keywords and comments. During editing, placeholders can be eas-ily introduced (using the Ins Mets \nbutton in the editing box on the right). Placeholders can then be filled up by selection of an abstract \nsyntax oper-ator (the window on the left-hand side shows only possible operators of type INSTRUCTION,the \ncur-rent selection in the program window). The ab-stract syntax definition ensures that the whole ab-stract \nsyntax tree for the program is syntactically correct. Finally, the editing window on t,he right provides \nhelp for navigation in the tree, changing the level of details, cut-and-paste operations, and so on. \nProgram editing and visualization is part of the so-called editing server (possibly running on one machine) \nas opposed t,o the semantic server which handles execution of the semantics (possibly running on another \nmachine); the model is based on a client-server architecture, with asynchronous communications. To trigger \nthe interpretation of a program, we provide a specific popup menu, which is a call to the operational \nsemantics of the language. The ab-stract syntax tree of the source program is transmit- ted from the \nediting server to the semantic server. The result of the execution is an abstract syntax tree modeling \nthe final list of objects which is sent to the servers for visualization. 5.2 Visualization and Animation \nTools We provide two different visualizations of objects, using two visualization engines, both of them \nbased on the semantic structure for modeling the list of objects presented in Section 4.1. In one window, \nwe present a textual represen- tation of objects with their configuration: pro- cess or object, static \ntype, current attribute val- ues, current activity, current pending requests. Fig- ure 8 shows the root \nobject and a process of type P-BINARY-TREE. The left and right attribute values are references to other \nobjects (#3 &#38; fl4 are not shown here, the scroll-bar must be used). This process has currently 2 \npending requests (in red, between ( and )). Last, its current activity (the highlighted continuation), \nis a if statement. The question mark ? in object #l is discussed in Sec- tion 5.3. Such a presentation \ndoes not give a global view of the graph of objects. So, in another window, we show the complete topology \nof the system in a graphical representation. This graph is visualized thanks to the graph displaying \npackage of Centaur [32]. Nodes and edges of the graph are built using a traversal of the abstract syntax \ntree representing the list of objects: for each object, a node repre-senting an object is created, and \nfor each attribute value which is a reference, an edge is created be-tween two object nodes. Two kinds \nof object nodes exist, distinguished with specific colors: objects in blue and processes in green. Figure \n9 displays all processes during execution of the binary tree exam-ple. A zooming process makes it possible \nto show, on request, attribute values of a given object node. Figure 8: Textual Visualization of Objects \nFigure 9: Graphical Visualization of Objects This is done with an expansion of an object node into a \nsubgraph made up with the object node itself and attribute nodes (containing attribute name and value, \npossibly a reference). References noted in Figure 8 are shown with arrows between the root process and \nits two sons (P-BINARY-TREE #3 &#38; #4). We also provide a selection mechanism in the graphical representation \nfor modeling subsystems. Selecting an object highlights its root process (pos-sibly itself) and related \npassive objects. This may be useful for a better understanding of concurrency aspects (communications, \ntransmission of param-eters, etc). For readability, no other information (such as pending requests, or \nactivity) is available in the graphical representation. These two visualizations are based on the same \nsemantic structure modeling the list of objects and can be displayed after execution of the program. \nThis technique also provides animation to visual-ize objects during program execution, and so have a \nbetter understanding of the behavior of the pro-gram. One thing we chose to highlight is the current \nac-tive object and activity, in the textual presentation (with a particular selection) and in the graphical \npresentation (with a thick blue border). This is done with a notification expressed in the semantic specification \nas a side effect of the application of rule (Gl). This notification is sent from the seman-tic server \nto the editing server each time an object is selected for execution. To visualize objects during execution \nand provide animation, it is also necessary to show the changes that occur (creation of a new object, \nupdate of an attribute value, etc). This is done with a notifi-cation in the appropriate semantic rule. \nFor in-stance, axiom (117) dealing with the assignment of an attribute, when applied, notifies the editing \nserver that a change has occurred. Then, it is up to the textual and graphical presentations to show \nthe change with an incremental redisplay (so the user is not bothered with screen flashes) and permits \nto focus the attention on the change (a new value, a new object) which is highlighted.  5.3 Visualizing \nSynchronizations Our environment makes it possible to visualize au-tomatic futures which are data-driven \nsynchroniza-tions. An example, from the binary tree example in Figure 2, is illustrated in Figures 8 \nand 9, with a question mark ?8 as the value of the attribute v. When the root object executes the statement \nv:= bt . search(21, bt refers to a process object of type P-BINARY-TREE. The rule (G5) for communica-tion \nis applied. Then the environment of futures @ is updated by a new pair ($,c$) and the future 4 is transmitted \nto bt (which will later update on the future with the result). In the root object, the value 4 (identified \nby the number 8), is assigned to the attribute v). Execution continues, with the state-ment v. print, \nwhich starts by the evaluation of the attribute v (axiom (14)). Because the value of v is the future \nc$, the continuation c$. print will be returned. The axiom for the evaluation of a future (17) then may \nbe applied, depending on whether or not the side condition of the axiom is verified. The value of the \nfuture 4 may still be 4, otherwise, the value is an effective value (the integer 4). In the first case \nthe root object is then waiting for the value of v and the execution continues with other processes. \nIn the second case, the value is returned and the continuation is 4. print.  5.4 Termination and Deadlock \nBecause operational semantics simulates paral-lelism with non-deterministic interleaving, there is only \none working object at a time, chosen among all active objects. We use the following terminology for objects: \nactive: has an activity to complete (non-empty list of closures). terminated: has no activity to carry \non (empty list of closures). waiting: is currently waiting either for the return of a future value (wait-by-necessity) \nor for a request (wait-a-request primitive). In the initial configuration, only one object (root) exists \nand is active. To decide which object will proceed its execution (for one elementary step), we arbitrary \n(non deterministically) choose among ac-tive objects (see Section 5.7 for other alternatives). Activation \nand deactivation of objects occur, ac-cording to the following principles: . when an object is created, \nit is activated with the create routine as continuation; . after one transition step, one active object \nis deactivated if either this object is blocked, wait-ing for a request, or this object attempts to access \nthe value of a future 4 which is not yet returned (failure of axiom (17)); in both cases, the object \nbecomes waiting; . after one transition step, a waiting object is activated if this object received a \nrequest (rule (G5) applies) or if this object received the value associated to a future $ (rule (G6)) \napplies). Note that the deactivation of an object permits to handle waits without consuming cputime \n(passive wait). With this terminology, we can state termination and deadlock properties. An execution: \nterminates: when every object is terminated; deadloclcs: if there is no more active object and at least \none waiting object on a future. Our semantic-based environment handles such properties and reports a \nmessage during execution when a deadlock is detected. Figure 10 illustrates the deadlock detection in \na classical problem of re-source allocation: the philosophers. In this version of the philosophers, as \nshown in the figure, it is pos- sible that each philosopher grabs a fork and waits for the second one \n(the continuation is stopped on a future: ?i . wait), and a deadlock occurs. However, the fact that a \nprogram terminates nor-mally (without deadlock) during one execution does not prevent from a deadlock \noccurring in another execution. To statically detect that a program is deadlock-free, we would have to \nconsider all pos-sible executions (with the combinatorial explosion problem) and make sure that no execution \ncan lead to a deadlock. Figure 10: Detecting a deadlock  5.5 Controlling the execution To control the \nexecution, it is necessary to suspend (and resume) the semantic server on user request. This is done \nwith the definition of a communica-tion protocol between the editing server (user in-teractions) and \nthe semantics server (program ex-ecution). Each transition of the system is condi- tioned by the reception \nof a message from the edit-ing server. On the other hand, messages from the semantic server can be emitted \nto the editing server (to give information on the execution progress). With these communications, it \nis quite straight-forward to add a debug box to control execution (see Figure 1l.a). Four buttons are \nprovided in this tool: a go: execution resumed without stopping; . stop: execution stopped in the next \nconfigura- tion of the transition system; . step: execution resumed for one transition (ap- plication \nof one global rule of Figure 3); . abort: execution aborted. So, during the interpretation of a program, \none can stop the execution, inspect the current state of the system (attribute values, requests, activities \nof objects), and resume execution, step by step, or continuously. Nothing in our approach prevents us \nfrom changing attribute values during execution; this possibility will be added in the future. 1 Abort \n[ (b) Control of gran- (4 Global ularity control (c) Control of in- terleaving Figure 11: Control over \nthe execution 5.6 Changing the granularity Our semantics is based on a very fine-grain inter-leaving: \nevery statement is decomposed into a large number of elementary steps (local actions, see Sec-tion 4.3.2); \nof course, a method execution is not atomic. This means that the number of system configurations during \nexecution is important (e.g. 551 transitions for the binary tree example). This kind of granularity is \nuseful when the user wants to see the detailed execution, inside an object or a process for instance. \nHowever, this granularity might be too fine in some cases, especially when the user is interested into \nthe global behavior of the sys-tem, and interactions between processes. For this reason, we also provide \na coarse-grain interleaving, which is handled just by providing a new set of rules for global actions; \nthese rules are as expressed (n,~,nU{(a,n,p,c,R)})~(~,~,~U{(~,~,~ ,C ,R )}) in Figure 3 except for the \nrule (Gl), to be replaced with the following rule (Gl ): int rI,a+(a,K,p,C,R)-* p ,C ,R (Gl. ) Previously, \natomic actions were object creation, ob-ject copy, communication, or an elementary inter-nal action (every \naction dealing with only one ob-ject). In this coarse-grain version of the semantics, a suite of internal \nactions can be executed without interleaving until a global action involving two ob-jects is reached. \nThis is expressed by adding the transitive closure (*) of the internal action relation (z) in rule (Gl \n). The number of global configurations during exe-cution is considerably reduced in coarse-grain exe-cution \n(e.g. 73 transitions for the binary tree exam-ple instead of 551); note that method execution is still \nnot atomic, but the interleaving is of a coarser grain. These two different sets of rules for global \nactions are accessible via two distinct entry points. One can then choose between these two modes of \ninterleaving as shown with the menu of Figure 1l.b.  5.7 Exploring the interleaving space The selection \nof the next object to execute is, by default, arbitrary in the set of active objects. This random selection \ncan be changed on the pro-grammer s request, after stopping the execution.. This is done via a menu (see \nFigure 11.~); the user can decide to suspend (or resume) a given object, objects of a given class, or \nall objects. When click-ing on object entries, the user is asked to select an object (in the textual \nor graphical presentation). When clicking on class entries, the user is asked to select a class in the \nprogram source. Any action has a straightforward effect on the sta-tus of (individual or sets of) objects, \nswitching an active object to inactive or the reverse. With this possibility, one can simulate fast or \nslow processes, different priorities on different families of processes, etc. For instance, one useful \nexploration is to sus-pend all objects and to resume one particular ob-ject. Thus, only this object can \nproceed with its activity as far as it does not access some awaited value. Thanks to this mechanism, \nvery specific in-terleaving can be explored, e.g. looking for poten-tial deadlock.  5.8 Understanding \nthe semantics Thanks to a particular compilation mode of the se-mantic description, one can visualize \nthe semantic rules: a specific window shows the inference rule currently applied (see Figure 12 for the \napplica-tion of rule (Gl)). The skip button is an attempt to prove the rule without displaying the complete \nproof. One can control over the semantic interpre-tation; for instance, the fail button provokes a fail- \nure which has a direct impact on non-determinism and determines one particular execution path, at the \nmeta-level of semantics. It is also possible to set breakpoints in the semantics and see the current \nvalue of a given variable (with the examine button). Figure 12: Visualizing the Semantics To conclude \nthis section and as a general illus-tration of our environment, we show the sequential execution of an \napplication in speech recognition (161 in Figure 13.a, and a parallel execution in Fig- ure 13.b. We \ncan deduce from both figures that the four knowledge sources became active objects and that some passive \nobjects were duplicated (e.g. signal) because of the construction of several sub-systems (no shared objects). \n  Discussion The technique we used, as presented in Sections 4 and 5, offers two main advantages: (a) \nSequential Execution (b) Parallel Execution  Figure 13: A Speech Recognition Application (1) the environment \ngenerated is general enough so that programmers can develop and debug ob-ject-oriented programs in a \nsequential as well as in a concurrent framework; (2) visualization tools are based on the semantic de-scription \nof the concurrent object-oriented model, so the programmer is not required to instrument his programs \nto get a visualization of the execution.  If we take as a reference criteria proposed in the taxonomy \nof program visualizations [58], our sys-tem can be qualified as following. All aspects of the program, \nthe scope criterion in [58], are visual-ized (code, data and control state, behavior): the source code \nis displayed and animated in one win-dow, objects are displayed and animated in other windows. The level \nof abstraction is based on di- rect and structural representations: references are abstracted as an arc \nin the graph of objects. The specification method relies on logical predicates (as in Pavane [22]) at \nthe semantics level (not at the code level). The graphical interface provides simple objects, events, \nmultiple worlds, and control inter-action: the graph server we use not only provides an abstract representation \nof objects (an output) but it also reacts to user actions (input): select an object, move an object, \nzoom, etc. Last, the presen- tation of the visualization is analytical and explana-tory: we visualize \nconcurrent computations as they occur, and also we can focus the attention of the user on a particular \nevent (for instance, a synchro-nization is shown when the computation accesses an awaited value presented \nas a red question mark l? ). Agha et al. suggested to use predicate transition nets [44], and defined \nthe so-called causal interac-tion model which captures causal behavior and co-ordination between actors \n[2]. In the latter work, one of the key points is the consistency between the events as they occur and \nthe visualization; the authors developed a model that preserves this con-sistency (causal connection \nrestriction). We do not have to deal with such questions because a seman- tic-based visualization is \nby definition consistent with the interpretation of the semantics. For the same reason, we do not need \nobservers and coor-dinators, everything is centralized in the semantics definition and interpretation. \nThe two approaches are rather complementary: [2] well-adapted for ob-servation in situ and optimization, \nour approach for investigation of all possible behaviors and formal verifications. In [46], Nierstrasz \ndevelops an executable nota-tion, Abacus, allowing the specification of various concurrent object languages. \nThe intended goal is to offer a generic platform; as an illustration, a spec- ification of SAL [l] (a \nSimple Actor Language) is described within Abacus, and SAL programs can be interpreted using an Abacus \nto Prolog transla-tion. Techniques similar to those described here could be used to provide Abacus with \ngraphical vi-sualization -a semantics of Abacus would have to be defined in Typol, leading to both genericity \non the concurrent model, and non instrumented graph-ical visualization. However, since Abacus modeling \noccurs in term of agents and events which are com-posed to specify the semantics of a particular ac-tor \nmodel, a general purpose visualization would re-flect those building bricks. While interesting when designing \nand comparing concurrent models, they might not be relevant when experimenting with one given system3. \nThus, an interesting direction for improvement might consist to add to the specifica-tion of a system, \ndirectly within the Abacus nota-tion for instance, the necessary specification of how to visualize the \nconcurrent language being modeled. This extra specification would provide an abstrac-tion, relevant to \nthe user of a concurrent language, over the agents and events being used to model it. 7 Conclusion and \nFuture Work In this paper, we presented how we can build a graphical visualization environment from an \noper-ational semantics of a (concurrent) object-oriented language. The visualization is not obtained \nfrom code instrumentation but automatically, using the semantic description. The graphical environment \nfocuses on objects and their interactions (object topology, attribute values, concurrent activities, \nsubsystems, synchronizations), provides a set of primitives for controlling and probing the execu-tion \n(granularity of interleaving, step-by-step exe-cution, control over the interleaving), and detects deadlock \nconfigurations when they occur. Due to non-determinism of concurrency, it is crucial to pro- vide the \nuser with the possibility to investigate the interleaving space of all possible executions. An important \nissue with visualization environ-ment is scalability. Based on a formal semantics, our approach might \nraise some concerns. However, 3A similar phenomenon occurs when modeling parallel languages with the \nT-calculus: far too many agents are gener- ated, not well representing the actor structure of a program. \n the technique is viable, and our current system is References actually operational; applications with \nmore than 600 objects were handled and visualized graphi-cally, and the execution speed is such that \nit is often necessary to slow down interpretation for the sake of visualization. To further improve these \naspects and enable the user to apprehend complex systems, several paths are possible. Regarding visualization, \na solution is to ask the user extra information in order to customize the layout. A first possibility \nconsists in giving a partial view of the graph of objects (only processes, only objects from a given \nclass, etc.); this solution is quite straightforward to add to our system, and we are currently working \non that aspect. More sophisticated strategies, that shows an abstraction of the system topology, are \nalso considered. Within our semantic framework, we see two possibilities for the specification of this \nvisualization information: at the formal level us-ing semantics rules, or at the target language level, \nwriting visualization classes. These two options are probably complementary since they do not concern \nthe same kind of user. Another important improvement would be to provide a framework generic on the programming \nmodel, and especially the model used for concur-rency. One possibility would be to use the ap-proach \ndiscussed at the end of Section 6. Regard-ing visualization, if one describes the semantics of another \nmodel of concurrency, for instance using quasi-parallel and parallel processes, the visualiza-tion would \ndirectly follow from the new semantics, i.e. several continuations would be added to each active object. \nFinally, expressing the behavior of a parallel sys-tem with transitional semantics inherently repre-sents \nall possible executions, which can then be used to study program properties such as absence of deadlock, \nliveness, or equivalence using classi-cal techniques based for instance on traces [30] or bisimulation \n[42]. A semantic-based visualization should permit to provide an integrated environment where users can \nboth visualize program execution and study formal properties. [II G. Agha. Actors: A model of Concurrent \nCompu-tation in Distributed Systems. MIT Press, Cam-bridge, 1986. PI G. Agha and M. Astley. A visualization \nmodel for concurrent systems. International Journal of Information Science, Elsevier, 1996. To appear. \nG. Agha, I. Mason, S. Smith, and C. Talcott. A [31 foundation for actor computation. technical re-port, \nUIUC, 1995. To appear in Journal of Func- tional Programming. P. America. Inheritance and subtyping in \na par- PI allel object-oriented language. In Proc. ECOOP 87, LNCS 276, pages 234-242, Paris, France, \nJune 1987. P. America, J. D. Bakker, J. N. Kok, and J. Rut-[51 ten. Operational Semantics of a Parallel \nOb-ject-oriented Language (POOL). In Proc. of the 13th Symposium on Principles of Programming Languages, \n1986. P. America, J. D. Bakker, J. N. Kok, and J. Rut- Fl ten. Denotational Semantics of a Parallel Ob-ject-oriented \nLanguage (POOL). Information and Computation 83, 152-205, 1989. I. Attali, D. Caromel, and S.O. Ehmety. \nA Natural 171 Semantics for the Eiffel Dynamic Binding. To ap-pear in ACA4 Transactions on Programming \nLan-guages and Systems (TOPLAS), 1996. I. Attali, D. Caromel, PI ral Semantics for the Report 2732, INRIA, \nR. Balter, S. Lacourte, PI language. Computer and Eiffel// 1995. and Journal, S.O. Ehmety. A Natu- Language. \nResearch M. Riveill. The Guide 37(6):519-530, 1994.  [lOI K. Beck. Object explorer for visual works. \nCom-mercial Product http://c2.com/ppr/about/au-thor/kent.html, First Class Software, Inc. J. K. Bennett. \nThe design and implementation VI of Distributed Smalltalk. In Proc. OOPSLA 87, ACM SIGPLAN Notices 22 \n(12), pages 318-330, December 1987. M. H. Brown. Zeus: a system for algorithm anima- PI tion and multiview \nediting. In Proc. of the IEEE Workshop on Visual Languages, 1991. B. Bruegge, T. Gottschalk, and B. Luo. \nA frame- 1131 work for dynamic program analyzers. In Proc. OOPSLA 93, ACM SIGPLAN Notices 28 (lo), pages \n65-82, October 1993. M. Burnett, A. Goldberg, and T. Lewis, edi- (141 tors. Visual Object-Oriented Programming, \nCon-cepts and Environments. Manning Publications, Greenwich, CT, 1995. [15] Concurrent Object-Oriented \nProgramming. Com-munications of the ACM, 36 (9), 1993. Special issue. [16] D. Caromel. Concurrency and \nreusability: From sequential to parallel. Journal of Object-Oriented Programming, 3(3), 1990. [17] D. \nCaromel. Towards a Method of Object-Oriented Concurrent Programming. Communications of the ACM, 36 (9), \npages 90-102, 1993. [18] D. Caramel; F. Belloncle, and Y. Roudier. The C++// system. In G. Wilson and \nP. Lu, editors, Parallel Programing Using C++. MIT Press, 1996. To Appear. [19] P. Ciancarini, K. K. \nJensen, and D. Yankelevich. On the operational semantics of a coordination language. In Proc. Object-Based \nModels and Lan-guages for Concurrent Systems, LNCS 924, pages 77-106. Springer-Verlag, 1995. [20] M. \nConsens, A. Mendelzon, and A. Ryman. Visu-alizing and querying software structures. In Proc. of the 14t \nInternational Conference on Software Engineering, pages 1388156, May 1992. [21] T. Despeyroux. Typol: \nA Formalism to Implement Natural Semantics. Research Report 94, INRIA, 1988. [22] G.-C. Roman et al. \nA System for Declarative Vi-sualization of Concurrent Computations. Journal of Visual Languages and Computing, \n3 (2), 1992. [23] P. Borras et al. Centaur: the System. In SIG-SOFT 88 Third Annual Symposium on Software \nDevelopment Environments, Boston, 1988. [24] G. Friedrich, W. H., C. Stary, and M. Stumpt-ner. Objview: \nA task-oriented, graphics-based tools for object visualization and arrangement. In Proc. ECOOP 89, pages \n299-310, Nottingham, July 1989. Cambridge University Press. [25] D. Gangopadhyay and S. Mitra. Objchart: \nTangi-ble specification of reactive object behavior. In Proc. ECOOP 93, LNCS 707, pages 4322457, Kaiserslautern, \nGermany, July 1993. [26] J. Gosling, B. Joy: and G. Steele. The Java Lan-guage Specification. Addison-Wesley, \n1996. [27] J. E. Grass. Object-oriented design archaeology with CIA++. Computing Systems, 5(1):5-67, \n1992. [28] V. Haarslev and R. Moller. A framework for vi-sualizing object-oriented systems. In Proc. \nOOP-SLA/ECOOP 90, ACM SIGPLAN Notices 25 (lo), pages 237-244, October 1990. (291 C. Hewitt. Viewing control \nstructures as patterns of passing messages. Journal of Artificial Intelli-gence, 8 (3), 1977. [30] C.A.R \nHoare. Communicating Sequential Pro-cesses. Prentice Hall, 1985. [31] K. Honda and M. Tokoro. An object \ncalculus for asynchronous communication. In Proc. ECOOP 91, LNCS 512, pages 133-147, Geneva, Switzer-land, \nJuly 1991. [32] A. Le Hors. Graph: A directed graph displaying server, GIPE 2 Esprit project, 4th review \nreport, workpackage 4, 1992. [33] G. Kahn. Natural Semantics. In Proc. of Sympo-sium on Theoretical Aspects \nof Computer Science, Passau, Germany, LNCS 247, 1987. [34] K. Kahn. T oonTalk -an animated programming \nenvironment for children. In Proc. of the Na-tional Educational Computing Conference, Balti-more, MD, \n1995. [35] N. Kobayashi and A. Yonezawa. Type-theoric foun-dations for concurrent object-oriented program-ming. \nIn Proc. OOPSLA 94, ACM SIGPLAN Notices, October 1994. [36] E. Kraemer and J. T. Stasko. The visualization \nof parallel systems: an overview. Journal of Parallel and Distributed Computing, 18, 1993. [37] C. Laffra \nand A. Malhotra. Hotwire -A visual de-bugger for C++. In USENIX Sixth C++ Technical Conference, pages \n109-122, Cambridge, MA, April 11-14 1994. USENIX. [38] D. B. Lange and Y. Nakamura. Interactive visu-alization \nof design patterns can help in framework understanding. In Proc. OOPSLA 95, ACM SIG-PLAN Notices 30 (lo), \npages 342-357, October 1995. [39] ObjecTime Ltd. ObjecTime. Commercial Product http://www.objectime.on.ca, \nOntario, Canada. [40] B. Meyer. Object-Oriented Software Construction. Prentice-Hall, 1988. [41] B. \nMeyer. Eiflel, the Language. Prentice-Hall, 1992. [42] R. Milner. A Calculus of Communicating Systems. \nSpringer Verlag, LNCS 92, 1980. [43] R. Milner, J. Parrow, and D.J. Walker. A Calculus of Mobile Processes. \nAcademic Press, 1989. [44] S. Miriyala, G. Agha, and Y. Sami. Visualizing ac-tor programs using predicate \ntransition nets. Jour-nal of Visual Languages and Computing, 3 (2), 1992. [45] 0. Nierstrasz. Active \nobjects in hybrid. In Proc. OOPSLA 87, ACM SIGPLAN Notices 22 (l2), pages 243-253, 1987. [46] 0. Nierstrasz. \nA guide to specifying concurrent be-haviour with abacus. In Object Management, pages 267-293, Centre \nUniversitaire d Informatique, Uni-versity of Geneva, July 1990. [47] 0. Nierstrasz. The next 700 concurrent \nob-ject-oriented languages -reflections on the future of object-based concurrency. Object composition, \nCentre Universitaire d Informatique, University of Geneva, June 1991. [48] 0. Nierstrasz. Towards an \nobject calculus. In Proc. of the ECOOP 91 Workshop on Object-Based Concurrent Computing, LNCS 612, pages \nl-20. Springer-Verlag, 1992. [49] 0. Nierstrasz. Regular types for active objects. In Proc. OOPSLA 93, \nACM SIGPLAN Notices, 28 (lo), pages l-15, October 1993. [50] 0. Nierstrasz, P. Ciancarini, and A. Yonezawa, \ned-itors. Rule-based Object Coordination. LNCS 924. Springer-Verlag, 1995. [51] 0. Nierstrasz and M. \nPapathomas. Viewing ob- jects as patterns of communicating agents. In Proc. OOPSLA/ECOOP 90, ACM SIGPLAN \nNotices, 25 (IO), 1990. [52] A. Paepcke. Object-Oriented Programming: The CLOS Perspective. The MIT \nPress, 1993. [53] W. De Pauw, R. Helm, D. Kimelman, and J. Vlis-sides. Visualizing the behavior of object-oriented \nsystems. In Proc. OOPSLA 93, ACM SIGPLAN Notices, 28 (lo), pages 326-337, October 1993. [54] W. De Pauw, \nD. Kimelman, and J. Vlissides. Mod-eling object-oriented program execution. In Proc. ECOOP 94, LNCS 821, \npages 163-182, Bologna, Italy, July 1994. Springer-Verlag. [55] G. D. Plotkin. A Structural Approach \nto Op-erational Semantics. Report, DAIMI FN-19, Computer Science Department, Aarhus University, Aarhus, \nDenmark, 1981. [56] Project Technology, Inc. BridgePoint. Commer-cial Product http:// www.projtech.com, \nBerkeley, California. [57] S. P. Robertson, J. M. Carroll, R. L. Mack, M. B. Rosson, S. R. Alpert, and \nJ. Koenemann-Belliveau. ODE: A self-guided, scenario-based learning environment for object-oriented design \nprinciples. In Proc. OOPSLA 94, ACM SIGPLAN Notices, pages 51-64, October 1994. [58] G.-C. Roman and \nK. C. Cox. A Taxonomy of Program Visualization Systems. IEEE Computer, 1993. [59] I. Satoh and M. Tokoro. \nA formalism for real-time concurrent object-oriented computing. In Proc. OOPSLA 92, ACM SIGPLAN Notices, \n27 (IO), pages 315-326, October 1992. [60] SES, Inc. SES/objectbench, SES/workbench. Commercial Product \nhttp:/ /www.ses.com, Austin, Texas. [61] S. Shlaer and S. Mellor. Object Lifececyles: Model- ing the \nWorld in States. Prentice Hall, Englewood Cliffs, NJ., 1992. [62] J. T. Stasko and E. Kraemer. A methodology \nfor building application-specific visualizations of par-allel programs. Journal of Parallel and Distributed \nComputing, 18, 1993. [63] M. Tokoro and K. Takashio. Toward languages and formal systems for distributed \ncomputing. In Proc. of the ECOOP 93 Workshop on Object-Based Dis-tributed Programming, LNCS 791, pages \n93-110, 1994. [64] V. Vasconcelos and M. Tokoro. Traces seman- tics for actor systems. In Proc. of the \nECOOP 91 Workshop on Object-Based Concurrent Com-puting, LNCS 612, pages 141-162, 1992. [65] V. Vasconcelos \nand M. Tokoro. A typing system for a calculus of objects. In Object Technologies for Advanced Software, \nFirst JSSST International Symposium, LNCS 742, pages 460-474, November 1993. [66] J.-Y. Vion-Dury and \nM. Santana. Virtual im-ages: Interactive visualization of distributed ob-ject-oriented systems. In Proc. \nOOPSLA 94, ACM SIGPLAN Notices 29 (IO), pages 65-84, Oc-tober 1994. [67] D. Walker. Pi-Calculus Semantics \nof Ob- ject-oriented Programming Langage. Proc. TACS Sl, Springer-Verlag, LNCS Vol. 526, pages 532-Q \n7, 1991. [68] T. Watanabe and A. Yonezawa. R.eflection in an object-oriented concurrent language. In \nProc. OOPSLA 88, ACM SIGPLAN Notices 23 (ll), pages 306-315, November 1988. [69] P. Wegner. Design issues \nfor object-based concur-rency. In Proc. of the ECOOP 91 Workshop on Object-Based Concurrent C omputing, \nLNCS 612, pages 245-256, 1992. [70] P. Wegner, G. Agha, and A. Yonezawa, editors. Workshop on Object-Based \nConcurrent Program-ming. ACM SIGPLAN Notices 24 (4), San Diego, April 1989. [71] G. Wilson and P. Lu, \neditors. Parallel Programing Using C++. MIT Press, 1996. To Appear. [72] Y. Yokote and M. Tokoro. The \ndesign and imple-mentation of Concurrent Smalltalk. In Proc. OOP-SLA 86, ACM SIGPLAN Notices, 21 (ll), \npages 331-340, November 1986. [73] A. Yonezawa and M. Tokoro. Object-Oriented Con-current Programming. \nMIT Press, Cambridge, Mass., 1987.  \n\t\t\t", "proc_id": "236337", "abstract": "We present a graphical environment for parallel object-oriented programming. It provides visual tools to develop and debug object-oriented programs as well as parallel or concurrent systems. This environment was derived from a structural operational semantics of an extension of the Eiffel language, Eiffel//. Object-related features of the language (inheritance, polymorphism) are formalized using a big-step semantics, while the interleaving model of concurrency is expressed with small-step semantics.Without user instrumentation, the interactive environment proposes features such as step-by-step animated executions, graphical visualization of object and process topology, futures and pending requests, control of interleaving, deadlock detection.", "authors": [{"name": "Isabelle Attali", "author_profile_id": "81100458193", "affiliation": "INRIA Sophia Antipolis, CNRS - I3S - Univ. Nice Sophia Antipolis, BP 93, 06902 Sophia Antipolis Cedex", "person_id": "P117051", "email_address": "", "orcid_id": ""}, {"name": "Denis Caromel", "author_profile_id": "81100007208", "affiliation": "INRIA Sophia Antipolis, CNRS - I3S - Univ. Nice Sophia Antipolis, BP 93, 06902 Sophia Antipolis Cedex", "person_id": "PP39022937", "email_address": "", "orcid_id": ""}, {"name": "Sidi O. Ehmety", "author_profile_id": "81100051621", "affiliation": "INRIA Sophia Antipolis, CNRS - I3S - Univ. Nice Sophia Antipolis, BP 93, 06902 Sophia Antipolis Cedex", "person_id": "P265042", "email_address": "", "orcid_id": ""}, {"name": "Sylvain Lippi", "author_profile_id": "81100124621", "affiliation": "INRIA Sophia Antipolis, CNRS - I3S - Univ. Nice Sophia Antipolis, BP 93, 06902 Sophia Antipolis Cedex", "person_id": "P272846", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236383", "year": "1996", "article_id": "236383", "conference": "OOPSLA", "title": "Semantic-based visualization for parallel object-oriented programming", "url": "http://dl.acm.org/citation.cfm?id=236383"}