{"article_publication_date": "10-01-1996", "fulltext": "\n Reuse Contracts: Managing the Evolution of Reusable Assets Patrick Steyaert, Carine Lucas, Kim Mens, \nTheo D Hondt Programming Technology Lab Vrije Universiteit Brussel Pleinlaan 2, 1050 Brussels, Belgium \n http:Nprogwww.vub.ac.be/ Email: prsteyae@vnet3.vub.ac.be, clucas@vnet3.vub.ac.be, kimmens@isl.vub.ac.be, \ntjdhondt@vnet3.vub.ac.be Abstract. A critical concern in the reuse of software is the propagation of \nchanges made to reusable artifacts, Without techniques to manage these changes, multiple versions of \nthese artifacts will propagate through different systems and reusers will not be able to benefit from \nimprovements to the original artifact. We propose to codify the management of change in a software system \nby means of reuse contracts that record the protocol between managers and users of a reusable asset. \nJust as real world contracts can be extended, amended and customised, reuse contracts are subject to \nparallel changes encoded by formal reuse operators: extension, refinement and concretisation. Reuse \ncontracts and their operators serve as structured documentation and facilitate the propagation of changes \nto reusable assets by indicating how much work is needed to update previously built applications, where \nand how to test and how to adjust these applications. Introduction It has become a well-known fact \nthat the degree to which software reusability is pursued is matched by the extent to which the same reusability \nfails to fulfil the high expectations. A delicate balance between longer term investments in reusable \nartifacts and the need to meet deadlines needs to be accomplished. To be properly reusable, artifacts \nshould undergo some form of certification thereby turning them into reusable assets [2]. To be able to \nleverage on the Permission to make digitakhard copy of part or all of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for profit or commercial \nadvantage, the copyright notice, the title of the publication and its date appear, and notice is given \nthat copying is by permission of ACM, Inc. To copy otherwise, to republish, to oost on servers. or to \nredistribute to ksts, requires prior specific permission and/or a fee. OOPSLA 96 CA, USA Q 1996 ACM 0-89791-788~W96/0010...$3.50 \ninvestment, reusers must be able to benefit from future improvements of the assets they reuse: proper \nevolution of reused assets should not invalidate previous reuse. In a similar vein, reuse should go beyond \nthe act of copying out code fragments and adapting them to current requirements without regard for the \nevolution of the reused fragments. This implies the management of some kind of consistency in the evolution \nof reusable software. The absence of such management mechanisms is recognised as an important inhibitor \nto successful reuse [2, 12, 161. In this paper we not only recognise the need for software to evolve \nboth during its initial design and when it is being reused, we actually advocate the development of a \nmethodology for managing change in the process of engineering reusable software. We advocate a kind of \nreuse that, unlike black-box reuse, allows reusable assets to be adapted before reuse. This makes our \napproach more akin to white-box reuse: it cannot always be guaranteed that changes to a given reusable \nasset will propagate without invalidating previous reuse. Unlike white-box reuse, however, reuse is controlled \nin a way so that reusers know when and how the assumptions they make about reusable assets are broken \nwhen this asset is changed. We propose to codify this management of change in an (object-oriented) software \nsystem by means of reuse contracts. Reuse contracts are interface d escriptions (of, for instance, classes), \noffering guidelines for reusing assets in some problem domain and recording the protocol between managers \nand users of a reusable asset. Similar to the real world where contracts can be extended, amended and \ncustomised, reuse contracts are subject to typical reuse operators: extension, refinement and concretisation. \nTogether, reuse contracts and operators can be used by the asset producer to document that part of the \ndesign that is relevant for reusers. Moreover, they document the assumptions made by reusers about the \nway an asset is reused. This documentation facilitates the propagation of changes to assets by indicating \nhow much work is necessary to update previously built applications, where and how to test and how to \nadjust these applications. Reusers thus can benefit from improvements to the assets they reuse and the \nproliferation of different versions of reusable assets can be kept to a minimum. In a similar vein, reuse \ncontracts can be valuable to the asset developer to assess the impact of changes and to decide whether \nchanges should be made. As a tangible case in which to explain our ideas, we focus on class abstractions \nwith inheritance as the reuse mechanism. This is by far the best-known and most widely used technique \navailable today for structuring object-oriented software. We use abstract classes, specialisation interfaces \n[7] and the different reuse operators, as a framework in which to study change management of method overriding. \nWe analyse some of the problems that can arise in inheritors when changes are made to a parent class \nand show how reuse contracts can help in solving these problems. While the proposed reuse operators are \nsufficiently expressive for our discussion, it is beyond the scope of this paper to give a formal treatment \nof their completeness. Interested readers can verify this and other properties in another document [8]. \nThe major contribution of this paper is the identification of a framework for the codification of the \nevolution of reusable assets. Class hierarchies are used as a specific case in which to explore a consistent \nset of reuse operators. Our conjecture is that this approach is applicable to other and possibly more \ngeneral adaptable architecture of the asset, can be used as structured documentation and generally assist \na software engineer in adapting assets to particular needs. They thus help break down the barriers between \nasset producers and asset reusers. When adopted, reuse contracts may significantly enhance the way in \nwhich software is being built and managed. systems. We even dare to suggest that reuse contracts have \na broader scope than managing evolution in reusable assets: they shed light on the 2 Conflicts with \nEvolving Parent Classes As a concrete case, in this paper we focus on reuse based on abstract classes \nand inheritance. Because the power of inheritance lies in the ability to override methods that are invoked \nby methods of the parent class, the possible problems with inheritance become apparent when considering \nthe calling structure between a class and its inheritors. A class hierarchy can evolve in different ways \n(see Fig. 1). First, a class hierarchy evolves simply by editing the classes in it. Since this corresponds \nto the replacement of a class with a new, modified version, and this class may already have a number \nof inheritors, this form of evolution is called parent class exchange. Second, classes evolve through \ninheritance. Rather than just editing it, a class s description gets modified by inheritors. This kind \nof evolution is called layering: a class s description evolves through a chain of inheritors, each adding \nits own layer of modifications. The only difference with parent class exchange is the availability -after \nmodification -of both the original class and the modified class. calling_structure Fig. 1 Problems when \nReusing Classes The problem with class evolution in general, is that modifications made to the calling \nstructure of a parent class can introduce conflicts in already existing inheritors. With layering, the \ncalling structure of a parent class gets modified by a chain of inheritors, which makes it difficult \nto assess the impact of the modifications made by intermediate inheritors. This is perceived by many \nusers of object-oriented class libraries and frameworks as one of the major obstacles to reuse them. \nSimilarly, with parent class exchange, it is difficult to detect whether changes made to the parent s \ncalling structure introduce conflicts in inheritors. As both problems are similar, we will only focus \non the latter. We take a closer look at four specific conflicts introduced by parent class exchange. \n 2.1 Conflicts in the Method Interfaces The first problem involves the case where an exchanged parent \nclass introduces a new method, while one of the inheritors had previously introduced a method with the \nsame name. If this method is not invoked by any of the other methods of the parent, at first sight, this \ncauses no erroneous behaviour (the case where this method is invoked by other methods of the parent is \ndiscussed in section 2.3). The method of the inheritor will simply override the method of the parent \nclass. But, as a consequence, the intention represented by the adaptation of the parent class will get \nlost. Moreover, as this causes no technical error, this loss will probably go unnoticed. A related problem \nis that of conflicts in annotations made to a method s interface. It is not uncommon to attach extra \ndesign information to methods. As inheritors rely on this information, this can lead to extra conflicts. \nFor example, methods can be marked as being abstract or concrete. Inheritors that override an abstract \nmethod assume that the overridden method has no implementation. This can lead to a conflict in inheritors \nwhen the parent is exchanged with a class where this abstract method is already made concrete. Apart \nfrom an annotation abstract or concrete, we will also add other design information to the interface. \n 2.2 Unimplemented Methods Another kind of problem is where an exchanged parent class introduces a new \nabstract method, that might be invoked by other methods of the exchanged parent. When already existing \ninheritors do not provide an implementation for these newly added abstract methods, this results in incomplete \nclasses. 2.3 Method Capture The exchanged parent class can include extra method invocations. These could \nbe invocations of methods that are provided by this parent class itself, but also invocations of methods \nthat are implemented by an inheritor and that were not invoked before. In the latter case, we say that \nthese methods of the inheritor get captured by the methods of the parent that invoke them. This may result \nin erroneous behaviour, as the inheritor did not take into account that its method would be invoked by \nthe parent. Two cases of method capture can be distinguished. First, the case where a method that did \nnot exist in the original parent class is now introduced and invoked. An inheritor might have introduced \na method with the same name, that will now be invoked by the new parent. As this could not be foreseen, \nwe call this accidental method capture. Second, in the exchanged parent, a method that already existed \nin the original parent might be invoked by more methods than before. An inheritor might have overridden \nthis method, and this implementation will now be invoked by more methods of the parent. As this can be \nforeseen more easily, we call it regular method capture. A good example of how a similar kind of problems \ncan occur in class hierarchies can be found in the standard Smalltalk-class library. The reason why the \nnames of primitive methods (e.g.,basicAt:,basicAt:put:, ...)on the rOOt Class (Object) are prefixed with \nbasic is exactly to avoid users accidentally introducing a method with the same name in their classes, \nthus causing a situation similar to method capture.  2.4 Inconsistent Methods When method invocations \nare omitted -which is frequently done for performance reasons -the inverse situation of method capture \ncan arise. If on parent class exchange the new parent class performs less invocations of a method than \nbefore, this might lead to inconsistent behaviour. We then say that the method that used to perform the \ninvocation has become inconsistent with the method that used to get invoked. This terminology is due \nto Kiczales and Lamping [6]. Consider the prototypical example of a Collection hierarchy. A class Set \ndefines a method add and a method addAll, which invokes add to add a group of elements to the set simultaneously. \nA subclass CountingSet might override add to keep a counter of the number of elements added to the set. \nIf on parent class exchange in a new version of Set, addAl does not invoke add anymore, this will lead \nto inconsistent behaviour in CountingSet, as not all additions will be counted. addAl has become inconsistent \nwith add.  3 Reuse Contracts 3.1 Documenting Dependencies through Specialisation Interfaces To be able \nto detect and solve the above problems it is crucial to have the right kind of documentation. Currently, \nthe main mechanism to document the design of object-oriented software systems is through abstract classes \n[5]. The client interface of an abstract class sketches the design of future concrete subclasses, by \nindicating which methods they should provide. However, information about internal dependencies is also \na crucial piece of design information to inheritors. This information can usually only be acquired by \ninspecting the code. To solve this problem, Lamping introduced specialisation interfaces as a means to \ndocument the calling structure of a class, by explicitly naming all methods that are invoked through \nself sends in each method [7]. Consider, for example, an abstract class AbstractView', that describes \nthe general behaviour of a view that visually represents a certain subject. A view can be drawn and updated. \nThe method Update relies on the method Draw and on a number of other methods for its implementation. \nI Throughout this text we use a part of a GUI library as an example. The example is inspired by [4] and \n[6]. Class AbstractView Abstract Draw0 Concrete Update0 [ self.SetPen(2); self.SetRect(40,60); self.Draw() \n] Concrete SetPen(size) [ .I. 1 Concrete SetRect(height, width) I ,.. 1  End Class  The specialisation \ninterface of AbstractView is shown below. The information on the self sends is provided by enumerating \nthe names of the referenced methods between curly braces after the method s signature. Specialisation \nInterface AbstractView Abstract Draw Concrete Update ( Draw,SetPen,SetRect ) Concrete SetPen t .. 1 Concrete \nSetRect { ~. )  End Specialisation Interface  While specialisation interfaces are an important step \ntowards achieving actual reuse of design, their main drawback is that they document the internal dependencies \nof a class by listing all self sends in a class. They do not distinguish between implementation level \nand design level dependencies and thus do not allow hiding of implementation details. While providing \ntoo little information about internal dependencies makes it impossible to define large applications in \nan implementation independent way, exposing too much implementation detail restricts the ability to evolve \nor to allow different implementations. It is thus very important to expose only those parts of the internal \nstructure that are crucial to the design of a class. Reuse contracts are introduced in the next section \nas a mechanism that distinguishes between that part of the specialisation interface that is implementation \ndependent and that part that is crucial for inheritors. They thus hide those dependencies on which inheritors \nshould not rely. A remark must also be made about the kind of information that specialisation interfaces \ncan provide. Specialisation interfaces can be specified either by listing method dependencies purely \nbased on names, or by including type information, or by including semantic information that specifies, \nfor example, the order in which methods should be invoked. The art is in finding the right balance between \ndescriptions that are easily understood and expressed, and descriptions that capture enough of the semantics \nof possible adaptations. Reuse contracts will only indicate which methods rely on which other methods, \nby enumerating the names of methods that are invoked through self sends. Although reuse contracts provide \nonly syntactic information, we will show that this is enough to firmly increase the likelihood of behaviourally \ncorrect exchange of parent classes. For simplicity we have restricted the reuse contracts we propose \nhere to include only documentation on the internal dependencies among a class s methods. The dependencies \namong the methods of one class and the methods of its acquaintances are at least as important. Just as \nour current reuse contracts are based on specialisation interfaces, reuse contracts could be developed \nbased on descriptions of interclass relationships. Such descriptions have already been studied in the \nform of contracts [3, 41, but will not be discussed here.  3.2 Definition of Reuse Contracts A reuse \ncontract is a set of method descriptions that is divided into two subsets: the abstract and the concrete \nmethod descriptions. Reuse contracts are only interfaces: they never contain actual methods, only descriptions \nof methods. Each method description consists of a method name together with a specialisation clause and \nan annotation abstract or concrete. For reasons given in the previous paragraph, the specialisation clauses \nonly list the methods that are crucial to the design of a particular method. Methods that are listed \nin specialisation clauses are called hook methods and can be abstract as well as concrete. This term \nshould not be confused with the term template methods, which is usually used to describe concrete methods \nthat invoke abstract methods in their implementation. Finally, similarly to classes and inheritance, \nnew reuse contracts can be derived from existing ones. Unlike inheritance we will have different operations \nto obtain a derived reuse contract; e.g., a reuse contract can be an extension of another one. We will \ndiscuss the meaning of the various possible relationships in section 4. Summarising, we a reuse contract \ncan be defined as follows: A reuse contract is an interface, i.e., a set of method descriptions each \nconsisting of . a unique name, . an annotation abstract or concrete, *a (possibly empty) specialisation \nclause. Furthermore, for a reuse contract to be well-formed it needs to satisfy certain conditions: \nA reuse contract is well-formed if every name occurring in one of the specialisation clauses corresponds \nto a method description appearing in the reuse contract itself; Well-formed reuse contracts can be explicitly \nrelated to other reuse contracts by one of the following operators: concretisation, extension, refinement, \nabstraction, cancellation, coarsening. Unless explicitly stated otherwise, from now on when we use the \nterm reuse contract we mean a well-formed reuse contract. As a first example, consider a reuse contract \nview describing the abstract class AbstractView from section 3.1. Reuse Contract View Abstract Draw \n Concrete Update ( Draw }  End Reuse Contract  As discussed, this reuse contract is subdivided into \nan abstract and a concrete section. While AbstractView' s speciahsation interface enumerated all methods \ninvoked through self sends in Update, in the reuse contract View only Draw is mentioned in the specialisation \nclause of Update, as the invocation of this method is the only one crucial to the design. The other methods \nthat were invoked through self sends in Update were pure implementation methods and are therefore not \nincluded in the reuse contract. Not only did we leave SetPen and SetRect out of the specialisation clause \nof the Update method, we also did not include them in the list of method descriptions in the reuse contract \nview.  3.3 Implementing Abstract Classes that Comply with Reuse Contracts Since reuse contracts only \ndescribe interfaces, implementations must be associated with them. As these implementations should satisfy \nthe design imposed by a reuse contract, the classes should comply with the reuse contracts in some way: \nwe say that a reuse contract is implemented by an (abstract) class when the conditions below are fulfilled. \nA reuse contract R is implemented by a class C if (1) C provides an implementation for all concrete method \ndescriptions of R; (2) C provides a signature, but no implementation for any abstract method description \nof R; (3) for every name n in a specialisation clause of a concrete method description m of R, the method \nin C with name n is invoked through a self send by the method corresponding to m (or by a method of C \nthat is directly or indirectly invoked by m).  According to this definition the abstract class AbstractView \nis a possible implementation of the reuse contract vi e w. The definition also immediately implies that \nreuse contracts containing abstract method descriptions are implemented by abstract classes. The need \nto explicitly declare reuse contracts as well as the compliance of classes to reuse contracts could be \ncriticised for too much verbosity. Some remarks can be made about this comment. In languages that promote \nthe separation of interface and class hierarchies, reuse contracts can be introduced as an extension \nto these interfaces. In that case, reuse contracts do not introduce too much overhead, since interfaces \nmust be specified anyway. For languages that do not include interfaces, reuse contracts can be managed \nby the programming environment. In that case, reuse contracts could be semi-automatically constructed \non the basis of the calling structure (the programmer only has to delete the descriptions and names of \nmethods that should not be exposed). Moreover, since reuse contracts are design concepts, they should \nalready have been constructed during the design phase. A problem can occur with classes that include \nimplementation-specific methods not specified by the reuse contract. As these methods are not specified \nin the reuse contract but only in the implementation, it is possible that a user later accidentally introduces \na method with the same name in the class implementing a derived reuse contract. As discussed in section \n2.3., method capture might occur. The classes that implement the reuse contracts should therefore encapsulate \nthe invocation of their implementation-specific methods (whether they are public or private) from the \nderived reuse contracts and their implementations. Different approaches are possible to achieve this. \nKiczales and Lamping suggest using a package system such as the Common Lisp package system or information \nhiding facilities such as provided in languages like C-t+ [6]. Another possibility is that a tool checks \nfor this kind of errors and requires the user to rename one of the methods involved. Yet another option \nis provided by languages that offer the possibility to explicitly encapsulate self sends [I, 141. In \nsuch languages, the self sends to implementation-specific methods can be explicitly encapsulated so that \nthey are invisible to future inheritors. Another problem that may occur with implementation-specific \nmethods is that the specialisation clauses might demand that a method m performs a self send to some \nmethod n, while this self send is not made in m itself, but only in one of the implementation-specific \nmethods invoked by m. Therefore, when verifying whether an implementation satisfies a reuse contract, \nit is actually necessary to look at the transitive closure of all self sends made from within methods. \nThis is the motivation behind the phrase: or by a method of C that is directly or indirectly invoked \nby m in clause 3 of the above definition. Note that even when a self send appears in the implementation \nof a method, it is not always possible to check -without extensive data flow analysis -whether this invocation \nwill actually be performed at run-time. It could for instance occur in the body of a conditional expression. \nAs discussed in the previous section, reuse contracts do not aim at fully specifying the design of classes \nat a behavioural level, only through descriptions.  Operators on Reuse Contracts Reuse contracts are \nonly a first step towards solving the problems concerning parent class exchange from section 2. Without \nreuse contracts it is difficult to detect problems such as method capture because specialisation interfaces \nare not explicitly available. But even making specialisation interfaces explicit does not suffice in \norder to detect problems on parent class exchange. More information is needed both on the assumptions \nmade by inheritors about their parent classes and on the way the parent classes are actually reused. \nConsider exchanging a parent class with a new parent class that introduces a new method m. When looking \nat plain inheritors, it is not always clear whether a method with the name m in the inheritor was intended \nto override the method m of the parent class or whether it was intended as a new method leading to unintended \nmethod capture. These two cases can only be differentiated by meticulously comparing the reuse contracts \nof the old parent class, the new parent class and the inheritors. This is neither practical (in practice \nthe old parent class might not even be available anymore), nor intuitively compelling. We propose a methodology \nthat is more intuitive for both inheritors and developers of reusable classes and guides them in managing \nchanges to these classes. It is based on a categorisation of the typical actions undertaken by the designers \nof both abstract classes and inheritors and the changes these actions cause in the calling structure. \nWe essentially distinguish three different logical operators on reuse contracts: concretisation, refinement \nand extension and their inverse operators: abstraction, coarsening and cancellation. Although not the \nonly operators imaginable, they do coincide with the typical ways to use abstract classes. By examining \nthe interactions between these operators and by investigating which operators respect the design, rules \ncan be proposed that facilitate exchange of reuse contracts of parent classes. In the above example, \nhad it been clear that the inheritor intended to perform an extension (i.e., introducing a new method), \nit would have been easier to detect possible problems. So, in order to be able to correctly assess the \nimpact of parent class exchange, reuse contracts must be labelled with how they are derived from other \nreuse contracts in terms of the basic operators. For the programmer, the work effort involved is obviously \nnot the adding of an extra keyword (i.e., extension, concretisation, . ..). but rather the careful construction \nof the derived reuse contract corresponding to the inheritor by means of the basic operators. While this \nputs an extra burden on the programmer for making more conscious decisions during the design process, \nthe pay-off of this work will become clear in the next sections. Moreover, supporting tools can be constructed \nthat automatically decompose the derived reuse contract of an inheritor in terms of the basic operators. \nSuch tools can also be an extra help in understanding how an inheritor differs from its parent. In this \nsection we will define the different operators, in the next section their interactions will be examined \nand we will discuss how this information can be used to detect and solve problem cases. While the definitions \nof the operators and the discussion of their interactions were developed on a much more formal level \n[S], they are presented in this paper in a way that makes their intuition more clear. For every operator \na definition, a description of the prerequisites and an inverse operator are given. Each operator will \nbe defined in terms of a modifier M. This modifier is necessary to discuss parent class exchange, as \nfor an inheritor having its parent class exchanged comes down to applying the same modifier that was \napplied to the former parent, to the new parent2. The 2 This is similar to the way inheritance is achieved \nin languages with mixin-based inheritance [I]. prerequisites for each operator will describe the exact \nform of these modifiers, as well as the conditions they must comply with in order to be correct. Modifiers \nthemselves are reuse contracts, although not necessarily well-formed ones. Every R and R, in the following \ndefinitions represent a well-formed reuse contract. Every M and M, represent a Reese modifier, i.e., \na reuse contract that is not necessarily well-formed. In the examples we will not explicitly mention \nthe modifiers, as they will always be clear from the context. 4.1 Concretisation Concretisation is an \noperation that is typically performed by an application developer, when customising assets to obtain \napplications tailored to a certain domain. It makes an asset more concrete, by overriding (some) abstract \nmethod descriptions with concrete ones. R, is a concretisation of R with M, if (1) R is concretisable \nwith M, (defined below); (2) R, contains only method descriptions with the same name and specialisation \nclause as in R; (3) every abstract method description of R listed by M, becomes concrete in R,; (4) \nall other method descriptions in R remain unchanged in R,.  When we are not explicitly interested in \nthe modifier M,, we simply say that R, is a concretisation of R. The effect of a concretisation is depicted \nin Fig. 2. Note that a concretisation does not change the calling structure, nor does it add new method \ndescriptions. Reuse Contract R Reuse Contract R, Abstract Abstract I I Fig. 2 Concretisation As concretising \na reuse contract can happen in several steps, we distinguish complete concretisations from partial concretisations. \nWhereas the former yield new reuse contracts containing only concrete method descriptions, the latter \nresult in reuse contracts that still contain abstract method descriptions and need subsequent concretisations. \nAs concretisations merely transform some abstract method descriptions of R to concrete ones, at first \nsight a correct concretisation modifier M, should only mention their names. Although including information \non the specialisation clauses as well seems to be redundant, it is necessary in order to avoid conflicts \nin the method interfaces, as will be explained in section 5.1. On the other hand, since only abstract \nmethod descriptions can be concretised, including the annotation is not really necessary. Nevertheless, \nto be consistent with the other definitions we include this redundant information.  R is concretisahle \nwith M, if every method description of M, (1) is concrete; (2) has a name corresponding to an abstract \nmethod description of R;  (3) has the same specialisation clause as in R.  The following reuse contract \nViewPort is an example of a complete concretisation of View. It transforms the only abstract method description \nDraw of View into a concrete one. Reuse Contract ViewPort is a concretisation of View Concrete Draw \n Update { Draw } End Reuse Contract As there are no abstract method descriptions in this reuse contract, \nthe keyword Abstract was left out. The opposite of a concretisation is called an abstraction. Abstraction \nwill not often be used, but might, for example, be wanted by a library developer to add a more abstract \nlayer to a class library. R, is an abstraction of R  iff R is a concretisation of R, This means that \nR, is an abstraction of R if some method descriptions that were concrete in R are made abstract in R, \nand no other changes occur.  4.2 Extension An extension adds new method descriptions to a reuse contract. \nAn application developer might use extension to introduce new method descriptions to express a certain \nbehaviour particular to the application; the developer of reusable assets might use it to enhance an \nasset s functionality. R, is an extension of R with M, if (I) R is extendible with M, (defined below); \n (2) R, contains all method descriptions of R plus all method descriptions of M,.  An extension is called \nconcrete if no abstract method descriptions are added, otherwise it is called abstract. A legal extension \nmodifier M, must fulfil the following conditions: R is extendible with M, if (I) M, contains no method \ndescription with the same name as a method description in R (2) the specialisation clauses of method \ndescriptions in M, contain only names of method descriptions occurring in M, or R.  Condition 1 is included \nto make the different operators more orthogonal. Just as a concretisation cannot add new method descriptions \n(condition 2 of concretisable) and thus perform an extension, an extension cannot affect any existing \nmethod descriptions. Reuse Contract R Reuse Contract R, I Fig. 3 Extension The reuse contract DragableView \nbelow is an example of a (concrete) extension of the reuse contract View. An extra method description \nDrag is added, representing a method that has to invoke Draw to redraw the view at its new position. \nReuse Contract DragableView is an extension of View Abstract Draw Concrete Update ( Draw } Drag { \nDraw }  End Reuse Contract The opposite of extension is called cancellation. Cancellation will mainly \nbe used by an asset developer to remove unnecessary behaviour from the asset. R, is a cancellation of \nR  iff R is an extension of R, A cancellation merely removes existing method descriptions. Of course, \nthis operation can only be performed if the method descriptions that need to be removed are not listed \nin the specialisation clauses of any other methods (unless these are removed as well).  4.3 Refinement \nFinally, refinement is the operation of overriding method descriptions in order to refine their design. \nIt can be performed by an asset developer to model the evolution of an asset, or by an application developer \nto make reuse contracts specific to some application domain, thus creating a more layered design. This \nis achieved by adding extra hook methods to the specialisation clauses of the original method descriptions. \nSince the already existing hook methods are maintained, the design of the original reuse contract is \npreserved. By adding hook methods, it is refined. As an example, consider the reuse contract Button below \nwhich is a refinement of View. It refines the method descriptions Update and Draw. Where Draw originally \nhad an empty specialisation clause, it now lists a new abstract method Geometry. Obviously, this new \nmethod description also needs to be added to the reuse contract. Because a button is always visually \nrepresented as on or off , Update is also refined to depend on this status. To represent this behaviour, \nUpdate must rely on Choose and UnChoose, whichintumrelyon Refresh to draw the button in either status. \n Reuse Contract Button is a refinement of View Abstract Geometry Draw { Geometry I Concrete Update \n{ Choose, UnChoose I Choose { Refresh 1 UnChioose ( Refresh 1 Refresh [ Draw I  End Reuse Contract \n As the example illustrates, refinements can also extend a reuse contract with new method descriptions. \nThis is the only place where the functionalities of the operations partially overlap. Condition 6 below \nrestricts this overlap by stating that new method descriptions can only be added by a refinement if they \nare (directly or indirectly) called by one of the refined methods. This is illustrated in Fig. 4. Otherwise, \nadding method descriptions is an extension. Reuse Contract R Reuse Contract R,  Fig. 4 Refinement Note \nthat while the old specialisation clause of Update listed Draw, the new one only lists Choose and UnChoose. \nThis does however indirectly lead to Refresh (because Choose and UnChooseliStRefresh), and eventually \nto Draw (because Refresh k.tS Draw). When these indirections are taken into account, it is clear that \nUpdate's new specialisation clause is indeed an augmentation of the old one. Therefore, it is necessary \nto work with the transitive closure of the specialisation clauses. Summarising all this we can define \na refinement in terms of an overriding modifier M,, and an extending modifier M,, as below.  R, is a \nrefinement of R with (M,,M,) if ( 1) R is refinable with (M,,M,) (see below); (2) R, contains all method \ndescriptions of M, and M,, as well as all method descriptions of R not corresponding to a method description \nin M,. A refinement is called concrete if none of the added method descriptions (described by M,) are \nabstract, otherwise it is nbstruct. For a modifier pair (M,,M,) to express a correct refinement, the \nfollowing constraints need to be satisfied: R is refinable with (Me,Mo) if (1) M, contains no method \ndescriptions with the same name as method descriptions in R; (2) M, contains only method descriptions \nwith the same name as method descriptions in R; (3) the method descriptions in M, have the same annotations \nas the corresponding method descriptions in R; (4) the specialisation clauses of method descriptions \nin M, or M, contain only names of method descriptions occurring in M,, M, or R; (5) the transitive closures \nof specialisation clauses in M, are augmentations of the transitive closures of the corresponding specialisation \nclauses in R; (6) the name of every method description in M, must occur in at least one of these augmented \nspecialisation clauses.  Note that a refinement does not change the annotation abstract or concrete \nattached to method descriptions. Nevertheless, again to avoid method interface problems, this information \nis included. The opposite of a refinement is called a coarsening. We discuss coarsening a bit more in \ndepth than the other inverse operators, because it is an important operator in practice. Coarsening is \nachieved by omitting hook methods from the specialisation clauses of method descriptions. Although this \nmeans partially ignoring the design of an asset, this is often done for performance reasons or because \nsome parts of the design are irrelevant to certain domains. Coarsening is defined as: Rcoarse is a coarsening \nof R if (1) every method description in RcOarSe corresponds to a method description in R; (2) these \nmethod descriptions are exactly the same as in R except that the transitive closure of their specialisation \nclause in R cOarSe can be smaller than in R; (3) method descriptions with names that were mentioned \nin specialisation clauses in R but are no longer mentioned in a IZ y specialisation clause in R,,,,,, \ncan be removed .from R,,,,,.  The motivation behind 3 is twofold. First, to avoid errors, only methods \ncorresponding to method descriptions that are not invoked anymore can be removed. Second, if these method \ndescriptions were not invoked in R either, then the operation concerned would be a cancellation rather \nthan a coarsening. To keep things simple, the above definition of coarsening was not given in terms of \nreuse modifiers. An actual coarsening modifier should associate a coarsening clause with each method, \nindicating which method invocations are removed. This information will be used later on to detect the \nproblem of inconsistent methods. 4.4 Implementation of Reuse Operators All operators on reuse contracts \nthat are defined in this paper can be achieved on their implementors through inheritance. We could, for \nexample, have an abstract class GeneralView implementing the reuse contract vi ew and a concrete class \nMacintoshView implementing the reuse Contract Viewport. While Viewport is a concretisation of View,MacintoshView \nisasubclassof GeneralView. MacintoshView Fig. 5 Implementation of Reuse Operators Note that this example \nis a simplification. First, because the techniques to encapsulate invocations of implementation-specific \nmethods as discussed in section 3.3. must be applied here. Second, because the relation between reuse \ncontracts and the classes that implement them is presented as one-to-one. This might nor always be the \ncase. Different reuse contracts can provide different views on a single class. Conversely, a single reuse \ncontract can be implemented by a chain of classes, rather than a single class. In such inheritance chains, \nthe implementor can resort to plain code reuse. Obviously, the responsibility to avoid method capture \nand other problems within these inheritance chains is then left to the implementor.   5 Managing Parent \nClass Exchange through Reuse Contracts In this section we discuss how reuse contracts help in managing \nparent class exchange. Rather than plainly examining exchange of parent classes, we will investigate \nwhat the effect is of exchanging the associated reuse contracts. We will call this base contract exchange. \nReuse contracts corresponding to parent classes are called base reuse contracts (or short, base contracts), \nand reuse contracts corresponding to the inheritors are called derived (reuse) contracts. This is depicted \nin Fig. 6. bse Rexch Base contract Fig. 6 Base Contract Exchange To examine the effect of base contract \nexchange, we investigate what happens when the same modifier Mder, that created a derived contract from \na base contract, is also applied to the exchanged base contract. Unlike plain parent class exchange, \nbase contract exchange allows the detection of conflicts by a set of simple rules. It is sufficient to \ncheck whether the modifier Mder is still applicable to the exchanged base contract (i.e., concretisable, \nextendible or refinable). If so, we can safely conclude that no assumptions made by the reuser about \nthe base contract are violated. Non-applicability indicates the existence of a conflict between the exchanged \nbase contract and these assumptions. This is further explained in the next section. More subtle conflicts, \nsuch as method capture and inconsistent methods, cannot be detected without further information on how \nthe calling structure in the exchanged base contract has changed. Exactly this information is documented \nin the exchange modifier Mexch (see Fig. 6). Rules to detect these conflicts are based on the interaction \nbetween M exch and Mdel-, As we will discuss the conflicts that may arise by combining modifiers one \nby one, the results must be iteratively applied for base reuse contract exchanges that involve several \nmodifiers. It is proven in [S] (and illustrated in a prototype tool for Smalltalk classes) that even \nif these modifiers are not explicitly known, they can always be computed by comparing the concerned reuse \ncontracts.  5.1 Conflicts in the Method Interfaces A first set of problems concerns conflicts of method \nnames or annotations, or specialisation clauses attached to a method. These conflicts can be detected \nby checking whether the modifier that created the derived contract is still applicable to the exchanged \nbase contract. Non-applicability indicates that the reuser s assumptions have been violated. Moreover, \nby taking a closer look at the particular operations involved we can differentiate between different \nkinds of conflicts. Name Conflicts: Extension versus Extension When both the exchanged base contract \nand the derived contract are created through an extension of the original base contract (i.e., in Fig. \n6 both M exch and Mde,. are extensions), name COtIfliCtS might occur. More specifically, a name conflict \noccurs when Mder introduces a new method description with the same name as a method description introduced \nby Mexch. This can be detected by checking whether the exchanged base contract is extendible with M&#38;r. \nNote that name conflicts can also occur when M exCh or Mder (or both) are refinements that introduce \nnew methods. To detect this, only the extension part of the refinement needs to be taken into account. \nThese problems are comparable to problems concerning multiple inheritance and can be solved with similar \ntechniques. In languages without multiple inheritance they have to be solved through renaming or hiding. \nAnnotation Conflicts: Concretisation versus Concretisation When both Mexch and Mdel are concretisations, \na conflict may occur when the same method gets concretised twice. This can easily be detected as the \nexchanged base contract will not be concretisable anymore with Mder (condition 2 of concretisability \nwill be violated, as the method is already concrete). Only when both concretising modifiers Mexch and \nMder manipulate a disjoint set of method names is there no problem. An analogous reasoning holds when \nboth Mexch and Mde,. are abstractions. Although such annotation conflicts will not cause a problem for \nthe corresponding classes technically, the knowledge that Mder is no longer a correct concretisation \nindicates that there might be a problem on the behavioural level, because the concretisation (and the \ncorresponding implementation) given by the exchanged base contract will be ignored. The reuser can solve \nthis problem either by removing Mde,., thus accepting the concretisation Mexch, or by turning Mder into \na refinement which combines both concretisations, or by turning Mder into a coarsening which (partially) \nignores the concretisation Mexch. Specialisation Clause Conflicts: Refinement  versus Refinement When \nMexch and Mder are both refinements that refine the same method a conflict might arise. This is the case \nwhen the specialisation clause of this method in Mexch contains more names than the corresponding specialisation \nclause in Mder. In that case, Mder will not be a correct refinement of the exchanged base contract. The \nreuser can solve this problem by changing the Mder modifier into a coarsening thereby indicating that \nhe has no interest in respecting the design of the exchanged base class. A more elaborate solution is \nto re-implement the conflicting method as a correct refinement. Mixed Conflicts: Concretisation versus \n Refinement Mixed conflicts concerning the specialisation clauses, as well as the annotations abstract \nor concrete can occur when Mexc,, is a refinement is a concretisation or vice versa. In the case where \nthe base contract is exchanged for a refined version and a derived contract was made by performing a \nconcretisation of the base contract, the concretisation Mder will not always be applicable to the exchanged \nbase contract. Consider, for example, the reuse contract Viewport and her which concretises the Draw \nmethod of View, and the reuse contract BU t ton which refines the draw method of view to invoke a newly \nintroduced method Geometry. Despite the orthogonality of concretisation and refinement, the concretisation \nthat created Viewport from view cannot be applied to Button. Applying this concretisation could lead \nto incorrect behaviour as the implementation of Draw corresponding to ViewPort is not required to perform \nany self sends, while the implementation of Draw corresponding to But ton is obliged to invoke Geometry. \nFor this reason, a concretisation  Base contract Concretisation exchange Operation to create derived \ncontract Concretisation annotation conflict Extension / Extension Part no method of Refinement interface \nconflict Overriding Part mixed conflict (2) of Refinement 5.2 Unimplemented Methods The second kind \nof problem, somewhat related to method interface conflicts, is that of unimplemented methods. This problem \noccurs, for example, when a base contract is exchanged with can only be applied to reuse contracts where \nthe methods to be concretised have the same specialisation clauses. This is the motivation behind condition \n3 in the definition of concretisable. Similar problems occur when the derived contract is a refinement \nand the base contract is a concretisation of the original base contract. Information on the annotations \nabs t rat t or concrete in a refinement modifier is necessary as refining an abstract method is essentially \ndifferent from refining a concrete method, since in the first case no implementation is required while \nin the second case there is. This is the motivation behind condition 3 in the definition of refinable. \nThe only remedy is to update the conflicting parts (and the associated reuse contracts), so that they \ndo take the extra design information into account. Summary The continued applicability of the reuse modifiers \nindicates to reusers which parts of their applications can be trusted, and which parts might introduce \nbehavioural problems. This set of problems can be further subdivided, depending on the kind of operations \ninvolved, as summarised by the table below. For refinements, a distinction is made depending on whether \nrefinability fails due to a conflict in its extension part or in its overriding part.  Extension / \nExtension Overriding Part Part of Refinement of Refinement no method interface mixed conflict (1) conflict \nname conflict no method interface conflict no method interface specialisation clause conflict conflict \nan extended or refined version that adds new abstract method descriptions. A concrete reuse contract \nthat was derived from a base contract through a concretisation is not concrete anymore when derived from \nthe exchanged base contract and needs additional concretisations. Only when the extension or refinement \nis concrete (i.e., when only concrete methods are introduced) can it be guaranteed that no unimplemented \nmethods will be introduced. This is summarised by the following property: If Rder is a complete concretisation \nof Rbase with Mder and Rcxch is a concrete refinement or extension of &#38;me and hew is a concretisation \nof Rexch with Mder then R,,, is a complete COnCretktiOII of Rexch with Mder. This implies that extensions \nand the extending parts of refinements can be performed freely, without having to worry much about possibly \nexisting concretisations. Either the concretisations will still be complete or else it is easy to determine \nhow the partial concretisations can be completed. In general, an extra concretisation needs to be performed \non all abstract method descriptions added through the refinement or extension. This is a significant \nresult as it means that users that only use an asset by concretising it, can easily switch to new versions \nof the system, as long as this new version is obtained by only making correct refinements and extensions \nof the old one. However, problems of method capture and inconsistent methods might still occur. Note \nthat the problem of unimplemented methods can also occur when, for example, Mexch is a cancellation and \nMder is a refinement that introduces this cancelled method in its specialisation clause. The reuser depends \non a method that has been removed. The only solution therefore is to incorporate the old implementation \ninto the reuser s implementation. 5.3 Conflicts in the Calling Structure Method Capture While applicability \nof reuse modifiers can check method interface conflicts, for the detection of more subtle conflicts, \nsuch as method capture and inconsistent methods, the specialisation clauses of the modifiers must be \ntaken into account. A method capture occurs when a hook method m that is added by exchanging a base contract \nis also added or changed by a derived contract (Fig. 7). It is accidental when the method m did not yet \noccur in the original base contract. base Rexch Refineme or Extensi . . . . . . . . . . . . . . . . . \n. Mexch  Fig. 7 Definition of Method Capture Thus, accidental method capture only occurs when both reuse \nmodifiers are extensions or refinements that introduce the method m in their extension part, thereby \ncausing a name conflict. This is illustrated in the following check for accidental method capture that \nadds an extra condition to the rule for name conflicts. If a method m is the cause of a name conflict \nwhen applying a reuse modifier Mder after Mex,-h and m occurs in the specialisation clause of a method \nn in Mexch. then m gets accidentally captured by n Regular method capture is more complicated to check \nas it does not introduce a method interface conflict (i.e., Mder remains applicable after base contract \nexchange). Reuse contracts in their current form only allow detection of regular method capture by comparing \nthe specialisation clauses from the original base contract with the specialisation clause of the exchange \nmodifier (to find newly added hook methods), and the interface of Mder. The detection of regular method \ncapture thus happens directly on the level of specialisation clauses (and not on the level of applicability \nchecks as is the case with the other rules) and by taking the original base contract into account. This \ncan be amended by making explicit in the Mexch modifier which part of the specialisation clause is new. \nWe did not do so because we are not entirely convinced that regular method capture is indeed a conflict. \nRegular method capture can be entirely anticipated by the developer of the exchanged base contract. In \nany case, the user should be notified of occurrences of accidental method capture. Sometimes these captured \nmethods have the expected behaviour on the corresponding classes, so that it is still (behaviourally) \ncorrect to apply Mder to the adapted base contract Rexch although as another operation. When this is \nnot the case, the problem can be solved by encapsulation techniques, as was discussed for implementation-specific \nmethods in section 3.3. Inconsistent Methods While method capture occurs when augmenting the specialisation \nclauses in a base contract  hISi inconsistent methods are created when parts of the design are omitted \nby narrowing these specialisation clauses. Fig. 8 illustrates this. R base %xh Fig. 8 Definition of Inconsistent \nMethods Notice that inconsistent methods can only appear when the set of hook methods removed by exchanging \nthe base contract and the set of names of method descriptions changed or added by the reuse modifier \nMder are not disjoint. Therefore inconsistent methods can be detected as follows: Assume that Rbase is \na base contract, and that R eXch and Rder are derived from Rbase by applying modifiers Mexch and Mder \nrespectively. If M exch is a coarsening where the coarsening clause associated to some method n contains \nm, and m also occurs in the interface of Mder then n becomes inconsistent with m Indeed, inconsistent \nmethods can only be introduced by coarsenings or cancellations, since these are the only operations that \nnarrow (or delete) specialisation clauses. Cancellation however does not create inconsistencies, as the \nmethod description that omitted the reference from its specialisation clause simply does not exist anymore. \nTherefore only coarsenings can create inconsistent methods. Notice that, similar to method capture, two \nforms of inconsistencies between methods exist, depending on whether the methods that have been removed \nfrom the specialisation clauses are also cancelled. In the latter case, an extra conflict will arise \nsince the Mder modifier in Fig. 8 will not be applicable after base contract exchange. Once inconsistencies \nare detected, the solution is straightforward. On base contract exchange, all method descriptions n that \nhave become inconsistent due to a coarsening might need to be adapted by the derived reuse contract Rnew~er \nas well. Whereas they used to rely on a method m to implement their behaviour, they do not anymore in \nthe exchanged base contract. This might lead to inconsistent behaviour with respect to derived reuse \ncontracts that depended on this information. Recall the example from section 2.4. After exchanging the \nclass set with a version of addAl that does not invoke add anymore, the subclass Countingset needs to \noverride addAl as well to avoid inconsistent behaviour. 5.4 Evaluation The previous sections gave simple \nrules to detect problems when exchanging parent classes. Most of the possible conflicts are directly \nexpressed in terms of reuse contracts and operators rather than on the level of interfaces and calling \nstructures. This allows developers to reason about change in more intuitive terms and on a higher level \nthan previously possible. Because conflicts upon change can be easily detected, reuse contracts help \nto predict the work effort to update existing applications. Because they document what aspects possible \nreusers can rely on, they can also be used by developers of a reuse library to decide whether making \na certain change to the reuse library is a good idea or not. For example, when adding method descriptions \nto specialisation clauses, a distinction can be made between adding new method descriptions and adding \nalready existing method descriptions. When adding already existing method descriptions to specialisation \nclauses, a developer of reusable assets knows that there is a great chance that method capture will occur. \nWhen these method descriptions are abstract this is even a certainty, since these method descriptions \nmust be concretised by derived contracts. Therefore the developer might try to avoid doing this or at \nleast pay extra attention that the captured method is only used for what it was originally defined for. \nIn the same vein, the rules from the previous section can be used to guide application developers in \nunderstanding where testing is needed when the reusable asset has changed and how to fix the problems. \nWe have mainly explained how reuse contracts can be useful in the context of reusable asset evolution. \nReuse contracts are also an important aid in making the layered structure of classes more explicit. As \nmentioned in section 2, the problems involved are similar to those in evolution of class hierarchies. \nAssociating reuse contracts with classes in a class hierarchy helps in solving these problems by classifying \ndifferent inheritors by the operators with which the associated reuse contracts are derived and pointing \nout possible conflicts when methods are overridden in the class hierarchy. Future Work Extensions to \nthe model Although we restricted ourselves to only three operators on reuse contracts, others are imaginable. \nFor example, in the course of changing an abstract class a frequent operation is that of refactoring \nexisting methods by introducing intermediate methods. The method Update in the reuse contract Button \nis such an example. In our approach this was implicitly achieved through refinement. One could also think \nof predefining frequent combinations of operators on reuse contracts. An interesting example of such \na combined operator on reuse contracts is turning an abstract hook method into a concrete method that \ninvokes newly introduced abstract hook methods. This is a typical operation to add a more concrete layer \nto an abstract class. Currently, such an operator is a combination of a refinement and a concretisation \n. A more serious extension of reuse contracts is including interclass relationships. In their current \nform, reuse contracts only document the internal dependencies among a class s methods. Part of our future \nwork is studying how reuse contracts can be extended to include interclass dependencies as well, yet \non a less behavioural level than contracts [3, 41.  Tools When necessary, reuse contracts and the relationships \nbetween reuse contracts must be deduced. We already dispose of a prototype implementation of such a too13. \nThis tool also checks the correctness of explicitly declared relationships and signals possible problem \nsituations as discussed throughout the text. Such tools can also assist in the synchronisation of reuse \ncontracts and their implementations. Two situations can be distinguished. In those parts of the reuse \nlibrary that have a stable design, the implementation must be forced to comply to the reuse contract. \nIn those parts that are still subject to major redesign, it should be possible to make changes to both \nimplementation and reuse contracts independently. The environment could discretely issue warnings, but \nshould not become a hindrance. Analysis and Design Notations Reuse contracts provide design information \nthat is complementary to what conventional object-oriented design notations provide. We are actively \ninvestigating how reuse contracts can be integrated with existing design notations and how the same principles \ncould be applied to analysis and design specifications instead of classes. 3 A prototype tool in Prolog \ncan be found via the URL http://progwww.vub.ac.be/prog/pools/rcs/rc.html. We are also currently working \non a reuse contract -extractor for Smalltalk classes.  Related Work The work of Kiczales and Lamping \nforms the basis for this work by describing the problems involved in the specification of class libraries \nand by stressing the importance of internal dependencies [6, 71. Lamping approaches this from a library \nspecification angle and uses the interfaces primarily as documentation. Stata and Guttag extend the idea \nof specialisation interfaces to incorporate full behavioural specifications [ 131. Ossher and Harrison \ndiscuss the combination of independently developed inheritance hierarchies [lo]. They suggest a new way \nof system building, where systems are not adapted by subclassing or modifying code, but by combining \nexisting hierarchies with merge operators. Their proposal can however only handle non-conflicting parallel \n extensions (two extensions are non-conflicting if the order in which they are combined has no importance). \nIn their further work, they present composition rules to combine different independently developed subjects \n[ 1 I]. This work is more focused on the implementation level than on the design level. Reuse contracts \nare based on separating a particular kind of design information from the implementation. Recently a lot \nof attention has been paid to separation of concerns: separating the various aspects that a piece of \nsoftware consists of. Examples of such aspects are: algorithmics, data representation and synchronisation. \nAspect-oriented programming (AOP) is a new programming paradigm under development, entirely based upon \nthis principle [15]. It seems that AOP and reuse contracts are complementary. Another way to handle evolving \nframeworks is refactoring [9] of class hierarchies. This work is, in our opinion, complementary to our \nwork. Refactoring aims at transforming entire class hierarchies in order to make them more reusable, \nfor example, by abstracting common behaviour into abstract classes. It is based on code analysis and \ntransformation. Our work also starts from class hierarchies, but deals with how to manage design changes \nthat propagate through these hierarchies. 8 Conclusions Although recently important advances have been \nachieved in object-oriented software engineering, reusability still fails to fulfil its high expectations. \nTwo of the most important inhibitors to successful reuse are the lack of adequate documentation and the \nabsence of mechanisms to manage the propagation of changes to reusable assets through applications that \nhave been built on them. Reuse contracts and reuse operators solve these problems by recording the protocol \nbetween producers and users of reusable assets. They not only document the design intentions of the asset \nproducer, but also the assumptions made by reusers about the assets they reuse. When changes are made \nto assets, this documentation allows to identify which of these assumptions are no longer valid and thus \nwhere the applications built on the assets should no longer be trusted. A detailed study of the reuse \noperators and their interactions led to rules that describe just that. These rules indicate to reusers \nwhere and how to test and adjust applications, when the assets on which they were built undergo changes. \nIn a similar vein, they assist asset developers in assessing the impact of changes they make. 9 Acknowledgements \nSpecial thanks to Adele Goldberg for supporting this paper and for her suggestions that fundamentally \nimproved it. The authors would also like to thank Niels Boyen, Koen De Hondt, Wolfgang De Meuter, Serge \nDemeyer, Kris De Volder, Karel Driesen, Theo Dirk Meijler, Mira Mezini, Tom Mens, Bedir Tekinerdogan \nand Marc Van Limberghen for useful discussions on this subject and for reading drafts of this paper. \nWe also thank the EROOS group (Eric Steegmans, Sam De Backer, Jan Dockx, Bart Swennen and Stefan Van \nBaelen) for interesting exchanges of ideas on the subject. Also thanks to Wilfried Verachtert and Wim \nCodenie at OOPartners for early discussions on the topic. 10 References ill Bracha, G. The Programming \nLanguage Jigsaw: Mixins, Modularity and Multiple Inheritnnce, PhD Thesis, Dept. of Computer [I 11 Ossher, \nH., Kaplan, M., Harrison, W., Katz, Science, University of Utah, 1992. A., Kruskal, V. Subject-Oriented \n[21 Goldberg, A., Rubin, K. Succeeding with Composition Rules , Proceedings of Objects: Decision Frameworks \nfor Project OOPSLA 9.5, Conference on Object-Management, ISBN o-201-62878-3, Oriented Programming, Systems, \nAddison-Wesley Publishing Company, Languages and Applications, pp. 235-250, 1995. ACM Press, 1995. 131 \nHelm, R., Holland, I., Gangopadhyay, D. [121 Pancake, C. Object Roundtable, The Contracts: Specifying \nBehavioral Promise and the Cost of Object Compositions in Object-Oriented Systems , Technology: A Five-Year \nForecast , Proceedings of Joint ECOOP/OOPSLA 90 Communications of the ACM, October 1995, Conference, \npp. 169-180, ACM Press, Vol 38(10), pp. 32-49, ACM Press, 1995. 1990. 1131 Stata, R., Guttag, J. Modular \nReasoning in 141 Holland, 1. The Design and Representation the Presence of Subclassing , Proceedings \nof Object-Oriented Components, PhD thesis, ofOOPSLA 92, Conference on Object-Northeastern University, \n183 pages, 1992. Oriented Programming, Systems, [51 Johnson, R., Foote, B. Designing Reusable Languages \nand Applications, pp. 200-214, Classes , Journal of Object-Oriented ACM Press, 1995. Programming, l(2): \n22-35, 1988. iI41 Van Limberghen, M., Mens, T. [61 Kiczales, G., Lamping, J. Issues in the Encapsulation \nand Composition as Design and Specification of Class Orthogonal Operators on Mixins: A Libraries , Proceedings \nof OOPSLA 92, Solution to Multiple Inheritance Conference on Object-Oriented Program-Problems , Object \nOriented Systems ming, Systems, Languages and Applica-Journal, Volume 3, Number 1, tions, pp. 435-451, \nACM Press, 1992. Chapmann&#38;Hall, 1996. [71 Lamping, J. Typing the Specialisation [I51 Xerox Part Aspect-Oriented \nProgramming Interface , Proceedings of OOPSLA 93, Project, A position paper on Aspect-Conference on Object-Oriented \nProgram-Oriented Programming , position paper for ming, Systems, Languages and Applica-the ACM Workshop \non Strategic Directions tions, pp. 201-215, ACM Press, 1993. in Computing Research, Working Group [81 \nMens, K., Lucas, C., Steyaert, P. ARC: an Object-Oriented Programming, June 14-15 Algebra of Reuse Contracts \n, Tech-report 1996, MIT, USA available at: progftp.vub.ac.be/tech-report [161 Yourdon, E. Object-Oriented \nSystem /I 996/vub-prog-tr-96-03.ps.Z. Design: An integrated Approach, Yourdon [91 Opdyke, W., Johnson, \nR. Refactoring: An Press Computing Systems, Prentice Hall, Aid in Designing Application Frameworks 1994. \nand Evolving Object-Oriented Systems , Proceedings of Symposium on Object-Orierlted Programming Emphasizing \nPractical Applications (SOOPPA), 1990. [lOI Ossher, H., Harrison, W. Combination of Inheritance Hierarchies \n, Proceedings of OOPSLA 92, Conference on Object-Oriented Programming, Systems, Languages and Applications, \npp. 25-40, ACM Press. 1992.  \n\t\t\t", "proc_id": "236337", "abstract": "A critical concern in the reuse of software is the propagation of changes made to reusable artifacts. Without techniques to manage these changes, multiple versions of these artifacts will propagate through different systems and reusers will not be able to benefit from improvements to the original artifact. We propose to codify the management of change in a software system by means of reuse contracts that record the protocol between managers and users of a reusable asset. Just as real world contracts can be extended, amended and customised, reuse contracts are subject to parallel changes encoded by formal reuse operators: extension, refinement and concretisation. Reuse contracts and their operators serve as structured documentation and facilitate the propagation of changes to reusable assets by indicating how much work is needed to update previously built applications, where and how to test and how to adjust these applications.", "authors": [{"name": "Patrick Steyaert", "author_profile_id": "81100327733", "affiliation": "Programming Technology Lab, Vrije Universiteit Brussel, Pleinlaan 2, 1050 Brussels, Belgium", "person_id": "P220643", "email_address": "", "orcid_id": ""}, {"name": "Carine Lucas", "author_profile_id": "81100597283", "affiliation": "Programming Technology Lab, Vrije Universiteit Brussel, Pleinlaan 2, 1050 Brussels, Belgium", "person_id": "PP31085345", "email_address": "", "orcid_id": ""}, {"name": "Kim Mens", "author_profile_id": "81100460617", "affiliation": "Programming Technology Lab, Vrije Universiteit Brussel, Pleinlaan 2, 1050 Brussels, Belgium", "person_id": "PP39080454", "email_address": "", "orcid_id": ""}, {"name": "Theo D'Hondt", "author_profile_id": "81100105560", "affiliation": "Programming Technology Lab, Vrije Universiteit Brussel, Pleinlaan 2, 1050 Brussels, Belgium", "person_id": "PP39070754", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236363", "year": "1996", "article_id": "236363", "conference": "OOPSLA", "title": "Reuse contracts: managing the evolution of reusable assets", "url": "http://dl.acm.org/citation.cfm?id=236363"}