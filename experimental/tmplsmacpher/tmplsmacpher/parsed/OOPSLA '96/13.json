{"article_publication_date": "10-01-1996", "fulltext": "\n A Functional Layer for Description Logics: Knowledge Representation Meets Object-Oriented Programming \n Ralf Miiller ? University of Hamburg, Computer Science Department Vogt-Kalln-Str. 30, D-22527 Hamburg, \nGermany moeller@informatik.uni-hamburg.de Abstract: The paper motivates the facilities provided by modeled. \nThis means that programming is still neces- Description Logics in an object-oriented programming sce- \n sary. The question is, how this should be treated. One nario. It presents a unification approach of \nDescription approach is to emphasize the logical model and to Logics and object-oriented programming \nthat allows both avoid talking about the additional procedural pro- views to be conveniently used for \ndifferent subproblems in gramming parts. This can be called the Dr. Jekyll and a modern software-engineering \nenvironment. The main thesis of this paper is that in order to use Description Log- Mr. Hyde approach. \nIn my opinion, from a software its in practical applications, a seamless integration with engineering \nperspective, it is more advantageous to object-oriented system development methodologies must make the \nbest of the two worlds. When a subproblem be realized. of a complex application can be adequately solved \nwith Description Logics, this formalism should be 1. Introduction used. However, the DL solution must \nbe integrated into the whole system development approach which,Object-oriented modeling is now a standard \ntechnique at the current state of the art, uses object-orientedfor application development (see the discussions \nin modeling. Object-oriented modeling (or program-[8] and [9]). In addition to object-oriented modeling, \nming) is intimately related with incremental develop-Description Logics (DL) have been proven to be a \nment and reuse. When a DL is to be integrated into useful formalism for modeling knowledge in a spe-such \nan environment, the 00-mechanisms should cific domain (see e.g. [33] for a commercial example also be \napplicable to the DL part. In this paper, it is application). A DL provides a relational rather than \nan shown how both representation and modelingobject-oriented way of modeling ([4], [32]). The main approaches, \nlogical modeling and object-orientedadvantages of the DL perspective are that (i) infer- programming, \ncan complement each other. The paper ences about domain objects can be formally modeled presents a unification \napproach that allows both and (ii) A DL can deal with incomplete conceptual views to be conveniently \nused for different subprob-information about objects. lems in a software-engineering environment. Although \nthe logical semantics of DL modeling con-Object-oriented programming is only a very vague structs is \na big plus, to ensure decidability of the sub- *a term for a variety of approaches to software structur-sumption \nproblem, the expressiveness of the logical ing and system development ([8], [9]). In this paper, language \nmust be limited ([231, 1321). The conse-the Common Lisp perspective will be used [30]. The quence is \nthat in a real application without toy prob- document is written for readers with an object-ori-lems, \ncurrently not all aspects can be fm-mlly ented programming background. It assumes basic Permission to \nmake digitalkard copy of part or all of this work for personal knowledge about CLOS ([14], [15], [24]). \nA short or ckssroom use Is granted without fee provided that copies are not made or distributed for p!ofit \nor commercial advantage, the copyright notice, the introduction to the main ideas behind Descriptiontitle \nof the publication and its date appear, and notice is given that @JPYing is by Permission of ACM, Inc. \nTo copy otherwise, to republish, to Logics is given with several examples. Description post on servers, \nor to redistnbute to lists, requires prior specific permission and/or a fee. Logic is also a very general \nname for different theo- ries and practical systems [32]. One implementation OOPSIA 96 CA, USA (73 1996 \nACM 0-89791-788-x/96/001 0...$3.50 of a DL is the CLASSIC system ([I], [3], [25], [29]) which will be \nused for the examples presented in this paper. The integration of CLASSIC and CLOS requires that generic \nfunctions and methods can be written for CLASSIC objects (called individuals for historical reasons). \nThe procedural parts of an application should be able to use CLASSIC individuals just like CLOS instances. \nThe services of an object are accessed only by the use of functions. This means that the relational part \nof CLASSIC should be hidden behind a functional layer because, from a software engineering point of view, \ndealing with individuals and relations can be quite cumbersome for at least two reasons: First of all, \nfrom a functional program-ming point of view it is irrelevant whether a result of a function call is \ndefined by merely looking up a set of instances in a relation table or by actually computing instances \nwith complex algorithms and auxiliary data structures.2 Second, using generic accessor functions for \nretrieving the objects that are directly set into rela- tion to a specific individual allows a lot of \nerror checking code to be automatically generated. A uni- fied interface for accessing the services that \nan object provides hides many representation details which are irrelevant from a more abstract perspective. \nThe advantages of a logical representation system like CLASSIC, i.e. its ability to deduce implicit informa-tion, \nwill be presented with a small object-oriented software-engineering scenario. Using three common programming \nproblems (also called design patterns [lo]) it will be shown that a Description Logic pro-vides solutions \nwithin the language itself, i.e. there is no need to find specific implementation tricks or pro- gramming \nconventions to adequately implement the 1. CLASSIC can be licensed from AT&#38;T Bell Labs. The code \nfor the extensions presented in this paper is available from the author [ 191. 2. Sometimes so-called \nvirtual relations (or virtual slots) are used whose fillers are computed by functions that access the \nfill- ers of other relations (or slots). However, conceptual assertions about virtual relations are not \nsupported (see also Section 2.6) and therefore, these relations are somewhat asymmetric.  design patterns. \nWe will discuss the following pat-terns: . Define an interface for creating objects but let subclasses \nspecify which classes should actually be used to instantiate objects and the correspond- ing subobjects \n(design pattern Factory Method in [IO]). This problem is also called the Make isn t Generic Problem (the \nterm has been coined by Kiczales [ 171). . Automatically change (or adapt) the class of an object to \na certain subclass when the object is associated with another object. Deal with conceptual assertions \nfor individual objects at runtime (e.g. the type of associated objects, or the number of objects associated \nwith an object using a certain relation).  2. The Use of DL in an OOP Scenario Let us assume, that in \na press office, information about an unknown ship is gathered because of an SOS signal being received. \nThe kind of the ship determines the importance of the SOS signal. For instance, for the next newspaper \nissue, there will be last minute changes to the banner headline whenever a passenger ship is found to \nbe in distress. Thus, ini-tially, there is a ship instance and step by step addi-tional information about \nthis ship will be added. The information that a certain ship is a passenger ship might not be given explicitly. \nThe information source for the press office might not know that passenger ship , which serves as a trigger \nfor additional pro-cesses here, is an important piece of information. 2.1. Example Domain: Modeling Ships \n The world model for this example domain consists of a few concepts and roles which will be presented \nusing the KRSS syntax for CLASSIC [26]. Concepts can be compared to classes and can be described with \nsuperconcepts and restrictions for role fillers (neces-sary and sufficient conditions). A primitive concept \n(declared with define-primitive-concept) is only partially described with necessary conditions. If also \nsufficient conditions are given, a defined con-cept is described (declared with define-concept). The \ncomplete set of concept definitions is called TBox. The root of the concept hierarchy is classic-thing \n(compare this to standard-object in CLOS). Our initial TBox is defined as follows: (define-primitive-conceptperson \nclassic-thing) (define-primitive-conceptcargo-object classic-thing) (define-primitive-conceptcontainer \ncargo-object) (define-primitive-conceptpassenger (and person cargo-object))  Roles to relate individuals \nmust be declared as well (for the term role , the term relation is often used as a synonym). In a similar \nway as concepts, roles can be hierarchically related as well (nil is used for no parent ).3 The inverse \nof a role can be declared as well. (define-primitive-role has-ship nil) (define-primitive-concept captain \nperson) (define-primitive-role has-cargo-object nil) (define-primitive-role has-captain nil :inverse \nhas-ship) (define-primitive-role has-position nil) (define-primitive-conceptpos classic-thing) (define-primitive-role \nhas-x-coordinate nil) (define-primitive-role has-y-coordinate nil) (define-primitive-concept ship (and \n(all has-cargo-object cargo-object) (at-least 1 has-position) (at-most 1 has-position) (all has-position \npas) (at-most 1 has-captain) (all has-captain captain)))  The concept ship will be explained in detail. \nThe declaration specifies that all cargo objects (relation has-cargo-object) must be instances of cargo-object, \ni.e., in DL terminology, they must be sub-sumed by cargo-object. All fillers of the role has-captain \nmust be captains. For each ship, there will be exactly one filler for the role has-position (which must \nbe subsumed by the concept pos) and at most one filler for has-captain (which must be subsumed by captain). \n3.Asubrole(or subrelation)identifies relation a subsetofthe tuples superrole. definedbythe  From a \ndata representation point of view, this small domain model could also be represented with CLOS (or any \nother object-oriented representation mecha-nism). So, what are the advantages of Description Logics? \nThe answer is that a DL can be used to deduce implicit information. In the following sec-tions, we will \ndiscuss three simple examples which indicate why deductive capabilities of Description Logics go far \nbeyond object-oriented programming. Before we discuss the examples, I would like give a brief overview \non the semantics of description logics. 2.2. Semantics of Description Logics Concept terms are mapped \nonto logical formulas. For instance, (all r C) is mapped onto the formula: where D is the domain (universe \nof discourse), Y is a relation and C is a concept term. Cardinality restric-tions like (at-least 1 z-1 \nare mapped onto formu-las with existantial quantifiers. hx,Ll(ye D, r(x,y)) The and concept term constructor \nis mapped onto a logical conjunction etc. Statements with (define-primitive-concept C term) and (define-concept \nc term) are mapped onto the following logical axioms, respectively. V(xe D.C(x) *term(x)) V(xe D,C(x) \n-term(x)) The first declaration defines only necessary condi-tions for a concept C (implication) while \nthe second defines also sufficient conditions (bi-implication). A concept C is a superconcept D iff C(x) \n=> D(x). The superconcept-subconcept relationship is also called the subsumption relationship. A detailed \ndescription of the semantics of the CLASSIC representation lan-guage is beyond the scope of this paper \n(see [2]). The logical axioms provide the basis for logical deductions to derive implicit information. \nA DL rea-soner can be interpreted as a sound and complete inference engine for a subset of First-Order \nPredicate Logic. Thus, in contrast to the semantics of program- ming languages, the semantics of the \nDL language also defines what has to be computed by a DL rea-soner given a set of input formulas (i.e. \nthere is no need to define an operational semantics). For instance, the set of concept and relation definitions \n(TBox) can be checked for consistency. Furthermore, implicit subsumption relations between defined concepts \nare automatically detected. For example, the TBox could be extended by the follow- ing concept definitions: \n (define-concept ship-with-captain (and ship (at-least 1 has-captain))) (define-concept ship-with-cargo \n(and ship (at-least 1 has-cargo-object) (at-least 1 has-captain))) Though not explicitly stated, it \nis evident that ship-with-cargo is also a subconcept of ship-with-captain and the TBox reasoner adds \nship-with-captain as a superconcept of ship-with-cargo. However, in general, finding these implicit subsump-tion \nrelations in the TBox can be very difficult (see ~231, ~321). 2.3. Dynamic Classification Computing the \nsubsumption relation and doing con-sistency checking in the TBox is one kind of service a DL reasoner \noffers. Consistency checking is also done for individuals in the ABox. For example, only one captain \ncan be set into relation to a ship via the has-captain relation. More interesting than consistency checking \nis the dynamic classification service for ABox individuals. The ABox incremen-tally derives the concepts \nof an individual from its relations to other individuals (forward reasoning). This is possible for defined \nconcepts which are described with necessary and suficient conditions (see above). Concrete individuals \nare created in the ABox with the following statements: (define-distinct-individual sl) (state (instance \nsl ship)) (define-distinct-individual cl) (state (instance cl captain))  Instances can be related \nto each other by an addi-tional ABox statement: (state (related sl cl has-captain))  After this statement \nhas been asserted, the ABox of CLASSIC will deduce that sl is not only a ship but must also be a ship-with-captain. \nNote that the additional concept ship-with-captain is not explicitly stated for s 1. It is automatically \nderived from the relation of sl to other individuals (in this case cl). If cl were not known to be a \ncaptain, this would also be inferred as a by-product (see the restriction (all has-captain captain) in \nthe definition of ship). Why is this an important service which an object sys-tem definitely should provide? \nThe answer is that the first design pattern of the introduction (Factory Method) can be elegantly implemented \nusing the DL facilities. In other words, it solves the Make isn t Generic Problem . This problem will \nbecome appar-ent a larger software development scenario. I will explain it using our ship domain.  2.4. \nDynamic Classification as a Solution to the Make Isn t Generic Problem At the heart of object-oriented \nsystem design is the notion of reuse. Therefore, let us assume a large soft-ware package for handling \nships has been developed by a software company Seasoft. A shipping firm Ocean-Trade will buy the product \nif the local soft-ware development team of Ocean-Trade can adapt the software library to the needs of \nthe firm. Obvi-ously, Seasoft will not give away the source code and Ocean-Trade gets an object-oriented \nsoftware library with classes and methods in binary format only. Surprisingly, object-oriented development \nalone does not guarantee enough flexibility even for simple pro-gramming problems. A simple example shows \nwhere standard 00 techniques fail or where they are more complicated than necessary. The software system \nof Seasoft contains classes (or, as we will see, even bet-ter: concepts) that are used for modeling ships, \nposi- tions, persons, passengers, captains etc. However, the need to represent a ship-with-captain has \nnot been anticipated (ship-with-captain serves as a placeholder for something to be incrementally added \nby Ocean-Trade here). Like many large software sys-tems, the Seasoft library generates objects internally. \nFor instance, for planning purposes, additional ships might be created by the Seasoft logistics module \nwhich consists of a set of ship classes. We assume that a set of generic functions have been defined \nto solve a logistics planning problem. For the predefined Seasoft ship classes, methods are written as \nusual. The out-put of the planning system might be a report to pro-pose further investments etc. Let \nus return to Ocean-Trade now. In our scenario, the planning module must be adapted to match the needs \nof Ocean-Trade. In the spirit of object-oriented pro-gramming, subclasses of predefined classes will \nbe created and methods might be overwritten . Due to an object-oriented system design, there should be \nno problems. For example, for ships with captains, Ocean-Trade would like to add additional functional-ity \nto the Seasoft planning module. Let us assume, the Seasoft system uses a certain generic function for \nwhich a method will be added that dispatches on ship-with-captain (the subconcept of ship defined above). \nThis method is more specific than the predefined method dispatching on ship. In this case, the problem \nis that instances are created in the body of old methods written by Seasoft. Seasoft methods create instances \nof ship rather than instances of ship-with-captain. The instantiation functions called in the inherited \nmethods do not use the intended subclass ship-with-captain, i.e. the code is not easily extensible (hence \nthe term make is not generic ). In the example discussed above, the class of a new instance depends on \nsome other instances being related to it (or, as Kiczales puts it, which give rise to the creation of \nthe instance [17]). A first attempt to find a solution for Seasoft would be to insert a function which \nis used compute the class of internally created instances. This solution has been proposed by Gamma et \nal. as the Factory Method design pattern [lo]. Seasoft must anticipate the desire for extensions here \nand should add an additional generic function to their protocol which is used to dynamically compute \nthe classes used by their plan-ning module. The idea might be to let customers (i.e. Ocean-Trade) write \nmore specific methods for this function. But, on which object(s) should this function dispatch? It must \nbe an object that Ocean-Trade will have to provide in order to avoid an infinite recursion of the problem! \nThe software system of Seasoft will become clumsy if too many of these unwieldy extension hooks are provided.4 \nThis is where Description Logics come into play. If CLASSIC were used for the develop-ment of the Seasoft \nsystem, the concept ship-with-captain could have been defined by the Ocean-Trade software team. Instead \nof using a primi- tive concept, Ocean-Trade can define a concept with sufficient conditions just as in \nthe example presented above. With the extended generic functions presented in this paper, it is possible \nfor Seasoft to write meth-ods that dispatch on CLASSIC individuals. Ocean-Trade can specialize a certain \ngeneric function pro-vided by Seasoft. Now, when other methods defined by Seasoft create an individual \nwhich is subsumed by ship and which is related to a captain, this indi-vidual will be automatically classified \nas a ship-with-captain. There is no need to use a procedure to compute the class at instance creation \ntime. When- ever generic functions are applied to this ship-with-captain in old methods defined by Seasoft, \nthe intended behavior (which is defined by Ocean-Trade) is automatically available. The small example \npresented above is no con-structed problem . Kiczales presents several other problems of the same category \n[17] and proposes a solution that uses an extension to instance creation. In his solution, the creation \nof an instance (e.g. a ship) can depend on other instance (e.g. a captain). The main idea is to let the \nsoftware customer (Ocean-Trade) define dependencies in terms of class paths (called traces ). By traces \nnew superclasses can be inserted at instance creation time. Thus, Seasoft provides default classes and \nOcean-Trade can force 4.Otherapproaches also in this scenario. 1ike delegation\"fail  subclasses to \nbe used. However, Seasoft must antici-pate a possible trace and has to use a more generic make function \nfor instance creation. The solution of Kiczales only works when the relation of a ship to a captain is \nknown at instance creation time (i.e. the captain must be an initialization argument to the ship). But, \nwhat happens when the captain is not known at instance creation time? With Description Logics, this is \nno problem either. Reclassification will occur even if the ship individual is created first and a captain \nwill be added afterwards! It is even possible todefineaconcept ship-without-captain. (define-concept \nship-without-captain (and ship (at-most 0 has-captain))) Specific methods can be written for this concept, \ntoo. In this example, the dependency solution of Kicza- les with traces at instance creation time also \nfails because, in this case, there is no dependency at all. The declarative way of specifying defined \nconcepts can be of great importance in modem software engi-neering scenarios. It can help to open up \nimplementa- tions (see the notions of open implementations [ 161 or glass-boxes [28]) and supports encapsulation \nat the same time (no hooks for class computations). The examples presented in this section indicate that \nrea-soning about concepts with necessary and sufficient conditions is more powerful than object-oriented \npro-gramming techniques provided by CLOS (and other 00 systems). ABox reasoning also goes beyond the \ncapabilities of standard frame systems which only support consistency checking as an inference service. \nBut DL reasoning offers even more.  2.5. Dynamic Classification as a Solution to the Concept-by-Relation \nProblem Continuing our ship example, I would like to add new concepts and relations. (define-primitive-concept \nship-in-shipyard ship) (define-primitive-role has-ship-in-repair-dock nil)  (define-primitive-concept \nshipyard (all has-ship-in-repair-dock ship-in-shipyard)) For ships which are subsumed ship-in-shipyard, \nchanging the position might be forbidden. This might be achieved by the definition of specific methods. \nIn some circumstances a concept should only be a superconcept of an instance when the instance is set \ninto relation to another instance. Thus, a ship should only be subsumed by this concept when it is set \ninto relation to a shipyard. However, it would be very inconvenient to directly create an individual \nof ship-in-shipyard or to explicitly change the class of the individual. A similar situation occurs when \npersons become customers when they are set into relation to a bank . This dynamic classifica-tion is \nno problem when DL concepts are used. The ship example is continued with the following asser-tions. (define-distinct-individualsl) \n (state (instance sl ship)) (define-distinct-individualyardl) (state (instance yard1 shipyard)) (state \n(related yard1 sl has-ship-in-repair-dock))  Even though sl is created as a ship, the dynamic reclassification \nmechanism of the ABox forces sl to be also an instance of ship-in-shipyard just because sl is set into \nrelation has-ship-in-repair-dock to yardl. The classification is dynamic because sl will no longer be \na ship-in-shipyard when the related statement is retracted. It should be noted that in dynamic OOP languages \nthe class of an instance might be changed (e.g. in CLOS: (change-class a-ship 'ship-with-captain)). However, \nthe new class itself has to be determined in beforehand (possibly with procedural code) and will not \nbe determined automatically by considering relations to other objects. The so-called Concept-by-Relation \nproblem is not adequately solved in object-oriented programming languages. Another important topic is \nthe treatment of general- ized conceptual assertions for individuals. 2.6. Beyond OOP: Generalized Conceptual \nAssertions for Individuals Object classification can also depend on conceptual assertions about role \nfillers (concept restrictions, car-dinality restrictions). This will be illustrated with the example \nfrom the press office. The individual sl known from above serves as a representative for the ship in \ndistress in this example. Let us further assume, a few other concepts for ships are declared in the TBox. \nConcepts for passenger ships as well as con-tainer ships will be defined with sufficient conditions. \n(define-concept passenger-ship (and ship (all has-cargo-object passenger))) (define-concept container-ship \n(and ship (al.1 has-cargo-object container) ))  Let us further assume, that in our example domain, incomplete \ninformation about sl is announced to the press office (e.g. by an incoming fax). As time passes it turns \nout that there are passengers on the ship. Although there might also be some containers on the ship, \nthis is unimportant for the press office and, as an additional assumption, it is asserted that all cargo \nobjects are passengers. In formal terms, this is expressed as follows. (state (instance sl (all has-cargo-object \npassenger)))  Together with the given TBox, implicit information can be inferred by ABox reasoning. \nThe individual s 1 is reclassified (or subclassified ) as a passenger-ship. In this case, the inference \nstep is justified by the conceptual assertion (all has-cargo-object passenger).Together with the concept \nship the con-ditions for passenger-ship are satisfied (see the concept definition for passenger-ship). \nIn contrast to the ship-in-shipyard example in the previous section, no concrete passenger instances \nare known. Conceptual information about the cargo objects suf-fices to deduce that sl is a passenger-ship. \nKnowing the fact that sl is a passenger-ship might trigger processes which change the newspaper headline \netc. Reasoning about concepts is required when concrete objects are not known, i.e. when the information \navailable about objects is incomplete. Dealing with incomplete, conceptual information at runtime is \ncur- rently not supported by OOP languages. In strongly typed Functional Programming languages (e.g. \nHaskell [27]) and strongly typed OOP languages (see e.g. [6]), at compile-time a type inference mechanism \nmay be used but, at runtime, inferences like those presented above are not supported. There are other \nexamples where the concept of an individual is important. For example, in a graphical user interface, \nthe drawing function for a ship might depend on the ship s concepts. User interface pro-gramming is one \nof the best examples for the applica- tion of object-oriented programming techniques. For rapid user \ninterface development however, an exist-ing UIMS must be reused (for Common Lisp, this can be CLIM [7], \n[22]). UIMSs like CLIM provide powerful programming abstractions which are mod-eled with the object-oriented \nrepresentation tech-niques of CLOS (e.g. different classes for gadgets and output streams etc.). There \nis no way to rebuild these software libraries with CLASSIC or any other DL in a reasonable time. So what \ncan be done? Copy-ing information associated with a DL object into a CLOS object which is used for UI \npart of an applica- tion is inadequate as well. Unfortunately, managing multiple copies of the same object \nis a direct con-tradiction to the principles of object-oriented pro-gramming. Thus, for rapid application \ndevelopment, object-oriented programming techniques must be made available to CLASSIC individuals. The \nnext chapter discusses an approach that demonstrates how this can be achieved with an extension to CLASSIC \nthat uses CLOS-like generic functions to access information about an individual. 3. Integrating OOP and \nDL The main features of object-oriented programming are: . defining the structure of instances (in terms \nof slots or instance variables and inheritance), defining object behavior (partial function defini-tions \nwith methods and inheritance), realizing encapsulation by hiding the structural layer behind the behavioral \nlayer. CLOS separates the structure definition (slots) from the behavioral definition (generic functions \nand meth- ods). Encapsulation is realized by the module mecha-nism of Common Lisp (packages). The separation \nof these software-engineering dimensions has many advantages. One of the advantages is that it is possible \nto define a behavioral layer for an existing structural layer. In our case, the internal object structure \ncan be handled by CLASSIC and will be hidden behind the behavioral layer of generic accessor functions \nas is usual in CLOS. 3.1. Accessors: A Functional Interface to a Knowledge Base CLASSIC itself provides \na relational interface for retrieving and adding role fillers. Assume, there exists a ship sl with captain \ncl. Given the ship, the captain can be retrieved: (cl-fillers @sl Ghas-cap-tain).5 In our example, this \nwill a return a set of fill- ers (@cl ) . For all ships, at most one captain will be returned (see the \ndefinition of the concept ship). However, the result will always be a set (actually a list) and the function \nfirst must be applied to get the list element itself. To hide the repeating access to the first element, \nan additional function will have to be written. Furthermore, in some circumstances, it will be considered \nas an error if the filler is not known. Unfortunately, additional code must be writ- ten to check this. \nIf nil (the empty set) is returned, an error is likely to occur in subsequent function calls when a captain \nindividual is expected. Again, code must be written to avoid this. Instead of writing this code manually, \na more general mechanism is advanta- geous. The way to access individuals should be declaratively defined \nusing generic functions and cor-responding low-level code for methods should be automatically generated. \nThe declaration form 5.@ is read as individual and is used quote\" to gettheindivid- ualwithname sl as \nanobject. 205 def ine-accessors has been introduced to specify the access to individuals in that way. \n(define-accessors <concept-name> (<role-name> <accessor-name> [ :single-value-p <boolean> ] [ :error-if-null \n<boolean> ] ) . . . )  For each role description mentioned after the concept name, a reader method \nand a setf writer method for the generic function <accessor-name> is gener-ated. If they do not already \nexist, corresponding generic functions are automatically generated.6 The first role option : single-value-p \nspecifies whether a single value or a set of values should be returned by the role reader function. The \nother option : error-if-null is used to insert code for error checking to avoid an empty set to be returned. \nIn our example, the following definitions are used. (define-accessors captain (has-ship captains-ship \n:single-value-p t)) (define-accessors ship (has-cargo-object ship-cargo-objects) (has-position ship-position \n :single-value-p t :error-if-null t) (has-captain ship-captain :single-value-p t :error-if-null t)) \n (define-accessors pos (has-x-coordinate position-x :single-value-p t :error-if-null t) (has-y-coordinate \nposition-y :single-value-p t :error-if-null t))  6. The explicit declaration of a generic accessor function \nis nec- essary, for instance, when a special method combination that dif- fers from the standard isto \nbe used [30]. method combination  7. Default values for role options could be inferred from concept \ndefinitions. For instance, in a def ine-accessors defini-tion for a concept c, :single-value-p t\"mightbe \nautomatically inserted as a role option for a role r if the concept c was subsumed by ( at-most 1 r ) \n. On the other hand, if cwassubsumedby (at-least 1 r) theoption :error-if-null t\"couldbeused.Inmyopinionitis \nbetter to define the options explicitly (for readability reasons). Furthermore, in some cases it is convenient \nto use a set in subse- quent function calls even if its cardinality is one. One of the main advantages \nof dispatched access to information about individuals via methods is error checking. When, by accident, \nposition-x is applied to a person, the condition no-applicable-method will be signalled. An error is \nindicated right at the wrong function call. If CLASSIC s retrieval functions for role fillers were used, \npossibly nil would be returned. Though not being inconsistent, a person might never intended to be (directly) \nrelated to a number via the role has-x-coordinate. It would be very inconvenient to restrict this on \nthe logical side (e.g. by forcing an inconsistency). Even if this were done, CLASSIC would happily return \nthe empty set (nil) as the set of role fillers for has-x-coordi-nate. From a logical point of view, such \na query for a role filler is well defined. On the procedural side, the return value nil might cause an \nerror. If ever, the error might be detected in subsequent function calls which do not expect nil to be \na valid return value. With generic functions and methods, the missing information (on the logical side) \nthat persons are not intended to be related to numbers via has-x-coor-dinate can be added. The functional \naccess layer has been deliberately sep-arated from the concept definitions (TBox). These mechanisms can \nbe considered as completely inde- pendent layers. As in CLOS, for accessing informa- tion of an object, \ndefine-accessors defines methods for generic functions. Additional methods might be written by the programmer \n(e.g. around methods or after and before methods). CLASSIC individuals require another dispatch mech-anism \nwhich is realized by extended generic functions which will be explained in the next section.  3.2. Generic \nFunctions and Methods The extended generic functions presented in this paper can dispatch on CLASSIC \nconcepts or CLOS classes or both. An example for a generic function that indirectly accesses information \nstored for an object is given below. The form define-generic-function is used to define a generic function \nwith dispatching extended to CLASSIC individuals. (define-generic-functionship-position-xy ((ship :classic))) \n (define-method ship-position-xy ((ind ship)) (let ((pas (ship-position ind))) (values (position-x pas) \n(position-y ~0s))) When the function ship-position-xy is applied, the internal role structure used for \nrepresenting posi-tion information is transparent. (ship-position-xy sl) just returns two values. Hiding \nthe internal role structure is quite important because the role structure might be subject to change. \nGeneric func-tions realize important encapsulation principles. The relational interface of CLASSIC is \nweak in this respect. The argument list of define-generic-function indicates which arguments expect CLASSIC \ndispatch and which arguments use standard CLOS dispatch. (define-generic-function<function-name> (<dispatched-argument-description>. \n. . [ <other-argument> .._ ] ) [ <option> . ..I ) A description for a dispatching argument is a list \ncon- sisting of an argument name and a dispatch indicator (either :clos or :classic). Just as defgeneric \nfrom CLOS, define-generic-function also supports ordinary arguments without specializer (called other-arguments), \nThe options for define-generic-function are the same as for defgeneric. Note that method combinations \nare also supported.8 Methods can be defined with the form define-method. (define-method <function-name> \n[ <qualifier> ] ( <dispatched-argument> __. [ <other-argument> . . . ] ) . . . ) The syntax of a dispatched \nargument in a method parameter list is identical to the syntax of arguments 8. In CLOS, a generic function \nis automatically generated when the first method definition is evaluated and the generic function is \nnot yet known. This is currently not supported by define - method. for defmethod of CLOS. The <qualifier> \nindi-cates the kind of method combination. In addition to names for CLOS classes, CLASSIC concept names \ncan be used as specializers. In our ship domain, we will use a generic function for printing information \nabout ships on a certain output stream. As usual, multimethods should be defined that dispatch on the \nkind of ship and on the kind of output stream (e.g. textual-output-stream, graphi-cal-map-output-stream). \nThe example empha-sizes the requirement that both, CLASSIC and CLOS arguments must be dealt with during \nmethod dispatch. Nobody would try to reinvent the wheel and represent streams with CLASSIC concepts. \n(define-generic-function print-ship-info ((ship :classic) (stream :clos)) (:documentation \"Demonstration \nfunction for - method dispatch.\")) The generic function print-ship-info might be used by the Seasoft \nsoftware. Methods are defined for ship and its subconcepts and a CLOS class tex-tual-output-stream. (define-method \nprint-ship-info ((ship ship) (stream textual-output-stream)) (format stream \"-%Ship -S.\" ship) . \n. . 1 (define-method print-ship-info :after ((ship container-ship) (stream textual-output-stream)) \n (format stream \"-%-S is even a CONTAINER ship.\" ship) . . . ) (define-method print-ship-info :after \n ((ship passenger-ship) (stream textual-output-stream)) (format stream \"-%-S is even a PASSENGER ship.\" \n ship) (print-ship-info sl *text-output-stream*) When the function print-ship-info is applied to a \nship individual and a stream instance, the composition of the effective method depends on the ship s \ncon-cepts and the stream s class. Initially, for sl only the first method will be applied because sl \nis classified as a ship. The main advantage of CLASSIC is the feature of dynamic object classification \nby ABox reasoning. Let us assume, that in our example domain, the following is asserted (see above). \n(state (instance sl (all has-cargo-object passenger)))  By ABox reasoning sl is classified as a passen-ger-ship. \nAcallto print-ship-info will result in different output after the assertion has been added. An additional \n: after method will be added to the effective method for subconcepts of ship (standard method combination). \nMethods can also be written for generic accessor functions that are created with def ine-accessors. For \ninstance, the position of a captain can be directly associated with the position of his ship. (define-method \nposition-x ((c captain)) (let ((ship (captains-ship c))) (if ship (position-x ship) nil))) (define-method \nposition-y ((c captain)) (let ((ship (captains-ship c))) (if ship (position-y ship) nil)))  In this \ncontext, the liberal use of dynamic OOP sys-tems like CLOS should be emphasized. There is no need to \ndefine a method within the scope of a class definition. Why not writing a separate method for print-ship-info \nthat dispatches on captains? (define-method print-ship-info ((c captain) (s stream)) (let ((ship (captains-ship \nc))) (unless (null ship) (print-ship-info ship s)))) These methods for existing generic functions might \nbe written by another programmer who has no access to the source code for the definition of captain. \nIn languages like C++ a subclass of captain has to be created to add such a method. Additional subclasses \neven increase the need for design patterns like Fac-tory Method . In CLOS this can be avoided because \na method is associated with a generic function and not with a class.9 The service of printing information \nabout a ship can very well be reached via a captain object. A common pitfall is illustrated with the \nfollowing example. In order to avoid the test whether the call to captains-ship returns nil in the method \npre-sented above, it might be a good idea to define an additional concept. (define-concept captain-with-ship \n (and captain (at-least 1 has-ship) (at-most 1 has-ship)))  According to the definition of has-captain \nas the inverse of has-ship, the statement (state (related sl cl has-captain)) implies that (related \ncl sl has-ship) also holds. Therefore, the ABox also concludes that cl is a captain-with-ship because \nthere is at least one ship (s 1)set into relation to cl. A simplified method might be defined for the \ngeneric function print-ship-info. (define-method print-ship-info ((c captain-with-ship) (s stream)) (print-ship-info \n(captains-ship c) s)))  The accessor function captains-ship can also be used for an instance of captain-with-ship \nbecause this is a subconcept of ship. It seems to be that the test whether captains-ship returns nil \ncan be omitted because there should be exactly one filler for the role has-ship. Everything runs fine \nas long as captain-with-ship is inferred via ABox reasoning about the role fillers of has-ship (and the \ninverse has-captain). But, what happens when a captain-with-ship is createddirectly? (define-distinct-individual \nc2) (state (instance c2 captain-with-ship))  9.Associating with class is impossible when a method a \nspecific multiargument dispatch is supported ( multimethods ). The instance c2 is an instance of captain-with-ship \nby definition. However, there is no filler known for has-ship. The logical semantics of (at-least 1 has-ship) \nmerely says that it is consistent that a captain-with-ship is associatedwitha ship and iff there is a \nfiller for has-ship, the captain will also be a captain-with-ship. There is no need to actually create \na jiller when an instance is a cap-tain-with-ship by definition. Thus, a runtime error (no applicable \nmethod) is likely to occur when the method defined above is executed because there isno print-ship-info \nmethod for nil (and a stream). 3.3. Individual Creation and Initialization Creating individuals using \nthe primitives supplied by CLASSIC (or KRSS) is somewhat crude. From a software engineering point of \nview, a protocol for individual initialization is needed. For individual cre-ation, a function create-individual \nwith param-eters (concept-name &#38;optional (ind-name (gensym)) &#38;rest initargs) hasbeensupplied. \nAn example would be (setf c2 (create-individual 'captain-with-ship 'c2)). When an individual is created \nwith create-indi-vidual, the generic function initialize-indi-vidual is automaticallycalled. A method \nfor this function can be defined as follows (compare this to initialize-instance fromCLOS). (define-method \ninitialize-individual :after ((ind captain-with-ship) &#38;rest initargs) (unless (captains-ship ind) \n(setf (captains-ship ind) (create-individual Icaptain)))) Initialization arguments can also be given \nto cre-ate-individual. The list of initargs is a sequence of role names and corresponding sets of ini- \ntial fillers. lo (setf sl (create-individual 'ship 'sl 'has-captain cl)) 10.The setofinitial fillersfor \nis represented a role by a list. If a non-list is used, a singleton list is automatically created. For \nship another initialization method might be defined. (define-method initialize-individual :after ((ind \nship1 &#38;rest initargs) (let ((captain (ship-captain ind))) (setf (captains-ship captain) ind) (unless \n(ship-position ind :error-if-null nil) (setf (ship-position ind) (create-individual 'pas (gensym \n\"KS\") 'has-x-coordinate 0 'has-y-coordinate 0))))) A CLASSIC individual can be used just like a CLOS \nobject. For instance, (ship-position sl) returns a single value: a position individual. As the body of \nthe method indicates, defaults for options given in the def ine-accessors definition can be overridden \nfor a specific accessor call. 3.4. A Functional View on Conceptual ABox Assertions? So far we have seen \nthat a functional layer with extended generic functions, methods and automati-cally generated accessors \ncan be smoothly integrated with a relational DL system. In this context, it is inter- esting to consider \nwhether conceptual assertions (see the example in Section 2.6) can also be stated from a functional point \nof view. In our example, the ship sl will be used as an argu-mentto ship-cargo-objects. Theindividualslis \nsubsumed by ship. When applied to sl,the function ship-cargo-objects is expected to return alistof passengers \nand therefore, sl must be an instance of passenger-ship. The assertion presented above could be denoted \nusing a functional syntax, for instance, the following declaration could be used: (assert-result-type \n(ship-cargo-objects sl) (passenger)) The effect of this assertion would be a reclassification of sl \nas a passenger-ship. From a Functional Pro-gramming perspective, it turns out that the ABox (of a DL \nsystem) allows reasoning about types of specific instances based on information about function calls. \nNote that this kind of reasoning happens at runtime rather than at compile-time. However, type restric-tions \non function calls could only be defined for accessor functions because for generic functions with general \nCommon Lisp methods no type calculus exists. In order to avoid a mismatch between accessor functions \nand general functions, only the relational syntax for conceptual assertions is supported. 3.5. Computation \nof the Concept Precedence List The TBox defines a partial order relation between concepts (subsumption \nrelation). In order to define how method dispatch is handled, the multiple inherit-ance lattice must \nbe serialized by a concept prece-dence list which represents a total order between concepts. A concept \nprecedence list is used for the same purposes as a CLOS class precedence list, it defines how an effective \nmethod for a specific func-tion call is computed (see the detailed introduction in [15]). A valid concept \nprecedence list is any total ordering that obeys all partial orders defined by the TBox. However, by \nthis requirement only a small set of constraints are defined. There are still several dif-ferent approaches \nto serialize a concept lattice. In CLOS the notational order of superclasses in a class definition defines \na set of additional order constraints. However, from the viewpoint of Description Logics, the direct \nsuperconcepts (the least general subsu-mers) are unordered. Therefore, in the approach pre-sented in \nthis paper, the relation of parents with respect to method dispatch is left undefined. Proce-dural code \nmust not depend on any notational order between concept parents. 4. Implementation of Method Dispatch \nTo allow experiments with the functional layer to CLASSIC, a straightforward implementation for method \ndispatch with individuals has been provided. CLASSIC dispatch is reduced to CLOS dispatch. 4.1. Reducing \nCLASSIC dispatch to CLOS dispatch The implementation of generic functions and method dispatch for CLASSIC \nis quite simple. The form define-generic-function is used to declare which parameters are handled as \nordinary CLOS instances and which parameters are CLASSIC indi-viduals. As a side effect of this declaration, \na new function is created (a simple Common Lisp function). This wrapper function calls another function \nwith the same name concatenated with the suffix METHOD. This function internally represents the generic \nfunc-tion and implements the method dispatch. For instance, the macro form: (define-generic-function \nprint-ship-info ((ship :classic) (stream :clos)))  expands into (PROGN (SETF (GET 'PRINT-SHIP-INFO :ARGUMEN'-SIGNATURE) \n' (:CLASSIC :CLOS)) (DEFGENERIC PRINT-SHIP-INFO-METHOD (IND #:TYPE6806 STREAM)) (DEFUN PRINT-SHIP-INFO \n(IND STREAM) (FUNCALL (FUNCTION PRINT-SHIP-INFO-METHOD) IND (COMPUTE-TYPE-ARG IND) ST=) ) )  Theintemalfunction \nprint-ship-info-METHOD is applied to the same arguments as the wrapper func-tion, but for each parameter \nwhich uses CLASSIC dispatch, an additional parameter is inserted (for ind this will be # : type6806). \nFor each CLASSIC indi-vidual, an associated CLOS instance is computed with compute-type-arg. In a method \ndefinition, the additional arguments are used for the real dis-patching . Note that normal CLOS arguments \nare treated as usual. The method definition (define-method print-ship-info ((ship ship) (stream textual-output-stream)) \n (format stream \"-%Ship -S.\" ship) , . . )  expands into 11. The main idea is inspired by the implementation \nof presenta- tiontypedispatchinCLIM (define-presentation-generic-functionanddefine-presentation-method). \n(DEFMETHOD PRINVSHIP-IKF+C-METHOD ((IND T) (#:TYPE6807 SHIP) (STREAM TEXTUAL-OUTPUT-STREAM)) (FORMAT \nSTREAM \"-%Ship -S.\" IND) . . ., The method is defined for the real generic function with suffix METHOD. \nIn the example, the specializer ship has been moved to the second parameter. For the original parameter \nno specializer is defined. It specializes on t, the most general type in Common Lisp, and therefore, \nthis parameter has no discrimi-nating power . Nevertheless, the original instance must be passed as an \nargument. In the body of the method, the CLASSIC individual must be bound to IND.The corresponding additional \nparameter is used only for dispatching (its system-generated name is unintemed). Since the substitute \nspecializer must be a CLOS class (here the class ship is used), for every named CLASSIC concept (either \ndefined by define-concept or define-primitive-con-cept) a corresponding CLOS class is automatically created. \nThe set of superclasses of such a class is computed on the basis of the TBox classification pro-cess. \nNote that the list of superclasses of a class might dynamically change when a defined concept is automatically \ninserted into the subsumption hierar-chy by TBox classification. The function compute-type-arg (see the \nexpan-sion of define-generic-function) computes a CLOS placeholder for a CLASSIC individual. The idea \nbehind compute-type-arg is to get the con-cept of a CLASSIC individual (classic : cl-ind- parents), to \nderive a corresponding CLOS class, and to use the class prototype of this class. One prob- lem is that \na CLASSIC individual may be subsumed by more than one named concept, i.e. classic : cl- ind-parents returns \na list of concepts. When this happens, a new anonymous CLOS class with corre-sponding superclasses must \nbe created on the fly. The prototype object of this class will then be used. A memoization scheme (with \na hash-table *class-table*) is used to avoid inflationary class creation. (defun compute-type-arg (ind) \n(or (classic::di-clos-instance ind) (let ((class-names (mapcar #'classic:cl-name (classic:cl-ind-parents \nind)))) (if (null (rest class-names)) (find-class-prototype (find-class (first class-names))) (let ((class \n(gethash class-names *class-table*) 1) (if class (find-class-prototype class) (let* ((class-name (gensym)) \n(class (find-class class-name))) (ensure-clos-class :name class-name :superclasses class-names) (setf \n(classic::di-clos-instance ind) (find-class-prototype (find-class type-name))) (setf (gethash class-names \n*class-table*) class) (find-class-prototype class))))))) With access to the internal data structures \nof CLAS- SIC (classic: :di-clos-instance), an individ-ual, can be directly associated with its CLOS counterpart, \ni.e. the procedure compute-type-arg is used only when the individual is reclassified. CLASSIC has been \nextended to reset the association between an individual and its CLOS representative when the individual \nis reclassified. In the following, we have a look at the performance of the current implementation for \nCLASSIC dispatch.  4.2. Performance considerations The definition of compute-type-arg indicates that \nthe straightforward implementation of CLASSIC dis-patch comes at a certain cost. In addition to static \ncosts for the definition of CLOS classes for named CLASSIC concepts, there are some initial dynamic costs: \n. some calls to retrieval functions (classic:cl-name,classic:cl-ind-parents), . a complex hashing operation \nover a list of sym-bols, possibly a dynamic creation of a CLOS class, . the access to the CLOS class \nprototype, and an additional CLOS dispatch step for the sub- stitute argument. Furthermore, a lot of \ngarbage is created (mapcar). Measurements on a Symbolics MacIvory-Model-3 indicate that a dispatched \naccess to a relation with a generic function created by def ine-accessors takes less than one millisecond. \nThis is approxi-mately three times slower than directly using CLAS-SIC s retrieval functions on the same \nprocessor. Note that accessing a slot of a CLOS instance takes less than a microsecond, i.e. CLASSIC \nitself is inevitably slow compared to CLOS. Thus further optimization of CLASSIC (we used Version 2.2) \nis required. 5. Related Work Generic functions for Description Logics have also been developed in the \nLoom System [5]. Loom offers a more powerful Description Logic than CLASSIC though it is incomplete. \nMethod dispatch for individ- uals is provided by specific generic functions which dispatch on ABOX object \nbut not on CLOS objects. Loom also supports CLOS classes for the implemen- tation of ABox individuals \nbut only a limited sort of reasoning is implemented on these instances (no dynamic reclassification by \nforward inferences). With the substitution scheme presented in this paper, method dispatch will be handled \nby the CLOS sys-tem. From the viewpoint of CLOS, extending the object-oriented system can be considered \nas pro-gramming at the metalevel. CLOS itself can be extended using a predefined set of classes and generic \nfunctions. The facilities are known as the CLOS Metaobject Protocol [ 151. Though some fea-tures of the \nMOP have been used (e.g. ensure-clos-class creates a new class at runtime and find-class-prototype accesses \nthe prototype instance of a class), the whole system architecture has not been defined in the spirit \nof the MOP. Using the MOP it might have been possible to avoid the definition of new macros like define-generic- \nfunction or define-method. The MOP idea enforces an open system implementation that avoids the introduction \nof additional (possibly incom-patible) layers for software specification [16]. The original mechanisms \nprovided by CLOS (defge-neric, defmethod) would have been extended rather than shadowed . For several \nreasons, the MOP has not been used for implementing the exten-sions defined in this paper. The first \nreason is simplic- ity. It is not very easy to find the right entry points into the MOP for a specific \nimplementation problem (but see [12] and [ 131 for several examples), The other reason is that the MOP \nis not standardized and is not coherently supported by all Common Lisp systems. The MOP however, might \nhelp to find a more opti-mized implementation. The solution presented in this paper with new macro form \ndefinitions is straightfor- ward and the main points of the implementation are easy to understand. Starting \nfrom a different background, the dynamic reclassification or subclassification of objects as a software \nmodeling principle has also been considered by Wieringa et al. [31]. They use a more general order-sorted \ndynamic logic with equality in the con-text of class migration . See also the extensive work of Goguen \nand Meseguer (e.g. in [ll]). The program- ming problems presented in this paper can also be solved using \nthe simpler Description Logic approach. 6. Summary and Conclusion The examples have demonstrated that \nthe facilities of Description Logics allow a system designer to tackle programming problems that cannot \neasily be solved with object-oriented programming alone. Neverthe-less, the main thesis of this paper \nis that in order to use Description Logics in practical applications, a seamless integration with object-oriented \nsystem development methodologies must be realized. Extended generic functions and multimethods with CLASSIC \ndispatch not only allow an incremental way of software definition. In addition to this, they can even \nbeen seen as a form of defining assertions that enforce a safer system architecture also for the procedural \nparts (the same holds for CLOS [ 181). The paper has presented an approach that demon-strates how the \nintegration of CLOS and CLASSIC can be achieved. The notion of generic functions and methods have been \nextended to define how CLAS-SIC individuals can be incorporated into the dispatch mechanism of CLOS. \nWe have discussed a prototype implementation that is easy to understand and allows the integration to \nbe tested in larger applications. With the extended dispatch mechanism for CLASSIC instances, a large \nsystem for generating interfaces has been implemented [20], [21]. References 111 Borgida, A., Brachman, \nR.J., McGuiness, D.L., Resnick, L.A., CLASSIC: A Structural Data Model for Objects, in: Proceedings of \nthe 1989 ACM SIGMOD International Conference on Management of Data, Portland, Oregon, May-June, 1989. \nPI Borgida, A., Patel-Schneider, P.F., A Semantics and Complete Algorithm for Subsumption in the CLASSIC \nDescription Logic, Journal of Artificial Intelligence Research, No. 1, Morgan Kaufmann Pub]., 1994, pp. \n277-308. Brachman, R.J., Reducing CLASSIC to Practice: Knowledge Representation Theory Meets Reality, \nin: Proc. KR 92 Principles of Knowledge Representation and Reasoning, Nebel, B., Rich, C., Swartout, \nW. (Eds.) Morgan Kaufmann Pub]., 1992, pp. 247-258. Brachman, R.J., McGuiness, D.L., Patel-Schneider, \nP.F., Resnick, L.A., Living with CLASSIC: When and How to Use a KL-ONE-like Language, in: Principles \nof Semantic Networks - Explorations in the Representation of Knowledge, Sowa, J. (Ed.), Morgan Kaufmann \nPubl., 1991, pp. 401-456.  [I Brill, D., Loom Reference Manual, Version 2.0, USC/ISI, 4676 Admiralty \nWay, Marina de1 Rey, CA 90292, December, 1993. [61 Bruce, K.B., Crabtree, J., Murtagh, T.I?, Gent, R. \nvan, Dimock, A., Muller, R., Safe and Decidable Type Checking in an Object-Oriented Language, in: Proc. \nOOPSLA 93, ACM SIGPLAN NOTICES, Volume 28, No. 10, October 1993, pp. 29-46. [71 Common Lisp Inter$ace \nManager: User Guide, Franz Inc., 1994. 181 Communication of the ACM, Special issue about Object-Oriented \nExperiences and Future Trends , October 1995, Vol. 38, No. 10. 191 Computer -Innovative technology for \ncomputer professionals, Special issue about Object-Oriented Technology , October 1995. [lOI Gamma, E., \nHelm, R., Johnson, R., Vlissides, J., Design Patterns -Elements of Reusable Object-Oriented Software, \nAddison-Wesley, 1995 [ 1 l] Goguen, J.A., Meseguer, J., Unifying Functional, Object-Oriented and Relational \nProgamming with Logical Semantics, in: Research Directions in Object- Oriented Programming, Shriver, \nB., Wegner, P. (Eds.), MIT Press, 1987, pp. 417-477. [ 121 Haarslev, V., Moller, R., Visualization and \nGraphical Layout in Object-Oriented Systems, Journal of Visual Languages and Computing, Nr. 3, 1992, \npp. l-23. [ 131 Haarslev, V., Moller, R., A Frumeworkfor Visualizing Object-Oriented Systems, in: Proceedings \nOOPSLA 90, SIGPLAN Notices, Volume 25, No. 10, October 1990, pp. 237-244. [141 Keene, S.E., Object-Oriented \nProgramming in CLOS: A Programmer S Guide to CLOS, Addison-Wesley, 1989. [ 151 Kiczales, G., des l&#38;vi&#38;es, \nJ., Bobrow, D.G., The Art of the Metaobject Protocol, MIT Press, 1991. [ 161 Kiczales, G., Towards a \nNew Model ofAbstraction in the Engineering of Sofmare, in: Proc. IMSA 92 Workshop on Relflection and \nMeta-level Architectures, 1992. [ 171 Kiczales, G., Traces (A Cut at the Make Isn t Generic Problem), \nin: Proceedings of ISOTAS 93, alsoavailable as: ftp://parcftp.xerox.com/ pub/openimplementations/traces.ps.Z. \n[ 181 Lamping, J., Abadi, M., Methods as Assertions, Xerox Palo Alto Research Center, available as: ftp://parcftp.xerox.com/pub/ \n openimplementations/methods-as- asserti0ns.ps.Z. [ 191 Miiller, R., Extending CLASSIC with Generic \nFunctions and Methods, http : / / kogs - www.informatik.uni-hamburg.de/ -moeller/, 1996. [20] Moller, \nR., Reasoning about Domain Knowledge and User Actions for Interactive Systems Development, IFIP Working \nGroups 8.1/l 3.2 Conference on Domain Knowledge for Interactive System Design, Chapman &#38; Hall, 1996. \n[21] Moller, R., Knowledge-Based Dialog Structuring for Graphics Interaction, in: Proc. ECAI 96, Budapest, \nHungary, August 1996. [22] Moller, R., User Integace Management Systems: The CLIM Perspective, http : \n/ / kogs -www.informatik.uni-hamburg.de/ -moeller/uims-clim/clim-intro.html, 1996. [23] Nebel, B., Reasoning \nand Revision in Hybrid Representation Systems, Lecture Notes in Artificial Intelligence, Vol. 422, Springer-Verlag, \n1990. [24] Paepcke, A,, Object-Oriented Programming -The CLOS Perspective, MIT Press, 1993. [25] Patel-Schneider, \nP.F., McGuiness, D.L., Brachman, R.J., Resnick, L.A., The CLASSIC Knowledge Representation System: Guiding \nPrinciples and Implementation Rationale, SIGART Bulletin, Vol. 2, No. 3, pp 108-113. [26] Patel-Schneider, \nP.F., Swartout, B., Description Logic Specification from the KRSS Effort, ksl.stanford.edu:/pub/knowledge-sharing/papers/dl-spec.ps. \n[27] Peyton Jones, S.L., Hall, C., Hammond, K., Partain, W., Wadler, P., The Glasgow Haskell Compiler: \nA Technical Overview, in: Proc. UK Joint Framework for Information Technology (JFIT), Technical Conference, \nKeele, 1993. [28] Rao, R., Implementational Reflection in Silica, in: Informal Proceedings of ECOOP/OOPSLA \n90 Workshop on Reflection and Metalevel Architectures in Object-Oriented Programming, October, 1990. \n[29] Resnick, L.A., Borgida, A., Brachman, R.J., McGuiness, D.L., Patel-Schneider, P.F., Zalondek, K.C., \nCLASSIC Description and Reference Manual for the Common Lisp Implementation, Version 2.2, 1993. [30] \nSteele, G.L., Common Lisp -The Language, Second Edition, Digital Press, 1990. [31] Wieringa, R., de Jonge, \nW., Spruit, P., Roles and Dynamic Subclasses: A Modal Logic Approach, in: Proc. ECOOP 94, Tokoro, M., \nPareschi, R. (Eds.), Springer, LNCS 821, 1994, pp. 32-59. [32] Woods, W.A., Schmolze, J.G., The KL-ONE \nFamily, in: Semantic Networks in Artificial Intelligence, Lehmann, F. (Ed.), Pergamon Press, 1992, pp. \n133- 177. [33] Wright, J.R., Weixelbaum, ES., Vesonder, G.T., Brown, K., Palmer, S.R., Berman, J.I., \nMoore, H.H., A Knowledge-Based Conjigurator That Supports Sales, Engineering, and Manufacturing at AT&#38;T \nNetwork Systems, AI Magazine, Vol 14, No. 3, 1993, pp. 69-80.  \n\t\t\t", "proc_id": "236337", "abstract": "The paper motivates the facilities provided by Description Logics in an object-oriented programming scenario. It presents a unification approach of Description Logics and object-oriented programming that allows both views to be conveniently used for different subproblems in a modern software-engineering environment. The main thesis of this paper is that in order to use Description Logics in practical applications, a seamless integration with object-oriented system development methodologies must be realized.", "authors": [{"name": "Ralf M&#246;ller", "author_profile_id": "81100071383", "affiliation": "University of Hamburg, Computer Science Department, Vogt-K&#246;lln-Str. 30, D-22527 Hamburg, Germany", "person_id": "PP31089590", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236357", "year": "1996", "article_id": "236357", "conference": "OOPSLA", "title": "A functional layer for description logics: knowledge representation meets object-oriented programming", "url": "http://dl.acm.org/citation.cfm?id=236357"}