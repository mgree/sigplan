{"article_publication_date": "10-01-1996", "fulltext": "\n Creating Host Compliance Portable Framework: in a A Study in the Reuse of Design Patterns Phillip M. \nYelland ParcPlace-Digitalk Inc. Abstract This report describes an experiment carried out at ParcPlace-Digitalk \nwhich sought to increase the look-and-feel compliance of portable applications built using the company \ns Smalltalk-based VisualWorks product. We outline the structure of the current VisualWorks user interface \nframework, and the precise requirements which the experimental system sought to t?&#38;ill. We go on \nto show how we were able to reuse design patterns from the literature in a generative fashion, to direct \nthe evolution of the new framework. This contrasts with most pattern-related work to date, which has \nconc- entrated on discerning design patterns in existing systems. Finally, we draw generalizations from \nour experience concerning the evolution of software arch-itecture using patterns. 1. INTRODUCTION The \nVisualWorks product from ParcPlace-Digitalk is a Smalltalk-based program development environment intended \nto facilitate the production of graphical client-server applications. One distinguishing feature of Visu- \nalWorks is the very high degree of portability it offers; applications developed using VisualWorks run \nwithout alteration on any brand of Microsoft Windows, the Macintosh, OS/2 and several varieties of UNIX. \nAuthor s current address: JavaSoft (Sun Microsystems Inc.), 2550 Garcia Ave., UCUPOl-202, Mountain View, \nCA 94043-l 100; Phillip.Yelland@eng.Sun.COM. *In fact, VisualWorks applications also enjoy a unique form \nof snapshot porfaahiliy, which allows a running application to he shut down on one plat- form and restarted \nin the same state on another. permission to make digital/hard copy of part or all of this work for personal \nor classroom use is ranted without fee provided that copies are not made or distributed for pro BIt or \ncommercial advantage, the copyright nOtiC% the title of the publication and its date appear, and notice \n!S given that copying is by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, \nor to redistribute to lists, requires prior specific permlssion and/or a fee. OOPSIA 96 CA, USA (0 1996 \nACM O-89791 -788-W96/0010...$3.50 VisualWorks comprises an extensive class library. containing a number \nof complementary application frameworks designed to support different aspects of client-server development. \nIn this report, we describe an experiment which involved one of these frameworks -that used in the development \nof graphical user inter-faces. Currently, VisualWorks user interface frame-work achieves portability \nby relying exclusively on emulation; every element of an application s user inter-face is drawn and animated \nin Smalltalk, using a num- ber of platform-independent I/O primitives. Unfortu-nately, this approach \nimposes a number of penalties on VisualWorks applications, particularly as regards host look-and-feel \ncompliance -the degree to which appli- cations conform to the look-and-feel guidelines stipu- lated for \na particular platform [A871 [M91]. The ex- perimental system sought to ameliorate these problems by revising \nthe implementation of the user interface framework so as to incorporate controls3 provided di- rectly \nby the host. A number of software design patterns taken from the literature played a pivotal role in \nthe development of the new architecture produced during the experiment, and their use is described in \ndetail in the main body of the report. Documented experience of this so-called gen-erative [C95a] [DeB95] \nuse of design patterns is fairly rare, particularly in application to the evolution of ex-isting frameworks4 \nGiven the relative infancy of the field, most pattern-related work to date has concen-trated on discerning \ndesign patterns in existing software architectures. 3Throughout this report, we use the terms control \nand widget interchangeably to denote user interface elements such as buttons, lists, input fields and \nthe like. 4[S95] is amongst the few examples. Direct Communlcatlon b Figure 1. The existing VisualWorks \nuser interface architecture The next two sections sketch the architecture of the current VisualWorks \nuser interface framework and de- scribe in more detail the shortcomings in it which the experimental \narchitecture sought to address.  2. THE EXISTING VISUALWORKS ARCHITECTURE Figure 1 is a greatly simplified \nrendition of an applica-tion built using the VisualWorks user interface frame-work.5 The ApplicationModel \ndepicted in the diagram encapsulates the application-supplied parts of the inter- face; it is responsible \nfor specifying the form and layout of windows and controls in the interfaces, and for sup-plying the \ninformation to be displayed. The specification of an interface in VisualWorks takes the form of a collection \nof Specification objects, which define the characteristics of the interface in a platfonn- independent \nfashion. To create the interface, the Appli-cationModel passes the specification to a Builder object, \nwhich traverses the Specification objects, constructing the interface as it does so. In order to render \nthe inter- For more details, see [P94]. 6All Smalltalk class names are rendered in sari--serif. face \nappropriately for a given platform, the Builder is equipped with a LookPolicy, responsible for providing \nthe Builder with components for that particular plat-form Interfaces in VisualWorks are constructed using \nthe Model-View-Controller pattern, which VisualWorks in-herits from its predecessor, Smalltalk-80. Thus \non Windows, for example, a button is realized using Win3ButtonView (responsible for displaying the button), \na ButtonController (which handles user input) and a Val- ueModel. The latter is a standard form of model \nobject that acts as a conduit between the ApplicationModel and the View and Controller. The View associated \nwith a control may be supplemented with one or more Wrap-pers, which provide decoration and/or additional \ncapa-bilities, such as borders or scroll-bars. The Application-Model is able directly to access the Wrappers, \nViews and Controllers in the interface through the Builder, to which it retains a reference after the \nlatter has finished con-structing the interface. As we pointed out in the introduction, VisualWorks makes \nno attempt to make use of controls provided by the platform. Instead, the system emulates all the con-trols \nin the user interfaces it produces. Hence, the Win3ButtonView alluded to above depicts a Windows same \ntechniques they are accustomed to usingwith 3.1 button using only graphical primitives furnished by other \napplications on a particular platform. the Smalltalk Virtual Machine [GR83], and a Button-Controller \neffects the appropriate behaviour based on low-level events originated by the Virtual Machine. This approach \ngives the system great flexibility and control, and makes achieving portability very easy, since the \nVirtual Machine s I/O facilities are platform-independent. However, it carries with it a number of liabilities, \nas we describe in the next section.  3. REQUIREMENTS FOR EVOLUTION The following are some of the notable \nweaknesses of VisualWorks emulation-based approach to user-interface construction: . Faithfully rendering \na given platform s look and feel by emulation can be a demanding task; there are a number of respects \nin which current VisualWorks ap-plications exhibit less than complete fidelity on certain platforms. \nFurthermore, a change in platform look-and-feel (such as that which occurred with the introduction of \nWindows 95, or Macintosh System 8.0) means de-veloping a new set of emulated controls. Both of these \nproblems can be overcome by making use of platform- provided controls, rather than do-it-yourself emulations \nof them. . The apparent responsiveness of a VisualWorks user interface is critically dependent on the \nspeed of the emulation code, which is written almost entirely in Smalltalk. On a less-than-well-endowed \nmachine, this can result in VisualWorks applications appearing unac-ceptably sluggish. Performance can \nbe improved con-siderably by using host controls. . The platform-independent input/output mechanisms \nused by the emulated VisualWorks controls differ markedly from those employed by host controls. The differences \nmake it difficult to achieve inter-operation with platform user interface elements, such as Windows 95 \nCommon Controls [C95b], OS/2 2.0 Controls [H92], in-place-activated OLE applications or OCX s [M94b]. \nIt can also prove frustrating for developers who expect to apply to VisualWorks applications the In alleviating \nthe problems listed above, we were de-termined not to vitiate the strengths of the current Visu-alWorks \nproduct. This led us to the following list of requirements for the new VisualWorks user-interface architecture: \nRl. It should make use of platform-provided controls and I/O mechanisms wherever possible. R2. It should \nincrease the accessibility of platform facilities from VisualWorks. R3. It should have minimal impact \non existing Visu-alWorks applications; ideally, applications written for the emulated VisualWorks user \ninterface framework should operate without alteration on the new platform-control-based framework. R4. \nIt should retain the portability (of both code and snapshots) of VisualWorks applications. R5. It should \nimpose no penalties in terms of applica- tion speed or memory requirements, compared with the existing \nemulation framework. R6. It should be easier to use, maintain and enhance than the emulated framework. \nIn the next section, we introduce the design patterns that were central to the accomplishment of these \ngoals. 4. EVOLUTION USING PATTERNS To recapitulate a point made briefly in the introduction: Given that \nsystematic descriptions of software design patterns have only been available in significant num-bers \nrelatively recently, it s no surprise that most work in the area has been of a largely descriptive nature. \nThe authors of [G+95], for example, make it clear that their intention is to systematize existing practice \nby identi-fying patterns in existing applications. By contrast, we found when embarking upon our experimental \nrevision of the VisualWorks user interface framework, a suffi-cient body of work had built up that we \nwere able to make use of already documented patterns in a genera-tive fashion [C95a] [DeB95] to guide \nthe development process. This allowed us to design our new architecture by identifying those patterns \nbest suited to fulfilling the 20 1. Layered Architecture  2. Adapter IIAdded R3  I 3. Interpreter \nRetained R3, R6 4. Decorator Removed R6 5. Model-View-Controller I Modified Rl / 6. Bridge /I Added Rl, \nR4 / 7. Proxy 8. Self-Addressed Stamped Envelope 9. Flyweight IIAdded / R.5 /I 10. Accumulator IIAdded \n( R2.R6 i Table 1: Design patterns in the evolution qf the experimental system requirements placed upon \nit. In fact, the entire exercise produced only one truly novel pattern (the ACCU-MLJLATOR , described \non page 9). All the remaining patterns employed were taken from the literature, either directly or by \nadaptation. We would represent this not as evidence of a singular lack of originality, but as a ratification \nof the oft-repeated assertion that design patterns constitute viable candidates for reuse. In the remainder \nof this section we describe the design patterns which figured in the evolution of the new ar-chitecture, \nand the ways in which those patterns were manipulated in response to the requirements set out above. \nNote that the architectural modifications did not consist solely of pattern additions -some patterns \nidentified in the old VisualWorks architecture were re-moved or substantially modified. A brief summary \nof this section-s discussion is given in Table 1. Space considerations preclude the formal presentation \nof each pattern. Instead, we will simply characterize them in general terms, and direct the reader to \nthe refer-ences for further detail. Unless otherwise indicated, a formal description of each pattern \nmay be found in [G+95], and for the sake of brevity, we will usually For clarity s sake, the names of \npatterns are rendered in SMALLCAPS refrain from referencing [G+95] explicitly in the fol-lowing. Where \nappropriate, illustrations are provided of the application of particular patterns; a complete depiction \nof the new architecture -from which these illustra-tions are excerpted -may be found on in Section 5. \nPattern 1: Layered Architecture A system with a portable layer 0 LAYEREDARCHITEC-portable API TURE [B95a] \nis con- . ,I...,. ..J.. .,.,.,.,.....,.,.,.,...,.,.,...,.,.,.,.,.,.,.,...,.,....,.,.....,.....,Y........,. \n ,.,.. . ..,...,.,.,.,.....,...,.,.,j,.,,. *.,...,.,.*.,.*.,. .,...,.,...,.....,.,.,., y!$g:~..~j ,.....,..haviour \nstrutted as a number I 0 4 bridge layer of tiers, linearly-ordered with the be- of objects in a given \nlayer nor-iI\\ mally expressed inel 0 ~~~, terms of the behav-iour of objects in the same or lower layers. \nObjects in lower layers are often said to provide services to ob-jects in higher layers. Layers were \na feature of software designs for many years before the use of object-oriented programming technology \nbecame widespread [P72] [T88], The appli-cation of layers has been particularly prominent in the design \nof a number of portable systems (possibly the most well-known recent example is Windows NT [C94]). Such \nsystems contain one or more platform-dependent layers which are responsible for presenting a platform-independent \nset of services to higher layers in the system. This allows applications inhabiting the up- per layers \nof the system to be written in a portable fashion. The user interface framework developed in the experi-ment \nuses a version of the layered pattern to reconcile support for the development of portable applications \nwith the provision of direct access to platform facilities. The new architecture divides objects into \nthree layers: In the top-most layer are portable objects, which are able to draw on the services provided \nby two lower lay- ers. The middle layer -called the bridge Layer for reasons explained below -supplies \na platform-independent API to the portable objects using capabili- ties drawn from the bottom-most layer. \nThis bottom-most layer -the pla<form access layer -presents a rendition of the platform s own API (more \ndetails later in the report). This architecture allows the application developer a choice: write entirely \nto the platform-independent API provided by the bridge layer? to produce a portable ap-plication, or \nuse the platform access layer to write a non-portable application which takes advantage of plat- form-specific \nfunctionality. A layered architecture also allows the new framework to retain the snapshot portability \nof its predecessor, because the system is structured in such a way that all the state of an application \ns user interface which needs to be present in a snapshot (so that it can be reincar- nated on the same \nor a different platform) resides in the portable layer; no persistent state is kept in the bridge- or \nthe platform access layer. Therefore, taking a snap-shot of a portable application is simply a matter \nof re-cording the state of the portable objects it comprises.g When the snapshot is regenerated, the \nobjects in the bridge-and platform access layers are appropriately Or more precisely, use system-provided \nportable objects which use the bridge layer s API -see pattern 2. Of course, applications which make \ndirect use of objects in the platform access layer need to make special provision for snapshots; the \nsystem supplies facilities to support this. reconstituted, reproducing the original user interface using \ncontrols from the new platform Pattern 2: Adapter Application-Model 0 The chief participant in the ADAPTERpat- \ntern is an object which provides an interface to a client portable layer based upon the serv- bridge \nlayer ices provided other object. by an-[G-t-95] 9 observes that this pattern is most com- access layer \nmonly used to match the interface of an existing class to the needs of a new set of clients. In the \nexperimental architecture, we used the pattern in the converse sense; to present an interface on new \nclasses for use by existing clients. Here, the existing clients are legacy VisualWorks ApplicationModels \nand ValueModels, written to the portable API formed by the message protocols of the Views, Wrappers, \nControllers and Builder in the original VisualWorks system. The new classes are the objects in the bridge \nlayer, which present a portable abstraction of the host. Most of the adapter objects are called widgets, \nsince they represent VisualWorks portable user interface controls, This use of the ADAPTERpattern in \nthe experiment was particularly successful; a large proportion of the legacy VisualWorks applications \nsampled in the project oper-ated correctly with the new user interface framework with little or no modification. \nAlso, since the widgets and their interfaces resided entirely in the portable layer, any legacy application \nwas ensured the same code and snapshot portability with the new framework that it enjoyed with the old. \nPattern 3: Interpreter The combination of Builder and LookPolicy described in section 2 can be regarded \nas an instance of the pattern INTERPRETERcomposed of instances of two other pat-terns -BUILDERand ABSTRACTFACTORY. \nTogether, the Builder and LookPolicy interpret the language comprised by the Specification objects, constructing \na graphical interface as they do so. Such is the flexibility of this configuration that we were able \nto retain both it and the existing implementation of Builder objects in the new framework. It only required \nthe provision of a new LookPolicy to cause the system to construct user interfaces according to the new \narchi-tecture rather than the old one. Retaining the Builder had a number of advantages: . It relieved \nus of the need to implement a replace-ment for the class Builder and the ancillary classes asso-ciated \nwith it. . It automatically preserved a major proportion of the API used by legacy VisualWorks applications \n(recall from section 2 that an ApplicationModel s prime means of access to the interfaces it controls \nis via a Builder object). . It allowed the new architecture to coexist with the old emulation system, \nand with other VisualWorks-based user interface frameworks (such as that used in ParcPlace-Digitalk s \nVisualWave Internet-based prod-uct [P96]). which also provide their own LookPolicy. Pattern 4: Decorator \nThe Wrappers described in section 2 are instances of the DECORATORpattern -a pattern used to attach addi-tional \ncapabilities to an object dynamically. They are used in the current VisualWorks user interface frame-work \nto add scroll-bars, borders and the like to emu-lated controls. The experimental architecture dispenses \nwith Wrappers. for the following reasons: Wrappers are not entirely transparent to the appli-cation developer, \nwho must take care to drill down through the appropriate number of wrappers before performing certain \noperations. For the same reason, the presence of wrappers can also greatly complicate de-bugging. . Most \nof the classes of Wrapper in the emulated VisualWorks framework are required because they provide the \nimplementation of the capabilities they en-dow. For example, a BorderedWrapper actually draws a border \nof a given style around its component. Most of these adornments are provided by the platform-provided \ncontrols themselves. which eliminates the need for Wrappers to implement them in the new system. Pattern \n5: Model- View-Controller The Smalltalk (MVC) MODEL-VIEW-CONTROLLER configuration [KP88] is one of the \nmost venerable of the design patterns associated with object-oriented pro-gramming. Many user interface \nframeworks profess to owe it inspiration -examples include the Microsoft Foundation Classes [M94a] and \nMacApp [A89]. How-ever, very few of these frameworks make use of the configuration in the original form \nembodied in Small- talk-80; ahnost without exception, they conflate the View and Controller into a single \nobject. The main reason for this is that Controllers in Smalltalk- (and latterly, in VisualWorks) are \nlargely an artifact of the imple-mentation of control-flow in the (emulated) UI. In a user interface \nbased upon the use of platform-provided controls, a distinct implementation of control-flow is unnecessary \n-and actually very difficult to achieve, since the platform takes care of such matters itself. Following \nthis lead. the new architecture arranges to have the Widgets introduced in pattern 2 subsume the responsibilities \nof both the Views and Controllers in the original framework. Specifically, they are responsible for displaying \nand manipulating the information in Val- ueModels, and for providing the programmatic API s supported \nby the Views and Controllers in the original product. The chief benefit of the MVC pattern -sepa-rating \nthe provision of data from its visual representa-tion -is retained in the new architecture by carrying \nover the indirect connection from ValueModels to their respective Widgets. Pattern 6: Bridge The bridge \nlayer described in pattern 1 is comprised largely of objects fashioned after the BRIDGEpattern defined \nin [G+95]. These bridge objects are critical to the provision of portability in the new architecture, \nsince they afford the portable objects in the uppermost layer of the system a platform-independent interface \nto the host. Applicatlon-A bridge object is Model T--T responsible for taking ValueModel the native \nfacilities of a particular platform /mrtab/e /ayer and using them to .I . . . . . ._i....C... . . . . \n. . . . . . . . . . . . . _......I.. . . . . . . . . ..I. i..... . . . . . . . . . . . . i... . . . .A.. \n..L... . . . . ..i..... . . . . . . ..L......... implement the set of Bridge III 1 bridge layer platform-independent \ncapabilities which a .,.,.,., ,.,.,.,.,., ., .,..._.,.,.,.,.i,...,.,.).,.,.,. ., .,.,.).,.,.,.,.,.( .,.,.,\\.,.,.,.,...,./,.,.,.,.,.,...,.,..,.,. \nK ~ particular type of platform acces layer Widget requires to implement its control in VisualWorks. \nSo for example, a RadioButtonWidget would be furnished a Win32RadioButtonBridge on MS Windows, a MacRadioButtonBridge \non the Macintosh and so on. Likewise, a ListWidget is matched with a Win32ListBridge: MacListBridge, \netc., as appropriate. The use of bridge objects brings with it a number of advantages: . It de-couples \nthe inheritance hierarchies of widgets and their implementations. For example, all Win32...Bridge classes \ninherit MS-Windows-specific capabilities from their abstract superclass Win32Bridge, while Mac.. Bridges \ninherit Macintosh-specific capabili-ties from MacBridge. Were widgets to be combined with their bridges, \nthe single inheritance model of Smalltalk would render it practically impossible to separate plat-form-specific \ncapabilities in this fashion, impacting the modularity (and hence the maintainability and amena-bility \nto enhancement) of the system very adversely. . In VisualWorks, it is possible to alter the charac-teristics \nof a control dynamically in such a way that the implementation of that control using a platform s native \nfacilities changes completely. Consider, for example, a VisualWorks push button which is initially assigned \na textual label. Implementing such a push-button on Mi-crosoft Windows is relatively straightfonvard, \nsince the MS Windows button control provides the required ca-pabilities directly. However, VisualWorks \nalso allows an arbitrary DisplayObject (which includes bitmaps, formatted text, geometric figures and \ngraphical com-posites) to be used as push-button labels. Implementing this kind of button on Windows \nis significantly more complicated than is the case with the simple textual label. Furthermore, it is \npossible to change the label of a push-button after it has become visible on the screen. This means that \na significant revision of the widget s implementation may be required at any point in its life- time. \nFortunately, this is easy using bridge objects: If a bridge detects a change (a new label, for example) \nin the widget it s implementing such that it is no longer able to supply the proper implementation, then \nit simply relinquishes responsibility to a new bridge capable of dealing with the new characteristics. \n. The footprint of VisualWorks applications destined to be executed on one platform only can be reduced \nsimply by discarding (or neglecting to load) the code for bridge classes particular to platforms other \nthan the target. We should note in passing that widgets are actually provided with the appropriate bridges \nusing another pattern -the AEBTRACT FACTORY. In this case, the pattern takes the form of a WidgetPolicy \nobject which returns new bridges in response to messages such as pushButtonBridge , listBridge and the \nlike. Different subclasses of the abstract superclass WidgetPolicy pro-vide suitable implementations \nof these methods for dif-ferent platforms. Pattern 7: Proxy Bridge objects actually implement widgets \nusing ob-jects from the platform access layer described in pattern 1. Recall that the purpose of the \nplatform access layer was two-fold: To provide support for the portable ob-jects and to furnish convenient \ndirect access to the plat- forms facilities for discretionary use by the application developer. To this \nend (and also to ease the develop-ment and maintenance of the bridge objects), we elected to make the \nplatform access layer a little more sophisti-cated than a mere foreign function interface to the host \ns API s, Electing to use the PROXY pattern was a fairly direct consequence of this decision, and is in \nline with fairly widespread practice, as exemplified by MFC [M94a] and MacApp [AX9]. These frameworks \nemploy proxies to encapsulate platform resources such as windows, fonts, bitmaps and the like. Messages \nto these objects are transliterated fairly directly into API calls involving the encapsulated resources. \nThe proxies may also pro-vide supplementary functionality to make programming more convenient than using \nthe platform API alone. We followed a similar approach with the platform access layer. producing Smalltalk \nproxies for windows menus. bitmaps, fonts, etc. These proxies facilitate most of the manipulations which \nthe hosts API s sup-port on the corresponding resources. They also provide for a degree of type translation \nto and from Smalltalk, and for automatic resource reclamation upon garbage collection of the proxy, The \nproxies for windows and controls are also chief participants in the SASE pattern, discussed in the next \nsection. Pattern 8: Self-Addressed Stamped Envelope Introduced formally in [B95b], the SELF-ADDRESSED \nSTAMPED ENVELOPE (SASE) pattern is frequently em-ployed to provide a means of indirect communication \nbetween the lower tiers of a layered architecture. Ac-cording to this pattern. a nether object may be \ninformed that upon the occurrence of a particular event (the clicking of a button for example), a specified \nmessage is to be dispatched to a specified receiver. Both mes-sage and receiver may be varied arbitrarily, \nand provi- sion is made for the supply of arguments to the message either at the time of registration \nor message dispatch. The platform access layers of the experimental system make use of this pattern to \nallow the interception of host-specific events by objects in higher layers. On Windows. for example. \nevaluating the expression: winProxy onEventNamed: #WM-PAINT send: #paint to: handier causes the (Smalltalk) \nmessage #paint to be sent to the object handler whenever Windows dispatches the (Windows) message WM-PAINT \nto the window whose proxy object is winProxy. Usually, the handler is a bridge object, or an object in \nthe application used to monitor the reception of the Windows message or mod-ify the window s response \nto it. Use of the SASE pattern does away with the necessity for direct communication from objects in \nthe platform layer to those in the bridge layer. Eliminating the need to make bridge objects privileged \nin this way, it makes the full generality of the proxy s capabilities available to the application developer. \nthus helping to fulfill the requirement (R2, section 3) for ready access to plat-form facilities from \napplications. The SASE also allows the same window proxy objects to be shared by both bridges and application \nobjects, allowing application developers to modify program-matically the behaviour of interfaces constructed \nusing the VisualWorks screen painter. Finally. the pattern provides a convenient means of customizing \nthe behaviour of windows without resort-ing to subclassing. This increases the encapsulation of the platform \nobject classes, leading to easier mainte-nance and framework enhancement. Pattern 9: Flyweight The SASE \npattern requires that each window proxy retain sufficient information that it can dispatch the appropriate \nmessage (with arguments, if required) to the appropriate receiver upon the occurrence of a speci- tied \nevent. To take the platform access layer for Micro- soft Windows as an example: a naive implementation \nof the pattern would have each proxy associated with a collection of registration records: -Glhg, msg, \nrcvr, arg,, arg2, . . . . m-g,> Such a record would indicate that upon reception of a Windows message \nz&#38;%g, the Smalltalk message msg is to be dispatched to the object rcvr with the arguments specified. \nUnfortunately, the bridge objects make heavy use of the SASE mechanism. and such an implementation would \nresult in immoderate storage requirements, since each control present in an application s user interface \nwould require several such records to coordinate its activities with the bridges. Furthermore, the need \nto construct such collections for each control every time a window in the interface is opened would lead \nto an unacceptable degradation of performance. These difficulties are ameliorated in the experimental \narchitecture by application of yet another design pattern -the FLYWEIGHT. to pattern, econo- According \nthis mies result from identifying the variable components ([G+95] calls this extrinsic state ) in a large \npopula- tion of similar objects, separating out those components and sharing the identical portions which \nremain. Thekey to using the FLYWEIGHTpattern context in the of the experimental architecture is to observe \nthat bridge objects of a given type use similar registration records. For example, an MS Windows bridge \nobject brl controlling a top-level window would register the following with its proxy: <WM-SIZE, #size, \nbrl> On reception of WM-SIZE, send #size to brl <WM-MOVE, #move, brl> On reception of WM-MOVE, send #move \nto brl <WM-CLOSE, #close, brl> On reception of WM-CLOSE, send #close to brl Likewise, top-level window \nbridge br2 would register with its proxy: <WM-SIZE, #size, br2> On reception of WM-SIZE, send #size to \nbr2 <WM-MOVE, #move, br2> On reception of WM-MOVE, send #move to br2 <WM-CLOSE, #close, br2> On reception \nof WM-CLOSE, send #close to br2 Clearly, the registration records for both bridges differ only in the \nreceiver they stipulate. We can remove the receiver field from the registration records to produce a \nsingle collection of abbreviated records we ll name reds: <WM-SIZE, #size> On reception of WM-SIZE, send \n#size <WM-MOVE, #move> On reception of WM-MOVE, send #move cWM CLOSE, #close> On reception of WM-CLOSE, \nsend #close Now bridge brl s registration records can be synthe-sized directly from the pair <brl, reds>, \nand br2 s rec-ords from <br2, reds>. Note that the collection of ab- breviated records is shared by both \npairs. Using such pairs to register bridges with their proxies substantially reduces the storage overhead \nassociated with the SASE implementation in the system. Furthermore, the shared components of such pairs \n(reds in the example) can be pre-computed at system start-up, and this speeds up the process of interface \nconstruction significantly. Pattern 10: Accumulator As far as we re currently aware. this is the only \ntruly novel design pattern conceived during the course of the experiment. Its discovery and use arose \nduring the im-plementation of the platform access layers. To take Mi- crosoft Windows as an example once \nagain consider a Win32 API [M93] call which creates a new dialog win-dow of window-class MY-DIALOG-CLASS \n: CreateWindowEx( WS-EX-DLGMODALFRAME, MY-DIALOG-CLASS , A Dialog , WS-VISIBLE 1 WS-CAPTION j WS-SYSMENU \nj WS-MINIMIZEBOX j WS-MAXIMIZEBOX, CW-USEDEFAULT, CW-USEDEFAULT, CW-USEDEFAULT, CW-USEDEFAULT, NULL, \nNULL, hlnst, NULL) It s easy to appreciate the inconvenience that would be associated with using a direct \ntranscription of such a call in Smalltalk. The experimental system seeks to ad- dress this by providing \nobjects called creators. The function of such an object is to provide the arguments to a CreateWindowEx \ncall. These arguments may be provided as defaults, or they may be set individually by the creator s client. \nTo create the dialog window in the example above, the developer would begin by procuring an appropriate \ncreator object -usually by requesting one from the object representing the window-class in question. \nThe creator comes loaded with a number of default parameter values, requiring that the user supply only \nthose for which the default values are inappropri-ate. Using such a creator, the call above can be ren-dered \nmuch more succinctly: myDialogClass creator windowName: A Dialog Window ; Creator forms disjunction of \nthe following... visible; caption; sysMenu; minimizeBox; maximizeBox; createwindow. The deployment of \ncreator objects is a particular exam-ple of the ACCMIJLATORpattern. The idea behind this pattern is to \nencapsulate in a single object the parame- ters required to control one or more complex opera-tions. \nExamples abound of its use, especially in graph- ics systems. They include the DeviceContexts of the \nWindows GDI [M93], GraphicsContexts in X-Windows [J88], or -to cite a more strictly object-oriented ex-ample \n-the BitBlt (later RasterOp) objects of Small-talk-80 and its descendants ]GR83]. The ACCUMULATORpattern \nconfers a number of ad-vantages in such applications: . Accumulators may be pre-loaded with default pa-rameter \nvalues, relieving the application programmer of the need to specify each parameter explicitly for every \noperation. Accumulators may be produced with a vari- ety of different pre-loaded values by making the \nappro- priate requests to other objects in the system. In the example above, the object representing \nthe MS Win-dows window-class produces a creator object with the appropriate window-class name and style \nalready set. . Accmlmlators can provide extra facilities for set-ting parameters. An example of this \ncan been seen in the use of the creator object described above. In the C call, the style of the new window \nis specified as a com- plex disjunction of masks. By contrast, the creator ob-ject forms the disjunction \nitself. requiring only that the programmer send the appropriate unary messages. Figure 2. The Experimental \n27 0 If a succession of operations require parameters which are substantially similar, the same accumulator \ncan be reused for all operations. This provides greater convenience. and -as shown by the X-Windows sys-tem \n-a potential for added efficiency.  5. THE NEW VISUALWORKS ARCHITECTURE Figure 2 is a schematic of the \narchitecture which re-sulted from the experiment. Objects used only on a transitory basis (such as creators), \nor those largely in-visible to the application programmer (for example, registration records supporting \nSASE communication) have been omitted. The communications annotated with asterisks are optional, and \nonly arise if the application programmer elects to make direct (non-portable) use of elements of the \nplatform access layer. IndIrect Communlcatlon . . . . . . . _. . ., Portable Layer Bridge Layer Platform \nAccess Layer User Interface Architecture 6. CONCLUSION Incorporation of design patterns into the experimental \narchitecture enabled the project successfUlly to fulfill all of the requirements set out for it. We were \nable to reconcile a high degree of portability with the use of and ready access to host facilities, to \nmeet our goals for backwards compatibility and to provide the perform- ance and maintainability required. \nWe can draw several broad conclusions from the ex-periment concerning the use of design patterns, par-ticularly \nin the context of framework evolution of the kind detailed here: . Successful use of design patterns \nto guide (rather than simply document) architectural evolution in a real- world, commercial application \nis indeed possible. Of the ten patterns discussed in the above, only one (ACCUMULATOR) new. is actually \n. Given the current state of the art, it is not possible simply to apply patterns mechanically during \nthe design process. In almost every instance, we found it necessary to adapt or tailor existing design \npatterns so as to fashion them for use in the architecture. To make such adaptations successfully requires \nbroad-based archi-tectural experience, and recognition of the trade-offs which can be made in each particular \ninstance. . The application of a pattern does not invariably improve an architecture. In some cases (examples \nin this case are the DECORATORand MODEL-VIEW-CONTROLLERpatterns), it may be advisable during evolution \nto discard or substantially modify a pattern which has become inappropriate due to changes in re-quirements. \n. As was been observed in [G+95], design patterns rarely stand in isolation. Often, one or more design \npatterns participate in the implementation of another: Examples in the new VisualWorks architecture are \nBUILDERand ABSTRACT FACTORY (components ofan INTERPRETER); Adapter, BRIDGE and PROXY (LAYERED ARCHITECTURE); \nFLYWEIGHT (SASE). Thus it its very common to find a single object partici- pating in a number of different \ndesign patterns. . In common with a other authors, experience with the evolution of the VisualWorks architecture \nsuggests that as an architecture is refined, it is common to find that increasingly substantial portions \nof the implemen-tations of an object s responsibilities are delegated to other objects. In [JO93], this \nis manifest as the re-placement of inheritance with composition and delega- tion; in our case, we can \nobserve it in the delegation of I/O responsibilities from Widgets (erstwhile Views and Controllers) to \nBridges and (indirectly) Proxies. 7. ACKNOWLEGEMENTS k The author owes a considerable debt of gratitude \nto the members of the van Gogh project team at ParcPlace-Digitalk (Terry Chou, Mike Khaw, Lee Ann Rucker, \nLisa Yee-Estrada, together with a number of part-time contributors), who collaborated in the work docu-mented \nin this report. 8. REFERENCES [A871 Apple Computer Inc. Human Interface Guide-lines: The Apple Desktop \nInterface. Addison-Wesley, 1987. [A891 Apple Computer Inc. MacApp 2.0 Program- mer s Guide. 1989. [B95a] \nBrown, K. Remembrance of things past: lay- ered architectures for Smalltalk applications. The SmalltaIk \nReport 4(9):4-7, 1995, [B95b] Brown, K. Understanding inter-layer commu-nication with the SASE pattern. \nThe Smalltalk Report 5(3):4-g. 1995 [C93] Custer, H. Inside Windows NT. Microsoft Press. 1993. [C95a] \nCoplien, J. A generative development-process pattern language. in [CS95]. [C95b] Cluts, N. Programming \nthe Windows, 95 User Interface. Microsoft Press, 1995, [CS95] Coplien, J., Schmidt, D. Patterns Languages \nof Program Design. Addison-Wesley, 1995. [DeB95] DeBruler, D. A generative pattern lan-guage for distributed \nprocessing. in [CS95]. [G+95] Gamma, E., Helm, R., Johnson, R., Vlissides, J. Design Patterns: Elements \nqfReusable Oh- ject-Oriented Software. Addison-Wesley, 1995.  [GR83] Goldberg, A., Robson, D. Smalltalk-80: \nThe [T88] Tanenbaum, A. Computer Networks (2nd ed.). Language and its Implementation. Addison-Prentice \nHall, 1988. Wesley, 1983. [H92] Haggar, P. New controls in OS/2 2.0: an over- view. IBM Personal Systems \nDeveloper, No. 1, 1992. [JO931 Johnson R., Opdyke, W. Refactoring and ag- gregation in object technology \nfor advanced software. Nishio S.. Yonezawa, A. (eds.), LNCS 742, Springer, 1993. [J88] Jones, 0. Introduction \nto the X Window Sys-tem. Prentice Hall. 1988. [KP88] Krasner, G. E.. and Pope, S. T. A cookbook for using \nthe model-view-controller user inter-face paradigm in Smalltalk-80. Journal of Object-Oriented Programming, \nl(3), 1988. [L+95] Lewis. E., Rosenstein, L., Pree, W., Weinand, A., Gamma, E., Calder, P.. Andert, G., \nVlis- sides, J., Schmucker, K. Object Oriented Ap-plication Frameworks. Manning Publications, 1995. \n[M9 l] Microsoft Corporation. The Windows Inter-face: An Application Design Guide, Microsoft Press, 1991. \n[M93] Microsoft Corporation. Win32 Programmer s Reference. Microsoft Press. 1993. [M94a] Microsoft Corporation. \nManuals for Visual C+ + and Microsoft Foundation Class Li- brary. 1994. [M94b] Microsoft Corporation. \nOLE Programmer s Refirence. Microsoft Press, 1994. [P72] Pamas, D. On the criteria to be used in decom- \nposing systems into modules. Communications of the ACM, 15(12), 1972. [P94] ParcPlace Inc. VisualWorks \nTutorial. 1994. [P96] ParcPlace-Digitalk Inc. Visual Wave: Building Live WWW Applications. http://www.parcplace.comlmarketing/products/ \nvwavelwpaper.html. [S95] S&#38;mid, H. Creating the architecture of a manufacturing framework by design \npatterns. Proceedings of the 10th Annual Conference on Obj ect-Oriented Programming Systems, Languages \nand Applications, 1995  \n\t\t\t", "proc_id": "236337", "abstract": "This report describes an experiment carried out at ParcPlace-Digitalk which sought to increase the look-and-feel compliance of portable applications built using the company's Smalltalk-based VisualWorks product. We outline the structure of the current VisualWorks user interface framework, and the precise requirements which the experimental system sought to fulfill. We go on to show how we were able to reuse design patterns from the literature in a <i>generative</i> fashion, to direct the evolution of the new framework. This contrasts with most pattern-related work to date, which has concentrated on discerning design patterns in existing systems. Finally, we draw generalizations from our experience concerning the evolution of software architecture using patterns.", "authors": [{"name": "Phillip M. Yelland", "author_profile_id": "81100634004", "affiliation": "JavaSoft (Sun Microsystems Inc.), 2550 Garcia, Ave., UCUP01-202, Mountain View, CA, and ParcPlace-Digitalk Inc.", "person_id": "PP31101084", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236340", "year": "1996", "article_id": "236340", "conference": "OOPSLA", "title": "Creating host compliance in a portable framework: a study in the reuse of design patterns", "url": "http://dl.acm.org/citation.cfm?id=236340"}