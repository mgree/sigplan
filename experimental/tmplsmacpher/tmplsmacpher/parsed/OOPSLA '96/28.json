{"article_publication_date": "10-01-1996", "fulltext": "\n A Framework for Run-time Systems and its Visual Programming Language Alan M. Durham Universidade de \nSso Paulo durham@ime.usp.br Ralph E. Johnson University of Illinois johnson@cs.uiuc.eclu Abstract 1 Introduction \nFrameworks and domain-specific visual Domain-specific software tools can be very languages are two different \nreuse tech- productive. For example, GUI builders niques, the first targeted at expert pro- can generate \nmost of the code for a user grammers, the second at domain experts. interface. They are usually based \non a In fact, these techniques are closely re- well defined model of interaction between lated. This \npaper shows how to develop the graphical interface and the applica-a domain-specific visual language \nby first tion software. A GUI designer uses a developing a white-box framework for the domain-specific \nvisual language to spec-domain, then turning it into a black-box ify which of a series of pre-defined \ncom-framework, and finally building a graphi- ponents are used and how they interact cal front end for \nit. We used this technique with the underlying application. Some-in a compiler to specify run-time systems. \ntimes only the choice and location of com- Research: reuse, components, and ponents are specified visually, \nother times  frameworks the interaction is also specified visually, but the specification language is \nalways Permission to make digital/hard copy of part or all of this work for Person&#38; or classroom \nuse is granted without fee provided that copies are not made specialized for user interfaces. or distributed \nfor profit or commercial advantage, Fe qopyright noti@% the title of the publication and its date appear, \nand notice 1s given that It is a lot easier to design a good copying is by permission of ACM, Inc. To \ncopy other$e, to,!epubli$ !o domain-specific visual language when post on servers, or to redistribute \nto lists, requires pnor SpeClflC PermIssIon and/or a fee. there is already a graphical notation used \nOOPSLA 96 CA, USA in that domain. Some notations, like Q 1996 Af3vl 0-89791-788~W96/OOt0...$3.50 that \nof GUls, come right out of the prob-lem domain. Others, like PERT charts, have been developed by clomain \nexperts and just have to be automated. But of-ten there is no existing language. What should a tool designer \ndo then? This pa-per presents a way of developing a visual language as part of framework design. We used \nthis technique to develop a visual lan-guage for implementing the run-time sys-tem of a compiler. Compilers \nare a popular domain for de-veloping software tools. Compilers have a well-known standard architecture, \nwith parts such as lexical analysis, parsing, static analysis, and machine code gener- ation. Some parts \nof a compiler are of- ten automated, such as parsers [Knu65] [La1651 [Joh75] and machine code gen-eration \n[Mi170] [Gla77] [Cat%] [HC86] [PLG88] [Fra89] [ESL89]. Other parts, such as static analysis (type checking \nand code optimization), have structured approaches that make them easier to implement (such as attribute \ngrammars [Mad801 [B.H78] [FS89]), but are not yet completely automated. We found that the standard architecture \ndid not make it easy to change the implementation of a language s run-time system, and there were no \ntools for specifying the run-time system of a language, even though this has been noted as an important \nproblem [She881 [Gab851 [Kra83]. So, we built a visual language-based tool for specify-ing run-time systems \nthat works along-side the older parser-generators and code-generator-generators. Our work is part of \nthe I S project [.JGZ88], an optimizing compiler for typed Smalltalk, written in Smalltalk-80. Our goal \nwas to develop a tool that could be used to specify not only Smalltalk s run-time system, but the run-time \nsystems for other languages as well. Such a tool would let us experiment with run-time system design. \nDue to the lack of previous work in the field, we had to create a new model for run-time systems that \ncould be used to de-velop high-level tools for run-time system specification. We wanted to automate as \nmuch of the task as possible, and to en-able compiler writers to specify run-time systems by writing \nas little code as possi-ble. This paper describes how such a system was developed, and the lessons we \nlearned in the process. Our system was developed in three phases. First we centralized all infor-mation \nabout run-time systems in a sin-gle class. This class could be subclassed to produce new run-time systems, \npro-viding some degree of code reuse. The class had three components that could be replaced, but there \nwere lots of de-pendencies between them. A this point, the run-time system module was a white-box framework[JF88] \nNext, we refined the three components so they could be built by composing them from even smaller com-ponents. \nSome classes had to be sub-classed but there seemed to be an up-per bound to the number of classes that \nwere needed. Eventually, it was possible to specify a run-time system entirely by com-posing existing \nclasses. At this point, the run-time system module was a black-box framework. Finally, we created a visual \nlanguage for specifying the run-time sys-tem, along with browsers to inspect imple-mentations. We think \nthe same approach could be used to develop systems for other problem domains.  2 Phase 1: Creating \na white-box framework Initially, the TS compiler consisted of a front-end and a back-end. The front-end \nwould produce an abstract syntax tree, check and optimize it, and then convert it into an intermediate \nform in a register transfer language called RTL. There was a class hierarchy of abstract syntax tree \nnodes (the Interpreter pattern[GHJV95]). Each node class had methods for optimiza- tion and for generating \nthe intermediate code. The back-end, called RTLBuilder, constructed the RTL program (using the Builder \npattern[GHJV95]) and then opti-mized it and generated code for it. Run-time system information was di-vided \nbetween the front-end and the back-end. The front-end knew how to imple-ment operations on primitive \ndata types and how objects were laid out in memory, but the back-end was responsible for regis-ter allocation, \nparameter passing, and ac-cessing local variables. The RTLBuilcler interface for generating RTL code \nwas low-level, and exposed many details of the in-termediate RTL code. Unfortunately, this meant that \nchanges to the run-time system woulcl require changing both the front-end and the back-end. The front-end \nwould have to sub-class the node classes that generated code for the features being changed, while the \nRTLBuilder would have to change if the environment implementation changed. The classes that needed changing \nwould not depend on the structure of the run-time system but on which parts of the ab-stract syntax tree \nand of the RTLBuilder were in charge of generating the corre-sponding code. The only way to under-stand \nthe run-time system being imple-mented was to read the code generation routines that were distributed \nover the ab-stract syntax tree node class hierarchy. To centralize all information about the run-time \nsystem, we created a new class, RunTimeSystemsExpert, that would hold all the knowledge about the run-time \nsys-tem. The front end classes did not commu-nicate directly with the back-end anymore, but would ask \nthe RunTimeSystemsEx-pert to generate code for a run-time sys-tem function. Each abstract syntax node \nwould basically ask the RunTimeSystem-Expert to generate code for it. This is an example of the Visitor \npattern[GHJV95]. RunTimeSystemsExpert then issued the proper code generation requests to the RTLBuilder. \nThe RTLBuilder no longer knew anything about how to implement the environment. RTLBuilder was re-duced \nto generating code for expressions, memory and variable access, assignment, conditional jumps, calls \nand returns. Initially, RunTimeSystemsExpert was a large object with little internal structure. It kept \ntrack of things like the registers as-signecl to temporary variables and labels of branches. Although \nit delegated the task of building register transfers to the RTL-Builder, it did everything else itself. \nThis new structure encapsulated new run-time systems, but did not reduce the total amount of new code \nthat had to be written. Each new run-time system re-quired a new subclass of RunTimeSystem- sExpert, \nno matter how tiny the differ-ences would be. A small modification of an existing run-time system could \nbe im-plemented easily by redefining the meth-ods corresponding to the changed func-tions. However, there \nwere interdependen-ties among the various methods. For ex-ample, access and update methods both shared \nknowledge about some specific for-mat feature. It was clear that Run-TimeSystemsExpert needed to be decom-posed \nfurther. We started trying to determine the func- tions implemented by all run-time sys-tems, trying \nto obtain a more modular and reusable system, and also to obtain an ini-tial class hierarchy for run-time \nsystems. The first step was to group the various methods of the RunTimeSystemsExpert. Three groups arose: \n. the methods related to primitive data types, 0 the methods related to environment implementation, . \nthe methods related to control flow. The primitive data types group was the biggest. It had an operation \nfor each oper-ation on each data type, so there would be operations like generate code for adding two \nintegers and generate code for fetch- ing an element from an array . Except for integers, no data type \nseemed common to all run-time systems, so even inheri-tance did not seem useful. It also seemed to be \nthe most difficult to automate, be- cause primitive data types can be arbitrar- ily complex. The environment \ngroup seemed to be more clearly defined. Most languages have the same type of information in environ-ments. \nEnvironments must access and up-date arguments, temporaries, and other variables. We also made environments \nre-sponsible for manipulating predefined lo-cations in memory, such as entry points into the operating \nsystem and addresses of the memory management routines. The control flow group included meth-ods for \ngenerating calls, conditional jumps, case, return and message send. We then divided the RunTimeSystem-sExpert \ninto three components, one for each group of methods, and made a class for each component. This par-titioned \nthe run-time system implemen-tation work into independent sub-tasks. However, there were still dependencies \nbe-tween components. The message send op-eration needed to know the structure of objects, classes, and \nmethod dictionaries, which were all primitive data types, but it also needed to use control flow opera-tions \nand is a kind of high-level control flow operation. Procedure calls involve creating new context frames, \na task asso-ciated with the environment group of mes- sages. Also, literals in Smalltalk are asso-ciated \nwith both the envirotiment and the primitive data types, because the environ-ment knows where they are \nstored, but the primitive data type knows how they are represented. The result was that the RunTimeSys-ternExpert \nwould not only communicate with its components, but they would com-municate with each other. Most commu-nication \nwas unidirectional, from the Run-TimeSystemExpert to the components, but it was important for each component \nto have an interface that the other com-ponents would use. Ideally, each compo-nent would have a fixed \ninterface, so it would be easy to replace one version of a component with another. If the interfaces \ncould stay the same, one component could be changed independently of other com-ponents. This is an example \nof the Open-Closed Principle. [Mey88] The problem is how to achieve this principle. 3 Phase 2: Creating \na black-box framework Once we had defined the components of RunTimeSystemExpert, we tried to make them \nmore general. We wanted to be able to implement any run-time system, so the new components should have \nan interface general enough to be used by any run- time system. The final goal was to be able to provide \na descriptive specification that the components would use to produce code. The compiler writer should \nnot have to subclass the components or have to deci-pher the code generatiou routines. 3.1 Control flow \nMaking the control flow component more general involved determining which con-trol flow operations were \ncommon to all run-time systems and which ones were spe-cific to certain groups of run-time systems. The \nbasic Pascal-type control flow com-mands seemed to be generic, but fancy op-erations like message send \nwere specific to a group of run-time systems. One possibil-ity was to have a superclass with an inter-face \nfor all basic control flow operations, and a subclass for each group of fancy control flow operations. \nHowever, it slowly became clear to us that all fancy control flow in high level languages had two im-portant \ncharacteristics: they were imple-mented in terms of the more basic ones, and they were always associated \nwith a primitive data type. In other words, fancy control flow operations were in fact basic operations \non primitive data types. This changed our approach to control flow. The control flow component just implemented \nthe basic operations. All other opera-tions were implemented in the the prim- itive data types module* \n3 2 primitive data types * Initially, we had a specific message for each type of request of the Smalltalk \nfront-end. Messages to access the class of an object, message to get a specific instance variable, messages \nto allocate objects, messages to get a specific constant. However, the goal was to make a new run-time \nsystem re-quire as little Smalltalk code as possible. The solution was to create a table of primitive \ndata type definitions, ancl to make a data type definition be an object that knew how to generate code \nfor each of its operations. Thus, the unbounded set of primitive data types operations was re-duced to \na small number of operations like fetch data type from table and gener-ate code for operation on data \ntype . The specification of the code for the operation could be stored in a table, indexed by the operations \nnames. It was still hard to cre-ate a data type definition, but the individ-ual definitions were now \nreusable between run-time systems, and the interface to the data types was now simple. All primitive \noperations were expressed as a low level RTL program. The Run-TimeSystemsExpert could pass the primi-tive \ndescription to the RTLBuilder, which would splice in the code at compile-time. Now, instead of having \nto create a new subclass for each new set of primitive data types, one would only have to write, in RTL, \nthe appropriate set of primitive op-erations, giving each one a name. The in-terface of the Primitive \nData Types com-ponent was reduced to only a few mes-sages: 0 messages to generate code for a spe-cific \nprimitive operation of a given data type. 0 messages to generate the run-time representation of a constant \nfor a given data type . messages for testing the data type of a given object reference. However, it also \nbecame clear that, for a given run-time system, the semantics of basic operations was essentially the \nsame across various implementations, while the format of the data types could vary a lot. The best example \nof this is probably in- tegers. Integers can be represented di- rectly in their machine representation, \ncan have low-bit tags or can have high-bit tags. All small integers have the same opera-tions, only \nthe data representation differs. We decided to separate the description of data type format and the description \nof the semantics of the basic operations. This way changes in data type formats could be more easily \nimplemented, increasing the modularity of the system. Both format and semantics could be ex-pressed using \nRTL code. Using code to specify semantics seemed reasonable to us, but we wanted to have a more descriptive \nspecification for formats. A program needs to know the format of a data type to access and update its \nvarious fields. These fields were grouped together in data blocks or inside a refer-ence word that could \nbe in memory or in registers2. We decided to create a class to describe each kind of field. Our ulti-mate \ngoal was to find all possible types of fields, references, and data blocks. Once 5mall integers are generally \nintegers that can be represented in a single machine word, and therefore be operated by a single machine \ninstruction 2A good example of fields inside reference words are Lisp s cells. Some implementations store \nboth the CAR and the CDR in the word that cout.ains the reference. this goal was accomplished, formats \ncould be described by just selecting which types of fields were necessary, without writing any code. \nThe PDTField hierarchy was designed to keep all necessary information regard-ing fields of data types. \nWe constructed a hierarchy of 10 classes to represent fields. This hierarchy includes classes for stan-dard \ndata fields, absolute pointers, relative pointers, indirect pointers, and multiple (indexed) fields. \nPointer field descriptors have enough information to distinguish be-tween pointers to other objects and \npoint-ers to data blocks. All code is generated automatically by the classes methods us-ing the information \nstored in the instance variables. One additional advantage of having spe-cific classes to describe the \nformat of data types is that we can write methods to ex-tract information about formats, such as routines \nto support garbage collection. The PDTField hierarchy was designed to be static. New subclasses should \nbe added only if some unpredicted type of field is desired, which should not occur of-ten. Compiler writers \nshould not need to do this subclassing. We also developed a small class hier-archy to describe data blocks \nand object references. This hierarchy included the classes DataBlock, PDTRefe,rerace and a common abstract \nclass, class Field~Iokkr. This hierarchy was also static. 3.3 Environment Environments look a lot like \ndata types. There are a standard set of operations applied on them (like the primitive op-erations of \ndata types). They have a fixed set of entries (much like the fields of data types). We considered joining \nthe environment component to the primitive data types component at first, but decided against it. There \nwere two main reasons behind it. First, we found that the oper-ations on environments did not change \nat all, so there was no need to require the user to write RTL code for them. Second, run-time systems \nspecified much more care-fully the placement of environment entries than placement of data type fields. \nFields of data types are just part of a data block or of the reference. The allocation and placement \nof this data block is not spec-ified with the data type. Environment descriptions, on the other hand, \nhave to specify if entries go in the stack, in the heap, or even in registers. Some entries may even \ngo at pre-defined addresses. Also, there is no notion of typing of entries in the same sense as in data \ntypes. The semantics of most of the information that is placed in the environment is not of the environment \ns concern, the environ-ment s task is only to keep this informa-tion, not to process it. The only infor-mation \nthat. is processed by the environ-ment components is the information about how to do static and dynamic \nlinking. In other words, information on how t,o ma-nipulate context fra.mes. Therefore, the environ tnent \nspecification was a separate, customized component. Environment has four classes of entries: 0 arguments \n0 implicit arguments 0 temporaries a global variables and constants Arguments are the standard arguments, \npresent in most message and procedure calls. Implicit arguments are the argu-ments added by the compiler \nlike, for ex-ample, the receiver of a message. Tem-poraries are the environment entries that depend on \nthe source code, like tempo-raries for computing expressions, environ-ment locations for dumping registers, \netc. Global variables and constants are the en-vironment entries that are not part0 of an activation \nrecord. These entries can go anywhere in memory. The first three types of entries are the ones that go \ninto context frames. Context frames are allo-cated and deallocated during the execu-tion of a program, \nand the environment component should know how to generate code for this allocation and deallocation. \nArguments and implicit arguments are al-located by the caller and temporaries can be allocated by the \ncaller or by the callee. Global variables can have their values re-trieved and updated, but there is \nno need to allocate space for them at run-time. The interface for the environment com-ponent is also \nfixed. There are methods to generate code for: . accessing and updating argument,s, implicit arguments \nand lemporaries. a allocating context frames. 0 creating a new temporary. . accessing and updating global \nvari- ables. Environment entries can be placed al-most anywhere. The position of an en-vironment entry \nis described by the class RTLLocution. Each instance of this class is able to generate code for accessing \nand updating that location. A compiler writer can describe the environment by selecting the appropriate \nlocations. No code will need to be written. There is a specific subclass of the RTLLocation hierarchy \nto describe each type of location: register lo-cation, frame location, data type location. A data type \nlocation specifies a data type and a field, and it generates code by del-egating to the primitive data \ntypes com-ponent. This lets the front-end be com-pletely independent of the format of the primitive data \ntypes, though it depends on the names of the data types and the names of the operations they support. \n  4 Phase 3: Creating a vi-sual interface Having created a black- box framework for specifying the run-time \nsystetn, the next step was creating a visud language ancl associated tools. These tools would then generate \nthe components of the compiler. The information that is best specified graphically is the format of primitive \nclata types. Both locations and fields can speci-fied by a series of semi-graphical windows. Since the \nset of classes is fixed, the user just specifies which type of location or field and then fills in information \nspecific to that kind of location or field. We also created browsers to specify en- vironments and data \ntypes. Each browser has a specific format to conform to the characteristics of the underlying compo- \nnent. 4.1 Specifying the Primitive Data Types Each instance of the PrimitiveDataTypes-Browser holds the \ndescriptions of all the data types of a single run-time system. An example of such a browser can be seen \nin fig. 2. The browser is quite similar to the system browser of Smalltalk-80. We have four sub-windows \nplus a radio button. The four windows are: . data type window (topmost, leftmost) . operation window \n(topmost, right-most) . code window (center) . data type format window (bottom-most) Selecting a data \ntype in the data type window will cause a graphi&#38; description of its format to be drawn in the data \ntype format window, and a list of operations to appear in the operations window. The selection of the \nradio button will deter-mine which operations will appear: prim-itive operations ( MAIN button), aux-iliary \noperations (used internally by the primitive operations code, AUX but-ton), and constant generation ( \nCONST button). When an operation is selected its RTL code will appear in the code win-dow, In our figure \nwe have selected the primitive data type bogus and selected the primitive operation demoOperation. The \nformat window shows that this data type is represented by a data block of 3 fields, the first called \nclass, the second size and the third instance variable. Any reference to such data type will have a pointer \nto this data block (as represented by the line linking the REFERENCE box to the DATA BLOCK box. The third \nbox is a description of the instVElrfield, which is an indexed field (i.e. PDTVariantRepeti-tionField \n) whose total size is in field size. All entries of instVar are 32 bits long, the first one being at \ndisplacement 2[0] (that is, second 32-bit word, bit 0). The code window is a standard text ed-itor that \ncan be used to specify RTL code for the basic operations of the primitive data types. The RTL code can \nrefer to fields by their name and the system will automatically generate code for access or update (whichever \nis the case). In the fig-ure the second instance of multiple field instlhr receives the content of field \nclass. The data format window is used to clis-play the data type s format and also to specify it. We \nspecify a new format for a datatype selecting the option acid field of the pop up menu. You are then \nguided by a series of request to specify the type of field, its clata block aud the appropriate information \nto describe the field. All the specification is done by selecting options of menus and by filling up \nentries in boxes.  4.2 Specifying the environment The EnvironmentBrowser is simpler than the PrimitiveDataTypesBrowser. \nFigure 1 shows that it has only two sub-windows and a set of radio buttons. The radio but-tons are used \nto select a group of environ- ment entries: global variables, arguments, tempararies, and implicit arguments. \nSe-letting a radio button causes the defined environment entries of the corresponding group to appear \nin the top window. Se-lecting an entry causes the browser to dis-play a textual description of the location \nassociated to it. Figure I: Environment Browser Figure 1 SLOWS the implicit argument met/iod selected \nfor inspection. The tex-tual description states that the implicit argument nlethorl is located at displace-nient \n0 (7,ero) of the main context frame and that it will conta.in a reference to a da.ta type. Describing \na new environment entry is similar to describing a field. The pop up menu of the topmost window has a \nnew entry option. The user has the choice of just writing the textual descrip-tion directly or engaging \nin a dialog that is entirely menu and form-driven.  5 Specifying the Control Flow We did not create \na tool to specify the flow of control because there are few alterna-tives. Most languages share the same \nset of basic control flow operations, which is implemented by class ControlFlow, whose methods generate \neach of the control flow operations. Usually a new form of con-trol flow is associated with a specific \ndata type, such as a continuation or an ob-ject, so it can be specified as an opera-tion on that primitive \ndata type using the PrimitiveDataTypeBrowser. Implement-ing that basic control flow operations dif-ferently \nrequires making a new subclass of ControlFlow, but we do not expect this to be necessary. 6 A method \nfor creating visual languages 6.1 ~~~ specification tools differ Any tool that can be used to specify \na sys- tem incorporates a model for generating the system. We can divide these tools in two groups: tools \nthat provide a closed model of the resulting system, and tools that only provide the user with a syn- \ntactic model to transform high-level spec- ifications into low-level implementations. Tools in the first \ngroup hide from the user all the details of the final form of the sys- tem, and tools in the second group \nprovide a language that expresses this final form. One example of tools in the first group are GUI builders \n[Ale871 [PS94]. The user has no idea of how the interfaces they spec-ify are going to be implemented. \nThey are provided with a model of interaction be-tween the figures and applications. A set of interface \ntypes is given to the user, to-gether with a composition model. We can use a visual language to perform \nthis com-position. The only code the user needs to write is the code to perform communica-tion with the \napplication, and even this is limited. An example of the second set of tools are attribute grammar systems \n[B.H78] [Mad80]. The user specifies the system us-ing a specialized programming language. A syntactic \nsubstitution transforms the specification into the realization of the sys-tem. This substitution is guicled \nby the syntactic rules given by the user. The tool itself has little semantics associated with it. The \ntool hides many of the details of the transformation, but the user must still know how the target system \nfunctions. At a first glance it would seem a mistake to choose the second type of tools over the first, \nbut the first type of tool is not always possible. We can only provide a black-box view of the final \nsystem implementation when all the possible options are known. That difference became very clear dur-ing \nthe development of our system. Se-mantics of primitive data types can be ar-bitrarily complex and we \nhad no hope of inventing a model that woulcl permit the development of a tool of the first kind. Therefore \nwe chose to perform the syn-tactic translation. The user is presented with a translation model: primitive \noper-ations names into RTL code, where RTL is the implementation model. For each op-eration, the user \nspecifies the RTL imple-mentation for it. However, we were able to better delimit the problem in the \nother cases. We cre-ated a fixed class hierarchy of field de-scriptors that could describe the format \nand functionality of any of the data type fields we have investigated. The same hap-pened with locations \nfor environment en-tries. We also successfully separated the environments into 4 different types of lo- \ncations, according to the way they are ma-nipulated at run-time. We created a fixed universe of options, \nand also a model to compose these fixed options. This let us construct a high-level language to spec-ify \nthose parts of the system. The user does not need to understand the final im-plementation for this part \nof the system. 6.2 An approach to developing a domain specific visual pro-gramming language The first \nstep in developing a domain spe-cific visual programming language is to clearly delimit the domain. This \ntask is not as trivial as it may seem. A good ap-proach is to start with a specific exam-ple in the problem \ndomain. This is what was clone in the first phase of our project. Our problem domain wa.8 run-time system \nimplementation, our example was the TS compiler. The lack of previous research in the specific problem \nof specifying a whole run-time system made the task less obvi-ous, and increased the importance of work- \ning initially with a specific example. Once the problem is delimited for the specific chosen example, \nwe should try to break it into independent subproblems. It is important in this phase to compare the \nspecific problem you are solving with other problems in the domain. This will help in finding a set of \nuseful subdomains. The result is probably a white-box framework. After a set of subdomains is found the \nnext step is to produce independent com-ponents to solve each of the subproblems found. The subproblems \nshould be as in-dependent from each other as possible. Any dependencies should be expressable through \na fixed interface. The result is a black- box framework. Since the goal is to provide a domain-specific \nvisual language, we need to find the basic units of this language. For each component of the system, \ndetermine the variability. If there are a fixed set of pos- sibilities for a component, create a set \nof classes to describe them. Instances of these classes should be able to produce a solution for the \nspecific subproblem they tackle, given t,he state information they hold. When we cannot find such a fixed \nset of possibilities, a language should be chosen to specify how to map the requests to the component \ninto a solution. In our case we chose RTL for specifying the se-mantics of the primitive operations. \nThe next step is to give the final form to the visual language. Each subcompo-nent of the system can \nhave its own vi-sual tool. This tool will provide the users with ways of specifying the solutions of \neach of the subproblems of the problem domain. Components with fixed set of possible classes can use \na menu and dia-log box type of language. The final step is to develop a tool for organizing existing \nsolutions and for spec-ifying new ones. This tool is usually some kind of browser. The browser should \noffer an organized list of solutions and some vi-sualization for them. This visualization is often graphical, \nbut sometimes a textual description is more clear. 7 Conclusion This paper describes a general-purpose \ntechnique for designing a domain-specific visual programming language. We ve seen it used in other frameworks, \nbut none of them have been publically documented, and the technique itself has not been de-scribed before. \nIt should be a key tool for framework designers.  References [Ale871 James II. Alexander. Pain-less \npanes for Smalltalk win-dows. In Pmceedings of OOP-SL.4 $7, Object-Oriented Pro-gwnl~rning Sjystems, \nLnnguqes [B .~78] [Cat781 [ESL89] [Fra89] [FS89] and Applications, pages 287-294, November 1987. printed \nas SIGPLAN Notices, 23(11). B.H.Mayoh. Attribute Gram-murs and mathematical seman- tics. PhD thesis, \nComputer Science Department, Aarhus University, Aarhus Denmark, 1978. R. G. G. Catell. Formafiza- tion \nand Automatic Derivation of Cocle Generators. PhD the-sis, Computer Science Depart-men t , Carnegie-Mellon \nUniver-sity, 1978. Hemu t Emmelmann, Fredrich-Wilhelm Schroer, and Rudolf Landwehr. A generator for effi-cient \nback ends. In Proceedings of the ACM SIGPLAN Con-ference on Programming Lan-guages and Design and Im-plementation, \npages 227-237, 1989. Christopher W. Fraser. A lan- guage for writing code gen-erators. In Proceedings \nof the ACM SIGPLAN Confer-ence on Programming Lnn-guages and Design and Im-pkmentntion, pages 238-245, \n1989. Rodney Farrow and Alec G. Stanculescu. A VHDL com-piler based on attribute gram-mar met hodolonv. \nIn Proceed- [Gab851 [GH JV95] [Gla77] [HC86] [dF88] ings of the ACM SIGPLAN Conference on Programming \nLanguages and Design and Im- pfementation, pages 120-130, 1989. R. Gabriel. Performance and Evaluation \nof LISP Systems. MIT Press, 1985. Erich Gamma, Richard Helm, Ralph Johnson, and John Vlis-sides. Design \nPatterns: El-ements of Reusable Software. Addison Wesley, 1995. Robert Steven Glanville. A Machine Independent \nAlgo-rithm for Code Generation and Its Use in Retnrgeatable Com-pilers. PhD thesis, Computer Science \nDepartment, Univer-sity of California at Berkeley, 1977. Philip J. Hatcher and Thomas W. Christopher. \nHigh Quality Code Generation Via Bottom-Up Tree Pattern Matching. In Proceedings of the 13th Symposium \non Prin-ciples of Progranmnzing Lnn- gtlclges, pages 119-130, Jan- uary 1986. Ralph E. John-son and Brian \nFoote. Design-ing reusable classes. .Journnl of Object-O.riented Progmtnnzing, l(2):%35, 1988. [JGZBB] \nRalph E. Johnson, Justin 0. Graver, and Lawrence W. Zu-raws ki . TS: An optimizing compiler for Smalltalk. \nIn Proceeding5 of OOPSLA $8, Object-Oriented Programming Systems, Languages and Appli-cations, pages \n18-26, Novem-ber 1988. printed as SIGPLAN Notices, 23( 11). [Joh75] S.C. Johnson. YACC: Yet An-other \nCom-piler Compiler. Technical Re-port Technical Report 32, Bell Laboratories, 1975. [Knu65] D. E. Knuth. \nOn the transla-tion of languages from left to right. Information nnd Con-trol, (8):607-639, 196.5. [Kra83] \nGlenn Krasner. Smalltallc-50, bits of history, words of advice. Addison Wesley, 1983. [La1651 W. R. Lalonde. \nAn efficient lalr parser generator. Infornacl-tion und Control, (8):607-639, 196.5. [Mad801 Ole Lehrmann \nMadsen. On defining semantics by means of extended attribute gram-mars. In Senanntics-directed C ompiler \nGeneration-Lecture Notes In Computer Science 94, pages 259-299. Springer Ver-lag, 1980. [MeyBB] W701 \n[PLGBB] [PS94] [She881 Bertrand Meyer. Object-Oriented Software Construc-tion. Prentice-Hall, 1988. Perry \nL. Miller. Automatic code gener-ation from an object-machine description. Technical Re-port Technical \nMemorandum 18, Project MAC -MIT, 1970. Ed uardo Pellegri-Llopard and Susan L. Graham. Optimal Code Generation \nfor Expres-sion Trees: An Aplication of BURS Theory. In Pro-ceedings of the 15th Sympo-sium on Principles \nof Program- ming Languages, pages 309-318, January 1988. Inc ParcPlace Systems. Visu-alworks User s Guide, \n1994. Stanley T. Shebbs. Implement- ing Primitive Datatypes for Higher-level Languuges. PhD thesis, Department \nof Com-puter Science of the University of Utah, 1988. NAME: InstVar PosItion: 2101 Size: 32 BitMask: \nA[34 DataBlock: header Type of Repeated Field: PDTPointerField Total Size In Field: size Figure 2: Primit,ive \nData Types Browser  \n\t\t\t", "proc_id": "236337", "abstract": "Frameworks and domain-specific visual languages are two different reuse techniques, the first targeted at expert programmers, the second at domain experts. In fact, these techniques are closely related. This paper shows how to develop a domain-specific visual language by first developing a white-box framework for the domain, then turning it into a black-box framework, and finally building a graphical front end for it. We used this technique in a compiler to specify run-time systems.", "authors": [{"name": "Alan M. Durham", "author_profile_id": "81100346535", "affiliation": "Universidade de S&#227;o Paulo", "person_id": "P12387", "email_address": "", "orcid_id": ""}, {"name": "Ralph E. Johnson", "author_profile_id": "81330492373", "affiliation": "University of Illinois", "person_id": "PP39078430", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236381", "year": "1996", "article_id": "236381", "conference": "OOPSLA", "title": "A framework for run-time systems and its visual programming language", "url": "http://dl.acm.org/citation.cfm?id=236381"}