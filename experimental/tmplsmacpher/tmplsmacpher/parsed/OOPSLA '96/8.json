{"article_publication_date": "10-01-1996", "fulltext": "\n Split Objects: a Disciplined Use of Delegation within Objects * Daniel Bardou Christophe Dony bardou@lirmm. \nf r dony@lirmm.fr Laboratoire d hformatique, de Robotique et de Micro-e lectronique de Montpellier 161, \nrue Ada -34392 Montpellier Cedex 5 -FRANCE  Abstract This paper s primary aim is to improve the un-derstanding \nof the delegation mechanism as de- fined in [18]. We propose a new characterization of delegation based \non the notions of name shar-ing, property sharing and value sharing. It allows us (1) to clearly differentiate \ndelegation from class-inheritance in particular and more generally from other inheritance mechanisms \nand (2) to explain how a founded use of delegation relies on a correct semantics of variable property \nsharing between ob-jects connected by a delegation link. We then de-scribe a model of split objects which \nis proposed as an example of a disciplined and semantically founded use of delegation, where property \nsharing expresses viewpoints within objects. Introduction All kinds of inheritance mechanisms in object- \noriented programming or representation languages, despite their diversities [5, 261, have at least the \nfol- lowing common points [II]: . They are based on a relation Z between ob- jects or between concepts \n(for example the *Partially supported by March6 CNRS/CNET 93 1B 142, Projet 5115 Rkseau futk . Permission \nto make digital/hard copy of part or all of this work for PEOnal or classroom use is granted without \nfee provided that copies are not made or distributed for profit or commercial advantage, the cppyright \nnot@ the title of the publication and its date appear, and nOtiN !s Qlven that copying is by permission \nof ACM, Inc. To copy other? -e, to,r,epublish, to post on servers, or to redistribute to lists, requires \npnor speclflc permission and/or a fee. OOPSIA 96 CA, USA Q I 996 ACM o-89791 -788-x/96/001 0...$3.50 \nsubtype relation between abstract data types which is implemented in class-based languages by a superclass \nlink between classes). The mechanism itself uses that relation to achieve inheritance (for example a \nmessage sending mechanism in class-based language which performs a lookup - whatever form it takes - \nalong the superclass links to re- trieve inherited properties). An interpretation or a semantics is \ngiven to the relation Z to justify the above mechanism. For example in class-based languages the formal \nproperty that gives a meaning to the super- class link and underlies inheritance is inclu- sion polymorphism \n[6], other interpretations, such as concept specialization or set inclusion, have been given in other \ncontexts. Finally, a common characteristic of all inher-itance mechanisms is that they are used to achieve \nsome kind of sharing [26]. We deal in this paper with the delegation mechanism, as it is defined in \n[17, 18, 261, which does not exactly denotes a message redirection (as in actors systems) but actually \na kind of inher- itance mechanism (which can be understood in The reason why it is founded to look up \nfor methods in a superclass is that any function applicable to objects of a type 7 (instances of a class \nC) is intended to be also applicable to objects of type 7 subtype of T (instances of C s subclasses). \na way as a message redirection). Delegation in this sense is thus a kind of inheritance mechanism which \nis generally associated to object-centered or prototype-based programming [18,29, 301 in a one kind of \nobject-one kind of link world. In fact, to be class-less and to provide a delegation mechanism are two \northogonal features of an object-oriented programming or representation language [19]. Ef-ficient class-less \nlanguages with some kind of shar- ing but without delegation can be built [28] and it is possible to \nimagine some uses of delegation in many different worlds including worlds without classes [l] and worlds \nwith classes [lo! 15, 161. The delegation mechanism is based on a link (generally called parent or delegation \nlink) between ob-jects*, rather than between descriptions. In object- oriented programming, delegation \nis presented as a message forwarding mechanism [17, 181: infor-mally described in the following way: \nan object that cannot answer a question can delegate it to its parent: if the parent can answer it: the \nanswer will be performed in the context of the values of the original object . An example of such objects \ncan be found in the classical point-turtle example (see Fig. 3-a, page 8). Finally delegation is a kind \nof sharing mechanism [9? 261. If this very general description is to be compared to the four points above, \nit appears that two very important things are missing that limit our under-standing of delegation: (1) \nwhat is the kind of sharing actually achieved by this mechanism and (2) how to interpret the relation \non which the mech- anism is based: 1. The kind of sharing achieved by delegation is not yet well characterized, \nfor example the difference between delegation and class-inheritance (let, us give that name to the in-heritance \nmechanism found in class-based sys-tems) is still unclear. Contrasting with gener-ally accepted ideas, \nwe claim that delegation is not class-inheritance and that delega.tion is not to class-less objects what \nclass-inheritance is 2We more exactly mean between entities holding vari-able values and used to perform \ncomputations, these can be classes but seen as objects. to classes. Delegation is not class-inheritance \nbecause the former and the latter do not in-duce the same sharing relation between ob-jects: an instance \nil of a class Q! and an in-stance i:! of a class p subclass of a: do not share the same things than an \nobject 01 and an ob-ject 02, 01 having 02 as parent. 2. Once the kind of sharing actually achieved by \ndelegation has been characterized, the next question is: what does it mean for two en-tities to be connected \nby a delegation link? More precisely: what semantics or interpreta- tion can be given to the relation \nbased on that link? The aim of this paper is to address these two points. Concerning sharing, it is \nalready well known that delegation induces a sharing of variable values but a formal characterization \nof delegation is needed to express more precisely and in a simple way the differences with other inheritance-based \nsharing mechanisms. For what concerns the interpretation of the link, the problem is to correctly use \nvariable value sharing which, when used without care, raises the problem of object-identity [9, 19, 271. \nWhat does it mean for an entity to share variables values with another? A first answer can be found in \nsome existing systems in which delegation is used to perform some life-time default value sharing between \nconcepts and objects. We will introduce and develop a second answer [3, 201 by defining what we call \nsplit objects . In split objects, delegation is used inside objects to express property sharing between \ndifferent perspectives or viewpoints. The paper is organized as follows. Section 2 formally defines name \nsharing, value sharing and property sharing. Section 3 proposes a character-ization, in term of these \nnotions, of both sharing in class-based systems and sharing in delegation class-less systems. It shows \nhow delegation induces property sharing for both variables and methods. Section 4 recall the possible \nbad consequences of sharing variables on object modularity. Section 5 recall a well-known use and interpretation \nof vari- able sharing with delegation and its semantics as it can be found in existing systems. Section \n6 then discuss a second founded use of delegation which express viewpoints. Section 7 describes what \ncould be a model in which the latter use of delegation is disciplined within what we call split objects. \nFi-nally section 8 briefly compares split objects with some existing object systems allowing to express \nviewpoints. 2 Name sharing, value sharing, and property sharing We define in this section the notions \nof name shar-ing, property sharing and value sharing3 between objects integrated in a single4 inheritance \nworld. These notions will be used in the next section to formally characterize the kind of sharing achieved \nby various inheritance mechanisms. 2.1 Properties What defines objects in object-oriented systems are, \ngenerally speaking, properties. We use the term property to designate either a slot , an at-tribute , \na field , an instance variable , or a method . We do not use the term property to designate generic properties5 \n(it is for example pos-sible to talk about the global entity printOn: in Smalltalk), but rather the properties \nactually de-fined on classes or objects (for example the method printon: of the class String in Smalltalk). \nProper-ties are declared and defined for objects (wherever the declaration and definition take place). \n3The formalism we define has been inspired from the one appearing in [ll] in which the notions of name \ninheritance and value inheritance are defined. The two formalisms are however different and there is \nno direct correspondence be-tween name inheritance and name sharing, or between value inheritance and \nvalue sharing. Indeed, generic properties are considered in [ll] whereas they aren t here. 4These notions \nare basically not different in presence of multiple inheritance but are more difficult to express for-mally. \n5Such entities are reified in Clos (generic functions) and in Lore. Property names. We consider that \nproperties can be identified by a name in the context of an objet@. Several properties can of course \nbe given the same name for different objects. Property values. Properties may be complex entities but \nthey have at least a value (they may also have a type, a signature, a cardinality, etc.). Each property \nhas only one value (of course, a value can be the value of several properties). Formally, let us consider \nan object system char-acterized by a set 0 of objects, a set P of prop-erties, a set N of property names \nand a set V of values, we define the following functions: NameOf : P -+ N RefProp : N ---+ 2? Prop : \nOxN + P Vu1 P --+V Given an object o E 0, a property p E P and a property name n E N: NameOf is the \nname of p, RefProp(n) is the set of the properties named n, Prop(o,n) is the property of a which is named \nn (the property identified by n within the con-text of o), and VaZ(p) is the value of p. We also note \nVaZue(o,n) = VaE(Prop(o, n)) the value of the property of o which is named n. Various kind of sharing \nwill then be defined in terms of two sets: No and No. No is the set of property names which identify \na property within the context of o, in other words No is the set of properties declared for o. The value \nof a property for an object o can be either defined at the object level7 or inherited. For an object \no, No is the set of the names of properties the value of which is de- fined at the object level. We separate \no s property names in two sets: No and No-No, the set of the names of properties the value of which is \ninherited. We use the term name to designate what is sufficient to identify a property, this term can \nthus encompass name and signature for example. 7We mean either in the object or in its class or anywhere \nin a place directly accessible independently of the inheritance mechanism. 2.2 Sharing To say that an \nobject o has a property n with value w means three things: (1) o has a prop-erty named n (i.e. n E NO), \n(2) this property is identified in o by n as a certain property p (i.e. Prop(o,n) = p E P), and (3) the \nvalue of the property of o which is named n is u (i.e. VaZue(o,n) = VaZ(p) = v E U). We define sharing \nas a relation8 S from 8 to 0, and we note <S (respectively 2s) the transitive (respectively transitive \nand reflexive) closure of S. Sharing thus applies at those three levels: what can actually be shared \nare property names, properties themselves and property values. 1. Name sharing What is shared in name \nsharing is the fact of having a property of a given name, or in other words, the declaration of a property \nor the existence of a property. More formally, a sharing relation S is charac- terized as being a name \nsharing relation when: or: if or <s 02 then if 02 has a property named n, then or also has one. For a \nconcrete example, consider a class-based world with two instances ir and ip of a class Q (or ir an in-stance \nof (Y and i2 an instance of a subclass of GE): if an instance variable name n is declared on GE then \nir and i2 share the fact that they have a property named n, and that it will be possible to ask any of \nir and i2 the value of its property named n. 2. Property sharing Property sharing implies name sharing. \nWhat is shared in property sharing are properties We do not expect a sharing relation to be symmetric. \nThis can be misleading as far as to say that something is shared between an object 01 and another one \n02 is equivalent to say that the same thing is shared between 02 and or. We define however sharing as \na directed relation in order to be able to identify what is shared between two objects. themselves. It \noccurs when a given name n identifies exactly the same property in two or more different objects). We \ncharacterize as be- ing a property sharing relation any name shar-ing relation S such that: (Vn E No1 \n-N 1, Prop(ol, n) = Prop(o2, n)) or: if orSoz then if 02 has a property named n and if or has no local \ndefinition for that prop-erty (n E No1 -No1) then the property of or which is named n is also the property \nof 02 which is named n. The important conse-quence (discussed in 5 4) is that the value of the property \nof or which is named n will be the same than the value of the property 02 which is named n (at least \nas long as n E No1 -No ). For an example, consider two instances ir and i2 of the same class Q and a \nmethod named m which value is defined on cy, ir and ix share that method.  3. Value sharing What is \nshared in value sharing are property values. A sharing relation S is said to be a value sharing relation \nif: V/(01,02) E 02, OlSO:! =+ (Vn E No1 -N l, Value(ol, n) = VaZue(o2, n)) or: if orSo then if 02 has \na property named n then the value of the property named n of or is the same as the value of 02 s property. \nValue sharing implies name sharing. Property shar- 1ng implies value sharing but the opposite is not \nnecessarily true. Value sharing is further discussed in 5 5.   3 Sharing in class-based systems and \nsharing achieved by dele-gat ion We give in this section a characterization of both kinds of sharing \nfound in class-based systems and delegation-based systems, using the previously de-fined notions of name \nsharing and property shar-ing. This characterization will reveal how the two inheritance mechanisms are \ndifferent. 3.1 Sharing in class-based systems is name sharing for variables and property sharing for \nmethods Classes, variables and methods. In class-based systems a distinction is made between state proper-ties \n(variables) and behavioural properties (meth-ods) . The declarations of variable and method names and \nthe definitions of method values9 are done at the class level. Given an object o, let us note CZass(o) \nthe class of o, and given a class cy, VN, the set of the variable names declared for in-stances of Q \nand MN, the set of method names declared for instances of Q. According to our pre-vious definitions (see \n5 2), No = VN, U MNQ for any object o. Class-inheritance. Classes are organized in a class-inheritance \ngraph which we note Gz = (C,Z) where C is the set of classes and 1 is the inheritance relation. We note \n<z the transitive closure of Z, and 5~ the transitive and reflexive closure of Z. Given two classes Q \nand ,L?, if a <z ,13 (respectively aZ/3) then a is said to be a subclass (respectively a direct subclass) \nof /3. Sharing in class-based system is variable name sharing. Class-inheritance is used to deter-mine \nthe YN, set for any given class cy. It ensures that any variable name of which the declaration is held \nby cx or one of the o s superclasses is an element of VN,: v(cv, /3) E C2, cy <z /3 =+ VN, 2 VN, Therefore, \nit is easy to prove the existence of a variable name sharing relation SZ between objects, which can be \ndefined by: ClUSS(Ol) = Class(o2) V(o1,02) E cJ2, OlSZO2 @ or Czass(ol)ZCzass(02) Method values can be \nthought of as lambda-expressions. In other words, each instance of a class (I! shares the N existence \nof its variables with any other instance (u of a! and moreover with any other instance of any **I*, a \ns subclass. Of course, each instance will own a proper value for each variable declared in its class. \nNote that there is neither property nor value shar- ing for variables. Sharing in class-based systems \nis method property sharing. As for variable name decla- rations, class-inheritance is used to determine \nthe MN, set of any given class CX: It is straightforward to establish that ST is also a method name sharing \nrelation. Furthermore, class-inheritance is also used for method activation. Methods that can be acti- \nvated by sending a message to a given object o are those the value of which is defined in Class(o) or \nin one of Class(o) s superclasses. We distin- guish between them by calling MNcLass( ) the set of the \nformer (the latter being in the set MNclasscoj -MNC1ass(o)). Given an object or, when a message is sent \nto activate the method m named n of or, a lookup for m s value definition is performed which is started \nat or s class and eventually continued along the inheritance links to be finally found in a certain class \n,0. p can hold only one value definition for the method named n, this implies that n identifies a unique \nmethod within the context of /3, and this method is m. As we could have chosen any object 02 among the \ninstances of any class CY, such that CZass(or) <_I p and a <z ,B, instead of or for the lookup to terminate \nin /3, we can conclude that: qm32) E 02, 015202 * (Vn E MNclass~ol~ -MNC aSS(ol), Prw(ol, n) = Pw402,n)) \nThus class-inheritance induces property sharing for methods. In other words, all the instances of a class \np have the same behavioural properties (and thus the same behaviour) and, given any o, sub- class of \n0, all of these properties which are not redefined in ~1: are also some behavioural properties of a \ns instances. 3.2 Delegation achieves (variable and method) property sharing We characterize here the \nkind of sharing achieved by delegation. In a delegation-based system, prop-erty name declarations and \nproperty value defini-tions are directly done at the object level, on a per- object basis [26], and inheritance \ndirectly occurs between objects. Objects are linked together by delegation (or parent) links in a delegation \ngraph Gz, = (0,D), the vertices of GD are the objects of the system. D is the delegation relation, we \nnote <v its transitive closure and 12) its transitive and reflexive closure. If, given two objects or \nand 02, 01 <v 02 (respectively orDo2, i.e. there is a dele-gation link from 01 to 02) then 01 is said \nto be a descendant (respectively a child) of 02, and 02 an ancestor (respectively the parent) of or. \nDelegation is a message forwarding mechanism which ensures that: when an object or is asked for the value \nof one of its properties named n and it can not answer by itself (i.e. n @ n/*1), the question is forwarded \nto the ancestors of o with the task for the nearest ancestor which is able to answer, let s call it 02: \n(i.e. n E No2) to perform the answer in the value context of o. D is also a name sharing relation. Indeed, \nfor any object o a value can be computed for any property name which is declared for any ancestor of \no, ei-ther this value is explicitly defined for o, or it is inherited. Therefore any property name which \nis the name of a property of at least one of the ascen-dants of o is also a property name for o: ~(01,02) \nE 02, 01 <ID 02 =+ No, 1 No, 2, is also a property sharing relation. Indeed, consider the lookup performed \nat the reception of a message sent to an object 01 asking for the value of a property p named n. Let \ns call 02 the object where this lookup ends. 02 is the object holding the definition of p s value: and \nsince 02 can only hold one definition of the value of the property named n, n also identifies p within \nthe context of o2 (i.e. Prop(or,n) = p = Prop(oz,n)). Note that we could have done the same reasoning \nwith any object 03, such that or 12) 0s and 0s 1~ 02. We thus deduce that: tJ(Ol,O2) E 02, 012)02 =+ \n(Vn E No,-No , Prop(ol, n) = Prop(oz, n)) In other words, an object shares each of its prop-erties with \nits descendants which do not hold a def- inition of the value of this property. Remark: As there is exactly \nthe same kind of shar- ing for both variables and methods in delegation-based systems, they can be (but \nare not necessar-ily) embedded in the unique notion of property (as done with the slots of SELF [l]). \n  4 Variable value sharing and del- egation semantics The important result of the previous section is \nthe characterization of delegation as a mechanism entailing property sharing for both variables and methods \nand class-inheritance as one entailing also method property sharing but only variable name sharing. From \nthis perspective, the main difference between the two mechanisms is that delegation in-duces property \nsharing for variables. We focus on this characteristics to bring to the fore the semantic issues raised \nby the existence of a delegation link between two objects. For this purpose, we recall in 5 4.1 the intrinsic \ninterest of variable property sharing and in 5 4.2 the problems it raises. 4.1 Variable property sharing \nis useful Consider some objects representing a person -say Joe -in a delegation-based system as shown \nin Fig. 1 (such an example is also considered in [3, 9, 201). Suppose we first want to con-sider Joe \nas a simple person, we create the ob-ject JoePerson with the variables address; age, name and phone, \nand a method growold. Then the object JoeSportsman is created with the vari-ables stamina and weight \nas a child of JoePerson in order to be able to deal with Joe as a sports-man. The delegation link from \nJoeSportsman to JoePerson ensures that all the properties of the latter are shared by the two objects. \nNote that representing Joe by these two objects allows us to deal with: Joe as a sportsman (whose properties \nare weight, stamina, address, age, name, phone and growold), Joe as person (without the weight and stamina \nproperties). JoeFilmEnthusiast JoeSportsman Figure 1: A representation of Joe split in three objects. \nWe also keep the ability to create other chil-dren of JoePerson along other lines. We do it when creating \nthe JoeFilmEnthusiast object, having JoePerson as parent, with the definitions of the variables favouriteActor, \nfavouriteFilm and favouriteDirector. Note that in this example we clearly want the three objects to denote \nthe same entity of the real world, the real person Joe. Thus the address variablelO owned by JoePerson \nis also intended to be the address variable of JoeSportsman and JoeFilmEnthusiast. For that reason, variable \nproperty sharing achieved by delegation is in this case welcomed because any message attempting to affect \nthe address variable will result in the mod-ification of the address variable in the JoePerson object \nand thus be effective for all the three objects. The address variable is here considered as an example, \nwe could have made the same remarks for any other variable owned by JoePerson. Figure 2: Another representation \nof Joe completed with an employee aspect. Furthermore any property can be redefined in a child of JoePerson. \nFor example, JoeEmployee is created as a new child of JoePerson, denoting Joe as an employee, in which \na new degree variable is defined and the two variables address and phone are redefined (see Fig. 2). \nAs far as redefined prop-erties are not shared, Joe is represented as having different address and phone \nnumber while he is at his work. There is no simple way to obtain an equivalent representation in a class-based \nlanguage since class-inheritance simply does not achieve variable prop-erty sharing. 4.2 Variable property \nsharing raises the problem of object identity We recall here how variable property sharing breaks the \nfrontiers of objects and subsequently breaches encapsulation [27]. More generally we raise the issue \nof the interpretation of the delega-tion link. Consider another example in a delegation-based system. \nA point at 5@10 is represented by an ob-ject Pointl, and a turtle at lo@10 and heading to 90 by an object \nTurtle1 (see Fig. 3-a). Be-cause a turtle object is like a point object having one more variable (heading) \nand two more meth-ods (rotate and forward), and more specifically because Turtle1 has the same value \n(at least, at creation time) for the y variable and a different value for the x one as Point 1, Turtle \n1 is made a child of Pointl. If now Turtle1 is asked to move at 10@14, its y value has to be changed. \nA value def-inition of y is not found in Turtle1 but in Point1 where the modification is performed (see \nFig. 3-b). As delegation basically achieves property sharing, the parent link not only grants a read \naccess but also a write access for Turtle1 to the y variable owned by Point 1. Consequently, if we only \nexpect an object to be an entity which is able to receive messages, then Turtle1 and Point1 can be considered \nas two dif-ferent objects but this become false as soon as we also expect an object to be an independent \nindi-vidual entity. In most of the delegation-based languages, there is no prerogative to create an object \nas a child of another. Full access to an object s properties can then be gained in an unexpected manner \nby creat-ing a child of it. Either property sharing basically achieved by delegation should be restricted \nto value sharing (see \u00a7 2 for definition), or a set of objects connected by delegation links have to \nbe consid-ered as the parts of the representation of only one global entity (as was done in our previous \nexample given in \u00a7 4.1). To choose between these two alter-natives amounts to choose between two different \nbut founded use of delegation.  5 A first semantics: individua .1 objects and default values A first \nsound semantics for delegation can be found in some actors systems (e.g. Act1 [17]), frame-based ones \n(e.g. Y3 [lo]) but also prototype-based ones (e.g. the KR language of Garnet [22]). In these systems, \nthe properties of an object can not be modified by sending an affectation message to one of its descendants. \nAn object has at least as many properties as its parent, each of these prop-erties is identified by the \nsame name within the context of any of the two objects and has the same value default value . Point \n1 5 10 90 Figure 3-a: before the mod-ification of y. Point1 Point I 7. 5 14 add Y   tils move Turtle1 \n1 Figure 3-b: after the mod-Figure 3-c: after the modifi-ification of y with property cation of y with \nvalue shar-sharing. ing. Figure 3: Point 1 and Turtle1 share the y variable. The modification of y s \nvalue of Turtle1 leads to the case of 3-b with property sharing and to the case of 3-c with value sharing. \nConsider again our point-turtle example (see Fig 3-a). The reason why the Turtle1 object is made a child \nof the Point 1 object is clearly in this case the reuse of the definition of Pointl s proper-ties. We \ndo not want Pointl s properties to be the very properties of Turtlel, but rather Point 1 to provide default \nvalues for the Turtlel s variables which are not redefined. In order to ensure this an y affectation \nmessage sent to Turtle1 should not Lieberman also suggested objects as default behaviour and value repositories \nfor their children in [18]. result in Point l s y value modification as shown in Fig. 3-b but rather \nin the definition of the y variable in Turtle1 as shown in Fig. 3-c. Such an interpretation of variable \naffectation amounts to re-strict, by a separate mechanism, property sharing (basically achieved by delegation) \nto value sharing. Either this mechanism can test for the existence of a definition in some ascendant \nfor the variable to be affected before adding a new local definition (as in Y3 [lo]. Or it can systematically \nconsider the affectation of a non locally defined variable as the creation of a new initialized variable \n(as in KR Pa Delegation links can in this case be intended as is-like-a links. Delegation then grants \nread access to variables but no more write access to the par-ent properties. The frontiers between objects \nare then clear: in our example Point1 and Turtle1 are really two different objects and can evolve on \ntheir own. The only way to modify the value of the Point l s y variable is to explicitly send a message \nto Pointl. Although this will also modify the y value for Turtlel, this isn t unexpected since this value \nis only intended to be a default one. 6 A second semantics: view-points within an object We showed in \nthe previous section that property sharing is restricted to value sharing in some exist-ing systems in \norder to get rid off the problem of object identity. But we also pointed out in 5 4.1 the usefulness \nof property sharing by producing an example of the representation of a person Joe. We introduce in this \nsection a second sound semantics which retains property sharing. Consider again the representation of \nJoe which is split in four objects (see Fig. 2): JoePerson, JoeEmployee, JoeFilmEnthusiast and JoeSportsman. \nWhat does this mean exactly? According to Ferber, objects denoting the same en-tity (coreferent objects) \ndenote viewpoints of this entity [13]. It should be clear that JoePerson denotes Joe as a person, JoeSportsman \nJoe as a sportsman, JoeFilmEnthusiast Joe as a film en-thusiast and JoeEmployee Joe as an employee. To \nsplit a representation in several objects in a delegation hierarchy is simply a natural way of rep- resenting \nviewpoints. As in a description hierarchy, the most general viewpoints are those denoted by the objects \nnear the top of the hierarchy whereas the most specific viewpoints are those denoted by the objects which \nare leaves of the hierarchy. In our example, person is a more general viewpoint on Joe than either employee, \nsportsman or film enthusiast. We however still face some problems because we can not deal with the whole \nrepresentation of Joe. We can not send messages to it but only to one of the objects denoting a viewpoint \nof Joe. We neither deal with the whole representation as a structure in order to duplicate it for example. \nThe problem of object identity is still not resolved but we now know that the frontier to be put on the \nsplit representation is one around it all, that is around the four objects in our example. A solution \nto these problems is to give the object status to the whole representation and to remove that sta-tus \nfrom its four parts. Indeed, we can no more consider JoeEmployee (for example) as an object because there \nwould be a conflict between its fron-tier and the one of the whole representation. The inadequacy between \nthe system and the real-world should be recovered: a one-to-one correspondence between objects in the \nsystem and entities of the real world should be ensured. We define split ob-jects for this purpose in \nthe next section. 7 Split objects We have shown in the previous section that dele-gation can be used \nto achieve a per-viewpoint rep-resentation of a single entity of the real world. We also pointed out \nthat a solution to some problems raised by these representations relies on a one-to-one correspondence \nbetween objects in the system and entities of the world being represented. We propose in this section \na model for split objects in which this correspondence is respected. Teacher Researcher Figure 4: A split \nobject representing a person, 7.1 A basic model for split objects A split object is defined as a collection \nof pieces. The properties of a split object are stored into its pieces. Pieces are organized within an \nobject in a delegation hierarchy (a property sharing one). A split object denotes a single entity of \nthe real world and its pieces denote viewpoints of this en-tity. Pieces do not have an object status, \nwhereas split objects do. To illustrate what a split object is, consider our new completed repre-sentation \nof Joe shown in Fig. 4. Joe is now repre-sented by a single split object Joe which contains nine pieces. \nPerson, Employee, FilmEnthusiast, and Sportsman are no more objects but only pieces of Joe. We detail \nbelow the basic fea-tures that an object-centered language with cloning should include to provide for \nsplit objects. The reader is also referred to [3] for a more complete description of this model and to \n[20] for a denota- tional semantics of a similar one. each piece denotes a viewpoint on this person. \n Naming and accessing As far as split objects are first class entities, they are directly accessible. \nThis is not the case of pieces, which can only be accessed through the en-compassing split object by \nspecifying a piece name. Creation Split objects are created by cloning. A special case of creation is \ncreation ex-nihilo: it is achieved by first cloning the empty split object (a predefined object of the \nlanguage having no pieces) and then performing as many piece additions as required. Cloning Cloning a \nsplit object results in a new split ob-ject, initially composed of the same set of pieces holding the \nsame properties. Cloning a split object thus consists in deep copying the pieces hierarchy in which each \npiece is shallow copied. Modification Split objects can be modified on a per piece basis. One can add \nto, delete from or modify a piece of a split object. . Adding a piece is performed by creating a new \nempty piece as a child of an existing one. Iden-tifiers of both the existing and the new pieces should \nbe specified. . Piece deletion also implies the deletion of all the descendant pieces in the hierarchy: \nrecall that a piece denotes a viewpoint and descen-dant pieces denote more specific viewpoints. If Joe \nis no more a sportsman, it is clear that he can no more be a skier, a volleyball player or a tennis player. \n. Piece modification consists in either adding a property, deleting a property, setting a new value to \na variable, or changing the body of a method stored in a piece of the split object.  Basic message sending \nA split object s property values are accessed by message sending. Since methods and variables are owned \nby the pieces and since pieces denote view-points, messages are sent on a per viewpoint ba-sis. When \na message is sent to an object, a view-point must be specified by giving the identifier of the piece \ndenoting it. A lookup is then performed, starting at this piece and eventually continued in its ascendant \npieces, in order to compute and re-turn the reply. Message sending can be extended to support messages \nsent to an object without speci-fying any viewpoint. This will be further discussed in \u00a7 7.2. Pseudo-variables \nAs in all object-oriented languages, a pseudo-variable self is bound, during a method s activa-tion, \nto the current receiver, i.e. in our case a split object. For the particular case where one wants to \nsend a message to self from the same viewpoint as the message currently being evaluated, a sec-ond pseudo-variable \nthis Viewpoint is also provided. During the evaluation of a message, thisViewpoint is bound to the name \nof the piece denoting the cur-rent viewpoint. Structure coherence controls At modification time, it \nis possible to check that the tree structure of the piece graph of a split object is preserved. 7.2 \nExtending message sending to ad-dress more viewpoints We have presented in previous subsection a basic \nmodel in which the user can deal with each of the viewpoints denoted by a piece in a split object. An \ninteresting issue is now to know whether there are only as many denoted viewpoints as there are pieces \nin a split object. We show in this section that there are more viewpoints than pieces. We give some clues \non how messages can be sent from all these viewpoints, including a particular one which can be thought \nof as the reunion of all the others. The split object Joe (see Fig. 4) is a collection of nine pieces \nand each of them denotes a viewpoint on Joe. Joe thus denotes at least nine viewpoints. We are able to \ndeal with any of these nine view-points by sending messages. We can for example ask Joe as a researcher \nwhich are the papers he has written by, sending a message to Joe, indicating the Researcher piece and \nthe selector papers. But how can we get this information if we do not know that the papers variable of \nJoe is stored in the Researcher piece? Shouldn t we be able to deal with Joe as a whole, the global viewpoint \non Joe from which any of the properties defined in Joe s pieces can be a priori accessed? We would like \nto answer yes to this question but there is no piece which denotes Joe as a whole: the global viewpoint \nis only implicitly denoted in Joe, and messages can not a priori be sent from it. If we allow pieces \nto have more than one parent, a naive solution to this problem would be to create a piece to denote Joe \nas a whole. This piece could be an empty one made the child of each of the leaves of the hierarchy in \norder to gain access to any of the properties defined for Joe. But this solution is only applicable in \na system providing for multiple delegation. However, a key remark is that Joe as a whole 132 can be \nconsidered as the composition of other viewpoints of Joe, denoted by pieces of different branches of \nthe sharing hierarchy. We can also con-sider that all possible combinations of such pieces denote interesting \nimplicit viewpoints on the en-tity denoted by a split object. For example, we could want to deal with \nthe teacher-and-researcher viewpoint on Joe (denoted by the combination of the Teacher and Researcher \npieces). But we also need to consider all possible compositions of view- points, since even a combination \nof some pieces of the same branch does not denote the same view-point as the one denoted by the more \nspecific of these pieces. Just consider for example the person-and-employee viewpoint (denoted by the \ncombina-tion of the Person and Employee pieces): it is not the same viewpoint as the employee one because \nasking the address of Joe as an employee is an un-ambiguous question whereas asking the address of Joe \nas a person-and-employee is ambiguous. When counting the viewpoints (implicitly or ex-plicitly) denoted \nin a split object, one must thus count as many as there are non empty subsets in the whole set of pieces. \nIn our example, Joe has 9 pieces and denotes 2 -1, that is 511, viewpoints on Joe. We conclude that creating \nan empty piece to explicitly denote each viewpoint implicitly de- noted is not a practically applicable \nsolution with respect to the memory consumption. Message sending can be extended to support messages \nalong any of the viewpoints denoted in a split object. Implicitly denoted viewpoints can be specified \nby a list of piece identifiers. It is also possible to systematically consider a message sent with no \nviewpoint specification as a message sent from the global viewpoint. Properties of a split object can \nthen be activated without knowing in which pieces they are stored and full support for encapsulation \nis thus provided. As there can be ambiguous messages, a lookup strategy should be chosen, which at least \ndetects ambiguities. It seems reasonable to expect also this strategy to not perform any lookup in pieces \nwhich are not related (either ascendant or descendant of) the pieces specified as a viewpoint. We have \npro-posed such a strategy in [3] which ensures an uni-formly defined semantics of messages sent to either \nexplicitly or implicitly denoted viewpoints.  8 Viewpoints in other systems Our primary goal in this \nwork was not to design a new model for viewpoints but rather to fully understand delegation and its semantics. \nThe notion of viewpoints nevertheless came naturally out when we thought about split representations. \nMany other works have been done around this notion in the object-oriented field of research. We discuss \nthem in a short comparison with our split objects. The notion of perspectives appears in Loops [4, 51. \nPerspectives, which are reified by independent objects with separate name spaces, are clustered into \nsome special composite objects and are inter-preted as different views on the same conceptual entity. \nEach perspective on an entity can be ac-cessed from any other perspective on the same en-tity. Ferber \ndeveloped a theory of viewpoints based on the coreferentiality [12, 131, where viewpoints of an entity \nare represented by coreferent objects. Translation operations and coreference rules be-tween coreferent \nobjects can be defined to ensure the coherence of the whole representation of the application domain. \nThe main differences between these two ap-proaches split objects lies in the fact that view-points on \na split object are not reified. Viewpoints are also clustered as in Loops, but they are not in-dependent. \nSome kind of coherence between view-points is also ensured by the sharing relation be-tween pieces. ROME \n[7, 81 emphasizes fragmentation of the definition of properties in a inheritance hierarchy (principle \nof multiple and evolving representation of objects). Viewpoints (denoted by classes) are also organized \nin a generalization/specialization hierarchy in which lookup can be restricted to some classes during \nthe evaluation of as-expression messages. In this respect, the functionalities of split objects with \nextended message sending are very similar to those of ROME. The viewpoint notion can also cover viewpoints \non the entire application domain, rather than solely viewpoints on individual entities. Indeed, in Tropes \n[al, 241 a viewpoint corresponds to a whole hierarchy of classes. Such hierarchies, the root of which \nare called concepts are used for classification purposes: an object is the instance of only one con-cept, \nwhich totally describes its attributes names, but can be classified within a viewpoint in the con-cept \ns subclasses, which specialize descriptions of instances in term of attribute values. Harrison and Ossher \nproposed a model of sub-jects [14], where a subject also specifies a whole hierarchy of classes. A subject \nmerely corresponds to the view of the world one can have from the context of a particular application. \nSubjects can be activated (eventually more than once) in order to associate some data and behaviour to \nany of the object identities of the system. An object identity can be associated to different data and \nbehaviour by different subject activations. Subjects can also be composed together, in which case a composi-tion \nrule then defines how they cooperate in re-spect with various topics including message send-ing, coherence \nof representations, object creations, etc. (see [23] for two possible composition rules). It is possible \nto compare split objects and ex-tended message sending with subjects, because for example viewpoints \ncan be composed in the two models. Semantics of viewpoints composition are not determined by the same \nfactors: this issue does not rely in our model on some composition rule but rather on the lookup strategy \nchosen for implicitly denoted viewpoints and the property sharing rela-tion imposed on the pieces of \na split object. Viewpoints can be considered in object-oriented application design techniques. Role modeling \n[2] emphasizes separation of concern between differ-ent aspects at possibly different level of details \nin the design of more or less independent applications. A role model is a behaviour description of two \nor more entities termed roles. Roles describe the re- quirements that objects have to satisfy in order \nto achieve the behaviour described by the role model. An important operation on role models is synthesis \nwhere some roles are sometimes projected together into a new aggregated role to obtain a new role model. \nConsidering that requirements of a role can be clustered into a piece, and that projection of roles \ncan then be thought of adding pieces to a split objects, our model may perhaps be a well- adapted tool \nfor the implementation of role models. Finally, Us [25] also uses delegation to express perspectives. \nDefinitions of objects in Us are done through layers: each layer contains exactly one piece (eventually \nan empty one) of each object. Ob-jects can inherit from each other by delegation, and so do layers in \na separate but orthogonal delega-tion hierarchy. A layer considered together with its chain of layer \nparents is a perspective from which messages can be sent to objects. The receiver-perspective symmetry \nprinciple governs evaluation of messages: layer parent links and object parent links have the same semantics. \nThe symmetry principle is quite well respected, but is weakened by the lookup algorithm which composes \nthe layer parent hierarchy first. This is the main difference with our model in which a split object \nmust first be considered before view-points (our viewpoints are also viewpoints on ob-jects rather than \nviewpoints on the whole system). There are nevertheless strong similarities between split objects and \nUs: the notion of piece, the use of delegation and the generalization/specialization relation between \nperspectives. 9 Conclusion and future works In this paper we have introduced a formalism in which we \ndefined the notions of name sharing, property sharing and value sharing. This allowed us to precisely \nqualify the kind of sharing achieved in class-based systems as variable name sharing and method property \nsharing, and the one achieved objects but also explained that a secure use of del- egation relies on \na correct semantics of delegation links. As a first sound semantics we highlighted the restriction property \nsharing to value sharing done in some existing systems, using delegation to achieve default life-time \nvalue sharing between independent objects. As a second semantically founded use of delegation, we proposed \na new model of split objects in which property sharing no more occurs between objects but rather be-tween \none object s viewpoints. We have finally briefly compared the split object model with other systems providing \nviewpoints. by delegation as property sharing. We have then shown how property sharing can be used to \nobtain per viewpoint representations of We discussed how split objects can be manipu-lated in a class-less \nlanguage, creation of new ob-jects is basically achieved by cloning. We how-ever believe that there exists \na corresponding class-based model: one can think of classes in which the declaration of variables and \nthe definition of meth- ods are partitioned along a set of piece names. In-deed, delegation occurs between \npieces within split objects and we did not put any requirements ei-ther on inheritance between split \nobjects, or on the organization of their world. We currently are in-vestigating what are the pros and \ncons of choosing between a class-based system or an object-centered one to implement split objects. Topics \npertinent to this choice are including: . the possible solutions for factorization of com- mon properties: \ncode reuse can be achieved by class-inheritance in class-based systems, but it remains a problem in prototype-based \nlan- guages [3, 91; . the way viewpoints are expressed in split ob-jects, whether piece names of an object \nare de-fined at the class-level or directly at the object-level ; . creation and dynamic modification \nof split ob-jects. Another important issue to be discussed is en-capsulation. As far as it is possible \nto put fron-tiers between split objects, some support for en-capsulation is provided by our model, but \nwe do not give details on how encapsulation can actually been achieved. Moreover there may be two levels \nof encapsulation: encapsulation of properties (the classical one ) and encapsulation of pieces. Acknowledgements \nThis work began in collaboration with Jacques Malenfant, we would like to thank him for his nu-merous \nand relevant comments. We also would like to thank Bernard Carre, Roland Ducournau and Gilles Vanwormhoudt \nfor many fruitful discussions on viewpoints and delegation. Thanks to Allister Cockburn for his help \nin finalizing this paper. References [l] 0. Agesen, L. Bak, C. Chambers, B.- W. Chang, U. Hijlzle, J. \nMaloney, R.B. Smith, D. Ungar, and M. Wolczko. The SELF 4.0 Pro- grammer s Reference Manual. Sun Microsys-tems \nInc, Stanford University, 1995. [2] E.P. Andersen and T. Reenskaug. System De-sign by Composing Structures \nof Interacting Objects. In Proceedings of the 6th European Conference on Object-Oriented Programming \n(ECOOP 92), Utrecht NL, Lecture Notes in Computer Science 707, pp. 133-152, 1992. [3] D. Bardou and C. \nDony. Propositions pour un nouveau modele d objets dans les langages &#38; prototypes. In Actes de LMO \n95 (Langages et Modiles ci Objets), Nancy, France, pp. 933 109, 1995. [4] D.G. Bobrow, M. Stefik. The \nLOOPS Man-ual. Memo KB-VLSI-81-13, Xerox Palo Alto Research Center, 1983. [5] D.G. Bobrow and M. Stefik. \nObject-Oriented Programming: Themes and Variations. In The AI Magazine (6)4, pp. 40-62, American Asso-ciation \nfor Artificial Intelligence, 1986. [6] L. Cardelli and P. Wegner. On Understanding Types, Data Abstraction, \nand Polymorphism. In ACM Computing Surveys (17)5, pp. 472- 522, 1985. [7] B. Car&#38;. The Point of \nView Notion for Mul-tiple Inheritance. In Proceedings of the OOP-SLA/ECOOP Conference, Ottawa, Canada, \nACM SIGPLAN Notices (25)10, pp. 312-321, 1990. [8] B. Car&#38;, L. Dekker and J.M. Geib Multiple and \nEvolutive Representation in the ROME Language. In Proceedings of TOOL%?, Paris, pp. 101-109, 1990. C. \nDony, J. Malenfant, and P. Cointe.  P Prototype-Based Languages: From a New Taxonomy to Constructive \nProposals and Their Validation. In Proceedings of the 7th Conference on Object-Oriented Programming Systems, \nLanguages and Applications (OOP-SLA 92), Vancouver, British Columbia, ACM SIGPLAN Notices (27)10, pp. \n201-217, 1992. [lo] R. Ducournau. YS/YAFOOL : Le langage a objets. Sema Group 1989. [ll] R. Ducournau, \nM. Habib, M. Huchard, M.- L. Mugnier, and A. Napoli. Le point sur l hdritage multiple. In Techniques \net sciences informatiques (14)3, pp. 309-345, 1995. J. Ferber and P. Volle. Using Coreference in W Object \nOriented Representations. In Proceed-ings of the 8th European Conference on Arti-ficial Intelligence, \npp. 238-240, 1988. [13] J. Ferber. Objets et agents: une e tude des structures de representation et de \ncommu-nications en Intelligence Artificielle. These d informatique, Universite Pierre et Marie Curie, \nParis 6, 1989. [14] W. Harrison and H. Ossher. Subject-Oriented Programming (A Critique of Pure Objects). \nIn Proceedings of the 8th Conference on Object-Oriented Programming Systems, Languages and Applications \n(OOPSLA 93), Washing-ton, DC, USA, ACM SIGPLAN Notices (28)10, pp. 411-428, 1993. [15] W.R. LaLonde, \nD. Thomas, and J.R. Pugh. An Exemplar Based Smalltalk. In Proceed-ings of the 1st Conference on Object-Oriented \nProgramming Systems, Languages and Appli- cations (OOPSLA 86), Portland, Orergon, ACM Sigplan Notices \n(21)11, pp. 322-330, 1986. [16] W.R. LaLonde. Designing Families of Data Types Using Exemplars. In ACM \nTOPLAS (ll)Z, pp. 212-248, 1989. [17] H. Lieberman. A preview of Actl. AI memo No 625, Massachusetts \nInstitute of Technol-ogy, 1981. [18] H. Lieberman. Using Prototypical Objects to Implement Shared Behavior \nin Object Ori-ented Systems. In Proceedings of the 1st Con-ference on Object-Oriented Programming Sys-tems, \nLanguages and Applications (OOPSLA 86), Portland, Oregon, ACM SIGPLAN No-tices, (21)11, pp. 214-223, \n1986. [19] J. Malenfant. On the Semantic Diversity of Delegation-Based Programming Languages. In Proceedings \nof 10th Conference on Object-Oriented Programming Systems, Languages and Applications (OOPSLA 95), Austin, \nTX, USA, ACM SIGPLAN Notices (30)10, pp. 215-230, 1995. [20] J. Malenfant. Split Objects: Taming Value \nSharing in Object-Oriented Languages. Rapport de recherche IRO-968, Departe-ment d Informatique et de \nRecherche Opera-tionnelle, Universite de Montreal, 1995. [21] 0. Mariiio. TROPES. These d informatique, \nUniversitk Joseph Fourier, Grenoble 1, 1993. [22] B.A. Myers, D. Giuse, R.B. Dannenberg, B. Vander Zanden, \nD. Kosbie, E. Pervin, A. Mickish and P. Marchal. Garnet: Com-prehensive Support for Graphical, Highly-Interactive \nUser Interfaces. In IEEE Com-puter, 23(11), pp. 71-85, 1990. [23] H. Ossher, M. Kaplan, W. Harrison, \nA. Katz and V. Kruskal. Subject-Oriented Composi-tion Rules. In Proceedings of the 10th Con-ference on \nObject-Oriented Programming Sys-tems, Languages and Applications (OOPSLA 95), Austin, TX, USA, ACM SIGPLAN \nNo-tices (30)10, pp. 235-250, 1995. [24] F. Rechenmann, 0. Mario and P. Uvi-etta. Multiples Perspectives \nand Classifica-tion mechanism in Object Representation. In Proceedings of the 10th European Conference \non Artificial Intelligence, Stockholm, pp. 425-430, 1990. [25] R.B. Smith and D. Ungar. A Simple and \nUni-fying Approach to Subjective Objects. To ap-pear in TAPOS special issue on Subjectivity in Object-Oriented \nSystems (2)3, 1996. [26] L.A. Stein, H. Lieberman, and D. Ungar. A Shared View of Sharing: The Treaty \nof Or-lando. In Object-Oriented Concepts, Appli-cations and Databases, W. Kim and F. Lo-chovosky eds., \nAddison-Wesley, 1988. [27] P. Steyaert. and W. De Meuter. A Marriage of Class-and Object-Based Inheritance \nWithout Unwanted Children. In Proceedings of the 9th European Conference on Object-Oriented Pro-gramming \n(ECOOP 95), Aarhus, Denmark, W. Olthof ed., LNCS 952, Springer-Verlag, pp. 127-144, 1995. [28] A. Taivalsaari. \nA Critical View of Inheritance and Reusability in Object-Oriented Program-ming. These d informatique, \nUniversite de Jyvaskyla, No 23, Finlande, 1993. [29] D. Ungar and R.B. Smith. SELF: The Power of Simplicity. \nIn Proceedings of 2nd Con-ference on Object-Oriented Programming Sys-tems, Languages and Applications \n(OOPSLA 87), Orlando, FL, ACM SIGPLAN Notices (22)12, pp. 227-242, 1987. [30] P. Wegner. Dimensions \nof Object-Oriented Language Design. In Proceedings of 2nd Con-ference on Object-Oriented Programming \nSys-tems, Languages and Applications (OOPSLA 87), Orlando, FL, ACM SIGPLAN Notices (22)12, pp. 168-182, \n1987.  \n\t\t\t", "proc_id": "236337", "abstract": "This paper's primary aim is to improve the understanding of the delegation mechanism as defined in [18]. We propose a new characterization of delegation based on the notions of name sharing, property sharing and value sharing. It allows us (1) to clearly differentiate delegation from class-inheritance in particular and more generally from other inheritance mechanisms and (2) to explain how a founded use of delegation relies on a correct semantics of variable property sharing between objects connected by a delegation link. We then describe a model of split objects which is proposed as an example of a disciplined and semantically founded use of delegation, where property sharing expresses viewpoints within objects.", "authors": [{"name": "Daniel Bardou", "author_profile_id": "81100325392", "affiliation": "Laboratoire d'Informatique, de Robotique et de Micro-&#233;lectronique de Montpellier, 161, rue Ada - 34392 Montpellier Cedex 5 - France", "person_id": "P58514", "email_address": "", "orcid_id": ""}, {"name": "Christophe Dony", "author_profile_id": "81100431943", "affiliation": "Laboratoire d'Informatique, de Robotique et de Micro-&#233;lectronique de Montpellier, 161, rue Ada - 34392 Montpellier Cedex 5 - France", "person_id": "PP39075729", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236347", "year": "1996", "article_id": "236347", "conference": "OOPSLA", "title": "Split objects: a disciplined use of delegation within objects", "url": "http://dl.acm.org/citation.cfm?id=236347"}