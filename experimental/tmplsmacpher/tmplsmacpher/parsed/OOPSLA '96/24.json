{"article_publication_date": "10-01-1996", "fulltext": "\n Using Role Components to Implement Collaboration-Based Designs Michael VanHilst and David Notkin Department \nof Computer Science and Engineering University of Washington PO Box 352350 Seattle, Washington 98195-2350 \nUSA {vanhilst,notkin}@cs.washington.edu Abstract In this paper we present a method of code imple- mentation \nthat works in conjunction with collab- oration and responsibility based analysis model- ing techniques \nto achieve better code reuse and resilience to change. Our approach maintains a closer mapping from responsibilities \nin the analy- sis model to entities in the implementation. In so doing, it leverages the features of \nflexible design and design reuse found in collaboration-based de- sign models to provide similar adaptability \nand reuse in the implementation. Our approach re- quires no special development tools and uses only standard \nfeatures available in the C++ language. In an earlier paper we described the basic mech- anisms used \nby our approach and discussed its advantages in comparison to the framework ap- proach. In this paper \nwe show how our approach combines code and design reuse, describing spe- cific techniques that can be \nused in the develop- ment of larger applications. 1 Introduction The notion of collaborations is well \naccepted in object-oriented design. In collaborations, groups of objects cooperate to perform a task \nor to main-tain an invariant. In the collaboration view, a role is the part of an object that fulfills \nits responsibil- ities in the collaboration. In most design method-ologies, roles are an ephemeral concept, \nexisting Permission to make digital/hard copy of part or all of this work for personal Or C!~SrOom Use \nis granted without fee provided that copies are not made or distributed for profit or commercial advantage, \nthe copyright notice, the title of the publication and its date appear, that and notice is given COPYing \niS by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute \nto lists, requires prior specific permission and/or a fee. OOPSLA 96 CA, USA 0 1996 ACM O-89791 -788-x/96/001 \n0...$3.50 briefly, if at all, between the description of collab- orations and the specification of classes. \nThey do not generally exist as identifiable components of the implementation. In our approach to object-oriented \nimplementa-tion, roles are an important key to code reuse and adaptation. Compared to classes, roles \nencapsu-late fewer decisions and are thus more stable with respect to evolution. We provide a method \nto im-plement roles as source code entities-specifically, class templates defined in a stylized way-and \ncompose them into classes using separate spec-ification statements-classes defined in terms of instantiations \nof those class templates. Our ap-proach improves code reuse and adaptability, and overcomes a number \nof other limitations found in more traditional approaches to implementation. In this paper we demonstrate \nhow a design that originates with a collaboration-based methodol-ogy can be implemented directly using \nrole com-ponents. In the second section we describe collaborations and roles more fully and discuss their \nsignificance in object-oriented design. In the third section, we present the basic details of our method \nof imple- menting roles as source code components.r In the fourth section we describe the design of a \ncon-tainer recycling machine similar to the one pre-sented in Jacobson, et al. [ll]. In the fifth section, \nwe show how to implement that design using role components. The sixth section discusses some of the differences \nbetween our implementation and A lengthier discussion of the details is available in an earlier paper, \nin which we compared our approach to the use of frameworks [17]. the implementation presented by Jacobson, \net al., with respect to possible changes. We also describe some of our experiences with a much larger \nap-plication, a telescope imaging system. The sev- enth section contains a discussion of related work, \nwhile the last section contains a concluding sum- mary.  2 Collaborations, Roles, and Collaboration-based \nDesigns A collaboration is a set of objects together with obligations on and relationships among those \nob-jects. Collaborations are often used to model se-quences of message passing and state changes de-rived \nfrom use-case-like scenarios in the require-ments analysis. In so doing, collaborations offer a view \nthat complements the static view of class and inheritance structures. Collaborations are of-ten informal \n[2, 3, 11, 201, but they have also been formalized in contracts [lo], given a nota-tion [14, 151, and \nassociated with framework im-plementations [7, 131. A collaboration can address only the parts of objects \nneeded to participate in a particular task, concern, or pattern. In this view of collabora-tions, a role \nspecifies a part of a single object that participates in a particular collaboration. Collab-orations \nmay be seen, then, not so much as collec-tions of objects, but as collections of roles.2 An object participates \nin a collaboration by having a role in that collaboration. An object that participates in several collab-orations \nmay have several roles, one from each of the collaborations. The relationship between objects and roles \nhas a number of significant fea-tures. Just as a collaboration may be viewed as a collection of roles, \nan object, or its class, may also be viewed as a collection of roles. So, a role is a unit of design \ncommon to both views. Any object that has the proper role may play that role in a collaboration. Thus \nthe same spec- Some methodologies make a distinction between col-laborations of objects and collaborations \nof roles. Where that distinction might be significant, we will always mean the latter. ification of a \ncollaboration may apply to different sets of objects, provided the corresponding ob-jects play the same \nroles. In this generality we can see the value of roles in reuse. If we can reuse a collaboration, we \ncan reuse its roles, even if the classes of the objects that contain them are differ-ent. Viewed from \nan evolutionary standpoint, if we wish to replace an existing object in a collab-oration, the new object \nmay belong to a different class, but it must still play the same role. Con-versely, if we change or replace \na collaboration, the roles of its participant objects in other collab-orations do not change. A few approaches \nto object-oriented develop-ment already use collaborations and role-like de-compositions to achieve better \ndesign reuse [7,13]. Our strategy is to extend this kind of reuse to code by implementing the roles in \nthe design directly as encapsulated source code components. Classes are then literally compositions of \nrole compo-nents. Because we want to implement roles directly, we need a design methodology in which \nroles are still identifiable late in the design process. We have found this to be possible with a number \nof ex-isting collaboration-based design methodologies, including use-cases [ 111, responsibilities [19], \nand role models [13]. 3 A Method for Implementing Roles To implement the roles from a collaboration-based \ndesign, we need a mechanism that gives role components the same properties as roles in the design. In \na design, when a role is added to an existing class, it refines or extends the inter-face of that class. \nThus inheritance is a logical glue for composing roles into classes. But roles can be composed with a \nvariety of other roles in a variety of classes, so the inheritance in the im-plementation must be delayed \nuntil composition takes place. Similarly, since roles in the design place no restrictions on the types \nof objects with which they collaborate other than that they play the appropriate role, bindings to types \nfor all col- laborator references must also be delayed. We have found that we can satisfy all of these \nproperties using parameterized types in general and C-l-+ class templates in particular. There are two \nkey language structures that we use to explicitly define and implement roles and then to compose those \nroles into classes. For each role, we define a separate class tem-plate that is parameterized by each \nof the col-laborators. For example, a father s role in a two parent household might be defined in part \nas: template (class ChildType, class MotherType, class SuperType> class FatherRole : public SuperType \nC ChildType *child; MotherType *mother The ChildType and MotherType parameters in-dicate that the father \nrole will collaborate with a child role and a mother role that are played by objects of yet-unknown types. \nThe SuperType parameter is used in every role definition in our approach, since every role is part of \nsome yet-unknown class. A husband s role in a marriage collaboration might be similarly defined, in this \ncase collaborating only with a wife role, as shown here: template <class WifeType,class SuperType> class \nHusbandRole : public SuperType ( WifeType *wife; We compose roles into classes by instantiating templates \nlike these, binding the template param-eters to the specific classes that play the roles. An instantiation \nof the FatherRole might, for exam-ple, appear as: class Father2Class : public FatherRole <ChildClass,MotherClass,FatherlClass><>; \nThis says that the Father2Class includes the Fa-therRole. It also says that specific classes, Child-Class \nand MotherClass, play the child and mother roles in the collaboration with the FatherRole. FatherlClass \nis the class that we extended to get Father2Class. The FatherlClass might be defined in terms of HusbandRole \nand its instantiation: class FatherlClass : public HusbandRole <MotherClass,emptyClass> 0; This statement \ndefines FatherlClass as a collab-orator with MotherClass playing the wife role in a marriage collaboration. \nThe emptyclass (es-sentially a default base class) parameter simply indicates that the FatherlClass is \na base class. This somewhat abstract description of our im-plementation method will be clarified by example \nin Sections 5 and 6; more details also appear else- where [17]. By writing different template instantiation+ \nwe can define different combinations of roles without modifying the role definitions themselves. This \nallows us to handle various orders of inheritance, to include the same role twice, and to add addi-tional \nroles before, after, or in between the roles currently defined. Section 6 discusses the ways in which \nthese kinds of flexibility support our strat-egy for application development and evolution.  4 The Recycling \nMachine De-sign To demonstrate our implementation approach, we begin with a modified version of Jacobson, \net al.? collaboration-based design for a container recy-cling machine [ll]. This example defines a vend-ing \nmachine that takes empty beverage containers and issues a receipt for the deposit value of the containers. \nThe front of the machine has three slots (one each for cans, bottles, and crates), a button to request \na receipt, a slot to issue a re-ceipt, and a lighted panel marked NOT VALID. The interaction between \nthe recycling machine and a customer combines two separate activities, Adding Item and Print Receipt. \nIn the Adding Item scenario, when a customer inserts an empty beverage container into one of the slots, \na cus-tomer total and a daily total for that item type are both incremented by the system. In the Print \nReceipt scenario, when the customer presses the receipt button, the customer total is calculated and \nthe following information for each item type is printed on a receipt: name, number deposited, unit deposit \nvalue, and total deposit value. Fi-nally the sum of the deposit values is printed, and the receipt is \nissued through the slot. The cus-tomer totals are then cleared, and the machine is ready for a new customer. \n An analysis of the recycling machine s detailed requirements yields two extensions to the basic Adding \nItem scenario, Validate Item and Item Stuck. These extensions provide additional or al-ternative sequences \nof events to the original base scenario. In the Validate Item scenario, when an item is inserted, it \nis measured by the system. The measurements are used to determine if the con-tainer should be accepted \nfor a deposit refund. If it is not accepted, no totals are incremented, and the NOT VALID sign is highlighted. \nIn the Item Stuck scenario, before incrementing any counts, the system checks to see if the item has \nbecome stuck. If the item is stuck, the system sounds an alarm and no totals are incremented. As in other \ncollaboration-based approaches, ob-jects are identified at this point in the design process so we can \nassign roles to system parts. We identified the following objects needed to sup-port the recycling machine \ns scenarios: Customer-Panel, DepositReceiver, DepositItem, ReceiptBa-sis, and InsertedItem. Figure 1 \nshows a diagram of the object structure. DepositItem is the ab-straction for each item type. Its responsibilities \nare to validate items of its type and to main-tain a daily total. It must also know its name and deposit \nvalue. ReceiptBasis is the abstrac-tion for a single customer session. Its responsibil-ities are to keep \nthe list of customer totals by item type and to print the appropriate information on a customer receipt. \nTo fulfill its responsibilities, the ReceiptBasis maintains a list of InsertedItem objects. Each InsertedItem \nkeeps the customer s total for a specific container type and has a refer- ence to that type s DepositItem \nobject. The Cus-tomerPane1 interfaces to the devices and displays of the front panel, while the DepositReceiver \nis the main control object for the system s interac-tions. Once the objects are known, the scenarios \ncan be restated as collaborations among participant objects. For example, the Adding Item scenario can \nbe restated as: When a customer inserts an empty beverage container into a slot, the Cus-tomerPane1 signals \nthe DepositReceiver with the slot type. The DepositReceiver identifies the cor-responding DepositItem \nand signals the Receipt-Basis. The ReceiptBasis adds an InsertedItem to its list if one of that type \ndoes not already exist. The ReceiptBasis tells the InsertedItem to incre-ment the customer s total. The \nDepositReceiver then tells the DepositItem to increment the daily total. The interaction diagram for \nthis collabora-tion is shown in Fig. 2. 5 The Recycling Machine Role Implement at ion Our strategy for \nimplementing applications is to create a source code component for each role in the design. The goal \nis to make it easier to reuse code among related applications, and to support a wider range of future \nadaptations with less im- pact on the existing implementation code. In this section we describe the process \nof implementing the recycling machine design using the method described briefly in Section 3. Our intent \nis to illuminate where this process and the resulting implementation differ from more traditional ap-proaches. \nIn the collaboration-based design from the pre-vious section, identifying roles is straightforward. The \ninteraction diagram used to describe the Adding Item collaboration shows the operations that each object \nneeds to fulfill its role in that col-laboration. We simply collect the operations for a particular object \nand determine which attributes those operations use. CRC or class cards [2, 201 I Alarm \\ =;ecez$2q~LCustomerPanel \n c ReceiptBasis InsertedItem Figure 1: Block diagram of objects in the recycling machine design. (Arrows \nindicate calls relations.) CustomerPanel DepositReceiver Receipt Basis InsertedItem DepositItem addItem \naddItem -I tddItem( *item) getItem _ init(*item) _ incr() incr() 1 -1 Figure 2: Interaction diagram \nfor Adding Item collaboration. CustomerPanel DepositReceiver ReceiptBasis InsertedItem DepositItem Linked \nList list *next setNext(*next) 1 getNext 1 Adding item[N], *receipt number, *item total Item addItem \naddItem addItem(*item) getItem incr() init(*item) incr() Validate invalid0 l,w,h Item addItem(s,l,w,h) \naddItem(s,l,w,h) accept(l,w,h) Item Stuck isStuck addItem Figure 3: Roles/responsibilities matrix for \npart of the recycling machine. (Names followed by paren-theses are method names. Names in italics are \nattribute variable names.) class DepositReceiverlClass : public DRAddingItemRole<ReceiptBasisClass,DepositI~emClass,emp~yClass~ \nI); class DepositReceiver2Class : public DRItemStuckRole<CustomerPanelClass,Ala~Class,Deposi~ReceiverlClass~ \n0; class DepositReceiver3Class : public DRValidateItemRole<CustomerPanelClass,Deposi~I~emClass,Deposi~Receiver2Class> \n0; typedef DepositReceiver3Class DepositReceiverClass; Figure 4: Definition statements to compose the \nDepositReceiver class. can be used in a similar manner, if the responsi- bilities are annotated with \nthe names of the col-laborations to which they belong. But we need more information to construct our \napplication, especially when trying to compose several roles to form a single class. First, the same \noperation, or attribute, may be defined for more than one role. If so, we must determine if the duplicate \noperation is to be shared, repeated, or overridden. Depending on the results of this analysis, some roles \nmay need to be subdivided. Second, where one collaboration extends another, we need to identify the calls \nbetween roles within the same class. These may be implied, but not shown, in interaction diagrams. Third, \nthe use of data structures may also be implied, but not shown. The ReceiptBasis class in the recycling \nmachine example uses a linked list, in which In-sertedItems might function as nodes. Finally, we need \nto determine the order in which to compose the roles. To aid in the process of answering these questions, \nwe have found the roles/responsibil-ities matrix, adapted from business manage-ment [6], to be a useful \ntool. Figure 3 shows a roles/responsibilities matrix for part of the recy-cling machine involving the \nAdding Item, Item Stuck, and Validate Item collaborations.3 In the matrix, rows represent collaborations, \nwhile columns represent classes. The internal cells of the matrix represent roles. In the column for \nthe CustomerPanel class, there are two distinct addItem methods. In the 3To save space, the Ahrm and \nPrinter columns have been left out. design, the addItem method from the Validate Item extension replaced \nthe one from the Adding Item collaboration. We will implement the three roles with the methods that are \nshown in the ma-trix. In the composition of the CustomerPanel class, the role from Validate Item must \nbe in a more derived position than the role from Adding Item so that methods in the extension can over-ride \nthose in the base. The column for the DepositReceiver class has three addItem methods, each having a \ndiffer-ent responsibility. The method from Adding Item adds an item to the receipt basis and increments \nthe counts. The method from Validate Item checks the container s dimensions and calls the original addItem \nmethod only if they are valid. The method from Item Stuck checks for a stuck container and calls the \noriginal only if no con-tainer is stuck. The implementations of the latter two include a call to the \noriginal encoded as a call to the superclass: SuperType::addItem(s). Thus their roles must be more derived \nthan the Adding Item role. From the requirements we determine that the Validate Item role s addItem method \nmust be called first, thus it must be the most de-rived. By inserting the Stuck Item role between the \nValidate Item role and the Adding Item role, when Validate Item s addItem method calls Su- perType::addItem(s), \nStuck Item s addItem will be called next. With the composition ordered in this way, the resulting class \nsupports the behavior intended. The class definition statements to com-pose these roles into a class \nare shown in Fig. 4. In the composition for the DepositReceiver class, Item Stuck may be thought of as \ninter-ICustomerPanel DepositReceiver Print *receipt Receipt printReceipt printReceipt 1 getItem getValue \nI-! Figure 5: The roles/responsibilities matrix row for the Print Receipt collaboration. CPAddingItem \nDRAddingItem CPItemStuck DRItemStuck ~~~,~I CPValidateItem DRValidateItem CPPrintReceipt DRPrintReceipt \n CustomerPanel DepositReceiver ReceiptBasis InsertedItem DepositItem Figure 6: Order of inheritance for \nrole composition by class (more derived toward bottom) cepting the addItem call from Validate Item to \nthe InsertedItem class inheritance hierarchy, since Adding Item to add additional behavior, or, as the \nAdding Item role does not access anything in this case, additional conditions on the existing from the \nLinked List role. As we explain else-behavior. This is an example of what we call spe-where [17], we \noften treat data structures as col-cialization by inserting ancestors [17]. It may be laborations and \nmake the nodes derived classes of helpful to model the flow of control among collab-the data. This treatment \ndiffers from the tradi-orations as well as within collaborations to ana-tional approach to reusable data \nstructures, where lyze the complete behavior. The control flow can the common data structure parts are \nbase classes be modeled informally by drawing on a copy of and nodes have pointers to data. the roles/responsibilities \nmatrix, or more formally Figure 5 shows part of the roles/responsibilities using state-transition diagrams \nor petri nets, as matrix for the Print Receipt collaboration. Com- shown by Alice and Warboys [l]. pared \nwith the row from the earlier matrix for the Adding Item collaboration, the two collabo-The Adding Item \nrole in the ReceiptBasis class rations share many attributes in common. In this uses a linked list. We \nseparated the Linked List situation, we will want to split one or both col-collaboration from that of \nAdding Item in order laborations into two parts. The common part willto reuse an existing linked list \nimplementation. contain most of the attributes, while the special-Because Adding Item s role in the ReceiptBasis \nized part contains mostly methods. This issue isclass uses the list, the Linked List role must be the \nsame as that of abstract use cases describedless derived in the ReceiptBasis inheritance hier-in Jacobson, \net al. [ll]. archy. When ReceiptBasis calls getNext on the list, it wants an object of a type that includes \nthe The order of inheritance for role composition InsertedItem class s Adding Item role. The re-in the \nfive classes discussed is shown in Fig. 6. turned value required an unsafe type cast in the From this \ngraphical representation, we can gener-implementation in Jacobson, et al. [ll]. We avoid ate the type \ndefinition statements to compose the the type cast by making the Linked List s role in roles and form \nthe application s classes. A small the InsertedItem class more derived than Adding amount of additional \ncode is needed to instantiate Item s role. This ordering is not a problem for objects and initialize \nthe application.  Discussion Choosing a structure that supports anticipated change is one of the challenges \nof object-oriented design. Simple subclassing is limited in the adap-tations it can support. Often the \ndesigner must choose between evolutionary paths, supporting one set of changes while foregoing the opportu-nity \nto make others. Suppose we designed our recycling machine with base classes to measure and count containers \nas in the original and sub-classes to print the receipt. If some stores wanted machines that gave change \ninstead of printing a receipt, we could replace the receipt printing sub-classes while reusing the original \nbase. But sup-pose, instead, that for some states we needed to change the validation criteria from measur-ing \ncans to reading their bar codes. How much code could we reuse then? With traditional ap-proaches, we \nwould have to copy and edit the re-ceipt printing subclasses for use with the bar code reading base classes. \nWith our approach, in either case we just recompile with the new roles specified in the appropriate composition \nstatements. If we later want to upgrade the receipt format of the machines-say, to include a machine \nreadable bar code of its own-there will only be one version of receipt printing code to upgrade. One \nof the strategies for supporting change is to encapsulate the behaviors of change in sepa-rate objects. \nBut objects created to encapsulate change distort designs based on is-a and has-a re-lationships. The \nrecycling machine design in Ja-cobson, et al., had an aEarmist object intended to encapsulate the Item \nStuck extension to the DepositReceiver class. Even then, the ideal of completely encapsulating change \ncould not be re-alized: Unfortunately, we cannot accomplish this with today s programming languages [ll, \np.2501. Code in the DepositReceiver class had to be mod- ified to support the Alarmist s extension. Our \nap-proach doesn t have the same problem because we don t encapsulate change in separate objects. We encapsulate \nit in roles that can become an inte-gral part of the original object s class. The other parts of our \nDepositReceiver class did not have to be modified for the Item Stuck extension. What about support for \nstructural change? In the original design, the Item Stuck role of the De-positReceiver class sends an \nisStuck message to the CustomerPanel object to find out if any con-tainers are stuck. What if a new design \nuses a ContainerFeed object for that function? In our approach, binding to collaborator types is de-layed. \nIf the DepositReceiver s Item Stuck role used its own reference to the CustomerPanel ob-ject, we could \nchange the binding for the type of that collaborator to the ContainerFeed object s class and initialize \nthe reference to point at the ContainerFeed object. If the DepositReceiver s Item Stuck role was using \nthe reference to Cus-tomerPane1 from its superclass, we could create a new role with its own reference, \nand insert it between the Item Stuck role and its immediate superclass.4 In our designs, we almost always \nuse separate roles for external references. Not only does this approach defer the decision about which \nroles should share a common reference, but it gives us the opportunity to choose among roles that satisfy \nan obligation locally, roles that ref-erence other objects in the same address space, and roles that \nsatisfy obligations by accessing a remote server. All of these architectures can be supported without \nchanging the implementations of our roles. In subdividing roles, as in the above example, we use the \nterm role more loosely: some of the resulting components might more appropriately be called role fragments. \nThe distinction is not significant to how they are handled in the imple-mentation. (In another paper \nwe discuss the value for maintenance and reuse of capturing decisions in separate submodules similar \nto those discussed here [16].) Of course, we can t support every change. By mapping units of design directly \ninto units of im- plementation, our goal is to make it proportion-ally easy to change the implementation \nas it is to change the design. Changes that are difficult to make in the design will probably be difficult \nto 4 We left the location of the CustomerPanel reference pointer out of the roles/responsibilities matrix \nto simplify the earlier discussion. make in the implementation, as well. With our approach, the runtime \ncost of config- urability is low. Because we use static inheritance to compose the roles, there are no \nextra levels of indirection. Composition occurs at compile time, so we can also inline method calls to \nremove the function call overhead commonly associated with decomposing operations into smaller steps. \nWith so low overhead, our approach encourages a more aggressive strategy toward decomposing applica- \ntions into smaller pieces that encapsulate fewer decisions. This bias towards decomposition is, in turn, \nreflected in our designs. To test the scalability of our approach to large applications, we have undertaken \nthe develop-ment of an image display and manipulation ap-plication. Our intention is to duplicate an \nas-tronomy application that was originally written in 30,000 lines of C code. This display program poses \na number of challenges. One of its chal-lenges is a complicated structure involving many-to-many relationships \namong viewports, images, and coordinate systems. Another is our desire to provide different versions \nof the program for use in many different contexts. We hope to reuse com-ponent code in similar and dissimilar \nobjects to support a variety of configurations tailored to spe-cific uses. We are already using the code \nwritten thus far to explore and experiment with different architectures as we try to address the structural \nissues of the design. As we had expected, the order of evolution of the image display application does \nnot at all fol- low the order of inheritance in the class compo-sitions. Added features tend to go in \nthe mid-dle of the class hierarchy where they can interact with existing features in a natural order, \nwhile the more derived roles tend to be concerned with event detection and object initialization. Yet, \nat each step in the evolution we have a workable ap-plication By being able to reason about the flow \nof con-trol within and among objects, we are able to structure the flow of control implicitly through \nthe specifications of composition rather than us-ing an encapsulated central dispatcher. This ap-proach \nlets us use local decision making at run-time while still maintaining a global overview to determine \nthe order of responding to events such as mouse movements and reconfigured windows. Our inheritance hierarchies \ntend to be much deeper than those found in other object-oriented applications. Each of the major classes \nis com-posed of 10 to 20 roles, and we are still adding roles. We have found graphical representations \nof class compositions and role dependencies to be in- dispensable in managing our designs. By inspect- \ning the role hierarchies, we can easily identify common superclasses. In some cases, by chang-ing the \norder of role composition, we were able to reduce the number of classes needed by the appli-cation. The \nrepeated use of roles within a class is common, especially the generic handle roles used for inter-object \nreferencing. We have had some difficulties with template in-stantiation, especially when trying to support \nsep-arate compilation of source code files. We have also had some difficulty with debugger support for \ntemplate generated names. Our templates can get nested very deeply. Many of these problems appear to \nbe compiler-specific, so a general solu-tion may not yet be available. We suspect that similar problems \nare encountered by other users of templates. The fact that some compilers seem to work much better than \nothers gives us hope some of the issues will be ironed out. We are often asked why we don t use multi-ple \ninheritance for composing roles. Roles can be incomplete types that extend other roles and must be able \nto interact within the composition-something not permitted among multiply inher-ited classes in C++. \nBecause the same role can appear twice in the same class, we use type names for intermediate levels of \ncomposition to disambiguate references to names in the interface, a problem even for CLOS-style multiple \ninher-itance. Finally, we don t need multiple inheri-tance.  Related Work The OOram methodology has \nmany similarities with the work presented here, but differs in em-phasis [13]. Although both approaches \nstart with roles and collaborations, the OOram approach combines or synthesizes roles in the design pro-cess \nto improve design comprehension, while our approach subdivides roles in the design process to improve \ncode maintainability and reuse. Code reuse in the OOram methodology is based on ob-ject libraries and \nframeworks of base classes. (A comparison of our approach with frameworks is the focus of our earlier \nwork [17].) The goal of our work is similar to that of subject-oriented programming in that both ap-proaches \naddress the issue of composing differ-ent views on a common set of objects [9]. In subject-oriented programming, \nseparate applica-tions are merged by combining common objects. The mechanism of Harrison and Ossher requires \na runtime dispatcher and special compiler tools. By comparison, ours is a lightweight approach in-tended \nfor building a single application structure. The decorator pattern from the book by Gamma, et al., is \nalso used to add responsibilities to an object [7]. The decorator has an advantage of being able to support \ndynamic change. But an object s decorators must conform to a fixed in-terface by subclassing from a common \nbase class. Calls to that base class must be explicitly encoded in the object being decorated. Compared \nto our approach, the decorator mechanism places more restrictions on the location and type of extension \nthat can be applied and does not address the issue of unanticipated change. The notion of role has a \ncounterpart in object- oriented databases [8, 181. The issue arises, for ex-ample, when an employee object \nmay play the role of trainee at one time and manager at another, or possibly even the same, time. While \nboth uses of role address objects playing roles in different con-texts, the database usage is more concrete. \nIn our usage, if an object satisfies the requirements of a role, it can play that role. In the object-oriented \ndatabase sense, an object must have a role of that name. For database roles, the main issue is the ability \nof objects to dynamically change roles. Bracha and Cooke demonstrated delayed inher-itance using type \nparameters, calling the resulting components mixins [5]. The term roughly cor-responds to the use of \nmultiply inherited classes in CLOS. Unfortunately the meaning of the term mixin is often confused with \nthe different seman-tics of multiply inherited base classes in C+ t. Bracha s dissertation focused on \nsemantics and language issues and did not present mixins in the context of a design methodology [4]. \nThe C++ Standard Template Library of Stepanov and Musser uses templates exten-sively [12]. But STL uses \ntemplates for genericity, not composition, and it does not use inheritance. Roles can use STL data structures, \nbut roles can also be used to implement data structures. For instance, we have produced role-based implemen-tations \nof the list and binary tree data structures and shown how the two could be composed to form a multiply \nthreaded list with a binary tree find0 operation. That combination would not be possible with the equivalent \ndata structures in the STL. 8 Conclusion We have demonstrated a new approach for im-plementing object-oriented \nprograms using source code role components. We showed how to derive the roles from a collaboration-based \ndesign and how to compose the role implementations at com-pile time to form the classes of the application. \nOur approach supports more flexibility for change and adaptive reuse than traditional approaches to implementation, \nwhile requiring fewer deviations in the design and less runtime overhead than com-mon approaches for \nsupporting change. Our ap-proach requires no special tools and uses only the features associated with \nclass templates in Q-t. While all of our experience to date has been with small applications, recent \nexperience working on a larger application has been very promising. References I. Jacobson, M. Christenson, \nP. Jonsson, and WI PI PI  PI PI PI  PI VI PI PI DOI F.S. Aliee and B.C. Warboys. Roles represent \npatterns. In Proceedings of the Workshop on Pattern Languages of Object-Oriented Pro-grams at ECOOP 95, \n1995. K. Beck and W. Cunningham. A labora-tory for teaching object-oriented thinking. In Proceedings \nof the 1989 ACM Conference on Object-Oriented Programming Systems, Lan-guages and Applications, pages \n1-6, 1989. G. Booth. Object Oriented Design with Ap-plications. Benjamin/Cummings, 1991. G. Bracha. The \nprogramming language JIG-SAW: mixins, modularity and inheritance. PhD thesis, University of Utah, 1992. \nG. Bracha and W. Cooke. Mixin-based in-heritance. In Proceedings of the 1990 ACM Conference on Object-Oriented \nProgramming Systems, Languages and Applications, pages 303-311,199o. A.M. Burkett. Clarifying roles and \nresponsi-bilities. CMA: the Management Accounting Magazine, 69(2):26-28, March 1995. E. Gamma, R. Helm, \nR. Johnson, and  J. Vlissides. Design Patterns: Elements of Reusable Object-Oriented Software. Addison-Wesley, \n1994. G. Gottlob, M. Schrefl, and B. Rock. Extend-ing object-oriented systems with roles. ACM Transactions \non Information Systems, 14(3), July 1996. W. Harrison and H. Ossher. Subject-oriented programming (a \ncritique of pure objects). In Proceedings of the 1993 ACM Conference on Object-Oriented Programming Systems, \nLanguages and Applications, pages 411-428, 1993. R. Helm, I.M. Holland, and D. Gangopad-hyay. Contracts: \nSpecifying behavioral com-positions in object-oriented systems. In Proceedings of the 1990 ACM Conference \non Object-Oriented Programming Systems, Languages and Applications, pages 169-180, 1990. G. overgaard. \nObject-Oriented Software En-gineering: A Use Case Driven Approach. Addison-Wesley, 2nd edition, 1992. \nD.R. Musser and A.A. Stepanov. Algorithm-WI oriented generic libraries. Software Practice and Experience, \n24(7):623-642, July 1994. T. Reenskaug. Working With Objects: The P31 OOram Software Engineering Method. \nMan-ning, 1995. T. Reenskaug, E.P. Anderson, A.J. Berre, P41 A. Hurlen, A. Landmark, O.A. Lehne, E. Nordhagen, \nE. Ness-Ulseth, G. Oftedal, A.L. Skaar, and P. Stenslet. OORASS: Seam-less support for the creation and \nmainte-nance of object-oriented systems. Journal of Object-Oriented Programming, 5(6):27-41, October \n1992. D. Riehle. Describing and composing pat-  WI terns using role diagrams. In H. Steffen, edi-tor, \nWOON 96, Conference Proceedings, St. Petersburg, Russia, June 1996. M. VanHilst and D. Notkin. DecouplingWI \nchange from design. In Proceedings of SIG-SOFT 96 Foundations of Software Engineer-ing. ACM Press, 1996. \nM. VanHilst and D. Notkin. Using Cft P71 templates to implement role-based designs. In Proceedings of \nthe 2nd JSSST Interna-tional Symposium on Object Technologies for Advanced Software, pages 22-37. Springer-Verlag, \n1996. R.J. Wieringa, W. de Jong, and P. Sprint. Ml Roles and dynamic subclasses: a modal logic approach. \nIn Proceedings of the 1993 Eu-ropean Conference on Object-Oriented Pro-gramming, pages 32-59, 1994. R. \nWirfs-Brock and B. Wilkerson. Object- P91 oriented design: A responsibility-driven ap-proach. In Proceedings \nof the 1989 ACM Conference on Object-Oriented Programming Systems, Languages and Applications, pages \n71-76, 1989. R. Wirfs-Brock, B. Wilkerson,WI and L. Wiener. Designing Object-Oriented Software. Prentice \nHall, 1990.  \n\t\t\t", "proc_id": "236337", "abstract": "In this paper we present a method of code implementation that works in conjunction with collaboration and responsibility based analysis modeling techniques to achieve better code reuse and resilience to change. Our approach maintains a closer mapping from responsibilities in the analysis model to entities in the implementation. In so doing, it leverages the features of flexible design and design reuse found in collaboration-based design models to provide similar adaptability and reuse in the implementation. Our approach requires no special development tools and uses only standard features available in the C++ language. In an earlier paper we described the basic mechanisms used by our approach and discussed its advantages in comparison to the framework approach. In this paper we show how our approach combines code and design reuse, describing specific techniques that can be used in the development of larger applications.", "authors": [{"name": "Michael VanHilst", "author_profile_id": "81100148199", "affiliation": "Department of Computer Science and Engineering, University of Washington, PO Box 352350, Seattle, Washington", "person_id": "PP43116795", "email_address": "", "orcid_id": ""}, {"name": "David Notkin", "author_profile_id": "81100636585", "affiliation": "Department of Computer Science and Engineering, University of Washington, PO Box 352350, Seattle, Washington", "person_id": "PP43123111", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236375", "year": "1996", "article_id": "236375", "conference": "OOPSLA", "title": "Using role components in implement collaboration-based designs", "url": "http://dl.acm.org/citation.cfm?id=236375"}