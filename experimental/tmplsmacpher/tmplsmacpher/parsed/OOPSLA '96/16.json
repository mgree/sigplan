{"article_publication_date": "10-01-1996", "fulltext": "\n Automatic Inheritance Hierarchy Restructuring and Met11Od Refactoring Ivan Moore Department of Computer \nScience University of Manchester, Oxford Road Manchester Ml3 Abstract Most, object-oriented programs \nhave imperfectly designed inheritance hierarchies and imperfectly fact,ored methods, and these imperfections \ntend to increase with maintenance. Hence, even object-oriented programs are more expensive to main-tain, \nharder to understand and larger than neces-sary. Aut,omatic restructuring of inheritance hi-erarchies \nand refa.ctoring of methods can improve the design of inheritance hierarchies, and the fac- toring of \nmethods. ing smaller, having more consistent. prototype tool for chy restructuring programs. Results \nThis results in programs be-better code re-use and being This paper describes Guru, a automatic inheritance \nhierar-and method refactoring of Self from realistic applications of the tool are presented.  Introduction \nFactoring shared methods into classes and shared code into methods allows systems to be compact and improves \nconsistency, making them more eas-ily understood and less expensive to maintain. Manually designing inheritance \nhierarchies and methods which maximize factoring is very diffi-cult. Even if a system is well designed \ninitially, maintenance and evolution will tend to cause its design to deteriorate. Many programmers are \nre- Permission to make digital/hard copy of part or all of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage, \nthe copyright notice, the title of the publication and its date appear, and notice is given that copying \nis by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute \nto lists, requires prior specific permission and/or a fee. OOPSLA 96 CA, USA CD 1996 ACM 0-89791-788~Xl96/0010...$3.50 \n9PL, England luctant to manually restructure a system, as this can be very difficult, particularly if \nthe system is large and has been built by many different pro-grammers. For large systems, no one programmer \nmay understand the whole system at the level of detail of individual methods. Manual restructur-ing is \nalso error prone and, while a system works, however badly structured it is, the temptation is to leave \nit alone. Previous work on automatic and semi-auto-matic structuring and restructuring of object-oriented \nsystems [Casais92] [Dicky96] [GodingS] [Hoeck93] [Lieberherr88] [Lieberherrgl] [Moore951 [Opdyke92] [PunSO] \nh as concentrated on areas other than refactoring expressions from methods; such as restructuring inheritance \nhierarchies con-sidering methods as indivisible. Factoring com-mon code out of methods into abstract \nsuper-classes is considered in [Opdyke92]. However, user interaction is required; in particu1a.r the \nuser spec-ifies which (two) classes to refactor methods and common code from, to put into a sha,red imme-diate \n(abstract) superclass. Work on refactor-ing expressions from functions or procedures in conventional \n(non object-oriented) programming languages [Lano93] is not entirely applicable to object-oriented languages, \nas conventional pro-gramming languages lack inheritance, which af-fects how methods can be shared, and \nthere is no message sending polymorphism, which affects how methods can be refactored. Ideas related \nto factoring as a fea,ture of good design are explored in [Wolff94]. Guru [Moore951 explores a radical \nnew ap-proach: restructuring inheritance hierarchies and refactoring methods simultaneously. In the re-sulting \ninheritance hierarchies, none of the meth-ods and none of the expressions that can be fac-tored out are \nduplicated. This paper describes how Guru has been extended, from automatically restructuring an inheritance \nhierarchy to auto-matically refactoring methods at the same time. As Guru is automatic it can be used \nfrequently, for example after every design iteration. In com-parison with [Opdyke92], rather than refactor-ing \nmethods and common code from user chosen classes into an abstract superclass, the inheritance hierarchy \nis restructured by Guru to enable the maximum amount of sharing of methods and ex-pressions. Inheritance \nhierarchy structure and method factoring are only two aspects of the design of an object-oriented system. \nThere are other as-pects of object-oriented design which Guru does not address. Guru is so named as it \nassists in Self improve- ment. Automatic Inheritance Hier-archy Restructuring This section briefly \ndescribes the inheritance hi-erarchy restructuring, without refactoring, per-formed by Guru. A more detailed \ndescription can be found in [Moore95]. Guru takes a collection of objects (or classes), which need not \nbe related by inheritance and which do not have to be a complete inheritance hierarchy, and restruct.ures \nthem into a new inher-itance hierarchy in which there are no duplicated methods, and the behavior of \nobjects (or classes) is preserved. The existing inheritance hierarchy is removed, and a new one inferred \nusing a simple but effi-cient algorithm [Moore96]r, which infers a hier-archy that reflects the structure \ninherent in its Discovered independently of a similar algorithm de-scribed in [Mineau95]. objects. The \nalgorithm is briefly described in Ap- pendix A. Only the features of concrete objects and classes, such \nas methods and instance vari-ables, are used to infer the hierarchy. The struc-ture of the original hierarchy \nis irrelevant to Guru; any hierarchy defining the same features of con-crete objects and classes will \nbe restruct,ured into the same hierarchy by Guru. A simple example from [Moore951 is presented below \nto illustrate the inheritance hierarchy re-structuring performed by Guru. Consider the classes shown \nin Figure 1. Inheritance is shown as arrows from subclasses to superclasses. The labels represent the \nmethods defined by each class, and methods of the same name are equivalent in this example. The existing \ninheritance hierarchy is re- moved, resulting in the classes shown in Figure 2. A new inheritance hierarchy \nwhich preserves the behavior of the concrete classes (in this case the leaves of the hierarchy), and \nin which no methods are duplicated, is inferred, resulting in the hierar-chy shown in Figure 3. ml.m2 \nil Figure 1: Example inheritance hierarchy Figure 2: Example classes after removing hierarchy Figure \n3: Restructured inheritance hierarchy There have been some minor improvements to Guru since it was described \nin [Moore95], which will not be discussed in this paper as they do not affect the refactoring of methods. \n 3 Automatic Refactoring of Methods This section describes the essential features of the refactoring \nof methods performed by Guru. Fea-tures of Self relevant to refactoring methods are introduced, followed \nby subsections which intro-duce refactoring of methods, describe limitations inherent to method refactoring, \nand describe the additional limitations imposed by Guru. 3.1 Self Self [Ungar87] is a dynamically typed \nobject-oriented language, similar in many ways to Smalltalk [GoldbergSO], but with some differences which \nwill need explaining in order for the Self code fragments to be understood by readers fa-miliar only \nwith Smalltalk. Self code fragments are shown in sans serif font. Messages without an explicit receiver \nare sent to self. Variable ac-cesses and assignments are made using message sends. Therefore, the expression \nx aMessage: y means that aMessage: is sent to the object result-ing from x sent to self, with the argument \nwhich is the object resulting from y sent to self. The messages x and y may refer to the Self equivalent \nof instance variables, or to methods. The message aMessage: may invoke either an assignment, or a method \nt,aking one argument. In Self, methods, instance variables, data and inheritance relationships are defined \nin slots. Data slots are equivalent to non-assignable in-stance variables or class variables. Self is \nan object-centric language; it does not have classes. However, the majority of readers will be more familiar \nwith class-centric languages, so the word class will be used for objects which perform the r6le equivalent \nto classes. Self is dynamically typed; additional consider-ations which would need to be taken into account \nif the approach described were used for a. stati- cally typed language a.re beyond the scope of this \npaper.  3.2 Refactoring methods Expressions can be factored out of methods by creating a new method \nto implement the expres-sion, and by replacing occurrences of that expres-sion by the appropriate message \nsend. In this way, an expression can be shared by many methods. The terminology used in this paper is \nthat expres-sions which are factored out are called fa.ctored expressions and the methods created to \nsha.re fac- tored expressions are called factoring methods . The behavior of a method is determined by \nits sequence of message sends. Provided the same messages are sent in the same order, the factoring of \nmethods and the classes where they are located do not matter. Due to message sending polymor-phism, a \nsequence of message sends may result in different methods being executed for different objects. If two \nmethods (or expressions) send the same messages in the same order, then they can be factored out as one \nmethod (or expression), irrespective of the original classes (or methods) they occurred in. It does not \nmatter which meth-ods will execute as the result of those message sends, they will be the same irrespective \nof where the methods (or expressions) are located. Due to message sending polymorphism, more factoring \nis possible than in conventional languages which have only procedure or function calls. Note that in \nSelf it does not matter whether a messa.ge send results in an instance variable access (or assign-ment) \nor a method being executed; this enables more refactoring than otherwise. The following code shows a \nsimple example of refactoring a method: methodone = ( ( x aMessage: y) something ) ma.y be refactored \nas: newMethod = (x aMessage: y) methodone = ( newMethod something ) provided that the object for which \nthe lat,ter ver-sion of methodone is executed responds to the message newMethod by executing the implemen-ta,tion \nshown above. For the rest of the pamper this condition is assumed to be valid, and Sec-tion 4 will describe \nhow this condition is guaran- t,eed by the refa,ctoring system. For conciseness, some refa.ctorings are \nshown for expressions oc- curring only once (as above). 3.3 Expressions which can be factored out Not \nall expressions may be factored out of a method. For example, a block with a non-local return may not \nbe factored out, because a non-local return is from a particular method; return-ing from a different \nmethod does not have the same effect. Similarly, assignments to local vari-ambles may not be factored \nout. Expressions containing references to arguments and local variables may be factored out, provided \nthe reference to the argument or variable is also given to the factoring method. For example: methodone: \nargument = ( ) temporaryvariable 1 temporaryvariable: something. temporaryvariable result. (argument \n-I- aMessage) * 10) may be refactored as: newMethod1: temporaryvariable = (temporaryvariable result) \nnewMethod2: argument = ((argument t aMessage) * 10) methodone: argument = ( 1 temporaryvariable 1 temporaryvariable: \nsomething. newMethod1: temporaryvariable.  newMethod2: argument) Although references and assignments \nto vari-ables appear identical to other messa,ge sends, it is straightforward to statically determine \nwhether a message send is a reference or assignment to a local variable or a. reference to a4 argument. \nIn the above example, the expression temporaryvari-able result is not worth factoring out, as its re-placement \nnewMethod1: temporaryvariable is no improvement. The system uses a simple metric based on the size of \nan expression to determine whether to factor it out, so that cases such a,s this do not occur. Section \n6 includes a discussion of whether this metric is adequate. An expression which includes a block contain-ing \nassignments to local variables of that block mny be fa,ctored out, as shown in the following example. \nmethodone = (I temporary 1 do: [ ( :e. t 1 t: e aMessage. t something: temporary 1. some other code) \ncan be refactored as:  newMethod1: temporary = (do: [ 1 :e. t 1 t: e aMessage. t something: tem-  \n poraryI> methodone = (I temporary I newMethod1: temporary. some other code) However, the expression \nt: e aMessage inside the block cannot be factored out by itself. A more subtle restriction is imposed \nby the im- plementation of Self used2. Blocks by themselves may not be factored out; they may only be \nfac- tored out as part of an expression. For example, the expression [a b c] value may be factored out, \nbut the block [a b c] by itself may not.. The rea- son for this limitation is that blocks whic.h execute \nafter their enclosing method has returned (called non-lifo blocks) are not supported by the current implementation \nof Self. This restriction is very Sun Microsystems Laboratories, Self versiou 4.0 minor, as the expressions \ninside blocks are refac-tored; thus, in the example above, the expression a b c may be factored out of \nthe block. 3.4 The expressions factored out by Guru A limitation of the current implementation of Guru \nis that, with the exception of expressions containing references to arguments or local vari-ables of \ntheir enclosing method or block, only complete expressions (i.e. a piece of code which evaluates to an \nobject) are factored out. Refer-ences to arguments or local variables are passed to factoring methods \nas described in the previous section. Expressions which are message sends to implicit self, explicit \nself or literals, or messages sends to such expressions, to any depth, can be factored out. Expressions \nwhich occur more than once will be factored out, including expressions re-peated in the same method, \nand repeated subex-pressions of the same expression. Furthermore, the system refactors expressions within \nfactoring methods. An example of the method of factoring that Guru uses is that the expressions a b c \nand a b d can be factored into newMethod = (a b), so that a b c would become newMethod c and a b d would \nbecome newMethod d. There are many other different ways of refactor- ing. One example is refactoring \nthe expressions a b c and x b c. Guru can only refactor these expressions in limited circumstances; but \nthis is a limitation of Guru rather than this method of refactoring. A factoring method newMethod1: a \n= (a b c) could be created, and the expressions a b c and x b c would then become newMethod1: a and newMethod1: \nx respectively. This refactoring is performed by Guru only when a and x are ref-erences to arguments \nof their enclosing methods. In situations such as the example above, the names of messages which represent \nreferences to arguments are ignored when comparing expres-sions, otherwise the two expressions would \nhave to be identical. As a consequence, the names of method arguments also have to be ignored when comparing \nmethods, otherwise unnecessary methods could be created, for example, if both newMethod1: a = (a b c) \nand newMethod2: x = (x b c) were created. This comparison of methods is used for all methods, not just \nfactoring meth-ods. Two other ways that the expressions a b c and x b c could be factored are presented \nbelow. If the two expressions occur in methods in different classes which had a common super-class, then \na factoring method newMethod = (newMethod b c) could be created in the super-class, and the methods newMethod \n= (a) and newMethod = (x) could be created in the appro-priate subclasses. Alternatively, the expressions \ncould be factored out by creating factoring method newMethod = (b c) in the classes of the objects which \nmay re-sult from the message sends a and x, and re-placing the expressions with a newMethod and x newMethod \nrespectively. If the message sends a and x always result in objects of only one class, then this would \nbe a very good solution. How-ever, determining the classes of the objects which may result from the message \nsends a and x may be extremely difficult as it requires precise type infer-encing [Agesen95]. Furthermore, \nit ma,y be that these message sends result in objects of nmny dif-ferent classes. If these classes were \nnot rcstruc-tured, then the refactoring would increase the number of methods in the system, which would \nbe counter-productive. A consequence of Guru only factoring comp1et.e expressions is that two expressions \nwhich a,re the same except for a small difference are not refac-tored. For example, the expressions a \nb: (c d: e) and a b: (c d: f) cannot currently be factored as newMethod1: e = (a b: (c d: e)) with the \nexpres-sions becoming newMethod1: e and newMethod1: f respectively, unless e and fare arguments of their \nenclosing met hod. Furthermore, the la.rgest ex-pressions which can be factored out are individual statements. \nIf consecutive statements are shared by two or more methods, the statements a.re fac- tored out as separate \nfactoring methods, rather than as a single factoring method. Currently, Guru only refactors in limited \nways. There are many other ways that methods and ex-pressions could be refactored, in addition to the \nways discussed above. Section 7 discusses the pos-sibilities for extending Guru to refactor in dif-ferent \nways. In practice, even with the limita-tions described, the system performs a consider-able amount of \nrefactoring, as discussed in Sec-tion 6. 4 Simultaneous refact oring of inherit ante hierarchies and \nmethods The refactoring of methods is performed as part of inheritance hierarchy restructuring for two \nrea-sons. Firstly, all of the methods in all of the ob-jects and classes are refactored together, which \nachieves the highest possible amount of method refactoring. There is no limitation on refactoring of \nmethods that they have to be related by in-heritance (before the refactoring stage; they will necessarily \nbe related by inheritance after refac-toring and inheritance hierarchy restructuring). Secondly, the \nrefactoring of methods can discover classes and inheritance relationships which would not necessarily \notherwise exist. That is, if two classes share expressions? even if they do not share any methods, then \nthey will be related by inheri- tance in the resulting inheritance hierarchy. This is further discussed \nin Section 6. The algorithm used to refactor methods is de- scribed below, using an example. Consider \nthe three methods: ml = (((size + 1) > end) ifTrue: [something]) m2 = (((start + end) > 0) iffrue: [size: \nsize -j- 11) m3 = (size: size + 1. ((start + end) > 0) iffalse: [error]) A dictionary is created which \nrelates methods to all of the expressions they contain which may be factored out by Guru. ml -+ size \n+ 1, (size -I- 1) > end m2 --+ start + end, (start + end) > 0, size + 1, size: size + 1 m3 -size + 1: \nsize: size t 1, start + end, (start + end) > 0 For brevity, the largest expressions (((size -I- 1) > \nend) ifTrue: [something], ((start t end) > 0) iffrue: [size: size t l] and ((start t end) > 0) iffalse: \n[error]) have been omitted, and will not be shown in the rest of this example. Another dictionary is \ncreated which relates expressions to the methods which contain them. size + 1 -+ ml, m2, m3 (size + 1) \n> end + ml start f end --+ m2,m3 (start + end) > 0 --i m2, m3 size: size -I- 1 + m2,m3 From this, a \ndictionary is created which relates collections of methods to the expressions which they share. ml, m2, \nm3 -+ size + 1 ml --+ (size $ 1) > end m2, m3 -+ (start + end) > 0,  start f end, size: size + 1 In \norder to avoid unnecessary refactoring, subexpressions of those expressions shared by ex-actly the same \nset of methods are not factored out. Hence, in t.he example above, the expres-sion start + end is not \nfactored out, as (start f end) > 0 is also shared by the same methods. Ex-pressions which appear only \nonce, such as (size + 1) > end in the example, are not factored out. Having determined which expressions \nshould be factored out, a factoring method is created for each factored expression, with a unique name. \nIn the example above, this means that the following methods are created: newMethod = (size + 1) newMethod \n= (size: newMethod1)  newMethod = ((start + end) > 0) A replacement method is made for each method \nwhich includes any fact.ored expressions. These replacement methods are modified such that each factored \nexpression is replaced by the appropriate message send to invoke the appropriate factoring method. The \nresulting methods are: ml = ((newMethod > end) iffrue: [something]) m2 = (newMethod iffrue: [newMethod2]) \nm3 = (newMethod2. newMethod iffalse: [error]) These modified methods and the factoring methods for all \nof the factored expressions that they include effectively replace the original meth-ods in the objects \nand classes to be restructured. For example, the method ml = (((size + 1) > end) iffrue: [something]) \nis replaced by ml = ((newMethod > end) ifTrue: [something]) and newMethod = (size f 1). The restructuring \nis then performed on the ob-jects and classes with their refactored and factor-ing methods, as described \nin Section 2, exactly the same as if there had not been any refactoring. As the appropriate factoring \nmethods are included in the objects and classes which include meth-ods containing their factored expressions, \nthe re-structuring ensures that the appropriate factoring methods will be in the appropriat,e restructured \nclasses. A factoring method will be located in the class from which all methods which included its factored \nexpression inherit. In other words, if an expression is factored out of methods from only one class, \nthen the factoring method will be in the same class as those methods. Alternatively, if an expression \nis factored out of methods from several different classes, then it will be in a class from which all \nthose classes inherit, directly or indirectly. Therefore, the appropriate factoring method will definitely \nbe executed by a message send of its name, because the names of such meth- ods are unique, and factoring \nmethods are in-herited by every class or object which includes a method which contains such a message \nsend. Objects and concrete classes will be slightly changed by the refactoring version of Guru, be-cause \nthey will understand the messages imple-mented by the factoring methods they inherit. However, the introduction \nof factoring methods does not cause any problems, as the behavior of programs will not be changed. It \nis straightfor- ward to check, within the limitations discussed below, that the system does not contain \nany mes-sage sends which would execute factoring meth-ods inappropriately and does not implement any \nmethods with the same names as any of the fac-toring methods. This check needs to be performed on the \ncomplete Self system, as an object which is not included in the collection of objects refac-tored may \nsend a message to a refactored object which it previously could not understand, but af-ter refactoring \nit can understand it, thus changing the behavior of a program. Programs which rely on an object not understanding \na certain message are unusual, so this check will rarely be necessary. In Self, it is possible to write \ncode which sends a message which cannot be determined statically, thereby defeating any attempts to statically \ncheck whether a. certain message is sent, but this pro- gramming style is unusual.  5 Results The results \nof applying Guru to three inheritance hierarchies are presented in this section. The three inheritance \nhierarchies, which will be called the indexables, orderedOddballs and sendishNodes hierarchies respectively, \nwere restructured using Guru, both with and without refactoring of meth- ods. In all except one restructuring, \nGuru was used fully automatically. Restructuring of in- heritance hierarchies is abbreviated to restructur- \ning, and refactoring of methods is abbreviated to refactoring. Two of the hierarchies, the indexables \nand or- deredoddballs, were chosen because it was -ex- petted that they would already be well designed \nand well factored, and so would provide a good benchmark for evaluating the performance of Guru. Both \nof these hierarchies were designed before Guru existed (by someone other than the author), and hence \ntheir design could not have been influenced by the existence of Guru. Both the indexables and orderedOddballs \nhier- archies are used extensively during the running of the Self system, as the programming environ- \nment is written in Self. Some of the objects and classes are fundamental to the running of nearly all \nSelf code. In particular, vectors, bytevectors, canonicalStrings (the Self equivalent of Symbols in Sma.lltalk), \nsmalllnts, floats, true and false are ez-tensively used. The restructured hierarchies, with and without \nrefactoring, were used to replace the original hierarchies, with no change in the behav-ior of the system. \nWhile the successful replace-ment of such fundamental classes is not a formal proof that the restructurings \nare correct, it gives swbstantial evidence. The sendishNodes hierarchy was chosen because it is known \nto be imperfect, and as it is part of the Guru system itself, its design has been af-fected by the existence \nof Guru, which is what we should expect for hierarchies which are developed when a system such as Guru \nis availa,ble in a pro- gramming system. This point is further discussed in Section 6. In the figures, \nrestructured objects and classes are labeled either with the name of the object or class they replace, \nor with the name of the class they most closely replace. What is meant by this is that, for example, \nthe class labeled traits string in Figure 5 does not necessarily define the same behavior as the original \nclass traits string. Only the behavior of objects and concrete classes is pre- served, and traits string \nis not a concrete class. The label traits string in the restructured hierar-chy is used only for convenience, \nand reflects the fact that this class is inherited by t,he equivalent objects and concrete classes in \nthe original hierar-chy. Restructured objects and classes which can-not be labeled in this way are not \nnamed. All objects and classes are shown wit.h the number of non-inheritance slots they define. Hierarchies \nrestructured with and without refactoring which have the same structure are shown together. In those \nfigures, the first number is the number of slots without refactoring, and the second is the number with \nrefactoring. Tables of simple metrics are presented. The entries labeled Message sends refer to the to-tal \nnumber of potential message sends in all the methods in all the classes in the appropriate hier-archy. \nThis metric is used as an indication of the total code size of the hierarchies. Counting the number of \nmethods, the number of statements, or the lines.of code does not really measure the amount of code. Such \nmeasures are misleading for large, badly factored methods or statements, or code written in very long \nlines. Measuring the number of potential message sends gives a. more accurate indication of the amount \nof code. The entries labeled Overriding methods are the number of methods which override other methods \nboth from inside and outside the classes restructured. Having too much overriding, or methods overridden \ntoo often, is an indication of poor design [ Johnson881. 5.1 The indexables hierarchy This hierarchy \nincludes strings, vectors and se-quences. A very similar hierarchy was restruc-tured by the previous \nversion of Guru, and the results are described in [Moore95]. The dif-ferences between the hierarchy restructured \nby Guru, shown in Figure 4, and the hierarchy re-structured in [MooreSti], are because a newer ver-sion \nof the Self system has been used. The result of restructuring without refactoring is shown in Figure \n5. This hierarchy is not ex-actly the same as in [Moore95], because of the differences in the original \nhierarchy and some mi-nor improvements to Guru since it was described in [Moore95]. 1 traits mdexable(29 \nthe restructuring.  objens and classes included rn t trait?. mutablelndexable(l9) trails traits traits \ntraits inmutableString(6) mutebieString(6) t traits canbnicalString(6) A I I I \\ I 1 I canonicalString \nmutebleStnng bytevector vector sequence sortedSequence (0) (0) (0) (01 (7) (81 Numbers shown in brackets \natter the objen s name are the number ot methods and instance variables defined by the object Figure \n4: The original indexables hierarchy traits mutablelndexablef461 tralfs string(l76) traits kts canonicalString(l4) \nmutableString(l0) I t 4 I \\ I canonktring mutableString bytektor vecfor seqknce sorlec&#38;quence (0) \n(0 (0 (0 (7) (8 Figure 5: The restructured indexables hierarchy This restructuring included a very small \namount of programmer intervention, in that one method was manually moved higher in the inher-itance hierarchy. \nThe original hierarchy was then restructured with refa-ctoring, producing the hier-archy shown in Figure \n6. tram colled~on I traits mutablelndsxable(60) // \\ (6) \\ \\ traits (26; traits vector(21) seq e ce<4 \nr2 / traits 4 \\ traits smng(207) byteVector(5) traits I so edSequenca(9) t CanonlcalSlrlng(l7) mutableString(l0) \nI I 1 I I I canonkxlString mutableString byteVector vector sequence so edSequence (0) (0 (0) (0 (7) (6) \nFigure 6: The restructured and refactored indexables hierarchy In this case, there was no manual interven-tion. \nIt is interesting to observe that the hier-archy is slightly different to the one produced by the restructuring \nwithout refactoring. An addi-tional class has been discovered because of the factoring methods introduced. \nFurthermore, this additional class is very easy to understand; it is the class of vector-like objects, \nas opposed to sequence-like objects. The following table gives some simple metrics concerning the refactoring \nand restructuring re-sults. (Ori = Origina.1, Res = Restructuring with-out refactoring, RwR = Restructuring \nwith refac-toring) Ori Res RwR Classes and Objects 17 15 16 Methods 316 311 390 Message sends 3681 3662 \n3622 Overriding methods 86 72 69 A small problem with replacing t,he original objects with the restructured \nones wa.s tha,t, be-cause vector, bytevector, mutablestring and canon-icalstring have the equivalent \nof indexed insta,nce variables, only their class objects were actually modified. This has exactly the \nsame effect a,s if these objects are modified, as they each ha,ve only one slot defining inheritance \nfrom their cla,ss. 5.2 The orderedOddballs hierarchy This hierarchy includes the numbers and boolean \nclasses. Although Guru was designed to restruc-ture hierarchies including concrete objects, it can equally \nbe used when given only the Self equiva- lent of classes, as in this case. Only classes have been used, \nbecause number objects cannot be modified; furthermore, nothing would have been gained by including number \nobjects in the restruc-turing as they define only one slot for inheritance. The original hierarchy is \nshown in Figure 7. The results of restructuring with and without refactoring methods are both shown in \nFigure 8. m&#38;ins oddball lobby mixins ordered Objects and classes Included in lhe restrucwring traits \nnumber(61) traits l,r--i -; trails boolean(5) \\ \\ traits blglnt(78) traits kalllnt(59) trams float(62) \nt&#38;S) false(s) *traits ordwec+Xdball defines only lnherrtance and does not Include any methods. Figure \n7: The original orderedOddballs hierarchy mrxins o&#38;ball lobby mixins ordered lraits orderedOddball(2R) \nH \\ traits nunber167/711 \\ tralts lnteger(62/67) traits boolean(4A) traits biglnt(69/62) traits smalllnt(50/50) \ntrans float(51156) true(8/6) lalse(s/s) Figure 8: The restructured orderedOddballs hierarchy, with and \nwithout refactoring of methods Notice that there is no difference in the struc-ture of the hierarchies, \nonly in the details of where methods are located and how they are factored. This is not generally true \nof hierarchies restruc-tured using Guru, but in this case the hierarchy can be assumed to have been very \nwell designed initially, as such hierarchies are well understood, and it is a small hierarchy, in terms \nof the number of classes. An example of the detailed difference between the hierarchy restructured without \nrefactoring and the original is that there were several methods which had been defined identically in \ntraits big-Int, traits smalllnt and traits float, for which in the restructured inheritance hierarchy \na single imple-mentation has been put in the equivalent of traits number. In the hierarchy restructured \nwith refactoring there are more detailed differences. For example, in the equivalent of traits number, \none expression was factored out from 14 methods, and shared between them using a factoring method. Some \nmethods in the replacement for traits float had the same implementation but different names, and so their \ncode was shared using factoring methods, The following table provides some simple met-rics about the \noriginal hierarchy, and the restruc-tured hierarchies with and without refactoring. 5.3 The sendishNodes \nhierarchy This hierarchy is part of the parse tree nodes hi-erarchy used in the implementation of Guru. \nThe original hierarchy is shown in Figure 9, the restructured hierarchies with and without refac-toring \nof methods are shown in Figure 10. IrailS parwTreeNode 1 Objects and classss included traits sendlshNods(l2) \nin the restruauring Af \\ trak. r es*/ / \\ rralts flats traits traits dlrectedResendN(7) wdireciedRess \ndN(7) implidtSendNode(39) sendNcde(l4) t t t I I I I I direaedResendN(l0) undrecledResendN(8) implidtSendN&#38;(B) \naa dNode(l0) Node is abbreviated to N far some labels Figure 9: The original sendishNodes hierarchy IraitsparseTreeNode \nI IF sendishNode(9RO) . tratts rasendNodsf7llO~ traas traits traits traks directedResendN(6/6) undirectedRese \ndN(6) impiidtSendNode(34/38) sendNode(W13) 1 t I t directedRese .3U(lWlO) u direcledResendN(&#38;B) \nimplidtSe dNcde(8/6) se dNcde(lO/lO). Node is abbreviated to N lor s&#38;e labels Figure 10: The restructured \nsendishNodes hierarchy, with and without refactoring of methods The restructured hierarchies are similar \nto the original hierarchy, with the difference in structure due to the discovery of a new class. This \nclass can easily be understood as the class of all parse tree nodes which represent expressions tha.t \nhave self as the implicit receiver (including resends). The following table provides some simple met-rics \nabout the original classes, and the classes re-structured with and without refactoring. Ori Res RwR Classes \nand Methods Objects 10 77 11 70 11 89 Messa,ge Overriding sends methods 490 37 461 29 429 29    Discussion \nof results The most important feat,ure of the results is that the structure of the inheritance hierarchies \npro-duced by Guru are exactly as expected for well designed hierarchies. It is important to remember \nthat Guru does not use the structure of the origi-nal hierarchies to guide the creation of the restruc-tured \ninheritance hierarchies. The hierarchies produced are based only on maximizing shar-ing and minimizing \nduplication of the features (mostly methods) of objects and concrete classes. Any other hierarchies which \ndefined the sa,me fea- tures for their objects and concrete classes, how-ever badly structured, would \nhave produced the same results from Guru. It should be noted that Guru will produce inheritance hiera,rchies \nwith multiple inheritance when necessary; for t,he three examples used, single inheritance was sufficient \nto ensure no duplication of methods or factored ex- pressions. It is interesting that method refactoring \nhas not had more effect on the structure of the inheri-tance hierarchies produced. While the approach \ntaken maximizes the amount of factoring of meth- ods (within the limitations of Guru), the benefit of \ninferring new classes from factoring methods would appear, on the evidence gathered so far, to be of \nminor importance. A more detailed feature of the hierarchies re-structured with refactoring was that \na high pro-portion of method refactoring was found to be inside individual restructured classes, with \nrela-timely few factoring methods sharing expressions amongst methods of more than one class. The ex-planation \nfor this, given that refactoring of meth ods is performed before the final restructured hi-erarchy is \ncreated, must be due to the fact that methods that will be restructured into in a single class will tend \nto have more similarities between them than methods in different classes. The largest difference between \nthe original and restructured hierarchies is in the details of the location and factoring of methods. \nThe restruc-tured and refactored hierarchies are an improve-ment compared to the original hierarchies. \nIn terms of simple objective measures, the reduc-tion in the number of potential message sends in the \nrestructured and refactored hierarchies in-dicates that the total amount of code has been reduced, and \nan improvement in code reuse has been achieved. Furthermore, as no methods or factored expressions are \nnow duplicated, but are defined only once, the restructured and refactored hierarchies are more consistent \nthan the original hierarchies. The results of the previous section show that, despite the limitations \ndescribed in Section 3.4, the system performs a considerable amount of refactoring. In the case of the \nindexables hier-archy, 77 expressions were factored out. There is scope for improvement, particulasly \nin a,llow-ing for more refactoring to be possible, while only performing refactoring which is desirable. \nOne of the problems of automatic refactoring is that it can be difficult to understand the mean-ing of \nsome of the methods automatically created. The names generated for factoring methods are unique system \ngenerated names which have no in-herent meaning. These methods can be renamed by the user, and Guru will \nrename all sends of the appropriate message. It can be difficult to in-vent a short and meaningful name \nfor many of the factoring methods. To give an indication of the sort of expressions which were factored \nout from the orderedoddballs and indexables hierarchies, a selection of some of the factoring methods, \nand one method which was modified to use a factor-ing method, are shown below (including too many brackets, \nthis is one of the features which could be improved, as mentioned in Section 7): newMethod651P: a P: \nres = (res sign: (sign * (a sign))) newMethod = (-1 = sign) newMethod659P: d = ((d size) -cByteSize) \nmostSignificantDigit: d = (in d At: (newMethod659P: d)) newMethod636P: digit = ((digit asByte) -( 0 asByte)) \nnewMethod = (size + 1) newMethod = ( size: (newMethod661)) The purpose of a factoring method may not \nbe obvious, unless one fully understands the code. It is currently impossible for a fully automated system \nto determine the purpose of a fra,gment of code to decide whether it is worth refactoring or not, and \nto invent a. meaningful name for the factoring method. Furthermore, the amount of refactoring that should \nbe performed can be ar-gued to be a subjective decision. For example, in Self some programmers use the \nexpression x + 1, where others use the equivalent expression x WCC. A possible argument for limiting \nthe amount of factoring is that some programmers may under-stand the meaning of, for example, x f 1 more \neasily than x succ, and in some cases may have to find the factoring method that will be executed in \norder to understand the code. Furthermore, it may be very difficult to think of a name for a factoring \nmethod which is understandable, and at the same time more abstract and preferably also more compact than \nthe original expression. For example, the expression size + 1 could be fac- tored out as a factoring \nmethod called sizePlu-s0ne. This is slightly more characters to type, and is not very abstract. The ideal \nrefactoring should discover meaningful method abstractions from expressions, so that the system is easier \nto understand, reuse and modify. An approach that may satisfy both those who prefer as much fac-toring \nas possible and those who do not, would be for the code to be as highly factored as possi-ble, but for \nthe system to allow expressions to be shown as if they were inlined in the code, as much as each programmer \nrequires. To implement such a facility would, in general, require precise type inferencing [Agesen95]. \nThe metric used by Guru to dec.ide whether to factor out an expression is based simply ou the size of \nthe expression, measured as the number of message sends, not including references to ar-guments or local \nvariables. The minimum size of expression that will be factored out has been cho- sen as the smallest \nthat ensures that replacement expressions will be smaller than the expressions they factor out (in terms \nof number of message sends); hence the total number of message sends will be reduced by the refactoring. \nDetailed anal-ysis of the results of refactoring several hierarchies indicates that this metric is not \nideal, as many expressions are factored out which have no eas-ily understood meaning as method abstractions. \nA metric which could be used, that ma.y give a better indication of which expressions to factor out,, \ncould be the number of times an expression occurs. Currently, any expression which occurs more than once \nis factored out, but it may be better to factor out certain expressions, for cx- ample the smallest possible \nexpressions, only if they occur frequently. A possible criticism of increasing factoring is that it \nwill degrade the performance of the code. However, this is a weak argument, as sophisti-ca.ted compilers, \nsuch as the Self system used for this work, are able to automatically inline code so that the amount \nof factoring at the source level does not affect the performance of compiled code. In the sendishNodes \nhierarchy, some methods were written in a particular way in order to max-imize their possibility of refactoring. \nIn pa,rt ic-ular, consistency between methods in the order of expressions, in cases where the ordering \ndoes not matter for the meaning of the expression, enabled some subexpressions to be factored out which \nwould not have otherwise been possible. The existence of a tool such as Guru can influence the way that \ncode is written. There is possibly a counter-productive psychological consequence of the existence of \na system such as Guru, that pro-grammers may become lazy about creating good code and inheritance hierarchies, \nbecause they be-lieve that the system will tidy everything up for them.  Future research More work \nis required to reduce the limitations of Guru s refactoring. If the system is made capable of factoring \nmethods or expressions in different ways, then it will have to be able to decide which refact.oring to \nuse. Similarly, as more factoring becomes possible, the system will either have to decide whether a potential \nrefactoring is worth applying, given that some programmers will not appreciate too much refa.ctoring, \nor it. should pro-vide the a.bility to display source code as if inlining has been performed, as described \nin the previous section. Also, there may be a limit to the amount of refactoring that can be performed \nin an accept-able amount of time. A drawback of Guru which needs improvement is that the source code \nof factoring methods a*nd methods which have been modified because they included a, factored expression \nis generated from parse trees, ignoring the original source code. This results in the original layout \nand comments being lost, and most programmers would prefer as little disruption to their layout and commends \nas possible. In the present system, the source code generated is not very well formatted; for example \nit uses too many brackets. The speed of Guru for restructuring includ-ing refactoring of large systems \nis poor in the current implementation. Restructuring including refactoring of the indexables hierarchy \ntook ap-proximately 8 hours on a Sun Spare 2. This is mostly because of details of the current imple-mentation \nof Guru, but partly due to the fact that all methods in a restructuring are refactored together. While \nthis approach ensures the maxi-mum amount of refactoring is possible, it is com-putationally expensive. \nOne way of reducing the computational expense would be to restructure a hierarchy without refactoring, \nand then perform refactoring on subgraphs of the restructured hier-archy. This approach would not achieve \nthe maxi-mum amount of factoring possible, and would not discover any new classes or inheritance relation-ships \nin performing the refactoring. The results discussed in Section 6 suggest that if the time taken to refactor \na large system were important then the loss of these benefits might be a reasoIi- able compromise. However, \nthe limit on the size of hierarchy which can reasonably be restructured including refactoring may be \nreached before t.he limit, imposed by computational considerations. This is because of t,he complexity \nof understand- ing a large hierarchy well enough to understand the effects of the restructuring. More \nrefactoring could be possible by using a more sophistica,ted comparison of expressions than simply examining \ntheir sequence of mes-sa,ge sends. For example, by inlining expres-sions, superficially different expressions \nor meth-ods which have the same effect could be refac-tored [lingar94]. Furthermore, if it ca,n be cleter-mined \nwhich methods are private (only executed due to messages sent to self) then these meth-ods could be removed \nif all message sends which cause them to execute are removed through in-lining. This would allow better \nrefactoring of the public methods. Similarly, it might be possible to determine that expressions are \nequiva,lent even if the order of message sends is different.. Sophisti-cated analysis of code is increasingly \nperformed by optimizing compilers; a refactoring system could benefit from reusing the analysis of such \ncompil-ers. The successful application of Guru to objects and classes fundamental to the Self system \nis a practical demonstration that the restructuring and refactoring performed do not alter the be-havior \nof a system. However? proofs should be constructed in order to verify that the algorithms used by Guru \npreserve the behavior of a system. 8 Conclusions This paper has shown that automatic restruct,ur- ing \nand refactoring can improve the inheritance hierarchy structure a.nd method factoring of real- istic \nexamples. Hierarchies created by restructuring realistic examples are exactly the structures that, should \nbe expected of good designs, and eliminate du-plication of methods. The refactoring of meth-ods improves \nhierarchies even further by elimi-nating duplication of the expressions which it fac- tors out. Eliminating \nduplication of methods and factored expressions reduces the total amount of code (measured as the number \nof potential mes-sage sends), improves consistency and increases code reuse. Further work is required \nto increase the amount of refactoring possible, and to pro-duce more easily understood factoring methods. \n Guru does not directly approach the related problems of (user directed) program maintenance or progra,m \nunderstanding. However, program understanding may be assisted due to reducing the size a,nd increasing \nthe consistency of a sys-tem. Similarly, Guru provides an approach to perfective maintenance which may \nsimplify user directed maintenance due to this improved con-sistency, which makes alterations easier \nand safer, as it ensures that a change needs to be made in only one method, rather than having to make \nthe same change in many methods, The structure of the hierarchies produced by Guru is either the same, \nor better, than the orig-inal programmer designed hierarchies, providing objective evidence that maximizing \nfactoring is a good design principle. The comparison of an original hierarchy with its restructured hierarchy \nis suggested as a quality metric. As the system uses only details of code in the system, rather than \nknowledge of the problem domain, the hierarchies and refactoring created by Guru reflect what actually \nexists in a system, which may not be the same as what should exist in a system.  Acknowledgements I \nwould like to thank the EPSRC for funding this work. I am very grateful to my ex-supervisors, Trevor \nHopkins, Mario Wolczko, Jon Taylor and Tim Clement and my current supervisor Chris Kirkham, for their \nencouragement and assistance during my studies at Manchester University. I am also indebted to the Self \ngroup, for advice and in- formative discussions about the Self system.  References [Agesen95] Ole Agesen. \nThe Cartesia,n Product Algorithm: Simple and Precise Type Inference of Parametric Polymorphism. In Proceedings \nof ECOOP 95. (L,NCS 952, pages 2-26) Springer-Verlag, 199rj. [CasaisSO] Eduardo Casais. Managing Class \nEvo-lution in Object-Oriented Systems. In Object Management. Centre Universi-taire d Informatique, Geneve, \n1990. [Casais92] Eduardo Casais. An Incremental Class Reorganization Approach. In Procced-ings of ECOOP \n92. (LNCS 615, pages 114-132) Springer-Verlag, 1992. [Dicky96] Herve Dicky, Christophe Dony, Mar-ianne \nHuchard and Therese Libourel. On Automatic Class Insertion with Overloading. In Proceedings of OOP-SLA, \n1996. [GodingS] Robert Godin and Hafedh Mili. Build-ing and Maintaining Analysis-Level Class Hierarchies \nusing Galois Lat-tices. In Proceedings of OOPSLA, (SIGPLAN Notices 28(10), pages 394-410) 1993. [Goldberg901 \nAdele Goldberg and David Robson. Smalltalk-: The Language. Addison-Wesley, 1990. [Hoeck93] Bernd H. Hoeck. \nA Framework for Semi-Automatic Reorganisation of Object-Oriented Design and Code. MSc thesis, University \nof Manchester, 1993. [Johnson881 Ralph E. Johnson and Brian Foote. Designing Reusable Classes. Journal \nof Object-Oriented Programming l(2), pages 22-35, 1988. [Lano93] Kevin Lano and Howard Haughton. Reverse \nEngineering and Software Maintenance: A Practical Approach. McGraw-Hill, International Series in Software \nEngineering, 1993. [Lieberherr88] Karl J. Lieberherr, Ian Holland, and Arthur J. Riel. Object-Oriented \nProgramming: An Objective Sense of Style. In Proceedings of OOPSLA, (SIGPLAN Notices 23(11), pa.ges 323-334) \n1988. [LieberherrSl] Karl J. Lieberherr, Paul Berg-stein, and Ignacio Silva-Lepe. From Objects to Classes: \nAlgorithms for Op-timal Object-Oriented Design. Soft-ware Engineering Journal 6(4), pages 205-228, 1991. \n[Mineau95] Guy W. Mineau and Robert Godin. Automatic Structuring of Knowledge Bases by Conceptual Clustering. \nIn IEEE Transactions on Knowledge and Data. Engineering 7(5), pages 824-829, 1995. [Moore951 Ivan R. \nMoore. Guru - a Tool for Auto- matic Restructuring of Self Inheritance Hierarchies. In TOOLS USA 1995. \n(TOOLS 17, pages 267-275) Prentice-Hall, 1995. [MooregG] Ivan R. Moore and Tim P. Clement. A Simple and \nEfficient Algorithm for Inferring Inheritance Hierarchies. In TOOLS Europe 1996. (TOOLS 19, pages 173-184) \nP rentice-Hall, 1996. [Opdyke92] William F. Opdyke. Refactoring Object-Oriented Frameworks. PhD the-sis, \nUniversity of Illinois at Urbana-Champaign, 1992. [Opdyke93] William F. Opdyke and Ralph E. Johnson. \nCreating Abstract Super-classes by Refactoring. In Proceedings of CSC 93: The ACM 1993 Computer Science \nConference. ACM, 1993. [Pun891 Winnie W. Y. Pun and Russel L. Winder. Automating Class Hierarchy Graph \nConstruction. Technical report, University College London, 1989. [PunSO] Winnie W. Y. Pun. A Design Method \nfor Object-Oriented Progranl-ming. PhD thesis, University College London, 1990. [Ungar87] David Ungar \nand Randall B. Smith. Self: The Power of Simplicity. In Pro-ceedings of OOPSLA, (SIGPLAN No-tices 22(12), \npages 227-241) 1987. [Ungar94] David Ungar. Private communica-tion. Sun Microsystems Laboratories Inc, \nMountain View, California 1994. [Wolff941 J. G erard Wolff. Towards a New Con-cept of Software. In Software \nEngineer-ing Journal 9(l), pages 27-38, 1994. A The hierarchy restructuring algorithm This section briefly \ndescribes the important fea-tures of the algorithm used for inferring an inher-itance hierarchy, called \nthe IHI algorithm, for a set of objects/classes. It is more fully described in [Moore96]. To simplify \nthe text, the word class is used to mean object or class . Given a set of classes, each class defining \na, set of features (such as instance variables and methods, without any inheritance links), the IHI algorithm \ninfers a hierarchy with no duplication of features, which includes replacement classes defining or in-heriting \nexactly the same sets of features as de-fined by the original classes. Let 0 be the set of classes for \nwhich a hierarchy is to be inferred. Let R be the set of classes inferred. In order to ensure no duplication \nof features, a relation is built mapping each set of all the classes in 0 which share a feature, to the \nset of features they (alone) share. This requires that features define equivalence. A set of features \nmay contain only one feature. Similarly, a set of features de-fined by only one class requires a mapping \nfrom a set containing that class only, to the set of fea- tures defined. Such single element sets need \nto be constructed for classes even if there is no feature that they alone define (in which case the set \nof features defined will be empty). Each mapping from a set of classes to a set of features defines a \nclass in R (with that set of features), but does not define the necessary inheritance links. Each mapping \nfrom a set containing a single class to a set of features defines a class in R which directly replaces \na class in 0 (the class which is the single element of the set). To ensure that replacement classes \ninherit all the features they need, inheritance links are added from each class in R which shares features \nbe-tween classes C, to every class in R which shares features between a proper superset of C. In order \nto remove transitively unnecessary inheritance, for each class C in R, for each class D which has an \ninheritance link to C (before any inheritance links have been removed), and each class E which has an \ninheritance link to D, remove any inheritance links from E to C. The classes in R, and their inheritance \nlinks, are now defined.  \n\t\t\t", "proc_id": "236337", "abstract": "Most, object-oriented programs have imperfectly designed inheritance hierarchies and imperfectly factored methods, and these imperfections tend to increase with maintenance. Hence, even object-oriented programs are more expensive to maintain, harder to understand and larger than necessary. Automatic restructuring of inheritance hierarchies and refactoring of methods can improve the design of inheritance hierarchies, and the factoring of methods. This results in programs being smaller, having better code re-use and being more consistent. This paper describes Guru, a prototype tool for automatic inheritance hierarchy restructuring and method refactoring of Self programs. Results from realistic applications of the tool are presented.", "authors": [{"name": "Ivan Moore", "author_profile_id": "81100041802", "affiliation": "Department of Computer Science, University of Manchester, Oxford Road, Manchester M13 9PL, England", "person_id": "P117473", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236361", "year": "1996", "article_id": "236361", "conference": "OOPSLA", "title": "Automatic inheritance hierarchy restructuring and method refactoring", "url": "http://dl.acm.org/citation.cfm?id=236361"}