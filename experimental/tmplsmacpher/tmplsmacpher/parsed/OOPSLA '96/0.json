{"article_publication_date": "10-01-1996", "fulltext": "\n An Equational Object-Oriented Data Model and its Data-Parallel Query Language Susumu Nishimura* nisimura@kurims.kyoto-u.ac.jp \nResearch Institute for Mathematical Sciences Kyoto University  Atsushi Ohorit ohori@kurims.kyoto-u.ac.jp \nResearch Institute for Mathematical Sciences Kyoto University Keishi Tajima tajima@in4wolf.in.kobe-u.ac.jp \nDepartment of Computer and Systems Engineering Kobe University Abstract This paper presents an equational \nformulation of an object- oriented data model. In this model, a database is represented as a system of \nequations over a set of oid s, and a database query is a transformation of a system of equations into \nan- other system of equations. During the query processing, our model maintains an equivalence relation \nover oid s that relates oid s corresponding to the same real-world entity. By this mechanism, the model \nachieves a declarative set-based query language and views for objects with identity. Moreover, the query \nprimitives are designed so that queries including object traversal can be evaluated in a data-parallel \nfashion. 1 Introduction A major advantage of object-oriented databases over traditional relational databases \nis that they directly sup-port complex objects with complicated object sharing relations through the \nmechanism of object identity. Un-fortunately, however, this mechanism makes it difficult to develop a \nset-based declarative query language and a view mechanism. It also conflicts with parallel pro-cessing \nof database queries. The purpose of this work Partly supported by International Information Science Founda-tion, \nTokyo Japan. +Partly supported by the Japanese Ministry of Education Grant- in-Aid for Scientific Research \non Priority Area: Advanced databases, area no. 275. Permission to make digitalhard copy of part or all \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for profit or commercial advantage, the copyright notice, the title of the publication and \nits date appear, and notice is given that copying is by permission of ACM, Inc. To copy otherwise, to \nrepublish to post on servers, or to redistribute to lists, requires prior specific permission and/or \na fee. OOPSLA 96 CA, USA 0 1996 ACM 0-69791-766-W96 0010...$3.50 is to develop a simple yet powerful \nformulation of an object-oriented data model that overcomes these two difficulties and define a data-parallel \ndeclarative query language based on the formalism. Let us first examine the problem of developing a declarative \nquery language for objects with identity. In the relational data model, the unit of data manipula-tion \nis a relation, i.e. a set of tuples, and a database query is simply a relation transformation constructed \nfrom a small set of primitive operations on relations. This property provides a clean declarative semantics \nto database queries and is the basis of query decompo-sitions and optimization. This structure also supports \ndatabase views: since the result of a query is another relation, a view can simply be a query expression \nwhich is to be evaluated lazily when needed. This is in sharp contrast with object-oriented data models. \nAn object- oriented database consists of sets of mutually dependent objects interconnected by object \nidentifiers, and queries crucially depend on navigation, i.e. traversing object-identifiers. This structure \ndoes not immediately yield a set-based declarative query language. To see the prob- lem, consider the \nfollowing simple object types and sets of objects: type EmpZ=[Name:string, Salary:&#38;, Departmentdkpt, \nBoss:EmpZj type Dept = [Namewing, Manager:EmpZj Empl : {Empl} Dept : {Dept} where {T} denotes the set \ntype whose element type is T and [[,:7-l ,. .., .!n-.m] denotes a type of object containing the set of \nfields e, Y-I ,. . .,&#38;:T,. One typical query against this database would be to transform the above \ntwo sets of objects into the following different representation. type Empl = [Name:sthg, Department:Dept \n, BOSS:EmpZ , Colleague:{E~pZ }] type Dept = [Namewing, Manager:Empl ] Empl : {Empl } Dept : {Dept } \nIn order for this transformation to be a database query on objects, the results should at least be sets \nof objects preserving the mutual dependency of the original sets of objects. Furthermore, we also expect \nthat an object in Empl (Dept ) and corresponding object in Empl (Dept, respectively) denoting the same \nreal-world entity share the same identity, so that we should be able to perform various other queries \non objects through those sets such as identity test for two objects taken from each of the two sets Empl \nand Empl , or computing the intersection of two subsets of the sets. This sort of transformation is routinely \ndone in the relational model, and is the basis for view definitions. Unfortunately, however, none of \nexisting proposals of object-oriented database query languages allow us to perform such a query processing. \nThe apparent difficulty is the preservation of object identity while performing transformation of structures \nof objects. In most of object-oriented data models, the identity of an object is determined based on \nan oid attached to a record representing the object, and therefore a record in Empl and one in Empl cannot \nshare the same identity. A simple approach to get around this difficulty is to restrict queries to be \nthose that can be constructed by navigation and selection [BKK88], disallowing any query that changes \nthe structures of objects such as the example above, and eliminates the possibility of flexible view \ndefinitions. In [Bee95], Beeri discussed several desireble features in a formal model of an object-oriented \ndatabases. The query languge sketched in his proposal is, however, based on the approach similar to [BKK88], \nand does not contain proper query mechanism for identity preserving transformation of object structures. \n02 [LRV88, BCD89] allows queries that construct new structures by distinguishing values from objects \nand insisting that the results of such queries should be values. The drawback of this approach is that \na structure transforming query does not preserve properties of objects including sharing relations and \nobject identity. In some languages, so called object-creating queries are allowed [AK89, Day89, SZ89, \nKim89, Cat94]; the result of an object-creating query is new objects independent of any existing ones. \nOf course, creation of new objects is sometimes necessary, but this mechanism can not be a substitute \nfor the ability to transform the structures of existing objects while preserving their identity. In order \nto obtain a sufficiently expressive query language for objects with identity, we need to develop a general \nmechanism for writing identity preserving queries. There are some attempts [SS90, AB91, Run921 to support \nidentity preserving queries and views. However, their approach is just to support primitives for dropping \nor adding methods to the classes to which objects belong, and there seems to be no general mechanism \nto write identity preserving object transformation such as the example above. We believe that the source \nof the difficulty is the lack of a proper formalism for manipulating complex objects with identity. As \nis done in the relational model, one way to solve the problem is to construct a proper semantic domain \ntogether with a set of primitive operations to form a sufficiently rich algebra to represent databases \nand queries. Let us turn to the second issue of parallel processing of object-oriented database queries. \nA database consists of a large collection of data elements. One of the most promising paradigms for parallel \nprocessing on such a large collection of data is data-parallelism, which is based on the mechanism of \napplying the same operation to each data item simultaneously. This paradigm works well for relational \ndatabases in which each relation is represented as a collection of independent tuples, and several parallel \ndatabases [DG92, YCWT93] have been developed based on this paradigm. However, object-oriented databases \nseem to be difficult to be integrated with the paradigm of data-parallelism because of the existence \nof navigation. For example, suppose a database of the ancestry trees of viruses is defined as a set of \nobjects of the following type. type Virus = [Code:string, Ancestor:Virus] The Ancestor field contains \nan oid for the immediate ancestor. Now consider the problem of transforming the set into the following \nform type Virus = [Code:string, Origin:Wrus] by finding the origin of each virus. To perform such a \ntransformation, all the ancestors for each virus ob-ject must be traversed, until the origin is reached. \nThe current practice in object-oriented database program-ming is to combine a database query language \nwith a programming language with recursion and to resort to general recursive programming. This rather \ncrude ap-proach loses the benefit of set-based declarative query processing and yields complicated programs. \nMore se-riously, recursively traversing oid s (in Ancestor field in this example) sequentializes the \noid dereference op-erations, and requires the time proportional to the maxi- mum height of the ancestry \ntrees. However, as we shall show later, there is a data-parallel algorithm that per-forms such traversals \nin logarithmic parallel steps. To achieve an object-oriented query language supporting data-parallel \nqueries, we must develop a mechanism for parallel object transformation including navigation. The goal \nof this paper is to develop an object-oriented data model that achieves identity-preserving object transformation \nand data-parallel query with navigation. There are other important features in object-oriented databases \nsuch as inheritance. Although the present paper does not consider such features, we believe that the \nbasic framework for representing objects with indetity will be extended with those other features. We \nwill briefly comment on this issue in Section 7. The basis of our development is to regard an object- \noriented database as a system of equations over object identifiers. This general idea is not entirely \nnew. In IQL [AK89], a database is represented by a set of oid s associated with a function that maps \noid s to the associated values. A similar structure is used in ILOG [HY90]. The structures used in these \nmodels can be seen as representations of system of equations. Indeed, representing an object-oriented \ndatabase as a system of equations is just a way to represent a set of objects interconnected by oid s, \nand this alone does not solve the problems mentioned above. Our proposal is based on the following two \nkey observations: 1. A database query is an operation to compute a new system of equations from a given \nsystem of equations. 2. An object identity corresponds not to a single oid in a system of equations \nbut to an equivalence class of oid s induced by queries. The oid s belonging  to an equivalent class \nall correspond to the same real-world entity. This first feature enables us to recover the desirable \nclosure property of database queries: the result of a query remains the same semantic domain of databases. \nBy combining some of the authors recent results [N095], we can also overcome the sequentiality of traversing \nobject identifiers and develop a data-parallel evaluation scheme for database queries. A database can \nnow be regarded as a collection of equations, each equation can be transformed in parallel. The second \nfeature enables us to develop an identity preserving query language. In most of the existing object-oriented \ndata models, object identity is regarded as an oid itself. We observe that this is the source of the \ndifficulties in developing a query algebra for objects mentioned above. In contrast to those existing \nones, object identity in our model is up to an equivalence relation between oid s induced by queries: \ntwo objects have the same identity if the oid s of the two objects belong to the same equivalence class. \nWhen a query generates a new system of equations over a new set of oid s from a given system of equations, \nthe equivalence relation is extended to relate each new oid in the new system with the corresponding \noid in the source system. The general idea of maintaining equality among multiple objects corresponding \nto one real-world entity was also exploited in several proposals in the context of versions of objects \n[CK86, KSW86], and views or roles of objects [HZ90, ABG093J. However, in these proposals, the maintenance \nmechanism of equivalence relation between oid s is designed for specific purposes, and is not an integrated \npart of a query language. In [KC86], various forms of equality relations among objects are discussed, \nbut none of them can be applied to express the correspondence between different views of the same entity \ndiscussed above. To our knowledge, there is no query language that systematically maintains object identity \nduring general query processing. Based on these two features, we develop an object-oriented data model \nand its data-parallel query language, which allows us to write data-parallel queries to trans- form complex \n(possibly mutually dependent) structures to another structures while maintaining identity of ob- jects. \nFor example, the object set Empl mentioned at the beginning of this paper is represented by a system \nof equations over a set of oid s. Transformation of this set into a new set Empl of objects is done by \ngenerating a new system of equations from the system of equation over the oid s in Empl by a data-parallel \ntransformation. In this transformation, the equivalence relation is gen- erated to relate each oid in \nEmpl and the corresponding oid in Empl . The rest of the paper is organized as follows. In Section 2, \nwe explain the semantic domain of our object-oriented data model. Section 3 develops a language to define \nand manipulate object-oriented databases. Section 4 demonstrates its usefulness by examples. In particular, \nwe show that our model support identity preserving queries and object-oriented views. Section 5 shows \nthat the query language supports data-parallel query processing involving navigation. In Section 6, we \nbriefly describe both sequential and parallel implementation strategies of the language. Finally, Section \n7 concludes this paper.  Semantic Structure of the Data Model This section describes a semantic structure \nunderlying the object-oriented data model proposed in this paper. The operations for writing database \nqueries will be given in the next section by defining a language to create and manipulate the structure \ndescribed in this section. The top level semantic structure is a database, which is a triple (S, 0, C) \nwhere S is a schema describing the type structure of the database, 0 is a schema instance representing \nobject structures, and C is an oid cZassi$cation into classes. In what follows, we explain each of these \ncomponents. To define the structure of a schema, we need to define the set of types in the model. Here, \nwe consider the set of types given by the following grammar:  7 ::= t 1 b 1 [e: T,. . . ,e : T] 1 {t} \n1 class(t) t stands for a denumerable set of type variables, which are used for types of oid s. Intuitively, \na type variable corresponds to a class name in usual object-oriented systems. b stands for a given set \nof atomic types for various atomic values such as integers. [!, : 71, . . . , .&#38; : 7.1 is a record \ntype we have already explained. {t} is a set type whose element type is type variable t. This implies \nthat sets are restricted to be those of oid s. A set of values of atomic or structured type, however, \ncan be expressed as a set of oid s by using the mechanism of schema and schema instance which will be \nexplained below. class(t) is a class type whose element is oid s of type t. A set of oid s of type {t} \nis called a class and has class type class(t), if it satisfies a particular condition which will be given \nlater when we define typing relation. Note that class(t) is a subtype of {t} and therefore that a set \nof type class(t) also has type {t} . A schema S is then defined as a system of type equations of the \nform: with an associated equivalence relation 2s on the set of type variables {t 1, . . . , tn}. We require \nthat the set of type equations is closed, i.e. tl, . . . , t, are pairwise distinct and all the type \nvariables occurring in ~1, . . . , r, belong to the set { tl , . . . , tn}. Each equation ti = ri describes \nthe fact that an oid of type ti has the associated value of type q, and determines the type structure \nof class(ti). Since tl, . . . , t, may appear in any of ?-l,...,TnTn, the entire schema definition represents \nthe structure of mutually dependent classes of objects. The associated equivalence relation Es denotes \nthe property that if tl gs t2 then tl and t2 represent two different classes that correspond to the same \nset of real-world entities . How this relation is maintained will be given later when we define query \nprimitives. To define schema instances, we first define the set of possible object values (ranged over \nby 0) by the following grammar: O::=o(aI [i?=O )...) e=o] I(0 I,..., On} where o stands for a denumerable \nset of oid s and a for a given set of atomic constants. As mentioned above, we restrict sets to be those \nof oid s. A set of values of atomic or structured type, such as a set of integers, are expressed as a \nset of oid s { 01,02, . . . , on} with the following set of equations over oid s: {ol = 3, o2 = 5,. . \n. , o, = 38) The type of this set is expressed as {t} with a type equation t = int in S. Representing \nsets of values in such an indirect way, though it seems to be somewhat inefficient, enables a uniform \ntreatment of ordinary sets of values and sets of objects. A schema instance 0 is defined as a system \nof closed oid equations of the form: {o,=O I,..., o,=O,} . Schema Empl = [Name:string, Salary:int, Department:Dept, \nBoss:EmpE], Dept = [Name:string, Manager:EmpZ] s= Empl = [Name:string, Department:Depl , Boss:EmpZ , \nColleague:{EmpZ }], Dept = [Name:string, Manager:EmpZ ] Type equivalence: Empl Zs Empl , Dept 2s Dept \n. Schema instance mary [Name= Mary , Salary=6850, Department=director, Boss=mary], john [Name= John \n, Salary=3770, Department=accounr, Boss=mary]: [Name= Judy , Salary=3 120, Department=accoun&#38; Boss=john], \njudy director [Name= Director , Manager=mary] , account [Name= Account , Manager=john], mary [Name= \nMary , Department=directo#, Boss=mary , Colleague={ }], john [Name= John , Department=account , Boss=mary \n, Colleague={judy }], judy [Name= Judy , Department=account , Boss=john , Colleague={john }], director \n[Name= Director , Manager=mary ], account [Name= Account , Manager=john ], Oid equivalence: mary go \nmary , john 20 john ,judy + judy , director + director , account Z: o account , . Oid classification: \n C(Empl) = {mary,john,judy}, C(Dept) = {director, account}, C( Empl ) = { mary , john , judy }, C(Dept \n) = {director , account } Figure 1: A Well-Typed Database associated with an equivalence relation + \non the set of . a : b whenever a is an atomic value of an atomic oid s { 01, . . . .on}. A schema instance \n0 represents a set type b. of mutually dependent objects. The intended meaning . o : t whenever o E C(t). \nof the equivalence relation ZQ is that if 01 go 02 then 01 and 02 are the different views of the same \nreal-world . [!, = 01,. . . , !, = 0,] : [.!!I : 71,. . . ,&#38; : T-~] if entity. 0, : T] ) . . . \n) 0, : 7-n. An oid classification C is a finite map from type . . ,o,} : ... if (01,. . . ,o,} C_ C(t). \n variables to sets of oid s. For each type variable . ..... t E domain(C), C(t) indicates the set of \nall the oid s . (01,. * * , on) : class(t) if (01,. . . , on} = C(t) and of type t. 0 gu oi for some \noi for all 0 E C(s) s.t. s 2: s .. A database, represented by a triple (S, 0, C) consist- ing of the \nabove structures, must be type consistent. To The first four express natural typing condition for each \ndefine the type consistency, we first define typing re-structure. The last rule describes the condition \nfor a set lation 0 : 7 of object values by the following set of of oid s of type . to be a class of type \nclass(t): the set rules: must contain all the oid s of type . and every oid in the set must has an equivalent \noid of type s for all s such that s Q t. The well typing condition of a database (S, 0, C) is now given \nby the following conditions: a t E domain(C) iff t = 7- E S for some T. . If o = 0 E c? then there exists \nt = T E S such that o E C(t) and 0 : 7. . If C(t) n C(S) # 8 then t E s. . If o1,02 E C(t) and 01 go \n02 then 01 z 02. . If 01 Zo 02 and 01 E C(t) and 02 E C(s), then . =: s s. Databases of the form (S; \n0, C) satisfying the well typing conditions form the semantic domain of our data model. As we noted in \nthe beginning of this section, the semantic structures presented in this section only describes a snapshot \nof the state of a database. Our major contribution is to show that a declarative query language can be \nconstructed for creating and manipulating these semantic structures. We show in Figure I an example of \na well-typed database state. This is a database of employees and de- partments we considered in Section \n1. The database consits of four classes: { mm-y, john, judy} of type czass(Empz), {d zrec . OT, account} \nof type cZass( De@), {m-y , john , jady } of type class (Empl ), and {director , account } of type cluss(Dept \n). The latter two are the classes that would be derived from the for- mer ones by an identity preserving \nquery, and the query induces the equivalence relations over type variables and oid s. The Query Language \n We are now in position to define a query language for object-oriented databases whose models are described \nin the previous section. In this section, we describe the syntax of each construct, its typing constraint, \nand its semantics as the effect on a given database state. We use the following operations on records \nand oid s: PI =uuI ,...,&#38;=v~] defines a record with vi for the value of each field &#38;, as seen \nin the examples. X.t selects the value contained in the filed e of X. If o denotes an oid, then value(o) \nreturns the value associated with the oid. As a convention, we usually omit value if it is combined with \na field selection operation. That is, o.Field is an abbreviation for value(o).Field. We also assume the \navailability of standard primitive operations on atomic types such as integer arithmetic operations. \nThe constructs of the language falls into five categories: class creation, set operations, identity preserving \ntransformation, oid operations, and reduction operation. 3.1 Class Creation The query language provides \ntwo ways to define classes of objects. The first is to define a set of mutually dependent classes by \nenumerating all the objects in each class using the following construct: class Namel={ol,l=Ol,l,. . . \n,~I,~(I)=~I,,(I)) and Name2={02,1=02,1,. . . y02,n(2)=02,n(2)) and Name,=(o,,l=O,,I ,. . . ,o,,,(,)=%,~(~)) \nend where each Namei is a program variable in the language bound to a class of objects, Oi,j's are object \nvalues, and 0~'s are oid descriptors for the corresponding objects. The oid descriptors can appear in \nany object value 0~ to refer to the corresponding oid, allowing mutually dependent object definitions. \nThe declaration works as an operation that defines m new classes and registers them in the database. \nIt extends the schema S with the set of type equations {t 1 = rl , . . . 7t m--TV}, provided that the \nfollowing typing relation holds: Oi,j : pi for any i?j under the assumption that ok,l : tk holds for \nall k, 1, where each tk is a fresh type variable introduced for each Namek. In accordance with the extension \nof the schema, the schema instance is extended as follows: First, for every i (1 5 i 5 m), a set of new \noid s { OQ , . . . , o~,~(~)} is created and the schema instance c3 is expanded with the set of oid equations \n{OQ = oi,j ( 1 5 i 5 m, 1 5 j < n(i)} where each Oi,j is the value denoted by Oi,j. Next, each program \nvariable Namei is bound to the set of oid s {%,I, + . . , o~,~(~)}. Finally, the oid classification C \nis augmented so that each ti is mapped to the set of oid s {@,I > * * * , o~,~(Q}. The type of each Namei \nis therefore czass(t~). In Figure 2, we show an example of class declaration which defines a part of \nthe database of employees and departments in the previous section. The example class Empl = {mary=[Name= \nMary ,Salary=6850,Department=director,Boss=mary], john=[Name= John ,Salary=3770,Department=account,Boss=mary], \njudy=[Name= Judy ,Salary=3120,Department=account,Boss=john]} and Dept = {director=[Name= Director ,Manager=mary], \naccount=[Name= Account ,Manager=john]} end Figure 2: A Class Creation Example declares mutually dependent \ntwo classes denoted by Empl of type cZuss(Empl) and by Dept of type cZass(Dept). In the declaration, \nthe oid descriptors mary, john, . . . denote new oid s mary, john, . . . . respectively. This declaration \nbounds program variable Empl to the set { mury, john, j&#38;y} and Dept to {director, account}. It also \nadds type equations for Empl and Dept to the schema S, and oid equations for mary, john, judy, director, \naccount to the schema instance 0. The oid classification C is augmented so that Empl and Dept are mapped \nto the corresponding sets of oid s. The other way to create a class is to use the following construct: \nclass M from xl in X,, . . . . xn in X, where P where XI,..., x, may appear in M and P. This construct \nworks as follows. Let each Xi has type {ti}. If M has type T under the assumption that Xl : t,,...,xn \n: tn. then the schema S is augmented with the equation t = 7 where t is a new type variable introduced \nfor the new class. Then this expression has type class(t). The schema instance is augmented as follows. \nFirst, the product is generated from the sets of oid s X1, . . . ,X,. Then, for each product element \n(01,. . . , o,), the following operation is simultaneously performed: each xi is bound to oi, and under \nthis binding, if the predicate P holds, then M is evaluated to object value 0, a fresh oid o for 0 is \ncreated in the new class being defined, and the schema instance c3 is augmented with the equation o = \n0. The oid classification C is augmented so that t is mapped to the set of the new oid s.  3.2 Set Operations \nSet expression of the form: (0, ,02,. . .,O,} defines a set of oid s. If each Oi denotes an oid of type \nt, then the expression returns the set of the oid s, and the result type is {t}. Otherwise, if each Oi \nis a value of atomic or structured type 7, then it returns a set of new oid s (01 i . . . , on}, and \nthe schema instance 0 is augmented with the set of oid equations (0, = 0 I,..., on = 0,} where each Oi \nis the value evaluated from Oi. The result type is class(s) where s is a fresh type variable. The schema \nS and the oid classification C is augmented with the equation s = 7 and the map from s to the set { 01, \n. . . ! o,}, respectively. The basic operations on sets are union and intersection of two sets of oid \ns written as XUYand XflY, respectively, where both X and Y must have the type either {t} or class(t). \nThe type of the result of intersection is {t}. The type of the result of union is class(t) if either \nof the two sets has type class(t); otherwise the result type is {t}. In the spirit of SQL and set comprehension \nin programming languages, the language also support general set selection whose syntax is: select M from \nxl in XI, . . . . x, in X, where P where each Xi must be a set of oid s and P is a predicate. This corresponds \nto the mathematical set comprehension notation {M 1 (x1 E Xl) A ... A (x, E X,) A P}. The evaluation \nproceeds as follows: First, the product of the n sets of oid s are created, and then M (and P) is evaluated \nsimultaneously for each of the products. The resulting set has type {s} if the type of Xi is {ti} for \neach i and M has type s under the type assumption Xl : t, ). . . ,x, : t,. For example, select x from \nx in Empl where x.Salary>4000 returns the subset of Empl whose salary is greater than 4000. The type \nof the resulting set is { EmpE}.  3.3 Identity Preserving Transformation: Parallel Map Parallel map \nis the main feature of our language, which allows us to transform a set of classes of objects into another \nset of classes of possibly different structure preserving the object identity up to equivalence relation \nof oid s. This operation is derived from the mechanism developed in [NO951 for data-parallelism on recursive \ndata, and is the main source of parallelism of the language. The significance of data-parallel database \nquery will be discussed in Section 5. The syntax for parallel map is given as follows: map M foreach \nx in X The intuitive meaning of this construct is to transform the structure of a class X by simultaneously \napplying an operation (represented by a function Xx.M) over the values of every objects in X. The types \nof this expression is determined as follows. Suppose X has either a set type {t} or a class type class(t) \nsuch that t = T E S. A fresh type variable s is introduced, and the type equivalence relation is augmented \nby the equivalence t + s. If the type of M is 7 under the type assumption X: 7, the schema S is augmented \nwith the type equation s = 7 . The resulting set has type {s} (class(s)) if X has type {t} (class(t), \nrespectively.) The execution of this operation is as follows: suppose X is a set of oid s @I, * ..,o,}andoi=Oi~(3foreachi.Asetofnew \noid s {o ,, . . . , oh} is first created, and the equivalence relation is augmented with the equivalences \noi Zo 0: (1 5 i 5 n). For each i (1 5 i 5 n), x is first bound to the corresponding object value Oi and \nthen the map operation M is evaluated to a value 0: of type 7 . (In this step, the map operations are \nexecuted simultaneously.) Finally, the schema instance 0 is expanded with the set of equations (0: = \n0;) . . . ,oL = OL}, and the set ofoid s {o;,... , ok} is returned as the result. The oid classification \nC is augmented so that s is mapped to the set of the new oid s {o , , . . . , o;}. A simple parallel \nmap example follows: let Empl = map [Name=x.Name, Department=x.Department] foreach x in Empl which creates \nanother restricted view of the class Empl. It is also possible to apply several parallel maps to a set \nof mutually dependent classes and to create another set of mutually dependent ones, as shown in Section \n4, with the following concurrent let construct: let Xl = map . . . and X2 = map . . . . . . and X,= map \n. . . end  3.4 Oid Operations There are three oid operations: value(o) oid dereference, M=M equivalence \nchecking, and M as X oid coercion. We have already introduced the oid dereference at the beginning of \nthis section. M=M checks equivalence between arbitrary two values. If M and M denote two oid s, say o \nand o , respectively, then the expression returns true if o Eo 0 ; it returns false otherwise. This equivalence \nchecking for oid s is extended to that for arbitrary values in the obvious way. M as X is a powerful \nfacility to coerce an oid denoted by M to its equivalent oid in the set of oid s denoted by variable \nX. The type of this expression is therefore the type of the oid s belonging to X. The program variable \nX can be the one being defined in aconcurrent let construct. This facility makes it possible to update \na class of objects while preserving the dependencies between the objects. Consider the following example: \nlet Empl = map [Name=x.Name, Department=x.Department, Boss=(x.Boss as Empl )] foreach x in Empl . x.Boss \nas Empl coerces the oid denoted by x.Boss that belongs to Empl to the equivalent oid which will belong \nto the new set Empl being defined. (If there are multiple occurrences of the same name, the inner-most \nbinding of the form Empl =... enclosing the coercion operation is selected.) The resulting set of oid \ns has type {Empl } such that Empl = [Name:string, Department:Dept, Boss:EmpZ ], and is a new view of \nclass Empl. Due to the effect of the coercion operator, the BOSS field of every object in the new class \nis assigned an oid in the new class that shares the same object identity with the equivalent oid in the \noriginal class. The coercion facility also can be used to define more powerful operations such as update \nof database, as will be noted in Section 4. M as X does not work for arbitrary set X of oid s, even if \nthe oid s in the set is created from the class to which the oid denoted by M belongs. This is because \nthe set X may be created from a subset of the original class generated by a select operation. In such \na case, the oid being coerced may not have the corresponding oid in X. This difficulty is circumvented \nby our distinction of sets by the two types {t} and class(t), the latter of which guarantees that the \nset contains an equivalent oid for every oid of type s such that s Es t. The typing constraint for the \ncoercion operator is therefore stated as follows: M as X is allowed only if M has type t, X is the name \nfor the value of type class(s), and the equivalence relation s 2,~ t holds.  3.5 Reduction Operation \nFollowing approaches for querying database collections [TBN91, BNTW95] and set operations in database \nprogramming languages [BBKV88, B096], we include the following general aggregate operation: reduce X \nwith unit=E, op=@ where X has type {t} with t = 7 E S, @ is an associative and commutative binary operation \non the values of type T that returns a value of type T, and E is a unit element for the binary operation. \nIf X is a set { 01, . . . , 0,) (n 2 0) such that oi = UU~E 0 (for each i, 1 < i < n), the result of \nthe reduction operation is E ~3 vi @ . . . @ u,. For example, let Salary = map x.Salary foreach x in \nEmpl in reduce Salary with unit=O, op=+ returns the sum of salary of all the employees. The reduction \noperator works as the set flattening operation if it is combined with the set union operator: reduce \nS with unit={ }, op=u where S denotes a set of sets and {} denotes the empty set. The reduction operation \nis also a source of data- parallelism, as will be noted in Section 5. 4 Query Examples and Language \nExtensions In this section, we first show some examples of object-oriented database queries and then \ndescribe the extensions of the language for views and updates. 4.1 Examples of Queries Suppose the following \ntype equations are defined in the schema: EmpZ = [Name: string, Salary:int, Department:Dept] Dept = [Name: \nstring, Manager: EmpZj and Empl and Dept are bound to classes of type class (Empl) and cluss( Dept) respectively. \nThe first example is a simple projection on these classes. Suppose the user is only interested in the \nname of each department and the name of the managers of each department. The query below projects those \nattributes and bound the result to Dept : let Dept = map [Name = x.Name, MngrName = x.Manager.Name] foreach \nx in Dept This query is a usual relational-style query, and forgets the sharing relation between the \nclass of employees on Manager attribute. There are cases, however, where we want to reflect the sharing \nrelation between the two classes of employees and departments in the query result. The following is an \nexample of such a query: let Dept = map [Name = x.Name, Manager = (x.Manager as Empl )] foreach x in \nDept and Empl = map [Name = x.Name] foreach x in Empl end The sharing relation on Manager attribute is \nretained by coercing the original oid to the corresponding oid in the new class Empl . Next, we show \nan example of a more complex transformation of the class Empl to different structure. The query below \ncomputes the colleagues of each employee, i.e. the employees belonging to the same department, and add \nthe result as a new attribute Colleague. The result of the entire query is bound to Empl : let Empl \n= map [Name = x.Name, Department = x.Department, Boss = x.Boss as Empl , Colleague = select (o as Empl) \nfrom o in Empl where (x.Department=o.Department A x.self#o)] foreach x in ,Empl In this query, we have \nassumed that each object value is, when parallel map is applied, automatically augmented with the additional \nfield self that contains the oid of the object itself. In the rest of the paper, we assume this convention. \nIn a relational database, the query above should be done through joins. In our model, we can extend each \nemployee object directly so that it includes the related objects, while preserving the identity of Empl \nobjects. Note also that the objects in Colleague attribute belong not to the old class Empl but to the \nnewly created class Empl . This allows us to continue query processing by issuing a new query on Empl \nas shown in the following example. select o.Name from o in Empl where (select 02 from 02 in o.Colleague \nwhere #(o2.Colleague) > 10) # {) This query returns the names of employees that have a colleague who \nhas more than 10 colleagues. In the query, # stands for a function that returns the number of elements \nof a given set. # X can be expressed by a com- bination of a parallel map and a reduction operation as: \nreduce (map 1 foreach x in X) with unit=O, op=+. These examples demonstrate that our model success-fully \nintegrates the benefits of both relational databases and object-oriented databases. In our model, we \ncan easily write a set-based declarative query that transforms classes objects into new classes of different \nstructures that preserve object identity and the mutual dependence relation among objects. The next example \nshows an object-creating query using class . . . from . . . where. . . construct. Suppose there is a \nclass of objects of type class(Computer) defined as: Computer = [Hostname: string, Type: string, AssignedTo: \nDepartmenf]  Assuming that each employee is privileged to use only the computers that are assigned to \none s department, the following query computes the class of objects ComputerAccount by joining Empl and \nComputer belonging to the same department: let ComputerAccount = class [Emp = 01, Cmp = 021 from 01 in \nEmpl, 02 in Computer where 01 .Department = oZ.Department  ComputerAccount has type class( ComputerAccownt) \nwith a type equation ComputerAccount = [Emp : Empl, Cmp : Computer]. The query in Figure 3 transforms \nthe classes Empl and Dept defined above into mutually dependent classes using the coercion operator as. \nThe query adds Manager attribute to the employee objects, adds Member attribute to the department objects, \nand creates a new set Mngr of managers from Empl as a set of objects having Name, Managing, and Subord \nattributes. Managing is the set of departments one manages, and Subord is the set of members of the department \none manages. Note that the query retains the mutually dependent structure between the objects. This is \naccomplished by coercing some oid s to those of newly created objects by using as. There is one subtle \npoint to be made in this query: the objects assigned to Manager field of Emp2 and Dpt2 are coerced to \nthe objects in Emp2. Although it may be more appropriate to coerce them to the objects in Mngr, the typing \nconstraint does not allow it, since the type of Mngris not class(t) but{t}. In this particular case, \nwe see that employee objects referred to through Manager attribute always have corresponding objects \nin Mngr, and therefore coercing them to Mngr never causeserrors. Such an analysis could be incorporated \nin our model by using some techniques in programming language research such as abstract interpretation, \nbut we do not discuss the issue in this paper. As shown in the example above, parallel map and as construct \nprovide us with a uniform way to transform a class of objects into another class of objects of arbitrary \nmutually dependent structure. Moreover, transformations induce and maintain the equivalence classes of \nthose objects representing the same real-world entity. For example, in the query shown in let Emp2 = \nmap [Name = x.Name, Department = (x.Department as Dpt2), Manager = (x.Department.Manager as Emp2)] foreach \nx in Empl and Mngr = map [Name = x.Name, Managing = (select (o as Dpt2) from o in Dept where o.Manager \n= x.self), Subord = (select (o as Emp2) from o in Empl where o.Department.Manager = x.self)] foreach \nx in (select o.Manager from o in Dept) and Dpt2 = map [Name = x.Name, Manager = (x.Manager as Emp2), \n Member = (select (o as Emp2) from o in Empl where o.Department = xself)] foreach x in Dept end Figure \n3: Transforming Mutually Dependent Classes Figure 3, objects in Empl, Emp2, and Mngr are properly related \nby the equivalence relation. This enables us to perform identity test among the objects belonging to \ndifferent types of classes. For example, the following query is possible. select 01 .Name from 01 in \nMngr, 02 in Emp2 where 01 = 02 A o2.Department = Account This query returns the names of employees who \nis a manager of some department and is also a member of the account department. In other words, this \ncomputes the intersection of Mngr and the set of all members of the account department. 4.2 Extension \nfor Views and Updates The facilities for writing a set-based and identity-preserving query immediately \nyield identity-preserving view mechanism; as in relational databases, a view is just an unevaluated query. \nFor example, the query in Figure 3 can be changed to a view definition only by replacing the keyword \nlet with a keyword view. view . . . and . . . end construct is the same as let . . . and . . . end except \nthat the evaluation is delayed until one of the names defined in the construct is referred to. After \ndefining this view, Emp2, Mngr and Dpt2 are used as classes in a query such as: select o.Manager.Subord \nfrom o in Emp2 where o.Name = John which is evaluated by first materializing all the classes defined \nin the view, and then evaluating the query itself. In relational databases, only the relations that are \nreferred to in the query need to be materialized. In our model, however, all classes defined in a view \nconstruct need to be materialized even if some of them are not yet referred to because they may have \nmutual references. We can also describe update of database by means of parallel map and oid coercion. \nConsider a hypothetical update query in Figure 4(a). The query intends to update the database by adding \n100 to the salary of all the employees in the account department. We can translate the hypothetical query \nto a query written by means of our query primitives as shown in Figure 4(b). This updating query indicates \nthat updating objects is equivalent to mapping the target objects (here, employee objects) to new objects, \nand switching all references to the target objects into references to the new objects. In the example \nabove, all the objects in Dept need to be mapped because they have references to employee objects. In \nthis way, any update query can be systematically transformed to a query composed of parallel map and \noid coercion, by analyzing type dependence. Furthermore, updates that alter the type of objects are also \nallowed. The straightforward update Empl=[Name=Empl.Name, Salary = (if Empl.Department= Account then \nEmpl.Salary+lOO else Empl.Salary), Department=Empl.Department] end (a) A Hypothetical Update Query let \nEmpl= map [Name=x.Name, Salary=(if x.Department= Account then x.Salary+lOO else x.Salary), Department=(x.Department \nas Department)] foreach x in Empl and Dept = map [Name = x.Name, Manager = (x.Manager as Empl)] foreach \nx in Dept (b) A Translated Query Code Figure 4: An Update Query execution of the translated code may \nnot be as efficient as the corresponding in-place update that may be possible in some imperative language. \nHowever, some optimizations are possible. For example, we can discard the old data, since they are replaced \nby the updated data and are never referred to. In the case the type of objects are not changed, we can \ntranslate the update query to the code performing in-place update.  5 Data-Parallel Processing of Database \nQueries The proposed paradigm of an object-oriented database query language is suitable not only for \nidentity preserving transformation of classes of objects, but also for achieving data-parallel query \nprocessing on parallel machines, especially on recently emerging massively parallel distributed memory \nmulticomputers. The paradigm has two desirable properties. First, it easily scales up with respect to \nthe number of processors. Secondly, we can apply a class of data-parallel algorithms for parallelizing \nqueries including navigations. 5.1 Data-Parallel Query with Navigations The mechanism of parallel map \nachieves data-parallel evaluation of a query on a collection of objects in the obvious way, if the map \noperation does not include any navigations. However, as mentioned in the introduction, navigations sometimes \nconflict with parallelization. Suppose a database contains the following class describing the ancestry \ntrees of viruses: class Virus = { iadhk=[Code= IADHK ,Ancestor=iadhk], iadhl =[Code= IADHC , Ancestor=iadhk], \niab37=[Code= IAB37 , Ancestor=iadhk], iackb=[Code= IACKB ,Ancestor=iackb], iackj =[Code= IACKJ , Ancestor=iackb], \niackg=[Code= IACKG ,Ancestor=iackj], iacka=[Code= IACKA ,Ancestor=iackg], . . . and more and more.} \nend where the fields Code and Ancestor respectively indicates each virus s identification code and the \nimmediate ancestor; in the case the ancestor is unknown, the Ancestor field is specially set to the oid \nof the object itself. On this database, consider the following query: detecting the origin of each virus. \nProcessing this query requires traversing virus objects recursively via the oid contained in the field \nAncestor. The conventional way of implementing the required traversal as a recursive program, however, \ndoes not achieve the desired parallelization, particularly when the class Virus contains a long chain \nof the ancestor 15 \\ (4 f 16 17 (cl b-4 Figure 5: The Data-Parallel Root Finding Algorithm in a Forest \nof Objects relation. This is because each recursive computation must wait until the successive recursive \ncomputation finishes, i.e. the recursive program sequentializes the oid dereferences. Moreover, if the \nancestor relation has many confluences, i.e. there are many objects to which multiple Ancestor pointers \ngo, much redundant duplications of computation are generated. In the following, we show how this difficulty \ncan be overcome by combining parallel map and the technique of pointer jumping [Jaj92] which is well \nknown in the field of imperative data-parallel programming. The above query can be regarded as a problem \nof finding the root nodes in a forest illustrated in Figure 5 (a). parallel algorithm based on for this \nroot finding problem. of the following data-parallel to the parent in each node by its reference s reference, \nshown in Figure 5 (b). This of trees such as the one There is an efficient data-pointer jumping technique \nThe algorithm is iteration operation: the reference is simultaneously updated resulting new structure \nas operation is repeated until all the reference in every node is set to its root node (Figure 5 (c)). \nSince every reference is doubled in each iteration, every pointer in a forest of trees of N nodes refers \nto the root node at most after 0 (log, N) iterations. This algorithm can be directly applied to the above \nquery by regarding the dots, the integer numbers, and the arrows in the figure as objects, oid s, and \nreference relations, respectively. The pointer jumping technique can be used to write a wide range of \ndata-parallel algorithms including not only root finding but also parallel prefix, tree contraction, \nand so on. If we are able to describe such we can achieve effective queries including object work [N095], \nit has been algorithms in our language, parallelization of various traversals. In the previous shown \nthat various parallel algorithms based on the pointer jumping technique can be expressed in a declarative \nprogramming language through the notion of parallel recursion, which is a process of repeatedly transforming \na system of equations by parallel map into another system until the final result is obtained. Our query \nlanguage is also designed to be able to express parallel recursion on classes of objects. As parallel \nrecursion is iteration of parallel map, it is sufficient to introduce the following primitive for bounded \niteration. iterate N times do X=M end In this construct, N is an integer which indicates the number \nof iterations, and M is the code for each transformation. The transformed class of objects is assigned \nto the variable X in each iteration. For example, the following code creates a class of new virus objects \nby replacing the Ancestor field in each object in the class Virus with the Origin field that is assigned \nthe oid of its most distant ancestor: let Virus = map [Code=x.Code, Origin=(x.Ancestor as Virus)] foreach \nx in Virus end; iterate log(#Virus) times do Virus = map [Code=x.Code, Origin=(x.Origin.Origin as Virus)] \nforeach x in Virus end where # Virus is the number of oid s contained in the class and log is the logarithm \nwith base 2. The query first transforms the class Virus to the class of type cZass(Virus ) with type \nequation Virus = [Code : string, Origin : Vim ] where each Origin field is set to its immediate ancestor. \nThen the pointer jumping technique is applied to the class of virus objects by repeatedly transforming \nthe class via parallel map. It is sufficient to iterate log,#Virus for every object to reach its most \ndistant ancestor. Though it is possible to stop iteration just when all the objects reach to the most \ndistant ancestors, testing this condition requires, in each iteration, an additional reduction with a \nboolean operator or over the set of virus objects. We therefore take the way to iterate by a fixed number \nas a gentle solution for termination checking. Implementation Strategy We claim that the proposed model \nserves not only as a formal model to account for object-oriented databases but also as a basis to develop \na practical object-oriented database systems. In this section, we describe two implementation strategies \nof our query language: one for conventional single processor architectures and the other for distributed \nmemory massively parallel multicomputers. 6.1 Implementation on Conventional Single Processor Architectures \nOur set-based query primitives such as parallel map is designed to be evaluated in data-parallel fashion. \nHowever, they can equally well be implemented on a conventional single processor machines. Most of the \nfeatures of our query language can be implemented by using the existing technologies for implementing \ndatabases on conventional architectures, except for the features that is specific to our query language: \noid coercion operation as, equality test between oid s, and oid dereference operation. In order to implement \nthese features, we represent an oid using a pair (i, t) where is an instance identifier and t is the \ntype of that oid. An instance identifier corresponds to a real-world entity, and is shared by all the \nobjects representing different views of the same entity. For example, in the example in Figure 3 that \nderives the class Emp2 from the class Emp, we first introduce a fresh type variable s for Emp2, derive \nobjects for Emp2 from objects in Emp, and then assign an oid (i, 3) to each object for Emp2 where i is \nthe same instance identifier of the source object from which that object is derived. In this way, the \nsame instance identifier is assigned to all objects representing the same entity. By this representation \nof oid s, equality test for two oid s is easily implemented: it just tests the equality of instance identifiers \nof those oid s. Coercion of an oid is also easy. It just changes the type in the oid to the type of the \ntarget class. We can coerce an oid to a class that is being defined, since the type of the target class \nis statically known by a preceding type checking phase. Finally, oid dereference operation is implemented \nas a map from oid s to object values. A map for oid dereference is maintained by the system as a hash \ntable whose key is an oid and the contents of whose entry is the object value of that oid. Since only \nlimited combinations of instance identifiers and types would be used, we use hashing function to avoid \na very sparse table. 6.2 Implementation on Massively Parallel Multicomputers To achieve data-parallel \nexecution of our query lan-guage, we propose an implementation strategy for dis- tributed memory massively \nparallel multicomputers. The basic strategy is, similar to that of conventional data-parallel languages \nsuch as Dataparallel C [HQ91], to evaluate queries in so called SPMD (single program multiple data-streams) \nstyle [Kar87]. In the SPMD execution, every processor executes the same program (compiled code) on its \nown copy of scalar data, while a set of oid s are distributed over the processors by assign- ing each \ndata element (oid) to a distinct processor. In the rest of this section, we assume that underlying hardware \nsystem is a distributed memory multicomputer consist-ing of unbounded number of processors, each of which \nhas a unique processor id. There are four sources of parallelism in the language: the class creation \noperation class, the set restriction operation select, the parallel map map, and the reduction operation \nreduce. Among them, the reduction operation can be effectively parallelized due to binary operator s \nassociativity and commutativity. In particular, if the hardware supports special machine instruction \nfor reduction, it can be utilized for speed up. To achieve parallelization of the other operations, we \nmust invent a run-time representation of schema instance, i.e. system of oid equations, suitable for \ndata- parallelism. In the previous work [N095], a method has been proposed for expressing system of equations \non a massively parallel distributed memory multicomputer model. We can apply this method for implementation \nof our query language with some modifications as follows. Each oid is represented by (p, t), a pair of \na processor id p and the type of the oid t. The processor number p corresponds to instance identifier \nin the implementation strategy for conventional machines. This indicates objects that represents the \nsame real-world entity are assigned to the same processor. A schema instance is represented by maintaining \nin each processor a table that associates each type variable with the corresponding object value. The \nobject value associated with an oid (p, t) is stored in the local table of processor p with t as the \nkey. Note that an oid (p, t) in a processor p has a unique corresponding object value stored in the local \ntable, since no two objects in the same class are assigned to the same processor. Dereference of an oid \n(q, t) in a processor p returns the value stored in the local table with t as the key, if p = q; otherwise, \nit retrieves the value stored in the table of processor q with t as the key via inter-processor communication. \nWhen a parallel map is applied to transform a set of objects represented by a set of oid s {(pi, t) / \n1 5 i 5 n}, every processor pi simultaneously applies the same map operation to the object value associated \nwith t in the local table, and the result value of the map operation is registered to the table with \ns as the key, where s is the type of oid s of the new object set. The parallel map finally returns a \nset of oid s {(Pi, 4 I 1 I i 5 n 1 as a result. An oid equivalence checking between two oid s (p: t) \nand (q, s) returns true if and only if p = q and t ES s. An oid coercion on (p, t) to a set of oid s \nX returns an oid (p, s), where s is the type of oid s belonging to X. The above method is designed to \nwork only in a simple setting. To support full specification of the query language, we must consider \nnested parallelism, i.e. execution of parallel operations in another parallel operation. An obvious way \nto execute such nested parallel queries is to give up nested parallel execution, and to sequentially \nexecute the inner parallel constructs. Such a solution, however, significantly limits the parallelism \nto be exploited. In order to achieve full parallelization, a technique called JIattening has been studied \nby some researchers to support nested data-parallelism in the array based data-parallel languages [Ble90, \nPP93]. They have proposed systematic ways to flatten the nested parallelism, and an array based data-parallel \nlanguage NESL [Ble93], which supports the nested parallelism based on such a method, has been actually \nimplemented. A similar technique may be applicable to our language. A bit of difficulty lies in our data \nrepresentation, the equational data formulation, but the authors believe that the difficulty can be overcome \nby further investigations. 7 Conclusion and Future Work This paper proposed an object-oriented data \nmodel and its query language. We based our development by modeling an object-oriented database as a system \nof oid equations of the form { 01 = 01, . . . : on = O,} which associates each oid oi with a value Oi. \nEvery Oi can include any uj defined within the system of equations for expressing object sharing and \nmutual dependencies. On this model, we developed a query language that transforms a system of equations \nto a new system of equations. We demonstrated that the language can express wide range of transformation, \nincluding those that cannot be described in the existing object-oriented query languages. In our language, \nobject identity is up to an equivalence relation over oid s in the system of equations. This equivalence \nrelation is automatically induced and maintained for each time the system of equations is transformed \nby a query. By this mechanism, the language supports identity-preserving queries and views. Another advantage \nof our model is that it naturally supports data-parallelism. Even those queries that crucially depend \non navigation can be evaluated in a data-parallel fashion in our language. The discussion on our object-oriented \ndata model and query language has been focused on object identity so far. There are some important aspects \nof object-oriented paradigm which are not covered in our proposal. One of most important is inheritance. \nIn object-oriented databases, the term inheritance implies method inheritance, i.e. the ability to share \ncode among classes, and extent inclusion, i.e., hierarchical organization of classes induced by inclusion \nrelation of their extents. A conventional approach is to represent both of them by simple subtype relation \n[&#38;r-88]. This appracoh can certainly be adopted to our model. A more promissing approach would be \nto integrate the model presented here with a polymorphic type system for database programming language \n[B096] based on record polymorphism [Oho95]. As demonstrated in [B096], method inheritance and extent \ninclusion can be more accurately represented by polymorphic typing of record structures. We believe that \nthese features can be cleanly integrated with our model of objects. We have not provided an algebra for \nour query language either. An important further investigation is to develop an algebra that works as \na basis of equational reasoning, query optimizations, and so on. It would be also challenging to develop \na systematic method for flattening nested parallel queries, which will enable us to achieve a full implementation \nof the data-parallel object-oriented query language.    References [AB91] Serge Abiteboul and Anthony \nBonner. Objects and views. In Proc. ACM SIGMOD Conference, pages 238-247, Jun. 1991. [ABG093] [AK891 \n[BBKV88] [BCD89] [BKK88] [Bee951 [Ble90] [Ble93] [BNTW95] [B096] [Car88] Antonio Albano, R. Bergamini, \nGiorgio Ghelli, and Renzo Orsini. An object data model with roles. In Proc. VLDB Conference, pages 39-5 \n1, Aug. 1993. Serge Abiteboul and Paric C. Kanellakis. Object identity as a query language primi-tive. \nIn Proc. ACM SIGMOD Conference, pages 159-173, Jun. 1989. Francois Bancilhon, Ted Briggs, Setrag Khoshafian, \nand Patrick Valduriez. FAD. a powerful and simple database language. In Proc. VLDB Conference, pages \n97-105, Sep. 1988. Francois Bancilhon, Sophie Cluet, and Claude Delobel. A query language for the 02 \nobject-oriented database system. In Proc. Int. Workshop on DBPL, pages 122-138, Jun. 1989. Jay Banerjee, \nWon Kim, and Kyung-Chang Kim. Queries in object-oriented databases. In Proc. IEEE ICDE, pages 31-38, \nFeb. 1988. Catriel Beeri A Formal Approach to Object-Oriented Databases. Data and Knowledge Engineering, \n5:353-382, 1990. G.E. Blelloch. Vector Models for Data-Parallel Computing. MIT Press, 1990. G.E. Blelloch. \nNESL: A nested data parallel language. Technical Report CMU-CS-93- 129, Carnegie Mellon University, 1993. \n Peter Buneman, Shamim A. Naqvi, Val Tannen, and Limsoon Wong. Principles of programming with complex \nobjects and collection types. Theoretical Computer Science, 149(1):3-48, Sep. 1995. Peter Buneman and \nAtsushi Ohori. Poly-morphism and type inference in database programming. ACM Transactions on Database \nSystems, 21(l), 30-76, 1996. Luca Cardelli. A semantics of multiple inheritance. Information and Computation, \n76:138-164, 1988. [Cat941 [CK86] DyW [DG92] WQ911 [HY90] [HZ901 [Jaj92] [Kar87] [KC861 [Kim891 [KSW86] \n[LRV88] R.G.G. Cattell. The Object Database Standard: ODMG-93. Morgan Kaufmann, 1994. Hong-Tai Chou and \nWon Kim. A unifying framework for versions in a CAD environ- ment. In Proc. VLDB Conference, pages 336344, \nAug. 1986. Umeshwar Dayal. Queries and views in an object-oriented data model. In Proc. Int. Workshop \non DBPL, pages 8%102, Jun. 1989. David Dewitt and Jim Gray. Parallel database systems: The future of \nhigh performance database systems. CACM, 35(6):85-98, Jun. 1992. Hatcher, P.J. and Quinn, M.J. Data-Parallel \nProgramming on MIMD Computers. The MIT Press, 1991. Richard Hull and Masatoshi Yoshikawa. ILOG: Declarative \ncreation and manipula- tion of object identifiers. In Proc. VLDB Conference, pages 455-468, Aug. 1990. \nSandra Heiler and Stanley B. Zdonik. Object views: Extending the vision. In Proc. IEEE ICDE, pages 86-93, \nFeb. 1990. J. Jaja. An Introduction to Parallel Algorithm. Addison-Wesley, 1992. A. Karp. Programming \nfor parallelism. IEEE Computer, pages 43-57, May 1987. Setrag Khoshafian and George P. Copeland. Object \nidentity. In Proc. ACM OOPSLA Conference, pages 406-416, Nov. 1986. Won Kim. A model of queries for object-oriented \ndatabases. In Proc. VLDB Conference, pages 423-432, Aug. 1989. Peter Klahold, Gunter Schlageter, and \nWolfgang Wilkes. A general model for version management in databases. In Proc. VLDB Conference, pages \n3 19-327, Aug. 1986. C. Lecluse, P. Richard, and F. Velz. 02, an object-oriented data model. In Proc. \nACM SIGMOD Conference, pages 424433, Jun. 1988. [NO95 1 [Oh0951 [PP93] [Run921 [SS90] [SZ89] [TBN91 ] \n[YCWT93] S. Nishimura and A. Ohori. A calculus for exploiting data parallelism on recursively defined \ndata (preliminary report). In Proc. International Workshop on Theory and Practice on Parallel Programming, \nLNCS vol. 907, pages 413-432,1995. Atsushi Ohori. A polymorphic record cal-culus and its compilation. \nACM Transac-tions on Programming Languages and Sys- tems, 17(6):844-895, 1995. J. Prins and D. Palmer. \nTransforming high- level data-parallel programs into vector operations. In Proc. ACM Symposium on Principles \nand Practice of Parallel Programming, pages 119-l 28, 1993. Elke A. Rundensteiner. Multiview: A methodology \nfor supporting multiple views in object-oriented databases. In Proc. VLDB Conference, pages 187-198, \nAug. 1992. Marc H. Scholl and Hans-Jorg Schek. A relational object model. In Proc. ICDT, LNCS vol. 470, \npages 89-105. Springer-Verlag, Dec. 1990. Gail M. Shaw and Stanley B. Zdonik. An object-oriented query \nalgebra. In Proc. Int. Workshop on DBPL, pages 103-l 12, Jun. 1989. Val Tannen, Peter Buneman, and Shamim \nNaqvi. Structural recursion as a query language. In Proc. Int. Workshop on DBPL, pages 9-19, Aug. 1991. \nPhilip S. Yu, Ming-Syan Chen, Joel L. Wolf, and John Turek. Parallel query pro-cessing. In Nabil R. Adam \nand Bharat K. Bhargava, editors, Advanced Database Systems, LNCS vol. 759, chapter 12, pages 229-258, \n1993.  \n\t\t\t", "proc_id": "236337", "abstract": "This paper presents an equational formulation of an object-oriented data model. In this model, a database is represented as a <i>system of equations</i> over a set of oid's, and a database query is a transformation of a system of equations into another system of equations. During the query processing, our model maintains an <i>equivalence relation</i> over oid's that relates oid's corresponding to the same \"real-world entity.\" By this mechanism, the model achieves a declarative set-based query language and views for objects with identity. Moreover, the query primitives are designed so that queries including object traversal can be evaluated in a data-parallel fashion.", "authors": [{"name": "Susumu Nishimura", "author_profile_id": "81100461849", "affiliation": "Kyoto Univ., Japan", "person_id": "PP31043314", "email_address": "", "orcid_id": ""}, {"name": "Atsushi Ohori", "author_profile_id": "81100168829", "affiliation": "Kyoto Univ., Japan", "person_id": "PP39030730", "email_address": "", "orcid_id": ""}, {"name": "Keishi Tajima", "author_profile_id": "81100124720", "affiliation": "Kobe Univ., Japan", "person_id": "PP40023974", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236339", "year": "1996", "article_id": "236339", "conference": "OOPSLA", "title": "An equational object-oriented data model and its data-parallel query language", "url": "http://dl.acm.org/citation.cfm?id=236339"}