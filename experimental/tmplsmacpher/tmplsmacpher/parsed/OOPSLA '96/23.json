{"article_publication_date": "10-01-1996", "fulltext": "\n Change Cases: Use Cases that Identify Future Requirements Earl F. Ecklund, Jr. Lois M. L. Delcambre \nMichael J. Freiling Objective Technology Group Oregon Graduate Institute Conceptrics Beaverton, OR 97008 \nBeaverton, OR 97006 Portland, OR 97213 ecklund@teleport.com lmd@cse.ogi.edu concept@teleport.com ABSTRACT \nEvolution of software systems is prompted by all sorts of changes. This paper demonstrates how the use \ncase, a well known construct in object- oriented analysis, is adapted to form the change case, to identify \nand articulate anticipated system changes. A change case provides the ability to identify and incorporate \nexpected future change into a design to enhance the long-term robustness of that design. In this paper, \nwe define change cases and demonstrate how change cases are captured by the analyst. We present examples \nto illustrate how change cases can influence present system design and point the way toward designs that \nmore easily accommodate expected future changes. Change cases can be effectively employed in the context \nof any methodology that supports use cases and traceability links.  I - INTRODUCTION AND MOTIVATION \nSoftware systems derive their usefulness from providing services in an operational context that consists \nof human (and electronic) users who request either information or action. These requests are embedded \nin larger organizational processes, of which the human users are a part. System change is sometimes necessitated \nbecause of a poor initial match between the system and its context. However, even if a system is well \nmatched with its context, change is inevitable. Brooks observed that the software product is embedded \nin a cultural matrix of applications, Permission to make digital/hard copy of part or all of this work \nfor personal or classroom use is ranted without fee provided that copies are not made or distributed \nfor pro B It or commercial advantage, the cppyright noti% the title of the publication and its date appear, \nand notice !s given that copying is by permission of ACM, Inc. To copy otherwlse, to republish, to post \non servers, or to redistribute to lists, requires prior specific permission and/or a fee. OOPSIA 96 CA, \nUSA (D 1996 ACM 0-89791-788-x/96/0010...$3.50 users, laws, and machine vehicles. These all change continually, \nand their changes inexorably force change upon the software product. [Brooks871 Examples of such changes \ninclude: Market changes -As a business becomes more successful, the client base it serves tends to grow \nlarger and more demanding. New clients may require things done their way , especially if the business \nthey do is significant in volume. A large customer, for instance, may require on-line access to order \nand inventory information, requiring a new avenue of access to the system. Business requirements change \n- Organizations are constantly changing their policies and procedures to cope with changes in their environment. \nFor example, a new policy may be established to check a customer s account status before shipping goods \nto fill an order. This policy change will affect the organization s order fulfillment system. Operational \nprocesses change -Required information or actions are redefined because of changes to the operational \nprocess for internal or economic reasons. For example, the elimination of data entry clerks in an order \nprocess may require the system to expand its capabilities to validate raw data as it enters the system. \n Legislative or regulatory change - Operational actions may need to be changed and new information acquired \nin the face of legislative or regulatory change. Previous operations may now be forbidden, Recent Financial \nAccounting Standards Board (FASB) regulations requiring companies to account for pension and retiree \nmedical benefits, for instance, could require a company s reporting system to access information that \nwas not previously needed. Imaginative users --As users become more familiar with a system, they inevitably \ndiscover ways in which it could better meet their needs. Users will request enhancements that make them \nmore productive, even when their initial satisfaction with the system was quite high. To understand and \nanalyze change effectively, it is necessary to understand the key characteristics of each change under \nconsideration. We have identified three key characteristics that we will rely on in this paper to discuss \nthe analysis and handling of potential changes. The focus of a change is the set of system responsibilities \nthat the change directly affects. Take a billing system for example. If we are contemplating a change \nto the billing terms from net 60 days to net 30 days, then the focus of this change are the system responsibilities \nto determine when an account is past due and take appropriate action. The narrower the focus of a potential \nchange, the easier we will be able to accommodate the change. The scope of a change, with respect to \na given model, refers to the pervasiveness of ramifications of the change throughout the artifacts developed \nin that model. We use the term model to refer to the end product of any phase of the development life \ncycle, e.g, requirements model, analysis model, etc. We use the term artifacts to refer to the components \nof the model, e.g., objects, responsibilities, etc. Intuitively, one might think of the scope of a change \nas the number of objects or subsystems that will have to modify their behavior in order to accommodate \nthe change. But the scope of a change also includes user documentation, project documentation, test cases, \net cetera. A change may have a small focus and yet still have a large scope. In a system that was not \ncarefully designed, for instance, the change of expanding Social Security Numbers to include Canadian \nand other national identification numbers could have a tremendous scope, even though its focus is quite \nsmall. The degree of definition of a change refers to the extent to which we know the particulars of \nthe potential change. In some cases, we know all the particulars or at least many of them, e.g., when \nit is necessary to extend an electronic CAD system to handle an already existing device technology such \nas CMOS. In other cases, such as legislative or regulatory changes, the most we can know in advance are \nthe focus of the pending change, and perhaps the competing alternatives. The change does not become fully \ndefined until the law has passed. For years, researchers and practitioners in software design have recognized \nthat robustness to change is one of the hallmarks of a good design. Historically, however, the development \nof designs that are robust to change has been more a matter of art than science. Predictable and repeatable \ndevelopment of such designs requires two things: a means to capture and identify potential changes to \na system, and the availability of constructs to support designs that effectively take potential change \ninto account. Jacobson, almost alone among object-oriented methodologists, has pointed out the importance \nof addressing change in a systematic way [Jacobson86, Jacobson87, Jacobson911, but his focus has not \nbeen on the description of the changes. We propose the change case to capture potential change. The change \ncase is expressed primarily as a use case [Jacobson87, Jacobson921 to describe potential functionality \nof the system. Change cases, like use cases, express functionality from the user s point of view. A change \ncase adds links to all relevant use cases that the change case will affect, if the change is ever implemented. \nThat is, the change case links determine the scope of the change at the use case model level. The change \ncase thus allows for the articulation of potential changes to system functionality and, further, directly \nrelates a change to the current system functionality. We advocate the use of change cases for object- \noriented development methodologies that are based on use cases and traceability [Jacobson92]. Such a \nuse case-driven, object-oriented development methodology supports traceability through the entire development \nlife cycle. The links from change cases to use cases, coupled with traceability, explicitly allow the \ndevelopers to consider the impact of a potential change and to evaluate alternative models according \nto their robustness to change. We note that there are requirements beyond those that describe the functionality \nof the system as expressed in use cases, such as algorithmic specifications, performance requirements \nor constraints concerning the software deployment environment, Changes to such requirements are outside \nthe scope of this paper. In the next section we present our definition of change cases along with an \nexample. Section III briefly discusses use cases and traceability, the foundation for change cases. Section \nIV discusses measuring the impact of a change and the robustness of a design to a change. Section V describes \nthe role of change cases during the phases of software development using an object- oriented methodology. \nWe offer concluding remarks in Section VI.  II - CHANGE CASES AND AN EXAMPLE A change is a requirements-level \nexpression of an intended revision. A change may be very specific, such as changing from 9.6 Kb modems \nto 28.8 Kb modems, or it may represent a simply stated intention to make a revision that will have broad \nscope, such as amending the business model to enable employees to telecommute and work from home. Thus, \ndepending on the narrowness of its focus, a change may require amending one or many use cases, expressed \nas change cases which describe the intended, revised function. Definition: A change case consists of: \n(a) a use case, with a new or revised scenario, derived from a change to requirements, and (b) a set \nof existing use cases, that would need to be changed to be consistent with the changed requirements. \n  Our description of change comprises the description of the change (intentional) and an associated \nset of change cases, each describing a potential, new or revised use case. Each change case, in turn, \nhas a relationship to the use cases that would by affected by the change case. We thus provide traceability \nas advocated by Jacobson [Jacobson921 at two levels: from the change to representative change cases, \nand from each change case to the affected use cases (the Impact Links) These components and their relationships \nare shown in Figure 1. Y Change Case Figure 1. Change, Change Cases and Use Cases Specifically, a change \ncase isa use case [Jacobson87, Jacobson921. As inherited from use cases, the behavior of a change case \ncan be many subordinate use cases (e.g. based on the characterized by a sequence of interactions or extends \nor uses abstractions [Jacobson92]). The dialogue between a user (or actor) and the system. scope of the \nchange case at the use case level is Each change case s scenario describes a single determined from the \nnumber of use cases affected. course of events in the actor/system interaction. A scenario can be described \nin English, as a We give an example, taken from the field of dialogue or conversation [Rubin92, Wirfs-pension \nadministration, of a change and a related Brock941, or in other notations [Buhr96, change case. Our example \ndeals specifically with Potts941. the task of supporting the process that occurs when an employee retires \nand wishes to begin A change case refines a use case by adding a receiving a pension benefit. This example \ncomes relationship between the change case and the use from concrete experience with a commercially cases \nthat are affected by the change. A single available pension administration system change case may affect \none or more of the use [WatsonWyatt95]. cases already captured. Usually, one would expect a change case \nto affect one user-visible use case When an employee announces his or her intention and, in a refined \nuse case model [Jacobson92], to retire, a process is set in motion to compute a Jse Case 1. qame: Initiate \nRetirement Process lcenario: E: I d like to retire. s: What is your name and social security number? \nE: I m Joe Smith, SSN 222-33-4444. s: What will be your last day of work? E: July 31, 1996 s: What month \ndo you wish to begin receiving your benefit? E: January, 1997 s: A preliminary estimate indicates you \nare entitled to the following benefits (based on regulations in effect February 1, 1996): (a) life annuity \nwith no payment to surviving spouse 752.00 (b) life annuity with 50% to surviving spouse: 664.02 (c) \nlife annuity with 100% to surviving spouse: 594.46  Please select the option you prefer. E: Option (c) \n s: [ records pending retirement on indicated date ] [ records election of option (c) ] [ logs suspended \nprocess for final calculation and issue trustee instructions ] Thank you very much. Cast of Characters: \nE: employee S: system Figure 2. Use Case Describing the Retirement Process r  Figure 3. Interaction \nDiagram pension benefit that will be paid to the employee. In most pension plans, the employee is allowed \nto select from several payment options. If the employee is married, for instance, he/she may typically \nselect from options that pay a survivor annuity to his/her spouse in the event that the employee should \ndie before the spouse. Depending on the option selected, the amount of the survivor annuity may be 50% \nor 100% of the original benetit amount. Needless to say, the higher the percentage for the survivor, \nthe lower the amount of the initial annuity payment for the employee. Annuities of equivalent actuarial \npresent value can be calculated using actuarial techniques that consider mortality and interest rates \n[Jordan67]. The calculation of an employee s benefit in a defined benefit pension plan is usually a function \nof the employee s final pay and length of service. The exact amount of this benefit cannot be known until \nthe employee actually stops working. But, a preliminary estimate of the benefit must be computed, to \nenable the employee to select a payment option prior to the actual date of retirement. Once an option \nhas been selected, a  for Retirment Processing benefit payment calculation process is established to \ncompute the exact final benefit and send instructions to the pension plan s trustee to begin paying a \nbenefit to the employee. This process is held in suspension until the day the employee actually retires. \nFigure 2 shows a use case corresponding to this requirement. To keep matters simple, we have cast the \nuse case as a conversation between the system and the retiring employee. In practice, this conversation \nis typically between the system and a pension plan administrator, who carries out the dialogue via formal \ncorrespondence with the employee. The administrator uses the system to manage and track the employee \ns retirement process. We show in Figure 3 a summary of a CRC analysis session for this use case, shown \nas an interaction diagram. Each vertical line represents an object (i.e., a card in CRC). Each directed \narrow represents a collaboration from one object to another, with the return of control shown by a dotted, \ndirected arrow in the reverse direction. PCO: Plan Control Object responsibility: collaborates with: \ncapture retirement date EIO get employee data EDB perform preliminary pension calculation CALC determine \nelected form of benefit EIO log benefit payment process PSS EIO: Employee Interface Object responsibility. \ncollaborates with: capture retirement date determine elected form of benefit  EDB: Employee Database \n responsibility. collaborates with. retrieve employee historical data CALC: Pension Calculator responsibility. \ncollaborates with: perform pension calculation  PSS: Pension Subsystem responsibility: collaborates \nwith: log benefit payment process Figure 4. CRC Model for Retirement Processing The vertical box on \nthe line indicates the duration invoked. This is at the analysis level in that we of the execution, within \nthat object; time proceeds identify objects and responsibilities by name; there down the page. Finally, \neach collaboration line is are no signatures, attributes, relationships, etc. labeled to indicate the \nresponsibility that is being Change R-l Description: Add support for court-issued qualified domestic \nrelations orders (QDRO). When initiating pension payments on an employee s plan, determine if a QDRO \napplies to this plan, and if so, determine the QDRO splits of benefits by interacting with the plan administrator. \nDo not begin actual payments until the QDRO split is certified by the plan administrator. This is an \nanticipated regulatory change. Traceability Links: Change Case 23: Initiate Pension Payment with QDRO \n. . . Figure 5. Change to support QDRO benefit splits much like Wirfs-Brock [Wirfs-Brock901, Figure \n4 supersede the use case in Figure 2 and would shows the resulting CRC model. indicate a new version \nof the regulations. To accommodate such a change, delegating the One possible (and likely) change is \na change in the calculator responsibility to a separate object, as regulations concerning the calculation \nof payment shown in Figure 3, would result in a very small amounts. The associated change case would \nscope (only one object in the analysis model needs Change Case 23. Vame: Initiate Retirement Process \nwith QDRO scenario: E: I d like to retire. s: What is your name and social security number? E: I m Joe \nSmith, SSN 222-33-4444. s: What will be your last day of work? E: July 31, 1996 s: What month do you \nwish to begin receiving your benetit? E: January, 1997 s: [ determines that there is a QDRO for Joe \nSmith] Please excuse me. Because a qualified domestic relations order has been issued on your pension \nbenefit, we will need some time to determine your exact benefit. S->P: What is the benefit split for \nJoe Smith? P: Joe Smith gets 50% of his accrued benefit. s: A preliminary estimate indicates you are \nentitled to the following benefits (based on regulations in effect February 1, 1996): (a) life annuity \nwith no payment to surviving spouse 376.00 (b) life annuity with 50% to surviving spouse: 332.01 (c) \nlife annuity with 100% to surviving spouse: 297.23 Please select the option you prefer. E: Option (c) \n s: [ records pending retirement on indicated date ] [ records election of option (c) ] [ logs suspended \nprocess for final calculation and issue trustee instructions ] [ logs suspended process to determine \nbenefit for QDRO payee ] Thank you very much. Cast of Characters: E: employee S: system P: plan administrator \nimpacted Use Cases: Use Case 1. Initiate Retirement Process Figure 6. Change Case Initiating Retirement \nProcess with a QDRO Figure 7. Interaction Diagram for Retirement Processing with a QDRO to be changed). \nThe analysis model of figure 4 is quite robust to this change. To demonstrate a more substantive change \ncase, we now consider expanding the original system to handle qualified domestic relations orders, or \nQDRO s. A QDRO is an order written by the court that entitles someone other than the employee to a stipulated \nportion of the employee s pension benefit. Typically, QDRO s are issued as part of a divorce settlement, \nand award a former spouse the fraction of the benefit to which they were entitled. Because courts may \nwrite QDRO s in any number of ways, entering the amount of the QDRO benefit split often requires the \nintervention of a pension plan administrator. The administrator may consult the actual text of the QDRO, \nconfer with lawyers and/or actuaries if necessary, determine an amount for the split benefit, and enter \nit into the system. The change to add QDRO processing to a pension system is shown in Figure 5. One of \nthe change cases associated with this change is shown in Figure 6. Note that now two separate benefit \npayment processes must be initiated --one for the employee, and one for the QDRO payee. Also note the \nintroduction of a new participant, the plan administrator, in the change case. We note that, in practice, \na scenario may not actually wait for the plan administrator to enter the QDRO amount, but we express \nit this way for simplicity. An interaction diagram for a CRC analysis session on this change case scenario \nis shown in Figure 7 and the resulting CRC model is shown in Figure 8. A QDRO specialist object (QCO) \nis introduced to handle issues related to the QDRO. This is a control object traceable to the change \ncase. A new interface object (PIO) is introduced to handle communications with the plan administrator. \nThere are new collaborations (from the QDRO control object) to existing objects. That is, the number \nof objects depending on certain responsibilities has increased, providing additional information about \nthe assumptions or preconditions that those responsibilities should assume. In particular, the Employee \nDB must now PCO: Plan Control Object responsibility: capture retirement date get employee and QDRO data \nhandle QDRO (if needed) perform pension calculation determine elected form of benefit log benefit payment \nprocess collaborates EIO EDB QCO CALC EIO PSS with. QC 0: QDRO Control Object responsibility. handle \nQDRO determine benefit split log benefit payment process collaborates PI0 PSS with: EIO: Employee Interface \nObject responsibility. capture retirement date determine elected form of benefit collaborates with. HO: \nPlan Administrator Interface Object responsibility: determine benefit split collaborates with: EDB: Employee \nDatabase responsibility: get employee and QDRO data collaborates with: CALC: Pension responsibility: \nperform pension Calculator calculation collaborates with: PSS: Pension Subsystem responsibility. log \nbenefit payment process collaborates with. Figure 8. CRC Model for Retirement Processing with QDRO s \ntell us whether a QDRO is in effect for this employee, the Calculator object must now work with the net \namount available, and the Pension Subsystem is now called twice (for the QDRO recipient and the employee). \nThe benefits of change case analysis are demonstrated by this example. By conducting this simplified \nanalysis CRC session for the change case, we discover broader contexts for existing responsibilities. \nFor example, without the change case, the Pension Subsystem might have been written assuming that there \nwas only one payment process per retiree. Or the calculation program might have been written expecting \nthe entire employee benefit to be available during the computation (rather than the net amount, e.g., \nafter the QDRO). Based on the change case, both the interface and the context for each (affected) responsibility \nin the current design can easily reflect the broader view of the system that includes the change case. \nIf the interfaces and the contexts of existing responsibilities do effectively support the change case, \nthen change case analysis has minimized the scope of the change at the analysis model. (I.e., no existing \nobjects need to be changed, only the new control objects are in the scope of the change.) Note that the \nnew objects associated with the change case, by themselves, do not affect the robustness of the design, \nRather, they are simply added, designed, and implemented when the change is actually authorized. The \nbenefit from change case analysis is consistent with common wisdom that getting the interfaces to existing \nobjects right promotes the maintenance and evolution of the software system. Change case analysis allows \nthe current design to reflect interfaces that can accommodate a future change. III -THE FOUNDATION FOR \nCHANGE CASES: USE CASES AND TRACEABILITY The use of change cases for analyzing and adapting to change \nis not in itself a methodology. Rather, it represents a technique that can be applied in the context \nof any methodology for object oriented design and development, as long as the methodology being used \nsupports: (a) capture of use cases (b) capture and maintenance of traceability links between different \nphases of the methodology.  In this section, we discuss the importance of these two capabilities as \na foundation for the use of change cases. USE CASES A use case [Jacobson87, Jacobson92, Jacobson951 describes \na single thread of interaction with the (proposed) system from the point of view of a user or other external \nactor (which may be a separate system). A use case-driven software development methodology, such as that \nadvocated by Jacobson [Jacobson92], gathers all of the requirements for user level system functionality \nin the form of use cases and drives the development of each model developed during the software life \ncycle by considering these use cases. A number of different formats have been proposed for expressing \nuse cases [Buhr96, Rubin92, Wirfs-Brock941. These formats include: . a conversation between the user \nand the system 0 a transcript of alternating user and system actions 0 a flow chart or list of decision/action \nsteps that are not assigned to either user or system. While we have found the conversation format simple \nand natural to use (see examples in Section II), our change case model does not depend on any specific \nformat. All that is required of the format employed is that it be easy to identify which use case steps \nmotivate specific artifacts in the analysis model (or design model, if the methodology does not support \nan analysis model). Change cases also carry the same benefits as use cases. They are expressed in user \nor domain terminology. They are understandable to the user because they express changes in the system \naccording to how the user-visible functionality of the system will be changed. They can be easily validated \nby the user and they engage the user into thinking about possible system evolution. TRACEABILITY Effective \nuse of the change case model also requires that the methodology support traceability from one design \nlevel to another. Simply put, traceability refers to the explicit recording, on paper or in a CASE tool, \nof links from artifacts at one level to related artifacts at subsequent levels in the methodology. For \nexample: 0 each construct (e.g., analysis object) in the analysis model is linked back to the use case(s) \nthat motivates the construct. . each construct (e.g., block [Jacobson92]) in the design model is linked \nback to the analysis model construct from which it is derived. each test in the test suite is linked \nback to the use case or other requirement it is intended to test. Traceability allows us to gauge the \nscope of a change with respect to any level of a system s evolving design by following the traceability \nlinks forward from affected use cases to the level we are examining. Understanding the scope of a change \non any level enables us to make judicious decisions about how to change the design at that level (see \nSection V). Traceability is well known and widely practiced in software engineering and software requirements \nengineering [e.g., Nelson90, Potts94, Thayer90, Wymore79, Zave791. In software requirements engineering, \ntraceability is sometimes referred to as requirements flowdown, and it is used to trace the refinement \nof general requirements into more concrete requirements. Traceability enables one to speak about the \ncompleteness and necessity of the final detailed requirements as follows: . COMPLETENESS: If each top-level \nrequirement traces forward to detailed requirements, and if at each level of refinement one can assert \nthat the next level of requirements (when met) will, as a set, satisfy the parent requirement, then the \ndetailed requirements are complete; . NECESSITY: If each final detailed requirement traces backward \nto a top level requirement, then it is necessary. If a requirement statement does not trace backward \nto a top level requirement, then it is spurious and/or out of scope, so designing and implementing to \nthat statement is wasted work. (Or we have identified a missing top-level requirement.) In software \nengineering, traceability is also commonly used to relate test cases to requirements. A test case can \nbe traced back to the requirements that provide the criteria against which the test case is performed. \nWithin the Object-Oriented community, Jacobson advocates using traceability in object-oriented software \nengineering [Jacobson87, Jacobson921. It is a consistent theme in his work that development proceeds \nby seamlessly refining the models, with traceability from use cases (representing requirements) to each \nsuccessive Use Cases Analysis Model Design Model implementation Test Figure 9. Traceability in Object-Oriented \nSoftware Development model (analysis, design, implementation and test models). Traceability enables one \nto determine which objects implement each use case, and to develop test cases against those objects that \nderive the test criteria from the use cases (see Figure 9). Traceability has the most value in a methodology \nwhen the links are bi-directional. Tracing the links downstream allows us to see the analysis and design \nlevel ramifications of a use case or change case, and to determine the scope of a change. Tracing the \nlinks upstream allows us to see why (in terms of the original requirements) a particular design decision \nwas made. Even when a hypertext-like system is not available to support the navigation, links can be \nmaintained in simple database tables and/or paper documents that refer to individually numbered sections \n(or pages, if appropriate) of the appropriate document versions. IV -MEASURING THE IMPACT OF A  CHANGE \nAs mentioned in Section II, the links from a change case to the affected use cases are an important part \nof the structure of an individual change case, since they determine the scope of the change at the use \ncase level. We can get a rough estimate of the impact of the change at this level by measuring the percentage \nof use cases affected by the change. Impact( change C, use case level U) ( use cases in U affected by \nC 1 = use cases in U We can take this approach a step further by noting that any level in the system \ndevelopment process consists of a number of constructs. Typical constructs are shown in Table 1. If we \nhave (as discussed in the previous section) traceability links between levels, we can determine the constructs \naffected by a given change at each level. The number of affected constructs, relative to the total number \nof constructs at that level, gives us a rough measure of the impact of the change at that level. Irnpact( \nchange C, level L) 1 constructs in L affected by C 1 = constructs in L Although software designers can \noften recognize a good design for some particular purpose, determining objective criteria by which designs \ncan be judged has been quite difficult. Some software metrics have been proposed [Henderson96, Lorenz941. \nRecent work on object-oriented development [Jacobson92, Gamma951 has focused on robustness to change \nas a critical criterion for evaluating designs. The concept of impact of a change, shown above, can be \nused to develop a rough measure of robustness of a design to potential changes. Intuitively, we would \nlike an absolute measure of the potential impact of a change. We would then be able to compare the potential \nimpact against the actual impact, using the formula developed above. However, the potential impact may \nbe a real world concept that does not submit to formalization in our model. Note that the existing use \ncases for a system are a fixed reference set, since revisions are made by adding change cases. Thus we \ncan use the impact of a change at the use case level (i.e., the focus of the change) as an approximation \nof the potential impact of the change. To measure the robustness of a downstream level to a particular \nchange, we propose to measure the impact of that change at the (downstream) level, and compare it with \nthe impact at the use case level, whether the downstream level be analysis, design, or implementation. \nRobustness level L, change C ( ) = 1 Impact( change C, use case level U) 1 1 Irnpact(change C, level \nL) 1 In general, this measure will vary between 0 and 1, although it can exceed 1. The higher the value, \nthe more robust our design. If it exceeds 1, we have a very good design from the standpoint of change \nC, because it means that the impact of the change at this level has been reduced from the original focus. \nThis measure, Robustness(L, C), measures robustness to only one change. In the overall evaluation of \na design, of course, we would want to measure robustness against a set of changes, C,, Cl, . . . Ck, \nwhich can be viewed as components of a change vector C = < C,, C2, . . . Ck >. In comparing two designs, \nD, and DZ, against a change vector C, D, will most likely be more robust with respect to some of the \ncomponent changes, and D, more robust with respect to others. If the robustness of D, exceeds that of \nD2 for every component of C, then D, is clearly preferable with respect to the changes contemplated. \nOtherwise, it is a judgment call based on the relative likelihood and priority of each component change, \nCi. Although this metric is useful for judging impact, we note that other considerations must be taken \ninto account when evaluating a design. V -CHANGE CASES IN A DESIGN METHODOLOGY So far, we ve talked \nabout how change cases can be employed in individual situations. In this section, we discuss the overall \nrole of change cases in a full software development methodology. In particular, we discuss how the requirements, \nanalysis, design and implementation phases can be affected by incorporating change cases into your methodology. \nThe discussion of the requirements phase focuses on sources for discovering changes, and determining \nwhich change cases to elaborate. Discussion of phases after the requirements phase assumes that the change \ncases have been captured, and focuses on their use during the phase. REQUIREMENTS PHASE The requirements \nphase is typically where use cases are captured, so it is a relatively simple matter to capture change \ncases as well during this phase. Sources for information about potential change are also plentiful, including: \n. planned or scheduled changes to product / service offerings 0 user comments during JAD sessions 0 review \nof regulatory / legal environment . drafts of pending legislation / regulations . review of organization \ns technology &#38; platform strategy Candidate Use Cases Analysis Objects Design Objects Implemented \nObjects  I Figure 10. Change Analysis The difficult decision to make is to determine how many and which \npotential changes are important enough to warrant consideration during initial system design, since budgetary \nconstraints usually preclude consideration of every possible change. In Figure 10, we show the required \ndevelopment artifacts on the left side and the optional development artifacts, associated with potential \nchanges, on the right side. Assuming that a project might budget some resources for change analysis, \nwe have drawn a dashed line to indicate the budgetary cutoff. The budget line is sloped to imply that \na subset of the change cases should be considered, with some of the change cases reflected in the analysis \nmodel, and possibly a few of the changes reflected in the design model. We assume that none of the potential \nchanges are to be implemented within the present scope of the project. The importance of a potential \nchange can depend on many things, including its likelihood, scope and expected cost. In general, it requires \na judgment call on the part of the design team to identify the most important changes while staying within \nbudget. Any design effort, however, will benefit from analysis of some potential changes, because they \nprovide a benchmark for evaluating the design that emerges in the later stages of the methodology. Change \nAnalysis Budget Line IL 8 iII---chGle---&#38; -----; -----*------------I ,-----T/-----T---.____, 1 Poten@xl \nAnalysis Objects 1 ,_____-__-----_-__--_I ,_-_/_----_-__-______, ; -$o-t~n-t~~l l+jEn_ Fbjects ;  Budget \nfor Robustness Analysis Once the significant changes are identified, change cases can be captured using \nthe same techniques and formats that the methodology employs for ordinary use cases. As we have discussed \nthroughout this paper, it is important to establish the links between each change case and the existing \nuse cases that would be affected by it. ANALYSIS PHASE Methodologies differ as to the deliverables expected \nfrom the analysis phase of a design methodology. Some expect a preliminary object model that is directly \ndriven by the domain requirements and pre-figures the design phase object model, just as an entity-relationship \ndiagram pre-figures a final data model. Analysis guidelines of such methodologies include rules like: \n0 Create a surrogate object for each system user. 0 Create a surrogate object for each object that occurs \nin the domain. 0 Create a specialist object for each use case. 0 Create a responsibility in the specialist \nobject for each . . , We will prioritize or otherwise select change cases to be analyzed within the change \nanalysis budget. Having selected a set of change cases, we develop the base analysis model, based on \nanalysis of all the use cases, and then perform analysis of selected change cases. This produces a change- \nextended analysis model , that is, the base model transformed by the selected change cases. When performing \nchange case analysis, we may observe common responsibilities between a change case object and a use case \nobject, which would lead us to factor out a superclass providing the shared responsibilities. This is \na good change to the analysis model, making it more robust to the related change. Traceability links \nshould be exploited to keep track of the dependencies between the change cases and the components of \nthe various analysis models, so that the reasons for such analysis decisions do not become lost. DESIGN \nPHASE Typically, the design phase focuses on refining the analysis model as the requirements and design \nconstraints are more carefully considered. Often this results in factoring and/or reducing the analysis \nmodel to produce an object model suitable for code development in the implementation phase. A concern \nis that a design-level decision (e.g., factorization) may reverse an analysis-level decision made explicitly \nfor robustness. Therefore, at the design level, attention should be paid to the scope of the analysis \nmodel constructs that are traceable back to change cases. The impact measures defined in Section V can \nbe used to predict whether the design model with a particular factorization (reduction) is more robust \nto the analyzed changes than otherwise. Suppose D, is a design model for a given analysis model, and \nD2 is a design model, with some additional factorization (reduction) for the same analysis model. For \na given change C, by comparing Impact(C, Design level) for designs D, and D2 , we can determine which \ndesign is preferable (more robust) with respect to change C. IMPLEMENTATION PHASE The implementation \nphase usually focuses on realizing the design model in working code. Significant changes are considered \na re-design rather than a separate refinement of the design model. While the analysis and design models \nmay include the effects of potential changes, it is appropriate at the implementation phase to focus \non what actually needs to be delivered for the upcoming system release. Traceability links identify objects \nand methods that owe their existence primarily to potential changes. Implementation of these can be deferred, \nstubbed, or replaced with simpler code derived from a restricted design model. As with all artifacts \nof the implementation model, traceability links should be created to identify the need to change these \nartifacts when the potential change becomes actual. LATER IDENTIFIED CHANGES Finally, consider a potential \nchange, C, that is identified when the design, or even the implementation, is nearly complete. Change \ncases can be used to analyze the impact of C on the current models. Assuming that the impact analysis \nof change C is within the robustness analysis budget, for each phase of the development lifecycle, we \nselect change cases (that trace from C) to analyze the robustness of the model at that level. The desirable \noutcome is that, after robustness analysis, the robustness of each model level (to this change) is acceptable. \nOtherwise, we could consider a redesign, at one or more levels of the model. We can use the impact measure, \nImpact(C, L), and the known cost of completed models to estimate the expected costs of making change \nC with or without doing immediate redesign for additional robustness. Depending on costs-benefit analysis, \nwe may choose to backtrack and revise the existing work for increased robustness. VI -CONCLUSION REFERENCES \nIn this paper, we have introduced the concept of a change case as a way to describe potential system \nfunctionality, and demonstrated how it can be used to capture potential changes and design systems that \nare robust to the changes identified. The importance of dealing with change early in the analysis process \ncannot be underestimated. By dealing with change early in the development process, it should be possible \nto both reduce future maintenance costs, and extend the system s effective life span. We note that object-oriented \nprogramming provides constructs which can be effectively used to produce designs that are robust to change. \nThe object construct itself supports the encapsulation of both data and its associated behavior, and \nprovides a convenient means of isolating a small number of system components likely to be affected by \nsome change. The message passing model, and the use of control objects and interface objects [Jacobson921 \nto serve as gatekeepers to accept all incoming messages for larger object subsystems, supports the isolation \nof larger subsystems if necessary. Finally, the polymorphism of most object languages provides a means \nof developing protocols to request and receive services, even when the exact nature of the responding \nobject is poorly understood, or likely to change. Thus, we observe a symbiotic relationship between use \ncases, change cases and object orientation. Acknowledgment We thank Rebecca Wirfs-Brock for her insightful \ncomments and assistance, which led to significant improvements in the final version of the paper. Brooks87 \nF. Brooks, No silver bullet --essence and accidents of software engineering , Computer 20,4, April, 1987, \npp. 10-19. Buhr96 R. Buhr and R. Casselman, Use CASE Maps for Object-Oriented Systems, Prentice-Hall, \n1996. Gamma95 E. Gamma, R. Helm, R. Johnson and J. Vlissides, Design Patterns: Elements of Reusable Object-Oriented \nSoftware, Addison-Wesley, 1995. Henderson96 B. Henderson-Sellers, Object-Oriented Metrics: Measures of \nComplexity, Prentice-Hall, 1996. Jacobson86 I. Jacobson, Language Support for Changeable Large Real Time \nSystems , Proc. OOPSLA 86, pp. 377-384. Jacobson87 I. Jacobson, Object Oriented Development in an Industrial \nEnvironment , Proc. OOPSLA 87, pp. 183-191. Jacobson9 1 I. Jacobson and F. Lindstrom, Re-engineering \nof old systems to an object-oriented architecture , Proc. OOPSLA 91, pp. 340-350. Jacobson92 I. Jacobson, \nM. Christerson, P. Jonsson and G. avergaard, Object-Oriented Software Engineering: A Use Case Driven \nApproach, ACM Press, 1992. Jacobson95 I. Jacobson, M. Ericsson and A. Jacobson, The Object Advantage: \nBusiness Process Reengineering with Object Technology, ACM Press, 1995. Jordan67 C. Jordan, Society of \nActuaries, Textbook on Life Contingencies, Society of Actuaries, Chicago, 1967. Lorenz94 M. Lorenz and \nJ. Kidd, Object-Oriented Software Metrics, Prentice-Hall, 1994. Nelson90 E. Nelson, System Engineering \nand Requirement Allocation , System and Software Requirements Engineering, R. Thayer and M. Dorfman, \neds, IEEE Computer Society Press, 1990, pp. 60-76. Potts94 C. Potts, K. Takahashi and A. Anton, Inquiry-Based \nRequirements Analysis , IEEE Software, 11,2, March 1994, pp. 21- 32. Rubin K. Rubin and A. Goldberg, \nObject Behavior Analysis , CACM, 35,9, September, 1992, pp. 48-62. Thayer90 R. Thayer and W. Royce, Software \nSystem Engineering , System and Software Requirements Engineering, R. Thayer and M. Dorfman, eds, IEEE \nComputer Society Press, 1990, pp. 77-116. WatsonWyatt HR Edge PENSIONS User s Guide Version 2.0, Watson \nWyatt Software, Lake Oswego, OR, 1995. Wirfs-Brock90 R. Wirfs-Brock, B. Wilkerson and L. Wiener, Designing \nObject-Oriented Software, Prentice-Hall, 1990. Wirfs-Brock94 R. Wirfs-Brock, The Art of Designing Meaningful \nConversations , The Smalltalk Report, 3,5, 1994. Wymore79 A. Wymore, Resolution of System Design , Proc. \nCOMPSAC 79, IEEE Computer Society, 1979, pp. 21 l- 122. Zave79 P. Zave, A Comprehensive Approach to \nRequirements Problems , Proc. COMPSAC 79, IEEE Computer Society, 1979, pp. 117-214. \n\t\t\t", "proc_id": "236337", "abstract": "Evolution of software systems is prompted by all sorts of changes. This paper demonstrates how the <i>use case</i>, a well known construct in object-oriented analysis, is adapted to form the <i>change case</i>, to identify and articulate anticipated system changes. A change case provides the ability to identify and incorporate expected future change into a design to enhance the long-term robustness of that design. In this paper, we define change cases and demonstrate how change cases are captured by the analyst. We present examples to illustrate how change cases can influence present system design and point the way toward designs that more easily accommodate expected future changes. Change cases can be effectively employed in the context of any methodology that supports use cases and traceability links.", "authors": [{"name": "Earl F. Ecklund", "author_profile_id": "81100652029", "affiliation": "Objective Technology Group, Beaverton, OR", "person_id": "P74354", "email_address": "", "orcid_id": ""}, {"name": "Lois M. L. Delcambre", "author_profile_id": "81100426809", "affiliation": "Oregon Graduate Institute, Beaverton, OR", "person_id": "PP40035234", "email_address": "", "orcid_id": ""}, {"name": "Michael J. Freiling", "author_profile_id": "81100455876", "affiliation": "Conceptrics, Portland, OR", "person_id": "PP31043072", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236372", "year": "1996", "article_id": "236372", "conference": "OOPSLA", "title": "Change cases: use cases that identify future requirements", "url": "http://dl.acm.org/citation.cfm?id=236372"}