{"article_publication_date": "10-01-1996", "fulltext": "\n Environment al Acquisition ~ A New Inheritance-Like Abstraction Mechanism JOSEPH GIL DAVID H. LORENZ \nThe Faculty of Computer Science, Technion-Israel Institute of Technology, Technion City, Haifa 32000, \nISRAEL; Email: { yogi 1 david } @CS.Technion.AC.IL Abstract The class of an object is not necessarily \nthe only deter- miner of its runtime behaviour. Often it is necessary to have an object behave differently \ndepending upon the other objects to which it is connected. However, as it currently stands, object-oriented \nprogramming pro- vides no support for this concept, and little recogni- tion of its role in common, practical \nprogramming sit- uations. This paper investigates a new programming paradigm, environmental acquisition \nin the context of object aggregation, in which objects acquire behaviour from their current containers \nat runtime. The key idea is that the behaviour of a component may depend upon its enclosing composite(s). \nIn particular, we propose a form of feature sharing in which an object inherits features from the classes \nof objects in its environment. By examining the declaration of classes, it is possi- ble to determine \nwhich kinds of classes may contain a component, and which components must be contained in a given kind \nof composite. These relationships are the basis for language constructs that supports acquisi- tion. \nWe develop the theory of acquisition that includes topics such as the kinds of links along which acquisi- \ntion may occur, and the behaviour of routine (meth- ods) and attribute features under acquisition. The \npro- posed model for acquisition as a hierarchical abstrac- tion mechanism is a strongly typed model \nthat allows static type checking of programs exploiting this mech- anism. We compare it to several other \nmechanisms in- cluding inheritance and delegation, and show that it is significantly different than these. \nPermission to make digital/hard copy of part or all Of this work for Personal or classroom use is granted \nwithout fee provided that wles are not made or distributed for profit or commercial advantage, the copyright \nnoti% the title of the publication and its date appear, and notice is given that copyingis by permission \nof ACM, Inc. To Copy otherwise, to republis$ to post on sewers, or to redistribute to lists, requires \nprior specific PermIssion and/or a fee. oOPSLA 96 CA, USA Q 1996 ACM 0-89791-788-x/96/0010...$3.50 1 \nIntroduction Nature vs. Nvrture? 1 This long standing question obsessed philosophers, psychologists, \nlaymen and even physicists [46] for years. The dispute is over the relative importance of heredity and \nenvironment in determining the makeup of an organism. However, for the object-orienteer2, it has rarely \nbeen a problem: The basic char-acter of an object, sometimes called behaviour in the object-oriented \n(00) jargon, is determined at birth (in-stantiation), and not by the household (the composite object) \nof which it is a part. This simplistic sweeping claim is, as are all such claims, false for humans. How \ntrue is it for objects? How should the nurturing of an object, affect its manners? Can such influence \nbe dealt with in a (type) safe manner? In this paper we address these questions. We explain what is and \nwhat is not the influencing environment of an object. We show that there are many impor-tant cases, both \nin the problem and program domains, in which the need for environmental a$ect naturally arises. We then \npropose a new abstraction mechanism, environmental acquisition, and study its possible real-ization in \na strongly-typed programming language. This paper does not provide solutions to all the prob-lems it \nraises. Rather, it presents a framework for ad-dressing the issues involved in the many aspects of en-vironmental \naffects. 1.1 Motivation Consider the following example which may occur in an automobile industry application: \nAn object of a class Car depicted in Figure 1, is a composite which comprises components such as objects \nof class Door. Suppose that it is known that a car is coloured red, then we are likely Also known as \nthe environmental-heredity controversy. *or, should we write, object-orientalist? Door 0 Colour A iI \nHatchback Sedan Figure 1: Acquisition in t.he problem space to infer that its doors are red as well. \nHowever, al-though the door inherits its colour from the car of which it is part, it would be wrong to \nderive Door from Car. This colour-inheritance is related to t,he in-a link which binds doors to cars. \nConsider now the subclasses of Car, say Sedan and Hatchback, which are distinguished among other things \nby their number of doors. Class Door inherits its colour from Sedans and Hatchbacks alike, just as it \nwould from another hypothetical class Airplane which does not stand in an is-a relationship with Car. \nWe call this kind of inheritance environmental acquisition (acquisition for short) and distinguish it \nfrom inheri-tance. Observe that since acquisition binds objects and not their classes, it does not (indeed \nit cannot) induce any subtype relationship. This is in contrast to the common role of inheritance in \nprogramming. The above example is drawn from the problem space. Another example, which belongs in the \npro-gram space, is that of class objects. In a pure object-oriented programming (OOP) model, such as \nthat of SMALLTALK [19], c 1asses are also objects. The concept of class objects occurs even in less pure \nmodels such as Objective-C [la], and SOM [15]. A class object is an instance of a meta-class Class.3 \nIt provides a mould for the instantiation of objects in the class and defines their behaviour. If a class \nCi inherits from Cz, then the class object of Ci has a super link t,o its containing class object of \nCar as shown in Figure 2. Inheritance is realized by propagation of features4 of Cz along that pointer \nfrom Ci. This propagation can be thought of as acquisition in the meta-level. Part of the role of the \nmeta-class Class is to define and implement the process of this propagation. The fact that the propagation \nof features across links is not part of the usual object model contributes to the 3For the purposes of \nthe example, it is sufficient to assume that there is only one m&#38;a-class and that abstraction stops \nat Class. That is, there are no meta-meta-class, meta-meta-meta- class etc. However, the example becomes \neven more interesting, albeit more complex, if these are allowed. 411ere, and henceforth, our terminology \nadheres as much as possible to that of EIFFEL [32]. complexity of understanding and programming with \nclass objects and meta-classes. Assuming a single-inheritance scheme, a view which mitigates this diffi-culty \nis that of class objects as representing sets. The class object Car models the set of all cars. The class \nobjects Sedan and Hatchback model their correspond-ing sets, which are part-of the class object of Car. \nBy allowing components to acquire attributes from their respective composites we put colour-inheritance \nof doors from cars, and the acquisition of features of the class object Sedan from the class object of \nCar at at the same conceptual level.  1.2 Acquisition vs. inheritance Generally, an 00 system encompasses \ntwo hierarchies, as depicted in Figure 3: an is-a -inheritance hierar-chy of classes, and an an in-a \n-composition hierarchy of objects where acquisition dwells. The two hierar-chies are tied by instance-of \nlinks between objects and classes which are drawn as dotted lines in the figure. Despite superficial \nsimilarity, there are important dif-ferences between inheritance and acquisition. These are highlighted \nby making the distinction between shared and particular features of an object. Shared features are those \nwhich are determined by the object s class. They include behaviour (declaration and definition of meth-ods) \nand structure (declaration of instance variables). Particular features may be different in different \nobjects of the same class. They include the object s identity and state (current values of instance variables). \nInheri-tance pertains to classes and therefore serves as a means of abstraction over shared features. \nIn cont#rast, acqui-sition can be viewed as a means of abstraction over particular features.5 Let al,. \n, a, be objects of classes Cl,. . , C, respec-tively, such that al is an instance variable of az, and \nso on, as depicted in Figure 4. All shared attributes of al are determined by Cl. Traditionally, the \nparticular fea-tures of al are independent of both the shared and the particular features of a2. Environmental \naffect on al is tantamount to the dependence of its particular features on the class Cz and its instance \n~2. More generally, the environment of al consists of the particular features of a2,...,an as well as \ntheir shared features ((72,. ) Cn). The environmental affect on al is the extent t,o which its particular \nattributes depend on the environment. Unlike inheritance, acquisition does not impose sub-typing: a Door \nis not a Car just as Clyde the ele-phant [13] is not the jungle it resides in. In subtyp- One may argue \nthat in the case of inheritance an object in-herits particular features from its subobjects. With acquisition \nthe subobject would had inherited from the containing object.  Objects Classes class S er Class Bi \n Figure 2: Meta class acquisition in the program space Objects Classes Figure 3: The is-a -inheritance \nand the in-a -composition hierarchies Objects Classes shared features j.: C2 particular features 1 ;c \nn pmtrt~ular features Figure 4: Environmental affect on al ing, the heir could be used wherever the \nparent is used. Hence, all features of the parent musi also exist in the heir. With acquisition, this \nis unexpected, often unde-sirable, and in some cases impossible: Although the be-haviour of Clyde in \nthe jungle might be different than in a zoo, Clyde is not green just because the jungle is. On a workstation, \nwe may want our windows to acquire the colour palette, but not the exact colour of their com-posite window. \nIn word processors, words cannot, be justified, while the paragraphs they are in can. Another difference \nbetween acquisition and inheri-tance is therefore that acquisition is done on a feature by feature basis. \nThe acquiring class must enumerate all features it needs to acquire. In offering this freedom of selection, \nacquisition is more expressive than inheri-tance. The penalty, that comes in the form of long lists of \nsuch enumerations, can be alleviated with semantic grouping of features, or even collect,ing features \nthat are acquired together in a compound feature class. Our proposal for acquisition is strongly typed; \nspe-cific ways are provided for the programmer of an object to cater for all of its potential environments \nand deal in a type safe manner with a concrete environment in which it exists. Moreover, a component \ncan be dynam-ically moved to a different composit,e, resembling per-haps dynamic inheritance. A consequence \nof this is an inclination towards forwarding rather than delegation semantics. Acquisition is also subject \nto polymorphism. Envi- ronmental polymorphism means that there are many possible variant behaviours \nof objects of a given class, and that the precise behaviour is dependent on the envi- ronmental affect. \nThe terms environmental acquisition and environmental polymorphism are complementary, just as inheritance \nand subtype polymorphism [41, 81 are. Environmental polymorphism is different from subtype polymorphism: \nWith subtype polymorphism, the code applicable to a certain type (class), be it part of that type definition \nor not, is also applicable to all of its subtypes (subclasses). The code s behaviour is therefore parameterized \nby the actual object it operates on. With environmental polymorphism, the object s behaviour is parameterized \nby its surrounding environ-ment Acquisition is different from programming with ex-emplars [29, 51 in \nthe same way that classical class-based languages are different from languages such as SELF6 [47]. Although \nacquisition can be imitated (to a known extent) by the delegation mechanism, such There is no need in \na single-hierarchy system with only one kind of objects, as in SELF, for m&#38;a-classes because objects \nde-scribe themselves. SELF provides, however, dynamic inheritance in the form of delegation. an imitation \ndoes not match a disciplined use of this paradigm as enforced by built-in lingual support. This difference \nis similar to that of high-level languages to assembly language. Although machine code is at least as \npowerful as high-level languages, since it implements them all, the availability of high-level promotes \nbetter programming practices. For example, as we shall see, it is possible to practice type-safe programming \nwith acquisition, a trait which the unharnessed power of del-egation excludes. Outline The rest of the \npaper is organized as fol-lows: To give the reader a taste of the motivation for this research, we present \nin Section 2 several important application domains in which acquisition ernerges nat-urally. Sections \n3, 4 and 5 together develop the theory of acquisition: Section 3 deals with the channels along which \nacquisition occurs, Section 4 with environmen-tal polymorphism, and Section 5 deals with the ques-tion \nof propagating features in these channels in a type safe manner. In Section 6 the proposed acquisition \nis compared with few other models, including dynamic in-heritance, delegation, genericity, composite \nobject sup-port [23] and complex associations [27]. Finally, Sec-tion 7 gives the conclusions and possible \ndirections for further research.  2 Application Domains Containment hierarchy is a ubiquitous concept \nin pro-gramming methodology in general, and specifically in the 00 paradigm. The COMPOSITE design pattern \n[16] appears in almost any 00 system. Many of the 00 analysis and design methods even devote a special \nnota-tion for containment [3, 10, 381. In this section we show that there are abundant cases of containment \nhierar-chies where contained objects have different behaviours depending on their surrounding environment. \nWe give five application domains in which this phenomenon oc-curs naturally. 2.1 GUI Systems 00 graphic \nuser interface (GUI) frameworks typically organize screen elements: windows, views, dialog boxes, and \nso on, in a view tree. Systems of this sort are for example, Turbo-Vision and its descendent OWL [4, \n431, Interviews [30], and that of NeXT [45]. Responsibili-ties, such as screen drawing and handling input \nevents, are distributed down this hierarchical view-tree. A screen element to which responsibility is \ndelegated from its (environmental) narents. also acauires some of its \\ I 1 parents traits. In Turbo \nVision [4] for example, we see the following acquired traits. Origin of the coordinate system. The coordinate \nsys-tem of a screen element is relative to that of its parent. Error handling. The routine to call in \ncase an unrec-ognized event occurs may be that of the parent. Control fiozu. Modal screen elements are \nsubtrees which, when activated, disable all elements external to them. Examples of modals are yes-no \nmessage boxes and the application itself. When a modal element terminates, it returns control to its \nnearest enclosing modal element. The nearest enclosing modal element is implemented as an environmentally-acquired \nattribute which exists in all screen elements. Attributes palette. Screen colours (aka attributes) of \na screen element are given as indices of a palette table stored in one of the screen element ancestors. \nThe val-ues stored in this table serve in turn as indices to an ancestor of this a.ncestor and so on \nuntil the application global attributes are reached. This acquisition mecha-nism is designed for flexibility \nand power, but it makes programming and reasoning with palettes a complex task. Interviews [30] uses \nacquisition for computing con-straints on an object s size. Other GUI systems use ac-quisition for other \npurposes e.g., context sensitive help, where a screen element acquires its response to a help request \nfrom its enclosing element but may override it to support more specific help. These GUI systems are written \nin languages that do not support acquisition as an environmental inheritance mechanism. Acquisition must \nbe therefore emulated, usually by a complicated web of point,ers and schemes for call-back. Beyond unwieldy \ncomplexity, this results in difficult to understand features (as in the attribute palettes example), \nor in non-safe programming, (e.g., is it always guaranteed that an existing modal will find an enclosing \nmodal?).  2.2 Graphic modeling The intricacies of Turbo Vision s attribute palette are only multiplied \nin the realm of high resolution graphics modeling 3-D objects. Here it is necessary to address issues \nof acquisition of many more kinds of attributes such as line styles, colour, shading, textures, model-ing \ntype, and transformation matrix, spread along very complex objects. The graphics community recognizes \nthat the ensuing questions are difficult [14, Section 9.21. However, there is at least one major graphic \nstandard which includes acquisition [37]. 2.3 Text processing Emphasized text in I4TEX [28] normally \nprints in ital-ics. However, an emphasized within an emphasized block prints in roman (as demonstrated \nin this sen-tence). This is only one of the many examples in the domain of desktop publishing systems \nwhere the behaviour of text elements is strongly dependent on their surrounding environment. Systematic \napproaches to document processing, such as SGML [20, 7] and RTF (Rich Text Format), use a hierarchical \nrepresen-tation, and let attributes such as type-face, text-size, and bounding boxes be environmentally-inherited \nby elements from their surrounding elements. Some mod-ern word-processors (e.g., Dagesh [l]) even explicitly \nuse the word inheritance to denote what we call ac-quisition. The usage of acquisition is very evident \nin the scoping model of TEX [25]: the value of all macros, declarations, and registers, is acquired at \neach point from the inner-most enclosing scope in which they are defined. Ac-quisition and environmental \npolymorphism are part of the reason why programming T&#38;X macros is so notori-ously difficult. A macro \nis a polymorphic object whose behaviour depends on the values of the commands and on other macros that \nit calls at t,he time of activation. To add to the complication, a macro may change its own definition \nduring its execution. Therefore, recur-sive calls may amount to something totally different than our \nusual understanding of recursion. Better un-derstanding, strong typing, and disciplined acquisition should \nmake TEX macros less awkward. 2.4 User defaults in an operating envi-ronment Fancy GUI windowing environments \nallow the attach-ment of various defaults and user preferences to files and other resources. For example, \none may attach a word processing application, customized and configured appropriately, to a certain type \nof document. On click-ing on a document s icon, the corresponding editing ap-plication will be invoked. \nIf the user manipulates many different projects, or if a large multi-user environment is to be supported, \nthis attachment has to be carried out in an orderly manner. Even in a simple Unix environment, a default \nsystem is needed: Different users have different preferences, which may further depend on the types of \nfiles and their location. Upon editing a file of an unknown type located anywhere under the Programs \ndirectory, the ed-itor should be in programming mode. If the same file is under a Documents directory, \ndefaults should change accordingly. This behaviour may be different depend-of its enclosing struct. We \ndeal with this delicate issue ing under which home directory these directories reside. Acquisition, together \nwith an inheritance hierarchy of types of files and other resources, is the appropri-ate way of setting \ndefaults. Its absence brings about a major source of confusion for naive users and a source of headache \nfor the system administrator. Current solutions in Unix use a tangled mixture of compile-time flags for \napplications, system-global, user and di-rectory initialization files (. Xrc in the Unix jargon), together \nwith environment variables settings. Shared (networked) installation of many applications in MS- Windows \nis next to impossible.  2.5 Language processors and reverse engineering Processing formal (programming) \nlanguages is another application domain which calls for acquisition: com-pilers, interpreters, automatic \ngeneration of test cases, computing metrics, etc. If the processed language be-longs in the Algol family \nand has static binding, then acquisition is applicable. A parse tree for a specific in-put program of \nthis language only captures the syntac-tical aspects of the prograrn [17]. The semantic infor-mation \ncan be computed from that tree with the help of acquisition. Here are a few examples, all taken from \nC+t. Constructors. Constructors and ordinary member functions have essentially the same syntax, but gener-ate \nquite a different code. The precise type of method can only be determined by the name property of the \nenclosing class/struct definition. Variable definition vs. function declaration. The x y(z) ; C++ statement \nis either a function declaration or a variable declaration, depending on the declarations of x, y and \nz. These declarations can only be found in the environment surrounding the statement. Members visibility. \nThe visibility (public, protected or private) of members in an aggregation is also determined by the \ntype of the aggregation, struct or class. Contexts. More generally, each scoping unit: file, function, \nclass, struct or namespace, acquires a con-text from its enclosing scoping unit, may override this context \nin part or in whole, and passes on the modified context to elements enclosed in it. In summary, as is \nthe case in life, things must be put in context. Observe that in the last two items above, an enclosed \nelement not only acquires properties of the en-closing one, but may also change them. A protected: statement \nin a struct changes the visibility attribute later.  3 Paths of Acquisition In our motivating examples, \nfeatures were acquired through aggregation links. A natural question that arises is that of acquisition \nalong other kinds of links among objects. In the MVC model [26] for example, it would be far-fetched \nto claim that the view is part of the model, but it would be very natural for it to acquire along the \n%iews link those aspects of the model that are relevant to displaying the model. The same can be argued \nfor the OBSERVER design pattern [16] which can be thought of as a generalization of MVC. There are other \ndesign patterns such as PROXY and STATE in which acquisition might prove useful even across non-aggregation \nlinks. 3.1 Aggregation links Acquisition along aggregation links is particularly in-teresting because \nof several properties that the contain-ment relationship exhibits: (i) an object may be a component of \n(directly con-tained in) at most one composite at any one time; (ii) no object may be contained, directly \nor indirectly, in itself; and  (iii) all objects may be part of a containment hierar- chy, i.e., all \nobjects have aggregation links. Property (i) eliminates the need to specify the link through which the \nacquisition is done. Property (ii) re-solves the problem of circularity in acquisition. Prop-erty (iii) \nenables acquisition for all objects. The forest topology of containment engenders an analogy between \nsingle inheritance and acquisition. This analogy even suggests environmental inheri-tance as an alternate \nterm to acquisition, where the notion of environment refers to a list of all enclosing composites of \na component. Three more properties complement our understand- ing of the containment relationship: (iv) \ncomposites export the ability to access the com-ponents they enclose as autonomous objects; (v) the \nprotocol of a composite does not depend on knowledge of its components; and (vi) the protocol of a component \ndoes not depend on knowledge of its composite.  Together, these last three properties constrain the \ncoupling between the composite and the component. Although property (iv) is sometimes used for separa-tion \nof containment (Car-Door) from attribution (Car-Colour), it is not a pre-requisite for the two others, \nnor for acquisition. The protocol of objects exists even if they are inaccessible from outside the containment, \nand acquisition might be useful for such objects as well. 7 Containment relationship has yet another \nproperty: (vii) the contains relationship is covariant. Specifically, if a class Cs has a slot of class \nCi, then the type of this slot in a subclass of Ca is Cl, or Ci, a subclass of Ci. With the natural abstract \nsuperclass rule [al], and the proviso that insertion of components into slots can only be done in concrete \ncontainer classes, we have that covariance of slot type is not only natural, but can also be checked \nstatically. This form of covari- ante should be contrasted with covariance of function arguments, which \nis natural but unsafe. Although general purpose programming languages reflect the situation in which \n. . . the difference be-tween whole-part associations (WPAs) and other asso-ciations is often only cosmetic \nand diagrammatic. [9], there are numerous application domains in which con-tainment is essential and \nnatural. In these domains, which include solid modelers, hierarchical databases, text structuring systems \nsuch as SGML, parsers and other language processors, acquisition should be done along aggregation links. \nIn order to restrict acquisition to aggregation links, we must be able to distinguish these from all \nother links. However, in examining programming languages we find that such a lingual distinction tends \nto be the exception rather than the rule: In reference-semantics languages such as SMALLTALK, there is \nno clear distinction be-tween containment and other kinds of associations; in value-semantics languages \nsuch as LISP, all associations are containment in a sense. The distinction is crisper in mixed semantics \nlan-guages such as C++ and EIFFEL [32]: an object is inter- preted to be contained in another if its \nvalue is stored in it ( EIFFEL S expanded), while reference representation is used for non-containment \nassociations. But despite the explicit claims [24] of the designers of BETA [31], reference semantics \nis not exclusive to associations in that language as in others. Reference semantics is used in many cases \nfor implementation convenience, for over-coming problems of creating and managing large wholes 7Conversely, \nwe can remark that it is not even essential that the composition root itself be accessible. In a parse \ntree applica-tion, for example, there may be no need for direct access to the single composition root. \nand wholes with a variable number of parts, and for handling cases where garbage collecting environments \nprevent the realization of property (iv) with value se-mantics of the containment. Note also, that despite \nits smoothness and safety, property (vii) is not supported directly in mainstream languages. The consideration \nof issues of acquisition may help in the dilemma of discerning WPA from other kinds of associations. \nThis dilemma is expressed in Civello s words [9]: While it is generally acknowledged that WPAs bind classes \nmore strongly than other associa-tions, there are no further rules or constraints to guide design and \nimplementation decisions. If acquisition occurs along specific links then these links are more likely \nto be classified as containments, although as we have seen, there are cases of acquisition along other \nkinds of links. The term whole in the acronym WPA does not co-incide entirely with our understanding \nof the compos-ite notion. In [9]: Civello also suggests classification of wholes as assemblies in which \nWPAs are functional, or as either aggregates or tuples in which both WPAs are non-functional. We believe \nthat acquisition along aggregation links should occur only along functional WPAs. However, it should \nalso occur along spatial or temporal inclusions which are not WPAs according to Civello s taxonomy. \n 3.2 Nonaggregation links Although our chief example for acquisition is through containment links, there \nare cases of acquisition of fea-tures along other links. The environment of an object might contain the \nsender of the message, the set of con-tainers, or the creator of the object ([22] for example presents \na language mechanism for allowing an object to inherit behaviour from its creator). We generalize the \nconcept of acquisition by allow-ing acquisition to occur through an arbitrary system of links that has \na forest topology and is similar in struc-ture to containment. By this we mean chiefly properties (i)-(iii) \nand (vii). Properties (iv)-(vi) are significant as well, but they are usually only a concern in containment \nin which the binding between the objects is so strong that a clear boundary must be set bet,ween t~hem. \nEx-amples for containment-like hierarchies are the relation between an object and its creator [22] and \nownership as in Car-Owner. Another possible generalization is multiple environ-mental acquisition: this \noccurs e.g., in the armed forces and other large organizations where there are two chains of commands: \nprofessional and organizational. An artillery officer might report organizationally to the brigadier \nand professionally to the chief artillery com-mander. We leave this generalization beyond the scope of \nthis paper, and, sufficing ourselves with the intuition and the motivation built upon the motivating \nexam-ples, concentrate on issues of the theory of acquisition itself. The main virtue of containments \nand containment-like hierarchies is the ability to use transitive closure in acquisition. If an object \na is contained in b and b is con-tained in c, then a may acquire features from c, even if b does not \nacquire them. Current applications us-ing attribute grammars are cumbersome because copy rules must be \nused to propagate the values of attributes. Great simplifications are achieved using what we may call \nleap acquisition, arising from this transitive closure. Yet another generalization step is that of allowing \nacquisition across arbitrary links. However, with this generalization, the uniformity of the links is \nlost; the notion of transitive closures may thus lose its meaning. Although it may be technically possible \nto extend the definitions to enable leap acquisition in such a case, we will refrain from doing so. To \nsmoothen t.he discourse, we limit the technical discussion to containment rela- tionships only. It should \nbe obvious that no generality is lost.   Static acquisition Acquisition could be implemented by letting \nall objects store a reference to their immediate enclosing compos-ite, if one exists. The standard binding \nof messages to methods can then be altered so that if a message is not recognized by a receiver, it is \nresent to its composite. Resends could be done in a forwarding manner, i.e., method execution in the \ncontext of the composite, or in a delegation manner, that is method execution in the context of the original \nreceiver. s The implementation of this seemingly-simple scheme is difficult in statically-typed compiled \nlanguages such as Ctt; sophisticated tricks such as the one presented in [ll, Section 9.21 are required \nfor tampering with the builtin dynamic binding mechanism. Implementation is more feasible, however, in \nSMALLTALK and other dy-namically typed languages which poses runtime reflec-tive capabilities. Nevertheless, \nin both implementations much is left to be desired in terms of safety and ease of use. The sender of \na message must be familiar with the runtime environment of the receiver in order to know if the messages \nwill be recognized or not. Lack of safety is also the source of difficulty in an implementation in 8The \nfollowing section explains why forwarding is preferred over delegation for acquisition, but this distinction \nis of secondary importance here. Ct+-like languages: the protocol of an object can only be determined \nat runtime. To obtain type safety, a programming environment supporting acquisition must be able to generate \nand prove predicates such as instances of Ci can only occur as direct components of instances of Cz , \ninstances of Cr can only occur as direct or indirect components of instances of C2 , and instances of \nCi may occur as direct components of instances of (32 . Further, since as explained above, the interface \nof a component lists the acquired features that are part of its interface, the environment must be able \nto make deductions of similar nature with regard to individual features. 4.1 Environmental polymorphism \nThe main difficulty in carrying out static analysis is the accounting for the environmental polymorphism, \ni.e., the uncertainty that stems from the multitude of po-tential configurations of the composition hierarchy \nat runtime. There are two sources to this uncertainty: 4.1.1 Containment freedom The same component may \nbelong to composites of dif-ferent classes or even occur standalone. Examining Fig-ure 5 for example, \nwe see that Door may acquire colour and airline. A Door may be part of a Car or a part of an Airplane \nbut never both. Acquisition of neither can be guaranteed.  4.1.2 Subtype polymorphism Determining all \npossible composites a class may be part of is done by a traversal of the graph of classes and the composition \nlinks that connect them. Curiously enough, subtype polymorphism makes it necessary to examine, for each \nclass encountered in the traversal, all of its superclasses, a.11 of its subclasses and even all su-perclasses \nof all of its subclasses. To understand this, Auto-part Vehicle driver 4 D00r Figure 5: Environmental \npolymorphism consider the two distinct ways in which subtype poly-morphism may effect acquisition: Component \nPolymorphism If a superclass of a certain class may be contained in a composite, then so might the class \nitself. In Figure 5, a Trunk-door may be contained in a Car. Composite Polymorphism If a class may serve \nas a composite of a certain component, then all classes in-heriting from this class are potential composites \nof that component. Consequently, when we go from the com-ponent to the composite through a specific composition \nlink, there is uncertainty with regard to the actual class of the composite. If that composite is in \nturn a com-ponent of yet anot#her composite, then its polymorphic nature must be taken into account. \nIn other words, composite polymorphism means that if a subclass of a certain class may be contained in \nsome other class, then (non-immediate) instances of this class may also be contained in this composite. \nIn Figure 5, we have that some Auto-parts may be contained in a Car. More generally, in a multiple inheritance \nsetting, non-immediate instances of a class that shares a heir with another class, may be contained in \nany composite that contains instances of that other class. In Figure 5, some Cars may be contained in \na Box. To handle cases where a component cannot be guar-anteed to acquire a feature, we employ two standard \ntechniques: a default action or value for missing fea-tures and a guarded computation mechanism similar \nto ML s case operator [36] and C s ternary operator, cond? expl : exp2, where expl and exp2 (the true \nand the false branches) are of the same type. These tech-niques should be used to capture uncertainty \ndue to containment freedom and due to component polymor-phism; protection against uncertainty due to \ncompos-ite polymorphism is more appropriately taken care of by dynamic binding. In the example we have \nthat an Auto-part may have a pla-y-age feature in its environ-ment if it happens to also be an instance \nof Door which happens to also be part of an instance of a Match-box-car. However, this property is not \nallowed to be ac- quired since checking whether or not it exists is nothing else than a baroque mechanism \nof runtime type infor- mation of objects-a technique that. is better avoided whenever possible.   4.2 \nKinships between classes This subsection gives a precise meaning to the sentence a class Ci may be contained \nin a class Cz , writ- ten as Ci c C2. This meaning accounts for contain-ment freedom and for component \npolymorphism but specifically excludes composite polymorphism from the semantics of the word may . In \nFigure 5, we will have that Door &#38; Car, but that none of the pairs (Auto-part,Car), (D oor,Vehicle), \nand (Door,Box) stand in the , relationship. Note that if Ci C Cz, then all features that Ci ac-quires \nfrom Cz must have default values or be used only with guarded expressions. Guaranteed acquisition of \na feature can only be done if is known that Ci must be contained in C2 . The precise meaning for this \nsentence (Definition 4.3) includes all sources of runtime uncer-tainty, since in this case, a feature \nthat Ci acquires from Cz can be used without guards in all possible con-figurations of the runtime hierarchy. \nThe remainder of this section gives formal defini-tions for the so-inclined readers. These definitions \ncan be readily translated to algorithms. The follow-ing notations are pertinent: For t,wo classes C, \nC , we write C < C if C inherits directly or indirectly from C andC<C ifC<C orC=C . AclassChasa set of \nslots S(C). Members of S(C) are pairs of the form (n, D), n being a named place holder for a com-ponent \nof class D. Also, let S (C) be the set of all inherited slots of C, i.e., S (C) = Uccc, S(C ) . -For \nsimplicity, we assume that no overloading oc-curs. Every slot name n is introduced in exactly one class \nwhich we denote by Intro(n). That is to say. no name n appears in more than one set S(C). (Overload-ing \nfans who dislike this restriction may use classes to tag overloaded names.) One exception to account \nfor property (vii) applies, if (n, D) E S(C) and if C < C , D < D , then we may also find that (n, U \n) E S(C ). Still, S (C) would contain only one copy of R as part of the pair (n, D) ( usual overriding). \nW.1.o.g. , there is also a unique frozen root c1a.s~ ~ R which makes roots of composition trees; only \ninstances of R can serve as such roots; there is a single slot (r>R ) E S(R); only subclasses of RI can \ninstantiate immediate components of roots. 4.2.1 May kinship As explained above, when analyzing potential \ncontain-ment relations, we must look at classes that are related by a common subclass. If D 5 Cr and \nalso D 5 Cz, then an object contained in a slot defined in Cr may acquire features defined in Ca. gFrozen \nclasses are classes that cannot be further used for inheritance. The root class R should not be confused \nwith Any that is sometimes used to denote the root of the inheritance tree. Figure 6: A containment \nWe write C -&#38;-C to denote that C and C are related via a common subclass D. We write C $C to denote \nthat n is a slot satisfying (n, C ) E S(C). Definition 4.1 A containment path is a sequence Dk-1   \nlr=c,~c~2c,~...-c~~, %c, where Ck is the root class R. (Figure 6) . We say that a class D dominates \na containment path P if there exists a class Di on T, such that Di 2 D. . We say that a containment path \nT covers a class D if D 5 Ci and D 5 C[, for a pair of classes Ci, Ci on x. Dominance of a containment \npath starting with a class CO is a necessary condition for environmentally affecting Co s interface. \nIf D dominates a particular containment path (that starts wit#h Co), then Co is po-tentially contained \nin D. If all containment paths that start with Co are dominated by D, then Co is necessar-ily contained \nin D. May-and must-kinships are based on potential-and necessary-conta.inment, respectively, with few \nadditional constraints. The concept of coverage captures uncertainty due to composite polymorphism, that \nis, the freedom of choos-ing the actual composites Do, D1,. , Dk-1. A defini-tion of may kinship has \nto ensure that nothing is re-vealed about the subtype of the composite. Suppose that we have that a class \nC may be contained in a class D. Then, the environmental acquisition mecha-nism makes it possible to \ndetermine in runtime for any specific object of C if it is contained in an object of D. We would like \nto limit this runtime power to exactly this. Specifically, if D < D or D < D then the envi-ronmental \nacquisition mechanism should not give rise to a possibility of determining whether an object of C is \nin an object of D or D . path from CO to Ck. There are several other subtleties in the definition of \nmay kinship which are not discussed in t,his proceedings version of this paper. As it turns out the appropriate \ndefinition for may kinship is: Definition 4.2 We say that a class C may be con-tained in a class D, C \nE D, if all containment paths that start with C and couer D are also dominated by D. 4.2.2 Must kinship \nIt is harmless to ignore some potential containment paths in may kinship. Not so for the must kinship. \nWe need to examine all potential paths to ensure that an instance of the component, can only be contained \nin an instance of the composite. Yet, must-kinship overrules some containments that satisfy this condition \nbut their safety is coincidental in nature rather than captured in the design. Again, we can obtain that \nan adequate definition for must kinship is: Definition 4.3 We say that a class C must be con-tained in \na class D, C 4 D, if there exist a slot n such that all containment paths that start with C are dominated \nby D, pass through n, and D = Intro(n). With regards to inheritance, the must kinship takes into account \nboth component and composite subtype poly-morphism as follows: C 4 D only if C + D for any C such that \nC 5 C or C 5 C .  5 Acquisition of features Now that the may and must kinships are elucidated, we can \ndeepen our study of acquisition by investigating the issues arising when specific features are acquired. \n5.1 Acquisition of routines Inheritance, as a relation among classes, pertains only to features which \nare shared by all instances of the class: methods, structure and potentially also class variables. As \nexplained in the introduction, acquisition, as a rela-tion between classes, deals also with features \nwhich are particular to an object (attribute values). To gradually reach understanding of this, our study \nbegins with ex-amination of routines. Routines are conceptually sim-pler than attributes in the sense \nthat they are read-only features. In most object-oriented systems (excepting perhaps Delphi) objects \ncannot replace routines defined in the class. The simplest case of routine acquisition occurs when a \nclass must be contained in another class. In this case, we can use the following EIFFEL-like syntax to \ndeclare an acquired routine: class Paragraph feature acquire emphasize0 . . . end Paragraph (Recall \nthat acquired features must be declared ex-plicitly. After all, we do not want a Door to acci-dently \nacquire a method to start the engine.) The compiler must now check that there exists a class that defines \nemphasize such that Paragraph must be con-tained in that class. For example, it may find that an emphasize \nmethod is defined in a class Document and that Paragraph 4 Document. What happens if there exists some \nother class, say Section, that defines emphasize, and Paragraph must (or even just may) be contained \nin it? An instance of Para-graph would then acquire emphasize of the inner most composite object that \nhas it, be it of class Document or Section. This is fine as long as Document.emphasize and Section.emphasize \nare basically the same feature. That is to say, if there is a common ancestor of Sec-tion and Document, \nsay Formatting-Entity that, defines emphasize. If there is no such ances-tor, then Document.emphasize \nand Section.emphasize are tied only by means of name overloading. Such a tie is coincidental in nature; \nthere is no certainty of agreement or even conformance between the types of the two features. If the \nfeatures were intrinsically re-lated, then a skilled designer should have captured this in a common ancestor. \nWe allow acquisition of an overloaded attribute only if the overloading ambiguity is resolved with explicit \nqualification of the defining class name. Incidentally, another consequence of the above deliberation \nis that a good acquisition system must support multiple inheri-tance so as to enable factoring of common \nfeatures into appropriate base classes. The next case to consider is acquisition in may kin- ship. Consider \ntwo classes Cl, Cz such that Cl may be in Ca, but it is not guaranteed that 6 1 must be in Ca, i.e., \nCl E Cz and Cl + Ca. Suppose that, Cz defines a feature f. It would be unsafe to invoke, by means of \nac- quisition, the feature f from Cx unless f is defined also in Cl. If C1. f takes precedence over \nC2.f) then C2.f can never be called, and this would render acquisition pointless. Conversely, an interesting \nand useful semantics is ob- tained when letting C2.f take precedence over C1.f. For example, a black \nDoor put in a white Car should turn white. But once removed from it, it should show black again. Notice \nthat the precedence is in opposite direction than what happens with ordinary inheritance. A class that \ninherits a feature may override it. A class that acquires a feature must supply a default imple-mentation \nto it; the acquired feature takes precedence over that default. Routines that are acquired through a \nmay kinship are defined as follows: class Window  feature may acquire help0 default is . end help . \n. end Window In inheritance a routine may refine its inherited im-plementation. Is it also possible \nfor a routine to refine its acquired implementation? The default implemen-tation of help cannot call \nits acquired version, since it is invoked exactly when there is not such an acquired version. In contrast, \nin the case of must kinship, refine-ment is possible. class Quotation feature  acquire left-margino: \nLength overrule is return acquired left-mar&#38;() + I cm end left-margin . end Quotation The overrule \nkeyword signifies that the implementma-tion of left-margin in the current instance of Quotation takes \nprecedence over the acquired one. A default implementation in a must kinship is mean-ingless. All that \nremains is therefore to consider the case of an overrule implementation in may kinship, which makes sense \nonly if the overruling implementa-tion calls the acquired one. Although it is not entirely clear that \nthis must be supported, we describe how it can be done. For a type safe implementation, we are obliged \nto introduce a language construct mirror-ing ML s case, where it is used for safe examination of variant \nrecords. class Enumeration  feature may acquire itemsep(): Length overrule is return 0.8 * acquired \nitemsep() guard 0.5cm end itemsep . . . end Enumeration The guard clause provides a default value to \nthe re-turn expression when the acquired feature itemsep is not present. In words, the above states that \nitem sepa-ration in a nested enumeration is 80% of the innermost enclosing enumeration and that it is \nhalf a centimeter in an external enumeration. Note that Enumeration may probably acquire from itself. \nThe guard clause makes it possible to call a may acquire routine from outside of the acquiring class. \nTherefore, it is deprecated but not forbidden to declare such a routine with no default implementation: \nclass Component feature may acquire foo(): Boolean; --No body for foo here! . . end Component . . x: \nComponent if x.foo guard true then . Table 1 summarizes the proposed syntax and seman- tics of routines \nacquisition.   5.2 Context of execution of acquired routines So far, we tacitly ignored the issue of \nthe context of ex-ecution of acquired routines. There are two possible semantics corresponding to ordinary \n(static binding) and virtual (dynamic binding) of function members in C++. This distinction is also known \nas, especially in the context of links between distinct objects, the quar-rel between forwarding and \ndelegation semantics. Forwarding means that the context of the initiating object is forgotten during \nthe execution of an acquired routine of this object. If this routine uses a certain feature, then this \nfeature is understood in the context of the object of the current execution thread. Delegation means \nthat the feature is sought in the context of the initiating object. Dynamic binding and static binding \ngeneralize del-egation and forwarding in prescribing the context of features selection also for polymorphic \ncode that is ex-ternal to the class. For example, a non-method routine that has a formal parameter of \na certain class, may also receive an object of any of its subclasses. Dynamic binding dictates that the \ndynamic (actual) class of an object is used in interpreting the messages sent to it; in static binding, \nthe static (declared) class is used in-stead. Since acquisition does not impose subtyping, only the more \nrestricted terminology is relevant. Put differently, a component cannot be used in a general context \nwhere a composite is expected. In the case of may kinship, such use is not type safe because it cannot \nbe guar-anteed that the component has or can acquire all the features the composite has. Even with must \nkinship, there is the problem that not all the features of the composite are sensible for the component-it \nis not ap-propriate to send a message to a door enquiring it for its number of wheels, even though it \nis guaranteed that a door is always a part of a car. Let us therefore limit the discussion to the question \nof binding in a method, i.e., a routine defined within a class (as opposed to a general routine). Suppose \nthat such a method of a class z uses a feature f on the current object. Then, in the forwarding semantics, \nall that is required in order to guarantee that f is found in run time, is to check that it is defined \nin 2. A moment s reflection would show that this static check covers also delegation, even in the case \nof may kinship. The search for f is conducted along the chain of contained in links starting from the \ninitiating object. The search must succeed since the chain includes also the current object of class \nz that defines f. The fact that, delegation semantics is type-safe does not necessarily imply that it \nshould be preferred over forwarding. There are several good reasons to use for-warding semantics in all \nbut very special cases. First, it is counter intuitive to have different semantics for inter-nal and \nexternal routines. This would imply, for exam-ple, that the set of acquired features varies depending \non whether you view it from inside or from outside the class. Second, acquisition encompasses a sophisticated \nmechanism of polymorphism by itself; delegation adds to this, and to the usual sub-type dynamic binding, \nKinship Declaration Syntax Comments not embodied may acquire f Use with guard may embodied default may \nacquire f default is . Safe to use; no refinement overrule may acquire f overrule is . . . Safe to use; \nrefinement with guard must not embodied acquire f Safe to use. embodied default Senseless-never invoked \nN/A overrule acauire f overrule is . . Safe to use; safe refinement Table 1: Summary of routine acquisition. \nyet another dimension of complexity. Third, in many cases where delegation semantics is required, it \ncan be implemented by means of inheritance. For example, a method for computing the paragraph indentation \nlevel in a text processing system could read parindento: Length return leftmargin() + lcm end parindent \n If parindent is an acquired feature, then we must com- pute leftmargin within the context of the acquiring \nob-ject. However, a better design would make parindent an inherited, not acquired feature. Fourth, within \nthe semantics of inherited attributes in attribute gram- mars (one of the thoroughly studied examples \nof acqui- sition), the attributes are computed in a local context and only then propagated further. There \ncould be cases in which delegation semantics may be required also for acquisition. For example, one may \nwant to apply different algorithms for computing the paragraph indentation in footnotes and in ordinary \ntext. For that reason, we do allow delegation semantics for acquisition as well, and suggest that they \nboth may play an important role. This is in contrast to the case of inheritance, in which the existence \nof non-virtual function members have no useful semantics, and their existence is just another symptom \nof the C++ design philosophy of not penalizing a programmer for an un-used language feature. 5.3 Acquisition \nof attributes Many of the conclusions drawn in the study of acquisi-tion of routines are also applicable \nto acquisition of at-tributes. If we forget for a moment that values may be assigned to attributes, they \ncan be treated as functions with no parameters in which no overriding is allowed. The picture is complicated \nthough if assignment is recalled. If an acquired attribute is also embodied in the acquiring class, then \na-priori, the acquired value should take precedence. Later, the precedence could change. It should be \npossible to paint just the door green after it had been placed in a white car. We propose the following \noperational model for the precedence of embodied attributes: With each such a.ttribute we associate an \nauxiliary flag that controls whether the component takes precedence over the com-posite or vise versa. \nThe flag may be in one of two states: default or overrule. The sema.ntics of these two are in accordance \nwith the default and overrule keywords used in defining bodies for routines. Initially, when an object \nis created and the embodied attribute is initialized, the flag is default. When an at-tribute of a certain \nobject is modified, its auxiliary flag becomes overrule. In addition, the flags of all embod-ied attributes \nacquiring the modified attribute become default. Thus, by painting the car blue, all doors be-come blue \nas well. By further painting a particular door of the same car green, the door s handle becomes green \nas the door, but the car as a whole remains blue. When a free object is inserted into a composite, all \nauxiliary flags of that object are set to default, thus supporting the black-white door colour flipping \nbehaviour described above. The flags do not need to change when an object is removed from a composite. \nThere are attributes which have a special undefined value. If an attribute is assigned undefined, then \nits flag becomes default. The auxiliary flag of the embod-ied attribute that acquire from this attribut,e \ndoes not change in this kind of assignment. In a Delphi like system, in which routines can be overridden \nby single objects, similar semantics applies to routines. Table 2 summarizes the proposed syntax and \nseman-tics of attribute acquisition. As it is for routines, the acquire clause for an attribute is eit,her \nunmodified-signifying that acquired value is not guaranteed or ac-companied with a may modifier-in which \ncase no such guarantee can be made. In both cases, the attribute may be also embodied in the class. An \nembodied at-tribute may have an initializer, i.e., an expression used for initializing it at the time \nof object construction. Acquired attributes can be used safely, except in the case of may acquire with \nno embodied, where they should be used with guard (type safety Chauvinists may want to forbid this case). \nThe initializer may use the acquired value, but only with guard in the case of may acquire. In contrast \nwith Table 1, default and overrule semantics is determined dynamically as described above and therefore \nis not described in this table. Kinship Declaration Syntax Comments may not embodied may acquire f Use \nwith guard embodied may acquire f embodied [ := . . . 1 Safe to use; initializer may use acquired value \nwith guard.- must not embodied acquire f Safe to use. embodied acquire f embodied C := . . . 1 Safe to \nuse; initializer may use acquired value safely. Table 2: Summary of attribute acquisition The rvalue \nof an acquired attribute is one of the em-bodied attributes incident on the contained in chain that starts \nat the object. There are three possible se-mantics of the halve of such an attribute: the embod-ied attribute \nin the object itself, the nearest enclosing attribute, and the effective enclosing attribute. We envisage \na system in which assignment is nor-mally done to the embodiment in the object but that has provisions \nfor the other two semantics. Assignment to the nearest enclosing in the case of no embodiment is useful, \ne.g., for upward propagation of synthesized attributes in an attribute grammar application. For example, \ninside the parse tree of a nested C++ class, an assignment to an acquired symbol table should occur at \nthe nearest enclosing scope that, embodies a symbol table. Assignment to the effective attribute is also \nuseful. In a drawing program, it should be possible to repaint a distinctly painted part of a whole even \nthrough one of its subparts.  6 Comparison to other models and related works In this section we briefly \ncompare acquisition to other related work. We first explain why some common 00 constructs do not constitute \nby themselves an acqui- sition system and then turn into comparing our work with recent advances.  6.1 \nState as it is recorded in instance variables It is possible to implement acquisition using object state. \nAn object may contain a pointer to its com-posite (immediate container). By following the chain of pointers \nit is possible to implement all of the intri-cacies of the acquisition. Indeed, systems such as TI$, \nInterviews, TurboVision and many attribute grammar compilers do exactly this kind of emulation. One may \ntherefore argue that the state of an object, including the value of this pointer includes all information \nrequired for acquisition. We disagree with this claim because of the following two reasons: First, as \nshould be clear by now, acquisition is far from being trivial. Its inherent complexity cannot be covered \nup. Re-implementation, as done for example in the software systems mentioned, is bound to be compli-cated, \ninefficient, and in many cases lacking a well de-fined semantics. It is instructive to consider the case \nof att,ribute grammars. Although there is a huge body of work on their efficient implementation, they \nhave failed to become popular. We feel that this is partly due to the fact that the algorithms were not \npackaged in a well defined language construct, and the need to enumerate all inherited attributes puts \na heavy burden on the user. Second, we feel it is wrong to blur the boundary be-tween objects by stret.ching \nthe meaning of the term state to include external objects to which pointers are stored. A network of \nobjects, including perhaps all objects of a system, could be thus made into a single object. Further, \nsince in general pointers are not bidi-rectional, and since there might be variables pointing to various \nlocations in the network, a complicated seman-tics would have to be called in to describe the complex \nrelationship between a subobject which corresponds to connected component of a directed graph. Instead, \nwe feel that if there is a consistent pattern of acquisition of properties from one object by another, \nthen it is bet- ter to define an abstraction mechanism that captures this pattern. Acquisition, and in \nparticular the over- rule/default mechanism described above, gives a good balance between state change, \nthe change undertaken by the object itself, and the environmental influence. 6.2 Inheritance runtime \nsystems, such as that of SELF,which already Inheritance is a relation between classes, whereas ac-quisition \npertains to individual objects. Other reasons why inheritance cannot serve for acquisition are given \nin the following discussion of dynamic inheritance.  6.3 Dynamic inheritance Here we take this term \nin its restricted sense-a sense also called configurable inheritance [18]: if a class C is declared as \ninheriting from C , then the sub-object of objects of C, which correspond to the base-class C , may also \nbe of a class C which also inherits from C . Loosely, C may also inherit at run time from any class C \nwhich inherits from C. Stroustrup [42, Section 12.71 reports on a C++ extension proposal accompanied \nby an implementation experiment to that effect. Had this proposal of delegation , as it is called there, \nbeen accepted, it could have only approximate acquisition, falling short in several important ways: 1. \nDynamic inheritance, just as a static one, induces a subtype relationship. This is usually undesirable \nin acquisition: a component is not necessarily a subtype of its enclosing composite. Observe that private \ninheritance merely restricts the visibility of sub-typing (as suggested in [40]) but does not exclude \nit altogether. 2. There is usually an orthogonal hierarchy classifying the kinds of objects that may \noccur in the contain-ment hierarchy. Mixing the two hierarchies at the cost of the complexities of multiple \ninheritance and at the risk of blurring the distinction between the two hierarchies is worse. 3. It \nis inherent to acquisition that an inherited sub-object (a composite) is shared by many objects (its \ninheriting components). Such sharing contra-dicts our usual understanding of inheritance.  This latter \nhindrance is the main reason for the failure of this experiment. 6.4 Prototypes To emulate an acquisition \nin a prototyping system one would, as another approximation, replace substitute containment links with \ndelegating ones. Several problems arise. The first, and perhaps the easiest, is that of delegation vs. \nforwarding. As men-tioned above, both semantics are feasible and useful for acquisition. Clearly, adding \nsupport for forwarding to support delegation should be a simple task. Another problem is that, the containment \nlinks should be distinguishable from other links. This again could be done via relatively easy syntactical \nchanges. Another change required is reversing t,he links direc-tions so that the composite has slots \nfor the components and not vice-versa. Although no delegation system that we know of implements this, \nsuch an addition does not seem too problematic. The third, and most difficult problem: delegation systems, \nalmost by nature, subvert strong typing. Be-yond the usual benefits of strong typing, such as im-proved \nefficiency and reliability, we argued above that acquisition should be done in a strongly-typed man-ner. \nInthis respect, our research can be viewed as an attempt to investigate strong typing of a restricted \nform of a delegation system. The more general problem should be the subject of another investigation. \n 6.5 Other related work Blake and Cook [2] deal with the issue of support to containment hierarchy in \n00 languages. They com-pare part hierarchies with inheritance and delegation and provide a mini-taxonomy \nfor kinds of containment relationships. They also identify the dilemma of the visibility of parts, and \nargue strongly that exposing the parts does not violate encapsulation. (Thus support-ing property (iv) \no f ours). Specifically they propose, implement and report on the lessons learned from a SMALLTALK extension \nin which the composite forwards messages to its components. Another aspect in which their work is different \nfrom ours is that they tacitly ignore the question of strong typing and optional com-ponents. In our \nmodel strong typing and optional par-ents play an important role. We were unable to deter-mine if Blake \nand Cook s work makes the distinction between part and attribute links. Kim et. al [23] examine the question \nof composite objects in 00 database systems. They also argue that the composition links should be distinguishable \nfrom other links. They provide a formal definition of the data model of composite objects a,nd show how \nthey might be used in a database system by addressing questions such as locking and efficiency. One of \ntheir interesting contributions is the support for versions of composite objects. (This is similar to \nthe work in Vesta [6].) As it is common in databases, it is assumed in their work that parts have external \nvisibility. No treatise is given to the question of propagating properties inside the composite object. \nWe consider using their results in testing our proposal on large inputs, such as legacy systems, which \nneed to be reverse engineered. Kristensen [27] argues for and proposes lingual mech-anisms to support \ngeneral complex associations, includ-ing special notations for containment. In this sense and in the \nstrong ties his work has with formal methodolo-gies of analysis and designl , it is more general than \nours. IIowever, acquisition is much more powerful than a mere existence of a containment link.  Conclusions, \nOpen Questions and F urt her Research This paper demonstrated the need for down propaga- tion of attributes \nin containment hierarchies. This is just a special case of a phenomena that often shows up in the development \nof even modest-sized 00 systems: an object behaviour depends on its surrounding envi- ronment. The broader \nquestion that we try to solve is the modeling of environmental affect, i.e., the ways in which the environment \nparticipates in setting the prop- erties of an object. It is clear that an object is not a specialization \nof its container or any other element of its environment. Therefore, it is not appropriate to let an \nobject inherit from its environment. Instead, the traditional tech-nique for modeling such an affect \nis by interfaces that are tailored for each kind of environmental link. De-spite its appealing simplicity, \nthis approach suffers from several drawbacks: 1. Instead of the convenient separation between pub-lic \ninterface and implementation, objects must posses dedicated environment interface(s). 2. The design \nand implementation of such interfaces is difficult and repetitive. 3. Environmental affect by non-immediate \nneigh-bours is tricky. What we called leap acquisition is a powerful tool that is difficult to use in \nthe absence of a good understanding of the involved issues.  The new acquisition mechanism we advert \noffers a compromise between inheritance and a tailored solu-tion. It is not as elegant and easy to understand \nas in-heritance (but then, so are real life programming prob-lems) but it is much more appropriate for \nmodeling environmental affect. On the other hand, acquisition is more orderly and more elegant than a \ntailored dynamic solution which tends to be error-prone, inefficient and discouraging to the implementor. \nI1 In this respect, it should be compared to the work of Civ-ello [9] Our investigation revolved around \nthe example of ac-quisition a.cross aggregation links. The results however, are applicable directly to \nacquisition in other forest hi-erarchies and from immediate general neighbours. The generalization to \nother network topologies and leap ac-quisition across non uniform links is a subject for fur-ther research. \nAmong the surprising discoveries of this research we include the illusive character of the definitions \nof the may and must kinships: We saw that in order to prove that an object of a certain class must be \ncontained in an object of another class, one has to consider carefully the containment relationships \nbetween all super-and subclasses of both these classes. Also, the may kinship may, if not defined properly, \ncapture instead of struc-ture freedom, the dynamic type of objects; information that is better handled \nby other means in good object-oriented programming. Most design methodologies represent relationships \nand objects, but offer almost no rules or guidelines of how these should interact with inheritance. A \npromis-ing research objective is better insight of the interde-pendencies between inheritance and containment \nand other links among objects. This hopefully will result in a coherent set of rules similar to property \n(vii) to guide design and enable more structured reasoning. Even though our understanding of the permissible \ntopologies in the inheritance-containment diagram is lacking, and we allow many constellations which \nshould never occur in a well designed system, static type analy-sis can eliminate many possibilities \nand help a dynamic implementation. We can show that this analysis can be done in O(1) calls to a directed \ngraph s-t connectivity algorithm. We identified the basic rules of acquisition of rou-tines, and in particular \nhow refinement and overrid-ing carry on to it. The term environmental polymor-phism was coined to designate \npolymorphic behaviour of objects due to their respective environments. We proposed an operational model \nfor environmental poly-morphism that uses a system of defaults and overrul-ings. The model seem to capture \nthe needs of current applications. With regard to implementation complexity, it is easy to imagine an \nefficient implementation if the contain-ment trees are static: if each acquisition is realized us-ing \na pointer then the time to access an acquired fea-ture is O(1). The problem becomes more difficult if \nwe want to cater for tree updates: insertion and deletion of components. Two solutions come to mind: \nIn the first, acquisition pointers are updated with each tree operation. This is an R(n,) (worst case) \ntime operation, where n is the number of objects in our system. In the second, there are no acquisition \npointers; instead each object has a pointer to its container. In this solution, updated are efficient, \nrunning in O(1) time, but queries are R(n). In both solutions though, the setting to default of an auxiliary \nflag in a whole sub-tree as a result of an as-signment to an attribute is an R(n) time operation. There \nis a sophisticated implementation approach that gives O(lg n) amortized (and at the cost of greater programming \ncomplexity, even O(lg n) worst-case) for all operations: insertions, deletions, query and flag flip-ping. \nThis is done using data structures based on Tar-jan and Sleator s dynamic trees [39] (See [44] for a \ntext book exposition.) Unfortunately, this can only be done if there is only one kind of an acquired \nattribute in the tree. If there are m kinds of attributes in the system, then the insertions and deletions \ntime increase by an m factor. What s worse, the storage requirements be-come O(mn). Our data structures \nintuition leads us to believe that much better implemenations are possible, but their existence remains \nan open problem. This research of course only opens the road to the understanding and using acquisition. \nThere are many lessons to be learned and data to be gathered from a large scale exploitation of this \nnew abstraction mecha-nism. Acknowledgment We thank William Cook for his thoughtful remarks on an early \nversion of this paper. References [II Accent Software International, Jerusalem, Israel. Dagesh User \ns Guide, Israel s National Word Proces- sor for Windows, 1994. E. Blake and S. Cook. On including part \nhierar-chies in object-oriented languages, with an implemen-tation in Smalltalk. In European Conference \non Object-Oriented Programming, number 276 in LNCS, pages 41-50. Springer-Verlag, 1987. PI G. Booth. \nObject Oriented Design with Applications. [31 Benjamin/Cummings, 1991. Borland International, Scotts \nValley, CA. Pascal Turbo Vision Programming Guide, 1992. [41 A. H. Borning. Classes versus prototypes \nin object- [51 oriented languages. In ACM/IEEE Fall Joint Com-puter Conference, pages 36-40, Dallas, \nTX, 1986. [61M. R. Brown and J. R. Ellis. Bridges: Tools to extend the vesta configuration management \nsys tern. Techni- cal Report 108, digital Systems Research Center, 130 Lytton Avenue, Palo Alto, California \n94301, June 1993. PI M. Bryan. SGML an Author s Guide to the Standard Generalized Markup Language. Addison-Wesley, \n1992. L. Cardelli and P. Wegner. On understanding types, PI data abstractions, and polymorphism. ACM \nComput. Surv., 17(4):471-522, 1985. F. Civello. Roles for composite objects in object- PI oriented analysis \nand design. In Proceedings of the 8rh Annual Conference on Object-Oriented Programming Systems, Languages, \nand Applications, pages 376-393, Washington, DC, USA, Sept. 26 -Oct. 1 1993. OOP-SLA 93, Acm SIGPLAN \nNotices 28(10) Oct. 1993. [101 P. Coad and E. Yourdon. Object-Oriented Design. Prentice-Hall, 1991. \nJ. Coplien. Advanced C+t Programming3 Styles and Idioms. Addison-Wesley, 1992. PII B. J. Cox. Object-Oriented \nProgramming -An Evolu-tionary Approach. Addison-Wesley, 1986. P21 S. E. Fahlman. NETL: A system for \nrepresenting and using real-world knowledge, 1979. P31 J. D. Foley and A. V. Dam. Fundamental of Interactive \nConputer Graphics. Addison-Wesley, 1984. P41 I. R. Forman, S. Danforth, and H. Madduri. Composi-tion \nof before/after metaclasses in SOM. In Proceedings of the gth Annual Conference on Object-Oriented Pro-gramming \nSystems, Languages, and Applications [35], P51 pages 427-439. E. Gamma, R. Helm, R. Johnson, and J. \nVlissides. De-sign Patterns: Elements of Reusable Object-Oriented Software. Professional Computing Series. \nAddison-Wesley, 1995. PI J. Gil and D. H. Lorenz. SOOP -a synthesizer of an object-oriented parser. \nIn Proceedings of the 16 h International Conference on Technology of Object-Oriented Languages and Systems, \npages 81-96, Ver-sailles, France, Mar. 6-10 1995. TOOLS 16 Europe Conference, Prentice-Hall. P71 J. \nGil and R. Szmit. Software boards via configurable objects. In Proceedings of the ldth International \nCon-ference on Technology of Object-Oriented Languages and Systems, CA, Aug. 1994. TOOLS 14 USA Con-ference, \nPrentice-Hall. P91A. Goldberg and D. Robson. Smalltalk-80: The Lan-guage and Its Implementation. Addison-Wesley, \n1983. r-201C. F. Goldfarb. The SGML Handbook. Clarendon Press, Oxford, 1990. W31 W. L. Hiirsch. Should \nsuperclasses be abstract? In WI M. Tokoro and R. Pareschi, editors, Proceedings of the gLh European \nConference on Object-Oriented Program-ming, number 821 in LNCS, pages 12-31, Bologna, Italy, July 4-8 \n1994. ECOOP 94, Springer-Verlag. P21G. Kiczales. Traces (a cut at the make isn t generic problem). In \nS. Nishio and A. Yonezawa, editors, Proceedings of the International Symposium on Ob-ject Technologies \nfor Advanced Software, number 742 in LNCS, pages 27-42, Kanazawa, Japan, Nov. 4-6 1993. First JSSST International \nSymposium, Springer Ver-lag. W. Kim, J. Banerjee, H. T. Chou, J. F. Garza, and [231 D. Woelk. Composite \nobject support in an object-oriented database system. In Proceedings of the ,@ Annual Conference on Object-Oriented \nProgramming Systems, Languages, and Applications [34], pages 118- 125. J. L. Knudsen, M. Lijfgren, 0. \nL. Madsen, and Mag- [241 nusson. Object-Oriented Environments, The MJ0L-NER Approach. Object-Oriented \nSeries. Prentice-Hall, 1993. D. E. Knuth. TheT&#38;X Boolc, volume A of Computers [25l &#38; Typesetting. \nAddison-Wesley, 1986. G. E. Krasner and S. T. Pope. A cookbook for using the model view controller user \ninterface paradigm in SMALLTALK-80. Journal of Object-Oriented Program-ming, 1(3):26-49, Aug.-Sept. 1988. \nWI B. B. Kristensen. Complex associations: Abstractions in object-oriented modeling. In Proceedings of \nthe gth Annual Conference on Object-Oriented Programming Systems, Languages, and Applications [35], pages \n2722 [27l 286. L. Lamport. LATEX: A Document Preparation System. P31 Addison-Wesley, 1986. Lieberman. \nUsing prototypical objects to imple-  P91H. ment shared behavior in object oriented systems. In Proceedings \nof the lst Annual Conference on Object-Oriented Programming Systems, Languages, and Ap-plications [33], \npages 214-223. M. A. Linton, J. M. Vlissides, and P. R. Calder. In-terviews: A C++ graphical interface \ntoolkit. Technical Report CSL-TR-88-358, Stanford University, Stanford, CA 94305-2192, July 1988. [30] \n0. L. Madsen, B. Moller-Pedersen, and K. Nygaard. [311 Object-Oriented Programming in the Beta Program-ming \nLanguage. Addison Wesley, 1993. B. Meyer. EIFFEL: The Language. Object-Oriented [321 Series. Prentice-Hall, \n1992. OOPSLA 86. Proceedings of the 1 Annual Conference [331 on Object-Oriented Programming Systems, \nLanguages, and Applications, Portland, Oregon, USA, Sept. 29 -Oct. 2 1986. Acm SIGPLAN Notices 21(11) \nNov. 1986. OOPSLA 87. Proceedings of the 2nd Annual Confer- 1341 ence on Object-Oriented Programming \nSystems, Lan-guages, and Applications, Orlando, Florida, USA, Oct. 1987. Acm SIGPLAN Notices 22(12) Dec. \n1987. [35] OOPSLA 94. Proceedings of the gth Annual Conference on Object-Oriented Programming Systems, \nLanguages, and Applications, Portland, Oregon, USA, Oct. 23-27 1994. Acm SIGPLAN Notices 29(10) Oct. \n1994. [36] L. C. Paulson. ML for the Working Programmer. Cam-bridge University Press, Cambridge, 1991. \n[37] Programmer s hierarchical interactive graphics system, 1986. J. Rumbaugh, M. Blaha, W. Premerlani, \nF. Eddy, and 1381 W. Lorensen. Object-Oriented Modeling and Design. Prentice-Hall, 1991. D. Sleator and \nR. Tarjan. A data structure for dynamic PI trees. .I. Comput. Syst. Sci., 24, 1983. A. Snyder. Encapsullation \nand inheritance in object- [491 oriented programming languages. In Proceedings of the 1 st Annual Conference \non Object-Oriented Program-ming Systems, Languages, and Applications [33], pages 38-45. C. Strachey. \nFundamental concepts inprogramming [411 languages. In Lecture Notes for the International Sum-mer School \nin Computer Programming, 1967. Copen-hagen, Denmark. B. Stroustrup. The Design and Evolution of Ctt. \n[421 Addison-Wesley, Mar. 1994.  Sun. Open Windows Library Manual. [431 R. E. Tarjan. Data Structures \nand Network Algorithms. [441 SIAM, Philadelphia, PA, 1983. T. Thompson and N. Baran. The NeXT computer. \nByte, 13(12):158-175, 1988. [451 X. T. Trinh, J. T. van Tran, and C. Balkowski. Physics of nearby galaxies: \nNature or nurture? In Proceedings of the 27rh Moriond Astrophysics Meetings, Les Arcs, Savoie, France, \nMar.15-22 1992. Editions Frontieres. [461 D. Ungar and R. B. Smith. SELF: The power of sim- [471 plicity. \nIn Proceedings of the 2nd Annual Conference on Object-Oriented Programming Systems, Languages, and Applications \n[34], pages 227-241.   \n\t\t\t", "proc_id": "236337", "abstract": "The class of an object is not necessarily the only determiner of its runtime behaviour. Often it is necessary to have an object behave differently depending upon the other objects to which it is connected. However, as it currently stands, object-oriented programming provides no support for this concept, and little recognition of its role in common, practical programming situations. This paper investigates a new programming paradigm, <i>environmental acquisition</i> in the context of <i>object aggregation</i>, in which objects acquire behaviour from their current containers at runtime. The key idea is that the behaviour of a component may depend upon its enclosing composite(s). In particular, we propose a form of feature sharing in which an object \"<i>inherits</i>\" features from the classes of objects in its environment. By examining the declaration of classes, it is possible to determine which kinds of classes <i>may</i> contain a component, and which components <i>must</i> be contained in a given kind of composite. These relationships are the basis for language constructs that supports acquisition. We develop the theory of acquisition that includes topics such as the kinds of links along which acquisition may occur, and the behaviour of routine (methods) and attribute features under acquisition. The proposed model for acquisition as a hierarchical abstraction mechanism is a strongly typed model that allows static type checking of programs exploiting this mechanism. We compare it to several other mechanisms including inheritance and delegation, and show that it is significantly different than these.", "authors": [{"name": "Joseph Gil", "author_profile_id": "81100349003", "affiliation": "The Faculty of Computer Science, Technion--Israel Institute of Technology, Technion City, Haifa 32000, Israel", "person_id": "PP14124925", "email_address": "", "orcid_id": ""}, {"name": "David H. Lorenz", "author_profile_id": "81100540418", "affiliation": "The Faculty of Computer Science, Technion--Israel Institute of Technology, Technion City, Haifa 32000, Israel", "person_id": "PP14187733", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236358", "year": "1996", "article_id": "236358", "conference": "OOPSLA", "title": "Environmental acquisition: a new inheritance-like abstraction mechanism", "url": "http://dl.acm.org/citation.cfm?id=236358"}