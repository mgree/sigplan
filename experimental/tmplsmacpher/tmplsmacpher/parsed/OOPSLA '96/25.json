{"article_publication_date": "10-01-1996", "fulltext": "\n Formal Design Constraints Nils Klarlund Jari Koistinen klarlund@research.att.com ebujak@ebu.ericsson.se \n Michael I. Schwartzbach mis@brics.dk Abstract Large software systems are often built on system platforms \nthat support or enforce specific char-acteristics of the source code or actual design. These characteristics \nare either captured infor- mally in design guideline documents or in spe- cialized design and implementation \nlanguages. In our view, both approaches are unsatisfac-tory. Informal descriptions do not allow auto-mated \nanalysis and lead to vague constraint de-scriptions. The language-based approach leads to different languages \nfor Afferent platforms and even for diflerent versions of the same basic platform. Our approach is to \ndescribe and name the constraints separately in a design constraint language called CDL, which is based \non an ex-traordinarily concise logic of parse trees. De-signs are then annotated with the names of the \nconstraints they are supposed to satisfy. We discuss how the design constraint lan-guage is integrated \ninto a design language envi-ronment. We exhibit industrial and experimen-tal evidence that our choice \nof design constraint language allows us to formalize naturally and succinctly common design characteristics. \nPermission to make digitalhard copy of part or all of this work for personal or classroom use is granted \nwithout fee provided that copies are not made or distributed for profit or commercial advantage, the \ncopyright notice, the title of the publication and its date appear, and notice is given that copying \nis by permission of ACM, Inc. To copy otherwise, to republish, tc post on servers, or to redistribute \nto lists, requires prior specific permission and/or a fee. OOPSLA 96 CA, USA 0 1996 ACM O-89791 -788-x/96/0010...$3.50 \n1 Introduction 1.1 Background Companies building large systems are com-monly using and sometimes developing \ntheir own system platforms. These platforms support the building of applications with specific characteristics. \nAs an example, telecommunication companies build plat-forms supporting signaling, error recovery, distribution, \nand other functionality needed in most telecommunications applications. The characteristics of a platform \nand an ap-plication architecture are expressed as a set of general design constraints. In order to use \nthese platforms in efficient or even correct ways, the programmer must ensure that de-sign constraints \nare satisfied. Examples of design constraints are: Classes with persistent in-stances should inherit \nonly from other classes with persistent instances and not provide asyn-chronous operations. Classes abstracting \nhardware resources should provide asyn-chronous operations and respond through an event channel. Such \nconstraints can be discovered in many specifications and architectural doc-uments. As an example, such \nconstraints can be found in the typed event service of the OMG Event Services [16]. In the OMG Event \nService the typed push model requires that the event consumer and the event sup-plier must have an agreed \nupon interface where operations may not return values nor have out or inout parameters. This is an ex-ample \nof a constraint that can not be defined in the OMG interface definition language it-self. Design constraints \nare often described in-formally in design guideline documents. For larger systems, specialized languages \nmay be developed that by their definition enforce the design rules. Both solutions have significant disadvantages. \nInformal descriptions are of-ten incomplete and ambiguous. They are also difficult to check, since this \ncan only be done through manual reviews. In contrast, specialized design languages are formal and allow \nautomatic checking. Their disadvantage is that the language must evolve with the platform and the differ- \nent applications. Unfortunately, proprietary platforms usually evolve rapidly-leading to situations where \nseveral versions of the plat-form are used simultaneously for different applications. 1.2 Contributions \nof this paper In this paper, we propose a design lan-guage, called Category Description Language (CDL), \nfor the explicit description of ar-chitectural aspects of platforms and soft-ware applications in a clear \nand unambigu-ous way. CDL is based on newly developed deci-sion procedures for logics on parse trees \n[9]. These logics, which are variations on first-order logic (predicate logic), can express quantification \nover nodes in a parse tree (and are thus of very high computational com-plexity). Consequently, informal \nconstraints on parse tree can often be transliterated di-rectly into CDL. In fact, we provide ex-perimental \nevidence that design constraints found in practice can be expressed very con-cisely in CDL-while still \nbeing computable by the decision procedure. Thus CDL offers substantial advantages of ease-of-use and \nreadability compared to e.g attributed gram-mars or recursive functions on parse trees. We show how CDL \ndesign constraints can be translated to attributed grammars from the output of the decision procedure. \nAny proposed design can then be held up against the attribute grammars to check that all con- straints \nare satisfied. The CDL ideas originates from the solu-tion of a real problem in designing languages and \nplatforms for large software systems at the telecommunications company Ericsson. At Ericsson, we have \nevaluated CDL for the development of distributed object-oriented systems, expressed in the DELOS [ll] \ndesign language on a proprietary platform with a Corba-like [15] architecture. The architectural style \nfor the proprietary platform was initially formulated informally by Ericsson designers working in telecommu- \nnications applications. (Such styles and the Delos language have been used for real appli-cations.) There \nwere on the order of 50 con-straints, and approximately 85-95% of these were readily expressible in CDL \n(and a few, when formalized, were found to be unneces-sary). Each constraint is specified in a cou-ple \nof lines like the examples we present in this paper. Some of these constraints are de-scribed in detail \nin the evaluation study [12]. By incorporating CDL as a part of the De-10s language we allow systems \narchitects to tailor Delos according to their own general design considerations. In this paper, we provide \nexamples of con- straints for designs expressed in both DELOS and OMG-IDL [15]. 1.3 An Introductory \nExample Let us illustrate our approach with a small example. Assume we want to use DELOS to design applications \nfor a OMG/Corba com-pliant object request broker. DELOS cov-ers more than interface definition, for inter- \nface definition it also provides functionality not available in OMG-IDL. Using DELOS as the interface \ndefinition language on a Corba compliant platform therefore involves defin-ing the appropriate constraints \non DELOS descriptions so that a design will satisfy the requirements of the Corba platform. One such \nconstraint is that Corba interfaces can-not pass objects as operation arguments-only references to objects \ncan be passed. Design constraints are imposed in two phases: . The constraints are named and de-scribed \nin CDL. A named set of con-straints is called a category. A set of categories is called an design style. \n. The source code of the actual design is annotated with the appropriate cate-gory names. To illustrate \nhow the method works from the programmers point of view, we illustrate the second phase, by an example \nin DELOS source code. Below an object type called subscriber is declared: OBJECT TYPE corba : subscriber \nIS ATTRIBUTES id : INTEGER  OPERATIONS addService(s : REFERENCE TO service); setStatus(st : status); \nEND END The object type has one public attribute and two public operations. The first operation addservice \ntakes an argument that is a refer- ence to an instance of the object type service. The second operation \nsetstatus takes an ob-ject of type status as argument and passes it as a value. In addition, subscriber \nis de- clared to satisfy the category corba, which describes the constraints associated with the Corba \nplatform. Below we outline the declaration of status, thus status is an object type. OBJECT TYPE status \nIS ATTRIBUTES . . . END The system architect has already in the first phase formalized the constraints \nof the corba category. For simplicity, let us look only at the constraint that operation argu-ments of \ncorba interfaces cannot denote ob-ject values. Informally, the constraint is: If x is an operation argument \nnode in the syntax tree of a corba object type, then the node y below denot- ing its type cannot represent \nan ob- ject type. To use Delos appropriately for design on Corba, the system architect has formalized \nthis constraint in CDL as CATEGORY corba FOR dam-ObjectTypeSpecification IS V x: domArgument. 3 y: dom-Type. \nx I y A 1 OT(y); END where the domX identifiers are DELOS syn-tax [ll] production names and OT(y) is \na DELOS specific predicate-defined in CDL, that evaluates to true if y is a node that de-notes an object \ntype. Does the actual design satisfy the category corba? No, since the name status used in the operation \nsetstatus above is an object type name. Thus the definition of subscriber would be rejected as an interface \nfor Corba.  1.4 The Design Cycle From the example above, we see that the use of CDL involves the following \nsteps: . Architectural style design. - A systems architect defines the ap-propriate set of categories \nand gen- eral constraints. - He (or she) uses the CDL decision procedure to verify that the style is \ninternally consistent, i.e. that the constraints are not mutually con-tradictory. . Application design. \n- The application developer selects the appropriate architectural style for the applications and develop-ment \nplatform that is used. -He (or she) annotates the design with the categories of the style. - He (or she) \nrequests automatic checks of the design against the style to determine whether the de-sign satisfies \nall categories. Tool support The systems architect may use a design ed-itor tool to define models in \ngraphical and textual representations. In addition to defin- ing classes and their interrelationship, \nthe system architect may also use the tool to de- fine interfaces in more detail. In particular, the \narchitect may adorn each design entity with the categories that it should satisfy. The screen below \nshows a DELOS tool, where the modules (rectangles) are anno-tated with names of categories. DELOS cat-egory \nnames are placed before the entity name, separated by a colon. The categories SE, SA, DefG, and SWILIB \nused in this ex-ample stem from a telecommunications ar-chitectural style. . In addition to the commands \nusually appli-cable in design editors, the proposed exten-sion of this tool will provide two additional \nmenu commands: . Load architectural style. . Check for satisfaction. The first menu alternative shown \nis used to load a style, i.e. a set of categories. The style loader is also a style compiler so that \nany syntactic errors in the style are de-tected and appropriate error messages are displayed. The style \nconsistency checker might be part of this command or it could be a separate tool or menu alternative. \n The check command is used when the ar-chitect or application designer wants to con-trol that one particular \ndesign satisfies the current style. In a more sophisticated tool, the satisfaction check could be performed \nin-crementally as the design is constructed. We are in the process of implementing CDL support for the \nDELOS tools. We have already prototyped the most difficult aspects of integrating CDL support into a \ndesign tool , including: . dynamic loading and checking of style with respect to a particular design; \nand . consistency checking of a style. We report in Section 4 on the technically most challenging aspect, \nnamely to translate styles into a format usable by a constraint checker. 1.5 Related Work A CDL description \ndefines formally a set of architectural concepts, called categories. The description does not represent \nany par-ticular architecture, rather it defines what can be called design style or architectural style \n[17]. In contrast, languages like AE-SOP [4] focus on the high-level description of architectures. With \nsuch languages, archi-tectural elements can be defined, and con-straints on their relationships can be \nim-posed. From such specifications, tools are generated that support the building of sys- tems respecting \na particular architecture. In [ 141, a comprehensive approach to spec- ifying regularities in large software \nsystems is outlined. These regularities are called laws of the system. They encompass both dy- namic \nand static properties. Dynamic prop- erties are checked or enforced during run- time. Static properties \nare enforced during com-pilation time by viewing the system un-der development as a collection of objects. \nWhen an object is changed, rules formulated in a logic programming language are in-voked. Thus as with \nour approach, the envi-ronment provides the enforcement of design constraints. The part of the method \nin [14] that deals with source code constraints does not make explicit how syntactic constraints like \nthe ones we consider should be modeled. Meyers et al. [13] describe a language called CCEL for defining \nconstraints on C++ programs. C++ programs can be stati-cally checked to satisfy associated CCEL con-straints. \nCCEL has C++ specific predicates -such as the is-friend predicate-and is therefore in principle only \napplicable to C++ programs. However, the ideas of CCEL and parts of its implementation can be used for \nother lan-guages than C++. It is not clear if CCEL allows any consistency checks or how the checking \nof constraints is implemented. In CCEL constraints are imposed within a cer-tain scope such as a file, \nclass, or member function. This is quite different from CDL, where syntactic elements are adorned with \ncategory names. In recent years design patterns [3] have become a popular way of describing solu-tions \nto common design and implementa-tion problems. Commonly, a design pat-tern [3] describes a problem, outlines \na solu- tion, and has certain consequences. In addi-tion, Gamma et al [3] state that their design patterns \nare on a certain level of abstraction and describe communicating objects and classes that are customized \nto solve a general design problem in a particular context. Although there are similarities on an ab-stract \nlevel between a CDL style and a de-sign pattern, the motivation, application, and definition of them \nhave significant dif-ferences. While a design pattern is intended to propose a solution in a limited \ncontext, a CDL style is intended to enforce certain design invariants on a complete system or a significant \nportion of a system. Design patterns are described informally, with examples in some selected implementa-t \nion language. In contrast, a CDL style is a formal description of categories that can be assigned to \ndesign elements such as inter- face definitions, classes, and coarse-grained modules. In addition, a \nCDL style is defined in the context of a well-defined design lan-guage . As the term design pattern is \ngenerally used, a CDL style is not a design pattern. Nevertheless, CDL could be used to partially formalize \ndesign patterns. It will, however, require that care is taken not to overspecify the categories defining \na design pattern. Superficially, our aims are similar to those of meta-object protocols, which also special- \nize object types [6]. However, a MOP spe-cializes through programmed extensions of the behavior of object \ncreations and mes-sage sends. In contrast, we never change the run-time semantics of objects. Our special-izations \nare only imposed through more or less intricate syntactic restrictions. CDL is an application of the \nFIDO pro-gramming language for expressing regulati sets of labeled trees. FIDO is intro-duced in [9] \nas a high-level notation for the Monadic Second-order Logic (M2L) on finite trees, see [20]. While the \nM2L has been known to be decidable since the 196Os, it A tree language is reg ular if it is recognized \nby a finite-state tree automaton. is only recently that practical implementa-tions have been available, \nlargely due to the adaptation of BDD techniques [2]. In [9], the translation techniques for M2L on strings \nof [5] are extended to trees along with com-binatorial techniques and data structures for avoiding state \nspace explosions. FIDO is also used in [7] for the behavioral descrip-tion of distributed programs and \ntheir veri-fication. M2L has also been applied to hard-ware verification [ 11. CDL is described in detail \nin [lo]. In a technical sense, the most closely re-lated work is in formal linguistics, where re-cent \nwork has focused on constraint-based formalisms. Here the classical rewriting mechanisms of context-free \ngrammars are augmented with formalized constraints on parse trees. Such constraints make it pos-sible \nto avoid combinatorial explosions in grammars, for example those that occur when modeling agreement. \nJames Rogers in his thesis [19] develops a theory of the use of formalisms based on M2L for express- \ning parse tree constraints. Our use of con-straints is similar in that it avoids multipli-cation of syntactic \ncategories for parse trees of programs.  2 Applying Constraints to OMG-IDL 2.1 Introduction In this \nsection, we introduce the category definition language in some more detail, and we provide some realistic \nexamples. To il-lustrate that CDL is generally applicable, we have here chosen to use OMG-IDL as the \nspecification language instead of DELOS. Thus, we will use CDL to define design con-straints for IDL \nspecifications. Note that IDL needs to be extended slightly to allow that holds for all syntax trees. \nThe second category annotations. formula states that no subtree with a root of type A may contain both \na node of type C and one of type B; this formula holds for only 2.2 The Constraint Language some syntax \ntrees, including the one above. CDL is based on predicate logic where first-The third formula states \nthat any node of order terms denote nodes in a parse tree over type C must have a child of type D; this \nis which a formula is interpreted. The logi-an absurdity that holds for no syntax tree. cal connectives \nA, V, =+, etc. have the same To define categories, we need a construct meaning as in conventional predicate \nlogic. for grouping and naming sets of constraints. In addition, CDL provides operators that ex-The following \ncategory is named 0. It is ap- press relations among tree nodes as follows. plicable to any node of type \nA for enforcing If x and y are variables denoting nodes, that the node satisfies the constraints of the \nthen the formula x < y states that y is a de- category 0. scendant of x, i.e. it is in the subtree rooted \nCATEGORY 0 FOR A IS by x; whereas the formula x Q y states that 3 y: B.root a y; y is a direct descendant \nof x. Furthermore, END if x is a node, then x.i is its i th child in the syntax tree, counted from left \nto right. The This particular category states that every quantifiers V and 3 range over nodes in the \nnode of type A annotated with the category syntax tree, possibly restricted to a subset name 0 must have \na direct child of type B. of the non-terminals. Finally, the predicate The name root denotes the node \nof type A x=t holds when the node x is labeled with to which we apply the category. The cate-the terminal \nsymbol t. gory concept is a grouping mechanism that The example below shows a simple gram-is mapped to \nthe following tree logic expres-mar and a possible syntax tree where each sion: node is labeled with \nits non-terminal sym- V root: A. O(root) + 3 y: B.root a y bol. The category construct is useful as \na concept A to group associated constraints and to give them a name. A ::= BA 1 BC 1 BD B A B ::= id \n( C C ::= id  2.3 A Subset of OMG-IDL C B D D ::= id cl&#38; In order to describe constraints on OMG- \nConsider now these three formulas: IDL specifications, we need to know the IDL syntax. This is necessary \nin order to under- V x: A. 3 y: B. x a y stand the structure of syntax trees and to 1 3 x: A. 3 y: B. \n3 z: C. (x 2 y) A (x 5 z) know the names of the node types. Node v x: C. 3 y: D. x < y type names are \njust the production names The first formula states that for all nodes x used in the syntax. of type A \nthere exists a direct child of type B; We also need to extend the IDL syntax in for our grammar this \nformula is a tautology order to allow category annotations in IDL specifications, specifically for interface \ndef- dnheritance-spw ::= I : ddentifien f 1 4dentifien }* The following is a simple OMG-IDL inter-face: \ninterface node !catName! { void addChild(in node c); void setParent(in node p); 1; Note that the category \nannotation (!cat-Name!) is possible thanks to our slight ex-tension of IDL. Below, we show a partial \nsyn-tax tree, where nodes in the tree are labeled by the corresponding node types, i.e. pro-duction names. \ninterface-dcl interface-body op-t yp&#38;t er-dh op:dcl op-t ypet er-dcls identifier The following subsections \nprovides some ex-amples of possible design constraints for IDL interfaces. Our examples are limited to \na few categories although, in our experience, a realistic style consists of between 5 and 20 categories \nwith each category containing at most 10 separate constraints.  2.4 Peer-to-Peer Interfaces The first \nset of constraints originates from the need of expressing communication ac-cording to the standardized \nROS [18] model. In the ROS model, we may have two peer in-terfaces exchanging asynchronous messages, \ninitions. Below the OMG-IDL[G] underlined. C.pecificatioO CdefinitioO dntetface> dnterface-dcb <interface-headen \ndnterface-bode <exporD <const-dcb <attr-dcb ueadonly-dcb <op-dcb <op-attribute <oneway-dcb <category-dclu \nwe have included parts of syntax with our extensions :: ::= ( 1 1 1 ::= ::= <definitiorD* Gype-dcb ; \n<const-dcb I; <except-dcb ; <interface9 ; aoduleb ; dnterface-dcb dnterface-headeo { <interface-bodp \n} ::= interface tidentifieo ::= ::= ) 1 1 ) ::= ::= ..- ::= :I= [<category-d&#38;b*] [dnheritance-speo] \n<export>* qpe..dcb ;I <const-dcb ; <except_dcb I; cattr-dcb I; <op-dcb ; const <const-type, 4dentifieP \n= I <const-exp> [readonly-dcl] attribute Cparam-type-speD &#38;mple-declaratoo , -&#38;mple-declaratoo* \n readonly [<op-attribute>] cop-type-spee garameter-dcle [oaises-expO] [<context-expr3] coneway-dcb ::= \noneway ..- ! 4dentifieP .,- { , I bdentifien}* ddentifien ! I thus we have no pure client server model. \nWe use OMG-IDL one-way operations to de- note asynchronous message passing. Inter-faces that represent \na peer are expected to be annotated with the peer category, which informally expresses: AI1 nodes x that \nare subnodes of an interface declaration node and represent operation declara-tions should have a subnode \nthat is a one-way declaration. This means peer interfaces should only pro-vide asynchronous operations. \nFormally, CATEGORY peer FOR interface-dcl IS V x: op-dcl.root 5 x + 3 y: oneway-dcl. x a y; END We also \nwant to add that an interface clus-tering a set of one-way operations should not reveal any concrete \nstate. A concrete state should not have publicly available attributes, but may still reveal (abstract) \nstate informa-tion through operation calls. We therefore refine the peer category as follows: CATEGORY \npeer FOR interface-dcl IS If x: op-dcl.root < x + 3 y: one-way-dcl. x a y; V z: attr-dcl. l(root 5 z); \nEND This constraint disallows attributes in inter- faces of category peer. The following is an example \nof two col-laborating peer interfaces, one representing a player resource for a telephony application \nand the other representing a player resource client which we call the controller. interface controller \n! peer! { one-way void done(); one-way void error(); interface player !peer! { one-way void play(); \none-way void rewind(); one-way void stop(); one-way void pause(); ); A controller may start, stop, rewind, \nor pause the player without waiting for the pre-vious operation to terminate. When an op-eration such \nas play terminates, it calls the done operation on the controller. For sim-plicity, we have omitted any \nargument the operations may convey in this example. The example illustrates the type of prob- lems where \npeer interfaces and their charac-teristics are applicable. In particular, the asynchronous semantics \nand encapsulation of state is of vital importance. If attributes or non-one-way operations are introduced, \nthen the interface would no longer satisfy the constraints of the peer category. By enforcing certain \nconstraints on peer interfaces, we are able to ensure correspond-ing characteristics. For instance, since \nwe are guaranteed that the communication be-tween peers is asynchronous, we need not worry about deadlocks \ncaused by peers mu-tually calling each other. By introducing explicit categories we have also extended \nour design language with the peer concept and consequently included ex-plicit design level support for \nthe ROS com-munication model.  2.5 Services and Resources In this example, we introduce several cat-egories. \nThe goal is to introduce concepts that support the design of telecommunica-tions systems, where new services \ncan be introduced more easily. This is achieved by separating the user services from the re-sources. \nObserve that IDL is a limited lan-guage, considering the full needs of a soft-ware design. DELOS, for \nexample, would al-low the expression of a more complete design model. For the purpose of this style we \nhave iden-tified the following meta-concepts: service, resource, plain, and factory. A service object \nwould represent a user level services, such as call, voice mail, etc. The resource objects model resources \nthat are shared among multiple instances of the same or different services. Examples of such are speech \nrecognition, tone sender, sec-ondary storage, etc. A plain object is neither considered a ser- vice nor \na resource from an architectural point of view. Rather it is an object that is used to implement a service \nor resource ab-stractions without itself being one from the high-level architecture perspective. Finally, \nwe want to adopt the object fuc-tory concept in order to decouple the usage and creation of objects. \nCDL allows us to specify formally what characterizes the interfaces that corresponds to each of these \nconcepts. Each concept will be represented by one CDL category. Objects of category service should have \na single one-way operation called execute. This operation represents the main flow of the service. Having \na convention for the name also simplifies automatic service man-agement since all services have the same \nstatic interface signature. We define the service category as follows: CATEGORY service FOR interface-dcl \nIS 3! x: op-dcl.3 y: identifier.3 z: one-way-dcl. root 2 x a y A y= execute A x a z; V z: attr-dcl. lroot \n2 z; END In our model, resources possibly provide many one-way operations. Services are no tified about \nthe results through the event service. It could also provide a concrete state, but only for reads. Resource \ninter-faces should only inherit from other resource interfaces. We define the resource category below. \nCATEGORY resource FOR interface-dcl IS V x: op-dcl. root < x + 3 y: one-way-dcl. x a y; V x: inheritance5pec.V \ny: identifier. root 1. x a y * resource(y); V x: attr-dcl. root 5 x =S 3 y: readonly-dcl. x a y; END \nPlain interfaces represent auxiliary objects rather than abstractions that are important from an high-level \napplication architecture point of view. Plain interfaces should be re-stricted so as not to provide one-way \noper-ations This restriction limits the degree of asynchronous message passing, thereby sim-plifying \ndebugging. Also, plain interfaces should be restricted so as to only inherit from other plain interfaces \nCATEGORY plain FOR interface-dcl IS 4 x: one-way-dcl. root 5 x; V x: inheritance-spec.V y: identifier. \nroot 5 x a y * plain(y); END Finally, for interfaces representing object factories, we wish to enforce \na naming con-vention and make the factory concept more explicit than an informal convention. CATEGORY \nfactory FOR interface-dcl IS 3! x: op-dcl.3 y: identifier. x a y A y= get0bj ;  END Below, we outline \na small example where categories have been used to annotate an OMG-IDL interfaces. The annotations en-able \nus to more readily identify the archi-tectural role of each interface. Since cate-gories are described \nformally, we can auto-matically ensure that the interfaces satisfy the constraints. interface wakeUpCall \n!service! { void setTime(time t); one-way void execute0 raises (not-avail); 1; interface tonesender ! \nresource! { . . . interface linelnterfacectl !resource! { }; - - interface IicFactory !factory! { linelnterfacectl \ngetObj(licnr In); }; . . Consistency The style given above is obviously consis-tent, since we have just \nsketched an example of a legal design. However, suppose that we stupidly added the following constraint: \nV x: interface-dcl. resource(x) A plain(x) which states that all interfaces must be both of category \nplain and resource. Unfortu-nately, the added constraint has the implica-tion that no design can possibly \nbe legal-a fact a consistency check would discover. Without such a check, we could perhaps en-ter a costly \nand frustrating cycle of trying to complete a design. For a large and com-plicated design developed simultaneously \nby several architects, the risk of inconsistency is very real. The following section will discuss the \nthe-oretical basis for our constraint language and the possibilities it provides.  3 Theoretical Basis \nThe CDL formalism is based on the Monadic Second-order Logic on finite binary trees. In M2L, the universe \nof discourse is the nodes of a binary tree. There are basic predicates for relating the positions of \nnodes. Second-order terms are monadic relations, i.e. sets of nodes. There are the usual logical connec-tives \nand both first-and second-order quan-tifiers. Each formula in M2L denotes a set of trees: those for which \nthe formula holds. These sets coincide with regular tree sets. The fundamental difference between the \ntwo representations is that a formula may be non-elementary more succinct than the cor-responding automaton. \nThus an extremely complicated automaton may be described by a brief and elegant formula. CDL is essentially \nthe first-order fragment of M2L; however, the full logic is needed to correctly model the underlying \nsyntax trees of a given grammar. Since regular tree sets need not be sufficient, we also extend the logic \nwith externally computed unary pred-icates. In the translation these are repre- sented simply as free \nsecond-order variables. For the satisfaction problem, a CDL for-mula is translated into the underlying \ntree automaton, which is essentially a simplistic attribute grammar, as discussed in the fol-lowing section. \nIt is now a straightforward task to see if a given syntax tree is accepted. For the consistency problem, \nwe must de- c, cide if some constraints Ci, Ca, . . . , are mutually contradictory. Thus we con-struct \nthe automaton for the combined for-mula Ci A Cz A . . . A C,. The constraints are now consistent if this \nautomaton accepts any trees at all, which can be determined through a simple depth-first search. The \nM2L formalism is known to be a very ambitious compromise between expressibil-ity and decidability. Almost \nany extension leads to an undecidable logic. Thus, we can rest assured that CDL is as strong as it can \npossibly be for expressing regularity. For example, regular expressions with negation and conjunction \noperators can be translated into M2L with only a linear increase in size.  4 Implementat ion The translation \nof CDL into tree automata by means of the FIDO compiler and MONA decision procedure [9] is reasonably \nquick. For example, the formulas in Section 2.4 are all translated in about 15 seconds. The con- sistency \ncheck is potentially costly, lasting several minutes for the style in Section 2.4. New versions of these \ntools are under devel- opment and they will run at least an order of magnitude faster due to an improved \nBDD package [ 81. We illustrate with an example how tree automata are represented as attribute gram- \nmars. Recall this simple grammar: A ::= BA 1 BC 1 BD B ::= id 1 C C ::= id D ::= id Consider the constraint \nthat for every node of type A there must below be a node of type D for which the external predicate P \nholds: if x: A. 3 y: D. x 5 y A P(y) We now describe in detail the attribute grammar that is generated. \nAll attributes are synthesized, and the attribute values are simply integers. A rule looks like: T : \n[ml,. . . ,mk] H n if P1,7P2,. . . The meaning is: if we are at a given node of type T and the i th subnode \nhas synthesized the value rni and the external predicate PI is true, P2 is false, etc., then we synthesize \nthe value n. A given syntax tree is accepted if a bottom-up run yields an accepting at-tribute value. \nThe full attribute grammar is as follows: attributes 0,1,2 accepting 0,l A : [O,O] I-+ 2 A : [OJ] I-+ \n1 A : [0,2] H 2 B : [] I-+ 0 B : [0] I--+ 0  c : [] t-+ 0 D : [] I-+ 0 if 1 P D : [] t--+ 1 if P \n The claimed succinctness of formulas is not apparent from this trivial example. How- ever, the full \nresource category generates attribute values and several dozen intricate rules; in comparison, the resource \nconstraints are rather intuitive, completely modular, and easy to maintain. The generated attribute grammars \nare guaranteed to be minimal, since they are generated from uniquely minimized tree au- tomata. Thus, \nthe design architect need not be concerned with efficiency of the particular phrasing of a given constraint. \n In the new version of CDL under devel-opment, the compiled automata are actually more complicated than \njust explained. They are factorized according to the principles ex-plained in [9] so that the automata \ncorre-spond to grammars that have both inherited and synthesized attributes. We have not yet completed \nthe integra-tion with a design tool for DELOS or any other language. Note, however, that at-tribute grammars \ncorresponding to design constraints can be expected to be as simple as above. Thus existing programming \nenvi-ronments can easily be extended to deal very efficiently with design constraint checking. Concluding \nremarks Our proposed design constraint language CDL arose from our experiences in develop ing design \nlanguages and tools for object-oriented systems. Our approach to architec-tural styles allows a formal \ntreatment of de- sign constraints without forcing them to be built into the design languages. The main \npractical advantages of CDL are: . we identify and formalize important architectural concepts in named \ncate-gories; and . a design can be annotated with cate-gory names, and we can automatically verify that \na design satisfies the stated constraints. Our industrial experience and the ex-amples presented here \nmake us confident that the expressive power of CDL is well-balanced, since it allows interesting con-straints \nto be expressed concisely and pre-cisely, while allowing automated support by a decision procedure. In \nthis paper we have applied CDL to textual languages. There are, however, no hindrance to the application \nof CDL to graphical languages. The only-general-prerequisite is that the language has a well-defined \nsyntax and that syntactic entities can be annotated with categories. References D. Basin and N. Klarlund. \nHardware verification using monadic second-order logic. In Computer aided verification : 7th International \nConference, CAV 95, LNCS 939,1995. Randal E. Bryant. Graph-based algo-rithms for Boolean function manipula-tion. \nIEEE Transactions on Computers, August 1986. Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. \nDesign Patterns. Addison-Wesley, 1995. David Garlan, Robert Allen, and John Ockerbloom. Exploiting style \nin ar-chitectural design environments. SIG-SOFT, (12), December 1994. J.G. Henriksen, J. Jensen, M. \nJorgensen, N. Klarlund, B. Paige,  T. Rauhe, and A. Sandholm. Mona: Monadic second-order logic in prac-tice. \nIn Tools and Algorithms for the Construction and Analysis of Systems, First International Work-shop, \nTACAS 95, LNCS 1019, 1996. Also available through http://www.brics.aau.dk/Nklarlund. Gregor Kiczales, \nJim des Rivieres, and PI Daniel G. Bobrow. The Art of the Metaobject Protocol. MIT Press, 1991. N. Klarlund, \nM. Nielsen, and K. Sune- PI sen. Automated logical verification based on trace abstraction. Technical \nReport RS-95-53, BRICS, 1995. To ap- pear in Proceedings of PODC 96. Nils Klarlund and Theis Rauhe. BDD \nPI algorithms and cache misses. Technical Report RS-96-05, BRICS, 1996. Sub- mitted. Nils Klarlund and \nMichael I. PI Schwartzbach. Logical programming for regular trees. BRICS, University of Aarhus, December \n1995. Jari Koistinen. The Delos cat- PO1 egory definition language: Def- inition and rational. Ellemtel \nTelecommunication Systems Lab- oratories. Also available through http://dsv.su.se/wjari/acprojects.html., \nJuly 1995. Jari Koistinen, Eui-Suk Chung, Mats Pll Svensson, and Martin Bostrom. Delos 2.2 language description. \nEllemtel Lab- Telecommunication Systems oratories. Also available through http://dsv.su.se/Njari/acprojects.html., \nDecember 1995. Johan Liseborn. The Delos Cat- PI egory Definition Language: A user s first impression. \nEllemtel Telecommunication Systems Lab-oratories. Also available through http://dsv.su.se/Njari/acprojects.html. \nScott Meyer, Carolyn K Duby, and P31 Steven P. Reiss. Constraining the struc- ture and style of object-oriented \npro-grams. In First Workshop on Principles and Practice of Constraint Program-ming. Brown Univeristy \nComputer Sci-ence Technical Report CS-93-12, April 1993. N. L. Minsky. Law-governed reg- PI ularities \nin object systems; part 1: Principles. To be published in The-ory and Practice of Object Systems (TOPAS)). \nAlso, available through http://www.cs.rutgers.edu/mminsky/ pubs.html., 199? Object Management Group. \nThe Com- P51 mon Object Request Broker: architec-ture and specification, December 1991. OMG Document \nNumber 91.12.1, revi-sion 1.1. Object Management Group. Common WI Object Services Specification, Volume \n1, March 1994. OMG dot nr. 94-1-1, Re-vision 1 .O. Dewayne E. Perry and Alexander L. WI Wolf. Foundations \nfor the study of soft- ware architecture. ACM Software Engi-neering Notes, 17(4), October 1992. ITU-T \nrecommendation X.880. Remote[181 operations: Concept, model, and nota-tion. July 1994. James Rogers. \nStudies in the logic of PI trees with applications to grammar for-malisms. PhD thesis, University of \nDelaware, 1994. [20] W. Thomas. Automata on infinite objects. In J. van Leeuwen, editor, Handbook of \nTheoretical Computer Sci- ence, volume B, pages 133-191. MIT Press/Elsevier, 1990.   \n\t\t\t", "proc_id": "236337", "abstract": "Large software systems are often built on system platforms that support or enforce specific characteristics of the source code or actual design. These characteristics are either captured informally in design guideline documents or in specialized design and implementation languages.In our view, both approaches are unsatisfactory. Informal descriptions do not allow automated analysis and lead to vague constraint descriptions. The language-based approach leads to different languages for different platforms and even for different versions of the same basic platform.Our approach is to describe and name the constraints separately in a design constraint language called CDL, which is based on an extraordinarily concise logic of parse trees. Designs are then annotated with the names of the constraints they are supposed to satisfy.We discuss how the design constraint language is integrated into a design language environment. We exhibit industrial and experimental evidence that our choice of design constraint language allows us to formalize naturally and succinctly common design characteristics.", "authors": [{"name": "Nils Klarlund", "author_profile_id": "81100072411", "affiliation": "", "person_id": "PP39025867", "email_address": "", "orcid_id": ""}, {"name": "Jari Koistinen", "author_profile_id": "81332509495", "affiliation": "", "person_id": "PP31045403", "email_address": "", "orcid_id": ""}, {"name": "Michael I. Schwartzbach", "author_profile_id": "81392609511", "affiliation": "", "person_id": "P198767", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236376", "year": "1996", "article_id": "236376", "conference": "OOPSLA", "title": "Formal design constraints", "url": "http://dl.acm.org/citation.cfm?id=236376"}