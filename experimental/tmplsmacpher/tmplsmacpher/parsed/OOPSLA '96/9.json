{"article_publication_date": "10-01-1996", "fulltext": "\n Reorganizing Split1 Objects Herr&#38;n Astudillo R. SHL Systerrlhousc E-mail: IIAstudillo@SIII,.COM \nPhone: +( 1) (404) 892-7504 905 .Junipr St. NE, Suite B-2 Atlwnta, GA 303U9 + Abstract Object-based \n(i.e. classless) models are very effec-tive for elucidating requirements from users, a.nd they support. \nexploratory programming and rapid prototyping, providing a, direct manipulation ap-proach. On t,he other \nhand, class-based models have powerful mechanisms to control redundancy, exploit sharing, express extension, \nand propagate changes to instances. The price object-based approaches pay is loss of control over change \npropagation, and p0tent.ia.l redundancy. Two mechanisms to overcome this are sharing among objects and \ndefinition of ob-jects as ext,ension of others. We examine these mechanisms, and consider the effect \nt,hat interact-ing policies for objects sharing and definition-by-extension have on change propaga.tion \nand repli-cation control. An implication is t,hat, in absence of meta-objects or extra-language support,, \nmono- lithic shared parts ca.nnot coexist with protot,ypes represented as split objects. Permission \nto make digital/hard copy of part or all of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for profit or commercial advantage, the copyright \nnotice, the title qf th,e publicati?n,and its date appear, and notice is given that copying IS by permissron \nof ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires \nprior specific permission and/or a fee. OOPSLA 96 CA, USA Q 1996 ACM 0-89791-788-X/96/0010...$3.50 *This \nwork was performed while t he author was with the College of Comput.ing, Georgia Instit,ute of Technology, \nAt-lanta GA 30332 1 Introduction Among object-oriented systems, a special variety called object-based \nsystems has emerged in the last few years with some ontological claims on tow I. In essence, object-based \nsyst,ems consist, of O&#38;Y+ without cZasses, unlike their better known cousins like Smalltalk and C++. \nObject-based program- ming fans (present author included) believe t.hat it, allows a better paradigm \nfor manipulat,ing reality t,hru programming constructs. In particular, t,his t,ranslates to concept s \nlike direct manipulat,ion by dispensing wit,11 t,he conceptual clutch of the class, allowing the modeler \nt,o work direct ly with objects (something especially interest,ing for rapid prototyping and use-cases \nrepresentation [GS81], representation of concepts without a priori classi-ficat,ions [Lie86], design \nof interfaces [US87], and requirements validation via modeling in terms of concrefe User objects [BS84] \n). On the other hand, classes have very useful roles in development, because they allow intensional de- \nscription ojgroups ojobjecfs, beyond mere explicit dtscription of indioidds. This simplifies the sys-tem \ndescription, allows code reuse via extension, and supports change propagat,ion. Hence, Ihe nat,-uralness \ngained from direct access t,o objects is paid for with the loss of abstraction t.ha,t comes wit,h dis- \ncarding t.he concept of class. In particular, a model This classification was introduced by Wegner in \n[Weg87], who reserved the name object-orient.ed for models where objects are instances of classes. hats \ngives up on classes aIs0 gives up control upon propaga,tion of (certain kinds of) changes, and con-t,rol \nover (certain kinds of) rud~ndancy. In this article, we will examine these certain kinds of control that \nare lost. in object-based mod-els: we will look at some standard solutions for them; a,nd we will consider \nthe effect that the in-teraction of policies for sharing and e.&#38;nsion has on change propagation and \nreplication control. On a side note, t,he problems of restructuring object-ba,sed workspaces into fully \nobject-oriented syst,ems [AstM] is bewildering because not only higher abstractions are being identified, \nbut. also t,he act.ual control policies tha.t are usually incar-nated by classes (such as consistency \ncontrol among instances, sharing of class-wide data, and transpar-ent cont,rol of extension, as we shall \nsee). The remainder of this paper is organized as fol-lows: Section 2 introduces object crea.tion mech-anisms \nand some problems arising from them, Section 3 examines object sharing, Section 4 covers object ext,ension, \nSection 5 analyzes the interaction and effect of sharing and extension, and Section 6 present,s some \nfinal comments.  Object creation Tn an object-based world, objects come to exist. (concept,ually a.t \nlea&#38;) in one of three ways: 1. Ex nihilo: created via some primitive. 2. By cloning: produces an \nexact copy of an ob-ject. 3. By extension: an object is defined as an incre-mental modification of an \nexisting one.  For example, in Figure 1 a Studen.t can be created via: (a) some primit,ive operation, \nor (b) cloning an existing Student, or (c) extending an existing Person. Cloning and extension establish \na relationship between two objects: one of them is either a copy or an ext,ension of the other. However, \nsince an object,-based world is based on autonomous ob-jects, t,his relationship is usually lost, or \nif recorded, it. is not in an explicit manner usable by the pro-grammer. In a, syst em based in cloning, \nthe modification of any object poses a problem right away: Should this change be propaga,ted to all objects \ncloned from it? Only to t hose otherwise unmodified ? And should it propaga.te t,o the object from which \nit was orig-inally cloned ? What about its extensions? A sec-ond problem is that cloning itself introduces \nredun-dmcy among objects, as in the case of any copied feat,ures that are not) modified. Can similar \nob-jects be factorized ? Should the programmer be a.wa,re of t,his ? Should sharing me undone if one \nof t,he involved object is modified? And more iI)-terestingly, how does factoriza,tion interfere wit.h \nextension? In most cases (and this is where the appeal of the object approach resides), changes are meant, \nto differentiate an object from the rest of it,s cloned set. However, this is not always the case; distin-guishing \nt,hese cases and supporting both of them is t.he hard problem. To summarize, in object-based systems \nthe lack of (explicit) support for higher level abstraction and for intensional sets2 creates two kinds \nof prob- lems: 1. Change propagation: since there is no clear concept. of object, equivalence or compulsory \nset membership, any change t,o an object raises t,he question (or even worse, skips it alto-gether) if \nthe change should also be applied t,o its clones and/or t,o its extensions. 2. Replication controk many \nobjects 1na.y have identical parts, taking up space due to their replication.  The severity of t.hese \ntwo concerns depends great,ly on the system policies for sharing among objects and for o&#38;% extension. \nIn the follow-ing sections we examine policies to represent these two mechanisms, and discuss the effects \nof different. combinations of sharing and extension policies on the redundancy and change propagat.ion \nproblems. 2Sets created by description rather than enumeration. (a) Ex nihilo (b) By cloning another \nStudent (c) By extending a Person Figure 1: Three ways Some terminology We will define now some terms \nneeded for further use. A feature (or slot) is a named reference to an object. An object is ei- ther \na set of features or a piece of code. A feature can be marked as delegating feature (see below), and \nthe object referenced by it is called a parent ob-ject of the feature holder. Delegution [Lie861 is an \nexplicit relationship between objects, which allows an object bo forward references t,o missing features; \nhence, delegation provides a mechanism akin to in- heritance in object-oriented systems. A cloned set \ndenotes an object. and all objects that are either unmodified clones from it or unmod-ified clones from \nother set members (a new cloned set appears whenever an object. is modified3). Hence, a cloned set is \ncomposed of all objects that, are direct or indirect faithful clones from a com- mon prototype. Notice \nthat this definition does not require the existence of a distinguished prot,otype, nor even the continued \nexistence of the initial ob-ject. Sharing From a programmer s viewpoint, we can distin- guish two kinds \nof features in any object: 3Ry adding, removing or modifying features. to create an object . . Immutable \nfeatures, which are not meant to change during the object s lifetime, since they record the object s \nstatic properties. . Mutable features, which do change and are used to record the object state. Notice \nthat the mutable/immutable dichotomy is . orthogonal to the data/methods dichotomy; for ex-ample, callbacks \nand error handlers are code that is mut,able (from an object s viewpoint) even in con-ventional programming. \nClearly, mutable and immutable features can be physically reorganized to improve space-use effi-ciency, \nsince all immutable features are (by def- 41 inition) identical among the members of a clone set. (Immutability \nonly is needed as regards an object against its co-clones; shared4 mutable data \\ is hence OK too.) \nHence, sharing elimina,tes (or reduces) replication (redundancy). Additionally, and perhaps more important, \nsharing facilitates the r propagation changes to shared feat,ures, as we ll see shortly. Several mechanisms \nhelp to automate the iden- tification of mutable and immutable features in objects, and their separation \nwherever possible. Among t,hem are explicitly annotating immutable features (indicating their const-ness \n), keeping track of unmodified features, and algorithmic 4 Or synchronously varying. a A A  ClfJ \n(a) No sharing (b) System- (c) Delegation- (d) Jm plicit -simulated -based (with class) object s immutable \npart - delegation object s mutable part . . ...* cl instance-of Figure 2: Alternative represent,ations \nof sha.ring :. ,,&#38; A b A (a) No sharing (b) System-simulated (c) Delegation-based (everything replicated) \n(immutable parts is (immutable part iS not only apparently replicated) replicated nor appears to be) \n.,.a:  ,,:.,. object s immutable part m + cloning -+ delegation object s mutable p drt 0 Figure 3: \nCloning in presence of sha.ring + recognition of common values a,mong several ob- jects. The issue of \nreorganizing objects for sharing can be approached with the following policies, again as seen from the \nprogrammer s viewpoint (as shown in Figure 2): . Ignomd (in Figure 2(a,)): the issue is fully ig-nored. \nThis alternative is mostly academic, since real systems would quickly suffer the ef-fect,s of indiscriminate \nreplication of essentially identical material. . S ystenz-simulated (in Figure 2(b)): the prob-lem is \nacknowledged, but is is considered just, an implementation issue underlying a programmer s vision of \nobjects as fully au-tonomous. This is the model in the Kevo lan-guage [Tai95], which provides sharing \nbetween apparently self-sufficient objects, and also in t,he virtual copies proposed by Mittal et al. \n[MBK%]. . Via delegation (in Figure 2(c)): the sharing is explicit and visible to the programmer, who \nmust determine what is shared and what is in- dividual among clones. This is the model used in the Self \nlanguage [US87], where traits objects hold shared slots, and prototypes and their clones hold individual \nstate. The above mentioned approaches can be used to implement this one, as in fa,ct, Self [IJCCHSl] \nuses ma.ps to support sharing among clones. . Implicit (in Figure 2(d)): the issue of shar-ing is abstracted \ninto membership in a group denoted by a common description of fea-tures. This is the case in object-oriented \nlan-guages [Weg87] like Smalltalk [GR.89] and C++ [Str86], where a class holds both shared features and \nan implicit prototype of its mem-bers. (In Smalltalk it also provides access to the set itself.) Any \nof the above mentioned ap-proaches can be used to implement this one, with the caveat that it be visible \nto t,he imple- mentor but not to the programmer. Cloning in presence of sharing Figure 3 il- lustrat,es \nhow a cloned set (with members labeled A for simplicit,y) can be represented wit,h either: (a,) no sharing, \n(b) system-simulated sharing, or (c) delega,tion-ba,sed sharing. 4 Objects extension In programtning \nby extension, new objects can be defined CLSextensions of existing ones; t,his rela- tionship preserves \nthe original object integrity, and allows automatic propagation of changes from an object s to it,s ext,ensions. \nThe ext,ended object is defined in terms of an original object plus some addit,ional features (as in \nt.he example of Figure 1). From the programmer s viewpoint, t,he following representa.tion options exist \n(as shown in Figure 4): . Delegation (Figure 4(a)): an extended object is implemented as if having components \n[NGT92]: the added feat,ures are grouped into a new object, and this one delegat,es (cf. Section 2) to \nthe original object, (which re-mains unt.ouched). This representation amvoids redundancy and facilitates \nchange propaga-tion. In Self, objects extended t,his way are called data-parents of their extensions. \nWe will refer t,o delegation-extended objects as split objects, following Deny ct al. call [DMC92]. . \nConcutenution (Figure 4(b)): a new object is built, by copying the object. t,o be extended and then adding \nthe new feat,ures directly to itm5. This is the extension paradigm used in Kevo [TaiSTj]. This model \nis conceptual cleaner than delegation, since it supports self-sufficient ob-jects by avoiding dependencies; \non the other hand, it suffers of possible inconsist,encies and certainly of replication. Notice that. \nconca.te-nation can be implemented using delegation and split objects; the key point is that the pro-grammer \ncan be safely unaware of this. . ........ eztensiorz (Figure 4(c)): the process of extension itself is \nhidden by some abstrac- Not unlike t,he cuband-paste paradigm. Otiginally (a) Delegation (6) Concatenation \n(c) Implicit (with class) -delegation object s immutable part . . . . . * instance-of object s mutable \npart ---* subclass-of Figure 4: Alternative representations of extension tion. The programmer is not \nawa.re of object, extension, but class ext,ension (one step re-moved) can take its place. Smalltalk and \nC++ provide subclassing , by which the implicit cla,ss-held prototypes a,re actually extended; insta,nces \ncreated from a sub-class are them-selves monolithic, even though classes them-selves are both viewed \nand implement,ed as split. objects [TaiN]. Implicit object extension can also be implement,ed using split \nobjects or concatenation. 6 Cloning in presence of extension Figure 5 shows how bhe cloning and extension \noperat ions are combined (in absence of sharing): cloning a monolithic object, is straightforward, but \ncloning a split. object must actually clone the &#38;oZe hitrarchy of data parents rather than just t,he \nobject i&#38;elf. This can be done by ha.nd in simple cloning syst,ems like Self (modifying the cloning \noperation specifi-cally for each ext,ended object), but it betrays the purpose of object-based programming \nbecause it, forces the programmer to be aware of the split-ness, and (even worse) t,o ma.intain a met,a-level \nof 61n fact, Skin showed in [St,e87] that inheritance is sub- sumed by delegation. information about \nthe object. besides what is di- rectly accessible. The bookkeeping of this meta-level is wha,t classes \ndo in object-oriented program-ming like Smalltalk, since they are aware of t,heir instances structure; \nbut it, clearly t,akes us out of the direct. manipulation approach. A purely object,-based solution is \nto provide a kind of st,ructural delegat,ion , to be used for cloning purposes besides message lookup; \nbut, this would bring back the complexity of an abstraction-based language, pushing the programmer away \nfrom direct manipulat,ion.  5 Interaction of policies Let us consider how the int,eraction of mechanism \nfor redundancy elimination and for objects exten-sion affects object organization modes. Our expo-sit,ion \nis gra.phically shown in Figures Fi and 6, and is summarized in Table 1. For all combina,tions of t,hree \ndimensions, we explore the degree of change propa,gation and replication control availa~ble to the programmer. \nThe t,hree dimensions shown in t,he table are: 1. Factorization: whet,her the immut,able fea.-t,ures \nof an object reside in t,he object itself I.---- *..,._ _. . . . fA+B) (A+B)  (a) Monolithic prototype \n(using concatenation) -3 cloning data parent (extended structure) cl i : I ._._.... .! -i;A&#38; (A+B) \n  (b) Split prototype (using delegation) object s mutable part Figure 5: Cloning of extended objects \n(t.he i&#38;ioid~u~ or in a shared object (here tion must be explicit, and replication called traits, \nas in Self), which is accessed If the model a.llows for split objects, through delegat,ing references. \nis used only to support1 dat,a-parents sub-parts); propagation of changes is maxima17. then delegation \n(i.e. objects from objects to 2. TN&#38;S splitting: if the immutable features re-their extensions is \nimmediate, but changes to clones side in a traits object,, whether this object is sets must be explicit. \na single object (a 7no7~&#38;thic tmit.r built using concatenation) or is a. split traits, built using \nSplit objects, but monolithic traits The delegation. ond row in Table 1 (also Figures 6(a) and describes \nobject models which allow sharing 3. Prototype splitting: whether the mut,able fea- traits object with \ncommon immutable features, tures of an object reside in a single object (a the traits cannot be a split \nobject itself. monolithic prototype) or in several delegation- means that a traits extending another \none sec-6(b)) of a, but This must concatenated objects (a split prototype). replicate it; however, \nthis will not produce as much replication of changes These representation can be combined with vary- \nbe done ing effects on change propagation and replication supportingcontrol. as the previous cases. \nThe from the originally ext,ended either separately (e.g. by a a more abstract. system on propagation \ntraits must mechanism top of this), or in a,n ad hoc manner. The first one is the way that C++ objects \nare actually implemented [St,r%]: Monolit hit objects The first row in Table 1 a. large table referencing \nthe class members, and (also Figures 5(a) and 5(b)) corresponds to self-instances with inherited members \nas sub-parts. sufficient objects, wit,h no sharing. If only concat,e- Unless the system itself implement,s \none of the ot,her nation extension exists, then delegation (and shar- models beneath the programmer \ns interface, like Self s ing) have no place in t.he model; change propaga- maps [UCCHSl]. *.. . . . . \n_. .* CA+B) (a) Monolithic Traits (b) Monolithic Traits Monolithic Prototype Split Prototype . . . . \n. . _ . . .   (A+B) (A+B) (c) Split Traits (d) Split Traits Monolithic Prototype Split Prototype ~~~ \nobject's immutable pati + cloning ElII object s mutable part -delegation u / -1 prototype -mm* data \nparent (extended structure) _ -I ,. . . __ :-.__i split instance (cloned object) Figure 6: Combining \nextension and sharing 145 r imm utablc monolithic prototype split prototjypr pa.rt locntion (extension \nby concatenation) (extension by delegat,ion) individual Figure 5(a) Figure 5 (b) shared monolithic Figure \n6(a) Figure 6(b) (traits) split Figure 6(c) Figure 6(d) Table 1: Clam bining extension and factorization \nSplit objects, with split traits too The third row in Table 1 (also Figures 6(c) and 6(d)) con-siders \nobject models which allow sharing of t,raits a&#38; that the trait,s it,self be a, split object,. These \ntwo cases provide minimal replica.tion for all im-mutable feat,ures in the object workspace. If pro- \ntot,ypes are also allowed to be split, we have a, sit,ua- Con of maximal change propagation for immutable \nfeatures (which are propa.gated along the delega-Con lattice). However, propa,gat.ion of cha,nges to \ninstance structure requires the existence of higher levels of abstraction, such as classes. In fa.ct, \nthis last, model is how C++ progra,mmers perceioe their system: classes defined by extension, and inst,ances \nwith superclass part,s as components. Problem: redundancy of traits Notice that case (b) in Figure 6 \nis at best redundant, and at worst ambiguous, since any instance of (A + B) in-herits actually two set,s \nof (A)t,,;t,: one from it,s own, and one from the (A + B)traits. The solutions to this situation (see \nFigure 7) all involve making the (A) part of (A+~),roto to be a copy of (A)proto, rather than (il)pi-oto \nitself; consequently, the advan-tage of split prototypes are lost,. Notice t,oo that having a blind-alley \ncopy of (A)protor i.e. with no parents, is valid because the self for (A + B) instances refers to their \n(B) part. The difficulties to combine split prototypes and monolithic traits seem to point a fundamental \nlim-itation to the split-ness of prototypes, namely that it cannot exceed their traits split-ness. This \nde-fines a, clear limit on our choice of mecha,nisms: not all combinations are feasible.  6 Conclusions \nWe have considered the organization and manage-ment of non-class objects. To minimize redundancy and \npropa,gate changes, these objects can be rep-resented using sharing and extension mechanisms. Sharing \ncan be either ignored, syst,em-simulated, explicit via delegation, or implicit (e.g. classes). Object,s \nextension can be manifested either via del- ega.tion, concatena,tion, or implicit extension (e.g. subclassing). \nThe analysis of the interaction of mechanisms for change control and for object,s ext,ension shows tha.t \nthe mechanisms chosen by the implementor are not necessarily the same as those perceived by the pro-grammer. \nAlso, aa interesting result is the appar-ent limitation that t,he split-ness of prototypes ca.n-not exceed \nthat of their traits. We can conclude that straight cloning is not enough; we need smart cloning (which \nrecognizes extension). This can be simulated by hand, or can be accomplished with meta,-objects, aware \nof our objects structure; but, both solutions defeat t,he purpose of direct manipulation Ultimately, \nthe degree in which object creation operations are fossilized into the syst,em (e.g. subsisting as explicit \nlinks or sets) determines the explicit control tha.t he progra,mmer can exercise on his/her object s \nlifetime. . . I Using a dead-alley Using a modi/ed copy of (Ajproto copy of (A)proto object s immutable \npart  [----I -> cloning object s mutable part 0 ---I -delegation I I split prototype --I . . . . . \n> data parent (extended structure) ; .__ _i split instance (cloned object) Figure 7: Solutions to Redundant \nInheritance References in object, orient,ed syst,ems. In Nor- [*4st9Ci] [E384] [DMC92] [CR891 [GSSl] \n[Lie861 Hernan Astudillo. Evaluation and Ileal-ization of Modeling Alternatioes: S,up-porting Derivation \nan,d Enhancement. PhD thesis, College of Computing, Georgia lnstitute of Technology, At-lanta, GA 30332, \nUSA, February 1996. Reinhard Budde and K. Sylla. From application domain modelling to target system. \nIn Reinhard Budde, K. Kuh-lenkamp, L. Mathiassen, and H. Zul-lighoven, edit.ors, Approaches to Pro-totyping: \nProceedings of the Working Conference on Prototyping, pages 31-48, Berlin &#38; New York! Namur, Bel-gium, \n1983 1984. Gesellschaft, fur Math- ematik und Datenverarbeitung mbH, Springer-Verlag. Christ,ophe Dony, \nJacques Malenfant, a.nd Pierre Cointe. Prot,otype-based languages: From a new t,axonomy to constructive \nproposals and their val-idation. In Andreas Paepcke, edi-tor, OOPSLA 92, 7th annual confer-ence on object-oriented \nprogramming system,s, languages, and applications, pages 201-217. ACM SIGPLAN, ACM Press, Vancouver, \nBritish Columbia, Canada, 18-22 Ott 1992. Adele Goldberg and D. Robson. SmalltaZk-80: The Lan-guage. \nAddison-Wesley series in com-puter science. Addison-Wesley, 1989. H. Gomaa and D. B. II. Scott,. Pro-totyping \nas a tool in the specification of user requirements. In ICSE, edit,or, 5th International Conference of \nSojt-ware Engineering, pages 333-342. IEEE and ACM SIGSOFT, IEEE Comput,er Society, 198 1. Henry Lieberman. \nIJsing prototypical objects to implement shared behavior [MBK86] [NGT92] [Ste87] [Str86] [Tai95] [UCCHSl] \n[US871 148 man Meyrowit,z, editor, OOPSLA 86 Conference Proceedings, pages 214-223. ACM, ACM Press, Portland, \nOregon, 1X4, Sept 29 -Ott 2 1986. Sanjay Mitt,al, Daniel G. Bobrow, and Kenneth M. Kahn. Virt,ual copies: \nAt, the boundary between classes and in-stances. In Norman Meyrowit,z, edi-t,or, OOPSLA X6 Corzference \nProceed-ings, pages 159-166.4CM, ACM Press, Port,land, Oregon, IJSA, Sept. 29 --Ott, 2 1986. Oscar Nierstrasz, \nSimon Gibbs, a,nd Dennis Tsichritzis. Component-orient,ed soft.ware developtnent. Corn-m.unications of \nthe ACM, 35(9):160-, 165, Sep 1992. Lynn Andrea Stein. Delegation is inheritance. In OOPSLA, editor, \nOOPSLA 87: Conjerence on Object Oriented Programming, Systems, Lan-guages and Applications, pages 138- \n146. ACM SIGPLAN, ACM Press, Or-lando, FL, USA, 4-8 Ott, 1987. Bjarne Stroustrup. The C-t-f-Program-ming \nLanguage. Addison-Wesley series in computer science. Addison-Wesley, 1st edition, 1986. Antero Taivalsaari. \nDelegation ver-sus concatenation, or cloning is inheri- tance too. OOPS Messenger, 6(3):20-49, July 1995. \nDavid lJngar, Craig Chambers, Bay-Wei Cha,ng, and Urs Hiilzle. Orga-nizing programs wit,liout classes. \nLisp and Symbolic Computation, 4(3), Jun 1991. David IJngar and Ra.nda.11 B. Smith. Self: The power of \nsimplicity. In OOPSLA, edit,or, OOPSLA 87: Cbn-fcrer~e 011 Object Orien,ted Progmm-Ining, Systems, La,nguagts \nand Applica-tions,pages 227-241. AC1M SIGI LAN, ACM Press, Orlando! FL, IJSA, ,-2-g act 1987. Pet,er \nWegner. Ihriensions of object- hsed language design. In OOF -SLA, editor, OOPSLA 87: Confer- ence on \nObject Oriented Program.miny, Systrms, Languages and Applications, pages l68--182. ACM SIGPLAN, ACM Press, \nOrlando, FL, USA, 4-8 Ott 1987. \n\t\t\t", "proc_id": "236337", "abstract": "Object-based (i.e. classless) models are very effective for elucidating requirements from users, and they support exploratory programming and rapid prototyping, providing a direct manipulation approach. On the other hand, class-based models have powerful mechanisms to control redundancy, exploit sharing, express extension, and propagate changes to instances.The price object-based approaches pay is loss of control over change propagation, and potential redundancy. Two mechanisms to overcome this are sharing among objects and definition of objects as extension of others. We examine these mechanisms, and consider the effect that interacting policies for objects sharing and definition-by-extension have on change propagation and replication control. An implication is that, in absence of meta-objects or extra-language support, monolithic shared parts cannot coexist with prototypes represented as split objects.", "authors": [{"name": "Hern&#225;n Astudillo R.", "author_profile_id": "81442597753", "affiliation": "SHL Systemhouse, 905 Juniper St. NE, Suite B-2, Atlanta, GA and College of Computing, Georgia Institute of Technology, Atlanta, GA", "person_id": "P110103", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236350", "year": "1996", "article_id": "236350", "conference": "OOPSLA", "title": "Reorganizing split objects", "url": "http://dl.acm.org/citation.cfm?id=236350"}