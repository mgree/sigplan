{"article_publication_date": "10-01-1996", "fulltext": "\n On Automatic Class Insertion with Overloading H. Dicky, C. Dony, M. Huchard, T. Libourel LIRMM: Laboratoire \nd lnformatique, de Robotique et de Micro-e lectronique de Montpellier 161, rue Ada -34392 Montpellier \nCedex 5 -FRANCE email: dicky, dony,huchard, libourel@lirmm.fr Abstract Several algorithms [Cas92, MS89, \nRun92, DDHL94a, DDHL95, GMM95] have been pro-posed to automatically insert a class into an inheritance \nhierarchy. But actual hierarchies all include overriden and overloaded properties that these algorithms \nhandle either very partially or not at all. Partially handled means handled provided there is a separate \ngiven function f able to compare overloaded properties [DDHL95, GMM95]. In this paper, we describe a \nnew version of our algorithm (named Ares) which handles automatic class insertion more efficiently using \nsuch a func-tion f. Although impossible to fully define, this function can be computed for a number of \nwell de- fined cases of overloading and overriding. We give a classification of such cases and describe \nthe com-putation process for a well-defined set of nontrivial cases. The algorithm preserves these important \nproper-ties: - preservation of the maximal factorization of prop- erties - preservation of the underlying \nstructure (Galois lattice) of the input hierarchy  -conservation of relevant classes of the input hier-archy \nwith their properties. 1 Introduction This paper deals with automatization of the inser-tion of a class \n(defined by a set of properties) into an existing inheritance hierarchy, we will refer to Permission \nto make digital/hard copy of part or all of this yrk for personal or classroom use is ranted without \nfee provided that copses are not made or distributed for proBIt or commercial advantage, the copyright \nnotice, the title of the publication and its date appear, and notrce IS given that copying is by permission \nof ACM, Inc. To copy otherwise, to,r,epublls,h, to post on servers, or to redistribute to lists, requires \nprior speclflc permISSIOn and/or a fee. OOPSLA 96 CA, USA 0 1996 ACM O-89791 -788-x/96/001 0...$3.50 \n this as the class insertion problem. It also deals with automatic inheritance hierarchy construction \nor reorganization which is related to the class in-sertion problem. We propose, via a new algorithm, \nnew advances to fill the gap between what current class insertion algorithms are able to do and what \nautomatic handling of actual inheritance hierarchies really requires. Why automate hierarchy construction? \nClass or object (Some programming or knowledge rep-resentation object-oriented languages are classless \n[DMC92]) inheritance hierarchies are at the heart of object-oriented programs, object knowledge-bases \nand object data-bases, and they are a cornerstone of frameworks i. e. of adaptable and reusable object-oriented \narchitectures. Any kind of automated help in building, reorganizing or maintaining hierarchies can thus \nbe of interest and can have applications in several important research areas of object technol- ogy: \n. organization of object-oriented frameworks [JF88]: automatic reorganization is able to bring to the \nfore new factorization classes and abstract classes [0 J93]. . adaptation of legacy systems: numerous \nobject-oriented systems, thus numerous hier-archies, have been developed in the past years, automatic \nreorganization can help to adapt or reuse them, - by reorganizing poorly designed systems built either \nby nonspecialists, or too rapidly, or with- out any concern for generalization, - by reorganizing huge \nsystems built by differ- ent designers or programmers at different time periods,  -by merging hierarchies: \nthe final hierarchy could be computed by reclassifying classes from the different hierarchies. This approach \nshould not be confused with hierarchy combination, as proposed in [OH92], where a methodology is proposed \nto extend existing hierarchies. . software adaptability: automatic insertion of a class adds flexibility \nto an object-oriented soft-ware system, which becomes for example able to undergo change. Independently \nof the application area, the more the classes to be structured multiply and become intricate, the more \nthe structuring process can benefit from partial automatization. Given these possible applications, the \nnext ques-tion that emerges is: what kind of methods can be provided? Before going further, it should \nbe stated that it would certainly be impossible to find a general al-gorithm that could completely automate, \ngenerally speaking, class insertion and/or hierarchy reorgani- zation; firstly, because of the difficulty \nin expressing criteria to define a LLgood hierarchy independently of the context, and secondly, because \nthe construc-tion rules are often very informal and empirical. The different works describing algorithms \nfor automatic class insertion or hierarchy reorgani-zation that have been published [GM93, Cas92, LBSL91, \nLBSLSO, Ber91, MS89, Run92, DDHL94a, DDHL95, Moo95, MC961 focus on the most tangible and one of the most \nimportant criteria used when organizing hierarchies: to point out common prop-erties and create classes \nto store them (i.e. factor common properties ). Once this criterion is set, there is room for mul- tiple \nvariations: incrementality, maximal factoriza-tion, conditions on inputs and outputs of the algo- rithm, \nconstraints imposed by a particular applica-tion domain. Finally, a common and fundamental characteris-tic \nof object-oriented programs, knowledge repre-sentation and database hierarchies is that they in-clude \nproperties whose name s are overloaded. So usable and actual class insertion algorithm has to correctly \nhandle overloading. Most existing algo-rithms do not handle this issue and, when done, it is only partial \n[DDHL95, GMM95]. The main issue concerning overloading in our context is to compare properties of the \nsame name using their signatures and codes. Unfortunately, code comparison is un- decidable. This paper \ndescribes Ares, explains how we achieve property comparisons in a number of well- defined cases, and \nhow we use this procedure to efficiently insert classes in the presence of overload- ing. In Section \n2, we present the terminology used. In Section 3, some commented examples of algorithm inputs-outputs \nare proposed that highlight its main properties and give an idea on the way overloading is handled. Section \n4 compares our approach with related works. Section 5 gives a detailed descrip-tion of the algorithm \nthat takes overloading into account. Then a thorough study of how to compare oc-currences of generic \nproperties, the key-problem for handling overloading, is presented. 2 Terminology and context Before \ndescribing examples of class insertion, in the light of the fact that words such as overloading , properties \n, genericity , signature are some-how overloaded in the world of object-oriented lan-guages, let us \nfirst introduce the classical terminol-ogy, and terms specific to our problem. The algorithm will be \napplicable, provided it is correctly interfaced, to inheritance hierarchies for various object-oriented \nsystems. Designing an al-gorithm interface for a particular language may be complicated. In order to \ndescribe the algorithm, we have chosen the global context of a standard class-based object-oriented language \nwith inclusion poly-morphism, property overloading and overriding. 2.1 Classes, inheritance, properties \nClasses and types are assimilated, and basic types are interfaced and can be considered as classes. Classes \nare organized into an inheritance hierarchy H with a root. The subclass relationship induces a partial \norder, which we denote by >H* A class is characterized by a set of properties. Class properties can be \neither instance variables or methods ( SmaZltalk terminology). We will refer to variables and methods \nunder the terms property or class property. All properties have a name and other characteris- tics such \nas a signature, and in the case of methods they may have a body or code (a set of instructions). The \nsignature of an instance variable represents its type. The signature of a method is the ordered list \nof its parameter types and possibly its return type. Traditionally, the first element of a signature \nis the receiver type. In this presentation, the signa- ture does not include this first element. For \na given class C, Declared(C) denotes the set of properties declared in C, and Inherited(C) is the set \nof properties declared in C superclasses. Cl q) a, C2( c3 a a4c4 c3 c4 fL c5b 3 a4 H' H\" Figure 1: \nH is not maximally factorized, H is  2.2 Overloading, overriding and generic properties Properties can \nbe overloaded, i.e. it is possible to find properties with the same name and different characteristics \n(signature, code , etc.). Overriding is a particular case of overloading which makes sense in the presence \nof inheritance and applies when a redefined property hides, for a certain object, a property of the same \nname that is otherwise inherited. The rules of conformance that govern signature redefinition are language \ndepen-dent . The conformance rule for signature redefini-tion is one point to be specified when the algorithm \nFor example, concerning methods, the rules are different in Eiffel (multi-covariance, where the type \nof several or all parameters of a method can be specialized in method redef-initions) and C++ (simple-covariance, \nonly the receiver can be specialized) is to be applied. We present Ares using an Eiffel-like covariance \npolicy [Mey9 2] for variable and method redefinitions. We have to mention the set of all class proper-ties \nwith the same name and same arity (in case of methods ). We call such a set a generic property 2. Each \nproperty belongs to a generic property, i.e. is an element, or an occurrence of the set of prop- erties \nhaving the same name, OGP stands for Oc-currence of a Generic Property. P denotes a generic property, \nand p or pi an oc- currence of P, the index is used when necessary, i.e. when we want to speak, in the \nsame context, about two distinct occurrences of P. The different occurrences of P are ordered by a specialization \norder. For variables, this special-ization order can be deduced from the specialization order on their \ntypes. For methods, this specializa-tion order can be deduced from a specialization or-der on the signatures \nand then on a specialization order on method bodies3. A ticklish problem arises when we admit self-reference \nin signatures4. We call lowest common generalizations and use LCG(pi,pj) to denote the set of the most \nspecialized common generalizations of two occur-rences of the same generic property. In most cases, LCG(pi,pj) \nis a single element set. In the following, we will assimilate this single element with the set. This \nsimplification does not hide difficult problems. p(Cl,C2) : Cs[code] denotes a method with sig-nature \n(CrrC2,C3), where C3 is the return type, and code is the method s body. We also denote: ps or p()[= 0] \nfor a subclass re-sponsibility or pure virtual method with an empty code. Such a method is automatically \nthe top of the specialization order of P. same name and same meaning than Clos generic func-tions; note \nthat this notion is reified in 6 10s but is common to all object-oriented languages, for example we can \nspeak of the generic property print0n: in Smalltalk, which is the set of all methods named printon: defined \nin the system 3A method that performs a super call could be considered as a specialization of the method \ninvoked by this call 4a signature is self-referent when it contains the type of the method s receiver \nHl H2 Cl Cl H4 HS Figure 2: Insertions  2.3 Meaningful classes The designer may arbitrarily set apart \na subset Cnilean of meaningful classes. The algorithm will not be allowed to delete these meaningful \nclasses from the hierarchy. Examples of meaningful classes could be: classes with instances (of great \nimportance in a persistent world) or classes which represent an in-teresting abstract concept.  2.4 \nMaximal factorization An inheritance hierarchy is maximally factorized if and only if, for any two classes \nC3 and C4 with two properties a3 and a4 respectively, and for LCG(a.3, ad) = 132, the hierarchy always \nincludes a common superclass of C s and C4 that declares 132, such that a2 = LCG(u3, IZ~) (cj. Figure \n1). c2 h b CS c4 (abdf) c c3 + 0de H3 Cl n H6 without overloading  3 Commented examples of inputs-outputs \nof the algo-rithm Before formally describing the algorithm, we will comment on a few examples of class \ninsertions as they are performed by Ares. 3.1 Examples without overloading Here is a sequence of class \ninsertions (cf. Fig. 2) starting from hierarchy HI and successively pro-ducing hierarchies Hz to HG, \nhighlighting decisions taken by Ares and showing how the maximal fac-torization property holds: . the \ninserted class is a simple subclass of an ex- isting class. The first example shows an initial hierarchy \nHI reduced to classes Cl and Cz and a class Cs to Cl c3 abc c3 c2 c3abd Hl H2 H3 Figure 3: Compactness \nand maximal factorization C fiYi&#38;i-- c3 (al) c2 a2 bl cl d2 4-l Figure 4: A simple be inserted. \nCs s set of properties contains Cz s set of properties, so Cs is a subclass of Cz. The output hierarchy \nis Hz. the inserted class is not a leaf of the hierar-chy. In HP, t,he class C4 is inserted between C2 \nand Ca producing H3. The declaration of c is transferred from Ca to C4. a new class is created and factorizes \ncommon properties. The next class C s is an indirect subclass of Cz. In Ha, class Cc is created to factorize \nproperty d common to Cs and C5. a class becomes added, property side effect is that properties in Hg. \nan empty class could be adjusted empty. When class C7 is d is extracted from CI~. The Ce does not declare \nany more is removed. The algorithm by deciding whether to keep or delete an empty class. If a deletion \npolicy is chosen, the result of removing Ce is H6. Note that maximal factorization is not always compact. \nSeveral maximally factorized hierarchies can be built from the same set of classes. Consider for example \n(cf. Fig. 3) a hierarchy built from two classes Cr and Cz in which properties a and b have to be factorized. \ncl f a0 b0 CO d0 7 A c4 al bl dl c2 case of overloading We may obtain the following different results. \nEi-ther a and b are grouped together in the same fac-torization class C s (HI), or a and b are declared \nin different classes C4 and Cs (Hz) (resp. C s and CT in Hs). All hierarchies are maximally factorized, \nbut HI is more compact than the others. Ares produces compact and maximally factorized hierarchies. \n3.2 Handling of overloading in an ideal case In the presence of overloading, we have divided the problem \nin two parts. The first problem is to find the lowest common generalization of two oc-currences pr and \np2 of the same generic property P. The second problem is how to use this gener-alization in the algorithm, \nassuming it is available (either computed or given by a human expert). We present here some examples \nof how Ares handles the second subproblem. In Figure 4, C s is to be inserted in the hierarchy made of \nclasses Cr and C2; the order for properties is: u2 < al < ac, b2 < bl < bo, LCG(q,c2) = co, and LCG(&#38;,da) \n= dr < da. CCU registerDriver(Driver)[...] Vehicle Truck registerDriver(TruckDriver)[...] registerDriver(TruckDriver)[...] \nGeometricFigure Cdisplayol=Ol) Figure 5: Signatures give the LCG GeometricFigure display()[=O] Circle \n Figure 6: Code gives the LCG Ares determines that Cs is a subclass of Cr sim- ply because each property \nof Cr is specialized in C3. Combining Cz and Ca is more complicated, since they are not comparable. For \nany two occurrences in C2 and C3 of a same generic property p, we take the common lowest generalization \np,. If p, does not appear in the classes above Cz (here in Cl), we declare pm in the factorization class \nC,.  3.3 Examples of class insertion with overloading and automatic determi-nation of LCG It is generally \nimpossible to automatically compute the lowest common generalization of two OGP, but it is possible in \nmany situations that we have started studying. The detailed results are presented in sec- tion 5.3. We \ngive here some concrete examples of overloading where we know how to compute LCG and how Ares exploits \nit. . Signatures give the LCG The first example (cj. Figure 5) comes from [Mey92]. The existing hierarchy \nis made of a single class Cur and the class to be inserted is Truck. The two properties to be compared \nare = registerDriver(TruckDriver) and p2 = Pl registerDriver(Driver). Given that TruckDriver < Driver, \nregardless of their bodies P2. Given this result, Ares method to be stored in (which we, not Ares, name \nand Truck. we deduce that pl < pz and that LCG(pl,p2) = knows that p2 is the the factorization class \nVehicle) made from Car . Code gives the LCG In the second example (cf. Figure 6) two occurrences of \nthe generic property display ex-ist in the hierarchy: do = &#38;pZay()[= O] and , dr = dispZuy()[Codel] \nand a new one, (4 = displuy() [Code2]) comes with the class Circle to be inserted. Their code being different, \ndr and d2 can be considered as incomparable. However, an-other more precise code examination shows that \ndo = LCG(dl, dz). These results allow Ares to correctly produce the final hierarchy. It should be noted \nthat the class GeometricFigure is created (except for the name) by the algorithm, if not ini-tially present. \n. Using codes and signatures The last example (CL Figure 7) is taken from Smalltalk-[GR83] and adapted \nto a typed world. Given the class Date, inserting the class Time day: integer month: integer year: integer \n Date i=(Date)[Codel] <=(Time)[Codel] day: integer <(Time)[Code4] =(Time)[CodeS] <=(Date)[Codel] <(Date)[Code2] \n=(Date)[Code3] Figure 7: Using codes and signatures month: integer year: integer i=(Time)[Codel] <(Time)[Codd] \n=(Time)[CodeS]   I--- should produce a factorization class (1Magnitude) with the method <= common \nto Date and Time and subclass responsibility versions of methods < and =. The occurrences of the generic \nprop-erties <=, <, = have to be compared and their KG computed. Let us see how an automatic comparison \nis possible using the method codes and signatures. The first issue here is to enrich the language de- \nscribing our signatures of the methods <=, <, by an anchored type Indeed, the parameter s and to recode \nthe signatures = by replacing Date or Time as defined in Eiffel [Mey92]. type of self-referent meth- \nods <=, <, = is the type of the method s receiver, thus the possible type of the argument will be de- \ntermined by the place in the hierarchy where the class will be inserted. In other words, we need to know \nwhere the class will be inserted in order to cor- rectly compute LCG and thus to correctly insert it. \nThus, to compute LCG, we build new versions of signatures in which anchored types are replaced by the \npattern LC (which stands for like current in reference to Eiffel anchored type declaration). We then \ndefine two signatures that match (in our terminology signatures potentially equal ) as two signatures \nhaving at a given position either both the same type, or both the pattern LC. In the example of Figure \n7: . The two met,hods < (of Date and Time) now have signatures that match, and have different bodies. \nThis is enough to confirm that they are incompatible and that their LCG will be a method having an empty \nbody, defined in the common superclass -say Magnitude-of Date and Time, and of signa- ture (Magnitude). \n. The two methods <= (of Date and Time) have signatures that match and the same code p. This is enough \nto confirm that they can be fac- tored via a LCG, which is a method of code p defined on the same common \nsuperclass -Magnitude -of Date and Time and of signa- ture (Magnitude). This example represents a typical \nsituation show-ing how Ares is able to highlight interesting factor-ization classes. 4 Comparison with \nrelated works Related works [GM93, Cas92, LBSL91, LBSLSO, Ber91, MS89, Run92, DDHL94a, DDHL95, Moo95, \nMC961 may be studied from three viewpoints: the strategy used to reorganize hierarchies, the features \nof the hierarchy and the handling of overloading. 4.1 Global, incremental and toolbox strategies To \nbuild a hierarchy, different strategies can be con- sidered: . The Toolbox approach, proposed by [BerSl], \nis based on a set of local operations allowing users to modify a hierarchy. a Global algorithms [MGGSO, \nLBSL91, LBSLSO, Cas91, Moo95, MC961 build in a single step the whole hierarchy from the binary relation \nClass -property. . Incremental algorithms insert a new class into an already existing hierarchy. Such \na tech- nique is proposed by [Cas92, MS89, Run92, DDHL94a, DDHL95, GMM95]. All of these strategies may \nlead to the same re-sults, no one can be considered better than another. For instance, given a set of \nclasses, a whole hierar- chy can be built by successive applications of an incremental algorithm. Conversely, \na global algo- rithm can always be used to insert a class A in a hi- erarchy whose class set is &#38; \n-starting from A and 8, forgetting the structure of the hierarchy. However, depending on the utilization \ncontext, one strategy or another will be more suitably adapted. A global algorithm is obviously more \nsuitable in the first case above, while an incremental algorithm should be used in the second. Besides, \nglobal algorithms are more adapted when the given data is the relation Class-Property -for instance, \nwhen reorganizing an unsatisfactory hierarchy from scratch-, while incremental algorithms and toolboxes \nfit evolution better. 4.2 Underlying hierarchy models The underlying model used to represent hierarchies \nis more or less restrictive. [Cas92] does not impose any constraints on the inheritance graph; this seems \npowerful at first sight but there is no formal characterization of the results produced by the algorithm. \nIn [LBSLSl, LBSLSO], there is a strong constraint on hierarchies in which only leaves can represent instanciables \nclasses. Moreover, a second set of algorithms use implic- itly ([Run92, MS89, MC96]), or explicitly ([GM93, \nGMMM95, DDHL94a, DDHL95]) with further adaptations, the Galois lattice of the Class-Property relation \nto encode hierarchies. The Galois lattice is a mathematical construction ensuring the most compact maximal \nfactorization (more details can be found in [Aig79, Wi189, Wi192, GM93, DDHL94a, GMMM95]). [Run92, MS891 \nuse the whole lattice (precisely a sup-semi-lattice) and this raises some problems. Firstly because of \nspace consumption: in the worst case, the space complexity is exponential in max(number of classes, number \nof properties). Secondly, because this structure imposes some con- straints on the hierarchy; for example, \nFigure 2 shows how this structure can forbid the deletion of a class (class C, in Hs); indeed, if the \ndeletion is achieved (as in He) then Cs and Cs have the two lowest common superclasses Cz and C s and \nthe hi- erarchy is no longer a lattice. More cleverly, [GM931 proposed use of a struc-ture which is a \nsub-order of the Galois lattice, that we call a Galois subhierarchy, which improves space complexity. \nHowever, in the same example of Figure 2, the Galois subhierarchy imposes a con- trary constraint to \nthe hierarchy: class CG must be deleted even if it is a meaningful class (cf. section 2.3). [MC961 seems \nto produce the same structure of a Galois subhierarchy. Our algorithm is based on the Galois subhierar-thy. \nIt uses and preserves an underlying Galois lattice and thus produces formally well character- ized results. \nWe have added a slight modification to avoid the deletion of meaningful classes. 4.3 Taking overloading \ninto account Initial studies [LBSLSO, LBSLSl] did not take over-loading into account. A first advance \nis described in [Cas92], which simply allows an abstract (pure virtual) method to be overriden by an \nimplemented one which itself cannot be overriden. A second step is described in [MS89, Run92, DDHL95, \nGMMM95, GMM95], proposing systems able to take overload- ing into account, provided there is an oracle \nable to compare two occurrences of the same generic property, and give their lowest common generaliza-tion(s). \nWe improve algorithms concerning this topic in two ways: the main one concerns partial automa-r tion \nof the oracle for a set of well-defined cases, in-cluding cases of self-referent signatures, the sec-ond \none is a significant improvement of the space complexity.  5 The Ares Algorithm We present below the \nspecifications, the algorithm, and then detail our approach of overloading with self-referent signatures. \n5.1 Specifications Input: The algorithm starts with Hi = (Ci, l i) a class hierarchy with a root 5 and \nwith a meaning- ful class A to be inserted. ~~~~~ is the set of mean- ingful classes of Iii. Properties(A) \nis A s property set. output: The final hierarchy Hf = (Cf,rf) integrates Iii and A and respects the following \nproperties [DDHL94b]. . Preservation of the maximal factoriaa-tion of properties When Hi is maximally \nfactorized, so is Hf . Preservation of the underlying model When Hi is a Galois sub-hierarchy of ~~~~~~ \nHf is a Galois sub-hierarchy of Chlean U(A). . Inheritance path preservation of the hi-erarchy For all \nclasses of Hi still belonging to Hf, the inheritance paths remain. . Conservation of the properties of \ninput classes Classes which belong to both hierarchies Hi and Hf keep the same set of properties. . Meaningful \nclass conservation The set of meaningful classes of Hf is Clean U(A) Note that with any input hierarchy, \ni. e. not nec- essarily a Galois subhierarchy and/or a maximally factorized one, everything common to \nthe hierarchy and the class to be inserted is factorized by Ares.  5.2 The algorithm The algorithm (cf. \nFigure 8) can be split into three parts : (1) search of A superclasses, (2) deletion of non-meaningful \nempty classes and (3) search of A The root has no properties, and does not appear in the figures subclasses. \nWe focus on part 1, in which A super-classes are found or built and where A is bounded to its immediate \nsuperclasses. This part raises the main issues. A complete description of parts 2 and 3 could be adapted \nfrom previous work [DDHL94b]. The algorithm uses some global variables: . AaZreadyCreated: a Boolean \nwhich is true if, while visiting the hierarchy and creating factor-ization classes, a class with the \nsame properties as A is found. . SH: the current set of A superclasses. At any time, SH holds already \nvisited classes in Hi which are A superclasses, as well as the factor- izing classes (obviously A superclasses) \nalready created by the algorithm. . EmptyClasses: the set of the non-meaningful classes which, after \na factorization, do not de- clare any more prop erties. We use the function SetMeaningful to in- sert \nc into CMean, as well as the predicate IsMeaningful (C). The algorithm visits all classes in the input \nhier-archy Hi going down from the root and following a linear extension LEHi of >H~, i.e. a class is \nvisited after all its superclasses. The goal of these visits is to build SH, the set of A superclasses \nin Hf. Then, if needed, A is created and bounded to its direct superclasses. When a class C is visited, \nits set of de- clared properties Declared(C) is compared to the set Properties(A). We compute ExtractedProperties(C, \nA) which can be seen as the set of the properties common to C and A. For any pair of occurrences (pc,p~) \nof the same generic propert,y, we call a function which in first approximation returns LCG(pc,pA) -for \nfurther details, see section 5.3. We keep U G(pc,p~) if it is not declared in a (strict) superclass of \nC. More formally, the set ExtractedProperties(C, A) is: ExtractedProperties(@: A) = {P, = LCG(PC,PA) \ns.t. 3P, PC E P, PA E P, PC E Declared(C), pA E Properties(A), and p, is not declared in a strict superclass \nof C} The set of remaining properties of C (resp. A) is: Remainder(C) = Declared(C)\\ ExtractedProperties(C, \nA) Remainder(A) = Properties(A)\\ [ExtractedProperties(C, A) U Inherited(C)]). The operator \\ is in first \napproximation the set difference, and will be better specified in Section 5.3. Now, when ExtractedProperties(C, \nA) is empty, nothing has to be factorized, and in the other cases: . Remainder(C) is not empty -Remainder(A) \nis not empty Example: A = C s and C = Cs for H3 in Figure 2. ExtractedProperties(C, A) = {d}, Remainder(C) \n= {e} and Remainder (A) = {f}. The two classes are incomparable and the properties of ExtractedProperties(C, \nA) are factorized6 in a common superclass C of C and A. C is added in the hierarchy and is stored in \nSH (the set of A superclasses). C is defined as a superclass of C, and as a subclass of the classes of \nSups(C, SH). We call Skps(C, SH) the minimal elements of the set of classes which are C superclasses \nwhile belonging to SH. -Remainder (A) is empty Example: A = ch and C = Ca for Hz in Figure 2. ExtractedProperties(C, \nA) = {c}, Remainder(C) = {d, e} and Remainder(A) = {}. A is a superclass of C, the properties of A declared \nin C are extracted from C and we insert A in the hierarchy as a superclass of C. . Remainder(C) is empty \n-Remainder(A) is not empty Example: A = Ca and C = CZ for Hierarchy 1 in Figure 2. ExtractedProperties(C,A) \n= Remainder(C) = {} and WY Remainder(A) = {c,d, e}. C is a super-class of A, C is stored in SH. - Remainder(A) \nis empty It means that A and C are the same class. When the whole hierarchy has been visited, SH and \npossibly adapted as shown later contains all A superclasses. If A has not already been found, it must \nbe created and connected to its immediate superclasses -we use the func-tion Min(E), which returns the \nminimal (for <H) classes of set E. 5.3 Automatic comparison of occur-rences of generic properties Handling \noverloading in Ares requires being able to compare an occurrence of a generic property (com- ing with \nthe class to be inserted) with elements al- ready present in the hierarchy. A problem arises when the \nset of properties of the class A to be inserted and the set of properties of an existing class C being \nvisited (cf. section 5.2) contain PA and pc respectively, two OGP of the same generic property P. In \nsuch cases, Ares needs to compute: LcG(p~,pc) i. e. the property to be factor- ized in a common superclass \nof C and A. LcG(p~,pc) can be either PA or pc or the low- est property that both PA and pc specialize. \nRemainder(C) and Remainder (A), allowing Ares to state what is the common superclass of A and C7. In \nthe above section, describing the algorithm, discussions related to (1) the computation of the LCG of \ntwo OGP and (2) the precise de-scription of the computation of Remainder(C) and Remainder(A) have been \ndelegated and are presented here. We first present additional information and def- initions of OGP and \ntheir signatures necessary for the comparison of properties. Secondly, we explain how to compute remainders \nof C and A in the gen- eral case, and thirdly we deal with automatic com-putation of LCG(p,,p,). f7 \nnote that with our working hypothesis, A and C owning an occurrence of the same generic property will \nhave a com- mon superclass, that can be either A or C or a factorization class Algorithm ARES(Hi ,A) \nbegin // Initializations AalreadyCreated t false SHtO EmptyClasses t 0 // Looking for and binding superclasses \nFor every vertex C following LEHi do  // LEHi is an arbitrary linear extension of Hi starting from root \nCl // Visiting C if EztractedProperties(C, A) # 0 then if Remainder(C) # 0 then Create( C ) DecEared(C \n) t EztractedProperties(C, A) ImmediateSuperclasses t Sups(C, SH) Inherited = lJC,YESUps(C,SH) Properties \nProperties t DecZared(C ) U Inherited ImmediateSuperClasses t (ImmediateSuperCZasses(C) U{C }) \\ Sups(C, \nSH) DecEared(C) t Declared(C) \\ DecZared(C ) Inherited(C) t Inherited(C) U DecZared(C ) if Properties \n= Properties(A) then //C =A is a serperclass of C SetMeaningful AalreadyCreated t true else SH t SHU{C \n} endif if Declared(C) = 0 and not IsMeaningful then EmptyClasses t EmptyClasses U(C) endif else //Remainder(C) \n= 0 if Remainder(A) # 0 then //C is a superclass of A SH t SH U(C) else //Remainder(A) = 0 : C and A \nare the same class AalreadyCreated t true endif endif endif endf or // Creating class A and binding it \nto SH if not AaZreadyCreated then Create(A) SetMeaningfuZ(A) ImmediateSuperClasses t Min(SH) Inherited(A) \n= Uc,3EMin(SHj Properties(P) Declared(A) t Properties(A) -Inherited(A) endif DeleteEmptyCEasses BindSubClasses \n end  Figure 8: The ARES Algorithm 5.3.1 Keys for property comparisons 5.3.2 Remainder computation Methods \nare compared by mixing code comparison and signature comparison. Instance variables are compared using \ntheir types. Code comparison. At this stage of the work, two cases have been considered, the codes of \nthe methods to be compared are either identical or different. Signature comparison. Signature comparison \nis based on type comparison. Two types 2 1 and Tz are either equal, or one is a subtype of the other, \nor they are incomparable and thus have a common supertype sup(T1, T2). Moreover, as explained in the \nexamples (cf. Section 3.3), we need to separately consider self-referent signatures, i. e. signatures \nincluding the class in which the property is defined. Such a class has been characterized in the signature \nas an anchored type and recoded with the pattern LC . Comparison relationships for signatures. Def-initions \nof some comparison relationships between signatures used in the algorithm are presented. Let us consider \ntwo signatures SA = (Al: AZ, . . . . A,) and SC = (Bl, B2, . . . . Bn), where Ai and Bi are known types. \n. SA and SC are equal if Vi (Ai = Bi) . SA and SC are potentially equal if Vi (Ai = Bi) or (Ai = LC and \nBi = LC) . SA and SC are comparable if one is a spe- cialization of the other, for example SA < SC if \nVi (Ai 5 Bi), . SA and SC are potentially comparable if one is a potential specialization of the other. \nFor instance SA is a potential specialization of SC if Vi (Ai <= Bi) or (Ai = LC and Bi = LC), . SA and \nSC are incomparable, if (3i s.t. Ai and Bi are incomparable) or (3i,j s.t. Ai < Bi and Bj < Aj). Let \nus define equal (resp. potentially equal) properties as properties with the same code and . equal (resp. \npotentially equal) signatures. It is now possible to more precisely compute Remainder(C) and Remainder \n(A). -Remainder(C) is obtained by removing, from Declared(C), properties equal or potentially equal \nto a property of ExtractedProperties(C, A). -Remainder(A) is obtained by removing, from Properties(A), \nproperties equal or potentially equal to a property of ExtractedProperties(C, A). 5.3.3 Computing LCG \nof two properties We deal in this section with the issue of computer- aided determination of LcG(p~,pc) \nin the working context defined in section 2. Recall that we gener- ally distinguish between three kinds \nof cases in the determination of LCG(~,J, PC): Cases where such a determination requires a human expert, \nfor example when comparing two methods with different codes doing the same thing. Cases in which an automatic \ncomputation is possible that we do not yet handle. For exam- ple, it is possible to perform much more \nclever code comparisons than those we have already done. Cases that we have studied and that we now describe. \nWe consider that the rather simple rules that we have established allow Ares to deal with numerous and \nnontrivial cases.  The cases we have considered are given by mixing code and signature comparisons as \nsummarized in Figure 9. Let us consider again two OGP: PA with signa- ture SA in the class A to be inserted, \nand pc with signature SC declared in the class C that Ares is visiting. For each case in the array, we \ngive the LCG and when needed explanations and examples. 1. PA and pc have the same signature and the \nsame code : pA and pc are the same property, LCG(PA,PC) = PA = PC. 2. PA and pc have the same code, and \ntheir signatures are potentially equal : both signatures have at least one anchored type at the same \nposition. For instance, if ? A is PA(Tl, . . ..Ti.A, . . ..Tn)[codelI. and pc is P&#38;L . . ..Ti. C, \na.7 T,)[codel], then LcG(p~,pc) = Pm = p(T1, . ..> Ti, sup(A, C), . . . . T,)[codel], where sup(A, C) \nis the lowest common superclass 8 of C and A in which the algorithm will store pm, if pm is not already \ndeclared in a superclass of C i. e. if there is no superclass X of C containing px(Tl, ..a,Ti,X! . . \n. . T,)[codel]. An example of such a situation can be found in the Mugnitude example (cf. Figure 7), \nwhere A is Time, C is Date, and the considered property is 5. The following provides a snapshot of things \ncomputed by the algorithm: LCG(5 (LC )[codel], 5 (LC)[codel]) = 5 (sup(Time, Date))[codel]) ExtractedProperties(Time, \nDate) = (5 (sup(Time, Date))[codel], . ..} Remainder (Date) = {hour : in,teger,minut : integer, second \n: integer,...} Remainder(TimZe) = {day : integer,month : in.teger,year : integer,...} Knowing that neither \nRemainder(Date) nor Remainder(Time) are empty, Ares deduces that a factorization class C = Magnitude9 \nhas to be created. In Magnitude properties stored in ExtractedProperties(Time, Date) will be de-clared, \nin particular 5 (Magnitude)[codel]. Note that the signature for 5 on Magnitude has been rebuilt. 3. PA \nand pc have the same code, and their signatures are comparable. In whole generality, one of the properties \nis a specialization of the other, if for example SA < SC, then LCG(~A, PC) = pc. superclass in a broa,d \nsense: which can be C or A We will use the name Magnitude for clarity but of course, Ares does not find \nthe name In the car-truck example (cf. Section 3.3, Fig- ure 5), no hypothesis have been put forward \ncon-cerning the code of the two properties register-Driver. If we consider that they have the same code, \nthis is an example of our current case 3, and we compute: LCG(registerDriwer(Driver)[codel], registerDriwer(TruclDriver)[codel]) \n= registerDriwer(Driver)[codel] = pm pm will be declared on the superclass of the two classes Car and \nTruck, whatever it is. Know-ing whether or not the other property (here registerDriver(TruckDriver)[codel]) \nshould be considered the same and subsequently be removed from the other class, is an optimization of \nthe algo- rithm and is language and application dependent. 4. PA and pc have the same code, and their \nsignatures are potentially comparable : both signatures have at least one anchored type at the same position. \nFor instance, if PA is p~(Tr, . . . . Ti,X, . . . . Tj,A, . . . . T,)[codel], pc is pc(T~, . . . . Ti, \nY, . . . . Tj, C, . . . . T,)[codel], with Y < X. Then LcG(p~,pc) = p(Tl, . . . . Ti,X, . . . . Tj,sup(A, \nC), . . . . T,)[codel]. This case is very similar to Case 2, but sup(A, 3 is more constrained, it cannot \nbe C. 5. PA and pc have the same code, and their signatures are incomparable. For instance, if PA is \nPA (Ti , . . . , Ti, . . ., T,) [codel], and pc is pc(T:, . . . . Ti , . . . . TA)[codel], then LCG(PA, \nPC) is P(suP(TI,T;), -.., suP(Ti,T, ), ...l sup(T,,TA))[codel].  6. PA and pc have the same signatures, \nand their codes are different. If codes are different, at least a deferred property can be declared \nfor a superclass. For example, if pA is of the form: PA(T1, . . ..Tn)[codel]. and pc is of the form: \npc(Tl, . . ., T,)[code2], then LCG(PA,PC) = P(TI, ~..,T,)[= 01 Comparable Potentially Incomparable comparable \nEqual Different 6 8 9 10 Figure 9: Mixing code and signature comparison This situation was encountered \nin the second ex-ample of section 3.3, (cf. Figure 6) when com-paring the methods display of class Square \nand display of class Circle. The LCG to factorize is dispZay()[= 01. S ince this property is already \nde-clared in the hierarchy, Ares correctly inserts the class Circle as a subclass of GeometricFigure. \nThis formula for LCG is again an acceptable result, but pi could also be a specialization of pc (or the \nopposite). Determining this requires either a human expert or more sophisticated techniques for code \ncomparison (is p, s code a specialization of pc s code?) or an optimization of the Ares result on which \nwe are currently working. 7. PA and pc have different codes, and their signatures are potentially equal. \nFor instance, if PA is PA (TI, . . . , Ti, A, . .., T,) [codel], and pc is pc(Tr , . . . . T!, C, . . \n. . T,)[code2], then LCG~A,PC) = p(Tl,...,Ti,sup(A,C),...,T,)[= 01 The Magnitude hierarchy (cf. Section \n3.3, Figure 7) includes an example of such a case, where A is Time, C is Date, and the considered properties \nare < of Date and Time. The computed LCG to be stored in the factorization class is < (sup(Date, Time))[= \n01. This factorization class being determined (cf. the discussion on Case 2)) the final property to factorize \nis < (Magnitude)[= 0]  8. PA and pc have different codes, and their signatures are comparable. One of \nthe properties is a specialization of the other, if for instance SA < SC, then LcG(p~,pc) = PC- This \ncase occurs in the car-truck example (cf. Figure 5) if we consider that the two methods registerDriver \nhave different codes. The com-puted LCG is registerDriver(Driver)[codel] that will be declared in the \ncommon superclass of Car and Truck. The difference with Case 3 is that here registerDriver(TruckDriver) \nclearly overrides registerDriver(Driver). 9. PA and pc have different codes, and their signatures are \npotentially comparable -both signatures have at least one anchored type at the same position. For instance, \nif pi is p~(Tl, . . . . Ti,X, . . . . Tj,A, . . . . T,)[codel], and pc is pc(Tl, . . . . Ti, Y, . . . \n. Tj, C, . . . . T,)[code2], with Y < X, then LCG(~A,~C) = p(Tl, . . . . Ti,X, . . . . Tj, sup(A, C), \n. . . . T,)[= 01. 10. pi and pc have different codes, and their signatures are incomparable. For instance, \nif PA is p~(Tl, . . . . Ti, . . . . m)[codel], and pc(T;, . . . . T,, . . . . T.,)[code2], then LCG(PA,PC) \n= P(~~P(T~,T:),...,~~P(T~,T,!),...,~~P(T,,T:,))[= 01. This is a case where further researches are neces- \nsary, indeed such a rule may lead, in certain cases, to the creation of uninteresting (only containing \nde-ferred properties) factorization classes. The issues here are (1) how to obtain a more precise rule \nand (2) how to optimize the hierarchy thereafter.    Conclusion We have presented an incremental \nalgorithm able to automatically insert a class, defined by the set of its properties, into an existing \nclass inheritance hierarchy. The algorithm takes an input hierarchy and a class and produces a well characterized \noutput hierarchy: it preserves the input hierarchy features such as its structure, maximal factoriza-tion \nof properties, inheritance paths and the set of meaningful classes. Furthermore, handling of overloading \nin the algorithm has been studied and partially achieved. The problem has been split into two subproblems: \n(1) the comparison of occurrences of generic properties and (2) the use of the results of these comparisons \nin the algorithm. Provided that the first subproblem is solved, the algorithm works with overloading \naccording to the above descrip-tions. Concerning the first subproblem, we have recalled the limits of \nautomatization, i. e. we explained why it will never be able to completely deal with the comparison of \ngeneric properties without the assistance of a human expert. These limits being defined, we have given \na first catego-rization of properties and some rules to compare them automatically in a certain number \nof well de- fined cases, notably in self-referent signatures cases. The algorithm has been implemented \nand tested on nontrivial but pre-compiled cases, One of our main current concerns is to apply it to large \nscale hierarchies produced in foreign applications. This requires interfacing the algorithm, and secondly \nim- subclass responsibility plementing post-processors that will optimize its re- sults -many optimizations \nare possible but there was no room to describe them there. Many further studies can be foreseen: We first \nplan to extend the number of handled cases of automatic comparison of generic properties; this is possible: \n(1) by studying in further detail the cases of properties having self-referent signatures, and (2) by \nanalyzing more precisely method bodies via syntactic and even semantic analysis. Concerning method refactoring \nthrough syntactic analysis, the reader should refer to [OJ93] and [Moo96]. Another difficult issue would \nbe to combine this work with linearization algorithms [DHHM94] used to solve conflicts in hierarchies \nwith multiple inheritance. Ackowledgments We would like to thank Nicolas Prade for its contribution to \nthe automatic comparison of occur- rences of generic properties.  References [Aig79] M. Aigner. Combinatorial \nTheory. Springer-Verlag, 1979. [BerSl] P. Bergstein. Object Preserving Class Transformations. Special \nissue of Sig- plan Notice -Proceedings of ACM OOPSLA 91, 26(11):299-313, 1991. [CasSl] E. Casais. Managing \nEvolution in Ob- ject Oriented Environments : An Al- gorithmic Approach. PhD thesis, Uni-versite de Geneve, \n1991. [Cas92] E. Casais. An incremental class reor-ganization approach. ECOOP 92 Pro-ceedings, 1992. \n[DDHL94a] H. Dicky, C. Dony, M. Huchard, and T. Libourel. ARES, un algorithme d Ajout avec REStructuration \ndans les hierarchies de classes. Actes de Lan- gages et Modkles ci Objets 94, pages 125-136, 1994. [DDHL94b] \nH. Dicky, C. Dony, M. Huchard, and T. Libourel. ARES, un algorithme [DDHL95] [DHHM94] [DMC92] [GM931 \n[GMM95] [GMMM95] [GR83] d Ajout avec REStructuration dans les hierarchies de classes. Technical re-port, \nLIRMM, 1994. H. Dicky, C. Dony, M. Huchard, and T. Libourel. ARES, Adding a class and REStructuring Inheritance \nHier-archies. 11 itmes journe es Bases de Donnees Auance es, Nancy, 1995. R. Ducournau, M. Habib, M. \nHuchard, and ML. Mugnier. Proposal for a Monotonic Multiple Inheritance Lin-earization. Special issue \nof Sigplan Notice -Proceedings of ACM OOP-SLA 94, 29(10):164-175, 1994. Christophe Dony, Jacques Malenfant, \nand Pierre Cointe. Prototype-based languages: From a new taxonomy to constructive proposals and their \nvali-dation. Special issue of Sigplan Notice -Proceedings of ACM OOPSLA 92.) 27(10):201-217, 1992. R. \nGodin and H. Mili. Building and Maintaining Analysis-Level Class Hi-erarchies Using Galois Lattices. \nSpecial issue of Sigplan Notice -Proceedings of ACM OOPSLA 93, 28(10):394-410, 1993. R. Godin, G. Mineau, \nand R. Missaoui. Incremental structuring of knowledge bases. Proceedings of International KR USE symposium: \nKnowledge Re-trieval, Use, and Storage for Es-cienc y Springer- Verlag s Lecture Notes in Artificial \nIntelligence, 9(2):179-198, 1995. R. Godin, H. Mili, G. Mineau, and R. Missaoui. Conceptual Clustering \nmethods based on Galois lattices and applications. Revue d intelligence arti-ficielle, 9(2), 1995. A. \nGolberg and D. Robson. Smalltalk-80, the Language and its Implementa- [JF88] [LBSLSO] [LBSLSl] [MC961 \n Pb921 [MGGSO] [Moo951 [Moo961 [MS891 tion. Addison Wesley, Reading, Mas-sachusetts, 1983. Ralph E. Johnson \nand Brian Foot. Designing reusable classes. Jour-nal of Object-Oriented Programming, 1(2):22-35, 1988. \nK. J. Lieberherr, P. Bergstein, and I. Silva-Lepe. Abstraction of object- oriented data models. Proceedings \nof International Conference on Entity-Relationship, pages 81-94, 1990. K. J. Lieberherr, P. Bergstein, \nand I. Silva-Lepe. From objects to classes: Algorithms for optimal object-oriented design. Journal of \nSoftware Engineer-ing, pages 205-228, 1991. Ivan Moore and Tim Clement. A Sim- ple and Efficient Algorithm \nfor Infer- ring Inheritance Hierarchies. TOOLS Europe 1996 Proceedings, Prentice-Hall, 1996. B. Meyer. \nEi$el, The Language. Prentice Hall -Object-Oriented Series, 1992. Guy Mineau, Jan Gecsei, and Robert \nGodin. Structuring Knowledge Bases Using Automatic Learning. Proceed-ings of the sixth International \nConfer-ence on Data Engineering, pages 274- 280, 1990. Ivan Moore. Guru -A Tool for Auto- matic Restructuring \nof Self Inheritance Hierarchies. TOOLS USA 1995 Pro- ceedings, Prentice-Hall, 1995. Ivan Moore. Automatic \nInheritance Hierarchy Restructuring and Method Refactoring. Special issue of Sigplan Notice -Proceedings \nof ACM OOP-SLA 96, 1996. M. Missikoff and M. Scholl. An Algo- rithm for Insertion into a Lattice: Ap-plication \nto Type Classification. Proc. 3rd Jnt. Conf. FODD 84, pages 64-82, 1989. [OH921 Harold Ossher and William \nHarrison. Combination of Inheritance Hierar-chies. Special issue of Sigplan Notice -Proceedings of ACM \nOOPSLA 92, 27(10):25-40, 1992. [OJ93] William F. Opdyke and Ralph E. Jonhson. Creating Abstract Super-classes \nby Refactoring. Proceedings of the 21st Annual Conference on Com-puter Science, pages 66-72, February \n1993. [Run921 E. A. Rundensteiner. A Class Classifi-cation Algorithm For Supporting Con-sistent Object \nViews. Technical report, University of Michigan, 1992. [Wi189] R. Wille. Knowledge acquisition by methods \nof formal concept analy-sis Data Analysis, Learning Symbolic nd Numeric Knowledge, 23~365-380, 1989. \n[ Wi192] R. Wille. Concept lattices and con-ceptual knowledge systems. Comput-ers Math. Applic, 23:493-513, \n1992. \n\t\t\t", "proc_id": "236337", "abstract": "Several algorithms [Cas92, MS89, Run92, DDHL94a, DDHL95, GMM95] have been proposed to automatically insert a class into an inheritance hierarchy. But actual hierarchies all include overriden and overloaded properties that these algorithms handle either very partially or not at all. Partially handled means handled provided there is a separate given function <i>f</i> able to compare overloaded properties [DDHL95, GMM95].In this paper, we describe a new version of our algorithm (named <i>Ares</i>) which handles automatic class insertion more efficiently using such a function <i>f</i>. Although impossible to fully define, this function can be computed for a number of well defined cases of overloading and overriding. We give a classification of such cases and describe the computation process for a well-defined set of nontrivial cases.The algorithm preserves these important properties:- preservation of the maximal factorization of properties- preservation of the underlying structure (Galois lattice) of the input hierarchy- conservation of relevant classes of the input hierarchy with their properties.", "authors": [{"name": "H. Dicky", "author_profile_id": "81332496385", "affiliation": "LIRMM: Laboratoire d'Informatique, de Robotique et de Micro-&#233;lectronique de Montpellier, 161, rue Ada - 34392 Montpellier Cedex 5 - France", "person_id": "PP14046570", "email_address": "", "orcid_id": ""}, {"name": "C. Dony", "author_profile_id": "81100431943", "affiliation": "LIRMM: Laboratoire d'Informatique, de Robotique et de Micro-&#233;lectronique de Montpellier, 161, rue Ada - 34392 Montpellier Cedex 5 - France", "person_id": "P36093", "email_address": "", "orcid_id": ""}, {"name": "M. Huchard", "author_profile_id": "81100296948", "affiliation": "LIRMM: Laboratoire d'Informatique, de Robotique et de Micro-&#233;lectronique de Montpellier, 161, rue Ada - 34392 Montpellier Cedex 5 - France", "person_id": "PP36041504", "email_address": "", "orcid_id": ""}, {"name": "T. Libourel", "author_profile_id": "81100496349", "affiliation": "LIRMM: Laboratoire d'Informatique, de Robotique et de Micro-&#233;lectronique de Montpellier, 161, rue Ada - 34392 Montpellier Cedex 5 - France", "person_id": "PP31086892", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236364", "year": "1996", "article_id": "236364", "conference": "OOPSLA", "title": "On automatic class insertion with overloading", "url": "http://dl.acm.org/citation.cfm?id=236364"}