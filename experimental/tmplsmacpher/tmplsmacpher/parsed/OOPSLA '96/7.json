{"article_publication_date": "10-01-1996", "fulltext": "\n The Basic Object System: Supporting a Spectrum From Prototypes To Hardened Code Allen H. Dutoitt ahd@sei.cmu.edu \nSoftware Engineering Institute, Carnegie Mellon University, Pittsburgh, PA Sean Levy, Douglas Cunningham, \nRobert Patrick Isnl, dougc, rp2y)@cmu.edu Engineering Design Research Center, Carnegie Mellon University, \nPittsburgh PA Abstract BOS is a prototype-based, object-oriented toolkit aimed at better supporting \nevolutionary software development. BOS attempts to support a spectrum of activities in one environment-ranging \nfrom rapid prototyping to code hardening. Features enabling rapid prototyping include a prototype-based \nobject model, an interpreted language, run-time argument constraints, position and keyword arguments, \nand a user interface toolkit. BOS also provides features for code hardening such as multi-methods, multiple \ninheritance, external code wrapping mechanisms, and interfaces to other packages such as database management \nsystems. BOS thus enables the end-to- end programming of software in an integrated and unified environment. \nBOS has been used to develop several full-size applications which have been evalu- ated and delivered \nexternally. 1. Introduction Evolutionary software development entails the rapid development of prototype \ncomponents and their evo-lution into hardened components [Budde92] [Krogh96]. We have observed that the \ndevelopment of software that exhibits a long life-cycle, for exam-ple software research prototypes which \nare converted into commercial products, often follow an evolution- ary cycle. Research prototypes start \nout as a proof of -t The views and conclusions contained in this document are solely those of the authors \nand should not be interpreted as representing official policies, either expressed or implied, of the \nSoftware Engineering Institute, Carnegie Mellon University, the U.S. Air Force, the Department of Defense, \nor the U.S. Government. permission to make digital/hard copy of part or all of this work for Personal \nor classroom use is ranted without fee provided that copies are not made or distributed for pro PIt or \ncommercial advantage, the qopywht nocW the title of the publication and its date appear, and notlce Is \ngiven that copying is by permission of ACM, Inc. To COP) otherwise, to,!ePublis$ to post on servers, \nor to redistribute to lists, requires Prior speclflc PermIssion and/or a fee. OOPSLA 96 CA, USA (D 1996 \nACM 0-89791-788-x/96/001 0...$3.50 . concept demo which is then turned into a more reli-able prototype \nfor its evaluation by target users and then optimized and refined according to new research directions, \ncommercial ventures, or client require-ments. Furthermore, the maintenance of commercial software may \nalso be viewed as a continuation of this cycle; commercial products reach the market at an earlier stage \nof development, beta testing is done by potential users, and new features are added while the core technology \nis hardened and ported to a variety of hardware architectures. Several recent key achievements in software \nengineering and object-oriented languages are con-sistent with this perspective [Blaschek84] [Cox91]. \nFirst, in software engineering, iterative development processes have become popular as a means to control \nchange and mitigate risks. The spiral model describes an iteration cycle in which prototypes, requirements, \ndesign, and implementation are evolved [Boehm88]. The end of each spiral is characterized by a risk assessment \nphase, which is used to manage the next iteration of the prototype. Second, object-oriented languages \n(e.g., Smalltalk [Goldberg831 and C++ [Stroustrup91]), and later, object-oriented methods (e.g., OMT \n[Rumbaugh93], OOSE [Jacobson92]), became popular, partly because of their potential for developing modifiable \ncode. From an object-oriented perspective, a software system is not viewed as an end point but as a substrate \nwhich evolves and onto which new features are grafted based on market demand. With the above perspective \nof software develop-ment in mind, it is highly desirable to build environ-ments which support evolutionary \ndevelopment. Such an environment would support the development of prototypes and their evolution into \nhardened com-ponents. Moreover, it would support both activities guages and multiple developers, thus \nmaximizing the reuse of knowledge and reducing the need for dis-carding prototype code. Although environments \nsuch as Smalltalk, SELF [Ungar91a], and Tel [Ousterhout94] address some issues associated with evolutionary \ndevelopment, no single environment has systematically addressed evolutionary development. simultaneously \non the same substrate, as new compo- nents are prototyped and integrated into a mature system. It would \nalso accommodate multiple lan- In this paper, we report on the design, implemen-tation, and use of the \nBasic Object System (BOS) [Levy96a], a programming environment we envision as a first step towards supporting \nevolutionary devel-opment systematically. Our approach has been to investigate individual features of \nother languages and systems for their use during either rapid prototyping or code hardening. We then \nimplemented and inte-grated those features into BOS and evaluated their synergy through use. BOS is a \ndynamic, prototype-based, object-ori-ented environment and toolkit. It differs from other environments \nin that it is designed to be open, exten-sible, and language independent. It is packaged as a C library \nwhich enables its use from non-object-ori-ented environments such as C and from existing compiled object-oriented \nlanguages such as C++. Moreover, BOS provides an interface for code gener-ators, enabling the construction \nof parsers supporting different syntaxes. BOS is packaged as a toolkit which includes an example of such \na parser, imple-menting a simple syntax called stitch [Levy96b], a user interface toolkit based on Tk \n[Ousterhout94], and several interfaces to database management sys-tems such as Informix, Ingres, Postgres \n[Stonebraker86], and Illustra. We have used BOS to successfully develop and evolve several mid-to-large \nscale software systems, including a graphical configuration tool, a tool for capturing engineering design \nhistory, and a distrib-uted information modeling environment. This paper is structured as follows. Section \n2 motivates BOS and states our goals when we initi-ated its development. Section 3 describes the core \nBOS programming model. Section 4 discusses issues encountered during its implementation. Section 5 describes \nselected components from the toolkit (i.e., stitch and user interface objects). Section 6 is a sim- ple \nexample of a program written in BOS. Section 7 describes the use of BOS, its observed strengths, and \nits drawbacks. Section 8 briefly relates BOS with two influences of this work: SELF and Tel. Section \n9 concludes this paper.  2. BOS design rationale BOS emerged as the convergence of several research \ninterests and pragmatic constraints present in our research group . The n-dim group has been con-cerned \nwith the study and support of collaborative engineering design in its rich socio-technical context [Subrahmanian93]. \nThis has involved doing detailed studies of information flow between members of design teams and between \ndepartments of large orga-nizations [Finger93], participating in collaborative design exercises with \nother universities [Wilkins89], and developing software tools to study and support collaborative engineering \ndesign. n-dim views software engineering as collabora-tive engineering design. As a consequence, evolu-tionary \nsoftware development is relevant to our research interests. Also, the software prototypes entailed by \nour research are complex and require a significant enough level of reliability and portability that supporting \nevolutionary development is essential to our work. All development environments that we investi-gated \nhave concentrated on supporting either rapid prototyping or the development of commercial strength software. \nFew support both activities well. For example, environments such as Ada [ANSI83], C [Kernighan78], C++, \nand FORTRAN have been successfully used for building commercial software. These languages were designed \nas com-piled languages, enabling compiler optimizations which produce efficient binaries. Ada and C++ \npro-vide strong type-checking, enabling the explicit deti-nition of module interfaces, the early detection \nof errors, and the mitigation of miscommunication among multiple developers. Unfortunately, none of 1. \nThe /t-dim group at the Engineering Design Research Center. CMU, ndim-info@ndim.edrc.cmu.edu these environments \nare appropriate for rapid proto- typing. The compiled nature of their languages entails a long compile-test-debug \ncycle. The strong type-checking for Ada and C++ forces developers to commit to specific module interfaces \nearly. More- over, any interface change of a module (e.g., the addition of a parameter to a routine or \nthe addition of a field to a public structure) forces the modification and recompilation of all dependent \nmodules. When the software under development is large, this becomes an error-prone and expensive task. \nFinally, all of the above languages require programmers to manage memory explicitly, resulting in higher \nerror rates due to memory management errors. At the other extreme, environments such as Smalltalk, Tel, \nCLOS [Gabriel91], and SELF support rapid prototyping well. They provide interpreted lan-guages allowing \nthe modification of code at run-time. They provide weak type systems, which, together with their dynamic \nnature, allows the deferral of clas- sification decisions until late in the development pro-cess. Their \nsyntax is simple and the number of language concepts is relatively small, which enables users to concentrate \non design errors, rather than syn- tactical errors. Finally, most of them provide garbage collection, \nwhich relieves programmers from manag-ing memory explicitly. However, all of these environ- ments suffer \nscale problems; the dynamic nature of these languages often hinders performance. The lack of strong type-checking \nand the overall increased flexibility make it harder for multiple developers to work on a large project. \nAnother issue that has limited the use of environ- ments such as Smalltalk or CLOS for commercial development \nis the difficulty associated with integrat- ing legacy code. Languages such as FORTRAN and C have been \nused extensively for several decades. As a consequence, the number and quality of off-the-shelf components \nfor these languages is very high and embody enormous investments of time and effort. It is often unreasonable \nto expect that this soft- ware be translated into a newer language solely based on the qualities and \nadvantages of the new language. The need for a simple object system and devel- opment environment emerged \nfrom the above consid-erations. Given that our group had an urgent need and could not embark on a full \nscale development of a programming environment, we decided to develop an environment which provides or \nallows for:2 flexible typing and execution of incomplete programs . strong typing . interfaces to external \nsystems . powerful datatypes and generic I/O facilities . object-oriented components . swift development \ncycles . separation of functional and interactive components  3. BOS programming model The first design \ngoal of BOS was to provide a flexible model enabling programmers to create objects, mod-ify their structure \nand behavior, and change their inheritance without restarting applications. This enables programmers \nto prototype and tine-tune components quickly. We accomplished this by adopt- ing and refining the SELF3 \nprototype-based object model. The second design goal was to enable program-mers to harden components \nand reimplement them in C or C++ to address performance issues. In addition, this mechanism allows the \nwrapping of legacy code. We accomplished this by adapting and improving on the code wrapping features \nof Tel. The final task was to reconcile the conflicts between the two goals. This was accomplished by \nmodifying the features of either or both Tel and SELF as incorporated into BOS. 3.1. Ob,ject model overview \nObjects and slots. The object model implemented by BOS is heavily inspired by the SELF prototype-based \nobject model. Most constructs are represented as objecrs; each object is a collection of named slots. \nState and behavior are accessed solely via messages. In BOS, a slot has several attributes, including \na 2. These requirements are a subset of the requirements for an evolutionary development environment \naccording to R. Budde et. al. ([Budde92], pp. 148-50) 3. In this paper, we refer to SELF 2.0 described \nin [Ungarc)la].  nnme, a vnlue, a type, and a priority.4 Slot names and values are defined as in SELF. \nUnlike SELF, BOS has slot types which constrain the kind of object which can be assigned to the slot \n(see Section 3.2). Finally, the priority of a slot is an integer which spec-ifies the manner in which \nthe slot should answer mes-sage sends. If the priority is zero, the slot is considered a value slot, \nand will merely return its value upon receiving a message. If the priority is neg- ative, the slot is \na method, which evaluates its content upon receiving a message. If the priority is positive, the slot \ndenotes an inheritance relationship between the object in which the slot is defined and the object to \nwhich the slot refers. The use of priorities by the message dispatcher is described in Section 3.3. parentPoint \nI I fl parent[l] move - - 1 y(int) *I----- aPoint Legend: parent reference (priority > 1) -+ value \nreference ---) (T) (priority = 0) . - method reference (priority c 1) object slot name[slot priority] \n I ~ ~ I slot name(slot type) Figure 1. An example of a prototype and its associated parent object \nFigure 1 illustrates the three kinds of slots using a point example. A point object, upoioint, contains \ntwo value slots maintaining its state (i.e., its coordinates). 4. After version 2.0, SELF abandoned priorities \n[RSmith95]. aPoint also contains a parent slot referring to parent-Point which provides the behavior \nshared by all points. Finally, the move method slot in parentPoint refers to a block object containing \nthe code to move a point. Note that, due to the prototype nature of BOS, there are no restrictions on \nthe kind of slots which can be defined on objects. In the example above, the move method could have been \ndefined directly on aPoint. This is useful for defining the behavior of one- of-kind objects (e.g., the \nbehavior specific to the true object is defined on the true object). Blocks and methods. As in SELF and \nSmalltalk, closures are represented as blocks. Formal arguments are represented as slots in the block \nobject. The slot name corresponds to the formal argument name, its type corresponds to the argument type, \nand its value corresponds to the argument default value. The code segment of the block is represented \nas internal state. A block is activated by sending the value message to the block with zero or more actual \narguments. Upon activation of the block, BOS clones the block to create an activation object, initializes \nthe activa-tion s slots with the actual arguments, and executes its code segment. When the execution \ncompletes, the result of the last expression in the activation is returned as a result and the activation \nis garbage col-lected. Expressions may return any number of results (including no results at all). A \ncommon method which can return multiple results is the stitch method (provided by all collection objects \nsuch as bags, sets, and vectors) which returns all elements of a collection. Figure 2 illustrates the \nuse of multiple // create three vectors and add elements // to them vlr (prototypes vector clone add: \n1). v2: (prototypes vector clone add: 3 4). v3: (prototypes vector clone add: 7 8). // add elements \nto vl using multiple /I results vl add: 2 (v2 stitch) 5 6 (v3 stitch). // vl is now cl, 2, 3, 4, 5, \n6, 7> Figure 2. Multiple results for vector concatenation results for concatenating vectors. Note that \nthe use-fulness of multiple results is a consequence of their combined use with variadic methods (i.e., \nin this example, the add method on vectors may take an arbitrary number of arguments). BOS blocks differ \nfrom SELF blocks in several ways. First, method and argument names are orthog-onal; the message selector \nin BOS only includes the message name. Although BOS uses keyword argu-ments for resolving ambiguities \nduring message dis-patching, arguments may be passed without keywords; that is, arguments can be passed \nby posi- tion only. Considering only slot names for initial message selection enables BOS to differentiate \nbetween typing errors, ambiguities, and undefined messages (see Sections 3.3 and 3.4). The second dif-ference \nis that slots of a block object are classified into two categories: required and option&#38; arguments. \nRequired argument slots are arguments that must be specified in a message send. Optional argument slots \nmay also be used as local variables in the block. The need for optional arguments was motivated in the \ndomain of user interfaces. From a performance point of view, it is desirable to specify a large number \nof attributes upon creation of a window or other graphi-cal objects. From a usability point of view, \nwe found it unreasonable to require the user to specify all pos- sible attributes of a window. The existence \nof optional arguments provides a trade-off by allowing the development of methods with a large number \nof options with default values. BOS blocks provide a wrapping mechanism sim-ilar to Tel commands. The \ncode segment of a BOS block is represented either by executable byte code or a C function. Unlike Tel \nand SELF, BOS supports argument constraint checking (see Section 3.2) and provides the programmer with \nstronger assumptions about the actual arguments passed to the block. This significantly reduces the amount \nof code the pro-grammer must write to check the consistency of arguments. Also, unlike Tel which represents \nevery-thing as strings, BOS represents objects and values as C structures (see Section 4.1). This reduces \nthe over-head entailed by converting arguments to and from wrapped code and across blocks. Figure 3 depicts \na method referring to a block with two arguments. parent of point objects parent[l] Figure 3. An example \nof a block object Note that methods and blocks in BOS are orthogonal concepts. A method slot can refer \nto a non-block object, in which case it behaves as a value slot. Simi- larly, a value slot can refer \nto a block, in which case it returns the block (without evaluating it) when answering a message. Table \n1 summarizes the rela-tionship between slot behavior, slot type, and slot content. This clear distinction \nbetween methods and blocks leads to a simple model and a robust imple-mentation. Methods implementing \ncontrol structures (e.g., ifTrue, do, and while) are common uses of value slots referring to blocks. \nFor example, for do methods, the block implementing the iteration code is passed as an argument and then \nstored in a value slot of the activation. Table 1: Slot behavior . 1 block 1 evaluate block method slot \n send value message non-block to content Inheritance. As in SELF, inheritance is represented as parent \nslots with priorities. Objects inherit state and behavior from their ancestors when answering messages \n(see Section 3.3). In addition, all objects, by definition, inherit from traits object, the BOS root \nobject which provides methods applicable to all objects. As in SELF, all BOS objects inherit from themselves. \nThe rationale for this design deci-sion is discussed in the following section, describing the BOS type \nsystem. 3.2. Slot and argument constraints Slot types. The slot type attribute is used by BOS to enforce \nconstraints on the kinds of objects which can be referred to by a given slot. To be consistent with the \nprototype-based nature of BOS, types are repre-sented as objects. Moreover, any object (including immutable \nobjects such as 1 ) can be used as a type. In BOS, an object A is said to conform to a type T if A inherits \nfrom T. Given that all objects inherit from traits object, the programmer may delay any classification \ndecisions by initially setting slot types to traits object. Also, the object nil con-forms to all types. \nThis allows the programmer to use nil as a default value for initializing optional argu-ments and slot \nvalues in prototype objects. Finally, self-inheritance (e.g. given that A inherits from A, A conforms \nto type A) renders the type system consis-tent with the prototype-based nature of BOS and allows the \nprogrammer to use slot types to constrain arguments to be one-of-a-kind objects. This symme-try between \nthe type system and prototype object model makes BOS distinctive. Figure 4 illustrates the use of this \nfeature with a simple implementation of the and and or messages for true and false. true -DefineSlots: \n(I and = [aBool(true) 11 1 true]. and = [aBool(false) 111 false]. or = [aBool(bool) 11 1 true]. 1). \nfalse -DefineSlotS: (( and = [aBool(bool) I ) I false]. 01 = [aBoo (true) 11 I true]. or = [aBool(false) \n) 1 I false]. I). Figure 4. Using BOS types for one-of-a-kind objects. While slot types in BOS are intuitively \nsimilar to variable types in C and C++, several critical differ-ences should be noted. C++ provides static \ntype-checking, while BOS checks argument constraints at run-time. This is desirable during prototyping \nwhen types and inheritance structures are still changing. This also enables consistency checking of actual \narguments against formals even in the presence of polymorphism. Note that the BOS type system is biased \ntowards supporting prototyping rather than code hardening by checking argument constraints at run-time. \nOn the one hand, this trade-off allows code to be modified and reloaded at run-time. On the other hand, \ntype conformance in BOS requires the execution of the application under test, while C++ type-checking \nguarantees type conformance before the application is ever executed. Slot type signatures. The type signature \nof a method slot containing a block is defined as the sequence of slot types of its required arguments. \nFor example, if a method M takes three required arguments, A, B, and C, of slot type T,, Tbr and T,, \nthe type signature of M is said to be CT,, Tb, T,>. The type signature of a value slot is the empty sequence-i.e., \na value slot is treated as a method taking one optional argument (see Figure 5). Slot type signatures \nare used by BOS during message dispatching to match methods by using actual arguments. // 3 required \n // Type signature: <int, float, bool> m = [a(int).b(float).c(bool)lj I . ..I // 2 required &#38; 1 \noptional // Type signature: <int, float> m = [a(int). b(float) ( c(bool)I ( . ..I // value slot // \nType signature: C> m = true. Figure 5. Examples of type signatures.  3.3. Message dispatching BOS \nis an asymmetric, multiple-dispatching message system. It is a multiple-dispatching system in the sense \nthat receiver and actual arguments are used to select methods. It is asymmetric in the sense that multi-methods \nare located in the inheritance graph of the receiver (unlike CLOS, which provides symmet- ric multi-methods). \nFrom the programmer s point of view, message dispatching occurs for every message send. In other words, \nany change in the state of the system is visible as early as the next message send. For example, the \nprogrammer may change the inheritance hierarchy, change the type signature of a method, or add or remove \nslots between any two message sends. Message dispatching in BOS comprises two steps: message lookup \nand disambiguation. Message lookup selects candidate methods by matching the message selector against \nslot names. Then, disambig-uation filters out any candidate method whose formal arguments are incompatible \nwith the actuals. Message lookup. In the presence of a single inherit-ance structure (i.e., when every \nobject in the system has exactly one parent slot), the BOS message lookup algorithm is identical to the \none in SELF. The lookup starts with the receiver to which the message was directed. If the receiver does \nnot have a slot matching the name of the message, the lookup con-tinues with the parent of the receiver. \nIf the parent does not define a matching slot, the lookup continues with the parent of the parent, recursively. \nThe lookup returns when either one or more matching slots are found or the inheritance graph is unsuccessfully \ntra-versed. If the lookup is unsuccessful, the mes-sageNotUnderstood erroris raised. Multiple inheritance. \nIn the presence of multiple parent slots within an object, the lookup algorithm uses parent priorities \nto direct the search. Given an object with multiple parents, only parents with the highest priority are \ninitially searched. If matching slots are found, the lookup returns without examining parents of lower \npriority. If the search is unsuccess- ful, the search is repeated with parents of the next highest priority. \nIf all parents are searched unsuccess-fully, the lookup raises the messageNotUnder-stood error. In other \nwords, priorities are used to impose a lexical ordering on all possible paths from the receiver to matching \nslots. In this manner, the lookup algorithm is simply reduced to a depth first, branch and bound search \nalgorithm. The semantics of priorities are similar to that of SELF 2.0. BOS provides priorities as a \nmechanism for the programmer to resolve ambiguities due to multiple inheritance. Note that parent slot \npriorities need not be unique within an object and thus provide only a partial ordering of the objects. \nSetting equal parent priorities enables the programmer to use type signatures for selecting messages \ninstead of parent priorities. Multi-methods. BOS allows multiple slots in the same object to have the \nsame name, as long as their slot type signatures are unique. Consequently, the message lookup can return \nmultiple candidate meth-ods. Then, the actual arguments are used to filter can-didate methods. First, \nthe number of required arguments is used to filter out any methods whose number of required arguments \nis greater than the number of actual arguments. Then, any actual argu-ments passed by keyword are used \nto filter out meth-ods whose formal argument names are incompatible. Finally, the actual arguments are \nchecked against the formal argument slot types for type conformance; any methods whose type signature \ndoes not conform to the actual arguments are discarded. If this filtering step discards all candidate \nmethods, BOS raises the argumentMismatch error. If more than one method is left, the ambiguousMessage \nerror is raised. Oth-erwise (i.e., exactly one method is left), the message is bound and the message \nsending algorithm pro-ceeds to the argument binding step described in Section 3.4. Note that the consistency \nof actual and formal arguments is checked even when the message lookup returns a single method. Another \nexample of multi-methods is presented in Figure 4. Note that BOS resolves multi-methods at run-time as \nopposed to C++ which provides static over-loading. Although the semantics of BOS multi-meth-ods and C++ \noverloaded methods are different, BOS F allows a programmer to wrap overloaded C++ meth- ods. Also, note \nthat there still are many open issues related to the use and implementation of multi-meth- ods in the \ncontext of object-oriented languages. Solu-tions to these issues have been recently proposed in Cecil \n[Chambers95]. Message resend and delegation. BOS allows the programmer to specify the first object to \nconsider during the message lookup. In the common case, the message lookup starts with the receiver of \nthe mes-sage (i.e., self). In the simplest form of a message resend, the lookup starts with the parents \nof the object in which the current method is defined. For example, in Figure 6, assume aPoint received \nthe cartesianObject abstractfoint curtesianfoint parent[l] otherParent[2]  movea c yolarfoint parent[l] \n d move . . . Figure 6. Examples of delegation move message and movea method in cartesianfoint is selected. \nIf movea simply resends the move message, the lookup starts with the highest priority parent (i.e., labeled \nparent in the figure) and the moveb method in cartesianObject is selected. A similar behavior is provided \nby super in Smalltalk. In the presence of multiple inheritance, this behavior is not always desired. \nTo solve this prob-lem, BOS allows the programmer to specify the par- ent slot to follow. In the previous \nexample, if the movea method in cartesianfoint resends the move message and specifies the parent slot \notherparent as a starting point, the move' method in abstractPoint is selected. Finally, the programmer \nmay want to resend a message to an object which is not a direct parent of the current method holder, \nsuch as an ancestor or a sibling. Using the previous example, the movea method may resend the move message \nand specify polarPoint as a starting point. In that case, the moved method is selected. Note that message \nresending in BOS is only a mechanism for explicitly specifying the starting point of the message lookup. \nMessage resending is independent of the current state of the receiver. For example, if the parent slot \nof doint is modified after the selection of movea but prior to any of the three resends describe previously, \nthe same behavior would have been observed. Note also that the semantics of BOS resend is much simpler \nthan that of SELF 2.0. In case the moveb method resends the move message, the BOS lookup never considers \nthe moveC method as a candi- date, that is, the message lookup never backtracks from the current method \nholder. However, we have limited experience in developing applications which use multiple inheritance \nextensively. It is therefore possible that the simultaneous use of slot priorities, multi-methods, and \nmultiple inheritance in BOS leads to undesirable interactions such as those observed in SELF 2.0 [RSmith95]. \n3.4. Argument binding Position arguments. BOS supports position argu-ments, given that their implementation \nleads to an efficient argument passing algorithm. When actual arguments are not tagged with keywords, \nactual argu-ments are bound to formal arguments in the same order they are passed. Since the number of \nactual arguments and their type have already been checked during the message dispatching step, actual \nargu-ments are simply used to initialize the slots of the activation being bound. If the number of actual \nargu-ments is less than the total number of slots in the acti- vation (i.e., if some of the optional \narguments have not been passed), these last slots maintain their origi- nal value (i.e., the default \nvalue). Keyword arguments. Given that their use is more frequent during rapid prototyping and user interface \nconstruction, BOS also supports keyword arguments. Here, each actual argument is tagged by a keyword, \nwhich is used for matching against the name of the formal arguments. The actual arguments do not have \nto be in the same order as the formal arguments. The optional arguments do not have to be specified. \nIf formal arguments are specified more than once, or if a required argument is not specified, BOS raises \nan argumentMismatch error, as described previously. Mixed arguments. BOS allows position and key-word \narguments to be mixed in a message send. We observed that this ability is useful during the devel- opment \nof user interfaces, in which methods with a large number of optional arguments are frequent. This enables \nthe programmer to pass the required arguments by position (for efficiency) and the few optionals to be \nspecified by keyword (for brevity). In this case, position arguments are bound first, then keyword arguments \nare then, as explained in the pre- vious paragraph. Variadic methods. An alternate way to handle meth-ods \nwhich can take a large number of optional argu-ments is the use of variadic methods. Given a method M, \nif the last required argument is of type traits rest, all remaining arguments are col-lected into a rest \nobject which is bound to that argu- ment. A rest object is a collection which contains a vector part \nand a table part. Unbound position argu-ments are added to the vector part in the order they were passed, \nwhile any unbound keyword arguments are added to the table part using the argument key-word as a table \nkey. Argument constraints. As previously described, activations are represented with block objects and \narguments are represented as slots in blocks. From the programmer s point of view, the actual arguments \nare checked for type conformance with formal argu-ments when the block is activated. However, check-ing \nargument constraints is not necessary at this point, given that the message dispatch algorithm guarantees \nthat the formal and actual arguments are consistent by the time a method block is activated. Repeating \nthe constraints check is unnecessary. 4. Implementation issues In this section, we describe some of the \nmajor issues we encountered while implementing BOS and satis- fying the requirements described in Section \n2. Since the number of such issues is too large to allow dis-cussion here, we focus on three: the BOS \narchitec-ture, external code wrapping, and garbage collection. 4.1. Architecture Our requirement of \nan evolutionary development environment is that it accommodates legacy code, either interpreted or compiled, \nwritten in different languages. Also, the mechanisms developed for wrapping existing code can be used \nduring hardening to reimplement performance critical components. Tel accommodates compiled code by providing \nwrapping mechanisms. SELF accommodates Small-talk by providing a translator. Our approach was to package \nBOS as a C library, rendering it independent of any syntax (unlike Tel). Consequently, BOS can be used \neven in purely compiled languages without the overhead of an unneeded parser. Instead, primi-tives provided \nby BOS are available as a small set of C structures and functions. The code segment of blocks is either \na C function or encoded as a stream of virtual machine instructions, similar to Smalltalk byte code. \nThe instruction set of the BOS virtual machine is a simple stack machine with less than 15 instructions \nfor pushing objects on and popping them from the run-time stack, sending messages, and rais- ing exceptions. \nObject creation and modification, block activation, control structures, and arithmetic operations are \nall currently implemented as message sends. Drawing on lessons learned from using Tel, we also provided \na large number of convenience func-tions and macros to support common cases encoun-tered when writing \nC blocks. A parser for stitch (see Section 5.1), an object-oriented language inspired by the SELF syntax, \nis also provided in the form of a separate library, though its use is not required by BOS. Moreover, \nwe envision the development of parsers on top of BOS for implementing other lan-guages, such as SELF \nand Smalltalk, which would address the issue of accommodating interpreted leg-acy code. To facilitate \nwrapping legacy code, the memory layout of BOS objects respects the same rules as C structures. Except \nfor space overhead at the begin-ning of the object, there is a one to one mapping between BOS objects \nand C structures containing primitive types. Figure 7 contains an example of such a mapping. The top \npart of the figure shows a BOS object referring to a character, a double, and a string (all of which \nare considered objects). The bottom part of the figure shows the equivalent C structure. Note that BOS \nstrings are not equivalent to C strings. This mapping reduces the need for converting across representations \nand copying values when passing arguments. It also allows an object to be cast to a structure in methods \nimplemented in C, thus enabling the programmer to bypass the message sending mechanism when accessing \nstate. Although this practice introduces an explicit distinction between state and behavior (which is \nnormally hid-den in BOS), we found it critical near the end of the code-hardening cycle when run-time \nspeed becomes a much more important issue than modularity. This also facilitates the wrapping of existing \ncomponents by reducing the amount of glue code required and by avoiding data duplication. The following \nsection addresses in more detail the issues related to wrap-ping legacy code. I/ a sample BOS object \n( I c (traits char). d (traits double). s (traits string). I) // its corresponding C structure struct \n{ /* per-object overhead */ -BOS-HEADER-; /* slots */ char c; double d; /* s is a handle (sizeof(pointer)) \n*/ Bos-Object s; Figure 7. A BOS object (using the stitch notation) and equivalent C structure 4.2. \nExternal code wrapping The mechanisms provided by BOS to wrap compiled legacy code are similar in concept \nto those provided by Tel. We addressed two drawbacks of Tel: data representation and the amount of glue \ncode needed (see Section 8.1). Representing objects as C structures partially addresses the drawback \nof Tel s representation of values as character strings. However, our approach assumes that the legacy \ncode does not access or mod- ify memory space in front of the structure (which is managed by BOS). When \nwrapping around C-c+ classes (which exhibit this problem), the programmer addresses this issue by modifying \nthe inheritance hierarchy such that wrapped classes all inherit from the C-t+ Wrapper class provided \nby BOS. Finally, if the modification of the inheritance hierarchy is not possible (e.g., the classes \nto be wrapped are part of a commercial product), wrapper objects may be defined as a structure containing \na single pointer to the C++ object being wrapped. BOS provides the C programmer with primitives to hide \nand manage these pointers and requires that any access to the BOS object are done through methods. Although \nthis last approach requires a slightly larger amount of glue code (i.e., one method per exported C++ \nmethod), we observed that the wrapping overhead is still smaller than the amount of glue code required \nby Tel. Tel requires the programmer to convert wrapped data from a string representation to primitive \ntypes and to explicitly check the argument types, which is not the case in BOS (see Section 8.1). Finally, \nthe last difficult issue we encountered when wrapping legacy code was the co-existence of code requiring \nthe explicit management of memory (as in C and C++) with garbage collection provided by BOS. This is \nthe subject of the next section. 4.3. Garbage collection Explicit memory management (i.e., allocation, \nreal-location, and freeing of memory chunks) provides the programmer with the ability to optimize the \napplication for speed and space. However, explicit memory management also introduces the potential for \nfatal errors. Garbage collection addresses mem-ory management by freeing any structures that are not \nreferenced. However, in addition to significant speed and space overhead, garbage collection intro-duces \na variance in response time, thus frustrating the user with unpredictable performance. In an evolu-tionary \ndevelopment environment, garbage collection should be provided such that its overhead is spread across \nrun-time in a predictable manner, and such that it can be explicitly controlled by the programmer (i.e., \nthe programmer should be able to tune garbage collection to trade-off space with speed). However, the \nprogrammer should not have to be burdened with detailed knowledge of the garbage collector. More-over, \ngarbage collection should co-exist with any other essential features provided by the environment (e.g., \nlegacy code wrapping). Memory management in BOS (which is handled by the clone method and the garbage \ncollector) is implemented using standard C memory management primitives only. Object structures are allocated \nand freed individually on a per need basis. We avoided using operating system specific memory manage-ment \nprimitives in order to enhance portability and ensure compatibility with legacy components. The BOS garbage \ncollector does not compact memory. Instead, additional memory fragmentation is con-trolled by caching \ncommon memory structures (i.e., by pooling objects). The garbage collector is implemented as an incremental \nmark and sweep algorithm [Wilson941 which is packaged in a separate run-time thread. The amount of work \ndone by the garbage collector is managed by a feedback control algorithm which readjusts the garbage \ncollector s parameters based on the process size and the rate of allocation. Moreover, the programmer \nhas direct control over the algo-rithm s parameters, which enables fine tuning the garbage collector \nto trade-off between speed and space. However, the feedback algorithm performs well in most situations \nand thus, makes such an inter- vention a rare occurrence. The interaction with legacy code is handled \nby way of callbacks. When the programmer wraps leg-acy code, he may specify three callbacks for allocat- \ning, scanning, and freeing memory chunks unknown to BOS. These callbacks are invoked when the wrapped \nobject is cloned, marked, or swept, respec-tively. 5. Tools BOS comes with several tools for the construction \nof object-oriented programs. Two of them are described in this section: the stitch language, which supports \nthe prototyping phase of software development, and the graphical user interface toolkit, which allows \nusers to easily create interfaces by cloning interface objects. 5.1. stitch The stitch programming language \nbegan as an imple- mentation of the SELF language on top of BOS. However, as the implementation of stitch \nproceeded it became apparent that there were concepts of BOS that were not supported by the SELF syntax. \nAs a result, the stitch syntax was modified such that it could use all of the features of BOS including: \n. slot types position and keyword argument passing . optional arguments . variadic methods . multiple \nresults stitch provides syntactic sugar for creating blocks and objects in the form of an object and \na block con- structor, respectively. Figure 8 shows two examples of stitch syntax. The first example \nis an object con-structor showing the creation of an object from prototypes object with a slot called \na of type traits number with a priority 0 and a default value of 5. The second example is a block construc-tor \nwhich shows the creation of a block containing the required arguments a (typed as traits number) and \nb (typedas traits object by default); a variadic argument collector, args; and a local variable, c. // \nExample 1: A stitch object (prototypes object1 a(traits number) [Ol = 5. I). // Example 2: A stitch \nblock attraits number). b argsltraits rest) C I I I. Figure 8. stitch syntax examples 5.2. BOSTk \nTk, as provided in the standard TcVTk release, con-sisted of two major components: . A replacement for \nthe X toolkit intrinsics which sought to work around a number of fundamental problems with X windows \nso as to hide them from the TcVTk programmer; . A set of user interface widgets (components) which more \nor less mimicked the Motif graphical style, but which could be used in a much more flexible and immediate \nway via Tel. BOS provides a user interface toolkit based on Tk; however, instead of Tel, this version \nof Tk (BOSTk) is based on BOS. All widgets are repre-sented as BOS objects, and the normal notions of \ninheritance, refinement, and so on are available to the programmer. In addition, BosTk objects are easily \ncreated and manipulated from stitch thus facilitating the rapid prototyping of interfaces. For example, \nFigure 9 shows how a dialog box can be prototyped in just a few lines of stitch. The stitch code shown \nwas simply entered at the stitch command line to cre- ate the dialog box shown. 6. Point Example The \nfollowing example incrementally demonstrates several features of BOS. First, it shows how to create a \npoint object in stitch. Then, a user interface is constructed to display the point. The example dem-onstrates \nthat the point object can be reimple-mented in C to gain speed. Then the point object is implemented \nin C++ to demonstrate how existing code can be wrapped, or used, by BOS. Finally, the example presents \nhow the brokering mechanism pro-vided with BOS can be used to cleanly separate the implementation of \nthe user interface displaying the point from the actual point itself. Point Object in stitch. Figure \n10 represents the cre-ation of a point object in stitch. The point object has two slots, x and y, both \ntyped as traits integer. In addition, a move method is defined on traits point which resets the coordi- \nnates of the point. To use the point object, the pro- grammer would clone the prototypical point and \ninteract with it via messages. world -DefineSlots: (1 dialog. message. okButton I). dialog: (tk prototypes \ntoplevel clone: (tk top) 1. message : (tk prototypes label clone: dialog text:\"Error!\" relief:#ridge). \nmessage packAppend: side:#top fill:#both expand:true. okButton: (tk prototypes button clone: dialog text: \n\"OK\" relief: #groove block: [Id=dialog/ ) d destroy I). okButton packAppend: side:#top padY:20 dialog \ntitle: \"Dialog\". dialog map Figure 9. BOSTk Dialog Box Example defineProtoAndTrait: #object #point. \n prototypes point -DefineSlots: (1 x (traits integer). y (traits integer). I)' traits point -DefineSlots: \n(1 // Move the point to new coordinates move = [ dx (traits integer). dy (traits integer). I I x: (x \n+ dx). y: (y + dy) . self. // Return the point I. I). Figure 10. stitch point object User Interface \nto Point Object. After creating the point object we can create an interface in stitch by cloning BOSTk \nobjects. The resulting window inter-face, called the pointDisplay object, is shown in Figure 11. The \ninterface contains two entry lines for the x and y coordinates and a canvas which contains a displayed \npoint. The displayed point is a represen- tation of the point because it is merely how the user interface \npoint object displays itself. the point object; it is not the Coordinate Entries Displayed Point Figure \n11. Point Display Now we need to interact with the point object from the interface. Figure 12 shows \nthe canvasMove method which implements a mechanism for interac-tion. The canvasMove method is invoked \nwhen the user drags the displayed point on the canvas: it retrieves the coordinates from the X event \nof where the user moved the mouse to, sends the move mes-sage to the point object, and sends itself the \nredisplay message. In addition, the interface has an entryMove method which moves the point in a similar \nmanner when the user enters new coordinates in the entry lines. The user can drag the displayed point \naround or enter new coordinates and the result is that the point object is sent the move message with \nits new coordinates and then the coordinates are updated and the displayed point is redrawn. Point Object \nin C. When an object definition becomes stable, it can be partially or completely reimplemented in C \nfor efficiency. Figure 13 demon- strates how the point object definition and move method would be implemented \nin C. It is important to note that this does not preclude the addition of new stitch methods to the point \nobject (now in C). Point Object in C++. To extend this example fur- /* Method to move point from binding \n*/ canvasMove = L e (tk traits event) mx. my. px. py I I // Position of mouse mx: (displaycanvas canvasx: \n(e x)). my: (displaycanvas canvasY: (e y)). // Position of display point px: (uiPoint xc). py: (uiPoint \nyc). // Move point object by difference point move: (mx - px) (my - py). // Redisplay coordinates and \npoint redisplay Figure 12. CanvasMove method in stitch /* BOS Point Object Definition */ typedef struct \n{ /* per-object overhead */ -BOS-HEADER-; /* slots */ int x; int y;  } BosPoint; /* Bos point move \nmethod */ BosDefineCMethod(BosPointMoveCM) Bos-ReturnCode code = BOS-OK; BosPoint **point; int dx, dy; \n point = self->v-object; dx = msgv[O].ma-value.v-int; dy = msgv[l].ma-value.v-int; (*point)->x = (*point)->x \n+ dx; (*point)->y = (*point)->y + dy; BosRetUrnSelfo; return BOLT-OK; Figure 13. C point object ther, \nassume that the point object is implemented in C++. Figure 14 shows the C++ code necessary to implement \na Point class. In order to access the C++ Point class, a BOS point object still needs to be implemented, \nbut this time, instead of containing x and y slots the BOS   \n\t\t\t", "proc_id": "236337", "abstract": "BOS is a prototype-based, object-oriented toolkit aimed at better supporting evolutionary software development. BOS attempts to support a spectrum of activities in one environment---ranging from rapid prototyping to code hardening. Features enabling rapid prototyping include a prototype-based object model, an interpreted language, run-time argument constraints, position and keyword arguments, and a user interface toolkit. BOS also provides features for code hardening such as multi-methods, multiple inheritance, external code wrapping mechanisms, and interfaces to other packages such as database management systems. BOS thus enables the end-to-end programming of software in an integrated and unified environment. BOS has been used to develop several full-size applications which have been evaluated and delivered externally.", "authors": [{"name": "Allen Dutoit", "author_profile_id": "81100009904", "affiliation": "Software Engineering Institute, Carnegie Mellon University, Pittsburgh, PA", "person_id": "P15391", "email_address": "", "orcid_id": ""}, {"name": "Sean Levy", "author_profile_id": "81332512064", "affiliation": "Engineering Design Research Center, Carnegie Mellon University, Pittsburgh PA", "person_id": "PP31086762", "email_address": "", "orcid_id": ""}, {"name": "Douglas Cunningham", "author_profile_id": "81405595698", "affiliation": "Engineering Design Research Center, Carnegie Mellon University, Pittsburgh PA", "person_id": "PP15036275", "email_address": "", "orcid_id": ""}, {"name": "Robert Patrick", "author_profile_id": "81100138555", "affiliation": "Engineering Design Research Center, Carnegie Mellon University, Pittsburgh PA", "person_id": "PP14059063", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236346", "year": "1996", "article_id": "236346", "conference": "OOPSLA", "title": "The basic object system: supporting a spectrum from prototypes to hardened code", "url": "http://dl.acm.org/citation.cfm?id=236346"}