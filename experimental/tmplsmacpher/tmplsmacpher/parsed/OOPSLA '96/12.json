{"article_publication_date": "10-01-1996", "fulltext": "\n Slicing Class Hierarchies in C++ Frank Tip Jong-Deok Choi IBM XI. Watson P 0. Box 704, Yorktown {tip, \njdchoi, jfield, Abstract This paper describes an algorithm for slicing class hier- archies in C++ programs. \nGiven a C++ class hierarchy (a collection of C++ classes and inheritance relations among them) and a \nprogram P that uses the hierarchy, the algorithm eliminates from the hierarchy those data members, member \nmnctions, classes, and inheritance relations that are unnecessary for ensuring that the se-mantics of \nP is maintained. Class slicing is especially useful when the program P is generated from a larger program \nP by a statement slicing algorithm. Such an algorithm eliminates state-ments that are irrelevant to a \nset of slicing criteria-program points of particular interest. There has been considerable previous work \non statement slicing, and it will not be the concern of this paper. However, the combination of statement \nslicing and class slicing for C++ has two principal applications: First, class slicing can enhance statement \nslicing s utility in program de-bugging and understanding applications, by eliminating both executable \nanddeclarative program components ir-relevant to the slicing criteria. Second, the combination of the \ntwo slicing algorithms can be used to decrease the space requirements of programs that do not use all \nthe components of a class hierarchy. Such a situation is particularly common in programs that use class \nli-braries. Permission to make digitalkard copy of part or all of this work for personal or classroom \nuse is aranted without fee provided that copies are not made or distributed for prozt or commercial advantage, \nthe copyright notice, the title of the publication and its date appear, and notice is given that copying \nis by permission of ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute \nto lists, requires prior specific permission and/or a fee. OOPSLA 96 CA, USA Q 1996 ACM O-89791-788-W96/0010...$3.50 \nJohn Field G. Ramalingam Research Center Heights, NY 10598, USA rama}@watson.ibm.com 1 Introduction \n 1.1 Overview Program slicing is a technique for isolating computa-tional threads in programs [30]. A \nprogram slice is generally defined as the set of statements that either contribute to, or are affected \nby, the values computed at some designated point of interest in the program. The combination of a program \npoint and a set of variables of interest at that point is referred to as the slicingcriterion. Almost \nall previous work on slicing has addressed the question of determining which executable statements should \nbe included in a slice, i.e., obtaining what we will call a statement slice. By contrast, we are concerned \nin this paper with eliminating unnecessary components from the declarative parts of C++ programs. In \nabstract form, our algorithm takes as input a C++ class hierar-chy (a collection of C++ classes and and \nthe inheritance relations among them) and a program that uses the hi- erarchy. It then eliminates from \nthe hierarchy those data members, member functions, classes, and inheri-tance relations that are unnecessary \nfor ensuring that the semantics of the program is maintained. Our algorithm is specifically designed \nto accommo-date the inheritance mechanism of C++. Due to the complexity of the semantics of multiple \nand virtual (i.e., shared) inheritance in C++, the task of obtaining class slices that are correct (in \nthe sense that they do not alter the behavior of the criteria), yet not excessively conservative (in \nthe sense that they do not include un-necessary class components), is far from trivial. Sim-ple approaches \nto the problem are likely to suffer from subtle errors, or, if correct, to require excessive con-servatism. \nWe therefore take a formal approach to the problem that ensures that the semantics of the program are \npreserved by the slicing operation. Statement slicing was originally proposed as a way to allow programming \ntools to assist the programmer in isolating the source of an error, or to focus attention on code that \nis relevant to a proposed program modification (see [29] for a survey of various slicing techniques and \ntheir numerous applications). For C++, our algorithm can complement statement slicing algorithms (e.g., \nthat of Larsen and Harrold [20]) by eliminating irrelevant declarations as well as irrelevant statements. \nIn addition, our algorithm has the benefit of allow- ing unused components of classes to be eliminated \nin applications that do not use those components. This application is similar to the work of Agesen and \nUngar [4, 31 for the dynamically typed language Self. How-ever, the complex static inheritance mechanisms \nof C++ require a different approach. Although class slicing can be used to eliminate un-needed components \nfrom any program, it is of particular value when used in conjunction with statement slicing to eliminate \nextraneous components from a class li-brary. In this scenario, statement slicing would be used to eliminate \nlibrary code irrelevant to a particular client application. Class slicing would then be used to elim- \ninate unnecessary data members and inheritance links. The space savings accruing from elimination of \nsuch components, especially for programs that make exten-sive use of libraries, can be considerable. \n 1.2 Statement Slicing To understand the traditional notion of statement slicing, consider the example \nprogram in Figure l(a). This program computes the sum and the product of the first n integers. Figure \n1 (b) shows a slice with respect to the value of prod at the last line of the program. Observe that the \nstatements that concern the computation of sum have been eliminated. Thus a programmer concerned with \nan error in the computation of prod need not consider the omitted statements when tracking down the error \ns source. #include <iostream.h> #include <iostream.h> I void mainO{ void mainO( int n; int n; tin >> \nn; tin >> n; int sum = 0; I I int prod = 1; int prod = 1; for (int i = 1; for fint i = 1; i <= n; i \n<= n; i++){ i++){ sum += i: I I prod *= i; prod *= i; 1 1 tout <q sum << endl; I I tout C-C prod << \nendl; tout << prod << endl; 1 1   (a) I tb) Figure 1: (a) Example program. (b) Slice of the program \nw.r.t. the value of prod at the last line of the program; constructs irrelevant to the final value of \nprod have been eliminated and replaced by boxes. 1.3 Slicing Class Hierarchies Consider now the more \nsubstantial example in Fig-ure 2(a), which shows a class hierarchy that uses both multiple inheritance \nand virtual inheritance. This exam- ple is deliberately very contrived in order to illustrate a number \nof fine points. According to the semantics of C++ [ 141, any ob-ject of type D contains two distinct \nsubobjects of type A (inherited non-virtually through classes B and C, respec- tively), but only one \nsubobject of type S (because S is inherited virtually through classes B and C). The subob- ject graph \n[27,26] for this class hierarchy is depicted in Figure 2(b). For convenience, we will refer to the two \nA subobjects of D as [D, D-B-A] and [D, DC-A], respectively. The control flow in the example is slightly \ncounterin-tuitive. The call to method bar ( 1 in procedure main is resolved to C : : bar ( ) . The resolution \nprocess that is used here, relies on the notion of dominancel. In this case, both C : : bar ( ) and S \n: : bar ( ) are visi-ble from class D, and the former dominates the latter. The call to method f oo ( \n) in the body of C : : bar ( ) is resolved in a similar way. However, due to the fact that f oo ( ) is \nvirtual, the run-time type is used IA member name f in one subobject B dominates a member name fin subobject \nA if A is a base class subobject of B [I, Section 10.21.  180 class A { public: int x; class S { public: \nvirtual void foot); void bar0; 1; class B : public A, public virtual S { public: virtual void foot); \n 1: class C : public A, public virtual S { public: void bar0; 1: class D : public B, public C {}; \n void S: :fooO{}; void S: :barO{}; void B::fooO{ x++; }; void C::bar(){ this->fooO; }; void mainO{ D \nd; B* b = &#38;d; b->x = 17; c* c = &#38;d; c->x = 71; d.barO; int v = b->x; int W = C->X;  S A CldSS \nfi 1. public: int x; 1; class S { public: virtual void foo0; L I 1; class B : public A, public virtual \nS { public: virtual void foo0; 1; @I class C :-public virtual S { public: void bar(); 1; class D : public \nB, public C (1; void S::fooO{}; I 1 void B::fooO{ x++; }; void C::bar(){ this->fooO; }; void main(){ \nD d; B* b = &#38;d; b->x II = 17; d.barO; 1 int v = b->x; 1 1 W w Figure 2: (a) Example program. (b) \nSubobject graph for the class hierarchy of the program. (c) Slice of the example program w.r.t. the final \nvalue of v; constructs irrelevant to the final value of v have been omitted and replaced by boxes. (d) \nSubobject graph for the class hierarchy of the slice. in the resolution process. In this case, the run-time \ntype of the this pointer in C : : bar ( ) is D, because C : : bar ( ) is called for an object of type \nD in proce- dure main ( ) . From class D, two f oo ( ) methods are visible: s : : f oo ( ) and B: : f \noo ( ) , where the latter dominates the former. Therefore, B : : f oo ( ) is se-lected. Consequently, \nthe program computes the value 18 for variable v, and the value 7 1 for variable w. We are interested \nin determining the slice with respect to the final value of v in the main program. The value of v is \nequal to the value of data member x accessed via pointer b, which is the x in the [D, D.B+A] subobject. \nBy carefully examining the program we can observe that: 1. The statements C* c = &#38;d and c - >x = \n7 1 in procedure main that manipulate the x in subobject [D, DX.A] are irrelevant for v s final value. \n 2. Neither S : : bar0 norS : : f oo ( ) are called, so they are irrelevant to v s final value.  3 Although \ns : : f oo ( ) is not called, it cannot be eliminated, because the absence of a statically visible definition \nof f oo ( ) from the body of C : : bar ( ) would prevent B : : f oo ( ) from be-ing called. 4. The inheritance \nrelation between classes B and S, while locally superfluous, cannot be removed, since it affects the \ndominance relation between B: :foo() and~::foo(). (Notethatwhena virtual inheritance relation can be \nremoved safely, the representation of the base class can often be optimized by eliminating the need for \nan indirect access). 5. The instance variable x in subobject [D, DC.A] does not affect the final value \nof v. 6. The inheritance relationship between C and A is not needed for determining the final value \nof v.  Using the algorithm we present in Section 5, the slice shown in Figure 2(c) can be computed. \nThis example should make clear that there are a number of subtle issues that must be considered to ensure \nthat a class slice is correct, yet not unnecessarily conservative.  1.4 Use of Type Inference Algorithms \nOur algorithm for computing class slices assumes as a prerequisite the existence of a type inference \nalgorithm for C++. Such an algorithm is used to determine the set of potential run-time types of all \nreceiver expressions of the form e.f() or e + f(), where f() is a virtual function. By narrowing the \nrange of potential run-time types for expressions, more accurate class slices may be computed. In the \nabsence of a more sophisticated algorithm, the trivial algorithm which assumes that the receiver may \nhave any subtype of its static type can be used. Section 6.2 reviews type inference algorithms in greater \ndetail. 1.5 Scope of the Paper In this paper, we will view a class hierarchy somewhat abstractly, treating \nit as a collection of classes with in-heritance relations defined among them. Each class is then modeled \nas a simple collection of members. This view intentionally elides such issues as name scoping, access \nrights, and the genesis of the class definitions, e.g., whether they arise via preprocessing mechanisms \nsuch as templates and macros. By setting these is-sues aside, we are able to focus on the core technical \nproblems of class slicing. For many applications of class slicing, particularly space optimization, the \nab-stract view alone is sufficient. Slicing in the presence of preprocessing mechanisms is an important \nopen is-sue (both for statement and for class slicing), which we leave for future work. Most of the remaining \nissues not covered by our abstract model are only relevant when a compilable program must be computed \nfrom a slice; however, a smart compiler that could use the results of our slicing algorithm directly \nwould not need to address these problems.  2 Application to Program Optimiza-tion To enable reusability, \nobject oriented programming en-courages the use of classes that incorporate a high de- gree of functionality. \nWhile reusability is very desir-able, this approach has some drawbacks. Programs that class ListLink \n{ public: friend class List: ListLinkCint i); private: ListLink* .prev; ListLink* next; int -elan; \n3: class List ( public: ListO; void addHead(int i): void addTail(int i): int deleteHead0; int deleteTail0; \n private: ListLink* head; ListLink* -tail: 1: List::Listl): ~eadlO1. -tailCO){): ListLink::ListLink(int \ni) : -elan(i) , .PlFJlO), next(O){}; void List::addHead(int i)( ListLink* newLink = new ListLink( newlink->next \n= head; if (head) head-xprev = newlink; Ahead = newlink: if (!-tail) -tail = newlink; void List::addTail(int \nil{ ListLink* newLink = new ListLink( newlink->prev = -tail: if (-tail) -tail->next = newlink; -tail \n= newlink; if (!head) head = newlink; 1 int List::deleteHeadO{ int elem = head->-elem; if (-tail == \nhead) -tail = 0; ListLink* OldHead = -head: head = head->-next; delete oldHead; return e1em; It int \nList::deleteTailO( int elan = -tail-xelem; if (head == -tail) -head = 0: ListLInk* oldTail = -tail: -tail \n= -tail->-prev; delete oldTail; return e1em; 1 int main0 { List list: list.addHead(l7): list.addHead(l81; \nlist.deleteHeadO; int ) = list.deleteHeadO; return j; It class ListLink { public: friend class List: \nListLinkCint i); private: I I ListLink* next; int xlem; >: class List { public: ListO: head(O). \nm void addtleadlint ii: I I int deleteHead0: I I private: ListLink* head; >;- List::Listll: Ahead(O). \nI]{>: ListLink::ListLink(int i): -elem(i), 71 next(O){}; void List::addHeadlint i)( ListLink* newLink \n= new ListLink( newlink->anext = head; I I head = newlink; 3= r I I I I 0 int List::deleteHeadO{ \nint elem = head->.elem: I ' head = head-,next; I I return elan; 1 I 1 , int main0 { List list: list.addHead(l7): \nlist.addHeadil8): list.deleteHeadO; int j = list.deleteHeadO: return j; 1  Figure 3: (a) Example program. \n(b) Optimized program obtained by slicing with respect to the return expression of mainl).  183 use \nfeature-rich classes may pay a penalty for func-tions they do not use. The more obvious penalty is that \nof increased code size resulting from linking unused functions [28]. The less obvious penalty is that \nob-jects may contain unnecessary data members and sub- objects. Larger objects can not only increase \nthe space requirements of the program, but also decrease its exe- cution speed, due to the extra time \nrequired for object construction and destruction, and the effects of pag-ing and caching. These considerations \nforce the class designer to choose carefully between features (which enable reusability) and performance. \nOne solution to this quandary is to design the class with as many features as needed, relying on the \ncom-piler to optimize applications by specializing classes to the requirements of the program. Statement \nand class slicing together can perform such an optimization by eliminating not only dead code and dead \nfunctions (as some smart linkers are also capable of doing), but also unused data members and subobjects. \nFigure 3(a) illustrates this process using a program containing a class List. List defines doubly linked \nlists together with a number of associated operations; its auxiliary class ListLink represents a single \nlist element. Lis tLink consists of a data member -elem containing an integer value, and pointers -prev \nand -next, which refer to the object s predecessor and suc- cessor, respectively. The crux of the example \nis that the procedure main ( ) does not make use of the fact that the list is doubly linked. Figure 3(b) \nshows an optimized version of the pro- gram, where in addition to the dead code in methods addTail and \ndeleteTail, the -prev pointers in class ListLink have been removed. The program of Figure 3(b) can be \nobtained by first computing an in-terprocedural statement slice with respect to the return expression \nof procedure main ( 1, then determining the components of the class hierarchy that are needed by the \nstatements in the executable slice. The statement slice may be computed using a slightly enhanced ver-sion \nof the algorithm of Larsen and Harrold [20] (see Section 6.3 for further comments on statement slicing \nin C++). The example above does not illustrate the full power of slicing-based optimization, since the \nbenefits of the latter extend beyond the elimination of unnecessary data members. First, unused subobjects \nmay be eliminated. Second, the removal of virtual inheritance links can en- able further optimizations, \neven when subobjects cannot be eliminated. For instance, eliminating such a link from the dreaded diamond-shaped \ninheritance graph (created by virtual inheritance and multiple inheritance) breaks the diamond. Most \ncompilers can then generate more efficient code as a result. If one is interested only in eliminating \nunnecessary data members and not in these more involved optimiza-tions, it is possible to use techniques \nthat are simpler than the slicing algorithm presented in this paper. For instance, one could simply eliminate \ndata members not mentioned in the statement slice.  3 The Rossie-Friedman Framework We will begin by \nformalizing the notion of a class hierar- chy, the set of subobjects for a given class in a hierarchy, \nand the selection of class members. The definition of a slice that will be presented subsequently is \nexpressed in terms of these concepts. The formalization presented in this section is based on that of \nRossie and Friedman [26], although there are some differences. The main differences will be pointed out \nbelow. 3.1 Class Hierarchies and Subobjects Let C denote the set of class names, and let M denote the \nset of member names. We will assume that class names are unique, or that some naming scheme is used if \nthis is not the case. In addition, let Y denote the set { non-virtual , virtual }. A class hierarchy2 \ncan now be defined as follows: Definition 3.1 (class hierarchy) A class hierarchy y is a quadruple ((I?, \nAk, j, 3) where: 2The main difference between this notion, and Rossie and Fried- man s notion of a class \ncontext [26], is that our class hierarchies specify for each member whether it is virtual or not. Our \nclass hier- archies are also subject to additional constraints in order to disallow overriding of a virtual \nfunction by a nonvirtual function with the same name. (I) d C_ C, (2) Iii c c x M x V, (3) .Y? &#38; \n6 x fi, and(4) 9 C c x c such that: (i) 3 and p are irreJexive, (ii) 3, p = 0, (iii) the transitive \nclosure of (,!? Uk) is antisymmetric, (iv) if (X, m, fi) E 2 and (X, m, f2) E &#38; then fi = fi, and \n(v) tf(X, m, virtual ) E A2, (Y, m, f) E 2, and (Y, X) E (3 U @)* then f = virtual . Given a class hierarchy \ny, its components will be denoted by 6 (r), Q(y), g(y), and i (y), respectively. The reflexive and transitive \nclosure of (9 Up) will be denoted by i(y). Here, C denotes the subset of class names that are used in \nthis class hierarchy. A? is a function that maps every class in 6 to a subset of the set of member names, \nand specifies for every class member if it is virtual or non-virtual; the function is stated in relational \nform be- cause that will make it easier to specify operations on class hierarchies later. However, in \ncases where we are not interested in the virtuality of a member, we will often write m E ti(C) instead \nof (C, m, w) E &#38;f for some 21 . ,$ and j are relations indicating the pro- prietary (i.e., non-virtual) \nand the shared (i.e., virtual) inheritance relations between classes in C. Constraints (i)--(v) encode \nthe usual C++ constraints on inheritance relations that: (i) a class cannot be its own base class, (ii) \na class cannot be a non-virtual and a virtual base class at the same time, (iii) cycles in the inheritance \ngraph are not allowed, (iv) a member cannot be virtual and non-virtual at the same time, and (v) a virtual \nmember cannot be overridden by a non-virtual member with the same name. For practical reasons, we will \nassume class hierarchies to be finite. Example 3.2 For the example in Figure 2, the class hierarchy ye2 \nis given by: &#38;ez) A?f(y,,) = = {A, B, C, D, S > ( (A, x, non-virtual ), (S, foo, virtual ), (S, bar, \nnon-virtual ), (4 foe, virtual ), (C, bar, non-virtual ) } hz:> = { (B, S), (C, S) ) hez) = { (D, C), \n(D, B), (B, A), (C , A) ) I3 Rossie and Friedman use the term subobject not to refer to a part of an \nobject, but rather to denote what is in essence a refined notion of type derived from the combination \nof the static (declared) and run-time (as allocated) types of an object. Therefore, when we wish to refer \nto a part of an object, we will use the term subobject instance. Intuitively, a subobject identifies \nthe type (i.e., class) C of the full object instance in which a subobject in-stance is embedded as well \nas the type (class) D of the subobject instance itself. However, defining a subob- ject as a pair (C, \nD) would be insufficient, because a C object instance may contain more than one subcompo-nent of type \nD in the presence of multiple inheritance. We will identify a subobject by a pair [C, C1. . . . C,], \nwhere C denotes the type of the full object instance , andC1. .a. 47, is a sequence of class names encoding \nthe transitive inheritance relation between C1 to C,. There are two cases here: For non-shared subobject \ninstances we have that C1 = C, and for shared sub-object instances we have that C1 is the least derived \n(smallest) shared base class of C that contains the sub- object. This scheme is sufficient because shared \nbase classes are unique. In Definition 3.3 below, the set of subobjects of a class C in a hierarchy y \nis defined. We use cx to denote a possibly empty sequence of class names C1. . . . C,. Definition 3.3 \n(subobject) For a class hierarchy y, and a class C E 6 (r), the set of subobjects of C, denoted C(y) \nC), is inductively defined as follows: 2. [C, D] E C(y, C) ifthere exists an X such that (C, X) E f(r), \nand(X, 0) E $7) 3. v, c=-q E qy, C) q-p, a.X] E C(y, C) and (X, Y) E p(y). We will use C(y) to denote \nthe set containing all subobjects of all classes in y. Ournotion ofa subobject is equivalent to Rossie \nand Friedman s [26], although our notation and definition are different. Example 3.4 For the class hierarchy \nye+ of Exam-ple 3.2, it follows from Definition 3.3 that the set of subobjects of class D,C( ye=, D)consists \nof -i [D, D], [D, D-B], [D, D.C], [D, D.B-A], [D,S]}   [D, D-C-A], 0 Example 3.5 Consider the followingfragment \nof code with respect to the class hierarchy of Figure 2 and Ex- ample 3.2. PI D dl, d2; PI B *bl = &#38;dl; \n[31 B *b2 = &#38;d2; Using informal conventional terminology, one might say that dl and d2 in the above \nexample are (two different) objects of class D, while bl and b2 point to the B subobject of dl and d2 \nrespectively. In our terminology, we would say that dl and d2 are (two different) instances of the subobject \n[D, D], while bl and b2 point to (two different) instances ofthe subobject [D, D.B]. We will now define \nthe notions of a subobject s most derived class and a subobject s least derived class, respectively4. \nIntuitively, a subobject s most derived class is the class with respect to which references to vir- tual \nmethods are resolved. A subobject s least derived class is the class with respect to which references \nto data members, and references to non-virtual methods are re- solved. In a more operational view, the \nleast derived class of an object corresponds to the declared type of an object (i.e., the type as it \nappears in the object s de-claration), whereas the most derived class of an object corresponds to the \nrun-time type of the object. Definition 3.6 (most/least derived class) Let [C, a.X] E C(y). Then. mdc([C, \na.X]) Ai c Idc([C, CPX]) 25 x *These concepts are equivalent to Rossie and Friedman s nctual class and \neffective class, respectively. 3.2 Subobject Ordering and Member Lookup Though defined differently, Definition \n3.7 below is equivalent to Rossie and Friedman s partial ordering < on the subobjects in C(y , C). This \nordering mod- els the effect of hiding, as well as the dominance rule WI. Definition 3.7 (<) Let y be \na class hierarchy, C E C(y). Then:  K 4 <p,r [C, Q.-q [C, Q.-q <s,r [C, Y] if (X, y> E S(Y) Furthermore, \nlet cr be the union of <P,T and cS,-, , and let -<G be the transitive and reflexive closure of cr, Moreover, \nfor any C C C(y , C), let min, (C) denote the least element of C w.rt. $, when it exists, We will drop \nthe subscript y if the class hierarchy is obvious from the con text. Example 3.8 From DeJinition 3.7 \nit follows that we have thefollowingrelationships between the subobjects in C(Y,,, D) (see Example 3.4) \nof class hierarchy yer (see Example 3.2):  [D, D] < [D, D.B] [D, D] < [D, D*C] [D, D.B] < [D, D-B.A] \n[D,D.B] < [D, s] [D, D.C] < [D, D-GA] [D,DC] < [D, S] These relationships were rendered pictorially \nin Fig- ure 2(b). 0 We will now define VisibleDefs(y, CT, m), the set of all subobjects that have a member \nm that is visible in a subobject ~9. Definition 3.9 (VisibleDefi) Let y be a class hierarchy c E C(r), \n0 E q-y, C), and let m be a member name in M. Then the set of all subobjects of C that have a Rossie \nand Friedman do not define VisibleDefi, but have a similar notion, fam, which does not take hiding into \naccount. This does not make a difference for the purpose of defining member lookup, but VisibfeDefs will \nmm out to be essential for the slicing algorithm of Section 5. 186 member m that is visible in o is: \n-b> if m E Ak(Jdc(a)) I VisibJeDefs(y , 0, m) 4 U VisibJeDefgy , o , m) I O<O if m # Ib(Jdc(a))I Example \n3.10 The subobjects of class D in the class hi- erarchy ye+ ofExample 3.2 were shown in Example 3.4. \nFrom DeJnition 3.9, itfollows that VisibJeDefs(y,,, [D, D], bar) = { [D, S], [D, DC] > VisibJeDefs(y,,, \n[D, DX], f oo) = { [D, S] } WsibJeDefs(y,,, [D, D-B], x) = { [D, D-B-A] ) The key property of a class \nhierarchy slice that will be presented in Section 4 is preservation of member selection. Informally stated, \nthis means that a com-ponent of the class hierarchy is irrelevant so long as removing that component \ndoes not affect the selection of members (i.e., data members and virtual and non-virtual methods). In \nthis section, we will formalize the process of member selection. Using Definitions 3.7 and 3.9, we can \nnow formally define which subobject is selected for a static or dynamic access to a member m in a subobject \nO. The functions static-lookup and dynamic-lookup defined below use WsibJeDefs and the subobject ordering \nto determine which subobject contains the member that is accessed. Functions static-lookup and dynamic-lookup \nare both defined as a mapping from subobjects to subobjects. Definition 3.11 (static lookup and dynamic \nlookup) Let y be a class hierarchy, C E C(y), CT E C(y, C), and let m E M be the name of a member Then: \nstatic-Jookup(y , o , m) ?? min( VisibJeDefs(y , CT, m)) dynamic-Jookup(y , (I, m) k min( VisibJeDefs(y \n, [mdc(g), mdc(o)], m)) The lookup is undefined in cases where a minimum el-ement w.rt. 5 does not exist \nand this denotes that the reference is ambiguous. Definition 3.11 defines the selection of a subobject \ngiven a member m and a subobject 0. However, the question whether the lookup for m should be static or \na dynamic is encoded in the a component of the class hierarchy, and depends on m and the static class \nof subobject 0. In function lookup6 (Definition 3.12 be- low), a static lookup for member m is performed \nfirst. Then, the virtuality of m is determined, and a dynamic lookup is performed if m is found to be \nvirtual. This double lookup scheme is designed in such a way to simplify the subsequent definitions and \ndescriptions of algorithms; there are obviously more efficient ways of implementing lookups for virtual \nmembers. Definition 3.12 (lookup) Let y be a class hierarchy C E C(r), o E C(y, C), and let m E M be \nthe name of a member. Let g. = static-Jookup(y, 0, m), and let (Jdc(a ), m, v) E 2(y). Then: 0 if 2, \n= non-virtual Jookup(y , B, m) e dynamic-Jookup(y , or, m) ifv = virtual i Example 3.13 From Example \n3.2 and Definition 3.12, we can obtain the following for the call to bar ( ) in procedure main ( 1 of \nthe program of Figure 2. static-Jookup(y,,, [D, D], bar) = min(VisibJeDefs(y,,, [D, D], bar)) = min({ \n[D, Sl, ID, D-Cl >)= [D, D.Cl Because of(C, bar, non-virtual ) E A?(y,+) we have that Jookup(y,,, [D, \nD], bar) = static-Jookup(y,,, [D, D], bar) = [D, D.Cl 6 static-lookup and dynamic-lookupare equivalent \nto Rossie and Friedman s stat and dyn, though defined differently. In [26], Rossie and Friedman do not \naddress the problemof determiningwhether a lookup should be static or dynamic. In particular, they do \nnot define a function lookup similar to Definition 3.12 below. For the call to f oo ( 1 in C : : bar \n( 1 we have the fol- lowing: static-~ookup(y,,, [D, D-C], foe)= min( KsibleDefs(y, [D, DX], foo)) = Since \nwe have that (S, foo, virtual ) E ti(rez) we have that Ioo~IJ~~~~, [D, D-C], foo) = dynamic-lookup(y,,, \n[D, D-C], foe)= min( WsibleDefs(7, [D, D], foo)) = min({ [D, Sl, [D, WI> = 1% D.B]  4 Class Hierarchy \nSlices 4.1 Objective We may view a C++ program as a pair (7, S), where 7 is the declarative part, i.e., \na class hierarchy and S is the non-declarative, or executable, part. Previous work on slicing can be \nadapted to compute slices of the executable part of a C++ program (see Section 6.3): that is, given a \nprogram (7, S) and a slicing criterion, one can compute a statement slice (7, S ) which has the same \nexecution behavior as the original program with respect to the criterion. The goal of this work is to \ncompute class hierarchy slices: given a program (7, S ) (which may be, but is not necessarily, the output \nof a statement slicing algo- rithm), we would like to compute a slice (y , S ) that has the same execution \nbehavior as (7, S ), where 7 is a subhierarchy (see Definition 4.3 below) of 7. In particular, we would \nlike 7 to consist only of the parts of 7 that are necessary to ensure that C(7 ) includes all subobjects \nthat may be instantiated during execution of S , and that &#38;?(y ) includes all members that may be \nused during the execution of the S . However, we also need to ensure that replacing 7 by 7 does not change \nthe execution behavior of S . The primary component of the program execution behavior that depends on \nthe class hierarchy is the member lookup operation. Hence, the class hierarchy slice should preserve \nthe result of any member lookup that may be performed during the execution of the S . We formalize these \nrequirements below. Definition 4.1 (subobject instantiation) A subobject u is said to be instantiated \nduring program execution when a pointer or reference to an instance of u is gen- era ted. Example 4.2 \nConsider the code in Example 3.5. Line [I] instantiates the subobject [D, D], while lines [2] and [3] \ninstantiate the subobject [D, D-B]. Further the subobject [D, DC] is not instantiated by this code fragment \n(even though the [D, D] subobject instances created in line [I] contain instances of [D, D&#38;J). Definition \n4.3 (subhierarchy) Let 7 and 7 be class hierarchies. Then 7 is a-subhierarchy of y (7 *C7) iJJ (i) C(7 \n) C C(r). (ii) M(7 ) C M(7), (iii) B(7 ) C P(y), and (iv) S(7 ) C S(7). Example 4.4 Let 7:, be a class \nhierarchy, where. C(r:,) = {A, B, C, D, S) Q(7:,) = { (A, x, non-virtual ), (S, f 00, virtual ), (B, \nfoo, virtual ), (C, bar, non-virtual ) } S(Y:,) = { (4 S), (C, S> 1 &#38;r:,) = -t (D> C>> (D, B), (B, \nA) ) Then from DeJinition 4.3 it follows that 7:, is a sub- hierarchy of the class hierarchy 7ez that \nwas dejned in Example 3.2. 0 Definition 4.5 (class hierarchy slice) Let (7, S ) be a program. A subhierarchy \n7 of 7 is said to be a class hierarchy slice of (7, S ) if 1. C(7 ) includes every subobject o that may \nbe in- stantiated during execution of S . 2. y preserves the lookup of any member m in any subobject \nu that may be performed during execu-tion of S : that is,  lookup(y , u, m) = lookup(y , u, m) 4.2 Member \nLookup Slices We now introduce some terminology and notation that will be useful in presenting our algorithm. \nWe define a member lookup slicing criterion to be a pair (a, m) where m is the name of a member, and \no the subobject associated with the receiver expression e with respect to which m is referenced or called. \nDefinition 4.6 (member lookup slicing criterion) For a given class hierarchy 7, a member lookup slicing \ncriterion is defined as a pair (o, m), where CT E C(7) and m E A?(y). We define a union operator on class \nhierarchies as below. (Note that this operator is only defined on hierarchies that have a common superhierarchy.) \nDefinition 4.7 (U) Let 7 = (6 (7 ), &#38;(y ), 3(7 ), i (7 )) and 7 = (C?(7 ), 2(7 ), 9(7 ), p(7 )) be \nsubhierarchies of a class hierarchy 7. Then: y'uy\" g ( d(7')@7\"), ti(y')Uti(y\"), S(y')U3(7'~), P(7')UP(7\") \n) Our basic approach is to identify the subhierarchies of 7 that are necessary to satisfy various criteria \nand to take their union, In particular, we satisfy condition (2) of Definition 4.5 by identifying the \nset of all member lookups (0, m) that may be performed, and by comput- ing a slice of 7 for each lookup, \nand by taking the union of all these slices. What should a slice with respect to member lookup (a, m) \nbe? Let 7 and 7 be class hierarchies such that 7 C_y and o E C (7 ). Let us call 7 a weak slice of 7 \nwith respect to the member lookup criterion (a, m) if Jookup(y , u, m) = Jookup(7, o, m) Although a weak \nslice S with respect to a criterion C captures the essential property of preserving lookup behavior fo,r \na criterion C, it is not very useful because it lacks a desirable compositional property: If S1 and Sz \nare weak slices with respect to criteria C1 and Ca, respectively, then SIU Sz is not necessarily a weak \nslice with respect to criterion Cr (or C,). This can be seen from the example of Figure 4. This leads \nto the follow- ing definition. Definition 4.8 (slice) Let 7 and 7 be class hierarchies such that 7 57. \n7 is said to be a member lookup slice of 7 with respect to criterion (a, m) iffor all 7 such that y C7 \n27 and u E X(7 ) we have that Jookup(y , o, m) = Jookup(7, a, m) We may define the concepts of a static \nlookup slice and dynamic lookup slice analogously by replacing lookup in the above definition by static-lookup \nor dynamic-lookup respectively. Example 4.9 We will study the member references d . bar ( ) and this \n->f oo ( ) in the program and slice of Figure 2. The hierarchies yer and 7:, for the program and the \nslice were shown in Examples 3.2 and 4.4, respectively. For call d. bar ( 1, we assume that subobject \no = [D, D] E C(7em D) is associated with expression d. Since we have that Jookup(y,,, [D, D], bar) = \nJookup(y&#38;, [D, D], bar) = [D, D.C] is a weak slice of ye+ with respect to criterion 7:z ([D, 4, bar). \nFor call this - > foo ( 1, suppose that subobject [D, D-C] E C(Y,,, D) is associated with expression \nthis. Since we have that Jookup(y,,, [D, DX], f oo) = Jookup(y:, , [D, DX], f oo) = [D, J-1 is a weak \nslice of ye. with respect to criterion rhz ([D, DC], foo). The reader may vertjy that 7&#38; is also \na slice w.rt. each of the criteria mentioned above. 0 The following lemma states that the slices of Defini- \ntion 4.8 may be composed with the union operation of Definition 4.7. This property is very important \nbecause it implies that a slicing algorithm can compute member lookup slices element-wise, and safely \ncompute their union without affecting the result of any of the lookups. As the example of Figure 4 shows, \nthere is no analogue of this theorem for weak slices. class A { public: int y; 3; class B : public \nvirtual A { public: int y; 3: class C : public virtual A { public: int x; 3; class D : public B, public \nC { 3; void mainO{ D d: d.y = 17: d.x = 18; c c; c.y = 19; 3 (4 class A { public: int y; B 3; \nY class B 0 D -I( public: int y; % 3; Sl C class C : X public virtual A ( public: D int x; (b) \n A 3; 8 class D : public B, public C { 3; void mainO{ D d; d.y = 17; d.x = 18; c c; c.y = 19; 1 \n Cd) (d 69 Figure 4: (a) Example program. (b) Pictorial view of the class hierarchy of (a). (c) Pictorial \nview of three weak slices Sr, Sa, and Sa w.r.t. criteria ([D, D], y), ([D, D], z), and ([C, C], y}. (d) \nPictorial view of the union SlUS2~S, of the weak slices of (c). (e) Program corresponding to the (d). \nObserve that the member-selection expression d . y is ambiguous. This implies that lookup-behavior is \nnot preserved, and therefore that &#38;US~U&#38; is not a weak slice w.r.t. ([D, D], y). PI-OOJ:Follows \ndirectly from Definition 4.8. a 5 Computing Class Hierarchy Slices 5.1 The Algorithm In Section 4 we \npresented a formal definition of what constitutes a slice. In this section we present an algo- rithm \nfor slicing a class hierarchy (see Figure 5). The algorithm is defined as a function Slice that takes \na pro- gram P as an argument and returns a class hierarchy slice of P. The first step in computing the \nclass hierarchy slice is to identify all subobjects that may be instantiated during the execution of \nthe statement slice. Objects may be created in a C++ program through the use of various program constructs \nsuch as the new operator (e.g., new X ) and variable definitions (e.g., X 2; ). By scanning P for all \nobject creation constructs7, we identify the set of all full objects (sub- objects of the form [X, X]) \nthat may be instantiated during the execution of P, and add the corresponding class X to the slice. (See \nlines [4] through [7].) However, this is not enough. We also need to identify references (or pointers) \nto partial subobjects (sub-objects of the form [X, a.Y], where Y # X) that may be created. Such references \nare usually created through a sequence of (implicit or explicit) typecasts starting from a full object. \nHence, we scan P for all typecast expressions and add an appropriate part of the class hierarchy to the \nslice. (See lines [8] to [lo].) In particular, for a typecast from a class F to a class T we add SubHierCJass(F, \nT) to the slice, where SubHierCJass( F, T), defined below, denotes the part of the class hierarchy that \nlies between the two classes F and T. 7C++ programs usually have a number of implicit constructs: constructs \nthat are generated by the compiler if the programmer omits them. For instance, a constmctor for a class \nmay contain implicit instantiations of all its data members. The algorithm needs to take care of these \nimplicit constructs as well. Definition 5.1 (SubHierCJass) Lemma 4.10 Let y be a class hierarchy, let \ny1 be a slice of y w.v.t. criterion S1, and let y2 be a slice of y wx t. criterion S2. Then (+yI~7~) \nis a slice wxt. S1, and (+yI uy2) is slice w.r.t. criterion S2. SubHierCJas%(F,T) A ( C, 8, g(y) n (C \nx C), p(y) n (C x C) ) whe re C = { X ( (F, X) E i(y) and (X, 7 ) E f(r) } We now turn our attention \nto member lookups. The next step in the algorithm requires a type inference al-gorithm to identify for \nevery member lookup operation e.m or e -+ m in P the set of possible run-time types for e, which we denote \nby PotentiaJRunTimeTypes(e) (line [13]). (The algorithm requires the run-time type information only for \nlookups of virtual members. For the sake of simplicity, we ignore this possible refine-ment.) Once this \ninformation is available, the set of relevant member-lookup slicing criteria is easily deter-mined. The \nset of possible run-time types of e and the static type of e are used to determine the set SubObjSet \nof possible subobjects that e may denote at this pro-gram point. (This is the information computed by \nFunc- tion CorrespondingSubobjectsin lines [20]-[26].) Each (T E SubObjSet identifies a member-lookup \nslicing cri-terion (cr, m). Once the set of member-lookup slicing criteria that are relevant have been \nidentified, the algorithm simply computes member lookup slices with respect to each of these individual \ncriteria and adds them all to the slice being computed. The computation of member lookup slices uses \na function SubHier, defined below, that given any two subobjects cl and g2 identifies the part of the \noriginal class hierarchy that lies between these two subobjects. (Note that SubHier,(al, g2) 5 SubHierCJass,(Jdc(aI), \nJdc(a2)). We could use SubHierCJass,(Jdc(a&#38; Jdc(o,)) in place of SubHier, ( ol, 02) when computing \nmember lookup slices, but that would lead to larger slices in some cases.) Definition 5.2 (SubHier) SubHier, \n(gl, 02) 4 (C, 0, S, P) where R = { (T 1 015*05*c72 } C = { Jdc(a) 1 0 E R } S = { (Jdc(o), Jdc(a )) \n1 u,o E R, o<,u > P = { (Jdc(a), Jdc(c9)) 1 0,~ E R, g<&#38; } HI function SJice(Program P) : hierarchy; \nPI let y be the class hierarchy of P; [31 instantiatedclasses = 0; [41 for each (implicit or explicit) \nobject creation construct e in P do [51 instantiatedclasses = instantiatedClasses U { class instantiated \nby e } ; PI end for c71 Yslice = (instantiatedClasses, 0, 0, 0) PI for each (implicit or explicit) typecast \nexpression (T *) e or (T &#38;) e or (T) e in P do r91 7slice = -ysriee U SubHierCJass,(StaticType(e), \n2 ); [lOI end for [Ill call ComputePotentiaJRunTimeTypes(P); [121 for each (implicit or explicit) expression \ne.m ore + m in P do [I31 SubObjSet = CorrespondingSubobjects(y, PotentiaJRunTimeTypes(e), StaticType(e \nP41 for each u in SubObjSet do [I51 Yslice = yslice U MemberLookupSJice(y, C, m); end for [I71 end for \n1161 [I81 return huh; [I91 end;  PO1 function CorrespondingSubobjects(hierarchy7; Typeset T; Class X): \nSubObjectSet; Pll SubObjSet = 0; FQI for each class C E T do 1231 SubObjSet = SubObjSet U { c 1 u E C(y, \nC) and Jdc(a) = X }; [241 end for ~251 return SubObjSet; P61 end; v71 function MemberLookupSJice (hierarchy \ny; Subobject a; member m): hierarchy; WI u = static-Jookup(y, CT, m); [291 staticLookupSJice= (0, li?(r, \nJdc(a ), m), 0, 0) [301 U SubHier, (a, a ) [311 U (IJ { SubHitr7(u , a ) ( u E VisibJeDefs(y, u, m) }); \n~321 if (Jdc(u ), m, virtual ) E M(y) then /* virtual member lookup */ I331 u = dynamic-Joohdy, u, m); \n[341 dynamicLookupSJice = (0, M(y, IdHa ), m), 0, 0) [351 U SubHier, ([mdc(u), mdc(u)], a ) [361 U (U \n{ SubHier, (u , u ) 1 u E VisibJeDefs(y, [mdc(u), mdc(u)], m) }); [371 JooJcupSJice = StaticLookupSJice \nU dynamicLookupSJice; [381 else [391 JookupSJice = StaticLookupSJice; [401 end if [411 return JookupSlice; \n~421 end;  Figure 5: Algorithm for slicing class hierarchies. Let us now consider how the slice is computed \nfor a lookup of a non-virtual member m in a subobject c. (See lines [28H3 11.) Assume that the lookup \nreturns a subobject u of least derived class C. The slice consists of several components. The first component \n(line [29]) ensures that the class C has the member m; for conve-nience we use M(y , C, m) to denote \nthe singleton set { (C, m, v) ) C ii?(y), for some v E V. The second component (line [30]) ensures that \nCT will be a subobject of c in the new hierarchy and, hence, that the member m of C+ will be visible \nin g. The third component (line [31]) adds enough of the hierarchy to ensure that the member m in c dominates \nany other member m that may be visible in 0. (This component is not necessary for a weak slice, but is \nessential for a slice.) While the above components are all that are required in the case of a lookup \nfor a non-virtual member, the lookup for a virtual member requires more parts of the class hierarchy \nto be added to the slice. The components added in lines [34)-[36] are analogous to the compo- nents added \nin lines [29)$31] (except that they apply to the full object containing a). Remark: The functions SubHierClass \nand SubHier, as defined above, return all of the class hierarchy that lies between the specified classes \nor subobjects. For example, if D derives from a virtual base B in mul- tiple ways, then SnbHierCIass(D, \nB) will include all the inheritance paths between D and B. In actuality, it would suffice if one of the \ninheritance paths be-tween D and B was included in the slice. We choose to include all paths, rather \nthan choose some path non- deterministically . (Ideally, it might be preferable for the slice to just \nrecord that D is required to inherit from B in some fashion. It would, however, be diffi- cult to project \nsuch slices onto the source program for display purposes.) 5.2 Correctness of the Algorithm We now establish \nthe correctness of our algorithm. We need to show that the hierarchy ysliee returned by Func- tion Slice \nsatisfies the two conditions in Definition 4.5. Consider condition (1). Let us denote the re-sult of \ntypecasting a subobject 0 to a class X by Ovcast(7,c X). Lemma 5.3 For every subobject u instantiatedduring \nthe execution of P, there exists a sequence of subob- jects [D, D] = oo, ol, ---, uk = u, where D is \na Class instantiated in P, andfor every i > 0, oi is obtained (during execution of P) from uiWI through \na typecast (that is, ui = typecast(7, ui- 1, Xi)) or lookup (that is, ui = lookup(y , u~-~, mi)). ProoJ: \nStraightforward. . Lemma 5.4 Let ul$uz. Then, for all y 7SubHier,(uI,aa) ifuI E C(y ) then u2 E II and \nul_<;,u2. Proof: Straightforward. . Lemma 5.5 1. Let u2 = static-lookup(y , ul, m). For all ~ JSubHier,(al, \nu2), if al E C(y ) then u2 E E(7 ). 2. Let u2 = dynamic-lookup(y , ul, m). For all 7 2 SubHier,( [mdc(d, \nmdc(ud], u2), if u1 E C(y ) then e2 E C(y ). 3. Let u2 = W=47, ~1, T). For all y 7SubHierCIass, (Idc(ur), \nIdc(u2)), if u1 E C(y ) then u2 E II(  Proo$ Follows from Lemma 5.4. (For the third part of the lemma, \nnote that SubHierClass, (Idc(u,), fdc(u2)) 1 SubHier,(uI, u2).) . It follows from Lemma 5.3 and Lemma \n5.5 that yslice satisfies condition (1) of Definition 4.5. Consider condition (2) of Definition 4.5. \nLet us de-note the value of the variable IookupSIice in a specific invocation of the function MemberLookupSfice(y \n, CT, m) by lookupSbce(y ,u,m). staticlookupSlice(y,u,m) and dynamiclookupSlice(y,u,m) are defined similarly. \nLemma 5.6 staticLookupSJice(y, CT, m) is a static-lookup slice of y with respect to (u, m). Proo$ Consider \nany 7 such that r &#38;r, 7 7staticLookupSlice(7, u, m), and CT E x(7 ). We need to show that static-lookup(y \n, a, m) = static-lookup(y, a, m). Let g denote static-lookup(y , a, m). First, we show that cr E KsibJeDefs(y \n, a, m). Ob- serve that 0 E C(y ) and a$,~ . (This follows from Lemma 5.4 since g E C(y ) and y lSubHier,(a, \na ).) This implies that there is a path ~~~~~~ . . .~~.+g in the subobject graph of y . Clearly, m @ \nj$r>( JWd) for any i, since otherwise we would not have u = static-Jookup(y , a, m). Since r Er, m # \nA.?(r )(ld~(a~)) either. It follows that (T must be in WsibleDefs(y , a, m) We now need to show that \ng is the least el- ement of VisibleDefs(y , o, m). Let 0 be some element in NsibleDef$y , a, m). This \nimplies that there is some path O+ul ...ak-l<,,ak = 0 in the subobject graph of y . Let i be the minimum \nvalue such that m E i $(r)(Idc(ai)). Then, ai E WsibleDefs(y , a, m), By construc- tion, staticLookupSlice(y \n, a, m) 2 SubHier, (CT , ai). Hence, y aSubHier,(a , a;). Lemma 5.4 implies that a $, ai. Hence, a $, \na , from the transitivity of $, . cl Lemma 5.7 dynamicLookupSlice(y , CT, m) is a dynamic-lookup slice \nof y with respect to (CT, m). Proof: This follows just like Lemma 5.6. 0 Lemma 5.8 iookupSlice( y , CT, \nm) is a member lookup slice of y with respect to (a, m). Proo$ Follows from Lemma 5.6 and Lemma 5.7. \n0 It follows from Lemma 5.8 and Lemma 4.10 that YsIiee satisfies condition (2) of Definition 4.5 also. \nHence, we have the following theorem. Theorem 5.9 Function Slice computes a class hierar- chy slice of \nP. 6 Related Work 6.1 Elimination of Class Components The work that is most closely related to ours is \nthat by Agesen and Ungar [4,3], who describe an approach for application extraction for the dynamically \ntyped object oriented language Self. Agesen and Ungar s objective is similar to ours: the elimination \nof unused parts of objects while preserving program behavior. It is in- teresting to observe that, whereas \nfor statically typed object-oriented languages eliminating such redundan- cies is a useful optimization, \nfor Self it is almost essen- tial: Due to the absence of declarations, it is unclear a priori what code \nis used by an application and, hence, even a small application requires the incorporation of the entire \nrun-time environment unless countermeasures are taken. Comparing the application extraction algo- rithm \nof [4] with our class hierarchy slicing algorithm is difficult because of the different languages under \ncon- sideration, and the differences in presentation of the algorithms, but a few similarities are evident: \n. Both algorithms rely on a type inference algorithm to determine the potential targets of method calls \n(message sends in Self). For C++, due to the static nature of class hierarchies, there is the possibility \nof using efficient algorithms that only use class hierarchy information (see Section 6.2). For Self, \nthis option is not available. . Both algorithms essentially determine a separate slice for each lookup/send, \nand the slice with re-spect to a program consists of the union of these single-point slices, In his \nPhD thesis [3], Agesen discusses related work on application extraction for dynamically typed object- \noriented languages. To our knowledge, the problem of eliminating dead declarative code in C++ programs \nhas not been studied. For statically typed object-oriented languages such as C++, the focus has thus \nfar been on eliminating dead executable code, and we are unaware of any approaches that go much beyond \ncall graph analysis [28] and vir- tual call elimination [7]. As Srivastava s study [28] in- dicates, \nobject-oriented programs are likely to contain more dead code than programs written in procedural lan-guages. \nAgesen [3] remarks that as the current trend towards the use of frameworks in the development of applications \ncontinues, the amount of dead code will likely increase further. We believe that this applies to executable \nas well as declarative code. 6.2 Type Inference The class hierarchy slicing algorithm of Section 5 re- \nquires a set of potential run-time types for each expres- sion that is involved in a member access. A \nnumber of different approaches for type inference have been discussed in the literature. In the context \nof C++, much work has been done re-cently on type inference for the sake of virtual method call elimination. \nThe objective of virtual call elimina- tion is to identify calls to virtual functions from receiver expressions \nthat can only have a single run-time type; such calls can be replaced by direct function calls. Be-sides \nthe fact that a direct call can be implemented more efficiently, they can also be inlined, which enables \nvar-ious intraprocedural optimizations that cannot be per- formed across function boundaries. Although \nC++ type inference algorithms are often designed primarily to de- termine whether the run-time type of \na receiver expres-sion is unique or not, extension of these algorithms to compute a set of potential \nrun-time types instead seems straightforward in most cases. C++ type inference al-gorithms fall into \ntwo broad categories: algorithms that only use signature information or class hierarchy infor-mation \n[lo, 16, 28, 8, 7, 131 and more sophisticated algorithms that are based on alias analysis [23, 111. Al- \nthough the latter category theoretically offers the most precise results, it is unclear how much better \nthese re-sults are than those of algorithms in the former category in practice [7]. In addition to the \nC++ type inference algorithms de-scribed above, several constraint-based type inference algorithms for \nobject-oriented languages have been pre- sented in the literature. Constraint-based type inference methods \ncompute type information by determining the solution of a constraint network where the nodes corre-spond \nto type variables, and where the edges represent constraints between type variables [22, 2, 241. 6.3 \nStatement Slicing for C++ Although class slicing in abstract form simply special-izes a class hierarchy \nwith respect to a target program, several applications also require a statement slicing al-gorithm. Krishnaswamy \n[19] and Larsen and Harrold [20] have addressed statement slicing in C++. Krishnaswamy s algorithm [ \n191, which is based on an algorithm for the C language by Livadas and Croll [2 11, has insufficient detail \nfor us to confidently evaluate its accuracy or correctness, although it appears to outline a slicing \nalgorithm based on interprocedural dataflow analysis in a procedure call graph derived from a set of \nmethods. Later work on slicing in C++ by Larsen and Har-rold [20], based on work on interprocedural slicing \nby Horwitz, et al. [18] and Reps et al. [25], contains considerably more detail. The most significant \ncon-tributions of Larsen and Harrold s work, in our view, are the idea of treating all instances of method \ndata as global variables (i.e., s tat i c members in C++), and the introduction of a special node in \ntheir dependence graph representation to account for the dynamic binding implicit in virtual function \ncalls. However, this work does not explicitly address a number of common constructs in C++; e.g., object \nref- erence via the this pointer, direct access to member data of objects (only access via member functions \nis dis- cussed), and calls to methods on objects that are method arguments or member data. The latter \ntwo omissions prevent the Larsen/Harroldalgorithm from being imme- diately applicable to the example \nof Figure 3, although it is not difficult to apply some simple patches to their algorithm sufficient \nto yield the slice in the example. Despite the limitations of existing C++ slicing algo- rithms, considerable \nprogress has been made in devel- oping slicing techniques that address problematic con- structs in other \nlanguages, e.g., unstructured control flow [5, 12, 91, composite datatypes [6], and pointers [6,15,17]. \nWe believe that many of these techniques are applicable to C++ as well, and algorithms for statement \nslicing in C++ are likely to improve over time. 7 Conclusions and Future Work We have defined a semantically \nwell-founded notion of a slice of a class hierarchy. This notion of a slice is defined using an adaptation \nof Rossie and Friedman s algebraic semantics for subobject selection [26]. In addition, we have presented \nan algorithm for comput- ing class hierarchy slices. This algorithm relies on the availability of run-time \ntype information for receiver expressions of virtual calls, but any suitable type infer- ence method \ncan be used to compute this information, allowing for a variety of cost/accuracy tradeoffs. Our class \nhierarchy slicing algorithm has two princi- pal applications when used in conjunction with a state- ment \nslicing algorithm. First, it enhances the utility of statement slicing in traditional slicing application \nsuch as debugging and program understanding. Second, the combination of the two algorithms may be used \nto opti- mize an object-oriented program by reducing its space requirements. For future work, we would \nlike to extend the frame- work presented in this paper to other declarative aspects of C++ not treated \nhere, such as static class members, pointers to members, and typedef constructs. In ad- dition, slicing \nin the presence of preprocessing mecha-nisms such as templates or macros remains a difficult open problem. \nFinally, we wish to investigate how to compute slices that are not necessarily projections of the source \ncode, e.g., by allowing transitive inheritance relations to be replaced by direct inheritance relations. \nAcknowledgements We thank Jon Rossie for several helpf% discussions about the subobject model of [26]. \nReferences [l] ACCREDITED STANDARDS COMMITTEE X3, I. P. S. Working paper for draft proposed international \nstan-dard for information systems-programming language C++. Draft of 26 September 1995. [2] AGESEN, 0. \nConstraint-based type inference and para- metric polymorphism. Proceedings OftheFirstInterna- tional \nStatic Analysis Symposium (SAS 94) (September 1994), 78-100. Springer-Verlag LNCS vol. 864. [3] AGESEN, \n0. Concrete Type Inference: Delivering Object-Oriented Applications. PhD thesis, Stanford University, \nDecember 1995. Appeared as Sun Mi- crosystems Laboratories Technical Report SMLI TR- 96-52. [4] AGESEN, \nO., AND UNGAR, D. Sifting out the gold: Delivering compact applications from an ex-ploratory object-oriented \nprogramming environment. 196 In Proceedings of the Ninth Annual Conference on Object-Oriented Programming \nSystems, Languages, and Applications (OOPSLA 94) (Portland, OR, 1994), pp. 355-370. SIGPLANNotices 29(10). \n[5] AGRAWAL,H. On slicing programs with jump state-ments. In Proceedings of the ACMSIGPLAN 94 Con-ference \non Programming Language Design and Im- plementation (Orlando, Florida, 1994), pp. 302-3 12. SIGPLAN Notices \n29(6). [6] AGRAWAL,H., DEMILLO, R., AND SPAFFORD, E. Dy- namic slicing in the presence of unconstrained \npoint-ers. In Proceedings of the ACM Fourth Symposium on Testing, Analysis, and Ver$cation (TAV4) (1991), \npp. 60-73. Also Purdue University technical report SERC-TR-93-P. [7] BACON, D. F., AND SWEENEY, P. F. \nFast static analysis of C++ virtual function calls. In this proceedings. [8] BACON, D. F., WEGMAN, M., \nAND ZADECK, F. K. Rapid type inference for C++. Tech. Rep. RC 1234, IBM Thomas J. Watson Research Center, \n1995. [9] BALL, T., AND HORWLTZ, S. Slicing programs with arbitrary control-flow. In Proceedings of the \nFirst In- ternational Workshop on Automated and Algorithmic Debugging (1993), P Fritzson, Ed., vol. 749 \nof Lecture Notes in Computer Science, Springer-Verlag, pp. 206- 222. [lo] CALDER, B., AND GRUNWALD, \nD. Reducing indirect function call overhead in C++ programs. Conference Record of the Twenty-First ACMSymposium \non Princi- ples ofprogramming Languages (January 1994), 397- 408. [l l] CARINI, P. R., HIND, M., AND \nSRINIVASAN, H. Flow-sensitive type analysis for C++. Tech. Rep. RC 20267, IBM T.J. Watson Research Center, \n1995. [12] CHOI, J.-D., AND FERRANTE, J. Static slicing in the presence of goto statements. ACM Transactions \non Pro- gramming Languages and Systems 16, 4 (July 1994), 1097-l 113. [ 131 DEAN, J., AND CHAMBERS, C. \nOptimization of object- oriented programs using static class hierarchy analysis. Tech. Rep. 94-12-O 1, \nDepartment of Computer Science, University of Washington at Seattle, December 1994. [14] ELLIS, M. A., \nAND STROUSTRUP, B. The Annotated C++ Reference Manual. Addison-Wesley, 1990. [ 151 ERNST, M. Practical \nfine-grained static slicing of op- timized code. Tech. Rep. MSR-TR-94- 14, Microsoft Research, Redmond, \nWA, 1994. II161FERNANDEZ,M. F. Simple and effective link-time op- (Austin, TX, 1995), pp. 187-199. SIGPLAN \nNotices timization of modula-3 programs. Proceedings of the ACM SIGPLAN 95 Conference on Programming \nLan- guage Design and Implementation (June 1995), 103- 115. FIELD, J., RAMALINGAM, G., AND TIP, F. Parametric \nprogram slicing. In Conference Record of the Twenty- Second ACM Symposium on Principles of Program- ming \nLanguages (San Francisco, CA, 1995), pp. 379- P71 392. VI HORWITZ,S., REPS, T., AND BINKLEY, D. Interproce-dural \nslicing using dependence graphs. ACM Transac- tions on Programming Languages and Systems 12, 1 (1990), \n26-61. WI KRISHNASWAMY, A. Program slicing: An application of object-oriented program dependency graphs. \nTechnical report TR94- 108, Dept. of Computer Science, Clemson University, 1994. PO1 LARSEN, L., AND \nHARROLD, M. J. Slicing object- oriented software. In Proceedings of the 1996 Interna- tional Conference \non Software Engineering (ICSE-18) (Berlin, March 1996). PII LIVADAS,P. E., AND CROLL,S. Program slicing. \nReport serc-tr-61-c Computer Sciences Department, Univer-sity of Florida, 1992. WI PALSBERG, J., AND \nSCHWARTZBACH, M. I. Object-oriented type inference. Proceedings of the ACM 1991 Conference on Object-OrientedProgramming \nSystems, Languages, and Applications (OOPSLA 91) (October 1991), 146-161. ACM SIGPLAN Notices 26(11). \n[231 PANDE,H. D., AND RYDER, B. G. Static type determi- nation and aliasing for C++. Report LCSR-TR-250-A, \nRutgers University, October 1995. ~241 PLEVYAK, J., AND CHIEN, A. A. Precise concrete type inference \nfor object-oriented languages. Proceed-ings of the ACM 1994 Conference on Object-Oriented Programming \nSystems, Languages, and Applications (OOPSLA 94) (October 1994), 324-340. ACM SIG- PLAN Notices 29( IO). \n[251 REPS, T., HORWITZ, S., SAGIV, M., AND ROSAY, G. Speeding up slicing. In Proceedings of the Second \nACM SIGSOFT Conference on Foundations of Soft- ware Engineering (New Orleans, LA, December 1994), pp. \n1 I-20. 1261 ROSSIE, J. G., AND FRIEDMAN, D. P. An algebraic semantics of subobjects. In Proceedings \nof the Tenth Annual Conference on Object-Oriented Programming Systems, Languages, and Applications (OOPSLA \n95) 30(10). v71 SAKKINEN,M. A critique of the inheritance principles of C++. ComputingSystems 5, 1 (1992), \n69-110. P81 SRIVASTAVA, A. Unreachable procedures in object ori- ented programming. ACM Letters on Programming \nLanguages and Systems 1, 4 (December 1992), 355- 364. r291 TIP, F. A survey ofprogram slicing techniques. \nJournal ofProgramming Languages 3,3 (1995), 12 l-l 89. [301 WEISER, M. Program slices: formal, psychological, \nand practical investigations of an automatic program abstraction method. PhD thesis, University of Michi- \ngan, Ann Arbor, 1979.  \n\t\t\t", "proc_id": "236337", "abstract": "This paper describes an algorithm for <i>slicing</i> class hierarchies in C++ programs. Given a C++ class hierarchy (a collection of C++ classes and inheritance relations among them) and a program <i>P</i> that uses the hierarchy, the algorithm eliminates from the hierarchy those data members, member functions, classes, and inheritance relations that are unnecessary for ensuring that the semantics of <i>P</i> is maintained.Class slicing is especially useful when the program <i>P</i> is generated from a larger program <i>P'</i> by a <i>statement slicing</i> algorithm. Such an algorithm eliminates statements that are irrelevant to a set of slicing <i>criteria</i>---program points of particular interest. There has been considerable previous work on statement slicing, and it will not be the concern of this paper. However, the combination of statement slicing and class slicing for C++ has two principal applications: First, class slicing can enhance statement slicing's utility in program debugging and understanding applications, by eliminating both executable <i>and</i> declarative program components irrelevant to the slicing criteria. Second, the combination of the two slicing algorithms can be used to decrease the space requirements of programs that do not use all the components of a class hierarchy. Such a situation is particularly common in programs that use class libraries.", "authors": [{"name": "Frank Tip", "author_profile_id": "81100333471", "affiliation": "IBM T.J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY", "person_id": "PP15029416", "email_address": "", "orcid_id": ""}, {"name": "Jong-Deok Choi", "author_profile_id": "81423596242", "affiliation": "IBM T.J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY", "person_id": "PP43124361", "email_address": "", "orcid_id": ""}, {"name": "John Field", "author_profile_id": "81100419562", "affiliation": "IBM T.J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY", "person_id": "PP43119729", "email_address": "", "orcid_id": ""}, {"name": "G. Ramalingam", "author_profile_id": "81100519054", "affiliation": "IBM T.J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY", "person_id": "PP31045870", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236355", "year": "1996", "article_id": "236355", "conference": "OOPSLA", "title": "Slicing class hierarchies in C++", "url": "http://dl.acm.org/citation.cfm?id=236355"}