{"article_publication_date": "10-01-1996", "fulltext": "\n A Monotonic Superclass Linearization for Dylan Kim Barrett <kab@camellia.org> Bob Cassels cCassels@harlequin.com> \nPaul Haahr chaahr@netcom.com> David A. Moon cMoon@mc.lcs.mit.edu> Keith Playford <keith@harlequin.co.uk> \nP. Tucker Withington <ptw@harlequin.com>t 28 June 1996 Abstract Object-oriented languages with multiple \ninheritance and automatic conflict resolution typically use a linearization of superclasses to determine \nwhich version of a property to inherit when several superclasses provide definitions. Recent work has \ndefined several desirable characteristics for hnearizations, the most important being monotonicity, which \nprohibits inherited properties from skipping over direct superclasses. Combined with Dylan s sealing \nmechanism, a monotonic linearization enables some compile-time method selection that would otherwise \nbe impossible in the absence of a closed-world assumption. The Dylan linearization is monotonic, easily \ndescribed, strictly observes local precedence order, and produces the same ordering as CLOS when that \nis monotonic. We present an implementation based on merging and a survey of class heterarchies from several \nlarge programs, analyzing where commonly used linearizations differ. use this model include Ada 95, C++, \nCLOS, Dylan,  Introduction Eiffel, Java, Oberon-2, Sather, and Smalltalk. Why linearizations? In object-oriented \nsystems with multiple inheritance, some mechanism must be used for resolving conflicts In a class-based \nobject-oriented language, objects are when inheriting different definitions of the same property instances \nof classes. The properties of an object -what from multiple superclasses. Some languages requireslots \nor instance variables it has, which methods are manual resolution by the programmer, with mechanisms \napplicable to it -are determined by its class. A new such as explicit delegation in C++ [ES 901 and feature \nclass is defined as the subclass of some pre-existing renaming in Eiffel. [Meyer 881 classes (its superclasses \n-in a single-inheritance language, only one direct superclass is allowed), and it Dylan, [Apple 921 [Apple \n941 [Shalit 961 like other inherits the properties of the superclasses, unless those object-oriented \ndescendants of Lisp (e.g., Flavors [Moon properties are overridden in the new class. Typically, 861, \nLOOPS [SB 861, and CLOS [Steele 901 [KdRB 91]), circular superclass relationships are prohibited, so \na automatically resolves conflicts occurring in method hierarchy (or heterarchy, in the case of multiple \ndispatch. This resolution is implemented using a inheritance) of classes may be modeled as a directed \nlinearization. When a class is created, a linearization of acyclic graph with ordered edges. Nodes correspond \nto its superclasses, including itself, (also known as the class classes, and edges point to superclasses. \nLanguages that precedence list or CPL) is determined, ordered from t The work reported here was started \nwhen Barrett, Cassels, and Permission to make digital/hard copy of part or all of this work for personal \nor classroom use is granted without fee provided that copies are not made Moon were at Apple Computer, \nand Haahr, Playford, and or distributed for profit or commercial advantage, the copyright notice, the \nWithington were at Harlequin. At the time of writing, Cassels, title of the publication and its date \nappear, and notice is given that copying is by permission of ACM, Inc. To copy otherwise, to republish, \nto Playford, and Withington are with Harlequin, Barrett is at IS post on servers, or to redistribute \nto lists, requires prior specific permission Robotics. and Haahr and Moon are unaffiliated. and/or a \nfee. OOPSLA 96 CA, USA 0 1996 ACM 0-89791-788~Xl96/0010...$3.50 most specific to least specific. When \nseveral methods are applicable for a given call, the one defined on the most specific class, according \nto the linearization, is selected. Dylan, like CLOS, uses generic functions with multimethods, that \nis, methods specialized on more than one parameter. The use of the class precedence list generalizes \nto multimethods without difficulty, but for purposes of presentation, we will not consider multimethods \nfurther in this paper. Most object-oriented languages implicitly use a rule similar to linearization \nfor method dispatching in single inheritance: a class is more specific than any of its superclasses, \nso methods defined for subclasses override methods defined for superclasses. The problem with generalizing \nthis to multiple inheritance is that the simple rule does not make clear which of two superclasses with \nno subclass/superclass relationship between them is more specific. For example, consider the simple use \nof multiple inheritance in example la. (For details on Dylan language constructs, see the Dylan Reference \nManual. [Shalit 961) The question multiple inheritance raises is Whatisthe starting-edge foran <hv-grid>?\" \nIf it is more like a horizontal than a vertical grid, it is the left edge, but if it is more like a vertical \ngrid, it is the top edge. In an explicit resolution system, the author of the <hv-grid> class would have \nto write a declaration or method to choose which superclass to obtain the starting-edge behavior from. \nIn contrast, when a linearization is used, the default behavior is determined by which of <horizontal-grid> \nor <vertical-grid> appears first in the linearization. Following CLOS, Dylan uses the localprecedence \norder - the order of the direct superclasses given in the class definition -in computing the linearization, \nwith earlier superclasses considered more specific than later ones. Therefore, since <horizontal-grid> \nprecedes <vertical-grid> inthedefinition of <hv-grid> it will also precede it in the linearization. The \nfull linearization for <hv-grid> is <hv-grid>, <horizontal-grid>, <vertical-grid>, <grid-layout>, <object> \n On the other hand, to create a combined horizontal and vertical grid which is more like a vertical grid \nthan a horizontal one, the only change necessary to the definitions above would be to reverse the order \nof the direct superclasses in the class that combines the two grids; see example 1 b. It is possible \nthat an inheritance graph is inconsistent under a given linearization mechanism. This means that the \nlinearization is over-constrained and thus does not exist for the given inheritance structure. An example \nof an inconsistent inheritance relationship appears in example lc. <confused-grid> is inconsistent because \nit attempts to create a linearization that has define define define define class class class class <grid-layout> \n(<object>) ~. end; <horizontal-grid> (<grid-layout>) ~.end; <vertical-grid> (<grid-layout>) ~.end; <hv-grid> \n(<horizontal-grid>, <vertical-grid>) ~. end; define method starting-edge #\"left\" end method starting-edge; \n(grid :: <horizontal-grid>) define method starting-edge # 'I top 1q end method starting-edge; (grid :: \n<vertical-grid>) Example la: A simple use of multiple inheritance define class <vh-grid> (<vertical-grid>, \n<horizontal-grid>) ~. end; Example lb: Reversing classes in the linearization define class <confused-grid> \n(<hv-grid>, <vh-grid>) ~. end; Example Ic: An inconsistent class definition <object> <grid-layout> \n /\\ <horizontal-grid> <vertical-grid> <hv-grid> cvh-grid> \\/ <confused-grid> Figure I: An inconsistent \nclass heterarchy <horizontal-grid> before <vertical-grid>, because it subclasses <hv-grid>, and <vertical- \ngrid> before <horizontal-grid>, because it subclasses <vh-grid>. Clearly, both of these constraints cannot \nbe obeyed in the same class. Characteristics of linearizations A number of characteristics have been \nidentified as being desirable for linearizations. Two of these characteristics - acceptability and monotonicity \n-were advocated by Ducoumau, Habib, et. al. [DHHM 921 [DHHM 941. In addition, the CLOS linearization \nstrictly observes local precedence order, and Ducoumau, Habib, et. al. discuss the local precedence order \n(under the name precc). An acceptable linearization is one in which only the shape of a class s inheritance \ngraph may be used in determining the linearization. All the linearizations considered here are acceptable, \nbut one based on classes outside the inheritance graph (as in the global linearization proposed in [Baker \n911) or on the names of classes would not be. A linearization that observes localprecedence order will \nnot produce a linearization which is inconsistent with the local precedence orders of any of the superclasses. \nThat is, if class A precedes class B in the local prece-dence order of class C, the linearizations of \nC and all of its subclasses should have A before B. A monotonic linearization is one in which every property \ninherited by a class is inherited or defined by one of its direct superclasses; that is, an inherited \nproperty cannot skip over all of the direct superclasses. This means that the linearization of a class \nmust be an extension without reordering of the linearizations of all of its superclasses. [DHHM 941 gives \nthe class heterarchy pictured in figure 2 as an example for monotonicity. The linearizations for <pedalo> \nand its direct superclasses using the CLOS mechanism are: <pedal-wheel-boat>: <pedal-wheel-boat>, <engineless>, \n<day-boat>, <wheel-boat>, <boat>, <object> <small-catamaran>: <small-catamaran>, <small-multihull>, \n<day-boat>, <boat>, <object> <pedalo>: <pedalo>, <pedal-wheel-boat>, <engineless>, <wheel-boat>, <small-catamaran>, \n<small-multihull>, <day-boat>, <boat>, <object> Consider a method defined on <day-boat> and <wheel-boat>. \nFor both direct superclasses of <pedalo>, the method on <day-boat> is the most specific, yet the method \non <wheel-boat> is the most specific for <pedalo>. With a monotonic linearization, this surprising result \ncannot occur. <object> <boat> <day-boat> <wheel-boat> I <engine-less> I <pedal-wheel-boat> <small-catamaran> \n \\/ cpedaloz Figure 2: For CLOS, a non-monotonic class heterachy, from [DHHM 941  Computing linearizations \n<object> Typically, a linearization is computed by merging a set of constraints or, equivalently, topologically \nsorting a relation on a graph, though other mechanisms are pos-sible. The linearizations we considered \ncan be expressed as the merging of a set of sequences and a selection rule for ambiguous cases. The merge \nof several sequences is a sequence that contains each of the elements of the input sequences, An element \nthat appears in more than one of the input sequences appears only once in the output sequence. If two \nelements appear in the same input sequence, their order in the output sequence is the same as their order \nin that input sequence. (Note that a class cannot appear twice in the same input sequence.) The linearization \nused in Dylan merges the local precedence order of the class being defined with the linearizations of \nits direct superclasses. The CLOS linearization merges the local precedence orders of the class and of \nall its superclasses. If there is no possible merged output sequence which is consistent with all the \ninput sequences, the class heterarchy is inconsistent. It is possible that there are several valid merges \nfor some set of input sequences. For example, consider the class heterarchy in example 2 (pictured in \nfigure 3). Using the Dylan mechanism, computing the linearization for cpopup-menu> involves merging the \nsequences: <popup-menu>, <menu>, <popup-mixin> <menu>, <choice-widget>, <object> <popup-mixin>, <object> \n where the first is the local precedence order for <popup-menu> and the second and third are, respectively, \nthe linearizationsof <menu> and <popup-mixin>. The first two elements of the merged result are <popup-menu> \nand <menu>, but the third element of the linear- ization is not unambiguously determined by the input \ndefine class <choice-widget> (<object>) <choice-widget> I <popup-mixin> <menu> / \\/ <popup-menu> \n Figure 3: The heterarchy from Example 2 sequences. After <popup-menu> and <menu> have been placed in \nthe output, either <choice-widget> or <popup-mixin> could appear next, since both have all their predecessors \nalready in the merged sequence. A mechanism is needed for choosing between <choice- widget> and <popup-mixin>. \nDylanandCLOSuse the same rule, which is to select the class that has a di- rect subclass closest to the \nend of the output sequence, as currently computed. The result so far is (<popup- menu>, <menu>), and \n<menu> is a direct subclass of <choice-widget>so<choice-widget> isselected. After that, no ambiguities \nremain, and the full lineariza- tion is the sequence (cpopup-menu>, <menu>, <choice-widget>,cpopup-mixin>,<object>). \n [DHHM 941 introduces the L*,,Ops linearization, a variation on the linearization used in LOOPS, which \nwas designed to be monotonic. The original construction of ~*l.ooPsis in terms of a depth-first topological \nsort on the linearization graph, which is a graph where the vertices are the classes in the heterarchy \nand the arcs are determined by the linearizations of the direct superclasses. To facilitate comparisons \nwith the other linearizations, we will describe L*,,,,, in terms of merging. ~*lsmPs merges the linearizations \nof the direct superclasses, but, unlike Dylan and CLOS, does not include the local precedence order in \nthe merge. When ~. end; define class <menu> (<choice-widget>) ~. end; define class <popup-mixin> (<object>) \n.. end; define class <popup-menu> (<menu>, <popup-mixin>) ~. end; Example 2: A class heterarchy with \nan ambiguity in constraints selecting the next class from several alternatives for which all the predecessors \nare already in the output sequence, it uses the first unselected class in a depth-first ordering of the \nlinearization graph.  The Dylan Linearization Why Monotonicity? Dylan [Apple 921 [Apple 941 [Shalit \n961 originally specified a linearization equivalent to the one used in CLOS. In light of the research \ndone by Ducoumau, Habib, et. al., and the definition of the monotonicity criterion, it was decided that \nthe CLOS linearization should be replaced by a monotonic linearization. The first reason for the change \nis that a monotonic linearization seems a better match for users intuitions about how inheritance and \nlinearizations work. With a monotonic linearization, it is easier to understand the behavior of classes \nwhen multiple inheritance is used, largely because behavior of instances of a class can be explained \nin terms of the direct superclasses. A second reason for picking a monotonic linearization for Dylan \nis that it enables more compile-time method selection. Dylan has an innovative mechanism, known as sealing, \nfor describing what extensions to a library are possible after it is compiled. A sealed class may not \nbe directly subclassed outside of the library where it is defined, whereas an open class may be. Similarly, \nmethods may be added outside the defining library to an open genericfunction, but not to a sealed one. \nA domain of a generic function may be sealed, which prohibits the definition of new methods or classes \nwhich would change the applicability of methods for the types specified by the domain. (For details on \nsealing, see the Dylan Reference Manual. [Shalit 961) The restrictions imposed by sealing permit a Dylan \ncompiler to select methods for generic function calls at compile-time without imposing a closed-word \nassumption on the program. Consider the pedal0 example from above in the context of sealing. Suppose \nthat all the classes are open (and thus can be extended), but there is a sealed function max-distance \nwith methods defined on <day-boat> and <wheel-boat>. Now consider the method defined in example 3. If \nthe linearization is known to be mono-tonic, the compiler can choose to dispatch the call to max-dis \ntance directly to the method defined on <day-boat>. This is known statically because no new meth-ods \ncan be defined on max-distance -it is sealed -and <day-boat> is always more specific than <wheel- boat> \nfor instances of <pedal-wheel-boat>. The Algorithm As described above, the Dylan linearization merges \nthe local precedence order of a class with the linearizations of its direct superclasses. When there \nare several possible choices for the next element of the linearization, the class that has a direct subclass \nclosest to the end of the output sequence is selected. It should be clear that the Dylan linearization \nis monotonic, because the merge procedure never reorders the linearizations of superclasses when producing \nthe linearization. Similarly, it obeys local precedence order because the merge explicitly takes local \nprecedence into account, and the local precedence orders of superclasses are propagated by the linearizations. \nAn implementation of the Dylan linearization appears in Appendix A.  Empirical results When we decided \nto adopt a monotonic linearization for Dylan, we had initially considered using L*LOOPs. The first problem \nwe encountered was that the presentation of the algorithm in [DHHM 941 makes it hard to see what the \ndifferences with the existing (CLOS) approach were. We were concerned that existing class heterarchies \nwould be reordered by L*,,~~~, causing mysterious bugs. We wanted to ensure that all of the differences \nbetween our new linearization and the previous one (CLOS) could be justified as part of the desired new \nproperties (e.g., monotonicity) and were not due to gratuitous define method max-pedal-rotations (pwb \n:: <pedal-wheel-boat>) max-distance(pwb) / distance-per-pedal-rotation(pwb) end method max-pedal-rotations; \n Example 3: A method which may permit sealing optimizations heterarchy 1 classes 1 Mjoins different 1 \nDylan vs. Dylan vs. CLOS vs. L*LOW., CPLS LispWorks 1 507 1 70 0 CLIM 842 184 31 (21) database 38 4 0 \nemulator 571 205 8 (4) proprietary 665 124 81 (12) Watson 673 114 0 total 3296 701 120 (37) Table I: \nComparison of the Dylan, incompatibilities. Compatibility with CLOS was considered important both because \nof an existing body of Dylan code that assumed that linearization and because of the substantial amount \nof real experience with it in the Common Lisp community indicating that it could be used successfully. \nIn order to understand the scope of the change we were making to Dylan, we surveyed the classes defined \nin six class heterarchies from existing large CLOS programs and compared the linearizations computed \nfor them by the Dylan, CLOS, and L*,,,, mechanisms. The results of this survey are summarized in table \n1. The first column contains the program which the heterarchies came from. The programs we studied were: \nLispWorks -The implementation of CLOS in Harlequin s LispWorks development environ-ment and the set of \nclasses used in its user inter-face. (Note that all these class heterarchies were built on top of the \nbasic LispWorks heterarchy, but those classes have only been counted once, in the totals for LispWorks.) \nCLIM -The Common Lisp Interface Manager, a Lisp-based programming interface that provides a layered set \nof portable facilities for constructing user interfaces. [MY 941 database -An interface to SQL databases. \nemulator -A Dylan emulator on top of CLOS and some basic class libraries (collections, streams) written \nin Dylan. (The CLOS linear- ization was used for all classes when originally written.) proprietary -A \nlarge proprietary application written by a Harlequin customer which makes heavy use of CLOS. CLOS abloom \nL*LOWS inconsistent 0 0 0 0 31 (21) 5 31 (21) 0 0 0 0 0 8 (4) 0 8 (4) 0 81 (12) 81 (12) 19 (81 0 0 0 \n0 41 (27) 86 (17) 120 (37) 19 (8) CLOS, and L*,,, linearizations WatsonTM - Harlequin s Watson product, \na data analysis tool. The next two columns give the number of classes and the number of multiply inheriting \nclasses in the heterarchy, respectively. It is only the multiply inherit-ing classes for which there \nis the possibility of a differ- ence in linearizations. The next four columns summa-rize the differences \nthat appeared in the linearizations. First, we show the number of classes for which any two linearizations \ndiffered, and the following columns give the results for pairwise comparisons between the differ- ent \nlinearizations. The final column reports the number of classes in each heterarchy which were inconsistent \nunder the L*,,,,s linearizations; no inconsistent classes were found when using Dylan or CLOS. We do \nnot claim that L*,,,,, inherently makes inconsistent classes more common: this data was taken from CLOS \nprograms, and any inconsistencies with respect to the CLOS linearization would have been eliminated as \npart of the normal development process before the class heterarchies were surveyed. The Dylan linearization \nis sufficiently similar to CLOS that definitions consistent with one are typically consistent with the \nother. It is important to recognize that if two linearizations dif-fer for a given class, they will differ \nfor its subclasses; similarly, if a class is inconsistent under one lineariza-tion, all its subclasses \nwill be, too. The difference or inconsistency even appears in subclasses which are con- structed by single \ninheritance, despite the fact that all linearizations use the same mechanism for single inher-itance: \nprefixing the linearization of the single super-class with the class being defined. Therefore, in the \ntable above, we have reported in parentheses the number of classes for each category which were not subclasses \nof classes that were already counted in the category, when <object> that number differed from the total \nnumber. The large number of differences in the linearizations encountered from the proprietary data set \ncan be explained by ob- <cho serving that a few classes, with a large number of sub- classes, account \nfor most of the differences; in fact, a single class accounts for more than half of the differ-ences \nbetween the Dylan and L*,,Opr linearizations. Comparison with L*,~,,,, An important difference between \nCLOS and L*,,,, that our survey made clear is that L*,,,,, does not observe local precedence order for \nsome inheritance graphs. Notably, transitivit?, edges in the inheritance graph -where a class has a direct \nsuperclass that is also an indi- rect superclass -are ignored by L*,,,,,, leading to cases where it disobeys \nlocal precedence order. To see the effect of transitivity edges, consider the alter- nate definition \nin example 4 of the popup menu class from example 2. The L*Loopslinearization for <new-popup-menu> is \n(<new-popup-menu>,<menu>,<choice-widget>, <popup-mixin>,<object>), which violatesthelocal precedenceorderin \n<new-popup-menu> that <popup-mixin> is supposed to appear before <choice-widget>. The linearization produced \nby both Dylan andCLOSis (<new-popup-menu>,<menu>,<popup-mixin>,<choice-widget>,<object>). Uses of inheritance \nwith transitivity edges may seem, at first glance, odd. Why should <new-popup-menu> list both <menu> \nand <choice-widget> as direct superclasses, when <menu> is a superclass of <choice-widget >? We hypothesize \ntwo reasons for such inheritance graphs. The first reason is that one can use such a technique to exercise \nfine control over the linearization. That is, the selection rule used in the linearization may not do \nwhat the programmer wants in some cases, and adding transitivity edges can constrain the merge so that \nthe intended result is obtained. In this example, the programmer s intention could be to ensure that \nthe behavior of <new-popup-menu> follows <popup-mixin> andnot <choice-widget> forsome define class <new-popup-menu> \n(<menu>, I <popup-mixinz T <menu> \\I/ <new-popup-menu> Figure 4: The heterarchy from example 4 particular \nmethod. However, this form of tuning is fragile, because it requires deep knowledge of the heterarchy \nand the linearization on behalf of the programmer; subtle changes in early parts of the class heterarchy \ncould cause such uses to create inconsistencies. We suspect that this technique is rarely used, but an \nauthor of one program in our survey reports adjusting local precedence orders until method dispatch matched \nhis intuition, and that process may have introduced transitivity edges. The second reason comes from \njust the opposite cause: the programmer knows little about the class heterarchy, and intends to mix in \nsome behavior she wasn t aware was already in one of the classes being used. This com-monly occurs during \ndevelopment if classes near the root of the heterarchy are redefined with extra superclasses that might \nalready be inherited by some subclasses. We believe that observing local precedence order is an important \ncharacteristic for a linearization, and our ex- perience with Dylan and CLOS confirms this. If local \nprecedence is not obeyed, the order in a linearization of the direct superclasses cannot be understand \nonly in terms of the class declaration and the ability to exercise fine control over the linearization \nprocess is lost. Ducoumau, Habib, et. al., [DHHM 941 disagree, noting that The fact that LOOPS does not \nalways respect the local order -here prec -is not a problem . . [because] the part of prec which is not \nrespected by LOOPS is always a con- tradictory part of the extended precedence graph. [Section 2.4.41 \nWe note that the contradiction caused <popup-mixin>, <choice-widget>) ~. end; Example 4: A variation \non the popup menu class, with an extra constraint by transitivity edges is only with edges that are added \nto the class graph to produce the extended precedence graph, and the contradiction takes the form of \ncycles in the EPG. (See below for details on the extended precedence graph.) Comparison with CLOS The \nDylan linearization is an extension of the one used in CLOS, where the central difference is that Dylan \nuses the linearizations of superclasses to preserve monotonicity. The Dylan and CLOS linearizations, \nwhen considered as merge operations, have identical structures. Further, the rule used in selecting the \nnext class when there are several for which all predecessors have already been removed from the input \nsequences is the same. The only difference is in the sequences being merged: CLOS uses the local precedence \norders of all superclasses (including the class itself), whereas Dylan uses the linearizations of the \ndirect superclasses and the local precedence order of the class. Note that the sequences merged in the \nDylan lineariza-tion strictly contain those merged by CLOS; that is, Dylan imposes a superset of the \nconstraints used in CLOS on linearizations, and these extra constraints -ordering requirements from the \nlinearizations of superclasses -are exactly those needed to enforce monotonicity. The only cases where \nthe linearizations can be different are those in which CLOS selects among several classes where all the \npredecessors have been placed in the out- put sequence, but at least one of those classes has a pre- \ndecessor in the Dylan linearization, and therefore can-not be selected next. That extra predecessor enforces \nmonotonicity; if it were not present, the result would be non-monotonic. Thus, the Dylan and CLOS lineariza-tions \nproduce the same results when CLOS is monotonic. Consider the cpedalo> example from above. The Dylan \nlinearizations of the direct superclasses of <pedalo> are the same as those found in CLOS: <pedal-wheel-boat>: \n<pedal-wheel-boat>, <engineless>, <day-boat>, <wheel-boat>, <boat>, <object> <small-catamaran>: <small-catamaran>, \n<small-multihull>, <day-boat>, <boat>, <object>  Thus the Dylan linearization for <pedalo> is the result \nof merging those two sequences with the following, which is the local precedence order for <pedalo>: \n<pedalo>, <pedal-wheel-boat>, <small-catamaran>  On the other hand, the CLOS linearization is produced \nby merging <boat>, <object> <day-boat>, <boat> <wheel-boat>, <boat> <engineless>, <day-boat> <pedal-wheel-boat>, \n<engineless>, <wheel-boat> <small-multihull>, <day-boat> <small-catamaran>, <small-multihull> <pedalo>, \n<pedal-wheel-boat>, <small-multihull>  Note that the sequences used in the Dylan linearization require \nthat <day-boat> precede <wheel-boat> in <pedalo>, due to the effect of the linearization of <pedal-wheel-boat>. \nNo such requirement exists for CLOS, thus it is able to select <wheel-boat> before <day-boat>, with a \nnon-monotonic result. Ducournau, Habib, et. al., derived L*,,,,, from the LOOPS linearization by constructing \na linearization graph for a class and applying LOOPS to that rather than to the inheritance graph defining \nthe class. The Dylan linearization can be considered an application of the CLOS mechanism to the linearization \ngraph; using the terminology of [DHHM 941, it might be named L*,,,,.  The extended precedence graph \nand the C3 Linearization The extended precedence graph (or EPG), described in [DHHM 921 and [DHHM 941, \nis an extension of a class heterarchy graph to include the transitive effects of local precedence order. \nConsider the class heterarchy as a directed graph with nodes corresponding to classes and a directed \nedge lead- ing from each subclass to its superclasses. The EPG for a class C is constructed by augmenting \nthe heterarchy graph for C with edges connecting each pair of classes (e.g., A and B) that do not have \na subclass/superclass relationship. The direction of the edge from A to B is determined by finding the \nmaximal common subclasses of A and B among the superclasses of C, that is, classes which are subclasses \nof both A and B but do not have any super-classes that are subclasses of both. Since C is a subclass \nof A and B, there exists at least one such class. For each such class M, if A or a subclass of A precedes \nB or a subclass of B in the local precedence order of M, there is a directed edge from A to B. Similarly, \nif B or one of its subclasses precedes A or one of its subclasses in M s local precedence order, there \nis an edge from B to A. Note that the EPG may contain cycles. Ducoumau, Habib, et. al. [DHHM 921 prove \nthat if the EPG is acyclic, the CLOS and LOOPS linearizations produce the same results and are monotonic. \n(This is true also of the Dylan and L*Loops linearizations .) A linearization is consistent with the \nextended precedence graph if and only if there is a path in the EPG from every class in the linearization \nto all of its successors in the linearization. Since there is a path from every node within a cycle to \nevery other node in the cycle, consistency with the EPG imposes no ordering among classes found within \na cycle in the EPG, but does imply an ordering for the acyclic portions of the graph. Unfortunately, \nthe Dylan linearization, like CLOS but unlike L*LOOps,isn t always consistent with the extended precedence \ngraph, and this can lead to counter-intuitive linearizations. Consider the class heterarchy in figure \n5. The Dylan (and CLOS) linearizations order the super- classesof <editable-scrollable-pane> as <editable-scrollable-pane>, \n<scrollable-pane>, <editable-pane>, <pane>, <editing-mixin>, <scrolling-mixin>, <object> which may have \nsurprising consequences for the user, in that <editing-mixin> precedes <scrolling-mixin> inthelinearizationof \n<editable-scrollable-pane>, despite the fact that <scrollable-pane>, from where <editable-scrollable-pane> \ninherits <scrolling-mixin>, precedes <editable-pane>, whereitgets <editing-mixin> from,in <editable- \n<Dane> <scrolling-mixin> <editing-mixin>  <scrollable-pane> <editable-pane> \\/ . . <editable-scrollable-pane> \n Figure 5: A heterarchy where Dylan s linearization does not observe the extended precedence graph scrollable-pane>'s \nlocal precedence order. If <editable-scrollable-pane> inherits a property defined differently by both \n<scrolling-mixin> and <editing-mixin>,<editable-scrollable-pane> will behave like <editable-pane> rather \nthan <scrollable-pane>, contradicting a programmer s reasonable expectation about the interaction of \ninheritance and local precedence order. C3 -A linearization consistent with the EPG If consistency with \nthe extended precedence graph, local precedence order, and monotonicity are desired, a hybrid of the \nDylan and L*,,Ops linearizations can be used. We call this linearization C3, because it is consistent \nwith these three properties. C3 uses the constraints of the Dylan linearization with a selection rule \nmodeled on the one used in L*,OOps. Our implementation of C3 is similar to the merging algorithm used \nfor the Dylan linearization, differing only in the selection rule. When choosing among several classes \nfor the next element of the linearization, when the input sequences alone do not determine the selection, \nthe C3 linearization chooses the class which appears in the linearization of the earliest direct superclass \nof the class being defined, in local precedence order. Note that at most one candidate class is in the \nlinearization of each of the direct superclasses, because if two were to appear, one would precede the \nother due to the constraints and thus the order between them would be determined by the monotonicity \nrequirement. Examining the <popup-menu> class from example 2 again, after <popup-menu> and <menu> have \nbeen picked as the first two elements of the linearization, a decision has to be made between <choice-widget> \nand <popup-mixin> as the next element, Since <choice-widget> is a superclass of <menu>, and <menu> precedes \n<popup-mixin> in the local precedence order of <popup-menu>, the C3 algorithm selects <choice-widget> \nnext. This is the same result as Dylan, though for a different reason. Ontheotherhand,giventhe <editable-scrollable-pane> \nexample above, where Dylan is not consistent with the EPG, the selection rule of C3 diverges from Dylan \ns when selecting between <scrolling-mixin> and <editing-mixin>. Because <scrolling-mixin> is a superclass \nof <scrollable-pane>, <editing-mixin> is a superclass of ieditable-pane>, and <scrollable-pane> precedes \n<editable-pane> in the local precedence order of <editable-scrollable-pane>,iscrolling-mixin> is selected \nas the next class. To show that C3 is consistent with the extended prece-dence graph, we will demonstrate \nthat C3 cannot violate consistency with the EPG because every time it selects a class it is following \narcs that appear in the EPG. First, note that the edges of the class heterarchy graph, from which the \nEPG is constructed, are included in the input sequences for the C3 merge: the local precedence order \nand the linearizations of superclasses. Next, observe that the C3 selection rule, when presented with \na choice of two classes where the maximal common subclass of the classes is the class being defined (say \nC), will pick, by construction, the one that is itself or has a subclass earliest in the local precedence \norder; that is, the one consistent with the extended precedence graph. What about the case where the \nselection rule must choose between classes where the maximal common subclass is a superclass of C? That \ncannot occur with the C3 algo- rithm, because, if there were such a choice to make, it would have been \nmade in the linearization of that maxi- mal common superclass, and thus would be reflected in the input \nsequences used by the C3 merge. Finally, we observe that every predecessor relationship encoded in the \nlinearizations of superclasses used in the merging process comes from one of three sources: a subclass/ \nsuperclass relationship, the local precedence order of a superclass of C, or one of the augmenting edges \nfrom the EPG for a superclass of C. The general effect of the selection rule used in C3, as in ~*LoiJPs~is \nto produce a depth-first ordering of the class heterarchy, constrained by superclass relationships and \nlocal precedence orders. In contrast, the selection rule used by Dylan and CLOS leads to depth-first \nbehavior locally within the graph, but somewhat arbitrary behavior when considering the graph as a whole. \nAn implementation of the C3 linearization appears in Appendix B. Comparison with other linearizations \nWe compared the C3 linearization with the Dylan and ~*moF5linearizations on the same set of class heterarchies \nwe used above. The results of the comparison are summarized in table 2. The first three columns report \nthe same information as in the table above. The fourth and fifth columns report the number of linearizations \nfor which C3 differed from Dylan and L*,,,Ops, respectively. The final column gives the number of classes \nfor which C3 was unable to produce heterarchy classes MI joins c3 vs. c3 vs. Dylan ~* um,, LispWorks \n507 70 0 0 CLIM 842 184 5 1 database 38 4 0 0 emulator 571 205 0 0 proprietary 665 124 80 (11) 62 (4) \nWatson 673 114 0 0 total 3296 701 85 (16) 63 (5) Table 2: Comparison of the C3, Dylan, and L*,,,,, linearizations \na consistent linearization. Again, parenthesized entries indicate the number of relevant classes where \nthe difference or inconsistency was not a result of a similar problem in a superclass. We observe that, \nmost of the time, C3, Dylan, and L*,OOps produce the same result. When they differ, C3 is more commonly \nthe same as L*,,,,, than it is the same as Dylan, though it is often different from both in such cases. \nFurther, among the classes we surveyed, C3 finds inconsistent class definitions in exactly the same classes \nwhich L*,OOpsdoes; in general, this indicates that those classes multiply inherit from classes where \nthe extended precedence graphs led to contradictory linearizations. Again, we do not consider the lack \nof inconsistencies in the Dylan linearization a general property of the mechanism; because of the similarity \nof the Dylan and CLOS linearizations, this data, coming from large CLOS programs, is unlikely to contain \ninconsistencies under the Dylan linearization. Since C3 differs from Dylan only in the selection rule, \nand C3 s selection rule is used to enforce consistency with the extended precedence graph, C3 and Dylan \nonly produce different results when Dylan s selection rule would lead it to be inconsistent with the \nEPG. Similarly, since the linearization graph used in L*,,Ops contains precisely the edges corresponding \nto the linearizations of superclasses used as input to C3 s merge and the same selection rule in both \nalgorithms (though presented differently in [DHHM 94]), but local precedence order is not used in the \nlinearization graph, the only cases where the results of those algorithms differ is where the presence \nof local precedence order forces C3 to make a different decision from L*,OOps. Note that if L*,OOps and \nDylan produce the same result (which is inherently consistent with the extended prece-dence graph and \nlocal precedence order), it is the same as C3.  Results We have presented two new linearizations, Dylan \nand C3, that are monotonic and obey local precedence order; C3 is also consistent with the extended precedence \ngraph. We ve contrasted those linearizations with two existing linearizations, CLOS and L*,O,,ps, in \nterms of their structure and how they behave on existing class heterarchies. The differences among the \nlinearizations can be summarized by examining which kinds of class topologies they differ on. Dylan is \nthe same as CLOS except where CLOS is non-monotonic. C3 is the same as Dylan except where Dylan is not \nconsistent with the extended precedence graph, and the same as L*,OOps except where that violates local \nprecedence order. In the abstract, C3 is the best of the linearizations we considered. However, C3 diverges \nfrom CLOS in more ways than the Dylan linearization does. Consistency with the extended precedence graph \nis not a necessary precondition for doing Dylan s sealing optimizations and C3 makes a significant number \nof classes from existing CLOS heterarchies inconsistent; thus, using it for Dylan would have been a more \nradical shift, late in the language design process, than using the monotonic variation on CLOS that was \nchosen.  Acknowledgments Roland Ducournau, Michel Habib, Marianne Huchard, and M.L. Mugnier formalized \nthe characteristics of linearizations which underlie this work and offered valuable clarifications of \ntheir research. Joseph Wilson implemented L*,,,,, in the Marlais interpreter and proposed changing the \nlinearization used in Dylan. Glenn S. Burke studied the L*,OOps algorithm when we first considered switching \nlinearizations. Andrew L. M. Shalit participated in the discussions about changing the linearization. \nJudy Anderson, John Aspinall, Nicolas Graube, Kevin Males, Scott McKay, and Martin Simmons, all of Harlequin, \nprovided us with the class heterarchies and related information for our survey of linearizations. Susan \nKarp commented on and proofread drafts of this paper. James Nicholson assisted in the production of a \ncamera-ready version. Apple Computer, Inc., and Harlequin, Inc. and Ltd., sup- ported the authors during \nthe design of the Dylan lan- guage, when this work was undertaken.  Appendix A: Implementation of the \nDylan Linearization define constant compute-class-linearization = method (c :: <class>) => (cpl :: <list>) \nlocal method merge-lists (reversed-partial-result :: <list>, remaining-inputs :: <sequence>) if (every?(empty?, \nremaining-inputs)) reverse! (reversed-partial-result) else / / start of selection rule local method \ncandidate (c :: <class>) / / returns c ifit can go in the result now, otherwise false local method head? \n(1 :: <list>) c == head(l) end method head?, method tail? (1 :: <list>) member?(c, tail(l)) end method \ntail?; any?(head?, remaining-inputs) &#38; -any?(tail?, remaining-inputs) &#38;C end method candidate, \n method candidate-direct-superclass (c :: <class>) any?(candidate, direct-superclasses(c)) end method \ncandidate-direct-superclass; let next = any?(candidate-direct-superclass, reversed-partial-result); \n / / end of selection rule if (next) local method remove-next (1 :: <list>) if (head(l) == next) tail(l) \nelse 1 end end method remove-next; merge -lists(pair(next, reversed-partial-result), map(remove-next, \nremaining-inputs)) else error (\"Inconsistent precedence graph\"); end if end if end method merge-lists; \n let c-direct-superclasses = direct-superclasses(c); local method cpl-list (c) as(<list>, all-superclasses(c)) \nend method cpl-list; merge-lists(list(c), concatenate(map(cpl-list, c-direct-superclasses), list(as(<list>, \nc-direct-superclasses))) ); end method; // compute-class-linearization A few aspects of this program \nmay need to be explained. The selection rule from above is enforced because, when choosing the next class, \nany.3 searches the reversed partially computed CPL in order and returns the first true value it encounters. \nThe function all-superclasses is defined to return the linearization for a class. It is called for each \nof the direct superclasses, and it in turn calls compute-class-linearization recursively, potentially \nstoring the results to avoid recomputing the linearizations. There is no possibility of infinite recursion \nbecause circularities are prohibited in the inheritance graph; the recursive calls bottom out at cob \nj ec t>,the only class in Dylan which has no superclasses. The function direct-superclasses returns the \ndirect superclasses of its argument, in local precedence order. For other details on Dylan, see the Dylan \nReference Manual. [Shalit 961 Appendix B: Implementation of the C3 Linearization The C3 linearization \ncan be obtained by replacing the implementation of the selection rule from Dylan program above (that \nis, the definitions of the local methods candidate and candidate-direct-superclass and the binding of \nthe local variable next) with the following: local method candidate (c :: <class>) // returns c if it \ncan go in the result now, // otherwise false local method tail? (1 :: <list>) member?(c, tail(l)) end \nmethod tail?; -any?(tail?, remaining-inputs) &#38;c end method candidate,  method candidate-at-head \n(1 :: <list>) -empty?(l) &#38; candidate(head(1)) end candidate-at-head; let next = any?(candidate-at-head, \nremaining-inputs): Again, the property that any? returns the first matching result enforces the selection \nrule, because lists of remaining input sequences are maintained according to the local precedence order \nof the classes from which they are obtained. For this to be acorrect implementation of C3, the call to \nall-superclasses in the local function cpl-list must return the C3 linearization rather than the built-in \nDylan linearization. References [DHHM 921 [DHHM 941 [ES 901 [KdRB 913 [MY 941 [Meyer 881 [Moon 861 [SB \n861 [Shalit 961 [Steele 901 R. Ducournau, M. Habib, M. Huchard, and M.L. Mugnier. Monotonic Conflict \nResolution Mechanisms for Inheritance. OOPSLA 92 Proceedings, October 1992. [Apple 921 [Apple 941 [Baker \n911 Apple Computer, Inc. Dylan: an object-oriented dynamic language. 1992. Apple Computer, Inc. DIllan \ninterim Reference Manual. 1994. Henry G. Baker. CLOStrophobia: Its Etiology and Treatment. ACM OOPS Messenger \n2(4), October 1991. R. Ducournau, M. Habib, M. Huchard, and M.L. Mugnier. Proposal for a Monotonic Multiple \nInheritance Linearization. OOPSLA 94 Proceedings, October 1994. Margaret A. Ellis and Bjarne Stroustrup. \nThe Annotated C++ Reference Manual. Addison-Wesley, 1990. Gregor Kiczales, Jim des Rivikres, and Daniel \nG. Bobrow. The Art of the Metaobject Protocol. MIT Press, 1991. Scott McKay, William York, et. al. Common \nLisp Interface Manager (CLIM II) Specijication. 1994. Bertrand Meyer. Object-oriented Software Construction. \nPrentice Hall, 1988. David A. Moon. Object-oriented Programming with Flavors. OOPSLA 86 Proceedings, \nNovember 1986. Mark Stefik and Daniel G. Bobrow. Object-Oriented Programming: Themes and Variations. \nAI Magazine 6(4), 1986. Andrew L.M. Shalit, D$an Reference Manual. Addison-Wesley, 1996. Available as \n http://www.cambridge.apple.com/dylan/drm/drm-1.htmlontheWorldWideWeb. Guy L. Steele, Jr. Common Lisp: \nthe Language (2nd edition). Digital Press, 1990. \n\t\t\t", "proc_id": "236337", "abstract": "Object-oriented languages with multiple inheritance and automatic conflict resolution typically use a linearization of superclasses to determine which version of a property to inherit when several superclasses provide definitions. Recent work has defined several desirable characteristics for linearizations, the most important being monotonicity, which prohibits inherited properties from skipping over direct superclasses. Combined with Dylan's sealing mechanism, a monotonic linearization enables some compile-time method selection that would otherwise be impossible in the absence of a closed-world assumption.The Dylan linearization is monotonic, easily described, strictly observes local precedence order, and produces the same ordering as CLOS when that is monotonic. We present an implementation based on merging and a survey of class heterarchies from several large programs, analyzing where commonly used linearizations differ.", "authors": [{"name": "Kim Barrett", "author_profile_id": "81100343093", "affiliation": "", "person_id": "P161576", "email_address": "", "orcid_id": ""}, {"name": "Bob Cassels", "author_profile_id": "81100138993", "affiliation": "", "person_id": "P31189", "email_address": "", "orcid_id": ""}, {"name": "Paul Haahr", "author_profile_id": "81100361374", "affiliation": "", "person_id": "P221436", "email_address": "", "orcid_id": ""}, {"name": "David A. Moon", "author_profile_id": "81100243475", "affiliation": "", "person_id": "P63001", "email_address": "", "orcid_id": ""}, {"name": "Keith Playford", "author_profile_id": "81100619866", "affiliation": "", "person_id": "P159118", "email_address": "", "orcid_id": ""}, {"name": "P. Tucker Withington", "author_profile_id": "81100464891", "affiliation": "", "person_id": "P218530", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236343", "year": "1996", "article_id": "236343", "conference": "OOPSLA", "title": "A monotonic superclass linearization for Dylan", "url": "http://dl.acm.org/citation.cfm?id=236343"}