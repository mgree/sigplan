{"article_publication_date": "10-01-1996", "fulltext": "\n Lessons Learned from Implementing the CORBA Persistent Object Service3 Jan Kleindienst2, FrantiSek P1BE1 \n32, Petr Tiima Charles University 2 Institute of Computer Science Faculty of Mathematics and Physics, \nCzech Academy of Sciences Department of Software Engineering Pod vodarenskou vL?Y Malostranske namesti \n25, 118 00 Prague 1, 180 00 Prague 8 Czech Republic Czech Republic phone: (42 2) 2191 4266 phone: (42 \n2) 6605 3291 f ax: (42 2) 532 742 f ax: (42 2) 858 5789 e-mail:{plasil, tuma}@kki.ms.mfl.cuni.cz e-mail: \n{kleindie, plasil]@uivt.cas.cz Abstract. In this paper, the authors share their experiences gathered \nduring the design and implementation of the CORBA Persistent Object Service. There are two problems related \nto a design and implementation of the Persistence Service: first, OMG intentionally leaves the functionality \ncore of the Persistence Service unspecified; second, OMG encourages reuse of other Object Services without \nbeing specific enough in this respect. The paper identifies the key design issues implied both by the \nintentional lack of OMG specification and the limits of the implementation environment characteristics. \nAt the same time, the paper discusses the benefits and drawbacks of reusing other Object Services, particularly \nthe Relationship and Externalization Services, to support the Persistence Service. Surprisingly, the \nkey lesson learned is that a direct reuse of these Object Services is impossible. specification, CORBA \n1.2 [OMG92], comprises many components together providing a foundation 1 Introduction for performing \ntransparent remote request calls from the requestors of services (clients or client 1.1 CORBA and TOCOOS \napplications) to the providers of services (servers). In Around 1990, the Object Management Group (OMG) \nprinciple, a request requires an operation to be introduced the Objects Management Architecture executed \nupon a target (or server object) provided by (OMA) for distributed systems [OMG95c], which a server. \nThe functionality of server objects is defines an abstract object model. In 1991, OMG specified via the \nInterface Description Language defined an industry standard called the Common (IDL) defined in [OMG95]. \nIn a client, the IDL Object Request Broker Architecture (CORBA), based compiler typically allows a server \nobject to be used upon a concrete object model derived from the OMA as an ordinary object (by generating \nan access to a abstract object model. Among the CORBA-compliant stub or a proxy in the client); the abstraction \nsystems (CORBA implementations) currently provided for accessing a server object via a stub available \nfrom different vendors are Orbix [ORBIXa, (proxy), both specified by the same IDL interface, is ORBIXb], \nSOM [IBM94a, IBM94b], DOME referred to as CURBA object [OMG94a]. Generally, [DOM93], NE0 [NE096], and \nHP ORB+ [HP95], the request format is vendor-dependent. The CORBA 2.0 standard [OMG94d] specifies ways \nto The first version of the CORBA standard interconnect different CORBAs either by Permission to make \ndigital/hard copy of part or all of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for profit or commercial advantage, the copyright notice, the \n3 This work was done as a part of TOCOOS, a project title of the publication and its date appear, and \nnotice is given that funded by the COPERNICUS Program, project CP 940247; the copying is by permission \nof ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires \nprior specific permission work was also partially supported by GA CR Grant No. and/or a fee. 201/95/0976 \nOOPSIA 96 CA, USA 0 1996 ACM 0-89791-788-X/96/0010...$3.50 transforming requests in a bridge/gateway \nor by transporting requests in the standardized Internet Inter-ORB Protocol (IIOP). The CORBA 1.2 standard \nalso proposes a collection of Object Services [OMG92] that facilitate CORBA-supported objects with additional \nfunctionality such as creating and deleting new objects (Object Lifecycle Service), looking up a server \nwith a specific interface in another CORBA environment (Object Trading Service), or managing persistent \nobjects (Persistent Object Service). The functionality of an Object Service is specified as a set of \ninterfaces specified in IDL, e.g. [OMG94a, OMG94b]. There are two design principles that OMG follows: \nfirst, OMG intentionally leaves services not fully specified; second, services may be mutually dependent \nand, at the same time they OMG interfaces should be able to exist separately, thus partially covering \nfunctionality of other services. Typically, an Object Service is used by inheriting a subset of IDL interfaces \nspecifying the Object Service. Since 1994, we have participated in the TOCOOS Copernicus project (CP940247 \n(other partners: Mari (UK), IONA Technologies (IE), CYFRONET (PL)), the goal of which is to design and \nimplement the bridge between two CORBA implementations: Orbix and DOME [SUZ96] and also to design and \nimplement a subset of the Object Services that would furnish the bridge with enhanced functionality, \nsuch as persistence and fault-tolerance. 1.2 The goal of the paper The purpose of the paper is to articulate \nthe lessons we have learned from designing and implementing 3MG functionality PO/t4PO manager PDS  \n  ;I---------------------. Figure 1 Standardized and unresolved parts of the OMG Persistence Service \nthe CORBA Persistent Object Service (the Persistence Service for short; similarly, we will skip object \nin the names of other CORBA Object Services). Throughout the paper, we show that it is non-trivial to \nfulfill one of the key design principals proposed by OMG in the Requests For Proposals (e.g. [OMG95b]), \nwhich has been referred to as the Bauhaus principle: Minimize duplication of functionality. Functionality \nshould belong to the most appropriate service. Each service should build on previous services when appropriate. \nAs the corresponding OMG document [OMG94b] leaves the design of the Persistence Service functionality \ncore unspecified, the first goal of the paper is to analyze those important issues that have been left \nunresolved by the OMG specification and to report on lessons we have learned from our design and implementation. \nOur second goal is to share the lessons we have learned when trying to follow strictly the recommended \nOMG architecture strategy which strongly encourages reusing other Object Services to minimize duplication \nin functionality. In compliance with this recommendation, in our design and implementation, we focused \non the Relationship Service [OMG94e] and the Externalization Service [OMG94g]. As the inter-dependencies \namong the three Object Services are rather complex and potentially circular, we will also aim at providing \nthe reader with an analysis of inherent trade-offs. 1.3 Structure of the paper The paper has the following \nstructure: Section 2 is focused on our project requirements and restriction. It also very briefly summarizes \nthe OMG Persistence Service specification. In Section 3, we focus on our Persistence Service design decision. \nWe provide the reader with the decision we made with respect to the general issues associated with the \ndesign and implementation of the Persistence Service -determining object persistence, accessing object \nattributes, updating object state, resolving dependencies and referential integrity, etc. Also, our approach \nto the key design architecture issues is addressed. Our implementation of the Persistence Service is \ndescribed in Section 5 with a particular emphasis on the parts left unresolved in the OMG specification. \nSection 5 focuses on analyzing the potential reuse of other Object Services in an implementation of the \nPersistence Service; it discusses two of them in more detail: the Relationship Service and the Externalization \nService. Section 6 closes the paper by summarizing the lessons we have learned from our design and implementation \nof the Persistence Service, especially while balancing necessary trade-offs, and particularly while analyzing \nthe option of reusing other Object Services in our implementation of the Persistence Service. 2 Project \nrequirements and restrictions 2.1 Our design goals and boundaries From the very beginning of our Persistence \nService design, we had to consider two essential properties of the target application, the bridge. First, \nas the bridge uses CORBA distributed objects as well as local C++ objects, the Persistence Service implementation \nmust be able to handle both kinds of objects. (We have, therefore, found it natural to consider implementing \nthe Persistence Service only for the C++ environment.) Second, parts of the bridge must run in different \nCORBA environments. The Persistence Service implementation must not depend on any CORBA implementation-specific \nproperties of the target environment. The overall functionality of the service, however, should not be \ndegraded by the decisions made as a result of meeting the requirements mentioned above. Furthermore, \nthe service s implementation should fulfill the following objectives: 4 The implementation should fully \ncomply with the OMG Persistence Service specification [OMG94b]. b) The implementation should not depend \non any other service unless a suitable implementation of it is readily available. c> The implementation \nshould neither require any change to the C++ [Str94] and IDL [OMG95] languages, nor any modification \nof the hosting CORBA environment. 2.2 The OMG specification of the Persistence Service The Persistence \nService is specified in [OMG94b], where the IDL specification of three basic interfaces are provided: \nPersistent Object (PO), Persistent Object Manager (POM), and Persistent Data Service (PDS). Fundamentally, \nthese interfaces comprise the same methods: connect(), disconnect(), store(), restore0 and delete(). \nA PDS supports a collection of pairs <Datastore, Protocol>. Dutustore actually saves and loads the PO \ns data, Protocol describes the way a PDS transfers data into and from the PO. Both Dutustore and Protocol \nare not standardized; however, [OMG94b] offers three examples of Protocol and a specification of Datastore-CLI, \nwhich might be used as a uniform interface for accessing many different Datastores. I Generally speaking, \na PDS communicates with the PO through a Protocol, and with the datastore via either Datastore-CL1 or \na proprietary (not defined by OMG) Dutustore interface. A POM dynamically resolves the binding between \nPO and its PDS, given a PID of a PO and the Protocol supported by the PO. Here, a PID is an identifier, \nuniquely denoting the object derived from PO in a datastore. Thus, a PID is basically represented as \na triple <datastore-type, datastore-type-instance-id, key-to-PO>. For example, a PID could be cFS, hostname, \npath+offset> for a file-system-based datastore, or <DB, DBname, key> for a database-like datastore. Under \nthe assumptions a>a POM knows about all available PDSs and the combinations of Dutustore and Protocol \nthat each PDS can support (implementation: POM keeps this information either in a configuration file, \nor registry, or via a dedicated interface), and b)given a PO, the POM knows which Protocol the PO supports \n(implementation: the supported Protocol is deduced for example from the PO s type), the POM resolves \nthe PDS in the following steps: 1. get the datastore-type and data-store-type-instance-id fromthePO sPID \n2. get the Protocol supported by the PO 3. localize a Dutustore object using the pair cdata-store-type, \ndatastore-type-in-stance-id> 4. determine the PDS given the pair <Dutustore, Protocol>  2.3 Reusing \nother services One of the CORBA architectural strategies is to stimulate mutual reuse among Object Services. \nMore specifically, [OMG95b] reads: Each service should build on previous services when appropriate with \nthe key motivation stated as Functionality should belong to the most appropriate service. With respect \nto the Persistence Service, the corresponding OMG specification discusses the option of integrating the \nPersistence Service with other Object Services. The discussion distinguishes the services that potentially \nmay use the Persistence Service, such as the Backup/Restore Service or the Replication Service, and the \nservices that may be used by the Persistence Service, such as the Externalization Service or the Relationship \nService. At first glance, it appears that reusing the latter two services might cover a substantial portion \nof a Persistence Service implementation. Therefore, we originally followed this track recommended by \nOMG. We summarize the lessons we learned during this stage of the design in Section 5, where we discuss \nthe pros and cons of integrating these two services into our implementation of the Persistence Service \nand also provide the reasons why we have not done it in the current implementation.  3 Persistence Service \ndesign decisions Filling the semantic gap left in the OMG specification of the Persistence Service (Section \n2.2) involves many decisions to be taken when designing and implementing the service. In this section, \nas a result of both thorough analysis made before our decisions were made and experience gained from \nthe actual design and implementation, we provide an overview of those design issues and tradeoffs we \nfeel that everyone who implements the Persistence Service will have to face. We divide these issues into \ntwo parts: general design issues (determining an object s persistence property, accessing persistent \nobject state, updating persistent object state, resolving dependencies) explained in Section 3.1, and \ndesign architecture issues (basically the internal structure of the building blocks from Figure 1) analyzed \nin Section 3.2. 3.1 General design issues 3.1.1 Key concepts As for persistence [e.g. Tan95, Mu194, CDK94, \nSKW92, DdBF+92] in this paper, we will limit ourselves to persistence of objects in the CORBA environment. \nIn this respect, the following are the principal concepts to which we will refer: A persistent object \nis an object, the lifetime of which can exceed the lifetime of the application it is used in. Persistent \nstate (of a persistent object) is the n-tuple of values corresponding to the n attributes of the object. \nCertain object attributes, usually with a very limited lifetime, can be considered auxiliary; their values \nmay not be embodied in the object s persistent state. Dependencies (of a persistent object PO) -the set \nof all the objects targeted by a reference (either standard or defined by the Relationship Service) from \nthe PO. Transitive closure of dependencies (of a persistent object PO) -the set of all objects reachable \nfrom PO via references transitively over all nested dependencies; this is an analogy of the deep copy \nconcept [Mey88, Str94]. 3.1.2 Determining object persistence property Basically, there are three ways \nto determine objects persistence properties: static, semidynamic and dynamic determination. Static determination: \nAt compilation time, certain application objects may be statically denoted as being persistent, typically \nby inheriting from a persistent base class. Such objects will retain their persistence property forever \nwithin the time scope of the application; there is no way they can cease being persistent at runtime. \nThis approach is relatively easy to implement. However, the necessity to activate the object persistence \nproperty statically and the impossibility of deactivating it later is not very convenient for the user. \nThus, this black-or-white approach is not desirable. Semidynamic determination: This approach is a modification \nof static determination through a runtime enhancement: the persistent property of statically denoted \nobjects can be dynamically activated and deactivated. This provides the user with the runtime ability \nto decide objects persistence. This control is limited to those classes of objects which have been statically \npreselected [Mey88], e.g. by inheriting from a PersistentObject base class. Dynamic determination: This \nhighly desirable approach allows the user to decide dynamically the persistence property of all objects \n(orthogonal persistence [MA90]). To be able to implement the dynamic determination approach that guarantees \npersistence for all objects, the C++ compiler used would have to provide ways for accessing runtime type \ninformation for each C++ class. Since this is usually not the case with the C++ compilers and since we \nobliged ourself not to modify any C++ compiler, we decided to choose the semidynamic approach, e.g. support \npersistence only for certain, statically preselected, objects. Such objects are derived from a common \nbase class and must explicitly export the runtime type information h required by the Persistence Service. \nThis information includes a list of the object s non-reference attributes, a list of the object s references \npointing to other objects, and the identifier of the object s class. 3.1.3 Accessing object attributes \nWhen manipulating an object s persistent state, two principal approaches to accessing its attributes \ncan be identified: access via object s methods and direct access. Access via object s methods: Typically, \neach persistent object is equipped with two specialized methods for saving and loading its state. Basically, \nthe methods can be made public, and thus a part of the object IDL interface, or they can be made accessible \nto the underlying persistence system only - e.g. by using the friend construct in C++. While making them \npublic works nicely also for distributed calls, the former alternative is limited for the server side \nonly. Direct access: Access to the object s attributes is done by direct access to the memory location \nat which the object is stored. This approach is typically used when a persistent address space is supported. \nA number of approaches towards the persistent address space architecture exist. The most well-known of \nthese are [AJJ+92, AJL92, PSWL94, SDP93, SF94, FS94b, SG9la, SKW92, DdBF+92, and HCF+95]. In this case, \nthere was basically no problem with the decision since the limitations of a distributed environment set \nheavy odds against the direct access approach. Thus, every persistent object in our implementation is \nequipped with two methods, save-state{) and load-state(), defining how to store and load the object s \nattributes compactly. 3.1.4 External representation data format The format of data external representation \ncan be either canonical or ad hoc. Canonical format: Data on the external media is stored in a standardized \nformat, possibly the Standard Stream Data Format defined in [OMG94g] with the bound IDL type set and \nidentification keys reused from the Naming Service. Such a format, of course, has the advantage of being \nwidely recognized and can be used for porting objects data from one implementation to another. On the \nother hand, supporting such a format sometimes requires sacrifices in the implementation and may slow \ndown overall performance. Ad hoc format: Each datastore implementation comes with its own format for \nexternalized data, typically tailored for a particular save/load protocol and naturally taking advantage \nof the underlying media representation (files, raw blocks, database tables). In our design we came up \nwith the ad hoc format that suits well our datastore implementation and supports the save/load protocol \nwe use.  3.1.5 Updating persistent object state The updating of an object s persistent state can be \neither automatic or explicit. Automatic: Updating is system-controlled, based on a consistency protocol \nwhich can be e.g. transaction based, virtual memory based, system event based, etc. [AJL92, HKPCS951. \nExplicit: Updating is application-controlled, i.e. store and restore methods of the Persistence Service \nare called explicitly by the application. We chose the explicit approach for the current implementation. \nFuture extension to provide the automatic updating is possible, probably transaction based and implemented \nvia Orbix filters.  3.1.6 Resolving dependencies and referential integrity In addition to the issue \nof when to update the persistent state of an object, the question arises of how the object s dependencies \nare handled: the object s dependencies are either not considered (shallow updating), or they are considered. \nIn the latter case, the dependencies can be updated recursively up to the n-th level; in general, to \nensure referential integrity, the transitive closure of dependencies is considered (deep updating). To \nimplement deep updating, object dependencies have to be resolved; two techniques are used for this purpose: \ngrouping and evaluation of dependencies. Grouping: The current status of relations among objects is not \nevaluated; dependencies are resolved implicitly by defining groups of object. Such a group must be closed \nwith respect to inter-object references. As examples, see clusters in COOL [HMA90, AJJ+92, ALJ92] or \ngroups in SOM [IBM94a, IBM94b]. Evaluation of dependencies: Dependencies are explicitly evaluated (typically, \nbefore each update of an object s persistent state). This can be either application-controlled or system-controlled \n(based on hardware-supported reference identification). In the latter case, the techniques of early or \nlate pointer swizzling are typically used [SKW92, VD92]. Having possible integration with the Relationship \nService in mind, we selected the evaluation of dependencies technique for our implementation, since it \nemulates the graph traversal mechanism used by the Traversal Criteria object from the Relationship Service. \n 3.2 Design architecture issues This section briefly describes three major components of our Persistence \nService proposed architecture: Persistent Data Service, Protocol, and Data Store. In accordance with \n[OMG94b], the Persistent Data Service is responsible for actually carrying out all Persistence Service \nrequests. As discussed in Section 3.1.3, the Persistent Data Service accesses the persistent attributes \nof an object using the POProtocol interface (this interface is a part of protocol in terms of [OMG94b]). \nThe object dependencies are processed together with an object (Section 3.1.6). The heart of the Persistent \nData Service architecture is, therefore, an algorithm capable of recursively traversing all nodes of \na persistent object graph, together with a list of all persistent objects being served by the Persistent \nData Service. The Protocol describes a method of communication between the Persistent Data Service and \npersistent objects. It is designed to provide the Persistent Data Service with the necessary information, \nwhile remaining as simple as possible from the persistent object s point of view. As our environment \ndoes not provide sufficient information about an object s type, we have included a method to get a unique \ntype ID as a part of the Protocol. The only responsibility of the Data Store is persistent storage management, \ntogether with reading and writing the managed data. As the structure of the persistent storage may vary \ndepending on the application environment, the Data Store interface should be flexible enough to cover \na wide range of underlying storage mechanisms. We have, therefore, decided to keep the Data Store interface \nvery simple, providing only basic methods to read and write untyped data. Specified by OMC I. I  I \nIIpoI / II---_ persistent SD object * L~~~~~~~~~~-~.------~~~~---------~~~~ ________._, __-_-__-__3i \n~~~~~~~~~~~~~~ ~~~~~~a~~~~ .8sg~~~~~~~~~~~~~~.~~ jpg.jvDataLayer,:I / -;.jjjj:i ;;ljzgljj:jlillii:: \n~:.:... .... . . . . .,;.,; ................ I;;:;: ):~jjjjjp(i: ji::g::;:.:,:::.: ... ...>..:.:::..:: \n:.: :.i !i :.~,i: ..............................:.:.:.:.:.j::.,.::.:,>: ::,:.::::.:.:.:.:.:...::j:.:; \n::.:::::::...... :,::.:: ....... ... .......... : .:;>,,:.::,,: .......................... :,/: ..................... \n::::: t:i::::::,:,:,:,:..... ::::..................  I , .:::::::::: .. .:.:.,.: ................................................................................................................................ \n ................................................ ............................................................................. \n ,:...:.:...:.:...:.:.:.:.:...............:::;: ......................................................... \n.:.:. .:.::::::::::::::;: :.,.: ...... .. 1 ,..:.:.:.:.:.:.:.:.:.:.:.:.:...:.:.:.:.:.............,.,.: \n.......................... .:.,.:.:.,.::.:.:.................:.:.:.:.:.:.........:. . :. . ; ..I; .: \n.......... ...........i:..::. ........................................ ...................;,.; :,:..:.:..:.::....... \n::.:............. :,; ....... ..:: .:.,.:.:::::::: ....... .:.:.:.:.::: .. ............ :. ............. \n .:.:.::...:.:..:.::>:...... . .. .................................................................. \n ,j::j:$$Jy;;:; .:.:.:.:.j:.>:.: ::.:.... :.( g;.ji:;;;y;-i :i - .;+g ;::jjiG:$ : :.: ;. ::::::::q........:.....::.:.: \n I r ........... .. .::.:.> .. ........................ :..,..:.:::::::i.: :.:::::::.::::::::.: ...... \n::.:...:..I:..::..: ;>...;.:. .j,:.j. .ji:j.j:j::.j,::,.~:,:: / l::.> >j:.j..:..j; ::.:jj:::j,j,j:::j,: \n,,,,,,,,,,,:::j.:y::.: ..:.:.i.:;,(F: ;;:*,~$;,;;:.p,~,r@&#38;@;;;yj&#38; / f :j:.::.::.j.:,jT.j .:.:j:~~~~~~~ \nstore ....... ,\\,,,,,,,)j:,:..... j:,: .. .:,:j.::; :..:.:.:.:.:. ... :,,::,,,, ...,.-J-y :, ,::,.................... \n I ,.jfyj: j: :~,ii:ii,i::ii iii~~~~~~::,, j:j::j .,:.:.:, [j::j:,:jji:,:i;::;,;:,:;:::::::,::::::p, \n........ :..:: :.:I i:,:s:::; . .: .:::$ : : ::. j . .... I t:i.:i::il.ii.i::ii:~~.~~~~:~~.~ j,:,j;:;:f!;: \n. .,:,-I:., :,::.: .:. : -:,.>:,.y .,.::y:I pJ::yjs.:i i:.;;i:g.;jjj::jj .;,,: :. :.:,:::<j): .;;g g--J \n ..........  I [:i,ni: i.--,.::..:. .............,:,.: :.:: .. ::*::..:. (;-:;~~;;...ij:--_-*--~~~~~:,~::,~:,.....,.,.:..:.: \n....... ;.,: :<::,:i..........................................................................::..:; \ni.iI:;I;/ :.:.:.:.: .. ... ..I:)iigi.:i.i;:l: ........ c .:.,:  ..:::,:: : ........ ,::,,::,.,:,:, \n~::.:.~:..:.:::.;.$:,.>:+::,::,::,::,::,,:...... .:.::.:: .......... :.;::..I :.:: <:.;.:.:.:: :::j:::j:j:::: \n:.;:g:; :::,: . .::..::.:.:.:.:...:...:.:.. :5:::. Not soecified bv OMG Figure 2 Proposed architecture \nof the OMG Persistent Service Figure 2 depicts the structure of our implementation in terms of the OMG \nPersistence Service 4 Persistence: our design approach specification. As indicated in this figure, the \nthree layers of our architecture roughly correspond to the 4.1 Our design architecture major components \nof the OMG specification: the Our Persistence Service design architecture can be Typed Data Layer implements \nthe OMG Datastore divided into three layers. The Typed Data Layer is component, the Persistent Object \nLayer contains responsible for accessing datastores; its only purpose important sections of the OMG Protocol, \nand the is to provide a common interface for accessing Persistence Service Layer represents both the \nOMG various datastore types. The Persistent Object Layer Persistent Data Service and the OMG Persistent \nuses the underlying Typed Data Layer to save the Object Manager components. contents of individual persistent \nobjects. The Persistence Service Layer coordinates the previous 4.2 Typed Data Layer two to provide the \nclient with a simple-to-use This layer is embodied by the Store Access ModulePersistence Service interface \n(POM and, potentially, responsible for accessing data on external storage PO). media. The module implements \nstorage access primitives and is also capable of providing single level transactions necessary for crash \nrecovery support in higher layers. The module consists of four interfaces. The first two interfaces, \ncalled PZD and PIDFactory, introduce the notion of a unique persistent identifier. The other two, called \nDataStore and DataStoreFactory, provide a means of accessing the external store: module StoreAccess { \ninterface PID : CosPersistencePID::PID / }; interface PIDFactor) ( ); interface DataStore { ); interface \nDataStoreFactory { ]; The PZD interface masks the differences among various storage media classes, thus \ncreating the unified abstraction of a datastore containing records addressable by PIDs. The primitives \nare not aware of the structure of the data being saved -at this level, each record is simply a stream \nof bytes of an arbitrary length. Each PID instance denotes a single location in a store. The PZD interface \nis derived from the CORBA CosPersistencePID::PID base interface: intelface CosPersistencePID::PID / attribute \nstring datastore-type; string get_PIDString ( ); I; interface PID : CosPersistencePID::PID { void clear \n(in ulong location); oneway void remove ( ); boolean is-empty (in ulong location); void storeAt (in tBufjCer \nbuf, ulong location, in ulong offset); void restoreAt (inout tBuffer buj ulong location, in ulong offset); \nI; The storeAt method is used to put data into a store location denoted by the PID itself and by the \nlocation and oflet arguments, the restoreAt method is used to retrieve data in a similar manner. A location \ncan be emptied using the clear0 call, or tested whether it is empty using the is-empty0 call. As described \nin [OMG94b], PZD instances are created by an appropriate factory (once created, the PZD remains valid \nuntil a PID::remove() call is issued): interface PIDFactory ( PID get-root_PID ( ); PID create-unique_PID \n( ); PID create-PIDJrom-string (in string pid-string); needs to be taken to provide the client with \nmeans of obtaining the store contents. By a convention, the get-root-PID() method returns a single PID \ndenoting a special record to be used for the purpose of maintaining a directory of saved data. It is \nup to the client to specify a strategy for root record usage. An instance of the DataStore interface \nrepresents a datastore capable of saving and loading persistent data: interface DataStore / void trans-begin \n( ); void trans-commit ( ); void trans-abort ( ); PIDFactory get_PIDFactory ( ); void destroy-on-remove \n( ); I. As the Persistence Service is expected to be secure with respect to system failures, a certain \nlevel of fault tolerance is required from the underlying DataStore as well. Thus, a simple one-level \ntransaction mechanism is introduced -any changes made to the store contents after the trans.-begin0 call \ntake effect after the trans-commit0 call successfully returns. A particular DataStore implementation \nis always associated with a corresponding implementation of the PIDFactovy and PID interfaces. The store \nprovides its client with the means to obtain an appropriate PIDFactory by calling the PIDFactory::get-PIDFactory() \nmethod. The DataStore instances used by the Persistence service are manufactured by an instance of the \nDataStoreFactory: inteeace DataStoreFactory { DataStore open-DataStore (in string media-ID); 1; Once \ncreated, a DataStore object remains valid until a DataStore::remove() call is issued. Removing the store, \nhowever, does not destroy its data, unless the DataStore::destroy-on-remove() method has been called \nprior to DataStore::remove(). Usually, the DataStore interface will be used to save data of simple types, \ni.e. chars, integers, strings etc. In the first version of the implementation, a simple set of macros \ncan provide an interface to save simple data types easily and effectively. As PIDs are devised by the \nstore itself, extra care  4.3 Persistent Object Layer 4.3.1 Object Storage Module This module is responsible \nfor saving and loading the persistent attributes of an individual object and for exporting type and object \nreference information. As the only entity authorized to access a persistent object s internal state is \nthe object itself, the services of this module are exported in the form of methods provided by each persistent \nobject (2.4). Using the terms introduced in [OMG94b], this is a part of the proprietary protocol. The \nmodule contains one interface: module ObjectStorage { inter$ace POProtocol { ]; I: In order to be able \nto cooperate with the Persistence Service, an object needs to be equipped with the POProtocol interface: \ninterface POProtocol / TID get_TID ( ); void save-state (StoreAccess::PID pid); void load-state (StoreAccess::PID \npid); void get-references (out POList references); void set-references (inout POList references); The \nimplementation of the Persistent Data Service needs to be able to identify object classes at runtime. \nAs the C++ language does not provide runtime type information to the user, the POProtocol interface exports \nthe get-TID() method to do this -this method returns a user-supplied identifier representing the object \ns type. The save-state0 and load-state0 methods access the object s persistent state minus the references \nto other persistent objects. The get-references0 and set-references0 methods load and save the references \nto other persistent objects. When creating the list of references, the method get-references0 is expected \nto call the get-references0 methods of its direct superclasses (transitively); the list references is \nthus created from the contributions implied by the class hierarchy structure. Similarly, the dual method \nset-references0 calls the methods set-referencesO in the direct superclasses (transitively). Each such \ncall is supposed to eliminate the references it has processed from the list references passed to it as \nthe actual inout parameter. 4.3.2 Object Factory Module When loading dependencies of a persistent object \n(Section 3.1 .l), the Persistent Data Service implementation needs a way to create (rebuild) object instances \nto be filled with data from a datastore. Thus, a generic object factory is required to be capable of \ncreating an object instance of the type corresponding to a given TID. In practice, the generic factory \ninterface is more convenient for the purpose of obtaining specific object instances if it is extended \nby a mechanism for registering specific object factories.  4.4 Persistence Service Layer This layer \nincorporates both the Persistent Data Service and the Persistent Object Manager, both specified in [OMG94b]. \nAccording to the OMG specification, the main role of the Persistent Object Manager is to dispatch a function \ncall to the appropriate Persistent Data Service. Since we have only one Persistent Data Service instance, \nthe interface of the Persistent Object Manager simply passes all requests through to the instance. 4.4.1 \nReference Management Module As the implementation of the Persistence Service is expected to work with \nC++ objects as well as with CORBA objects, we can not use CORBA object IDS to identify object instances. \nWe need another kind of identifier associated with every persistent object to encode inter-object references \nin the persistent store. Fortunately, there is no need to devise another object identification mechanism. \nEach persistent object is already associated with its PID; all we have to do is to promote the PID to \nact as an object identifier in addition to a saved location identifier. In an application, we need to \nprevent the Persistence Service from creating several object instances using the same persistent object \nimage in the datastore. As a PID is used as a persistent object identifier, a list of <PID, object reference> \npairs maintained by the reference management module can be used to check whether an object has already \nbeen loaded. 4.4.2 Persistence Management Module This module is the heart of the Persistence Service \nfunctionality. It exports the following specialized version of the Persistent Data Service CosPersistencePDS::PDS \ninterface: module PersistenceManagement { intetiace PDS { PDS connect (in POProtocol object, in PID pid); \nvoid disconnect (in POProtocol object, in PID pid); void store (in POProtocol object, in PID pid); void \nrestore (in POProtocol object, in PID pid); void delete (in POProtocol object, in PID pid); I; I; As \ndefined in [OMG94b], the connect0 and disconnect0 method turn on and off the automatic updating of the \nobject s persistent state image in the datastore. In our implementation environment, the persistent data \nservice has no way of detecting the moments when an object is modified. Therefore we can only update \nthe object s image at system and transaction well-defined moments (Section 3.1 S). The Persistent Data \nService architecture dictates the necessity of saving and loading the entire transitive closure of an \nobject s dependencies at once. Thus, the store0 and restore0 methods process objects dependencies recursively. \nWhen saving an object, the Persistent Data Service starts by finding a PID associated with the object. \nA new PID is assigned if necessary. The object s TID is saved into a location associated with the PID; \nthe object is then asked to save its state into the location. A list of references to the object s dependencies \nis retrieved using the object s POProtocol interface. The object s dependen-cies are saved recursively \nand a list of PIDs of the dependencies is saved into the location. The process of loading an object is \ninverse to the process of saving. When a delete{) call is issued, an object is removed from the list \nof memory resident objects and its PID is destroyed using the PID::remove() call. This results in the \nobject being disassociated with its persistent state. The transient state of the object is not affected \nby this call.  4.5 Design evaluation We made many key design decisions based on limited environment \ncharacteristics (Section 2.1). Thus, anyone facing the task of designing a Persistent Object Service \nin a similar setting will probably ask similar questions as we did, and may therefore benefit from our \ndesign decisions (Section 3) and the proposed architecture (Section 4). In a different environment, the \ngeneral architecture and some design details may still remain useful, while permitting the developer \nto enhance certain environment-specific features. As an example, we have considered a system with runtime \ntype information support -in such a system, the POProtocol interface can be modified to exploit the type \ninformation, thus relieving the user of the necessity to specify the information by hand. Another example \ncould be a system with virtual memory support, in which memory management can be used to implement delayed \nloading of object dependencies, removing the necessity to process object graphs in one piece. At this \npoint, let us emphasize the key points of our solution with respect to its performance impact. The ability \nof the PID::storeAt() method to place data at the specified location in the Data Store extends the power \nof the data manipulation semantics by increasing the level of the data handling granularity, thus improving \nperformance in the cases when only a small subset of an object s attributes needs to be saved. The persistent \ndata is saved in an ad hoc format, taking advantage of the Data Store architecture and thus obviously \nachieving better average storing/restoring time compared to the Standard Stream Data Format (Section \n3.1.4). Also, explicit providing of the POProtocol::save-state0 and POProtocol::load-state0 methods gives \nthe user the possibility to save/load only the attributes that he/she considers necessary. On the contrary, \nif the direct access approach (Section 3.1.3) were employed, the Persistence Service would have to save/load \nalso non-persistent (limited lifetime, Section 3.1.1) attributes, such as large transient buffers and \nfile handles. On the other hand, the necessity to load all objects from the Data Store to memory at one \nshot reduces performance in the case that only a small subgraph of the whole transitive closure of dependencies \nis required by the application.  5 Reuse of other Object Services in the Persistence Service The specification \nof the Persistence Service discusses very briefly the reuse of other Object Services, particularly of \nthe Relationship Service, the Externalization Service, the Trading Service, and the Lifecycle Service. \nIn this section, we will focus on the issue of reusing the Relationship Service and the Externalization \nService as these services, if really reused, can cover substantial subtasks of the Persistence Service \nimplementation. 5.1 Reusing Relationship Service object can use the concept of propagation value. Finally, \nthe highest level provides the specific 51.1 Building Persistence Service over relationships Containment \nand Reference. For brevity,  Relationship Service we have found it useful to call an instance of the \nThe goal of the Relationship Service [OMG94e] is to Role, Relationship, or Node interfaces an r-object. \nprovide tools for operating upon abstractions based When the Relationship Service is employed, twoon \nentity relationship diagram concepts. According to types of inter-object references are to be considered: \nthe abstractions it provides, the Relationship Service inter-object references expressed by (i) standard \nis hierarchically structured into 3 levels. The base object references and (ii) via r-objects. The conceptlevel \nrelationship provides Role and Relationship as a of object dependencies (Section 3.1 .l) covers both \nmeans for organizing entity objects (related objects) types of inter-object references. However, whenin \nentity-relationship-diagram-like structures. The saving/loading dependencies, the two types must besecond \nlevel provides Node, Graph, and Edge which treated distinctly. can be used to create graphs of related \nobjects. It also provides Traversal and TraversalCriteria for Standard object references can be treated \nin the way traversing these graphs and, very importantly, described in Section 4.4.2, i.e. the transitive \nclosure defining subgraphs at runtime. A TraversalCriteria of dependencies is built by recursive evaluation \nof //Setting pointer to HisObject //Creating relationship with HisObject Object *MyObject,*HisObject; \nNode *MyNode; Object *HisObject; Role *MyRole,*HisRole; Relationship *MyRelationship; NamedRole NamedRoles \n(2); RoleFactory *MyRoleFactory; RelationshipFactory *MyRelFactory; MyObject->TheOther = HisObject; \nMyRole = MyRoleFactory->create-role (MyObject,IT-X); HisRole = MyRoleFactory->create-role (HisObjectJT-X); \nNamedRoles[O].name = strdup ( A ); NamedRoles[O].aRole = MyRole; NamedRoles[ l].name = strdup ( B ); \nNamedRoles[l].aRole = HisRole; MyRelationship = MyRelFactory->create (NamedRolesJT-X); NIT-x serves to \nsignal exception //Traversing pointer //Traversing relationship HisObject = MyObject->pointer; RelationshipHandle \n*MyRelHandle; MyRelHandle.the-relationship = MyRelationship; MyRelHandle.constant-random-id = MyRelationship->constant-random-id \n( ); HisObject = MyRole-> get-other-related-object (MyRelHandle, B ); igure 3 Increase in source code \ncomplexity dependencies. On the other hand, the transitive closure of dependencies based on r-objects \ncan be built by using the standard traversal mechanism offered by the Relationship Service. To preserve \nthe flexibility of defining subgraphs dynamically at runtime, the traversal process should use the user-defined \nTraversalCriteria object (Section 5.1.2). In order to meet the minimum requirements of the Persistence \nService (dependencies, transitive closure of dependencies) the Relationship Service implementation needs \nto fulfill at least the service levels 1 and 2 as defined in [OMG94e]. In the general case, the two \nreference types can coexist in the transitive closure of an object s dependencies. This even allows several \nsubgraphs defined by different TraversalCriteria objects to participate in one transitive closure. The \nPersistence Service should respect this flexibility in defining subgraphs. A way of specifying the TraversalCriteria \nin the Persistence Service interface must therefore be devised. Moreover, a mechanism has to be defined \nfor updating the graph s persistent state by combining the effect of several store operations upon subgraphs \nof the graph. A dual problem arises with combining the effect of several restore operations upon subgraphs \nof the graph. A detailed study of these issues is a subject of our current research. In theory, following \nstrictly the Bauhaus principle to achieve maximum Object Service reusability, all inter-object references \ncould be expressed by r-objects only. Even though this would unify the process of searching for the transitive \nclosure of dependencies, the overhead inherent in dereferencing only via r-objects would hardly be acceptable \n(Section 5.1.4). In addition, the Persistence Service needs to handle references among r-objects; to \navoid infinite recursion, these references cannot be expressed by using r-objects. Therefore, the Persistence \nService needs to handle standard object references in any case. 5.12 Making r-objects persistent In this \nsection, we will presume that both types of inter-object references coexist in the single transitive \nclosure of an object s dependencies. How the standard object references are to be handled was described \nin Sections 4.3 and 4.4. To make the transitive closure persistent, however, r-objects themselves have \nto be saved/loaded as well. Thus, the key focus of this section is how to save/load r-objects. As, in \nprinciple, the set of an object s attributes belonging to its persistent state is to be determined dynamically, \nsaving an r-object (particularly Role) as an ordinary object is not possible. This fact is implied by \nthe option to determine a subgraph by using TraversalCriteria. Consequently, to save r-objects, a special \ntechnique is necessary. In general, given a TraversalCriteria object and a root Node, the entire subgraph \nmust be traversed to determine its relevant nodes and edges. Thus, saving of the subgraph can take place \nonly after all the r-objects representing the subgraph are found. In the following we discuss the possible \napproaches to storing the r-object. The discussion is based on the sound assumption deduced from the \nOMG Relationship Service specification [OMG94e] that all Roles belonging to a given relationship maintain \na reference to the particular Relationship object and -vice versa -the Relationship object keeps references \nto all its Roles. As an aside, such a reference can be a CORBA-reference. These references will be saved \nin the Data Store as PIDs. There are basically three ways of storing those r-objects: a) References in \nboth directions are saved inside the persistent state of r-objects: Both role -> re- lationship and relationship \n-> role references are saved as PID s inside the persistent state of the Role and the Relationship objects, \nThis technique closely follows the principle of saving inter-object references as PIDs. b) References \nare stored outside the persistent state of r-objects: Information about references among Role and Relationship \nobjects is stored in a separate external data structure. At load time, references are reconstructed as \na part of the Relationship objects rebuilding process (e.g. supplying the information on related roles \nto the create0 method of RelationshipFactory). c) A mixture of approaches a) and b) is used. For example, \nrelationship -> role references can be stored inside the persistent state of Relationship objects, and \na list of the Relationship objects belonging to the graph is stored in a separate external data structure. \nAt load time, role -> rela- tionship references in roles are reconstructed via Role::link() calls. The \ndrawback of alternatives b) and c) is that they need a special mechanism to save references among r-objects. \nIn our view, alternative a) is the most convenient one. It scales well, and it treats r-objects in a \nsimilar way as ordinary objects. Naturally, in any case, each r-object has to support sto-ring/restoring \nof its persistent state. Thus, with respect to reusing, the Relationship Service must be modified accordingly. \n5.1.3 Advantages of reusing the Relationship Service Naturally, the inherent benefit of building the \nPersistence Service upon the Relationship Service is reusing existing CORBA code. However, the domi-nant \nadvantage of employing the Relationship Servi-ce in the Persistence Service is the power and flexibility \nof graph traversing operations. In the Relationship Service, it is very easy to make changes to searches \nfor dependencies or groups of objects simply by changing the Traversalcriteria object. For that purpose, \na set of specialized Traversalcriteria objects (e.g. those traversing only certain edge types) may be \npredefined. Furthermore, each Traversal-Criteria object can be parametrized dynamically at runtime. To \nbenefit from this type of flexibility, the Persistence Service must provide its client with a way to \nspecify a Traversalcriteria object to be used when traversing the persistent object graph. This can be \nachieved by enriching either the POProtocof or the PDS interface, the first option being more in line \nwith the CORBA Persistence Service concept. In principle, the Persistence Service employing TraversalCriteria \nstores/restores a subgraph of a given etteamable 1 object B INT2 graph. This raises the issue of what \nthe semantics of combining subgraphs when storing/restoring parts of the given graph should be (subject \nto our current research). 5.1.4 Disadvantages of reusing Relationship Service Compared to the standard \nC++ dereference mechanism, using the Relationship Service may slow down the application considerably, \neven if local caching of relationship attributes (e.g. via smart proxies in Orbix [ORBIXb]) is used. \nWhen using the Relationship Service, dereferencing an object pointed to by a relation implies calling \nRole::get-other-rela-ted-object(). The get-other-related-object0 method requires the Role object it is \nto be invoked upon and the Relationship object to be traversed. Thus the operation of dereferencing an \nobject involves at least one RPC call with at least two CORBA objects being passed as an argument and \na result. In fact, the overhead of evaluating dependencies by means of the Relationship Service may not \nbe critical for the Persistence Service itself, as most of the time is spent operating with the Data \nStore. On the other hand, forcing the client to use the Relationship Service inside its applications \nis hard to advocate, as it makes the application program more complex in terms of both source code and \ntime complexity. The increase in source code complexity is obvious from the example in Figure 3. According \nto our measurements made on a Sun Figure 4 Simple Externalization Control Figure 5 Compound Externalization \nControl Flow Flow SPARCstation 4 with Solaris 5.4 and Orbix 2.0, a cdl of a remote object s method with \nempty body with the target object being dereferenced via Role::get-other-related-object{) is two to three \ntimes slower than calling the remote method directly. The results are even more convincing with the caller \nand the target object being in the same address space. Using get-other-related-object0 of a server in \nthe same address space slows the program down approximately 1000 times; using a server in a separate \naddress space yields 10000 times slower execution. The Relationship performance can be substantially \nimproved by reference caching, but even then there is a significant difference between the two cases. \n 5.2 Reusing Externalization 5.2.1 Relevant concepts of the Externalization Service The Externalization \nService supports the sequential saving/loading of objects from/into the CORBA environment. Externalized \nobjects are saved on media in the canonical form described by [OMG94g]. Thus the Externalization Service \nallows an easy transfer of objects between different CORBA architectures. The Externalization Service \nis based on three interfaces: Stream, StreamlO, and Streamable. The Stream interface represents a sequential \nstream of externalized objects. It is associated with the StreamlO interface which provides the low-level \ntool for externalizing an object s attributes. The code describing how an object saves/loads its state \n(using the methods of StreamlO) is wrapped inside the methods of the Streamable interface. The object \nis required to inherit from Streamable to make itself externalizable: Streamable::internalize_from-stream \n(Stream(O) Streamable::externalize~to~stream (StreamlO, FactoryFinder) The methods take as a parameter \na reference to a Stream10 object. This mechanism provides for dynamic binding between the object and \nthe stream which externalizes the object s attributes. An object uses methods of the Stream10 interface \nsuch as StreamIO::writeJoat ( oat) or Stream:: write-string (String) to save its attributes of simple \ndata types into the stream represented by a Stream object. The Stream10 interface also provides two methods \nfor saving dependencies referenced from the object: write-object0 and write_graph(). The write-object0 \nmethod is used when the relations among objects are not represented via the Relationship Service. The \ntypical control flowis illustrated in Figure 4. The write-graph0 method is called when the Relationship \nService is used to represent relations among objects (Figure 5). An Externalization Service capable of \ncooperating with the Relationship Service is called the Compound Externalization Service [OMG94g]. To \ndistinguish the two cases, the non-compound Externalization Service will be referred to as the Simple \nExternalization Service. All in all, it should be emphasized that the Stream interface inherently implies \na sequential way of saving and loading objects to and from external media.  5.2.2 Simple Externalization \nas a POS protocol As stated in the Externalization Service specification [OMG94g, Section 3.11, the Externalization \nService has been designed to be able to integrate with the Persistence Service as a specific POS protocol. \nAt the same time, the reference to the Externalization Service in the Persistence Service specification \n[OMG94b, Section 6.171 reads: I ... the Persistence Service could use this service as a POS protocol. \nHowever, neither of the OMG documents goes any further in specifying how the Externalization Service \nmight be reused in the Persistence Service. In fact, being inherently sequential at a higher level of \nabstraction, the Externalization Service can support the Persistence Service, inherently based on random \naccess to individual objects, only in a very special case -when a Persistence Service implementation \ndoes not support fine-grained updating of parts of an externalized transitive closure of dependencies. \nOn a lower level of abstraction, the Externalization Service interfaces Streamable and Stream10 are not \nnecessarily limited to sequential access to externalized objects. In principle, it would be possible \nto implement a specialized Stream10 interface, such that the Streamable interface could be used to access \nthe persistent state of an object without imposing the limit mentioned above. Although not strictly adherent \nto the semantics described in [OMG94g], the specialized Stream10 interface implementation could make \nit possible to reuse the Streamable code in a client application. The following might be a fragment of \nthe specialized implementation: Figure 6 Externalization Service General Architecture void StreamIO. \n.:write-char (char chr) { Buffer bfr; bfr->data = &#38;chr; bfr->length = bfr->maximum= sizeoflchar); \n CurrentPID->storeAt (bfr,O,CurrentOffset); bfr->data = NULL;  1; void StreamIO:: write-object (Streamable \nobj) 1 RelatedObjectsList->add (obj); ); The write-char ( ) method stores chr at the Data Store location \ndefined by CurrentPID. Repeated calls of wri te-ob j ec t ( ) build a list of dependencies to be exploited \nafter the exrernalize_ro_stream() method returns (during the evaluation of the transitive closure of \ndependencies). 5.2.3 Advantages of reusing the Simple Externalization Service Both the Persistence and \nthe Externalization Services have a similar task: to store/restore the client object s attributes. This \nsimilarity can be exploited by using the Streamable interface in place of POProtocol, thus preventing \na duplication of functionality. This is Figure 7 Reusing Externalization in Persistence Service particularly \nadvantageous when the client already uses the Externalization Service and is going to employ the Persistence \nService. In such a case, the Persistence Service can use the existing Streamable implementation provided \nby the client s objects without any change; thus the Persistence Service does not need any additional \nprotocol. 52.4 Disadvantages of reusing the Simple Externalization Service Although exploiting the Streamable \ninterface makes it possible to reuse parts of the client object s code, a large part of the Externalization \nService remains unused. Obviously, the parts of the Externalization Service which reflect its sequential \nnature cannot be readily reused. 5.2.5 Reusing the Compound Externalization Service So far, we have \nrelied on calling the Streamable interface with an instance of a specialized StreamIO class specified \nas an argument; thus, the interface provided a direct access to an object s attributes without a need \nto change the Streamable implementation. This trick, however, cannot be used with the Relationship Service \ns nodes, as the Compound Externalization Service uses a single externalize-node0 call to externalize \nthe node together with its roles. As all the roles adjacent to a node do not necessarily belong to the \nsubgraph defined by the graph traversal process run by the Persistence Service, the roles not belonging \nto the subgraph do not have to be externalized. Thus, the standard implementation of the CosCompoundExternalization::No-de::externalize-node(} \nmethod prevents the Persistence Service from processing only the roles belonging to the subgraph. Providing \na specialized implementation of the externalize-node0 method could remedy this problem; this change, \nhowever, cannot be incorpora- ted into the Externalization Service in such an elegant and flexible way \nas was the case with StreamlO.    6 Conclusion The paper is based on our experience with designing \nand implementing the CORBA Persistence Service. As OMG leaves large parts of the Persistence Service \nfunctionality unspecified, several very important issues, such as handling of related objects and interfacing \nwith a datastore, remain unresolved in the specification. Therefore, in Section 3, we focused on analyzing \npossible techniques related to these issues and particularly to the crucial trade-offs we have had to \nface in our implementation. Our particular solution to these issues was also described in Section 3. \nThe core functionality of our Persistence Service implementation is located in the Persistent Data Service \nlayer, with the low level support routines split between the Persistence Object and Store Access layer. \nIn Section 5 we provided the reader with relevant details and design evaluation. Interesting lessons \nhave been learned when evaluating the prospects of reusing the Relationship Service and the Externalization \nService (Section 5). As for related objects, we have found it very important to treat both standard references \nand references defined by the Relationship Service in a unified way with respect to an object s dependencies. \nTherefore, in Section 3.1 .I, we introduced the concept of dependencies as the set of all the objects \ntargeted by a reference of either type from a given object. Further, we concluded that reusing the Relationship \nService does not grant any significant profit to the Persistence Service implementation alone; the user, \nhowever, may benefit from the ability of the Persistence Service to understand and process the graphs \ndefined via r-objects of the Relationship Service. Thus, if the Relationship Service is implemented in \na CORBA, the Persistence Service implementation should support both types of inter-object references; \nat the same time, to avoid endless recursion, the references among r-objects must be treated in a special \nway in the Persistence Service. For this purpose, guidelines for making the Relationship Service s r-objects \npersistent were articulated in Section 5. Being in principle sequential at a higher level of abstraction, \nthe Externalization Service can support the Persistence Service, which in contrast is inherently based \non random access to individual objects, only in a very special case as discussed in Section 5.2. However, \non a lower level of abstraction, the client part of the Externalization Service implementation can be \nexploited by the Persistence Service to access object s persistent state with no need to equip client \nobjects with additional methods used by the PDS protocol. To reuse the Compound Externalization Service, \nan enhancement of its specification is necessary (Section 5.2.4). Acknowledgements The authors of this \npaper would like to express their thanks to Jaromir Adamec and Christian Bat for many valuable comments \nand suggestions. Also, Dugan Balek, Antonin BrEak, Michal FadljeviE, Michael Grof, and Nguyen Duy Hoa \ndeserve special credit for taking part in the implementation. Finally, the authors are grateful to Adam \nDingle and Camie Bates for proofreading the text. References [AJJ+92] P. Amaral, C. Jacquemot, P. Jensen, \nR. Lea, and A. Mirowski: Transparent object migration in COOL-2. In Proceedings of Workshop on Dynamic \nObject Placement and Load Balancing in Parallel and Distributed Systems, ECOOP 92, Utrecht, June 1992 \n[AJL92] P. Amaral, C. Jacquemot, and R. Lea: A model for persistent shared memory addressing in distributed \nsystems. Technical report TR-92-52, Chorus systemes, 1992. [ALJ92] P. Amaral, R. Lea, and C. Jacquemot: \nImplementing a modular object oriented operating system on top of CHORUS. In Proceeding s of OpenForum \n92, Utrecht, November 92. [A931 P. Amaral: PAS: A Framework for studying the implementation of multiple \naddress spaces. PhD thesis, Universite Paris VI, 1993. [Ben951 R. Ben-Nathar: CORBA: A guide to Common \nObject Request Broker Architecture. McGraw-Hill. 1995. [Bou94] F. Bourdon: The Automatic Positioning \nof Objects in COOL V2. In Proceedings of 14th ICDCS, Poznan, IEEE Computer Society Press, June 1994. \n[CBHS93] V. Cahill, S. Baker, C. Horn, and G. Starovic: The Amadeus GRT -Generic Runtime Support for \nDistributed Persistent Programming. Proceedings of OOPSLA 93, pages 144- 16 1, ACM Press, 1993. [CDK94] \nG. Coulouris, J. Dollimore, and T. Kindberg: Distributed Systems. Concepts and Design. Addison-Wesley, \n2nd Edition, 1994. [CTP96] T. L. Casavant, P. Tvrdfk, F. P&#38;i1 (Editors.): Parallel Computers: Theory \nand Practice. IEEE Press, 1996. [DdBF+92] A. Dearle, R. di Bona, J. Farrow, F. Henskens, A. Lindstrom, \nJ. Rosenberg, and F. Vaughan: Grasshopper: An orthogonally Persistent Operating System. Computer Systems, \n7(3), pages 289-3 12, 1992. [DOM93] DOME User Guide, Release 2.2, Object- Oriented Technologies Ltd., \n1993. [DRH+92] A. Dearle, J. Rosenbergr, F. Henkens, F. Vaughan and K. Maciunas: An Examination of Operating \nSystem Support for Persistent Object Systems. In Proceedings of the 25th Hawaii International Conference \non System Services, 1, IEEE Computer Society Press, 1992. [Ede92] D. R. Edelson: Smart Pointers: They \nre Smart but They re Not Pointers. UCSC-CRL-92-27, Baskin Center for Computer Engineering &#38; Information \nSciences, University of California, Santa Cruz, 1992. :FS94a] P. Ferreira and M. Shapiro: Garbage Collection \nand DSM Consistency. In Proceedings of the first symposium on the Operating Systems Design and Implementation \nConference, Monterey, November 1994. :FS94b] P. Ferreira and M. Shapiro: Garbage Collection of Persistent \nObjects in Distributed Shared Memory. In Proceedings of the Persistent Object Systems, Tarascon, September \n1994. [FS96] P. Ferreira and M. Shapiro: Larchant: Persistence by Reachability in Distributed Shared \nMemory through Garbage Collection, In Proceedings of the 16th International Conference on Distributed \nComputing Systems, Hong Kong, IEEE Computer Society Press, May 1996. [HCF+95] D. Hagimont, P. Y. Chevalier, \nA. Freyssinet, S. Krakowiak, S. Lacourte, J. Mossiere, and X. R. de Pina: Persistent Shared Object Support \nin the Guide System -Evaluation and Related Work. In Proceedings of the 9th Annual Conference on 00 Programming \nSystems, Languages, and Applications, Portland, pages 129-144, October 1994. [HK93] G. Hamilton and \nP. Kougiouris: The Spring nucleus: A microkemel for objects. In Proceedings of the 1993 Summer Usenix \nconference, Cincinnati, June 1993. [HKPCS95] J. Hans, A. Knaff, E. Perez-Cotes, and F. Saunier: Arias: \nGeneric Support for Persistent Runtimes. In Proceedings of European Research Seminar on Advances in Distributed \nSystems, L Alpe d Huez, pages 220-226, April 1995. [HP951 HP ORB Plus 2.0, URL: http//www.hp.com [HMA90] \nS. Habert, L. Mosseri, and V. Abrossimov: COOL: A Kernel Support for Object-Oriented Environments. In \nProceedings of the Joint ECOOP/OOPSLA Conference, Ottawa, pages 269-277, October 1990. [IBM94a] IBM Corp. \nSOMobjects Developer Toolkit Users Guide, Version 2.1, 1994. [IBM94b] IBM Corp. SOMobjects Developer \nToolkit Programmers Reference Manual 2.1, 1994. [KN93b] Y. A. Khalidi and M. N. Nelson: The Spring Virtual \nMemory System. Technical Report SMLI-93-9, Sun Microsystems, 1993. [KPT95] J. Kleindienst, F. PlaSiI, \nP. Turna: Implementing CORBA Persistence Service, TR 117, Charles University Prague, Department of . \nSoftware Engineering, 1995. [KPT96] J. Kleindienst, F. PlaSil, P. Turna: CORBA and its Object Services. \nInvited Paper, SOFSEM 96, Springer LNCS (to appear), 1996. [LXC93] S. B. Lim, L. Xao, and R. Campbell: \nDistributed Access to Persistent Objects. Technical report, University of Illinois at Urbana- Champain, \nDept. of Computer Science, 1993. [MA901 R. Morrison, M. P. Atkinson: Persistent Languages and Architectures. \nIn Proceedings of the Security and Persistence, J. Rosenberg and J. L. Keedy(ed.), Springer, pages 9-28, \n1990 [Mey88] B. Meyer: Object-Oriented Software Construction, Prentice Hall, 1988. [MoZa95] T.J. Mowbray, \nR. Zahavi: The Essential CORBA, J. Wiley &#38; Sons, 1995. [MCCK94] R. Morrison, R. C. H. Connor, Q. \nJ. Cutts, and G. N. C. Kirby: Persistent Possibilities for Software Environments. In Proceedings of the \nThe Intersection between Databases and Software Engineering, IEEE Computer Society Press, pages 78-87, \n1994. [Mu1941 S. Mullender, editor: Distributed Systems. Addison-Wesley, 2nd Edition, 1994. [NE0961 \nSolaris NE0 Operating Environment, Product Overview, Part No. 95392-003, Sunsoft Inc, March 96. [OMG92] \nObject Service Architecture, OMG 92-8-4, 1992. [OMG92a] Kala-Standardizing on Object Meta Services, \nBrief Response to the OMG services, Request for Information, OMG 92-4-5, 1992. [OMG94a] Common Object \nServices Volume I, OMG 94-1-1, 1994. [OMG94b] Persistent Object Service Specification, OMG 94-10-7, 1994. \n[OMG94d] Universal Networked Objects, ORB 2.0 RFP Submission, OMG 94-9-32, 1994. [OMG94e] Relationship \nService Specification, Joint Object Services Submission, OMG 94-5-5, 1994. [OMG94fl Compound LifeCycle \nAddendum. Joint Object Services Submission. OMG 94-5-6, 1994. [OMG94g] Object Externalization Service. \nOMG 94- 9-15, 1995. [OMG95] Common Object Request Broker Architecture and Specification Revision 2.0, \nOMG 96-3-4, 1995. [OMG95b] Object Services RFP 5. OMG TC Document 95-3-25, 1995. [OMG95c] Object Management \nArchitecture Guide, 3rd Edition, R.M. Soley (Editor), John Wiley &#38; Sons, 1990. [ORBIXa] Orbix, Programmer \ns Guide. IONA Technologies Ltd. Dublin, 1994 [ORBIXb] Orbix, Advanced Programmer s Guide. IONA Technologies \nLtd. Dublin, 1994. [PG95] F. PlaSil, M. Grof: An Overcoming of Inheritance Anomaly, TR 95-05-02, Department \nInformatique, Institut national des Telecommunications, Evry, France, 1995. [PSWL94] G. D. Parrington, \nS. K. Shrivastava, S. M. Wheater, and M. C. Little: The Design and Implementation of Arjuna. BROADCAST \nProject deliverable report, 4, University of Newcastle upon Type, October 1994. [PT95] F. PlaSil, P. \nTurna: Memory Management in Spring. TR 95-05-03, Department Informatique, Institut national des Telecommunications, \nEvry, France, 1995. [RHB+90] J. Rossenberg, F. Henskens, A. L. Brown, R. Morrison, and D. Munro: Stability \nin a Persistent Store Based on a Large Virtual Memory. In Security and Persistence, Workshops in Computing, \npages 229-245. Springer, 1990. [SDP93] S. K. Shrivastava, G. N. Dixon, and G. D. Parrington: An Overview \nof the Arjuna: A Programming System for Reliable Distributed Computing, IEEE Software, 8(l), pages 63-73, \nJanuary 1991 [SF941 M. Shapiro and P. Ferreira: Larchant-RDOSS: A distributed shared persistent memory \nand its garbage collector. In Proceedings of the 9th Workshop on Distributed Algorithms (WADG), Le Mont \nSaint Michel, Sept. 1995. [SG91 a] S. S. Simmel and I. Godard: The Kala Basket: A Semantic Primitive \nUnifying Object Transactions, Access Control, Versions, and Configurations. In Proceedings of OOPLSA \n91, pages. 230-246, 1991. [SGH+91] M. Shapiro, Y. Gourhant, S. Habert, L. Mosseri, M. Ruffin, and C. \nValot: SOS: An Object-Oriented Operating System -Assessment and Perspectives. Computing Systems 2(4), \n1989. [Sha94a] M. Shapiro: A Binding Protocol for Distributed Shared Objects. In Proceedings of the International \nConference on Distributed Computing Systems (ICDCS) , Poznan, June1994. [Sim92] S. S. Simmel: Providing \ncommonality while supporting diversity. Hotline on Object-Oriented Technology, 3( lo), Aug. 1992. [SKW92] \nV. Singhal, S. V. Kakkad, and P. R. Wilson: Texas: An Efficient, Portable Persistent Store. In Proceedings \nof the Persistent Object Systems, San Miniato, A. Albano and R. Morrison (Editors), Springer, pages 1 \nl-33, 1992. [Str94] D. Stroustrup: The C++ Programming Language. 2nd Edition. Addison-Wesley, 1995. [SUZ96] \nM. Steinder, A. Uszok, K. Zielinski: A Framework for Inter-ORB Request Level Bridge Construction. In \nProceedings of the IFIP/IEEE International Conference on Distributed Platforms, Chapman &#38; Hall, Dresden, \npages 86-99, 1996. [Tan951 A. S. Tanenbaum: Distributed Operating Systems. Prentice Hall, 1995. [VD92] \nF. Vaugham and A. Dearle: Supporting Large Persistent Stores using Conventional Hardware. In Proceedings \nof the Persistent Object Systems, San Miniato, A. Albano and R. Morrison (Editors), Springer, pages 35-53, \n1992. \n\t\t\t", "proc_id": "236337", "abstract": "In this paper, the authors share their experiences gathered during the design and implementation of the CORBA Persistent Object Service. There are two problems related to a design and implementation of the Persistence Service: first, OMG intentionally leaves the functionality core of the Persistence Service unspecified; second, OMG encourages reuse of other Object Services without being specific enough in this respect. The paper identifies the key design issues implied both by the intentional lack of OMG specification and the limits of the implementation environment characteristics. At the same time, the paper discusses the benefits and drawbacks of reusing other Object Services, particularly the Relationship and Externalization Services, to support the Persistence Service. Surprisingly, the key lesson learned is that a direct reuse of these Object Services is impossible.", "authors": [{"name": "Jan Kleindienst", "author_profile_id": "81100578586", "affiliation": "Institute of Computer Science, Czech Academy of Sciences, Pod vod&#225;renskou v&#277;&#382;&#237;, 180 00 Prague 8, Czech Republic", "person_id": "PP39049365", "email_address": "", "orcid_id": ""}, {"name": "Franti&#353;ek Pl&#225;&#353;il", "author_profile_id": "81100509688", "affiliation": "Charles University, Faculty of Mathematics and Physics, Department of Software Engineering, Malostransk&#233; n&#225;mest&#237; 25, 118 00 Prague 1, Czech Republic and Institute of Computer Science, Czech Academy of Sciences, Pod vod&#225;renskou v&#277;&#382;&#237;, 180 00 Prague 8, Czech Republic", "person_id": "P86387", "email_address": "", "orcid_id": ""}, {"name": "Petr T&#367;ma", "author_profile_id": "81100395651", "affiliation": "Charles University, Faculty of Mathematics and Physics, Department of Software Engineering, Malostransk&#233; n&#225;mest&#237; 25, 118 00 Prague 1, Czech Republic", "person_id": "PP15031228", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236351", "year": "1996", "article_id": "236351", "conference": "OOPSLA", "title": "Lessons learned from implementing the CORBA persistent object service", "url": "http://dl.acm.org/citation.cfm?id=236351"}