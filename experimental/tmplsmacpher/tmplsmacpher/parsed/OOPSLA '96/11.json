{"article_publication_date": "10-01-1996", "fulltext": "\n A Situated Evaluation of the Object Management Group s (OMG) Object Management Architecture (OMA) Evan \nWallace National Institute of Standards and Technology Manufacturing Engineering Laboratory Gaithersburg, \nMD, 20899, USA wallace@cme.nist.gov (301) 975 3520 (301) 258 9749 FAX Abstract It has been difJicult \nto objectively assess the real value or maturity of the Object Management Group s Object Management Architecture \n(O&#38;IA). While experience reports have appeared in the literature, these have focused more on the \nfunctionality of the end-system than on systematically exploring the strengths and weaknesses of rhe \nOMA, and providing practical guidelines on the effective use of the OMA for speci$c s&#38;ware-engineering \nproblems. In this paper we describe a case study in the use of the OMA to integrate legacy software components \ninto a distributed object system. We assess the OMA in this problem context, and indicate strengths and \nweaknesses of the specification and current implementations. We extrapolate our experience to a broader \nclass of component-based sofhvare systems, and recommend an architectural strategy this class of systems. \nfor the effective use of the OMA to Keywords:SoftwaEvaluation. re Architecture, OMA, Tec hnology 1. Introduction \n The Object Management Architecture (OMA) [l] con-tinues to attract attention, with numerous implementations \nof the OMA common object request broker architecture (CORBA) emerging in the commercial marketplace. \nHow does an organization decide whether to embrace this tech- 1. We use CORBA to refer to only the message \nbroker component of the OMA; we use OMA to refer to CORBA plus additional OMA services. permission to \nmake digital/hard copy of part or all of this work for Personal or ctasroom use is granted without fee \nprovided that copies are not made or distributed for profit or commercial advantage, the qopyright notic% \nthe title of the publication and its date appear, and nOtI@ !s given that copying is by permission of \nACM, Inc. To COPY othewse, to republis) to post on sewers, or to redistribute to lists, requires prior \nspecific Permission and/or a fee. COPSLA 96 CA, USA (D 1996 ACM 0-89791-788-x/96/001 0...$3.50 Kurt C. \nWallnau Software Engineering Institute Carnegie Mellon University Pittsburgh, PA, 15213, USA kcw@sei.cmu.edu \n(412) 268 3265 (412) 268 5758 FAX nology? The stakes are high since the OMA can have a pro- found influence \non the design and implementation of application software. A technology assessment strategy that can identify \nthe value-added of a new technology, and simultaneously reveal how best to exploit this value added, \nis therefore of great potential value. We have applied one such evaluation technique to the OMA [2]. \nWe describe the evaluation technique as situ-ated because it describes the technology being evaluated \nin terms of peer technologies (in order to identify the new value-added features of a technology, i.e., \nits feature delta), and then places the feature delta into specific usage contexts. The technology is \nthus situated in both the tech- nology marketplace and in the problem domain in which the technology \nis to be evaluated. There are many ways of evaluating feature deltas. In some cases it is possible to \nisolate and benchmark elements of the feature delta, as illustrated by the comparative bench-marking \nof CORBA and RPC [3]. However, the lack of a specific problem context within which to evaluate the benchmarks \ncan limit the effectiveness of this form of eval- uation. To overcome this limitation, experimentally-focused \ncase studies can be undertaken that apply the fea- ture delta to representative problems of an application \ndomain. Such case studies can be particularly fruitful as in addition to providing a problem context \nfor evaluating a technology, then can also provide a wealth of practical experience in how to best apply \na feature delta to these problems. In this paper we describe one experimentally-motivated case study \nin the use of the OMA to an increasingly-impor- tant problem domain: the integration of component-based \nsystems (systems comprised of stand-alone, indepen-dently-executing software packages). Section 2 provides \nbackground information on the engineering problems inherent to component-based systems. Section 3 provides \n 168 further background on the manufacturing domain, and on the legacy collection of computer-aided design \nengineering (CADE) components that we modernized into a distrib- uted, object-based system. Section 4 \ndescribes the impact of the OMA on the architecture of the modernized system, and Section 5 continues \nthe discussion of the impact of OMA at a more detailed implementation level. Finally, Section 6 states \nour conclusions about the OMA based on this experiment. 2. Background: Component-Based Systems While \nall (real) systems are composed of components, in our usage component-bused systems are comprised of \nmul- tiple software components that: . are ready off-the-shelf, whether from a commercial source (COTS) \nor re-used from another system; . are self-contained and possibly execute independently; will be used \nas is rather than modified; must be integrated with other components to achieve required system functionality; \nand, have significant aggregate functionality and complexity. Examples of component-based systems can \nbe drawn from many domains, including: computer-aided software engineering (CASE), design engineering \n(CADE) and manufacturing engineering (CAME); office automation; workflow management; command and control, \nand many others. 2.1 Architectural Mismatch: The Core Issue In contrast to the development of other \nkinds of systems where system integration is often the tail-end of an imple- mentation effort, in component-based \nsystems determining how to integrate components is often the only latitude designers have. In our evaluation \nwe were interested in whether the OMA suggested solutions to the core engineer-ing problems in the integration \nof component-based sys-tems: architectlcrul mismatch [4]. The term architectural mismatch refers to \nthe problem that components always embed assumptions about their intended operational context, and these \nassumptions often conflict with assumptions made by other components. For example, a component that uses \na graphical human inter-face as the sole means of executing component functions has embedded an assumption \nthat will render it unusable in a system that must run in batch mode-unless this mis-match can be removed \nby some form of component adap-tation. Scores of other kinds of mismatches are commonplace involving, \ne.g., multi-users support, resource management, and security. The term architectural mismatch implies \nmore than just mismatched component assumptions: it also implies that mismatches can arise between components \nand a soft- ware architecture [5]. The general consensus is that soft-ware architecture deals with high-level \ndesign patterns1 for structuring and expressing system designs. A sense of what is meant by high level \nis that these patterns are often expressed in terms of components, connectors and coordi- nation. Components \nrefer to units of functionality*, con-nectors refer to the integration of components, and coordination \nis the manner in which components interact at run-time. Architectural mismatches can arise that inhibit \ncomponent integration and coordination. Not all architectural styles are equally-well suited to a specific \ndesign problem. Many factors can influence the selection of a style-functional requirements, quality \nattributes (e.g., modifiability) and a priori design commit-ments (e.g., distributed system). Thus, a \ngiven set of soft- ware components may be assembled into a number of architectural styles, and may exhibit \ndifferent kinds of architectural mismatches in each architectural setting. This suggests a reference \nmodel for describing the engineering practices involved in assembling component-based sys- tems. as denicted \nin Figure 1. adaptation to composition into a selected I&#38; off-the-shelf qualified adapted components \ncomponents components components igure 1. Architectural Assembly of Component! ;1 The vertical partitions \ndepicted in Figure 1 describe the central artifact of component-based systems-the compo-nents-in various \nstates: Off-the-shelf components have hidden interfaces (using a definition of interface that encompasses \nall potential interactions among components, not just an application programming interface[6]). 1. The \nterms styles and idioms are synonymous with patterns.  2. The component-based definition of this term. \nwhich is the one used here, is more a restrictive form than that used in software architecture literature. \n  Qualified components have discovered interfaces so that possible sources of architecture mismatch \nhave been identified. This is (by the definition of interface) a partial discovery: only those interfaces \nthat mismatch an architectural style or other components are identified. Adapted components have had \ntheir architectural mismatches ameliorated. The figure implies a kind of component wrapping, but other \napproaches are possible (e.g., the use of mediator agents). Assembled components have been integrated \ninto an architectural infrastructure. This infrastructure will support component assembly and coordination, \nand differentiates architectural assembly from ad hoc glue.  2.2 A Component-Based System Evaluation \nContext for the OMA Although the reference model depicted in Figure 1 is simplistic, it is nonetheless \nsufficient to suggest the follow- ing questions for an evaluation of the OMA: Are certain architectural \nstyles suggested by the OMA? If yes, does the OMA provide an adequate mechanism for implementing these \nstyles? Are other mechanisms in addition to the OMA (as currently specified) required? Does the OMA introduce \npotential sources of architectural mismatch beyond those implied by architectural style? If yes, do these \nresult from the OMA specification, or peculiarities of commercial implementations of the OMA? Are some \nkinds of components more readily adaptable to the OMA than others? If yes, what are the characteristics \nof components that make them more adaptable? What adaptation mechanisms work best with the OMA? The case \nstudy described in detail, below, provided sig-nificant insight in answering these questions.  3. Background \non CADE While the nature of component-based systems provides a needed backdrop for focusing the OMA \ntechnology eval-uation, the problem setting must be completed with requirements stemming from an application \ndomain, and those stemming from the particular problem being addressed. We selected the manufacturing \ndomain as a basis for this case study. 3.1 A Manufacturing Domain of the Future The manufacturing processes \nrequired to move a prod- uct from concept to realization are many and varied, and often require the application \nof highly-specialized skills and computing resources. Job scheduling, shop layout, and manufacturability \nanalysis are examples of such skills that ari supported by software technology. In many cases these specialized \nskills are relatively independent of the underly- ing application domain-manufacturability analysis tech- \nniques for automotive parts and washing machine parts are quite similar. Some believe that a breakthrough \nin manu- facturing efficiency can be achieved if these horizontal skills can be freed from their existing \nvertical market confinements, and allowed to develop in the free-market. The challenge is how to re-assemble \nthese horizontal specialties into virtual enterprises, i.e., otherwise indepen-dent manufacturing companies \ncollaborating in vertical manufacturing enterprises. Virtual enterprises are a means of supporting the \nflexible combination of the skills and tools from many highly-specialized companies; from this, faster \nmarket response time, reduced time-to-market, and increased manufacturing quality can he achieved. How-ever, \nin addition to regulatory and business-model chal-lenges of virtual enterprises, additional technology \ninfrastructure is needed that will support: the integration of separately-developed, specialized, computer-aided \nmanufacturing technologies; geographical distribution of computing resources, and support for heterogeneous \ncomputing environments; fee-for-service brokering of computer-based services to enable competition for \nspecialized tools and skills. In short, virtual enterprises in an increasingly special-ized manufacturing \nworld will rely more and more upon information technology such as supported by distributed object technology. \nHowever, the existing investment in computer-aided technology will need to be preserved, and adapted, \nto exploit distributed object technology. 3.2 A Legacy Manufacturing System We needed a legacy manufacturing \nsystem for modem- ization to distributed object technology that would be sim- ple enough to quickly prototype, \nyet sophisticated enough to constitute a reasonable test of the OMA. As a domain model of manufacturing \nactivities suggests [7], there are many subdomains that might provide for fertile hunting. From this \nmodel we determined that the design engineering activity was suitably focused and automated. Design engineering \ninvolves modeling and simulating part designs to test the performance of parts under certain expected \nreal-world use conditions. This analysis can be used to determine the adequacy of a part design for per- \nforming a function, to optimize a part design, and to lower the cost and/or weight of a part while preserving \nconti-dence in its performance. A diverse range of software com-ponents have been developed that support \ndesign engineering, providing the basis for a OMA case study. 170 Problem Definition Visualization Exodus \nII Data . coordinates . connectivity . load locations . results variables structural dynamics analysis \nSimulation/Analysis Figure 2. SEACAS Tool and Data Relationships The Sandia National Laboratory Engineering \nAnalysis Code Access System (SEACAS) provided us with a repre- sentative set of design engineering components. \nSEACAS supports functions such as problem definition, simulation, analysis, and visualization (see Figure \n2). Sandia has devel- oped many components in each functional category, reflecting both the diversity \nof analysis problems being addressed and the evolving sophistication of design engi-neering methods. \nFor our case study, we selected a core set of SEACAS components that could represent a single thread \nthrough a design engineering scenario. The general usage scenario for these tools is as shown in Figure \n3, which uses a process description formalism sim-ilar to IDEF-0: the bubbles represent activities; data \ninput appears on the left of activities, and data output appears on the right; mechanisms appear on the \nbottom of activities; and, control flow appears on the top of activities. The con-trol flow end-user \nwhich would appear on each activity is omitted from Figure 3 for simplicity. Following Figure 3, an analyst \nuses FASTQ to produce a discretized model of the part to be analyzed. The visual- izing tool BLOT then \ncan be used to produce a graphical representation of the model for inspection by the analyst. Based on \nthat inspection the analyst either re-runs FASTQ to correct the model or feeds the model to GEN3D to \nextrude the two-dimensional model into the third dimen-sion. Another inspection/correction iteration \nmay occur for the resulting three-dimensional model before the model is fed to the analysis tool. One \nor more analyses may be con- 1. A two- or three-dimensional mesh that models the contours of a solid. \n ducted, with results evaluated via the visualization tool or through inspection of other JAS3D output \n(not illustrated). As suggested by Figure 3, the process can be highly itera- tive, reflecting a process \nof convergence on a suitable design. iterate I I I Figure 3. Components and End-User Scenario As Figure \n2 points out, many of these tools make use of a common data format (Exodus-II). This is an important \nproperty that greatly simplified the prototyping effort. However, there is more to component integration \nthan data interchange. For example, in the scenario described above end-users are responsible for launching \ntools (often with personalized scripts), managing tool output (in private directories), and preparing \nthe output of one tool for use as input to another (sometimes with manual application of fil- ters since \nnot all SEACAS tools use the same version of the Exodus data format). In effect, the end-user is the \nsystem integrator, continually exposed to all of the low-level details and technology dependencies exhibited \nby the SEACAS components, and the environments in which they operate.  3.3 Objectives for OMA-Based \nModernization From the particular requirements of SEACAS, we deter- mined that the case study should \nevaluate the use of the OMA to integrate a legacy collection of design engineering tools in order to: \npresent a uniform virtual environment for end-users that would reflect the nature of the analysis activity \nand not the idiosyncrasies of specific SEACAS components; support wide-area distribution of SEACAS services \nwhile maintaining control over the software that provides these services (some of which contain classified \nalgorithms); deliver reasonable, usable and predictable performance to end-users who are otherwise accustomed \nto using computer services in local area network settings. These requirements extend and refine those \nof the under- lying manufacturing application domain (Section 3.1).  4. A Distributed Object Architecture \nfor the SEACAS Components The modernization objectives (cited above) can be thought of as quality attributes+xternally-visible \nsystem properties that deal with issues other than functionality. The significance of quality attributes \nis that it has been demonstrated that the top-level design, or architecture, of a system is the key factor \nleading to the satisfaction (or lack) of these non-functional requirements [S]. Thus, for our evaluation \nof OMA we needed to determine how well it addressed architecture-level issues inherent to component- \nbased systems (Section 2.2) as well as how it addresses component-based systems that exhibit these quality \nattributes. In the following discussion it is useful to bear in mind that the purpose of the case study \nwas an evaluation of the OMA feature delta. If the design problem is viewed strictly in terms of the \nfour components integrated, then there were undoubtedly simpler design solutions to achieving the lim- \nited objectives outlined in Section 3.3. However, viewing the design problem as a representative one \nin a broader class of problems led us to design solutions that required a more elaborate use of the OMA, \ni.e., use of the OMA fea-ture delta. 4.1 Architectural Overview We quickly discovered that the OMA suggested \nan architectural approach that makes extensive use of the OMA object model and the CORBA interface definition \nfeatures; we were pleased to discover that this feature delta beyond the more primitive form of an RPC \ninterface defi-nition had such significance. This central role for an object model in a component-based \narchitecture is illustrated in Figure 4, which depicts a top-level view of the prototype architecture. \n This architecture can be described in terms of how it supports integration-the core design activity \nin compo-nent-based systems (architectural mismatch is the inhibitor of integration). One useful way \nto think of integration is as a relationship between two integrated entities, where the relationship \nhas four aspects: control, data, process and presentation [9][ 101: Control integration describes how \ncomponents make requests of (or invoke) each other s services. Data integration describes how components \nmake data available to each other. 4Bremote users lightweight graphical end-user interface 81 scripting \nlayer logical object layer physical component layer Host 1 Host 2... Host N 10 corba object ---+ relationship \n component /\\fi invocation a Figure 4. Architectural Overview Process integration describes what end-user \nprocess is supported by, or activates, the integration relationship. Presentation integration describes \nhow end-users interact with the endpoints of an integration relationship. The end-user layer addresses \npresentation and process integration through interactive, graphical client interface, and scripting logic \nthat sequences and controls the execu-tion of remote services. This layer will not be described in detail; \nwe view it as an application layer supported by the architecture. However, we note that abstraction mis-matches \nbetween the scripting language and the object model were introduced by our use of TCLTTk; a mecha- nism \nsuch as Java, which is object oriented, would address this problem. The physical component layer addresses \nthe run-time aspects of the SEACAS components, and various platform dependencies. At this level a number \nof sometimes subtle interactions between components, operating system and CORBA implementation arose. \nThese detailed implemen-tation issues are discussed in Section 5. The logical object layer addresses \ndata and control inte-gration. Interestingly, we discovered that the OMA sug-gested an architectural \nstyle to address these aspects that in effect blends two different styles: a repository style for data \nintegration and a structural style for control integration. The remainder of this section will describe \nthese styles and how they were realized with the OMA.  4.2 Object Layer as Data Repository The repository-style \narchitecture is characterized by a central data repository that is used as a principle means for components \nto coordinate their execution and share results. Numerous examples of repository-style architectures \nhave been seen in the computer-aided software engineering (CASE) domain [ll]; examples in the manufacturing \ndomain are also emerging [12]. The repository-style architecture is motivated by two factors, both of \nwhich are relevant to SEACAS: 1. The data artifacts that are manipulated by software components are key \nassets that must be managed. Mechanisms for access control, versioning, backup and recovery, transactions, \netc., are all important for the effective management of data assets. 2. The structure of data can be \nquite complex, with different kinds of data related in a complex network of aggregation and dependency \nrelationships. Mechanisms for schema definition and evolution, query, and navigation are all needed to \nmanage this complexity.  The two OMA services that we found to be most impor-tant for the SEACAS repository \nwere relationships and persistence. Relationships were used to define links between various kinds of \nSEACAS artifacts while persis-tence allowed networks of object instances to persist beyond user sessions. \nWe used the object-oriented features of the CORBA interface definition language (IDL) to model SEACAS \narti-facts in a class hierarchy, and used relationships to express the derivation history from one class \nof artifact to another. A simplified object model is depicted in Figure 5, whi f, relationship Figure \n5. Object Types and Relationships shows the major object types and their relationships to each other \nand to the SEACAS components. For example, exodus2d (a two-dimensional mesh) inherits (and defines its \nown) operations and attributes from the exodus abstract superclass; exodus2d functionality is implemented \nby FASTQ; and, it participates in a 1:many relationship with exodus3d objects to indicate that a single \ntwo-dimensional mesh can be extruded into several three-dimensional meshes. The net effect of populating \nthe logical object model layer with instances of these object types and relationships is to create a \ndistributed object repository of SEACAS objects. On the surface, this would seem to indicate that the \nOMA provides a good foundation for repository-style architectures, and in the large this is true. Upon \nlooking deeper, however, there are limitations to the OMA specifi-cation and commercial implementations \nof the OMA that may effect the scaleability and robustness of OMA-based data repositories. With respect \nto commercial implementations, vendors are not required to implement any of the OMA services beyond CORBA. \nThe object request broker we used did not support the relationship service, and it supported a non-standard \npersistence service. These missing services resulted in a substantial increase in programming complex \nity and a decrease in application functionality and robusr ness. For example, we implemented relationships \nas object valued attributes (object references); this required addi-tional encoding of dependency management \nlogic within exodus methods, and introduced subtle interactions with the persistence mechanism, which \nitself was quite com-plex. Also, the bi-directionality, arity and object type con-straint checking, and \ncompound object operations that would have been available with OMA relationship services were too expensive \nto implement. Issues are also raised by the specification of the OMA services. For example, the underlying \nOMA assumption that object services can be separately specified and individ- ually implemented is a cause \nfor concern. There are, for example, specification and implementation dependencies between persistence \nand transactions, naming and security, and relationships and life cycle. While the OMA specifica-tion \nis sensitive to some of these dependencies, many more dependencies exist than can be conveniently specified \nor even anticipated. The PCTE specification-a quasi-object based repository technology, is a broad indication \nof the level of complexity involved [13]. Other specification issues that will inhibit the development \nof robust OMA-based repositories include: the lack of various data man-agement services (e.g., schema \ndefinition, administration, object ownership and sharing), and optimistic design assumptions about object \ngranularity and network/inter-process communication performance. However, while the OMA does have limitations \nregard-ing data management services, component-based systems might not, in general, require repositories \nthat implement a full range of database management functionality. For our case study even simple OMA \nservices-had they been available-would have sufficed. Thus, we concluded that . Object services are \nboth useful and essential for component-based systems integration; and, the OMA provides (barely) sufficient \ndata management services, provided the designer is not over-exuberant.  4.3 Object Layer as Structural \nArchitecture The repository style architecture addresses issues of data and object management, but it \ndoes not address how the functionality of components (such as the SEACAS compo-nents) is mapped to persistent \nobjects, nor how these objects interact at run-time (the coordination model). There are two overall approaches \nto addressing these issues-a functional approach and a structural approach. The functional approach \nis by far the predominant approach to component-based systems. This approach defines component interfaces \nin terms of their specific functionality. Functional architectures are good for describing system functionality \nand for integrating specific functionality but are weak at addressing the run-time prop-erties of a design. \ne.g., throughput, latency and reliability. The structural approach has emerged as the study of software \narchitecture has intensified. Rather than defining component interfaces in terms of functionality, structural \nstyles define interfaces in terms of the role a component plays in a coordination model-a model that \ndescribes how the components interact. A simple illustration of a struc-tural style is UNIX pipes and \nfilters; more sophisticated illustrations include structural models for flight simulators [14], and the \nSimplex architecture for evolvable depend-able real-time systems [ 151. The structural approach has become \nmore popular recently because it yields architec-tures that, by definition, support analysis of dynamic \nsys-tem properties. CORBA IDL supports functional and structural styles equally well. However, we discovered \nthat the structural approach is particularly well-suited to component-based systems; further, it is also \nsuggested by the OMA. This con-clusion can be demonstrated by a discussion of the simpli- fied structural \narchitecture depicted in Figure 6, which illustrates the key coordination interfaces of one type of SEACAS \nobject . The focus of attention for this discussion is on the structural model in Figure 6. 1. The interfaces \nof other SEACAS objects are nearly identical. The essence of the SEACAS coordination model is that objects \nare data managers that are either in a consistent or an inconsistent state. A consistent object is one \nwhose input attribute is consistent with the EXODUS data that has been derived from this attribute through \nthe execution of a SEACAS component. The input attribute for the SEACAS object depicted in Figure 6 is \nanalysis, which is a string containing simulation instructions for the finite element analyzer. Clients \nof an object can test whether an object is consistent using the consistent? probe, and can re-establish \nconsistency by using the update method. The update method is non-blocking; clients can determine if an \nupdate is still in progress by using the done? probe. Clients can examine the results of an update in \ntwo ways: through a view method on the SEACAS object (not illustrated), or through an event queue. The \nview method can only be used on a consistent object, while the event queue can be used while an update \nis in progress (an object is not consistent until the update has successfully completed). /f 1 Figure \n6. Structural Architecture (Overview) Our conclusion that structural styles are particularly well-suited \nfor component-based systems and for the OMA is based on these two observations: 1. Explicitly representing \nthe coordination model via object interfaces addresses ambiguous and restrictive run-time semantics inherent \nin the OMA specification as described below. 2. Coordination-focused object interfaces help identify \nareas of architectural mismatch, and suggest re-usable adaptation techniques for different kinds of mismatch. \n The first is discussed here, the second in Section 5. The decision to make update a non-blocking method \nrepresents a departure from more straightforward use of 174 CORBA features for client-side concurrency. \nTypically, pure clients will use CORBA s dynamic invocation inter-face (DII)2 if they do not wish to \nblock on a remote method; alternatively, multi-threaded clients could create a separate thread for each \nblocking method. Implementing a non-blocking update method appears to restrict the client s options-so \nwhy do it? There are two reasons. The first reason is that finite element analysis may con-sume anywhere \nfrom a few seconds to several days of wall clock time. Relying on a synchronous connection over a wide-area \nnetwork for such durations will do violence to our reliability requirements-a momentary network failure \nwould cause an update to fail. Making the update method a oneway call-another CORBA mechanism-is inadequate \nbecause this mechanism does not permit clients to be noti- fied of the many exceptional circumstances \nthat might indi-cate a problem with the update prior to the actual execution of SEACAS component services. \nThus, had the update method been implemented using default CORBA synchro-nous logic, clients would have \nbeen forced to use the DII to achieve the desired level of system reliability. This is an unfair burden \nto place on clients because of the additional overhead forced on the client to dynamically build all \noper- ation requests; also, the architecture should ensure the reli- ability regardless of the form of \nclient interface used. The second reason concerns the way the CORBA basic object adaptor (BOA) addresses \nserver-side concurrency, i.e., how to achieve concurrent execution of the methods of one or more objects \nwithin a server process. Clearly, serv-ers that can exploit thread libraries will have a ready-made mechanism; \nhowever, the Object Management Group is loath to build implementation dependencies such as this into \ntheir specifications. Thus, the BOA specifies activation policies that (in increasing concurrency) associate \na server process with: classes of objects ( shared activation policy); individual objects ( un-shared \nactivation policy); or, individual methods ( per-method activation policy). By implementing update as \nnon-blocking we subverted the BOA activation policy, since non-blocking semantics requires de facto concurrency \nof object implementations. However, the un-shared and per-method policies require interprocess communication \n(IPC) for objects to invoke each other s methods. Certainly this kind of coupling is to be expected where \ndifferent object types are closely in a 1. Pure clients are applications using but not containing any \nobjects; object implementations can also be clients, but are not purely clients. 2. The DII provides \nmechanisms for deferred synchro- nous communication, aka asynchronous polling.  class hierarchy, as \nis the case with SEACAS objects (refer to Figure 5). While it is possible to specify multiple sets of \ninterfaces for objects-those for clients and private inter-faces for friends, this can require substantial \nadditional coding and in any event does not address the cost of the IPC or the creation of separate processes, \nespecially in the case of per-method activation. Also, implementations of CORBA treat activation policy \nas a kind of configuration option for object implementations: different installations of the services \nmay choose different policies. Again, such important system properties should be reflected in the architecture \nof the system, not in implicit coordination semantics and configuration options. A final point on this \ntopic is that these design and imple- mentation decisions could have been taken even in a func- tional \nstyle, i.e., had the update method been a direct interface to a specific SEACAS function. However, the \nstructural approach makes these coordination model deci-sions explicit in the object interface-there \nis no mistaking the assumptions concerning concurrency in the objects described in Figure 6. Moreover, \nthe structural approach addresses the coordination model the same way for each SEACAS component, as is \nevident in their common inter-faces; this would be far less obvious in a functional style. 5. Component \nAdaptation Issues As illustrated in Figure 6, there are several distinct rela-tionships between the SEACAS \ncomponents and the struc- tural architecture. Each of the connections between component and structural \nmodel indicate an interaction between the architecture and a component, and hence an area of potential \nmismatch. For example, from Figure 6, the consistent? probe should return true if and only if the SEACAS \ncomponent executed properly. A failure could result from either a semantic fault or a system fault. SEACAS \nassumes that end-users will determine the success of an operation by reading diagnostic output; this \ndoes not match with the structural model, which assumes a more automated approach. System faults, such \nas a component crash, can also arise. SEACAS assumes such crashes will be evident since the end-user \nwill have directly invoked the compo- nent; this also does not match with the structural model, which \nhides the component and its invocation. Removal of these and other kinds of mismatches requires some \nform of component adaptation. In the above example, the diagnostic output needed to be parsed to determine \nif, and what kind, of semantic fault arose (if any, since the same output stream was used to report success \nand failure): also, the component process needed to be monitored for exceptional conditions and exit \ncodes. Each of the other component-to-architecture connections depicted in Figure 6 exhibited such mismatches \nthat needed to be resolved by component adaptation code (the wrap- pers in Figure 6)-there were other \nareas of mismatch that were not depicted in the figure for reasons of clarity. The term wrapper is very \nmisleading-the term implies that component adaptation is accomplished through action taken on the component \nitself, i.e., encapsu- lating the component behind a veneer that presents an alter- native, translated \ninterface. However, this is just one approach to removing architectural mismatch. A better way of thinking \nof component adaptation is to observe that the mismatch occurs between two entities, in this case a com- \nponent and an architecture, and that adaptation can occur at either or both ends of the relationship, \nor in the middle via an intermediary agent. We do not have a complete model of adaptation tech-niques. \nHowever, the structural model did suggest a catego- rization of types of architectural mismatch that \ncould arise, and our implementation provided at least one technique for addressing these mismatches. \nThis confirms our earlier assertion that structural styles help focus attention on key areas of architectural \nmismatch. Also, since the structural model is quite general-there is little about Figure 6 that implies \ndependencies on the manufacturing domain-there is reason to hope for the development of architecture-spe- \ncific adaptation techniques. Unfortunately, while well motivated, this last hope may be thwarted by the \ncomplexity of the adaptation, especially where the adaptation involves the architecture-side. We discovered \nthat architecture-side adaptation is character-ized by a thorny tangle of interactions between the coordi- \nnation model, OMA semantics, vendor-specific features of the object request broker (ORB), operating system \nprimi-tives, and characteristics of the components themselves. While a complete exposition of these issues \nwould require a code walk-through, a high-level overview of one exam-ple may reveal the nature of this \ncomplexity. We take the accumulation of incremental output on an event queue, as illustrated in Figure \n6, as our example. Recall that the decision to make the update method non-blocking in effect mandated \nthat the object server support concurrent execution of object services, and that we could not use the \nBOA per-object or per-method activation policy for reasons discussed earlier. To this we add that the \nORB implementation we used for the case study did not support multi-threaded servers. As a consequence, \nwe were forced to implement our own homegrown concurrency service. Those familiar with UNIX systems programming \nwill not be surprised by our approach to this problem, and Figure 7 depicts the key elements of our solution. \nThe core of the solution makes use of UNIX asynchro-nous I/O and sockets. The idea is to have the main \nevent Object Server r----------- -7 I UNIX pmcess-_I 4 h Figure 7. Component Adaptation (Detail) l,I: \n, _i m call) for activity on any number of socket connections, and when activity is detected on a socket \ninvoke a callback pro-cedure that is appropriate to the kind of activity detected (e.g., data available). \nWith this background in mind, the solution works as enumerated in the figure: 1. A client inititiates \nconnections to objects via sockets. These sockets are installed as they are created into the asynchronous \nevent handler so that client requests for object services can be detected and dispatched. This installation \ndepends upon ORB-vendor connection management services that allow the detection of new client connections, \nand the use of sockets. 2. A client request for an update is detected as activity on the client socket. \nThe callback routine registered to handle this activity calls the ORB-vendor s implementation of the \nstandard BOA object event handling method; this is portable across ORBS, provided the ORB allows server \ndevelopers to access these routines (which is not true of one ORB we have used). 3. In response to the \nupdate request the SEACAS component is launched (viafork and exec(j). Different kinds of components may \nrequire different approaches to this step, for example the component could be a server that must be connected-to \nrather than launched. The process identifier of the launched tool is installed in the process harvester, \nand signal handlers are established to monitor the state changes of the process. 4. The component will \nbegin writing its incremental output to a data file; component-side adaptation ensured that the file \nname was unique to each invocation. A monitor process is launched to detect state changes to the output \nfile and report them to a socket established in step 3 for this purpose; this requires delicate timing \nlogic because  the data file will appear an indeterminate time after the SEACAS component is launched. \n5. Incremental output is detected on the data harvester socket. A callback procedure is invoked by the \nevent manager to parse the data, since only portions of the data file that are being generated by the \nSEACAS component are of interest for the purposes of observing the progress of the finite element analysis. \nThe parsed data is enqueued on an event channel. 6. The process harvester detects the termination of \nthe SEACAS component, and determines whether the termination was normal or exceptional (needed to determine \nif the object is in a consistent state). Upon termination of the SEACAS component, the data monitoring \nprocess is terminated, sockets are closed, and I/O callbacks removed from the event handler.  This illustration, \nwhile gory in detail, serves to highlight a number of important points. First, adapting architectural \nmismatch may require low-level, intricate code. Tech-niques for making this process rational and repeatable \nwill contribute greatly both to programmer productivity and system reliability: most of the problems \nour prototype experienced involved low-level adaptation code. Second, vendor-specific ORB features have \nan overwhelming influ-ence on adaptation techniques. Another commercial ORB we have used requires completely \ndifferent, but not less complex, adaptation approaches. Last, the possibility of developing architecture-specific \nadaptation techniques may be hampered by intricate ORB, tool, and operating system dependencies. However, \nthis is only an issue if por- table object implementations is desired-and the OMA does not support object \nimplementation portability in any event.  6. Conclusions about the OMA In Section 2.2 we posed a specific \nrange of questions that the OMA evaluation would answer. First, the OMA does indeed suggest a particular \narchitectural style, which we referred to as a repository style in this paper. However, we are skeptical \nthat the key OMA services (e.g., persistence, relationship, transactions and relocation services, to \nname just a few) will be sufficiently well-integrated and func-tional to implement robust distributed \ndatabase manage-ment functionality. Despite this skepticism, we found the OMA to be sufficiently flexible \nand expressive to describe a wide range of other styles, including hybrid styles that make selective \nuse of OMA distributed object management services. Second, we found that the OMA does introduce its own \nforms of architectural mismatch. This is to be expected- most legacy components will not have been designed \nto operate within the context of a distributed object model. On the other hand, we were surprised at \nhow sensitive our com- ponent adaptation tactics were to specific ORB features. In our prototype, vendor-specific \nfeatures played a key role, in part because the vendor did not provide standard imple-mentations of needed \nOMA services (e.g., persistence). Vendor-specific features also played a role in low-level code that \ndealt with mapping between the operating system process model and the OMA object model. Last, although \nwe were not able to identify component characteristics that are useful for OMA-based integration beyond \nthe usual characteristics of integrable components (open interfaces, etc.), we can state categorically \nthat devel- opers should be prepared to write low-level, and often intri-cate code to enable the ORB \nto launch and manage the execution of legacy components. Not only must the compo- nent s implicit coordination \nmodel be reconciled with the OMA object model and the application architecture, but the mapping of the \noperating system process model (and other platform-specific resource models) to the OMA object model \nmust also be addressed. Despite the somewhat negative tone of these conclu-sions, we are overall quite \nimpressed with the applicability of the OMA to distributed component-based systems. However, while the \nOMA does make the building of dis- tributed component-based systems easier, it does not make the hard \ndesign and implementation decisions involved in such systems disappear. Nevertheless, we believe the \nOMA provides sufficient mechanisms and latitude for system designers to address many of these difficult \nchallenges. 7. References PI Object Management Architecture Guide, Revision 2.0, Second Edition, OMG \nTC Document 92.11 .l, Object Management Group, 492 Old Connecticut Path, Framingham, MA, 01701. PI Brown, \nA., Wallnau, K., A framework for systematic evaluation of software technologies IEEE Software, September \n1996. [31 Wallnau, K., Rice, J., ORBS In the Midst: Studying a New Species of Integration Mechanism , \nin Proceedings of International Conference on Computer-Aided Software Engineering (CASE-95), Toronto, \nCA, July 1995. [41 Garlan, D., Allen, R., Ockerbloom, J., Architecture Mismatch: Why Reuse is so Hard \n, IEEE Software V12, #6, ~~17-26, November 1995. VI Garlan and Shaw, An Introduction to Software Architecture, \nin Advances in Software Engineering and Knowledge Engineering, vol. I, World Scientific Publishing Company.1993. \n[61 Pamas, D., Information distribution aspects of design methodology, in proceedings of IFIP conference, \n1971, North Holland Publishing Co. [71 Barkmeyer, E., SIMA Reference Architecture Part I: Activity Models, \nNIST Technical Report (in publication). 181 Abowd, G., Bass, L., Kazman, R., Webb, M., SAAM: A Method \nfor Analyzing the Properties of Software Architecture, in Proceedings of the 16th International Conference \non Software Engineering, Italy, May 1994. [9] Thomas, I., Nejmeh, B., Definitions of tool integration \nf.or environments, IEEE Software 9(3), pp. 29-35, March 1992. [lo] Wasserman, A., Tool integration in \nsoftware engineering environments, in E Long, ed., Sofmare Engineering Environments, Lecture Notes in \nComputer Science 467, pp. 138-l 50, Springer-Verlag, Berlin, Germany, 1990. [ 1 l] Principles of CASE \nTool Integration, Alan Brown, et. al., Oxford University Press, 1994, ISBN O-19-509478-6. [ 121 Brown, \nA., Judd, R., Riddick, E, Architectural issues in the design and implementation of an integrated toolkit \nfor manufacturing engineering in the International Journal of Computer Integrated Manufacturing. [13] \nWakeman, L. and Jowett, J., PCTE: The Standards for Open Repositories , Prentice-Hall, 1993. [14] Structural \nModeling: An Application Framework and Development Process for Flight Simulators, Gregory Abowd, Bass, \nL., Howard, L., Northrop, L., SE1 Technical Report, CMU/SEI-93-TR-14, 1993, Software Engineering Institute, \nCarnegie-Mellon University, Pittsburgh, PA. [15] A Software Architecture for Dependable and Evolvable \nIndustrial Computing Systems, Sha, L., Rajkumar, R., Gagliardi, M., SE1 Technical Report, CMU/SEI-95TR-005, \n1995, Software Engineering Institute, Carnegie-Mellon University, Pittsburgh, PA.   \n\t\t\t", "proc_id": "236337", "abstract": "It has been difficult to objectively assess the real value or maturity of the Object Management Group's Object Management Architecture (OMA). While experience reports have appeared in the literature, these have focused more on the functionality of the end-system than on systematically exploring the strengths and weaknesses of the OMA, and providing practical guidelines on the effective use of the OMA for specific software-engineering problems. In this paper we describe a case study in the use of the OMA to integrate legacy software components into a distributed object system. We assess the OMA in this problem context, and indicate strengths and weaknesses of the specification and current implementations. We extrapolate our experience to a broader class of component-based software systems, and recommend an architectural strategy for the effective use of the OMA to this class of systems.", "authors": [{"name": "Evan Wallace", "author_profile_id": "81100271007", "affiliation": "National Institute of Standards and Technology, Manufacturing Engineering Laboratory, Gaithersburg, MD", "person_id": "P79874", "email_address": "", "orcid_id": ""}, {"name": "Kurt C. Wallnau", "author_profile_id": "81100197234", "affiliation": "Software Engineering Institute, Carnegie Mellon University, Pittsburgh, PA", "person_id": "P163879", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/236337.236353", "year": "1996", "article_id": "236353", "conference": "OOPSLA", "title": "A situated evaluation of the Object Management Group's (OMG) Object Management Architecture (OMA)", "url": "http://dl.acm.org/citation.cfm?id=236353"}