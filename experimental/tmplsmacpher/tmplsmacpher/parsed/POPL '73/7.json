{"article_publication_date": "10-01-1973", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1973 ACM 0-12345-678-9 $5.00 ON THE DEFINITIONAL METHOD OF STANDARD PL/I David Beech IBM United Kingdom \nLaboratories Hursley Park Winchester, England ABSTRACT formal style as the normal working mode In order \nto define the semantics of of expression. Indeed, if the meta- PLI1 in a form which is both precise and \nlanguage to be discussed below is con\u00adreadable, a method of definition has been sidered to have any merit, \nit now developed which employs an abstract machine deserves a more leisurely fundamental operating on \ntree-structured data. The analysis than it has so far received in classes of trees involved are defined \nby the somewhat strenuous circumstances of formal grammars, while the algorithms its development. governing \nthe behaviour of the machine are One hesitates to admit to an expressed semi-formally in prose. This \naudience assumed to be largely autocratic algorithmic metalanguage is itself intended that this metalanguage \nis the work of a to have largely intuitive semantics, but committee. The American National these are \nmade more precise by an indica-Standards Institute and the European tion of how they could be supported \nat a Computer Manufacturerst Association have lower level of detail within the abstract had committees \nworking jointly since 1969 machine. to produce a PL/I Standard, and this effort is now nearing completion. \nA 1. Introduction significant part of the work over the last two years has been devoted to the con- This \npaper describes a method of prog\u00adstruction of an appropriate metalanguage, ramming language definition \nwhich aims to and the writing of the whole definition close the gap that has often seemed to exist in \nthis form. This has been carried out between theory and practice in this field. under the aegis of the \nAd Hoc Editing The method has been applied to an un-Committee of ANSI X3J1 and the 1/0 Sub\u00ad deniably \nlarge and realistic language, Group of ECMA TCIO, in two complete F L/1, with the intention of combining \niterations over BASIS/1, the draft docu\u00ad precision and completeness with lucidity ment specifying the \nlanguage [11. The and naturalness. An optimistic analogy general approach was to plan a thoroughly might \nperhaps be drawn with informal systematic definition, but only to mathematics -some formalism is used \nwhere introduce formalism where it would aid justified, and is supplemented by dis\u00adthe reader -who might \ntypically be ciplined prose. A more thorough forma\u00adassumed to consult a Standard to seek a lization might \nhelp to correct mistakes \u00adprecise answer to a difficult question, might even reveal paradoxes -which \nhad without wishing to undergo lengthy been overlooked at the intuitive level, education in an unfamiliar \nformal system. without necessarily supplanting the semi\u00adRather than discuss the fine points of metalanguage \ninterminably, the committees arrived at a first approximation and cast the definition accordingly in \norder to discover which of the fine points were OY practical significance and what unforeseen problems \narose. The second iteration then converged relatively quickly towards reso\u00ad lution of the outstanding \ndifficulties. 2. Characterization of method The method employed may be characterized as mechanical, rather \nthan translational or axiomatic. That is to say, it defines the semantics of the language by showing \nhow its interpretation would affect the workings of an abstract macnine. A trans\u00adlational approach [2] \nwould merely map the given language into another language, such as the lambda-calculus or a particular \nmachine language, whose semantics were assumed to be already known. Unless the source and target languages \nare very similar, this thoroughgoing trans\u00admogrification tends to make the semantics obscure to non-specialists. \n(Although we do perform some initial translation of PL/1, this is only an intermediate stage in the working \nof the abstract machine, and the target languaRe of the translation is more akin to a canonical form \nof the source language than to a language whose semantics immediately leap fl?om the page). An axiomatic \napproach [3,41 would specify the semantic effect of statements in the language in terms of transformations \nof axiomsasserted about the state of the comp\u00adutation. One aim here is to abstract the intent of a program \nf rom the mechanism used to achieve it, although there seems to be an underlying notion of a machine \nstate in the rudimentary form of a list of variable names and values in examples so far attempted. It \nis too early to say how successful this method will be as a des\u00adcriptive tool. However, another aim aPpears \nto be prescriptive, in requiring languages to adapt to the capabilities of this method. There are virtues \nin such discipline,although the dangers of exclusivity are apparent from the jingle of Ronald Knox: I \nam the Master Of this College And what I don?t know Isntt Knowledge. The abstract machine we have intro\u00adduced \nis capable of performing certain algorithmic operations on information held in tree structures. Wnen \noffered the representation of what purports to be a program, it will determine whether it is valid, and \nif so will execute the program to cause certain changes in the state of the machine. The point of view \nhere is that a programming language is designed to control the operation of real machines, and that one \nshould be able to display the semantics most effectively by making a recognizable model, especially as \none moves away from the purely compu\u00adtational aspects via operations on storage and data sets to the \nmore explicit interaction with the environment which one currently tends to reacn in separate control \nlanguages. The realization of the definition consists in ensuring certain correspondences between the \nreal machine and the definitive one, and in the case of PL/I these are limited to exhibiting faithfully \nthe logical struc\u00adture and state changes of the data sets. The intent of a program is taken to be the \naccomplishment of such externally accessible results, and whether or not an implementation closely models \nstate changes of other parts of the abstract machine in order to achieve these is its own affair. ~lotationally, \nthe balance of pre\u00adcision and humanity that transpired was that Yormal grammars were specified for the \ntree structures employed, while the algorithms operating on them were written in the prose equivalent \nof a progranuning language. This algorithmic metalanguage is in principle mechanizable in a similar way \nto parts of the language being defined, but this mechanization has not been shown. It is assumed that \na more intuitive definition of the metalanguage, supported by an indication of a possible mechanization, \nwill suffice. Clearly one is close to a semantic situation familiar in natural language where a lang\u00aduage \nis defined in a subset of itself, so that even ii one avoids blatant circu\u00adlarity, there is at the very \nleast an intricately spun conceptual web in need of painstaking analysis. This deeper theo\u00adretical aspect \nof the current metalang\u00aduage still needs to be explored. It one seeks to place the method in a historical \ncontext, the authors would be honoured to be considered in the line of descent from Algol 60, but would \nnot risk so controversial a claim. The similarity lies in the formal grammars and informal semantics, \nand the extension beyond this is in making explicit the executing machine with its more complex state. \nBy comparison with the Vienna defin\u00adition of PL/I [51, this method is very similar in overall structure \nbut has two main differences. Firstly, the Vienna metalanguage was completely formalized and was deliberately \nat a more primitive level so that an operation of the machine was not a sequential algorithm but was \na function defined as a single conditional expression. Secondly, the abstract mach\u00adine for the PL/I Standard \nhas been des\u00adigned to be quite realistic in terms of the structure of the in~ormation in its state and \nthe notion of multiple proc\u00adessors operating, possibly in parallel, on a shared memory. There is some \nsimilarity with the A1.gol 68 definition in the metalanguage for interpreting trees, and the use of sequential \nalgorithms. However, there is not the same emphasis on syntax in the PLI1 definition, which separates \nthe Translator from the Interpreter with an interface provided by the abstract syntax, and then uses \nan explicit machine-state during interpretation. 3. Tree concepts The definition of PLII deals with \nthree classes of trees (concrete parse, abstract text and machine state), and a uniform concept of tree \nis employed throughout. This is of a tree which is a directed graph with a label (e.g. <procedure> ) \nat each node, and where the subtrees of any node are ordered. (Al\u00adthough the ordering is oi ten irrelevant, \nit is needed, e.g., in the concrete parse and in lists, and it was eventually decided that the simple \nuniformity of concept outweighed the advantages of explicitly distinguishing instances where the order \nwas significant. ) More\u00adover, each node implicitly has a unique name by which it can be designated when \nrequired. A copy or a tree has the same ordered structure and labelling, but new unique names to designate \nits nodes. Equality of trees requires equality of all except the unique names of nodes, and identity \nrequires that these should match also. The explicit label of a node may be either a grammatical category \nname, or some other type of value such as an integer or a designator (i.e a copy of the unique names \nimplicitly associated with some node). Thus a single value may be handled as a degenerate tree with only \na root node labelled with this value, and data objects referenced in the meta\u00adlanguage are uniformly \nregarded as trees. The terminology applied to trees is developed f rom the starting-point of a tree consisting \nof a node (the root node) . and an ordered, possibly empty, set of immediately contained trees. Any tree \nX immediately contained in Y, or immediately contained in a tree contained in Y, is said to be contained \nin Y. X is simply contained in Y if and only if it is con\u00adtained in Y and it is not contained in any \ntree Z contained in Y and having a root node equal to that of X or of Y. For example, if we ref er to \nan <expression> simply contained in a tree representing some statement in a program, we mean tne complete \n<expression> tree and not some subexpression which might be a tree rooted in <expression> at some lower \nlevel within it. Since simple contain\u00admentisa frequently required concept, the use of any form of possessive \nphrase not employing the verb containll is taken to imply simple containment, e.g. if y has an <expression> \n(meaning a tree with root node labelled cexpresscsn> ), the <expression> of y , or its <expression> . \nThe terminology makes it possible to perform the three essential types ofoper\u00ad ration on trees, namely \nto test them for the presence or type of their subtrees, to select subtrees from them, and to con\u00ad struct \nor alter them. However, con\u00adstruction can be laborious if phrased as root node <a> with two immediate \nsubtrees, the first being <b> with immediate sub\u00adtrees <c> and <d>, and the second being x (where x is \nthe name of some tree, meaning that a copy of it is to be made in constructing the new tree). This may \ntherefore be abbreviated as <a>: <b>: <c> <d>; x; The indentation is inessential, although helpf ul with \nlarge trees. One or more trailing semi-colons at the end of such a constructed tree may optionally be \nreplaced by a period. Proceeding from consideration of particular trees to classes of trees, we encounter \ngrammars composed of sets of production rules couched in a slightly extended Backus-Naur Form. The inter\u00adpretation \nwe make of such rules is that they describe how to construct a tree belonging to the class described \nby the grammar -it is only in the traditional syntactic use of these rules that the sequence of terminal \nnodes of a tree acquires a special importance as being the sequence of characters representing an utterance \nin the language. The poss\u00adibility of using a form of production rule with both selector and predicate \nfunctions was considered, but the uniformity and simplicity of having all trees labelled only at the \nnodes and not, so to speak, on the branches as well, was preferred. As an illustration, we will construct \na tree from a rule of the form <P>::= <q>l {<r-list> l<s>}*<~> [<u>] A grammatical rule in the meta\u00adlanguage \nis rather like a statement in a language which it may be used to define, i.e a metalanguage rule itself \nhas a grammatical structure which has to be validated and correctly interpreted. We have chosen to escape \nfrom circularity or regress at this point by not giving a formal grammar for the metalanguage, but describing \nin prose how a rule is to be interpreted. So in the above example, the rule indicates that any node labelled \n<P> must have subtrees as described by the right-hand side of the rule. There are three types of metalanguage \noperator, for concatenation (indicated by juxta\u00adposition in the rule), permutation ( . ) and choice between \nalternatives ( ] ), in descending order of precedence. Parenthesised expressions are regarded as single \noperands, and the first stage in using a rule to construct a tree is to partition the syntax expression \nintc, sub\u00adexpressions separated by t l!!, the operator of lowest precedence, and to F LI1 definition \nof the machine-state choose one of these alternative subex\u00adnodes, except for those belonging to the pressions. \nSuppose we discard the altern\u00adgrammar of the abstract program which are ative of having <q> alone, and \nnext part\u00addistinguished by < and > to help the ition the other alternative by the * reader.) operator \nand decide to use the permu\u00adtation which reverses these partitions to yield Operations defined st>[fu>](<r-listslts>] \n. by algorithms The square brackets indicate that their contents may be optionally omitted, which Memory \nin tree f orm we choose to do here, and the curly braces enclose a syntax expression which must be interpreted \naccording to the method just described. Choosing the alternative <r-list> we would then have the tree \n<p> : <t> Fig 1 Structureof abstract machine <r-list> ; i he underlining of t indicates that it An operation \nof the machine is always labels a terminal node in the defined by a sequence of Steps, or a set grammar \nin question, i.e it does not of mutually exclusive Cases, numbered occur on the left-hand side of any \npro\u00adfrom 1 to n. The ilth Step or Case may duction rule. <r-list> indicates by con\u00aditself contain a sequence \nof Steps or a vention that it is to have one or more set of Cases numbered from i.1 to i.m, immediate \nsubtrees of type <r> beneath and so forth. Each Step or Case speci\u00ad it . We then apply the rule for <r> \nsep\u00adfies actions to be performed, using arately to each of these. The construct\u00advarious informal statement \ntypes in ion is completed when each terminal node the metalanguage. A Case begins by of the tree is either \nof a type which is stating the predicate that must be satis\u00ad always terminal or of a type which has pro\u00adfied \nfor Lt to be applicable. duced an empty set of subtrees. As an example of an operation, 4. Algorithm \nconcepts consider the definition of the prologue operation in Fig 2. This begins with The operations \nof the abstract mach\u00adan introductory paragraph which givesine are def ined by algorithms, which may some \nguidance to the reader but thebe compared with the logic or microcode definitive material is not reached \nuntil supporting the operation codes of a comp\u00adthe Operation: heading. uter. These operations inspect \nand/or change the <inachine-state>, i.e the Step 1 consists of an attach action, memory of the abstract \nmachine, which meaning that one tree is to be copied as contains all the information directly or a subtree \nof another in the position in indirectly affecting semantics, including which it may validly occur according \nto some form of the <program> itself . (The the syntactic rules governing the type metabrackets + and \n9 are used in the of the latter. The word current has 6.2.3 Prologue The operation prologue is invoked \nat the beginning of every block activation to establish +generation*s for the <automatic> and <defined> \n<variables local to that block. The <automatic> <variable>~ are xnztialised if their <declarations specify \ninitialisation. Any <expressions evaluated during the prologue, such as in <extent-expression>s or <initial> \n<expression>s, may not reference other <automatic> or <defined> <variables local to this block. The operation \nfind-directory-entry will impose the restriction when it finds a reference to a <variable> declared in \na block for which there exists a +~rologue-fla~+. The +~rologue-fla~+ is only present while -the operation \nprologue is active. Operation: prologue Step 1. Attach a +~rologue-fla~> to the current +linkage-part+. \nStep 2. For each <declarati.on>td, of the current block, that contains <automatic> or <defined>, perform \nStep 3, Step 3, Let id be the <identifier> immediately contained in d. Case 3.1. d contains <automatic>. \nStep 3.1,1, Perform evaluate-data-description-for-allocation (d) to obtain an +evaluated-data-description+, \nedd. Step 3.1.2, Perform allocate(edd) to obtain a +generation~tg, Step 3.1.3. Append to the current \n+automatic-directory-entry-list+ an +automatic\u00addirectory-entry+:id g. Step 3.1.4 If d contains <initial> \nthen perform initialize-generation (g,d). Case 3.2. d contains <defined>. Step 3.2.1. Perform evaluate-data-description-for-allocation \n(d) to obtain an ~evaluated-data-descriptionb, edd. Step 3.2.2. Append to the current +defined-directory-entry-list+ \na +defined\u00addirectory-entry+: id edd. Step 4. Delete the +prologue-fla~+ of the current +linkage-part+. \nStep 5. Replace the current +statement-control~ by a *statement-control*: 4operation-list*: 4operation9 \nfor advance-execution. Fig. 2. Definition of the prologue operation. been defined precisely with respect \nto the particular 4machine-state+ used in defining PLII -the current ~linkage-part~ is the 41inkage-part5 \nsimply contained in the *block-state+ corresponding to the block currently being executed. Step 2 indicates \niteration with a for each speci\u00ad fication applied to the first form of the perform action, which refers \nto one or more Steps in the same operation. A name such as d introduced between commas is a variable, \nlocal to the operation, whose value (v, say) is a designator of the tree mentioned immediately preceding \nthe ,, ,d,, . On subsequent uses of d, it is dereferenced, i.e. it means the tree designated by v except \nwhen it is rede\u00adfined in a way similar to its original definition (as would happen here on the next iteration \nof !Ifor each! ), or by its occurrence after the word let . The let statement is merely a more explicit \nsyntax for this kind of definition of a local variable, and Step 3 cDntains an instance of this. If d \nccntains <automatic>, the predicate of Case 3.1 is satisfied and Steps 3.1.1 to 3.1.4 will be performed \nin sequence. The second form of perform, which is used to invoke another operation as a sub\u00adroutine \nor function , occurs in Step 3.1.1. Here it is a function that is invoked to obtain a resulting value \nwhich is then given a name. d is passed as an argument to this operation, whose definition will name \na parameter to correspond to it. Argument passing is by reference, i.e. a designator to the argument \nis passed and becomes the value of the parameter, which is then dereferenced on use, behaving just like \na local variable. The append action in Step 3.1.3 attaches a tree at the end of a list, and Step 3.1.4 \nexemplifies an ~ statement containing a subroutine call. Steps 4 and 5 consist of the other two tree \nactions which we use, delete and replace. When a tree is replaced by another, the first tree is deleted \nand a copy of the second tree is made with its root at the same position, and having the same implicit \nname, as had the root of the tree just deleted. Assignment of a value to a variable is permitted in the \nsyntactic form of a set action, e.g. !Iset tv to .$true$f!, but this is only an alternative form of replacement \nwith the usual implied dereferencing of the variable name, meaning replace the tree designated by the \nstrict designator value of tv by +true+ . Other statement types not illustrated here are go to (used \nsparingly), terminate an operation at some point other than the end of the last Step, and return a value \nfrom a function (which also terminates the operation). Values are returned by reference, so that if the \nresult is a tree constructed within the function it must be copied back to the caller who will then receive \na designator of the copy -values local to an operation are deleted when it terminates. Clearly we have \nreached a point at which it is necessary to try and support our claim that we can indicate a mechan\u00adization \nof the metalanguage which will suffice to bolster intuition in its weaker moments. Step 5 provides the \ncue for this, since it constructs a tree which is to be placed in the 4machine\u00ad state> at exactly the \npoint at which it tails off into informality. There may be many active ~operation-list+s in the 4machine-state+, \nand each one has a conceptual processor associated with it which may execute operations asyn\u00ad chronously \nwith respect to the other processors. In particular, the PLI1 machine has a current ~block-state$ in \neach task, and this has a <statement\u00ad control+ where one could mechanize the actions of the metalanguage \ninvolved in interpreting the synchronous statements of the current block. The +operation-listY is to \nbe con\u00adceived as a push-down stack, where each +operation~ will have a subtree which is not formally \ndefined, but contains such information as the name of the operation, a list of its parameters and local \nvariables with their current values, all trees constructed during execution of the operation or copied \nback to it from invoked functions, an indication of whereabouts in which Step or Case it is executing \nits algorithm, how f ar it has proceeded through a f or each iteration, and so forth. When a perform \ninvokes another operation, this pushes down the stack and becomes the active operation; when an operation \nterminates, its whole tree (including its local values) is deleted and the stack pops up, activity in \nthe operation now at the head of the stack being resumed immediately after the point in its algorithm \nat which it was suspended. To return to the analogy suggested at the beginning of this section, it is \nas though an abstract processor had a machine cycle which could cause the execution of microcode operations \nwith their own local memories per invocation, together with the sophistication of the stacking capability. \n5. Conclusion Experience with this metalanguage has so far been encouraging. Although it still exhibits \nimperfections both in its specification and in its practical application to the def ini.tion of PL/1, \ni.t appears to be sufficiently precise aad to be intelligible to programmers. The conjunction of these \nattributes has led to more than one bug being discovered i.n the definition. The latest version has re \nbently (September 1973) been published as the 10th and penultimate update of BASIS/1, the joint working \ndraft Standard of the ANSI and ECMA committees. The final draft is due in the first half of 1974. Acknowledgement \nMajor contributions to the design and execution of this definitional work have been made by Milton Barber \n(CDC), Barry Folsom (Data General), Lois Frampton (FDA), Kenneth Lunn (IBM), Donald MacLaren (Honeywell), \nMichael Marcotty (General Motors), Andreas Schwald (Telef unken), Richard Sharman (IBM), Richard Wexelblat \n(Bell Laboratories), and the Editor of BASIS/l,Maurice Batey (IBM). References 1. BASIS/1. Morking draft \nof ECMA/ANSI PLII Standard, 10th revision. Sept\u00adember 1973. 2. Landin, P.J. A Correspondence  Between \nAlgol 60 and Church s Lambda-Notation. Comm. ACM, Feb/Mar. 1965. 3. Scott, D.Outline of a Mathematical \nTheory of Computation. Proc. bth Princeton Conference on Information Science and Systems 1970. 4. Hoare, \nC.A.R. An Axiomatic Basis for Computer Programming. Comm. ACM, October 1969.  Lucas, P.and Walk, K. \nOn the Formal Description of PL/I. Annual Review in Automatic Programming, Vol 6, Part ~.1969. 5. \n\t\t\t", "proc_id": "512927", "abstract": "In order to define the semantics of PL/I in a form which is both precise and readable, a method of definition has been developed which employs an abstract machine operating on tree-structured data. The classes of trees involved are defined by formal grammars, while the algorithms governing the behaviour of the machine are expressed semi-formally in prose. This algorithmic metalanguage is itself intended to have largely intuitive semantics, but these are made more precise by an indication of how they could be supported at a lower level of detail within the abstract machine.", "authors": [{"name": "David Beech", "author_profile_id": "81100513480", "affiliation": "IBM United Kingdom Laboratories, Hursley Park, Winchester, England", "person_id": "PP31045624", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512927.512935", "year": "1973", "article_id": "512935", "conference": "POPL", "title": "On the definitional method of standard PL/I", "url": "http://dl.acm.org/citation.cfm?id=512935"}