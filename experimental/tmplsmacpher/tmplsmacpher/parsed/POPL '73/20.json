{"article_publication_date": "10-01-1973", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1973 ACM 0-12345-678-9 $5.00 Large Scale File Processing POGOL Gloria J. Lambert Dept. of Defense INTRODUCTION \napproach without having to consider machine re\u00adsources. The POGOL system will put together a POGOL is \na data processing lsnguage which is configuration which makes good use of the re\u00addesigned to facilitate \nproblem solutions which sources available, producing actual files only involve very large files. Since \na programmer can when necessary. easily comprehend a finite though large file, the first mental solution \nto a problem usually permits PROBLEM SOLUTIOH INVOLVIITG LARGE FILES skipping back and forth in the file \nsearching for pertinent information and manipulating it. Unless A. HISTORICAJ, APPROACH the file is small \nenoup$ to fit into core, this approach to problem solving becomes much too This type of linear problem \nsolution was in\u00adcumbersome and expensive. An entire new concept plementeti in the past by producing a \nset of gen\u00adof problem solution is needed to deal with ex-eralized progrsms which perform certain file \ntremely large files. transformations. Then a problem solution was for\u00admulated by piecing together a series \nof these An approach to this problem is to produce a genertiized programs and speci~ing the options linear \nsolution. That is, since the files are too desired for this solution and this run. Obviously, large to \nbe stored in core, the file is read once, this produces solutions which can be put together a transformation \nis performed and an output file by the programmer fairly quickly but which are (or files) is produced. \nIn order to arrive at the wasteful of machine resources. In addition, if final desired solution, a series \nof these trans-the generalized program does not produce the exact formations may be necessary. Using \nPOGOL one may desired result, it could be awkward to make a define a total problem solution using this \nli~ear specialized change. w.. , .+--8 : --+ x 3 . ;+. -% .&#38; -*\u00ad ..+. k Figure 1A Figure lB FiEure \n2A Figure 1A shows the logic chart of a typical generalized problem solution involving file ~.ain\u00adtenence, \ndata selection, sortin~~ ~d rePort gen\u00aderation. Each box represents a @neralized pro-Cram. The shaded \nbox is a specialized progrm. When put on the computer, this solution becomes a one for one transformation \ninto machine steps (Figure lB). In addition, each intermediate ile must reside on en external storafle \ndevice. If the device is on-line, it ties up nachine resources. If the device is portable, it requires \nOperatOr inte rvent ion. This sane problem expressed in POGOL results in six operations (FiHure 2A) and \nfour machine steps (Tiflure 2B). Not only is the solution more easily stated in POGOL, but the compiler \nperforms the analysis necessarY to co~bine multiple operations into one machine step when possible. B. \nPOGOL APPROACH POGOL provides a linguistic capability to produce this type of problem solution in a natural \nw~v. The basic structure of a POGOL program is a series of operations, each of which consists of one \nor more input files, a verb (some ~~or data processing function), and one or more outPut files. These \noperations are connected via data paths de\u00ad fined by the ?iles involved. That iS , 1 f file A is output \nfrom operation 1 end input to operation 3, a data path has been defined which connects operation 1 to \noperation 3 (Fi$wre 3). The verb in an operation directs the basic function of the operation including \nits input strategy. In addition, the verb nay be wmented by algorithmic codins (seCtiOn III. B). Each \nrecord in the input file(s) can be ? iltered through some algorithmic coding before the verb flets it. \nCertain conditions encountered by the verb can ~---\u00ad 11 1 (p 1:: .................. * . . 1 II Figure \n2B cause exits to specified routines. When the verb has produced a record or a data object (dependin~ \non the verb s function), control is passed to the cutput section of the operation where additional algorithr.ic \nfunctions can be yerforved. lJsually new records for the output file(s) are built in the output section, \nbut this mav actuallY occur anuywhere in the operation, Using these components, the programmer can soeci~ \na tailored solution to his problem whiie lettinr the compiler direct the data paths necessa~ to handle \nthe larpe files involved. PROGRAM FLOW EXTERNAL flLE INPUT SECTION OPERATION VERB [ _OUTPUl SECTION \n8 TO INTERNAL FILE I_ El INPUT SECTION VERB OPERATION OUTPUT SECTION { 0, 1 EXTERNAL FIIE Fi~ure 3 When \nwriting a POGOL progrem, one need not concern himself with machine resources or con\u00adstraints. The progr~er \nstates his total problem solution in POGOL source. The compiler carries a parameter file which defines \nthe machine resource limitations to be imposed on a job step. The compiler then segments the job accordingly, \nproducing all the command languege necessary to run the resulting job. It also handles the inter\u00admediate \nfiles which must be produced due to seg\u00admentation. The user needs to provide only his POGOL program end \nthe command language to describe his external input end output files. If the user has existing non-POGOL \nprograms or subroutines he wants executed, there is a facility for speci~ing at what point in the procedure \nthe program should be inserted or the subroutine called. Example: The following operation looks up words \nin a diet ionary. FILE DATA (ITEM,5,c;IDEITT,25,C;p0S,l ,F). FILE DICT (woRD,5,c;}mM~Ir?G,20,c). IUPUT \nDATA, DICT . MATCH KEY ITI?M;FOR 1 MATCHED JUNPI O X; FGR 1 UHM-ATCRED JUtlPTO Y . LOCAL x: otmpuT c \n(ITE!.f;IDErm;POS;?mNIII?G).# LOCAL Y: OUTPUT c (ITEtf;IDENT;POs; ) .# When the NWCH verb finds .s record \nin the DICT file in which the field, VORD, matches the field, ITEM, from a record in the DATA file, the \nverb executes routine X. This routine writes the word end its meaning on the output file. If no matching \ncondition is found, routine Y outputs the word with blanks in the meaning field. POGOI, LAI lGUAGE A. \nVERBS The verbs are the major components of the pOGOL language. The verb is the controlling factor in \nen operation. It dictates how the records from the input file or files will move through the operation. \nThe algorithmic coding in sn operation serves to augment the verb, allowing the programmer to tailor \nthe verb s action to his particular problem Each verb issues requests for data baaed on its function. \nIt may need one record from one file, several records from one file, or one record Nom each of several \nfiles. The programmer may specify that as the verb proceeds to work on the file(s), if certain conditions \narise, en exit is to be taken from the verb to perform specialized algorithmic functions. In most of \nthe verbs it is possible (in fact, sometimes necessary) to specify a sequencing or control group identifier \nin a file. A control woup is a group of records which have a lo~ical. association. There are two basic \nways of in\u00ad dicating a control group. Each record may contain a key field which indicates where this \nrecord be\u00ad longs in the file. Or the first record of a goup may contain a special value or condition \nwhich indicates that this is the start of a new control group. The specification of the second condition \nis called a B?U?AK clause. This language feature is actually independent o? the verb. It is stated in \nthe verb statenent only because of the timing factor involved. That is, the KEY or BREAK clause is analyzed \nwhen the record becomes available to the verb and not when it becomes available to the operation. There \nare fifteen verbs de~ined in the POGOL language. These are the major data processing functions needed \nfor the class of problem POGOL was designed to address. Each verb has been de\u00adfined to be fairly flexible \nin itself as well as to allow interaction with al~orithmic coding. The verbs work with all data types \nexcept binary. Following is a brief description of each verb and its basic function. Combine takes a \nsingle input file and forms all combinations of records within a control proup. Couple picks up the specified \ndata from each record in a control group, and produces the resulting concatenated string. Identify selects \nthose records from the input file that belong to groups described in the verb statement, Index is used \nto identify words in the input =d then show the word (or the reverse of the word) in context. Match \nprocesses two files which have been sequenced -In control groups. One may then select matched or unmatched \nconditions on each of the two files. -processes two or more sequenced files prc\u00adducing a sinRle sequenced \nset of records. Offset produces successive segments or groups of the origin string in either left to \nright or cyclic fashion steppinp in equal increments. Pack reorganizes the specified data within a con\u00ad \n= group in the input file by packing the data from the individual records in the control group. Print \nprovides a report generation facility which =S the programmer to describe the page, spacing, top end \nbottom mar~ins, routines to handle page overflow, and columnar printing. Special algo\u00ad rithmic statements \nare used to build and print lines and perform. the various printinp functions. Process provides a verb \nenvironv.ent whereby the programmer can al.gorithmicelly specify the desired action includinp the input \nstrategy. Scan inspects the input data for occurrences of ~ified strings and returns hits, their position, \nend precedinp or following data. Search essentially_ provides a dictionary capabil\u00ad Onelty. file contains \nthe words and meanings!*. The second file contains values which are to be looked-up in the first file. \nSelect processes the file in control proups pro\u00ad-records which meet the selection criteria (e.g., F, \n-first of multiples, 1.1110 -last. record in a control group of at least 10 records). Sort sequences \nrecords from one or more files. ~individual files may have the same or different keys and may retain \ntheir individual identity or be merged into one file on output. w provides a file maintenance facility. \nThe verb will delete records or chatu?e the value of fields within the specified record(s). B. ALGORITRMIC \nSTATEMINTS -shifts the significant data in a field right or left either within itself or into another \nfield. -performs binary operations on two fields. cdl links to a subroutine (POGOL or non-POGOL). Clear \nresets a field(s) to the appropriate nulls. Close causes an input file to be closed and an end-of-file \nsignal to be passed to the verb. Convert converts data from one data type to snothe r. Displzqv gives \ndebug output on the line printer. ~ specifies a loop which can have both parallel and rectangular indexine. \nEdit returns a coumt of the significant data in ~ta field. Goto branches with the option to either return \n~or to snother label. ~ is the normal boolean expression with true and false para~raphs. @+trensfers \ndata from one field to another nthout conversion. ~ &#38; ~ control the setting of switches. Order sorts \nthe data within a field. Output constructs a record and puts it on an output file. Sead causes a record \nto be input from a parameter m. Reference &#38;vnamically assigns a data reference or address to a pseudonym. \nA pseudonym is a shorthand notation which ~fers to the address of some data string. It is used for either \nflexibility or efficiency. Set assigns the value of an expression to a Wtination. ~d Return are statements \nthe programmer can use to affect the sequence of control, especially as it concerns the flow of data \nthrou~h en operation. ~, *, c. DATA STRUCTURES Data structures within POCOL are based on the premise \nthat everything is a strini?. A variable cen represent n characters, n ~ull-words, n double\u00adfloat values, \netc. A variable, X, which is one tillword integer is simply considered a string of lenpth 1. This concept \nadds an extra dimension to all data structures. That is, one may map en arrqy or table over any string, \nthe only Constraint beinfl that the len@h of the strinp must be divisible by the number of intersections \nin the array or table. PiXXIL cmkes a distinction between tables and azv-ays. Tables are addressed throuph \nco\u00adordinates which are actual. data values while ar\u00adr~vs are addressed positionally. Wurth~ rmore , the \ncoordinate values of a table can be changed by the program. FIELIN JOl?, 100, C. ARRAYSAM10 BY 5 ; JOE \n. !UU31J! TO!! 50, 2 (JOE) ; 0F50. These stater.ents describe three data structures: JOE is a string \nof 100 characters. SAM is a two dimension array which is mapped over JOE. TO!f is a 5(? integer table \nwhine coordinates values are taken from .TOE two characters at a time. References to the arrqv SA ! are \nFade pOSitiOn~lY, i.e., SAM (3,2) addresses the two characters found in the third row end second column \n(if the arraY is thought of as beinp stored by rows). On the other hand, the table ?OV is referenced \nby an odd\u00adeven pair found in the character strinp .JOE. TOM ( AD ) will cause JOE tobe searched for P.B \n, steppinfi across JOI? two characters at a time. If Ail is the characters 9 &#38; 10 in JOE, TOM ( AB \n) will reference the fifth integer in the table. n. FILE DESCRI?TIOIT Each file in a PO(X3L procedure \nmust be fully described. A file which is internal needs only a description of the data in the fields \nwhich make up each record (e.g., three fullwords followed by 27 characters, followed by one double float \nnumber). On the other hand, an external file csn have much more information associated with it. If the \nfile is not in the standard character set of the host nachine, it may be necessary to trans\u00ad form the \nfile before workirq? with it internally. Conversely, an output file may need to be in a non-standard \ncharacter set. One vqv want to chan~e only certain fields or only certain char\u00adacters within the file. \nThis option is easily specified in the file description section. It is also possible to specify the desired \nreaction when encountering read errors or conversion errors. A PROBLE!I SOLUTION USING POGOL Since POGOL \nhas both the verbs and the sl~orithnic capability, there are two ways one One way is to program a solution \nin much the sane manner as one would using FORTRAN, that is, making heavy use of the algorithmic statements, \ncan program using the lancuage. The second method is to mike heavy use of the verbs. 130th methods require \na different approach to problem solution for progrenmers who use languages such as FORTRAN, ALGOL, or \nPL/1. POCX3L is more natural to project planners who have used the higher level generalized programs \nfor problem solution. The programmer cexmot think of his data as being all available at one time. For \nin\u00adstance, consider the following problem: Input: a file which contains text in the following format: \nCol id number ::;0 identification fields 21-80 text A text may span more than one record snd is blank \nfilled at the end. Problem: Suppose a linguist wants to study the relationship of words to each other. \nHe might want to scan text to find instsmces where two words are the same distance apart in di~~erent \nsamples of text. If the size of the file were known and sufficiently small, the obvious solution would \nbe to store the text in memory and search for hits using do-loops. However, in practice the file is extremely \nlarge and of fluctuating size. This leads to the following POGOL approach. Read the text file and create \na new file whose records contain the identifier , one word, and its position within the text. Using this \nfile, one wants to produce all the combinations of words within each control group. Since the position \nof each word within the text is known, the difference can be computed, The output file contains an identifier, \nthe two words with their positions, and the distance be\u00adtween the two words in the text. The next step \nis to sort the file by the two words and the distance between them. This will cause all the equidistant \nhits to fall together on the sorted file. How the records which are multiples for the key value (word \n1, word 2, distance) will be the solution to the problem. POGOL SOURCE LISTIHG IDE11T=C?51CJL3(20900 \n,OOR,31O) ;PRTY=1O;CLAS5=A. CONTROL=COMPILE( NSG=(SOURCE,DESC ,FLOW,JCL)); E~G%E TEXTFILE(READER,20 ;TEXT,60)?G(TXTIII,5)# \nFILE GRPS(RDR,5 ;WORD,20;P0S,5, C,511), FILE PAIRS,SPAIRS(RDR$5;~RP,30 ;SORP,30; D1FF,5,C,5N). FILE \nMATCHES(PAIRS)&#38; (TxTID,5;woRDl,20;p051,5; WORD2,20;POS2 ,5). INPUT TEXTFII,E. mDEX TEXT; WORD GIVES \n(W0RD,20);BNMK TXTID DC JOMPTO OUT;SZ ART JUMPTO OUT. FIELD POS,1,F;HOLD,5. SET POS=P(!S+l . OUTPTM \nGRPS(HOLD;WORD;POS). LOCAL OUT: MOVE !PXTII) INTO HOLD. CLEAR POS.# INPUT GRPS. COMBINE KEY HDR; FOR \nPAIF JUMPTO PAIRS (LE171 woRD,pos GIVING (FRSTGRp,30); RTGRT woti,pos GIVIHG (sCNDGRp,30); MAX 100). \nFIELDS POS1 IS FRSTGRP(2G:5);POS2 1s sc~~DGRp (26:5);DIFF,1,F. LOCAL PAIRS : SIT DI?F=POS2-POS1. OUTPUT \nPAIFS(HRD;FRSTGRP; SCNDGRP;DIFF).# INPUT PAIRS. SORT KEY FGRP(l:20),SGRP(l:20)4DI~. OUTPUT SPAIRS. INPUT \nSPAIRS. SELIX7T KEY FGRP(1:20),SGRP(1:20),D1FF;FOR M JOMPTO NULT. LOCAL MULT : OUTPUT MATCHFS. # INPUT \nMATCRES. pRIIIT I~CRPRT(PAGE 66;Top 6;BOTTOM 6;0FL0 JUMPTO OFLOW); START JUNPTO S! ART;ENDOP JUMPTO END. \nIF WORDl,WORD2,DTPF AC.SPACE 2 . LINE WORD1; +2=WOI?D2;+2Z=DIFF . SPACE O.# LINE 60=TxTID;+52=P0sl;+52=P0S2. \n LOCAL OFLOW: SET(PGHLJ}4,1,F)=PGNLIM+I . I,IHE 100=}PAGE1 :+lZ=PG?TUM hN . SPACli 1 . LINE-1 50=t2 \nPOTWT HITS}. SPACE 1: ELSE RETURN. # TOP : E<TECT. LI NE=LI??E-I . SPACE 2 . LINE woRD1~;+17=~woRD2~; \n+17=toFFsm J;60=!TXTID I ; +5= POSN ll;+b=!po~y~ 2!. LINE $ , SpACE I . REW, START : SPACE 20 . LI}Jli \n50= POGOL TOY NO. 31 . LINE 50= GLORIA J. LAWBERT!. LINE 50=tF EBRUARY,1973~. GO TO TOP. Elm : OFF(l). \nSKIP. GO TO OFLO\\T.# The above solution has one disadvantage. The file of combinations which must be \nsorted can become quite large. For instance, a semple file containing ten control groups with a total \nword count of 429 produced a combinations file of 9357 which must be stacked on an external, device for \nsortinR. Itwould not be unrealistic to ex\u00adpect an input file of ten thousend text groups which produce \na combinations file on the order of ten million records. ~erefore, the following solution is much more \ndesirable. Start as the first solution producing a file whose records consist of one word, its posi\u00adtion \nwithin the text, and an identifier. sort this file by word and text id number, then find all combinations \nof each word across records. From the combinations * produce a file containing the two text identifiers \nand the difference in the position of the word within the two sets of text. When this file is scmtedby \nthe two text id nwsbers and the slide difference, the equidis\u00adtant hits will fall together. The combinations \nof this file can be taken to give all the pairs. POGOL SOURCE LISTING IDE1iT=C951C2JL7( 209OO,OOOR,31O \n);PRTY=1O;CLMS=A. CONTROL=COMPIIX(MSG=(SOURCE,I)IXC ,FLOW,.TCL));GO. EXT FILE TEXTFIL12(READER,20;TEXT,60)&#38;(TXT \nID,5 ), f? FILE GRPS(TXT1D,5;WORD,20;POS,5,C ,5N). FILE SGRPS(GRPS) &#38;( REC,30). FILE PAIRS, SPAIRS( \nLGRP,30;RGRP,10 ;SLIDE,5,C,51I) &#38;( LTXTID,5;WORD 20; POS1,5;RTXHD,5 ;POS2,5). FILE MATCHllS(LHORHOLD,30; \nLTXTID,5; RTXT1D,5) LD,30; &#38;(WORDl,20;POSLl ,5;POSL2,5;WORD2 ,20;POSR1,5; POSR2,5). INPUT TEXTFILE. \nINDEx TLXT; WORD GIVES (WORD,20);BREAK TXTID DC JUMFTO OUT; START 3U!4PT0 OUT. FIELD POS,l,I ;HOLD,5. \nSET POS=POS+l . OUTPUT GRPS(ROLD;WORD;POS). LOCAL OUT: MOVE TXTID lHTO HOLD. CLEAR POS.# INPUT GRPS. \nSORT KEY WORD,TXTID . 0V2PU?! SGRPS. INPUT SGRPS. COMBINE KEY WORD; YOR PAIR JUNFTO PAIRS (LRIT RRC GIVTHG \n(LGRp,30); RIGHT TxTID,pOS GIVTIJG (RGRp,I_O); lfAx 200). FIELDS LTXTID IS LGRP(1:5);RTXTID IS RGRp(1:5); \nPOS1 IS LGRP(26:5); POS2 IS RGRP(6:5) ;SLIDE,1,F. LOCAL PAIRS :IF LT X ITID EQ RTXTTD. RETUR}J.# Om SLIDE= \nPOS2-POS1. OUTPUT PAIRS(LGRP;RGRP;SLIDE).# lHPUT PAIRS. SORT KRY LTXTID,RTXTID,SLIDE. OUTPUT SPAIRS . \nINPUT SPAIRS. CO14DINE KEY LTXTID,TRXTID,SLIDE; FOR PAIR JU!!PTO PAIRS (LE~ WORD,p0Sl,POS2 GIVRS (LRoLD,30); \nRIGHT WORD,POS1,POS2 GIVES (RHOLD,30); !4AX 200). LOCAL PAIRS : OUTPUT )~TC1lES(L1lOLD;R1lOLD; LTXTID;RTXTID).# \nINPUT MATCHES. PRIWT !mCHPRT(PAGE 66;TOP 6;130TToM 6;OFL0 JUMPTO OFLOW); START JUMF I!O START ;iHIDOP \nJUMPTO END. SPACE 2. LINE WORD1;+2=WORD2;+2Z=POSR1-POSL1;60 =LTXT1D; +5z=Pr)sLl;+5z=PosR1. mm 60=RTXTID;+5Z=pOSL2 \n;+52=p02R2. LOCAL OFLOW: SET(PGNUM1>F)=PGIJOM+l . LINE 10Cl=~PAGEt ;+lZ=PG30M hlT . SPACE 1 . LINE-1 \n50=~2 POINT HITS! IF(l). ELSE RETURN.# TOP : EJECT.LIHE=LINE-1 . SPACE 2 , LINE WORDI ; +12= WORD2 +17= \n~oFFsm1;60=~TxTID1 ; +5= POSII l!;+4~=lpcln{ 2!0 LIKE . SPACE 1 . RETURN. START : SPACE 20 . LINE 50= \nPOGOL TOY HO.3 . LI?~E 50= GLORIA J. LAMBERTt, LIIJE 50 = FEFJRUARY,1973 . GO TO TOP. EIID : OFF(I). \nSKIP. GO ! 0 OFLOW.# STOP . FILK PROCESSING TECH??TQUES One of the major problems with using general\u00adized \nprogrsns to solve problems was the fact that intermediate files were stacked on external devices (usually \ntape) between steps. This was not only wasteful of machine resources but required human intervention. \nt he POGOL solution to this problem is to let each record flow completely through the procedure without \ngoin~ external until it is on a terminal data path. Each verb may have multiple input files and multiple \noutput files. Since a req~est for en input record as well as the pro\u00adduction of an output record is data \ndependent and hence unpredictable, the management of the resulting data flow can become quite comulex. \nA. FILE MVdlAGE?fEIJT The processing flow of a POCX3L procedure is dictated by the m.nner in which the \noperations are linked to~ether using the I IJ.E, ?3PUI , snd OUTPUT statements. Files are identified \nas either external or internal. The external files may be either input or output from the procedure (but \nnot both) while internal files link operations within the procedure. Basically the ? ollowing siutations \ncan exist. 1. A file defined as external appears in an IITPUT statement. 2. A file defined as external \nappears in an OUTPUT statement. 3. A file appeari~ in an OUTPOT statement of one operation appears in \nthe INPUT statement of a subsequent operation.  In each of these situations, the originator of the file \ncan be called the predecessor and the user of the &#38;:le is the successor. The only means of communication \nbetween two operations is a file; and even then, it is a one-way com\u00admunications link. The predecessor \noperation can pass information to the successor operation as a record in the file that defines the link \nbetween them. Control can be passed in either direction. When the predecessor operation produces a record \nfor the file, control is passed to the successor. On the other hand, when the successor operation needs \na record, control passes to the predecessor operation. The data network defined by a set of operations \nand the files which connect them csn be viewed as a network in which data flows in one direction only \nbut control flows in two direct ions. Since the files are actually the connecting links (or edges) which \nhold this network together, each link has a block of infor!nation which des\u00adcribes the status of that \nlink. This block of information is called a file statistics block By using these pseudo-operations, the \ninter-oper\u00ad(FSB). It contains the following information. ation sequence of control flows very smoothly. \nAn operation never needs to be concerned whether -the predecessor operation its files are internal or \nexternal, so a standard -the successor operation file statistics block is sufficient. The problem file \nstatus (active record, tanked record, of several operations using the seine external file end-of-file \n,etc) is also resolved naturelly using pseudo-operations. -tank pointers (tanking will be discussed Finally \nthis concept leads to a clean, modular later) design for the run-time environment. chain link for multiple \nsuccessors -file name B. DATA IMPASSE -record count The operations in a POGOL procedure may be The FSB \ncontains the information needed to direct connected in such a manner that an operation in the flow of \nrecords through the procedure. the network has two (or more) input files both of which have a common \nsncestor. For example, in In this network a file may have only one Figure 1, files D and E both have \nOP 5 as an sn\u00adpredecessor but multiple successors. When a cestor. This situation results in a potential \nrecord is produced, it must be assured that each data conflict. If OP 9 needs a record from file E, of \nits successor operations receives a copy control is passed to OP 6 which can produce the of the record \nin the order produced. Therefore, record. Suppose OP 6 in turn needs a record from each successor has \nan FSB end they are chained file S3. Control will then pass to OP 5. Because together. When a record \nis produced, control of data conditions, the next record to be produced is passed to the successor pointed \nto by the ~w be for file A and not file B. When this first FSB in the chain. When control comes back \nhappens, the record flows into OP 7 which can to the predecessor, it has been left in a state produce \na record on file C. OF 8 in turn Cm such that the first thing it does is check the produce a record on \nfile D. At this point a data chain for further users of the file. In this way impasse occurs. OP 9 has \nan active record for all the successor operations are activated snd file I) and therefore cannot handle \nthe new record thereby receive a copy of the record before the at this time. It still needs a record \nfrom file E. predecessor can go ahead with its next function (which may result in destroying the original \ncopy of the record). A Another phenomenon which may occur is that one of the successor operations wants \nto logically close the file> but it renains active for the other successors. Since each successor has \na separate FSB this is easily accomplished by deleting the closed FSB from the chain. c External files \nare interfaced with the operations by a pseudo-operation which direct the input snd output of the files. \nThis pseudo-operati . on contains the 1/0 tables required by the operating system, an internal buffer, \nand a parameter list D which directs conversion snd fielding within the record. The compiler interjects \nthese pseudo\u00adoperations in the following manner. o It is possible to recopize a situation which El 7 \nis a potential problem, but since flow of control end record production are data dependent, it is impossible \nto know whether a conflict will in fact arise during execution. RDXF The compiler could take some action \nat compile time which would eliminate the problem by re. o structuring the procedure. Or the procedure \ncould be left intact by providing a run-time response ==$ OP (!) should the situation arise. The disadvantage \nof the first solution is that preventative action must be taken in all cases of potential conflict, whereas \nthe conflict may not even arise at execution time. E3 RXF Furthermore, the methods required (segmentation, \n forcinfl the file external) result in the very things the POGOL system was designed to avoid. + Therefore, \nthe second approach, the capability to o react to a conflict at run-time, has been im- E3 plemented. \nThere were several constraints placed on a solution. 1. It must guarantee that a successor receives all \ndata generated by its predecessor. 2. It must present records to the successor in the order in which \nthey were generated by the predecessor. 3. It must place no restrictions on the normal functioning of \nany operation (e.g., the artificial inhibition of record pro\u00adduction ).  l+. It must not impose data \nvolume limitations. In order for a real. time solution to work, the system must be able to recognize \na conflict when it occurs. That is , it must be discernible whether an operation is ready to accept a \nrecord on a data path or not. In addition, when an operation requests data, it must recognize whether \na previous conflict has occurred, since that will determine from where the next record for the operation \nmust come. The other requirement is a temporary repository for the record(s) whose untimely appearance \ncaused the ccmfli ct. The repository has been called a tank. POGOL makes use of an internal tank snd \nan external tank. When a record is produced which cannot be accepted by the target operation, the record \nis stored in the tsnk. When the internal tank is full, the excess is spilled onto disk. The status of \na file is re\u00adflected in the file statistics block (FSB). When the operation receives en input record, \na flag bit is turned on end stays on until the verb is ready to accept a new record. When a record is \npassed to sn operation, this bit is tested. If the bit is on, showing that the operation has an active \nrecord, the new record must be tanked. Once this happens, another bit is turned on to indicate that the \nfile has records in the tank. When the opera\u00adtion needs a new record, if the tank bit is on, a record \ncan be retrieved from the tank; otherwise, control is passed to the predecessor operation to produce \na record. c. SIJ3MEW ATION A POGOL procedure states a total problem solution without regard to the actual \nmachine environment. It is left to the POGOL compiler to determine what configuration this job should \nhave in order to operate efficiently on the target machine. The IBli/370 operating system (OS) requires \nthat the resources needed for a job step be declared when the job is initiated. Most compilers satis~ \nthis requirement by requiring that the resulting executable module fit into one job step whose resource \nrequirements have been initiated at the start of the job (i.e., before the com\u00adpilation step). This approach \nmust take one of the following forms: 1. A limited number of file declarations aPPear in the job stream \nSnd all. internal. files must be equated to then. If there are more files needed in the program than \nexist in the external declarations, some trickery rust be resorted to in order to effect the mapping. \n2. All of the files for the entire procedure must be allowed for in the execute step. The first solution \nis cumbersome for the progrsmuner and therefore did not seen acceptable from a lin~istic standpoint. \nThe second solution places undue burden on the machine resources. In OS all of the files are allocated \nwhen a step is in\u00adititelized and retained until the step is ended. Therefore, it was decided that the \ncompiler should segment the procedure according to the constraints desirable for the host machine snd \nproduce a second OS job step. The compiler also generates the JCL necessary to run the job. The circumstances \nwhich require that the POGOL compiler divide its object code into two or more job steps fall into the \nfollowing categories. 1. Resource limitations prohibit the execution of the procedure as a single job \nstep. 2. The programmer has specified the inclusion of a previously created job step. In\u00adsertion of \nthis job step requires pro\u00adcedure segmentation on either side of the inclusion point. 3. The occurrence \nof a sort step requires that the entire file be available to the sort verb.  The first category poses \nthe major problem to the segmentation algorithm. How should the procedure be broken down into tractable \nunits? The com\u00adpiler carries with it a parameter file which describes the limitations on a job step. \nThe programmer can override some of these values in the program control section. The segmentation phase \ndetermines a specific se~mentation scheme baaed on these thresholds. Using the scheme produced by the \nsegmentation phase, the exit phase of the compiler puts the object code into the specified sepments, \nbuilds the JCL for the execution job, end issues the command for the operating system to schedule the \njob. The compiler phase treats each operation as a separate entity without re~ard to its relation\u00adship \nto other operations. Tables are built which contain information concerning the operations size, input \nfiles, output files, and verb identity. Using this information, the segmentation phase can reconstruct \nthe data path network. Starting with the first operation in the procedure, the algorithm attempts to \nadd other operations to the job step under construction by following successor links. An operation can \nbe added to the current segment only if 1. All of its input is available. 2. It does not cause the segment \nto exceeti its threshold for resources.  The input files for en operation are available if its predecessors \nsatisfy the following criteria. 1. The predecessor is an external file (either explicitly declared to \nbe external or forced external by previous segmentation. 2. The predecessor is already resident in the \nsegment.  If the input is not available, the algorithm will attempt to make it available by adding the \npredecessor operation. When all candidates for inclusion have been considered, the segment is finalized. \nThe sane process is then repeated for the remaining unassigned oper\u00adations until all operations have \nbeen assi~ed to a segment. CONCLUSIOPJS The POGOL language is perhaps more properly termed a data processing \nsystem. It is a facility which SJ.1OWS the programmer to concentrate on the problem solution rather than \nthe operating system snd hardware constraints. The language is closely oriented to the terminolo~ of \nfile processing which results in readable programs. High powered operators or verbs are coupled with \nlower level operators in the algorithmic statements. It is powerful enough to SI.1OW the programmer the \nfreedom to formulate very so@isticated solutions. Conversely, POGOL is easy enough to use that problems \ncan be met tith a quick response. \n\t\t\t", "proc_id": "512927", "abstract": "", "authors": [{"name": "Gloria J. Lambert", "author_profile_id": "81100592986", "affiliation": "Dept. of Defense", "person_id": "P348461", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512927.512948", "year": "1973", "article_id": "512948", "conference": "POPL", "title": "Large scale file processing: POGOL", "url": "http://dl.acm.org/citation.cfm?id=512948"}