{"article_publication_date": "10-01-1973", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1973 ACM 0-12345-678-9 $5.00 MATHEMATICAL SEMANTICS OF SNOBOL4 R.D. Tennent Department of Computing and \nInformation Science Queen s University Kingston, Ontario ABSTRACT This paper analyzes the semantics of \nthe prograrmning language SNOBOL4, following the mathematical approach proposed by D. Scott and C. Strachey. \nThe study aims at clarifying a rather unusual semantic structure, and at demonstrating that the mathematical \napproach can provide a natural and usable formal specification of a practical programming language. KEY \nWORDS AND PHRASES mathematical semantics, SNOBOL4, environment, continuation, store, abstract syntax, \npattern matching. CR CATEGORIES 5.24, 4.22. 1. INTRODUCTION 1.1 Overview A number of informal or implementation-oriented \ndescriptions of SNOBOL4 have been published (Griswold et all, Wegner2, Harrison3, Griswoldq), but the \nmodel of pattern-matching by Gimpe15 appears to be the only example of a formal specification of some \naspect of its semantics. Since SNOBOL4 is a widely-used language and the available descriptions are incomplete \nand easily misinterpreted, a formal specification at a level higher than that of an actual implementation \nwould be useful to programmers, compiler writers, and language designers. In this report, we demonstrate \nthe feasibility of a mathematical semantic specification, as proposed by Scott and Strachey6 ,7,8. Other \na preaches to language1? definition are exemplified by Hoare and Wirthg, Lucas and Walk , and Fang l. \nIn the remainder of this introduction we summarize the characteristics of SNOBOL4 which make i.t an especially \ninteresting subject for semantic analysis, and discuss meta-linguisti.c concepts and notation. We then \npresent a formal speci-fication of a large subset of SNOBOL4 including pattern matching, assignment, \ntransfers of control, and functions. In this paper, input/outputr trace facilities, keywords, quickscan \nmode of pattern matching, and data structures are not discussed. The semantic specification is then used \nas the basis for discussion of Gimpel s model and a recent proposal for additional pattern operations. \nWe assume a knowledge of SNOBOL4; more precisely, the language considered is that discussed in references \n1, 4 and 5. Although we believe the specification to be consistent with these descriptions, it is not \nan official definition, and SNOBOL4 programmers may discover incompatibilities with respect to details \nthat are unspecified in currently available documentation. 1.2 The Defined Lanauaae SNOBOL4 is an especially \ninteresting and challenging language for which to attempt a mathematical semantic specification; in particular: \n(i) The applicative subset (aspects having to do with expression evaluation and declarations) is extremely \nlimited in SNOBOL4: there are no true identifiers, and functions, conditionals, pattern-matching, etc. \nare all highly imperative. Since the defining language is purely applicative, there is a much greater \nthan usual mismatch between the object and meta-languages. (ii) Transfer of control is based on the concept \nof evaluation success or failure, which in the case of pattern-matching generalizes to a backtracking \ncontrol structure. Built-in functions and operations provide the ability to compile text at run-time, \nand allow evaluations and assignments to be deferred or made conditional upon an ultimate pattern match \nsuccess. (iii) The storage structure of SNOBOL4 is quite unusual in many respects. Two of the data types \nare used both as variables and as values , so that successful expression evaluations must signal a return \nas being either by name or by value . Labels, functions, and operations are assignable , but by the use \nof built-in functions, rather than the usual infixed assignment operator. Despite these characteristics, \nit will be seen that the conceptual framework developed by Scott and Strachey is adaptable to SNOBOL4 \nwithout undue difficulty. Unfortunately, certain facilities (such as user-defined functions ) require \nspecifications that are unusually intricate and implementation-like. 1.3 The Defining Language 1.3.1 \nprimitive domains and functions The mathematical approach to semantics is based on a theory of computation \ndue to Scott / r which models data types by domains having a certain algebraic and topological structure, \nso that computable functions may be postulated to be continuous relative to this structure. All the domains \nand functions that we discuss can be shown to satisfy the postulates of this theory. Some of the primitive \ndomains we shall use are: T:T truth values l:N integers ~:Q strings The notation implies that the symbol \nT, possibly with primes or subscripts, will be used as a meta-variable over the domain T of truth-values, \nand similarly for the other domains. In every domain there is a special element .L which represents the \nmeaning of non-terminating, erroneous, or undefined computations. Primitive operations on T are conjunction \n(A) and disjunction (v); we use the notation co + &#38;l,s2\u00b0 for conditionals, and the usual arithmetic \nand relational operators for integers. For strings, we use Q for the empty string, 61A62 for concatenation, \nand 6 [~1 :12] for the substring of 6 from indices II to 12, (zero origin) . The length of a string \n8 is denoted #&#38; , so that 6 = 6[0:#6] and #Q = O. 1.3.2 derived domains and functions Non-primitive \ndomains are defined by using the domain operations x , + , and + , denoting cartesian product, disjoint \nunion, and exponentiation (function domain) respectively, and by writiing domain equations. We assume \nthat + associates to the right and that the precedence hierarchy is as above, from highest to lowest. \nFor aunionoftheforrn X= . . . +Yi+ . . . . we define the operations of inspection, projection, and injection \nas follows: (i) For any xcX, X~Yi = true, if x corresponds to an element of Yi false, if x does not correspond \nto an element of ~i (ii) For any [XCX, X/Yj\u00ad = Y, if x corresponds to Y~Yi { 1, if x does not correspond \nto an element of ii (iii) For any y6Yit y in X = x, where x<X corresponds to y. For any domain X, we \nwrite Xn for: xxxx ... XJ v n times and X* for the limit of Xl, X2, . . . 96 Functions may be defined \nby let or where auxiliary definitions (implicitly recursive) , or by the lambda notation A<.E , where \n~ is the bound variable and E is the body. Function application associates to the left and takes precedence \nover lambda abstraction; hence a~.clcz = k~.(clcz). If f:X + Y and g:~ + Z, then their composition is \nthe function fog:X + Z such that (fog) (x) = g(f(x)). Note the order of application, which makes possible \nleft-to\u00adright reading of complicated expressions. A variant form of composition will also be useful; \nif f:X + Y and 9;Y + X + Z, then feg:X + Z is the function such that: (f@g) (x) = (fog)(x)(x) = g(f(x) \n)(x). 1.4 Semantic Concepts In the mathematical approach, the semantics of a programming language are \nspecified by defining functions which map syntactic elements into their abstract meaning in an appropriate \nmodel; these definitions are syntax-directed in that every production in a BNF-like syntactic specification \nhas a corresponding clause in the semantic specification for that category of constructs. Typically the \ninterpretation of a syntactic construct is specified relative to three semantic constructs: (i) an environment: \na function mapping every symbolic identifier into the value denoted by that identifier; (ii) a continuation: \na function representing a computation that is to be done following the evaluation of the current syntactic \nconstruct;  (iii) a store: essentially, a function mapping every abstract storage location into the \nvalue currently stored as contents of that location; other components may be necessary to keep track \nof input/ output and dynamic storage allocation. For example, the meaning of an expression in a typical \nlanguage would be specified by a function &#38;:Exp + Env + K + S + S, where the domains are as follows: \nExp expressions Id identifiers Env = Id + D environments D denotable values S=L+V stores L locations \nv storable values K=E+S+S expression continuations E expression values The use of these constructs in \nsemantic specification is explained in more detail in Scott and Stracheys 7r8, Reynolds Is, and Wadsworth16. \n  2. SEMANTIC SPECIFICATION 2.1 Abstract Syntax L:Char* character strings ~:Id identifiers v:Nml numerals \nw:op operators c:Exp expressions u:Cmd commands y:Goto gotos Z:Stmt statements II:Prog programs Identifiers \nand operators will be considered to be components of the domain Char*. The following productions are \nin a BNF-like notation in which arbitrary elements of a syntactic domain are denoted by the corresponding \nmeta-variables, rather than a non-terminal symbol ; brackets and braces are used to enclose optional \nand alternative constructions. &#38;::= < literal Ig identifier Iv numeral \\ Us unary operation I cl \nh! &#38;~ binary operation I E(El,E2,.../En) function call \\ ~<&#38;I,E2, . . ..&#38;~> array indexing \nI (E) parentheses assignment pattern match replacement Y::= (E) I <E> 1  2.2 Expressions There are no \ndeclarations in SNOBOL , so that an environment component is not required; however, since an expression \nevaluation may fail, a second continuation must be ~rovided, and we will also see that the store is more \ncomplicated than usual. We . will not discuss input/output and so we suppose that the resklt of a program \nexecution is the final state of the store; then the continuation domains may be defined as follows: K:K \n= E + S + S expression continuations e:Fl = S + S failure continuations where the domains of expression \nvalues E and stores S will be defined later. The functionality of the expression interpretation function \nis then: C:EXP+KXFl+s+S Hence, if the evaluation of an expression E succeeds, the K continuation will \nbe applied to the resulting value and store, and otherwise the failure continuation will be applied to \njust the store. Even i.f an expression evaluation succeeds, it may return its value either by name or \nby value ; hence the domain of expression values is partitioned into domains of locations L and storable \nvalues V: ~:E = L + V expression values Then a return by name or by value i.s indicated by applying the \nexpression continuation to an ~ corresponding to an element of either L or V, respectively. (a name), \nA and variable so: (location) may be either natural (a string) or created ~:Q Nm strings names o,:L \n= Q + Nm locations The storable va ues include a so the other data types: z:N integers R reals IT:P \npatterns Ar arrays Tb tables U:w unevaluated expressions X:c code Df defined data types The domain of \nstorable values is then the sum of all of these: B:V=Q+Nm+N+R+P storable values +Ar +Tb+W+ C+ Df Strings \nand names are in both L and V, and so it is possible to define transfer functions val:L + V and var:V \n+ L as follows: va~(a) = (a:Nm + cxlNm , alQ) in V Var(!3) = (6:Nm+ !31Nm ; B as Q) in L where f3 as \nQ is 61Q if $:Q, but converts (3 to a string if B:N or 6:R, and is I otherwise. Similarly the suffix \nas N will denote the conversion of a value to an integer. The standard notations for inspections, projections, \nconversions, and injections of values can be simplified by (for example) writing v:N, nlN, n as N, and \n~ in E, rather than rI\\V:N, nlV\\N, rI\\V as N, and ~ in V in E, respectively. This is ambiguous for strings \nand names, but our convention will be that V is always the omitted intermediate domain. An unevaluated \nexpression is obtained by applying ~ to an expression but not supplying the continuations and store; \nthese will be provided when the unevaluated expression is passed to EVAL or encountered during pattern \nmatching. Hence: u:W = K x F1 + S + S unevaluated expressions For code , only the store needs to be provided: \nX:c =s+s code Pre-defined functions and operations must evaluate their own arguments and so we define \na general domain of functions as follows: +:F=W*+KXF1+S+S functions That is, an element of F will be \napplied to a list of unevaluated expressions. Patterns will be discussed later. We now consider the structure \nof S, the domain of stores; there is an L + V component as usual, but for the natural variables more \nis needed because functions and operations may be stored as attributes , di.sti.net from the stored value. \nThere is also a label attribute to store the code associated with that variable if it is used as a label. \nHence the domain of stores is constructed as follows: o:S = [L +V] X [Q+ F X F XFXCl stores (Additional \ncomponents would be required to account for input/output, allocation of names, etc.) The following functions \nallow storable values and the various attributes to be accessed and updated: 99 Contents: L,+S+V Update: \nL x V+S+ S Getunop, Getbinopr Getfcn: Q+S+F Setunop, Setbinop, Setfcn: Q x F+ S+ S Getcode: Q+S+C Setcode: \nQ X C+ S +S The meanings are evident from the mnemonics and functionalities. A very useful subsidiary \nfunction is coerce: K + K, defined as: Coerce(K) (~) (u) = K(rI:V + rl,Contents (il\\L) (6) in E) (o) \nwe may now specify ~:Exp + K x F1 + S + S as follows: du(c)l =~[cl The special brackets [.. .] will be \nused to enclose syntactic constructs in order to separate the object and metalanguages. t[ Z ](K,e) = \nK(~ap[C] in E) where ~aP:Char* + Q establishes the correspondence between syntactic strings and abstract \nstrings. ~l~](K,o) = K(~aP(~ in Char*) in L in E) The difference between the interpretation of a literal \nstring and an i-dentifier i-s that the former returns by value and the latter by name . Note that identifiers \nin SNOBOL4 are not inherently meaningless symbols as they are in most languages. ~[V](K,6) = K(llurnval[v] \nin E) where Numval:Nnll + N + R establishes the correspondence between syntactic numerals and abstract \nnumbers. ~[ws](K,6) = Getunop(Map(U in Char* ))f3k@.@(&#38;II&#38;] )(K,(3) The operation $ associated \nwith u in the current store is applied to the unevaluated expression ~[c] and the given continuations; \nthe store is passed along by the composition operator. Similarly: ~[e~ ~ CZ](K,O) = Getbinop(~ap(u in \nChar* ))@k@. @(~[c~],t[C, ])(K,8) 6UE(S,,C2,... ,Sn)](K,8) = Getfcn(Map(~ in Char* ))@kO.O(t[sll, . . \n. ~[&#38;nl) (K,@) 2.3 Functions The notation we shall use to specify the values, functions, and operations \nstored as initial contents or attributes of variables i-s exemplified by having $? denote the operation \nGetunop(Map(? in Char*)), where O. i.s the state of the store when program execution begins. Then: $?(~) \n(K,6) = u(l~.K(O in E),e) The interrogation operator returns the null string if evaluation of its operand \nis successful, and fails otherwise. The negation operator fails if its operand succeeds and returns the \nnull string otherwise: @q(U) (K,6) = U(a~.6,K(~ in E)) The name operator transfers the value of its operand \nfrom L into V. @.(U)(K,6) = U(kn.K(~al(nlL) in E),O) The indirect reference operator transfers the coerced \nvalue of its operand from V to L. @$(U) (K,e) = U(Coerce (k~.K(Var(vlV) in E)),fI) The deferred evaluation \noperator returns its operand as an unevaluated expression: $*(U) (K,@) = K(U in E) Then: @EvAL(u) (K,e) \n= u(coerce(An. (n:W + nlW,~(n as Q as ExP))(K,6) ),6) where the suffix as EXP converts a string into \nan expression (parsing) . APPLY causes the application of the function attribute of its first argument \nto the other arguments: OAppLY(UO lUll. .. JUn)(K ,0) = UO(Coerce (A~.Getfcn(~ as Q)$a@.I$ (UI, . . ..Un)(K \n,0)),8) UNLOAD erases the function attribute of its argument and returns the null string: $ NLoAD(U)(K,e) \n= U(Coerce (kll.Setfcn(~ as Q,l)oK(O in E)),O) Functions and operations may be assigned by use of OPSYN: \n(U1,U2,U3)(K,6) = Ul(COerCe(Kl),o OPSYN where KI(T_IZ) = Uz(Coerce(K2),o) where Kz (Tlz) = U~(Coerce(Ks) \n,6) where K3 (T13) = opsyn(~I as Q,rIz as Q, ~ as N)OK(Q in E) where 0psyn(&#38;l,6z,l) = (1=13 + Getfcn(~z) \n@~$.Setfcn(~l~$) I 1=1 + (6z:OP + Getunop(dz), Getfcn(6z))@k$ .(61 :OP + setunop(~l,$), .$etfcn(~l,$))~ \n1=2 + (6z:0p + Getbinop(dz), Getfcn(6z))~A$ .(61 :flp + setbinop(~l,$), setfcn(~l,~)),~) DEFINE obtains \nthe defined function s name, parameters, and locals by analyzing its first argument (the prototype ); \nwe suppose that a function Define: L x L* x L* x Q + F is then invoked to create the defined function, \nwhere the arguments are the function name, parameters, locals, and entry point. The defined function \nsaves the current contents of the name, parameters, and locals, and the label attributes of the three \nsystem labels RETURN, NRETURN, and FRETURN; then these are initialized appropriately and control transfers \nt-o the entry point. When control returns, the saved quantities are restored in reverse order. We use \n6B, 6 and 15F to denote ~ap(RETURIJ in Char*), Map(NRETURN in Char*), $ and Map (FRETURN in ~har ), respectively. \nThen: Define (a, (.. .,(Ji,. . .j, (. .,aj,. ..), d)(u 1,..., Un)(K,O) = ul(Coerce(Kl)te) where KI(T_lI) \n= Uz(Coerce(Kz),o) . . . where Kn(rln) (U) = let B = Contents(a) (U) and . . ..bj-r. . . = . . ..COntentS(Ui) \n(U),... and . .. JBjl... = ...~contents(~j)(a)~... and XRIXN8XF = Getcode(6R) (cJ),Getcode(~N) (~),GetcOde(~F) \n(~) in (CJpdate(a,~ in v)o...oupdate(~i~~ilv) ... update(aj~~ in V) ... SetCOde (6R,C0ntents (a)eA@ \n.Restore K(6 n )) .Setcode (6N,Contents (a)@lB .RestOre K(Var (~ ) n )) oSetcOde (6F,Restore 00) OGetcode \n(&#38;)@kX.X) (0) where Restore(U ) = (Setcode(~F,XF)OSetcode(~N/XN) 0Setcode(6R~XR) 0... .Update(a, \n,E3,) o.. .oUpdate(ai ,~i) . .. update (u/~)) (~ ) 13 2.4 Patterns Pattern matching is one of the most \ninteresting and complex features in SNOBOL4. We shall discuss only the FULLSCAN mode of matching; patterns \nmay then be modelled by functions which are applicable to the followin9 arguments: (i) a subject string; \n (ii) a cursor, which is an index into the subject to indicate where the match is to be attempted;  \n(iii) three continuations, to be applied if the local match is successful (the subsequent), if the local \nmatch is unsuccessful (the alternative), and i.f the global match i.s to be aborted (the failure continuation) \n; (iv) code for prior conditional assignments, to be evaluated if the global match succeeds and has this \npattern as a component; (v) the current store, to allow for side effects from immediate assignments \nand evaluation of unevaluated expressions.  Hence: n:P = Qx Nx Sb X/llt X F1 X C+ S+s patterns A successful \nlocal match might move the cursor, add conditional assignments, create new alternatives, and change the \nstate of the store: y:Sb= N x Alt X C * S+ S subsequent An alternative is simply applied to the current \nstore: L:Alt = S + S alternatives The domain of code and failure continuations were previously defined \nas: =s+s X:c code f3:F =s+s failure continuations We may now define some of the built-in pattern values \nas follows: ( 5,1,4,L,6 ,X) = ~ FAIL TABoRT(8, 1,v,L,0rx) = e (6,1,0,1 ,6,X) = 4(1,8,X) FENCE TrREM(8, \n1,+,L?,e,x) = v(#6,L,x) A typical built-in pattern-valued function is LEN; LEN attempts to match a substring \nwhose length is given by its operand. If this is an unevaluated expression, it will be evaluated when \nthe match is attempted; if this evaluation fails or the subject is not long enough, the local match fails, \nand if the integer is negative it is an error: @~EN(U)(K,8) = U(Coerce (~T1.K(Len(rl) in E)),6) where \nLen (Il)(6,1,~,L,9,X) = (~:W + (Ill W) (COerCe (K ),k),K (~)) where K (~ ) = (~ <0 + l,li-1 <#6 + ~(1+1 \n,k,x),~) where I =n as N The other built-in pattern-valued functions (except for ARBNO) could be similarly \ndefined. The fundamental pattern operations of alternation and concatenation may be defined as follows: \nAlt(7TI,T2)(d,l,I/J,,t,6 ,X) = TI(d,l,7j,ir ,6,X) where k = Tz(drl,$,k,e,x) i.e. try nl and if unsuccessful, \ntry nz with the original cursor, alternative, and conditional assignment restored. Cat (Tr~,iT2) (6,1,7),5L,6 \n,x) = TI(6,1,+ , !,,O,X) where $ (1 ,8 ,x ) = IT2(IS, I ,IJJ,L ,8,X ) i.e. try n and if successful, \ntry T2 with the new cursor, alternative, and conditions assignment. These operations are invoked by the \nalternation and concatenation operators , but implicit conversion to pattern values may be necessary, \nand so we define the convertibility predicate -Q and the conversion suffix as P , as follows: B-Q = B:Q \nJ !3:N v B:R !3 as P = (B:P -+ f31P, B:W+ ITl,lr,) where ITI(8,1,$,t,8,x) = (B \\W)(Coerce(An. (n as P) \n(6,1,V,L,6,X)),L) and Trz(6,1,4,L,6,x) = (6 = 5 [1:1 ] +IjJ(l ,1 ,x),!z) where l =1+#15 where 8 =6 as \nQ Then: 17(WJ2)(K,e) = U1(Coerce (l~I.U2 (Coerce (knz.K(Alt(rll as P,rlz as P)in E))),6) ),8) Concatenation \nis more complicated because strings may also be concatenated and the null string receives special treatment: \n$ (u1,U2)(K,8) = ul(coerce(~~l.uz(coerce(an 2. K(cat (nl,n2) )),@)),@) where Cat (i11,T12) =(nl-QAnlas \nQ=O+ IIZ, T127-QA T72 as Q = 52 + v], (III-Q A~2-Q + m as Qn r12as Q, Cat(nl as P, Vz as P)) in E) Patterns \nwith implicit alternatives require recursive definitions; we use some of the subsidiary functions previously \ndefined: = Alt(~ as P,mSuCcEED) SUCCEED = Alt(~ as P,Cat(Len(l in E),ITARB) ARB $~RBNO(u)(K,e) = u(coerce \n(Xn.K(Arb~O(n as p) in E)),e) where Arbno(7T) = A2t(~ as P,Cat(7T,Arbno (m))) The cursor assignment \noperator returns a pattern which matches the null string after assigning to its operand the current cursor \nposition; if the operand is an unevaluated expression, it will be evaluated during the match: $@(u) (K,6) \n= U(A~.K(At(~) in E),O) where At(Tl)(6,1,V,L/e,X) = (T-I:W + (n lW)(K ,L),K (n)) where K (T7 ) = Update(~ \nlL,~ in V) O$(I,L,X) The immediate assignment operator returns a pattern which assigns the substring \nmatched by its first argument to its second argument, which may have to be evaluated during the match: \n@$(U1,u2)(K,6) = ul(coerce (Anl.u2 (An 2.K(DOl~ar(rll as P,n2) in E),o)),e) where Dollar (n,rl)(d,l,$, \nL,@,X) = IT(6J~J~ JL,oIX) where ~ (1 ,9. ,x ) = (n:W + (T-IIW)(K ,i? ),K (TI)) where K (Tl ) = Update \n(rll L,6[l:~ 1 in V) OIIJ(I ,~ IX ) Conditional assignments are deferred until the global match succeeds; \ncode for a substring assignment is simply composed with the current conditional assignment argument. \nEvaluation of the location may also be deferred, but if this evaluation fails, the assignment is skipped: \n$.(uI/u2)(K19) = Ul(Coerce (~~l.Uz(a~?. .K(Dot (TIl as F ,T12) in E),@)),@) where Dot(r,~)(~,~,$,~,e,X) \n= m(~Ilr~ ,LJ8JX) where O (l ,L , X ) = W(I ,L ,X ) where X = (rI:W + (TIIw)(K ,x ),K (TI)) where K (Tl \n) = X oupdate(~ lL/~[~: I ] in V) 2.5 Commandsr Statements, and Programs Commands are interpreted relative \nto two continuations which are to be applied to the current store in case of success or failure: ~:Cmd+Cx \nFl+S+s We will specify the most complex case only: a replacement command with pattern matching in unanchored \nmode: Cucl:2 = E,n(x,e) =($[ed(K,r6) where KI(TII) = &#38;[ E2](Coerce(K2 ),6) where Kz(nz) = Content \ns(~ll L)@k B.~atch ((3 as Q,O) where h atch(d, l) = (1=#6 + tl,(~z as P) (6, l,Replace (d,l),Match(6 \n,I+l),f3,Acr.u)) where Replace (6,1) (l ,~, X ) = X [E31(C0erce(K3 ),6) &#38; where K3(i73) = Update(ill/L,Insert \n(T13 as Q) in V)OX where Insert (d ) = d[O:~]66 6[:#6]6] A goto is interpreted by obtaining the code \nattribute of the value of the expression and applying it to the current store; it is an error if the \nevaluation fails: d:Goto + S +S  #[(.)] =f[.](a~.~etcode(~]L Q)CBAX.X,L The coerced value of the expression \nin a direct go to should be of type code: ~[zs>j =~Iel(COerce(in.nlC) L) A statement is interpreted relative \nto a code continuation which is to be applied if there is no explicit transfer of control: ~:Stmt+C+ \nS+ s A[vl(x) =C[ul (x,x) J?3UU=CIPl(X rX ) X =ij[yl :Y3(X) where di[lJ :Syl (x) = CIILII(!?%YI,X) z3KlJ:Syl \n-FY21 (X) =C IIUID,AIY21) ( [Y, and similarly for the other possible arrangements. A program is interpreted \nrelative to the state of the store, and yields the final state as result: @:Prog + S+ S <n Ln END ~j \n] = x~ xj where XO = SetcOde (Map[Ell,Xl) O... .Setcode(Map[~n] ,Xn) and Xi ~~~i](xi+l), for i=l,2,..., \nn and Xn+l(U) = IJ If the suffix as Prog denotes the parsing of a string as a program, then @CoDE(U) \n(K,o) = U(Coerce (aI1.K(f (h as Q as Prog) in E)),8) 3. DISCUSSION 3.1 Gimpel s Theory of Patterns The \nformalization of pattern matching in Gimpe15 is based on the following definition: IT:P = Q X N+ N* patterns \nA pattern is a function, but is applied to only a subject string and a cursor; the resulting list of \ncursor positions defines the substrings that are potentially matchable, in order of preference. For example: \nThe fundamental pattern operations arekhen defined as follows: Alt(lT~,7r~) (6,1) = m1(6,~)Arl(6,~) The \nlimitations of this model are evident; aspects of SNOBOL4 pattern matching which cannot be treated using \nthe above definitions are the primitives ABORT and FENCE, conditional and immediate assignments, unevaluated \nexpressions, and side effects. The following are stated in [5]: Proposition 1 Concatenation is associative. \nProposition 2 Alternation i.s associative. ~3 Concatenation distributes over alternation from the right. \nIt may be verified that they also apply in our much more general model. Further results are based on \nthe concept of a monic pattern which always either fails, or succeeds in just one way; then: Proposition \n4 If 7r iS rnOnic, Cat (TT,Alt(n1,7Tz)) = Alt(Cat (lT,7Tl),Cat(n,TTz )) Pr~ 5 The concatenation of monies \nis monic. Proposition 6 (Canonical Form) Any pattern formed by concatenation and alternation of monies \nmay be written as an alternation of concatenations of monics~ These results may be applied in our model \nby defining a pattern T to be monic if for all 6,1,~,!.,13, and X, either T(6,Z,~,L,9rX) = L for all \n~ and !?, (IT fails), or for some 1 and x , n(d,~,~,!,e,x) = $(8 ,L,x ) for all ~ and k (n succeeds in \njust one way) The canonical form is used by Gimpel to verify the correctness of a pattern-matching algorithm \nthat is the basis of SNOBOL4 implementations. However, if there are unevaluated expressions, pattern-matching \nassignments, etc. , the canonical form result is not applicable. Presumably the algorithm could be verified \nin the general case using the model discussed in this paper. 3.2 Semantics and Language Design Scott \nand Strachey have suggested that semantic modelling should influence the design of programming languages. \nIn this section we consider a small example of this by analyzing a number of pattern-valued functions \nthat have been proposed as extensions of SNOBOL4. The original proposal was as follows17: AND(A,B) matches \nstrings matched by A and B NOT (A) matches null unless A would match, in which case it fails This was \nthen modified and elaborated as follows18: AND(A,B) matches strings matched by A and B NOT (A) matches \nstrings not matched by A and extends like ARB FAIL (A) matches null unless A would match, in which case \nit fails NULL (A) matches null if A would match, else it fails There was some argument that NOT should \nbe replaced by: ANDNOT(A,B) matches strings matched by A but not matched by B Eventually the entire proposal \nwas abandoned because of continuing controversylg. We can attempt to shed some light on the issues involved \nby attempting to specify these functions. The least troublesome is FAIL (originally called NOT, probably \na more appropriate name); in our model: Fail(m) (6,1,~,~,e,X) = m(drl,v ,v(l,~,x),~,x) where ~ (t ,! \n,x ) = ! Also fairly straightforward is NULL which is useful for lookaheads : Null (lr)(d, l,lJJ,L,e,x) \n= 7T( 5,1,qJ ,L,e ,x) where ~ (l ,!t ,x ) = ~(l,i,x) It should be noted that the alternatives and conditional \nassignments created during the lookahead are discarded; this is not explicitly stated in the proposal \nbut since FAIL and NULL are evidently the pattern matching analogues of the operators T and ? , it is \nappropriate to have NU1l = Fail o Fail, just as ?C = 11s. The other functions are problematical because \nthey are presumably based on a set of strings model of patterns; for example, AND is intended to implement \na set intersection. However, as we have seen, SNOBOL4 patterns are far more complex; attempting to specify \nan AND function in our model raises the following problems: (i) If the first argument matches and also \ncreates new alternatives, but the match of the second argument fails, should these alternatives be ignored \nor backed into with the hope that side effects may occur to cause the second pattern to match? (ii) \nIf both patterns match but the subsequent fails, which alternative should be backed into?  (iii) If \nboth matches succeed, which conditional assignments should be recorded? (iv) If the patterns match substrings \nof different lengths, is it a failure of the conjunction? If so, which alternative should be applied, \nand if not, where should the subsequent begin matching? Hence NULL and FAIL seem well-defined and could \neasily be implemented as described; however, the other proposed functions are unsatisfactory because \nthe underlying semantic model is inconsistent with the actual nature of SNOBOL4. In most practical situations \nthe following substitutions would be suitable: FAIL (A) for NOT(A) NULL(A) B or NULL(A @X) B @Y *EQ(X,Y) \nfor AND(A,B) FAIL(B) A for ANDNOT(A,B) This has been a fairly small illustration, but it demonstrates \nthe potential usefulness of semantic analysis in programming language design. The availability of a method \nfor precisely specifying the meaning of a proposed facility or comparable facilities in other languages \ncan help the designer to clarify his ideas and to discover simplifications and generalizations far sooner \nthan would otherwise be possible. REFERENCES 1. Griswold, R., Poaget J. , and Polonsky, I. , The SNOBOL4 \nProgramming Language; Prentice-Hall, Englewood Cliffs, N.J. (second edition) 1971.  2. Wegner, P., The \nstructure of SNOBOL4; Technical Report 68-9, Dept. of Computer Science, Cornell Univ., 1968.  3. Harrison, \nM.C. , Data Structures and Programming; Courant Institute of Math. Sciences, New York, 1970.  4. Griswold, \nR., The Macro Implementation of SNOBOL4; Freeman, San Francisco, 1972. 5. Gimpel, J., A theory of discrete \npatterns and their implementation in SNOBOL4; CACM 16, 2, 91-100, 1973.  6. Scott D., and Strachey C. \n, Towards a mathematical semantics for computer languages, Proc. Symposium on Computers and Automata; \nPolytechnic Institute of Brooklyn (1972).  7. Scott Conf. D., vol. Mathematical 40, 225-234, concepts \n1972. in programming language semantics; Proc. AFIPS 8. Strachey, Laboratory, C., The varieties of Technical \nmonograph programming PRG-10, language; (1973). Oxford University Computing 9. Hoare, PASCAL, C.A.R., \n1972. and Wirth, N., An axiomatic definition of the programming language 10. Lucasr Automatic P., and \nWalk, Programming, K., ~, On 3, the formal 1969. description of PL/I; Annual Review in 11. Fang, Science \nI., FOLDS, a declarative Report CS-72-329, 1972. formal language definition system; Stanford Computer \n12. Scott, Princeton D., Outline Conf. on of mathematical Information theory Sciences of and computation; \nSystems, Proc. 169-176, 4th 1970. Annual 13. Scott, D., prOgranUlling Lattice theory, Languages, ed. \ndata types, R. Rustinr and semantics; prentice Hall, in Formal Englewood Semantics Cliffs, of N.J., 1972. \n14. Scott, D.r Languagesr The ed. lattice of E. Engeler, flow diagrams; Springer-Verlag, in ~ Heidleberg, \n1971. 15. Reynolds, Proc. ACi 4 J.C. 27th , Definitional Nat. Conf. interpreters 1972. for higher-order \nprogramming languages; 16. Wadsworth, C.r Another approach to jumps: continuations; (unpublished) 1972. \n17. SPITBOL newsletter 2, Illi,noi,s Institute of Technology, 1972. 18. SPITBOL newsletter 3, Illinois \nInstitute of Technologyr 1972. 19. Dewar, R., personal communication.  \n\t\t\t", "proc_id": "512927", "abstract": "This paper analyzes the semantics of the programming language SNOBOL4, following the <i>mathematical</i> approach proposed by D. Scott and C. Strachey. The study aims at clarifying a rather unusual semantic structure, and at demonstrating that the mathematical approach can provide a natural and usable formal specification of a practical programming language.", "authors": [{"name": "R. D. Tennent", "author_profile_id": "81100474381", "affiliation": "Queen's University, Kingston, Ontario", "person_id": "PP43120291", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512927.512936", "year": "1973", "article_id": "512936", "conference": "POPL", "title": "Mathematical semantics of SNOBOL4", "url": "http://dl.acm.org/citation.cfm?id=512936"}