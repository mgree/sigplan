{"article_publication_date": "10-01-1973", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1973 ACM 0-12345-678-9 $5.00 TYPES ARE NOT SETS* James H. Morris, Jr. Xerox Corporation Palo Alto Research \nCenter (PARC) Palo Alto, California 94304 Introduction . The title is not a statement of fact, of course, \nbut an opinion about how language designers should think about types. There has been a natural tendency \nto look to mathematics for a consistent, precise notion of what types are. The point of view there is \nextensional: a type is a subset of the universe of values. While this approach may have served its purpose \nquite adequately in mathematics, defining programming language types in this way ignores some vital ideas. \nSome interesting developments following the extensional approach are the ALGOL-68 type system [vW], Scott \n~s theory [S], and Reynolds system [R]. While each of these lend valuable insight to programming languages, \nI feel they miss an important aspect of types. Rather than worry about what types are I shall focus on \nthe role of type checking. Type checking seems to serve two distinct purposes: authentication and secrecy. \nBoth are useful when a programmer undertakes to implement a class of abstract objects to be used by many \nother programmers. He usually proceeds by choosing a representation for the objects in terms of other \nobjects and then writes the required operations to manipulate them. There are two problems about the \ninteraction of his programs with ethers that he has great difficulty solving without the aid of a ty \nFe system to constrain the interactions. First, users of his programs may ask them to operate a * This \nwork was supprted by NSF Grant GJ34342x while the author was at the University of Californiar Berkeley. \n 120 value that is not a valid representation of any of the objects he has undertaken to process. This \nis the authentication problem. He could begin each operation with a well-formedness check, but in many \ncases the cost would exceed that of the useful processing. Second, users may write programs that depend \nupon the particular representation he chooses for objects. This precludes his re-designing the representation. \nThis is the secrecy problem. Type checking is a way to prevent such things from happening. All values \nused to represent the abstract objects are considered to be of a certain type. The rules are: (1) Only \nvalues of that type can be submitted for processing (authentication) . (2) Only the procedures given \ncan be  applied to objects of that type (secrecy). The remaining question is how to decide whether a \ngiven value has a particular type. The foregoing discussion should serve to persuade the reader that \nthe question should not turn on what the value is, but rather where it ca=?rom or @Q created it. In other \nwords type should not be an extensional property. I shall now outline the design for an extendible type \nsystem based on the foregoing considerations. Modules The overall structure of the language must permit \ndifferent parts of the same program to have different capabilities. Any language with textual scope rules \nhas this property to some extent; e.g. a FCRT RAN subroutine has exclusive access to its local variables. \nThe syntactic construct module is introduced to provide such structure. Basicallyv a module has the form \nof a complete ALGOL-60 program (delimited by godule, ~Q~); the main program part (if any) may be used \nto perform initialization. A module may appear anywhere a declaration can. Any identifiers declared at \nthe outer-most level of the module may be tagged (with +) to signify that they are entries in which case \nthey are known in the enclosing block . If the identifier denotes storage that storage may be read (but \nnot written) from outside the module. If it denotes a procedure, the procedure may be called from outside. \nA module is very similar to a SIMULA class [D]. Example ~. The following program defines and tests a \nscheme to remember equivalence classes. The array A and Grocedure R are unknown outside the module, while \ncount , Equiv, and Equate are known. module integer array A [1:100]; integer +count: integer ~ocedure \nR(i) ;integer i$ = integer t; t:=i$ while A[t]#O @i t:=A[t]; R:=t end: Bo~~an procedure +Equiv (xry) \n: integer x,y: Equ iv := R(x) = R(y) ~cedure +Equate (x,Y); integer X,Y: -_ ~nte9er U*V; u:=R(x) ; v:=R(y); \nbeqin count:=count-1: A[u]:=v ~Q *; ~ count:=l -Q 1 until 100 @ ~count]:=O: count :=100 end E~te (10,20); \nEquate (20,5); Print (count); Print (Equiv (10,5)) The programmer of a module is supposed to assume nothing \nabout the Frograms that access its entries. He should use private storage to maintain the integrity of \nhis data structures and treat parameters with suspicion. (The previous example violates the latter unless \narray-bounds checking is assumed.) A module~s initialization part is executed whenever its enclosing \nblock is entered. The question of whether modules can call each other recursively is ducked. while it \nis conceptually simpler to regard every program as one piece of text. in practice one must break them \nUF to facilitate editing, compiling, etc. The most natural way to do this seems to map (large) blocks \ninto file directories and modules into files. ZYL?SS First, a thoroughly dynamic type mechanism, similar \nto that in [M] will be presented. It seems more appropriate for operating systems and is similar also \nthe one designed for Carnegiees HYDRA system [w]. Performing the operation Createseal(false) delivers \nto the caller two capabilities (in the form of procedures) Seali and Unseali along with the integer i. \nThese things are unique in the sense that Createseal returns different versions every time it is called. \nIts role is analogous to a locksmiths. Seali (X) produces a value xc with the following limited properties \n(i) Testseal(X*,i) is true (ii) Unseali(X~)=X  In addition, unless y is a value produced by Seali , \nTestseal(y,i) is false and Unseal (y) causes an error. The seal is S2E2Q42 in the sense that no properties \nof X can be discovered; i.e. a primitive applied to X! causes an error. The operation Createseal(true) \nproduces a transparent sealing operation Sealiv along with i. 7%e value XS=Seal (X) retains all the properties \nof X except that Testseal(XC) is true. In addition, Testseal (y,i) is false unless y was produced by \na succession of seal operations one of which was Seali. In other words, transparent seals are like trademarks \nin that any number may be affixed without obscuring each other or any other properties of the object. \nIt is suggested that a programmer implementing a new type use these operations in the following way. \n(1) During module initialization he calls createseal, with false if he wishes an oFaque type, true otherwise. \n (2) Every time an object of the new type is passed out of the module he guarantees that it is sealed. \n (3) Every time a value allegedly of  the new tyFe is passed into the module he tests its seal and unseals \nit if it is opaque. This scheme detects type errors by extra-module code since only the module is 121 \nable to put its seal on things. Further, the ALGOL-68 sense) . The second if the seal is opaque the representation \nimplements intervals as real pairs: the of the new type is kept a secret. third, complex numbers as real \nFairs. Each of *he new types may be used in A considerable gain in clarity and declarations outside its \nmodule. Since efficiency can be achieved if the realpair and interval are transparent following assumptions \nare valid. types a value of type interval may be treated like an array for purposes of (a) A fixed number \nof new types are reading. However, an assignment to an created by the program, intervals component independent \nof the data. int[l] :=5 (b) Each new type is represented by a set of values describable as a is not \npermitted because it is regarded as compile-time tyFe (e.g. an the assignment ALGOL-68 mode). int := \n<5,int[2]> (c) Sealing, testing, and unsealing  are performed only at module and the right-hand side \nhas implicit type boundaries in the manner real array which implies an upward described above. coercion. \nSince complex is an opaque type complex numbers must be treated as atoms (d) Testseal is never used. \noutside the module, using the procedures re and im to get at their components. In such cases the type \nchecking (exclusive of union testing) can be done at module . compile-time and the sealing-unsealing \nactivity becomes so imElicit as to ~~ +realpair 2 real array [1:2]; disappear. realpair procedure +mkpair \n(x,y) ; real. x,y; To invent a new type in the static system beain yk;~i~r t; t[l]:=x; t[2]:=y; : =t \none makes a declaration of the form end ~~g <name> {>12] <type description> end; \u00ad module Normally the \nname will be tagged as an entry, indicating that the type name can ~~ +intervalZrealpair; be used outside \nthe module. If > is used interval procedure mkinterval (xry) ; the type is opaque, if 2 it is real x,y; \ntransparent. The type checking rules can mkinterval:=~~ x<y then mkpair (x,y) - be summarized bv some \nsimt)le. coercion Q= mkpair (y,x) ; rules interval ~cedure sumint (xry) ; interval x,y; (1) Inside the \nmodule <name> sumint:=mkpair (x[l]+y[l], x[2]+y[2]) simply an abbreviation f: end; <type description>; \ni.e. coercions in either direction module \u00adare allowed. ~g +Complex>realpair; (2) Outside the module \nan opaque complex procedure mkcomFlex(x,y) ; type cannot be coerced at all; real X.V: -4. i.e. something \ndeclared a <name> mkcomplex := mkpair (sqrt(x*x+y*y) , can reside only in contexts &#38;g x=6 t-pi/2*(y/abs(y) \n) -\u00addeclared such. ~ arctan (y/x)) ; real procedur~ re(c) : complex c; (3) Outside the module a transparent \nre := C[l] * Cos (C[21): type may be coerced downward; real procedure ire(c); complex c; i.e. something \nof type <name> im := C[l] * sin (c[2]) may move into contexts with type ~g <type description>, but not \nback. real t: real array a [ 1:2]; realpair x; interval y; complex z; It should be emphasized that coercion \nhere := mkinterval(5,10); x:=y; a:=y; t:=y[2]; never induces any computation. The rules y:=sumint (ycy) \n; z:=mkcomplex (3,6.5) : simply serve to control the contexts t:=re(z); t:=im(z) values may move between. \nThere are several statements that would not be legal in the main Frogram. Among ~xample ~. The following \nprogram defines them are and exercises three modules. The first implements pairs of real numbers as arrays \nY x:=a; Y:=x; Y[2]:=6; sumint(y,x); (assuming arrays are heap allocated, in x --.-z; y:=z; t:=z[l] 122 \nThe first four call for upward coercions which are never permitted while the remaining three attempt \nto coerce an opaque type. This type system has been designed to facilitate program verification on a \nmodular basis. The general principle is that a module writer should not have to look outside his module \nto verify its correctness. Part of this is achieved by defining correctness judiciously and the rest \nby having the type checker restrict how the outside world communicates with a module. Associated with \na new type T may be a ~ invarian~ of the form xeT => P(x) e.g., xc interval=> x[1]<x[2] To prove that \nit holds everywhere outside the module the verifier must (1) prove P (v) holds for every variable v of \ntype T at the end of initialization (if any). (2) at each entry of the module assume the invariant holds \nand prove P (x) for all changed variables and returned values of type T at the exits of the module. \n For example, to prcve the interval invariant above one must prove that the parameters of each call of \nrnkpair j.n mkinterval and sumint are non-decreasing; in summint one may assume the invariant holds for \nthe formal parameters x and y. Opaque types do not facilitate proofs per se but their significance can \nbe illustrated by considering proofs. The external specification of a module might be given as a set \nof statements of the form Q(x,fi(x)) where f ~ is function describing the effect of the lth procedure \nentry. E.g. mkcomplex (x,y) = <x,y> z=<x,y> => re(z)=x z=<x,y> => im(z)=y Since values of an opaque \ntype cannot be sampled directly there is no need for these statements to be literally true; indeed they \nare not for the current example. The actual situation can be described by assuming an implicit representation \nfunction R which maps the underlying representation into the externally assumed one. E.g., R(z) = <z[l]*cos(z[2]), \nz[l]*sin(z[2])> Then the internal specifications given to the module writer are derived by inserfinq \nR at appropriate places. E.g., R(mkcomplex (x,y))=<x,y> R(z)=<x,y> => re(z)=x R(z)=<x,y> => im(z)=y \nNow the module writer is free to choose any R he likes and prove that the programs obey the internal \nspecifications. For this particular example he would be wiser to choose R to be the identity function \nand revise the program accordingly. The important point is that he is free to change R any time he likes \nand the external specifications need not change. Remarks The type system presented here is like SIMULA~S \nclass construction but improves on it in a few respects. First, it allows the module writer to have absolutely \nprivate data while SIMULA allows outside programs to access all a classms storage. Second, it makes implementing \nbinary operations on new types simple, something that is nearly impossible in SIMULA. A student of Hoarets, \nJohn Elder, has designed revisions of the SIMULA ClaSS mechanism to overcome these problems. The notion \nof a transparent type provides a very limited form of polymorphism. If several transparent types are \ncoerceable UUWII U-I .S SLIIYLe base type it is possible to write a single procedure that accepts any \nof those types as a parameter. It is not entirely clear how to achieve true polymorphism since such a \nprocedure is unable to return values of varying type, dependent on the input type. An interesting point \ncomes up when one tries to justify the proof rule for type invariants: what constitutes a module entry \nor exit? If one has a language like ALGOL-60 with recursion and non-local transfers, each procedure call \nin the module must be regarded as an exit followed by an entry. This can be quite bothersome because \nit requires thdt everything be cleaned UE (i.e. the invariants truth assured) before every procedure \ncall. It is therefore appealing to put the following constraints on the control structure. (1) Any recursive \nchain of procedures must be entirely within one module and cannot involve entries of the module. (2) \nA non-local transfer cannot cross any module boundary.  To mitigate the effect of the lattez restriction \none can provide an error exit mechanism similar to PL/1 on-conditions. 2+n error signal propagates back \nalong the 123 call chain allowing each module to clean things up so as to restore its invariant. References \n[v$+] van Wijngaarden, A., Report on the Algorithmic Language ALGOL-68,*! Mathematische Centrum, 1969. \nWoutline of a Mathematical [S] Scott, D., Theory of Computation,tt PRG-2, Oxford University. llA [R] \nReynolds, J.C., Set-Theoretic Approach to the Concept of Type,vt Argonne National Laboratories, 1969. \n [D] Dahl, O.J., and Hoare, C.A.R.. ItHierarchical Program Structure, 9* Structural Proqrammi~, Academic \n. ____ Press, 1972. Ilprotection [M] Morris, J.H., Programming Languages, 81 Comm AC: . ~ (l), Jan. \n1973. [w] Wulf, w.A., et. al., Hydra: the Kernal of a Multiprocessor Operating System,qn Department of \nComputer Science, Carnegie Mellon University, June 1973.\n\t\t\t", "proc_id": "512927", "abstract": "The title is not a statement of fact, of course, but an opinion about how language designers should think about types. There has been a natural tendency to look to mathematics for a consistent, precise notion of what types are. The point of view there is extensional: a type is a subset of the universe of values. While this approach may have served its purpose quite adequately in mathematics, defining programming language types in this way ignores some vital ideas. Some interesting developments following the extensional approach are the ALGOL-68 type system [vW], Scott's theory [S], and Reynolds' system [R]. While each of these lend valuable insight to programming languages, I feel they miss an important aspect of types.Rather than worry about what types are I shall focus on the role of type checking. Type checking seems to serve two distinct purposes: authentication and secrecy. Both are useful when a programmer undertakes to implement a class of abstract objects to be used by many other programmers. He usually proceeds by choosing a representation for the objects in terms of other objects and then writes the required operations to manipulate them.", "authors": [{"name": "James H. Morris", "author_profile_id": "81332516966", "affiliation": "Xerox Corporation, Palo Alto Research Center (PARC), Palo Alto, California", "person_id": "PP31028920", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512927.512938", "year": "1973", "article_id": "512938", "conference": "POPL", "title": "Types are not sets", "url": "http://dl.acm.org/citation.cfm?id=512938"}