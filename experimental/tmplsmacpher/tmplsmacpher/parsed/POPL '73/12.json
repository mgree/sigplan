{"article_publication_date": "10-01-1973", "fulltext": "\n MODE MODULES AS REPRESENTATIONS OF Permission to make digital or hard copies of part or all of this \nwork or personal or classroom use is granted without fee provided that copies are not made or distributed \nfor profit or commercial advantage and that copies bear this notice and the full citation on the first \npage. To copy otherwise, to republish, to post on servers, or to redistribute to lists, requires prior \nspecific permission and/or a fee.&#38;#169; 1973 ACM 0-12345-678-9 $5.00 PRELIMINARY REPORT Alice E. \nFischer Waltharn, Massachusetts and Michael J. l?ischefi Massachusetts Institute of Technology, Cambridge, \nIntroduction High level programming languages tend to free a programmer from concern about the underlying \nmachine structure ad permit him to talk about his problem domain in more direct terms. Thus, he may imagine \nthat objects such as real numbers, character strings, and linear arrays really exist in the machine as \natomic entities and he need not understand the details of how they are actually represented in the machine. \nOf course what distintiwishes various kinds of objects are the operations that may b performed on them, \nso when talking about the domain of real numbers, we should include the basic arithmetic operations and \nconstants, and for strings, operations such as length, concatenation and indexing. Unfortunately, existing \nlanguages do not permit a programmer to ignore completely questions of representation, for if his problem \ndomain does not happen to be included already in the repertoire of domains supported by the language, \nthe programmer must figure out a representation himself and remember it throughout his programming effort. \nFor example, a FORTRAN programmer may know that it is not meaningful to multiply two integers that happen \nto re resent insurance policy numbers, gut he has no way of informing the compiler of this fact . Many \nextensible languages do provide a wide range of data types including structured types, enabling a programmer \nto choose a more natural representation of his external objects, but the structured data types reflect \nonly the structure of the data, not its meaning. They sti~ provide only one natural representation for \nboth integers and dates, mass and speed, or planar vectors in Cartesian or polar coordinates. *This research \nwas supported in part by the National Science Foundation under research grant GJ-34671- ManY domains \nthat arise in practice have a @eat deal of similarity %etween them which one must employ in his programs. \nFor example, the domain of length 3 vectors and the domain of length 4 vectors have the same rule of \naddition, that is, add componentwise, and it would be onerous to have to repeat this information for \neach new length vector. Thus, one needs both the ability to define brand new domains and also a method \nfor expressing relations among them. We present here some mechanisms, collectively called Aleph-1, which \nallow the expansion of a programming language s repertoire of internal domains. Many of the ideas embodied \nin Aleph-1 have been described previously in t+e literature, and we acknowledge their Influence on our \nthinking, in particular the work of Balzer [l] and Reynolds [5] s~esting the utility of separating out \nthe abstract behavior of an object fron its representation, the languages Pascal [10] and Simula-67 [3] \nwhich associate functions with data types and types with alternate representations, modular generic functions \nin Basel [2], Standish s wide variety of structured data [6], ad the systematic (though not extensible) \ntreatment of coercion in Algol-68 [8 . Our domain mechanisms tear certain s 2rong similarities to those \ndeveloped by Morris for the purposes of protection [4]. Representation of Domains Semantics of Eata \nTypes Declaring a variable to be of a partictiiar data type limits the set of possible values which \nmay be assumed by the variable. This has obvious vslue to a compiler, enabling more efficient code to \nbe produced. It also affects the language with res~ct to debu~ing, program verification and modularity. \nEven in the so-called l!ty~lessi languages, where variables are not declared, actual data values have \ntypes which affect the semantics of programs. Each type forms a domain over which functions are defined, \n139 and types must be tested to determine which interpretation of the built-in generic operators is applicable \nin each context. Thus, APL evaluates scalar and aray expressions differently, and LISP differentiates \nbetween atoms and lists. Extensible Types The wider the variety of types available in a language the \nmore likely one is to be able to find a type which is a good model for the objects of his external domain. \nThus type-extension facilities have been included in various extensible languages . (Cf. PPL 7], i Algol-68 \n[8], Basel [2_J, EL-1 [9]. Such type-extension facilities typically permit the declaration of multi-cell \ndata objects, structured objects whose parts are drawn from previously declared types, pointer-types \nrestricted in various ways, and types which are finite unions of other types. Unions and pointers permit \nrun\u00adtime variability and dynamic growth of data objects. Useful as these types are for modelling external \ndomams, they have two major shortcomings, both of which occur because the types come with a built-in \nfixed structure. First, for each kind of structure, there is only one corresponding type and hence only \none domain whose objects have that structure. However, one frequently deals with different domains whose \nnatural representations have the same structure. For example, two\u00addimensional vectors in polar coordinates \nand the same vectors in cartesian coordinates are both naturally represented by a pair of real. numbers, \nyet the representations behave differently under addition, so no single definition of addition of pairs \nof reals is correct for both domains. The second shortcoming is that the kinds of structures provided \nare fixed and not always appropriate for a given domain. For example, an upper triangular matrix can \nbe mapped onto roughly half the number of storage cells required for a full matrix of the same dimensions, \nbut the required mapping function does not correspond to the one usually associated with rows or arrays. \nRepresented Types in Aleph-1 Abstractly, a data type T can be characterized as a set of objects, all \ncreated and accessed tmiformly, and all identifiable as members of T. That is, a type is characterized \nby its constructor, predicate and selectors [6]. To separate the behavior of a type from its physical \nstructure, it is =$%$:=;=:; .. specl la structure [1, 5]. Initiall defined in Aleph-1 are the 7 simple \ntypes real, integer, etc.) and the row, tuple and pointer type constructors similar to those in [2, 6, \n7, 8, 9]. From these, represented types with different properties may be created. Abstractly, a represented \ntype is a completely new set of objects with no pre\u00addefine structure; the accessing and other primitive \noperations on it are all supplied by the user. To permit these objects to be represented in the computer, \none specifies an existing set of objects (usually itself a type) as the representation of the new type. \nThe Aleph functions REP and MAKE are the necessary bridge between represented and representing modes. \nThus , if new mode N is represented by M, b is an object in M and a is an object in N, then REP(a) is \nan object in M, MAKE(N,bj is an object in N, and the two identities hold: MAKE(N, REP(a)) =aand REP(MAKE(N,b)) \n= b. The necessary accessing and constructor functions for N are then defined in terms of the functions \nREP and MAKE. This being done, the program can be written using just these defined functions with no \nfurther concern for the underlying representation. In this way we achieve nearly complete independence \nof a represented typs from the type used to represent it, for none of the functions defined on the underlying \ntype are defined on the new type REP and MAKE are the only links between them. Thus, each type is a \nmodule, protected from unintended interactions with other modules. The generic function facility to be \ndescribed later on plays a role here in permitting a function f to be defined over a new mode quite independently \nof whether the name l!f*t has been used for a function defined on some other mode. Relations Amo~ Domains \nSubdomains Frequently in an external domain, there are several natural subsets of the elements which \nhave soae special property &#38;hat enables especially efficient computation or representation. Thus \none may wish to have several representations for a given external object. To the extent that the representations \nreally model the same external object, they should be interchangeable, that is, any representation should \nbe acceptable to a function without affecting the result, thereby eliminating the proliferation of function \ndefinitions otherwise necessary. For example, a matrix can be represented as a twc-diaensiona.l array \nof storage, but 140 other techniques can be used to represent sparse matrices in less storage. Assuming \nwe have defined the types SPARSE-MATRIX and FULL-MATRIX, we would like to express the fact that both \nkinds of objects are instances of the abstract notion of 14ATRIX. Structure Classes All data structures \nof a given form constitute a natural domain with the constituent types as subdomains, such as the classes \nof all pointers, all rows of reals, or all length 3 rows. These domains are specifiable in Aleph-1 and \nfunctions defined on them may be applied to any object in the class. Examples are the coercion from a \npointer to a value and a general print routine that can print anything. Narrowed Domains Another useful \nkind of su.bdornain is specified by a predicate on a domain. I?or example, SQUARE-MATRIX is the set of \nall members of MATRIX such that the object-s two dimensions are equal. In Aleph-1, one can declare such \na narrowed domain and use it as the domain of defmi~f functions which may not be applicable over the \nfull domain, with the assurance that these functions will never be executed with arguments violating \nthe predicate. Thus one might use the narrowed domain SQUAREIMATRIX in defining matrix inverse. Conversions \nIn some cases where multiple representations of the s~e external objects exist, it may be preferable \nto convert automatically from one representation to another rather than have a special function for each \ncombination of representations. A familiar example is the numeric conversion from integer to floating \npoint that allows + to be applied to a pair of arguments, one of which is an integer and one a real. \nThe Mode Graph . The data base used in Aleph-1 to describe the modes is called the mode graph. The nodes \nof this directe~aph are modes, each the internal model of some exte=domain and the locus of semantic \ninformation about it. The edges of the graph are relationships among modes. The parts of a mode, explalned \nbelow, are: a representation set; -a set of edges leading to related modes; a set of typed function names, \ncalled generators. An individual mode might lack one or more of these parts. The node graph is built \nup piece by piece in almost any order by declarations. Modes are created by the declaration: DECL MODE \n<mode name> The single restriction on the order of declarations is that a mode must be created before \nits name can be used in other declarations. Representation Sets Every type has an associated mode, permitting \neconomy in the language by allowing all functions to be defined over modes and all domain relations to \nbe expressed in terms of modes. Representation t~s are created and attached to a mode by the declaration: \n<new mode> IS REP <representing mode> This creates a set of new objects as descriked above which will \nbe objects of the new mode. Mode Relations Variants of the single declaration form: @ode 1> YIELDS <mode \n2> IF <predicate>) VIA <conversion>} 1BIAS <integer>} suffice to express all three kinds of domain relationships \nand install the appropriate edge from mode 1 to mode 2 in the mode Craph. (Curly brackets denote optional \nphrases.) The bias clause is used to determine the choice of coercion/conversion ~ths when it becomes \nnecessary to apply a function to arguments of a domain on which the function is not directly defined. \nPaths of low total bias are preferred. If tt$elbias is not specified it is taken to The simple submode \nrelationship is expressed if all the optional clauses are absent. Tor example: FULL-MATRIX YIELDS MATRIX. \nNote that one main mode M may have several submodes Ml ,...,l4n, each subnode being a particular representation \nmode, and it may be the case that no data objects belong directly to M; rather an object is related to \n14 by virtue of its kdonging to some submode Mi. A narrowed mode is declared by adding the IF c3.ause. \nThe predicate here is restricted as follows: it is a boolean function of one argument; it is defined \nover the entire mode 1; its evaluation causes no side 141 effects. Within these limits the predicate \ncan be any function or single body belonging to a generic. For example, MATRIX YIELDS SQUAREMATRIX IF \nproc(matrix:M) bool M.diml = M.dim2 declares the condition under which a matrix is square. The functions \ndiml and dim2 give the dimensions of a matrix. Note that the declaration M YIELDS M IF P necessarily \nimplies that M is a subset of M. Thus the modes with their subset and predicate links form a partial \norder. The Aleph-1 mode ANY is the upper bound of this order, that is, all modes are subsets of ANY. \nTo declare that mode 1 is convertible to mode 2, the VIA clause is added and the Il? clause may or may \nnot be used. The conversion given here can be any function or single body of a generic such that -it \ntakes a single argument and is defined on all mode 1 objects which satisfy the predicate; it has no \nside effects; it returns an object of mode 2. EXAMPLE : REAL YIELDS INT IF proc(real:R) buol R < 2135 \nVIA l?IX.(real); INT YIELDS REAL VIA FLOAT.(int) Note: ~begins = inline definition of a function, while \nthe notation l?IX.(real) denotes that body of the generic named FIX which is defined for a REAL argument. \nBoth submode coercions and conversions permit a function defined on one mode to be applied to an element \nof another. However, the latter causes a change of representation and a corresponding change of mode \nof the argument while the former does not. Generic Functions We noted above that generic functions are \nuseful in avoiding naming conflicts among unrelated domains. In Aleph-1 they serve this role, but also \na more important one: they are the means for making use of the relationships among modes. The abstract \nfunction ranging over an abstract domain is modelled in Aleph-1 by a Generic function defined over a \nmode M which can take as argument an object from any submod.e of M. This generic 1s written only in terms \nof the generic selectors, or .qen~rators, declared For M and defined-for each representation-submode \nof ~. A generator declaration is a list of typed function names, naming the set of representation-dependent \nfunctions which are required to bootstrap from computation in each submode Mi to computation in M. They \nexpress all information necessary to link the functions defined on M to the modes Mi. Each submode Mi \nhas a function defined on it corresponding to each generator of M. Whenever the evaluation of a generator \nof M is required, the actual argument must belong to one of the representation submodes in order for \nthe call to be legal, and the corresponding function defined on the submode is then executed. EXAMPLE: \nMatrix operations such as addition and multiplication can be defined in terms of the subscript and dimension \nfunctions and arithmetic on the matrix elements. Thus, subscript, diml and dim2 might form an adequate \nset of generators for the mode matrix$ . Interpreting The Function Call The interpretation of a generic \nfunction is determined by the modes of its operands and the pertinent information in the mode graph, \nso mode matching is a more complex procedure than asking about simple identity. The interpretation chosen \nfor a call g(al, a2, . . . , an) will be that function gi(fl, f2, ... , fn) 6 g such that (1) Each ai \nis in the mode of the correspondi~ fi; (2) The total cost of applying this inte_a_tT6ii is less than \nthat of any other interpretation.  The terms in and total cost are defined as follows: An object a is \nin mode m if there exists one or more p~hs through the mode graph from mode of a to m such that all predicates \nalo~h~p~th are satisfied for a. The total cost of applying a function inter-t~is the bias associated \nwith the interpretation itself plus the cost of each argument. The cost of an argument, a, is the cost \nof usi the chosen path from mode(a) to modeY formal). This path has minimal cost of all paths along which \nall the predicates are satisfied. The cost of a path from actusl mode m(a) to formal mode m(f) is the \nsum of the biases on each edge of the mode graph which is traversed by the path. Conclusion We have proposed \nsome mechanisms to enable program modules to model external domains: definable, structure-free data types; \ndefinable, characterizable and interrelated modes; and a function application mechanism which combines \nand 142 generalizes the usual. ~eneric function, coercion and automatic conversion facilities. The full \npower of these mechanisms is realized only when they are used in combination. REFERENCES llDataless ProgrammiU \n~ 1. Balzer, R.M., Proc. AFIPS 1967 FJCC, 535-544.  2. Cheatham, T.E., Fischer, A., and Jorramd, P., \n $?on the Basis fOr ~z an Extensible Language Facility !, Proc. AFIPS 1968 FJCC 33, ~ 2, lTTL#uTTfE5tT5K5,TEjkiK \nPa., 9Y7\u00ad . 3. Dahl, O.-J., Myhrhaug, B., Nygsard, K $lThe Simtia 67 Comllmn Base dguage , Norwegian \nComputing Centre, Forskningsveien IB, Oslo 3 (1 968). 4. Morris, J.H:, Protection in Programmlne Languages \n, Comm. ACM 16, ~ (January 1973), 15~ 5. Reynolds, J.C., GEDAIWEN -A Simple Typeless Language Based \non the Principle of Completeness and the Reference Concept , Comm. ACM 13  (May 1970), 30~319. VA ]>ata \nDefinition 6. Standish, T., Facility for Programming Languages !, Doctoral Thesis, Carnegie Institute \nof Technology, Pittsburgh, Pa. (1967). llppL user s llanual $ Technical Report, Aiken Computation Laboratory, \nHarvard University (1971). 7. Taft, E.A., 8. Van Wijngaarden, A., Mailloux, B.J., Peck, J.E.L., and \nKoster, C.H.A.,  !lRePort on the Algorithmic Lan@age ALGOL 68 , Kurnerische Mathernatik 14 (1969), 79-218. \nWegbreit, B., ItThe Treatment Of Data 9. Types in ml , Report ESD-TR-71-34_l to Deputy for Command and \nManagement Systems HQ Electronic Systems Division (AFSC) L.G. Hanscom Field, Bedford, Mass. from Harvard \nUniversity (1971). 10. Wirth, N., ]!~e programmi~ Iangmze PASCAL , Acts Informatica~, ~ (1971), 3!7=753.\n\t\t\t", "proc_id": "512927", "abstract": "High level programming languages tend to free a programmer from concern about the underlying machine structure and permit him to talk about his problem domain in more direct terms. Thus, he may imagine that objects such as real numbers, character strings, and linear arrays really exist in the machine as atomic entities and he need not understand the details of how they are actually represented in the machine. Of course what distinguishes various kinds of objects are the operations that may be performed on them, so when talking about the domain of real numbers, we should include the basic arithmetic operations and constants, and for strings, operations such as length, concatenation and indexing.Unfortunately, existing languages do not permit a programmer to ignore completely questions of representation, for if his problem domain does not happen to be included already in the repertoire of domains supported by the language, the programmer must figure out a representation himself and remember it throughout his programming effort. For example, a FORTRAN programmer may know that it is not meaningful to multiply two integers that happen to represent insurance policy numbers, but he has no way of informing the compiler of this fact.Many extensible languages do provide a wide range of data types including structured types, enabling a programmer to choose a more natural representation of his external objects, but the structured data types reflect only the structure of the data, not its meaning. They still provide only one natural representation for both integers and dates, mass and speed, or planar vectors in cartesian or polar coordinates.Many domains that arise in practice have a great deal of similarity between them which one must employ in his programs. For example, the domain of length 3 vectors and the domain of length 4 vectors have the \"same\" rule of addition, that is, add componentwise, and it would be onerous to have to repeat this information for each new length vector. Thus, one needs both the ability to define brand new domains and also a method for expressing relations among them.We present here some mechanisms, collectively called Aleph-1, which allow the expansion of a programming language's repertoire of internal domains. Many of the ideas embodied in Aleph-1 have been described previously in the literature, and we acknowledge their influence on our thinking, in particular the work of Balzer [1] and Reynolds [5] suggesting the utility of separating out the abstract behavior of an object from its representation, the languages Pascal [10] and Simula-67 [3] which associate functions with data types and types with alternate representations, modular generic functions in Basel [2], Standish's wide variety of structured data [6], and the systematic (though not extensible) treatment of coercion in Algol-68 [8]. Our domain mechanisms bear certain strong similarities to those developed by Morris for the purposes of protection [4].", "authors": [{"name": "Alice E. Fischer", "author_profile_id": "81100312425", "affiliation": "Waltham, Massachusetts", "person_id": "PP14114041", "email_address": "", "orcid_id": ""}, {"name": "Michael J. Fischer", "author_profile_id": "81100313431", "affiliation": "Massachusetts Institute of Technology, Cambridge, Massachusetts", "person_id": "PP48024045", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512927.512940", "year": "1973", "article_id": "512940", "conference": "POPL", "title": "Mode modules as representations of domains: preliminary report", "url": "http://dl.acm.org/citation.cfm?id=512940"}