{"article_publication_date": "10-01-1973", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1973 ACM 0-12345-678-9 $5.00 On the Decision Problems of Program Schemas with Commutative and Invertible \nFunctions Ashok K. Chandra Computer Science Department, Stanford University Abstract We consider partially \ninterpreted monadic schemas in which some functions are specified to commute, or some function is specified \nto be invertible. The decision problems considered are those of halting, divergence, equivalence, inclusion \nand isomorphism. It is shown that with either commutativity or invertibility alone, all these decision \nproblems are solvable, whereas with both commutativity and invertibility, all become unsolvable. These \nresults are also related to the decision problems for finite automata on multi\u00addimensional infinite tapes. \n1. Introduction A program schema is a computer program in which the basic operations are considered to \nbe uninterpreted. The program schema, as a model of computation, has been widely studied to charact\u00ad \nerize the power of various programing featxres such as couuters, recursion and pushdown stacks (Paterson \nand Hewitt [1970], Garland and Luckhsm [1971], Constable and Gries [1972], Chandra and Manna [1973], \netc.) and to prove assertions about progrsms, e.g. to grove the equivalence of programs (Ianov [1958, \n1960], paterson [1967], Manna [1969], Luckhsn, Park and Paterson [1970], Ashcroft, Manna and Fnueli [1973], \netc.). There is a problem, however, in going from the inter\u00ad preted program to the completely uninterpreted \nprogram schema, viz. that too much information is lost. Consider, for exsmple, the recursive schema 1 \n: The research was supported by the Advamced Research Projects Agency of the Department of Defense under \ncontract SD-183. : F(a) where 1 F(y) <=~p(y) then h(y) else g(y, F(f(y))) . In S1, a is an (uninterpreted) \nconstant, ,, fI, and rthrt are unary P is a unary predicate, functions, and g is a binary function. \n 1 cannot, in general, be translated into any efficient schema, i.e., one that requires a bounded amount \nof memory and takes time propor\u00adtional to the depth of the recursion of (see 1 Paterson and Hewitt [1~0]). \nIf, however, the function f is invertible, i.e., there exists an -1 easily calculated function f such \nthat Vx f-l(f(x)) = x , then S1 can be translated into the efficient schema S2 : START 2: Y1 + a; Ll: \n~ P(Y1) then goto L2; Y1 ~ f(yl); &#38;@ Ll; L2: y5 -a;y Yl; ylth(yl); 2 ; if p(yj) ~HALT(Y1); 5 Y2 \n-f -1(Y2); Yl -h(y2~y1) ; Y3 -f(y); goto L3 . is a program schema that uses three variables 2 yl, y2~dy5. \nAs another example, consider the schemas 3 and Sk: : START S4: START 3 .,. ... y -f(y); Y -!3(Y); Y -g(Y); \ny -f(y); ... ... where the three dots ( . ..) indicate that the corresponding sections in and Sk are \nidenti\u00ad 5 cal. (i.e., In general, they do not 5 and Sk are not equivalent always compute the same value). \nAn empty Two conjunction program is schemas the formula @l,@l) true . ~d (F2>@2) If, however, which \nf and 3 g and S4 comute, represent i.e., Vx programs f(g(x)) in = are the compatible schemas we if $1=$2 \nconsider, is valid. compatibility Note that is decidable. for g(f(x)) to be , then equivalent. S 3 and \nS4 should be considered a An schema interpretation S = (F,@) if I I is an interpretation specifies all \nthe for base In the following we will consider the decision functions and predicates in F and @ over \nsome problems of one-variable monadic program schemas in domain (only total functions and predicates \nare which certain functions are specified to commute, allowed), and @ is true in I . or is some function \nshown that is specified commutativity, to (or be invertible. invertibility) It by Sl~S2 A schema ) if \nS1 S1 includes and S2 a schema 2 are compatible (notation and on itself whereas exist, We also lems of \nleaves the decision problems solvable, if both commutative and invertible functions then the decision \nproblems are unsolvable. relate these results to the decision prob\u00adfinite state automata on infinite \nevery interpretation 2 halts on I then with the same output. (sl = S2) if S1>S2, I for S1 and for S1 \nalso halts on 1 is equivalent 2~sl S2 , if I and to 2 n-dimensional ftapes r. Details of some proofs \nare Two schemas 1  2 are isomorphic omitted and can be found in Chandra [1973]. (sl - S2) if they are \ncompatible and on every 2. Solvable We will to represent function (or functions. and Unsolvable Classes \nuse the symbols a,g,f,f &#38;unctions, where a is constant), and the others We will also use p,pl,P2, \n-l, fl, f2, . . . a zero-ary are unary . . . to interpretation I for S1 and for S2 , the sequence of \nstatements executed by the two compu\u00adtations look exactly alike (except for labels). Given a class C \nof schemas, the decision problems we consider are the followtig: represent unary predicates. Below, the \nsymbols fi (a) the halting problem: given any S in C, to and f, representJ ff 1) 2~ >f>g , P1>P29. ..>P \n. auy of and p. ~ the symbols represents any of (b) decide if S for S , the divergence halts on problem: \nevery interpretation given any S in U, A flowchart F consists of statements of the to decide if S diverges \nfor every interpre\u00ad following types: tation for S , (1) START y-a; -L (c) the equivalence problem: given \nany S1 , S2 (2) HALT(T) in c , to decide if S1=S2, (3) LOOP (d) the inclusion problem: given any S1 , \nS2 (4) y\u00ad fi(y); @L in c , to decide if l~s2 (5) where ~Pi(?) r is then goto an arbitrary L1 else term \ngoto L2 (constructed from (e) the in isomorphism c , to decide problem: given if 1-s2 any S1 , S2 the \nvariable y and/or the function symbols), and A class C5 is solvable if all its problems L ~ L1 J L2 are \narbitrary labels. The STA.ILC (a)-(e) are solvable, and it is unsolvable ifall statement is the first \nstatement in a flowchart, (a)-(e) are unsolvable. Of course, it is possible and all other statements \nmay be labeled. If a LOOP for a class to be neither solvable nor unsolvable. statement is executed the \ncomputation runs forever. Also, the halting problem and the negations of the where A program F is a schema \nflowchart S is and an fl ordered is a pair formula @,$) which divergence partially and isomorphism solvable. \nproblems are, in general, is a conjunction of formulas of the forms: Let cc denote the class of program \nschemas (1) Vxfi(fj (x)) =fj(fi(x)) (fi, fj commute ) (F,@) such that @ is a conjunction of formulas \n(2) where Vx f-l(f(x)) a = b = c =f(f-l(x)) denotes =x ((a=b) (f is A(b=c)) invertible) . J only of cc \nmay schemas the form be called for in Vx the Cc fi(fj(x)) class we may = fj(fi(x)) of Commutative specify \nthat . any set of pairs {fi, fj] commute, but no function is invertible. Theorem 1. The class Gp is \nsolvable. . All proofs are indicated in Section 4. Next, consider the class ~ of schemas (F,@) where \n@ is Vx f-l(f(x)) =f(f-l(x)) =x. Theorem 2. The class CT is solvable. We now wish to show that schemas \nwith both commutative smd invertible functions are unsolvable. To do this we exhibit the relatively restricted \nclass ~1 that i. unsolvable. Schemas (F,fl) have the function symbols a,f,f-l,g and n CCI the only predicate \nsymbol is p . The formula $ is Tx f(g(x)) = g(f(x)) AVX f-l(f(x)) = f(f-l(x)) = x , and HALT statements \nin F have the restricted form HALT(a) . In addition, the only kinds of tests allowed are of the forms \nP(Y) ~d P(&#38; (Y)) . Theorem 3. he clasS CCI s ~sOIVable It may be asked whether tests of the form \np(g(y)) are necessary to make the class CCI unsolvable. The answer is yes , as the next theorem indicates. \nNote that tests of the form p(f(y)) or p(f-l(y)) do not add any power to the schanas since a test like \np(f(y)) , for exwnple, can be implemented by first changing y to f(y) (by y * f(y) ) testing p(y) , and \nchanging y back to its original value (y+ f-l(y) ). denote the subclass of @C1 et CCI\u00adcontaining schemas \n(F,@) in which F has no test of the form p(g(y)) . Theorem 4. he class CCI- s O1vable 3. Application \nto Finite Automata Theory From the above solvability and unsolvability results we can obtain similar \nresults for finite automata on infinite n-dimensional tapes. The tapes are assumed to have a root, or \norigin which is the initial position of the automaton. We con\u00ad sider classes of automata by restricting \nthe kinds of input tapes allowed and the possible ways the reading head of *he automaton can move. An \nauto\u00ad maton may accept or reject its input tape, or it may run forever, in which case the tape is rejected. \nFor automata, the problems of acceptemce, rejection, equivalence, inclusion and isomorphism (below) are \nanalogous to the problans of halting, divergence, equivalence, inclusion and isomorphism for schemas. \nThe acceptance (rejection) problem is to decide if an automaton accepts (rejects) all input tapes; an \nautomaton includes an automa\u00ad 1 ton A2 if the set of tapes accepted by Al contains all tapes accepted \nby ~ ; two automata are equivalent if they accept exactly the same set of input tapes, and two automata \nare isomorphic if for every input tape, they visit and read exactly the sane squares of the tape in the \nsane order. We say that a class of automata is solvable (unsoIv\u00ad -if al.l these problems are solvable \n(unsolvable) for the class. An n-dimensional one-way automaton is a finite state machine with one reading \nhead that is initially at the origin of its n-dimensional infinite tape, and can move only in the positive \ndirection along each dimension. The tape symbols are from some finite alphabet z = {Ul, . . ..dm] . We \nwill represent the transition graph of the automaton by a program with the following kinds of statements: \n(1) LO: START goto 8(L0, read) (2) Li: ACCEPT (3) Li: REJECT (4) Li: move(j), goto 6(Li, read)  where \nmove(j) means move one step in the j -direction!! , 8 is a function from labels and tape symbols to labels \n(its value can never be LO ), smd read represents the current symbol read from the tape. From Theorem \n1 we can prove Corollary 1. The class of n-dimensional one way automata is solvable (for every n ) . \nTo show this we construct for every n-dimensional one-way automaton A on 2, = [01, . . ..um] a corresponding \nschema S@c as follows: S has n unary functions f each pair of which commutes, and S l  fn has (m-1) \nunary predicates pl, . . ..pl-l . Statements in A and S correspond as shown below: statement (1) for \nA corresponds to (1) for S, etc. Automaton A (1) LO: START _goto &#38;( LO, read) (2) Li: ACCEPI (3) \nLi: REJECT (4) Li: move(j), goto 6(Li,a) Schema S (1) START y ea; DEL(LO) (2) Li: HALT(a) (3) Li: \nLOOP (4) Li: Y -fj(y); DEL(Li)  where DEL(Li) represents the following statement: if pi(y) then goto \n5(Li,~l) else ~ p2(y) then goto &#38;(Li,02) S.@g Pm.l(Y) then goto IS(Li, Ore-l) else goto s(Li, am) \nwith the appropriate labels substituted for 5( Li, Jj) . Note that S uses some features (e.g. nested \nif-then-else s) that are not strictly legal, but it is clear how they can be eliminated. It is also obvious \nthat the decision problems for A are reduced to those for S . An n-dimensional two-way automaton is like \nan n-dimensional one-way automaton except that the head. can move both ways in each dimension (the tape \nis infinite in all directions) . A construction similar to the above can be used to reduce the decision \nproblems for one-dimensional two-way automata to those for % Corollary 2. The class of one-dimensional \ntwo-way automata is solvable. Of course, this result is not new, but we mention it to show that it follows \nfrom Theorem 2 in a straightforward way. Next, we consider a class of automata we call periscopic automata. \nA periscopic automaton has one reading head that moves on a two-dimensional infinite tape. We call the \ndtiensions horizontal and vertical . The head can move freely in the horizontal dimension (i.e., left \nor right), but vertically it can move only upwards. However, attached to the head is a little periscope \nso that the automaton can read the symbol just above the head without moving the head vertically up. \nFor our purposes it suffices to take the tape alphabet to be of size two (we may say z = {T,F]). f-l \n/ submarine with a periscope The relation between a schema S in ~C1 and the corresponding periscopic \nautomata A is obvious -\u00ad an interpretation for S corresponds to an input tape for A , applications of \nthe functions f , -1 f , and g in S correspond to moving the head of A right, left, and up respectively. \nIt is the test p(g(y)) in S that corresponds to the peri\u00adscopic vision of A . It is then easy to see \nfrom Theorem 3 that Corollary 3. The class of periscopic automata is unsolvable. We mention that if we \nprovide the automaton with any kind of periscope at all, e.g. arb i \u00ad trarily high, inclined, or even \npointing downwards (but not just horizontal, for that is equivalent to no periscope at all), then the \nproblems for the automata all remain unsolvable (and similarly for the corresponding schema.). Finally, \nconsider the subclass of periscopic automata in which the symbol at the periscope is never looked at, \nwhich we call p-automata. A p-automaton can move left, right, or up (but not down), and can only look \nat the symbol at the reading head. From Theorem k we have Corollary 4. The class of p-automata is solvable. \n4. F-roof s ble y . It is the responsibility of A to detect We sketch here the proofs of Theorems 1-4. \nwhether or not its input tape represents a feasible Details of the proofs can be found in Chandra [1975]. \ninterpret at ion. At any instant in the computations of s and S2 , let the values of the variable y 1 \n4.1 Solvability of cc 1jl 2j2 be F1 F2 in S1,and Fl F in S2 (since 2 We give here the proof for the \nsolvability of the schemas are in step il+jl ). Let the = 2+j2the inclusion problen only for the subclass \n~Ct count If the count is zero, c enote 1-i2 of c in which any schema contains just two unary c the \npredicate p must have the same value on both flmctions that commute, and. one predicate 1 2 tracks, \nelse the values on the tracks may be arbi\u00adp for which the only tests allowed are of the form trary. The \nautomaton A accepts an input tape P(Y) , and halt statwents have the fo~ WT(Y) . unless halts and S1 \ndoes not halt with the 2 The solvability of halting, divergence, and equiva\u00ad ssme output for the interpretation \nrepresented by lence for p? follow from the solvability of the tape. inclusion, and the solvability of \nisomorphism In its finite memory the automaton retains the follows by a similar proof. following data: \nWe first describe (without proof) a class J (i) the current (assignment) statement executed of canonical \ninterpretations for ~i . This means c by S1,andby S2,and that for any two schemas S1 , S2 in CJ , (ii) \nthe value of the count c provided if and only if for every ifiterpretation 1 ~ 2 Icl <min(s ~,s2) where \nS1 , S2 are the IeJ , if S2 halts on I , then so does S1 and numbers of assignment statements in with \nthe same output. 1 s2 The domain of any interpretation IeJ is the The automaton operates as follows: \nset of strings {F~F~li,j >O]c [F1,F2]* , where (1) Read the input tracks (if the end-of-file is and F2 \nare to be treated simply as symbols. 1 read, accept the tape). If c = O and the The ft.nctions a , fl \n, f2 are defined as follows: tracks read (T, F) or (F, T) then accept the Fo PO tape ( impossible interpretation). \na is,. (the empty string) (2) Using the values of p(y) from the tracks, find the next statements (other \nthan test statements) for both schemas. i j+lf2(F~ F:) is 1 2 (3) If the next statement for S2 is a halt \nstatement then reject the tape unless C=o and the predicate p is arbitrary. and S1 also halts. If S2 \nloops then Let S1 , S2 be any two schemas accept the tape. Without loss of generality we can assume \nthat both Y (k) If S1 halts or loops on the next statement, are free, for if they are not they can trivially \nreject the tape because as is free (over be made free. 2 0 ecide f 1 ~s2 e Constmct interpretations \nin J ) it can be made to a finite state automaton A (one-way, one-djmen\u00adreach a halt statement --and \nit will apply at sional, and on finite tapes) such that A accepts least one more function letter, thereby \ngiving all tapes if and only if S1 > S2 . The input tape a different output from that of S1 . of A represents \nan interpretation 16$ , and A (Both next statements are assignment state\u00ad (5) simulates the computations \nof S1 and S2 in ments . ) If S1 executes Y -fl(y) and S2 parallel. The tape consists of two tracks, one \nfor executes then increment c by 1; Y - f2(Y) each schema, and the symbols on each track are from if \nSexecutes Y -f2(y) and S2 executes the set {T,F] representing the value of thepredi-1 Y -fl(Y) then decrement \nc by 1 ; other\u00ad cate p applied to the current Value of the varia\u00adwise leave c unchanged. If the new value \nof ~ A schema S is free if all paths in S (from Icl exceeds min(sl, s2) then reject the the START statement) \ncan be followed by the tape, otherwise, go to (l). computation of S on some interpretation. The reason \nthat the input tape can be rejected if Icl exceeds min(sl, s2) isthat because S1 and S2 are free and \nindependent for the next c steps, they can both reach halt statements without executing any statement \ntwice (for some interpreta\u00adtion) --and, of course, the outputs can be equal only if both reach halts \nat the same time and c . 0 , but that is impossible because c changes by at most one in each step. This \ncompletes the proof of the solvability of the inclusion problem for ~~ . 4.2 Solvability of CT Schemas \nin ~1 have the flavor of two-way finite automata. Applying the function f corres\u00ad-1 ponds to moving the \nhead right, applying f corresponds to moving it left. There are some difficulties, however: (i) the \nschema outputs values, ( ii) there are functions other than just f and -1 f , (iii) the schema cantest \npredicates on terms. Nevertheless, a proof somewhat similar to the classical one for two-way automata \nworks. We do not give a proof of the divergence prob\u00adlem for 81 , but we use it in the proof for the \ninclusion problem below, from which the solvability of halting and equivalence follow, and that of isomorphism \ncan be proved in a similar way. Given any two schemas S1 , S2 (in C31 ) and having functions f, f-l, \nfl, . . ..fn , and predicates Pi>. ..)Pm , we give (without proof) a class g of canonical interpretations \nfor and S2 : the 1 domain is the set of strings in x = {F,F-l,F1, . . ..Fn]* for which symbols F and \n~-l do not appear adjacent to each other. The predicates pl, . . ..pm are arbitrary. As in Section 4.1, \nwe construct a finite automaton A which accepts all tapes if and only if s1~s2, and does so by simulating \nthe computations of 1 and S2 in parallel on an interpretation repre\u00adsented by the input tape. (For simplicity, \nwe assume that the only halt statements in and 1 are HALT(y) .) But first, some definitions. 2 For any \nterm T , let ITI denote the number of unary function symbols (f-ljf, fl, ...) in T , and let k denote \n max[l~l: T is used in S1 or in S2] . For any interpretation I in 9 , and any element x in its domain, \nwe define the specification state (SS) of x to be the values of pi(t(x)) for all pi , and l~l<k (this \nmay retreated asafhnction: pm]x{T: ITI <k] + {T,F] ). The {PI) ..., incomplete specification state (1SS) \nis the values of pi(~(x)) for all pi , and ITI < k-1 . A state vector is a label (in S1 or S2 ) and an \n1SS . A pivot element in the domain of I (IG!2) is any string for which the first symbol (if any) -1 \n isnot ForF. A symbol on the input tape of A is a pair of specification states. The automaton A views \nthese as specification states for the pairs (v, v), (F-l .v,F.v) , ((F-1)2.v, F2.v) , . . . (where v \nis a pivot element) umtil A decides that the pivot element v has changed. The first pivot element is \nA (the empty string). The auto\u00ad maton retains a table of instances and outcomes . For each assignment \nstatement (or start statement) in both schemas there are two instances, one for the left value in a pair \n((F-l)r.v, Fr.v) , and one for the right value, and it is to represent the computation of the schema \nif the variable y were to be set to the corresponding value just after the assignment (or start) statement \nis executed. In addition, there is one primary instance (for each schema) that represents the real computation. \nThe possible outcomes for each instance are the following: (1) halt, with some value x , (2) exit, with \nsome state vector and some value x it corresponds to an execution of -1 Y-fi(y) where fi is not f or \nf , (3) out-left , with some statement Li , (4) out-right, with some statement Li , (5) diverge. \n exit (apply fi) out-left ~ ~ out-right T IH I (F-l)r.v v Fr. v The automaton A need not (and indeed \ncannot) pivot element), remember the value x for all halt or exit out-( iv) if none of the above, then \ncontinue simu\u00adcomes; it suffices to remember the equivalence lation of S1 , constructing the set of classes \nof outcomes that halt or exit with the complete states until (i), (ii), or (iii) same value, and the \nvalues of only those instances above apply, or a complete state repeats, that halt with output x with \nlxl~k (x isa in which case reject the tape; string) . In its finite memory the automaton stores: if none \nof the above, continue simulation (5) of both S1 and S (1) the table of instsmces and outcomes, 2 (2) \nthe ISSofthe next pair to be read in,  This completes the proof. (3) the value of r if r <k , and the \nvalue v of the pivot element if lvl~k>  4.3 IJnsolvabilit,yof ~1 (4) the SS of the empty string A . \nA Post machine is a finite machine but with a We call (1) and (2) a complete state. In addi\u00ad (unbounded) \nqueue as a store. The machine can tion to (l)-(4) the automaton can store insert symbols from a finite \nalphabet z = {U1,U2] (5) an arbitraw set of complete states. at one end of the queue, and can remove \nsymbols from the other end. The halting and divergence The automaton operates as follows. On seeing problems \nfor null-input Post machines are unsolva\u00ad an end-of-file it accepts the tape. Otherwise it ble and can \nbe reduced to the corresponding reads a pair of specification state$ from the tape, problems for &#38;cI \n(from which the unsolvability checks if they match with the known incomplete is tiediate). specification \nstates. If not, the tape is accepted Of G ~ The idea is that any interpretation for a ( impossible interpretation). \nIf they match, then schema S in (&#38; Canbe represented bya grid (1) if the principal instance for schema \n2 of integer nodes in a half plane (doubly infinite diverges, then the tape is accepted; along the x-axis). \nThe constant function a (2) if S2 halts then corresponds to the origin; applying the function (i) if \nS~ halts with the same value -- -1 f corresponds to moving right, applying f accept, corresponds to moving \nleft, and applying g ( ii) if S~ halts with a different value -\u00ad corresponds to moving up. At each node \nwe have a reject, T or F value, corresponciing to the value of the (iii) if Sexits --reject, 1 predicate \np . (iv) if none of the above, then continue simulation of S1 and construct the set of complete states \nuntil either (i), (ii) or (iii) above applies, or a complete state repeats --in which case reject the \ntape; (3) if Sexits in a state vector which must 2 loop (can be shown to be solvable from the solvability \nof the divergence problem) then accept the tape; The schema S can simulate the computation of (4) if \nS2 exits in a state vector from a Pest machine M on this plane as follows. It which it can halt, then \nuses two horizontally adjacent nodes to fcode f a (i) if S~ halts, then reject, (ii) if Sexits with \na different value, marker: corresponds to TT , to TF ,  letter (either 01 , U2 or e --a special end \n1 1 2 then reject, e to F-). In this manner, the schema will lay S1 sane con\u00ad (iii) if exits with \nthe value, offtt the current value of the contents of the queue tinue simulation of both S, , S9 (new \n. .. (of M ) in one row of nodes, enclosedby end\u00admarkers. The next string (when M changes the contents \nof its queue) will be laid off on the next higher row. The schema S will simply check this computation. \nIf the interpretation doesn t agree with the desired computation the schema halts (if the halting problem \nis under consideration, or loops if it is the divergence problem). Also, S halts if M halts. 4.4 Solvability \nof cCl- The proof of the solvability of the inclusion problem for ~ does not carry over immediately \nbecause in Ctl if two schemas exit 0 Cl\u00ad(see notation of Section 4.2) with different values then they \ncan never output the same value (for the canonical interpretations), and. the two computations are essentially \nindependent. ot 0 or CCI- One can, however, find a bound c for any twa schemas in such that if the two \nschemas ~cI \u00adexit at a (horizontal) distance of more than c from each other then both can halt with \ndistinct outputs. This intuitive notion can be formalized to obtain the desired proof. References Ashcroft, \nManna and Fnueli [1975]. E. Ashcroft, Z. Manna and A. Fnueli, Decidable properties of monadic functional \nschemas, ! Journal of the ACM, Vol. 20, No. 2 (April 1973). Chandra [1973]. A. K. Chandra, On the properties \nand applications of program schemas, Ph.D. Thesis, Report no. CS-3>6, AIM-188, Computer Science Dept., \nStanford University, March 1973. Chandra and Manna [1973]. A. K. Chandra and Z. Manna, On the power of \nprogramming features, Report no. CS-533, AIM-185, Computer Science Dept., Stanford University, January \n1973. Constable and Gries [1972]. R. L. Constable and D. Gries, On classes of program schemata, in SIAM \nJournal on Computing, Vol. 1, No. 1, March 1972, pp. 66-118. Garland and Luckham [1971]. S. J. Garland \nand ,lRogra schemes, recursion D. C. LuCkham, schemes, and formal languages, r UCLA report no. ENG-7154, \nJune 1971. Ianov [1958]. Iu Ianov, The logical schemas of algorit~s,,f problems and Cybernetics, VO1. \n1) PP. 75-127, (Russian edition). Ianov [1960]. Iu I~ov, The logical schemes of algorithms, English \ntranslation in Problems of Cybernetics, Vol. 1, Pergemon Press, New York, 1960, pp. 82-140. Luckham, \nPark and Paterson [1970]. D. C. LuckhSJ% -+ D. M. R. Park and M. S. Paterson, On forma\u00ad lized computer \nprograms, Journal of Computer and System Sciences, Vol. 4, No. 3, (June 1970) PP. 220-2b9. Manna [1969]. \nZ. Manna, Properties of programs and the first-order predicate calculus, Journal of the ACM, Vol. 16, \nNo. 2, April 1969 PP. 244-255. Paterson [1967]. M. S. Paterson, Equivalence problems in a model of computation, \nPh.D. Thesis, University of Cambridge, England (August 1967). Also Artificial Intelligence Memo, No. \n1, Mass. Institute of Technology, 1970. Paterson and Hewitt [1970]. M. S. Paterson and C. E. Hewitt, \nComparative schematolo~, in Record of Froject MAC Conference on concurrent systems and parallel computation, \nACM, New York (December 1970), pp. 119-128.  \n\t\t\t", "proc_id": "512927", "abstract": "We consider partially interpreted monadic schemas in which some functions are specified to commute, or some function is specified to be invertible. The decision problems considered are those of halting, divergence, equivalence, inclusion and isomorphism. It is shown that with either commutativity or invertibility alone, all these decision problems are solvable, whereas with both commutativity and invertibility, all become unsolvable. These results are also related to the decision problems for finite automata on multi-dimensional infinite tapes.", "authors": [{"name": "Ashok K. Chandra", "author_profile_id": "81100394413", "affiliation": "Stanford University", "person_id": "PP39040848", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512927.512949", "year": "1973", "article_id": "512949", "conference": "POPL", "title": "On the decision problems of program schemas with commutative and invertible functions", "url": "http://dl.acm.org/citation.cfm?id=512949"}