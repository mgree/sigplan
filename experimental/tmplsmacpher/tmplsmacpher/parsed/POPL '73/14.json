{"article_publication_date": "10-01-1973", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1973 ACM 0-12345-678-9 $5.00 Actor Induction and Meta-evaluation Carl Hewitt Peter Bishop Irene Greif \nBrian Smith Todd Matson Richard Steiger Programa should not only work, but they should appear to work \nas well. PDP-lX Dogma The PLANNER project ia continuing research in natural and effective means for embedding \nknowledge in procedures. In the course of this work we have succeeded in unifying the formaliam around \none fundamental concept: the ACTOR. Intuitively, an ACTOR is an active agent which plays a role on cue \nac c~ding to a script. We use the ACTOR metaphor to emphasize the inseparability of control and data \nflow in our model. Data structures, functions, semaphores, monitors, ports, descriptions, Quillian nets, \nlogical formulae, numbers, identifiers, demons, proceasea, contexts, and data bases can all be shown \nto be special cases of actors. All of the above are objects with certain useful modes of behavior. Our \nformalism shows how all of these modes of behavior can be defined in terms of one kind of behavior: sendin~me~ea \nto actors. An actor ia always invoked uniformly in exactly the s=rn~ way regardless of ~~~er ~t beha~s \n\u00adas a recursive function, data structure, or process. It is vain to multiply Entities beyond need. William \nof Occam Monotheism is the Answer The unification and simplification of the formalism for the procedural \nembedding of knowledge has a great many benefits for us. In particular it enables us to substantiate \nproperties of procedures more easily. INTENTIONS : Furthermore the confirmation of properties of procedures \nis made easier and more uniform. Every actor has an INTENTION which checks that the prerequisites and \nthe context of the actor being sent the message are satiafied. The intention ia the CONTRACT that the \nactor has with the outside world. How an actor fulfills its contract is its own business. By a SIMPLE \nBUG we mean an actor which does not satisfy its intention. We would like to eliminate simply=g~ of actors \nby the META EVALUATION nf actorsto show that they satisfy their intentions. By this we do not necessarily \nmean a oroof in the first order quantificational calculua for input-output assertions written in the \nfirst-order quantificational calculus. The rules of deduction to establiah that actora satisfy their \nintentions essentially take the form of a high level interpreter for abstractly evaluating the program \nin the context of its intentions. This process [called META--EVALUATION] can be justified by a form of \ninduction. In general in order to substantiate a property of the behavior of an actor system some form \nof induction will be neelled, At present, actor induction for an actor configuration with audience E \ncan be tentatively described in the following manner: 1. The actors in the audience E satisfy the intentions \nof the actor to which they send messages. and 2. For each actor A the intention of A is satisfied => \nthe intentions for all actors sent messages by A are satisfied Therefore The intentions of all actions \ncaused by E are satisfied (i.e. the system behaves correctly) Computational induction [Manna], structural \ninduction [Burstall], and Peano induction are a special cases of ACTORinduction. Actor based intentions \nhave the followinq advantages: The intention is decoupled from the actors it describes. Intentions of \nconcurrent actions are more easily disentangled. We can more elegantly write intentions for dialogues \nbetween actors. The intentions are written in the same formalism as the procedures they describe. Thus \nintentions can hav~tentions. Because protection is an intrinsic property of actors, we hope to be able \nto deal with protection issues in the same straight forward manner as more conventional intentions. \nIntentions of data structures are handled by the same machinery as for all other actors. Syntactic Sugar. \nWhat s the good of Mercator s North Poles and Equators, Tropics, Zones and Meridian Lines? So the Bellman \nwould cry: and the crew would reply They are merely conventional signs! Lewis Carroll Thus far in our \ndiscussion we have discussed the semantic issues intuitively but vaauel,v. We would now like to proceed \nwith more precision. Unfortunately in order to do this it seems necessary to introduce a formal language. \nThe precise nature of this language is completely unimportant so Ionq as it is capable of expressing \nthe semantic meanings we wish to convey. For some .years we have been constructing a series of languages \nto express our evolving understanding of the above semantic issues. The latest of these is called PLANNER-73. \nMets-syntactic variables will be underlined. We shall assume that the reader is familiar with advanced \npattern matching languages such as SNOE0L4, CONVERT,PLANNERx71, 0A4, and POPLER. We shall use (%A W%) \nto indicate sending the message M to the actor A. We shall use fsT 32 . o sn] to denote the finit~~equence \ns1, s2, . ..sn. A sequence s is an actor where(%s i%) is element I of =quence s. For example (%[a c b] \n2%) is c. We will use ( ) to delimite the simultaneous synchronous transmission of more than one message \nso that (Al A2 ,..An) will be defined to be (%A1 [A2 . . . An]%). The expression [%al a2 . . . an%] (read \nas al then a2 . . . finally send back an ) will be evaluated by evaluating al, a2,..., and an in sequence \nand then sending back [ returni!?g ] the value of an as the message. Identifiers can be created by the \nprefix operator = For example if the pattern =1 is matched with v, then a new identifier is created and \nbound to v. But glory doesn t mean a nice knock-down argument, Alice objected. When I use a word, Humpty \nDumpty said, in rather a scornful tone, it means just which I choose it to mean-neither more nor less. \nThe question is, said Alcie, whether you can make words mean so many different things. The question \nis, said Humpty Dumpty, which is to be master-that s all. Lewis Carroll Humpty Dumpty propounds two criteria \non the rules for names: Each actor has complete control over the names he uses, All other actors must \nrespect the meaning that an actor has chosen for a name. We are encouraged to note that in addition to \nsatisfying the criteria of Humpty DumptY, our names also satisfy those subsequently proposed by Bl ll \nWulf and t4ar.y Shaw: The default is not necessarilyto extend the scope of a name to any other actor. \nThe right to access a name is by mutual aweement between the creatinq actor and each accessing actor. \nAn access right to an actor and one of ts acquaintances is decoupled. It is possible to distinguish different \ntypes of access. The definition of a name, access to a name, and allocation of storage are decoupled. \nThe use of the prefix = does not imply the allocation of any storage. One of the simplest kinds of ACTORSis \na cell. A cell with initial contents V can be created by evaluating (cell V). Given a cell x, we can \nask it to send back its content by evaluating (contents x) which is an abbreviation for (x #contents). \nFor example (contents (cell 3)) evaluates to 3. We can ask it to change its contents to v by evaluating \n(x c-v). For example ifwe let x be (cell 3) and evaluate (x <-4), we will subsequently find that (contents \nx) will evaluate to 4. The pattern (by-reference P) matches object E if the pattern P matches (cell E) \ni.e. a cell [see below] which contains E. Thus matching the pattern (by-reference =x) against ~~s the \nsame as binding x to (cell ~) i.e. a new cell which contains the value of the expression E, We shall \nuse => [read as RECEIVE MESSAGE ]to mean an actor which is reminiscent of the actor LA~BDAin the lambda \ncalculus. For example (=> =X body) is like (LAMBDAx body) where ~is an identifier. An expression (=> \npattern body is an abbreviation for (receive(message pattern) body) where receive is a more qeneral actor \nthat is capable of bindinq elements of the action in addition to the messaae. Evaluating (%(=> pattern \nbod ) the-message%), i.e. sending + (=> pattern body the-message, will attempt to match the-message against \npattern, If the-message is not of the form specified by pattern, then the actor is NOT-APPLICABLEto the-messa \ne. If the-message matches pattern, the body is evaluated. Evaluating (%(cases [fl__ f2 .~~~%) wilfie~e \nmessage arg and if ~s not applicable then it will send f2 the message arg, etc. until it findsone~hat \nis applic~e, The messaqe [#not \u00adapplicable] is sent back if none were applicable. Evaluating (%(cases \n{fl f2 . . . fn}) ara%)will send . fl the message arg, . . . . and send fn the message arg concurrently. \nThe following abbreviation~will be used to improve readability: (rules object clauses) for ((c=cl-object) \n (where object pattern-for-message body) for ((=> F!Jattern-for-messaael borlv) ob.iect) .! ~.. ; for \nexample (where t+j) x (x+ 1)) is 4 (let { [xO c= ex ressionO] [xl <= ex~ressionl] ... [xn <= expression]} \nbed_) for ((=> F ~o Xl ... =~n] ~) express~on 0 expresslon~ ... expression) ; for example (let { \n[X<= (2+1)] [y<= ( 2*2)]? (x+y))is7 The world s a theatre, the earth a state, Which God and nature do \nwith actors fill. Thomas Heywood 1612 Conceptually at least a new actor is created every time a message \nis sent. Consider sendin~ to a target ~a message Band a continuation ~. (send ~ (message~, [#continuation \n~]) ) The transmission (%T M%) is an abbreviation for the above where ~is defaulted to be the caller. \nIf the target~is the following: (receive (message the-body [#continuation =the-continuation]) the-~) \n then the-~is evaluated in an environment where the-message is bound to M and the-continuation is bound \nto c.  We define an EVENTto be a ouadruple of the form [C T M N ] where C_is the continuation of the \ncaller,~ the target, ~M the message thereby creating a new actor N. We define a HISTORYto be a strict \npartial order of events wTth the transitive closure of the partial o~dering ->[read as PRECEDES]where \n[cl tl ml nl] -> [c2 t2m2 n2] if {nl} intersect {c2 t2 m2} is nonvoid The above definition states that \none action proecedes another if any of the actors generated b.y the first event are used in the second \nevent. The relation -> can be thought of as the arrow of time.!, Notice that we do not require a definition \nof global simultaneity; i.e. we do not require the two arbitrary events be related by ->. We define the \nBEHAVIORof a history with respect to an AUDIENCE[ a set of actors] E to be the subpartial orderinmhistor.y \nconsisting of those quad\u00ad~C.l!!l!l WhereLorljs an element of the audience E. The REPERTOIRE of a configuration \nof actors is the set of all behaviors of the configuration for all interpretations of the actors in the \naudience. The REPERTOIREof a configuration defines what the configuration does as opposed to how it does \nit. Two configurations of actors will be said t~EOUIVALENT if they have the same REPE~IRE We can name \nan actor Hwith the name A in the body B by the notation (label {[A <= H]} B). More precisely, the behavior~f \nthe actor (la~el {[f <= (E n]} B) is defined by the M~NIMA~BEiTAVIORAL FIXED POINT of (~F) i.e. the minimal \nrepertoire F~uch t~a~(~fl = F. In the case where F happens to define a function, it will be the case \nthat the repertoire F is isomorphic with the graph [set of ordered pairs] of the function defined by \nF and that the graph of F is also the least (lattice-theoretic) fixed point of Park and Scott. Many happy \nreturns Many actors who are executing in parallel can share the same continuation. They can all send \na message [ return ] to the same continuation. This property of actors is heavily exploited in meta\u00adevaluation \nand synchronization. An actor can be thought of as a kind of virtual processor that is never busy [in \nthe sense that it cannot be sent a message]. The basic mechanism of sending a message preserves all relevent \ninformation and is entirely free of side effects. Hence it is most suitable for purposes of semantic \ndefiniton of special cases of invocation and for debugging situations where more information needs to \nbe preserved. However, if fast write-once optical memories are developed then it would be suitable to \nbe implemented directly in hardware. The following is an overview of what appears to be the behavior \nof the process of a running actor R sending a target T the message M specifying C as the continuation. \nIf C is not explicitly specified by R then a representative of R must be constructed as the default. \n1: Call the banker of R to approve the expenditure of resouces by the caller. 2: The banker will probably \neventually send a message to the scheduler of T. 3: The scheduler will probably eventually send a messaqe \nto the monitors ofT. 4: The monitors will probably eventually send a message to the intentions of T. \n 5: The intentions of T will probably eventually send the message M co T. 6: T will finally attempt \nto get some real work done. There are several important things to know about the process of sendina a \nmessage to an actor: 1: Conceptually at least, whenever a target is passed a messa~e a w actOr 156 is \nconstructed which is the possible we reuse old actors behavior of the system. target where instantiated \nthe reuse with cannot a message. be detected When ?ver by the 2: Sending messages between actors is a \nuniversal control sense that control operations such as function calls~ratlon, invocations, resource \nseizures, scheduling, synchronization, evaluation of expressions are special cases. p~imitiy~in the coroutine \nand continuous 3: Actors can conduct their dialogue directly with each others: have to set up some intermediary \nsuch as ports [Krutar, Balzer, or possibility lists [McDermott and Sussman] which act as pipes conversations \nmust be conducted. they do not and Mitchell] throuqh which 4: Sending a message to an actor is entirely \nfree of side effects such as those in the message mechanism of the current ~L TALK machine of Alan Kay, \nthe port mechanism of Krutar and Balzer, and possibility lists. Being free of side effects allows us \na maximum of parallelism and allows an actor to be engaged in several conversations at the same time \nwithout becominu confused. 5: Sending a message to an actor makes no presupposition that the actor sent \nthe message will ever send back a message to the continuation. The unidirectional nature of sendinq messages \nenables us to define iteration, monitors, coroutines, etc. stra]ght forwardly. 6: The ACTORmodel is not \nan [environment-pointer, instruction-pointer] model such as the CONTO~model. A continuation is a full \nblown actor [with all the rights and privileges]; it is ma program counter. There are no instructions \n[in the sense of present day machines] in our model. Instead of instructions, an actor machine has certain \nprimitive actors built in hardware. Static Data Structures the list Data nil: structures are special \ncases of ACTORS. For example consider the followina definition of [nil <= (cases {(=> [#o~tt~J&#38;r~gm~ \ncomment to print nil: print the, string (list) to stream (out stream (print-open ( ) (print-string list \n) (print-close ) ))) (=> (=> T#empty?] it is truej f~;~::v;:;nt empty =x =overl ord =the-complaint-dept] \n(=> (=> [(=> x true) (else (not-equal the-complaint-dept) [#structure?] ; iit is a structure true) [#next \nthe-complai nt-dept] (exhausted the complai nt-dept) ) )])) We also define the function output: [output \n<= (=> [=x =stream] ( x#out stream ))] The above is an operational definition of nil which is the null \nlist. For example (nil #structure?) is true. Evaluating (output nil s) will cause (list) to be p~inted \nto the stream s, However from an operational point of view nil is not very interesting because it is \ncompletely static. What we need to ask our-selvesis what are the useful modes of behavior that are embodied \nin the usual notion of a list structure and define an object which behaves in this way. So let us try \nto qive an operational definition of an arbitrary list: In order to do this we need to be able to make \nchanqes in the world, We will use the primitive actor CELL to realize these changes. Definition of LISP-like \nList Structure [cons-list <= (=> [( by-reference =first-of-list) (by-reference =rest-of-l ist)] (cases \n{(=> i_#firstl -. ; th&#38; first element of the list is contents of first-of-list (contents first-of-list))) \n(=> [#rest] ; the rest is contents of rest-of-list (contents rest-of-list)) (=> [#first <-=new-first] \n(first-of ~list <-new-first)) (=> [#rest <-=new-rest] (rest-of-list <-new-rest)) (=> [#constructor] \n; a constructor for this kind of behavior is list list) (=> [~;:::m=the-compl aint-dept] (contents first-of-list) \n(=> -x =overlor~ ~~~e-complaint-dept] r% [#eqJFl#i~~~s-rest-of-li t . (overlord (first x) (contents \nfirst-of-list) the-complaint-dept) (overlord (rest x) (contents rest-of-list) the-complai nt-dept)%]) \n(=> [#out =the-customer] (out the-customer to print the list first print open-delimiter ( (pri;t-open \n( ) ;print that it is a list (print-string list ) print the first element (pri;t (contents first-of-list)) \nprint the rest of the elements in the list (pri;t-elements (contents rest-of-list)) the function print-elements \nis defined below ~ print the close ) (print-close ) ))) (=> [structure?] true) (=> [empty?] false)}))] \n The above definition is much more interesting. For one thing there is a subtle buq in that if cons-list \nis implemented as a lambda calculus closure then it will hang onto too much storage since any actor which \nhangs onto a piece of list structure will hang onto the creator of that list structure. We will deal \n.with this bug later. But let s see how it works enyway: Let x be (cons-list 6 nil). Thus x is ?n lnstanglated \nCASESstatement in the definition of CONS-LIST with first-of-list the name of a new cell which contains \n6 and rest-of-list the name of a new cell which contains nil. now (x #first) evaluates to 6, but suppose \nwe execute ( x #first <-B) causing [#first <-B] to be matched against the patterns in the CASEStill it \nmatches [#first <-=new-firstl now (x #first) evaluates to B. The reason is that there is a side effect \nin the evaluation of (x #first <-B) which changes the first element of x to B. We can define a function \nwhich will print the elements of objects which behave like lists as follows: [print-elements <= (=> \n[j:;gply =send-to] supply ; else let =element be the next element and =remainder-of-supply be the remainder \nof the supply (=> \\ (stream =element =remainder-of-supply) (out send-to (print element) (print-elements \nremainder-of-supply)) (=> [#exhausted] if the supply is exhausted, do nothing nothing))))] The function \nnext calls up the supplY and asks it for the next . [next <= (=, ~~~~~~~~{r.the-customer =the-complaint-dept] \ni (the-supply #next the-complaint-dept) ))] Note that to get the second [and subsequent] elements out \nof a stream ~ the continuation received by~for (next s_n) must be used. Let wbe~cons-list 3 (cons-list \n4 nil)). The following expression will create a circular structure when evaluated: (w #rest <-w) (output \nw s) The printing will look like (list 3 3 3 3 . . . to s and will never cease. It will never get to \nprint the ) . The reader might be puzzled why we proceed in this ba$kward way. Why don t we write a FUNCTION \nrest which takes the rest of a list like any ordinary Pro9rammln9 lanquaqe does? For example (rest (cons-list \n 3 (cons-list B nil))) would be (list B) . People who have taken the approach of attempting to define \nsuch functions have come to realize that it is desirable to have some independence in the representation \nof data objects so they have tried to define RESTas a polymorphic operator. This means for example that \nRESTwould attempt to operate on vectors as well as lists. But then in any modeling situation in which \na kind of object is desired for which we would like to be able to compute the REST, the extrinsic functional \ndefinition of RESTwould have to change. The definition of RESTmust keep changing in a nonmodular way \nin order to add new knowledge, For example we might create strings and want to be able to take the RESTof \na string. Of course the following definitions of RESTand FIRST as functions will work: [rest <= (=> [=2] \n(z #rest))] [first <= (=> [=~ (z $first))] These are in fact the definitions that we use. Note that we \nhave two semantically related names: #REST and REST. We use #REST as a message and REST for the function \nwhich sends the message # REST to its argument. Making the above definitions of FIRST and REST and usinq \nthem instead of directly passing the messages #first and #rest does, however, increase the modularity \nof our formalism and so we shall adopt them, For example the definitions of FIRST and REST enable us \nto monitor these operations. The reason that we have discussed the actor cons-list in such areat detail \nis that it provides a paradigm for the way in which we will define actors in general. For example our \ndefinition of EVAL [the actor which evaluates forms] is: [eva~=;= [=x =the-environment] (x#eval the-environment))] \n In other words EVAL passes the buck to each kind of expression which is expected to either know how \nto evaluate itself or to further delegate the responsibility. There remains the problem of dividing up \nthe responsibility and knowledge in a reasonable wa,y. At this point we have only a few heuristics to \noffer. We hope to become more definitive as we ~ain more practical experience with actors. In general \nwe program each actor to field those requests for which it feels Imost qualified because the information \nneeded is most immediately at hand. For example we have not included #length among messages fielded by \nlist-structures but rather have preferred to write: [length .= (=> \\;::: -supply] the-supply (message \n[#length] [#al ternate (=> [~:j~-appl cable] the-supply (=> (stream ? =the-remaining-supply) ; the answer \nis 1 + (length the-remaining-supply))) (=> [ #exhausted] if the supply is exhausted then 0 O)))j There \nis a complete duality between operands and operators in the actor formalism. In many cases the precise \norganization seems more a matter of taste then anythinq else. The data type cons-list is the class of \nall actors that have the behavior defined above. Certain properties of the data type can be derived immediately \nfrom the definition. For example (where (cons-list xy) =Z (first z) is x) (where (cons-list xy) =Z (restz) \nisy) (where (cons-list xy) =Z (z #first <-x ) is z and z is equal to (cons-list x y)) (where (cons-listxy) \n=Z (z #rest <-y ) is z and z is equal to (cons-list x y )) McCarthy has given the above formulas as \naxicms for lists. In his system the data type list is the class of all structures that obey the above \naxioms. However if nothing is known about the actor draaons then (whe&#38; (cons-list xy) =Z (draqons \nz) (first (z #first <-x )) is unknown!%]) The reason is that dragons may have swallowed the list z and \npassed it to some actor which is still acting concurrently. Thus we don t know that the first of z is \nx even thouqh we just stored x there! Now any object which behaves like a list can be used in place of \na list. For example we can con\u00adstruct an object which is indistinguishable from an arbitrary list Z except \nthat it will Print OUt when\u00adever its first element is chanqed. To do this we will give a qeneral definition \nof a monitor. Monitors Every actor can have monitors which get to read ever,y message that is sent to \nthe actor. Monitors are mainly useful for metering and debugging. A monitor can be constructed b.y (Cons-monitorpattyn \nin-yinq-action Out-wiwmonity) where pattern is the specification Of the in going message, in-cjolng-action \n1s what t~o~out-aolnq-moni tor [which b.y the waY is oPtional] an out goinq rnonitor. For examplewe \ncan define a monitor for factorial that keeps addina one to the contents of number-of-calls\u00ad to-factorial \nevery time that factorial is called and prints out the [input output] pairs on the stream history-of-factorial \nfor each call. [monitor-for-factorial <m (cons -monitor (message =i nput) (number-of-cal 1s-to-factori \nal ~con~-mo~~t;r(contents (number-of -calls-to-factorial)))) (;essage =output) (out history-of-factorial \n(print [input output])) ))] The system actor NEW-MONITORis used to install a new monitor in an actor. \nFor example (new-monitor factorial monitor-for-factorial) installs monitor-for-factorial as a new monitor \nfor factorial. After which if (factorial 3) is evaluated then the contents number-of-cal is-to-factorial \nwill be increased by 3 and the stream history-of-factorial will be sent [[l] l] then [[2] 2] , and finally \n[[3] 61 . Iteration Iteration is a special case of sending messages to oneself. We envisaae a finite \nstate machine with inputs on one side and outputs on the other. ~m~ initial input...-.-->.-he Continuation---.-autput[iew-i \nnput] the The iteration statement is due to Nick Pippinqer and has the syntax: (iterate .~e m For example \nan iterative factorial program can be written as: [iterative-factorial <= (=> [=n] (itefit~lcounti rig-up \n(=> [=counter =accumulator] (rules counter [~~:en accumulator) (counting-up counter + 1) [ counter* \naccumulator)))]))))] Notice that there are no assignment statements in the above program! The behavior \nof iterative-factorial is the same as if it were defined as follows: [iterative-factorial <= (= > [=n] \n(label {[counting-up <= (receive (message [=counter =accumlator] [#continuation =c]) (rul~~=y~nter accumulator) \n(else (send counting-up (mes~age (counter + 1) (counter * accumulator )] [#continuation c])))]))]] \n(counting-up 1 l)))] We use (cycle name &#38;T as an abbreviation for (ite~~te = (=> [] ~)) Meta-Evaluation \nMeta-evaluation is the process of binding actors to their intentions and then evaluating the actors abstractly \non abstract data. Using actor induction we will show that if the meta-evaluation of a configuration of \nactors succeeds then the intentions of the actors will be satisfied in the subsequent execution of the \nconfiguration. If the meta-evaluation cannot proceed it will stop at the point where it cannot confirm \nthat an actor always satisfied its intention and ask for help. At this point there are several possibilities: \nThere really is an inconsistency: The inconsistency is between the way the actor is being attempted to \nbe used and its intention. The inconsistency is between the intention of the actor and its actual implementation. \nThe intentions for a configuration of actors are not mutually consistent. There is no inconsistency but: \nThere are hidden assumptions being made about actors that should be made explicit. There is hidden domain \ndependent knowledge that the actor is usino which should be made explicit, The intentions are not being \nsufficiently explicit as to why they are expected to be satisfied. Convergence of Actors Meta-evaluation \ncan be used to show that certain inputs must eventually generate outputs. The basic technique is the \nprinciple of induction over well-founded partial orders invented 11.v mathematicians and elegantly formalized \nby John von Neumann. The technique is a special case of actor induction. At present, actor induction \nfor an actor configuration with input audience I and output audience O can be tentatively described in \nthe following manner: 1. There is a well-founded input-output partial order P. That is, there is no sequence \ns of distinct elements of P such that for ever,y i we have (s i) {P}(5 (i +1)). 2. The actors in the \ninput audience I assiqn an element p of P to each input message m. Me will denote this by the notation \nP<m,p>. 3. For each actor A if ~<m,p> is received by A, then A must send a messacie p<m ,p > such that \nP{P}P.  Therefore Every message from the input audience must eventually result in a messaqe being sent \nto the output audience. A Simple Example Illustrating How A Diligent ~ Moderately Dumb Apprentice Can \n~ We would like to give a simple concrete example to illustrate our techniques in action. Consider the \nprobelm of writing a program to shift the gears of a truck with a manual transmission. We apologize for \nthe necessity for introducing new syntax but the following concepts are crucial to the discussion which \nfollows: 1: Definitions [x <= (=> [=y] body) ] is actor syntax which at a rough intuitive level means: \ndefine an actor x which, when it is called with an argument (to which ~is bound) executes ~. 3.63 2: \nRules ~es 3, (=> =yl bodyl) (=> =y2 bodyz) .,. ... )roughly means: take x, and if it matches Y1, execute \n~l; otherwise if it matches y~, execute body 2, etc... 3: Intentions [x <= (intention [n] il ~finition \n~ is an elaboration of 1, meaning that when ~ is called with ~, then il is the intention of the incoming \ncall and i2 is the intention when ~calls out again. Our first try at a shift procedure might be: Primitive-shift-to: \nwhen called with a target gear checks to see if it is 1, 2, 3, or 4 and calls the appropriate select; \nupper-left, upper-riqht, or lower-right respectively. [primitive-shift-to <= (=> [=target-gear] (rul~~>t~rget-gear \n(select-upper-left)) (=> 2 (select-lower-left)) (=> 3 (select-upper-right)) (=> 4 (select-lower-right))))] \n Now we consider the various select routines and their intentions. Each of the select functions has an \nincoming intention that the clutch be disengaged. Furthermore each of them has code (delimited by *) \nto do the selecting. When a selector calls out, we fully intend for the truck to be in the aear appropriate \nto that selection. [select-upper-right <= (intention [] (clutch-disengaged) *code-for-select-upper-right* \n(in-gear 3))] [select-upper-left <= (intention [] (clutch disengaged) *code-for-select-upper-left* (in-gear \nl))] [select-lower-ri ht<= (intention [ f (clutch disengaged) *code-for-select-lower-right* (in-gear \n4))] [select-lower-left <= (intention [] (clutch disengaged) *code-for-select-upper-right* (in-gear \n2))] Our apprentice notices that for each one that there is a physical constraint that the clutch must \nbe disengaged before shifting. He queries us abut this and so we decide to modify the function PRIMITIVE-SHIFT-TO \nto first disengage the clutch. [primitive-shift-to <= (=> [=target-gear] (disengage clutch) (rul~~>t~rget-gear \n (select-upper-left)) (=> 2 ~=~s;lect-l ower-1 eft) ) ~=~s;lect-upper-ri ght)) (select-lower-right))))] \n~engage clutcn~)j how the code for primitive-shift-to is to first disengage the clutch, then do the selectinq \nas before, and finally engage the clutch. We also write functions to disengage and engage the clutch, \n[disengage <= (intention [=clutch] (clutch engaged) *code-for-disengage* (clutch disengaged))] [engage \n<= (intention [=clutch] (clutch disengaged) *code-for-engage* (clutch engaged))] Now our apprentice \nis mollified. However, the engineers dealing with the transmission come to us with some additional constraints. \nFor example to select third gear the constraints are now that the clutch must be disengaged and the truck \nmust be in either second or fourth gear. The other constraints are similar. [select-upper-right <= (intm;m \n(clutch disengaged) (or (in-gear 2) (in-gear 4))) *code-for-select-upper-right* (in-gear 3))] [select-upper-left \n<= (i nt~;~~on (clutch disengaged) (stopped)) *code-for-select-upper-left* (in-gear l))] [select-lower-right \n<= (intention (and (clutch disengaged) (in-gear 3)) *code-for-select-lower-right* (in-gear 4))] [select-lower-left \n<= (int~:;~on (clutch disengaged) (or (in-gear 1 ) (in-gear 3))) *code-for-select-lower-left* (in-gear \n2))] The new requirements say that (temporarily at least) the truck has to be stopped to shift into gear \n1 and no gears can be skipped in shifting while running. (Note you can shift directly from any gear to \nfirst if the truck is stopped. ) So we have to write some new procedures to meet these new intentions, \nWe now write our top-level shifting function: SHIFT-TO: when called with a target gear considers in order \nthe followinq rules for the tarqet gear: If it is first gear, then-do a primitive-shift-to first qear. \nIf it is either one greater than the current gear or one less than the current gear then do a primitive-shift-to \nthe target gear. If it is greater than the current gear then shift-to one less than the target gear \nand then primitive-shift-to the target gear. If it is less than the current gear then shift-to one greater \nthan the target gear and then primitive-shift-to the target gear. [Silift-to <= (=> [=target-gear] (rul~~, \ntfrget-gear (primitive-shift-to 1)) (=> (eithfl (currcnc gear + 1) (current-gear -1)) (primitive-shift-to \ntarget-gear)) (=> (greater (current-gear)) (shift-to (target-gear-l)) (primitive-shift-to target-gear) \n) (=> (less (current-gear)) (shift-to (target-gear+ 1)) (primitive-shift-to target-gear))))] We ask \nour apprentice to meta-evaluate our program. It thinks for a while and sees two problems: It can only \nshift to gear 1 if the truck is stopped. It should not be asked to shift to the gear that it already \nis in. [the procedure shift-to does not work if it is asked to shift to the current gear.] We decide \nto give the following intention to SHIFT-TO: If the target-gear is first gear then the truck must be \nstopped; otherwise the target-gear must be 2, 3, or 4 and not be the current gear. [shift-to <= (intention \n[=target-gear] (rul~~,t~rget-gear (stopped)) (=> (or2 34) (target-gear# current gear)) (else (not-applicable))) \n*code-for-repeatedly-shift-to* (in-gear target-gear) )] To summarize we have used intentions in the \nfollowing somewhat distinct ways: As a contract that the actor has with its external environment. How \nit carries the contract is its own business. As a formal statement of the conditions under which the \nactor will fullfill its contract. 166 The above example does not deal with all of the computational issues \nthat our apprentice will be faced with. For example it does not have sophisticated data structures,and \nhas no concurrency or parallelism. We deal with these problems in the technical report. Acknowledgements \nEverything of importance has been said before by somebody who did not discover it. Alfred North b!hitehead \nThis research was sponsored by the MIT Artificial Intelligence Laboratory and Project MACunder a contract \nfrom the Office of Naval Research. We would be very appreciative of any comments, criticisms, or suggestions \nthat the reader might care to offer. Please address them to: Carl Hewitt Room 813 545 Technology Square \nM.I.T. Artificial Intelligence Laboratory Cambridge, Massachusetts 02139 The topics discussed in this \npaper have been under intense investigation by a larqe number of re\u00adsearchers for a decade. In this paper \nwe have merely attempted to construct a coherent managable formalism that embraces the ideas that are \ncurrently in the air . We would like to acknowledge the help of the following colleagues: Bill Gosper \nwho knew the truth all along: A data structure is nothing but a stupid programming lanquage . Alan Kay \nwhose FLEX and SMALL ~K machines have influenced our work. Alan emphasized the crucial importance of \nus~ng intentional de\u00adfinitions of data structures and of passing messages to them. This paper explores \nthe consequences of generalizing the message mechanism of SMALLTALK and SIMULA-67; the port mechanism \nof Krutar, Balzer, and Mitchell; and the previous CALL statement of PLANNER-71to a universal communication \nmechanism. Alan has been extremely helpful in discussions both of overall philosophy and technical details. \nNick Pippenger for his very beautiful ITERATE statement and for helping us to find a fast economical \ndecoding net for our ACTORmachine. John McCarthy for making the first circular definition of an effective \nproblem solving formalism and for emphasizing the importance of the epistemological problem for artificial \nintelligence. Seymour Papert for his little man metaphor for computation. Allen Newell whose kernel approach \nto building software systems has here perhaps been carried to near its ultimate extreme along one dimension. \nDavid Marr whose penetrating questions led us to further discoveries. Rudy Krutar, Bob Balzer, and Jim \nMitchell who introduced the notion of a PORTwhich we have generalized into an ACTOR. Robin Milner is \ntackling the problems of L-values and processes from the point of view of the lambda calculus. He has \nemphasized the practical as well as the theoretical implications of fixed point operators, Robin s puzzlement \nover the meaning of equality for processes led to our definition of behavior. Edsger Dijkstra for a pleasant \nafternoon discussion. Jim Mitchell has patiently explained the systems imple\u00admentation language MPS, \nJeff Rulifson, Bruce Adnerson, Gregg Pfister, and Julian Davies showed us how to clean up and generalize \ncertain aspects of PLANNER-71. Peter Landin and John Reynolds for emphasizing the importance of continuations \nfor defining control structures. Warren Teitleman who cleaned up and generalized the means of integrating \neditors and debuggers in higher level languages. Peter Landin, Arthur Evans, and John Reynolds for emphasizing \nthe importance of functional data structures. Danny Bobrow and Ben Wegbreit who originated an implementation \nmethod that cuts down on some of the overhead. We have simplified their scheme by eliminating the reference \ncounts and all of their primitives, C.A.R. Hoare is independently investigating monitors for data structures. \nJack Dennis for sharing many of our same goals in his COMMONBASE LANGUAGEand for his emphasis on logical \nclarity of lanquage definition and the importance of parallelism. Bill Wulff for our . notation on the \nconventions of the values of cells and for being a strong advocate of exceptional cleanliness in language. \nPitts Jarvis and Richard Greenblatt have given us valuable help and advice on systems aspects. Chris \nReeve, Bruce Daniels, Terry Winograd, Jerry Sussman, Gene Charniak, Gordan Benedict, Gary Peskin, and \nDrew McDermott for implementing previous generations of these ideas in addition to their own. J,C.R, \nLicklider for emphasizing the im\u00adportance of mediating procedure calls. Butler Lampson for the notion \nof a banker and and for the questions which led to our criteria for separating an actor from its base. \nRichard Wehyharauch for pointi~g out that logicians are also considering the possibility of procedural \nsemantics for logic. He is doing some very interesting research in the much abused field of computational \nlogic . Terry Winograd, Donald Eastlake, Bob Frankston, Jerry Sussman, Ira Goldstein, and others who \nmade valuable suggestions at a seminar which we gave at M.I.T. John Shockey for helping us to eradicate \na infestation of bugs from this document. Greg Pfister, Bruce Daniels, Seymour Papert, Bruce Anderson, \nAndee Rubin, Allen Brown, Terry Winogard, Dave Waltz, Nick Horn, Ken Harrenstien, David Marr, Ellis Cohen, \nIra Goldstein, Steve Zilles, Roger Hale, and Richard Howell made valuable comments and suggestions on \nprevious versions of this paper. Bibliography Balzer, R. M., Ports--A Method for Dynamic Interporgam \nCommunication and Job Control The Rand Coloration. 19710 Bishop, Peter. Data Types for Programming Generality \nM.S. June 1972. M.I.T. Bobrow D., and Wegbriet Ben. A Model and Stack Implementation of Multiple Environments. \nMarch 1973 Burstall, R.M. Proving Properiles of Programs by Strucural Induction Computer Journal Vol \n12. pp. 41-48 (1969). Courtois, P.J., Heymans, F. Parnass G.L. Concurrent Control with READERS and WRITERS \n Comm. ACM 14 10 PP667-668. Oct. 1971 Daniels, Bruce. Automatic Generation of Compilers from Interpreters \n. M.S. Forthcoming 1973. Davies, D,J.M. POPLER: A POP-2 PLANNER MIP-89. School ofA-I. University of Edinburgh. \nDeutsch L.P. An Interactive Program Verifier Phd. University of California at Berkley. June 1973. Forthcoming. \nEarley, Jay. Relational Level Data Structures for Programming Languages . March 1972. Elcock, E.W.; Foster, \nJ.M.; Gray, P.M.D.; MacGregor, H.H.; and Murrary A.M. Abset, a Programming Language Based on Sets: Motivation \nand Example. Machine Intelligence 6. Edinburg University Press. Evans, A.E. PAL--Pedagogic Algorithmic \nLanguage, A Reference Manual and Primer Dept. of Electrical Engineering. M.I.T. 1970. Fisher, D.A. Control \nStructures for Programming Languages Phd. Carnegie. 1970 Floyd R. W. Assigning Meaning to Programs Mathematical \nAspects of Computer Science. J.T. Schwarts (cd. ) V~~e~~.lA~. Math. Sot. pp. 19-32. Providence Rhode \nIsland 1967. Induction ti Proofs about Programs Project MACTechnical Report 93. Feb, 1972. Haberma~n \nA.N. Synchronization of Communicating Processes Comm. ACM 15 3 pp. 177-184. March 1970. Hewitt, C. and \nPatterson M. Comparative Schematology Record of Project MACConference on Con\u00adcurrent &#38;ystems and \nParallel Computation. June 2-5, 1970. Available from ACM. Hewit, C., Bishop P., and Steiger, R. A Universal \nModular ACTORFormalism for Artificial Intell\u00adigence PLANNERTechnical Report 3. December 1972. Revised \nMarch 1973 and June 1973. Hewitt, C., Bishop P., and Steiger, R. A Universal Modular Actor Formalism \nfor Artificial Intell\u00adigence IJCAI III. Stanford, Calif, Aug 1973 Forthcoming. Hoare, C.A.R. An Axiomatic \nDefinition of the Programming Language PASCAL February 1972. Kay, Alan C. Private Communication, Krutar, \nR. Conversational Systems Programming (or Program Plagiarism made Easy) First USA-Japan Computer Conference, \nOctober 1972. Landin, P.J. The Next 700 Programming Languages Comm.ACM9. (March, 1966). pp 790-793. Manna, \nZ.; Ness, S,; Vuillemin J. Inductive Methods for Proving Properties of Programs Pro\u00adceeding of an ACMConference \non Proving Assertions about Programs January 1972. McCarthy, J.; Abrahams, Paul W.; Edwards, Daniel J.; \nHart, Timothy P.; and Levin, Michael I. Lisp 1.5. Programmer s Manual, M.I.T. Press McCarthy, J. Definitions \nof New Data Types in ALGOLX ALGOLBulletin. OCT. 1964. Milner, R. Private communication. Mitchell, J.G. \nA Unified Sequential Control Structure Model NIC 16816. Forthcoming. Morris J. H. Protection in Programming \nLanguages CACM. Jan, 1973. Naur. P. Proffs of Programs by General Snapshots BIT. 1967. Newell, A.; Freeman \nP.; McCracken D.; and Robertson. G. The Kernel Approach to Building Software Systems. Carneigie-Mellon \nUniversity Computer Science Research Reviews. 1970-71. Park, D. Fixpoint Induction and Proofs of Program \nProperties Machine Intelligence 5. Edinburgh University Press. 1969. Patil, S. Closure Properties of \nInterconnection of Determinate Systems Project MACConference on Concurrent Systems and Parallel Processing. \nJune 1970. Perlis, A.J. The Syntesis of Algorithmic Systems JACM. Jan 1967, Reynolds, J.C. GEDANKEN-ASimple \nTypeless Language Based on the Principle of Completeness and the Reference Concept CACM, 1970. Reynolds, \nJ.C. Definitional Interpreters for Higher-Order Programming Lanquaqes Proceedings of ACMNational Convention \n1972. Rulifson Johns F., Derksen J.A., and Waldinger R. J. QA4: A Procedural Calculus for Intuitive Reasoning \nPhd. Stanford. Noveinber 1972. Scott, D. Data Types as Lattices Notes. Amsterdam, June 1972. Standish, \nT. A Data Definition Facility for Programming Languages Phd. Carnegie. 1967. Steiger, R. Actors . M.S. \n1973. Forthcoming. Waldinger R. Private Communication. Wang A. and Dahl O. Coroutine Sequencing in a \nBlcok Structured Environment BIT 11 425-449, Weyhrauch, R. and Milner R. Programming Semantics and Correctness \nin a Mechanized Logic. First USA-Japan Computer Conference. October 1972. Wulf W. and ShawM. Global Bariable \nConsidered Harmful Carnegie-Mellon University, Pittsburgh, PA. SIGPLAN Bulletin. 1973.\n\t\t\t", "proc_id": "512927", "abstract": "The PLANNER project is continuing research in natural and effective means for embedding knowledge in procedures. In the course of this work we have succeeded in unifying the formalism around one fundamental concept: the ACTOR. Intuitively, an ACTOR is an active agent which plays a role on cue according to a script. We use the ACTOR metaphor to emphasize the inseparability of control and data flow in our model. Data structures, functions, semaphores, monitors, ports, descriptions, Quillian nets, logical formulae, numbers, identifiers, demons, processes, contexts, and data bases can all be shown to be special cases of actors. All of the above are objects with certain useful modes of behavior. Our formalism shows how all of these modes of behavior can be defined in terms of one kind of behavior: sending messages to actors. An actor is always invoked uniformly in exactly the same way regardless of whether it behaves as a recursive function, data structure, or process.", "authors": [{"name": "Carl Hewitt", "author_profile_id": "81332503927", "affiliation": "", "person_id": "PP43124513", "email_address": "", "orcid_id": ""}, {"name": "Peter Bishop", "author_profile_id": "81542602056", "affiliation": "", "person_id": "PP30026029", "email_address": "", "orcid_id": ""}, {"name": "Irene Greif", "author_profile_id": "81100427186", "affiliation": "", "person_id": "PP40027153", "email_address": "", "orcid_id": ""}, {"name": "Brian Smith", "author_profile_id": "81539765156", "affiliation": "", "person_id": "PP14038378", "email_address": "", "orcid_id": ""}, {"name": "Todd Matson", "author_profile_id": "81547924356", "affiliation": "", "person_id": "P348465", "email_address": "", "orcid_id": ""}, {"name": "Richard Steiger", "author_profile_id": "81100632112", "affiliation": "", "person_id": "P348464", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512927.512942", "year": "1973", "article_id": "512942", "conference": "POPL", "title": "Actor induction and meta-evaluation", "url": "http://dl.acm.org/citation.cfm?id=512942"}