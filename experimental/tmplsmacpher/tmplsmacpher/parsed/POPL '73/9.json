{"article_publication_date": "10-01-1973", "fulltext": "\n Permission to make digital or hard copies of part or all of this work or personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, \nto post on servers, or to redistribute to lists, requires prior specific permission and/or a fee.&#38;#169; \n1973 ACM 0-12345-678-9 $5.00 FORMALIZATION of EXEL L. NOLIN G. RUGGIU Universit6 PARIS VII THOMSON-CSF \nPARIS 91401 -ORSAY -FRANCE 1 -INTROOUCTION.- EXEL is a family of programming languages, which has been \ndesigned in the framework of a research on computer architecture : the EOELWEISS system [VAS-BLA]. The \ndevelopment of EXEL is such as to place it in the framework of structured programming. The noti.one of \nlabel and GOTO have disappeared and are replaced by those of program schemata equations. This gives rise \nto important mathematical properties which are useful in organizing the system. Furthermore, this fact \nmay bring profound implications in the theory of programming CARS] ; in particular, we foreeee powerful \nmethods proving the correctness of programs. The semantics of EXEL is well-defined with respect to combinatory \nlogic that is, there exists an algorithm which allows one to translate any EXEL program A, into a word \na of combinatory logic. We assume that the semantics of combinatory logic is known [NOL-SCO 2], The word \na , thus obtained, contains constants only and the execution of the program consists in reducing this \nword until no reduction rule remains applicable. The reduced word thus obtained ie tha result of the \nprogram. It is necessary that certain constants of EXEL and of combinatory logic should have the same \ninterpretation. To simplify we have simply added to combinatory logic these specific constants and the \noperating rules in EXEL correspond to the reductions in combinatory logic. This is made more precise \nin the following. Since the mamory allocation will be mada during the interpretation of the programs, \nmost of the declarations are suppressed and are not considered in this formalization. However, concerning \nthe added constants, their treatmant by the computer is accompanied by a control of types similar to \nthat described by B. ROBINET [ROB]. Such a calculus ia in any way indispensable for a variant APL of \nEXEL. As for the procedures, we envisage a simplified treatment of the calculus of types. The header \nof a procadure gives the possibility of determining its type which is more general and more precise than \nthat defined in the languages such as ALGOL. We use this calculus of types to generalize the procedure \ncalls. The correspondence betwean EXEL and combinatory logic thus allows one : al -to describe without \nambiguity how a machine executes a program, b) -to define the interpretation and therefore the semantics \nof a program, independently of any machine, c1 to establish propartias of the programs, The research \nreported here was supported in part by the Comit6 de Recherches en Informatique. 108 These properties \ngive the possibility of defining transformations which preserve the equivalence of the programs. These \ntransformations may be used by the system to increase the efficiency of program execution by a machine. \nThe treatment of programs, and more generally, the architecture and the logical functions of the EDELWEISS \nsystem are thus justified. REMARK : Let us first mention some notations. The symbol ~ designates the \ncombinator which, applied to two arguments a and b forms the couple <a,b> More generally : is a combinator, \nwith n arguments and which forms an n-uple : <a ---~ =<a ---,an> nl n1 th To every natural integer, n, \nwe associate a combinator, 6, which selects the (n+l) componant of an m-uple (mm) : We use two particular \nconstants :CU and Q . We may interpret m as the undefined and Q as the error . We also use the predicate \n~Q which has one argument X ; this argument must be an n-uple (nzl): . d?,X . if at least one component \nofX=Qthen i, else O, Finally, we use specific algorithms, Un, with n arguments [NOL]. These algorithms \ncorrespond to the lattices operator SUP. They may be interpreted as follows (let us take for instance \nn=2) : \\ if a=b, then a u2(a,b)= if azb if a=rn then b if b.co then a else $2 II We also write U2 ({a, \nb}) instead of u2(a,b). When a and b are n-uples, the above definition must be extended by comparing \na to b, component by component, the result being an n-uple of the same length. 2 -THE BASIC LANGUAGE \n: .LS.\u00ad 2-1 -DEFINITION : The basic language LS describes the operations of sums and products for flow-charts \n: At a al IblI b $ a;b [al b)[tl sum product 109 These black-box contain either primitive operations \nor compound flow-charts. Primitive operations are described below (f 51. For the moment, it is enough \nto distinguish three claases of them: 1) -F , the set of formulas-variables [which designate instructions] \n: F = {fq, f2,---] ; 2) -!7 , the set of tests-variables : T = { cfl, t2,---} ; 3) -the constant A [which \ncorreeponde to the dummy e catemen c). LS is generated by the two following rules : a) -A and the elements \nof F belong to M ; b] -ifacLS, bASand teT, then [a;bl AS , [alb)[tl <IX. The translation of these formulas \nin combinatory logic is defined by the algorithm T : i) if aE(~UT), T(a) = a and T(A) = ~ ii] T((0,;6)) \n= ;(T(cs))(T(6)) and T((a16)[t]) = [(T(a))(T(6))(T(t)) Thus two new constants are introduced in L.C. \n: ; and [ . We generally admit that, in the formula (a;b) (reep. [a]bl[tll, b [reep. (alb)) is computed \nonly if the execution of a (resp. t) does not lead to an error (Q]. Hence, the following rules of reduction \n: for any variable ~ ;ab~ = j (CBab)a(&#38;Q(a~))~ ~abt~ = ~ ab(t~)~ The respective values of ; and C \nare deduced : i=i?(B(csI))(s(Bi?(B(cB)(B(eQ) ))(s(m(cj))(a?))) [=B(B(B(csr)))(B(Bs)(B(BK)j) REMARKS : \n1) -If the errors are not taken into account it is possible to limit oneself to a simpler composition, \nwritten ~ and to set : (a~b)~ =~ab~ , so ~=CB 2) -We suppose that (t~).n~ver leads to an error for we \ncan always limit ourselves to a set T such that v~, (t~)c{o,l} 3) -We introduce, thanks to appropriate \ndefinitions, the composition of tests bv boolean functions. For instance : (alb)[-tl = (bla)[tl, (alb)[tvul \n= ((alb)[ullb)[t], etc . . . .. 4) -We can generalize the formula of tests. If we suppose that : (tg) \nc {o, 1,---, n}, We can set : (al l---\\an+,)[t] ELS and T((all---\\an+l)[t]) =n~~(al)---T(an+2) T(t) with \nIlilal---aIl+l ~=n:la,---an+, (t~)~. 2-2 -EQUIVALENCE IN LS AND PROPERTIES : Two formulaa which give \nthe same reeults from the came arguments can be considered as equivalent. In fact, the variable ~ , used \nin the reduction rules, designates any possible arguments (the different states of the machine]. So, \nwe can set : Definition : TWO words a and b of LS are equivalent if and only if, v~ euch that (cQ~) = \no T(a)~ = T(b)~. Properties I : i) In the same way, we have : ii) a;A = a and ii] A;A = A Properties \nII : Associativity : va,b,c,eLS, (a;b);c = (a;b);c = a; b;c) = a;b;c As a matter of fact : ;;abc~ = \nj (CB(;ab)c)( ;ab)(&#38;(; ab~ )C If d2(aF,) = 1, then ;;abc~ = a<; else if 60(b(a~ )=;, then ;;abc~ \n= b(a~); else ;;abc~ = c(b(a~)). But ;a;bcc = j (CBa(;bc))a(6Q(a< If eQ(a~) = 1, then ;a;bc&#38; = a$; \nelse if &#38;(b(a~)) = ~ , ,then ;a;bc&#38; = b(a~); elee ;a;bc~ = c(b(a~)). The property of aasociativity \nthen allows the suppression of unnecessary paranthesee. In the came way, we have : Property III -Righ \ndistributivity : va, b,c~LS and teT : (alb)[t] ; c=(a;clb;c)[tl REMARK : It can be established that \nthere is no left distributive.ty : a; (blc)[tlz(a;bla;c)[tl If, on the other hand, one knows that c~(a~) \n= o , then ;a([bct)=[(; ab) (;ac)(~ta). The property of distributivity may be generalized. For this we \nintroduce the notion of continuation. Let us first define the terminal occurrences of a word of IS: \nDefinition : An occurrence f3 of a word in a ie eaid to be terminal if : al -either a=~; b] -or, there \nare a and d such aa 0,=Y;6 and 6 is terminal in 6 ; c1 -or, there are y,d and a test t such as a=( yld)[t] \nand @ is terminal in Y or in 6. For inetance in a=a; (b;cld)[t], d and b;c are terminal in a; a and b \nare not The continuation of a by ~ , denoted by pBa is defined as follows : Definition : p~a designates \nthe word obtained from a by concatenation of the word :!3? to all the terminal occurrences of A and \nof the elements of F in a. Property IV ! Generalization of distributivity : IY,;6 = pa.6 This is demonstrated \nby induction on the lengh of the word ct. If the length of a is one we have 66 6 precisely p~a = a;~, \nIf a ie of the form a;b, we have : a;~=(a;b) ;~=a;(b;~)=a;p b=P (a;b)=p a. 1.11 If a is of the form (alb)[t], \nwe have : a;@=(alb)[t];6=(a;@lb;~) [t]=(p6alp6b)[t]=p6( (alb) [tl)=p~a 3 -THE EXTENDED LANGUAGE -THE \nPROCEDURES .\u00ad 3-1 -SEMANTICS OF THE EXTENOEO LANGUAGE : It is the language in which the procedures are \ndescribed [except the calls of procedures which are deecribed later). Up to now, we described loopleee \nflow-charts. The extended language givee the possibility to describe looped flow-charts, or even recursive \nschemata, For that purpose we do not use the notion of label but that of action variables. We consider \na new set VA , the action variablee : VA={X,Y,---,XI}---} The extended language LE is obtained by adding, \nby induction,the elements of V to the words A of LS. We call equation in LS any word of the form xLF \nwhere X belongs to VA and F belongs to LE. X (resp.Fl is the left [reep. right) member of the equation. \nThe elemente of VA which have some occurrences in F, can be considered as linguistic variables which \nrange ,LS and xXF is then an implicit equation which binds X to these variables, The body, p, of a procedure \nis an ordered pair p=<E,Xn> such that : a) -E is a finite set of equations in .LS : E={Ej=Xj~Fj/Xj.VA \nand EjCLE, l<j<p} such that for any variable of action Xk occurring in one of the F., there exists an \nequation and only one : Ek of which the left part is precisely X: ; b) -there is an equation En of which \nthe left part is X n The body of a procedure is then a set of equations similar to these which define \nthe grammar of a C -language [CHOj.We can, consequently, solve them by the came method. In fact, it is \nfiret neceesary to complete LS in ~ by infinite words which are the limits of Cauchy saries in ~. For \nthat purpose the worda of L,!? are associated to the polynomial of the free associative algebra S=Q(F \nUZ U~)*], the monomials of which are elements of the free aemigroup (~,TJ~U~)* [with an unit element) \nand the coefficients of which belong to the ring !2={0,1} : P (a;b) = P(a) P(b) p ((alb)[t]= t P(a) +~P(b). \nWe call dietance of two polynomials, Pfl and P2, the number d(P1,P2] = 2-s, s being the degree of the \nmonomials having the smallest degree and which, in one of the polynomial, has 1 as a coefficient and \nO ae a coefficient in the other. S thus becomes an ultra-metric space. Thus Cauchy s sequences in S : \nP1 = {PJ/i=l,---}, Pz ={ P~/i=l,---l are equivalent if and only if : ~E>O, ~k, Vi(i>k+d(P~, Pf)<s). Let \n~ the quotient set of the set of equivalent Cauchy s sequences. The language L= corresponds to 5. Such \na completion is equivalent to that proposed by Scott [SCO 1] , It is known that in the language ~ [CHO-NIV],if \nthe system E verifies some conditions [conditions of elevation] which do not reetrain the generality \nof the equatione, E admits a unique solution Fo,. Let F be the p-uple <F1,---,FP>, and H: <X1,---,Xp>. \nF, applying fip, into ~, FO is such aa :; Fo = FIFo). The expression of this solution in combinatory \nlogic, T(Fo), must then verify the condition : T(FO)=[~(FO)/ r (H)l r (F) . But we may write T(H)=H : \n[T(Fo)/HIT (F)= (M. T(F)) (T(Fo)l where X is the operator of abstraction . Then the eolution may be written \n[BOH] as follows : T(Fo]=Y(AH.T(F]) where Y is a fixed-point combinator. TO build T(F); it ie sufficient \nto give the translation of the X,i(l<j<p) in LC:V,i T(X,i)=H~, and we then have : ~(F)=lH.(~(T(Fl))---(~ \nFpl)). th The translation of the body, p, of a procedure is then the n component of T(Fo) : T(P)=Y(T(F)); \n. 3-2 -EQUIVALENT SYSTEMS : TWO systems El and E2 are equivalent if they have the same solution. Let \nEq be the system : Eq={x1~F1, ,xp~Fp} and E2 the system identical to El except for one equation : , \nF! is deduced from Fj by substituting Fk for the occurrence a of a X<j+Fj where J variable X : k F;=[F \n/xal F kkj Theorem of substitution : The systems Eq and E2 are equivalent. The solution of E2 is : F \n=<F ----F . By definition E2 is equivalent tO : X1~CF,/xl,--,Fp/x~lF1, Opl P ---------,$~[F1/xl , --,FXp]([ \nFkFX;]FjFj ), -- - ---- -,Xp~[F1 /X1, --,FxplFpFp . But : [F1/X1,---,FXPl([FkFX~lFj)=[FIF1 /Xl,---,FXPl(I(EFIFX1,l, \n---,Fp/XPIFk)/X~lFj). Now, the eolution, ie the fixed point of E2 : [F1/X1,- ,F /X IF F . ppkk Consequently \nthe J. th equation becomee: Xj~[F1/X1,---,F /X IF. . PPJ In other words, Fo is aleo solution ofE1. The \ntwo systems El and E2 are then equivalent. This result shows that, during the process of successive approximations, \nallowing to reach the fixed-point, solution of the system, all substitutions are allowed. This them-em \nof substitution then defines transformations that preserve the equivalence of the systems of equations. \nIt also justifies the techniques of copy used by Ashcroft and Manna to transform the Goto programs into \nwhile programs [ASH 1. 4 -THE ITERATION .\u00ad 4-1 -DEFINITIONS : Iteration is an abbreviation for a particular \nform of action. In fact, we construct a new language LI, which, besides LS, contains iterations. The \niterations are a generalization of the loops While of ALGOL. The LI alphabet is constituted by the LS \nalphabet and by the three symbols : {, }, m. An iteration has the following structure : {<body of the \niteration>}, where <body Of the iteration> is obtained from the words of LS by substituting to some occurrences \nof elements of F the constant o . The language LI is obtained by adding, by inductiOn, the iterations \ntO LS. Thus we may construct nested iterations : {---{ }---{ ---{ ---} ---} ---}; ---:{---} An iteration \nis interpreted as follows : if during its execution, We meet the eymbol u , then one goes out of the \ninnermost iteration in which thie symbol ie met and one goes to the following formula ; otherviee one \ncontinues the normal execution of the iteration J one starts again at the beginning of this latter if \none meets a terminal occurrence different from m . 113 However, in spite of its analogy to regular expressions, \nthe LI-language ie still insufficient to describe all flow-charts [ARSI without having recouree to auxiliary \nvariables for locating exit teste [in the regular expressions there is no equivalent to these tests). \nThe incompleteness in the language LI appears because the continuation operation cannot be extended to \nthe iterations. For instance, let : 6 = {(alti)[t]};{a} in which a contains an occurrence of o ; it is \nimpossible to transform 6 into 6 : 6 {[al{a}][t]} for the occurrence of m in u should be also an exit \nof B\\ Thus, we consider the infinite countable set A {LO1,---,Wn,---} . Let LI* be the set of the worde \nobtained from LI by substituting any element of A to the occurrences of m . We extend the notion of terminal \noccurrence to the iterations :6 has a terminal occurrence in a if these is y such as U={a} and 6 ia a \nterminal occurrence Of a . Definition : It is said that ~ has an occurrence at the level n in a if there \nie y and 6 such as c4=y(3d-and y contains exactly n more { symbols than } . Definition : The language \nLI is a subeet of LI* such as : al -the iterations only have terminal occurrences in the words of LI \n; b) -vn, any occurrence of u is a terminal occurrence at level p>n. n OJ is a more general symbol than \nu, the occurrence of which leads to the termination of the n n innermoet iterations. The words of LI \n, thus only containe terminal iterations. This does not decrease the generality of this language at all, \nbecauee of the continuation operation which is possibile in LI*. For inetance : {a};{(a\\ul)[tl}=> {Ct;{(alwz)[tl}} \n: The word situated on the left of => does not belong to L1! whereas that eituated on the right belongs \nto ; but, according to the interpretation of on, they are equivalent. The semantics of the iteration \ncan be defined by an algorithm which permits to asaoclate a set of action equations to each word of LI \n, Let M c LI and J an occurrence at level O of the iteration {1] , Let Z1 and Z2 two action variables \nwe associate to M the two actions : ZI z [Z2/J]M Z Z:Y where ~ is obtained from 1: al -by concatenating \n;22 to every terminal occurrence of the elements of F and at level O in I; b] -by canceling every occurrence \nat level O of ;ofl ; cl -by replacing, vnzl, every occurrence at level n of on by Z2 . d] -by replacing, \n~nzl, every occurrence at level n of tin+q by un . In ~, the occurrences of tin are terminal and at the \nlevel p>n. By thus adding a eufflcient. number of equations, in a finite number of steps, we are led \nto a syetem, E, which no longer contain any iteration ; by definition, this system is associated to N. \nWe eaeily verify that the action variablee have only terminal Occurrencesin each equation of E. Such \na system is said regular. 4-2 -TRANSLATION OF FLOW-CHARTS INTO AN ITERATIVE FORPl : A regular system \ncorresponds to a flow-chart. The LI language permits to write the solutions of those systems [thus we \nare able to eolve them in LI ). As a matter of fact, the following algorithm permits to associate a \nword of LI to each regular system. Let E be such a system : E={X1~F, , - ,Xi~Fi,Xp~Fp}~Fp} . i= 1 :al \n-Set b] -if Fi ~ =0 , then eet F i--Fi and go to d) ; otherwise go to e) ; i c) -transform Fi into F: \nas follows : i) concatenate the word :U to every terminal occurrence of the elements of F which is 1 \nat level O; ii] cancel every occurrence of ;zz at level o in F. ; 1 iii) replace, Vn>l, every occurrence \nof U at level n by a ; n n+ 1 iv] replace, Vn>l, every occurrence of X which is at the level n, by \ntin , and frame i the word thus obtained within the brackets { and } ; d) -substitute F; for every occurrence \nof Xi in every equation indexed by j>i+l, replacing (lJ~ by U if the occurrence of Xi at the level p \n; n+p e] -set i=i+l and if isp go to b] ; otherwise go to f] ; f] -the last equation ie thereby transformed \ninto : X P Z F; where F~c LI ; by substituting X P in the first (p-1) equations, and then X p-1 in the \nfirst (P-21 equations, and so on ---, the entire system Is translated into LI . We have thus established \nthe equivalence between the regular systems and the language LI . l-his method, semantically equivalent \nto the uee of auxiliary variables shows that their utility can be reduced to a simple location of the \nlevel of imbrication of the iterations. 5 -STRUCTURE OF THE FORMULAS AND OF THE TESTS .\u00ad 5-1 -RULES \nOF FORPIATION OF THE FORMULAS : We have coneldered until now the formulas as atoms. The propertied established \nare then inde\u00adpendent of the structures of the formulas. Since we may define many variants of EXEL (FORTRAN \nvariant or APL variant, for instance) we do not try to define a precise structure of the formulas but \nrather the rules by which they are governed. We again consider the following sets : F. : set of constants \nO-ary={fO , f ,---} ; 11 - --- . - -- --- _--- - -__-- -------\u00ad !! Fm : m-ary={~ , ~ ,-- } . In practice \nwe may limit ourselves to mS2. Fq is the set of the monadic operators, F ~ the set o - \u00ad of the dyadic \noperators. V. : eet of variables O-ary={xO , y: ,-- ,xl , }; v: 11 p ary={xp, --,x~,-- } . P We suppose \n: vAn(u vi) =d i The n-ary varlablee are functions of n arguments, the domain of which is, by definition, \nfinite. Thus they can be represented by tables and, for that reason, unlike procedures, they may be modified \nby an affectation. If the domain of a n-ary variable is the cartesian product of n segments of the natural \nintegers, then we say that it is an array, the rank of which is n ; otherwiee It is, generally speaking, \na tree. The terms are generated by the two following rules : al -the constants and the variables O-ary \nare terms. 115 b) -IF tl,---,t are terms and if f~cFn and x~cVn, then f~(tl,---,tn) and x~[tq;---;tn] \nn are terms. The elementary formulas or assignments are generated by the two following rules : a) -if \nx~cV and if t is a term, their x~ is an assignment ; o b) -if tl,---,tn+l are terms and x~eVn then x~[tl;---;tn]~tn+l \n is an assignment. Finally, the formulas are obtained from elementary formulas, by adding in an inductive \nway, the assignments to the terms. The formulas are then equivalent to a serie of assignments. Therefore \n: z+f2(x+t, y[I]+t ) and X+yi-z are, by definition, respectively equivalent to : 12 x+t ;y[Il+t ;z+f; \n(x, y[Il) and y+z ; X+y 12 Hence we need only to consider the elementary formulas. REMARK : We must be \ncareful to distinguish the symbols ; , [ and ] which are used in the composition of the formulas from \nthe same symbols which appear in LS. To prevent any confusion, it would be prefe\u00adrable to choose other \nnotations. But this has no importance for what follows. 5-2 -SEMANTICS OF THE TERMS : The constants and \nthe variables of EXFL are translated into LC by constants and variables designated by the same symbols \n: ffc~ Fi ,T(f)=f; fX<: v ,T(x)=x11 The semantics of the terms is then defined by the rules : T(f;(tl,---,tn) \n)=f:(T(tl )(T(tn)(tn) ), T(x:[t, ;---;tnl)=x:)T(tl )(T(tn)(tn) ) The interpretation of each constant \nf; IS then described by a set of rules of reduction [these rules correspond to &#38;-conversion in the \nfull x-calculus). These rules are of the form : fxl---xn+a with feFn, I.Ii, I<iSn, xieFo, acFo We say \ntha c these functions are scalar operators. If <xl, -xn> does not belong to the domain of f we admit \nthat : fx,-- xn%l . We may also use a set U of mixed operator such that : g6U:gx1-- xn+a, in which at \nleast one x or a is an array [or a tree), We may choose for EXEL mixed i operators the semantica of which \ncan be described by means of scalar operators and specific iterations adapted to the data structures \n[array and tree). This has already been worked out with regard to the APL operators that are incorporated \ninto EXEL [RUG 11 . Besides, these iterations have remarkable properties [RUG 21 . These properties may \nbe used to interpret a term, in a global way, This global interpretation leads to a significant simplification \nof the circulation and economizes considerable number of memories. We euppose, from now on, that all \nthe operators are scalar. In the translation of the terms, the set of the variables u Vi is maintened. \nIn fact we show i later on, how the Variables disappear. 5-3 -TRANSLATION OF THE FORMULAS : a) -Every \nformula is, first, put into the form : x+t . In the formula : xo[tl;- -;tn]+tn+l, k is, by definition, \na function whose domain is finite, Let us suppose, to simplify the explanation, o that it is a function \nof one variable ; the domain is then isomorphic to an entire segment of integer [0, n]. If such is the \ncase, the word : x[I]@ is, by definition, equivalent to : x+:+t(~(xrj)@=o))---(>(~fi)t(I=n) ). b] -In \nLC is no equivalent to the operation of assigment. Thus we cannot define directly the semantics of the \nformula : to give the algorithm of translation of an assignment, it is neceesary to know the context \nin which it appears. This context is the procedure itself. Consequently we must, first of all, specify \nthis context, that is, make precise what we mean by a procedure. Thie is is develoDed \\ 6. 5-4 -TRANSLATION \nOF TIHE TESTS : The predicates of EXEL are translated into LC by some constants designated by the same \nsymbols : Vtc T, -r(t)=t. he predicates are used to form the tests : t Xq---xn , As for the operators, \nwe may distinguish the O-aray , ---, n-ary predicate. Their interpretation is thus described by a set \nof rules of reduction : txl---xn+a in which t is a n-ary predicates, vi, l<i<n, xicF o and a c{O,I} .Let \nit be remembered that we supposed that the tests are total functions. As in the formulas the variables \nhave not disappeared in the translation of the tests. 6 -TRANSLATION OF THE PROCEDURES .\u00ad 6-1 -ASSIGNMENTS \nAND TESTS : A procedura ~ is a 4-uple : II =<p, Vr, ~, AT> . Where : 11 -p is tha body of the procedure \nII : p=<E,Xn> 2) -VT ia the set of the variables which have occurrences in p(VnC~Vi) 31 -Pm is the set \nof the variables of procedures which have occurrences in p. 4) -An is the sat of arguments of II , defined \nby tha header of II : p[afl,---,ahl, with Am={ai,---,ak} Two new sets ara thus introduced, for every \nprocedure ; Pm and Am . The elements of Pm ara used in the procedure calls [described in a later paragraph). \nOf course, every one of the procedura variables is distinct from the other variables : PTn(lJ Vil=o and \n?TnVA=@ . But, the argumants are either 1 simple variables, or procedure variables : AncVruPn . Let IIL \nbe the translation of II into LC : H%H)%L.O(T(H)). The algorithm T does not take the assignments, the \nvariables and the tests into account. Lat us describe the algorithm @ Let Z be an auxiliary variable \n: Z4(VUVAUP). Let ~= VnUAmand We define a one-to-one n 1%1 . application Y~between ~andthe segment ofthaint@gers \n[O,(n-1)] .Weconsider the function @z(n,x,a), where ncN (natural integers) XC%, a is a word in combinatory \nlogic. Tha function @z is definad by : @z(n,x,a) = ifYn(x)=n, then o,, else Zfi . Let x+t ba an assignment. \nLet ~ be the word obtained by substituting tha word (Z~n(x)) for every xc in t. Under such conditions, \nthe transform of this assignment by $ is : % @(x+t)=AZ. (~(@T(0,x,7 ) )---(On(i ,x,E))---(OT( (l), x,;,; \n)). If t is a test, its transform by .$ is : @(t)=AZ.~ . 6-2 -PROCEOURE CALLS : In a procedura PO, a \ncall of the procedure PI may exist, in the formula s placa : (R)P1 (A) where R ie the result part, A \nthe argument part.. The effective arguments, corresponding place to place, to the formal arguments O,fl,---cik. \nWe first consider the transfer of tha arguments : p=Pl(al,---,ak). We have : kl=lAp, I ,nl=l~pl I JnO=12P0 \nLet m be the symbol designating a new constant, interpreted as the undefined and let @p, be the function \n: Opl(n,ul, --,u ~= if nc{Y ~l(cti)/lSiSk] then Um such that n=Ypl (am) ; else co . Thus the call of \nthe procedure PI is translated by : o(P)=plL(2(@p1 (o,~,--->~ ))---(@pl (i,~,~)),@pl(--@pl( (n-1 ),~,---,<))) \nSince the reeult of every formula of PIL is an nq-uple, the result of $(p) is also an n -uple. 1 This \ndefinition of the procedure call does no require the effective arguments, if they are terms, to be reducible \nbefore the call. As for the tranefer of the results, we may suppose that in the result part :(R1,---,R1 \n>R~)PR~)P every Ri ( l<i<~l is of the form : xO+X1, where XO ~ VPO and xl E VP, .As in the formulas, \na result transmitted in the form : xOII]+X1 ie, by definition, equivalent to : X@;+l(~(XO~)(Xl)(I=O))---(~(X@) \n(xl)(I=n) But, we must consider the case in which a came variable of PO is present in different reeults \nRi. Thus we use the algorithm Un (cf. J 11. The set of reeults defines an application rl : Ri=XOj+Xlj=rI(Xlk). \nThe value o (xOj) transmitted to the ~ariable Xoj is then : O(xoj)=u,n-l ~xo)l({o(P)~pl( xlk)/?l(xlk)=xo \nj}). J Let R be the set of theee values : R={cf(xOj)/xOjcfJ} where U is the set of variables of PO appearing \nin the reeulte R.. Let ~ be the function defined as follows : E(n,R,U)= ifnc{YPo(x)/x6U} 1 then U(xj) \nsuch that n=Ypo(xj), else Z i . The procedure call, (R)P1(A), by PO ie then translated by : O((R)pl(A))=aZ.(~ \n(S(o,R,U))---(~(i,Z,U)(E((no(lno-l ),R,U))). o Thus, the interpretation of a call of the procedure HI \nby a procedure 110 ie defined by substi\u00ad tutions in the words of combinatory logic : I IOL and IIIL, \nbut not in the very texts (written in EXEL) of the procedures. After the transformation $oT , each procedure \n~ is translated into a word ~ of combinatory L logic where every variable has disappeared, except the \nprocedure variables which do not belong to Am; these procedure variables are free in HL. 6-3 -THE EXPRESSIONS \nOF PROCEDURES AND THE EXTENSIONS OF TYPES : Until now we have supposed that the procedure call complied \nwith the rule of concordance of types. But we have defined [RUG 3] a mechanism which gives us the possibility \nof extending this rule. This has been formalized in the l-calculus and may be applied to most of the \nprogramming languagee. We use it in EXEL without restriction. The interest of such a mechanism is that \nit supplies the language with very simple rules of semantic extensions, at the level of the procedures \nthem selves. This simplifies the programming and avoids the use of a great number of intermediate procedures. \n7 -TRANSLATION OF PROGRAMS .- A program is a couple C=<P,(R)PI (D)> , where P is a set of procedures \nP={Pi/l<<n}, and P cP.D is a 1 set of data : these data are either structures of elements of F , or procedures \nwhich are supposed to belong to P. The execution of C is defined by the call : (R)pI!D). The desired \nresults are indicated in (R). We suppose that all the data may be applied to PI, that is not restrictive. \n118 Let ~ be an auxiliary variable. In P. and D, we replace every free variable of procedures : Pi P, \nby ; (pi)=Ti. The reeult of such aJ~ubstitution is designated by= and ~ .We, then transform the eet P \nof procedures into an n-uple : T(P)=lT. (~(@((R)~(~))P2L---~~, (in @((R)~(~)), we take no=l{~(xj)/xj \nR}I). As for the action equations, the translation of the programme C is is then : T(C)=Y(T(P))O. The \nword -c[C) obtained is then a word of c-mbinatory logic which contaira only constants and, consequently. \nwhich may be reduced. This definee the semantics of C. The reduction of T[C] leads : al -either to R, \nthe set of expected results. b) -or to an error [0]. In the case b) we may point out inwhichprocedure \nthe error appeared. Besides, the obtained values give the state of the memory of the computer at the \nmoment at which the error appeared. REFERENCES [ARS) -J.ARSAC -De la programmation -Publication N 13 \n-Institut de Programmation -Universit6 PARIS VI. Octobre 1972. (ASH) -E.ASHCROFT-Z.MANNA -The translation \nof GOTO programs into while programe -Rapport CS 188 - Stanford University -1971. (BLA) -G.BLAIN -Architecture \nof the EDELWEISS system -International Workshop on Computers Architec\u00adture -GRENOBLE -June 1973. ( BHO) \n-C.BOHM -The CUCH as a formal and description language -Formal Language Description Languages for Computer \nProgramming -ANSTEROAN -1966. [CHO1 -N.CHOMSKY-M.P.SCHUTZENBERGER -The algebraic theory of context-free \nlanguages -Computer Programming and Formal System -P.Braffort and O.Hirsberg -North Holland - 7963 (OIJI \n- E.W.OIJKSTRA -Notes on structured programming -University of Maryland. (NIV) -M.NIVAT -Langages alg6briques \nsur un magma libre et s6mantique des sch6mas de programme - Th60rie des Automates, des Langages et de \nla Programmation -PARIS -July 1972. (NOL) -L.NOLIN -Une th60rie des algorithms -Presentation intuitive \n-M6moire N 0173 du Groupe d Informatique Th60rique de l Universit6 de PARIS -1973. (ROBI - B.ROBINET \n-S6mantique des tableaux -Application au langage APL -ThGse -PARIS 1972. (RUG 11 -G.RUGGIU -Description \ns~mantique des fonctions primitives d APL.-Revue Technique THOMSON-CSF -March 1972. (RUG 2) - G.RUGGIU \n-S6mantique des langages de programmation et interpretation globale des expressions - C.R. Acad6mie des \nSciencee de PARIS -S6rie A -t.273, pp 1271-1274 et t.Z73, pp 100-103. [SCO 11 -O.SCOTT -The lattice of \nflow-diagram -Symposium on Semantics of Algorithmic Languages Springer Verlag 1971. (SCO 21 -O.SCOTT \n-Oata types as lattices -Amsterdam -June 1972 (VASI -J.P.VASSEUR -Nouvelles perspectives clans 1 1 interaction \nlogique-Tec hnologie Le Pro jet EOELWEISS -Collogue International sur les M6moires -PARIS -October 1973 \n(RUG 3] -G.RUGGIU -Les types et lee appels de procedures -Th60rie des Automates, dea Langages et de la \nProgrammation -PARIS -July 72 \u00ad 119 \n\t\t\t", "proc_id": "512927", "abstract": "", "authors": [{"name": "L. Nolin", "author_profile_id": "81100454052", "affiliation": "Universit&#233; PARIS VII, PARIS", "person_id": "P348462", "email_address": "", "orcid_id": ""}, {"name": "G. Ruggiu", "author_profile_id": "81100112366", "affiliation": "THOMSON-CSF, 91401 - ORSAY - FRANCE", "person_id": "P320509", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/512927.512937", "year": "1973", "article_id": "512937", "conference": "POPL", "title": "Formalization of EXEL", "url": "http://dl.acm.org/citation.cfm?id=512937"}