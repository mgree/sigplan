{"article_publication_date": "01-13-1988", "fulltext": "\n\t\t\t", "proc_id": "73560", "abstract": "<p>A <italic>collecting interpretation of expressions</italic> is an interpretation of a program that allows one to answer questions of the sort: &#8220;What are all possible values to which an expression might evaluate during program execution?&#8221; Answering such questions in a denotational framework is akin to traditional <italic>data flow analysis</italic>, and when used in the context of <italic>abstract interpretation</italic> allows one to infer properties that approximate the run-time behavior of expression evaluation. In this paper collecting interpretations of expressions are developed for three abstract functional languages: (1) a first-order language with call-by-value semantics, (2) a first-order language with call-by-name semantics, and (3) a higher-order language with call-by-name semantics (i.e., the full untyped lambda calculus with constants). It is argued that the method is simple (in particular, no <italic>powerdomains</italic> are needed), natural (it captures the intuitive operational behavior of a <italic>cache</italic>), yet more expressive than existing methods (it is the first exact collecting interpretation for either lazy or higher-order programs).</p>", "authors": [{"name": "P. Hudak", "author_profile_id": "81100539650", "affiliation": "Yale University, Department of Computer Science", "person_id": "PP40036033", "email_address": "", "orcid_id": ""}, {"name": "J. Young", "author_profile_id": "81100513431", "affiliation": "Yale University, Department of Computer Science", "person_id": "PP39081611", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/73560.73570", "year": "1988", "article_id": "73570", "conference": "POPL", "title": "A collecting interpretation of expressions", "url": "http://dl.acm.org/citation.cfm?id=73570"}