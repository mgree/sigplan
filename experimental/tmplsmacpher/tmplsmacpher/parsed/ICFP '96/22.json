{"article_publication_date": "06-15-1996", "fulltext": "\n Enriching the Lambda Calculus with Contexts: Toward a Theory of Incremental Program Construction* Shinn-Der \nLee and Daniel P. Friedman Computer Science Department Indiana University Bloomington, IN 47405 {sdlee \n,dfried}@cs. indiana. edu Abstract A context in the A-calculus is a term with some holes. Hole filling \ndiffers from &#38;substitution in that name capture is intended. This seemingly simple feature transcends \nstatic scope and lies at the heart of modular and object-oriented programming. Still, the name capture \nfeature of hole fill\u00ading is at odds with hygienic ~-substitution. In this paper we conservatively extend \nthe A-calculus to incorporate the notion of contexts without jeopardizing the fl-rule. We per\u00adceive contexts \nas source code and A-terms w target code. Context filling is encoded as compilation operations and the \nenriched calculus is a theory of separate compilation and incremental program construction. Linking of \nseparately\u00addeveloped programs is done by coherent renaming of free variables. We apply our context-enriching \nschema to the A-calculus extended with definitions and devise a calculus of first-class modules. We show \nthat module linking can be modeled solely by the renaming of import and export variables. We add relinkable \nvariable references to model virtual method references essential to object systems. The inclusion of \ncontexts introduces parameters whose linking is based on names (symbols, identifiers, or keywords). We \nsimulate in the context-enriched calculus other exten\u00adsions of the A-calculus with name-based programming \nno\u00ad tions such as Dami s ~-calculus with names, Ait-Kaci and Garrigue s label-selective A-calculus, Lamping \ns transparent data parameters, and our quasi-static procedures. 1 Introduction In the A-calculus [2], \na term e is a variable x, an abstraction Axe, or an application e e; a context C is an identifier x, \nan abstraction Ax. C, an application C C, or a hole h. That is, terms and contexts are built with the \nsame syntactic struc\u00adtures but based on distinct categories of names: variables z versus identifiers \nx and holes h. (We thus typeset contexts C in boldface to distinguish them from terms e.) Although terms \nand contexts are syntactically similar, they behave *This research was partially supported by the National \nScience Foundation under grants CCR 93-02114 and CDA 93-12614. Permission to make digitahlwrd mpy of \npart or all of this work for personal or classroom use is ranted without fee provided that copies are \nnot made or distributed for pro i t or commercial advantage, the copyright notica, the titie of the publication \nand its date appear, and notice is given that capying is by parmiaaion of ACM, Inc. To copy otherwiaa, \nto republish, to post on servers, or to rsdistributs to lists, requires prior specific psrrnissivn and/or \na fee. ICFP 96 5/96 PA, USA Q 1996 ACM 0-69791-771 -51 WOO05...$505O quite differently, as shown by their \ndistinct notions of sub\u00adstitution; see Figure 1. The ~-substitution [e/~]e of e for x in e is hygienic. \nThere is no capture of the free variables of e; see the abstraction clause of jl-substitution (throughout \nthis paper we use the symbol t to mark equations and re\u00adduction rules in which variable hygiene is assumed). \nThus, [y/z]&#38;v.z is AY .w, where the bound y is deliberately re\u00adnamed to a fresh y . Hole filling \n[C/h] C , in cent rast, has the effect of literally replacing occurrences of h in C with C. Capture of \nfree identifiers is actually solicited; see the abstraction clause of hole filling. Hence, [y/h] A y. \nh is A y. y, not Ay , y for some fresh y . We can perceive contexts as a keyword parameter-passing mechanism \nwhen identifiers are seen as keywords. A con\u00adtext Cz is a parameterized object whose keyword param\u00adeters \nare the free identifiers of Cz. Filling the hole h of let {x= Cl} in h with C2, resulting in let {X = \nCl} in C2, associates the keyword parameter x of Cz with the denota\u00adtion Cl. The context let {x = Cl} \nin h is reminiscent of a module with a single export designated by x. In gen\u00aderal, a context is a program \nmodule that exports through its holes and imports via its free identifiers. Hole filling in\u00adtegrates \nmodules, and identifier capture links import and export identifiers. The use of names as a common domain \nto communicate among program modules facilitates exten\u00adsible and reusable separately-developed program \nmodules. Names are essential to programming large flexible software systems that require maintenance \nover an extensive period of time. This view is shared by others [1, 7, 11, 12]. We further see contexts \nas separately-developed program modules that are incompletely compiled (due to holes) and partially linked \n(due to free identifiers). Hole filling is the means to incrementally integrate and link such program \nmodules together. In particular, we can construct compiled application code (Cl Cz) out of compiled code \nCl and C2 by filling the holes of the application context (hl hz) with Cl and Cz. Likewise, by filling \nthe hole of the abstraction cent ext Ax.h with C, we can construct compiled abstraction code Ax. C in \nwhich free occurrences of x in C are linked to the abstracter Ax via identifier capture. In general, \nstart\u00ading with holes h and identifiers x, any composite context can be incrementally compiled and linked \nusing these code construction operations. Contexts have not been explicitly realized as a program\u00adming \ntool, however. This is not surprising since there are difficulties in combining the A-calculus with contexts. \nIn particular, hole filling is at odds with @substitution. We demonstrate the anomalies in Section 2 \nand then show how Terms: e ::= zlkc.e lee Contexts: C ::= hlxl~x.c[cc ,B-Substitution [e/x] e : Hole \nfilling [C/h] C : C ifh~h [e/t]x s / ~, ~t~e~w~~e [C/hlh = ( h otherwise [C/h]x = ~ [e/z](el ez) ~ ([e/z]e~ \n[e/x]e2) [C/h]Ax.C -Ax.[C/h]C (t) [e/z]= ic .[e/z]e A2+.e Figure 1. A-terms to enrich the A-calculus \nwith the notion of contexts consis\u00adtently. We show that linking of separately-developed pro\u00adgrams is \nexpressible as careful a-conversion of free vari\u00adables. In Section 3 we give an alternate explanation \nof our context-enriched calculus AC in which a-conversions are implemented as environment lookups. In \nSection 4 we ver\u00adify that AC is indeed capable of simulating the behavior of cent exts. Our context-enriching \nschema is not restricted to the pure A-calculus. In Section 5 we apply it to the A-calculus extended \nwith definitions that Plotkin uses to demonstrate his structural operational semantics [18]. The context-enriched \ncalculus has modules expressed as first\u00ad class definitions. We then add relinkable variable refer\u00adences \nto express late binding, an essential feature of object systems. In Section 6 we discuss related name-based \npro\u00adgramming mechanisms, namely, records [4], A-calculus with names [7], label-selective A-calculus [1], \ntransparent data pa\u00adramet ers [11], and quasi-static procedures [12]. We summa\u00ad rize our work in Section \n7. 2 The Context-Enriched Lambda Calculus We cannot simply transplant ~-substitution to contexts or hole \nfilling to terms. Operating on a common domain, the integrated system is inconsistent. For example, when \ncon\u00adsidered as terms, Ax.h and Ay.h are a-equivalent. Filling their holes h with the same x would yield \nincomparable re\u00adsult s: [x/h]Ax.h [x/h]Ay.h = Ax.x = Ay.x $ Hence, hole filling defeats a-conversion. \nHole filling does not work with ~-reduction either. For instance, (Ax.h) y and h are ,&#38;convertible. \nFilling their holes h with x would yield different results: [x/h] ((Ax.h) y) [x/h]h = (Ax.x) y #=x We \novercome the inconsistency by distinguishing between the domains of /3-substitution and hole filling. \nWe see terms as target code and contexts as incomplete source code\u00ad incomplete in the sense that their \nparse trees may have non-t erminal leaves designated by holes. The new calcu\u00ad lus is thus a mixture of \ntarget code and source code, and hole filling is a mechanism for constructing source code. A context \nwithout holes is (jully-) evolved source code that can be compiled and linked with other compiled code. \nA con\u00ad text with holes is source code not yet ready for compilation. Put differently, a context is a \ncompilation operation wait\u00ad ing to happen once its holes are filled with evolved contexts. Computation \nis still modeled primarily with ,&#38;reduction. [C/h] (C, Cz) s ([C/h]C, [C/h]Cz) and contexts. In addition. \nthere are mechanisms to construct and comnile . source code and to link and execute compiled code. Hence, \nsuch a system can incrementally integrate, link, and execute separately-compiled code. We therefore add \nfour mechanisms to the A-calculus: (i) abstractions @p.e to simulate compiled evolved con\u00adtexts, (ii) \na unary compiled code operation exec to execute com\u00adpiled code Qp.e to e,  (iii) unary compiled code \noperations lamx to build com\u00adpiled A-abstraction code @p.kr.e, and (iv) a binary compiled code operation \napp to build com\u00adpiled application code Op.(el ez). The result is the context-enriched calculus AC shown \nin Fig\u00adure 2. The fact that AC is sufficient to simulate the behavior of contexts is verified in Section \n4. 2.1 Free Identifier Abstract ions An evolved context e is a context without holes: e ::= xl~x.e lee \nIt is source code ready for compilation. Compilation is not as trivial as simply translating e into its \nimage e in the A-calculus, e.g., compiling Ax.(x y) into Jx.(x y). (We as\u00adsume that each identifier x \nhas a corresponding variable ~ of the same name.) Consider the two a-equivalent terms Xc.Ay.y and Ay.kc.y. \nCompiling the identifier y into the variable y naively would yield incomparable results kc.~y.y and ~y.~x.y. \nWe therefore require free identifier abstractions @{xl: zl,. ... xn:xne.e to play the role of compiled \nbut not yet fully-linked cod:. The notation {xl: xl,. . . . x~: x~ }, where no two identifiers xi and \nxj are identical nor are any two variables x, and Xj, specifies the unlinked parameters of the compiled \ncode e. Each unlinked parameter xi: xi has an identifier x, and a variable xi. The identifier comes from \nthe source code (evolved context) of e. It is a literal and therefore may not be renamed. The variable, \nlike a A-parameter, denotes a place holder in the compiled code and is thus subject to a\u00adconversion. \nThe idea then is to compile an evolved context e into a free identifier abstraction @{XI: XI, ..., x~: \nx~ }.e where xl ,.. . , Xn are the free identifiers of e and xl, . . . , Xn are their respective images \nin the compiled code e. (The compiler is defined later in Theorem 5.) As an example, the Syntax: ::= \nzlAc.eleel@p.e16 i ::= exec I k I lamx I app P ::= {x,: Z,,..., xn:xn} n~O, x~$xjwheni#j, x~$ xjwheni#j \nBasic reduction rules: (t) &#38;Substitution [e/x] exec@{xl:zl, app e : (Jz.el) ez . . ..xn. Zne.e Iamx \n@p.e @pl .el @p2.e2 [e2/x]el [i&#38;/xn] . . . [kl/zl]e @p.Az.e where x: OPI Mp2.(el e2) z c p or else \nz is fresh (b) (exec) (lam) (app) (t) (t) [e/x] Az .e [e/z](el e2) [e/z] @p.e s = a k .[e/z]e ([e/4a \n*p.[e/z]e [e/z]e2) J Figure 2. Context-enriched A-calculus AC. compiled version of Ax. (x y) is @{y: \ny}. kc. (z g), which is a-equivalent to @{y: Z}. Jy.(y z). The variables of p in a free identifier abstraction \n@p.e need not coincide with the free variables of e. p can specify more unlinked parameters than are \nactually referred to in e; the unreferenced ones are simply ignored. There can also be free variables \nin e that are not specified in p; they sim\u00adply obey static scope, a design decision we have consciously \nmade. It allows us to embed target code in source code, so to speak. For instance, we may express the \ncompiled code of Ax. ((z y) (x y)) as @{y:y }.Az . ((x y) (z y )), which is impossible without this feature. \nMoreover, with nested free identifier abstractions, we have compiled code that, when executed, computes \nyet more compiled code. 2.2 Basic Reduction Rules The context-enriched calculus AC has four basic reduction \nrules; see Figure 2. A &#38;redex is still of the form (Az.el ) ez. The needed @-substitution is defined \nin Figure 2 where, again, we have used t to mark the clauses in which vari\u00adable hygiene is assumed. In \nparticular, x is not the same as x in the A-abstraction clause, and xl is not free in e; likewise, in \nthe free identifier abstraction clause, s is not a variable of p and none of the variables of p are free \nin e. 2.2.1 Executing Compiled Code We remarked earlier that a naive translation of evolved con\u00adtexts \ne to their images e in ~-calculus is incorrect. The primitive exec is a more sophisticated translator. \nIt exe\u00adcutes compiled code modeled by free identifier abstractions. Ideally, when @p.e is ready for execution, \nthe variables spec\u00adified in p should no longer occur fkee in e, they should have been linked in the process. \nIf that is the case, executing ibp.e can be accomplished by simply stripping off the abstracter @p to \nyield the term e. This is a difficult condition to ver\u00adify, however. We thus extend the calculus with \nconstants k, one for each identifier x, that serve as unlinked free iden\u00adtifier indicators. They are \na unique category of primitives whose interpretation is orthogonal to the rest of the calculus. The reduction \nrule for exec @{xl: Z1,..., x~: %}.e then re\u00admoves the abstracter *{x1 : Z1, . . . . x~: zn} after substitut\u00ading \neach variable w in e with the corresponding unlinked identifier indicator %; of xi. For instance, exec \n@{x:z, y:y}.Az.y ~ [5i/z][~/y]k.y E A.z.p The primitive j in the contractum k.~ indicates that the identifier \ny (and therefore the variable y) had not been linked when the free identifier abstraction was executed. \n 2.2.2 Constructing Compiled Abstraction Code A primitive lamx constructs compiled code @p.kc.e out of \n@p.e. It models the filling of Ax.h with the evolved context e represented by @p.e. That is, lamx @p.e \ndenotes [e/h]Ax.h where I?p.e is the compiled version of e. The choice of x in @p.Ax.e depends on whether \nx is specified as an unlinked identifier of p. If so, x:x ~ p and x is the corresponding variable of \nx; otherwise, x is any variable not free in e or p. Hence, we have constructed the compiled version of \nAxe out of the compiled version of e and linked free occurrences of x in ewith Ax. To illustrate, lamy \n@{y:y}.y + @{y: y}.~y.y where @{y: y} .y is the compiled version of y and the con\u00adtractum is the compiled \nversion of Ay.y, a result of filling Ay.h with y. In contrast, when x ~ y, lamx @{y :y}.y + @{y: g}.~x.y \n a result of filling Ax.h with y. The @-abstraction primitives lamx rely on the fact that the variables \nxl, . . . , x~ of @{xl :xl, ..., x~ :xn } .e are qwMz\u00adstatically scoped [12]. The binding between the \nfree occur\u00adrences of xi in e and the unlinked parameter xi: x; is not static; the free occurrences of \nx, can be linked, via cap\u00adturing a-conversion, to a newly constructed encapsulating &#38;abstractor. \n 2.2.3 Constructing Compiled Application Code The primitive app constructs compiled code @pl &#38;Jpz.(el \nez) out of @pl .el and @pz .ez. It models the filling of the appli\u00adcation context (hl hz) with the evolved \ncontexts el and ez represented by @pl .el and Qpz.ez. That is, app @pl .el @p2.e2 denotes [el/hl, ez/hz](hl \nhz) where @pl .el and Qpz .ez are the compiled code of el and ez, respectively. It yields the compiled \nversion of (el ez), expressed as Qpl MPZ .(el ez) with pl LtJP2 beiw a variant of the union of pl and \np2. The variant relies on variable re\u00adnaming to meet these constraints: (i) To maintain the well\u00adformedness \nof the union pl ItIp2, an identifier x can occur in both pl and pz as long as its corresponding variables \nare identical, that is, x: m E pi and x:X2 C P2 if and only if xl = Z2. Similarly, xl: z e PI and X2: \nz ~ P2 if and only if xl = X2. (ii) The variables of pl do not capture the free variables of ez except \nfor those specified in P2; likewise, the variables of pz do not capture the free variables of el except \nfor those specified in pl. The requirements can always be met since the variables of pl and pz are a-convertible. \nFor example, app @{x:z, Y:v}. (z y) @{x:z , Y :Y}. (z y) = app @{x:z, y:y}. (z y) @{x:.z, y :y }. (z \ny ) -+ @{x:z, y:y, y :y }.((z y) (z y )) To combine the two sets {x: z, y: y} and {X: z , Y : Y}, we \nidentify the variables of x and distinguish the variables of y and y . Hence, both x and z are renamed \nto z and the variable y of y is renamed to y . 2.3 AC: Calculus of Compiled Code The notion of reduction \nc underlying the extended calculus AC is the union of the four basic reduction relations /3, exec, lam, \nand app shown in in Figure 2. The one-step reduction relation ~ is the compatible closure of c. That \nis, a term el one-step reduces to ez if the term m is the result of replacing a c-redex subterm e! of \nel with its c-contractum e:. The reflexive and transitive closure of ~ is the reduction relation -w. \nThe least equivalence relation generated by ~ is the equational theory AC. Equivalence under AC is written \nas el = ez. The calculus AC is consistent: Theorem 1 The reduction relation + is C/wrch-Rosser. Intuitively, \nwe have introduced @-abstractions as a distinct data type operated upon by the primitives exec, app, \nand Iamx. The proof then follows immediately from Mitschke s Church-Rosser theorem for delta reductions \n(cf. Theorem 15.3.3 of Barendregt [2]). As usual, two terms are operationally equivalent, de\u00adnoted as \nel H ez, when they behave the same in all program contexts [15, 17]. For @-abstractions, we have the \nfollowing: Theorem 2 Let el + ez and jor each free variable x of ez, x:x e pl if and only if x:x c p2. \nThen, @pl.el % Qpz.ez. In other words, for any KJpl .el, we can remove from PI any unlinked parameters \nthat are not mentioned in el without changing the @-abstraction s behavior. Moreover, as el re\u00adduces \nto ez, we can further remove from pz parameters that are eliminated in the reduction process. To summarize, \ncomputation in AC involves three opera\u00adtions: the usual function application modeled by the @rule, incremental \ncompilation and linking modeled by the app\u00adand lam-rules, and the transformation of compiled code into \ntarget code modeled by the exec-rule. What sets AC apart from languages like C is that compilation, linking, \nand exe\u00adcution are readily available in a single language, instead of as separate programming environment \ntools.  2.4 Simulating Program Symbols We do not include identifiers x as proper terms of AC, since \nwe can simulate their behavior when used as program sym\u00adbols. (Symbols are names used in source code; \nvariables are names used in target code; identifiers are names used in compiled code to relate variables \nto symbols.) A program symbol x can be encoded as the pair: (lamx, @{x: m}.z) The predicate eq? that \ndetermines the equality of two such program symbols x and y is AC-definable as follows (pattern mat thing \nis used to simplify the presentation): eq? (cl, e2) (ei, ei) = exec (el (e; e2)) F T where T = Xz. Ay.x \nand F = Az.Ay.y are the boolean values of true and false, respectively. For instance, when x and y are \ndistinct program symbols, we have eq? (lamx, @{x: z}.z) (lamy, @{Y: Y}Y) exec (lamx (lamy Q{x:z}.z)) \nF T exec (Iamx i${x:z}.~y.x) F T where x ~ y exec @{x: z}.kz.~y.z F T (kdy.x) F T F Intuitively, we use \na program symbol x as the syntac\u00adtic representation of the binding variable of a A-abstraction or the \nsyntactic representation of a variable reference. The functionalities are covered by lamx and @{x: z} \n.z, explain\u00ading why we choose to represent a program symbol x as such. 3 Alternate View of JC We give \nan alternate view of the AC-calculus. Our start\u00ad ing point is the direct style denotational semantics \nof the A-calculus [19] shown in Figure 3. An environment r maps the syntactic representation [x] of variables \nx to their deno\u00ad tation. The notation r[[x] # e] denotes an extension of the environment r such that \nr[[x] + e] [y] is e if [z] and [y] are the same, but is otherwise r [y]. The meaning &#38; [e] of (the \nsyntax [e] of) a A-term e is usually defined in an abstract mathematical model of the A-calculus known \nas domains [19]. Here, in contrast to com\u00ad mon practice, we elect to remain metacircular; that is, &#38; \n[e] is merely another J-term. We can then prove the following in the A-calculus with a structural induction \non e: Theorem 3 Let m,. . . . x~ be the free variables of e. Then, &#38; [e] -Xr.[(r [xm])/xn] . . . \n[(r [zl])/xl]e Figure 3. Denotational That is, the meaning of the representation [e~ of e is the same \nterm e parameterized over an environment r and that every occurrence of each free variable Zi in e is \nreplaced by the environment lookup r [zi]. A term JT.[(T [z~])/z~] c.. [(r [zl])/xl]e is reminiscent \nof a free identifier abstraction @{xl : xl, . . . , x~: z~} .e when we view [~i] as a realization of \nxi. Once we recognize the relation, the deliberately filtered out meaning functions d and (L x), one \nfor each x, of Figure 3 are the @-abstraction primitives app and lamx, one for each x, of AC. The advantages \nof viewing AC aa environment manipu\u00adlations are: (i) There is no need for the special free identifier \nabstraction mechanisms, since reasoning can be done purely in the A-calculus. (ii) It is straightforward \nto encode a pro\u00adtotype implementation of AC with a suitable representation of environments. A case in \npoint is Wand s record calculus [21] in which environments can be implemented as extensible records and \nidentifiers as record labels. The advantages of thinking in terms of free identifier ab\u00adstractions are: \n(i) There are no administrative ,tLreductions involved in the construction and application of environments \nto contend with. Instead, we deal with quasi-static variable renaming, which is much simpler. More importantly, \nthe latter is conceptually closer to what happens in a linker. (ii) By recognizing free identifier abstractions \nas a distinct data type and studying their behavior as such, it is eas\u00adier to incorporate more @-abstraction \nprimitives in the fu\u00adture in a manner that would have been less than intuitive with the environment-based \nsemantics. (iii) We can capture the essence of free variables without worrying about imple\u00admentation \ndetails. Reasoning with @-abstractions is more natural than reasoning with environments precisely because \nthey separate specification issues from implementation is\u00adsues concerning free variables, a fundamental \nrequirement of any useful abstraction mechanism. 4 Simulating Contexts We give two simulations of contexts. \nTo simplify the presen\u00adtation, we assume that there is a function v that assigns a distinct variable \nv(n) to each name n, which is either a hole h or an identifier x. The image of a context C is a A-term \nirn (C) defined inductively on the structure of C as follows: ire(h) -v(h) im(Ax.c) = Av(x). ire(c) ire(x) \n= v(x) im(cl C2) = 2772(C1)im(cz) That is, ire(C) is C with each name n replaced by v(n). The first \nsimulation does not model a context C as its image ire(C) unless C is evolved. The second simulation \nmodels C as ire(C) except for its holes. 4.1 Preliminaries We begin with notions and notations needed \nin the simula\u00adtions. The set of holes occurring in a context C, oh(C), is defined inductively on the \nstructure of C as follows: semantics of the A-calculus. :):] : #l} oh(Ax.c) = oh(c) Oh(cl C2) = Oh(cl) \nu oh(c2) The set of identifiers used in a context C, UZ(C), is defined inductively on the structure \nof C as follows: ui(h) = 0 ui(~x. c) = Ui(c) Ui (x) = {x} U;(CI C2) = Ui(cl) u Ui(cz) The set of identifiers \noccurring free in a context C, $(C), is defined inductively on the structure of C as follows: ji(h) = \n@ J$(AX.C) = J$(c) \\ {x} j(x) = {x} J$(c, C2) = J$(CJUfi(cz) We write p~ or {~.:~c} for {hl :hl,. . \n. ,h~:k}, where {h,,... , hn} = oh(c) and hi = v(h;) is the unique variable of hi. Also, we write p: \nor {52. :z. } for {xl :zl, . . . ,x~:z~} where {xl, ..., x.} = ji(C) and Zi = v(x; ) is the unique variable \nof xi. Correspondingly, p: is {x1: xl, . . ., X~: z~} for {xl,. . . ,Xn} = u2(C). We define for each \nname n an operator bindn as follows: bindn -ky.(app (lamn y) z) such that bindn @pl .el *P2 .ez = @plkJp2. \n[el/z]e2 where either n: x G pZ or else x is fresh. That is, each free occurrence of the variable x \ncorresponding to n in ez is replaced by the denotation el. Let nl,. ... n~ be pairwise distinct names. \nWe define {nl: el, . . . . n~: en} , abbreviated as {ii: F }*, as the following syntactic sugar: {n:~} \n~ (bindnn $ {}.e~) o . ..0 (bindnl @{}.el) ({}* is the identity function) such that {ii: E}* @p.e = \n@p.[en/zw] . . . [e~/m]e where either n~: x, ~ p or else Z; is fresh. It substitutes Z, in e with ei. \nThat is, {ii:@}* is the operator encoding of an environment associating n, with e~. The composition {ii: \nE}*o{ii :E }* = Am({ii:iz} ({ii :E } x)) is the concatenation of environments {ii: z }* and {ii : z \n}*. A degenerate case of {ii: E }* is when E are ptirwise dis\u00adtinct variables Z. In such a case, {ii: \n5} is a O-parameter specification p and we thus write p* for {ii: z}*. 4.2 First Simulation In the first \nsimulation, a context C is encoded as the free identifier abstraction lJp~ .7(C) where the transformation \nT(C) is defined inductively on the structure of C as follows: T(h) s v(h) 7-(x) = @{x:z}.z T(Ax.C) = \nlamx T(C) T(CI C2) s app 7(CX) 7(C2) For instance, the encoding of the context Ax.(h y) is the ab\u00adstraction \n@{h: v(h)} .(lamx (app v(h) @{y: y}.y)), which is cr-equivalent to @{h: z}.(lamx (app x @{y: y}.y)). \nHole filling is accomplished as follows: Theorem 4 Let [C /h]C be C . Then, bind~ @p;, .7( C ) @p&#38;.T(c) \n= %ltll .7-( C ) Proofi Let h: z ~ p! or else x is fresh. Then, bindh Opt, .T(C ) @p$.T(C) = @p2@ .[lqc \n)/z]7(c) = %@pj .T([C /h]C) (1) % @pj,, .7-( C ) (2) lx/zJ~z/IIJll: ix: yj ~x/llJ[x/m]ll: ix: y) = [x/2j[y/x]z \ns [x/h]h: {X:y} = [x/z]z : [y/x]x -x $Y . On the left, h is filled with x and then x is substituted for \nx. On the right, the two substitutions are switched, x is substituted for x first and then h is filled \nwith x (which is [x/z] z). They produce different results since the suspended substitution [y/x] associated \nwith the hole h is activated as soon as the hole is filled, even though the filler x has yet to gather \nits to-be-captured free identifiers. Hence, to adapt binding structures to a programming language calculus, \nwe must pin down what the to-be-captured identifiers of a filler are; short of it, the system is not \nChurch-Rosser. Equality 1 follows from T([C /h]C) -[l _(C )/v(h)]T( C), whose proof is an induction \non the structure of C. Equiva\u00adlence 2 is a result of oh(C ) ~ oh(C) U oh(C ). IJ The following theorem, \nwhose proof is a straightforward induction on the structure of e, shows that T tramforms an evolved context \ne into its image: Theorem 5 T(e) + @p~.im(e). Following our intuition that contexts are source code and \nterms are target code, the transformation T is a compiler for evolved contexts. All we need then is a \nconcrete source code representation for A-terms that is abstract [13]: (i) for each source code encoding \nof e, there are predicates to tell whether e is a variable, an abstraction, or an application; (ii) there \nare mechanisms to break the encoding of each compos\u00adite term down to (the encoding of) its components; \nand (iii) there is a predicate to determine the equality of variables via their encoding. Clearly we \ncan devise such a represen\u00adtation based on the program symbols simulated in Section 2.4. Indeed, whichever \nabstract source code representation we may devise for A-terms, all we require from a symbol x is the \nneeded pair of lamx and @{x: z},s.  4.3 Second Simulation The encoding T of the last section is rather \nconservative. It translates a context to its image only when the context is evolved. Moreover, the transformation \nT does not regard (Ax.CI) Cz, where either Cl or Cz has holes, as a @-redex, since its reduction can \nchange the capturing identifiers of holes in Cl and C2. We give another simulation showing that it is \npossible to simulate any context C as closely ae ire(C) and hence allowing the @-reduction of (Ax.C1 \n) C2. 4.3.1 Binding Structures The second simulation is based on Talcott s binding struc\u00adtures [20]. \nThe a-and /3-conversions are recovered by anno\u00adtating each hole with its capturing identifiers, the identifiers \nit intends to capture (using our notation): e ::= zlkc.el eelxlh:{xl:el, . . ..xn. e~} An annotated hole \nh: {X1 : el,. . . . Xn: en} denotes a sus\u00adpended hygienic substitution of e~ for x, that is activated \nwhen h is filled. For instance, filling h: {x: y} with (x x) ini\u00adtiates the substitution of y for x in \n(z x), [y/x](z x), yield\u00ading (z y). With this setup, Az.h: {x:x} is a-equivalent to Ay.h: {x: y} and \n(kc.h: {x:z}) e @reduces to h: {x: e}. Still, hole filling and ~-substitution in Talcott s binding structures \ndo not commute. Consider the following: 4.3.2 Encoding Contexts In the second simulation, a context \nC is encoded as the triple (Ec, lC, IYc) with E= s @p~.@~.S{}* (C) 1= = @p:. {Y= :5=} H. = @p:. Ag.{h=: \n(g k=)} where we use the notation Ag. {fit: (g kc)}* as an abbrevia\u00adtionof~g. {hl:(ghl),... ,h~ :(g h~)} \nwith hi = v(hi). The encoding Sp. (C) is defined inductively on the structure of c as follows: SP* (h) \na (v(h) p ) SP* (x) = v(x) SP*(AX.C) = AV(X).S(P* ~ {X: V(X)}*)(C) SP*(CI C2) = (SP*(CI) SP*(C2)) The \nfirst element E. is the encoding S{}. (C) of C with the to-be-captured free identifiers and holes of \nC +-bound. S{}* (C) is similar to ire(C) except that each hole h is en\u00adcoded as the application (v(h) \np*), which is our way of an\u00adnotating h with its capturing identifiers encoded as p . The other two elements \nIc and H. are needed when C is used to fill the hole h of some context C , [C/h ] C . H. helps propagate \nthe capturing identifiers associated with h to the holes of C. The annotated hole h may not capture all \nthe free identifiers of C; ~. is used to ensure that the free identi\u00adfiers of C not captured by h remain \nas to-be-captured free identifiers of [C/h ] C .  4.3.3 Encoding Context Filling Filling the hole h \nof a (simulated) context (E., 10, H=) with another (simulated) context (Ecf, 1=, , Hc/ ) can be accom\u00adplished \nusing the fil~h operator defined below: jillh (~.,, l=J , Hc, ) (E., 1., ~.) = ((~, bidh E=, 1=, H=, \nE=), (F2 1=/ 1=), (F, H=, H=)) where the combinators F1, F2, and F3 are defined as follows: F1 = ~~abcd.(app \n(app O{}.(F1 f a c) b) d) F; = A.fabcd.(f (app @{}.(Ff a c) b) d) F; = Aabcy.(exec ((c (F~ y)) (exec \n(b (y a))))) F; = Ayzy .(z (y 0 y )) F2 = kzb.(app (app i@{}. ~ab.(a o b) a) b) F3 = kb.(app (app @{}.kbg.((a \ng) o (b g)) a) b) Theorem 6 Let [C /h]C be C and the encoding of C, C , C be (E., 1., H.), (E=,, 1=,, \nHCI ), (E=li, Ic/~, He/l ). Then, jillh (13eI, 1=,, H=,) (Ec, 1=, H=) x (EC,,, 1=/,, H=,,) Sketch of \nProof: By the definition of fillh, we have jillh (~cl , lc~, kf., ) (~c, Io> ~.) = (J!?,1, ~) with E \n= @p~up;, .@p~Mp~, .[G/z]S{l* (C) (3) I = @p:k@:,.({x=l :i=l} o {kc :ZC}*) (4) H = @p~up~,.Ag.({hcl :(g \nZ=))}* o {fit: (g i=)} ) (5)  where either h: z G p$ or else x is fresh and G = ~y.(Gh y (G. Y~cI)) \nG~ = Ayz.(exec ({fi=~ : ~y .(~c, (y o y ))}* z)) Gx = Ayz.(exec ({~=~: Z=,} (y z))) The effect of E \n(Equation 3) is that each hole h in C, which is encoded as (Z {~: z }*) in S{}. (C), becomes G{y, z}* \n= G~ {~:?} (GX {y:=} E=, ) Since E=, is @{k=~ :? }.@{ficJ :~ }.${,. (C ), we have Gx {Y: E}* E=J = exec \n({%=( :2=/} ({~: E}* E=,)) = @{k=J :k }.[E /i ]s{} *(c ) For each x;: x: ~ {X=l : z }, the occurrences \nof z; in S{}* (C ) are substituted with e:, which is some ej if x: s Yj or else it is the variable corresponding \nto X: in {%=/ : Z=J}. That is, each free occurrence of the identifier x: in C is linked to the denotation \nej of Yj when x; and Yj are the same identifier. Otherwise, x: remains free in the encoding of [C /h]C. \nThis step realizes the capture of the free identifiers %=t of C by the capturing identifiers Y of h. \nLet A be @{hcl :~}.[E /z ] S{ I*(C ). Then, G{y:z}* = Gh{~:E}*A = exec ({~=~ : Ay .(iot ({~: =} o y \n))}* A) = [Ay .(k=l ({y:tz} o y ))/P][E /E ]s{}* (c ) Hence, each hole (h[ {~ : E }*) of S{l. (C ), \nwhich is the encoding of h; in C , becomes [Ay .(ha ({y: z} o y ))/h:](h: {y :E }*) = (Ay .(h, ({y: E}* \no y ))) {y :E } = h; ({y:i2}*o{y :E }*) where h;: hi G {fi=l : ~}. That is, a hole h; in C becomes a \nhole h: in [C /h]C that not only captures the identifiers ~ of h;, but also captures the identifiers \nY of h. The element 1 (Equation 4) simulates {%=,, : itc,~ }*, where i=,i are the free identifiers of \nC , by composing {%: z.}* and {~=) : Zci }*. Likewise, the glement_H (Equation 5) simu\u00adlates the functionality \nof Ag. {hell : (g h=,l )}*, whgre hc~, are the holes_ occur~ing in C , by combining Jg.{hc: (g i=)} and \nAg. {hcl : (g hc~)} . D A novelty of AC that we have used extensively in the two simulations above is \nthe transparency of free identifier abstractions. The app primitive allows us to skip over the abstracter \n@p of a free identifier abstraction @p.e to operate on the body e without having to execute the abstraction \nfirst. Metaphorically speaking, free identifier abstractions Qp.e model compiled code; to link them together, \nwe should have access to their target code e. 5 First-Class Definitions Our context-enriching schema \napplies to extensions of the A-calculus as well. We experiment on the A-calculus ex\u00adtended with definitions \nthat Plotkin uses to demonstrate his structural operational semantics (for space considerations, we have \nomitted a few forms of definition). The context\u00adenriched definition calculus is capable of expressing \nfirst\u00adclass modules. Module linking is modeled, as expected, by the a-conversion of import and export \nvariables, no envi\u00adronment lookup is required. We then sketch how to add relinkable variable references \nto the definition calculus to express late binding essential to object inheritance. 5.1 Definitions The \nextended A-calculus has the following syntax [18]: e ::= z[kc.elee {let dine d ::= {zl=e,..., z~=e}lseqddlr-ecd \n A simple definition {xl = el,. ... Zn = en}, where n z O and xl,..., x~ are pairwise distinct variables, \nis a set of in\u00addependent bindings that associate the variables xl, . . . ,X* with the denotations el, \n. . . , en, respectively. seq 0!1 dz de\u00adnotes the sequential extension of dl with dz. The bindings of \ndl are visible to and shadowed by the bindings of dz. rec d causes the bindings of d to be recursive. \nThe defining variables of a definition d are the export variables of d. The set of defining variables \nof a definition d, dv(d), is defined inductively as follows: dv({zl= el,..., zn= en}) = {zl,..., G} dv(seq \ndl dz) = dv(dz) U (dv(dl) \\ (iv(dZ)) dv(rec d) = dv(d) The free variables of a definition d are the \nimport variables of d. The set of free variables of a definition d, fv (d), is defined inductively as \nfollows: jv({zI = el, . . ..zn= en}) = jv(el)U . ~~ Ujv(en) fv(seq dl dz) = fv(d,) U (fv(dz) \\ dv(dl)) \ntv(rec d) = fv(d) \\ dv(d) In the sequential extension clause, the scope of the defining variables of \ndl includes dz, hence the removal of dv (dl ) from the free variables of dz. The free variables of a \nterm e are the variables imported by e. The set of free variables of e, ~v(e), is defined as usual but \nextended with this clause: fv(let d in e) = fv(d) U (fv(e) \\ dv(d)) The operational semantics of definitions \nd can be under\u00adstood as syntactic extensions of the pure A-calculus. There are compelling reasons to \ntake definitions as core constructs of a programming language, however. They are more ef\u00adficient to implement \ndirectly than their corresponding ex\u00adpanded pure A-terms [16]. Furthermore, they are essential to polymorphic \ntype inference [14]. In the context-enriched calculus of definitions, we take the best of both views. \nOn the one hand, we regard definitions as syntactic extensions to avoid introducing additiomd mechanisms \nto explain their computational behavior. On the other hand, we treat them as core forms to demonstrate \nthe syntactic nature of our linkkg operations. Syntax: ::= x I Axe I ee I let dine [ @p.e I V(e, p).d \n: ::= {zl=e,..., xn=e} n~O, xt~xjwheni#j Isegddlrecd 6 ::= exec [ i I lamx I app I let I seq I rec E, \np ::= {x,:$,,... ,Xw:zn} n~O, x~$xjwhen i#j, x;$xjwheni#j Additional basic reduction rules: (t) let V(E1, \npl).d Opz.e + @pl W(pz\\cl).let d in e where p2 f%.sI (let) (t) seq v(cl, pl).dl !l?(e2, p2).d2 + W(e2U(cl\\e2), \nplU(p2\\q)). seq dl dz where p2 FTI.SI (seq) (t) rec W(c, p).d ~ Q(s, p\\c). rec d where p F%S (ret) Figure \n4. Context-enriched definition calculus ACD.  5.2 Cent ext Calculus of Definitions The contexts of the \ndefinition calculus are (cf. Figure 1): c ::= hlxl Ax. CICCllet Din C D ::= {X, =c,..., xn=c} lseq DDlrec \nD The evolved contexts e and evolved definitions d are: e ::= xl Ax.eleel let dine d ::= {xl=e,..., xn=e} \nIseqddlrecd The context-enriched calculus of definitions ACD is shown in Figure 4. In addition to AC \nand the definition constructs, we have added four terms: let, seq, ret, and Y(E, p) d. The primitive \nlet constructs compiled code of evolved context term let d in e. The next two build compiled evolved \ndefini\u00adtions seq dl dz and rec d (again, for space considerations, we have omitted mechanisms for constructing \nsimple con\u00adtext definitions {xl = el, . . . . x~ = en}). The fourth term W (s, p) .d is an abstraction \nfor compiled evolved definitions d. The specification p externally identifies some of the free variables \nof d. The specification E externally identifies some of the defining variables of d. The reason for the \nnew com\u00adpiled code abstraction dedicated to definitions is that the body of a @-abstraction i17(s, p).d \nis a definition d, which is not a proper term. Had we identified ill-abstractions with @-abstractions, \nthe compiled code execution operation: exec W(C, p).d would have introduced definitions as proper terms \ninto ACD! Indeed, we may perceive T(c, p) .d as a substitute for d as first-class citizens. This is reminiscent \nof modules that export (some of) the defining variables of d and import the free variables specified \nin p. The primitives seq and rec thus become module linking operators, and the primitive let is the means \nto import modules into compiled code. A constraint on Q (e, p) .d not shown in Figure 4 is If x: z 6 \ne and x: y G p, then the import variable y cannot occur free in the scope of the export defining variable \nx. We say W (c, p) .d is admissible when it satisfies the condition. Here is an example that is not admissible: \nIP({x:z}, {x:y}).(ret {Z= y}) Conceptually, it is supposed to be the compiled code of the evolved definition \ncon~ext rec {x = x}. Bu~ then, we should have identified x and y: T?({x:y}, {x:y}).(ret {y = y}) The \nlet-rule models the construction of the compiled code @pl w (pz \\El).let d in e of let d in e from the \ncompiled code IU(cl, pl) .d of d and the compiled code @pz .e of e. p2\\s1 is {x:x c p2 I x:y f E1 for \nany y}, the difference of pz from .s1. They are the import identifiers of pz that have no matching export \nidentifier in el. pl u (pz \\&#38;l ) is the well\u00adformed union of pl and p2 \\&#38;l, the import identifiers \nof d and the unmatched import identifiers of e. The matching import identifiers of pz and export identifiers \nof:1 must have identical variable names, namely, if x:x E c1 and x: y G p2 then x s y. This condition \nis denoted as pz R S1. The rule further relies on renaming the import variables of pl, p2, the export \nvariables of cl, and the defining variables of d to meet these hygiene conditions: (i) No defining variables \nof d may capture any free variables of e except for those specified in pZ m c1. (ii) Free variables of \ne must not be captured by pl except for those specified in pz \\El. Likewise, free variables of d must \nnot be captured by pl except for those specified in pl. In short, other than the intended capture specified \nin pz R cl, no capture should occur. The seq-rule models the construction of the compiled code ~(EzkJ(el \n\\e2), plkJ(p2\\&#38;l)). seq dl dz of seq dl dz from the compiled code 137(el, pl ) .dl and Q(ez, pz) \n.dz of dl and dz. Again, pl M (pz \\el) is the well-formed union of pl and Pz\\c1. .51\\ez is {x:x C E1 \nI X:Y $! e2 for any v}, the export identifiers of cl not shadowed by .52. ez u (s1 \\ez) is the well\u00adformed \nunion of the export identifiers of .5z and those of EI not shadowed by .52. The matching import identifiers \nof pz and export identifiers of S1 must have identical variable names, pz R c1. This rule, like other \nlinking primitives, re\u00ad lies on renaming the import variables of pl, p2, the export variables of El, \ne2, and the defining variables of dl, d2 to en\u00ad sure the absence of inadvertent capture and shadowing: \n(i) No defining variables of dl may capture any free variables of dz except for those specified in pz \nR c1. (ii) The export variables of dl specified in c1 must not be shadowed by d2. (iii) Free variables \nof d2 must not be captured by pl except for those specified in PZ\\&#38;l. Likewise, free variables of \ndl must not be captured by pz except for those specified in pl. The ret-rule models the construction \nof the compiled code V(E, p\\e) .(rec d) of rec d from the compiled code of d, V (e, p) .d. Again, the \nvariables of .s and p are renamed so that the matching import identifiers of p and export iden\u00adtifiers \nof e have identical variable names, p R&#38;. Other than that, no capture should occur. The calculus \nACD again demonstrates the fundamental view of our work: linklng can be explained in terms of care\u00adfully \ncontrolled a-conversion. We next demonstrate how the module linking operations work. 5.3 Examples Let \nA and B be two Q-abstractions defined as follows: A = W({c:c,d:t},{ d:s}). {c= Ap.(fps), t = 5) B = V({d:c},{d:d}).{c= \n(td)} Since the variable s of the import identifier d is not in the scope of the variable tassociated \nwith the export identifier d, A is admissible; B is likewise admissible. We may rename s to twithout \nchanging the meaning of A II!({c:c, d:t}, {d:t}).{c= Ap.(fpt), t =5} We can combine A and B sequentially \nas follows: C = seq AB = il({c:r,d:c},{ d:s}). (seq {r = Ap.(f p s),l = 5} {c= (t1)}) The variable of \nthe export identifier c of A and the variable of the export identifier d of B are the same c. We thus \nrename the former to a fresh r to avoid inadvertent shadow\u00ad ing. The import variable d of B matches the \nexport variable tof A; we thus link them together by renaming them to a fresh 1. Since the export identifier \nd of A is shadowed by B, it is no longer available as an export identifier and is thus removed from the \nresulting export specification. We also remove the import identifier d of B from the result since it \nhas been linked. We next make the definition C recursive: D = recC = IU({c:r, d:s},{}). (me (seq {r = \nAp.(f p s), 1= 5} {s= (t1)})) We link the import variable s to the matching export vari\u00ad able c by renaming \nthem to the same variable, says. Since d has been linked, it is removed from the import specification. \nWe can extract the denotation exported via c from the recursive definition D using let: let D @{c:c}.c \n= @{}. let (ret (seq {r = Ap.(f p s), 1 = 5} {s= (t 1)})) in T The import variable c is renamed to the \nmatching export variable r. 5.4 Relinkable Variable References We further extend the definition calculus \nwith relinkable variable references: e .. .. . .. IIZ. ,2$ ,...] A variable reference Z , where n ~ \n1, in Berkling and Fehr s rendition of the A-calculus [3] has both a name z and a de Bruijn index n \n[6]. It refers to the nth nearest enclosing binding variable with the name z. A relinkable variable reference \n[z~l, 3$2, . . .] consists conceptually of a (possibly infinite) non-empty sequence of Berkling and Fehr \ns variable references.1 It is equivalent to the dominant constituent z~i with the largest i such that \nz~i is bound; otherwise, if none of its constituents are bound, the relinkable reference is unbound. \nThat is, [x~l, c~z, . . .] is equivalent to if bound?(x~z ) then Z~2 else if bound?(z~l ) then m~l else \n[z~ , z?,...] is unbound where bound?(x ) is a predicate that tells whether z is a bound variable reference. \nRelinkable references are still statically scoped in the sense that given any program, we can statically \ndetermine the dominant constituent for each of its relinkable references. The potential of relinkable \nreferences is unleashed when they are enriched with contexts. In particular, they can model the late \nbinding behavior of virtual method references found in object systems. In the following scenario, we \nsketch how virtual method references can be expressed in terms of relinkable references. The I&#38;abstraction \nB below serves as a base class: B= W({f: f}, {X:z}). (ret {~= [~, z2, Z3,. ..], Z= 91}) It defines a \npublic method f named internally as f. The de\u00adnotation of f is a relinkable reference [zl, X2, Z3, . \n. .] that be\u00adhaves like a reference to a virtual method known externally as x. The dominant constituent \nof the relinkable reference is xl, which is underlined. It refers to the defining variable x, which is \nalso underlined. The default denotation of the virtual method reference is thus gl. This can be made \nclear by renaming the defining variable x to a fresh g: iv({f f}, {x:z}). (ret {f= [~, xl, xz,...], ~=gl}) \n We have decremented the indices of X2, X3,... by one since X2 is now in the scope of one less binding \nvariable named x, and so forth. From B we can define a derived class D as follows: D = rec (seq B IU({X:Z},{}).{Z \n= gz}) = W({f:f, x:z}, {x:z}). (ret (seq (ret {f = [zl, izl,z3,.. .],z = 91}) {z= 92})) lWe ~u~t find \n~ finite syntactic representation for such sequence3. Doing so would certainly limit the expressible \nsequences. Fortunately, many interesting uses of relinkable variables do have a finite represen\u00ad [1, \nn) and ~[l! *) to denote the finitetation. For instance, we can use z 3equence [Z1, Z2, . . . ,Z - ] \nand the infinite sequence [Z1, Z2,.. .]. The dominant constituent of the relinkable reference now becomes \nX2 and it refers to the new denotation gz. Again, we rename the bound constituents of the relinkable \nreference to clarify the situation: W({f:}, x:z}, {x:z}). (TSC (seq (ret {~= [y, Z,xl,...], y =91}) {z= \n92})) As the examples show, [zl, X2, Z3, . . .] haa a different deno\u00adtation in the derived class D than \nin the base class B. Some models of inheritance express recursive dependency among methods indirectly \nvia the pseudo-variable self, hence resolving method references either at object instantiation time [5] \nor at method invocation time [10]. In contrast, based upon relinkable references, our notion of late \nbinding resolves all method references, including virtual references, incrementally as soon as classes \nare defined, hence providing an intuitively more direct model of inheritance, 6 Related Work We relate \nour context-enriched calculi to other extensions of the J-calculus with name-based programming mechanisms: \nrecords, Dami s A-calculus with names, &#38;it-Kaci and Gar\u00adrigue s label-selective A-calculus, Lamping \ns transparent data parameters, and our quasi-static procedures. Not one of these systems explicitly supports \nincremental code construc\u00adtion. To simplify the discussion, we focus on the core of the abovementioned \nsystems. We also take the liberty of alter\u00ading their syntax in the style of our context calculi. 6.1 \nRecords In Section 3 we have shown that AC can be described in terms of environments. It is thus possible \nto simulate AC in a record calculus with adequate operations [4]. Indeed, ACD can also be simulated. \nA Z-abstraction V(s, p).d can be seen as a parameterized record: v = Ar. (xl= el,. ... xn= en) where \n(xl =el, ..., x. = e.) denotes a record that asso\u00adciates the labels xl, ..., xn with the denotations \nel, ..., en, respectively. The record labels x1,. . . . Xn are the export identifiers of E and el, ..., \nen are their respective denotation in d. Furthermore, each free occurrence of an import vari\u00adable x of \np, x: z c p, in d is replaced by field extraction T.x in -y. The linking operators seq and rec of ACD \ncan then be defined as transformations of parameterized records: seq = ~ylvz.h.((~1 r)@ (-Y2 (r@ (w r)))) \nrec = ~~.h.(fiz h- .(~ (r @ r ))) (6) where r @ r is the asymmetric concatenation of records r and r \n, with r shadowing r. Still, it is more natural to reason with free identifier ab\u00adstractions when dealing \nwith incremental program construc\u00adtion. The way linking is modeled in our context-enriched calculi is \nconceptually closer to what actually happens in a linker. An import variable reference is simply aasigned \nthe memory address associated with its corresponding export variable by the way of renaming. Moreover, \nour context\u00adenriched calculi specify what linking should be, not how it should be done. There are advantages \nof separating spec\u00adification from implementation. For instance, it is easier to add new module linking \noperators to ACD. We only need to make sure that what the new operators do is not in conflict with what \nthe existing operators do. Hence, we can generalize rec to rec~z that behaves like rec except that it \ndoes not link the identifiers k. That is, the result of r.ec,k N?(E, p) .d does not have recursive bindings \nfor %. Each operator reci~ can be defined as a generalization of Equation 6, the definition of ret: The \nrecord operation r \\k removes the %-fields from r . We may next decide to add to JCD yet another new \noperator join whose reduction rule is join reci~ reci~ + rec\\(~ U ~) where % u ~ is the union of z and \nY, and reci(~ u y, links neither 5? nor ~. The addition of join does not affect the behavior of any of \nthe existing operators. The same can\u00ad not be said about the record-baaed simulation, however. It would \nbe difficult at best to devise a functional definition F of join based on Equation 7: Reimrdemention \nof reci~ would be necessary to accommo\u00addate ~oin. In short, our context calculi are modular languages \nde\u00adrived from a lan~ua~e design schema that is itself modular. Compilation an~linlcing operators, as \nwell as operations on them, can be added, removed, or replaced in a modular fash\u00adion. Extensibility and \nmodifiability are therefore available at the language design level also.  6.2 Lambda Calculus with Names \nDami s Lcalculus with names AN [7], shown in Figure 5, ex\u00adtends the A-calculus with keyword parameters \nto facilitate extensibility. We show here that AN can be embedded into AC; see the translation C [ ] \nof Figure 5. A ~N-abstraction A{xl:zl,. . . , X.: x.}.e has each parameter Zi known ex\u00adternality via \nthe keyword (identifier) x;. It is equivalent to the free identifier abstraction @{xl: Z1, . . ., x~: \nz~}.c[e] where the keyword parameters of the AN-abstraction be\u00adcome the unlinked parameters of the ?&#38;abstraction. \nThe AN-calculus breaks ~-reduction up into two independent re\u00adductions called bind and close. A bind \nreduction is (Ap.el)(x > e2) + Ap.[e2/z]el where either x: z c p or else x is fresh. It supplies the \nargument ez to the parameter x of the abstraction Jp.el, but without invoking the abstraction. We can \nsimulate the same behavior in AC by translating (Ap.el ) (x > ez) to app (larnx @p.c[el]) @{}. C[ez]. \nA close reduction is (Ape)! + [err/zl] . . . [err/Zn]e where the z~ s are the parameters of p. It corresponds \nto invoking the abstraction Ape. we can simulate the close reduction by translating (Ape)! to exec @p.C \n[e], provided that we identify unlinked parameter indicators % with err. AN Syntax: e P ::= ::= z I \nApe {Xl:zl,..., I e(x > e) [ e! x.:x. } n~O, xi~xjwheni#j, xi# xjwheni#j Translation C[ ]: C[z] C[Ap.e] \n= = z @p.C[e] C[el(x->ez)] C[e!] = = app exec (lamx C[e] C[el]) @{}.C[e2] Figure 5. Embedding A-calculus \nwith names AN into AC,  6.3 Label-Selective Lambda Calculus . The label-selective ~-calculus [1] is \ndesigned for selective un\u00adordered currying of functions via commutation of function parameters and arguments. \nIt has the same syntax as the A-calculus except that abstractions and applications are la\u00ad beled with \nsymbols (identifiers); see Figure 6. An abstrac\u00ad tion Axz.e accepts only arguments labeled with the same \nsymbol x as its parameter x. An application elZe2 supplies ez labeled with x as an argument to el. The \n~-rule is (~xx.el)~ez -[e2/s]el when the abstraction s label matches the application s label. Otherwise, \nthe argument, along with its label, commutes with the abstractor:2 The simulation C[ ] of the label-selective \nA-calculus in AC is given in Figure 6. We encode a labeled abstraction Axx.e aa a pair consisting of \nthe symbol x (which is the pair (lamx, @{x:x} .z)) and the free identifier abstraction @{x: z}. C[e]. \nA labeled application e13e2 becomes an ap\u00ad plication of the label-matching operator match of two ar\u00adguments: \n(i) the translation of the x-labeled argument e2, denoted as a pair (x, C[ez]), and (ii) the translation \nC[el] of the function el, whkh should reduce to the representation (y, @{y: y}.C[e]) of some labeled \nabstraction ~y~.e. When x and y are the same label, we have a ~-redex. The match\u00ading process yields exec \n(lamx @{y: y} .C~e]) C[ez], which reduces to (Ay.C[e]) C[ez], the equivalent of C[[ez/y]e]. In the other \ncase where x and y are different labels, we have a commutation redex. Thus, the matching process yields \nthe pair (Y, (app @{}.(match (x, C[e2])) @{y: y}. Cle])), which reduces to (y, @{y: y} .(rnatch (x, C[ez]) \nC[e])), the transla\u00adtion of Ayy.(e?ez). 6.4 Transparent Data Parameterization Larnping s transparent \ndata parameters [9, 11] are an at\u00adtempt to unify the parameterization mechanisms employed in programming \nlanguages. The core haa the syntax: e ::= z I data X=Z: e I supply x+e toe Variables x are lexically \nscoped. data x= x: e denotes the parameterization of e over the data parameter (identifier) x known to \ne as x. Supply x + el to e2 supplies el as a 2 We omit two other reduction rules for reordering abstractions \nand applications. Their induced equivalence relations can be defined via operational equivalence. denotation \nfor the data parameter x to ez. The equivalent of /3-reduction is supply x+el to data x=x: e2 + supply \nx+el tO [el/z]e2 where the binding of x remains available to the contractum [el/z]ez. A data parameter \nbinding is transparent (commu\u00adtative) to any construct, making it accessible to the con\u00adstruct s components. \nA commutation reduction is3 supply x+el to data y=~: ez d data y=y: supply x+el toe2 if x $ y We can \nencode transparent data parameters in the label\u00adselective calculus and hence in AC: data x=x: e S ~xz.(e~z) \nSupply x+el tO e2 -ez~el A ~-redex supply x+ el to data x= z: ez is thus encoded as (~xz. (ez=z))~el. \nIt reduces to ([cl/z]ez)~el, the trans\u00ad lation of supply x+ el to [el/z]ez. A commutation redex supply \nx+ el to data y= y: ez becomes (AYy. (ezjy))+el. It reduces to Ayy. ((e2~~)~el ), which is operationally \nequiva-Yx lent to AYy.((ez=el);y), the translation of the contractum data y=y: supply x+el to ez. 6.5 \nQuasi-Static Procedures Our quaai-static procedures [12] are designed to share vari\u00adables across lexical \nscopes. A quaai-st atic procedure is com\u00adparable to a free identifier abstraction whose body is a A-Abstraction, \ns?p.kc.e. There is a mechanism similar to AN s bind operation to supply denotations for the parameters \nof p. A quaai-static procedure @p.Ax.e can be invoked as if it were the J-abstraction Axe, however. In \nsuch a case, un\u00adlinked parameters of p are assigned an exception value. We can express this in AC with \nthe help of a predicate @?(el ) to determine if el denotes a free identifier abstraction. Each quasi-static \napplication el ez is then simulated by the ap\u00adplication (if @?(el ) then (exec el ) else el ) ez; if \nel denotes the representation @p.Ax.e of a quasi-static procedure, it is executed to obtain the encapsulated \nA-abstraction Axe, which is then applied to e2. 7 Summary We have devised a schema for enriching kcalculi \nwith the notion of contexts. The centerpiece of our context-enriched 3we omit the ~om~utation rules for \nreordering data Parameter abstractions and applications for the reason stated in footnote 2. Label-selective \nA-calculus syntax e ::= z I Axz.e I e~e    C[z]= x Translaticm C[ ]: C[Axz.e] = (x, @{x: z}.C[e]) \nC[el~e2] = match (x, C[e2]) C[el] with exec (lamx vz ) VI ifx=y match (x, m) (y, V2) = (Y, (aPP @{}.(match \n(x, m)) v2)) otherwise { Figure 6. Simulating label-selective A-calculus with AC. calculi is the linking \nof open terms (terms with free variable [9] references) expressed purely in terms of free variable renam\u00ading. \nWe have also extracted from the encoding of contexts the essential mechanisms needed to compile program \nsym\u00adbols into variables. [10] We have demonstrated that the context-enriched calculi are modular languages. \nFurthermore, the schema itself is also modular. We can add, remove, or replace compilation and linking \noperators modularly. Extensibility and modifi\u00adability are therefore available to both the language design \n[11] process and the product languages. Acknowledgements. We are grateful to the referees for their insightful \ncomments. We particularly want to thank Jon Rossie, whose input has greatly improved the paper. [12] \nReferences [,1]Haasan kit-Kaci and Jacques Garrigue. Label-selective A-calculus: Syntax and confluence. \nIn Proc. of the 13th [13] International Conf, on Foundations of Software Tech\u00ad nologies and Theoretical \nComputer Science, pages 24\u00ad40, Springer-Verlag, 1993. [14] [2] H. P. Barendregt. The Lambda Calculus: \nIts Syntax and Semantics. Revised edition, North-Holland, 1984. [15] [3] Klaus J. Berkling and Elfriede \nFehr. A consistent exten\u00adsion of the lambda-calculus aa a base for functional pro\u00ad [16] gramming languages. \nInformation and Control, 55:89\u00ad101, 1982. [17] [4] Luca Cardelli and John C. Mitchell. Operations on \nrecords. In [8]. [5] William Cook and Jens Palsberg. A denotational se\u00ad[18]mantics of inheritance and \nits correctness. In Proc. of the ACM Conf. on Object-Oriented Programming: Systems, Languages and Applications, \npages 433-443, 1989. [19] [6] N. G. de Bruijn. Lambda calculus notation with name\u00adless dummies, a tool \nfor automatic formula manipula\u00adtion. Indagationes Mathematical, 34:381 392, 1972. [20] [7] Laurent \nDami. Software Composition: Towards an Integration of Functional and Object-Oriented Ap\u00adproaches. PhD \nthesis, University of Geneva, 1994. [21] [8] Carl A. Gunter and John C. Mitchell. Theoretical As\u00adpects \nof Object-Oriented Programming: ~pes, Seman\u00adtics, and Language Design. MIT Press, 1994. Stanley Jefferson, \nShinn-Der Lee, and Daniel P. Fried\u00adman. A syntactic theory of transparent parametrizat\u00adion. In Proc. \nof the Third European Symp. on Pro\u00adgramming, pages 211-226, Springer-Verlag, 1990. Samuel N. Kamin. Inheritance \nin Smalltalk-80: A de\u00adnotational definition. In Proc. of the Fifteenth ACM Symp. on Principles of Programming \nLanguages, pages 80-87, 1988. John Lamping. A unified system of parameterization for programming languages. \nIn Proc. of the ACM Conf. on Lisp and Functional Programming, pages 316 326, 1988. Shinn-Der Lee and \nDaniel P. Friedman. Quasi-static scoping: Sharing variable bindings across multiple lex\u00adical scopes. \nIn Proc. of the Twentieth ACM Symp. on Principles of Programming Languages, pages 479-492, 1993. John \nMcCarthy. Towards a mathematical science of computation. In Proc. of IFIP Congress 63, pages 21\u00ad 28. \nNorth-Holland, 1963. Robin Milner, Mads Tofte, and Robert Harper. The Definition of Standard ML. MIT \nPress, 1990. James H. Morris. Lambda-Calculus Models of Program\u00ad ming Languages. PhD thesis, MIT, 1968. \n Simon L. Peyton Jones. The Implementation of Func\u00ad tional Programming Languages. Prentice Hall, 1987. \nGordon D. Plotkin. Call-by-name, call-by-value and the J-calculus. Theoretical Computer Science, 1:125 \n159, 1975. Gordon D. Plotkin. A structural approach to op\u00aderational semantics. Technical Report DAIMI \nFN\u00ad19, Computer Science Department, Aarhus University, 1981. Joseph E. Stoy. Denotational Semantics: \nThe Scott-Strachey Approach to Programming Language Theory. MIT Press, 1981. Carolyn Talcott. A theory \nof binding structures and ap\u00adplications to rewriting. Theoretical Computer Science, 112:99 143, 1993. \nMitchell Wand. Type inference for objects with instance variables and inheritance. In [8]. \n\t\t\t", "proc_id": "232627", "abstract": "A context in the &amp;lambda;-calculus is a term with some holes. Hole filling differs from &amp;beta;-substitution in that name capture is intended. This seemingly simple feature transcends static scope and lies at the heart of modular and object-oriented programming. Still, the name capture feature of hole filling is at odds with hygienic &amp;beta;-substitution. In this paper we conservatively extend the &amp;lambda;-calculus to incorporate the notion of contexts without jeopardizing the &amp;beta;-rule. We perceive contexts as source code and &amp;lambda;-terms as target code. Context filling is encoded as compilation operations and the enriched calculus is a theory of separate compilation and incremental program construction. Linking of separately-developed programs is done by coherent renaming of free variables.We apply our context-enriching schema to the &amp;lambda;-calculus extended with definitions and devise a calculus of first-class modules. We show that module linking can be modeled solely by the renaming of import and export variables. We add relinkable variable references to model virtual method references essential to object systems.The inclusion of contexts introduces parameters whose linking is based on names (symbols, identifiers, or keywords). We simulate in the context-enriched calculus other extensions of the &amp;lambda;-calculus with name-based programming notions such as Dami's &amp;lambda;-calculus with names, A&amp;iuml;t-Kaci and Garrigue's label-selective &amp;lambda;-calculus, Lamping's transparent data parameters, and our quasi-static procedures.", "authors": [{"name": "Shinn-Der Lee", "author_profile_id": "81452596292", "affiliation": "Computer Science Department, Indiana University, Bloomington, IN", "person_id": "P264128", "email_address": "", "orcid_id": ""}, {"name": "Daniel P. Friedman", "author_profile_id": "81100636522", "affiliation": "Computer Science Department, Indiana University, Bloomington, IN", "person_id": "PP39051860", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/232627.232652", "year": "1996", "article_id": "232652", "conference": "ICFP", "title": "Enriching the lambda calculus with contexts: toward a theory of incremental program construction", "url": "http://dl.acm.org/citation.cfm?id=232652"}