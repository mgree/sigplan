{"article_publication_date": "06-15-1996", "fulltext": "\n A New Look at Pattern Matching in Abstract Data Types Palao Gostanza, Pedro Rlcardo Peiia Manuel Ntiiiez \n Departamento de Inform~tica y Autom6tica Universidad Complutense de Madrid, Spain e-mail: {ecceso,ricardo, \nmanuelnu}@dia.ucm .es Abstract In this paper we present a construction smoothly integrating pattern matching \nwith abstract data types. We review some previous proposals [19, 23, 20, 6, 1] and their drawbacks, and \nshow how our proposal can solve them. In particular we pay attention to equational reasoning about programs \ncontaining this new facility. We also give its formal syntax and semantics, as well as some guidelines \nin order to compile the construction efficiently. 1 Introduction Most modern functional programming languages \nallow the programmer to define his/her own types by using the aige\u00ad braic type facilit y. An algebraic \ntype is a set of terms freely generated by a collection of special operations called con\u00ad structors. \nFor instance, the complex numbers type can be defined as follows: I data Complex = Cart Real Real where \nCart :: Real + Real ~ Complex is a tupling construc\u00ad tor taking two real numbers as parameters and producing \na complex number. Constructors play also a second role: they may appear in patterns in the left hand \nside of equations. Its role here is to access the value components. In this case, the constructor in \nfact acts as a destructor. In the complex numbers example we can define an add operation as follows: \nz add (Cart rl il) (Cart rz 22) = 3 Cart (rl + rz) (21 + iz) When more than one constructor exists, functions \ncan be defined by using several equations having different left hand sides. Usually, these equations \nare tried sequentially, and the first equation whose left hand side matches the patterns is the one applied. \nIn this case, constructors are acting not only as destructors but also as checking functions. For in\u00ad \nstance, we can define the add operation for natural numbers as: 4 data Nat = Zero I SUCC Nat Permission \nb make digitabhrd copy of pert or all of this work for personal or Olessroom use is ranted without fee \nprovided that copies ara not made or distributed for pro I t or commeroiai advantage, the copyright notice, \nthe title of the publication and its date appear, and notice is given that copying is by permission of \nACfvt, Inc. To rxpy otherwise, to republish, to post on servers, or to redistribute to lists, requires \nprior specific permission andlor a fee. 5 add (Sum nl) nz = Succ (add nl nz) 6 add Zero nz = nz The combination \nof algebraic types and pattern match\u00ading has resulted in an easy and expressive way of defining types \nas well as of defining operations manipulating them. But it also has drawbacks. The first of them is \nthe positional notation of the constructor components. The introduction of records and the extension \nof patterns in order to use them almost solves this problem. The worst one is the difficulty of using \npattern matching in abstract data types. The complex numbers example il\u00adlustrates well this problem. \nWith the chosen representation, we could write the add function in a concise way, but this representation \nis not appropriate to define a product opera\u00adtion. For that purpose, it would have been better to deiine \ncomplex numb ers by using polar represent ati on: 7 data Complex = Pole Real Real . product (Pole ml \nal) (Pole mz a2) = 9 Pole (ml *m2) (al +az) The programmer has to make a (rather difficult) choice be\u00adtween \nthese two representations, and cannot have tl.e ad\u00advantages of both at the same time. In functional languages \nas well as in most modern pro\u00adgramming languages the decision can be delayed by using an abstract data \ntype hiding the representation. We could define a set of abstract operations for complex numbers as follows: \n10 abstype Complex 11 cart, pole :: Real + Real ~ Complex 12 real, imaginary :: Complex ~ Real 13 magnitude, \nangle :: Complex ~ Real With these operations we can elegantly and symmetrically define both add and \nproduct as follows: 14 add %1 %2 = cart (real ZI + real 22) 15 (imaginary z, + imaginary z,) le product \nZI Z2 = pole (magnitude ZI * magnitvde Z2) 17 (angle z, +-angle ZZ) Now the definition is more wordy \nbecause we have lost pat\u00adtern matching. Let us note that the destruction implicitly performed in the \nleft hand side, now must be explicitly performed in the right hand side, by applying the adequate functions. \nThis transformation is even worse when applied ICFP 98 5/96 PA, USA 01998 ACM 0-89791-771 -WWOO05...$505O \n essary to join them in a unique rule, and then distinguish between the different cases by means of checking \nfunctions. In general, whenever a type is transformed into an ab\u00adstract type, the implementation is hidden \nand so the possi\u00adbility of using patterns is lost. In the complex numbers ex\u00adample, the constructors \nwhich would be useful for an ADT user are also adequate for a possible implementation. But generally \nthis is not the case. For instance, sets are usu\u00adally implemented by means of AVL trees, priority queues \nare imdernented bv usimz binomial trees. and so on. Useful patte&#38; for priont y que~es could be one \nfor checking if the queue is empty, and one for extracting the first element. This problem has appeared \nbefore in programming lan\u00adguages. When a program is complex enough, it is necessary to split it into \nseveral modules, some of them implementing ADT s, and hkling the representations. IPattern matching can \nonly be used inside the modules implementing abstract data types. Thus, a pleasant mechanism such as \npattern matching has a limited usability. In this paper we propose a new mechanism to make pat\u00adtern matching \ncohabit with data abstraction. It is named active destructors. Its main characteristic is that pattern \nmatching and algebraic types are separated. So, active de\u00adstructors are not directly related to ADT s \nimplementations. The rest of the paper is organized as follows. In Section 2 we review earlier proposals \nin this area: laws [21, 19, 20], views [23, 6] and abstract value constructors [1]. The last one is part \nof the New Jersey s SML implementation [2]. The other ones were respectively parts of Miranda [21] and \nHaskell [9]. Because of equational reasoning problems, they were not included in the new versions of \nthese languages [10]. In Section 3 active destructors are introduced by means of examples. In Section \n4 we give a sketch of our syntax and a denotational semantics for it. In Section 5 we show how to perform \nequational reasoning by using the new mechanism. This has been the main drawback of manly of the previous \nproposals. In Section 6 we sketch some possible ways of compiling our construction, while in Section \n7 we present our conclusions. A thorough description of our proposal, including all technical details, \nis containeci in [14]. 2 Previous Work In this section we review several previous proposals trying to \nintroduce the idea of abstraction into algebraic types. Miranda laws [19] were the first proposal. The \naim there was the definition of non free types. The equations relat\u00ading the data constructors called \nlaws are interpreted as rewriting rules trying to reach a normal form. These non free data constructors \ncan be used both for pattern match\u00ading and for value construction. For example, the following algebraic \ntype with laws implements complex numbers in polar form la data Complex = Pole Real Real 19 Pole 0.0 \na ~ Pole 0.0 0.0 20 Pole m a -Pole (-m) (a+ n), m!<0.0 21 * Polem (a+2.0 *r), m> O.OAa<O.O 22 * Polem \n(a 2.0 *r), m>().0Aa~2.O*r In this example, the added laws keep values in canonical form. Lawa are compiled \nseparating the underlying free type from the laws themselves. These define a normalizing }zInc\u00ad we would \nhave the type 23 data Complex = pole Real Real and the function 24 pole 0.0 a = pole 0.0 0.0 25 pole \nm a = pole ( m) (a+ n), m <0.0 26 =polem(a+2.0 *r), m> O.OAa<O.O 27 =polem(a 2.0 *r), m> O.0Aa~2.O*n \n28pole m a= Pole m a When a constructor of a lawful type is used in the right hand side of an equation, \nit is replaced by the corresponding func\u00adtion; when it is used in a pattern, the constructor remains \nunaffected. From the pattern matching point of view, laws are not as convenient as it would be desired, \nbecause normaliza\u00adtion takes place before matching. For instance, if one wants to implement complex numbers \nin such a way that both a pattern for the cartesian form and another one for the polar form could be \nused, then we need to define an algebraic type with two constructors and a law relating them; for example \n29 data Complex = Cart Real Real 30 I Pole Real Real 31 pole m C7~ cart (m * CCISa) (m * sin a) We have \nchosen ( Cart z g) as the canonical representation of a complex number. Should we define the product \n;s . O11OWS 32 prod (Pole ml al) (Pole m2 a2) = 33 Pole (ml * m2) (al + az) and should we try to evaluate \nthe expression (prod Z1 22), we would obtain a matching error, because Z1 and 22 would be first normalized \nto the cartesian representation. Besides these problems, laws were excluded from Mi\u00adranda due to well \nknown problems in equational reasoning. Thompson solves some of these problems in [20] by distin\u00adguishing, \nfor reasoning purposes, bet ween the two uses of a data constructor: aa a pattern and as a normalizing \nfunc\u00adtion. But this solution leads to the unpleasant fact that for reasoning about a program, it is necessary \nto perform the same transformation that the compiler would do (as de\u00adscribed above). In a later work \n[6], this fact is made explicit in the program text: the constructor and the normalizing function receive \ndifferent names. Even though constructors can only be used in patterns, some abstraction is lost, be\u00adcause \nthe user can still access the values implementation. The main drawback of all the work related to laws \nis that the choice of possible implementations for ar 4DT is severely limit ed, because a unique canonical \nrepre sm.tative for each abstract value must exist. For instance, the only possible implement ation of \nsets is isomorphic to ordered lists. Wadler s views [23] are the most versatile proposal trying to solve \nthe main problem of this paper. In contrast to the traditional solution of hiding the implementation, \nWadler proposes to achieve abstraction, i.e. independence of the cho\u00adsen represent ation, by showing \nas many implementations as possible. Each implementation is a view of the type. There is a distinguished \none corresponding to the actual represen\u00adtation of the type. For each other view, two functions, called \nand from the distinguished view. These functions are in\u00adverse of each other. Because all implementations \nare visible, pattern matching over each view can be performed. For ex\u00adample, the complex numbers would \nhave the following two implement ations: 34 data Complex = Cart Real Real M view Complex = Pole Real \nReal 36 in (Cart r i) = Pole (sqrt (r2 + i2)) (atan2 r i) 37 out (Pole m a) = Cart (m*cosa) (m*sin a), \n38 if (m == 0.0 Aa == 0.0) V 39 (O.O<m A0.0~r<2.0 *r) In this case, the distinguished implementation \nis the carte\u00adsian one: in the case of the Dolar imdementation. functions .. must be defined for doing \ntransformations from and to the cart esian one. The out function transforms a complex num\u00adber in polar \nrepresentation to one in cartesian representa\u00adtion, while the in function does the opposite. As these \nfunc\u00adtions are inverse of each other, they must be injective, hence the guard appearing in lines 38 and \n39. But this guard leads to non trivial problems. For in\u00adstance, which is the value of an expression \nlike (Pole 0.0 1.0)? In [23] it is not specified the value of such expressions, but they are not forbidden. \nIn general, the infectivity con\u00adstraint for these functions has been considered verv. restri c\u00adtive (see \n[6]), but it is necessary in order to make equational reasoning feasible. Without this constraint, implicit \nequa\u00adtions may appear. For instance, if we removed the guard in the previous example, we would introduce \nthe equation: VaVb Pole 0.0 a = Pole 0.0 b These problems have been reviewed in [6], where they are solved \nby using the same idea as Thompson used in [20] for laws. They argue that the problems come again because \nof the dual role played by views constructors: as patterns and as value constructor functions. They propose \nto remove the second role. As a consequence of this, only the in function is required and it is not forced \nto be injective. The authors regard a view as a bundle of case recognition and component selection functions. \nUnfortunately, they insist in transforming from the rep\u00adresentation to the view before the matching is \nperformed. The reason for that seems to be exclusively a compilation issue. As a consequence, in the \ndefinition of a function, only construct ors belonging to the same view can be used. This fact imposes \nsevere limitations in accessing an ADT. Also, for a view to be useful when defining functions, it must \nbe total in the sense of providing enough observations about the abstract value. For this reason, all \nthe views examples shown in the mentioned papers could also work as alter\u00adnative implementations of the \nADT. Double queues are a typical example where these limitations appear clearly, be\u00adcause there must \nexist a way of accessing the first element as well as accessing the last element of the queue, In this \ncase, two constructors can be defined: (First e q) accessing the first element and (Last e q) accessing \nthe last one. But each of them must be defined in different views because First and Last are not free \nbetween themselves. So, a function like .O both~nds (First True q) = some computations ~, bothEnds (Last \nFalse g) = some other computations ~, bothEnds q = default computations constructor like ( FirstLast \nfe le q) accessing simultaneously both extremes could be defined. But this pattern would not match queues \nwith one element, and a new pattern (Singleton Queue e) should be used in these cases. Using these constructors, \nthe bothlhds function could be written, but it would be too verbose. We think that these limitations \nare a consequence of try\u00ading to make evolve the constructor concept instead of start\u00ading the problem \nfrom scratch. In short, the way to get ab\u00adstraction is not to show all possible implementations. The \nlast proposal we review is abstract value constructors (AVC) [1]. An AVC is a special function such that \nthe right hand side of its definition is an expression formed exclusively by constructors and variables. \nThis restriction makes possi\u00adble to use AVCS both as normal functions and as patterns. There are some \nspecial AVCS called projections which may have variables in the right hand side not appearing in the \nleft hand side, but they can be used only in patterns, and they can be considered as functions giving \npartial ob\u00adservations of the ADT. AVCS do not suffer from equational reasoning problems but their expressive \npower is very lim\u00adited due to their unability to perform computations. Al\u00adthough we conceived our proposal \nbefore getting knowledge of AVCS, our active destructors can be seen as projection functions where computations \ncan be performed. 3 Active Patterns Our solution to achieve a smooth integration between ADT s and pattern \nmatching comes from considering the problem from the very beginning. What is the role of pattern match\u00ading \nin the ADT philosophy? In our opinion, patterns must provide a comfortable way of observing abstract \nproper\u00adties, because construction of values is a different matter. ADT s usually split the operations \nof a type into several disjoint groups: value constructors in one hand, and check\u00ading, accessing or modification \nfunctions in short, observer functions in the other hand. In general, constructors and observers need \nnot to be dual to each other. A typical ex\u00adample of this are FIFO queues: while the construction op\u00aderation \ninserts an element at the end, the observation one accesses the element at the front. An active pattern \nwill play both roles of checking and of observer function. Additional, an active pattern will be able \nto do as many computations as necessary for playing these roles. The execution of an active pattern starts \nby checking the value in order to determine whether it satisfies the pattern applicability condition; \nif this is the case, a code computing the observations made by the pattern is executed. These computations \nare done at matching time. 3.1 First Example: Complex Numbers We will start the description of our proposal \nwith the com\u00adplex numbers example. The relevant observations of this type are: real, imaginary, magnitude \nand angle (see code lines 12 and 13). Each of these operations may be used in pattern matching, and we \nwant their syntactic use to coin\u00adcide with that of constructors. An operation implemented in such a way \nwill be called active destructor (AD) and its name will be capitalized. For example, the definition of \nthe W?eul function, which indicates whether a complex number 43 i.dl.eal (Imaginary i) = (i == 0.0) \nThe Imaginary AD, with one argument, defines a pattern which mat ches a complex number z. If the argument \nof Imaginary is a variable i, it will be bound to the imaginary part of z; if the argument is a pattern \np then the matching process will go on, trying to match the imaginary part of .z with p. So, the isReal \nfunction could also be defined as follows: M id?eal (Imaginary 0.0) = Tme 45 isl?eal _ = False In the \nprevious definition, we only had to extract the imaginary part of a complex number, but when dealing \nwith operations like add, we have to perform two observations on the same complex number: its real and \nits imaginary parts. We use the@ symboll to denote the conjunction of patterns. A value matches a pattern \nof the form pl CIW if and only if it matches pI and pZ. Moreover, the produced bindings are the union \nof those coming from the matching of pl together with those coming from the matching of p2. Then, the \nadd function can be written as: 46 add (Real rl )@(Imaginary il ) 47 (Red r2)@(Zmaginary i2) = 48 cartesian \n(rl + rz) (il + i2) where cartesian is a value constructor function of the Com\u00adplex ADT. Patterns using \nADs and the @ symbol are called actiue patterns. If we implement complex numbers by using a cartesian \nrepresentation, the definition of the Imaginary AD will be: 49 Imaginary i match Cart r i This definition \nis syntactically similar to that of a function: the name of the AD, its arguments, the keyword match \n(instead of the = symbol), and its definition. However, ev\u00aderything behaves in the opposite way. Th[e \nright hand side does not define the value of an AD. Instead, it is a pattern defining which values match \nthe AD. In this example, any complex number will match. This pattern is called a condi\u00ad tion pattern. \nLet us note that the argument of Imaginary is an output one, which means that it is the result of a com\u00adputation \ninstead of an argument for a computation. So, in an AD, data flow from the right hand sid~e to the left \none: the datum matching the AD is the input value, and it may match the condition pattern; this matching \nextracts parts, which are used to compute the values of the AD arguments. Following with our example, \nthe previous definition can be written using an anonymous variable, because the real part of the number \n(i.e. r) is not needed: 50 h?IUgif3Ury 1 match Cart -z These ideas are presented more clearly in the \ndefinition of the Magnitude AD, which performs a computation 51 Magnitude (sqrt (r2 + i2)) match Cart \nr i 1 This ~ymbol is used in some funtional languages to denote as patterns. We generalize its semant \nits, because a variable is a pattern. Let us note that our extension adds expressive power only to ADs. \nWhen it is applied to patterns built by usual algebraic constructors, the pattern will be unfolded until \neither one of the arguments is a variable or a pattern which always falls. Let us note that the argument \nof Magnitude is an expression built from variables appearing on the right hand side of the definition. \nIn general, the computations performed by an AD may be as complex as needed but, in order to simplify \nthe notation, we allow the use of a where clause where the auxiliary definitions can be written: 52 Magnitude \nm match Cart r i S3 where m = sgrt (r2 + i2) If we implement complex numbers in polar form, these ADs \ncan be reimplemented, so that functions like add re\u00admain correct. That is what we would expect from a \nsystem providing data abstraction. Moreover, it is not necessary to normalize the internal representation \nbecause ADs can normalize the returned value: 54 Magnitude (abs m) match Pole m _ 55 Angle (norm m a) \nmatch Pole m a 56 where norm m a S7 = 0.0, m== 0.0 58 = norm ( m) (a + n), m <0.0 59 = normm (a+2.0 *m), \nm> O.OAa<O.O 60 = normm (a 2.0 *x), m> O.0Aa~2.O*m 61 =a 3.2 Second Example: FIFO Queues Now we present \na more complex example, which illustrates the usual fact that constructor and observer functions are \nnot dual to each other: FIFO queues. Its signature is: 92 abstype Queue a 93 empty :: Queue a 64 enqueue \n:: Queue a b a ~ Queue a 66 isEmptg :: Queue a G Bool m jirst :: Queue a d a 67 dequeue :; Queue cr + \nQueue a Clearly, empty and enqueue are constructor functions, so they must be implemented as normal functions. \nThe isl?mpty function is a checking operation, so it may be a good candidate for an AD, which we will \ncall Empty. We use the classic amortized constant time representation of a queue by means of two lists: \n69 data Queue a = Queue [a] [a] 69 empty = Queue [] [ ] 70 enqueue (Queue [] []) m = Queue [z] [] 71 \nenqueue ( Queue fs 1s) x = Queue fs (z : 1s) 72 Empty match Queue [] [] The implementations of first \nand dequeue are more sub\u00adtle. On the one hand, both of them have a checking compo\u00adnent, because they \nare not defined for empty queues. But from the ADT s point of view, the first function is an ac\u00adcessing \none, while dequeue is a modification function. Ac\u00adcording to the dequeue role we consider more important \n modification or checking-, it may be implemented either as a function or as an active destructor. Because \nwe want to show as many ADs as possible, we will choose the second alternative: n First x match Queue \n(z : -) _ 74 Dequeue (Queue fs 1s) match 75 Queue (-: (fs@(_: -))) 1s 76 Dequeue (Queue (reverse ~s) \n[]) match 77 Queue [_] 1s Let us remark some important points in this example. First, the definition \nof an AD C may need several equations, as it happens to functions. A value matches C, if it matches one \nof the condition patterns appearing in the right hand sides. Second, it is important to emphasize that \ncondition patterns used in the right hand sides are not completely independent of each other. For instance, \nit would be nonsense that a particuk queue matched, at the same time, the condition pattern of Empty \nand the one of Degueue. A second way of implementing these ADT operations is by recognizing the strong \nrelation between them: sometimes it is useful to access the first element and to remove it at the same \ntime. The following code defines a Dequeue AD, with two arguments, implementing this idea: 7e Dequeue \n x g match Queue (x : (~s@(\u00ad: _))) is 79 where q = Queue fs 1s 80 Dequeue z q match Queue [z] 2s *I \nwhere q = Queue (reverse 1s) [] But we could also implement Dequeue from First and Degueue ADs 82 Dequeue \nz q match (First z)@(Dequeue q)) The decision to implement an abstract data type opera\u00adtion either by \nusing a function or by an AD is not irrevoca\u00adble. For instance, if the Queue type had been defined only \nby using functions, we still could define ADs on top of them: 83 Empty match q, if isEmpty q w First \n(first q) match q, if not (isEmptg q) as Dequeue (dequeue q) match q, if not (isEmpty q) This example \nalso shows the possibility of adding guards in the definition of an AD. A value u matches an AD C having \na guard, if w matches the condition pattern of a rule of C and also its associated guard is satisfied. \nAs it happens to function definitions, a guard can use both the variables bound by the condition pattern \nand the auxiliary variables defined in the additional where clause. As another feature, we can also \ndefine functions on top of ADs: 86 isEmpty Empty = True v is Empty -= False w first (First x) = x w dequeue \n(Degueue q) = q These examples show that ADs can be defined and used anywhere in the program text. It \nis not required to associate an AD to the definition of a certain abstract data type, unless it uses \nthe representation. This freedom allows the programmer to create auxiliary ADs for solving a problem \nin the same way as he/she would create any needed auxiliary functions. To show the elegance of the code \nobtained by program\u00adming using ADs, we present a function which computes the breadth-first traversal \nof a binary tree: go data Tree cr = Empty Tree 91 I Node (Tree a) a (Tree a) 92 bmadthSearch :: Tree \na ~ [a] 9. breadthSearch t = loop (engueue empty t) 94 where 95 loop (First Empty Tree) @( Dequeue q) \n= 96 loop q 97 loop (First (Node tl a t2))@(Dequeue q) = 98 a : loop (enqueue (enqueue q tl) t2) 99 loop \nEmpty = []  Let us note that inside the First AD an algebraic pattern over bhmry trees appears. That \nmeans that ADs can be used in the same way like algebraic constructors to create patterns without any \nkind of restrictions. In Section 6 we will show how these patterns can be efficiently compiled. 3.3 \nTypes If we wish to integrate active destructors in a typed func\u00adtional language, it is important to \nknow the type assigned to them. If we consider Imaginary and Magnitude aa conven\u00adtional constructors, \ntheir type will be Real ~ Complex. On the one hand, this is a reasonable type, because if Imaginary is \napplied to a pattern of type Real, we obtain a pattern of type Complex. On the other hand, this is an \nerroneous type because Imaginary is not a function, so it cannot be used in the right hand side of an \nexpression to build a complex number. There exists another problem with typing: How can a user infer \nthe number of arguments of Imaginary from its type? In the case of usual constructors such as Cart or \nPole, there is no problem because their arities are equal to the number of arguments to which they must \nbe applied in order to obtain a non functional type. But this rule does not work for ADs because we could \ndefine ADs matching func\u00adtional values. For example, an AD Not defined as follows 100 Not match f, if \n-1(~ True) A (f False) matches all the functional values of type Bool + Bool be\u00adhaving aa the negation \nfunction. Because Not has no ar\u00adguments, its type is the same as that of the values which matches, that \nis, Not :: Bool ~ Bool. So, even though the types of Imaginary and Not have the same shape, the former \nhas an argument while the latter has no arguments. Therefore, we think that a new notation for the type \nof a destructor is needed. This notation must distinguish between destructors and functions and must \nmake explicit that a destructor must be totally applied to patterns in order to built a new pattern, \nthat is, it must contain ex\u00adplicit information about the arity of the pattern. The pro\u00adposed notation \nencloses the type between (), and replaces arrows by commas. Then, the type of Imaginary and Mag\u00adnit \nude would be (Real, Complex), while the type of Not is (Bool + Bool ). Note that our proposed notation \nclearly in\u00addicates that Imaginary has one argument, while Not has no arguments and matches functional \nvalues. Finally, the sig\u00adnature of the Queue abstract data type by using functions and active destructors \nwould be: 101 abstype Queue a 102 empty :: Queue a 103 enqueue :: Queue a ~ a + Queue u 104 First :: \n(a, Queue a) 105 Dequeue :: (Queue a, Queue a) and the type of the Dequeue AD would be 106 Dequeue :: \n(a, Queue a, Queue a) Once presented how to assign type to ADs, it seems nat\u00adural to write higher order \nfunctions manipulating ADs. Let us see an example. ADs wit bout arguments are equivalent to predicates \nwith one argument. For instance, in the Queue example we showed how the Empty AD and the isEmpty function \ncould be defined on top of each other. This kind of transformations can be generalized by using the following \npair of functions: ,07 pm?d.2Dest :: (cl+ Boo/)+ (a) me pmd,2Dest p = C 109 where C match z, if p z 110 \ndest2P~d :: (a)+ (a + Boo/) III dest2Pmd C = Ax + case x of 112 C+ True 113 + False These transformation \nschemes can be applied to the Not AD to obtain a predicate isNot 114 isNot = dest2Pred Not 3.4 Other \nExamples Sets constitute an important example of A DT. We have not used them in order to introduce ADs \nbecause its behavior is too symmetric constructor and access operations are dual to each other. Using \nADs, the specificaticm of these opera\u00adtions is: lIK abstype Set e 116 empt@ et :: Set a 117 addSet ::a+Setff~Setn \n118 Empt@et :: (Set a) 119 ChooseSet :: (cr, Set cr, Set a) The emptySet and addSet functions respectively \ncreate an empty set and add an element to a set, while Empt ySet is an AD matching only the empty set. \nThe ChooseSet AD mat ches sets having at least one element, and it returns any of the elements in the \nset together with the previous set with this element removed. It is important to note that Choos\u00adeSet \nis non deterministic, and so it cannot be equationally specified. Any valid implementation of this operation \nwill be deterministic but indeterminate. Care must be taken with functions using this operation. For \nexample, the map function over sets causes no problem: IZO mapSet f EmptySet = emptySet IZI mapSet f \n(ChooseSet e s) = 122 addSet (f e) (mapSet f s) We can also define a fold function over sets 123 fddset \n(@) a ~@!J.$e~ = a 124fdd$et (0) ~ ( choosese~ e s) = 125 e CB (foldSet (@) i s) But in this case, the \nbinary operation (6B) must verify and i must be a right neutral element of this operation. In fact, mapSet \ncan be defined from foldSet 126 mapset f = foldSet (addSet O f) emptyset because addSet o f and empt@et \nsatisfy the previous con\u00additions. As it happens with views, we could define some appar\u00adently strange \nconstructions using ADs. For example, the as patterns can be defined as: ,27 (@) :: (CT,fl, @) 128(x \n@ m) match x 3.5 Other facilities Modern functional programming languages usually have spe\u00adcial patterns \nto deal with predefine types. The patterns (n+ k), which allow to define recursive fi.mctions over the \nnatural numbers, are the most classical example. Its def\u00adinition, using the AD notation, is (please ignore \nthe type declaration until the end of the paragraph): MS (+) :: (Int, Int J, Int) 130(n + k) match m, \nif m~k 131 where n= m-k A natural number m matches (n + k) if m ~ k; in this case, n is bound to m k. \nObviously, the previous definition is in\u00adcorrect, because k behaves as an input parameter. But this is \nprecisely the main feature of this kind of patterns: they are a whole family of patterns, parameterized \nby an argu\u00adment. The extension of ADs in order to cope with this kind of definitions is easy: A compiler \ncan detect whether an ar\u00adgument is an input or an output one just by looking whether it has an associated \ndefinition in the condition pattern or in the where declaration. In this case, the variable n has a definition \nin the right hand side, while k has not. Thus, there are two input arguments (the implicit one matching \nm, and k) and an output argument: n. Now, we have to enhance the type notation to cope with this extension. \nIn order to do this, we will add J after the type of the input arguments. The type in code line 129 reflects \nthis extension. The possibility of defining this kind of patterns is impor\u00adtant. When the predefine (n \n+ k) patterns are combined with overloading mechanisms many problems appear (they are described in detail \nin [5]). A class system, where ADs could be members, solves these problems: 132 Class Num a where ,,3 \n(+), (-), (*), ....: @+ a + a 134 ... 135 (+), (-), (*), . ...: (a,~ $,~) 1S6 ... 137 ((m -k) + k) match \nm, if m2k 138 ... Let us note that the overloading of arithmetic operators both as functions and as ADs \nis easily solvable, because they are always used in different syntactic contexts. 4 Syntax and Semantics \nIn this section we formalize the abstract syntax and the semantics of programs using active destructors. \nIn order to achieve the first objective, we must define an abstract syntax for a small functional language \ntogether with some contextual restrictions, while for achieving the second one we must give a denotational \nsemantics assigning Patterns may not contain two occurrences of the same formal meaning to the terms \ngenerated by the abstract syn\u00ad tax. Even though this semantics will define our language as a lazy one, \nit is very easy to adapt it for an eager language. In fact, none of the needed modifications affects \nactive de\u00adstructors. Expression Active Pat tern e~v p+v [c Ic {p} la lab} 1el ez IPI @P2 l\\v-+e I e where \n~ Icaseeof pllej+e~ p.le~+e. Sequence of Declaration Declarations d+u=e I {a{e} match p, if e }>, Figure \n1. Abstract Syntax In Figure 1 we give the abstract syntax of a small func\u00adtional language including \nactive destructors and conditional expressions for pattern matching. We have not included the declaration \nof abstract and algebraic types, because they are not necessary for defining the semantics of active \ndestruc\u00adtors. We have four different syntactic domains: expressions, pat\u00ad terns, declarations, and sequences \nof declarations. We also will use objects belonging to three syntactic domains having an infinite number \nof symbols. In Figure 2 we show these domains, and the variables ranging over them. Domain Ranges over \nContents r v u,u, r vo, v~, . . . Variables c C,C , CO,CL,... Algebraic Constructors A a,a , ao, a~, \n. . . Active Destructors E e,e , eo, e~, . . . Expressions P Active Patterns P! P ?PO)P:! . . . D d,d \n, Dodd;,... Declaration 5 ~:t, d;, d~, . . . Sequence of Declarations Figure 2. Syntactic Domains We \nassume that the domains associated with algebraic construct ors and with active destructors are the disjoint \nin\u00adfinite union of subdomains c = LA>oco A = U,20A0. where the index of each sub domain denotes the ari \nty of the elements belonging to it. The CO sub domain contains the boolean values: False and True. We \nalso need the prede\u00ad fine constructors Fail ~ CO and OK, G C, (for all z z O) indicating the success \nor failure in mat thing an active de\u00ad structor. We will also need the following contextual restrictions: \nvariable (i.e. they must be linear). If c E C,, then c must be applied to i patterns in order to get \nanother pattern. The same restriction applies to active destructors a c A,.  A variable (or an active \ndestructor) symbol may not appear twice in the left hand side of a sequence of declarations.  For any \nmatch sequence of declarations belonging to the same active destructor definition, the name of this destmctor \nand its arity must be kept.  b The definition of an active destructor a E A, must be done by using i \noutput arguments. We will work with a unique semantic domain, named Val, which is recursively defined \nas follows: Va/= Func @CnstO@Cnstl @... Func = [Va/ + Va~L Cnsto = (Co)l Cnstl = (CI X Va~l Cnst~ = (CZ \nx Val x Val)~ ... The coalesced disjoint sum of domains, where the domains bottoms are coalesced into \nonly one is denoted by @; the disjoint product of domains, where a new bottom is added, is denoted by \nx; given a domain D, its lifted domain, where we add a new bottom, is denoted by DL. The Cnst, sub domains \nare lifted in order to distinguish between a totally undefined value and the value of a constructor applied \nto undefined vahres. This fact implies that the semantics of our language will be lazy. We also need \nthe semantic domain for declaration en\u00advironments, which allows us to assign a meaning to each variable \nand to each active destructor Enu= V+A--% Val This definition shows that active destructors have a mean\u00ading, \nwhile algebraic constructors have (almost ) direct repre\u00adsentati ves in the Val domain. The last semantic \ndomain we need is the subdomain of the boolean values Bool = { True, False, J-} c Cnsto. The expression \nx in Val will denote the inclusion m Val of an element x, belonging to any of the components of the coalesced \ndisjoint sum-(f&#38; example z c Fti;c). For each syntactic domain r shown in Figure 1, we define a semantic \nfunction transforming elements of r into elements of one of the semantic domains. V:E + Env+ Val D:D+ \nEnu+ Enu @:~ + Env -+ Env AP: P+ Env + Val+ Bool AE:P+ Enu+-Val-+Env The V function computes the value \nof an expression (its def\u00adinition is given in Figure 5). The V function produces an environment, having \na unique binding, from the definition of an element, while the ~ function is the generalization of D \narmlv :: Val + Val + Val .. . f x2, XI = fin Func in Val apply xl x2 = { J-, otherwise is; :: Val + \nBool True, X=(c, yl, . . . , yn) in Cnstn in Val False, Z=(c , yl, ..., gm) in Cnstn in Val is; x= A(c \n#c Vrn #n) { 1, otherwise sel~ :: Val * Val x:, Z=(c, zl, ..., x.) in CnsL in Val sel~ z= { &#38; otherwise \n+ ::Env + Env + Env v belongs to the pz domain (m* P2)(U) = :[;]:{ otherwise + :: Env+ Env+ Env P1 A \np2, PI and pZ are disjoint domains /31+/%2= ~ {, otherwise Figure 3. Auxiliary semantic functions to \na sequence of simultaneous declarations (their definitions are given in Figure 6). AP checks whether \na value matches an active pattern, while A&#38; computes the environment pro\u00adduced as a consequence of \nthe matching (tlhese functions are defined in Figure 4). Note that these two functions need an environment \nwhere the ADs appearing in the pattern are detined. These functions use some auxiliary functions which \nare defined in Figure 3. 5 Equational Reasoning As it has been previously commented, early proposals \ntry\u00ading to integrate pattern matching and abstract data types lacked good equational reasoning properties. \nThe reason for that was that they tried, in some sense, to do equational reasoning at the ADT implementation \nlevel, while users of an ADT should only assume its specification. The improved proposals [6] do not \nsuffer from this problem. Nevertheless, no general way to reason about the external behaviour of an ADT \nis given in those proposals. Algebraic specifications of abstract data types have been around for many \nyears, and there exists a consensus that they are an appropriate mean to inform a potential user about \nthe external behavior of a data typ,e without reveal\u00ading its implementation details. For instance, if \nwe wish to specify the b ehaviour of a FIFO queue, then the following equations will do the job: abstype \nQueue a degueue (engueue empty z) == empty is Empty q == False ~ dequeue (enqueue q z) == enqueue (dequeue \nq) z first (enqueue empty z) == x is Empty q == False + first (enqueue q z) == first q isEmpty empty \n== True isEmpty (engueue q z) == False Just to facilitate further reasoning, we have adopted a syn\u00adtax \naa close as possible to that of functional languages. How\u00adever, the symbol == has here a slightly different \nmean\u00ad AP[v]px = True AP[c pl 0.. pn]pz = is:(x) A APbl]PzI As*. A AP~.]w. where ~: = sel~ (z) AP[a PI \n. . .pn]~~ = APIOKn P1 . . .p~]p(apply p(a) Z) AP~1@p2]px = dP~&#38;z A A?TP21(Jz d~[u]pz = [z/v] At[c \nPI . . . Pn]pr = Af~I]wl + . . . + ~~bn]p~. where x, = sel~ (x) Af[a PI . . . pJpz = At[OK~ P1 . . .p.]p(apply \np(a) Z) At5~1@p2]px = A~~I]Pz + dcbzh Figure 4. Definitions of AP and A&#38; ing: tl== tzestablishes \na congruence between the pairs of terms which can be obtained by instantiating tland t2in all possible \nways. In particular, we have adopted a variant of algebraic sp edifications in which operations can be \npartial, equations can be conditional, and the symbol == is interpreted as existential equality. An equation \ns== s ~ t== t specifies that if (an instance of) s is well defined and (the corresponding instance of) \ns is con\u00adgruent to s, then (the corresponding instances of) tand t are well defined and they are congruent. \nA consequence of the theory underlying this specification style is that terms not explicitly mentioned \nin the conclusion of an equation are by default undefined. For instance, in the example above, ~$~e~~~ty) \nand (dequeue empty) are undefined. See [s, 15] The algebraic specification of a data type has two main \nuses: (1) it allows to reason about the correctness of func\u00adtions external to the data type; (2) it serves \nas a requirement that any valid implementation of the data type must satisfy. The first use is rather \nfamiliar to functional programmers, as it simply consists of equational reasoning. An equation of the \ndata type may be used as a rewriting rule, in either direction, as long as terms are well defined and \nthe premises of the equation are satisfied. We remark that the equations of an algebraic specification \nare axioms needed in order to prove any interesting theorem about the ADT. In [6] these properties are \ndiscovered in an ad-hoc way for a particular implementation of the set ADT. In the rest of this section \nwe adapt the algebraic speci\u00adfication notation to cope with ADs. When executing active patterns of the \nform A xl . . . z. appearing in the definition of functions external to the ADT, first, the value v we \nare trying to match is checked to determine whether the pattern is applicable or not; if this is the \ncase, a computation takes place over v, and variables Z1, ..., X. are bound to some values. At the abstract \nlevel, this can be expressed by using a notation similar to that used in code lines 83 85: A(oj v)... \n(o2 v) match v ~ GA v where GA is the abstract guard associated to the active de\u00adstructor A, and the \noh are the observer functions applied to the matched value v when the guard evaluates to True. Both GA \nand oh are ADT operations that must be algebraically specified in the usual way. In the Queue ADT ab.we \nwe VlvJp = p(v) V[a]p = p(a) V[c]p = c in Cnsto in Val, if (c C CO) V[c]p =~inFuncin Val, if(cECn, n>1) \nwhere ~(zl, . . ..zn) = (C, Xl, . . ..Zn) c Cnstn G Va/ V[el ez]p = apply (V[el]p)(V[e2]p) V[\\u + e]p \n= Az.V[e](p + [z/u]) V[e where @ = V[e](p + b[~]p) Figure 5. Definition of V D[u = e]p = [V[e]p/u] /v.case \nv of PI Ie! + (OKn e: ... e~) ae~ ... e? match pI, if e; D P=[f/al, where ~= V P ... ae~... e: match \npm, if e~ 1 [ pmleL~(OK.eA ...el) + Fail n [ fi[(dl , . . ..dn)]p=p+p where p =PI+ +P; Pt = D[d,](p \n+ P) { Figure 6. Definitions of D and ~ would write: case, where we assume q = enzp tg : jht (inv (enqueue \nempty z)) Empty match q ~ isEmpty q by unfolding inv with First (first q) match q @ -(isEmpty q) == \nwEmpty (enqueue empty x) == False Dequeue (dequeue q) match q ~ -(isEmpty q) jirst (enqueue (irav (dequeue \nq )) (first q )) where q == enqueue empty x . by applying the specification equations where the isEmpty, \nfirst and dequeue operations have been first (enqueue (inv empty) z) specified above. by unfolding inv \nwith == Let us assume that we have defined the inv operation zsEmpty empty == True reversing a queue, \nby using the active patterns Empty, First jirst (enqueue empty x) and Dequeue in the following way: .= \n by applying the specification equations z 139 inv :: Queue a ~ Queue a Now we proceed with the induction \nstep, where we assume 140 inv Empty = empty q # empty : 141 inv (First z)@(Dequeue q) = enqueue (inv \nq) x jirst (inv (engueue q x)) by unfolding inv, and by using == Now, we wish to prove the following \ninductive theorem: zsEmpty (engueue q x) == Fal.,e first (enqueue (inv g ) x ) first (in. (enqueue q \nz)) == z being q = dequeue (enqueue q z) and z = first (enqueue q x). Now, q # empty implies that q == \ndequeue (enqueur=, q x) is not empty (this is an easy equational theorem). Then, by The technique consists \nof performing matching at the ab\u00adapplying the following (ZJSO easy to prove) inductive theo\u00ad stract level, \nexpanding the definition of inv, and then apply\u00ading equational reasoning by using the specification equa-rem, \ntions and perhaps some auxiliary theorems in order to simplify the resulting expressions. First, we prove \nthe base (isEmpty q ) == False ~ (isEmpty (inv q )) == False and the theorem holds. first (engueue (irw \nq ) s ) == by equational reasoning first (irw q ) ==  by unfolding q first (inu (dequeue (enqueue q \nx))) == _ by equational reasoning, knowing that q # empty first (inu (enqueue (dequeue g) z)) == _ by \ninduction hypothesis knowing that (dequeue q) is smaller than q x 6 Compilation An important feature \nof pattern matching is the quality of the generated code. There have been several algorithms for pattern \nmatching compilation, featuring different char\u00adacteristics: with backtracking [4, 22], without backtrack\u00ading \n[7], and lazy ones, either with or without backtrack\u00ading [11, 16, 12]. So, it is important to investigate \nwhether it is possible the efficient compilation of lpat tern matching when active destructors are used. \nIn [14] there is a detailed study of ADs compilation by using two difl[erent techniques: in-line expansion \nof the condition pattern and by means of a projection function. Algorithms with and without back\u00adtracking \nwere presented for both techniques. The first one produces a code similar to the one that would be generated \nby a programmer if he/she had access to the implementa\u00adtion. Nevertheless, this technique cannot be applied \nif ADs are used as parameters of a function (Haskell classes, ML stmctures or higher order functions). \nFor this reason, we introduced a compilation technique using projection func\u00ad tions. Due to the complexities \ninvolved in these techniques, we are going to describe only the in-line compilation technique by means \nof an example. The basic technique using projec\u00adtion functions is also described in [1] for AVCS together \nwith some optimizations. In [14] new optimizatilons are described in order to avoid the repeated evaluation \nof the same pro\u00adjection function. These optimizations are very important in our proposal: while the projection \nfunction of an AVC only performs trivial computations, the projection function of an AD can perform time \nconsuming ones. 6.1 In-Line Expansion As usual, patterns are compiled by transfimming them into a group \nof nested case expressions over simple pat t ems, i.e. construct ors applied to variables. This prc~cess \nis performed by a function called C receiving aa arguments the three im\u00adportant components of a function \ndefined by pattern match\u00ading a vector of variables, a matrix of patterns m and a vec\u00adtor of expressions \ne. For example, the code generated for the hop function (defined in code lines 95 through 99) is: loop= \n\\al + (First Empty Tree) @( Deguetile q) el C((al), (Fir9t (Node tlE;~/J@(Degueue q) , e, ) e3 where \ne 1, ez, e3 are the right hand expressions of the rules defining loop. The C function is recursively \ndefined by cases [ H) according to the shape of the patterns matrix. In the follow\u00ading, we concentrate \non the compilation of patterna defined using ADs. Before compiling a pattern, the rules detinhg ADs must \nbe split into two parts: the condition pattern, and the rest of the code computing the output arguments \n(the partial projection functions). In the queue example we obtain the following condition patterns: \nEmpty = Queue [] [] First = Queue (_: _) _ Dequeuel = Queue (-: -: -) _ Degueu# = Queue [-] _ and the \nfollowing partial pro jection functions: empt~ (Queue [] []) = () jirs$ (Queue (z : -) -)=x degueue (Queue \n(-: (@ (_: -))) 1s) = (Queue fs 1s) cfegueue2 (Queue [-] 1s) = (Queue (reverse h) []) Let us note that \n(1) all variables appearing in the condition patterns are anonymous and that (2) every partial projec\u00adtion \nfunction will be called only when the corresponding argument haa matched the pattern, so they can be \ncompiled without needing to perform the matching or to fail. Once ADs have been translated, we can perform \none more transformation step of the C function. We decompose the matrix m into two parts: the sequence \nof ADs appearing in each pattern mA and the sequence of patterns appearing in their output arguments \nm P: (First, Dequeue) mA = (Fir($~:~ue) [ 1 [ (( Empty Tree), (q)) mp = ((Node t~(; tz), (q)) 1 The \nnext step consists of replacing in mA each sequence of ADs by the conjunction of their condition patterns. \nA%ile Empty and First have only a defining rule, Dequeue has two. This fact gives rise to the duplication \nof the firat two rows of mA, mp and e. Each pattern of mp is associated to the corresponding partial \nprojection function. After these ma\u00adnipulations, and aft er the simplification of the mA patterns conjunctions, \nthe matrices are Queue (-: (_: _)) Queue [-] _ mA = Queue (-: (-: -)) Queue [-] - I Queue [] [] ((firs&#38;, \n(EmptyTree)), (dequeue , (q))) ((jhd, (Emptgl%e)), (dequeue2, (q))) mp = ((jirs?, (Node t, a tz)), (dequeuel, \n(q))) ((fir$~, (Node t, a t,)), (dequeu#, (q!)) I () The computation carries on by using a new function \nC hav\u00ading ss arguments (al), mA, rnp, (), (), e. The C function is expanded taking into account the shape \nof ?7?A (in our ex\u00adample, only constructors appear). Because the same pattern 4 = c (()] 01(())7(~I)t \n01 (e3)) ((first ,(JhaptyTree)), (dewed, (q)))  e;= (()(), ((jr,?, (Node t, a t,)), (dequeu~( q))) \n[ ((fir$$, (EmptyTree)), (dequeue , (q))) e~ = c (() () {(fir$$, (Node t, a t,)), (deque~e , (9))) [ \nFigure 7. Leaves of C appears several times, the resulting expansion is a verY small matchin~ m-ocess. \nWith respect to the latest version of case s tree views [61 ADs do not restrict-the type of patterns \nthat can be used while defining a function by pattern matching. Our 142 C=e ffl of patterns are independent \nof each other and they are not 1,3 (Queue CYZas) ~ bundled in any way. In general, it is easy to see \nthat all 144 case cr2 of the deterministic patterns which can be expressed by using 145 [] + casea,of \ncomplex pattern languages aa those defined in [8] or in [17], 146 can be defined in terms of ADs. 147 \n+ MATCHING ER.ROR We have also shown how to integrate the algebraic speci\u00ad148 (a~:as) +-case aE, of fication \ntechniques developed for abstract data types during 149 [] + ej the 70 s and the 80 s into the equational \nreasoning process 150 (-:-) + e: about functional programs using active patterns. In a pre\u00ad vious paper \n[13] we showed how to formally verify that a where the cti are fresh variables. This tree has four leaves. \nfunctional implementation of an ADT satisfies an algebraic One of them is a failing branch, but it never \nwill be taken specification. We believe that the attempts to integrate the because of the queue invariant. \nThe other three leaves have results of the functional and the algebraic specifications com\u00adcalls to the \nC function as it is shown in Figure 7. The e{ munities can be very profitable for both. expansion is \ntrivial, and it produces es. But in order to Finally, we have introduced two new features: the capa\u00adexpand \nej or ej, it is necessary to perform mat thing over bility of defining non algebraic patterns as the \n(n+k) pat\u00adthe ouput values of the ADs, that is, over the result of the terns and a type system for ADs. \nThis type system allows to evaluation of the corresponding partial projection function. treat patterns \nas first class citizens. As it is claimed in [18] After performing these evaluations, the recursive expansion \nfor a concurrent functional language, a special type is the goes on by using the C function. Now we show \nthe result of first step in order to get abstraction in a certain part of a the ej expansion (the ej \nexpansion is very similar): language. Acknowledgments 152 CY7 = dequeue2 al We would like to thank Narciso \nMartLOliet and Cordula 53 n C((@ a7) (Node tl a tz) ~ e2 ) Wohlmuther for their help while preparing \nthe final version Empt yTree el [ 1[1 of this paper. The rest of the expansion only concerns constructors, \nand it is solved by means of usual techniques. In Figure 8, we References present the resulting final \ncode. [1] William E. Aitken and John H. Reppy. Abstract data 7 Conclusions construct ors. In Proceedings \nACM SIGPLAN Work\u00ad shop on ML and its Applications, pages 1 11, 1992. We have presented active patterns, \na construction smoothly [2] A. W. Appel and D. B. MacQueen. A standard ML integrating pattern mat thing \nwith abstract data types. We compiler. In Functional Programming Languages and have illustrated its use \nand its semantics by means of some Computer Architecture 87, LNCS .274, pages 301-324, simple examples, \nand we have also given a sketch of a pos\u00ad1987. sible svntax and we have defined a denotational semantics \nfor thins syntax. We have shown how to reason about the [3] Egidlo Astesiano and Maura Cerioli. On the \nexistence programs containing thk facility, and we have given some of initial models for partial (higher \norder) conditional guidelines about their efficient compilation. specifications. In TAPSOFT 89, LNCS \n351, pages 74 The previous proposals reviewed in this paper have also 88, 1989. worked on these points, \nbut comparatively, we think that active destructors have more expressive power and less prob-[4] Lennard \nAugutsson. Compiling pattern matching. In lems than these proposals. For example, abstract value con-Functional \nProgramming Languages and Computer Ar\u00adstructors [1] are the particular case of ADs in which patterns \nchitecture 85, LNCS ,201, pages 368 381, 1985. simply select some representation components and do not \n[5] Emery Berger. FP + 00P = Haskell, 1991. perform any computation. With respect to laws [19], the \nmain difference is that ADs allow the programmer to choose [6] F. Warren Burton and Robert D. Cameron. \nPattern any representation for the ADT. This choice is severely lim-matching with abstract data t yp \nes. Journal of Func\u00adited for laws. Also, ADs can do computations during the tional Progmmming, 3(2):171 \n-190, 1993. case CYIof Queue ctz CY3 + case CV2 of [] + cas~l a: y; (.:.) + MATCHING ERROR (a~:as) + \ncase as of [] + let a, = first a, cr? = dequeu~ al in case ~G of Ernpt~Tree -+ loop cw Node @s w a10 \n+ cY9 : bop (enqueue (enqueue CY7 as) crlo) (@:@,) > let ~S = fird @~ Crg = dequeuel CII in case Ck3 \nof EmptyTree + loop CW Node CX1Oall alz + crll : loop (engueue (enqueue CM CIIO) 1212) Figure 8. Compiled \ncode of breadthSearch [7] [8] [9] [10] [11] [12] [13] [14] [15] Albert Grti. Left-to-right tree pattern \nmatching. In Jth Rewriting Techniques and Applications, LNCS J88, pages 323-334, 1991. Reinhold Heckmann. \nA functional language for the sp edification of complex tree transformation. In ESOP 88, LNCS 900, pages \n175-190, 1988. P. Hudak, P. Wadler, Arvind, B. Boutel, J. Fair\u00adburn, J. Faael, K. Hammond, J. Hughes, \nT. Johnson, D. Kieburtz, R. Nikhil, S. Peyton Jones, M. Reeve, D. Wise, and J. Young. Report on the program\u00adming \nlanguage Haakell: A non-strict purely func\u00adtional language (version 1.0). Technical Report YALEU/DCS/RR777, \nYale University, Deparment of Computer Science, 1990. Paul Hudak, Simon Peyton Jones, and Philip Wadler. \nReport on the functional programming language Haskell, version 1.2. SIGPLAN Notices, 27(5):1-154, 1992. \nAlain Laville. Implementation of lazy pattern matching algorithms. In ESOP 88, LNCS 300, pages 298-316, \n1988. Luc Maranget. Two techniques for compiling lazy pat\u00adtern matching. Technical Report RR- 2385, INRIA, \nOc\u00adtober 1994. Manuel Ntifiez, Pedro Palao Gostanza, and Ricardo Peiia. A second year course on data \nstructures based on functional programming. In Functional Program\u00ad ming Languages in Education, LNCS \n10.22?, pages 65 84, 1995. Pedro Palao Gostanza. Integraci6n de ajuste de pa\u00adtrones y tipos abstracts \nde dates, Technical Report DIA-UCM 16/94, Dept. Infornuitica y Autom&#38;ica, Universidad Complutense \nde Madrid, 1994. In Span\u00adi8h. Rlcardo Peiia. Diseiio de Progmmas. Prentice Hall, 1993. In Spanish. [16] \nLaurence Puel and Asc&#38;nder Suiftrez. Compiling pat\u00adtern matching by term decomposition. In Proceedings \nACM Conference on LISP and Functional Program\u00adming, pages 273-281, 1990. [17] Christian Queinnec, Compilation \nof non-linear, second order patterns on S-expressions. In PLILP 90, LNCS 456, pages 340-357, 1990. [18] \nJohn Reppy. A higher-order concurrent language. In Proceedings SIGPLAN 91, pages 294-305, 1991. [19] \nSimon Thompson. Laws in Miranda. In Proceedings ACM Conference on LISP and Functional Program\u00adming, pages \n1 12, 1986. [20] Simon Thompson. Lawful functions and program verif\u00adication in Miranda. Science of Computer \nProgramming, 13(2-3):181-218, 1990. [21] David A. Turner. An overwiew of Miranda. In David A. Tirrner, \neditor, Research Topics in Functional Program\u00adming. Addison Wesley, 1990. [22] Philip Wadler. Efficient \ncompilation of pattern match\u00ading. In S.L. Peyton Jones, editor, The Implementation of Functional Programming \nLanguages, chapter 5. Pren\u00adtice Hall International, 1987. [23] Philip Wadler. Views: A way for pattern \nraa~ching to cohabit with data abstraction. In Proceedings lJth Principles of Programming Languages, \npages 307-313, 1987. \n\t\t\t", "proc_id": "232627", "abstract": "In this paper we present a construction smoothly integrating pattern matching with abstract data types. We review some previous proposals [19, 23, 20, 6, 1] and their drawbacks, and show how our proposal can solve them. In particular we pay attention to equational reasoning about programs containing this new facility. We also give its formal syntax and semantics, as well as some guidelines in order to compile the construction efficiently.", "authors": [{"name": "Pedro Palao Gostanza", "author_profile_id": "81100054456", "affiliation": "Departamento de Inform&#225;tica y Autom&#225;tica, Universidad Complutense de Madrid, Spain", "person_id": "P222931", "email_address": "", "orcid_id": ""}, {"name": "Ricardo Pe&#241;a", "author_profile_id": "81100188613", "affiliation": "Departamento de Inform&#225;tica y Autom&#225;tica, Universidad Complutense de Madrid, Spain", "person_id": "PP31092312", "email_address": "", "orcid_id": ""}, {"name": "Manuel N&#250;&#241;ez", "author_profile_id": "81100250049", "affiliation": "Departamento de Inform&#225;tica y Autom&#225;tica, Universidad Complutense de Madrid, Spain", "person_id": "PP35045719", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/232627.232641", "year": "1996", "article_id": "232641", "conference": "ICFP", "title": "A new look at pattern matching in abstract data types", "url": "http://dl.acm.org/citation.cfm?id=232641"}