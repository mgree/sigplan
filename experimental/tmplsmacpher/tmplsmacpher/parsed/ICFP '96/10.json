{"article_publication_date": "06-15-1996", "fulltext": "\n Inductive, Conductive, and Pointed Types Brian T. Howard Department of Computer and Information Sciences \nKansas State University bhoward@cis. ksu. edu Abstract An extension of the simply-typed lambda calculus \nis pre\u00adsented which contains both well-structured inductive and conductive types, and which also identifies \na class of types for which general recursion is possible. The motivations for this work are certain natural \nconstructions in category the\u00adory, in particular the notion of an algebraically bounded functor, due \nto Freyd. We propose that this is a particu\u00ad larly elegant core language in which to work with recursive \nobjects, since the potential for general recursion is contained in a single operator which interacts \nwell with the facilities for bounded iteration and coiteration. Introduction In designing typed languages \nthat include recursion, there has long been a tension between the structure provided by types based on \nwell-founded induction and the freedom per\u00admitted by types based on general recursion. Very few lan\u00adguages \noutside of purely theoretical studies have chosen a strictly inductive system (one exception is charity \n[CF92]), partly because the logical price to be paid for ensuring that all recursion is well-founded \nis the necessity that all com\u00adputations terminate, hence the language cannot be Turing\u00adequivalent. On \nthe other hand, the prevalence of inductively defined structures in computer science makes it natural \nto structure many algorithms in terms of iteration over ele\u00adments of an inductive datatype. This natural \nstructure is lost in common programming languages, where iteration is at best a syntactic sugaring for \nan application of a fixpoint operator. In this paper we present an,extension of the simply-typed lambda \ncalculus with inductive types which also allows gen\u00aderal recursion in a controlled manner, thus preserving \nmany of the benefits of well-founded structural induction in a Turing-equivalent language. There are \ntwo key ideas which permit this: In addition to inductive types and iteration over their elements, we \nalso consider the dual notion, the cond\u00aductive types, along with their associated natural oP\u00ad eration \nof coiteration. Permission to make digitalhard copy of part or all of this work for personal or clsssroom \nuse is ranted wimout fee provided that mpies are not made or distributed for pro I t or mmmeroial advantage, \nthe copyright notioe, me title of the publication and its date appear, and notice is given mat copying \nis by permission of ACM, Inc. To copy otherwise, to republish, to past on servats, or to redistribute \nto lists, requires prior specific permission andlor a fee. ICFP 96 !396 PA, USA @ 1996 ACM 0-69791-771 \n-OAWOO05...$505O All the potential for unbounded recursion in the lan\u00adguage is confined to a subset of \nthe types which are syntactically identified as pointed a generalization of the standard notion of a \nlifted type, along the lines of Moggi s computation types. General recursion over pointed types follows \nfrom adding a function which forces evaluation of an element of a pointed conduct\u00adive type, either producing \na value of the corresponding inductive type or failing to terminate. All of the components of the language \nare motivated by con\u00adstructions in category theory. This reflects our belief that the language of categories \ncan be a useful source of inspi\u00adration and guidance in the design of programming language features. Our \ngoal is to apply several recent results and trends in category theory to issues in practical language \nde\u00adsign, producing an elegant, powerful base language with the full natural structure afforded by inductive \nand conductive types. This structure is well-behaved with respect to a pow\u00aderful set of equational reasoning \nprinciples, ensuring that many useful program transformations will be sound. As an example of a program \nwritten in this language, consider first the following term jibs, of the conductive type vt.(1+ nat x \nt) L (which may be thought of as a type of streams of natural numbers. The details of the language will \nbe presented in Section 2; we will use a minor amount of syntactic sugaring which will not be discussed \nfurther): jibs = gen(~(m, n). [,z(rn, (n, m + n))j)(l, 1) This generates the stream 1,1,2,3,5, . . . \nof Fibonacci num\u00adbers by coiteration; no non-termination is yet involved, be\u00adcause it only generates \nsuccessive numbers in the stream on demand. Now consider the related inductive type pt.(1 + nat x t) \nI, which is essentially a type of finite lists of natural numbers (the purpose of the lifting will be \nexplained in a moment ). A reasonable function defied by iteration over this type is head Up to, which \nwhen given a natural number k will take a list and return the longest prefix consisting entirely of numbers \nless than k: headUpto = M. it(~lxj. case z of LIO: nil LZ(n,l): if n < k then cons(n, 1) else nil), \nwhere nd and cons (n, 1) are abbreviations for fold[~10] and ~oki l~z (n, l)j, respectively. Again, this \nis a perfectly well\u00adfounded operation, because all lists of the inductive type are finite. If we wish \nto use this function to find the list of all Fibonacci numbers less than 100, we must first force jibs \nfrom a stream into a list; it is this action of observ\u00ading the value of a conductive object which introduces \nthe only possible source of non-termination in the language, and the only reason it is allowed in this \nprogram is that we made an explicit provision for it with the lifting operator ~, creating a pointed \ntype. The correct function applica\u00adtion is thus head Up to 100 (force jibs); with an appropriate reduction \nstrategy (which only needs tc) be lazy in apply\u00ading the force function), this evaluates to the desired \nlist (1, 1,2,3,5,8,13,21,34,55, 89). The above solution is natu\u00adral and elegant, and would not have been \nnearly so easy to produce in a strictly iterative style. On the other hand, a solution using the standard \nmachinery of fixpoint operators would have obscured or overpowered the intuitive construc\u00ad tion of the \niterative and coiterative pieces of the computa\u00ad tion. 1.1 Related work A preliminary attempt was made \nin the author s PhD thesis [How92] (see also [How93]) to reconcile inductive types with types for general \nrecursion. The solution there was to in\u00adtroduce two different kinds of recursive type, corresponding \nto the choice between induction and recursion. This sy5 tern did not provide a close integration of the \ntwo kinds of recursive type, and suffered from a reliance on the heavy machinery of fixpoint induction \nfor reasoning about terms involving general recursion. Following recent work by Freyd and others on algebraic \ncompactness [Fre90, Fre91, Fre92, Bar92, Sim92, Fio94], the more elegant solution presented in this paper \nwas developed. In brief, Freyd showed how to reduce the problem of finding solutions for general recursive \ndomain equations to that of buildlng inductive types, provided the functors involved are algebraically \nbounded, i.e., the inductive and conductive types are canonically isomorphic. By syntactically identi\u00adfying \na class of type expressions which will correspond in a model to algebraically bounded functors, we may \napply this construction to develop a programming language which accounts for general recursive functions \nwhile only dealing with inductive (and conductive) types. In spirit, this work also follows in the footsteps \nof Crole and Pit ts [CP92], who present a met alanguage which ac\u00adcounts for general recursion by obtaining \na jirpoint object which allows unbounded iteration under control of Moggi s computation type (see also \n[Mog95] for recent work of Moggi along similar lines). Independently, Launchbury and Paterson [LP95] \nhave developed a type system similar to that described here to keep track of values which may be unboxed \nin the imple\u00admentation of a lazy functional language. Their notion of a pointed type (which must be boxed) \nexactly corresponds with ours except they only allow recursive types which are pointed. It is difficult \nto see how a value of one of our un\u00adpointed inductive types could usefully be unboxed in gen\u00aderal; however, \nit is interesting to note that a natural unboxed representation of the type pt.1 + char x t is exactly \nthe tra\u00additional null-terminated string used in C. 1.2 Structure of the paper In Section 2 we present \nthe details of our proposed lan\u00ad guage and its categorical motivations: fist a basic language with functions, \nsums, and products is described, then in\u00adductive, conductive, and pointed types are added in turn. The \nmajor novelty of the language is the system of pointed types and the explicit forcing operation they \npermit -this is described in section 2.1. Following this are two sections of examples and comparisons \nto related work: a fixpoint combinator over pointed types is constructed in Section 3, based on the fixpoint \nobject of Crole and Pitts [CP92]; then Freyd s construction of recursive types from inductive types [Fre90] \nis applied in Section 4 to provide universal types for call-by-value and call-by-name versions of the \nuntyped lambda calculus; and finally, in Section 5, we compare our system to several recent proposals \nadvocating a categorical style of program construction and manipulation based on iteration and coiteration \n[MFP91, FM91, Mei92, Kie93]. 2 The language AP L Figure 1 presents a convenient formulation of the syntax \nof our base language with finite sums and products. As usual, a typing judgment r D M: a means that the \nterm M has type u, given the context 17 (a list of free variables and their types). Figure 2 lists the \naxioms governing these terms; they are derived from the equations which hold among the cor\u00adresponding \narrows in a closed category with finite products and coproducts. Observe that the term metavariables \nM, N ,. ... are restricted to range over only terms of the ap\u00adpropriate type (so that, for example, the \naxiom (lq) does not imply that ali terms are equal to O, but only all terms of type 1). In association \nwith standard rules about equal\u00adity and substitution, these axioms provide an equational se\u00admantics. \nA non-deterministic operational semantics for the language may be obtained by directing the /3 axioms \nfrom left to right. For more details about this system and the relation between its equational and operational \nsemantics, consult [How92]; related systems are considered many places in the literature, for example \n[GLT89, LS86, Mit90]. In a standard way, we may interpret a type expression a containing a free type \nvariable t as a functo~ that is, it provides a map from types to types by substitution for t, and it \nmay be extended to a map on terms of function type (because the intended model of this language is a \ncartesian closed category, we will feel free to abuse the distinction between arrows and elements of \nan exponential object, and to switch between external and internal views of functors). For example, if \nu = 1 + t,then as a functor it maps the type ~to 1+ Tand it maps aterm M of type ~+ wto the term [Az: \nl.~~+ O,Ag: ~.~j+ (My)] of type 1 + ~ ~ 1 + V. When talking about a as a functor, we will find it convenient \nto name these maps Fa, or simply F; thus, we would write F(7-) = 1 + r and F (M) = [kc. LI o, h. L2(MY)] \n(dropping type annotations for brevity). A solution to the recursive type equation t = u is a type T \nsuch that there is an isomorphism between ~ and F(T), i.e., r is a fixpoint of F. A well-known technique \nfor finding a fixpoint, attributed to Lambek, is to consider the category of F-algebras, whose objects \nare (in our case) functions of type F(v) + v, for any type v; given F-algebras ~: F(r) + r and g: F(v) \n+ v, an arrow from $ to g is a function h of type T + v such that the following diagram commutes: (oE) \nrb@:O~U I b M:u-+u rDN:rBv (+E) rb[M,N]:a+7~v Figure 1: Syntax of the basic language (+ /3) (Az: a. \nM)N = {N/x}M (Xr: o. Mz) = M, x not free in M (+ q) M = O (lq)(xPI) m(M, f V) = M (x@,) T,(M, N) = N \nM = (7r1M,7rzM) (Xq) M= O (Oq) (+PI) [M, N](~:+ P) = MP M = [Xc: a. M($+rz), ~y: ~. M(~~+ y)], (+v) \nx and y not free in M (+P2) [M, N](~j+ F ) = NP Figure 2: Axioms of the basic language F(h) f: r + v, \nthere is no general way to produce a function ofF(T) F(v) I I type (~-+ a) ~ (v ~ a) (consider u= ~= \nOand v= 1, and note that the existence of a function of type 1 ~ O leads f 9 to inconsistency). This \ncontravariance in the first argument of ~ leads us to restrict the types a for which we can find r v \nfixpoints to those in which t occurs only positively, that is, h to the left of an even number of function \narrows. The terms and proof rules corresponding to these least If ~: F(r) a r is an initial object in \nthis category, then in and greatest fixpoint types (which are commonly called in\u00ad fact r is a fixpoint \nof F, and ~ is the desired isomorphism. ductive and coirzductive types, respectively) are given in Fig-If \ng: F(u) ~ u is the isomorphism for any other fixpoint w ure 3. For pF, the term foldP~ is (the isomorphism \nof) of F, then the initiality of f implies that the arrow h in the the initial F-algebra, and the application \nit~~ M produces above diagram gives a unique way to map r into u; in this the unique F-algebra morphism \nfrom foldw~ to the given respect, ~ is the least fixpoint of F. function M. Dually, unfoidv~ is the terminal \nF-coalgebra, A dual solution to t= a may be found by taking a termi\u00ad and genur M produces the unique \nmorphism from M to nal object in the category of F-coalgebras, which are simply Urlfoidv ~ . functions \nof type v j F(v). Reversing all the arrows in The language described to this point is called AW in the \nabove diagram, if ~: 7 +-F(7) is such a terminal object, [How92]; it is shown there that the reduction \nrules for this then T is the greatest fixpoint of F. language are confluent and strongly normalizing, \nhence only If we extend our assumptions about the category under\u00adtotal functions may be computed. In \nfact, the class of to\u00ad lying JP l to suppose that at least every F which corre\u00adtal functions expressible \nin APV is quite large, containing sponds to a type expression u has both least and greatest precisely \nthose functions provably total in the logic ID<W, fixpoints (that is, it is algebraically complete and \ncocomplete in a relevant sense), then we may augment the language to 1For efficiency s sake, we should \nalso add terms and axioms providing explicit inverses to foldfl ~ and unjotdvF; although include these \nfixpoints as the types pt. u and vt.u,respec\u00ad it~~ F(.foldPF ) (and dually genuF F(unfoldvF )) has the \nr]ght be\u00ad tively, which we will frequently write as pF and uF. An havior, it works in time proportional \nto the size of its argument in\u00adimportant point to note is that the type expression t ~ a stead of constant \ntime. This is related to the well-known hnear -time does not produce a (covariant) functor-given a function \npredecessor problem, P(foldPF N) = M(F(P)N) ~pq) (P@ i% M(WPF ~) = M(F(it.F ~)~) P = itwFM (vO) un~oldVF(genVF \nM N) = F(genvF M)(MN) nfo~~ ;(::jn;:g)(M~) (Vq) F@re 3: Syntax and axioms/inference rules for inductive \nand conductive types which is first order arithmetic augmented by tinitely-iterat ed inductive definitions \n(see [BFPS81] for details about this logic; the relation to APV wsa presented in ~ow94]2). This almost \ncertainly contains every total function that would ever be needed for practical purposes, as it contains \nat an early stage every function bounded by Ackerrnann s noto\u00ad riously fast-growing function. However, \nfrom a theoretical viewpoint this is nowhere near the class of all computable functions (and as long \nas all computations are terminating it can never hope to cover the entire class, because to do so would \nsolve the Halting Problem), and from a practical viewpoint the proof of expressibility y of i~y total \nfunction bounded by some fast-growing function does not lead to an efficient program, since the result \nwill have the running time of the bounding function! 2.1 Contravariance and pointed types The usual Smyth-Plotkin \nconstruction of fixpoints of mixed\u00advariant fimctors in categories enriched with an order struc\u00adture [SP82] \nreveals a coincidence between least and greatest fixpoints. Recent work of Freyd [Fke90, Fre91, Fre92] \nshows that this coincidence is the essential property needed to han\u00adclle contravariance. Specifically, \nall that is needed to con\u00adstruct a fixed point for a contravariant endofimct or F is to show that the \ncovariant functor F= is algebraically bounded, meaning that it has both an initial algebra and a termi\u00adnal \ncoalgebra, and they are canonically isomorphic. Conse\u00adquently, the only addition needed to AK to allow \nthe repre\u00adsent ation of fixpoints of contravariant funct ors is a function expressing this isomorphism. \nWe do not want to assert that all corresponding least and greatest fixpoints are isomorphic; for instance, \nif there were any function from wt. t to @. tthen all terms of any given type would be provably equal \n(given that we desire categori\u00adcal finite sums aa well aa cartesian closure). Following Simp\u00adson [Sim92], \nwe will identify the algebraically bounded func\u00adtors by considering a faithful commutative strong monad \nwhose functor T is algebraically bounded. Call a type T pointed if it is the underlying object of an \nEilenberg-Moore T-algebra, i.e., if there is a retraction P.: T(7) ~ ~ for the tit q.: T + T(r) such \nthat P7 o T(p7) = p. o I.+, where pr: T= (T) + T(r) is the monad multiplication. Say that a 2An interesting \nfeature of this correspondence is that conductive types and non-strictly-positive inductive types (where \nt occurs to the left of a function arrow) do not add to the expressiveness-sl] com\u00adputations over these \ntypes may be coded up using a family of ordinal notations described by strictly-positive inductive types. \nfunctor F is pointed if F(T) is pointed for any r, and say that it is conditionally pointed if F (7) \nis pointed whenever T is; then we have the following proposition: Proposition 1 For any interpretation \nof ~~ ~ in a carte. sian closed categorg with finite sums, least and greatest fix\u00adpoints for all relevant \nendofuractors, and a monad as de\u00adscribed above: 1. If u and T are pointed types, and u is an arbitrary \ntype, then 1, Tv, u x r, and v + r are all pointed types. 2. If F is conditionall~ pointed, then VF \nis pointed. 3. If F is pointed, then pF and VF are canonically iso\u00admorphic [and pointed).  Since the \nmotivating example is the category of predo\u00admains and total functions, with the standard lifting monad \nidentifying the pointed objects as the domains,3 we will write ~1 for the type T(T). The corresponding \nadditions to the terms and proof rules are given in Figure 4. The lift [MJ corresponds to an application \nof the unit, while the pointed abstraction A lx: aJ. M corresponds to applying the functor T to the function \nk. M: a + ~ and post-composing with the retract from TL to T. These generalize the simi\u00adlar constructions \nin Moggi s computational lambda calculus [Mog89] in two ways: We include the total function space constructor \nas well aa the Kleisli exponential; this is consistent with our other type construct ors because we only \nallow general recursion on pointed types (see below).  As a result, the body of the pointed abstraction \nmay be of any pointed type, not just a computation type T(r).  The term forceP~ gives the promised isomorpbism \nfrom VF to pF (there is always a morphism in the other direction, described by it&#38;F unfold~~ or, \nequivalently, genv~ fo~djj); the axiom (vp,B) simply expresses the fact that it is an F\u00ad(co)algebra morphism. \nThe intuition for calling this func\u00ad tion force is that it provides the interface between the nat\u00adurally \nlazy conductive type VF and the more concrete, ob\u00adservable (at least to the extent that other components \nof 3This is not quite correct; to avoid cardimdity problems with types such m pt.(t+ bool) + bool, where \nboot 5 1+ 1, we need to work in an effective version of domains. An appropriate category of PEl%n should \nwork fine. (JJ3) (A[x: a]. A4)liVj = {iV/z}A4 (vp,B) fomeP~ M = foldW~(F(forceP~ )(unfoidv~ M)) Figure \n4: Syntax and axioms for pointed types F are observable types such as products or sums) inductive type \n@, coercing one to the other perhaps at the expense of non-termination if an attempt is made to force \nevaluation of an infinit e element. 2.2 Properties of reduction For reference, we collect the reduction \nrules for ~~ ~ in Fig\u00adure 5. Using standard results about such reduction systems (see [KI080, How92]) \nit is easy to prove that reduction is confluent and that a lazy reduction strategy (i. e., outer\u00admost \nreduction of the principal subt erm of each elimination operator, reducing force only when it is the \nargument of an iteration) is normalizing. In fact, since the reduction system without (u,u,B) is strongly \nnormalizing, the only op\u00aderator that needs to be t rested lazily is force. If we identify the class of \nobservable types as those which do not contain ~, v, or 1 (intuitively, these are the types whose values \nmay be printed out ), then a reasonable def\u00adinition of observational equivalence says that two terms \nare equivalent if they have the same result (normal form or non\u00adtermination) under lazy reduction in \nall closed contexts of observable or lifted observable type, with the proviso that we do not distinguish \nvalues of types isomorphic to 1 (since these are the only types which may be both observable and pointed). \nWe conjecture that all of the equational rules listed above (in particular, all of the (q)-rules) are \nsound with respect to this observational equivalence, therefore any program transformation justified \nby these rules will also be sound. The restriction to observable and lifted observ\u00adable types is not \nharsh: taking the example of the head- Upto function of the Introduction, which produced values of type \n~t.(1 + nut x ~)J_, we may easily convert such values into lifted lists, (pt.1 + nut x t)l, by applying \nthe function it(~ [z]. [}oki Similar observation functions pt.l+natxt xl). may be defined for all types \nnot containing -+ by applying Muh-y s notion of the lifting of a functor [Mu193]. 3 A fixpoint object \nIn [CP92], a jirpoirat object for a monad (T, q, p) is defined to be a structure (Q, g, w), where <: \nTQ + Q is an initial T-algebra and w: 1 G TO picks out the unique fixpoint of the arrow qn 0<: Tfl -+ \nTfl. This is used as the basis for a logical system for reasoning about fixpoint computations. For example, \ngiven a fixpoint object for T, they construct a fixpoint combinator for any type of the form a a T,tJ. \nIn AP l, we may find a fixpoint object for any monad (T, q, p) such that pT is pointed. The type Cl is \njust pT, and < is joldn. We may construct w by first coiterating the T\u00adcoalgebra VI: 1 ~ T1 to obtain \nthe function gen.~ VI: 1 -+ vT, and then applying it to the seed O and forcing the re\u00adsult over to Q: \nforcen (genv~ ~1 O). This gives an ~ infinite element in Q; call it co. The desired global object w is \nthen just w ~ (k 1. [coj). For the special case T(7) = ~L, where q. is (k: ~. lx~ ) (and p. is (~[y: \nT1]. g)), if we define the term co as above, then we may use it to construct a fixpoint combinator for \nan arbitrary pointed type u by defining jiza:(a ~ c) ~ a ~ (Af:a ~ u. it~(~[x:aj. jx)eo). That is, we \nsimply iterate ~ : al ~ a over the object W. This is as direct an explanation of finding fixpoints in \na typed language as this author has seen (an anonymous ref\u00aderee of an earlier version of this paper pointed \nout that this is essentially the construction given by Mrdry in Theorem 3.12 of [Mu192]). 4 Example: \nRecursive types reduced to inductive types It is a relatively simple matter to reproduce in AP L the \nproofs from [Fre90] that the process of finding a fixpoint of an arbitrary type expression, in which \nthe type variable may appear both covariantly and contravariantly, may be reduced solely to the problem \nof finding fixpoints for the covariant case, provided the resulting covariant functors are algebraically \nbounded. The process we follow is that, given a bifunctor T which is contravariant in its left argument \nand covariant in its right, first we show that pt.T( , t) isa contravariant functor whose fixpoints are \nalso fixpoints of T it se~ that is, we may find fixpoints one variable at a time. Next, we need to show \nthat if F is a contravariant functor, then the fixpoints of F are the same as the fixpoints of the covariant \nfimctor F2, provided F2 is algebraically bounded. We omit the details of these constructions here, and \njust note an example of this process. In [How92, How93] this author presented types which correspond \nto universal types for call-by-value and call-by-name versions of the untyped lambda calculus. Specifically, \nif V = V + VL and N = (IV ~ iV) 1, then we may use V and N respectively to give types to the cbv and \ncbn calculi. In AW l, we may find solutions to these type equations by taking V ~ pr-. ps. (pt. r + tl) \n+ SL s pr. F2(r), for F (r) S p.s. r ~ s~ N s pr. ~s. ((@. (r--+ t)l) + S)l ~ pr, G2(r), for G(r) s ,us. \n(r--s)l. F@re 6 exhibits the remaining definitions needed for the simulation. For each untyped lambda \nterm M, the transla\u00adtions ViTA41: VL and ~llkfl: N will be terms of JP l; it is (+ p) (Xp,) (X92) (k: \na. M)IV + {N/z}M (A[z: u]. M)llvj + 7rl(M, N) + M [M, N](L;+ P) 7r2(M, N) ~ N [M, N](~;+TP) (@) t/@ (fOid,F \n) + (F(i%~ )N) (r@) zmJfoldVF(genvF i kf N) ~ ~(genVF AI)(MN) (r@) fOTCep~ &#38;f + foldP~(F(forceP~ \n)(unfoldVF M)) {N/z}A4 ~ MP + NP (J@) (+B,) (+62) Figure 5: Reduction rules of JP L .. shown in [How92] \nthat a ~lmple argument based on stan\u00ad dardization of reductions will verify that V[lf] + V[M~ iff M ~cbv \nM , and similarly that Af[kf] ~ Af[i kf~ iff M +cbn ikf . 5 Hylomorphisms and inductive programming \nThere have been several recent efforts in the programming language community to use programming techniques \nbased on combinations of iteration and coiteraticm. Two which we will relate to our system are Meijer \ns hylomorphisms and Kieburtz s use of weakly initial algebras and their duals. Both of these proposals \nstay within the realm of pointed types, where inductive and conductive types coincide, so neither is \nable to take full advantage of the separation be\u00adtween the well-founded operations of iteration and coitera\u00adtion \nand the potential unfoundedness of an explicit jorce op\u00aderation. Nevertheless, we have been significantly \ninfluenced by their suggested style of programming, which reflects our intuitions about how the structure \nof data, should guide the structure of programs. In the language of the Squiggol group, the functions \nde\u00adfined using it are catamorphisms and thc~se using gen are anamorphisms ([FM91, MFP91, Mei92]). A hylomorphism \nis a combination of these concepts which first uses an anamor\u00adphism to build up what Meijer refers to \nas a call-tree , and then uses a catamorphism to reduce this tree to a fi\u00adnal result (compare the Fibonacci \nexample of the introduc\u00adtion). A requirement for this is that the inductive types under consideration \nare all isomorphic to the corresponding conductive types. They observe that hylomorphisms neces\u00adsarily \nintroduce the possibility y of partial functions; when put in the framework of JK l, where am explicit \nuse of forceP~ is needed to tie together genVF M: u + VF and it@ N: pF + r to obtain the hylomorphism \nfrom a to ~, this follows from the necessity of HF being a pointed type. By making this coercion explicit, \nour system also allows con\u00adsideration of purely inductive or conductive types, for which all functions \nare total. Kiekmrtz [Kie93] also uses hylomorphisms (although not by name) when he demonstrates that \na useful notion for inductive programming is that of finding, homomorphisms from weak initial F-algebras. \nThat is, we may have a func\u00adtion g: F (r) + ~ which has a left inverse p: ~ ~ F (7), i.e., p(g(~)) = \nz for all x: ~(r); if g is weakly initial then we may construct an F-algebra morphism from g to any given \nf: F(a) + a (which will not necessarily be unique). This will be possible if we can just find a fixpoint \nof the map which takes h: T + u into ~ o F(h) op. But this is just the hylomorphism which first coiterates \np and then iteratively applies ~ to reduce the call-tree back down. Therefore, in ~~ ~, we may find weak \ninitial F-algebras just by finding a left inverse, provided F is algebraically bounded. Kieburtz also \ndescribes the dual case, but this still involves a hylo\u00admorphism so it is not fundamentally different \n(just a shift of view between which of the given functions is the alge\u00adbra/coalgebra and which is the \nleft/right inverse). 6 Conclusions We have demonstrated how recent developments in cate\u00adgory theory may \nbe used as guidance in designing a pro\u00adgramming language with well-behaved recursive types. The language \nfacilities for recursion concentrate on the natural inductive/coinductive structure which is common to \nmany of the objects of interest to computer science. When gen\u00aderal, unbounded recursion is needed, it \nis introduced in a controlled manner through a function which forces the eval\u00aduation of a coiteration \nprocess. To avoid inconsistency in a model which includes both extensional (categorical) prod\u00aducts and \nsums, this forcing operation is only allowed on a class of types which have been identified as pointed \n. We believe that the result is an elegant language in which to describe and examine recursive objects \nand algorithms. References [Bar92] Michael Barr. Algebraically compact functors. Journal of Pure and \nApplied Algebra, 82:211-231, 1992. [BFPS81] Wilfried Buchholz, Solomon Feferman, Wolfram Pohlers, and \nWilfried Sieg. Iterated Inductive Definitions and Subsystems of Analysis: Recent Proof- Theoretical Studies. \nNumber 897 in Lecture Notes in Mathematics. Springer-Verlag, 1981. [CF92] R. Cockett and T. Fukushima. \nAbout CHAR- ITY. Technical Report 92/480/18, University of Calgary, June 1992. [CP92] Roy L. Crole and \nAndrew M. Pitts. New foundations for fixpoint computations: FIX\u00ad hyperdoctrines and the FIX-logic. Information \nand Computation, 98(2): 171 210, June 1992. [Fio94] [FM91] [Fre90] [Fre91] [Fre92] [GLT89] [How92] [How93] \nFigure 6: Simulation of call-by-value and Marcello P. Fiore. Axiomatic Domain Theor~ in Categories of \nPartial Maps. PhD thesis, Univer\u00adsity of Edinburgh, 1994. Maarten M. Fokkinga and Erik Meijer. Pro\u00adgram \ncalculation properties of continuous alge\u00adbras. Technical Report CS-R9104, CWI, January 1991. Peter Freyd. \nRecursive types reduced to inductive types. In Fifth Annuai IEEE Symposium on Logic in Computer Science, \npages 498 507, 1990. Peter Freyd. Algebraiczdly complete categories. In A. Carboni, M.C. Pedicchio, and \nG. Rosolini, editors, Category Theory: Proceedings, Como 1990, pages 95 104. Springer-Verlag, 1991. Peter \nFreyd. Remarks on algebraically compact categories. In M.P. Fourman, P.T. Johnstone, and A.M. Pitts, \neditors, Applications of Cate\u00adgories in Computer Science, number 177 in Lon\u00addon Mathematical Society \nLecture Note Series, pages 95 106. Cambridge University Press, 1992. Proceedings of the LMS Symposium, \nDurham 1991. Jean-Yves Girard, Yves Lafont, and Paul Taylor. Proofs and Types. Cambridge Tracts in Theo\u00adretical \nComputer Science. Cambridge University Press, 1989. Brian T. Howard. Fixed Points and Extensional\u00adity \nin Tgped Functional Programming Languages. PhD thesis, Stanford University, 1992. Published as Stanford \nComputer Science Department Tech\u00adnical Report STAN-CS-92-1455. Brian T. Howard. Inductive, projective, \nand re\u00adtractive types. Technical Report MS-CM-93-14, Department of Computer and Information Sci\u00adence, \nUniversity of Pennsylvania, 1993. call-by-name [How94] [Kie93] [K108O] [LP95] [LS86] [Mei92] [MFP91] \n[Mit90] [Mog89] untyped lambda calculi Brian T. Howard. The expressive power of in\u00adductive and conductive \ntypes. Presented at the Tenth Workshop on the Mathematical Founda\u00adtions of Programming Semantics, March \n1994. Richard B. Kieburtz. Inductive programming. Technical Report CS/E 93-001, Oregon Gradu\u00adate Institute \nof Science and Technology, 1993. Jan Willem Klop. Combinatorg Reduction Sgs\u00adtems. PhD thesis, University \nof Utrecht, 1980. Published as Mathematical Center Tract 129. John Launchbury and Ross Paterson. Para\u00admetricity \nand unboxing with unpointed types. Available at http: Ilwww. cse. ogi .edu/ jl/ Papers/point .ps, 1995. \nJ. Lambek and P.J. Scott. Introduction to Higher-Order Categorical Logic. Number 7 in Cambridge Studies \nin Advanced Mathematics. Cambridge University Press, 1986. Erik Meijer. Calculating Compilers. PhD thesis, \nUniversity of Nijmegen, 1992. Erik Meijer, Maarten Fokkinga, and Ross Pa\u00adterson. Functional programming \nwith bananas, lenses, envelopes and barbed wire. In J. Hughes, editor, Proceedings of the Fifth ACM Conference \non Functional Programming Languages and Com\u00adputer Architecture, number 523 in Lecture Notes in Computer \nScience, pages 124 144. Springer-Verlag, 1991. John C. Mitchell. Type systems for programming languages. \nIn Jan van Leeuwen, editor, Hand\u00adbook of Theoretical Computer Science, volume B, chapter 8, pages 365 \n458. Elsevier, 1990. Eugenio Moggi. Computational lambda-calculus and monads. In Fourth Annual IEEE Symposium \non Logic in Computer Science, pages 14-23, 1989. . 1. [Mog95] -lmgemo - Metalanguages arm appuca- \nMoggL tions. Available as UL-notes. ~dvi. gz by anony\u00ad mous ftp from theory. doc. ic. ac. uk in directory \ntfm/papers/140ggiE, October 1995. [Mu192] Philip S. Muh-y, Strong mormds, algebras and fixed points. \nIn M.P. Fourman, P.T. John\u00adstone, and A.M. Pitts, editors, Applications of Categories in Computer Science, \nnumber 177 in London Mathematical Society Lecture Note Se\u00adries, pages 202 2 16. Cambridge University \nPress, 1992. Proceedings of the LMS Symposium, Durham 1991. [Mu193] Philip S. Muh-y. Lifting theorems \nfor kleisli cat\u00adegories. In S. Brookes, M. Main, A. Melton, M. Mislove, and D. Schmidt, editors, Ninth \nhz\u00adternational Conference on Mathematical Founda\u00adtions of Programming Semantics, number 802 in Lecture \nNotes in Computer Science, pages 304\u00ad 319. Springer-Verlag, 1993. [Sim92] Alex K, Simpson. Recursive \ntypes in ldeisli cat\u00adegories. Available as kleisli, dvi. Z by anony\u00admous ftp from f tp. dcs. ed. ac. \nuk in directory publals, August 1992. [SP82] Michael B. Smyth and Gordon D. Plotkin. The category-theoretic \nsolution of recursive domain equations. SIAM Journal on Computing, 11:761 783, 1982.  \n\t\t\t", "proc_id": "232627", "abstract": "An extension of the simply-typed lambda calculus is presented which contains both well-structured inductive and coinductive types, and which also identifies a class of types for which general recursion is possible. The motivations for this work are certain natural constructions in category theory, in particular the notion of an algebraically bounded functor, due to Freyd. We propose that this is a particularly elegant core language in which to work with recursive objects, since the potential for general recursion is contained in a single operator which interacts well with the facilities for bounded iteration and coiteration.", "authors": [{"name": "Brian T. Howard", "author_profile_id": "81100328819", "affiliation": "Department of Computer and Information Sciences, Kansas State University", "person_id": "PP31037421", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/232627.232640", "year": "1996", "article_id": "232640", "conference": "ICFP", "title": "Inductive, coinductive, and pointed types", "url": "http://dl.acm.org/citation.cfm?id=232640"}