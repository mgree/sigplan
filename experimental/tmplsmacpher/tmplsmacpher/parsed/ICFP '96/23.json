{"article_publication_date": "06-15-1996", "fulltext": "\n Sharing Code through First-class Environments Christian Queinnec* &#38; David De Rouret Ecole Polytechnique \nDepartment of Electronics and Computer Science, &#38; INRIA-Rocquencourt University of Southampton Abstract \nNowadays the Net is one of the most obvious driving forces. Yet, to consider it as one global store through \nwhich val\u00ad ues and code may be shared is still immature. This paper suggests first-class environments \nas a means to achieve that goal in a multi-user Scheme framework. We propose two new special forms with \na simple semantics. Our model al\u00ad lows precise control over environments (including extensible environments) \nand does not require (but does not prevent) reflective operations. 1 Motivation Millions of users now \ndream of means through which they may share programs and/or data. Data are becoming more and more comple~ \nthey are no longer made of simple, atomic, flat values such as numbers or characters but now mun\u00ad danely \nincorporate pointers, as exhibited by the increasing number of WWW pages full of references towards remote \npieces of information. Other data are only acquired after long computations and are better shared rather \nthan recom\u00ad puted. Of course, data may be stored in shared files but then need to be parsed to resurrect \nprogrammatically. All these reasons favor the invention of a common shared distributed memory that offers \na language independent API (Applica\u00ad tion Programming Interface) allowing numerous users to de\u00ad vise \nstructures or claeses, to instantiate them and to share or migrate the resulting instances so they can \nbe directly computed upon. On the other hand, programs are mainly shared through tar. gz files (provided \nthey can be recompiled), exchanged via strings as in Tcl [OUS93] or compiled into bytecode as in Java \n[Sun95]. Basically when a program text is interactively submitted for evaluation, it is converted into \nsome code (pre\u00ad Laboratoire d Informatique de l Ecole Polytechnique (URA 1439), 91128 Palaiseau Cedex, \nfiance Email: Christian. Queinnec@polytechnique.fr This work has been partially funded by GDFLPRC de \nProgrammation du CNRS and EC project reference ERB 4050 PL 930186. tso th~pton SO17 lBJ, UK Email: dder%oton.ac.uk \nThis work has been partially funded by EPSRC GR/K36409 and EC project reference ERB 4050 PL 9301S6. Penniaaion \nb make digitab?mrd copy of part or all of thii work for personal or classreom use is ranted without fee \nprovided that oopiea am not made or d~tributad tir pm k or commafoial ~vanta e, the copy?ight notice, \nthe titte of the Publk%tion and its date appear, a#notioetagiwthat oopying is by permission of ACM, Inc. \nTo copy otherwise, to republish, to post on servws, or to radktribute to Ma, requires prior apadfk pwm~ \nandhr a fee. ICFP 96 5/96 PA, USA 01996 ACM 0-89791 -771 -WWW35...$~.~ sumably accompanied by some \nliterals) and some free vari\u00adables. These free variables have to be bound to some loca\u00adtions before this \nprogram may be run. Reciprocally, a pro\u00adgram is implicitly parameterized with respect to its free vari\u00adables. \nTherefore, to be able to share code, we must specify in which environments free variables must be found; \nthis may be achieved through the existence of first-class environments as in [BL84, RAM84, FF86, GJL87, \nMR91, Jag94, LF93]. A code to be shared mav then be remesented bv a module, a function that expects an \nenvironment providing the (lo: cations of the) free variables that the program needs for its evaluation. \nThe essence of our proposal is to offer two new special forms to handle first-claes environments i.e. \ncollections of named locations. The first one, export, allows us to reify a lexical environment (or part \nof it) into a first-class value. The second special form, import, evaluates some forms in an environment \nwhich is a mixture of an explicitly stated first-class environment composed with the current lexical \nen\u00advironment. Our proposal still provides efficient compilation as well as some additional functions \nto manage first-class en\u00advironments. First-class environment is the last component of the computation \nstate that was not reifiable in regular Scheme. Our aim is to show that we can (i) overcome this limit \nation without degrading performance, (ii) ease code sharing by a precise control over the environments \nwithin which code is installed. Programs are parameterized with respect to their free variables and as \nsuch are much more reusable than closures that may only be customized as far as their arguments allow \ncustomization. A closure gets values in a combination; an importation gets locations from a first-class \nenvironment. Making some resources available is better achieved through a first-class environment than \nthrough a list, a record or even a clo\u00adsure since these values impose some order, some accessing method \nand are too overspecified. A first-class environment can only be imported and allows reference to the \ncaptured variables with the least possible syntax: that of variable reference. Importation allows us \nto parameterize [Lam88] a pro\u00adgram with respect to an unordered set of variables. Different programs \nmay be parameterized with respect to intersecting sets of variables, thus achieving a sort of fragmented \nletrec between them if they are imported into the same environ\u00adment; different programs may thus share \nmutable locations. Conversely, one program may be imported into different en\u00advironments by different \nusers, or into different environments by a single user to achieve fault-tolerance by replication of computations: \nimportation features a sort of dynamic reen\u00adtrant linking facility. Our first-class environments (i) \nobey the quasi-static discipline meaning that variables are, on importation side, statically known to \nbe either static or quasi-static as in [LF93] and, on exportation side, local variables are stati\u00adcally \nknown to be either captured or non captured in a first\u00adclass environment, (ii ) do not require reflection \n(but do not prevent it), (iii) are versatile enough to promote new use\u00adful programming techniques (modules, \nobjects, etc.), (iv) may be exercised to explain the behavior of toplevel envi\u00adronments. Our proposal \nroughly stands as a new point among the pioneering works of [BL84, RAM84, FF86, GJL87, Lam88, CR90, MR91, \nJag94, Tun92, LF93, DPS94] on module, ex\u00adportation and importation systems. We improve on [LF93] since \nwe are able to manage extensible environments and implicit sets of free variables with a much simpler \nseman\u00adtics, while we offer some reflective features of [Jag94] with\u00adout impeding compilation efficiency. \nDetailed comparison is deferred until section 7. Since the semantics of these new special forms is fairly \nstraightforward, we dare start by immediately introducing their denotational semantics in section 2. \nWe then present, in section 3, a series of examples illustrating some of their usage. Section 4 introduces \nauxiliary functions to enhance environment management as well aa new examples of use. A naive implementation \nis sketched in section 5. Section 6 comments on reflective aspects while comparison with re\u00adlated works \nappears in section 7. 2 Formal Semantics This section presents the denotation of two new special forms \nnamed export and import. Table 1 cent sins the main frag\u00adment of a denotational semantics for Scheme. \nThe notations are inspired from [C R91]. Given a memory state (a store) and a number of locations, the \nallocate function invokes its third argument on the resulting store and the freshly aJlo\u00adcated locations. \nThe major difference from the semantics of [CR91] is the structure of the Env domain. Instead of map\u00adping \nan identifier directly into a location, an environment p rather has signature: Id x Store x (Store x \nLoc ~ Answer) ~ Answer In other words, given an identifier and a store, an envi\u00adronment invokes its third \nargument with the location associ\u00adated to the identifier and the resulting store. This signature is not \nnew [FW84] but will ease our later introduction of ex\u00adtensible environments. This signature is illustrated \nby the denotations of reference and assimment in table 1. Conventions for environment handling are inspired \nby [LF93]; they appear in table 2. The null environment is named p L. Environments may be restricted: \np\\W returns a new environment that is similar to p except that it only con\u00adtains the identifier v. This \nrestriction is naturally extended to a set of identifiers using notation p\\{v. }. Environments may be \nchained: p @ p returns a new environment that be\u00adhaves as p but for the identifiers not contained in \np that are then looked for in p . We overload the usual extension no\u00adt ation, p[v + cr], to cope with \nthe new signature of environ\u00adments. We ~so extend it to sets of identifiers and locations as in p[v + \na ]. Finally it is possible to actively check, wit h p 3 {V*} u, whet her an environment really associates \nlocations to a set of identifiers in a given store. The denotations of export and import each have two \ncases depending on whether or not the set of given identifiers is empty. Since to export or import an \nempty set of variables is pointless, these specisl cases will mean export or import all possible variables \nwhere all possible is explained below. Table 3 contains these denotations with 7W(~+ ) standing for the \nfree variables of the n+ forms. These denotations may be paraphrased as follows: (export ) : yields the \nentire current lexical environment. (export v+) : yields the current lexical environment res\u00adtricted \nto the identifiers given. Due to their presence in the export form, these identifiers appear free and \ntherefore are necessarily contained in the current lexi\u00adcal environment i.e. have an associated location. \nThe initial store, uo in table 1, shows that locations may be uninitialized provided they are not read. \n(import () ir ~+): evaluates T to obtain an environment, checks that the free variables of r+ are contained \nin this environment then evaluates ~+ in this sole envi\u00adronment. The current lexical environment is therefore \ntotally shadowed by the new environment during the evaluation of ~+. As for implicit begin forms, the \nfinal value of the import form is the last value of r+. (import (v+) m r+): evaluates x to obtain an \nenviron\u00adment, checks that the variables v+ are defined in this environment then evaluates T+ in this \nvery environ\u00adment restricted to v+ and chained to the current lex\u00adical environment. The v+ identifiers \nof the new envi\u00adronment shadow their homonyms in the current lexical environment. The final value oft \nhe import form is the lsst value of T+. Observe that a free variable of r+ is either explicitly mentioned \nby the import form (and must be provided by the obtained environment this is checked only once at im\u00adportation \ntime, that is linking time) or, must be present in the lexical environment of the import form. Reciprocally, \na local variable is either exported or not. This first case occurs when an export form mentions the local \nvariable (implicitly or explicitly) from within its binding scope. This catego\u00adrization of free and local \nvariables is statically decidable: we name it the quasi-static discipline in honor of [LF93] who introduced \nthe term quasi-static . Note that (export v+) and (import (v+ ) . . . ) restrict the first-class environment \nto only contain the v+ variables. This is also the case of (import () . ..) which restricts the imported \nenvironment to all the possible variables i.e. the free variables of its body. On the other hand, (export) \nlets the caller grab the entire lexical environment with all the variables it contains or potentially \ncontains if extensible; see section 4 below. 3 Examples This section presents some examples involving \nimportation and export ation. This first example creates then exports locations containing values. It \nshows that it is possible to alter the exported environment from the outside with values computed as \nif evaluated inside. This facility is important Vc Id a E Loc = Address+ {non-existent-variable} p c \nEnv = Id x Store x (Store x Loc ~ Answer) ~ Answer K E Cent = Value x Store * Answer u G Store = Loc \n* Value c G Value =Fun+Env+Id+ . . . We Fun = Value* x Cent x Store + Answer (qv] p K CT= (p v a Aa ci.(lt \n((Y a) u )) t~(set ! v 7r)] p ~ u = ~[7rJ p Asu . (p v u ,lu a.(~ e a [cr + e])) a ~~(lambda (v*) m+)] \np K u = (K inValue(k*6 c7 . if #e* = #v* then allocate u #v* k a .~+~r+] p[v L a*] R U [CY* A c*] \nelse wrong Incorrect arity en~lf ) a) F.[(7r 7r*)] p 6 a = E[m] p k+Yu .E*[7r*] p Ae*a . (p [Fun e \n K a ) u u t+[m7r+] p K a = &#38;[7r] p A&#38;u .t+[7r+] p K d u t+[7r]p Kcr=z[7r]p KC7 &#38;*[Yr T*] \np K a = C5[?r] p h7 .t*[7r*] p A&#38;*u .(x (.S)$E* a ) a a t []plccr=(fcocl) U. = kx. wrong Uninitialized \naddress Table 1. Denotational semantics of a subset of Scheme pl = Avuq.(q a nora-ezisterat-uariabie) \np\\V = Mug, if v = v then (p v a g) else (q u non-existent-variable) endlf P\\{v .*} = (P\\u) @ (P\\{u }) \nP\\{} = PL (p) @ (p )= Avaq.(p v a Au a. if a = nora-ezident-uarialde then (p v a q) else (q a a) endif \n) p[v + a] = Av aq. if U = v then (q a a) else (p u a q) endif p[v* 2 a ] = if #v* >0 then p[v ~ 1 \n~ cr t l][v*JI+ CY*J1] else p endif (P) 3 {}w = (~ ~) (p) 3 {v v }aq = (p v a h a. if a = non-ezistent-uariabie \nthen wrong Missing variable else (p) 3 {v* }u q endif Table 2. Auxiliary functions for environment \n for debugging, profiling, instrumenting, or upgrading pro\u00adgrams as well as for autoload functions. An \nexport form is a mechanism that extends the scope of the exported vari\u00adables. Reciprocally, import forms \nprovide the regions where this scope do extend. (clef ine (create-stack . content) ,. .,,. .\\\\ ... , \n,., , \\Lez [Ccounrer -1) j ; znwouuce local (define (push x) ; define push (set ! counter (+ counter \n1)) (set ! content (cons x content)) ) (define (pop) ; define pop (if (pair? content ) (let ((top (car \ncontent) ) ) (set ! content (cdr content)) top))) (push (length content ) ) ; pe?form some Computation \n; ; export three local bindings and one global (export counter + push pop) ) ) (let ((stk-env (create-stack \n11 22 33 44 55)) (+ *)) ; ; import only push, pop and counter (import (push pop counter) stk-env (set \n! pop (let ((old-pop pop)) ; modify pop (lambda () (import (+) stk-env ; import + (set ! counter (+ counter \n1)) (old-pop) ) ) ) ) (push (+ (pOp) (pOp) )) ) ; three operations (import (counter) stk-env ; import \ncounter counter ) ) +3 The first program defines a generator of stack utilities to be gathered in a first-class \nenvironment. The second pro\u00adgram creates such a first-class environment then imports it for some computations \n(redefining the pop location to count the number of times it is invoked) and, finally, reads the count \ner variable. Observe that these importations do not shadow the local variable st k-env nor the global \nvariable *. Observe also that the redefinition of pop is possible since the stk-env environment captures \nthe location of pop and not only its value. Moreover the new value of pop is evaluated after importing \nthe same addition function that the original push was using, and of course the same counter variable. \n3.1 Modules A reverse view would be to fill externally provided locations with values. In the first case, \nthe definer of the program builds a ready-to-use environment while in the second case the definer only \nprovides a function, a module, that installs a set of values into locations provided by the client of \nthe module. Here is an example of that second technique: (define (install-stack-module env) (import (push \npop counter) env ; acquire locations (let ((content ())) (set ! push (lambda (x) ; install push (set \n! counter (+ counter 1)) (set ! content (cons x content)) ) ) (set ! pop (lambda () ; install pop (if \n(pair? content ) (let ((top (car content) ) ) (set ! content (cdr content)) top))))))) (define counter \nO) (define (get-pusher) (let ((push wait) (pop wait) ) ;provide locutions (install-stack-module (export \ncounter push pop) ) push )) (define synchronous-push (let ( (pushers (list (get-pusher) (get-pusher)) \n) ) (lambda (x) (for-each (lambda (push) (push x)) pushers )))) In this example, the get-pusher function \ninst alk the push function twice, into two distinct but similar environ\u00adments. The synchronous-push function \njust pushes its ar\u00adgument onto two different stacks. Note that counter is shared by these two installations \nso both push functions in\u00adcrement the same counter. This is an example where map\u00adping two a priori different \nvariables onto the same location offers a customization that was not explicitly apparent in the install-stack-module \ncode and difficult to implement if only values were exported. Our view of module should not be confused \nwith the unit of compilation concept (sa provided by compilers such as Bigloo) where the goal is efficiency \nrather than re\u00adusability. 3.2 Objects The relationship between objects and first-class environ\u00adments \nhaa been studied for long and bsaicalIy the examples we could provide with our special forms would be \nin spirit similar to those of [L F93]. Nevertheless we do not think this is a good idea since one of \nthe critical point for method lookup is the ability to test efficiently the class of an object. The class-of \nfunction that returns the class of an object would be something like: (define (class-of o) (import (class) \n0 class) ) The linking cost of that import form is much higher than the execution cost of its body because \nthe location of class is not necessarily in a fixed position in the first-class envi\u00adronment o and must \nbe looked for dynamically. 3.3 Enquiring closures Some Scheme implementations provide a function, proce\u00ad \ndure->envirorment, that given a closure returns the en\u00ad vironment it closed. This is a dangerous feature \nsince it has to be precisely defined and may break previous op\u00ad timization. For instance in the following \nexample, does (procedure-> environment foo) contains y and does the addition disappear since x is zero \n? (define foo (let ((x O)(y foo)) (lambda (Z) (+ X Z)) ) ) (import (x y) (procedure-> environment foo) \n; import y f? (set! x y) ) ; change x to a non-number !? To open up a closure should not break the compilation \nof the associated function, just as the exportation of a lo\u00adcation must not break the exporting code. \nIt is therefore necessary to know statically which variables may be ex\u00adported, so the compiler can be \ncautious with these variables. We therefore introduce a new syntax to define a function and the environment \nit may export. Let s call this syntax enquirable-lambda and suppose the existence of a couple of functions \n(using ad-hoc primitives, hash-tables, whatever) associating/retrieving a value to/from a closure. Of \ncourse, to store this value in the closure object itself would be the best implementation. (define-syntax \nenquirable-lambda (syntax-rules () ( (enquirable-lambda exporting formals body . . . ) (let ((proc (lambda \nformals body . ..)) (env (export . exporting)) ) (set -exported-env ! proc env) proc )))) (define (procedure-> \nenvironment proc) (get-exported-env proc) ) A generic function, as in CLOS [BDG+ 88], may look for a \nmethod in a dispatch table, held in some closed variable, according to the class of a receiver. This \ndispatch table haa also to be made available to the general outer add-method! function to be enriched \nwith a new method. A good way to extract a dispatch table from a generic function is to use our previous \nenquirable-kunbda facfity: (define-syntax define-generic (syntax-rules () ((clef iue-generic (selector \nreceiver arguments . ..)) (define selector (let ((dispatch-table (initial-dispatch-table)) ) (enquirable-lambda \n(dispatch-table) ; erpo~t (receiver arguments . ..) ( (lookup-method dispatch-table (class-of receiver) \n) receiver arguments ... ) ) ) ) ) ) ) (clef ine (add-method! generic class method) (import (dispatch-table) \n; import (procedure-> environment generic) (augment-dispatch-table ! dispatch-table class method ) ) \ngeneric ) 3.4 Dynamic evaluation The import form may be viewed as a kind of static eval facility where \nit is possible to evaluate some static forms r+ in a dynamically chosen environment. The difference from \na full-fledged eval is that here the forms to evaluate are known statically and all the bindings they \nneed must exist beforehand: there is no possible incremental definition i.e. dynamic creation of new \nbindings. The import form corresponds to the many cases where eval is invoked on a backquot e form as \nsuggested by the following approximate relation (paying attention to the pos\u00ad sible lexical capture of \nvariable x): (eval (... ,x . ..) env) N (import (x) env (... x . ..)) Toplevel facilities that acquire \ndynamically the forms to evaluate (i.e. performing something like (eval (read))) cannot be helped by \nour import form. However, our import form do correspond to the cases where some code has to be evaluated \nin some environment and it is not possible to write this code in the scope of that environment. This \nim\u00adpossibility may occur for many reasons; for example, the size of the code may make it unmanageable \nin a single file, or some deferred user code (hooks) may be allowed to cus\u00adtomize a predefine library. \nEven if a direct programmation would not have used eval but objects instead, here follows a realistic \nexample where a byte-code machine may be dy\u00adnamically instrumented from the outside. (define (build-machine) \n(define bytes *(255)) (define PC O) (define val wait ) (define env )()) (clef ine (wrong) no such opcode \n) (let ((opcodes (make-vector 256 wrong))) (define (run) (let* ((byte (vector-ref bytes PC)) (0p (vector-ref \nopcodes byte)) ) (set! PC (+ PC i)) (Op) )) (define machine-env (export bytes PC val env opcodes wrong \nrun machine-env ) ) (vector-set ! opcodes O run) ; nop machine-env ) ) (define machineO (build-machine)) \n(import (opcodes bytes PC val run) machineO (vector-set ! opcodes i ; load-quick (lambda () (set ! val \n(vector-ref bytes PC)) (set! PC (+ PC i)) (run) ) ) (vector-set ! opcodee 2 ; exit (lambda () val) ) \n (set! bytes *(O i 23 2)) (run) ) +23 The load-quick bytecode instruction is synthesized out of the definition \nof the build-machine abstraction but as if it were defined in. The load-quick instruction just loads \nthe val register with the next bytecode. While import allows to evaluate some code as if con\u00adt ained \nin some environment, import is free of leakage. The following example leads to an error since it is not \npossible to extract build-machine from machineO: (import () machineO (export build-machine) ) 4 Library \nThe export special form is currently the only way to cre\u00adate first-class environments. It is a simple \nstep to enrich the model with regular side-effect-free functions that create or manage first-class environments. \nThese functions give the user access to the auxiliary functions of the denotation: one may create an \nempty (or arid [L F93]) environment with create-empty -environment; see table 4. The maior innovation \nis the introduction of extensible u environments. An extensible environment is an immutable first-class \nvalue that contains all possible variables. The trick is whenever an identifier is looked for in an extensible \nenvironment that does not contain it yet, a new location is associated to it and recorded. Therefore \nno identifier can be found not to belong to an extensible environment! Thk is this feature that imposed \nthesi nature of Env. Extensible % environments are created by C? ; see again table 4. An extensible environment \nuses a location as a place holder for the actual environment it stands for and this location is initialized \nwith pL. 4.1 letrec visited Extensible environments stand for environments in which all possible variables \nare bound to locations [CR91, ~ 5.2.1]. To say that variables are bound does not mean that they are ini\u00adtialized: \nthey are not, and it is an error to ask for the value of an uninitialized variable. The crest e-complet \ne-environ\u00adment function creates a new extensible environment where all possible variables are uninitialized. \nIt is therefore possi\u00adble to define letrec aa a regular syntax without resorting to the existence of \nthe necessarily non existent <undefined> value as done in [CR91, $ 7.3]. We neglect here the order of \nevaluation to simplify the expansion: (define-syntax letrec (syntax-rules () ((letrec ((var val) . ..) \nbody...) (import (var . . . ) (create-complet e-environment ) (set! var val) , . . body...)))) The local \nvariables of the letrec form are looked for in the extensible environment created, and their associated \nlocations are of course found since this is an extensible envi\u00adronment. The initializing assignments \nare evaluated in that environment followed by the body of the letrec form. If some variable is referenced \nbefore being assigned then an error will be raised since the variable was created uninitial\u00adized in the \nextensible environment. Although extensible, a smart compiler may notice that the locally created environment \nis only used for a fixed num\u00adber of variables that are not reexported (unless the body contains such \nan export form). Therefore the environment does not need to be actually extensible. On the other hand \nthe compiler haa to be cautious when referencing an im\u00adported variable and check whether it is initialized \nor not. It is possible to perform an approximate analysis [Que94, p. 389] to discover some surely initialized \nvariables and avoid checking them. This new definition of let rec is intended to be an expla\u00adnation not \na actual implementation. Compilers should still consider letrec as a primitive special form. The technique \nused to illustrate a correct expansion for letrec i.e. introducing new uninitialized locations out of \nan extensible environment may be turned into a syntax, say uninitialized-let, but may also be used to \nshadow i.e. exclude some locations from an environment as in: (import ( ezcluded variables ) (create-complet \ne-environment ) (export ) )  4.2 Linking environments The chain-environment function allows us to use \nthe @ op\u00aderation and thus to compose environments piece by piece. To chain an extensible environment \nwith anything is mean\u00adingless but the reverse is really useful. Suppose that the ini\u00adtial environment \ncontains all the predefine variables, then this environment may be reified with an (export) form and \nstored in the scheme-env variable. Chaining scheme-env with an extensible environment allows multiple \nusers to share a common environment with their own additional bindings gathered in the second part of \nthis environment. See sec\u00adtion 6.3 for a different solution where users bindings are recorded before \nthe initial environment and may thus shadow initial bindings. A function to create such toplevel environ\u00adments \nmay be defined as: ... (set ! scheme-env (export)) .,. (define (create-user-toplevel-environment) (chain-environment \nscheme-env (create-complete-environment ) ) ) Our proposed special forms do not provide control of the \nmutability of bindings, therefore the previous solution does not prevent s theme-env from being mutated. \nThis point will be addressed later in section 6.4. Chaining does not mean that the environments involved \nare really chained by the implementation; see section 5. A common problem of first-class environment \nlies with increment al definition [RAM84, MR91, Tun92] which re\u00adquires adapting the resolution of free \nvariables to the evolu\u00adtion of first-class environments. More precisely, the problem arises when the \ncurrent lexical environment is (p) @ (p ). If p is an environment not containing a variable X then the \nlocation associated to X must be provided by p . Now, if p is mutated to contain X then thk new definition \ndynamically shadows that of p . Such a change is against quasi-static discipline and is not possible \nin our model since our envi\u00adronments are immutable. Even if p is an extensible environ\u00adment, it totally \nshadows p and it is pointless to chain it in front of any other environment. The magic also comes from \nimport which is a special form and not a function as eval; see section 3.4. We do not think that this \nposition is against interactive modular programming [Tun92] as one can recreate a new environment excluding \nsome locations, but rather suggest that it avoids subtle bugs as names clashes should not be automatically \nignored and it avoids developing sophisticated implementation techniques to ensure efficiency. To export \nthe entire environment is dangerous: it de\u00adgrades efficiency since all locations may potentially be mu\u00adt \nated and therefore prevents optimization. It is neverthe\u00adless mandatory if one wants to reify the entire \nstate of com\u00adputation. Given the semantical gap between (export v) and (export ), the latter might be \nrenamed (the-environ\u00adment) to prevent hazardous typos. 5 NaYve implementation Fundamentally a first-class \nenvironment is nothing more than an unordered set of second-class named locations and can be implemented \nss a table (possibly accessed with some [create-empty-environment] + inValue(Je*Ku. if #e* = O then \n(K itavalue(pl) a) else wrong Incorrect arity endif ) [chain-environment] + inValue(k*mY. if #c =2 then(~ \ninValUe((&#38;* lllE..) @(6*l2lE.v))~) else wrong Incorrect arity endif ) (a a) = ~1/~q. let~=(d~) IE \nv in(p v a Aa a . if a = non-exigtent-variable then allocate a 1 Aa a . lets =cr*Jl in(qa [a-+ inValue(p[v \n+cr ])] a ) else (q a a ) endif ) [create-complete-environment] + inValue(Ae*m7. if #e* =0 then allocate \nu 1 ~a a*.(K inValue((flTw* JI)) a [a Jl+ inValue(p~)]) else wrong Incorrect arity endif ) Table 4. \nEnvironment related functions [environment-get] + inValue(Ae*Ku. if #e = 2 then let p = e* llIE.. and \nv = e* 1211~ in (p v a Au a. if a = non-existent-variable then wrong Won existent variable else (K (a~cv) \nu ) endif ) else wrong Incorrect arity endif ) [environment-present?] + inValue(Ae*mY. if #e* = 2 then \nlet P=e*ll[E.v and v = e J211~ in(pva~a a.(fi inValue(a #non-e#istent-variable) u )) else wrong Incorrect \narity endif ) [environment-rename] -.-+ inValue(k*tcu. if #c* = 3 then let/2=&#38;*lllEnv and v = E* \nJ.211d andv = e* J3114 in(p v a Aa a. if m = non-existent-variable then wrong ccNon existent variable \nelse (K inValue(p[v+ non-esistent-variable] [v + a]) a ) endif ) else wrong Incorrect arity endif ) \n[environment-enrich] + inValue(A&#38;*Ku. if #e* = 2 then letp=e*Jllm.v and v = e* J211~ inallocateol \nAa cr*. (K inValue(p[v +cr*Jl]) a ) else wrong Incorrect arity endif ) Table 5. Environment related \nreflective functions hash coding if its size or extensibility justifies this) map\u00ad ping names to their \nassociated locations; see figure 1. 1st-class environment location I +nameO II name2 II t valueO o Figure \n1. First-class environment Let s suppose that the lexical environment is represented by linked lexical \ncontours i.e. sequences of locations. An\u00adother technique to implement first-class environment [Que94, \np. 269], improving multiple reification of similar environ\u00adments (see figure 2), is to pair the current \nlexical environ\u00adment with a (static) table mapping names to their associated lexical indexes (i, j) where \nj is an offset in the Z h contour. The cost of reification is small but the linking time is slowed down \nand too much oft he current environment is captured. Ist-class environment Lexical environment F  H. \n ~meo iO jO -r j2 mmc1 il jl value2 narne2 i2 j2 ... o Figure 2. Variant of first-class environ\u00adment \nWhen importing a first-class environment, there is al\u00adways a finite number of statically known variables \nto resolve in that environment, that is the given variables of the import form, or the free variables \nof the body of the import form. Wenow suppose that these variables are gathered in anim\u00adport contour \nmap. Before evaluating the body of import, a fresh contour is allocated and for each variable of the \ncontour map, its loca\u00adtion is dynamically looked for in the first-class environment and copied, according \nto the contour map, in the fresh con\u00adtour; see figure 3. Access to these variables passes through this \nnew contour. For instance, a reference to the imported nameo variable (stored at position z in the import \ncontour .th map) will be compiled by fetching the z content of the fresh import contour, dereferencing \nit into the location hold\u00ading the value. Note that the body of the import form does not need any longer \nthe names of the imported variables, their rank in the import contour map is sufficient. However the \nnames are required at link-time to fill the fresh contour. The additional cost of accessing such an imported \nvari\u00ad able is just one indirection and a check that it is not unini\u00adtialized. This mechanism is reminiscent \nof the closure cre\u00adation of the FAM [Car84]. Any missing variable is immedi\u00ad at ely report ed, so no \nother test is needed when evaluating the body of the import form. The real cost of an import form is \nconcentrated in the linking cost, that is the research of the required named locations when building \nthe contour for the import form. 1st-class environment location T~ ~eo ( fresh lexical environmentimport \ncontour FTFT- I - \\ L--l I I\\ L  -.. ,.imw.conto.rnw r-Q.\\ \\  . . . n \\\\ name(l\\ \\ \\\\ a . Figure 3. \nLexical environment at import time As mentioned earlier, some improvements are possible when an extensible \nenvironment . imported: is explicitly this is quite similar to the optimization where a com~ination has \nan exphcit 1 ambda form as operator. 6 Reflective aspects It is clear from the information gathered in \na first-class en\u00advironment that, given the name of a variable, its associated value may be found dynamically \nand/or mutated (if allowed; see section 6.4 below) in this environment. It is also easy to determine \nwhether a name is present or not in a :lirst-class environment. The environment-present? predicate (see \ntable 5) corresponds to a stable property: its answer cannot vary. To check whether a binding is initialized \nis a different predicate whose answer may evolve from false to true. If the language provides an object \nsystem, a simple way to offer reflection over first-class environments is to make them regular objects. \nOtherwise, specific functions may be offered. Observe that, conversely to other proposals for first\u00adclass \nenvironment [RAM84, MR91], the presence of these additional functions is completely independent of the \nim\u00adport ation mechanism and does not impact it. 6.1 Renaming (set ! the-enviroment (export)) ) An interesting \neffect might be achieved if one is allowed to create a modified copy of a first-class environment: it \nis then possible to change the name under which a loca\u00adtion is exported, thus providing a renaming facility \nfor ex\u00adported environments; see function environment-rename in table 5. Renaming is not universally recognized \nas a good tool [DPS94] but we think in a more and more persistent, multi-user world, name clashes are \nvery likely to happen. This renaming facility may accompany cr-conversion to still produce a first-class \nenvironment defining the same set of names. The renaming work is done at run-time and does not impact \nthe compilation of the import form since the compiled code only depends on the presence of some loca\u00adtions \nin some well defined place (the import contour) and is independent of the names that were used to find \nthese very locations. 6.2 Extension Another interesting effect is to enrich a first-class environ\u00ad ment \nwith a given name. The enrich-environment function may be given a name v and an environment p and returns \na new first-class environment, the equivalent of (import (v) (create-complete-enviroment) (chain-environment \n(export v) p) ) In the resulting environment, the name is associated with an uninitialized location. \nNote that the environment which is extended, p, is not mutated even if extensible. 6.3 Toplevels All \nthese functions allow us to precisely and reflectively en\u00adquire and control first-class environments \nwithout impeding the semantics and the efficiency of the exportation/impor\u00adtation mechanism. They allow \nus to make completely ex\u00adplicit the work of a toplevel loop (aa in [GJL87]) that reads a program r, extracts \nits free variables fiv( rr) while an\u00adalyzing (expanding, compiling) it, turns the program into a module \ncorresponding to (lambda (r) (import (Y~(~) ) r m) ), selects one environment in which to evaluate it, \nen\u00adriches that environment with the free variables (or checks that they are already present) and, finally, \nevaluates the above entity. Depending on the chosen environment, one may only access a restricted set \nof variables, share a common environment with others or even create one s own private ex\u00adtensible environment \nas shown in the following example: (define (create-user-toplevel-loop read initial-env) (letrec ( (the-environment \n(chain-environment (export the-environment) initial-env ) ) ) (let loop () ((turn-into-module (read) \n) the-environment) (loop) ))) (create-user-toplevel-loop read-from-windowO pure-scheme-env ) (create-user-toplevel-loop \nread-f rom-windowl (create-user-toplevel-environment ) ) Within these two toplevel loops, one may read \nand write the the-environment variable. In the first, one has no access to the create-complete-environment \nfunction but may al\u00adready simulate hyperst atic environment d la ML just by say\u00ading: (letrec ((fact . \n. . ) ) By storing previous values of the-environment and rein\u00adstalling them, one is also able to regress \nin time or to switch among many different environments that may be managed as any other first-class value. \nThe second toplevel 100P is much more permissive.  6.4 Mutability Currently, if a variable is exported, \nall its importers may mutate it, even if the author of the module did not want it. It is therefore necessary \nfor the module author to re\u00adstrict writing access to some exported variables. One way to achieve this \nis to only export observer functions as sug\u00adgested in [FF86, Tun92] but this prevents the importation \nof mutable locations such as the errno variable from the C library. Another way is to enhance the syntax \nof export to specify which variables are exported read-only. Since export forms are special, they cannot \nbe ignored by the compiler which exactly knows the statue of every variable. On the import side, the \nlinking phase may check, when an imported variable is assigned in its body whether the import ed environment \nallows it or not. Finally, a regular function can also be offered to make read-only a named lo\u00adcation \nof a first-class environment. Note that only the en\u00adhanced export form allows the compiler to better \nhandle non-assigned variables that are exported read-only. 7 Related Works Pebble [BL84] introduced first-class \nbindings somewhat sim\u00adilar to first-class named locations (except that variables were immutable). Bindings \nmay be paired to form first-class en\u00advironments. Bindings may be made active in a scope using LET form. \nNevertheless this form does not exactly comply with quasi-static discipline since variables cannot be \nunam\u00adbiguously resolved with their sole names. This is, for in\u00adstante, the case for x, in LET x w 3 N \nLET b ~ x, whose meaning depends on the actual type of b that may or may not contain a binding for x. \nAn expression may be isolated from the current lexical context with IMPORT corresponding to our (import \n() . . . ) form. Importation and exportation were analyzed in [FF86] in terms of syntaxes, that is without \nintroducing new primi\u00adtive special forms to Scheme. They essentially export values rather than locations. \nThis is most of the time sufficient since values may be closures capturing mutable locations and offering \nsome protocol to mutate them, delay their ini\u00adtialization etc. Nevertheless it is not possible to really \nshare locations not containing functions nor to reify the entire en\u00advironment and these are precisely \nthe aspects our special forms were made for. The module system of [CR90] for Scheme favors static development \nof large applications rather than dynamic cre\u00adation of first-class environments. This is mainly due to \nthe presence of syntaxes whose expansion must be controlled statically (as in [QP91, DPS94]) and to the \nresearch of ef\u00adficiency, which requires accompanying locations with extra information qualifying their \ncontent and chiefly their type. Nevertheless we believe that our proposal is more useful in a context \nwhere many programs will be reused not through their text but from their runtime appearance. First-class \nenvironments were known in T as locales but are also present in MIT-Scheme; a detailed presentation ap\u00ad \npears in [MR91]. Environments are created with make-env\u00adironment and they are all ext ensible since computations \nmay be performed in any first-class environment using a bi\u00adnary eval function. Therefore it is not possible \nto capture a finite set of locations and the problem of incremental defi\u00adnition occurs negating the quasi-static \ndiscipline. Apart the runtime burden suffered by eval which, compared to our import, has to compile expressions \non the fly, a very efi\u00adcient implementation of dynamic resolution of variables is proposed. Interactive \nmodular program ming [Tun92] aims to allow the concurrent development of code within distinct module \nenvironments. Definitions are qualified as private or public to specify their scope. It is interactively \npossible to add or retract importations of modules inside a module environ\u00adment; these operations affect \nthe resolution of variables and thus negates quasi-static discipline. Reflective first-class environment \nappear in [Jag94]. Im\u00adportation and exportation are accomplished with operations respectively named reflect \nand reify. To ease the implicit manipulation of environments, these operations may have an additional \nargument: a closure standing for its closed envi\u00adronment. Variables may be qualified aa public and are \nthus automatically capt urable by a (reify) form. Reification barrier may also be installed to limit \nthese captures. The implementation suggested in section 5 is similar to the local caching strategy of \n[Jag94]. The closest work is [LF93] whose goal was similar to us i.e. to share locations; they introduced \nthe quasi-static concept from which we derive the quasi-static discipline that allows variables to be \nunambiguously resolved once and for all, a paramount quality in our eyes. They introduce two new special \nforms: qs-lambda and resolvel. A quasi-static procedure is returned by qs-lambda and represents a pa\u00adrametrized \npiece of code which may be applied as any reg\u00adular function but may also be made more static if resolving \n(with resolvei) one of its parameterizing variables to some location. We consider this double behavior \nas a nuisance and favor first-class environment on which there exists a unique operation: the importation. \nRenaming is natively offered by qs-lambda aa well as an original lexical inheri\u00adtance mechanism relating \nparameterized variables of nested qs-lambda forms. We instead provide renaming and ex\u00adtension of first-class \nenvironments by functions that do not impact our import form. We also offer the possibility to manage \nimplicit sets of free variables and extensible environ\u00adments therefore providing a substrate on which \nit is possible to build or describe interactive toplevel loops. Conclusion The Scheme Repository is an \nexample of an Internet re\u00adsource containing interesting programs. Its usability is com\u00adpromised by, at \nleast, the presence of heterogeneous macros and implicit assumptions on how to process that code (com\u00adpile, \nload, eval and their variation). After macroexpansion, such programs may be made more sharable if packaged \nas pure Scheme textual modules expecting an environment pro\u00adviding the required locations. If the Net \nsoon appears as a big repository of values and programs then to be able to capture these locations or \nvaJues for later use will be of primary importance. Parts of applications may be released as modules \nand thus may be automatically upgraded whenever their imported loca\u00adtions are upgraded. To avoid these \ndependencies, other parts may be delivered as ready-to-use values or first-class envi\u00adronments. In both \ncases, first-class environments are mod\u00adern hooks that represent a simple and controlled way to customize \npackages by operating on the true (locations of) variables. Were we to summarize the significance of \nour paper, we would say that (i) it binds quasi-static variables with first\u00adclass environments, (ii) \nit introduces extensible environ\u00adments avoiding the increment al definition problem, (iii) it reconciles \nefficiency of first-class environment and some reflective operations, (iv) it makes a clear distinction \nbe\u00adtween the orthogonal roles of mapping names to locations and locations to values. Acknowledgments \nMany thanks to Luc Moreau and the program committee for their enlightning comments. Bibliography IBDG+ \n881 Daniel G. Bobrow, Linda G. DeMichiel, Richard P. Gabriel, Sonya E. Keene, Gregor Kiczales, and David \nA. Moon. Comon lisp object system specifi\u00adcation. SIGPLA N Notices, 23, September 1988. spe\u00adcial issue. \n[BL84] R BurstalJ and B Lampson. A kernel language for modules and abstract data types. Technical Report \n1, DEC SRC, September 1984. [Car84] Luca Cardelli. Compiling a functional language. In Conference Record \nof the 1984 ACM Symposium on LISP and Functional Programming, pages 208 217, Austin, Texas, August 1984. \nACM Press. [CR90] Pavel Curtis and James Rauen. A module system for scheme. In Proceedings of the 199o \nACM Conference on Lisp and Functional PTogvamming, Nice, France, June 1990. [CR91] William Clinger and \nJonathan A Rees. The revised4 report on the algorithmic language scheme. Lisp Pointer, 4(3), 1991. [DPS94} \nHarley Davis, Pierre Parquier, and Nitsan %&#38;k. Talking about modules and delivery. In Proceed\u00adings \nof the 1994 ACM Conference on Lisp and Functional P.ogrammming, pages 113 120, Orlando (Florida USA), \nJune 1994. ACM Press. [FF86] Matthias Felleisen and Daniel P. Friedman. A closer look at export and import \nstatements. Journal of Computer Languages, 11(1):29-37, 1986. [FW84] Daniel P. Friedrrmm and Mitchell \nWand. Reifica\u00adtion: Reflection without metaphysics. In Confer\u00adence Record of the 1984 ACM Symposium on \nLISP and Functional Programming, pages 348 355, Austin, TX., August 1984. [GJL87] David Gelernter, Suresh \nJagannathan, and Thomas London. Environments as first-class objects. In Con\u00adference Record of the Fourteenth \nAnnual ACM Sym\u00adposium on Principles of Programming Languages, pages 98 110. ACM Press, January 1987. \n[Jag94] Suresh Jagannathan. Metalevel building blocks for modular systems. ACM Transaction on Progmm\u00adming \nLanguages and Systems, 16(3):456-492, May 1994. [Lam88] John Lamping. A unified system of pararneterization \nfor programrm ng languages. In LFP 88-ACM Sym\u00adposium on Lisp and Functional PTogvamming, pages 316 326, \nSnowbird, Utah, July 1988. ACM Press. [LF93] Shinn-Der Lee and Daniel P IMedman. Quasi-static scoping: \nSharing variable bindings across multiple lexical scopes. in POPL 93 Twentieth Annual ACM symposium \non Principles oj Programming Lan\u00adguages, pages 479 492, Charleston (South Carolina, USA), January 1993. \nACM Press. [MR91] James S Miller and Guillermo J Rozas. Free vari\u00adables and first-class environments. \nLisp and Symbo Iic Computation: An International Journal, 4(2):107\u00ad141, 1991. [OUS93] John K Wesley, \nOusterhout. 1993. Tcl and the Tk Toolkit. Addison\u00ad [QP91] Christian Queinnec and Julian Padget. Modules, \nMacros and Lisp. In Eleventh International Confer\u00adence of the Chilean Computer Science Society, pages \n111 123, Santiago (Chile), October 1991. Plenum Publishing Corporation, New York NY (USA). [Que94] Christian \nQueinnec. Les langages Lisp. Interl&#38;li\u00adtions, Paris (France), 1994. ISBN 2 7296 0549 5, 61 24481, \nEnglish version soon available from Cam\u00adbridge University Press. [RAM84] Jonathan A. Rees, Norman I. \nAdams, and James R. Meehan. The T Manual, Fourth Edition. Yale Uni\u00adversit y Computer Science Department, \nJanuary 1984. [sun95] Sun Microsystems. 1995. Java Language Specification, [Tuu92] Sho-Huan Simon Tung. \nInteractive moduiarprograrn\u00adming in scheme. In Proceedings of the 199.2 ACM Conference on Lisp and Functional \nProgramming, pages 86 95, San Francisco, USA, June 1992.   \n\t\t\t", "proc_id": "232627", "abstract": "Nowadays the Net is one of the most obvious driving forces. Yet, to consider it as one global store through which values and code may be shared is still immature. This paper suggests first-class environments as a means to achieve that goal in a multi-user Scheme framework. We propose two new special forms with a simple semantics. Our model allows precise control over environments (including extensible environments) and does not require (but does not prevent) reflective operations.", "authors": [{"name": "Christian Queinnec", "author_profile_id": "81100373159", "affiliation": "&#201;cole Polytechnique & INRIA-Rocquencourt and Laboratoire d'Informatique de l'&#201;&#201;cole Polytechnique (URA 1439), 91128 Palaiseau Cedex, France", "person_id": "PP14132326", "email_address": "", "orcid_id": ""}, {"name": "David de Roure", "author_profile_id": "81100497770", "affiliation": "Department of Electronics and Computer Science, University of Southampton, Southampton SO17 1BJ, UK", "person_id": "P64522", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/232627.232653", "year": "1996", "article_id": "232653", "conference": "ICFP", "title": "Sharing code through first-class environments", "url": "http://dl.acm.org/citation.cfm?id=232653"}