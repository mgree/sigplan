{"article_publication_date": "06-15-1996", "fulltext": "\n Deriving Structural Hylomorphisms From Recursive Definitions Zhenjiang Hu Hideya Iwasaki Department \nof Information Engineering Educational Computer Centre University of Tokyo University of Tokyo (huOipl \n.t .u-tokyo .ac. jp) (iwasaki@rds .ecc .u-tokyo. ac. jp) Masato Takeichi Department of Information Engineering \nUniversity of Tokyo (takeichi@u-tokyo .ac. jp) Abstract In functional programming, small programs are \noften glued together to construct a complex program. Program fusion is an optimizing process whereby \nthese small programs are fused into a single one and intermediate data structures are removed. Recent \nwork has made it clear that this process is especially successful if t he recursive definitions are expressed \nin terms of hylomorphisms. In this paper, we propose an al\u00adgorithm which can automatically turn all practical \nrecursive definitions into structural hylomorphisms making program fusion be easily applied. 1 Introduction \nThe compositional style of functional programming has the advantages of clarity and higher level of modularity. \nIt constructs a complex program by gluing components which are relatively simple, easier to write, and \npotentially more reusable. However, some data structures, which are con\u00adstructed in one component and \nconsumed in another but never appear in the result of the whole program, give rise to the problem of \nefficiency. Consider a toy example of function all testing whether all elements of a list satisfy the \ngiven predicate p. It may be defined as follows. all p= and o (map p) where and = Axs. case zs of Nil \n+ !lkuq Cons (a, as) + a A (and as) Here p is applied to all elements of the list producing an in\u00adtermediate \nlist of Booleans wh!ch are then anded together by the function and producing a single Boolean result. \nTo make the function all be computed efficiently, it is expected to fuse and and map p together to have \nthe following new definition where the intermediate list of Booleans is never produced. Permissiontomakedigitabtmrdcopyofpartorallofthii \nworkforpersonal or dassmrn use is rantad witlwut fee provided that copies are not made 1e, the mpyright \nnotice, the or distributed for pto t or commercial dvanta title of the blication and its date appear, \nan i notice k given that copying rIS yparmiaeionofACM,Inc.Totxpy otherwise,torepublish,to post on aarvws, \norb mdistributa to lists, raquiras prior specific permission @or a fee. ICFP W 5/9S PA, USA 01996 ACM \n0%9791-771-3WOO05...$505O all p = Axs. case zs of Nil + Tr Uq Cons (a, as) + pa A (all p as) There are \ntwo kinds of approaches dealing with such fusion. One, first proposed by Wadler [Wad88, Chi92] as called \ndeforestation, aims to fuse arbitrary functions by fold\u00adunjold transformations, keeping track of function \ncalls and using clever control to avoid infinite unfoldlng. The other [GLJ93, SF93, TM95], quite differently, \nmakes use of some specific forms such as catamorphisms (or called jolds), ana\u00admorphisms (or called unfolds) \nand hylomorphisms and finds how they interact. The second approach has been proved to be more prac\u00adtical \nin a real implementation in compilers, although at first sight it seems less general than the former. \nIts theoretical basis can be found in the study of Constructive Algorith\u00admic [Fok92, Ma190, MFP91] which \nwill be outlined in Sec\u00adtion 2. In constructive algorithmic, data types are categor\u00adically defined as \ninitial algebras of functors, and functions from one data type to another are represented as structure\u00adpreserving \nmaps between algebras. By doing so, an orderly structure can be imposed on the program and such structure \ncan be exploited to facilitate program fusion. However, this approach imposes recursive structures of \nspecific forms on programs, which is unrealistic in practi\u00adcal functional programming. One attempt to \novercome this problem has been made by Launchbury and Sheard[LS95]. They gave an algorithm to turn recursive \ndefinitions into so\u00adcalled build-cat a forms (i.e. catamorphisms with construc\u00adtors being parameterized) \nso that the shortcut deforestation technique becomes applicable. One major problem still left is that \nthe build-cata form is too restrictive to describe some kinds of practical recursive definitions and \ntherefore many intermediate data structures cannot be removed. The purpose of this paper is to demonstrate \nhow prac\u00ad tical recursive definitions can be automatically turned into hylomorphism, general forms covering \nall those in [MFP91, SF93, TM95], which makes program fusion transformation be applied better. The main \ncontribution of this work is as follows. We propose an algorithm which can automatically turn almost \nall recursive definitions of interest to structural hylomorphisms. With the fusion systems[SF93, KL94, \nTM95] successfully developed for hylomorphisms, we can improve a larger class of programs freely defined \nby programmers. Our algorithm is guaranteed to be correct, and to ter\u00adminate with a successful hylomorphism. \nTo the con\u00adtrary, Launchbury and Sheard s derivation algorithm of build-catas [LS95] from recursive definitions \nmay fail tO give Imild-catas. Their algorithm has to be on the alert against failure of the two-stage \nfusion and gives up the derivation in case failure occurs. . Our algorithm structures hylomorphisms so \nthat the Hylo Fusion and Acid Rain Theorems (Section 2) can be effectively applied. Particularly, we \npropose a new theorem for deriving polymorphic functions (Section 5.2), namely ~ and a, for the use of \nAcid Rain Theo\u00adrem. Our algorithm does not limit its use to the fusion of recursions inducting over a \nsingle data structure. It is helpful for the fusion of recursions over multiple data structures without \nintroducing new fusion theorems as in [FSZ94] (Section 4.4). Moreover, it is also useful for other program \noptimizations such as removal of mul\u00adtiple traversal over the same data structures[Tak87]. This is because \ngeneral optimization rules are much easier to be defined over hylomorphisms rather than over the recursions. \n This paper is organized as follows. In Section 2 we re\u00adview the previous work in Constructive Algorithmic, \nthe theoretical basis of hylomorphisms. Section 3 defines a sim\u00adple language for the description of recursive \ndefinitions. We dkicuss our algorithm in Section 4 and 5. In Section 4 we define our algorithm for deriving \nhylomorphisms from recur\u00adsive definitions, and in Section 5 we give the algorithm for structuring hylomorphisms \nso that the two fusion theorems can be effectively applied. Section 6 discusses the related work and \nSection 7 gives the conclusion. Background In this section, we review previous work [Ma190, MFP91, Fok92, \nTM95] on constructive algorithmic and explain some basic facts which provide theoretical basis of our \nmethod. Throughout this paper, our default category C is a CPO, the category of complete partial orders \nwith continu ous func\u00ad tions. 2.1 Functors Endofunctors on category C (functors from C to C) are used \nto capture both data structure and control structure in a type definition. In this paper, we assume that \nall the data types are defined by endofunctors which are only built up by the following four basic functors. \nSuch endofunctors are known as polynomial functors. Definition 1 (Identity) The identity functor Ion \ntype X and its operation on func\u00adtions are defined as follows. 1X=X If =f o Definition 2 (Constant) \nThe constant functor !A on type functions are defined as follows. X and its operation on IAX !Af D = \nA id where id stands for the identity function. o Definition 3 (Product) The product X x Y of two types \nX and Y and its operation to functions are defined as follows. XXY = {(z, y)lz Ex, yEY} (f Xg) (X, y) \n= (fz, gy) Some related operators are: 7rI (a,b) = a T2(u,b) =b (f 9) a = (fa, ga). D Definition 4 \n(Separated Sum) The separated sum X + Y of two types X and Y and its operation to functions are defined \nas follows. X+Y = {1} XX U{2}XY (f +9) (1,X) = (1, f x) (f +9) (2, Y) = (2, 9Y) Some related operators \nare: L1 a = (l,a) LZb = (2,b) (f V9) (1,X) = f~ (fv9)(2, Y) = 9Y. 1  Although the product and the separated \nsum are de\u00adfined over 2 parameters, they can be naturally extended for n parameters. For example, the \nseparated sum over n pa\u00adrameters can be defined by +?=lxt = U~=l({i} x X,) (+ P=lfi) 0,$) = (J, f, x). \n 2.2 Data Types as Initial Fixed Points of Funct ors A data type is a collection of operations (data \nconstruc\u00adtors) denoting how each element of the data type can be constructed in a finite way, and via \nthese data constructors functions on the type may be defined. So a data type is a particular algebra \nwhose one distinguished property is cat\u00adegorically known as the initiality of the algebra. Let C be a \ncategory and F be an endofunctor from C to C. Definition 5 (F-algebra) An F-algebra is a pair (X, ~), \nwhere X is an object in C, called the carrier of the algebra, and @ is a morphism from object F X to \nobject X denoted by # :: F X + X, called the operation of the algebra. 1 Definition 6 (F-homomorphism) \nGiven two F-algebras (X, q)) and (Y, @), the F homomor\u00adphism from (X, ~) to (Y, ~) is a morphism h from \nobject X to object Y in category C satisfying h o ~ = * o F h. o Definition 7 (Category of F-algebras) \nThe category of F-algebras has as its objects the F-algebras and has as its morphisms all F-homomorphisms \nbetween F\u00adalgebras. Composition in the category of F-algebra is taken from C, and so are the identities. \n1 It is known that the initial object in the category of F\u00adalgebras exists when F is a polynomial functors[Ma190]. \nThe representative for the initial algebra is denoted by pF. Let (T, in~) = pF, pF defines a data type \nT with the data constructor inJ7 : FT + T. Function odF :T+ FT is theinverse of in F?and it destructs \nits argument and is therefore called data destructor-. To be concrete, consider the data type of cons \nlists given by the following definition with elements of type A: List A = Nil I Cons (A, List A). It \nis categorically defined as the initial object of (List A, Nil v Cons) in the category of LA -algebrasl, \nwhere LA is the endofunctor defined by LA = !1 + !A x I (1 is the terminal object in C). Here, the data \nconstructor and the data destructor are as follows. inLA = Nil v Cons outLA = Ass. case Xs of Nil + (1, \n()); Cons (a, as) + (2, (a, as))  2.3 Hylomorphisms over data types Hylomorphisms in triplet form[TM95] \nare defined aa follows. Definition 8 (Hylomorphism in triplet form) Given two morphisms ~ :GA + A, + \n:B + F B and natu\u00adral transformation v : F 4 G, the hylomorphism [O, ~, @]G,F is defined as the the least \nmorphism f : B + A satisfying the following equation. o Hylomorphisms are powerful in description in \nthat prac\u00adtically every recursion of interest (e.g., primitive recursions) can be specified by them [BdM94]. \nHylomorphisms are quite general in that many useful forms axe their special cases as defined below. Note \nthat we sometimes omit the subscripts G and F when it is clear from the context. Definition 9 (Catamorphism, \nAnamcsrphism, Map) Let (TF, in~) = pF, (TG, Zno) = pG. [-DF VA. (F A+ A)+ TF+A (9$F = [~, id, otltF]F,F \n[(+ : VA. (A+ FA)+A+TF [@)]F = [inF, id, +]F,F (.]G,F : (F4G) +TF +TG {~k = [inG, V, Of.JtF]G,F cl 1Strictly \nspeakhg, Nil should be written as A(). Nd. In this paper, the function with the form of A () .twill be \nsimply denoted as t. Catamorphisms [-] are generalized foldr operators (or reduces) that substitute the \nconstructor of a data type with other operation of the same signature. Dually, anamor\u00adphisms ~_)]are \ngeneralized unfold operators (or generations). Maps {-} apply a natural transformation on the data struc\u00adture. \nMaps can be represented as both catamorphisms and anamorphisms based on the following Hylo Shift Theorem. \nThe Hylo Shift Theorem shows that some computations can be shifted within a hylomorphism. For program \nfusion, hylomorphisms possess the general laws called the Hylo Fu\u00adsion Theorem. Theorem 2 (Hylo Fusion) \nLeft Fusion Law: fo#=#o Gf f 0 [d> q, ~k,~ = [d, V, @]a,F Right Fusion Law: $og=Fgoq/ o [h?f,~h09 = \n[h ~) %%>F These laws are quite general in the sense that the func\u00adtions to be fused with, e.g., f and \ng in Theorem 2, can be any functions. If f and g are restricted to specific hylomor\u00adphisms, we could \nhave the following simple but praxtical Acid Rain Theorem[TM95]. Theorem 3 (Acid Rain) Cata Hylo Fusion \nLaw: T: VA. (F A+ A)-+ F/A+A [ #~91, outF]G,F 0 [7in~,92, @]P,L = [7(+ o 711),~2, Y]FI,L Hyl&#38;Ana \nFusion Law: u: VA. (A-+ FA)+A+F A [d, Vl, aoutF]G,F 0 [~nF, V2, @]F,L = [#,91,dV20 + )]G,FJ u 3 Language \nTo demonstrate our techniques, we use the language given in Figure 1 for the description of recursive \ndefinitions. It is nothing special except that functions are defined in an un-curried way. In order to \nsimplify our presentation, we restrict ourselves to single-recursive data types and func\u00adtions without \nmutual recursions, since the standard tupling technique can transform mutual recursive definitions to \nnon\u00adrnutual ones. We also assume that recursive function calls are not nested and only occur in the terms \nof the alternatives in the definition body. Several simple examples of recursive definitions are given \nbelow. The function sum sums up all the elements in a list, the function upto generates a list of natural \nnumbers between two given numbers, and the function zip turns a pair of lists into a list of pairs. Decl \n::= v = b b ::= Au.. case to of r us ::= Wl(vl, . . ..vn) r ::= pl+tl; . . ..pn+tn t ..= j ~tl,..., tn) \nI Vt I Ct P ::= c p I (Pl> ,Pn) Iv  (recursive) function definition definition body argument alternatives \nvariable term tuple function application constructor application pattern pattern tuple variable Figure \n1. The language sum : List A-+Int sum = ~xs. case xs of Nil -+ (); Cons (a, as) -+ plus (a, sum as) \nupto : Int x Int + List Int upto = A(b, e). case b < eof lkue -i Nil; False + Cons (b, upto (plus (b, \n1), e)) zip :List AxList B-+List (AxB) zip = J(z.s, ys). case (XS, ys) of (Nil,.) + Nil; (Cons (a, as), \nNil) + Nil; (Cons (a, as), Cons (b, bs)) + Cons ((a, b), zip (m,bs)) Here plus is the function adding \ntwo integers. Next, let s consider definitions of higher order functions, such as map:(A -+B) + List \nA~ List B map g = Axs. case xs of Nil -+ Nil; Cons (a, as) + Cons (g a, map g as) which is not a valid \ndefinition in our language since the de\u00adfined function map g is not a variable. The simplest way to solve \nthis problem is to consider map g aa a packed vari\u00adable and g as a global function. That is, the above \ndefinition is considered something like map.g = Axs. case xs of Nil +-Nil; Cons (a, as) + Cons (ga, map-gas). \n Viewed in this way, map g can be regarded as a valid defi\u00adnition. Below is another similar example. \nfoldrl: (Bx B+ B)+ List B*B foldrl @ = Axs. case xs of Nil + error; Cons (a, Nil) -) a; Cons (a, as) \n+ a @ (foktrl @ as) 4 Expressing Recursions as Hylomorphisms In this section, we propose an algorithm \nto turn recursive definitions into hylomorphisms. Consider the following typ\u00adfor Recursive Definitions \nical recursive definition of function f. f =Jv.. case toofpl +tl;..;pn +tn If we can turn the right \nhand side into the form of ~oF f o@, it soon follows that ~ = [+, id, +]~,~ from the definition of hylomorphisms \n(Definition 8). 4.1 Main idea The trick to do so is to turn each term t, (i = n)into 1,...,  gi t;, \na suitable function being applied to a new term. Put it in more detail, supposing that we have got that \nt~ = g? t:, the original definition becomes: j =Avs. case to ofpl +glt~;...;pa+gnt~. Extracting all \ng, s out and adding tag i to t:can give a compositional description of f: i=(91v v9n)o (Au.. case to \nofpl + (l, t~); . . . ;pn -) (n, t~)). If g, can be expressed as ~, o F; f where F, is some functor, \nit soon follows that g~v . . . vgn=(qhv v~n)o (Fl+. ..+ Fn)f. Now replacing it in the above compositional \ndescription of f gives: f=(lj,v . . . v@n)o(Fl+. + FW)fo (Au,. case to ofpl -) (l, tj); ..; pn + (n, \nt~)). According to the definition of hylomorphisms, we have f = M, id, 4J]iJ,~ where F = F1+. --+F. \n@ = @,v... vl#n @ = ~v.. case to ofp~ + (I, tl); . . ..pn + (n, t~). The essential point of our algorithm \nis, therefore, to de\u00adrive a function +i, a functor F, and a new term t:from each term tisatisfying t, \n= (#i o F f) t:. A[~=h3.case to Ofpl +tl;...;pn ~tn] = (j= [+1 v . . . v #n,2d, @]F,F) where F =F l+. \n..+Fn F ~=!l, ifk; =l; =O x!r(vj~ ) x ~1x ... x Ii,, (11 = . . . = L, = 1), otherwise =!r(vil] x... \n#t= A(v81, , viki, v;,,. ,w:,, ).tY @= Avs.caae to ofp, -i (l, t~); . . ..pn + (n, t~) t:=(vil,.. .,v,ki, \ntil, ti, i)i,i) where ({vi,, - ,viki}, {(v~,, ft~,),  ,(vl,i, ft*j, )},t?) = ~[t~l, (~= 1, ,~) r(v) \n= return v s type V[v] = if v is a global variable then ({}, {}, v) else ({v}, {}, v) D[(tl, . . . ,tn)]=(sl \nu... usn, clucn, (tj, (tj,... ,t;)) where (si,ci,t~)D[ti],z... n == 1,. V[v t] = if v= ~then ({},{(u,ft)},u)else \n(s. Ust, c. Uct,hh) ~ is~)h-vaiable where (sU,cV,t~ D[v], (st, ct, tt) = D[t] D[C t] = (s, c, Ct ) where \n(s, c, t )= D[t] Figure 2. Algorithm for Deriving Hylomorphisms 4.2 Deriving ~i, Fi and t:from t, Our \nalgorithm to derive ~,, Fi and t;from t;is informally as follows. 1. Identify all the occurrences of \nrecursive calls to ~ in t,, saytheyarettil, . . . . jiili; 2. Find all the free variables in tibut not \nin til, . . . t,li, saythey axevil, . . ..vib. *;  3. Define t:by tupling all the arguments of the \nrecursive calls obtained in Step 1 and the free variables obtained instep 2, i.e. t~=(vil,...,v$ki,tzl?... \n>%, ). 4. Define F2 according to the construction of t;byFi = !r(vil) x.. .x!qv,k, )x 11 x.. -xlzi, \nwhere n=...= 11, = I and r returns the type of the given variable.  5. Define ~~ by abstracting all \nrecursive function calls in tiby  qk=~(vil,. , vik,, v:l,..., v:,,). ti[fti* *V~l,..-,jfti/i l+V~l,] \nwhere V[l, . . . , v~,, are new variables introduced for re\u00ad , placing those occurrences of ~ til,. ... \nj ti,i.  4.3 Algorithm for Deriving Hylomorphisms The derivation algorithm described above is summarized \nin Figure 2. The main algorithm is A which turns a recursive definition into a hylomorphism. The algorithm \nA calls the algorithm D to process each ter m t,returning a triple, that is, {Vi,, . . . jVz~, }, {(v:l, \nft$l),..., (v;t,, ft,,, )}, = D[t,]. t~[fti~*Vjl,..., t t;,, * Vl,i ] ( ) The algorithm D actually \nimplements most of the algorithm in Section 4.2. It is worth noting that every time an occur\u00adrence of \nrecursive call is found, a fresh variable is allocated for the replacement. The algorithm A is correct \nand guar\u00adanteed to terminate with a successful hylomorphism as its result. Theorem 4 (Correctness of \nAlgorithm A) By the Algorithm A in Figure 2, a recursive definition of ~=~v.. case toofpl -+tl; . . \n..pn -+tn can be equivalently described by a hylomorphism as f=[#, v... v @n, ~~j #] F, I . Proof: \nFirst, we show that [qtJIv . . . v @n,id, @]F,F is in a correct hylomorphic form because 1. F is a polynomial \nfunctor; 2.fpl v... v &#38; hasthe type ofFTo + Toand+has the type of Ti + F Ti, as easily verified, \nwhere T, and To denote f s input type and output type respectively; 3. id is a natural transformation \nfrom F to F. Next, we argue that f = [@l v . . . v ~n, id, t/J]~,~ is equivalent to f = Avs. case to \nof pl -+ tl; ... ;Pn + % by the following calculation. _ f=[rj, v . . . v#n,id,+]~,~ . { Definition of \nhylomorphism } f=dl v vq$noido Ffo@  { Definition of ~ and F } f=dl v v@no(Fl+ . +Fn)fo (Avs. case \ntO of p, -i (l, t~); . . . ;pn + (n, t&#38;))  { Promote function into caseexpression } f = Au.. case \nto of pl -+ (+1 oFlj) tj; .... p. + (@.oF. f) t:  . { To be proved later ] f =Av,. case tOofpl +tl;...;pn+tn \n To make the above proof complete, we need to show that Section 6 will show how it helps removing more \nintermediate for any i, (#~ OF, f) tj= t, which can be easily proved as follows. (~, oF, f) t:  = { \nDefinition of t~ s } ((h-o F; f) (u,, . . . ,wki,ta,,  ~,ti,, ) ~ { Definition of,F i and @i } (A(Vi~ \n, .--, vi~i, vii, . . . ,V;li ).t:) (vi, , <+, Vik,, ftii,.. -, fti)i) ~ { Simplication } t~[v(l* 1+fti~,..-,vjli.f%il \n~ { Property of D algorithm } 1 ti  4.4 Examples To see the algorithm d in action, consider some examples \ndefined in Section 3. We begin by considering a quite simple definition of sum. In this case, we know \nthat tl = O and ih= plus (a, sum as). Applying D to tland tz gives qo] = ({},{},0) D[pk (a, sum as)] \n= ({a}, {(v\\, sum as)}, plus (a, v;)). It follows from A that t; = (), (), =A().0=0 ti = (a, as), @2 \n= A(a, 4). plus (a, vi) = plus and + = Axs. case zs of Nil+ (1, ()); Cons (a, as) + (2, (a, as)) = \nO lbt F F = !l+!lnt xl. Therefore we derive the following hylomorphkm for sum: sum = [0 v phs, id, OUtF]F,F. \n Notice that the above hylomorphism is also a catamorphism (O v pk]~. Our second example is to deal \nwith the recursive defi\u00adnition of foldrl @. This also appeared in [GLJ93] for the illustration of the \nlimitation of their shortcut deforestation algorithm because foldrl @ cannot be specified as a cata\u00admorphlsm \n(since it does not treat all Cons cells identically). With the algorithm A, we can get the following \nhylomor\u00adphkm. foldrl @ = [4, id, y]~,~ where F=!l+!B+!Bx I @=@lv@2vf#3 where @l = error; ~z= Aa.a= id \n43 =A(a, d). (a@vi) =@ * = Axs. case zs of Nil-i (1, ()); Cons (a, Nil) + (2, (a)); Cons (a, as) + (3, \n(a, as)) data structures than [GLJ93]. Next we d like to to show that our derivation algorithm does \nnot restrict to the recursive definitions inducting over a single parameter. Consider the recursive definition \nof zip which inducts over multiple parameters. Applying algo\u00adrithm A will give the following hylomorphism. \nzip = [Nil v Nil v A(a, b,p). cons((a, b), P), id, @]~,F where F=!l+!l+!Ax!13 X1 @ = ~(xs, ys). case \n(zs, ys) of (Nil, -) + (1, ()); (Cons (a, as), Nil)+ (2, ()); (Cons (a, as), Cons@, bs)) + (3, (a, b, \n(as, bs))) The advantage of this transformation is that zip now can be fused with other functions by \nthe Hylo Fusion Theorem. Compared with Fegaras approach[FSZ94] where some new fusion theorems were intentionally \ndeveloped, our algorithm makes it unnecessary to obtain the same effect. More de\u00adtailed discussion can \nbe found in [HIT95]. Finally, we give some other examples. map g = [Nil v ~(a, v~).cons (ga, V{), id, \notJtL~]L~,L~ upto = [in~lnt, id, @lLIn ,~lnt where @= A(b, e~. case b < e of True + (1, ()); False + \n(2, (b, (plus (b, 1), e))) 5 Restructuring Hylomorphlsms Once a hylomorphlsm is obtained, it can be \nfused with other functions. But not all hylomorphisms have good structures for program fusion to be effectively \napplied. In this sec\u00adtion, we show how to structure the given hylomorphism [d, q, y]G,F W arranging 4, \nq and@ well inside it, so that it could be fused with other functions effectively by the two fusion theorems, \nnamely the Hylo Fusion and the Acid Rain Theorems. 5.1 Suitable Hylomorphisms for Hylo Fusion The\u00adorem \nThe effective use of the Hylo Fusion Theorem requires that 4 (4) in a hylomorphism [d, q, @]G,F contain \nas much com\u00adputation as possible for the Left (Right) Fusion Law. As an example, consider the following \nprogram foo, where N rep\u00adresents the type of natural numbers with two constructors Zero and Succ. foo \n: List N+ List N foo = h o [inL~, id, (id+ Succ X id) o outLN]LN,LN where h = Axs. case xs of Nil -Nil; \nCons (Zero, Nil) -Nil; Cons (Zero, Cons (z , m )) ~ Cons (Succ x , h d); Cons (Succ z , ZS ) ~ Cons (Succ \nz , h XS ) To fuse foo by the Left Fusion Law, we have to derive @ from the equation h o inLN = + o LN \n~-But such # c~not 78 be derived because of the lack of information in in&#38;. To solve this problem, \nwe shift some computations into ~nLN and get the following program: foo = h o [ZnLN o (id+ hcc X id), \nid, OUtLN]LN,LN. Because of the knowledge that the value of Succ x cannot be Zero and thus the second \nand third branchs of the case expression in h cannot be taken, we can derive that c+ = Nil v (Cons o \n(Svcc ~ zd)) and have ~oo = [q$ ,id, OUtLN]LN,LN. Similar cases might happen to the Right Fusion Law. \n5.2 Suit able H ylomorphisms for Acid Rain Theo\u00adrem The Acid Rain Theorem expects ~ and @ in the hylomor\u00ad \nphism [#, q, #]G,F : A + B to be described as r in~~ and u OU~FA respectively. Here, ~ and u are polymorphic \nfunc\u00adtions and FA and FB are functors defiriing types A and B respectively. Our Laws for deriving such \n~ and o are as follows. Theorem 5 (Deriving Polymorphic Function) Under the above condkions, r and a \nare defined by the following two laws. Proof: We shall only prove the law for defining ~. The law for \ndefining o can be proved in a dual way. First, we have to check if r has the type of VA. (FB A -+ A) \n+ GA + A as required. This is obvious since r is defined for all a : FB A -+ A with any A; Next we prove \nthat r#J= ~ in~~ by the following calcula\u00adtion. Because in applying the Acid Rain Theorem we have to \nderive r$ (@ ) from @(~) for any a (f?) in order to define r (u), it is expected that 4 (~) is simple \n(contains few com\u00adputations). To see the practical usage of Theorem 5, we demonstrate how to derive a \nfrom # (the third part of hylomorphisms). Observe that @ is usually in the form of ks. case xs of pI \n+ (l, tl); . . ..pm + (n, tn). Sometimes it can be transformed into x o K where K = F~outFA 0 ...0 F; \nOUtF~ o O UtFA. Here K unfolds the data d times to cover all nested pattern Pi s, and x is a transformation \nfrom F~+l strUcture2 to F structure to match every term t;with p, while satisfying the following property. \nIn this case, according to Theorem 5, u will be defined as because r7=~@x[OUtFA t+@] OF~~0-. .oF;@o~ \n -i= { Theorem 5 } X o F~OUtFA 0.. . IJ F~ OUtF~ o OUtFAo [@)]FA = W41FA o x[outFA H P] o F~/3 0 ...0 \nF~ ~ o P ~ { Anamorphism: o?-dF~o [B)lFA = FAKD)]FA o @ } xOFjoutFA 0 . . . 0 F: OUtF~ o F~[(,@]F~ o \n~ = WD)IFA o x[outFA ++ /3] o F~/3 0 ...0 F~ @ o @ = { Functor FA } XOF~outq 0 . . . 0 F~ (OutF~ o KP)IFA) \n0 @ = F[(P)IFA o x[outFA I-+ B] o @b 0 ...0 F; @ o D ~ { Repeat the above transformation } XO~ +l[(@]FA \no@/?o... o@o@o@ = W)IFA o XIOWtFA I+ ~] o F~@ 0 ...0 F; ~ o @ . { Property of x } True. As a concrete \nexample, consider the hylomorphism we derived for fokh-1 @ in Section 4.4. We can derive a poly\u00admorphic \nfunction from its $ such that @ = UOutL~, where ~-1 can be think of as a folding of /3 and dist is a \nnatural transformation defined as follows. dist XX(Y+Z)+XXY+XXZ dist(z, (1, y)) = (1, (Z, y)) dist(z, \n(2, .Z)) = (2, (x, y)) Therefore, we obtain foldrl @ = [e?TOr v id V @, id, ~o~tLB]F,F. 5.3 Algorithm \nfor Structuring Hylomorphisms Generally, the behavior of a hylomorphism [+, V, +~G,F could be understood \nas follows: @ generates a recursive structure, q operates on the elements of the structure, and @manipu\u00adlates \non the recursive structure. It is possible for@ and@ to have the computation that q can do. They are \nsaid to have the least computation if they do not have computation that q Carl do. A hylomorphism [#, \nq, ~] is said to be structural if # and @contain the least computation. Structural hylomorphisms are \nfit for the two fusion theorems. For the Acid F/An The\u00adorem, it is suitable since @and @are simple. For \nthe Hylo Fusion Theorem, since # (~) contain the least computation, it implies that q o @ (@o q) contains \nthe most computation and so [~, id, q o @] ([@o q, id, @]) is suitable for the Right 2Here~~~= F~rn-l \noFA. 0 %@]G ,F 7 W,i ) =!r(u,l) X... X!r(utmi)XII X... XI1;, (11 =... = l/i = 1), otherwise where A(v,l, \n. . . ,V; ki ,v~l, . o. , v;, ). t,= #,,(assume v~l, . . . . v;, are recursive variables) ({(w,, ti, \n), , (%, ,t!m:)}, t:) = &#38;[ti] {V:l,  >V:t, } &#38;[v] s, = if v c s, then ({}, v) else ({(u, v)}, \nu) where u is a fresh variable &#38;[(tI,... ,tn)]= if Vi, Var,r(t,) then ({(u,....tn))}.(t\\,... s, (tl,u)else(w1 \nU ...Uwn, ,t~)) where (w,, t:) = &#38;[tt] s, (i = 1, ..-, n), u is a fresh variable t[c t] s, = if Vars7 \n(t ) then ({(u, Ct)},u)else (uJ, Ct ) where (vJ,t ) = &#38;[t] s., u is a fresh variable t[v t] S, = \nif Var~T(t~) A Var~. (t\\) then ({(u, v t)}, u) else (~~ U w, t:t~) where (w., t;) = ~[v] s., (wt, t;) \n= &#38;[t] S., u is a fresh variable VLW,T= t is avariable A t f s, (t) Figure 3. Algorithm for Structuring \nHylomorphisms (Left) Fusion Law. In other words, once a structural hylo\u00admorphism is got, we can shift \nthe natural transformation (q) freely inside the hylomorphism according to which Fu\u00adsion Law is to be \napplied. Our algorithm for structuring the given hylomorphism [~, ~, ~lb+~ is to shift computations from \n# and @ into v by factorizing ~ to # o q. and q to q+ o ~ so that ~ and ~ contain the least computation, \nresulting in a structural hylomorphlsm [@ , q~ o q o q~, ~ ]G/ ,Fl. In the following, we give the algorithm \nfor factorizing @to # oq+, while omitting the dual discussion on ~. Let @: GA+ Abe given as: +=+, v... \nvfpn where G= Gl+. ..+ Gn and @~: G, A-+ A. Atypical@,, as in algorithm A, is defined by: di=~(vt,, \n , vtk,, v;,, , v:l, ).ti The variables with type A are explicitly attached with a prime ( ) and called \nrecursive variables. In order to capture the computations in q5iwhich can be done by a natural transformation, \nwe define maximal non\u00adrecursive subterms as follows. Definition 10 (Maximal Non-Recursive Subterm) A \nterm ti,is said to be a non-recursive subterm of t,if (1) t,,is a subterm of t,;(2) ti,does not include \nrecursive variables. A non-recursive subterm is said to be maximal if it is not a subterm of other non-recursive \nsubterms. o The essence of our algorithm is to factorize ~i into q$~o~d, so that all the maximal non-recursive \nsubterms in tiare shifted into q+i. Informally, the algorithm is as follows. 1. Find all the maximal \nnon-recursive subterms in t,,say t%,,....L;. 2. Let t~be the term from t,with each maximal non\u00adrecursive \nsubterm tijbe replaced by a new variable u,, , I.e., t;= l-+ .. ,tim,* Wm.]. ti[til u*l,. 3. Factorize \n@$by extracting all the maximal non-recur\u00adsive subterms out of t,as follows. 4. Factorize @by grouping \nthe result of ~,, i.e.,  The above algorithm is summarized in Figure 3. The main transformation is \nS which in turn calls transformation &#38; to process every term t, for factorizing ~,. Similar to the \nalgorithm in Figure 2, a fresh variable is allocated every time a non-recursive subterm is found. It \nwill be discarded when the corresponding non-recursive subterm turns out to be non-maximal by the predicate \nVar. The correctness of the algorithm S is omitted, but it should be noted that the typeof4~v...v4~isA+A+A \nand~d, +... +qbm isa natural transformation from G to G . Theorem 6 The q~l + . . . + qon, derived in \nthe algorithm S, is a natural transformation from G to G , i.e., 80 Proof: We prove it by the following \ncalculation. . ..+w..G-4G w+ . . { Definition of natural transformation, for any f } + . ..+qdm) oGf=G \nf o(q~l+. ..+q). ) (W,  { Definitions of G and G } moGlf + . +q4flo Gmf = G~foq41 + ..-+ GLfoqd.  \n+ { trivial} ~~ioG~f=GjfoV@i, (i=lj , Jz)  . { Definitions o; V@,,Gi and G: } u;,, ). A(vil , #i~i9vz19 \n , (tt,,..., ttmi, fv;,, fv; li)=li)= f A(Vi~, .... Vz~i.V~17---, v:,.). (t*l, , ttm,, fv:l,  , fv:t,:), \n(i=l, , n) . { obvious} The o 5.4 Examples Let s structure the following hylomorphism obtained in Sec\u00adtion \n4.4 where g : A + B. map g = [Nil v A(a, vi). Cons (ga, vi), id, OUt~~]~~,q In this case, #l = A().Nil \nand 42 = A(a, v~). CorLs(ga, v!). Here there is only one maximal non-recursive subt=m as underlined. \nOur algorithm will move g a out of 4V as 42= $&#38;o J% where @j = A(uzl, v;). COraS(T.LZl, vj) V42 = \n~(a, v!). (9a, v{) and finally give the following structural hylomorphism: map g = [Nil v A(w21, v;). \nCons(u21, v;), id + A(a, vi). (ga, v!), OUtLA]LB,LA. Moreover, with Theorem 5, we can get + = a and \n~ = id. So the above hylomorphism becomes [inL~, id + ~(a,V~).(ga, V{), OUtLA]LB,LA a structural hylomorphism \nfor the two fusion theorems. In the following, we given an example of fusion transfor\u00admat ion over structural \nhylomorphisms. Consider the pro\u00adgram foldrl @ o map g which accepts a list Cons(xl,.. ., cons (%-.1, \nCons(zn, Nil) )...) and returns gzl@(... (gzl@gzn)n) .-.). Since foldr-1 @ is not a catamorphism (Section \n4.4), the al\u00adgorithm in [LS95] will fail and leave the intermediate data structure produced by map g \nremained. Our algorithm can solve thk problem. With the resulting hylomorphisms ob\u00adtained in Section \n5.2 and the above, we have [error v id v 6, id, C70UtLBlF,F o [~nLB, id + ~(a,v~).(ga,v~), OUtLAjLB,LA. \n We shall demonstrate how the Ana-Hylo Fusion Law is applied to eliminate the intermediate data structure \nin the program foldrl @ o map g. foldrl @ o map g = { Replace foldrl e and map g with their hylos } [error \nv id v @, id,uoUtL~]~,~ o [inL~ , id + g x id, oUtLA]LB,LA = { Acid Rain Theorem (Hylo-Ana Fusion Law) \n} [error v id v @, id, a((id + g x id) o o?dLA)]F,F Now we focus on the transformation of the third pwt \nin the above hylomorphism. cr((id +g X id) o OUtL~) { Definition of a (Section 5.2), let h = id + g x \nid } (~1 v (Q o ml v Q o (id x ((ho O?JtL~)-10 L2))) o dist) OLA (h OotitLA ) Oh o OutLA { Definition \nof LA, and h. } (L1 v (~2.o nl v L3 o (id x ((ho out~A )-lo t2))) o dist) O (id + (g X (h O otdL~))) \no OUt~~ { Definition Of LA } (~, v (@O XI V Ls o (id X ((ho OUtLA )-lo L2))) o dist) o(id +g X h) OLA \nOUtLA O OUtLA { Definition of h }  (LI V (L2 07,, V Lq O (ad X ((h O OtdLA)-10 L2))) o dist) O (id + \ng X (id + g X id)) OL/iOtLtLA o Of.dLA { Move dist backwards } (LI V (~z o 7rI V LL? O (id x ((ho otdLA \n)-lo L2)))) o (id+ (dist o (g x (id +g x id)))) O LA OUtLA O OUtLA { Transformation property of dist \n}  (LI V (L2 O T, V Ls O (id X ((h O OUtLA)-lo L2)))) o(id+(g xid+gx(g xid))odist) 0 LA outL~ O OutL~ \n{ (fvg)O(p +9)= f0pv90%out~~= inL~ } (L, V(L20fJO~, V L3 O (9 X (inLA O h 10 L2 O ((J X id)))) O dist) \nO LA O utLA o OUtL~ { Since h-l 0,2 = L2o (g x id)-l } (L, v (L2 O g O7T, V ,S 0 (9 X inLA OL;)) Odist) \nO LA OlbtL~ O OUtLA It then derived the following hylomorphism: [error v ad v @, id, (LI V (L2090T, V \nLs O (9 X (~rLLAo&#38;2)))o dist)o LA OUtL~ O OUtLA ]~,~. Inlining the above derived hylomorphism, named \nprg, would give the following familiar program: prg = ks. case X5 of Nil * error; Cons (a, Nil) + ga \nCons (a, as) + ga @prgas where the intermediate data structure produced by map g no longer exists. Compared \nwith Launchbury and Sheard s algorithm, this example indicates that ours is more general and powerful. \n6 Related Work and Discussions It has been argued that programming with the use of generic control structures \nwhich capture patterns of recursions in a uniform way is very significant in program transformation and \noptimization[GLJ93, MFP91, SF93, TM95]. Our work is much related to these studies. In particular, our \nwork was greatly motivated by Sheard and Fegaras work[SF93] and Takano and Meijer s[TM95]. Basically, \nboth of them work with a language without general recursion but containing hylomorphisms as basic components, \nadvocating structural functional programming. Sheard and Fegaras implemented a fusion algorithm called \nnormalization algorithm3 based on the similar theorem like the Hylo Fusion Theorem. Takano and Meijer \ngeneralized Gill, Launchbury and Peyton Jones s one-step fusion algo\u00adrithm [GLJ93] relying on functions \nbeing written in a hlghly\u00adstylized budd-cata forms (i.e., catamorphlsms with data con\u00adstructors being \npzwameterized), and implemented another one-step fusion algorithm based on the Acid Rain Theorem. All \nprevious work have made it clear that the fusion pro\u00adcess is especially successful if the recursive definitions \nare expressed in terms of hylomorphisms. However, as argued by Launchbury and Sheard[LS95], al\u00adthough \nstructural functional programming contributes much to program transformation and optimization, it is \nunreal\u00adistic in real functional programming. It is impractical to force programmers to define their recursive \ndefinitions only in terms of the specific forms like hylomorphisms, in which a lot of abstract categorical \nconcepts are embedded. To remedy this situation, Launchbury and Sheard[LS95] gave an algorithm to turn \nrecursive definitions into build\u00adcata forms. The major problem still left is that many pro\u00adgrams cannot \nbe fused because some recursive definitions cannot be specified in build-cata forms. Our algorithm can \nsolve this problem. As we seen in Section 5.4, our algorithm is more general and powerful. This work \nextends our previous work [HIT95] in which so-called mediotypes are constructed to capture the recursive \nskeletons so that the fusion laws for these recursions are derived. Conclusion We have successfully \ngiven the algorithm to turn recursive definitions to structural hylomorphisms in order to enable program \nfusion. Our algorithm is a two-stage abstraction, abstracting recursive function calls to derive hylomorphlsms \nand abstracting maximal non-recursive subterms to struc\u00adture hylomorphisms. A prototype of our algorithm \nhas been implemented and tested extensively, showing its promise to be embedded in a real system. Finally, \nour algorithm gives the evidence that hylomorphisms can specify almost all re\u00adcursions of interests as \nclaimed in [BdM94]. Acknowledgement This paper owes much to the thoughtful and helpful discus\u00adsions with \nAkihiko Takano. Thanks are also to Fer-Jan de Vries for reading the manuscript and making a number of \nhelpful suggestions, and to the referees who provided de\u00adtailed and helpful comments. Ssheard and Fegaras~ \nnormalization algorithm first OnlY worked with the language containing folds (i. e., catamorphlsms) \nas basic com\u00adponents. It has been extended to work with languages containing so-called homomorphisms \n(i.e., hylomorphisms) in [KL94]. References [BdM94] [Chi92] [Fok92] [FSZ94] [GLJ93] [HIT95] [KL94] [LS95] \n[Ma190] [MFP91] [SF93] [Tak87] [TM95] [Wad88] R.S. Bird and O. de Moor. Relational program derivation \nand context-free language recognition. In A.W. Roscoe, editor, A Classical Mind, pages 17-35. Prentice \nHall, 1994. W. Chin. Safe fusion of functional expressions. In Proc. Conference on Lisp and Functional \nPro\u00adgramming, San Francisco, California, June 1992. M. Fokkinga. Law and Order in Algorithmic. Ph.D \nthesis, Dept. INF, University of Twente, The Netherlands, 1992. L. Fegaras, T. Sheard, and T. Zhou. \nImproving programs which recurse over multiple inductive structures. In Proc. PEPM 94, June 1994. A. \nGill, J. Launchbury, and S.P. Jones. A short cut to deforestation. In Proc. Conference on Functional \nProgramming Languages and Com\u00adputer Architecture, pages 223 232, Copenhagen, June 1993. Z. Hu, H. Iwasaki, \nand M. Takeichi. Making recursions manipulable by constructing medio\u00adtypes. Technical Report METR 95 \n04, Univer\u00adsity of Tokyo, 1995. (URL: http://www. ipl.t. u\u00adtokyo.ac.jp/ hu/pub/M ETR95-04.ps.gz).  R.B. \nKieburtz and J. Lewis. Algebraic design language. OGI Technical Report 94-002, Oregon Graduate Institution \nof Sci. and Tech., 1994. J. Launchbury and T. Sheard. Warm fusion: Deriving build-catas from recursive \ndefinitions. In Proc. Conference on Functional Programming Languages and Computer Architecture, pages \n314\u00ad323, La Jolla, California, June 1995. G. Malcolm. Data structures and program trans\u00adformation. Science \nof Computer Programming, (14):255-279, August 1990. E. Meijer, M. Fokkinga, and R. Paterson. Func\u00adtional \nprogramming with bananas, lenses, en\u00advelopes and barbed wire. In Proc. Conference on Functional Programming \nLanguages and Com\u00adputer Architecture (LNCS 523), pages 124 144, Cambridge, Massachusetts, August 1991. \n T. Sheard and L. Fegaras. A fold for all seasons. In Proc. Conference on Functional Programming Languages \nand Computer Architecture, pages 233 242, Copenhagen, June 1993. M. Takeichi. Partial parametrization \neliminates multiple traversals of data structures. A eta Infor\u00admatica, 24:57 77, 1987. A. Takano and \nE. Meijer. Shortcut deforesta\u00adtion in calculational form. In Proc. Conference on Functional Programming \nLanguages and Com\u00adputer Architecture, pages 306 313, La Jolla, Cali\u00adfornia, June 1995. P. Wadler. Deforestation: \nTransforming programs to eliminate trees. In Proc. ESOP (LNCS 300), pages 344 358, 1988.    \n\t\t\t", "proc_id": "232627", "abstract": "In functional programming, small programs are often glued together to construct a complex program. Program fusion is an optimizing process whereby these small programs are fused into a single one and intermediate data structures are removed. Recent work has made it clear that this process is especially successful if the recursive definitions are expressed in terms of hylomorphisms. In this paper, we propose an algorithm which can automatically turn all practical recursive definitions into structural hylomorphisms making program fusion be easily applied.", "authors": [{"name": "Zhenjiang Hu", "author_profile_id": "81100253989", "affiliation": "Department of Information Engineering, University of Tokyo", "person_id": "PP15027466", "email_address": "", "orcid_id": ""}, {"name": "Hideya Iwasaki", "author_profile_id": "81100065591", "affiliation": "Educational Computer Centre, University of Tokyo", "person_id": "P110505", "email_address": "", "orcid_id": ""}, {"name": "Masato Takeichi", "author_profile_id": "81100466948", "affiliation": "Department of Information Engineering, University of Tokyo", "person_id": "PP15032927", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/232627.232637", "year": "1996", "article_id": "232637", "conference": "ICFP", "title": "Deriving structural hylomorphisms from recursive definitions", "url": "http://dl.acm.org/citation.cfm?id=232637"}