{"article_publication_date": "06-15-1996", "fulltext": "\n Complexity of kernel Fun subtype checking Giorgio Ghelli * Dipartimento d Informatica Corso Itaha 40, \nPiss, ITALY e-mail: ghelliQdi unipi.it Abstract System kernel Fun is an abstract version of the sys\u00adtem \nFun defined by Cardelli s and Wegner s seminal pa\u00adper [CW85], and is strictly related to system F<. Ex\u00adtensions \nof these two systems are currently the basis of most proposals for strong type systems for object\u00adoriented \nlanguages. We study here the problem of subtype checking for system kernel Fun, presenting the following \nresults. We show that the standard kernel Fun subtype checking al\u00adgorithm has an exponential complexity, \nand generates an exponential number of different sub problems. We then present a new subtype checking \nalgorithm which has a polynomial complexity. In the process we study how variable names can be managed \nby a kernel Fun subtype checker which is not based on the De Bruijn encoding, and we show how to perform \nkernel Fun sub\u00adtype checking with a constraint generating technique. The algorithm we give is described \nby a set of type rules, which we prove to be equivalent to the standard one. This new presentation of \nkernel Fun type system is characterized by a multiplicative behaviour, and it may open the way to new \npresentations for system F< as well. Keywords: type theory, type checking, subtyping, polymor. phism. \n* This author has been partially supported by Min]stero dell Unlvers]ti e dells Rlcerca Scientific e \nTecnologlca Permission to make digitalhmrd copy of part or all of this work for personal or classroom \nuse is ranted without fee provided that mpies are not made or distributed for pro i t or commercial advantage, \nthe copyright notice, the titie of the ubiication and its date appear, and notice is given that copying \nis ! y permission of ACM, Inc. To copy otherwise, to republish, to post on servers, or to redistribute \nto lists, requires prior specific permission andlor a fee. 1 Introduction 1.1 F< and kernel Fun The importance \nof a strong foundation for systems in\u00adtegrating parametric polymorphism with subtyping has become increasingly \nevident in recent years, thanks to the growing interest in the definition of strong type sys\u00adtems for \nobject-oriented languages. Most of the type systems which have been proposed for this purpose are based \non system F< and kernel Fun (see, for exam\u00adple, [DT88], [CH088], [CCH089], [CHC90], [Mit90], [CMMS94], \n[Ghe91], [Bru91], [PT94]. [MHF93], [GM94], [Bru94], [ESTZ94], [HP95], [BSVG9S], [FM94], [EST95], [AC94]). \nF< and kernel Fun are two different abstract versions of the language Fun, introduced by Cardelli and \nWegner [CW85]. System F< enjoys many interesting properties: strong normalization, the exist ence of \na minimum type for ev\u00adery term, transitivity and subsumption elimination, etc. [Ghe90, CL91, BCGS91, \nCMMS94, CG92, CG94]. How\u00adever, it also has some significant problems: F< sub\u00adtyping, and F< type-checking, \nare semidecidab~ only [CG92, Pie94]; F< types fail to form a semilattice [Ghe90, GP92]; F< exten~ion \nwith recursive types is not conser\u00advative [Ghe93b]. The technical source of all of these problems lies \nin the rule which F< uses to compare bounded universal types. These ~roblems disappear when bounded universal \ntypes are compared according to the more restrictive rule defined for system Fun in Cardelli s and Wegner \ns original paper [CW85]; the re\u00adsulting system is called kernel Fun. System kernel Fun enjoys all the \ngood properties of F< mentioned above, and the missing ones too (semi\u00adlattice, decidability, conservativit \ny with recursion). For this reason it has been used, instead of F<, as the ba\u00adsis of some higher order \ntype systems with subtyping ([Com94, PS]), even if it is somehow less expressive than ICFP 36 !5/96 PA, \nUSA system F<. 01996 ACfvf 0-89791 -771 -5,96/0005 ...$3.50 Thoug h kernel Fun subtyping, which is the \nhard core of the type-checking procedure, is known to be decidable (folk theorem, see [Ghe93a]), nothing \nwas known about the complexity of the subtyping procedure. In this pa\u00adper we show that the problem is \npolynomial, but that the standard subtype checking algorithm is exponential, and we actually present \na polynomial algorithm. This polynomial algorithm is rather different from the stan\u00addard one, and is \nbased on the adoption of a different presentation of kernel Fun subtype rules. Though we present this \nresult in the context of the kernel Fun sys\u00adtem, the standard, exponential, subtype checking algo\u00adrithm \nis essentially the one that is currently used for ev\u00adery type system which belongs to the family of Cardelli \ns and Wegner s Fun, Hence, our result may be applied to a wider class of type systems. We will not study \nthis point here, while we will show in the paper that our algorithm can not be easily transferred to \nsystem F<; this observation may give some more insight on the d~\u00adferences between the two systems. This \nstudy has been carried out in the attempt of finding more efficient algorithms to type check the object\u00adoriented \ndatabase programming language Fibonacci, re\u00adalized by the group lead by Antonio Albano in Piss University \n[AG095], and some of the features of the al\u00adgorithm we present have already been included in the Fibonacci \ntype-checker. However, the main interest of our result is, in our opinion, that it shows that the standard \nsubtype check\u00ading algorithm is not the only reasonable one, and that the standard approach used to write \nkernel Fun rules is not the only possible one. Using linear logic jargon, the main difference between \nthe sets of rules which describe the subtype-checking and the constraint-generating al\u00adgorithms is that \nthe former manages environments in an additive way, while the latter manages environments in a multiplicative \nway [Gir87]. 1 From an algorithmic point of view, this is simply a consequence of the fact that environments \nare an input parameter (for the sub\u00adtype checker) in the first case, and an output parameter in the second \ncase. However, it is intriguing to wonder whether a logical interpretation of this difference exists, \nand whether it may be possible, and worthwhile, to look for a multiplicative presentation of s,ystem \nF~ itself. 1.2 Technical outline and plan of the paper The definition of the polynomial algorithm proceeds \nin three steps. First, we define a specific form of the standard ker\u00adnel Fun subtype checking algorithm, \nthe a-free subtype checking algorithm , characterized by the fact that, dur\u00ad 1In linear logic, a binary \nrule w additive when the premises have equal contexts, and is multiplicative when the context in the \nconsequence is a combination of the contexts m the premises. ing the process of comparing two types, \nit never creates new type variables, nor does it renames any type vari\u00ad able. This aim is reached in \nthree steps. First of all, the algorithm starts with a judgement where no name clashes exist between \ndifferent variables. Secondly, a comparison Vt <T. U < Vt < T. U is not reduced to [t /t]U< U , but the \nalgorithm collects the unifica\u00ad tion t= t in its unification environment E, and re\u00ad duces the comparison \nE 1-Vt < T.U < Vt < T.U to E, t = t 1-U < U . Finally, when a variable is substi\u00ad tuted by its bound \nduring the subtype checking process, this algorithm does not rename the variables which are defined inside \nthat bound. We prove that this algorithm is equivalent to the standard algorithm. This is a crucial point, \nsince this result cannot be immediately extended to F<: any subtype checking algorithm for F< must creat~ \nnew type variables in the process [Ghe95~ Then, we define a new constraint generating algo\u00adrit hm, characterized \nby the fact that, while the a-free one takes a subtype judgement E 1-T1 < T2 and checks it, the new one \ntakes a pair of types T1 < T2 and re\u00adturns a set of constraints that must be satisfied by E for E 1-T \n< U to hold. More specifically, to prove that E + Vt<T. U < Vt <T. U , the a-free algorithm ex\u00adplores \nthe two types U and U in parallel in a unification environment E, t = t and, when it finds a subproblem \nw < v, it answers by checking whether u = v is in the unification environment. On the other hand, to \nanalyze the same Vt < T.U < Vt < T.U pair, the constraint generating algorithm first explores U and U \ncollecting all the subproblems with shape u < v it finds (the constraints ) ), ignoring, in this phase, \nthe unification of twith t . Only after this collection has been com\u00adpleted, the algorithm cancels those \nconstraints, such as t<t ,t <t,that are solved by the unification oft and t , and returns the remaining \nones. Hence, instead of hav\u00ading the unification environment as input, this algorithm gives a constraint \nset as output. Finally, we show that a memorization technique can be applied to the constraint generating \nalgorithm to make it polynomial. Without memorization, both al\u00adgorithms may take exponential time, as \nwill be shown. However, both algorithms work by reducing the analysis of (E I-)T < U to the analysis \nof a set of subproblems (E, !-)T, < U,, where T, and U, are subterms of T and U (E, E, are only needed \nby the subtype checking al\u00adgorithm), without generating any new types during the proof. If the size of \nT and U is n, then there are at most nz different T,, U, pairs of subterms of T, U. Hence, if the constraint \nalgorithm remembers and reuses the set 2~emoizing ~ean~ ~torlng m a table the already solved sub problems \ntogether with them solutlon, so that, ]f a subproblem is met again, it can be solved by a table lookup. \nof constraints generated by each already checked sub\u00ad problem, then it calls itself recursively no more \nthan nz times. The same optimization applied to the subtype\u00adchecking algorithm would not make it polynomial, \nsince in this case we have to store the already visited triples E, T, U, and a single judgement can generate, \nas we will show, an exponential number of different E, T, U sub\u00adproblems, due to the presence of an exponential \nnumber of different environments. This is the reason behind the switch from the environment as input) \nto the envi\u00adronment as output viewpoint. We will describe the subtype checking and the con\u00adstraint generating \nalgorithms through two sets of sub\u00adtype rules, and will prove their correctness and com\u00adpleteness by \nshowing that these two sets of rules are equivalent, and are both equivalent to the standard, non algorithmic, \nset of subtype rules for kernel Fun. In Section 2 we define kernel Fun by giving its stan\u00addard nameless \npresentation, where nameless means that variable names are irrelevant since a conversion can always be \napplied. In Section 3 we introduce a type system which models the a-free subtype checking algo\u00adrithm, \ncharacterized by the fact that it neither renames type variables nor generates new types, and we prove \nits equivalence to the nameless one. In Section 4 we introduce the type system which models the constraint \ngenerating algorithm, and prove its equivalence to the previous systems. In Section 5 we int reduce the \nmemo\u00adization technique which makes the constraint generating algorithm polynomial, and we also show that \nthe stan\u00addard algorithm is exponential and would remain expo\u00adnential even if the memorization technique \nwere applied to it. In Section 6 we comment on related work. In Sec\u00adtion 7 we draw some conclusions, \nand make suggestions for future work. Though we have carried out all the proofs in full detail, we can \nonly give the outline of the main proofs in the paper, for space reasons. 2 The nameless rules for kernel \nFun 2.1 The system In this section we report the standard presentation of system kernel Fun, which is \ncharacterized by the irrel\u00adevance of variable names. We formalize this feature with an explicit rule \nwhich allows a renaming to be freely performed during a subtyping proof. We consider the following syntax \nfor kernel Fun types and subtyping judgments. T ::= t I T+T I Vt<T.T I Top r ::= () I r,t<T  P ,:= (r) \nI (r, {T}) I (r, {T,T}) J ::= rl-g@EnvlrEgTTypelrE~T <T Pre-judgements P are used to denote judgments \nwhich have not yet been proved ; for an introduction to the other syntactic categories, and to the language, \nsee [CW85, Ghe90, CG92, CMMS94]. In this standard nameless presentation, the names of bound variables \nare irrelevant, i.e. whenever a judge\u00adment J is provable, so is any J which is a-equivalent to J. This \nfact is usually assumed in the notation. For example, it is often stipulated that any term (or type, \nor judgement) actually denotes its whole a equivalence class, or that variable names are only a readable \nversion of the corresponding De Bruijn indexes. In this paper, however, we have to deal with renaming \nexplicitly, since the fact that kernel Fun subtype checking can be per\u00adformed without a renaming is one \nof our results and is the basis of the application of the memorization tech\u00adnique. It is interesting \nto note that this is not true for FS, where some use of a renaming cannot be avoided (if F< subtyping \nwere checkable without a renaming, it would be decidable; see [Ghe95] ). For this reason, we will give \nan explicit rule which allows a renaming. We now give the traditional presentation of kernel Fun, defined \nby the following set of rules. In this set of rules variable names only stand for themselves; the free\u00addom \nof a renaming is explicitly stated by rule (a <).3 We do not report the good formation rules for types \nand environments, which state that, in a well-formed judgement, no type variable is free and no type \nvari\u00adable is defined in the scope of another variable with the same name; the scope of the variable tin \nVt<T.U is U, while the scope of tin I ,t<T, I &#38;g U < U , is I , T, U (see [CMMS94]). We also need \nthe following definitions and notations. A pre-judgement (17) is well formed when r t-g QEnv; (r, {T}) \nis well formed when 17 kg T Type; (I , {T, U}) is well formed when both r Fc T Type and r i-g U Type \nhold. PI =. Pz means that the pre-judgements PI and Pz are a equivalent and are both well-formed, while \nTI =. Tz means that TI and Tz are two a equivalent types. If 17-t~<Tn, tl<Tl,...,then def(I ) s {tl,..r \n= I ,t<T,r .,tn}.If and t ~ then denotes bound of t.Here def(r ), I (t)the T are the rules. 3kernel Fun \nis presented here without transitivity y, as it has been presented in [C W85]. The equivalence of this \npresentation with the one with transitivity, and with reflexivity defined on every type, can be proved \neither by adapting the proof in [CG92], or by a much simpler induction. A valid pre-judgement (r), (I \n, {T}), (r, {T, U}) should I , t<T, I I-G &#38;Env (Refl<) r,tgr, r EG ts t 17Fg T Type (Top<) 17 EgT \n<Top t#u tcdef(17) rkg r(t)< u (VZK) rt-Gt~u r +g T s u (r, {T, u}) =a (r , {z+, u }) (a<) r I-GT < \nU Rule (V<) is the essential rule which distinguishes ker\u00ad nel Fun from F<, and which makes kernel Fun \nsubtyping decidable. The freedom of applying a renaming whenever it is needed makes some rules, namely \n(V<) and ( Var<), easier to write. For example, in this formulation, rule (V<) apparently requires that \ntwo comparable quanti\u00adfied types have the same bound variable with exactly the same bound. But the rule \ncan also be used to com\u00adpare types with different bounds and variables, such as: Vt<(Vu<Top.u),t < Vt \n<(Vu <Top.u ) .Top by com\u00adbining it with a renaming. More subtly, without cr, (Var<) cannot be used to \nprove provable judgernents T Kg t< U where r(t) is not well formed in r , such as: t< Vu< Top.u, u< Top \nl-g t< Vv<Top, v, This use of the Q rule should not be overlooked. 2.2 The UBD variant The algorithm \nwe will define in Section 3 can avoid vari\u00adable renaming thanks to the presence of the unifica\u00adtion environment \n, but also because it analyzes a spe\u00ad cific class of pre-judgements. These we will call valid pre-judgements \n, an d they enjoy the properties that (a) no name clash is possible in a vrdid pre-judgement, (b) the \nbackward application of any subtyping rule reduces a valid pre-judgement to another valid pre-judgement4 \nand (c) two variables with the same name have the same bound. To make it easier to compare the standard \nsys\u00adtem with the one in the next section, we define here a variant of the standard system which enjoys \nprop\u00aderties (a), (b), and (c), by first defining what a valid pre-judgements is. 4Informally, the backward \napphcation of a rule to a Judgement is the process of unifying the Judgement with the conclusion of the \nrule, and substituting the judgement with the rule premises, instantiated by the umfication. be, first \nof all, well-formed (i.e. no variable should be de\u00ad fined in the scope of a different variable with the \nsame name), but this is not enough, since this property is not preserved by the backward application \nof rule (Var<). Consider for example, the following judgement (Vt .U abbreviates Vt<Top. U): t<vu.u, \nu<Top k~ t< VU .U becomes, by (Var<): t<b%.u, u~Top +g VU.U < du .u . (Notice that the original judgement \nis well-formed and provable, but we need the cr rule to prove it.) Hence we have to resort to a stronger \nrequirement. We say that a pre-judgement satisfies the UraiDef property when it is well-formed and it \nis still well-formed after the repeated substitution of each variable by its bound. This prop\u00ad erty is \nstrong enough to guarantee against name clashes, and the subtype checker always transforms a UniDef pre-judgement \ninto a set of UraiDef pre-judgements.5 It can be proved that the UniDef property can be checked in polynomial \ntime. Finally, property (c), which we will call UniBourad, is defined as follows. Definition 2.1 (f?*()) \nB*() applied to a judgement or to a pre-judgement collects ail variable definitions, with their bounds, \ncontained in the judgernent or pre-judgement. For example, f$*(t<Vu<Top.Top +g Vu<t.u < Vv<t,v) = {t<Vu<Top.Top, \nu<Top, u<t, v<t}. Definition 2.2 (UniBound ()) A pre-judgement belongs to UniBound ifl whenever two different \nvariables have the same name, they have the same bound. Unbound ~ ({t<Tl,t<T2}~ B*(P)+ TI = 2 2) Notice \nthat the UniBound and UniDef properties do not imply each other, and their combination gives us our validity \ncondition. Definition 2.3 ( UBD) A pre-judgement P satisfies UBD ifl UniDef(P) and UniBound (P) both \nhold. A judgement is provable in the UBD system iff it is provable in the nameless system by a proof \nwhere euery judgement satisfies UBD. 5The simpler and stronger property that no two variables in the \nsame judgement have the same name, regardless of them scope, would guarantee against name clashes, but \nis not pre\u00adserved by (Var< ), which would transform, e g., t<VU .U +g t < U into t< Vt4.u l-g Vt4.U < \nU, which only satisfies the f7ntDef property. We now prove that no subtyping is lost in the FG sys\u00adtem \nif only UBD judgments are allowed, i.e. that if a judgement J is a-equivalent to a UBD judgement J , \nthen J is provable in the nameless system iff J is prov\u00adable in the UBD system. Theorem 2.4 Let E~BD \nmean (just for this theorem) provable in a system where only UBD judgments are well-formed ; then: (I \n, {T, U}) =~ (r , {T , U }), UBD(17 , T , U ) +(r+gT<usr t-gBDT <u ). Proof Outline The (-+=) part is \ntrivial. The (+) part can be proved by induction on the size of the proof of I !-G T < U, and by cases \non the last applied r-ale. Cases (Top<), (+<) and (Var<) are solved by showing that, if (I , {T, U}) \n=e (r , {T , U }), then the premises of the last rule applied to prove r RG T < U are n equivalent to \nUBD judgments which can be used to prove I +G T < U. Case (V<) is diflerent, since in this case T and \nU are two universal types with the same variable name and bound, while this may not be true for T and \nU . Hence, we first inductively prove an UBD judgement (F , {T , U }) which is a equivalent to (r, {T, \nU}) and which has equal variable names and bounds, and then prove I F~BD T < U by apply\u00ading (a <), in \nthe UBD system, to I Fg T < U . In case (CY<), if (I , {T, U}) has been proved by (a S) from (1? , {T \n, U }), then provability of r E~BD T < U follows by induction with no need to use (CS<) in the UBD system. \n0 The proof above shows that, in the UBD system, the a rule can be eliminated by substituting rule (V<) \nwith the following one: r t-g Vt <T . U Type T + T r,t<T l-g u < [t=t ](u ) (V<.*) r t-G Vt<T.U < Vt \n<T . U Without the UBD restriction, we claim that it would also be necessary to substitute rule (Var<) \nas follows, where the empty substitution [ ] (17(t)) renames any vari\u00adable which is defined inside I \n(t). t # U t G def(17) r Eg [](r(t)) < U  (va@cY) rtot<u Hence, the UBD restriction can be seen as a \ntechnique to avoid a renaming when the (Var<) rule is applied. In the next section we will introduce \na technique to avoid a renaming when (V<) is applied. From now on we will forget about the standard name\u00adless \nsystem and will only consider its UBD restriction. 3 The a-free subtype checking algorithm 3.1 The system \nIn this section we introduce what we call the a-free subtype checking algorithm , where subtype checking \ndistinguishes it from the constraint generating one, which will be presented in the next section. This \nalgorithm is characterized by three main fea\u00adtures, the fact that it is only defined on UBD judgm\u00adents, \nthe fact that it has a priori knowledge of the bounds of all the variables, and the presence of the unification \nenvironment ). These features are related to the behaviour of some real subtype checking algo\u00adrithms, \nand they are also needed to obtain the prop\u00aderty that the algorithm never creates nor renames types during \nsubtype checking, which is essential for the poly\u00adnomial variant we will describe later. We now discuss \ninformally how these features are related to real subtype checkers and to the non-creation property, \nand how they are captured in our formalization. UBD judgments: the input for a subtype checker is generally \nproduced by a parser which allocates a new data structure for every variable definition, and represents \nthe instances of that variable by a pointer to that data structure. Hence, no two different variables \nmay have the same name (i.e. the same memory address). When the subtype checker applies rule (Var< ), \nit may break this strong property (see footnote 5), but it maintains the weaker UBD invariant. Hence, \nthe assumption that the judgement we have to check satisfies UBD is usually satisfied by a real type \nchecker, and, moreover, any judgement may be transformed, if needed, into an a equivalent UBD judgement \nin polynomial time, by giving fresh names to all its variables; hence the UBD assumption does not re\u00adstrict \nthe validity of our analysis. We impose the UBD condition since the UniDef property is es\u00adsential to \neliminate the use of the a rule which is related to the (Var<) rule (see Section 2.2 and Theorem 3.4); \nthe UniBound condition allows us to describe the global bounds environment B, de\u00adscribed below, simply \nas a mapping from variable names to types.  A priori knowledge of the variable bounds: in a real type \nchecker a variable is typically implemented by a structure which contains a pointer to its bound, and \nthis connection is often established when the parse tree is built, i.e. before the subtype-checker starts. \nMoreover, our subtype checker never cre\u00adates new varibles nor renames their bounds, hence this association \nnever changes during type check\u00ad  ing. This is formdlzed by substituting the stack\u00adlike environment \nI with a (bounds environment B which is not changed by the subtyping rules and which contains, right \nfrom the beginning, the bounds of all the type variables which are involved in the judgement being checked \n(this fact is en\u00adforced by rules (Var<) and (V<)). Unification environments: in order to avoid C(sub\u00adstitutions, \nwhen two types Vt<T. U and Vt ~T . U have to be compared, the algorithm compares U and U in a unification \nenvironment) t= t which tells it to consider t and t to be equal. This al\u00adlows it to avoid the renaming \nwhich [t=t ](U ), is performed by the standard algorithm. lb our knowledge, this technique is only used \nin the sub\u00adtype checker of the database language Fibonacci. We can now give the syntax of the subtyping \njudgm\u00adents which describe this algorithm. The &#38; subscript under the } symbols distinguishes these \nrules from the other systems in the paper, while the B superscript is a rule metavariable, which we put \nin this de-emphasizing position because it is, as we explained above, just a read-only variable. T ::= \ntlT+TIVt<T.T ITop B ::= () ] B,t<T E ::= () I E,t=t ::= () IX,t J ::= B +S B-Env I E @ &#38;-Env I X \nl-~ X-Env lX1-~TTypel El-f T<U A pre-judgement is well-formed only if it satisfies the UBD property. \nAll the rules trivially preserve the UniDef invariant, while the good formation and UniBound prop\u00aderties \nare explicitly enforced by the hypothesis of the rules when it is needed. We remark that the (V <~) rule \nof system F< does not preserve the UniDef invariant, and this is the technical reason which prevents \nus from making a trivial extension of the l-~ rules to system F<. We now give the complete set of rules \nwe consider fo~ kernel Fun. Notation 3.1 (clef(B), left(E), right (E), swap(E)) def(tl <TI, . ... tn<Tn) \n=def tl,....tn left(tl =~1, . . ..tn=~n) =def tl, . . ..tn right(tl =u1, . ..> t n =Un) clef ~1,...,~n \nswap(tl =u1, . . . . tn=&#38;) =def ttl=tl,.. .,%?=tn Notation 3.2 (B(t)) B(t) is defined as T, when \nB= ....t<T ..... Notation 3.3 (T= U) E k~ T = U stands for Ek~T~UA swap(E) l-~U <T. Subtyping rules: \nE,t=u, E l-~ f-Env (Refl~) E,t=u, E k; t~ U E F: &#38;-Env left(E) +: T Type (Top<) Et-g T< Top (t=U) \n@ E t c def(ll) tc left(E) Observe that the conditions with shape: E l-~ &#38;-Env, X 1-~ T Type, t \nc X, which are found in the subtyping rules are not actually checked by a real subtype checker, since \nthey are guaranteed by the tool which builds the subtype checker input, but they are still needed in \nour formal presentation to formalize which properties must be guaranteed by that input provider. 3.2 \nEquivalence of the nameless and the type check\u00ading systems We want now to prove that the two systems \nare equiv\u00adalent, which may be formulated as follows (recall that Fg refers here to the UBD variant): \nTo make this statement precise we will define what Er and r~,~ are (Theorems 3.7, 3.10). To prove that \nthe two systems are equivalent, we need the standard subproof, weakening, and strength\u00adening lemmas, \nplus the crucial lemma which states that, if any judgement J is provable in the E system, than any a \nvariant Y of J is provable. Lemma 3.4 The E-system is a invariant:  (B, E, {T, u}) =a (Bl, EI, {Tl, \nUl}) +( EF; T< UWEIFE T1 < Ul). Before proving that I -subtyping implies Esubtyping, we prove the same \nthing for good formations. Notation 3.5 (clef(r)) If def(l?) = (tl,. ... t~) then def2(1 ) s(tl=tl,... \nt~=t~). Lemma 3.6 (r good formation a E good form.) 1. r l-g @Env, B l-c B-Env, B ~ L?*(r) + clef(r) \nl-$ X-Env, def2(I ) t-~ ~-Env 2. r t-g T Type, B l-t B-Env, B ~ B*(r, T) +-def(I ) +: T Type Theorem \n3.7 (17 subtyping implies E subtyping) r ~g T s U, B l-t &#38;?-Env, B ~ B*(I , T, U) * de~(r) t-~ T \ns U Proof Outline By induction on the proof of r Kg T < U and by cases on the last applied rule. Some \ncare is needed when the last rule w (a <); in this case, @ pro vabdity follows by Lemma 3..4. We also \nheavily exploit Lemma 3.6. 0 The next definition specifies how a variable environment X can be upgraded \nto an environment 17by associating each variable in X with its bound in a specified bounds environment \nB. Definition 3.8 (B n X) Bn(tl, . . ..t~) =def t]< B(t]), . . . ,&#38;<B(trz) Definition 3.9 We say \nthat an environment is strongly well-formed in B if, whenever two variables are unijied by E, their bounds \nin B are unified too, in the following sense:6 E is strongly well formed in B zff E @ f-Env, Vt=t c E. \n(B(t) =~ [EJ(B(t )), [swap(E)] (B(t)) =0 B(t )) The next theorem completes the proof of the equivalence \nbetween the named and the nameless system. Theorem 3.10 (E provability + 17 provability) If E is strongly \nwell formed in B, then: X @ X-Env ~ B~ X t-g @Env (1) E k: E-Env # B n left(E) l-g @Env, B n right(E) \nl-g @Env (2) 1?n X EG &#38;Env, X k! T Type * Bn X1-~ TType (3) EF; T<U +-Bnleft(E) l-g T < [E](U), (41) \nB n right(E) t-g [swap(E)](T) < U (4r) eB(t) =. [d(B($ )) is actually equivalent to [swap(E)] (B(t)) \n=m but redundant formulation B(t ),this reheves us from having to prove this fact. Proof Outline (2) \nts a coro!kary of (1), and (3) is standard. (1) and (~) are proved together by induction on the size \nof the proof of the judgement, and by cases on the last applied rule. In case (Top<) of (Jr), some care \nis needed to prove that left(E) k; T Type implies B n right(E) t-g [swap(E)](T) Type, needed to prove \nthat B n right(E) EG [swap(E)](T) < Top. In case (Var<) of (Jr), the strong good formation hypothesis \nand the (a <) rule are needed to prove that t =t l-~ t < U amphes Bn t t-gt < U. In case (V<), E l-~ \nW< T.U < Vt <T .U is proved from E kg T = T , E, t = t !+ U < U . We jirst exploit an irreflexivity lemma \ntoshow that E k: T = T (where = means < A > ) inductively implies T =~ [E](T ), [swap(E)](T) =a T . This \nimplies that E, t = t 1-~ U < U is strongly well formed, hence we can prove by induction that B n (left(E), \nt)Eg U < [E, t = t ](U ), which implies, by (V<), B n left(E) i-g Vt<T.U < Vt<T.[E, t =t ](U ). The thesis \nfollows by rule (CY<). 0 4 The constraint based rules 4.1 The system In this section we describe a different \napproach to the subtype-checking process. Instead of providing the en\u00advironments B, E and the compared \ntypes T, U as input, obtaining only success or failure, we provide B, T, U alone, and obtain as an answer \na set of constraints Z=t]<ul,..., tn < u~ which specifies the minimal subtyping relation between variables \nwhich should be implied by E to make E K: T ~ U true. Thus, as we will detail later, a single problem \ncan only generate a polynomitd amount of different subproblems. Hence, by combining the algorithm described \nin this section with a memoization technique, we can finally obtain a polynomial algorithm for kernel \nFun subtype checking. Formally, we define this constraint generating algorithm by a t-~ entailment relation, \nwith the following syntax. The actual algorithm works by backward applications of these rules; the Z \nconstraint set in the subtyping judgement is the only output variable. B ::= () I B,t<T x ::= () I X,t \nz ::= () I X,t<t I -Lt>t J ::= B k~ t5-Env I X k: ,-Y-Env I Z F: S-Env lX+~TTypelZt-~T<T Notice that \nthe good formation judgments which do not need to be modified are borrowed from the a-free subtype checking \nsystem. Claim 4.1 (Theorems 4.7, 4.8) l-~ and l-~ are equiv\u00ad alent; formally, if T and U are well formed \nin B, then: Definition 4.3 (Z B (t=t )) Sing/e constraint (u B The k: relation is defined below; as usual, \nthe crucial rule is (V<); the B operator is defined later. Notation 4.2 (swap(~)) swap(tl<ul, . . . . \ntn>un) =def ul~tl,,..,Un<tn notVar( U) t G def(l?) Z l-~ B(t)< U (Var<) x~:t<u E+;T <T Z @T <T x @u<u \nX B (t=t ) #l {t<T, t <T } ~ B (}/<) swa.p(~),~ , (~ B (t=t )) kg Vt<T.U < Vt <T .U notVar( U) in rule \n(Var<) means that U is not a type variable. We make the following observations. (Atom<) is the rule which \ngenerates the constraints, which are then transmitted by the other rules and elim\u00adinated by rule (V<). \nRule (V<) analyses U < U without considering the t=t unification; then, once the corresponding con\u00adstraints \nZ have been collected, it removes those which are implied by t= t .The operation (Z B (t = t )) gives, \ninformally, the constraints which remain after one knows that t=t ,and ~ B (t=t )=1 means that, if t \nis equated in the environment to t ,thenZ cannot hold. Thanks to rule (Top<), it is possible that Z l-~ \nT < U, even if T or U are not well formed, hence the subproof property Z l-~ T < [J + clef(Z) }: T Type \nis not valid. Using linear logic jargon, note that the additive be\u00adhavior of environments in E-rules \n(same context in the consequence and in the premises) and their multiplica\u00adtive behavior in X-rules (the \ncontext in the consequence is a combination of the contexts in the premises) shows that environments \nare input variables in the first case, and output variables in the second case. We now define the operation \nZ B (t = t ), first on a single constraint cr, and then on a constraint list X. (t=t )): (t<t )(t=t )(1) \nB = () v # t ,t~u cB + (t<V ) B (t=t ) = 2@ (2) v # t ,t<T c B, notVar( 2 ) * (t<?J ) B (t=t )=1 (3) \nv#t + (Z@) B (t=t ) =1 (4) v#t, v #t +-(V<v ) -~ (t=t ) = V<v (5) (v~v ) -B (t=t ) = SWap((V <V) B (t \n=t)) (6) Constraint list: () B (t=t ) = () if ~ B (t=t )=-L -L Or ~ B (t=t ) =1 (~, C7) B (t=t ) = ~ \nB U B (t=t ) (t=t ), otherwise { Note that, while the order of pairs inside an equality environment \nis essential, the order of the constraints in a constraint list is irrelevant. This set of rules defines \na terminating algorithm. Lemma 4.4 The algorithm dejirzed by the rules we have given atways terminates \non a judgement E t-~ T < U such that (a) T and U are ground terms and (b) there exists E such that E \n@ &#38;-Env, left(E) @ T Type, right(E) i-g U Type. Proof Outline See [Ghe90, KS9.2, Ghe93a]. 0 4.2 \nEquivalence with the subtype checking system To prove the equivalence between the two systems, we first \nneed a lemma which specifies that the Z B (t = t ) operation behaves as expected. Definition 4.5 (E @ \nE Type, E l-~ Z) E +: ~ Type means that left(E) @ tType for each tin left(~), and the same for right(E), \nright(~). E t-g X means that E l-~ &#38;-Env and that E t-~ t ~ u for each t<u pair in E. Note that it \nis never the cose that E i-~ 1. Lemma 4.6 E, t=t l-~ Z ~ (E, t=t l-~ Z Type, E ~~ z B (t=t )) We can \nnow prove the equivalence between the two sys\u00adtems. Theorem 4.7 (Z subtyping implies E subtyping) Definition \n5.1 X@?T< U,. EI-; E, left(E) l-~ T Type, right(E) +~ U Type *E@T<U Proof Outline We prove the thesis \nby induction on the size of the proof of Z k: T < U and by cases on the last applied rule. The interesting \ncase is case (V <), where, from swap(~), ~ , (~ B(t=))))l-gVt<T. U < Vt < T .U , E h: swap(~), Z , (Z \n B (t = t )), and E1-~T < T, E l-~T<T , E k-$ U< U we must deduce that E @ T = T , (immediate) and that \nE,t = t k: U < U . To this aim, we need to prove that E, t = t! l-~ E , which follows, by Lemma 4.6, \nfrom E k: Z B (t = t ), once we have proved that E, t =t 1-~ E Type, which is long but standard. 0 Theorem \n4.8 (E subtyping implies Z subtyping) E@ T< U~(3E. Ek; Z, Et-~ T<U) Proof Outline We prove it by induction \non the size of the proof of E k; T < U and by cases on the last applied rule. The interesting case is \ncase (V<), Suppose that E @ Vt<T. U < Vt <T . U has been proved start\u00adingfrom Ek; T=T j E,t=t l-~ U< \nU . Byin\u00adduction, there exist X, Z , X such that swap(E) t-~ Z, Eb: E , E,t=t F: X , andZF; T < T, Z \n@ T < T , E l-~ U < U . ByLemma 4.6, Ek; swap(~), Z , (Z B (t= t )).The thesis follows by ap\u00adplying \nrule (V<). O 5 The polynomial algorithm 5.1 The standard algorithm is exponential Before presenting our \npolynomial algorithm, we show that the standard subtype checking algorithm has an exponential behaviour, \nand that, moreover, it may re\u00adduce a problem to an exponential number of diflerent sub problems. To this \naim, we define a family of envi\u00adronments B, and of judgments J,m such that the size of J: only grows \npolynomially with n, while the number of different subproblems it generates grows exponentially (in this \nsection we will write Vt.U as an abbreviation for Vt<Top.U). To to  T,+l t,+l-+Vx,+l .T, u, = the \nsame as T,, substituting Uj to t3 and y~ to x~ B] = to<Top, UO<TOP, tl <To, U1 <Uo Bt+2 = B,+l, t,+z<T, \n-Vx,+l.t,+l, UC+2<U, + Vyt+l .Ut+l = E, Uo=to, . . ..u. =tt J;(E, o) = E R: UO< TO J#(E, i+ 1) = E @ \nU, ~ Vy,+l .U,+l < t,+l--+VZ,+l.T, J#(E, z) = the same as J;(E, z), swapping Uj with t~ and y~ with XJ \nLet ns say that Sub(j) is the number of different subproblems, belonging to the {J: (E, i)}n,, or to \nthe {J:(E, i)}n,, families, generated by the standard algo\u00adrithm while it is checking judgement J. We \nnow show by induction that, for each i<n, Sub(J~(En, i)) contains 2; different judgments. In the base \ncase, Sub(J$(E~, 1)) contains 2 judgments, J#(swap(E~), O) and J~((Em, Y1 = ZI ), O) (here b means is \nreduced by the algorithm to ): J;(En, 1) ~ En @ UO -+ dyI.Ul < tl -+ VZI.TO b By (+<): { swap(En) l-~ \ntl< UO) En @ Vyl .UI < VZI.~o } b { by (Var<): swap(E~) E: To < UO, by (V<): En, y]=z] @ ul < To } b \n{ swap(E~) @n TO < UO, by (Var<): E~,yl=zl l-~ CJO < TO } In the same way we can show that Sub(J~(En, \nz + 2)) is equal to Sub(J~(swap(E~), i+l))USub(J~((E~, Y,+2 = X,+2),2 + 1)). To complete the proof we \nnow show that the two sets are disjoint, by observing that no judgement generated (by the standard algorithm) \nfrom J#(swap(En), i + 1)may contain y,+2 = Z,+2 or X,+2 = Y,+2 in the unification environment, while \nall judgm\u00ad ents generated from J~((E~, w+2= Zi+z), ~+ 1) con\u00adtain one of those two pairs. This completes \nthe proof that the size of Sub(J~(En) n)) is 2n. Observe now that the input size, i.e. the size of a \njudgement J$(swap(Ew), n) which generates 2 subprob\u00adlems, is polynomial (quadratic) in n. The dominating \ncomponent of that size is given by Bn: since the size of T, and U, grows linearly with i, the size of \nB, grows as Z2, dominating the growth of E, and of the compared types, which is linear. Notice that the \nsame judgement would be checked in exponential time by the constraint generating algorithm too. However, \nwe will show that the constraint generat\u00ading algorithm would only generate a polynomial amount of different \nsubproblems, hence it is easy to modify it in order to give it a polynomial complexity. 5.2 The polynomial \nalgorithm The non memoizing, hence exponential, constraint gen\u00aderating algorithm can be described by \nthe following SML program. The program does not explicitly enforce the assumption that, whenever two \ndifferent Var or All terms are associated with two {name, bound} tuples with the same name, the tuples \nalso have the same bound (and are actually represented by the same mem\u00adory location, though this is not \nrelevant here). We may explicitly check this fact if we do not trust the input provider, but this check \nwould not affect the complex\u00adity of the type checking. Also note that there exists no central B environment, \nbut every variable carries its own bound. Apart from this, the algorithm below ex\u00adactly mimics the rules \nwe defined, provided that the swap, append, and minus operations are defined as in Section 4 (#f r denotes \nthe contents of the f field of the r record). datatype Type = Var of {name: string, bound: Type} I Top \nI All of {name: string, bound: Type} *Type I Arrow of Type * Type; type VarPair = {name: string, bound: \nType}; datatype Constraint = Less of VarPair*VarPair I Greater of VarPair*VarPair; ,.. fun getSigma (Var(t)) \n(Var(u)) = [Less(t,u)] \\ getSigma T (Top)= [ ] \\ getSigma (Var({name,bound})) T = getSigma bound T / \ngetSigma (All(t,T)) (All(u,U)) = let val sigma= get Sigma (#bound u) (#bound t) val sigmal = get Sigma \n(#bound t) (#bound u) val sigma2 = getSigma T U in append [ (swap sigma), sigmal, minus sigma2 (t)u) \n] end [ getSigma (ArrcIw(T,TT)) (Arrmv(U,UU)) = let vaf sigma = getSigma U T val sigmal = getSigma TT \nUU in append [ (swap sigma), sigmal ] end; Let us now define the notion of a type being a subterm of \nanother one as the minimal transitive relation such that: bound is a subterm of Var ( {name ,bonnd} ); \nbound and T are subterms of All ( {name ,bound}, T); T and U are subterms of Arrow (T ,U). The constraint \ngenerat\u00ading algorithm enjoys the following subterm property : for every subproblem getSigma TT UU generated \nby a problem get Sigma T U , TT and UU are subte~rms of the types T and U. We can define the input size \nof a problem getSigma TT uu to be the nnmber of different occurrences of subterms of TT and UU. Hence, \nif n is the size of the problem get Sigma TT UU, its analysis gen\u00ad erates no more than nz different subproblems, \none for every different pair of subterms of TT and UU. Hence, if the algorithm is modified so that it \nremembers every already generated subproblem, it will call itself recur\u00ad sively no more than nz times. \nThe modified algorithm is shown below. It first uses lookForOldSolut ion to search in the memory data \nstruc\u00adture for the constraint set generated by a previous analy\u00adsis of the same subproblem, and calls \nnewGetSigma only the first time it meets a pair of types. newGetSigma is identical to get Sigma, bnt \nevery direct recursive call to getSigma T U is substituted by a call to checkSigma T U. The function \nrememberSolution stores the T, U, result triple in the memory data structure. fun checkSigma T U = case \nlookForOldSolution T U (memory) of Solved(result) => result I Unsolved=> let vaf result = newGetSigma \nT U in (rememberSolution T U result memory; result ) end and newGetSigma (Var(t)) (Var(u)) = ... Notice \nthat every branch of the algorithm only performs polynomial operations. The criticfl ones are the append \nand minus operations. append should be implemented as a set union, rather than a list concatenation, \nto pre\u00advent constraint lists from becoming too long. Thus, the length of any constraint list is bound \nby the input size, hence both append and minus can be executed in poly\u00adnomial time. This completes the \nproof of the fact that onr algorithm runs in polynomial time. Once the asymptotic complexity has been \nfixed, we should now look for more realistic implementations. The better algorithm we are currently experimenting \nwith differs from the one presented above because we check and update the memory structure only when \nwe apply the (Var<) rule. The net result is that, for most judge\u00adments, where memoiz ation gives little \nadvantage, we save a lot of costly lookForOldSolution and remember operations, while exponent ial judgments \nare still checked in polynomial time. TpJO~hln~would change ,f we suppose that the algOrlthm Input 1s \nnot a tree but a graph, so that common subterms can be shared, since in this case the upper bound for \nthe number of recursive calls would stall be nz, where n M the number of nodes m the graph. Related Work \nthose who would like to implement a subtype checker without using De Bruijn indexes. The complexity of \nsubtype checking problem has not been studied in the literature, to our knowledge, essen\u00adtially because \nmost interesting subtype checking prob\u00adlems are either obviously polynomial, as happens with first order \nsystems ([Car84]), or undecidable, as happens for system F< [Pie94, Ghe95]. When decidable variants of \nF< have been defined, proving their decidability has been-the main interest focus ([Bru94, CP94]). We \nsus\u00adpect, however, that our results may be easily transferred to those systems. A lot of work has been \nperformed about the complex\u00adity of type inference problems, usually in the context of ML-like systems, \nsometimes enriched wit h subtyping, as in, e.g., [LM92]. However, the problem of type inference in quite \ndifferent from the subtype checking problem we face here, and there is no apparent relation between the \nresults from this field and our result. Conclusions We have presented a polynomial algorithm to perform \nkernel Fun subtype checking. In the process, we have formalized a technique to compare universal types \nwit bout operating substitutions, and have proved the soundness and completeness of this technique. In \nparticular, we have shown that, when ap\u00adplied to kernel Fun, this technique allows subtyping to be checked \nwithout creating new types and without re\u00adnaming type variables (Theorems 3.7, 3.10). Apart from allowing \npolynomial subtype checking, this property is also important when kernel Fun is extended with recur\u00adsive \ntypes. Subtype checking among recursive types is, in fact, based on the comparison of subtype judgments \nwit h the previously explored ones [AC 93]. If no new types are generated, this process is guaranteed \nto ter\u00adminat e, and judgement comparison can be implemented as a pointer comparison. These facts imply \nthat system kernel Fun can be extended with recursive types along the lines of [AC93] without meeting \nthe subtle problems raised by recursive types in system F< [Ghe93b]. We have also shown that the standard \nsubtype check\u00ading algorithm for system kernel Fun is exponential, and may actually generate an exponential \nnumber of dif\u00adferent subproblems. These properties of the algorithm were previously unknown. Finally, \nwe have developed a type theory where vari\u00ad able names are taken seriously . The traditional ap\u00ad proach, \nwhich essentially ignores variable names, is still the best when fundamental studies are carried out. \nHow\u00ad ever, the lack of studies about variable name manage\u00ad ment in the subtype checking process is a \nproblem for References [AC93] [AC94] [AG095] [BCGS91] [B,u91] [Bru94] [BSVG95] [Car84] [CCH089] [CG92] \n[CG94] Roberto M. Amadlo and Luca Cardelli. Subtyp\u00ading recursive types. ACM Transactions on PTo\u00adgnzmmang \nLanguages and Systems, 15(4) :575 631, 1993. Martin Abadi and Luca Cardelli. A theory of primitive objects: \nSecond-order systems. In Eu\u00ad ropean Sympos~um on Programming (ESOP), Edinburgh, Scotland, 1994. A. Albano, \nG. Ghelli, and R. Orsini. Fibonacci: A programmi ng language for object databases. Journal of Very La~ge \nData Bases, 4(3):403\u00ad444, 1995. Val Breazu-Tannen, Thlerry Coquand, Carl Gunter, and Andre Scedrov. Inheritance \nas im\u00adplicit coercion. Information and Computation, 93:172-221, 1991. Also in [GM94]. Kim B. Bruce. The \nequivalence of two seman\u00adtic definitions for inheritance in object-oriented languages. In Proceedings \no.f Mathematical Foundat~ons of Programming Semantics, Pitts\u00adburgh, PA, March 1991. Kim B. Bruce. A paradigmatic \nobject-oriented progranunin g language: Design, static typing and semantics. Joumtal of Functional Pmgram\u00ad \nm~ng, 4(2), April 1994. Kim B. Bruce, Angela Schuett, and Robert van Gent. PoIYTOIL: A type-safe polymor-PKIC \nobject-oriented language, extended ab\u00adstract. In PTOC. of EuTopean Conference on Object-Oriented PTogrammtng \n(ECOOP), 1995. Luca Cardelli. A semantics of multiple in\u00adheritance. In G. Kahn, D. MacQueen, and G. Plotkin, \neditors, Semantics of Data Types, volume 173 of Lecture Notes in ComputeT Science, pages 51-67. Springer-Verlag, \n1984. Full version in Information and Computation 76:138 164, 1988. Peter Canning, William Cook, Walt \nHill, and Walter Olthoff. Interfaces for strongly-typed object-oriented programming. In O OPSLA 89, paws \n457 4677 1989 P.-L. Curien and G. Ghelli. Coherence of sub\u00adsumpt ion, minimum typing and type checking \nin F<. Mathematical Structures in Computer Scte;ce, 2(1):55 91, 1992. P.-L. Cnrien and G. Ghelli. Decidability \nand confluence of flqtop< reduction in F<. Inform a\u00adtion and C omputat;on, 109(1, 2):57=114, 1994. [CHC90] \n[CH088] [CL91] [CMMS94] [C0m94] [CP94] [CW85] [DT88] [EST95] [ESTZ94] [FM94] [Ghe90] [Ghe91] [Ghe93a] \nW.R. Cook, W.L. Hill, and P.S. Canning. In\u00adheritance is not subtyping. In POPL 9o, 1990. Peter Canning, \nWalt Hill, and Walter Olthoff. A kernel language for object-oriented program\u00adming. Technical Report STL-88-21, \nHewlett-Packard Labs, 1988. Luca Cardelli and Giuseppe Longo. A semantic basis for Quest. Journal of \nFunctional Program\u00ad ming, 1 (4):417 458, October 1991. Luca Cardelli, Simone Martini, John C. Mitchell, \nand Andre Scedrov. An extension of system F with subtyping. In.foTmation and Coraputation, 109(1-2):4-56, \n1994. A.B. Compagnoni. Decidability of Higher-Order Subtyping with Intersection Types Proceedings of \nComputer Science Logic, September 1994. Giuseppe Castagna and Benjamin Pierce. De\u00adcidable bounded quantification. \nIn POP L 94. ACM, January 1994. L. Cardelli and P. Wegner. On understand\u00ad ing types, data abstraction \nand polymorphism. Computing Surveys, 17(4) :471 522, December 1985. Scott Danforth and Chris Tomlinson. \nType the\u00adories and object-oriented programming. ACM Comput%ng Sumeys, 20(1) :29-72, March 1988. J. Eifrig, \nS. Smith, and V. Trifonov. SoundL poly\u00ad morphic type inference for objects. In 00 PSLA 95, 1995. J. Eifrig, \nS. Smith, V. Trifonov, and A. Zwarico. Application of 00P type theory: State, decid\u00adability, integration. \nIn O OPSLA !34, 1994. Kathleen Fisher and John Mitchell. Notes on typed object-oriented programming. \nIn Proceedings of Theoretical Aspects of Com\u00adputer Software, Sendai, Japan, pages 84.1 885. Springer-Verlag, \nApril 1994. LNCS 789. G. Ghelli. PTooj Theoretic Studtes about a Manamal Type System IntegTatzng Inclusion \nand Parametric Polymorphism. PhD thesis, Di\u00adpartimento di Informatica, Universit&#38; dl Piss, March \n1990. Tech. Rep. TD-6/90. G. Ghelli. ModeIIing features of object-oriented languages in second order \nfunctional languages with subtypes. In J.W. de Bakker, W.P. de Roever, and G. Rozenberg, editors, Foun\u00addations \noj Object-Oriented Languages, num\u00adber 489 in LNCS, pages 311 340, Berlin, 1991. Springer-Verlag. G. Ghelli. \nDivergence of F< type checking. Technical Report 5/93, Dipar~imento di Infor\u00admatica, University di Piss, \n1993. [Ghe93b] [Ghe95] [Gir87] [GM94] [GP92] [HP95] [KS92] [LM92] [MHF93] [Mit90] [Pie94] [Ps] [PT94] \nG. Ghelli. Recursive types are not conservative over F<. In M. Bezen and J.F. Groote, ed\u00ad itors, Typed \nLambda Calculi and Appltcatzons (TLC A) 93, number 664 in LNCS, pages 146\u00ad162, Berlin, March 1993. Springer-Verlag. \nG. Ghelli. Divergence of F< type checking. The\u00adoretical Computer Scien;e, 139(1,2):131 162, 1995. Jean-Yves \nGirard. Linear logic. TheoTetzcal Computer Sczence, 50:1 102, 1987. Carl A. Gunter and John C. Mitchell. \n7 heoret\u00adical Aspects oj Object-Oriented Progmmming: Types, Semantics, and Language Design. The MIT Press, \n1994. G. Ghelli and B. Pierce. Bounded existential and minimal typing. Available by ftp, 1992. Martin \nHofmarm and Benjamin Pierce. A unify\u00ading type-theoretic framework for objects. Jo ur\u00adnal of Functional \nProgramming, 1995. To ap\u00ad pear. Dinesh Katiyar and Sriram %mkar. Completely bounded quantification is \ndecidable. In Proceed\u00ad ings o.f the ACM SIGPLAN Workshop on ML and its Applications, June 1992. P.D. \nLincoln aud J.C. Mitchell. Algorithmic as\u00ad pects oft ype inference with subtypes. In POPL 92, pages 293 \n304, January 1992. John C. Mitchell, Furio Honsell, and Kath\u00adleen Fisher. A lambda calculus of objects \nand method specialization. In 1993 IEEE Sympo\u00adsium on Logic in ComputeT Science, June 1993. J. C. Mitchell. \nToward a typed foundation for method specialization and inheritance. In POPL 9o, 1990. Benjamin C. Pierce. \nBounded quantification is undecidable. InjoTmat~on and Computation, 112(1):131-165, July 1994. Also in \n[GM94]. B.C. Pierce and M. Steffen. Higher-order sub\u00adtyping. Submitted for publication. A prelimi\u00adnary \nversion appeared in IFIP Working Confer\u00adence on Programming Concepts, Methods and Calculi (PROCOMET), \nJune 1994. Benjamin C. Pierce and David N. Turner. Simple type-theoretic foundations for object\u00adoriented \nprogramming. Journal of Functional Programming, 4(2):207-247, April 1994. 145  \n\t\t\t", "proc_id": "232627", "abstract": "System kernel Fun is an abstract version of the system Fun defined by Cardelli's and Wegner's seminal paper [CW85], and is strictly related to system F&amp;le;. Extensions of these two systems are currently the basis of most proposals for strong type systems for object-oriented languages.We study here the problem of subtype checking for system kernel Fun, presenting the following results. We show that the standard kernel Fun subtype checking algorithm has an exponential complexity, and generates an exponential number of different subproblems. We then present a new subtype checking algorithm which has a polynomial complexity. In the process we study how variable names can be managed by a kernel Fun subtype checker which is not based on the De Bruijn encoding, and we show how to perform kernel Fun subtype checking with a \"constraint generating\" technique.The algorithm we give is described by a set of type rules, which we prove to be equivalent to the standard one. This new presentation of kernel Fun type system is characterized by a \"multiplicative\" behaviour, and it may open the way to new presentations for system F&amp;le; as well.", "authors": [{"name": "Giorgio Ghelli", "author_profile_id": "81100261191", "affiliation": "Dipartimento d'Informatica, Corso Italia 40, Pisa, Italy", "person_id": "PP39034962", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/232627.232643", "year": "1996", "article_id": "232643", "conference": "ICFP", "title": "Complexity of kernel Fun subtype checking", "url": "http://dl.acm.org/citation.cfm?id=232643"}