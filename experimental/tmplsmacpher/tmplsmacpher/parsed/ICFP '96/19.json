{"article_publication_date": "06-15-1996", "fulltext": "\n A Theory of Weak Bisimulation for Core CML William Ferreira* Matthew Hennessy Alan Jeffrey University \nof Sussex Abstxaet Concurrent ML (CML) is an extension of Standard ML of New Jersey with concurrent features \nsimilar to those of pro\u00ad cess algebra. [n this pape~ we build upon John Reppy s reduction semantics for \nCML by constructing a composi\u00ad tional operational semantics for a fragment of Cii4L, based on higher-order \nprocess algebra. We use this to build a se\u00ad mantic theory for CML, based on weak bisimulation equiva\u00ad \nlence. We give some small examples of proofs about CML expressions, and show that our semantics corresponds \nto Reppy s up to weak$rst-order bisimulation. Introduction There have been various attempts to extend \nstandard pro\u00ad gramming languages with concurrent or distributed features, [11, 17, 24]. CML [26, 28] \nis a practical and elegant exam\u00ad ple. The language Standard ML is extended with two new type constroetors, \none for generating communication chan\u00ad nels, and the other for delayed computations. By adding to the \nlanguage a small number of constants to manipulate ob\u00ad jeets of these new types, a new language is obtained \nwhich combines the functional features of ML with the cmnnmni\u00ad eation and concurrency capabilities of \nCCS, [20]. It has been implemented and a formal semantics has been given for a significant subset called&#38; \n[5, 28]. Here we give a compositional operational semantics to a subset of CML which we refer to asPCML. \nIn fact in order to describe all possible states which can arise during the compu\u00adtation of a well-typed \n,uCML expression, we need to extend the language. This extension is three-fold: The first consists in \nadding the constants of event type used by Reppy in [28] i.e. constants to denote certain delayed computations, \nHow\u00adever to obtain a compositional semantics we make further extensions.We add a parallel opmator /1, \ncommonly used in process algebras, which allows us to use programs in place of the muhisets of programs \nof [28]. The tlnal addition is more *WIBiam Ferreka was funded by a CASE atudentdip from British Tele\u00adcom. \nIhk work k carried out in the context of EC BRA 7166 CONCUR 2. Permissiontomakedigitalhrd COPYofpartorallofthisworkforpersonal \norclassroomuseis rantedwithoutfeeprovidedthatoopieaarenotmade i or distributed for pro t or commercial \nadvantage, the mpyright notice, the title of the publication and its date appear, and notice is given \nthat copyingisbypermissionofAOfvl,Inc.To oopyotherwise,to republish,to postonservers,ortoredistributetol% \nrequirespriorspadficpermission andlor a fee. ICFP 96 5/96 PA, USA @ 1996 A(XIA0-69791-771-0/96/0005...$3.50 \nsubtk we allow expressions which correspond to the synced versions of Reppy s constants. The operational \nsemantics thus defines a labeiled transition system where the statea are .uCML+ programs. We demonstrate \nthe usefulness of this compositional oper\u00adational semantics by using it to define a version of weak ob\u00adservational \nequivalence, [20], suitable for pCML. We prove that, modulo the usual problems associated with the choice \noperator of CCS, our chosen equivalence is preserved by all PCML contexts and therefore may be used as \nthe basis for reasoning about CML programs. We show that some stan\u00addard identities one would expect of \na call-by-value ka.hxdus and that certain algebraic laws common to process algebras, [20], hold. Reppy \ns semantics for A.v is ideal for proving type sound\u00adness, and properties about whole programs, while \nour seman\u00adtics enables equational reasoning about program fragments. We would certahly like them to be \nthe same , and so in the iinal section we show that, up to weak bisimuIation equiva\u00adlence, our semantics \ncoincides with the reduction semantics for &#38; presented in [28]. @ this version of the paper most \nproofs and some of the technical details have bem omitted. We refer the reader to [10] for a full account \nof this work. 2 The Language In this section we introduce our language PCML, a subset of CML [26, 281. \nThe type expressions for our language are @V~ by: A ::= unit I bool I int I than IA*A IA=LA [Aevent \nOur language may be viewed as a typed A-calculus aug\u00ad mented with the type constructor A event for constructing \ndelayed computations of type A, Let Chan be a set of channel names ranged over by k, k etc. and let Var \ndenote a set of variables ranged over by x, y, . . . The expressions of ECML are given by the following \nabstract syntax: e, f,g~Exp ::= v / ce I ifethen eelsee I (e)e) I Ietx= eine ee v,w CVal ::= Zlfix(x=fny+e)[x \nc G Const ::= fst I snd I add I mul I Ieq I transmitA [ receiveA I choose I spawn 1sync ] wrap never \n] always 1 ELit ::= true [false [k[ol Olll The main syntactic category is that of Exp which look very \nmuch like the set of expressions for an applied call-by-value version of the A-calculus. There is also \na syntactic category of expressions of a particular form, called Val; these repre\u00ad sent the objects to \nwhich functions maybe applied and which also may be sent and received between computation threads. We \nwill often abbreviate fix(x = fn y+ e) to fn y + e when x does not occur free in e. Finally there area \nsmall collection of constant functions. Note that thexe is no method for gen\u00aderating channel names other \nthan using the predefine set of names Chan. We use ~v(e) to denote the set of variables which have free \noccurrences in e. If ~v(e) = 0 then e is said to be a closed expression, which we sometimes refer to \nas a program. We also use the standard notation of e[v/x] to denote the substi\u00adtution of the value v \nfor all free occurrences of x in e where bound names may be changed in order to avoid the capture of \nfree variables in v. We now examine briefly the type system for this language. The types for the constant \nfunctions of the language are given in Figure 1w this is in a~eement with the typing rules given in \n[28] for&#38;v. The constants add, m u1,spawn have constant types associated with them, as have tra fEmitA \nand f eCeheA; but the type of the latter pair is determined by the type sub\u00adscript A. The type asswiated \nwith the remaining constants should be interpreted polymorphically. Thus, for example choose has thetypeAevent \nxAevent +Aevent for every type A. The type inference system is given in Figure lb and is straightforward. \nThere are two structural rules, literals are assigned their natural types while the types of functional \nval\u00adues are inferred using a minor modification of the standard rule for functional abstractions. The \nremaining constructs are dSO handled using standard inference n.des, [13]. We now turn our attention \nto the operational semantics. In [28, 5] a reduction semantics is given to A., and since ,uCMLCV is a \nsubset of Lv, this induces a reduction semantics for,uCML v; this is discussed in Section 5. The judgments \nin this reduction semantics are of the formC ~ C whereC,C are configurations which combine a closed expression \nwith a run-time environment necessary for its evaluation. However this semantics is not compositional \nas the reductions of a configuration cannot be deduced directly from the reductions of it constituent \ncomponents. Here we give a compositional operational semantics with four kinds of judgments: e J-e , \nrepresenting a one step evaluation or reduction,  e J.% e , representing theprcduction of the value \nv, with a side effect e ,  e m e , representing the potential to input a value x along the channel k, \nand  e JL e , representing the output of the value v along the  channel k. These are formally defined \nin Figure 2. The rules deiine the standard call-by-value left-to-right evaluation, familiar from the \nI-calculus. For example the rules governing the expres\u00adsion Iet x = el in e2 first involve evaluating \nthe expression el: Ietx = el inez S Ietx = e{ inez and when this produces a value, signalled by a { action, \nthe substitution is performed: The rules for application are entirely straightforward, and use the Iet \noperator to make the order of evaluation explicit; for example we have the rides: el -$2 e; elez% e;ez \nand: el -@+ e; [v= fix(x= fn y+g)] elez ~ ej II Iety= e2ing[v/x] where an explicit unwinding of the recursive \nfunction ocars. Note that production of a value in the above rules results in the genaation of a side-effect \nwhich continues in parallel with the remainder of the evaluation. We now explain this in more detail. \nWhen giving an operational semantics to a language with side-effects thexe are two standard approaches \nto retaining the information necessary to interpret them. The fist, used for example in [5, 28], is to \ndefine a notion of state or configura\u00adtion; these contain the program being evaluated together with auxiliary \nstate information, and the judgments of the oper\u00adational semantics apply to these configurations. The \nsecond, more common in work on process algebras, [4, 20], extends the syntax of the language being interpreted \nto encompass con@rations. We Choose the latter approach and one ex\u00adtra construct we add to the language \nis an asymmetric paral\u00adlel operator, e II ~; intuitively this corresponds to the use of multi-sets in \nthe reduction semantics of [5, 28]. As an exam\u00adple of the use of this extra construct the side-effect \ngenerated by the evaluation of spawn is reflected in our semantics by the inference spawn(fny+e) J-+ \n(fn y+e)() II (); one step in the evaluation of spawn (fn y *e) leads to two expressions running in parallel, \none being the spawned ex\u00adpression (fn y + e) () and the other the default value which results horn every \napplication ofs pawn. More generally the evaluation of spawn e proceeds by the evaluation of the ex\u00adpression \ne until this produces a value and then an application of an inference such as the one above. This is \nrepresented by the rule etie spawn e-Le llvol lo where the well-typedness of the operational semantics \nwill ensure that visa function of the appropriate type, unit --u nit. fst : A* B-A transmitA : than \n*A-+ unit event snd : A*B+B receiveA : than -+ Aevent add : int*int+int choose : A event *A event ~Aevent \nmul : int*int+int spawn : (unit -unit) -unit Ieq : int*int+bool wrap : A event * (A+ll) +Bevent sync \n: A event ~A never : unit ~Aevent always : A-+ A event Figure 1a Type rules for l~CML constant functions \nr t-true : bool r F false: bool rt-k:chan r~ () : unit I En:int 17,x: At-x:A 17,x: A+ B,y:A\\e:B r,::y;::B[x+Yl \nrl-fix(x =fnyse):A-+B rte:A, -, 17Fe: A--+B rt-~:A rFe:A rFf:B. rHce. B[c:A+B] rt-ef:B -171-(e, ~):A*B \nrt-e:bool r E~:A rl-g:A 17+e:A r ,x:A}f:B I } ifethen~elseg :A 17Fletx=ein~:B Figure lb: Type rules for \npCML expressions. We must also capture the behaviour of delayed computa-rule eJLe tions, and to do this \nwe introduce a new constructor for val\u00adues. % cextain kinds of expressions ge of type A, which we nevere \n~ el II [A] call guarded expression, let [ge] be a value of type A event; obtained by defining b(never, \n() ) to be [A]. The constant this represents a delayed computation which when launched wrap is of type \nA event * (A--+B) +Bevent. The evaluation initiatea a new computation thread which evaluates the ex\u00ad \nof wra p e proceeds in the standard way by evaluating e until it pression ge. The precise syntax for \nguarded expressions will produces a value, which must be of the form ([ge], v), where emerge by considering \nwhat types of values of the form [e] ge is a guarded expression of type A and v has type A --+ B. can \nresult from the evaluation of expressions of type event Then the evaluation of wrap e continues by the \nconstruction from the basic hmguage pCML. The constant reCeiveA is of of the new delayed computation \n[ge + v]. The guarded ex\u00adtype than + A event and therefore the evaluation of the ex\u00ad pression ge + v \nis a wrapper which applies v to the result of pression reC&#38;@A e proceeds by first evaluating e to \na value of evaluating ge. type than until it returns a value k, and then returning a de- The always construct, \nof tfpeA +A event, evaluates its ar\u00adlayed computation consisting of an event which can receive gument \nto a value v, and then returns a trivial delayed compu\u00adany value of type A on the channel k. To represent \nthis event tation; this computation, when activated, immediately evalu\u00adwe extend the syntax further by \nletting k?A be a guarded ex\u00ad ates to the value v. In order to represent these trivial compu\u00adpression \nfor any k and A, with the associated rule tations we introduce a new constructor for guarded expres\u00adsions, \nA and the semantics of always is then captured by the e-J$e rule reCeheA e &#38; e \\\\ [k?A] e~e alwayse \nL el II [Av] The construct trans!?_ikA is handled in a simhr manner. Since Av immediately evaluates to \nthe constant v we have Thwe remain five constructs for delayed computations to be explained. The first, \nnever of type unit ~Aevent, is han\u00addled by the introduction of the guarded expression A, repre-Av=+v \nsenting a deadlocked evaluation, together with the inference The choice constmct choose e is a choice \nbetween delayed computations as choose has the type A event * A event --+ A event. To interpret it we \nintroduce a new choice construc-3 Weak Bisimulation Equivalence tor gel Q ge2 where gel and ge2 are guarded \nexpressions of the same type. Then choose e proceeds by evaluating e until it can produce a value, which \nmust be of the form ([gel], [ge2]), and the evaluation continues by constructing the delayed computation \n[gel @ge2]. The notation ~, introduced b [281, is unfortunate, as it is used in [15] to represent the \ninternal choice between processes whexeas here it represents external choice and has the same rules as \nCCS summation. Finally sync is used to launch a delayed computation e-@Le synce J+e j\\ge  This ends \nour informal description of the operational se\u00admantics of pCML. We now summari se, giving the precise \ndetlnitions of the new syntax. For the purposes of compari\u00adson with the reduction semantics of L [281, \nit is convenient to view the extension to PCML in two stages. The tirst is obtained by adding the new \nsyntactic category of guarded expressions, and two new constructors for values: vEVal ::= ... I(v,v) \nI[ge] ge E GExp ::= v!Avlv? \\ge+vlge@gel A\\Av The resulting language we call flCMLcv, as it corresponds \nvery closely to Reppy s LCV. A precise comparison is given in Section 5. The final language, PCML+, is \nobtained by extending ,uCMLCV with: e E Exp ::= .lgeletle and type judgments for all the extra constructs \nare given in Figure 3. The operational semantics is given as a set of transition relations ovex closed \nexpressions horn pCML+. These tran\u00ad sition relations have as labels Label: a ::= v!Av I v?Ax ct::=alz \nl::=alfl which are typed with judgments E 1: A in Figure 4, and are defined to be the least relations \nsatisfying the rules in Figure 2. It is worth pointing out that the context rules are asym\u00ad metric for \nthe propagation of value production thou@ the context II; in e II~ only the computation thread ~ can \nproduce a value. This is in agreement with the reduction semantim of [28] where in a given state represented \nby a multi-set of expressions only one distinguished expression is allowed to produce a value. A complete \novwview of the operational semantics can be found in [10]. Theorem 2.1 (Subject Reduction) For every \nclosed ex\u00adpression e in pCML+ ife~e and te:Athen El:A,  ife Le and Fe: Athen l-e :A,  ife&#38;e and \nte:Athente :A, %e andk e: Athenx:Bke :A, and  lfe k!Bv e{ and\\ e :A then h e :A.  tfe +  In this \nsection we demonstrate the usefulness of our opera\u00adtional semantics by providing VCML+ with an appropriate \nversion of bisimulation equivalence. We discuss a range of possible bisimulation based equivalences and \neventually pro\u00adpose a new variation called hereditary bisimulation equiva\u00ad lence, which we feel is most \nsuited topCML+. We first show how to adapt the notion of strong bisimu\u00adlation equivalence to PCML+. Since \nour language is typed it is more convenient to detine the equivalence in terms of type-indexed families \nof relations. Moreover since the oper\u00adational semantics uses actions of the form e % f where f may bean \nopen expression we need to consider relations over open expressions. Let an open type-indexed relation% \nbe a family of relations &#38;,A such that if e ~r,A f then r b e: A and 17h ~: A. We will often elide \nthe subscripts from rela\u00adtions, for example writing e X, f for e Kr,A f when context makes the type obvious. \nLet a closed type-indexed relation ~ bean open type-indexed relation where r is everywhere the empty \ncontext, and can therefore be elided, For any closed type-indexed relation z, let its open extension \nZ be defined as: ff e[7/~ ~~ f [7/~ for all 1-7:1. e R;:A,~ f I A closed type-indexed relation 2(, is \nstructure preserving ifi ifv&#38;wand Ais abase type thmv=w,  if (VI, V2) &#38;,*A2 (lVI, W2) th~ vi \nfii ~i.  if [gel] fievent [ge2] then gel ~A ge2, and  ifvfi_+~v then forallt-w:A wehavevwfiv w.  Whh \nthis notation we can now detlne strong bisimulations over uCML+ expressions. A closed type-indexed relation \n~ is a$rst-order strong simulation iff it is structure-preserving and the following diagram can be completed: \nel~ ez e~~ ez 1 asl 1  &#38; :1~ :2 el Note the use of the open extension ~ . This means, for ex\u00ad ample, \nthat if el K ez w~re#re that the move el @ fl be matched by a move e2 fz whexe fz is such that for all \nvalues v of the appropriate type fl [v/x] ~ fz[v/x]. Thus in the terminology of [21] our definition corresponds \nto the late version of bisimulation. ~ is afirst-order strong bisimulation iff ~ and ~-1 are first-order \nstrong simulations. Let -1 be the largest first\u00ad order strong bisimulation. Proposition 3.1 R 1 is an \nequivalence. Unfortunately, =1 is not a congruence for .uCML+, since we have add(l,2) -1 add(2, 1) buti \nsync(transmk(k, fn x+ add(l,2))) +1  e%-e e=e e%. e ce--Lcf+ ef%e{f (e, f) $ (e , f) eJ%e eJZf? ifethen~elseg \n~ ife then~elseg Ietx=einf %Ietx=e inf Figure 2a Operational semantics: static rules gel % e ge2--% e \nge%e gel @ge2 S e gel d? ge2 --% e ge+v%ve Figure 2b: Operational semantics: dynamic rules e@le, e ~tr.e \ne, ~ ~fake et ce<e llb(c, v) ifethenfelseg~e 11 f ifethen f elseg <e I\\g etie etif? [v= fix(x = fn JJ*g)] \n (e, f) A e Illetx= fin(v,x) ef -Q+ e [1Iety = f ing[v/x] etif+ C*e, f~fl e~e, f*f, Ietx= ein f + e II \nf[v/x] ell f Ae 11 f [v/x] ellf 3e [v/x][lfl Figure 2C Operational semantics: silent rules Figure 2d: \nOperational semantics: axioms tl(fst, (v, w)) = v i5(snd, (v, w)) = w 5(add, (m, n)) = m+n b(mul,(m,n)) \n= mxn 5(leq, (m, n)) = m<n b(transmitA, (k, v)) = [k!~v] b(receiveA, k) = [k?A] b(choose, ([gel], [ge2])) \n= [gel fBge2] b(wrap, ([ge], v)) = [ge* v] b(never, ()) = [A] b(always, v) = [Av] b(spawn,v) = vo II \n() b(sync, [ge]) = ge Figure 2e Operational semantics: reduction of constants rFv:A r~~:B 17kge:A rl-(v, \nw):A*B r 1-[ge] : A event l_ 1-v:chan rt-w:A 171-v:chan 171-ge:A 171-v:A+B r ~ v!A~: unit rhV?A:A lTt-ge~v:ll \nrl-gel:A 17t-ge2:A rEv:A 171-ge1@ge2:A l_ k A:A l_ k Av:A Figure 3: Type rules for extra VCML+ amstructs \n171-v: chan rt-w:ll 17+v:chan rFv:A rtT:A rt-v!Bw:A rl-v?Bx:A rF@:A FQure 4 Type rules for labels sync(transmit(k, \nfn x+ add(2, l))) since the lhs can perform the move sync(transmit(k,fn .x% add(l, 2))) !(fnX+add(l 2)~ \n() but this can only be matched by the rhs up to strong bkimu\u00adlatiom sync(transmit(k, fn x+ add(2, l))) \n!(fn +add(21! () In fact, it is easy to verib that the only tirst-order strong bisimulation which is \na congruence for PCML is the identity relation. To find a satisfactory treatment of bkimulation forpCh4L, \nwe need to look to higher-order bisimulation, where the structure of the labels is accounted for. To \nthis end, given a closed type-indexed relation ~, define its extension to la\u00adbels ~1 as: v~Aw T~;T ~v \n~; @v v~w k?Bx ~: k?llx k!lfv Q k!~w Then ~ is a higher-order strong simulation iff it is structure\u00adpreserving \nand the following diagram can be completed e~~ e~ e~~ e2 11 as 11 12 where 11%1 12 I II e; e;~ ej LetF-hbe \nthe largest higher-ordm strong bisimulation. Proposition 3.2 -h is u congruence. For many purposes, strong \nbisimulation is too fine an equiva\u00adlence as it is sensitive to the number of reductions performed by \nexpressions: e.g. (fn x+ x) O #h O. We require the looser weak bisimzdation which allows -c-actions to \nbe ignored. This in turn requires some more notation. Let=% be the reflexive transitive closure of ~, \nand let =&#38;-be =%-L (i.e. any sequence of silent action followed by an i action). Note bat we are \nnot allowing silent actions after the 1 action. Let ~ be =% if 1= T and ~ otherwise. Then ~ is ajrst\u00adorder \nweak simulation iff it is structure-preseming and the following diagram can be completed: el~ ez el~ \nez 1 asl / 1! e; e;~ e~ Let d be the largest fist-order weak bisimulation. Proposition 3.3 251 is an \nequivalence. Unfortunately, w 1 is not a congruence, for the same reason as -1, and so we can attempt \nthe same fix. ~ is a higher\u00adorder weak simulation iff it is structure-preserving and the following diagram \ncan be completed e~~ ez e~~ ez 11 1 m 1 ~llwhaez @2 e~ e: 2(,0 e~ Let Sh be the largest higher-order \nweak bisimulation. Proposition 3.4 *h is an equivalence. However, Xh is not a congruence, for the usual \nreason that weak bisimulation equivalence N is not a congruence for CCS summation. Recall from [20] that \nNil w ~.Nil but k!O + Nil # k!O + ~.Nil. We can duplicate this counter\u00adexample inpCML+ since the CCS \noperator + corresponds to the pCML+ operator@ and Nil corresponds to A. However @ may only be applied \nto guarded expressions and therefore we need a guarded expression which behaves like -c.Nil; the required \nexpression is A[A] + syn c. l%us: A %h A[A] ~ sync since the rhs has only one reduction A[A] +sync \nL sync[A] <AIIA but: A@ k!O #h (A[A] ~ sync) @k!O because (A[A] a sync) @k!O ~ sync[A] ~ A A first \nattempt to rectify t.hk is to adapt Milner s observa\u00adtional congruence for PCML, and to define =h as \nthe small\u00adest symmetric relation such that the following diagram can be completed: Proposition 3.5 =h \nis an equivalence. This attempt fails, however, since it only looks at the ilrst move of a process, and \nnot at the tirst moves of any processes in its transitions. Thus, the above MCML counter-example for \nwh being a congruence also applies to =h. This failure was first noted by Thomsen [30] for CHOCS. Thomsen \ns solution to this problem is to require that ~-moves can always be matched by at least one ~-move. \nwhich produces his definition of an irrejiexive simulation as a structure-preserving relation where the \nfollowing diagram can be completed Let Xi be the largest irreflexive bisimulation. Proposition 3.6 zi \nis a congruence. However this relation is rather too strong for many purposes, for example add(l,2) #i \nadd(l, add(l, 1)) since therhs can perform more -c-moves than the lhs. This is similar to the problem \nin CHOCS where a.z.P #i a.P. In order to find an appropriate definition of bisimulation for vCML, we \nobserve that pCML only allows@ to be used on guarded expressions, and not on arbitrary expressions. We \ncan thus ignore the initial -c-moves of all expressions except for guarded expressions. For this reason, \nwe have to provide two equivalences: one on terms where we are not interested in initial wmoves, aud \none on terms where we are. A pair of closed type-indexed relations ~ = (~ , ~ ) form a hereditary simulation \n(we call ~n an insensitive sim\u00adulation and ~s a sensitive simulation) iff !?(,sis structure\u00adpreserving \nand we can complete the following diagrams: el~ ez el~n ez 11 I as 11 1! [2 where 11~sl 12 e; e; R \ne; and: el ~s ez el ~s ez 11 I m 1 Jwhae @ 2 e; ej 2(, 0 e; Let(EY)d) be the largest hereditary bisimulation. \nIn the operational semautics of expressions from pCML guarded expressions are introduced as components \nto Labels and never as residuals. This explains why in the detin.ition of X labels are compared with \nrespect to the sensitive re\u00adlation &#38; whereas the the insensitive relation is used for the residuals. \nFor example, if gel ~n ge2 then we have (fn x+gel) w (fn x*ge2) since once either side is applied to \nan argument, their tirst action will be a T-step. On the other hand: [gel] #h [gez] lhe main result \nof this section is embodied in the following Theorem Theorem 3.7 z is a congruence for pCML~, and W is \na congruence for JK.34L. Unfortunately, the proof of this Theorem is not straight\u00adforward, due to the \nhigher-order nature of hereditary bisim\u00adulation, and it appears that standard techniques from pro\u00adcess \nalgerbra fail to work. The problem is not unique to vCML, and it occurs in many higher-order languages, \nfor ex\u00adample Gordon s [121 operational semantics for the typed A\u00adcaleulus, Howe s [181 treatment of the \nlazy kakulus, and ThOIIMH1 S [30] Cal(xdus of Higher-Order Conmmnicating Systems (CHOCS). It seems that \nany inductive proof that weak bisimulation is a congruence for higher-order languages requires an in\u00adduction \non both syntax and proof structure. The usual meth\u00adods of performing nested induction fail in this case, \nand so another method of performing simultaneous induction is re\u00adquired. Fortunately this is achieved \nby a technique developed for the lazy ?wcalculus by Howe [18], and we have been able to adapt this technique \nto our setting. The following Theorem shows us that # is the largest congruence which is a weak bisimulation \nand is included in higher-order weak bisimulation. Theorem 3.8 d is the largest higher-order weak bisimula\u00adtion \nwhich respects IJCML contexts. Proposition 3.9 The equivalences on ,uCML+ have the fol\u00adlowing strict \ninclusions: ~1~ %1 r r ++ _h. h -+% h is the operator @ which differentiates between the two equivalences \n# and w~. However in order to demonstrate the difference we need to be able to apply 6 to guarded ex\u00adpressions \nwhich can spontaneously evolve, i.e. perform z\u00admoves. The only PCML+ constructor for guarded expres\u00adsions \nwhich allows this is A, and in turn occurrences of this can only be generated by the pCML constructor \nalways. Therefore Proposition 3.10 For the subset of pCML+ without aIways and A, # is the same as zh, \nand &#38; is the same as =h. Properties of Weak Bisimulation In this section, we show some results about \nprogram equiv\u00adalence up to hereditary weak bisimulation. Some of these equivalences are easy to show, \nbut some are trickier, and re\u00adquire properties about the transition systems generated by pcm+ . We now \nexamine the extent to which @ and II act like choice and parallel operators from a process algebras We \ncan find bisimulations for the following (and hence they are sen\u00adsitive bisimilar): Alle Wl e (e~ lle~)lle~ \nW e~ ll(e~lle~) (e~ lle~)\\\\e~ -1 (e~lle~)lle~ Thus II satisfies many of the standard laws associated \nwith a parallel operator in a process algebra. However it is not in general symmetric because of its \ninteraction with the produc\u00adtionofvalues: e.g. 1 IIAw1 A#l 1 WI All 1. This means that we can view the \nparallel composition of processes as being of the form (Llei)llf where the order of the ei is unimportant. \nNote that it is im\u00adportant which is the right-most expression in a parallel com\u00adposition, since it is \nthe main thread of computation, and so can return a value, which none of the other expressions can. The \nchoice operator of ,uCML+ also satisfies the expected laws tkom process algebras, those of a commutative \nmonoid, although it can only be applied to guarded expressions: A@ge -1 ge (gel @gez) @ge3 -1 gel@ (gez \n@ge3) gel @ge2 ml gez @gel This means that we can view the sum of guarded expressions as being of the \nform @gei where the order of the gel is unimportant. In fact guarded expressions can be viewed in a manner \nquite similar to the sum forms used in the development of the algebraic theory of CCS, [20]. We can find \nbisimtdations for the following (and hence they are sensitive bisimilar): (gel @gez) + v WI (gel *v) \n@(gez + v) ge+fnx+x &#38; ge Av d Aoafnx+-v From this, we can show, by structural induction, that all \nguarded expressions are of a given form ge &#38; @gel *v, where each gei is either ki !v,, k,? or A(). \nFrom this and Cv %1 5(C, V) we can show that all values E v: A event are of the form v # choose[wrap(el, \nvi), . . . . wrap(e~, vn)] where en is either transmit(kl, vi), receive k,, or alwayso. We could continue \nin this manner emulating the algebraic theory of CCS, for example with expansion theorems for guarded \nexpressions or values of event type. However we leave this for future work. We now turn our attention \nto pCML viewed as a functional language. One would not expect (3-reduction in its full gen\u00aderality in \na language with side-effects such as ,uCML but we do obtain an appropriate call-by-value version (fn \ny~e)v = e[v/y] We also have expected laws such as: fst(e, v) e snd(v, e) e (fix(x=fn y+e))v e[fix(x = \nfn y + e)/x] [v/y] letX= vine e[v/x] Iety=(letx =einf)ing Ietx= ein(lety= fing) where x @fv(g) The last \ntwo eguations are of txwticular interest, since they are exactly the le~ unit and ass~iativity axioms \nof Moggi s [22] monadic metalanguage. The right unit tquation: letX=einx#e is not so simple to show, \nand indeed if e were an arbitrary the reduction semantics for &#38;, presented in [28]. We have labelled \ntransition system then it would not be true, as can be not considered &#38;, in its entirety and so the \ncomparison will S13311by: be confined to the common subset, namely pCMLcv. Prom Reppy s reduction semantics \nwe then derive a labelled tran\u00ad Ietx=einx e # sition system for pCML expressions and our main theorem \n  Y x Y Y A Allv A A I~v Al\\A (This is the same example which makes SKIP not act as a right unit for; \nin CSP [16] and exit not act as a right unit for >> in LOTOS [1].) Fortunately, we can show that our \noper\u00adational semantics for pCML satisfies four properties which allow us to show the right unit equation. \nA labelled transition system is single-valued iff e L e implies e @ for any w. It is value deterministic \niff e ~ e ande * e implies v = w and e = e . It is forward commutative iff ~v ~v e e e + e ifa aa then \n I II o em e e  + It is backward commutative iif f +wj4 ~v. /// /rr e e Proposition 4.1 pCi14L satisfies \nsingle-valuedness, value determinacy, forward commutativity and backward commu\u00adtativity. The importaut \nproperty which such its s satisfy is the follow\u00ad ing, where we assume the existence of the operator II, \nProposition 4.2 In any single-valued, value deterministic, forward commutative, backward commutative \nits, fe &#38; e thene%l e Ilv. As a corollary to this proposition, it is routine to show that the following \nis a first-order weak bisimulatiom {(e,letx=einx)}Uwl So we have the right unit equation we were looking \nfon e=l Ietx=einx 5 Comparing ,uCML+ and &#38;v In section 2 we presented the operational semantics \nof a sub\u00adset of CML, as a labelled transition system, in order that we might investigate its behavioral \nproperties. In this section we shall make formal connection between this semantics and states that this \nlabelled transition system (up to fist-order weak bisimulation) is the same as ours. In fact the more \ntech\u00adnical results we derive connecting the two semantics would support a much closer relationship but \nexpressing it would in\u00advolve developing yet another bisimulation based equivalence. We briefly emphasise \nbelow the differences betweea &#38;v and yCMLCv: We do not consider the&#38; constructs guard and wrapAbort. \n . We omit the &#38; construct than x in e since we cannot encode unique channel name generation in vCML. \nWe have added recursive function types to ,uCMLCV . In [28] the semantics is represented by a reduction \nrelation between multi-sets of pCMLCv expressions, or more gener\u00adally &#38; expressions. Instead of multi-sets \nwe use configura\u00adtions of pCMLcv expressions given by the grammac Cc Conf::=el C[l CIA Note that configurations \nare restricted forms of pCML+ ex\u00adpressions. This will facilitate the comparison between the two semantics \nsince it can be carried out for configurations rather than pCML expressions. The semantics of [28] is \nexpressed as a reduction relation = between conilgurations and is defined in terms of reduc\u00ad tion contexts. \nFor example E[(fn x+ e) v] + E[e[v/x]] We refer the reader to [10] for a full description of the reduction \nsemantics. We call the semantics defied by this relation the pCMLcv semantics. We refer to that in Section \n2 as thepCML+ semantics and we now compare them. In order to do this, we extract a Iabelled transition \nsystem from the pCMLcv semantics by defining cJ-+Cr iff C+Cr C&#38;Cr iff C= C llvand C =C ll A C&#38;C \niff Cllk?=+C llv C&#38;C iff Cllk!x*c llo We will then show that this Iabelled transition system is \nweakly bisimilar to the yCML+ its: Theorem 5.1 The pCh4Lcv semantics of a configuration is weakly bisimilar \nto its pCML~ semantics. The remainder of this section is devoted to proving this result. Although the \nstyle of presentation of these two semantics are very different the resuhing relations are very similzu \nand there are essentially only two sources for the differences. The first is that certain reductions \nin VCMLCV, when modelled in the YCML+ semantics, require in addition some housekeeping reductions. A \ntypical example is the reduction (fn x~e)v ~ e[v/x]. In PCML+ this requires two reductions: (fnxae)v \nJ+ Ietx= vine --L e[v/x] This problem is handled by identifying the set of housekeep\u00ad ing reductions, \nsuch as the second reduction above, within thepCML+ semantics. These turnout to be very simple and we \ncan work with housekeeping normal forms in which no further housekeeping reductions can be made. The \nsand divergence between the semantics concerns the treatment of spawn; expressions in ,uCML+ may spawn \nnew processes which give rise to parallel processes warring as sub-term of the expression. For example, \nthe reductions of (spawn v, e) in ,uCML+ and,uCML vare (spawnv,e) J% (Allvollo,e) (spawnv,e) &#38; vo \nII ((),e) This differenceis handled by working with the ,uCMLCV se\u00admantics up to a syntactically defined \nequivalen~ this equiv\u00adalence is contained in strong bisimulation equivalence and it also preserves housekeeping \nreductions. We now explain in some more detail these technical devel\u00adopments. House-keeping reductions \nare ones derived using the rules: eJve, eWf+ synce --L e [Ige (e, ~) J-+ e II Ietx=$in(v, x) etiei [v= \nfix(x= fn ~>g)] e~J+elll lety=~ing[v/x] We shall write e % e whenever e 4 e is a housekeeping reduction. \nIt is routine to veri~ that the housekeeping moves are se\u00admantically unimportant , as is captured by \nthe next proposi\u00adtion. Proposition 5.2 If e -% e then e WI e Moreover, we can show a confluence result \nfor the pCML+ semantics about housekeeping moves: Proposition 5.3 T; -+ e +e e  + e If1 then1 f 1 M \n~~ // // //! Call ~ term tidy if it ~m no hou&#38;keping reductions. Then we can show that every ,uCML+ \nterm has a unique tidy nor\u00admal form. Proposition 5.4 For any pCML~ term e there is a unique tidy e such \nthat e %* e . We now turn our attention to the syntactic equivalence used to handle the different treatments \nof spawn. In order to de\u00adfine the equivalence ~ it is convenient to introduce reduction contexts for \n,uCML+, equivalent to those for pCMLcv: E+ ::= []\\ E+elc E+l(E+, e)lletx=E+ine] if E+theneelse elE+\\le\\el\\E+ \n Let= be the smallest equivalence given by equivalence given by: The equivalence ~ is a strong fist-order \nbisimulation which respects housekeeping, that is a relation ~ where we can complete the diagram and \nsimilarly for ~-1. Proposition 5.5 % is a strong$rst-order bisimulation which respects housekeeping. \nWe can also show a very strong correspondence between reductions of pCMLCV configurations, and their \ntidy normal forms. Proposition 5.6 If C % e and e is tidy, then the following diagrams can be completed: \n1 as1 1 I II ~1 c1~ ~el  and: -c; T; c e c e Whh these technical results we can now prove the main \nre\u00adsult showing the correspondence between the two semantics: Theorem 5.7 The ,uCMLc semantics of a configuration \nis weakly bisimilar to its .uCML~ semantics, Proof. Intuitively we know, from Proposition 5.2, that ,uCML+ \nexpressions are semantically equivalent to their tidy forms, and Proposition 5.6 can be used to transform \npCMLcv moves horn an expression into pCML+ moves of its tidy form up to E, and vice-versa. Formally we \nshow that % EZ is a weak bisimulation by completing the dia\u00adgranx T by using Proposition 5.4 to iind \nel s tidy form e2, and then using Propositions 5.3, 5.5 and 5.6 to show: and by completing the diagram \nby using Proposition 5.4 to find el s tidy form e3 and then using Propositions 5.3, 5.5 and 5.6 to show: \nThe result follows. o Conclusions In this paper we have defined a compositional operational se\u00admantics \nfor a core subset of CML, called PCML, and used it to develop at least the beginnings of an algebraic \nthe\u00adory of CML programs based on an appropriate version of weak bisimulation equivalence. The operational \nsemantics required an extension of the language to ,uCML+ although it is worth pointing out that all \nof the added constructs can be defined in the core language&#38;CML up to weak bisimulation equivalence \nMuch research remains to be done. The algebraic theory of ,uCML, started in Section 4, needs to be developed \nto the extent that it can be used to Charactexise the semantic equiv\u00ad alence = . More generally both \nthe operational semantics and the semantic equivalence should be extended to incca-po\u00adrate more of the \nfeatures of CML. Of particular interest is the generation of new channel names. We believe that our operational \nsemantics can be adapted to handle new channel generation but the semantic equivalence would need to \nbe changed to an appropriate adaptation of context bisimulation equivalence, [29]. As pointed out in \nSection 3 our semantic equivalence, @, is based on the late version of bisimulations, [21]. This fits \nin quite well with the functional nature of CML but nevertheless it would be of interest to consider \nother variations. One can easily define an early version of N* or versions where silent moves are allowed \nto occur afttx a matching L move. How\u00adevex we have been unable to adapt Howe s method to show that these \nequivalences are preserved by PCML contexts. In Section 3, we were forced to develop the theory of hereditary \nbisimulations because of the usual problems of z actions resolving choice. In the sublanguage without \naIways and A, we showed that weak bisimulation coincided with insensitive hereditary bisimulation, and \nso has a simpler and more elegant theory. This theory has been investigated by the first author [8]. \nIn this theory, it is possible to use CSP rather than CCS summation, and so weak bisimulation is respected \nby all contexts. As a side-effect of this, it is possible to re\u00admove the syntactic restriction that [ge] \ncan only be applied to guarded expressions. The third author has shown [19] that the resulting semantics \ncan be presented in terms of Moggi s [22] monadic type system. There has already been a considerable \namount of research into the foundations of CML and related languages. Much of this is concerned with \ndeveloping more detailed type systems, where types contain information on the behaviour of expres\u00adsions \nas they evolve, [23]. Here we confine our remarks to work diredy concerned with the development of semantic \ntheories. We have already given a detailed comparison with the operational semantica given in [27, 28]. \nThis semantics has been used in [5] to study an implementation of ML ref\u00aderence types using process gaeration. \nIf we extend our ap\u00adproach to include channel generation then we could hope to give an algebraic treatment \nof their results. In [6,7] there are a number of different semantics given to languages related to CML. \nA denotational semantics is given using the concept of dynamic types but it has not yet been related \nto any opera\u00adtionally based equivalence. An operational semantics is also given for a language called \nFPI. This contains many CML features but the author notes that accommodating any spawn or fork operator \nwould be difficult. In [14, 3] the spawn op\u00aderator is studied within the context of process algebras. \nThe former gives a two-level operational semantics for a simple pure process algebra with fork anduses \nthis to develop a semantic equivalence based on strong bisimulation; an ax\u00adiomatisation is also given \nusing an auxiliary operator called forked. The latter shows how the various algebraic them-k of ACP can \nbe adapted to support the addition of a spawn op\u00aderator. This contains an lts based operational semantics \nfor ACP + spawn and their treatment of spawn has been used in [91 to give an operational semantics of \na language which can be considered to be an untyped version of pCML. However http://www.cogs.susx. ac.uk/Computer \nScience Te&#38;ni\u00ad bisimulationbased equivalences are not developed in [9]; in\u00adstead a testing equivalence \nis detined [15] and a folly-abstract denotational semantics based on Acceptance Trees is given. Other \nlanguages which contain much in common with CIVIL include CHOCS [301, FACILE [11], PICT [25], AC-TORS \n[2] andHOTC [29]. Most of these are endowed with an operational semantics some of which are similar in \nspirit to ours. However we feel that our treatment of spawn and delayed computations is novel and hope \nthat it can be used to good effect with other languages. Many of these languages also have associated \nwith them bisimulation based seman\u00adtic equivalences. Section 3 may be viewed as an extension of the research \nin [30] and the new equivalence d can eas\u00adily be adopted to languages such as CHOCS and FACILE. We have \nalso already indicated that when we extend pCML to include channel generation it will be necessary to \nadopt the context bisimulation equivalence, originally developed in [29]. In short although semantic \ntheories are being developed independently for these languages many of the techniques de\u00ad veloped will \nfind more general References [1] ISO 8807. LOTOS-A based on the temporal haviour, 1989. application. \nformal description technique ordering of observational be\u00ad [2] G. Agha, I. Mason, S. Smith, and C. TalcOtt. \nA founda\u00adtion for actor computation. J. Functional Programming, 1994. [31 J. C. M Baeten and E W. Vaandrager. \nAn algebra for process creation. Acts lnformatica, 29(4):303-334, 1992. [41 J. A. Bergstra and J. W. \nKlop. Algebra of communicat\u00ading processes with abstraction. Theoret. Comput. Sci., 37:77-121,1985. [5] \nDave Berry, Robin Milner, and David N. Ti.n-ner. A se\u00admantics for ML concurrency primitives. In Proc. \nPOPL 92,1992. [61 Dofique BOliWam and Mourad Debabi.A semantic theory for concurrent ML. In Proc. TACS \n94,1994. [7] M. Debabi. Integration de Paradigms de Programma\u00adtion Paralle, Fonctionnelle et Imperative. \nPh.D thesis, University D Orsay, 1994. [8] WWiam Ferreira. Semantic Theories for Concurrent ML. D.Phil \nthesis, COGS, Sussex Univ., 1995. In preparation. [91 William Ferreira and Matthew Hennessy. Towards \na se\u00admantic theory of CML. Technical report 95:02, COGS, Sussex univ., 1995. available electronically \nftom http://www.cogs.susx.ac.uk/Computer Science Techni\u00adcal Reports/. [101 William Ferreira, Matthew \nHennessy, and Alan Jef\u00adfrey. A theory of weak bisimdation for core CML. COGS Comp. Sci. T&#38;h. Report \n05/95, univ. Sussex, 1995. available electronically from cal Reports/. [11] A. Giacalone, P. Mishra, \nand S. Prasad. Facile A symmetric integration of concurrent and functional pro\u00adgr amming. In Proc. Tapsoft \n89, volume 352 of LNCS, pages 184-209. Springer-V&#38;rlag, 1989. [12] Andrew Gordon. Bisimilarity as \na theory of functional progr amming. In Proc. MFPS 95, number 1 in Elec\u00adtronic Notes in Comp. Sci. Springer-Verlag, \n1995. [13] Carl Gunter. Semantics of Programming Languages. MIT preSS, 1992. [14] K. Havelund. The Fork \nCalcuJus: Towards a Logic for Concurrent ML. Ph.D thesis, Ecole Normale Superieur, Paris, 1994. [15] \nM. Hennessy. Algebraic Theory of Processes. MIT preSS, 1988. [16] C. A. R. Hoare. Communicating Sequential \nProcesses. Prentice-Hall, 1985. [17] Soren Holmstrom. PFL: A functional language for par\u00adallel programming \ng. In Proc. Declarative Programming Workshop, pages 114-139,1983. [181 Douglas Howe. Equality in lazy \ncomputation systems. In Proc. LICS 89, pagea 198-203,1989. [191 Alan Jefiey. A fully abstract semantics \nfor a concurrent functional language with monadic types. In Proc. LZCS 95, pages 255-264,1995. [20] Robin \nMilner. Communication and Concurrency, Prentice-Hall, 1989. [21] Robin Milner, Joachim Parrow, and David \nWalker. A calculus of mobile proceses. Inform. and Comput,, 100(1):1-77, 1992. [22] figtio Moggi Notions \nof computation and monad. Inform. and Comput., 93:55-92,1991. [23] F. Nielson and H. R. Nielson. From \nCML to process algebras. Report DAIMI FN-19, Dept. Comp. Sci., Aarhus University, 1993, [24] Sivaswami \nNikhil. Id Reference Manual. MIT Lab. for Comp. Sci., 1990. [25] Benjamin C. Pierce and David N. Tmer. \nPitt: A pro\u00adgramming language based on the pi-calculus. Ttical report in preparation; available electronically \nflom http://www.cl.cam.ac.uk/usezs/bcp 1000/ftp/index.html, 1995. [261 Johu Reppy. A higher-order concurrent \nlangauge. In Proc. SIGPLAN 91, pages 294-305,1991. [27] Johu Reppy. An operational semantics of first-class \nsynchronous operations. Technical report TR 91-1232, Dept. Comp. Sci., Cornell Univ., 1991. [28] John \nReppy. Higher-Order Concurrency. Ph.D thesis, Cornell Univ., 1992. [291 Davide Sangiorgi Expressing Mobiiity \nin Process Al\u00adgebras: First-order and Higher-order Paradigms. Ph.D thesis, LFCS, Edinburgh Univ., 1992. \n[30] Bat Thomsen. A theory of higher order communicat\u00ading systems. Inform. and Comput., 116(1):38-57, \n1995.  \n\t\t\t", "proc_id": "232627", "abstract": "Concurrent ML (CML) is an extension of Standard ML of New Jersey with concurrent features similar to those of process algebra. In this papes we build upon John Reppy's reduction semantics for CML by constructing a compositional operational semantics for a fragment of CML, based on higher-order process algebra. We use this to build a semantic theory for CML, based on weak bisimulation equivalence. We give some small examples of proofs about CML expressions, and show that our semantics corresponds to Reppy's up to weak first-order bisimulation.", "authors": [{"name": "William Ferreira", "author_profile_id": "81100244934", "affiliation": "University of Sussex", "person_id": "P298964", "email_address": "", "orcid_id": ""}, {"name": "Matthew Hennessy", "author_profile_id": "81100207163", "affiliation": "University of Sussex", "person_id": "PP39060125", "email_address": "", "orcid_id": ""}, {"name": "Alan Jeffrey", "author_profile_id": "81100380257", "affiliation": "University of Sussex", "person_id": "PP14134538", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/232627.232649", "year": "1996", "article_id": "232649", "conference": "ICFP", "title": "A theory of weak bisimulation for core CML", "url": "http://dl.acm.org/citation.cfm?id=232649"}