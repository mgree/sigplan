{"article_publication_date": "06-15-1996", "fulltext": "\n Mixin Modules Dominic Duggan* Mixin modules are proposed as a new construct for module lan\u00ad guages, \nallowing recursive definitions to span module boundaries. Mixin modules are proposed specifically for \nthe Standard ML lan\u00ad guage. Several applications are described, including the resolution of cycles in \nmodule import dependency graphs, as well as function\u00ad ality related to Haskell type classes and CLOS \ngeneric functions, though without any complications to the core language semantics. Mixin modules require \nno changes to the core ML type system, and only a very minor change to its run-time semantics. A type \nsystem and reduction semantics are provided, and the former is verified to be sound relative to the latter. \n Introduction The Standard ML module language has gained some interest be\u00ad cause of its state-of-the-art \nmodule language. The module language provides a clean separation between modules and interfaces, allow\u00ad \ning a module to export several interfaces. A particular strength of the language is its treatment of \nprrrameterized modules (functors). Standard ML provides an innovative mechanism for combining abstraction \nand sharing: sharing constraints in a fonctor building block can be used to place some graph structure \non the import hi\u00ad erarchy over which it abstracts. The original Standard ML module system provided weak \nsupport for separate compilation. Mo&#38;da\u00ad like manifest type definitions in opaque interfaces have \nbeen pro\u00ad posed as an alternative module design, facilitating both separate compilation [18] and first-class \nmodules [13, 26]. An aspect of the Standard ML module system which remains problematic is its interaction \nwith recursive constructs which cross module boundaries. The problem is that such constructs are not \nal\u00ad lowed; the module dependency graph is required to be acyclic. This IS an instance of a problem shared \nby all other module systems. The essence of the problem is that recursion cannot cross module boundaries. \nAs a resul~ for example, mutually recursive datatypes in ML must be defined in the same module. This \nresults in a some\u00ad what monolithic module structure, in which one module collects the datatype definitions, \nwhile client modules implement the func\u00ad tionality required for these datatypes. This monolithic structure \nis at odds with data abstraction, which would entail encapsulating the types, and the operations on those \ntypes, behind opaque interfaces. Various languages take different approaches to reconciling the need \nto allow recursion to cross module boundaries. Haskell and Modula-3 allow cycles in the module import \ndependency graph. Although some such approach might be investigated for the Stan\u00ad dard ML module system, \nthis is not a general solution to what we Address: Department of Computer Science, University of Waterloo, \nWaterloo, Ontario, Canada N2L 3G1. dduggaa@uwat erlo o. ca  Permission to make digitaihrd mpy of part \nor all of thii vmrk for personal or classroom use is ranted without fee provided that copies are not \nmade or distributed for pro i t or eommereiai advantage, the copyright notice, the title of the publication \nand its date appear, and notkx is given ttrat copying is by permission of ACM, Inc. To mpy otherwise, \nb republish, to poet on servers, or to redstribub to lists, requires prior apeoitio permission and/or \na fee. ICFP 96 5/96 PA, USA O 1996 ACM 0-69791 -771 -!XWOO05...$505O Constantinos Sourelis would like \nachieve in breaking up recursive constructs across mod\u00adules. For example the Haskell language also has \ntype classes [3 1]. In the semantics provided in [10], type classes allow recursive def\u00adinitions to cross \nmodule boundaries by breaking up recursive func\u00adtions into implementations of an overloaded operator. \nThe type system allows these implementations to be type-checked indepen\u00addently and then implicitly combined \nat points where an overloaded operation is used in an application. In this paper we present an extension \nto Standard ML mod\u00adules which supports modular building blocks where recursive def\u00adinitions cross module \nboundaries, but which is a conservative ex\u00adtension of the existing module system. This approach alIows \nSML modules to be decomposed into smaller parts, called mixin mod\u00adules. Mixins allow recursive definitions \nto be broken up into mod\u00adular fragments: both recursive function and recursive type defini\u00adtions may \nbe broken up and spread across modules. A combin\u00ading operation allows these fragments to be combined, \nand a clo\u00adsure operation allows an ordinary Standard ML module to be pro\u00adduced from the composition of \nseveral mixins. At the core language level, we allow empty dat at ype definitions. These are primarily \nfor mixins which rely on other mixins to provide the definitions of such datatypes (Sect. 2.2). We introduce \nan inner pseudo-variable, which allows access to further extensions of a recursive function within a \nmixin module body. We provide severaJ examples of the usefulness of our ap\u00adproach. Beyond resolving circular \ndependencies in import graphs, we demonstrate how our approach provides similar functionality to Haskell \ntype classes [14] and CLOS generic functions [17]. This is done without extending the core ML type system \nor operational semantics. The former fact means tha~ with our approach, the core language programmer \nsees a familiar and widely-accepted type system. The latter fact means that our approach allows a straight\u00adforward \nefficient run-time implementation. Section 2 provides several examples to motivate mixin modules Section \n3 presents the formal type system for mixin modules; this type system is an extension of recent reformulations \nwhich have been proposed for SML modules [13, 18, 19]. Section 4 presents an operational semantics for \nmixin modules, in the form of a reduction system which maps mixin modules to ordinary SML modules. A \nsemantic soundness result verifies that the semantics does not fail due to type errors during reduction. \nSection 5 considers related and future work, and provides our conclusions. 2 Examples of Mixin Modules \nThe addition of mixin modules to the ML module system requires the introduction of a new kind of module \nconstruc~ in addition to structures and functors: structure l f = mixin (defml ) body (de@2) ini.t (dejm~) \nend The body of the mixin, (de@s2), is required to be a collection of datatype and recursive fimction \ndefinitions. These definitions may use type and value definitions from (defisl ), which we refer to as \nthe prelude of the mixin. The definitions in (dej%sl ) and (defns2) are both visible in (dejks3 ), which \nwe refer to as the initialization 262 structure Num = Rixin body datatype terra = CONST of int datatype \nvalue = NUM of int type env = string -+ value fun eval (CONST i) . = NUM i I evalt39 (e:env) = imnertme \nmd (* Num*) structure Func = nixin fun bind(x,v,e) = fny + if x=y then velse ey ~ody datatype term= VAR \nof string I ABS of string * term I APP of term * tern datatype value =+ CLOS of term * env withtype env \n= string + value fun eval (VAR x) (env:env) = env x I eval (f as ABS .) e = CLOS (f, e) I eval (APP (rator,rand)) \ne = let val CLOS (ABS(x,b),e ) = eval rator e in eval b (bind (x,eval rend e,e )) end I eval tm e = innertm \ne md (* Func *) Figure 1: Simple Interpreter Mixins secdonofthemixin. (defisl) and (de@s3) contain type, \nfunction and module definitions, and have the usual ML semantics. The interesting part of themixin isthemixin \nbody, (defns2). Thedefi\u00adnitions in this partare assumed to berecorsive. More importantly, these definitions \nare assumed to be open to further extension, by combining the mixinwithother mixins.When twomixinsare \ncom\u00adbined, recursive definitions with the same names in the mixin bod\u00adies are merged. Corresponding to \nmixin modules we have mixin signatures: signature S = mixsig (dec.kl) body (deckz) init (decZs3) end \nCorrespondingto the composition roles for mixin modules, our module calculus also hasacomposition ndeformixin \nsignatures. Our module calculus also has an equalily theory for signatures which allows the composition \nof mixin signatures to be trans\u00adformed into amixin signature of the aforesaid form. The closure of a \nmixin module produces a module with an ordinary SML sig\u00adnature. Like structures, mixins may occur inside \nfunctor bodies and may be argumentsto fonctors, so thereis no problem with tbeir interaction with the \nSML module system. An extension we do not consider is mtiinfinctors, mixins which may be combined and \nclosed into afunctor. We leave this for futore work. We now provide several examples to demonstrate the \nuse of mixins. 2.1 Simple interpreter Mixins Figure 1 provides a simple example of the use of mixins, \nfor pro\u00advidmgamodular implementation ofan interpreter. Theexampleis asimple version ofthatused by Steele \nto motivate pseudo-monads [29]. Theexample provides two building blocks, one fornumbers and the other \nfor functions. Both building blocks provide cases forthedefmition of theterm andvalue datatypes. The \ncalculus Figure 2: Binding of inner, and of recursive references to eval, in definition of eval in Num \nand Func of mixin modules includes an operator for combining mixins, @ In the composition Num @ Func, \nthe two definitions for the term datatype are combined into a single datatype definition. Similarly the \ntwo definitions for eval are combined. The pseudo-variable inner, available within a function in the \nbody of a mixin module, provides programmer control over how this combination is per\u00adformed. In the result \nof composing the definitions of eval, the resulting single eval function first checks for the CONST constric\u00adtor \n(using the Num implementation) and then delegates to the Func implementation to check for the other constructors. \nBecause of inner, composition @ is not commutative. The Func mixin demonstrates the important points \nof the ex\u00ad ample. Both the term datatype and the eval function contain recursive references. However \nthese recursive references are not necessarily to the current definitions of these datatypes. The fi\u00adnal \nfixed point of these recursive definitions may include defini\u00adtions provided by other mixins, and the \nrecursive references within the Func mixii refer to these final fixed points. The definition of inner, \non the other hand, is not a recursive reference to the defini\u00adtion of eval, but anon-recursive reference \nto further extensions of eval contributed by other mixins composed to the right of Func. Figore 2 illustrates \nthis graphically. An initial call to the eval function exported by the composition of these mixins begins \nby ex\u00adecuting the code defined in the Num mixin. Invocations of inner transfer control to the code defined \nin the Font mixin. At any point recursive references to eval transfer control back to the code de\u00adfined \nin Nun  2.2 Cyclic Import Dependencies The Standard ML module system prohibits cycles in the module \nimport dependency graph. Figore 3 provides a practical example of the difficulties this causes, from \nthe Standard ML of New Jersey compiler [1]. This example shows some of the import hierarchy for the modules \ncomprising the front end of the compiler, modified by the addition of a type explanation facility to \nthe type-checker [9]. The type explainer stores explanations in extra information fields in type variables. \nAs a result the Types module is now (through TypeExplain) a client of Absyn, which introduces a cycle \nin the import hierarchy. Our implementation of type explanation avoided this cycle by using unsafe type \ncasting! The only alternative was to merge the Types, Variable and Absyn modules into a sin\u00adgle mega-module~ \nsince the types and abstract syntax datatypes are mutually recursive (with type explanation). Even so, \nthis dis\u00adguised import cycle shows up in other parts of the hierarchy. For example, TypesUt il exports \noperations for creating new type vari\u00adables; these variables are initialized with null explanations, \nso the 263 are that within a strongly connected component in the import de\u00adpendency graph, the order \nof initialization is left undefined. This PrintUt il is clearly unacceptable in ML-like languages, where \nvariables are Types immutable and bound to clearly defined initial values. In fact cur\u00adrent implementations \nof Standard ML modules explicitly rely on TYP!U~/~;~\\, ~: Modules / I I tSoduleUtil Absyn , % /1 // I. \nBV. Type Explain pB\\/7/ I PPAbs yn Unify >1 TypeCheck Figure 3: Jmport Hierarchy of SML/NJ operations \nfor creating these null explanations must be placed in . TypesUt il rather than TypeExplain, where they \nreally belong (where the type explanation data structures are declared). One might be tempted to believe \nthat these problems can be solved using functors, which have received a great deal of attention in the \ndesign and implementation of SML modules. For example, we might try to make Types into a functor, parametrized \nover the type explanations which are recorded with type variables. This functor is then instantiated \nat the point where Abs ynis defined. LJn\u00adfortunately this approach only serves to illustrate further \nproblems with SML modules: functor Types F (T: TYPE-EXPLAIN) : TYPES = . . . functor TypeExplainF (A: \nABSYN) : TYPE-EXPLAIN = . . . functor AbsynF (T: TYPES) : A13SYN = . . . structure Absyn = AbsynF (Types) \n and TypeExplain = TypeExplainF (Absyn) and Types = TypesF (TypeExplain) Functoriziig the code only delays \nthe problems described earlier until the point at which the functors need to be instantiated. Again we \nface the problem that the abstract syntax and type datatypes are mutually recursive, so their definitions \ncannot span different modules. The obvious solution to these problems is to allow recursive structures \nand functors. Modula-3 [24] is an example of a language which allows cycles in module dependency graphs. \nThis has signif\u00adicant implications for the semantics of modules. Type definitions in modules may be mutually \nrecursive, so type-checking must check for equality of rational trees. Allowing rationrd trees, as in \nModula\u00ad3, would involve adding circular unification to the type inference algorithm. Although this can \nbe done, experience suggests that some type errors are no longer detected statically in the resulting \ntype system; furthermore the inferred types can be somewhat com\u00adplicated [27]. The semantics of module \ninitialization in Modula-3 the absence of circularities in the initialization of modules [2]. Essentially \nthe semantics of module composition in Standard ML (and ahnost all other module languages) is based on \nfunctor ap\u00adplication. This is so even if functors are not explicitly involved; in the SML/lYJ implementation \nof linking [2], an ordinary ML struc\u00adture is implemented as a function which is applied to a vector of \nimports at link-time, and produces a vector of exports. Mixin mod\u00adules introduce anew form of module \ncomposition, based on merg\u00ading the fixed points of recursive definitions. Within the body of the mixin, \nall value definitions are required to be k-abstractions; since evshsation is delayed, order-of-initialization \nambiguities are avoided. Outside of the body of the mixin, the semantics of value definitions are the \nsame as that for Standard ML. As noted, mixin composition is non-commutative because of the use of inner. \nThe initirdixation order for definitions outside of the mixin bodies in a mixin composition is to initidze \nthe child (rightmost) definitions first for reasons made clear in Sect. 4. The solution to the original \nproblem is then to declare Absyn, TypeExplain and Types as mixins. This allows for example the type explainer \nto be reused with different abstract syntaxes and type systems, by combining it with different Absyn \nand Types mixins. The types module specifies a datatype for object language types, and some useful functions \nover that representation which are re\u00adquired by clients. The module makes use of the undetermined type \nexplanation datatype by giving a null definition for this datatype, depending on a type explanation mixin \nto complete its definition. This requires a mild extension of core ML, allowing empty datatype definitions. \nA particular implementation of a compiler frontend with type explanation is then constructed by combining \nthese mix\u00adins and closing up the result (using the mixin operations provided in Sect. 3} structure Types \n= mixin body datatype explain; datatype, ty = . . . end structure TypeExplain = . . . structure Absyn \n= . . . structure Front = C1OS (Types@ TypeExplain@ Absyn) Consider if the frontend requires an operation \nfor copying abstract syntax trees. Within the Types mixin, we define a function copyTy which recurses \nover a t y data structure. At some point this function needs to copy explanations. To do this, c opyTy \nmakes a recursive call to c opyExplai~ where the latter is defined by: fun copyExplain (exp: explain) \n: explain = inner (exp) The Types mixin then relies on the type explanation mixin to com\u00adplete the definition \nof copyExplain (and the latter will in turn call cop yAbs yn, the implementation of c opyAbs yn in Abs \nyn will in turn call copyTy).  2.3 Parametric Overloading and Generic Functions The next example compares \nmixin modules with parametric over\u00adloading [16], as exemplified by Haskell type classes [14], and with \nCLOS generic functions [17]. Although parametric overloading is well-understood for single-parameter \noverloading, the implemen\u00adtation of type classes remains problematic, necessitating as they do call-site \nclosure construction at the uses of overloaded functions. TWe classes remain the main performance bottleneck \nin Haskell 264 structure Linear = mixin body datatype car = VECTOR of car list I MATRIX of car list \nlist fun (VECTOR VS) * (VECTOR VS ) = . . . I (MATRIXms) * (vEcTORVS) = . . . I v * (WCTOliVS) = VECTOR \n(map (fn v ~ v * v ) VS) I V*V =inner(v,v ) end (* Linear *) structure Number = mixin body datatype \ncar = REAL of real I INT of int fm (8JMLx) * (INTY) = . . . end (* Number *) Figure4:Numencal AlgebraMixins \n comuilers. Furthermore tvoe-checkitu zforsom eextensionsofua\u00ad . .. rameter overloading remains unclear. \nFigure 4 demonstrates a ~se of mixin modules for an application of multi-parameter paramet\u00adric overloading. \nThe Linear mixin implements linear algebra op\u00aderations for vectors and matrices, while the Number mixin \nirrtple\u00adments operators for integers and rerds. In the definition of multi\u00adplication in Linear, there \nis a case for vector-vector and matrix\u00advector multiplication, with the third clause handling scalar-vector \nmultiplication (where scalars are meant to be provided by another mixin). Duggan and Ophel [11] demonstrate \nthat in any type system for multi-parameter parametric overloading which is rich enough to support the \nexample k Fig. 4, type-checking is undecid\u00adable. Mixin modules avoid these decidability and performance \nprob\u00adlems. Type-checking at the core language level is exaetiy the same as in Standard ML. Furthermore \nour module calculus avoids all of the implementation problems associated with type classes. The def\u00adinitions \nof a mixin module cannot be used until the module is closed up to an ordinary ML module. M the point \nwhere this is done, the datatype and function definitions in the mixin body are closed to any further \nextensions, and code generation and optimization may proceed without needing to accommodate future extensions \nto the definitions. As a result mixin modules introduce no complications for runtime efficiency. Mixin \nmodules can also model other extensions of paramet\u00adric overloading. For example, a facility analogous \nto type con\u00adstructor classes [15] can be modelled using mixins with collection datatypes: structure List \n= mixin body datatype a carr = LIST of cZ list fun nap f (LIST XS) = ... Imapf xs =inner f xs end (* \nList *) structure Tree = mixin body datatype a carr = LEAF I NODEof a * a carr * u. carr fun map f LEAF \n= LEAF I map f (NODE(x,tl,t2)) . NODE(f x,map f tl, map f t2) Imap f xs =inner f xs end (* Tree *) Mixin \nmodules and Haskell type classes each have their rela\u00adtive advantages. There is an essential difference \nbetween the two: the latter assumes homogeneous collection data structures (for ex\u00adample, all elements \nof a vector are integers, or all are matrices, etc). The approach of mixirt modules allows each element \nof a vector to be in the union of the types which make up the carrier type, so the approach of mixins \nallows heterogeneous collections. Run-time dispatching is then based on the tags associated with the \ndata constructors. The approach of mixin modules appears prefer\u00adable for e.g. graphical user interface \napplications. For example, we can structure an extensible window library as a collection of mixin modules, \nwith an extensible window type; the basic window library may be extended by adding mixin modules defining \nnew window types. The advantage of the mixin modules approach maybe seen by considering e.g., window \nhierarchies, which can be represented as a list of subwindows associated with each window. A function \nwhich operates over the window hierarchy dispatches based on the data constructor tag associated with \neach window in a list of sub\u00adwindows. In this way mixin modules maybe seen as in some sense analogous \nto CLOS generic functions [17]; what is lacking from mixirt modules is any notion of subtyping or subclassing, \nalthough subclassing is available with an extension of mixin modules which we consider in Sect. 5. The \napproach of type classes cannot handle this example of an extensible window system, because it requires \nthat collection types be homogeneous: the immediate subwindows of a given window would all have to be \nof the same window type, which is clearly useless. On the other hand the approach of type classes is \nprefer\u00adable for applications involving homogeneous collection datatypes (e.g. vectors and matrices), \nsince for example in mapping an over\u00adloaded operation over a vector, dispatching is done once for the \nentire vector, rather than repeatedly for each element of the vector.  3 Typing Mixin Modules In this \nsection we provide the static semantics for mixin modules. Section 3.1 summarizes the syntax of an ML-like \nminilanguage, while Sect. 3.2 provides the type rules for mixins. The dynamic semantics are provided \nin the next section. 3.1 Syntax Figure 5 contains the grammar of the calculus used in the presenta\u00adtion \nof mixin semantics and typing. Namess, t, x denote module, type, and value components of modules respectively, \nwhile iden\u00adtifiers s~, tt, tt bind to modules, types and values. Identifiers ii consist of an external \nname i and an internal name i. Following the approaches of Leroy [18] and Harper and Lillibndge [13], \nonly the internal name of a bound identifier admits a-conversion; this pertnits module access by external \nname and composition of cor\u00adresponding fields in mixin bodies. This renaming is implicit in the modules \ncalculus (similarly to other calculi such as the l-calculus), but is necessary for some of the preconditions \nof the type rules which require internal names to be distinct in the concatenation of environments and \nsignatures. The two main classes of expression are modules Mt and expres\u00adsions E. A structure is a collection \nof definitions M, and a functor is a mapping fkom modules to modules. In addition we now have m~@s as \na new module construc~ denoted by Ml <(M)M2. This is abstract syntax for mixin module expressions of \nthe form mixin h41 body M init &#38;fz end used in the previous section. Ml and M2 denote the prelude \nand initialization parts, respectively, of the mixin. G(M) denotes the body, in which all (type and value) \ndefi\u00adnitions are mutually recursive. Module types are defined by the\\St 265 M, ::= struct M end I functor(structure \ns,:S~) kf~ I (JV&#38;:S~) P I P@) I ~<(~b)M t ~~ ~~t t clos(~~) St ::= sig S end I funsig (structures, \n:S1)S1 I S $(S) S .. s .. typett I t=~ Itis$ I valx,:z I structure s,:S, I SJ I e . ._ P . . Slslp.s \nJ &#38; ::= . ._ E .. 1 I x IP.XIP.c(E) I El E2 I Ayfi [ letDinE I caseEofRI l ... l R . ._P+E R .. . \n._  P .. x I p.c(q  Figure 5: Syntax dOm(r) ~ {xlvalx:z~r}u {tltypetcr}u {s I structures: S, ~ r} dom($) \ns {C 11$=1$1 . .. UC(~) ..@n}n} cOxts(r) E U{dOm($) I (t is $) c r} cons(s) S U{dom(@) I (t iS @) C S} \ncons(kf) U{dom($) ] (t iS $) GM} IM(BV(L% )) n IB(BV(SZ)) = {) * s2 5 1 s2 K cOns(Sl) n cOns(S~) ={} \n{ dOrn(rl ) n dom(r2) = {} 1 + 2 s 1 u 2 i cOns(rl ) n cOns(l_ 2) = {} { EEU(r,t) ~ (type t) e r and \n(t is 0 ), (t = T) @r Em(N) ~ {x Iy, EN} IB(ff) E {y Iy, C~} BV(&#38; type tt)= (BV(S) {t~}t,) U {tt} \nBV(&#38; vai A: c) z (BV(S) -{~}ti) U {XX} BV($ tis I+) s BV(S) BV($ t =Z) E BV(S) BV($ structure s,: \nS ) s (BV(S) -{sj}.,) U {s,} BV(~, type tt)E ...(sirnfiar) Figure 6: Definitions syntax class, and consist \nof signatures for structures, fonctor sig\u00adnatures for functors, and a new form of module type for mixins, \nS1~(S)S2. Definitions M in a module consist of structure defini\u00adtions, type definitions and value definitions. \nValue definitions are separated into a separate syntax class since they may also appear in a let-expression. \nValue definitions include a special fun form for defining mutually recursive functions; each body Et \nis assumed to be a k-abstraction. In type definitions, we separate the decla\u00adration of a new type name \n(type tt)from its definition as a type abbreviation (t = r) or a datatype (t is $), as explained in the \nnext subsection. Our calculus contains severrd simplifications for the sake of ex\u00adposition. Functor applications \nare only allowed to have the form p (pf) where p and p are paths; this enables us to give a reduc\u00adtion \nsemantics which preserves type identity, a crucial issue in the design of a module type system with generativity. \nThis sitrtplifi\u00adcation is inessential, and we may assume a source-level transla\u00adtion which converts from \na more liberal syntax to this one [18]. We only allow simple paths S.SI . . . Sn; in particular we do \nnot have fonctor applications in paths, as suggested by Leroy [19] for typ\u00ading higher-order functors. \nWe do this to simplify the presentation, since higher-order functors do not materially affect the semantics \nof mixin modules. We make the simplifying assumption that func\u00adtors are tist-order, as in Standard ML, \nalthough this is not strictly enforced in the type rules. This assumption is only necessary to simplify \nreasoning about type soundness in the next section, due to the fact that we work with a reduction semantics \nrather than the usual denotational semantics. The core language types are simple type names, projections \nof type components of structures, and ar\u00adrow types. This type system can be extended very straightforwardly \nto more sophisticated core language types (polymorphic types, pa\u00adrametrized types, constrained types, \netc) without contributing any\u00adthing to the exposition. Finally we assume that each functor takes a single \nmodule as its argumenq this simplifies the type rule for functor application. The body of a mixin may \nonly contain type and value defi\u00adnitions. We make this restriction because of our decision that it should \nalways be possible to transform a combination of mixins into an ordinary ML module. For simplicity we \nonly allow datatype definitions, although type abbreviations can also be added (with some restriction \non recursive references having to go through a datatype). Mb gives the syntax of mixin body definitions. \nAU value definitions, and all type definitions, are assumed to be mutually re\u00adcursive. As with function \ndefinitions, value definitions are required to be k-abstractions. This prevents circuhirities in initialization. \nFigure 6 provides several metafunctions which are used in the type rules in the next subsection. dorn(r) \ndenotes the internal names in the domain of r. dom(+) denotes the constructors in a datatype definition. \ncons extends thk to environments, signa\u00adtures and modules. BV(S) denotes the set of (internal name, external \nname) pairs exported by the sequence of declarations S, this op\u00aderation excludes names which are shadowed \nby declarations to the right in S (i.e., a variable xx is excluded if there is another dec\u00adlaration with \nexternal name x to the right of it in S). BV(M) is defined similarly for sequences of definitions. IN(N) \nreturns the internal names in a set of names, while EN(N) returns the external names. NEW(r, t ) is a \npredicate which checks that there is a declara\u00adtion for the name t,but that there is no type or datatype \nassertion for t. S1 @S2 denotes the concatenation of the declarations of S1 and S2; the side-condition \non this operation ensures that internal names in the declarations are renamed apart beforehand, and that \nthe dec\u00adlarations have no data constructors in common. Similarly rl + r2 denotes the concatenation of \ntwo type contexts, with the proviso that they have no internal names in ~~mmon in their domai&#38;, \n 3.2 IWlixinTyping Rules We base the module type system on the systems of manifest types proposed independently \nby Leroy [18] and by Harper and Lillib\u00adndge [13] (see also [26]). We base our formulation on the approach \nof manifest types because of its relative simplicity in modeling gen\u00aderativity. 266 In the approach \nof manifest types, a definition in a structure type t = c gives rise to the manifest type type t = 7 \nin the sig\u00adnature of the structure. A subtyping relation on type declarations includes the rule (type \nt = @ <: (type t).Extended to signatures, this rule allows type information to be forgotten in signatures, \nso that manifest types may be made opaque. Generativity is ob\u00adtained by requiring that every top-level \nmodule be given a unique stamp (or, be bound to a unique internal name ), and making generative types \nopaque and with their identity determined by their path beginning at a top-level structure. We modify \nthis approach in the following ways. We break a type declaration into two parts, the binding assertion \ntype tand the defining assertions t= T and tisQ. Each bound type name has no more than one defining assertion. \nIn the aforesaid approaches to module typing, only the fist form of defining assertion (for type abbreviations) \nis allowed. We introduce the second form of defining assertion for generative datatypes. With this approach, \ndatatypes with identical forms but different stamps are distin\u00adguished; datatypes occupy a middle ground \nbetween manifest and opaque types. The final modification is to type strengthening [18]: given a structure \nwith path p and signature St, type strengthening St/p allows the replacement of an opaque type type ttinStwith \nthe manifest type type tt = pt. Type strengthening in our module system is given by: (sig S end)/p sig \nS/p end (funsig (S)S,)/p funsig (S)St (sq(s)s)/p Sqs)s (structures, : S, ; S)/p structures~ : (St/p.s) \n; S/p (type tt; S)/p type tt;t= p.c S/p (t= q s)/p Sfp (t is @; s)/p S/p (valxx : q S)/p valxx : q S/p \n Type strengthening allows a datatype to be shared between mod\u00adules: structure S1 = struct datatype f \noo = bar; val x = bar end structure S2 = S1 : sig type foo = S1. foo; val x: foo end if true then S1 \nbar else S2 .x (* type checks *) Figore 7 provides the type rules for the modules language. The rules \nfor typing declarations of modules (R-MOD,R-MOD-MR), structures (R-MOD-SS) and functors (R-MOD-FS), as \nwell as the rule for fonctor application (R-MOD-PA) are as usual and self\u00ad explanatory. The rule for \nprojecting a modules from within a struc\u00ad ture (R-MOD-SP) performs a substitution to construct the signature \nofs. All occurrences of an internal name bound before the decla\u00ad ration ofs in the signature of the enclosing \nstructure are prefixed by the path to this structure and replaced with the corresponding external name. \nThis prefixing is also done for data constructors defined before the declaration ofs. This prefixing \nstep is neces\u00ad sary to properly remove the dependency ofs on its local context since (as mentioned) internal \nnames admit ~-conversion whereas external names are fixed. Finaliy Rule R-MOD-TS gives the type strengthening \nrule for the calculus, Rule R-MOD-MAT gives the type rule for explicit signature matching, while Rule \nR-MOD-SUB gives the type subsumption rule. We omit type rules for checking the well-formedness of signatures \n(r 1-St modtype) and for sub\u00ad gptig (r 1-St <: S: and r E S <: S ), since these are essentially standard \n[13, 18, 19]. r~kf,:st r+{structures: S,}l-M:S r 1-(structures, = M, ; M): (structure S$: .$; S) (R-MOD) \nstructures: St e r (R-MOD-MR) rks:sf r t-p: (sig S ; structure s,: S, ; S end) s ~ EM(BV(S )) e = {p.u/n \nI n. C BV(S )} U {p.C/c I C G cons(s )} r F P.S: 0(s,) (R-MOD-SP) rt-p:s (R-hiOD-Ts) rkp:slp r~kf:s (R-MOD-SS) \nr i-struct M end : sig S end r+{shud~s:s,}kkfl :s/ r 1-S1modtype r 1-functor(structure s,: S~)M, :funsig(structure \ns,: S,)Sj (R-MOD-Fs) r t-p: funsig(strueture s,: S~)S1 r~p :s; (R-MoD-PA) r F P(P ): {p /s}st rkkf, :s, \n(R-MOD-MAT) rt-pf,:sf):s, rkkft:s, r 1-$ modtype r F S/ <: S/ (R-h40D-suB)rhkff:s; rkkfp:sp r+vk~b:sb \n. r+ SPh%kkfbOk r+ Sp+Sb EMi:Si (R-MOD-MIX) r ~ kfp<(kfb)~i : SP$(sb)si r k Ml:s: qs;)s! r E kfz: sjqs;)sf \nS;am;=sp r+~ks~18s$=sb S;gjs; =s, r b kfI @&#38;fz: Sp<(.$b)si (R-h40D-c0h4P) r b kff : Sp $(s b)Si (R-MOD-CL) \nr ~ CIOS(&#38;ff): Sp @sb @si Figure 7: Modules Language Typing Rules Rule R-MOD-MIX in Figure 7 determines \nthe signature of an atomic mixin module rt-MP:SP r+~lkM~:s~ 17+?$+~lt-Mb Ok r+~+Tt-Mi :Si r 1-kfpc(kf~)kfj: \nsp$(sb)si (R-MOD-MIX) This rule tirst constructs the signature Sp of tie prelude section MP. The operation \n~ returns the set of all decl~ations in SP after removing external names from identifiers. These declarations \nare added to the context to perform a tirst pass over the body of the mixin in order to construct a signature \nsb for the body. The sec\u00adond paSS over the body adds ~ and T to the context. The latter is needed because \ndeclarations within the body are mutually re\u00adcursive. The second pass can therefore verify the correctness \nof types ascribed to mutually recursive functions. The final step is the derivation of a signature for \nthe initialization section after the context has been extended with the declarations of the prelude and \nbody sections. Type inference for the functions in the mixin body is 267 exactly the same as type inference \nfor mutually recursive functions in Hindley-Milner type inference. Some explicit type information is \nnecessary if polymorphic recursion is desired. The fist and second passes over the mixin body are performed \nusing the rules shown in Figure 8. Rule R-MFP-T checks a bind\u00ading assertion for a datatype, ensuring \nthat the external name intro\u00adduced for the type does not occur elsewhere in the mixin module body. This \nrequirement is appropriate since declarations within the body section are mutually recursive and, moreover, \nconstructs with the same external name are extended during composition. Rule R-MFP-I handles the defining \nassertion of a datatype, checking that a binding assertion has already been encountered and that no other \ndefining assertions exist for the datatype. The rule also ensures that data constructors are all new \nand distinct (checked as a side\u00adcondition of the + operation). Rule R-MFP-V checks a value dec\u00adlaration, \nrequiring that the value be a A-abstraction as explained in section 3.1. The remaining rules of Figure \n8 perform the second pass over the body section. Rule R-MSP-V can verify the type of a function since \nthe bindings for the identifiers of any recursive references made by the function exist in the context. \nBefore checking the function, the rule also adds an appropriate binding for the pseudo\u00advariable inner \nwhich, as demonstrated in Section 2, acts as a place\u00adholder of extensions supplied by other mixins. Rule \nR-MOD-COMP in Figure 7 gives the rule for typing the composition of two mixins Ml @Mz: r+ fvfl: s;qs~p~ \nr I-M: s;qsgp~ s;@s; =sp r+q~s;w~=sb S~@jS~=Si r ~kfl @M 2 : ~p $(~b)~i (R-MOD-COMP) The signatures for \nthe relude and initialization sections are com\u00ad ?1 posed as S; @S~ and Si @Si respectively, with ~ defined \nin Fig\u00ad ure 6. This operation is essentially sequential composition. Figure g contains the rules used \nby Rule R-MOD-COMPto com\u00ad pose the signatures of the bodies of the mixins being composed. The composition \nof two signatures S1 and S2 is denoted by S1 @S2. The rules in Figure 9 allow the composition of two \nsignatures S1 @S2 to be rewritten to a normal signature. At the heart of these rules is the R-CB -I rule \nwhich joins together the constructors from the definition of a datatype in two different mixin bodies. \nThe first premise in this rule ensures that there is no overlap in the constmc\u00adtors defined for that \ndatatype in the two different mixins. The addi\u00adtion of the combined datatype assertion to the contexg \nr+ {t is Q}, checks that there is no overlap between the constructors being de\u00adfined and the constructors \nalready defined in the context r (recall that r has already combined the constructor definitions to the \nleft of these datatype definitions in the mixin prelude and body). The R-CB-TI, R-cB-11 and R-CB-VI rules \nin Figure 9 allow a type constructor or program variable which is defined in one mixin but not the other, \nto be added to the signature of the mixin resulting from their composition. We refer to these rules as \nthe inflation rules. They essentially allow us to inflate the interface of a mixin with declarations \nthat are missing from its body, in order to allow us to compose that mixin with other mixins that provide \nthe missing declarations. In the composition Ml @&#38;fz of two mixins Ml andM2, we refer to Ml and M2 \nas the parent and child modules, respectively. In the sequential composition of the prelude and initialization \nparts of the mixins, the parent mixin s declarations follow the child mixin s declarations. Consider \nfor example: body val x = fn u:int +-w+l init val y=x end structure mz = mixin type t = bool body val \nx=fn w:int * 3 init val x = true end Composing-ml @mz and closing results in a structure: Struct type \nt = bool; type t = int val x=fn u:int * w~i val x>=true; val y=x end with signature sig type t = int \nval x: int + int val y: int + int end Note that some renaming of the child mixin s shadowed fields is \nre\u00adquired. This approach is taken to make the overriding of definitions in the prelude and initialization \npart consistent with composition of bodies: since the parent does not use the inner pseudo-variable in \nthe definition of x, the definition of x in the child is discarded. So in some sense the parentis in \ncontrol and determines what parts of the child mixin are visible in the final structure. Rule R-MOD-CL \ndetermines the signature of an ML structure resulting from closure of a mixin module. The signature is \nthe concatenation o , as defined in Figure 6, of the signatures for the three sections of the mixin module. \nt @lw(Bv(S)) r+ {typez} IF M: S (R-MFP-T) r 1+(type q; M): (type rt; S) mw(t,r +{tis$}l~kf:s r) (R-MFP-1) \nrlt-(tisqy M):(tis~S) f zrm(w(s)) r+{valf:~} It-1. f:s (R-MFP-V) r l!-(vdff =.?7; M): (valjf: T S) rlFMok \n(R-MSP-T) r N-(type t~; M) ok rlFMok (R-MsP-1)rlF(tis&#38;M)ok (f:q cr r+{inner:~}lFE: c rlFMok rk (valff \n=~, M) ok (R-MsP-v) Figure 8: Atomic Mixin Typing Rules (See Rule R-MOD-MIX in Figure 7) The SML module \nsystem includes a subtyping relation based on interface containment. As mentioned, approaches based on \nmani\u00adfest types augment this with the ability to forget manifest types. For mixins the subtype relation \nmust be made invariant in the top\u00adlevel definitions in all parts of the mixin: BV(Sj) = BV($) BV(S: ) \n= BV(S~) structure ml = mixin (R-kiIx-s) type t =int 268 ~+{typet}ESl@S2=S (R-cB-T) r F (type tt; SI \n) @(type tt; S2) = (type tt; S) t f EU(BV(S4) r+{typet]FS1g3S2=S (R-CB-TI) r 1-(type h; S1) 8 S2 = (type \nh; S) dom(h ) n dom(h) = {} r+{tisO1u Q2}FS18S2=S r~ (tis$l; Sl)c3(tis Q2; S2)=(tis$lu$2; S) (R-cB-1) \nIJEH(t,r) r+{tis Q}t-s1c9s2=S (R-cB-@ rt-(tis@ Sl)c3S2=(tis$; S) r+{vaif:z] t-S1c3S2=S rl-(val ~f:TS1) \n8(val~f :zS2)=(val.tf:% S) (R-cB-v) f $?En(Bv(s2)) 17+{val~:z} FS1c3S2=S (R-cB-vl) rF(val~r:l S1)t3S2=(valfi:TS) \n Figure 9: Mixin Composition Typing Rules (See Rule R-MOD- This restriction is necessary because of the \ncomposition rule for mixins: If interface containment is allowed on the definitions in a mixin, then \nthe meaning of the composition of the following is ambiguous: structure nq = roixin val x = true end \nstructure roz = snixin val x = 3 end structure sn3 = nixin val x = 4 end structure s = clOS (ml @ mz \nB m3) For example, without the restriction on sub@ing, the type ofs. x could be int or bo o1; if its \ntype were int, its value could be 3 or 4. For example, we could use subtyping as follows: w : mixsig \nval x: bool end <: mixsig end to forget the value of ml so that in the final composition the type of \nx would be int instead of bo 01 (using inflation in mixin com\u00ad position). The restriction in rule R-MIX-S \ndissrtllows this since the two signatures do not share the same collection of identifiers. Figure 10 \nprovides typing rules for the core language. We omit rules for expressions L?. These are standard and \ntheir inclusion would be straightforward. Mixin modules are intended as an ex\u00ad tension to the module \nsystem of ML, which leaves the type system and semantics of the core language unmodified. The key property \nthat is required for type-checking is the exis\u00ad tence of principal types for modules. Definition 3.1 \nGiven a context r. An expression E has a principal type ~ if r E E : T and for any otherd such tha~ r \n1-E: z , we haver 1-z <: ?. A module Mt has a principal signature St ifr ~ A4t: St, andfor any other \nS; such that r E A4t: S{, we have r E St <:$. Lemma 3.1 Assume all well-typed expressions have princ+al \ntypes. Then all well-formed modules have principal signatures. The statement of principality deliberately \nabstracts from the details of core language types. For the simple core language used here, r+{typet}kkf:s \n(R-c-T) r F (type t,;M):(type tt; S) IIEW(t, r) r+{tis$}EM:S (R-C-I) r~(tiS~; M):(tiS~; s) MEW(t,r) r+{t=7}FM:s \n(R-C-E) i-t(t=llw):(t=ws) rt-~:z 17+{vaIx:7}FM:S (R-C-V) r~ (valfi=E, M) :(val~:7; S) r ={valfl :q,..., \nvalfn:%} r+ PFEl:zi, i=l...rs r+r t-kf:s (R-c-R) rE(fu~;=~ll[...llj;=~n:M) : (val~~ :zI; .... valf; \n:G; S) Figure 10: Core Language TWing Rules some form of tvme uolvmomhism must be added tO the core \nlan\u00adguage to admitp rin~iphty, with the subtype relation <: extended to an instance relation over polymorphic \ntypes. Various other en\u00adrichments of the subtype relation with core language subtyping are possible [25, \n12].  4 Semantics of Mixin Modules In this section, we provide the operational semantics for our mmilanguage \nin terms of a rewrite rule system. The rules for nor\u00admalizing mixin expressions are given in Fig. 11. \nRule COMP nor\u00admalizes a composition of two mixins. This forms the sequential composition of the respective \npreludes and initialization parts, and the parallel composition of the mixirs bodies. This latter compo\u00adsition \nis defined by the COMP-T, COMP-I and COMP-V rules. If a field is present in one mixin body and missing \nin the other, then a default definition is inserted during composition (either an empty datatype definition \nor a function definition fn x ~ irmer x). We refer to this as the infZation rule for mixin composition; \nwe omit the obvious rules which perform this inflation. Rule CLOS closes up a mixin module to an ordinary \nstructure. The value definitions in the body of the mixin are composed into a collection of mutually \nrecursively defined functions. The CLOS rule must also close up occurrences of inner in these value defi\u00ad \nnitions. We use the special constant 1-to closeup these definitions; evaluation fails at run-time if \nJ-is ever evaluated. This is analogous to the situation in ML where pattern-matching may fail because \nthe clauses in a function definition do not cover all possible cases. The reduction semantics is based \non the definition of evaluation contexts given in Fig. 13, with the rules: MEt [~ + ME, [M ] if M--+M \nJ4Et [Mt] + MEt [M;] f Mf+. M/ ME[.E] + ME[E ] if E+E ME[~ + ME[M ] if M+M and so on for evaluation \ncontexts for expressions (omitted). These rules prevent evaluation within a functor body or a mixin, \nand en\u00adsure that evsduation of a structure body proceeds from left to right. The rules for ordinary expressions \nare essentially similar and famil\u00adiar [32], and are omitted. The reduction semantics also needs to ac\u00adcommodatestructure \nprojection and functor application. Rules PROJ\u00ad 269 (COMP) (J fjww )@(J $o@ f?)+ (J@ f;wf: CM @(J@:) \n(type tt;kfj) IXI(type tt;kf~) + type rt;kfj wkf~ (COMP-T) (COMP-1) (COMP-V) Mb=(type fitis~valfi~ =El; \n. ..val&#38;~= E.) M = (type fi ~is ~ fun&#38; = {k.l/inner}E1 1[ . . . [1fit = {h.l/inner}En) (CLOS) \nCIOS(MP CJlfb) Mi ) + struct Alp ;M,lfi end EE[L] + -L (BOT) (kx.El) E2 + {E2/x}E1 (BETA) let&#38;in \nE+E (LET-1 ) let valxx = El; Din E2 + {E1/x}(let D in .52) (LET-2) let D ; D in E + let 9(D ) in (3(E) \n(LET-3) D = funJ~=Ell[ ...ll~f=E~ where { f) D {(h?.letlY hEi)/flli=l,...,n} (case p.c(~) of . . . ~ \np.c(xJ+E 1 . ..)+ {~/~}E (CASE-1) (cAsE-2) (wseE of . . . 1 x+.E 1 . ..)+ {E/x}E kfv; structure s,= \nMVt;ME[S.p] ---+ MV; structure s,= MVt;ME[MVr (p, E)] (PROJ-V) W; structure s,= MVt;ME[,s.p (p)] ---+ \nW; structures, = MV,;ME[(MVt (P , s)) (p)] (pRoJ-F) Figure 11: Computation Rules v and PROJ-F denote \nthe operations of projecting a value and a is allowed since no type identities are lost by this projection. \nThe functor, respectively, out of the global context of bound structures. third case corresponds to a \nvrdue being projected out of a structure, Note that a structure is never copied by projection, because \nof the while the fourth and fifth cases correspond to a functor and a mixin fact that type generativity \nis basedon the syntactic identity of paths. being projected, respectively. Finally the last case corresponds \nto a These rules use the operation of applying a module to a path, de-functor application being ~-reduced. \nfined in Fig. 12. The formulation of subject reduction is complicated by abstrac\u00ad tion in the type system. \nCo-nside~ Module application Mt (p,p ), where &#38;ft is applied top, is writ\u00adten using an accumulating \nparameter p which records the path so structure s : sig type t val x:t end = far followed from the top-level \nenvironment to reach the module struct datatype t=foo val x=foo end &#38;ft. The first case in the definition \nin Fig. 12 corresponds tu pro\u00adjecting a module out of a structure; however this projection is only With \nthis declaration, s. x has type s. t. s. x reduces to the con\u00addefined if the operation terminates in \none of the following cases. structor s. f 00, but the datatype declaring s. f OOis hidden behind As a \nmodule is projected out of a slructure, the definitions it im\u00ad the opaque type s. t. We refer to s. f \noo as a hidden value, since ports from the bindings to the left of it in the structure rue prefixed itcannot \nbe given a type outside of the body of s. Nevertheless, by the path to the structure from the top-level \nenvironment. This is in reasoning about subject reduction for this example, we need to completely analogous \nto the R-MOD-SP rule in Figure 7. expose the type information in the definition oft. The second case \nin the definition in Figure 12 corresponds to To reason about subject reduction, we use a reformulation \nof the the case where a path is being projected out of a structure. This type system presented in the \nprevious section, with the following 270 (structM1 ;structures, = MV, ;M2 end)(s.p ,p) = e(Mvt)(p ,p.s) \nwhere 8 = {p.n/nl n. c BV(kfl)}U{p.c/c I c e cons(Ml)} and s @ EN(BV(~2)) P (P lP ) = P.P (structM1;valxx \n= W ;kf2 end)(x,p) = 9(EV) where 8 = {p.n/rz [ nn c BV(kfl)} U {p.c/c I c c cons(M1)} and x @EN(BV(M2)) \n(functor (structure s,: S,)Mt)(s,p) = functor (structures, : St)kft J &#38; <(ll f~)kft (MpS(Mb)Mi )(S,P) \n= (functor (strnctures, : St)A4,)(p) = {P/s}~t Figure 12: Applying Modules to Paths To simplify the \nexposition of type soundness, we make the simpli\u00adfying assumption that functors are fist-order, as in \nStandard ML. [1 I struct ME end It is then trivial to define a syntactic transformation which removes \nexplicit signature matching from programs. This transformation is ME,8J4( I W, @M.Ef I CIOS(ME1) defined \nas the homomorphic extension of the following: [1 \\ MV; val~ =EEkl [(M, : St)] = [M,] MV; structures, \n= MEt ;M Let ~ EM M: S denote the derivability of type judgments in this functor(SOM, I M $,(~b) M I \nstruct MV end restricted (or minima~ type system. Then we have Lemma 4.1 l~r E M: S then r RM [~ : S \nfor some S such that r+sf~:s. Theorem 1 (Subject Reduction) Given r and M not containing signature matching. \nGiven r l-~ M: S and M + M . Then r FM Ml: S for some S such that r 1-S <: S. Fig. 13 also defines value \nexpressions. Afaulty term is an expres\u00adsion containing an irreducible subexpression which is not a value. \nLemma 4.2 Given r and M not containing signature matching. Given T FM M: S, then M contains no faulty \nterms. Figure 13: Evaluation Context Finally soundness follows from the fact that any reduction sequence \nin the original type system can be simulated by a corresponding changes: reduction sequence in the minimal \ntype system: 1. We remove the construct for allowing explicit type declara-Theorem 2 (Soundness) Given \nr and M not containing signaturetions for modules, (Mr : St ), and we omit the corresponding matching. \nIf r E M : S then evaluation of M does not go wrong, signature matching rule Rule R-MOD-MAT in Figure \n7. i.e.,there does not exist a reduction sequence 2. We fold the type subsumption rule, Rule R-MOD-SUB, \ninto the rule for functor application. Rule R-MOD-PA in Figure 7. M+... +Mi +... With the omission of \nexplicit signature matching, this is the only place where subsumption is required (even with the ad-of \nreductions starting from M such that some Mi contains a faulty dition of mixin modules). term. 271 5 \nRelated Work and Conclusions Mixin modules are clearly influenced by work in implementa\u00adtion inheritance, \nand in particular mixin-based inheritance, in the object-oriented languages community. As already discussed, \nmixin modules bear some relationship to CLOS generic functions, but with data constmctor tags replacing \nthe type tags that are used for dispatching in CLOS. The irmer construct bears some relationship to call \n-next -methodic CLOS, which allows a method in a class to invoke the instance of that method in the next \nclass in the inheri\u00adtance chain. Mixin modules are also related to BETA patterns [21], and indeed our \ninner construct is deliberately named to suggest the analogy with the BETA construct. Like BETA, implementa\u00adtion \ninheritance with mixin modules is based on incremental ex\u00adtensions only, and does not allow the overriding \nof existing defini\u00adtions (Smalkalk-style method overrides). Bracha and Cook [3] pro\u00adpose mixin classes \nas a construct for object-oriented languages. Bracha and Lindstrom [4] extend the work of Bracha and \nCook by proposing modules (object generators) as a more general notion than classes, from which classes \nand mixins maybe derived using their suite of inheritance operations. Mitchell, Meldal and Madhav [22] \nconsider the addition of object-oriented constructs to the ML module language. Their approach amounts \nto adding F-bounded quantification and implementation inheritance [7, 23] to the ML module language, \nand implementing objects as modules rather than as closures. AH of this work is based on providing some \nnotion of implementation inheritance for object-oriented languages. We are the first to suggest a form \nof implementation inheritance for a functional language, based on adding inheritance mechanisms to the \nmodule system. Burstall [5] proposed a functional language NPL (a predecessor h HOPE [6]) with extensible \ndatatypes and function definitions, in which constructors could be incrementally added to the definition \nof a datatype, and clauses could be incre\u00admentally added to the definitions of functions that operated \non that datatype. However unlike our approach he did not base his exten\u00adsions on the module system, and \nhis approach to providing exten\u00adsions is less general. Beyond the fact that our approach solves some \nopen problems with the SML module system, our commitment to providing inheritance in the module system \nhas important benefits for the implementation of mixins. One of the reasons for the in\u00adcreasing acceptance \nof functional languages has been the very ef\u00adficient implementation of pattern-matching [30]. This efficiency \nin turn relies on the fact that all of the constructors for a datatype are known when compiling the clauses \nof a function definition. This is manifested in the SML/NJ compiler, for example, where the imple\u00admentation \nof pattern-matching in exception handlers is somewhat less efficient than that for the ordinary case \nconstmct. By postpon\u00ading optimization and code generation for mixin modules until they are closed up \nto ordinary ML structures, we may similarly bene\u00adfit from efficient compilation while providing extensible \ndatatypes. We are currently investigating the design of a suitable intermediate form into which to compile \nmixin modules, in order to support this implementation strategy. The other implementation issue with \nmixin modules is the in\u00adferring of properties of extensible datatypes defined in mixins. Given a datatype \ndefinition in one mixm, how are we to infer whether it admits equality, since another mixin may declare \na con\u00adstructor for that datatype with a functional domain? Similar issues arise with other datatype attributes, \nfor example, variance proper\u00adties of datatypes if we introduce subtyping [8]. One possible ap\u00adproach \nhere is to require that these attributes be declared by the programmer. Analogous issues arise with datatype \nproperties that are only used internally in the compiler, in the representation anal\u00adysis of datatypes. \nIt appears plausible that work on cross-module optimization may be applicable in this situation. In a \nlarge sense we have only told half of the story of mixin modules. We have only reported on vertical extensions, \nadding cases to the definitions of datatypes and functions. However there is also a notion of horizontal \nextensions for mixin modules, which also allows the domain of a data constructor to be extended dur\u00ading \nmixin composition [28]. This provides us with the form of subclassing provided in CLOS that is missing \nfrom this account. Using this mechanism, for example, we can define modular inter\u00adpreter building blocks \nin the style of Liang et al [20]. Furthermore mixin modules can be extended to provide a class construct \nfor ML extended with objects [8]. In contrast to simply adding classes to ML, this approach provides \nimplementation inheritance for all of ML, not just some object-oriented fragment of it. We intend to \nreport on this in a subsequentpaper. Acknowledgements: Thanks to Bob Harper and David MacQueen for stimulating \ndiscussions.  References [1] Andrew Appel and David MacQueen. Standard ML of New Jersey. In Proceedings \nof the Symposium on Programming Language Iinplementation and Logic Programming, volume 528 of Lecture \nNotes in Computer Science, pages 1-13. Springer-Verlag, 1991. [2] Andrew Appel and David MacQueen. Separate \ncompilation for Standard ML. In Proceedings of ACM SIGPLAN Confer\u00adence on ProgrammingLanguageD esign \nand Implementation, pages 13 23. ACM Press, June 1994. SIGPLAN Notices VOL ume 30, number 6. [3] Gilad \nBracha and William Cook. Mixin-based inheritance. In Proceedings of ACM Symposium on Object-Oriented \nPro\u00adgramming: Systems, Languages and Applications, pages 303-311. ACM Press, October 1990. SIGPLANNotices, \nvol\u00adume 25, number 10. [4] Gilad Bracha and Gary Lindstrom. Modularity meets inheri\u00adtance. In International \nConference on Computer Languages, pages 282 290. IEEE, 1992. [5] R. M. Burstall. Design considerations \nfor a functional pro\u00adgramming language. In Infotech State of the Art Conference, Copenhagen, Denmark, \n1977. Infotech. [6] Rod M. Burstall, David B. MacQueen, and Donald T. San\u00adnella. HOPE: An experimental \napplicative language. In Cors\u00adferenceRecord of the 1980LISP Conference, pages 136-143, 1980. [7] William \nCook, Walter Hill, and Peter Canning. Inheritance is not subtyping. In Proceedings of ACM Symposium on \nPrinci\u00adples of Programming Languages, pages 125 135, 1990. [8] Dominic Duggan. Polymorphic methods with \nself types for ML-like languages. Technical Report CS-95-03, University of Waterloo, Department of Computer \nScience, 1995. [9] Dominic Duggan and Frederick Bent. Explaining type infer\u00adence. Technicrd Report CS-94-14, \nUniversity of Waterloo, Waterloo, Ontario, Canada, 1994. To appear in Science of Computer Programing. \n [10] Dominic Duggan and John Ophel. Kinded parametric over\u00adloading. Technical Report CS-94-35, University \nof Waterloo, Department of Computer Science, September 1994. 272 [11] Dominic Duggan and John Ophel. \nOn type-checking multi\u00adparameter type classes. To be submitted, 1995. [12] Jonathan Eifrig, Scott Smith, \nand V. Trifonov. Sound poly\u00admorphic type inference for objects. In Proceedings of ACM svm~osium on Obiect-OrientedProQraminQ: \nSvstems. Lan\u00adg~a~es and Appli~ations. ACM Pre&#38;, Octob&#38; 1~95. [13] Robert Harper and Mark Lillibridge. \nA type-theoretic ap\u00adproach to higher-order modules with sharing. In Proceed\u00adings of ACM Symposium on \nPrinciples of Programming Lan\u00adguages, pages 123 137, Portland, Oregon, January 1994. ACM Press. [14] \nPatd Hudak, Simon Peyton-Jones, Philip Wadler, Brian Boutel, Jon Fairbairn, Joseph Fasel, Maria M. Guzman, \nKevin Hammond, John Hughes, Thomas Johnsson, Richard Kieburtz, Rishiyur Nikhil, Will Par@in, and John \nPeterson. Report on the programming language Haskell, a non-strict purely functional language, Version \n1.2. ACM SIGPLANIVo\u00adtices, 27(5), 1992. [15] Mark Jones. A system of constructor classes: Overloading \nand implicit higher-order polymorphism. In Proceedings of ACM Symposium on Functional Programming and \nComputer Architecture, pages 1 10. Springer-Verlag, 1993. Lecture Notes in Computer Science 594. [16] \nStefan Kaes. Parametric overloading in polymorphic pro\u00adgramming languages. In European Symposium on Program\u00adming, \npages 13 1 144. Springer-Verlag, 1988. Lecture Notes in Computer Science 300. [17] S. C. Keene. Object \nOriented Programming in CommonLisp: A Programming Guide in CLOS. Addison-Wesley, 1989. [18] Xavier Leroy. \nManifest types, modules, and separate compi\u00adlation. In Proceedings of ACM Symposium on Principles of \nPrograming Languages, pages 109 122, Portland, Oregon, January 1994. acmp. [19] Xavier Leroy. Applicative \nfunctors and fully transparent higher-order modules. In Proceedings of ACM Symposium on Principles of \nPrograming Languages, pages 154-163, San Francisco, California, January 1995. ACM Press. [20] Sheng Liang, \nPaul Hudak, and Mark Jones. Monad trans\u00adformers and modular interpreters. In Proceedings of ACM Symposium \non Principles of Programming Languages, pages 333 343, San Francisco, January 1995. ACM Press. [21] Ole \nLehrmann Madsen, Birger Moller-Pedersen, and Kristen Nygaard. Object-Oriented Programing in the BEZA \nPro\u00adgraming Language. ACM Press, 1993. [22] John Mitchell, Sigurd Meldal, and Neel Madhav. An exten\u00adsion \nof Standard ML with subtyping and inheritance. In Pro\u00adceedings of ACM Symposium on Principles of Programming \nLanguages, pages 270-278. ACM Press, January 1991. [23] John C. Mitchell. Toward a typed foundation for \nmethod spe\u00adcialization and inheritance. In Proceedings of ACM Sympo\u00adsium on Principles of Programing \nLanguages, pages 109 124, 1990. [24] Greg Nelson. Systems Programing in Modula-3. Prentice-Hall Series \nin Innovative Technology. Prentice-Hall, 1991. [25] Martin Odersky and Konstantin Laufer. Putting type \nannota\u00adtions to work. In Proceedings of ACM Symposium on Princi\u00adples of Programing Languages, pages 54-67, \nSt. Petersburg Beach, Florida, January 1996. ACM Press. [26] John Ophel. A polymorphic language with \nfirst-class modules. Australian Computer Science Communications, 17(1):422-430, February 1995. [27] Didier \nR6my. Programming objects with ML-ART: An exten\u00adsion to ml with abstract and record types. In Masami \nHagiya and John C. Mitchell, editors, International Symposium on Theoretical Aspects of Computer Software, \npages 321-346, Sendai, Japan, April 1994. Springer-Verlag. [28] Constrmtinos Sourelis. Mixin modules. \nMaster s thesis, Uni\u00adversity of Waterloo, 1995. [29] Guy Steele. Building interpreters by composing monads. \nIn Proceedings of ACM Symposium on Principles of Program\u00adming Languages, pages 472-492. ACM Press, 1994. \n[30] Philip Wadler. Efficient compilation of pattern-matching. pages 78 103. Prentice-Hall, 1987. Chapter \ncontributed to The Implementation of Functional Programming Languages, Simon Peyton-Jones. [31] Philip \nWadler and Stephen Blott. How to make ad-hoc poly\u00admorphism less ad-hoc. In Proceedings of ACM Symposium \non Principles of Programming Languages, pages 60-76. ACM Press, 1989. [32] Andrew Wright and Matthias \nFelleisen. A syntactic approach to type soundness. Technical Report TR91-160, Rice Univer\u00adsity, April \n1991 273 \n\t\t\t", "proc_id": "232627", "abstract": "Mixin modules are proposed as a new construct for module languages, allowing recursive definitions to span module boundaries. Mixin modules are proposed specifically for the Standard ML language. Several applications are described, including the resolution of cycles in module import dependency graphs, as well as functionality related to Haskell type classes and CLOS generic functions, though without any complications to the core language semantics. Mixin modules require no changes to the core ML type system, and only a very minor change to its run-time semantics. A type system and reduction semantics are provided, and the former is verified to be sound relative to the latter.", "authors": [{"name": "Dominic Duggan", "author_profile_id": "81100303097", "affiliation": "Department of Computer Science, University of Waterloo, Waterloo, Ontario, Canada N2L 3G1", "person_id": "P67811", "email_address": "", "orcid_id": ""}, {"name": "Constantinos Sourelis", "author_profile_id": "81100219462", "affiliation": "", "person_id": "P50021", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/232627.232654", "year": "1996", "article_id": "232654", "conference": "ICFP", "title": "Mixin modules", "url": "http://dl.acm.org/citation.cfm?id=232654"}