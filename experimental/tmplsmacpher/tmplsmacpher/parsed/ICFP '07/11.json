{"article_publication_date": "10-01-2007", "fulltext": "\n McErlang: A Model Checker for a Distributed Functional Programming Language Lars-\u00b0Ake Fredlund * Facultad \nde Inform\u00b4atica, Universidad Polit\u00b4ecnica de Madrid, Spain fred@babel.ls...upm.es Abstract We present \na model checker for verifying distributed programs written in the Erlang programming language. Providing \na model checker for Erlang is especially rewarding since the language is by now being seen as a very \ncapable platform for developing in\u00addustrial strength distributed applications with excellent failure \ntol\u00aderance characteristics. In contrast to most other Erlang veri.ca\u00adtion attempts, we provide support \nfor a very substantial part of the language. The model checker has full Erlang data type sup\u00adport, support \nfor general process communication, node semantics (inter-process behave subtly different from intra-process \ncommuni\u00adcation), fault detection and fault tolerance through process linking, and can verify programs \nwritten using the OTP Erlang component library (used by most modern Erlang programs). As the model checking \ntool is itself implemented in Erlang we bene.t from the advantages that a (dynamically typed) functional \nprogramming language offers: easy prototyping and experimenta\u00adtion with new veri.cation algorithms, rich \nexecutable models that use complex data structures directly programmed in Erlang, the ability to treat \nexecutable models interchangeably as programs (to be executed directly by the Erlang interpreter) and \ndata, and not least the possibility to cleanly structure and to cleanly combine var\u00adious veri.cation \nsub-tasks. In the paper we discuss the design of the tool and provide early indications on its performance. \nCategories and Subject Descriptors D.2.4 [Software Engineer\u00ading]: Software/Program Veri.cation Model \nchecking General Terms Veri.cation  1. Introduction To model check a modern distributed functional programming \nlan\u00adguage is by no means a small task and there are many design deci\u00adsions that have to be taken. One \nof the largest decisions is to choose between: (1) translating the program into some existing formalism \nand use (or possibly extend) existing model checking tools for this * The author was supported by a Ram\u00b4on \ny Cajal grant from the Spanish Ministerio de Educaci\u00b4on y Ciencia, and the DESAFIOS (TIN2006-15660\u00adC02-02) \nand PROMESAS (S-0505/TIC/0407) projects Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. ICFP 07, October 1 3, 2007, Freiburg, Germany. Copyright c . 2007 ACM \n978-1-59593-815-2/07/0010. . . $5.00 Hans Svensson Computer Science and Engineering, Chalmers University \nof Technology, Sweden hanssv@cs.chalmers.se formalism, or (2) implement the veri.cation algorithms directly \nfor the language to be model checked. (In fact there is also a third al\u00adternative, namely to translate \ninto a formalism which has been con\u00adstructed for this particular task and implement tools for this formal\u00adism. \nThis approach is brie.y discussed in section 7.) There are advantages (as well as weaknesses) with both \nap\u00adproaches; Existing tools are probably optimized, and thus ef.cient to use. Translating into an existing \nformalism means that every\u00adthing in the language has to be modeled, including data. Finding a suitable \nformalism might not be easy. Implementing model check\u00ading algorithms ef.ciently is hard and time consuming. \nHaving the model checker in the language itself means that the pure functional part can be handled in \na simple and ef.cient way. One existing model checking tool for Erlang is the etomcrl tool set (Arts \net al. 2004b), which consists of a translator from Erlang to \u00b5CRL, a state space generator for \u00b5CRL speci.cations, \nand the CADP state space analysis tools. Thus it is an example of the .rst alternative above, however \nearly in the development of etomcrl its principal authors (Thomas Arts and Clara Benac Earle) were thinking \nof an implementation in Erlang itself. In the end the Erlang route was rejected because it was thought \nthat it would be more ef.cient to reuse existing tools. In this paper we describe the development and \nimplementation of the McErlang model checker which follows the second imple\u00admentation alternative above. \nThe development of McErlang was started for several reasons. One reason was the curiosity to .nd out \njust how well an implementation in Erlang would work in practice. The main reason however was the wish \nto model check distributed as well as fault tolerant Erlang programs. (Both distribution and fault tolerance \nare missing in the etomcrl tool set). It was deemed toohard toextend the etomcrl tool set with the concepts \nof distri\u00adbution and fault tolerance. The importance of supporting the dis\u00adtributed parts of Erlang is \nillustrated by Claessen and Svensson (2005). In their paper they show that it easy to overlook errors \ndue to the loose synchronisation between processes in the distributed setting. They also demonstrate \nthe presence of such errors in an open source Erlang implementation. One signi.cant advantage that the \nimplementation in Erlang it\u00adself brings is that we can model check a larger fragment of the lan\u00adguage \nthan is normally achievable. There is for instance no separate step to compile the data sub-language \nof the source speci.cation language to the often restrictive data language available in a model checker. \nInstead supporting the (purely functional) data part of Er\u00adlang is completely trivial; we can simply \nreuse the existing Erlang run-time system unchanged. It is in our opinion crucial to support a large \nfragment of Erlang in order to achieve some measure of acceptance of our tool by Erlang programmers. \nThe Erlang language contains many features not found in most normal programming languages (unless add-on \nlibraries are used): dynamic types (i.e., no static type system), concurrency via a process concept, \ninter-process communication using only asyn\u00adchronous message passing, distribution by mapping processes \nonto (remote) processing nodes, fault tolerance via a failure detector mechanism, and a standardized \nset of high-level components built on top of this foundation. As Erlang programmers frequently make use \nof all these features we think it is vital that the veri.cation tool supports them too. Nevertheless, \nby choosing to implement a model checker in a functional programming language we risk paying a price \nwith re\u00adgards to loss of execution performance and increased storage re\u00adquirements; there is clearly \na trade-off between easy experimen\u00adtation and expressive power on one hand, and implementation ef.\u00adciency \non the other. With the McErlang tool we want to explore this trade-off, and we hope that by not having \nto simulate the functional parts of Erlang this model checking approach is rather ef.cient. Since we \nhad access to a prototype implementation of the dis\u00adtributed Erlang semantics in Haskell, we also did \nsome experiments with implementing a model checker for Erlang in Haskell. We did not implement a full \nmodel checker, but the experiments gave us some insight in the strengths and weaknesses with such an \nap\u00adproach. In section 7 we brie.y discuss these results to get a different perspective on the McErlang \nimplementation. One of the design goals with McErlang was that it should be easy to use. All that is \nneeded to use McErlang is a program to test, a speci.cation of the environmental constraints and a property \nto check. All three are written entirely in Erlang. The environmental constraints describe how the program \nis executed in the implemen\u00adtation of the run-time system provided by McErlang. The property is given \nin the form of a monitor/automaton that is executed in par\u00adallel with the program, checking for errors \nalong the execution path. This work .ow is discussed further in section 4 and section 5 and is illustrated \nin Fig. 7. Contributions The main contribution of the paper is a presen\u00adtation of the tool McErlang. \nThe paper is not so much about the theory behind model checking or the semantics of Erlang, instead we \nfocus on design choices, implementation decisions, adaptabil\u00adity and usability. McErlang is a model checker \nfor Erlang imple\u00admented in Erlang, it supports a large subset of the Erlang program\u00adming language. In \nparticular it supports all of the distributed and fault-tolerant parts of Erlang. This is especially \nimportant since dis\u00adtributed and fault-tolerant implementations are known to be error prone and hard \nto test and debug. McErlang is also easy to use and should be accessible to an ordinary Erlang programmer. \nFi\u00adnally McErlang is designed in a very modular way and can easily be adapted to support other target \nlanguages. Paper organization The next section contains an introduction to the most important features \nof the Erlang programming language and section 3 contains a description of the most prominent fea\u00adtures \nof the Erlang semantics. In section 4 the parametric design of McErlang is described and section 5 presents \nthe model checker itself, i.e., essentially an on-the-.y model checker which executes B\u00a8uchi automatons \n(coded in Erlang) in parallel with the Erlang pro\u00adgram under study. In section 6 we show some results \nand examples of using the model checker. Section 7 discuss a number of design choices in more detail, \nand section 8 summarises related work. Fi\u00adnally section 9 draws conclusions, and outline future research \nwork. Download McErlang McErlang can be downloaded at http://babel.ls.fi.upm.es/~fred/McErlang/. 2. \nThe Erlang Programming Language Erlang is a programming language developed at Ericsson for imple\u00admenting \ntelecommunication systems (Armstrong et al. 1996; Arm\u00adstrong 2007). It provides a functional sub-language, \nenriched with constructs for dealing with side effects such as process creation and inter process communication \nvia message passing. Moreover Erlang has support for writing distributed programs; processes can be distributed \nover physically separated processing nodes. Today several commercially available products developed by \nEricsson and other companies are at least partly programmed in Erlang, an example is the AXD 301 ATM \nswitch (Blau and Rooth 1998). The software of such products is typically organized into many, relatively \nsmall, source modules, which at run-time execute as a dynamically varying number of processes operating \nin parallel and communicating through asynchronous message passing. The highly concurrent and dynamic \nnature of such software makes it particularly hard to debug and test. Erlang programmers, of course, \nmostly work with ready-made higher-level language components rather than the basic language. In practice \nprogrammers predominantly use the OTP component li\u00adbrary (Torstendahl 1997), which offers a number of \nuseful software components such as: a generic server component for client-server communication, a .nite-state \nmachine component, and a supervisor component that restarts failed processes. Our approach to model checking \nErlang programs can verify software that is built using both the core message passing language and with \nthese high level components. A key feature of the systems for which Erlang was primarily created is fault-tolerance. \nErlang implements fault-tolerance in a simple way. Links between two processes A and B can be set up \nso that process B is eventually noti.ed of the termination of process A and vice versa (using the normal \nmessage-passing machinery). The default behavior of a process that is informed of the abnormal termination \nof a linked process is to terminate abnormally itself. Al\u00adternatively the linked process can specify \nthat it wishes to receive a message with a noti.cation that its linked process has terminated. This process \nlinking feature can be used to build hierarchical pro\u00adcess structures where some processes are supervising \nother pro\u00adcesses, and can take corrective action (e.g., restarting them) if they terminate abnormally. \nIn order to create such fault-handling struc\u00adtures, Erlang/OTP provides the supervisor behavior. Another \nkey feature of Erlang systems, which is particularly useful for 24/7 systems, is the mechanism for hot \ncode replacement. In short it is possible to phase out old code and replace it with new code, having \nboth old and new code running simultaneously. This feature enables bugs to be corrected and features \nto be added without stopping the system. In summary, the Erlang/OTP programming environment is a comparatively \nrich programming environment for programming systems composed of (possibly) distributed processes that \ncom\u00admunicate by message passing. Fault tolerance is implemented by means of failure detectors (the linking \nmechanism), a standard mechanism in the distributed algorithms community. Moreover there is a process \nfairness notion, something which often makes it unnecessary to explicitly specify fairness in correctness \nproperties. Moreover the language provides explicit control of distribution, and a clean model of distribution \nsemantics. For distributed processes (processes executing on separate nodes) the communication guar\u00adantees \nare far weaker than for processes co-existing on the same processor node. This gives, in a clean way, \nconsiderable power with regards to checking a program under different environmental con\u00adstraints (simply \nchanging the mapping of processes to nodes), but on the other hand there is a requirement on implementing \nthe run\u00adtime system with different guarantees for inter-node and intra-node communication. Multi-core \nprogramming The concurrency oriented nature (Arm\u00adstrong 2003) and the (almost) transparent distribution \nmakes Erlang a really good candidate for writing ef.cient distributed software. With the latest version \nof the Erlang Run-time System (Erlang 5.5/OTP R11B) this is taken even further, as it includes built-in \nsupport for SMP (Symmetric Multi Processing). SMP is today sup\u00adported by most modern operating systems \nand becomes more and more important with the introduction of dual/quad/...processors, multi-core systems \nand hyper-threading technology. The SMP sup\u00adport in Erlang is transparent since most problems occurring \nin multi-threaded programs are solved by the Erlang VM. The SMP version of the VM can have many process \nschedulers running in\u00adside each OS thread, the default is to have as many schedulers as there are processors \n(or processor cores) in the system. Since the SMP support is completely transparent we get for free an \nef.cient multi-core implementation if we have a correct distributed imple\u00admentation. This shows another \nbene.t of having a working model checker for distributed Erlang. 3. Semantics Erlang is at the same \ntime both a simple language, having at its core a fairly uncomplicated dynamically typed functional language \nwith eager evaluation, and a fairly complicated one. The complexity is due to the addition of language \nlayers proving support for concur\u00adrency (processes and message passing), and distribution (process\u00ading \nnodes that encapsulate processes) and fairly elaborate inter\u00adprocess fault detection and fault handling \nmechanisms (via process links and process monitors). The intuitive picture of the distributed semantics \nis rather sim\u00adple, the guarantees given are simply: communication between a pair of processes is assumed \nto be ordered as described by Arm\u00adstrong (2003). The semantics of links and monitors are also fairly \neasy to get an intuitive understanding of. However, the full seman\u00adtics for distributed Erlang is indeed \ncomplex. It consists of some rather long and technical transition rules. Especially the corner cases, \nsuch as using the link mechanism on a dead process, makes a presentation somewhat lengthy and less intuitive \nthan one could wish. Nevertheless, our formal description of the semantics is lay\u00adered in three layers \nin a very clear way. Functional Semantics -consists of the pure functional part of Erlang (function \nevaluation, pattern matching, etc). It is dynam\u00adically typed and fairly straight forward.  Process Semantics \n-is above the functional semantics, and consists of process evaluation rules (sending and receiving mes\u00adsages \nand links, starting/terminating processes, and silent com\u00adputation steps) as well as process communication \nrules (process interleaving and process communication). This is all for the sin\u00adgle node case, that is \nall the involved processes are executing in the same run-time system.  Node Semantics -is placed on \ntop of the process semantics, and adds the concepts of nodes and full distribution to the semantics. \nSimilarly to the process semantics it consists of node evaluation rules and node communication rules. \n The functional semantics and the process semantics are de\u00adscribed in detail in Fredlund (2001) and \nthe node semantics is in\u00adtroduced in Claessen and Svensson (2005). The layering described here is, as \nwe see later, clearly mirrored in the implementation of the model checker. Since it is not feasible to \ncover all aspects of the semantics in this paper, we just highlight a few important details. With the \nfollowing example we show the importance of having the node semantics layer and that our intuitive understanding \nof the semantics is not suf.cient in all cases. 3.1 World Hello? Consider the small Erlang program in \nFig. 1. When we run the function worldhello() it will spawn A, which in turn results in two processes \nbeing spawned (B and C). Thereafter A will .rst send the message hello directly to C and then send the \nmessage world to B. Process B is very simple, once it receives a message, it will forward it to process \nC. Process C just receives two messages, and prints the result. (?MODULE is a built-in macro which is \nreplaced by the name of the current module by the compiler, ?NODEi are ordinary macros de.ned elsewhere.) \nworldhello() -> spawn(?NODE1,?MODULE,procA,[]). procA() -> PidC = spawn(?NODE3,?MODULE,procC,[]), PidB \n= spawn(?NODE2,?MODULE,procB,[PidC]), PidC ! hello, PidB ! world. procB(PidC) -> receive world -> PidC \n! world end. procC() -> receive X -> ok end, receive Y -> ok end, io:format(\"~p ~p\\n\",[X,Y]). Figure \n1. World Hello -program hello 1 4? AC 2 4? world world B 3 Figure 2. Possible message sequences The \ninteresting aspect of this program is that the result of run\u00adning the program depends on the distributed \nenvironment! If the program is running on a single node (that is ?NODE1 = ?NODE2 = ?NODE3), the result \nis always: hello world. However if the pro\u00adgram is running in a distributed environment (that is ?NODE1 \n= ?NODE2?NODE3), the result could be either hello = world or world hello. The reason for this is that \nthere are different com\u00admunication guarantees at the distributed level. In short; in a sin\u00adgle run-time \nsystem message delivery is instantaneous (that is the message is immediately put in the receivers in-box), \nwhile in a dis\u00adtributed system the only guarantee is that messages between a pair of processes are ordered. \nThe possible message sequences in the distributed case is shown in Fig. 2. The etomcrl tool for example \n(and the same goes for many other Erlang veri.cation efforts) does not have a notion of nodes at all, \nand therefore this aspect cannot be checked. It is clear that this is a problem, since the difference \nin communication guarantees is a de.nite source of errors in Erlang systems (see for example Arts et \nal. (2005)). It was therefore a strong requirement on McErlang that it should handle the node semantics. \nIn fact, it is fair to say that the major part of the implementation effort of the model checker has \nbeen devoted to an accurate treatment of the often surprisingly complex semantics of the node semantics \npart of the run-time system. 3.2 Semantics implemented in McErlang The McErlang tool has a full implementation \nof the distribution part of Erlang (i.e., explicit programmatic mapping of processes to explicit nodes), \nand thus provides the possibility to verify code based on either the assumption that all process are \nlocal (on the same node), or remote (all processes reside on different nodes), or a mix of the disciplines. \nThus it is possible to verify a program under quite weak communication guarantees and be sure that later \nprocesses can be freely mapped on distributed nodes. However, the drawback of the distributed semantics \nis that it greatly increases the state space of the veri.ed programs; essentially the distributed semantics \nnon-deterministically delays the delivery of messages to a receiving process.  4. Structure of the Implementation \nThe model checker implementation is parametric, using the Er\u00adlang/OTP style of behaviors to specify particular \ncomponent be\u00adhaviors that provide services to the model checking algorithm. The basic task of the model \nchecker is of course to check a program against a correctness property, a monitor module,that implements \nthe correctness property to check. Except specifying which program to check (a speci.c Erlang function), \nand which Erlang module that implements the correct\u00adness property, a user of the tool can also choose: \n the name of a language module providing an operational se\u00admantics,  the particular veri.cation algorithm \nto use, (e.g., a safety prop\u00aderty checker, a liveness property checker or just testing i.e., simulation \nof the program in conjunction with a correctness property),  thenameofa state table implementation, \nthat records encoun\u00adtered program states (typically a hash table), and  the name of an abstraction module \nthat abstracts program states,  The modular composition of McErlang is illustrated in Fig. 3, and in \nthe following sections we describe the functionality of these modules in turn. Figure 3. McErlang modular \nstructure 4.1 Source Language The language module should provide two functions implementing an operational \nsemantics for the language: (i) transitions which given a state returns a list of all next actions executable \nby the program, and (ii) the function commit which given an action re\u00adturns a concrete program state. \nThe transitions function may not cause side effects outside the model checker environment (e.g., really \nwriting out a .le to the .le system) whereas commit may (if used by the simulation algorithm). The language \nmodule most com\u00admonly used is clearly the one providing an operational semantics for Erlang, however, \nwe have also implemented an operational se\u00admantics for the WS-CDL web choreography language (W3C 2005). \nAlthough the effort is less mature than the Erlang model checker, it is interesting that the basic framework \nof the model checker can be reused in a different language setting (Fredlund 2006). As XML and XPath \nconstitutes integral parts of the WS-CDL de.nition, hav\u00ading good support libraries available for these \nlanguages is very use\u00adful when representing their operational semantics. As Erlang has seen considerable \nindustrial usage, the language already had good library support for working with XML based documents; \nwe expect the same kind of advantages from using Erlang when providing model checkers for other target \nlanguages. 4.2 Correctness Properties Correctness properties are encoded as automata programmed in Er\u00adlang. \nA safety monitor is a function which is checked in every reachable program state, and which returns an \nerror if an invalid state is seen. A B\u00a8uchi monitor (automaton) is a monitor that addi\u00adtionally may mark \ncertain states as accepting. A program violates a B\u00a8uchi monitor if a cycle can be found in the combined \nstate space of the program and the monitor, which contains an accepting state. As is well known (Vardi \nand Wolper 1986), linear temporal logic formulas can be automatically translated to B\u00a8uchi automata. \nThe memory aspect of monitors is implemented by send\u00ading along the old monitor state as an argument to \nthe Erlang function implementing the monitor. Concretely a monitor de.nes two callback functions: init(parameters \n) and stateChange(programState,monitorState ). The init function returns {ok,monState }where monState \nis the initial state of the monitor. The stateChange function is called when the model checker encounters \na new program state programState and the current monitor state is monitorState . If a safety monitor \n.nds that the combination of program and current monitor state is accept\u00adable, it should return a tuple \n{ok, newMonState }containing the new monitor state. If future states along this branch are un\u00adinteresting \nthe monitor can return skip (e.g., to implement a search path depth limit), any other value signals a \nviolation of the correctness property implemented by the monitor. A B\u00a8uchi automatons should return a \nset of states, each state either accept\u00ading {accepting,state }or not {nonaccepting,state }.Nor\u00admally \nwe expect a sound stateChange function to be without side effects. As an example, the code fragment in \nFig. 4 implements a simple safety monitor that guards against program deadlocks: (a process is considered \ndeadlocked if its execution state as recorded by the process data structure in the run-time system is \nblocked). stateChange(State,MonState) -> case lists:any (fun (P) -> P#process.status =/= blocked end, \nState#state.processes) of true -> {ok, MonState}; false -> {deadlock, MonState} end. Figure 4. Simple \nsafety monitor The syntax variable #recordName.field is used to access the .eld .eld of the record variable \nvariable , of type recordName . 4.3 Algorithms The McErlang tool currently offers two basic on the .y \ndepth\u00ad.rst state traversal model checking algorithms, one to check safety properties and the other to \ncheck B\u00a8uchi automatons (the liveness checking algorithm adapted from Holzmann et al. (1996)). To give \nan intuition to the coding of these algorithms in Erlang, a schematic representation of the algorithm \nfor safety property checking is de\u00adpicted in Fig. 5 (we have abstracted out the parameter passing of \nmodules implementing language (Lang), monitors (Mon), abstrac\u00adtion (Abs) and table implementation (Tab)). \ncheck([]) -> ok; check([[]|Earlier]) -> check(Earlier); check([[State|Alts]|Earlier]) -> {ProgState,MonState,StateTab,AState} \n= State, % Check monitor {ok,NewMonState} = apply(Mon,stateChange,[ProgState,MonState]), % Abstract \nstate {ok, {AbsState,NewAState}} = apply(Abs,abstractState, [{ProgState,NewMonState},AState]), % Check \nwhether state already seen case apply(Tab,addState,[AbsState,StateTab]) of no -> check([Alts|Earlier]); \n{ok, NewStateTab} -> NewStates = [{S,NewMonState,NewStateTab,NewAState} || S<\u00adlists:map (fun (Action) \n-> apply(Lang,commit,Action), apply(Lang,transitions,[ProgState]))], check([NewStates,Alts|Earlier]]) \nend end. Figure 5. Safety property checking algorithm To check an Erlang function call m :f (p1,...,pn \n), given an initial monitor state monState and an empty state table t ,and abstraction state a , the \nchecking algorithm should be invoked with: check([[{mkProc(m,f,[p1,...,pn ]),monState,t,a }]]) where \nmkProc constructs a model checking process executing the function call argument. As seen in the listing, \nmodel checking states are composed of a program state, a monitor state, a state table, and an abstraction \nstate. Program states are checked against the monitor, and if ac\u00adcepted, are abstracted using an abstraction \nfunction provided by the module Abs. The abstracted states are checked against mem\u00adbership in the state \ntable. If the program state is new, the set of next states is computed using the function transitions. \nNote that the particular choice of abstraction and table storage is abstracted out from the algorithm \nitself. In addition there is a simple simulator available, which by de\u00adfault chooses the next program \nstate randomly, but in addition has some debugging functionality, e.g., next states can be explicitly \nchosen, transitions can be single or multiple stepped, breakpoints can be set, and backtracking to previous \nstates is supported. The simulator is also used to explore safety model checking counterex\u00adamples (traces). \nFairness Constraints on Executions The Erlang language stan\u00addard requires that process schedulers must \nbe fair. The McErlang tool accordingly implements (weak) process fairness directly in its (liveness) \nmodel checking algorithm by omitting non-fair loops (i.e., ones that constantly bypass some enabled process) \nfrom the accepting runs. 4.4 Tables A state table records pairs of program and monitor states encoun\u00adtered \nduring model checking, to detect recurring states. The state table implementations used are normally \nimperative (e.g., updates -module(hashAbs). -export([init/1, abstractState/2]). init(Size) -> {ok,Size}. \nabstractState(State,Size) -> {ok,{erlang:phash2(State,Size),Size}}. Figure 6. Abstraction module for \nhashing to them are destructive) for performance reasons; however purely functional implementations of \nthe tables are available. 4.5 Abstractions An abstraction abstracts a concrete program state into an \nabstract representation. It can be used to drastically reduce the checked state space of a program. The \nidea is inspired by the use of abstractions in Arts and Fredlund (2002). A typical abstraction used in \nmodel checking is to compute a hash value from the state, and to use the hash value as the abstract state \nwhen checking for membership in the state table. However, program speci.c abstraction functions can also \nbe implemented. For example, an abstraction could transform an integer variable into a boolean value, \nsignaling whether the integer is less than zero. Clearly, there is in general no guarantee that such \nan abstraction is safe, i.e., that it does not cause a program failure to escape undetected (false positive). \nAs a second example we have implemented the usual abstrac\u00adtion of collapsing a whole state to a single \ninteger (through hash\u00ading), and using a bit array table module to implement the state table. Thus, in \na modular fashion, we have obtained an implementation of Holzmann s bit-state hashing veri.cation algorithm \n(Holzmann 1991). An implementation of a hashing abstraction thus becomes as simple as Fig. 6, where erlang:phash2 \nis a built-in function which computes a hash value between 0..Size for its term argu\u00adment. Note that \nis an unsafe abstraction, although as proven in prac\u00adtise in many veri.cations, also a highly useful \none.  5. Executing Erlang Programs in McErlang The model checking capability for Erlang programs is \nprovided by executing Erlang programs directly in the existing Erlang run time system. This enables an \neasy and reasonably ef.cient handling of computations that act solely on data (the purely functional \nsub-part of Erlang). However, the existing Erlang run time system does not provide a method to capture \nthe combined system state of a running program (check-pointing). This is unavoidable, since in general \nan Erlang computation could be distributed and so the combined state cannot be ef.ciently, or even reliably, \ncollected. For this reason we have implemented in Erlang a new run-time system for the concurrent and \ndistributed part of the language, that implements easy access to the combined system state of an Erlang \nprogram. This run-time system simply simulates distribution and concurrency, all computations take place \ninside a single real Erlang process. Structurally the new run-time system is layered on top of the old \none, replacing only the process handling and the concur\u00adrency part of the old system. This layered structure \nalso in many ways resemble the layered structure of the Erlang semantics in sec\u00adtion 3. Essentially a \ncomplete veri.cation model consists of three parts: (1) an Erlang program containing the original program \nto be checked, (2) a re-usable implementation of the run-time system (also written in Erlang) and (3) \na speci.cation of the environmen\u00adtal constraints (e.g., which process/node failures and link failures \noccur). See section 6.2 for a concrete example of such environ\u00ad  server(State) -> {recv, {?MODULE, f_0, \n[State]}}. f_0({new_state, NewState, Pid}, [State]) -> {true, fun ({new_state, NewState, Pid}, [State]) \n-> evOS:send(Pid,{reply,State}), server(NewState) end}; f_0(_, _) -> false. Figure 9. Receive statement \n after translation Handling a non tail-recursive receive The translation of the receive construct sketched \nabove is correct only when it occurs in a tail-recursive position. For the general case, what is essentially \na run-time stack is used instead. The run-time stack is implemented using another special return value: \n{letexp,{expr,{module,f,parameters }}},which is used in the situation when a receive statement occurs \nin an expres\u00adsion context (i.e. not in a tail-recursive position). Consider for ex\u00adample the recursive \nfunction server in Fig. 10 which repeatedly calls a function doRequest which in turn contains a receive \nstate\u00adment. server(State) -> {ok, NewState} = doRequest(State), server(NewState). Figure 10. Non tail-recursive \nreceive before translation The example in Fig. 10 is translated into a letexp return value as seen in \nFig. 11. The function referenced in the letexp special expression is called when the inner function has \nreturned a value, and receives as arguments the returned value as .rst argument and as second argument \na list of variables necessary in the continued computation. In general all non tail recursive calls to \nfunctions that contain a receive in their body will have to be similarly guarded using a letexp. We use \na global analysis over the set of input modules to the translator for computing the transitive closure \nof which functions may execute a receive statement. server(State) -> {letexp, {doRequest(State), {?MODULE, \nf_1, []}}}. f_1({ok,NewState}, []) -> server(NewState). Figure 11. Non tail-recursive receive after \ntranslation The translation is somewhat complicated by the need to support the Erlang feature of permitting \nvariable bindings to migrate out of their scope. The Erlang example in Fig. 12, which compiles without \nwarning and does not cause run-time errors, illustrates the translation dif.culty (Logger is assumed \nto be bound to a process identi.er). Note that the variables Msg and NewV are bound in different branches \nof the receive construct, but may still be used outside of it. Non-determinism in Erlang Another special \nreturn value is {choice,[{module, fun,context },...]}which introduces explicit non-determinism in Erlang; \nthe model checker will non\u00addeterministically select the continuation function from the list of function \nalternatives. This construct is needed to use Erlang as a speci.cation language rather as a programming \none. As an exam\u00adple, suppose that we have implementing a drink machine in Erlang, offering either coffee \nor tea. Using the choice construct it is easy to model a machine user that non-deterministically selects \neither cof\u00adfee or tea, and to verify that the program works correctly regardless pingOrpong(Logger) -> \nreceive {ping,V,Sender} -> Sender!{Msg=pong,NewV=V+1,self()}; {pong,V,Sender} -> Sender!{Msg=ping,NewV=V+1,self()} \nend, Logger!{Msg,NewV}, pingOrPong(Logger). Figure 12. Migrating variable bindings what drink the user \nchooses (the model checker automatically ex\u00adplores both possibilities). Finally {pause,{module,fun,context \n}}is short hand for a choice with a single continuation function; it is used to facilitate detection \nof interesting states in correctness properties. 5.3 Data Structures in the Run-time System An Erlang \nstate in our run-time system is a hierarchical structure and mimics to a large extent the organization \nof the real run-time system (and the structure of the layered Erlang semantics!) for Erlang, except, \nof course the state is physically centralized. The top level of the hierarchical structure is composed \nof a tuple (nodes, ether), combining a data structure containing the nodes of the running system and \nan ether data structure containing messages in transit between nodes. Each message is identi.ed by the \nfollowing tuple: (receivingNode, sendingNode, messageContent ). The ether data structure essentially \nhas a separate queue of mes\u00adsages, sorted by sending time, for each pair of sending and re\u00adceiving nodes. \nThis is needed since the language guarantees that communication between any two nodes is FIFO-like, i.e., \nmes\u00adsages are delivered in order, if they are delivered at all. The messageContent contains the message \nitself (e.g., a normal mes\u00adsage sent between two processes or a run-time event such as e.g. a noti.cation \nof a process termination). A node tuple (name, processes, registered , monitors, node monitors, links), \nis on the second hierarchical level. The processes .eld contains the processes executing on the node, \nregistered implements the Erlang name server which maps (on a node basis) pids to symbolic names. The \n.elds monitors, node monitors and links is used in the three different process linking mechanisms available \nin Erlang. Each process is a tuple (status, expr, pid, queue, dict, .ags). The .eld status records the \nexecution status of the process, e.g., whether it is blocked waiting on incoming messages, ready to run, \nor ready to receive an existing message. The expr .eld describes the next piece of code to execute, concretely \na named user-de.ned Erlang function and a set of actual parameters to invoke the func\u00adtion with. The \npid .eld is the system-wide unique process identi\u00ad.er of the process, queue contains the messages sent \nto the process that are available for reading (inter-node messages migrate from the ether data structure \nto the queue whereas intra-node messages are directly put in the queue data structure, mimicking the \ndiffer\u00adent communication guarantees provided by the run-time system for inter-node compared to intra-node \ncommunication). Finally dict contains a process dictionary (the equivalent of imperative vari\u00adables in \nErlang), and .ags describes the setting of various process options.  Although the exact manner in which \nstates are physically stored or represented (e.g., on the stack of choice points and in the table of \nstates previously seen) during a model checking is fully con.gurable, the normal exact representation \nof a state ensures that states are normalized, i.e., nodes are sorted in some order, as are processes \nwithin an nodes, as are links (pairs of processes identi.ers in a node) and so on, to ensure a rapid \ncheck for state equality. 5.4 Model Checker Semantics The tool implements a major part of the core erlang \nmodule in the Erlang/OTP distribution omitting mainly functions to inspect the run-time system itself, \nto obtain process status, timing func\u00adtions, and ports (which are used to interface with foreign, i.e. \nnon Erlang, code). In total we provide around 40 such API functions, the implementation of which constitutes \na signi.cant portion of the lines of code of the model checker. The operational semantics implemented \nby McErlang comprise an interleaving transition relation between Erlang states whose ac\u00adtions are decorated \nby sequences of actions (i.e., a big-step oper\u00adational semantics). States are comprised by stable systems \n(e.g., where all processes are waiting in receive statements or have just spawned) and transitions are \ncaused by invoking a single enabled process to run which may cause many side effects until it again becomes \nstable (waiting in a receive statement). The use of a big step semantics means that some errors will \ngo undetected which would be caught using a smaller-step semantics. For the typically large scale systems \nthat we are interested in verifying with McErlang there is a trade-off here. One option is to have a \nvery detailed execution model with all the possibility non\u00addeterminism inherent in the programming language.3 \nThis quickly leads to enormous state spaces with the result that only a very tiny part of such state \nspaces can be explored by a model checker. On the other hand, we can reduce the non-determinism in the \nspeci.cation language by slightly changing its semantics. The result is smaller state spaces, which we \ncan verify a bigger part of, but there are possibly states that we can never check because they will \nnever be generated by the model checker. In future work we aim to implement a more .nely-grained semantics \nfor intra-node Erlang to explore this issue in further detail. Interestingly it turns out that we can \nrecover a more .nely\u00adgrained semantics in case each process communicates only with other remote processes \n(located on other nodes). Then a send, as well as any other side effect, will be arbitrarily delayed \n(since the node ether data-structure is used, which essentially have separates queues for all pairs of \ncommunicating processes, see section 5.3 for details) compared to side effects caused by other processes, \nand so all interleavings of side effects are recovered. 5.5 Run-time Environment Modeling Probably the \nmost challenging part of developing a model checker for Erlang is to accurately model the environmental \nconstraints put on a running Erlang program. For example: constraints on schedul\u00ading Erlang processes, \nthe semantic impact of mapping processes 3 As an extreme case, Erlang, for instance, does not .x the \norder of evalua\u00adtion of arguments to functions, so a totally faithful semantics would gener\u00adate all such \norderings. As Erlang programmers can happily write code that cause side effects in the evaluation of \nfunction call arguments, generating all such orderings may be highly important in model checking. However, \nthe number of extra states could be huge, although part of the overhead could be eliminated through use \nof intelligent reductions. In practise, however, the only available Erlang language implementation does \n.x the order of argu\u00adment evaluation, and in our opinion this is very unlikely to ever change in the \nfuture of Erlang. onto remote processing nodes, the basic communication guarantees of Erlang, and on \nthe frequency of failures in a running system. Moreover the Erlang API has quite a few functions with \nside ef\u00adfects, whose actions cannot be understood as simply as sequences of lower-level primitives (send \nand receive) but are .rst-class citi\u00adzens in any operational semantics. As an example we consider below \nthe implementation, which is a form of operational semantics, of the erlang API function exit/2. In Erlang, \nexit(Pid,Reason) is used to send a termi\u00adnation signal to the process referenced by Pid, which may be \nter\u00adminated as a result. The implementation has to handle the rather subtle interplay between fault-handling \nmechanisms (linking, mon\u00aditors) and take into account process locality (on the same node, or not), etc. \nMoreover, its behaviour is very different depending on whether the process to terminate resides on the \nsame node as the process executing the call or not. Although the function may seem complicated, it is \nan intrinsic part of the Erlang language, which is used by programmers all the time (as invoked in through \nhigher-level functions), and we have no choose but to model it faithfully if we wish to verify realistic \nErlang software. Implementation sketch: 1. First the arguments are checked; if Pid is not a process identi\u00ad.er \nan exception is raised. 2. The code then checks if Pid is a local pid (i.e., the correspond\u00ading process \nresides on the same node as the process which exe\u00adcutes the exit/2 call. If the process is remote, a \nsignal (a mes\u00adsage) is sent to the node on which the process resides containing a request to issue an \nexit/2 call, and the function returns. 3. If it is a local process, the process .ags are retrieved. \nThe process traps exit messages if the .ag trap exit is set. If trap exit is set, and the Reason argument \nis not kill,a message, { EXIT ,self(),Reason}, is put into its mailbox (where self() evaluates to the \npid of the process that called exit/2), and the function returns. 4. If the process is local, and it \nis not trapping exits, and the Reason argument is normal, the process is not terminated (and no message \nis put in its message queue), and the function returns. 5. Otherwise (the process is local, the reason \nis kill, or...) the process is terminated, i.e., it is removed from the process table. 6. Moreover any \nregistered names for the process are removed (by modifying the registered element in the node). 7. And \nany monitors the now terminated process has set up are removed (all nodes are searched for such monitors), \nand mes\u00adsages concerning terminated processes due to such monitorings are removed (from the ether element). \n 8. Then every process that has requested to monitor the terminated process (information present in the \nmonitor .eld of the node structure) are sent a message informing them of the termination of the process \nthey monitored, and the reason for termination. 9. Then all the links mentioning the terminated process \nare exam\u00adined (recorded in the links .eld of the node structure). If a link mentions a remote process, \nthen the remote process is sent a signal (message) informing it that one of its linked process has terminated. \nIf the process is local, the linked process is itself a candidate to terminate immediately, and execution \ncontains for the linked process with roughly step 3 above.  As is indicated in the last step, in Erlang \nthe termination of a process can, through the link concept, cause the termination of more processes, \nand so on, in a chain reaction. Although at .rst counter-intuitive, the idea is to use this behavior \nof the linking mechanism to write fault tolerant code. Essentially some processes are designated as supervisor \nprocesses, which are responsible for starting processes, and handling their termination by optionally \nrestarting them. Such supervisor processes set the trap exit .ag to have termination message delivered \nto their message queues. Their clients on the other hand generally do not set the trap exit .ag, since \nthey do not contain programming logic to handle faults.  Many Erlang programs are written to be fault-tolerant, \nusing the linking or monitoring mechanism, and although using ready-made components4 make the task easier, \nprogramming fault tolerant ap\u00adplications is still hard, and being able to check code under adverse run-time \nconditions using a tool such as our model checker is a signi.cant help. Ensuring Finite Models Clearly \nthe ef.cacy of the model check\u00ading algorithm depends crucially on whether the checked Erlang program \nis .nite state or not. However, note that for checking non\u00adcompliance this is not always necessary. For \ninstance, we can eas\u00adily code a monitor that raises an alarm whenever a process mailbox contains more \nthan, say, N messages. Similarly, an abstraction (see the discussion in section 4.5) could simply cut \nthe mailbox when it has grown too large. Still, in model checking Erlang there are at least two sources \nof trivially in.nite models that we need to avoid: the assigning of process identi.ers to new processes, \nand the use of unique references to uniquely identify (generic server) calls. We solve both problems \nby consistently choosing the least fresh process identi.er (or communication tag) absent from both the \ncurrent program state and the correctness monitor.  6. Evaluation To evaluate the use of McErlang we \nhave used it on several non\u00adtrivial examples, ranging from a resource locker to a Video on demand server. \nHere we focus on two examples, .rst a simpli.ed resource manager (or locker) originally implemented and \nveri.ed by Arts et al. (2004b). Their locker is based on a real implementa\u00adtion in the control software \nof the AXD 301 ATM switch developed by Ericsson. The second example is an implementation of a leader \nelection algorithm. The implementation is (loosely) inspired by an algorithm presented by Singh (1996). \nAlso this example originates from the AXD 301 ATM switch, but the particular implementation we studied \nhere (and which have been studied before by Arts et al. (2005)) is an open source version written by \nWiger. The two examples aims to show different aspects of McErlang, the locker example is comparing McErlang \nwith etomcrl and does not use the distributed features of McErlang. On the other hand, the leader election \nexample is distributed (and fault-tolerant) and the example shows that it is possible to .nd errors in \na distributed application with McErlang. Other case studies realized using McErlang include the veri.ca\u00adtion \nof an implementation of the Chord peer to peer protocol (Sto\u00adica et al. 2001), another implementation \nof a leader election algo\u00adrithm namely Stoller s leader election algorithm (Stoller 1997), and of the \nabove mentioned Video on demand server (Fredlund and S\u00b4anchez Penas 2007). 6.1 Resource manager The locker \nis responsible for a number of resources, to which it can give clients exclusive or shared access, and \nwhich can survive client failures. To compare performance with the etomcrl tool we 4 Such as, for example, \nthe OTP supervisor pattern and the OTP generic server that are prepared to handle errors.  here focus \non checking a single property5: is the locker safe with regards to mutual exclusion? That is, if a client \nrequests exclusive access to a resource, and is granted access, then no other client will access the \nresource. The source code of the example is split into four Erlang mod\u00adules (.les): (1) a module implementing \na (parametric) client repeat\u00adedly accessing the locker using the gen server OTP client-server component, \n(2) the source of a fault tolerant locker, (3) a module implementing a supervisor process for starting \nthe clients (using the supervisor OTP component), and (4) a supervisor that starts both the server and \nthe client supervisor. In total around 430 lines of Erlang code. The mutual exclusion monitor is provided \nin a separate Erlang module (around 60 additional lines of code); it checks whether multiple clients \nthink they have access to the same resource, and at least one client has exclusive access (a mutual exclusion \nfail\u00adure). In the client source we make visible the property of hav\u00ading access to resource by introducing \na state using the pause value: {pause,{?MODULE,inUse,[Resources ]}}which docu\u00adments the resources and \nlock types the client thinks it has acquired. Results As a comparison with etomcrl we present some .gures \nfor the checking of the locker example in table 1 below. The con.g\u00aduration column indicates, in a schematic \nmanner, the model check\u00ading scenario used. For instance aEaEaEaEaS is a con.guration with four clients \nrequesting exclusive access to the resource a, and one client requesting shared access. The timing column \nshows the time for generating the transition system (for etomcrl, via the instan\u00adtiator tool) and both \nthe time to generate the transition system and check the mutex property for McErlang. The states column \nrepre\u00adsents the number of states in the generated models. Note that for McErlang we use a non-lossy hash-table \nto store the state table. etomcrl McErlang con.guration time states time states aEaEaEaEaE 52s 34282 \n17s 52197 aEaEaEaEaS 36s 28014 17s 50805 aEaEaEaSaS 39s 30814 18s 56313 aEaEaSaSaS 1m 4s 51928 25s 75801 \naEaSaSaSaS 2m 49s 135038 42s 130101 aSaSaSaSaS 9m 29s 466702 1m39s 284277 Table 1. Comparison of etomcrl \nand McErlang The table shows that in less complex scenarios, etomcrl cre\u00adates smaller state spaces than \nMcErlang. However, in complex sce\u00adnarios (a scenario with more sharing is more complex, since many processes \ncan request and succeed in getting a sharing lock on a resource at the same time) the difference in number \nof states evens out. The tool experiments were performed on a HP xw6400 work\u00adstation with four Intel \nXeon CPUS each running at 1.60GHz (al\u00adthough neither tool made us of more than one CPU) and with 2 GB \nof memory, running Ubuntu 7.04. It is hard to draw .rm conclusions from the performance .gures, although \nit is a promising sign that the time needed to generate the transition system using McErlang is competitive \nwith the instantia\u00adtor tool (Wouters 2001), as the instantiator is written in C and can be expected to \nbe heavily optimized by now.6 5 Since etomcrl in contrast with McErlang does not support checking fault \ntolerance we did not introduce failures in the checked model; this was done in a separate experiment. \n6 Version 2.17.13 of the \u00b5CRL toolset was used. 6.2 Leader election The objective of the leader election \nalgorithm is to elect a leader among a .xed set of participants. This may seem trivial at .rst, but in \na distributed and fault tolerant setting there are many subtle things that makes it a hard problem (and \na well studied problem (Lynch 1996; Dolev et al. 1997) as well). Each node has a single leader election \nprocess, and the processes communicate with mes\u00adsages and also uses monitors to detect failures of other \nprocesses. There are two basic properties for leader election: Safety two processes can never be elected \nas leaders at the same time.  Liveness eventually a process must be elected as the leader (or there \nis an in.nite sequence of processes dying and restarting).  Both can easily be expressed as LTL-formulas \n(and hence as B\u00a8uchi automatons). Here we focus mainly on the safety property. To illustrate the typical \norganization of a veri.cation we provide some details regarding the concrete .les involved. The source \ncode of the example is split into three Erlang modules (.les): (1) a mod\u00adule implementing the leader \nelection algorithm, (2) an environment for the leader election algorithm, and (3) a module that contains \nthe monitor for the safety property. The test scenario is schematically illustrated in Fig. 13. The \nenvironment module consists of code that initiates a set of nodes and starts a leader election process \non each node. The envi\u00adronment also spawn controller processes (one for each node) that are responsible \nfor killing and restarting the local leader election process. The controller processes in turn are dictated \nby a central stimuli generator (located on a separate node). The central con\u00adtroller sends messages to \nthe local controller processes, which then enforces the order from the central controller (i.e., either \nkilling or restarting the leader election process). All communication be\u00adtween conrollers are normal \nErlang communication and it is all part of the model checking experiment. The reason for this some\u00adwhat \nstrange stimuli generation structure stems from earlier testing, where we used tracing in a way which \nworked best with this struc\u00adture. However, this is a good example of one of the strengths of the everything \nin Erlang approach, where the code from testing can be re-used (almost as is) as the environment description \nin veri.cation. Also, the .exibility of having the environment in a separate module (which consists of \nordinary Erlang code) is that we could easily do a veri.cation of only the start-up phase (or some other \npart of the state space, such as just killing the process with highest priority) by just changing the \nmodule with the stimuli code. Originally, the test code provides random stimuli, which is not very suitable \nfor model checking. The randomness is removed in our example by setting the pseudo-random generator seed \nto a .xed value. The monitor for the safety property is not very complicated, it only consists of a check \nif there are two leaders elected in the current system state. The property monitor is listed in Fig. \n14. One -module(monNotTwoLeaders). init(State) -> {ok,{safety,State}}. stateChange(State,MonState,_) \n-> case notTwoLeaders(stRecords(allProcs(State))) of true -> {ok,State}; false -> {error,stRecords(allProcs(State))} \n end. allProcs(State) -> lists:flatmap (fun (Node) -> Node#node.processes end, State#state.nodes). stRecords([]) \n-> []; stRecords([P|Rest]) -> case P#process.expr of {recv,{ev_gen_server2,_,{Rec,_}}} -> [Rec|stRecords(Rest)]; \n_-> stRecords(Rest) end. isLeader({P,{_,State}}) -> Ldr = State#data.leader, P#process.pid == Ldr. notTwoLeaders(States) \n-> length(lists:filter(fun isLeader/1,States)) < 2. Figure 14. Safety property monitor NotTwoLeaders \nthing that is clear from the listing in Fig. 14 is the need for a set of convenience functions for accessing \nthe states and retrieving information from the state. Results If the example is run in McErlang using \nthe safety al\u00adgorithm, and the NotTwoLeaders monitor the result is a counter example. The time it takes \nto reach a counter example is only a few seconds (depending on the seed choosen it can take longer or \nshorter time) on a fairly modest workstation. The size/length of the counter example includes around \n50 transitions. The existence of a counter example is not surprising, since other studies of the same \nalgorithm (Arts et al. 2005) have revealed errors. (The counter ex\u00adample described below is actually \nexactly the same as the one la\u00adbeled The .rst serious bug in that paper) The counter example scenario \nis described in Fig. 15. The prob\u00adlem in the scenario is that some communication is slower than other. \nSince in the protocol only a majority of the involved pro\u00adcesses needs to accept a candidate it is possible \nthat an existing leader (B in the scenario) could be outnumbered by newly started and fast communicating \nprocesses (A and C in the scenario). What is important to note is that the error found is only present \nin a distributed and fault tolerant semantics. That is, we could not have found this error using a model \nchecker (or other veri.cation tool) that does not support the distributed semantics of Erlang. We also \nhave the possibility to search for the shortest path leading to an error (again what is the shortest \nvary due to the introduced random\u00adness). Having the shortest counter example is often desirable since \nit includes the least amount of unnecessary information. A search for the shortest path to an error is \nof course slower, sometimes sev\u00aderal order of magnitudes slower. In one of our examples a search took \nabout 30 minutes, and explored somewhere around 10 million states. Three processes A,B,C (with priority \nA > B > C): B is started B: Send capture to A,C and monitor A,C. B: Receive Down from A. B: Receive \nDown from C, broadcast elected . B is the leader A is started C is started  A: Send capture to B,C and \nmonitor B,C. C: Receive capture from A, Send accept to A. A: Receive accept from C, broadcast elected \n. A is the leader Figure 15. Counter example from leader election  7. Discussion In this section we \nwant to discuss some alternative implementation aspects. As mentioned in the introduction we made some \nexperi\u00adments with a prototype implementation of the distributed Erlang semantics in Haskell. The prototype \nconsisted of an Erlang parser and a layered run-time system with .exible control of path choice, etc. \nIt supported all the distributed features of Erlang, but a lot of the more basic pure functional things \nwere missing. We asked ourselves if it would be possible to use such an implementation as the starting \npoint for a model checker for Erlang as well. Much of the work with McErlang has gone into accurately \nmodeling the node level semantics of Erlang. Starting instead with an implementation of the distributed \nsemantics that task would be much simpler. We also think that a lot of the modular structure of McErlang \ncould be the same in a Haskell implementation. We have identi.ed some advantages with a Haskell approach \nas well as some drawbacks. One of the major drawbacks is that one looses the ability to re-use the existing \nevaluation mechanisms for the purely functional part. This means that every lower-level built-in pure \nfunction and data structure has to be dealt with in the implementation. To implement this is perhaps \nnot a very compli\u00adcated task, however we deemed it as far too time-consuming for a research project. \nOn the other hand, by having full control of the whole run-time system we could omit the Erlang to Erlang \ncom\u00adpilation phase discussed in section 5.2. It would also be trivial to switch from a big-step semantics \nto a small-step semantics since we could easily turn other syntactic constructions into choice points. \nA .nal drawback is of course also that we miss the all-in-Erlang aspect, since we involve Haskell. This \ncould be a hinder for an ex\u00adperienced Erlang programmer with limited Haskell knowledge. Our conclusion \nis that it is certainly possible to implement the same type of model checker in Haskell. However, it \nseems to be a lot more time-consuming, and it is not obvious that the end result would be any better \nthan McErlang. 8. Related Work Software model checking is a very active research .eld, which means that \nthere exist an overwhelming amount of related works. We try to mention the most important and the ones \nwhich have provided inspiration for McErlang. For Erlang the etomcrl toolset (Arts et al. 2004a) already \npro\u00advides a model checking capability. Although it is more restricted, covering a smaller subset of Erlang, \nfor instance lacking the con\u00adcept of distribution and fault tolerance (i.e. nodes, processes, links, \nmonitors, ...). Other veri.cation tools for Erlang include Huch s abstract interpretation model checker \n(Huch 1999) which uses ab\u00adstract interpretations to reduce the size of the state space. We also have \nthe Veri.cation of Erlang Programs -project (Fredlund et al. 2003) which uses theorem proving technology. \nFurther there is the interesting QuickCheck tool for Erlang by Arts and Hughes (2003), which however \nis more of a testing tool than a veri.cation tool as it cannot detect recurring states. The work on tracing \nfor Erlang, in particular the approaches that have used abstractions to handle the size of the traces, \nby Arts and Fredlund (2002) and by Arts et al. (2005) was also a source of in\u00adspiration for the abstraction \npart of the McErlang implementation. A lot of the inspiration for this work naturally comes from the \nwork on the SPIN tool by Holzmann (1991) and the CADP toolset (Fernandez et al. 1996), as they both constitute \nvery capable language based platforms for the veri.cation of software, and for testing new veri.cation \nalgorithms. The VeriSoft tool by Godefroid (1997) is one of the earlier ex\u00adamples of providing a veri.cation \nfunctionality to a real, complex, programming language (such as C or C++) instead of a simpler speci.cation \nlanguage. Another successful example of such a ver\u00adi.cation project is the Modex tool (Holzmann and Smith \n2002) which is closely connected to SPIN. A recent work on the veri.\u00adcation of complex concurrent program \ncode is the work on model checking .le system implementations by Yang et al. (2004). An\u00adother recent \nwork is the Zing model checker by Andrews et al. (2004) which aims at checking concurrent systems. 9. \nConclusion and Future Work As we have seen, adopting an everything-in-Erlang approach to model checking \nhas certain advantages. It is easy to provide a rich speci.cation language, and to use the same language \nfor formulat\u00ading correctness properties as for programming is convenient. More\u00adover much of the basic \nexecution machinery can be reused (e.g., McErlang uses the normal Erlang run-time system extensively). \nThe result is a model checker for Erlang, which supports all as\u00adpects of distribution and fault tolerance. \nThis is especially impor\u00adtant since distributed and fault-tolerant implementations are known to be error \nprone and hard to test and debug. It is our hope that McErlang is also simple enough to use, such that \nit can be used by the ordinary Erlang programmer. With two examples we have compared McErlang with the \nex\u00adisting etomcrl tool set and also showed that it is indeed possible to .nd errors in a distributed \nprogram using McErlang. The per\u00adformance of McErlang looks promising, and the trade-off between expressive \npower and ef.ciency seems positive. However, more case studies are needed before we can be certain about \nthe capacity of McErlang. Another good property of McErlang, is the clearly separated input. We can easily \nexperiment with different environment con\u00adstraints for a program under test. This is particularly useful \nif one is only interested in part of the complete state space, since the search space could easily be \naltered by changing the environment con\u00adstraints as we saw in the leader election example in section \n6.2. We have also experimented with an alternative implementation approach using Haskell. There we concluded \nthat although it is a possible alternative it is far from obvious that the result would be better than \nMcErlang. During the development of the McErlang tool we also realized that a (dynamically typed) functional \nlanguage offers several ad\u00advantages over traditional languages like C as a general framework for implementing \nformal veri.cation tools (e.g., quick prototyping, clean higher-order functions, separating functionality \ncleanly into modules, seamless composition of modules, and so on). Thus we have started experimenting \nwith the use of the McErlang tool as a general framework for building model checkers for various target \nlanguages. Essentially this involves provides an executable opera\u00adtional semantics for the target language \nin question, together with the glue necessary (state parsers and unparsers, and so on). As a small experiment \nwe implemented a simple interpreter and model checker for the WS-CDL web choreography language (W3C 2005). \nFuture work The tool is far from .nished, there are many things that we want to investigate further, \nthe following list indicates some of these areas: We would like to experiment with partial-order veri.cation \nalgorithms for the model checker. Clearly such reductions are normally quite language speci.c, and it \nwill be instructive to see whether we can express their enabling conditions cleanly in Erlang. Moreover \nwe can hope to bene.t from the fact that standard components are heavily used in Erlang, which should \nresults in more regular communication exchanges, i.e., which are more amenable to partial order reductions. \n To use McErlang on a larger body of programs we need to support a slightly richer Erlang fragment (e.g. \nthe port con\u00adstruct for communicating with the external world). In particular it would be interesting \nto have a normal Erlang node communi\u00adcate with nodes in our modeled Erlang environment.  We should provide \nthe option of changing the Erlang semantics implemented in the tool to re-schedule processes not only \nwhen a receive statement is encountered, but to do so for every side\u00adeffect inducing operation (e.g. \nmessage sends). This will result in a small-step semantics option that may detect new program bugs. \n Since many aspects of Erlang (asynchronous message passing, rich error detection mechanisms and process \nfairness) closely match standard implementation environments for distributed al\u00adgorithms. Therefore, \nit seems reasonable to think that McErlang can be really useful also for veri.cation of general distributed \nalgorithms. The leader election algorithm example, presented in section 6, could be seen as one example \nof such an algorithm.  We would like to develop a library of useful state abstractors for Erlang to \nenable this part of the tool to see wider use.  Acknowledgement Thanks are due to Clara Benac Earle, \nJuan Jos\u00b4eS\u00b4anchez Penas, Koen Claessen and Thomas Arts. References T. Andrews, S. Qadeer, S.K. Rajamani, \nJ. Rehof, and Y. Xie. Zing: A model checker for concurrent software. In Lecture Notes in Computer Science, \nvolume Vol. 3114, pages 484 487, Jan 2004. J. Armstrong. Programming Erlang Software for a Concurrent \nWorld. The Pragmatic Programmers, http://books.pragprog.com/titles/jaerlang, 2007. J. Armstrong. Making \nreliable distributed systems in the presence of software errors. PhD thesis, Royal Institute of Technology, \nStockholm, Sweden, December 2003. J. Armstrong, R. Virding, C. Wikstr\u00a8om, and M. Williams. Concurrent \nProgramming in Erlang. Prentice-Hall, 1996. T. Arts and L. Fredlund. Trace analysis of Erlang programs. \nSIGPLAN Not., 37(12), 2002. ISSN 0362-1340. T. Arts and J. Hughes. QuickCheck for Erlang. In Proceedings \nof the 2003 Erlang User Conference (EUC), 2003. T. Arts, C. Benac Earle, and J. J. S\u00b4anchez Penas. Translating \nErlang to mucrl. In Proceedings of the International Conference on Application of Concurrency to System \nDesign (ACSD2004). IEEE Computer Society Press, June 2004a. T. Arts, C. Benac Earle, and J. Derrick. \nDevelopment of a veri.ed Erlang program for resource locking. International Journal on Software Tools \nfor Technology Transfer (STTT), 5(2 3):205 220, March 2004b. T. Arts, K. Claessen, and H. Svensson. Semi-formal \ndevelopment of a fault\u00adtolerant leader election protocol in Erlang. Lecture Notes in Computer Science, \n3395:140 154, January 2005. S. Blau and J. Rooth. AXD 301 -a new generation ATM switching system. Ericsson \nReview, 1:10 17, 1998. K. Claessen and H. Svensson. A semantics for distributed Erlang. In Proceedings \nof the ACM SIPGLAN 2005 Erlang Workshop, 2005. S. Dolev, A. Israeli, and S. Moran. Uniform dynamic self-stabilizing \nleader election. IEEE Trans. Parallel Distrib. Syst., 8(4):424 440, 1997. ISSN 1045-9219. doi: http://dx.doi.org/10.1109/71.588622. \nErlang 5.5/OTP R11B. The Erlang/OTP Team. URL http://www.erlang.org/doc/doc-5.5/doc/highlights.html. \nJ.-C. Fernandez, H. Garavel, A. Kerbrat, L. Mounier, R. Mateescu, and M. Sighireanu. CADP: A protocol \nvalidation and veri.cation toolbox. In Proceedings of the 8th Conference on Computer-Aided Veri.cation, \nvolume 1102 of Lecture Notes in Computer Science, pages 437 440. Springer, 1996. L. Fredlund. A Framework \nfor Reasoning about Erlang Code. PhD thesis, Royal Institute of Technology, Stockholm, Sweden, 2001. \nL. Fredlund. Implementing WS-CDL. In Proceedings of the second Spanish workshop on Web Technologies (JSWEB \n2006).Universidade de Santiago de Compostela, November 2006. L. Fredlund and J.J. S\u00b4anchez Penas. Model \nchecking a VoD server using McErlang. In In proceedings of the 2007 Eurocast conference, Feb 2007. L. \nFredlund, D. Gurov, T. Noll, M. Dam, T. Arts, and G. Chugunov. A veri.cation tool for Erlang. International \nJournal on Software Tools for Technology Transfer (STTT), 4(4):405 420, Aug 2003. P. Godefroid. Verisoft: \nA tool for the automatic analysis of concurrent reactive software. In Computer Aided Veri.cation, pages \n476 479, 1997. G. Holzmann. Design and Validation of Computer Protocols. Prentice-Hall, 1991. G. Holzmann, \nD. Peled, and M. Yannakakis. On nested depth .rst search. In Proc. Second SPIN Workshop, pages 23 32. \nAmerican Mathematical Society, 1996. G. J. Holzmann and M. H. Smith. An automated veri.cation method \nfor distributed systems software based on model extraction. IEEE Trans. Softw. Eng., 28(4):364 377, 2002. \nISSN 0098-5589. F. Huch. Veri.cation of Erlang programs using abstract interpretation and model checking. \nIn Proceedings of the 1999 ACM SIGPLAN Interna\u00adtional Conference on Functional Programming, 1999. N. \nLynch. Distributed Algorithms. Morgan Kaufmann Publishers, 1996. G. Singh. Leader election in the presence \nof link failures. In IEEE Transactions on Parallel and Distributed Systems, Vol 7. IEEE computer society, \n1996. I. Stoica, R. Morris, D. Karger, F. Kaashoek, and H. Balakrishnan. Chord: A scalable Peer-To-Peer \nlookup service for internet applications. In Proceedings of the 2001 ACM SIGCOMM Conference, pages 149 \n160, 2001. URL citeseer.ist.psu.edu/stoica01chord.html. S. D. Stoller. Leader election in distributed \nsystems with crash failures. Technical Report 481, Computer Science Dept., Indiana University, May 1997. \nRevised July 1997. S. Torstendahl. Open telecom platform. Ericsson Review, 1, 1997. M. Y. Vardi and P. \nWolper. An automata-theoretic approach to automatic program veri.cation. pages 332 344, 1986. W3C. Web \nServices Choreography Description Language, Version 1.0 W3C candidate recommendation 9 november 2005. \nTechnical report, W3C, November 2005. U. Wiger. Fault tolerant leader election. URL http://www.erlang.org/. \nA.G. Wouters. Manual for the \u00b5CRL toolset. Technical report, CWI, Amsterdam, 2001. J. Yang, P. Twohey, \nD. Engler, and M. Musuvathi. Using model checking to .nd serious .le system errors. In Sixth Symposium \non Operating Systems Design and Implementation, pages 273 288. USENIX, 2004.   \n\t\t\t", "proc_id": "1291151", "abstract": "<p>We present a model checker for verifying distributed programs written in the Erlang programming language. Providing a model checker for Erlang is especially rewarding since the language is by now being seen as a very capable platform for developing industrial strength distributed applications with excellent failure tolerance characteristics. In contrast to most other Erlang verification attempts, we provide support for a very substantial part of the language. The model checker has full Erlang data type support, support for general process communication, node semantics (inter-process behave subtly different from intra-process communication), fault detection and fault tolerance through process linking, and can verify programs written using the OTP Erlang component library (used by most modern Erlang programs).</p> <p>As the model checking tool is itself implemented in Erlang we benefit from the advantages that a (dynamically typed) functional programming language offers: easy prototyping and experimentation with new verification algorithms, rich executable models that use complex data structures directly programmed in Erlang, the ability to treat executable models interchangeably as programs (to be executed directly by the Erlang interpreter) and data, and not least the possibility to cleanly structure and to cleanly combine various verification sub-tasks. In the paper we discuss the design of the tool and provide early indications on its performance.</p>", "authors": [{"name": "Lars-&#197;ke Fredlund", "author_profile_id": "81100403481", "affiliation": "Universidad Polit&#233;cnica de Madrid, Madrid, Spain", "person_id": "P580982", "email_address": "", "orcid_id": ""}, {"name": "Hans Svensson", "author_profile_id": "81337494107", "affiliation": "Chalmers University of Technology, Gothenburg, Sweden", "person_id": "PP37044504", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291171", "year": "2007", "article_id": "1291171", "conference": "ICFP", "title": "McErlang: a model checker for a distributed functional programming language", "url": "http://dl.acm.org/citation.cfm?id=1291171"}