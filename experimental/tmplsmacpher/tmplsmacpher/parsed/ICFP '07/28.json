{"article_publication_date": "10-01-2007", "fulltext": "\n A Type System for Recursive Modules Derek Dreyer Toyota Technological Institute Chicago, Illinois, USA \n dreyer@tti-c.org Abstract There has been much work in recent years on extending ML with recursive modules. \nOne of the most dif.cult problems in the devel\u00adopment of such an extension is the double vision problem, \nwhich concerns the interaction of recursion and data abstraction. In pre\u00advious work, I de.ned a type \nsystem called RTG, which solves the double vision problem at the level of a System-F-style core calcu\u00adlus. \nIn this paper, I scale the ideas and techniques of RTG to the level of a recursive ML-style module calculus \ncalled RMC, thus establishing that no tradeoff between data abstraction and recur\u00adsive modules is necessary. \nFirst, I describe RMC s typing rules for recursive modules informally and discuss some of the design \nquestions that arose in developing them. Then, I present the for\u00admal semantics of RMC, which is interesting \nin its own right. The formalization synthesizes aspects of both the De.nition and the Harper-Stone interpretation \nof Standard ML, and includes a novel two-pass algorithm for recursive module typechecking in which the \ncoherence of the two passes is emphasized by their representation in terms of the same set of inference \nrules. Categories and Subject Descriptors D.3.1 [Programming Lan\u00adguages]: Formal De.nitions and Theory; \nD.3.3 [Programming Languages]: Language Constructs and Features Abstract data types, Modules, Recursion; \nF.3.3 [Logics and Meanings of Pro\u00adgrams]: Studies of Program Constructs Type structure General Terms \nDesign, Languages, Theory Keywords Type systems, modules, recursion, abstract data types 1. Introduction \nThe ML module system (MacQueen 1984), while esteemed for its strong support for data abstraction and \ncode reuse, has also been criticized for lacking a feature common to less sophisticated mod\u00adule systems \nnamely, recursive modules. The absence of recursive modules in ML means that programmers are forced to \nconsoli\u00addate mutually recursive code and type de.nitions within a single module, often at the expense \nof modularity. Consequently, in re\u00adcent years, language researchers have proposed and implemented a variety \nof recursive module extensions to ML in the interest of remedying this de.ciency (Russo 2001; Leroy 2003; \nDreyer 2005; Nakata and Garrigue 2006). Permission to make digital or hard copies of all or part of this \nwork for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. ICFP 07, October 1 3, 2007, Freiburg, Germany. Copyright c &#38;#169; \n2007 ACM 978-1-59593-815-2/07/0010. . . $5.00 My Ph.D. thesis (Dreyer 2005) examines several problems \nin the design of a recursive module construct that all of the aforemen\u00adtioned proposals have had to deal \nwith in one way or another. By far the most serious of these problems is one that involves the inter\u00adaction \nof recursion and data abstraction. Inside a recursive module, one may wish to de.ne an abstract data \ntype in a context where a name for the type already exists, and there is no way in tradi\u00adtional accounts \nof ML-style type generativity to connect the old name with the new de.nition. I call this the double \nvision prob\u00adlem because it has the effect that the programmer sees two distinct versions of the same \ntype when they should only see one. (A moti\u00advating example of the problem is given in Section 2.1.) Double \nvision has proven dif.cult to cure. To the extent that existing recursive module proposals address the \nproblem, they do so either by imposing severe restrictions on the use of data ab\u00adstraction within recursive \nmodule de.nitions (Crary et al. 1999; Russo 2001), or else by implementing tricky typechecking maneu\u00advers \nthat are dif.cult to formalize cleanly and only work in certain cases (Leroy 2003; Dreyer 2005). Neither \nof these approaches is satisfactory. (An overview of existing proposals is given in Sec\u00adtion 2.2.) In \nrecent work (Dreyer 2007b), I argued that the reason double vision is a dif.cult problem is that the \nclassical type-theoretic inter\u00adpretation of abstract data types namely, as packages of existential type \n(Mitchell and Plotkin 1988) is inadequate for expressing the kinds of recursive abstract data types that \narise naturally in the con\u00adtext of recursive modules. I de.ned a type system called RTG (for Recursive \nType Generativity) that addresses this de.ciency at the level of a System-F-style core calculus. (The \nbasic idea of RTG is presented in Section 2.3.) Although I gave several examples to sug\u00adgest how recursive \nmodules may be encoded in RTG, I left the de\u00advelopment of a general recursive module semantics to future \nwork. The primary contribution of this paper is to ful.ll the promise of RTG by scaling its ideas and \ntechniques to the level of a recursive ML-style module calculus, which I call RMC. The semantics of RMC \nsuccessfully avoids the double vision problem without plac\u00ading any undue restrictions on the use of data \nabstraction in recur\u00adsive modules. While RMC s approach to solving double vision is based closely on \nthat of RTG, the typechecking of RMC programs is more complex than that of RTG programs (much as the \ntype\u00adchecking of ML modules is more complex than that of System F). In Section 3, I describe recursive \nmodule typechecking at an in\u00adformal level, and provide a number of examples and exercises to demonstrate \nits subtleties. I also discuss a number of the techni\u00adcal issues that arose (aside from the handling \nof double vision) in working out a semantics for a general recursive module language. The formalization \nof the RMC type system (presented in full detail in Section 4) is interesting on several levels. First, \nit exhibits a hybrid of the two main approaches to de.ning the semantics of ML-style modules: namely, \nthe De.nition of Standard ML (Milner et al. 1997) and the type-theoretic interpretation of Harper and \nStone (2000). On one hand, I de.ne the dynamic semantics of RMC by means of a Harper-Stone-style elaboration \nrelation (aka evidence translation) into an internal type system. This internal type system is just RTG \nextended with a primitive module system. The main bene.t of this approach is that it enables us to establish \nthe type soundness of RMC as a corollary of the type soundness of RTG. In contrast, while De.nition-style \nformalisms typically employ a direct big-step evaluation semantics, type soundness of these formalisms \nis more dif.cult to prove (Tofte 1988). On the other hand, the interpretations of modules and signa\u00adtures \nin RMC are much closer in detail to the semantic objects of the De.nition than to the translucent-sums/manifest-types \nfor\u00admalism (Harper and Lillibridge 1994; Leroy 1994) employed by Harper and Stone. Moreover, like the \nDe.nition s typing rules, the RMC typing rules are completely self-contained and can be ex\u00adplained to \nthe programmer independently of the evidence transla\u00adtion into the internal RTG type system. In fact, \nthat is precisely how I will present the rules in this paper, leaving most of the details of evidence \ntranslation to the companion technical report (Dreyer 2007a). Thus, RMC s formalization combines the \nbene.ts of both de.nitional approaches. A second interesting feature of RMC s static semantics is its \nstreamlined presentation of recursive module typechecking. The proper handling of double vision seems \nto demand the use of a two-pass algorithm for typechecking certain kinds of modules the .rst ( static \n) pass computes only the type components of the module, while the second pass typechecks the full module. \nAs a way of demonstrating the semantic coherence of these passes, I formalize both of them using a single \nset of typing rules the only difference is that the static pass omits some of the premises of the rules \nfor the full pass. I believe the built-in coherence of these judg\u00adments makes the semantics of RMC easier \nto understand than other recursive module formalisms that involve multiple typechecking passes (Nakata \nand Garrigue 2006; Dreyer 2005, 2006). A key feature that RMC does not account for in its present form \nis the ability to compile mutually recursive modules separately and link them dynamically. None of the \nrelated work on recursive ML\u00adstyle modules supports this feature either. In prior work (Dreyer 2007b), \nI demonstrated that the RTG calculus is capable of encod\u00ading separately compiled recursive modules, so \nI believe it will be possible in the future to scale RMC to support separate compila\u00adtion. At the moment, \nhowever, it is unclear how best to introduce this feature syntactically into a programmable module language, \nand I consider it separable from the focus of the present work. Detailed comparisons with related work \non recursive modules appear throughout the paper, particularly in Sections 2.2 and 3. I conclude in Section \n5 with further discussion of related work, as well as directions for future work. 2. The Double Vision \nProblem Crary et al. (1999) were the .rst to attempt to establish a type\u00adtheoretic foundation for recursive \nML-style modules. Perhaps the most in.uential aspect of their work is that they set forth the two main \nsyntactic extensions to the ML module system that appear (with minor variations) in every subsequent \nrecursive module pro\u00adposal, including the present one. The .rst is the recursive module construct itself, \nwhich has the form rec (X : sig) mod. Here, mod is the module being recur\u00adsively de.ned, X is the module \nidenti.er by which mod refers to itself, and sig is the forward declaration signature, which is used \nas the signature of X during the typechecking of mod. Mutually recursive modules are de.nable as a single \nrecursive module with multiple substructures. The second extension is the recursively dependent signature \n(or rds), which has the form rec (X) sig. The idea is that X is a vari\u00ad signature SA =sig type u; type \nt; val f:t->u* t... end signature SB =sig type t; type u; val g:t->u* t... end signature S = rec (X) \nsig structure A : SA where type u = X.B.u structure B : SB where type t = X.A.t end structure AB = rec \n(X : S) struct structure A :> (SA where type u = X.B.u) = struct type u = X.B.u type t= int fun f (x:t) \n:u *t = let val (y,z) = X.B.g(x+3) (* Error 1 *) in (y,z+5)end (* Error 2 *) ... end structure B :> (SB \nwhere type t = X.A.t) = struct type t = X.A.t type u = bool fun g (x:t) : u * t = ...X.A.f(...)... ... \nend end Figure 1. Motivating Recursive Module Example able by which sig can refer recursively to the \nmodule whose sig\u00adnature sig is intended to describe. This functionality is critical if we wish to describe \nthe signatures of mutually recursive modules with abstract type components, such as those in the motivating \nex\u00adample (below). Although several authors refer to rds s as recursive signatures , I concur with Crary \net al. that this is misleading, as it gives one the impression that the signatures can refer recursively \nto themselves (rather than to the modules that inhabit them). 2.1 Motivating Example Figure 1 presents \na motivating example of a recursive module that exhibits the double vision problem. So that this motivating \nexample may serve as a running example throughout the paper, it is concise to the point of being contrived. \nFor more realistically detailed examples of recursive modules, see Dreyer (2005) and Nakata and Garrigue \n(2006). The recursive module in Figure 1 comprises two mutually re\u00adcursive substructures A and B, with \nA providing an abstract type component t and a value component f,and B providing an abstract type component \nu and a value component g. In this example, the types of both value components, A.f and B.g, refer to \nboth type components A.t and B.u. So that we may write down the signa\u00adture for each module independently \nand bind it to a signature iden\u00adti.er (SA and SB), each of these signatures includes a speci.cation of \nthe type component from the other module. This is a standard technique in ML programming, which Harper \nand Pierce (2005) recently dubbed .bration. When we write down the forward declaration signature S,we \nneed a way to connect the two copies of each type component. For this purpose, we employ a recursively \ndependent signature. Using ML s where type mechanism, we can reify the speci.cation of A.u so that it \nis transparently equal to X.B.u (and similarly so that B.t is transparently equal to X.A.t). Now we come \nto the recursive module de.nition itself. While typechecking the body of the de.nition, we assume that \nthe recur\u00adsive variable X has the forward declaration signature S. Within the de.nition of module A, \nthe type t is de.ned to be int. The func\u00adtion f takes a value x of type t as an argument (i.e., an integer) \nand calls X.B.g on x+3. Unfortunately, this is not well-typed, be\u00adcause X.B.g expects a value of type \nX.A.t, not t,and X.A.t is not known to equal int. To the programmer, however, this may seem bizarre, \nsince X.A.t is merely a recursive reference to t,sothe two types should be indiscernible, shouldn t they? \nThis is the .rst instance of the double vision problem. The second instance comes on the following line \nof code. The call to X.B.g has returned a value z of type X.A.t, which the function f then tries to add \n5 to. The typechecker will prevent it from doing so, though, for the same reason as before X.A.t does \nnot equal int. Intuitively, the problem here is obvious. The bodies of A and B should have access to \ndifferent privileged information about the type components of X. Speci.cally, A should know that X.A.t \nis int, but it ought not know anything about X.B.u.Conversely, B should know that X.B.u is bool, but \nit ought not know anything about X.A.t. However, it is far from obvious how to de.ne a gen\u00aderal typing \nrule for recursive modules so that X has different sig\u00adnatures when typechecking different parts of the \nrecursive module de.nition. 2.2 Existing Approaches to Double Vision Under all of the existing recursive \nmodule proposals, the program in Figure 1 is rejected as ill-typed. Crary et al. (1999) observe the double \nvision problem in their original paper, although they do not refer to it as such. (Instead, they call \nit the trouble with opacity .) Their response to the problem is simply to restrict the forward declaration \nsignature of a recursive module to be transparent. In the case of our motivating example, this means \nthat the de.nitions of A.t and B.u would need to be ex\u00adposed, effectively prohibiting either module from \nhiding its internal data representation from the other. Aware of this, Crary et al. dis\u00adcuss informally \nseveral ideas for how this restriction might be lifted in practice, but to my knowledge none of these \nideas has been for\u00admally .eshed out. Russo (2001) de.nes a recursive module extension to Standard ML, \nwhich he has implemented in the Moscow ML compiler. Although Russo does not explicitly require forward \ndeclarations to be transparent, other restrictions of his system implicitly do. In particular, his typing \nrule for rec ( X : sig) mod demands that, if a type component t is forward-declared abstractly in sig,then \nmod must de.ne t to be equal to X.t (i.e., by writing type t =X.t). While this clearly has the effect \nof avoiding double vision, it also means that t never gets de.ned anywhere! This restriction makes it \nessentially impossible to forward\u00addeclare abstract data types. It is worth noting that Russo makes an \nexception for types that are de.ned by an algebraic datatype de.nition. If a type is forward-declared \nusing a datatype spec\u00adi.cation, then the body of the recursive module must de.ne the corresponding type \nvia SML s datatype copying construct, e.g., datatype t = datatype X.t. In some sense, though, this is \nthe exception that proves the rule while t in this case is technically an abstract type, the datatype \nspeci.cation of t in the forward declaration signature exposes all of t s data constructors, so t s internal \nrepresentation is all but transparent. Leroy (2003) describes informally a recursive module extension \nthat he implemented for OCaml. To permit abstract type speci.ca\u00adtions in forward declaration signatures, \nhe sketches a typecheck\u00ading algorithm that typechecks different mutually recursive modules under different \ntyping contexts. However, while his algorithm suc\u00adcessfully avoids double vision in certain cases, it \nonly works for type components that are de.ned internally by datatype de.ni\u00adtions. It does not work for \ntypes that are de.ned internally by trans\u00adparent bindings (such as A.t and B.u in our motivating example) \nor for types that are de.ned under more than one level of opaque signature ascription. Moreover, there \nremains no formal account of his algorithm. Nakata and Garrigue (2006) propose a recursive module exten\u00adsion \nto ML, called Traviata, that is signi.cantly different from other proposals in that it does not require \nrecursive modules to have any forward declaration at all. Nevertheless, as the authors freely admit, \ntheir approach still suffers from the double vision problem. (In fact, as I explain in Section 3.4, some \nof their examples only typecheck because their type system suffers from the double vision problem.) The \nauthors mention the existence of a workaround by which the programmer may manually coerce values from \none double vision of a type component to the other (e.g., from X.A.t to int), but they do not describe \nthis workaround in any detail. In my thesis (Dreyer 2005), I formally de.ned a recursive mod\u00adule extension \nto ML, which I implemented in the TILT compiler. My typechecking algorithm was an attempt to generalize \nthe ap\u00adproach taken by Leroy s OCaml extension into a more complete solution to the double vision problem. \nFigure 1 does not typecheck under my TILT extension, but only because my semantics for re\u00adcursively dependent \nsignatures was overly restrictive and did not permit one to write the signature S in its .bered form. \nA slight variant of this example using an un.bered forward declaration signature does typecheck in TILT. \nNevertheless, since my thesis does not contain a clean type\u00adtheoretic account of the double vision problem, \nthe formalization of my TILT extension is extremely long and complex. It employs a variety of ad hoc \ntricks, such as meta-signatures containing both public and private interfaces for subcomponents, and \ninference rules that make critical use of graphical boxes drawn around chunks of the typing context. \nIn short, while my TILT extension success\u00adfully avoids the double vision problem (as far as I know), \nits for\u00admalization is incomprehensible. The desire for a simpler solution was the primary motivation \nfor my work on the RTG type system. 2.3 The RTG Type System In traditional accounts of data abstraction, \nincluding both existen\u00adtial types (Mitchell and Plotkin 1988) and ML-style module sys\u00adtems (MacQueen \n1984), one can only create a new abstract type name if one supplies a de.nition along with it. In the \ncontext of recursive modules, this joining together of type creation and type de.nition engenders the \ndouble vision problem by preventing one from providing a de.nition for a pre-existing type name. For \nin\u00adstance, in the case of our motivating example, double vision arises because module A wants to de.ne \nan abstract type t in a scope where a name for that type X.A.t already exists. The key idea of my RTG \ntype system (Dreyer 2007b) is to separate the gener\u00adation of the name for an abstract type from the de.nition \nof the type, so that a type name may be created and referred to even if its de.nition is not yet available. \nThis approach is best illustrated by example. Consider Figure 2, which demonstrates how the motivating \nexample from Figure 1 would be encoded in RTG. (Actually, the encoding is in a variant of RTG that includes \na primitive module system. This variant is de\u00ad.ned formally in the companion technical report (Dreyer \n2007a).) Here, S is the RTG representation of the forward declaration signature S from Figure 1. The \nkey difference is that the type com\u00adponents A.t and B.u of S are not abstract like those of S rather, \ntheir speci.cations, written as [[= a : T]] and [[= \u00df : T]] , denote that they are transparently equal \nto the free type variables a and \u00df. These type variables are created and bound, before the recursive \nmodule AB is de.ned, by invoking a new construct. Since this new new a. T,\u00df. T in let AB= rec (X: S) \n[A =def a := int in [u = \u00df, t =int, f =..., ...] : SA, B = def \u00df := bool in [t = a, u =bool, g =..., \n...] : SB] in (* rest of program *) where def SA =[[u :[[=\u00df:T]],t :[[=a:T]],f :[[a. \u00df\u00d7 a]],...]] def \nSB =[[t :[[=a:T]],u :[[=\u00df:T]],g :[[a. \u00df\u00d7 a]],...]] def S =[[A :SA ,B :SB ]] Figure 2. Encoding of Figure \n1 in a Variant of RTG construct does not actually supply a de.nition for aand \u00df,they are considered unde.ned, \nand are marked as such in the type context during typechecking using an . binding. In the recursive module \nbody, the uses of opaque signature ascription (aka sealing) have been replaced by RTG s own sealing construct, \ncalled the def construct.1 For A, what this def construct does is to provide the type name a with the \nde.nition int,but to only make that de.nition visible within the body of the def. Within A s de.nition, \na is considered equivalent to int, and thus X.A.t is also considered equivalent to int since X.A.t is \ntransparently equal to a. This is the key to solving the double vision problem. Upon leaving the scope \nof A s de.nition, however, the identity of a is returned to its abstract state, and A is added to the \ncontext with signature SA. In addition, so that no subsequent code may attempt to rede.ne a a critical \ncondition for type soundness the context binding for a is changed from a. T to a. T. The typechecking \nof B proceeds similarly. In short, RTG provides a simple way of typechecking different parts of the recursive \nmodule de.nition under typing contexts that expose different privileged information concerning the identities \nof X.A.t and X.B.u. This corresponds to the programmer s natural intuition about how a recursive module \nshould be typechecked.  3. An Informal Overview of RMC Typechecking In this section, I explain what \nis involved in scaling the ideas and techniques of the RTG type system from the level of a System\u00adF-style \ncore calculus to the level of an ML-style module system. I begin in Section 3.1 with a simple informal \nexplanation of how recursive modules and sealed modules (the two main language features on display in \nour running example) are typechecked. Then, in the following sections, I explore some of the interesting \ndesign questions that arise when one goes to work out the details. Along the way, I test the reader s \nunderstanding of the exposi\u00adtion by offering some simple exercises concerning RMC semantics. I strongly \nencourage the reader to attempt the exercises or, fail\u00ading that, to cheat by looking ahead to the detailed \nsolutions given at the end of the paper because the exercises (and their solutions) help to illuminate \na number of subtle aspects of RMC semantics. 3.1 Typechecking Recursive and Sealed Modules Intuitively, \nthe basic goal of the RMC type system is to typecheck an RMC program such as the example in Figure 1 \nas if it were the RTG program in Figure 2. To understand how this is achieved, let us consider the major \nways in which Figure 2 differs from Figure 1. First of all, the success of RTG is based on its built-in \nfunc\u00adtionality for forward declaration of abstract types. Concretely, the 1 In (Dreyer 2007b) this is \ncalled the set construct. typechecking of an RTG expression is done under the assumption that the names \nof the abstract types the expression wants to de.ne have already been created and are bound as unde.ned \n(.) in the typ\u00ading context. The RMC type system relies on a similar functionality. In the case of our \nmotivating example, we will assume that when we are typechecking the module AB, there exist two type \nvariables a and \u00df, which will represent AB.A.t and AB.B.u, respectively, and which are bound in the initial \ncontext of AB as unde.ned.2 The names of these type variables are arbitrary they are purely semantic \nrepresentations of AB s abstract types, i.e., they play an important role in typechecking but are not \nvisible to the RMC pro\u00adgrammer syntactically. Second, the forward declaration signature S in Figure 1 \nis opaque, whereas the forward declaration S in Figure 2 is trans\u00adparent. To transform S into S, we need \nto reify the speci.cations of S s opaque type components to be transparently equal to their de.nitions \nin the recursive module body. Under ordinary module type systems this would be dif.cult, since the recursive \nmodule body can (and, in the case of module AB, does) withhold the def\u00adinitions of those components by \nde.ning them abstractly. How\u00adever, under the RMC type system this is not an issue, since we have arranged \nfor those components to be named ahead of time. For AB, the de.nitions of A.t and B.u are simply a and \n\u00df (the unde.ned type variables bound in the context). Correspondingly, S is morally equivalent3 to S \n.lled in with those de.nitions, i.e., S where type A.t = a and type B.u = \u00df. *** Exercise #1: Suppose \nthat our example were modi.ed so that the de.nition of module B were not sealed. What transparent signature \nwould S be transformed to in that case, and consequently what effect would this have on the typechecking \nof the recursive module? *** Third, sealed modules (such as AB.A and AB.B) in Figure 1 be\u00adcome def expressions \nin Figure 2. In order to typecheck a sealed module as if it were a def expression, we .rst compute a \ntype sub\u00adstitution d, mapping the names of the abstract types that the module will de.ne to their de.nitions \nin the module body (underneath the sealing). For example, for AB.A, the computed d would map a to int,and \nfor AB.B, the computed d would map \u00df to bool.This substitution is then applied to the typing context \nbefore typecheck\u00ading the module body. Thus, when typechecking the body of AB.A, all references to ain \nthe signature of X are replaced by int;when typechecking the body of AB.B, all references to \u00df in the \nsigna\u00adture of X are replaced by bool. In this way, each module s secret knowledge of certain type components \nis re.ected in the context under which it is typechecked. To summarize, and also to number the steps \nof typechecking for convenient reference later in the paper, here is how an RMC recursive module of the \nform rec (X:sig)mod is typechecked: 1. Assuming X has signature sig, compute the type components of mod, \nand use these to look up the de.nitions of the type components that are speci.ed opaquely in sig. 2. \nUse the information from the previous step to construct a trans\u00adparent forward declaration S, which is \njust sig with its opaque type components rei.ed with their de.nitions from mod. 3. After rebinding Xin \nthe context with S, typecheck mod. 4. Check that mod s signature matches (is coercible to) S.  2 Arranging \nfor these variables to magically appear in the context in the right number and with the right kinds is \nnot a problem. (See Section 4.5.) 3 Isay morally equivalent because S is a semantic signature, not a \nsyntactic RMC signature, but this is largely a technical point. The distinction between syntactic and \nsemantic signatures is explained in Section 4. The typechecking of an opaquely sealed module, mod :> \nsig, proceeds as follows: 1. For each of the type components speci.ed opaquely in sig, there should be \nan abstract type variable a bound as unde.ned in the context (with the appropriate kind). 2. Compute \nthe type components of mod, and use these to de\u00adtermine a substitution d that maps the unde.ned type \nvariables from the .rst step to their de.nitions in mod. 3. After applying d to the typing context, \ntypecheck mod. 4. Check that mod s signature matches (is coercible to) sig.  *** Exercise #2: Suppose \nthat the following is well-typed in RMC: rec (X : sig structure A : sig end) struct structure A = mod \nend Here, sig is an RMC signature, and mod is an RMC module. Also, assume that neither X nor B appears \nfree in sig. Determine whether or not the above recursive module would continue to be well-typed if its \nbody (structure A = mod) were replaced with: (a). structure A :> sig = mod (b). structure B :> sig = \nmod; structure A = B (c). structure B = mod; structure A :> sig =B 3.2 Forward Declarations, Not Signature \nAscriptions One design point on which existing recursive module proposals differ is the question of whether \nthe forward declaration signature in a recursive module de.nition should also serve as the exported signature \nof the recursive module itself. In Crary et al. s foundational type system, recursive modules are modeled \nas .xed-points at the level of modules. According to this interpretation, rec (X : sig) mod has signature \nsig, as long as mod has sig under the assumption that X has sig. Although Crary et al. s is the only \nproposal to treat recursive modules explicitly as .xed\u00adpoints,4 several other proposals, including Leroy \ns and the one in my thesis, follow suit in treating the forward declaration sig as the principal exported \nsignature of the recursive module itself. In contrast, Russo s extension to Moscow ML treats sig merely \nas a forward declaration, not as a sealing signature. In other words, it allows the recursive module \nto export components that appear in mod but are not forward-declared in sig. I believe that Russo s approach \nis a clear win, and RMC adopts it. If the author of a recursive module wishes to seal the body of the \nrecursive module with the forward declaration signature, it is very easy to do so explicitly, e.g., by \nwriting rec (X : sig)(mod :> sig). Moreover, if a recursive module is only slightly recursive e.g., if \nthere is only one value component f, say, that needs to be referred to recursively through the recursive \nmodule variable X then Russo s approach only requires one to specify the type of that one component f \nin the forward declaration signature. There is no need to forward-declare components of the module that \nwill not be referred to recursively. *** Exercise #3: In the example in Figure 1, is it necessary to \nuse a recursively dependent signature to de.ne S? Is there a simpler signature that could be used as \na forward declaration, without effecting any changes to the exported signature of AB? 4 Most other proposals \nemploy a Scheme-style backpatching semantics for module-level recursion, as does the present one. One \nexception is the pro\u00adposal of Nakata and Garrigue (2006), which uses a call-by-name semantics for modules. \n 3.3 Computing the Type Components of a Module A central step in both typing rules described above is \nthe one in which we compute the type components of the underlying module mod. I will refer to this phase \nas the static typechecking of mod. In an earlier version of the RMC system (Dreyer 2006), which I discuss \nin Section 5.1, this static typechecking pass was formalized using a completely different set of rules \nfrom the regular module typing judgment, and I found that this made the language de.nition seem somewhat \nad hoc and confusing. (It is a similar problem that plagues the typechecking algorithm in my thesis (Dreyer \n2005).) As a result, I have sought to develop a more declarative ac\u00adcount of module typechecking. In \nparticular, my initial idea was that the static typechecking steps could consist merely of nondeter\u00administically \nguessing the type components of mod. For example, in typechecking the sealed de.nition of AB.A from Figure \n1, one might simply guess that the type t was de.ned internally as int. That one had guessed correctly \ncould be veri.ed after the fact by making sure that the underlying module matched a signature with t \ntransparently equal to int. In practice, one would of course need to supply a deterministic algorithm \nin order to perform the guessing, but the declarative de.nition of the type system would not need to \nspecify the gory details of this algorithm. Unfortunately, this idea does not seem to work, and it is \ninstruc\u00adtive to see why. First, consider the following example: rec (X : sig type t end) struct type \nt = X.t end We run into trouble here if we try to nondeterministically guess the de.nition of t in the \nrecursive module body. If we guess that t is int, and we typecheck the body under a context where X has \nthe signature sig type t = int end asdemandedbystep 3 of the recursive module typing rule described above \nwe .nd that the body has the same signature. However, if we guess that t is bool, the module still typechecks, \nbut this time with signature sig type t = bool end. Hence, we lose the property that mod\u00adules have principal \nsignatures. In short, the problem is that the recursive de.nition of the type t in this example is non-contractive, \ni.e., there are in.nitely many ways to solve it. Ideally, we would like to demand that the de.ni\u00adtions \nof the type components be contractive. But this demand is a catch-22: we cannot even state it unless \nwe have already computed the de.nitions of the type components, which is precisely what we were trying \nto avoid doing by nondeterministically guessing them. A seemingly simple .x is to require that when we \nguess the type components of a module, the guess we make is the unique guess that enables typechecking \nto succeed. Such a restriction would ban\u00adish the above example from consideration. However, this modi.ed \napproach causes a different kind of trouble. Consider this second example: rec (X : sig type a t end) \nstruct type a t= a X.t val n :int t= 3 val b :bool t =true end In this example, although the type constructor \nt is de.ned in the same non-contractive way as before, there is a unique solution for it so that the \nwhole recursive module typechecks. Speci.cally, the type annotations on n and b constrain the de.nition \nof t to be the identity function, .a.a. Figuring this out requires a form of higher\u00adorder uni.cation, \nwhich in general is undecidable (Goldfarb 1981). These types of examples have led me to abandon the idea \nof guessing the type components of a module nondeterministically. Fortunately, I have found a way to \ncompute the type components of a module (deterministically) that does not complicate the lan\u00adguage de.nition \nwith a whole set of extra rules. The basic idea is that the inference rules that implement static typechecking \nare the same as those for normal typechecking, except with some of the premises such as the ones concerning \nvalue components of modules removed. As a result, it is only necessary to write down one set of inference \nrules for both the regular and static module typechecking judgments. I leave further discussion of this \ntech\u00adnique until Section 4.4. In both of the problematic examples presented in this section, the RMC \nstatic typechecking judgment would successfully com\u00adpute the type component t in the body of the recursive \nmodule to equal X.t. Whether such a cyclic type de.nition is considered ac\u00adceptable is then a separate \nquestion, examined in the next section. *** Exercise #4: Can you come up with a variant of the second \nprob\u00adlematic example above that achieves the same effect i.e., there is a unique way of guessing X.t \ncorrectly, and .guring it out involves higher-order uni.cation but where the module in your variant only \nhas type components, no value components? 3.4 Cyclic Type De.nitions Recursive modules provide a natural \nmeans of writing down cyclic type de.nitions that span module boundaries. However, existing recursive \nmodule proposals differ on what kinds of cyclic type de.nitions they consider permissible. One approach \nis to allow transparent type cycles, i.e., type com\u00adponents that are de.ned transparently in terms of \nthemselves, such as type t= int *X.t. This is the approach taken by Crary et al. (1999), but it requires \nthem to extend their type theory with support for so-called equi-recursive type constructors of higher \nkind.5 The meta-theory of higher-kinded equi-recursive type con\u00adstructors is not well-understood (in \nparticular, it is not known whether type equivalence in their presence is decidable). A more restrictive \napproach is the one taken by Leroy (2003) and Nakata and Garrigue (2006), who permit cycles between trans\u00adparent \ntype de.nitions, but only if they are intercepted by the use of opaque sealing. For instance, suppose \nwe were to modify the example in Figure 1 so that internally A.t were de.ned to equal int * X.A.t. The \nresulting cyclic de.nition would be permissi\u00adble in OCaml and Traviata because the type cycle is broken \nby the use of opaque sealing in the de.nition of module A. However, the ability to express such recursive \ntype de.nitions in these languages is intricately tied to their failure to handle double vision. For \nexample, if these languages were to solve the double vision problem, then in the de.nition of module \nA, the type X.A.t would be seen as transparently equal to int * X.A.t. This would constitute an unbroken \ntransparent type cycle, which OCaml and Traviata treat as illegal. In the interest of adopting a simple \npolicy concerning type cy\u00adcles that is compatible with solving double vision, my design for RMC follows \nRTG in requiring that all type cycles go through at least one component that is de.ned by a datatype \ndeclaration. That is, even if all uses of opaque sealing are stripped away, there must still be no transparent \ntype cycles. This policy has the ad\u00advantage that recursive modules do not introduce any new forms of \n(equi-)recursive type de.nitions that are not already expressible in the underlying core language of \nML they just provide the ability to decompose ML s existing forms of recursive type de.nitions into modular \ncomponents. That said, one consequence of following RTG is that the type\u00adchecking of certain constructs \nin RMC is somewhat conservative. 5 Crary et al. coined the term equi-recursive to describe recursive \ntypes whose equational theory follows the style of Amadio and Cardelli (1993). Speci.cally, in order \nto ensure that no transparent type cycles arise in the presence of data abstraction, (1) the internal \nde.nitions of abstract types in a sealed module are not allowed to depend on any type variables bound \nas unde.ned (.) in the context, and (2) in functor applications, the type components of the argument \nmod\u00adule may not depend on any type variables bound as unde.ned (.) in the context. (These restrictions \nare derived directly from similar restrictions in RTG, and I refer the reader to (Dreyer 2007b) for de\u00adtailed \ndiscussion.) Nevertheless, as demonstrated in the RTG paper, this approach is suf.cient to typecheck \ncommon uses of sealing and functors in recursive modules e.g., Okasaki s bootstrapped heap example (Okasaki \n1998). I am currently investigating ways to relax this restriction by generalizing RTG s treatment of \ntype cycles. Finally, it is important to mention how RMC de.nes and de\u00adtects a transparent type cycle. \nThe question arises once we have computed the type components of some module, at which point we typically \nneed to use them in order to look up the de.nitions of opaque type components in some signature. RMC \ns policy is that there must be some way of ordering the type components we are looking up so that each \ncomponent s de.nition only depends recur\u00adsively on the previous ones in the ordering. For example, consider: \nrec (X : sig type t; type a u end) struct type t = bool X.u type a u= a end This module is well-typed \nin RMC because the components of the module can be named in a certain order (u,then t) so that their \nde.nitions are acyclic t s recursive dependency on X.u is OK because u comes earlier in the ordering. \nIn contrast, consider: rec (X : sig type t; type a u end) struct type t = X.t X.u type a u= a end In \nthis case, the recursive module typing rule rejects the program because the de.nition of t refers cyclically \nto itself (via X.t). It is worth noting that RMC also rejects similar examples where no true transparent \ncycle exists, such as: rec (X : sig type t; type a u end) struct type t = X.t X.u type a u= int end I \ndo not consider this to be a serious limitation. In the above ex\u00adample, it does not seem like a serious \nhardship for the programmer to remove this cyclic dependency by replacing the module s def\u00adinition of \nt with type t =int. Alternatively, the programmer could make the type de.nition type a u= int explicit \nin the forward declaration signature, in which case the static typecheck\u00ading step would be able to determine \nthat the de.nition of t in the body normalizes to int. *** Exercise #5: The example in Figure 1 clearly \ndoes not have any type cycles. What would happen, however, if we changed it in any of the following ways? \nWould the RMC type system accept it or reject it? (a). Change the internal de.nition of A.t to int * \nX.B.u. (b). Change the internal de.nition of B.u to bool * X.A.t. (c). Change the example as described \nin (a), and also remove the sealing in the de.nition of module A. (d). Change the example as described \nin both (b) and (c). 3.5 Recursively Dependent Signatures RMC extends the signature language of ML with \nrecursively de\u00adpendent signatures (rds s), which have the form rec (X) sig.Com\u00adpared with typechecking \na recursive module, checking the well\u00adformedness of an rds is fairly straightforward. The basic goal \nis to check that the rds does not contain any cyclic transparent type speci.cations, whose presence would \ndemand support for equi\u00adrecursive types.6 While RMC s treatment of rds s is not markedly different from \ntheir treatment in most other proposals, it is worth explaining informally nonetheless. The well-formedness \nchecking of rec (X) sig proceeds as fol\u00adlows. First, we need to come up with some temporary signature \nsig' to which we can bind X during the checking of sig.This tem\u00adporary sig' will act essentially as a \nforward declaration of sig.As such, it need only be a shallow representation of sig it should record \nthe (path-)names and kinds of sig s type components, but may ignore sig s value components, because sig \ncan only possibly refer to the type components of X. In Russo s account of rds s, the programmer is required \nto write down this shallow sig' explicitly, but it is perfectly easy to infer sig' via a syntactic pass \nover sig. Second, after binding X to sig' in the context, we proceed to check the well-formedness of \nsig. Third, we check that there is some linear ordering of the type components of sig such that no transparent \ncomponent s speci.ca\u00adtion depends on a later component in the ordering. This is formal\u00adized in a manner \nvery similar to the detection of transparent type cycles in recursive modules (as described in the previous \nsection). For example, rec (X) sig type t = X.t end will be ill\u00adformed because t is de.ned transparently \nin terms of itself. In con\u00adtrast, the signature S from Figure 1 will typecheck successfully even though \nit contains references to the recursive module variable X in the speci.cations of A.u and B.t because \nthe type compo\u00adnents of the signature can be ordered in such a way that those ref\u00aderences are seen as \nacyclic (i.e., A.t, B.u, A.u, B.t).  4. The RMC Type System 4.1 Syntax Figure 3 gives the syntax of \nRMC. While RMC is intended to be representative of a Standard ML-like module language, it does not directly \nsupport all features of SML. I focus instead on supporting the most semantically interesting features, \nand leave formalization of a full-.edged ML extension to future work. Core Language In the spirit of \nkeeping the core language as un\u00adderdetermined as possible, the only interesting type-and term-level construct \nconsidered here is the path P, which is a module variable X followed by zero or more component projections. \nAs a matter of notation, I will write X.e1...en as shorthand for X.E.e1...en.In particular, X is shorthand \nfor X.E. As in ML, type constructors con either have kind T (the base kind of types) or are functions \nfrom n arguments of kind T to a single result of kind T,where n> 0. For uniformity, in some typing rules \nT0 . T is treated as synonymous with T,and con() as synonymous with con (when con has kind T). I use \nthe overbar syntax to denote a sequence of zero or more objects separated by commas (e.g., con = con1,..., \nconn). Signatures In order to simplify and regularize the syntax of mod\u00adules and signatures, I model \ntype components and value compo\u00adnents as atomic modules. Corresponding to ML s notion of an 6 This is \nin stark contrast to Crary et al. s original proposal for rds s, which requires them to be fully transparent \nspeci.cally so that they can be imple\u00admented internally using equi-recursive types. No subsequent proposal \nhas followed their approach. Type Variables a, \u00df Module Var s X, Y Labels e Label Sequences Paths es \n::= P ::= E | es.e X.es Kinds Type Constr s Terms K, L ::= con ::= exp ::= T | Tn . T (n> 0) P | a | \n.(a).con | con(con) | ... P | ... Signatures sig ::= [ K] | [[con]] | [[e con :K] |[[ec X: sig]] | (X \n: sig1) . sig2 |rec (X) sig | sig where es = con Modules mod ::= [con] | [exp] | [e con :K] |[ec X= \nmod] | P |let X= mod1 in mod2 |.(X : sig).mod | P1(P2) |rec (X : sig) mod |mod :> sig | mod : sig def \n [[= con :K] =[[K] where E = con def mod1(mod2)= let X1 = mod1 in let X2 = mod2 in X1(X2) Figure 3. RMC \nSyntax opaque type speci.cation, [[K] denotes the signature of an atomic module containing a single type \ncomponent of kind K. While there is no primitive signature corresponding to a transparent type spec\u00adi.cation, \nRMC does support ML s where type (or with type) construct (abbreviated here as where), and Figure 3 shows \nhow to de.ne the transparent type signature [[= con :K] as a derived form. (This is how the De.nition \nof SML de.nes transparent type speci\u00ad.cations as well (Milner et al. 1997).) The signatures of RMC structures \nhave the form [[ec X: sig]]. As in ML, these structure signatures are dependently-typed, with each internal \nname Xi bound in the subsequent sigj s. The reason for distinguishing between external labels e (which \nare immutable) and internal variables X (which are a-convertible) is explained by Harper and Lillibridge \n(1994). Although SML does not make such a syntactic distinction, I maintain it here in order to simplify \nthe presentation of typechecking. I also assume for simplicity that all the labels e and variables X \nare distinct. The signature [[e con :K] represents a non-recursive SML datatype speci.cation. It describes \na module providing a type component e of kind K that is isomorphic to con. (Following the style of Harper \nand Stone (2000), this isomorphism is witnessed via two value components a data constructor called in \nand a data destructor called out that the module also provides.) The modeling of recursive datatype speci.cations \nis achieved by using the datatype signature [[e con :K] in conjunction with a recursively dependent \nsignature (rds), written rec (X) sig.For example, if we were to add unit, sum, and product types to the \nlanguage, we could model the SML datatype declaration datatype a list = Nil | Cons of a * a list as rec \n(X) [ list .(a).1+ a \u00d7 X.list(a): T . T]] To be able to use such a datatype, of course, the term language \nneeds a mechanism for data constructor application, as well as data destructor application (pattern matching). \nFor space reasons, I omit Type Constructors A, B,t ::= a |b |.(a).t |A(t) Base Types b ::= .[a].t1 .t2 \n|... Signatures S ::= [[= A : K]] |[[t ]] |[[e :S] |.(a1 .K1).(L1;S1) ..(a2 .K2).(L2;S2) Type Locators \nL::= {a :K .es}Type Substitutions d ::= {a .A}Type Contexts . ::= \u00d8|.,a .K |.,a .K Module Contexts G \n::= \u00d8|G, X:S def .(.) = {a |a .K ..} def .@ a . =.\\{a ..(a) |a .a}.{a ..(a) |a .a} e.L def = {a :K .e.es \n|a :K .es .L} 8 S if es = E S.es def = > < > S ' if es = es ' .e and S.es ' =[[. ..,e :S ' ,...]] : unde.ned \notherwise Figure 4. Semantic Objects and Auxiliary Constructs this feature, as the details would closely \nfollow Harper and Stone (2000) and are orthogonal to the focus of the present work. Lastly, functor signatures \nare denoted (X : sig1) .sig2. Here, sig1 is the argument signature, and sig2 is the result signature, \nwhich may refer to type components of the argument via X. Modules [con] and [exp] are the atomic modules \nrepresenting type and value components, respectively. The syntax of structures parallels that of their \nsignatures, but structure projection (as in SML) is limited to paths. We include a module-level let construct \nwith semantics similar to SML s local mechanism. Functors are modeled as .-abstractions, and, for simplicity, \nfunctor application is limited to applications of paths to paths. Figure 3 de.nes syntac\u00adtic sugar for \ngeneral applications of the form mod1(mod2). The syntax for datatype modules parallels that of datatype \nsignatures. Recursive datatype s are encodable using a com\u00adbination of datatype modules and recursive \nmodules, written rec (X : sig) mod. For instance, to implement the list datatype (above), we can write: \nrec (X: [ list :[[T .T]]]]) [list .(a).1+ a \u00d7X.list(a): T .T] Lastly, RMC provides two sealing constructs \nopaque sealing, written mod :> sig,and transparent sealing, written mod : sig which model the corresponding \nconstructs in SML. Transparent sealing has the effect of narrowing mod to the target signature sig, but \nallows the identity of mod s type components to leak through, even if they are speci.ed opaquely in sig. \n 4.2 Semantic Objects Following the De.nition of SML, the static semantics of RMC employs a language \nof semantic objects, whose syntax appears in Figure 4. As it turns out, these semantic objects are really \njust types/signatures (in an internal type system) that have been dec\u00adorated with some meta-data that \nis useful during typechecking. That internal type system is de.ned in the companion technical report \n(Dreyer 2007a), but the static semantics of RMC can be un\u00adderstood perfectly well without it. Semantic \ntypes are similar to RMC types. The only difference is that semantic types include a base type .[a].t1 \n.t2,which represents the type of datatype constructors and destructors. We assume and maintain the invariant \nthat all types are kept in \u00df-normal form. Semantic signatures are very similar to those in Russo s the\u00adsis \n(Russo 1998), which is based closely on the style of the De.ni\u00adtion. In short, semantic signatures are \nfully transparent signatures. Data abstraction is handled separately via universal and existential quanti.cation \nover type variables as evidenced in the semantic functor signature instead of via opaque type speci.cations \nin sig\u00adnatures. Type locators Lare mappings from type variables to label se\u00adquences. The purpose of type \nlocators is discussed below. Type substitutions d map type variables to type constructors. In order to \nmaintain the invariant that types are kept in normal form, type substitutions are assumed to implicitly \n\u00df-normalize when they are applied. Regarding notation: Let FV(d) mean the free variables of the type \nconstructors in the range of d. Also, if L= {a :K . es}is a type locator, then dLmeans {da :K . .es} \nType contexts . bind type variables as either unde.ned (.)or de.ned (.). Module contexts G bind module \nvariables X to seman\u00adtic signatures S. The notation .(.) denotes the set of unde.ned type variables in \n., and the notation .@ a .signi.es the result of changing the bindings of a in . from unde.ned to de.ned. \n 4.3 Interpretation of Signatures Figure 5 shows how RMC type constructors and signatures are interpreted \nin terms of their semantic counterparts. The interpretation of type constructors is straightforward. \nThe only interesting point is that, when interpreting a type projected from a module X, we eliminate \nthe dependency on the module variable X. (Semantic types only depend on type variables in ..) RMC signatures \nare interpreted as signature denotations of the form .(a .K).(L;S). Here, a .K represent the opaque type \ncom\u00adponents of the signature, and S represents the signature itself (with transparent references to a). \nThe type locator Lis a mapping from each of the variables in a to a label sequence es that indicates \nwhich type component of S was the source of that abstract type in the original RMC signature. For example, \nthe signature S from Figure 1 is interpreted as .(a .T,\u00df .T).({a : T .A.t,\u00df : T .B.u};S) where S is as \nde.ned in Figure 2. (Note that a and \u00df are bound variables of the denotation.) This approach to signature \ninterpreta\u00adtion is modeled closely after Russo (1998). The main novelty is the presence of the type locator \nL. The reason for Lis that it makes the de.nition of signature matching (see below) more deterministic \nby telling the elaborator explicitly where to look in order to .ll in the opaque type components of a \nsignature. The interpretation rules for signatures are standard with the ex\u00adception of Rule 13 for rds \ns, which follows closely the informal description given in Section 3.5. The .rst premise of the rule \ncom\u00adputes a shallow denotation of sig, .(a0 .K0).(L0;S0),inwhich all its type components are treated \nas having opaque speci.ca\u00adtions and its value components are ignored. Given this signature for X, the \nsecond premise computes the actual denotation of sig: .(a .K).(L;S). These two premises set up a system \nof equations between the temporary variables a0 which were created to rep\u00adresent the type components \nof X and their de.nitions in S. To solve this system of equations, the third premise uses the lookup \njudgment de.ned in Figure 6, which in turn uses the type locator L0 to look up the de.nitions of the \na0 in S and return a type substitution d that solves for them. If there is a transparent type cycle among \nthe de.nitions, the lookup will fail. The detection of cycles is implemented as described in Section \n3.4.  Well-formed type constructors: .; G fcon r A:K .; G fP:[[=A:K]] .,a.T;G fcon r t : T a= a1,...,a \n. fa : T n (1) (2) (3) .; G far a : T .; G fP r A:K .;G f.(a).con r .(a).t : Tn .T .; G fcon ' r .(a).t \n' : Tn .T .; G fcon r t : T t = t1,...,tn (4) .t}t ' .; G fcon ' (con) r {a : T ...Insert rules for \nyour favorite base types here. . . Well-formed terms: .; G fexp : t .; G fP: [ t]] (5) .; G fP: t ...Insert \nrules for your favorite core language here. . . Well-formed signatures: .; G fsig r .(a.K).(L;S) .; \nG fcon r t : T (6) (7) .; G f[[K] r .(a.K).({a:K. E};[[= a:K] ) .;G f[[con]] r .().(\u00d8;[[t]]) K= Tn .T \n.; G fcon r A:K \u00df = \u00df1,...,\u00dfn (8) .; G f[[e con :K] r .(a.K).({a:K. e};[[e:[[= a:K] ,in :[[.[\u00df].A(\u00df) \n.a(\u00df)]],out :[[.[\u00df].a(\u00df) .A(\u00df)]]] ) .; G fsig1 r .(a1 .K1).(L1;S1) .,a1 .K1;G,X1 :S1 f[[ecX: sig]] r \n.(a.K).(L;[[e:S] ) (10)(9) .; G f[[]] r .().(\u00d8; [[]]) .; G f[[e1 cX1 : sig1,ecX: sig]] r .(a1 .K1,a.K).(e1.L1,L;[[e1 \n:S1,e:S] ) .; G fsig1 r .(a1 .K1).(L1;S1).,a1 .K1;G,X:S1 fsig2 r .(a2 .K2).(L2;S2) (11) .; G f(X : \nsig1) .sig2 r .().(\u00d8; .(a1 .K1).(L1;S1) ..(a2 .K2).(L2;S2)) .; G fsig r .(a.K).(L;S) a.K= a1 .K1,\u00df.L,a2 \n.K2 .; G fcon r B:L \u00df:L.es.L (12) .; G fsig where es= con r .(a1 .K1,a2 .K2).(L\\{\u00df:L.es}; {\u00df .B}S) \n .; G fShal(sig) r .(a0 .K0).(L0;S0) .,a0 .K0;G,X:S0 fsig r .(a.K).(L;S) flookup L0 in S r d (13) .; \nG frec (X) sig r .(a.K).(L; dS) Shallow version of a signature: Shal(sig) def Shal([[K] ) =[[K] def \ndef Shal((X : sig1) .sig2) =[[] Shal([[con]]) =[[] def def Shal(rec (X) sig)= Shal(sig) Shal([[e con \n:K] ) =[[e: [ K]]]] def def Shal(sig where es= con)= Shal(sig) Shal([[ecX: sig]]) =[[e: Shal(sig)]] \nFigure 5. Well-formedness Rules for Type Constructors, Terms, and Signatures 4.4 Static Semantics of \nModules Figure 6 shows the typing rules for modules. The main module typing judgment has the form .; \nG fmod :S with a.. The judg\u00adment assumes that arepresent the abstract types that mod is going to de.ne, \nand thus they are bound as unde.ned (a.K) in the input context .. The shaded premises in some of the \nrules mark the delta between the regular typing judgment and the static typing judg\u00adment, which we discuss \nbelow. In particular, static typechecking is de.ned by simply removing the shaded premises and replacing \nall references to the regular typing judgment with the static one. To begin with, let us focus on ordinary \nmodule typing. Rules 14 through 16 for paths and atomic modules are straightforward. Rule 17 for datatype \nmodules [e con :K] returns a signature that matches the interpretation of the corresponding datatype \nsignature [[e con :K] . The typing rules for structures (Rules 18 and 19) are self\u00adexplanatory. One point \nof note is that, after the .rst binding of a structure (e1 cX1 = mod1 in Rule 19) has been typechecked, \nthe remainder of the bindings are typechecked in a context where the abstract types de.ned by mod1 are \nbound as de.ned (namely, .@ a1 .). To see an instance where this is relevant, look at the solution to \nExercise #5(b) given at the end of the paper. The typechecking of module-level let (Rule 20) is essentially \nthe same as the typechecking of a structure with two bindings. The only difference is that the result \nsignature of the let only exports the second of the bindings. Rule 21 for functors is fairly straightforward \nas well. It is worth noting that in the signature returned for the functor, there is no type locator \nL2 for the result (we just write \u00d8). The main reason is that, due to the so-called avoidance problem, \na type locator does  Well-formed modules: .; G fmod :S with a. We omit with a. if a= \u00d8(i.e., if mod \ndoes not de.ne any abstract types). . ft : T.; G fcon r A:KX:S .G  (16)(14) (15) .; G fX.es :S.es .; \nG f[con]:[[=A:K]] .;G f[exp]: [ t]] K= Tn .T .; G fcon r A:K \u00df = \u00df1,...,\u00dfn a.K .. (17) .; G f[e con :K]: \n[ e:[[= a:K] ,in :[[.[\u00df].A(\u00df) .a(\u00df)]],out :[[.[\u00df].a(\u00df) .A(\u00df)]]] with a. .; G fmod1 :S1 with a1 . .@ a1 \n.;G,X1 :S1 f[ecX= mod]: [ e:S] with a2 . (18) (19) .; G f[]:[[] .;G f[e1 cX1 = mod1,ecX= mod]:[[e1 :S1,e:S] \nwith a1,a2 . .; G fmod1 :S1 with a1 . .@ a1 .;G,X:S1 fmod2 :S2 with a2 . (20) .; G flet X= mod1 in mod2 \n:S2 with a1,a2 . .; G fsig r .(a1 .K1).(L1;S1).,a1 .K1,a2 .K2;G,X:S1 fmod :S2 with a2 . (21) .; G f.(X \n: sig).mod : .(a1 .K1).(L1;S1) ..(a2 .K2).(\u00d8;S2) .; G fP1 : .(a1 .K1).(L1;S1) ..(a2 .K2).(L2;S2) .;G \nfP2 :S a.K2 .. flookup L1 in S r d FV(d) n.(.) = \u00d8fS .dS1 (22) .; G fP1(P2): d{a2 .a}S2 with a. .; G \nfsig r .(a.K).(L;S) .,a.K; G,X:S fstat mod :Sstat with \u00df. flookup Lin Sstat r d .; G,X: dS fmod :S ' \nwith \u00df. fS ' .dS (23) .; G frec (X : sig) mod :S ' with \u00df. .; G fsig r .(a0 .K0).(L0;S0) .=. ' ,a.K0 \n(L;S) = {a0 .a}(L0;S0) (24) .; G fmod :> sig :S with a. .; G fsig r .(a.K).(L;S) .;G fmod :S ' with \n\u00df.flookup Lin S ' r d fS ' .dS (25) .; G fmod : sig : dS with \u00df. Statically well-formed modules: .; \nG fstat mod :S with a. The rules de.ning this static judgment are precisely the same as the rules de.ning \nthe regular module typing judgment (above), except with the shaded premises removed, and all occurrences \nof the regular module typing judgment replaced by this static judgment. Signature matching: fS1 .S2 \n S ' fS ' fS ' =[[e:S] .e1 .S1 .[[e:S] (26) (27) (28) fS .S fS ' .[[]] fS ' .[[e1 :S1,e:S] ' fd1S ' \nflookup L1 in S1 r d1 fS1 .d1S ' 1 flookup L2 in d1S ' 2 r d22 .d2S2 (29) '' f.(a .K ' ).(L1' ;S ' 1) \n..(a .K ' ).(L2' ;S ' 2) ..(a1 .K1).(L1;S1) ..(a2 .K2).(L2;S2) 1122  Abstract type lookup: flookup Lin \nS r d L= {a1 :K1 .es1,...,an :Kn .esn} d0 = \u00d8 .i .1..n :S.esi =[[= Ai :Ki]] FV(Ai) ndom(L) .{a1,...,ai-1} \ndi = di-1 .{ai .di-1Ai} (30) flookup Lin S r dn Figure 6. Typing Rules for Modules not necessarily exist \n(Harper and Lillibridge 1994). In particular, it may be that some of the abstract types in a2 do not \ncorrespond to any type component speci.ed in S2, so there is no way to locate them. Fortunately, there \nis no need to locate them a signature only needs a type locator if one is going to match against it, \nwhich is not the case for the result signature S2. In general, we only need to match against signatures \nthat correspond to RMC signatures that the programmer wrote down, and such signatures always have type \nlocators (the signature interpretation judgment shows how to compute them). The typing rule for functor \napplications (Rule 22) .rst uses L1 to look up the de.nitions of a1 in the signature S of the argument \nP2. This results in a substitution d, which maps the abstract type components of P1 s argument signature \nto their appropriate instan\u00adtiations. We then check whether S matches the rei.ed argument signature dS1. \nWe also check that the type variables a we are sup\u00adposed to de.ne have the same kinds K2 as the abstract \ntypes in the result signature of P1. Finally, we check that the types we are us\u00ading to .ll in the de.nitions \nof a1 i.e., FV(d) do not depend on any unde.ned variables. This last condition is necessitated by the \navoidance of transparent type cycles, as explained in Section 3.4. For the next two rules, which concern \nrecursive and opaquely sealed modules, it is useful to refer back to the algorithmic descrip\u00adtions of \nthese rules given in Section 3.1. Beginning with Rule 23: The .rst three premises implement step 1 of \nthe algorithmic de\u00adscription, resulting in a type substitution d that maps the abstract type components \nof sig to their de.nitions in mod. Note that the computation of the type components of mod is achieved \nby a call to the static typechecking judgment. Step 2 of the algorithm is achieved by simply applying \nd to S. Steps 3 and 4 correspond to the remaining two premises, respectively. Rule 24 for opaque sealing \nmatches the earlier algorithmic description as follows: The .rst three premises implement step 1, the \nnext two premises implement step 2, and the last two premises implement steps 3 and 4, respectively. \nThe side condition on FV(d) requires that the internal de.nitions of the abstract types a not depend \non any unde.ned types. The reason for this side condition is explained in Section 3.4. Lastly, note that \nRule 24 allows the module mod to internally de.ne a set of local abstract types \u00df. These must be added \nto the context explicitly because they are not in scope outside of the mod\u00adule. In contrast, the typing \nrule for transparent sealing (Rule 25) assumes that the \u00df that mod wants to de.ne are already bound in \nthe ambient context .. Indeed, it is important that \u00df are bound in . since they may appear free in the \nresulting signature dS.The key difference between opaque and transparent sealing is that the for\u00admer \nleaves the opaque type components of sig abstract, while the latter uses d to reify the speci.cations \nof those components with their de.nitions in mod. Static Typechecking The static typechecking judgment \nis written .; G fstat mod :S with a .. Static typechecking is formalized using the same rules as regular \nmodule typechecking, except that we ignore the shaded premises. This technique underscores the semantic \ncoherence of the two typing judgments. The purpose of static typechecking is not to ensure that mod is \nwell-typed it is merely to compute mod s type components. In fact, the value components of mod are not \nnecessarily well-typed, and the types for those value components that appear in the result signature \nS may be garbage. This is .ne all that matters are the type components of mod, which will be re.ected \ncorrectly in S. This point is driven home by the .rst rule with a shaded premise: Rule 16, the rule for \natomic term modules. With the second premise removed, the static version of this rule may assign an arbitrary \ntype to the term exp. This renders the static Rule 16 nondeterministic, but only in a way that doesn \nt matter because the nondeterminism concerns the type of a value component. In practice, for example, \nwhen implementing static typechecking, we can infer the type int for all core terms, and still have a \ncomplete typechecker.    The shaded premises in the other rules are conditions that are relevant to \ntype-correctness in general, but are not important for computing the type components of a module. In \nparticular, all references to the signature matching judgment f S1 . S2 are ignored during static typechecking \nbecause this judgment is useless in computing type components. The side conditions on FV(d) are similarly \nignored. The rule with the most shaded premises is Rule 24. The reason is that, in order to determine \nthe type components of an opaquely sealed module mod :> sig, we need only look at the ascribed signa\u00adture \nsig the premises concerning mod are irrelevant. For a trans\u00adparently sealed module, on the other hand, \nwe must look at the module s implementation since its internal type de.nitions leak out. Finally, one \npoint of note: in the static version of Rule 23, it ap\u00adpears that we must statically typecheck mod twice, \nthe second time under a context to which d has been applied. In practice, the second typechecking pass \ncan be avoided by observing that static typing is preserved under type substitution. Thus, under context \nG, X: dS, we know that mod will (statically) have signature dSstat. Signature Matching The signature \nmatching judgment, written f S1 . S2, checks whether S1 can be coerced to S2.The de.nition of this judgment \nin Figure 6 is fairly standard. The rules for structure signatures permit both dropping and reordering \nof components. The rule for functor signatures uses contravariant matching on the arguments and covariant \nmatching on the results. 4.5 Evidence Translation and Type Soundness In order to claim that RMC has \na sound type system, I must supply a dynamic semantics and a type soundness result. Following Harper \nand Stone (2000), I do not provide a dynamic semantics for RMC directly. Instead, I provide an evidence \ntranslation of well-typed RMC modules into an internal language that is based closely on the RTG language \ndiscussed in Section 2.3. This makes it possible to reuse the type soundness result for RTG, and it also \noffers an interpretation of RMC modules in terms of more primitive constructs. Details of the internal \nlanguage, its static and dynamic semantics, and its type soundness are given in the companion technical \nreport (Dreyer 2007a). The evidence translation judgment for modules is simply the module typing judgment \nappended with r M, indicating that the module M is the internal language translation of the given RMC \nmodule. Similarly, the evidence translation for signature matching returns an internal language functor \nF, which coerces the source signature to the target signature. Figure 7 displays two of the most interesting \nevidence transla\u00adtion rules, namely those for recursive and sealed modules. In the rule for recursive \nmodules, the body of the recursive module translates to M, and the functor F represents the coercion \nfrom S ' (the signature of M)to dS (the rei.ed forward declaration signature). The internal language \ntype system does not permit the forward declaration of a recursive module to differ from its export signature. \nThus, in order to encode the more general semantics of RMC modules (as described in Section 3.2), the \ninternal forward declaration Srec includes both S ' and dS. The dynamic semantics of the internal-language \nrecursive module construct implements recursive backpatching in the style of Scheme s letrec. In the \nrule for sealed modules, the module underneath the seal\u00ading translates to M, and the functor F represents \nthe coercion from S ' (the signature of M) to the sealing signature sig. In the evidence translation \nof the sealing, the new construct is used to create the local abstract types \u00df,and the def construct \nis used to de.ne the  .;G fsig r .(a .K).(L;S) .,a .K;G, X:Sfstat mod :Sstat with \u00df . flookup Lin Sstat \nr d .;G, X:dS fmod :S ' with \u00df .r M fS ' .dS r F Srec =[[extern :S ' , intern :dS]] Mrec =[extern c Y={X.Xrec.intern}M, \nintern c Z=F(Y)] .;G frec (X:sig)mod :S ' with \u00df .r (rec (Xrec :Srec)Mrec).extern .;G fsig r .(a0 .K0).(L0;S0) \n.=. ' ,a .K0 (L;S) = {a0 .a}(L0;S0) .,\u00df .L;G fstat mod :Sstat with \u00df .flookup Lin Sstat r d FV(d)n.(.) \n= \u00d8 '' ' . ,\u00df .L;dG fmod :S with \u00df .r M fS .dS r F .;G fmod :> sig :Swith a .r (new \u00df .Lin def a :=da \nin let X=Min F(X):S) Figure 7. Evidence Translation Rules for Recursive and Sealed Modules abstract types \na corresponding to the opaque type components of sig. These are the same new and def constructs on display \nin the encoding from Figure 2.  4.6 Decidability It is also important for practical purposes that the \nRMC type system be decidable. It is mostly straightforward to show this because the typing rules are \nessentially syntax-directed. There are only two points of apparent nondeterminism. One in\u00advolves the \ntypes of value components in the signature returned by the static typechecking judgment. As discussed \nabove, this non\u00addeterminism is irrelevant because these types are never inspected. The other point of \npotential nondeterminism is that in certain typ\u00ading rules speci.cally, Rules 21 and 24 we must guess \na list of abstract types that a module is going to de.ne. In fact, no guess\u00ading is required. It is easy \nto de.ne a simple prepass over a module which will determine the unique number, order, and kinds of the \nabstract types that the module can possibly de.ne. The de.nition of this prepass is omitted for space \nreasons.  5. Related and Future Work Earlier sections of the paper contain detailed comparisons of \nRMC with related work. In this .nal section, I discuss some other related work, and suggest directions \nfor future work. 5.1 Are Forward Declarations a Burden? Most existing recursive module proposals demand \nthat the pro\u00adgrammer supply a forward declaration signature sig when de.n\u00ading a recursive module of the \nform rec (X:sig)mod. The only one that does not is that of Nakata and Garrigue (2006), who ar\u00adgue that \nit is burdensome for the programmer to have to write such signatures down. Instead, the typechecker for \ntheir Traviata lan\u00adguage performs two passes: a reconstruction pass, followed by a type-correctness check. \nThe former traverses the whole program, collecting type information about all program identi.ers, checking \nfor cyclic type de.nitions using a term-rewriting algorithm, and apparently (I believe) giving globally \nunique names to all bound variables. Given this information, the latter pass does relatively or\u00addinary \ntypechecking, although part of its simplicity is due to the fact that it does not address the double \nvision problem. One reason for requiring forward declarations is to make recur\u00adsive module code easier \nto read. But the main argument for forcing the programmer to write down a forward declaration is related \nto the implicit support that recursive modules provide for polymor\u00adphic recursion. For example, consider \nthis recursive module: rec (X : sig val f : a -> a end) struct fun f y = ...X.f(3)...X.f(true)... end \n Here, f may refer to itself recursively via X.f, and each such recur\u00adsive reference may instantiate \nthe polymorphic type variable a dif\u00adferently. In general, type inference in the presence of polymorphic \nrecursion is undecidable (Henglein 1993). Hence, even if a forward declaration signature is not required, \nthe programmer may need to write down a type annotation for any function that can be refer\u00adenced recursively \nthrough X. Indeed, in order for the .rst pass of Nakata and Garrigue s algorithm to collect type information \nabout value bindings in a recursive module before they have been type\u00adchecked, terms are required to \nbe explicitly annotated with their types. This would seem to negate the bene.ts of not requiring a forward \ndeclaration.7 On balance, in the interest of simplicity, I have opted to follow the norm and require \nthe programmer to write down a forward dec\u00adlaration. However, Nakata and Garrigue s complaint about burden\u00ading \nthe programmer with unnecessary annotations remains a rea\u00adsonable one. In a previous version of the RMC \ntype system (Dreyer 2006), I attempted to alleviate this burden using a different tac\u00adtic. Instead of \neliminating forward declarations, I tried to use them to my advantage. In particular, I provided a mechanism, \nwritten seal mod , by which the programmer could opaquely seal a module using the signature for that \nmodule that appeared in the nearest enclosing forward declaration. For instance, in the case of the example \nfrom Figure 1, one would not need to supply explicit signature ascriptions for A and B rather, one would \nsimply seal them and the type system would look to the forward declaration S for the appropriate sealing \nsignatures. In the end, the seal mechanism proved to be more trouble than it was worth. The formalization \nof seal required a novel form of bidirectional typechecking for modules, which, while interesting from \na formal point of view, made the typing rules very tricky to follow. I hope to .nd a simpler way of supporting \nthe seal mechanism within the type system of the present paper. 5.2 Interaction of Recursive Modules \nand Type Inference Formally, the closest relative of RMC is a type system that I devel\u00adoped recently \ntogether with Matthias Blume for a seemingly unre\u00adlated purpose understanding the interaction of ML modules \nand Damas-Milner type inference (Dreyer and Blume 2007). I will refer to this type system as DB for short. \nIn the paper on DB, we demonstrate that subtle aspects of the interaction of modules and type inference \ncause all Standard ML typecheckers to be incomplete with respect to the De.nition of SML. We show how \nto regain complete type inference by loos\u00ad 7 Nakata and Garrigue brie.y sketch a type inference algorithm \nthey have implemented to avoid requiring explicitly-typed core terms in practice, but it cannot possibly \nsucceed in all cases due to the undecidability of inference in the presence of polymorphic recursion \n(Henglein 1993). ening the declarative de.nition of typing. Interestingly, the more liberal declarative \nsemantics of DB makes critical use of the RTG language, even though DB does not support recursive modules. \nWhile there are great formal similarities between RMC and DB, there are a few major differences. One \nis that RMC supports recursive modules. Another is RMC s novel formalization of the regular and static \nmodule typechecking judgments using the same set of typing rules. Typechecking in DB does not require \nany static typechecking judgment due to the lack of recursive modules. Ironically, the completeness result \nfor DB type inference does not hold up if one (na\u00a8ively) extends the language with RMC s recursive modules. \nConsider the following code: signature S = sig type t; val v : t end structure Foo = rec (X : sig structure \nA : S end) struct val f = (print \"Hello\"; fn x => x) structure A :> S = struct type t=int; val v=f 3end \nend Due to ML s (and DB s) value restriction, the type of f here cannot be polymorphically generalized, \nbut f can be declaratively assigned any monomorphic type of the form t . t . However, there are two inequivalent \nmonotypes, int . int and X.A.t . X.A.t, which would both be valid types for f given its subsequent use \ninside the body of A. Thus, we lose the ability to assign a principal signature to the module Foo. In \nessence, the problem here is that RMC s solution to the double vision problem con.ates the types X.A.t \nand int inside the de.nition of A, but it does not con.ate them outside of A,and this confuses the type \ninference engine. One way to handle this problem is to simply prohibit examples like the one above in \nwhich the right-hand side of a module-level val binding is side-effecting but does not have a unique \ntype. (This is essentially the approach that is taken by the SML/NJ compiler.) I am currently investigating \nalternative ways of resolving this issue. 5.3 Modules and Units Flatt and Felleisen (1998) describe \na language of units, recursive modules for Scheme. They show how to extend them with type components, \nand their solution successfully avoids the double vi\u00adsion problem, but the unit constructs are syntactically \nheavyweight and awkward to use. In more recent work, Owens and Flatt (2006) invest the unit language \nwith features of ML modules (e.g., translu\u00adcent signatures), introduce a distinction between .rst-class \nrecur\u00adsive units and second-class hierarchical modules, and show how to encode a subset of the ML module \nsystem in their revised unit language. Their units remain verbose, however, and they do not provide any \nconcrete proposal for extending an ML-style module system with recursion. The key advantage offered by \nFlatt-style units is that they were designed from the beginning to support separate compilation of recursive \ncomponents. In contrast, ML s separate compilation mechanism the functor while powerful in many respects, \ndoes not generalize naturally to support separate compilation of recur\u00adsive modules. One of the bene.ts \nof basing the RMC type system on the RTG type system is that RTG provides built-in support for unit-style \nrecursive linking. Thus, I hope that RMC will serve as a jumping-off point for future work on synthesizing \nthe functionality of modules and units. 5.4 Applicative vs. Generative Functors Following Standard ML, \nthe semantics of functors in RMC is what is known as generative. This means that if a functor contains \nabstract type de.nitions in its body, then every application of the functor will result in the creation \nof fresh abstract types. In contrast, OCaml provides an applicative semantics of functors (Leroy 1995), \nin which every application of a functor to the same argument returns a module with the same abstract \ntypes. The main reason that RMC supports generative functors is that they are simpler to account for \nin terms of universal and existential type quanti.cation than applicative functors are. However, both \napplicative and generative semantics for functors are appropriate in different circumstances, and there \nhave been several proposals for combining support for both in one language. (Dreyer et al. (2003) offer \nthe most comprehensive existing proposal for doing this, as well as an overview of related work.) I am \ncurrently in the process of incorporating applicative functors into RMC.  References Roberto Amadio \nand Luca Cardelli. Subtyping recursive types. ACM Transactions on Programming Languages and Systems, \n15(4):575 631, 1993. Karl Crary, Robert Harper, and Sidd Puri. What is a recursive module? In ACM SIGPLAN \nConference on Programming Language Design and Implementation (PLDI), pages 50 63, Atlanta, Georgia, 1999. \nDerek Dreyer. Practical type theory for recursive modules. Technical Report TR-2006-07, University of \nChicago, Department of Computer Science, August 2006. Derek Dreyer. A type system for recursive modules. \nTechnical Report TR-2007-10, University of Chicago, Department of Computer Science, July 2007a. Derek \nDreyer. Recursive type generativity. Journal of Functional Program\u00adming, 2007b. To appear. Original version \npublished in 2005 ACM SIG-PLAN International Conference on Functional Programming (ICFP), pages 41 53, \nTallinn, Estonia. Derek Dreyer. Understanding and Evolving the ML Module System.PhD thesis, Carnegie \nMellon University, Pittsburgh, Pennsylvania, 2005. Derek Dreyer and Matthias Blume. Principal type schemes \nfor modular programs. In European Symposium on Programming (ESOP), pages 441 457, Braga, Portugal, 2007. \nDerek Dreyer, Karl Crary, and Robert Harper. A type system for higher\u00adorder modules. In ACM SIGPLAN Symposium \non Principles of Pro\u00adgramming Languages (POPL), New Orleans, 2003. Matthew Flatt and Matthias Felleisen. \nUnits: Cool modules for HOT languages. In ACM SIGPLAN Conference on Programming Language Design and Implementation \n(PLDI), pages 236 248, Montr\u00b4eal, Canada, 1998. Warren D. Goldfarb. The undecidability of the second-order \nuni.cation problem. Theoretical Computer Science, 13:225 230, 1981. Robert Harper and Mark Lillibridge. \nA type-theoretic approach to higher\u00adorder modules with sharing. In ACM SIGPLAN Symposium on Prin\u00adciples \nof Programming Languages (POPL), pages 123 137, Portland, Oregon, 1994. Robert Harper and Benjamin C. \nPierce. Design considerations for ML\u00adstyle module systems. In Benjamin C. Pierce, editor, Advanced Topics \nin Types and Programming Languages, chapter 8. MIT Press, 2005. Robert Harper and Chris Stone. A type-theoretic \ninterpretation of Standard ML. In Gordon Plotkin, Colin Stirling, and Mads Tofte, editors, Proof, Language, \nand Interaction: Essays in Honor of Robin Milner, pages 341 387. MIT Press, 2000. Fritz Henglein. Type \ninference with polymorphic recursion. ACM Transac\u00adtions on Programming Languages and Systems, 15(2):253 \n289, 1993. Xavier Leroy. Applicative functors and fully transparent higher-order mod\u00adules. In ACM SIGPLAN \nSymposium on Principles of Programming Lan\u00adguages (POPL), pages 142 153, San Francisco, California, 1995. \nXavier Leroy. Manifest types, modules, and separate compilation. In ACM SIGPLAN Symposium on Principles \nof Programming Languages (POPL), pages 109 122, Portland, Oregon, 1994. Xavier Leroy. A proposal for \nrecursive modules in Objective Caml, 2003. Available at: http://caml.inria.fr/about/papers.en.html. David \nMacQueen. Modules for Standard ML. In ACM Symposium on LISP and Functional Programming, pages 198 207, \n1984. Robin Milner, Mads Tofte, Robert Harper, and David MacQueen. The De.nition of Standard ML (Revised). \nMIT Press, 1997. John C. Mitchell and Gordon D. Plotkin. Abstract types have existential type. ACM Transactions \non Programming Languages and Systems,10 (3):470 502, 1988. Keiko Nakata and Jacques Garrigue. Recursive \nmodules for programming. In ACM SIGPLAN International Conference on Functional Program\u00adming (ICFP), pages \n74 86, Portland, Oregon, 2006. Chris Okasaki. Purely Functional Data Structures. Cambridge University \nPress, 1998. Scott Owens and Matthew Flatt. From structures and functors to modules and units. In ACM \nSIGPLAN International Conference on Functional Programming (ICFP), pages 87 98, Portland, Oregon, 2006. \nClaudio V. Russo. Recursive structures for Standard ML. In International Conference on Functional Programming \n(ICFP), pages 50 61, Florence, Italy, 2001. Claudio V. Russo. Types for Modules. PhD thesis, Edinburgh \nUniversity, Edinburgh, Scotland, 1998. LFCS Thesis ECS LFCS 98 389. Mads Tofte. Operational Semantics \nand Polymorphic Type Inference.PhD thesis, University of Edinburgh, 1988. Solutions to Exercises from \nSection 3 Solution to Exercise #1: The key change is in the type compo\u00adnents of the recursive module \nbody. While A.t remains equal to a,the removal of B s sealing means that B.u becomes transpar\u00adently equal \nto bool. Consequently, the rei.ed forward declaration signature that S is transformed to is {\u00df . bool}S \ni.e., S from Figure 2 with bool substituted for \u00df. The effect this has on the typechecking of the recursive \nmodule is simply that the identity of X.B.u and bool is visible throughout the whole recursive module \nde.nition, not just within B. Solution to Exercise #2: (a) is well-typed. Sealing A in this way has no \neffect on the in\u00adformation that A gets to see (via X) about its own type components. (One should certainly \nhope as much if sealing caused a problem here, it would be an instance of the double vision problem!) \n (b) is also well-typed. Intuitively, it ought to be, for it should not matter that mod is originally \nnamed B before it is named A.Step\u00adping through: Since A is just a copy of B, the type components of A \nare transparently equal to the type components of B. Thus, when we reify the forward declaration signature, \nthe type components of X.A will become visibly equal to whatever semantic type vari\u00adables are being used \nto represent the abstract types de.ned by B. Then, when we go underneath the sealing of B, those variables \nwill be substituted with their de.nitions inside B,and mod will see the same signature for X.A as it \nwould have seen in the original version of the recursive module. (c) is not necessarily well-typed. \nIntuitively, the reason is that mod is not underneath the sealing anymore. Although it happens that A \nis internally de.ned to be a copy of B, this information is only known within the sealed de.nition of \nA. At the point where we typecheck mod, it is not public knowledge that A s (and con\u00adsequently X.A s) \nabstract type components are implemented inter\u00adnally by those of mod, so we run into the double vision \nproblem. In this case, though, double vision is good. If mod were somehow able to know that X.A s type \ncomponents were equal to its own, the type system would not be respecting the data abstraction boundary \nerected by the programmer around the implementation of A.  Solution to Exercise #3: We could instead \nde.ne the forward declaration signature S to be: sig structure A : SA structure B : SB end This is suf.cient \nto make AB typecheck because steps 1 and 2 of the typing rule for recursive modules (in Section 3.1) \nwill reify the above forward declaration signature to the same S to which the original S was rei.ed. \nMoreover, because RMC does not use the forward declaration signature as a sealing signature, the fact \nthat the above signature is less transparent than the original S will not affect the exported signature \nof the module AB. It is reasonable, then, to ask: do we need recursively dependent signatures at all? \nI would argue that we do. For example, suppose the programmer wishes to write down a source-level RMC \nsigna\u00adture representing the exported signature of AB (e.g., if they want to parameterize another module \nover it). This cannot be done without the aid of recursively dependent signatures. Solution to Exercise \n#4: Here is one example: signature S = sig type a t; type n = int; type b = bool end rec (X : S) struct \ntype a t= a X.t type n =int t type b =bool t end The unique solution for the type t is the same as before: \n.a.a. Solution to Exercise #5: (a) is ill-typed because of RMC s rule that the internal de.ni\u00adtions \nof abstract types must not depend on unde.ned type variables. At the point A is de.ned, X.B.u (i.e., \n\u00df) is bound in the context as unde.ned, so the de.nition of t is not allowed to depend on it. (b) is \nwell-typed. This might seem odd since the situation is similar to (a). The difference is that the de.nition \nof B comes after the de.nition of A. Since typechecking processes module bindings in the order they appear \nsyntactically, the typechecking of B is performed in a context in which X.A.t (i.e., a) has already been \nde.ned (formally speaking, it is bound in the context as a . T). Since a is no longer unde.ned, it is \n.ne for the internal de.nition of B.u to depend on it. (c) is well-typed. By revealing the de.nition \nof A.t to be depen\u00addent on X.B.u, module A has placed the burden of ensuring absence of transparent type \ncycles on B.Since B.u is de.ned as bool,there is no problem. (d) is ill-typed. Here, there is actually \na transparent type cycle, which manifests itself as a type error during the typechecking of B. Speci.cally, \nthe internal de.nition of the abstract type B.u depends on X.A.t, which is transparently equal to int \n* X.B.u,which equals int * \u00df.Since \u00df is what B is supposed to be de.ning, this constitutes a cyclic type \nde.nition, which is prohibited.   \n\t\t\t", "proc_id": "1291151", "abstract": "<p>There has been much work in recent years on extending ML with recursive modules. One of the most difficult problems in the development of such an extension is the <i>double vision</i> problem, which concerns the interaction of recursion and data abstraction. In previous work, I defined a type system called RTG, which solves the double vision problem at the level of a System-F-style core calculus. In this paper, I scale the ideas and techniques of RTG to the level of a recursive ML-style module calculus called RMC, thus establishing that no tradeoff between data abstraction and recursive modules is necessary. First, I describe RMC's typing rules for recursive modules informally and discuss some of the design questions that arose in developing them. Then, I present the formal semantics of RMC, which is interesting in its own right. The formalization synthesizes aspects of both the Definition and the Harper-Stone interpretation of Standard ML, and includes a novel two-pass algorithm for recursive module typechecking in which the coherence of the two passes is emphasized by their representation in terms of the same set of inference rules.</p>", "authors": [{"name": "Derek Dreyer", "author_profile_id": "81100381796", "affiliation": "Toyota Technological Institute, Chicago, IL", "person_id": "P414177", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291196", "year": "2007", "article_id": "1291196", "conference": "ICFP", "title": "A type system for recursive modules", "url": "http://dl.acm.org/citation.cfm?id=1291196"}