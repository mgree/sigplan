{"article_publication_date": "10-01-2007", "fulltext": "\n ATypeDirectedTranslationofMLFto SystemF Daan Leijen Microsoft Research daan@microsoft.com Abstract \nTheMLFtype systembyLe BotlanandR\u00b4emy (2003)isa natural extension of Hindley-Milner type inference that \nsupports full .rst\u00adclass polymorphism, where types can be of higher-rank and im\u00adpredicatively instantiated. \nEven though MLF is theoretically very attractive,it has not seen widespread adoption.We believe that \nthis partly because it is unclear how the rich language of MLF types relateto standard SystemF types.In \nthis articlewegivethe .rst type directed translation of MLF terms to SystemF terms. Based on insightgained \nfrom this translation, we also de.ne Rigid MLF (MLF=), a restriction of MLF where all bound values have \na Sys\u00adtem F type. The expressiveness of MLF= is the same as that of boxy types,but MLF= needs fewer annotations \nand we give a de\u00adtailed comparison between them. Categories and Subject Descriptors D.3.3[Programming \nLan\u00adguages]: Language Constructs and Features Polymorphism General Terms Languages, Design, Theory Keywords \nFirst-class polymorphism, SystemF, MLF 1. Introduction TheMLFtype systembyLe BotlanandR\u00b4emy (2003)isa \nnatural extension of Hindley-Milner type inference that supports full .rst\u00adclasspolymorphism,whereanyvaluecanhaveapolymorphictype. \nMLFhasastrong theoretical foundationand requiresveryfewtype annotations. Even though MLF is very attractive \nfor these reasons, it has not seen widespread adoption.We believe that this is partly becausethetype \nlanguageofMLFis richerthanthatofSystemF. Besides that this is harder on the programmer, it is also harder \nto write a compiler for a language based on MLF: many compilers use an intermediate language based on \nSystemF, and the relation between MLF terms and SystemFtermsfarfrom clear. In an attempt to remedy this \nsituation, Leijen andL\u00a8oh (2005) describeda type inference algorithm that returns SystemF terms for well-typed \nMLF terms. Unfortunately, such algorithm does not giveparticularinsight into the relationbetween MLF \ntype rules and the translatedSystemFterms. Furthermore, we believe that oneof the reasons that a type \ndirected translation was not given in the previous article is that it is surprisingly subtle to do so \n indeed, this is the main technical contribution of this paper. Speci.cally: Permission to make digital \nor hard copies of all or part of this work for personal or classroom use is granted without fee provided \nthat copies are not made or distributed for pro.t or commercial advantage and that copies bear this notice \nand the full citation on the .rst page.To copyotherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 07, October 1 3, 2007, Freiburg, Germany. \nCopyright c &#38;#169; 2007ACM 978-1-59593-815-2/07/0010...$5.00 We are the .rst to give a type directed \ntranslation from MLF to SystemFterms,andweprovethatthe translationis sound.The translation of MLF types \nthat go beyond System F (namely .exibly bound polymorphic types)is done usingevidence trans\u00adlation. \n We show that a translation is possible where no evidence is passed for polymorphic types with rigid \nbounds, which corre\u00adspond naturally to inlined SystemFtypes. This greatly simpli\u00ad.es the translated System \nF terms, but we need to de.ne the translation on slightly modi.ed type rules. We show that the modi.ed \ntype rules are sound and complete with respect to the original MLF type rules.  Itis widely believed \nthata SystemFtranslationof impredica\u00adtive types may need to traverse structures at runtime to apply coercion \nterms.We show conclusively that this is not the case for MLF and that thereexistsa concise translation \nthatbuilds coerced terms directly without runtime traversals.  The type directed System F translation \nleads naturally to the de.nitionofarestrictionofMLF,called RigidMLF (MLF=), where all bound values have \na standard System F type. We show that MLF= has the same expressiveness as boxy type inference (Vytiniotis \net al. 2006),but needs fewer annotations. Since MLF= hides MLF types, it can work well as a simpli.ed \nversionofMLF wherethe programmeronlyworkswithregular SystemFtypes.  In the next section, we start with \nan introduction to MLF and explain the MLF type rules. Section 3 .rst gives an overview of the dif.culties \nof translating MLF to SystemF, and introduces a modi.ed set of type rules on which we de.ne a type directed \nSystem F translation. Section 4 de.nes MLF=, a restriction of MLF whereallvalueshave SystemFtypes. Finally,inthe \nrelated work section (Section 5) we give a detailed comparison between Hindley-Milner, MLF, MLF=, and \nboxy types. 2. An introduction to MLF Functional languages with type inference are almost always based \non the Hindley-Milner type system (Hindley 1969; Milner 1978) and for good reasons. Type inference based \non Hindley-Milner can automatically infer most general, or principal, types for ex\u00adpressions without \nfurther type annotations. Also, the type system is sound, and well-typed programs cannot go wrong . To \nachieve automatic type inference, the Hindley-Milner type system restricts polymorphism and polymorphic \nvalues are not .rst-class citizens. In particular, function arguments can only be monomorphic.Formally, \nthis means that universal quanti.ers can only appear at the outermost level (i.e. higher-ranked types \nare disallowed), and quanti.edvariables can onlybe instantiated with monomorphic types (i.e. impredicative \ntypes are disallowed). TheMLFtype systemby LeBotlanandRemy(Le Botlan2004; Le Botlan andR\u00b4 emy2003)isanaturalextensionof \nHindley-Milner that lifts these restrictions and supports .rst-class polymorphism with higher-ranked \nandimpredicativetypes. In contrast to Hindley-Milner, some type annotations are required in MLF to avoid \nguess\u00ading polymorphic types.Take forexample the following program: poly f =(f 1, f True) This program \nis rejected by both MLF and Hindley-Milner. The program would be accepted in MLF if we annotate the argument \nf with a polymorphic type, like .a. a . a or .a. a . Int. The type of a polymorphic argument like f cannot \nbe inferred automatically since there exist manytypes for f none of which are an instance of the other \n there is no principal type. The reader might be worried that many type annotations are needed,but suchis \nnotthe case. MLFhasa remarkable property that the only required type annotations are on arguments that \nare used polymorphically.For example, poly (f :: .a. a . a)=(f 1, f True) isa well-typed MLF program. \nNote that the annotation rule implies that all programs acceptedbyHindley-Milner are also acceptedby \nMLF. Moreover, the annotation rule only requires annotations on polymorphic arguments that are also used \npolymorphically and not merely passed through .Forexample: polyL :: [.a. a . a] . (Int, Bool) --inferred \npolyL xs = poly (head xs) is accepted without type annotations even though xs has an (in\u00adferred) impredicativepolymorphic \ntype.Weconsider this an impor\u00adtant property for abstraction and modularity, since we can (re)use standard \nfunctions like head, with type .a. [a] . a, for lists that contain polymorphic values. As another example, \nconsider the ap\u00adplication function: apply :: .a\u00df. (a . \u00df) . a . \u00df --inferred apply f x = fx Of course, \nthe direct application poly id is well typedin MLF,but also the abstracted application apply poly id. \nNo type annotations are needed, except for the argument annotation of poly. Note that to type check apply \npoly id, the a quanti.er in the type of apply is impredicatively instantiated to the polymorphic type \nof id, namely .a. a . a. More generally, if an application e1 e2 is well typed in MLF, than the expression \napply e1 e2 is also well typed. In general, this applies to functors(apply)applying polymorphic functions(poly)over \nstructures holding polymorphicvalues(id). For example, we can use the standard map function to apply \nthe poly function to the elements of a list of identity functions, as in map poly [id, id ], without \nanyfurther type annotations. 2.1 Bounded types Essential to type inference is the ability to assign principal \ntypes to expressions. In the presence of impredicative polymorphism however, we need more than standard \nSystem F types to have principal types. Consider the following program let ids =[id ] in (polyL ids, \nids + [inc ]) where inc has type Int . Int and the append function (++) has type .a. [a] . [a] . [a]. \nIn a setting with .rst-class polymorphism we can assign two types to ids, namely a list of polymorphic \nidentity functions, [.a. a . a], or a polymorphic list of monomorphic identity functions, .a. [a . a]. \nIndeed, in the body of the let expression, we use ids with both types: the polyL function requires the \n.rst type, while appending to an [Int . Int ] list requires the second type. Unfortunately, neither of \nthese types is an instance of the other so what type should we give to ids to make the program well \ntyped? Monomorphic types t ::= a type variable | c t1 ... tn constructor application Polymorphic types \ns ::= q.s quanti.ed type | t mono type |. most polymorphic type Quanti.er q ::= .(a os) a bounded quanti.er \no ::= ; | = a bound is .exible or rigid Pre.x Q ::= q1, ..., qn a pre.x is a list of quanti.ers Syntactic \nsugar .a = .(a ;.) Q.t = q1. ... .qn.t quantify using a pre.x Figure 1. MLF types. MLF solves this dilemmabygoingbeyond \nstandard SystemFtypes and assigns a type that can be instantiated to both of the previous types. The \nMLF type for ids is .(\u00df ;.a. a . a). [\u00df ], which is read as a list of \u00df, for all types \u00df that are an \ninstance of (or equal to) .a. a . a . As we will see later, both of our previous types are instances \nof this type: .(\u00df ;.a. a . a). [\u00df ] . [.a. a . a] .(\u00df ;.a. a . a). [\u00df ] ..a. [a . a] where s1 . s2 states \nthat s2 is an instance of s1.We call ; a .exible bound.For regularity, MLF also introduces rigid bounds, \nwritten as =. The type .(\u00df = .a. a . a). [\u00df ] is read as a list of \u00df, where \u00df is as polymorphic as .a. \na . a . Indeed, the type [.a. a . a] is justa syntactic shorthand for the previous type and we generally \ninline rigid bounds for notational convenience. 2.2 MLF typesformally Figure1de.nes the grammar of MLF \ntypes. Monomorphic types t are either a type variable a, or a type constructor application. We assume \nthat the function constructor . is part of the type constructors and we do not need to treat it specially. \nPolymorphic types s are either a monomorphic type, the most polymorphic type ., or a polymorphic type \nquanti.ed with a bound .(a os1).s2, where the bound o is either .exible(;)or rigid(=). A quanti.er with \na .exible bound can be instantiated to any instance of its bound. In particular, a quanti.er .(a ;.) \ncan be instantiated to anytype since . is the most polymorphictype.For example, the full MLF type for \nthe identityfunction is: id :: .(a ;.).a . a Wecall.(a ;.) an unconstrained bound and usually shorten \nit to .a. The . type is de.ned as equivalent to .(a ;.).a. Note that in Hindley-Milner all quanti.ers \nare always unconstrained. A list of quanti.ers is called a pre.x and denoted as Q. We always assume that \nthe quanti.ed variables are distinct and form the domain of Q, written as dom(Q). If all quanti.ers are \nuncon\u00adstrained, we call Q an unconstrained pre.x. 2.3 Type rules of MLF Thetype rulesforMLF aregivenin \nFigure2.Giventheexpressive\u00adness of MLF, theyare surprisingly simple and very similar to the type rules \nof Hindley-Milner.Aderivation (Q)G f e : s means that under a pre.x Q and type environment G the expression \ne has x : s . G VAR (Q)G f x : s (Q)G f e1 : t2 . t (Q)G f e2 : t2 APP (Q)G f e1 e2 : t (Q)G, x : t1 \nf e : t2 FUN (Q)G f .x.e : t1 . t2 (Q)G f e1 : s1 (Q)G, x : s1 f e2 : s2 LET (Q)G f let x = e1 in e2 \n: s2 (Q,a os1)G f e : s2 a/. ftv(G) GEN (Q)G f e : .(a os1).s2 INST (Q) G f e : s1 (Q) s1 s2 (Q) G f \ne : s2 ANN (Q) G f e : s1 (Q) s E- s1 (Q) G f (e :: s) : s Figure 2. Type rules type s. The type environment \nG contains the types of all the free term variables ine. The pre.x Q contains the bounds of all the free \ntype variables in G, s, and e 1. In Hindley-Milner, the pre.x Q is usually left implicit since all the \nbounds of the free type variables are always unconstrained. The application rule APP applies a function \nto a monomorphic argument. Remarkably, this is still expressive enought to apply functionsto polymorphicarguments \nsincethe pre.x Q can contain a polymorphic bound of a (monomorphic) type variable. As an example, we \nderive the type for the application poly id, where sid stands for the type .a. a . a, t for (Int, Bool), \nand sid . t as a shorthand for .(\u00df = sid).\u00df . t. poly : sid . t . G id : sid . G (.a = sid)G f poly : \nsid . t (.a = sid)G f id : sid (.a = sid) sid . ta . t (.a = sid) sid a (.a = sid)G f poly : a . t (.a \n= sid)G f id : a (.a = sid)G f poly id : t () G f poly id : .(a = sid).t () .(a = sid).t t () G f poly \nid :(Int, Bool) In the above derivation it is essential that we can instantiate sid to a under thepre.x \n(.a = sid). The instantiation rule INST is used twice to instantiate both the argument type of poly and \nid to a after which can we use the application rule APP. Finally, the generalization rule GEN is used \nto remove the assumption from the pre.x, and instantiation is applied to remove the (now) dead quantier, \nderiving (Int, Bool). The annotation rule ANN de.nes the type rule for type annota\u00adtions, using the abstraction \nrelation E -.We de.ne this relation (to\u00adgether with instantiation) in the next section. Note that MLF \nhas just a single rule for type annotations, and there is no need for spe\u00adcial type propagation rules. \nIn particular, a lambda bound annota\u00adtion .(x :: s).e is syntactic sugar for .x. let x =(x :: s) in e \nAs such, the essence of MLF is contained in the instance relation ()in ruleINST,andthe abstraction relation(E \n-)in the annotation 1due to annotations. (Q) s1 . s2 (Q) s2 . s3 R-TRANS (Q) s1 . s3 (Q,a os) s1 . s2 \na/. dom(Q) R-PREFIX (Q) .(aos).s1 ..(a os).s2 Figure 3. General rules, where . stands for = (equivalence), \nE - (abstraction), or (instantiation). EQ-REFL (Q) s = s EQ-VAR (Q) .(a os). a = s EQ-FREE (Q) a /. ftv(s2) \n.(aos1). s2 = s2 EQ-MONO .(a os0) . Q (Q) s0 = t0 (Q) t = t[a . t0] EQ-COMM a1= a2 a1 ./ftv(s2) a2 ./ftv(s1) \n(Q) .(a1 o1 s1)(a2 o2 s2).s =.(a2 o2 s2)(a1 o1 s1).s (Q) s1 = s2 EQ-CONTEXT (Q) .(aos1).s =.(aos2).s \nFigure 4. Equivalence A-EQUIV A-HYP A-CONTEXT (Q) s1 = s2 (Q) s1 E- s2 .(a = s) . Q (Q) s E- a (Q) s1 \nE- s2 (Q) .(a = s1). s E- .(a = s2). s Figure 5. Abstraction I-BOTTOM (Q) . s (Q) s1 E - s2 I-ABSTRACT \n(Q) s1 s2 .(a;s) . Q I-HYP (Q) sa I-RIGID (Q) .(a ;s1).s2 .(a = s1).s2 (Q) s1 s2 I-CONTEXT (Q) .(a ;s1).s \n.(a ;s2).s Figure 6. Instance rule ANN. In the next section, we formally de.ne these relations and explain \nthe annotation rule in detail. 2.4 Instantiation, abstraction, and equivalence Figure6formally de.nes \nthe instance relation( ). Through rule I-ABSTRACT, the instance relation includes the abstraction rela\u00adtion(E \n-)de.ned in Figure 5. Similarly, through ruleA-EQUIV, the nf(t )= t nf(.)= . nf(.(a os1).s2)= nf(s2) \ni. a/. ftv(s2) nf(.(a os1).s2)= nf(s1) i. nf(s2)= a nf(.(a os1).s2)= nf(s2[a . t ]) i. nf(s1)= t nf(.(a \nos1).s2)= .(aonf(s1)). nf(s2) Figure 7. Normal form abstraction relation includes the equivalence relation(=)de.ned \nin Figure4andwehavethe following inclusion: () . (E -) . (=). All three relations also include the general \nrules given in Fig\u00adure 3. That is, all relations are transitive through R-TRANS, and all rulescanbe appliedunderacommonpre.xthroughrule \nR-PREFIX. Note that the condition a/. dom(Q) in R-PREFIX can always be satis.ed through alpha renaming. \n2.4.1 Equivalence The equivalence relation in Figure 4 de.nes an equivalence on types that abstracts \nfrom syntactical artifacts, like the order of the quanti.ers. For example, rule EQ-FREE states that unbound \nquan\u00adti.ers are not meaningful, while rule EQ-COMM allows rearrange\u00adment of independent quanti.ers. Rule \nEQ-MONO is the only rule that reads information from the pre.x, and inlines monomorphic bounds.Forexample, \nassuming Q' =(.(a oInt), we can derive: '' .(a oInt) . (QQ)(QQ) Int = Int (Q, .(aoInt)) a . a = Int . \nInt a/. dom(Q) (Q) .(aoInt).a . a =.(a oInt). Int . Int Using transitivity R-TRANSand rule EQ-FREE,we \ncan nowconclude that .(aoInt).a . a is equivalent to Int . Int.For monomor\u00adphic types it does not matter \nwhether the bound is .exible or rigid. The context rule EQ-CONTEXT states we can substitute equiv\u00adalent \ntypes under any bound (rigid or .exible). For example, we can derive .(\u00df = .(a ;sid).a). [\u00df ] =.(\u00df = \nsid). [\u00df ] by the context rule and EQ-VAR. 2.4.2 Normalform To abstract away from syntactical artifacts, \nFigure 7 de.nes a normal form function nf(\u00b7) that maps equivalent types to the same normal form up to \nrearrangement of their quanti.ers (Le Botlan 2004). The normal form of a type is always equivalent to \nthat type, i.e. nf(s) = s. 2.4.3 Abstraction The abstraction relationin Figure5 extends the equivalence \nrela\u00adtion. In particular, it can read information from the pre.x by the abstractionhypothesis rule A-HYP.Ifaquanti.er \na is rigidly bound to a type s in the pre.x, we can abstract a type s by a. Note that abstraction is \nnot symmetric, and the opposite direction is not al\u00adlowed. This is essential for type inference since \nwe can infer that a given polymorphic type can be abstractedbut we cannot infer the other direction. \nThe abstraction relation nicely interacts with the type rules for lambdaexpression(FUN)andtype annotations(ANN)in \nFigure2. The FUN rule requires the lambda bound argument x to have a monomorphic type,justlike Hindley-Milner \nbuthowareweable to type a function like poly that requires a polymorphic argument? The key to typing \nsuch function is to give the argument x a monomorphic type a that is rigidly bound in the pre.x to the \npolymorphic type .(a = s). The polymorphic type of a is later revealed by the type annotation through \nA-HYP.Take forexample the desugared version of poly: poly = .f0. let f =(f0 :: sid) in (f 1, f True) \nWe assume that e stands for the body of the lambda expression. The typing derivation for poly uses generalization \nto introduce the polymorphic bound, and assignsa monomorphic type a to the type of the lambda bound argument \nf0: . . . (Q, .(a = sid)) G, f0 : a f e :(Int, Bool) (Q, .(a = sid)) G f .f0.e : a . (Int, Bool) a/. \nftv(G) (Q)G f .f0.e : .(a = sid)(a . (Int, Bool)) Given this environment, we are now able to type the \nbody of the lambda expression. In particular, we can use f with the polymor\u00adphic type sid in the body \nof the let since we can derive that the expression (f0 :: sid) has type sid: f0 : a . (G, f0 : a) .(a \n= sid) . (Q, .(a = sid)) (...)G, f0 : a f f0 : a (Q, .(a = sid)) - a sid E (Q, .(a = sid)) G, f0 : a \nf (f0 :: sid): sid The rule A-HYP applies here directly, and the type annotation rule reveals the polymorphic \ntype of a. Note that the annotation is required since we cannot instantiate rigidly bound type variables, \ni.e. we cannot derive (.(a = sid)) asid. 2.4.4 Instantiation The instantiation relationin Figure6extends \nabstractionandequiv\u00adalence through rule I-ABSTRACT. The rule I-BOTTOM states that the most polymorphic \ntype . can be instantiated to any other type. While abstraction can use rigid bounds from the pre.x, \ninstantia\u00adtion can use .exible bounds from the pre.x through thehypothesis ruleI-HYP.Ifthe pre.x containsaquanti.er \n.(a ;s) we knowthat a is an instance of s and therefore we can always safely instantiate a type s to \na. The context rule I-CONTEXT works only under .exible bounds. The context ruleworks nicely with I-BOTTOM \nto do standard instan\u00adtiationof unconstrained bounds.Forexample: .a. a . a = { sugar }.(a ;.).a . a { \nI-CONTEXT,I-BOTTOM }.(a ;Int).a . a { I-ABSTRACT,A-EQUIV,EQ-PREFIX,EQ-MONO,EQ-FREE }Int . Int 3. From \nMLF to SystemF In this section, we will develop a type directed translation from MLF termsto SystemF \nterms. Such translationisvery usefulin practice as compilers that use MLF type inference, can use Sys\u00adtemFtermsas \ntheirintermediate language.More importantly,such translation gives us a better understanding of the expressiveness \nand operational behaviour of MLF programs. In particular, Itis widely believed thata SystemFtranslationof \nimpredica\u00adtive types may need to traverse structures at runtime to apply coercion terms, where further \ninstantiations can even lead to multiple traversals. The translation we develop in this section shows \nthat this is not the case for MLF. Instead we show that we canalwaysbuild the coerced terms directlyina \nsingle pass without anytraversals. The SystemFtranslationleadsus naturallytoa restrictionof MLF where \nall boundvalueshavea SystemFtype and where the SystemFtranslationis particularlyef.cient.  Extending \nMLF with other type system extensions usually re\u00adquires a good understanding of the corresponding evidence \ntranslation.Forexample, to use MLF asa basis for languages that support quali.ed types, like Haskell, \nit is important to have an evidence translation of predicates which .ts seamlessly with the presented \nSystemFtranslation.  3.1 Translating .exible bounds The main dif.cultyingivinga SystemFtranslationof \nMLF terms occurswhentheMLF termshaveatypethatgoesbeyondSystemF, i.e. polymorphic types that are .exibly \nbound. Consider: let ids =[id ] in (polyL ids, ids + [inc ]) where ids has type .(a;sid). [a]. Unfortunately, \nthere is no directSystemF equivalentof this type, andina na\u00a8iveSystemF translation, ids can have two \ndifferent System F types, namely .a \u00b7 [a . a] or [.a \u00b7 a . a]. The .rst type is required by the append, \nwhile the second type is required by the polyL application. Effectively, MLF delays the instantiation \nand later ids is instantiated in two fundamentally different ways. In contrast, in SystemFthis choicehastobemadeupfront. \nA potentialwayof translating this programto SystemFisto assign the type [.a \u00b7 a . a] to ids, and explicitly \ncoerce the type by mapping a coercion function over all element types that instantiates them Int . Int \nfunctions. In practice though this solution is unacceptable since the type inferencer might suddenly \nintroduce coercion terms that need to traverse arbitrary structures at runtime! This is often seen as \none of the fatal properties of impredicative type systems (Peyton Jones et al. 2007) and boxy type inference \n(Vytiniotis et al. 2006) was speci.cally designed to avoid this behaviourby rejecting the above program. \nFortunately, there exists a very elegant solution for MLF, .rst describedby Leijen andL\u00a8 oh (2005): for \nevery non-trivial .exible bound, we pass in evidence on how to instantiate the term effec\u00adtively delaying \nthe instantiation to the call site.A .exible bound .(a;s) states that a can be anyinstance of s. Each \nsuch bound is translated into an explicit witness function of type s . a that transforms anytype s into \nits instantiation a.Forexample, the Sys\u00adtemFtranslationof the ids :: .(a;sid). [a] value is: ids :: .a \n\u00b7 (sid . a) . [a] ids =.a \u00b7 .(v :: sid . a) \u00b7 single a (v id) where we assume a function single :: .a \n\u00b7 a . [a] that creates a singleton list. Note in particular howthe witness v takes the identity function \nto type a. In the body of the let expression, ids can now instantiated to two different types.For polyL, \nwe simply pass an identity function that leaves the elements polymorphic: polyL sid (ids sid (.(x :: \nsid) \u00b7 x)) For the append though, the evidence instantiates all elements to Int . Int functions: ids \n(Int . Int)(.(x :: sid) \u00b7 x Int) For the above example, the evidence just changes the type param\u00adeters. \nIn the presence of quali.ed types evidence terms can change runtime terms too.Forexample, the term [inc \n] could have the type .(a;s). [a] where s equals .a. Num a . a . a. The Sys\u00adtemFtranslationpasses anexplicit \nruntime dictionary asevidence for Num a to such function. In that case the witness for ids trans\u00adforms \na term of type sid to s by adding the dictionary argument: ids s (.(x :: sid) \u00b7 (.a \u00b7 .(num :: Num a) \n\u00b7 x a)) s * = ft(nf(s)) ft(t)= t ft(.)= .a \u00b7 a ft(.(a = s1).s2)= ft(s2)[a . ft(s1)] ft(.(a;.).s)= .a \n\u00b7 ft(s) ft(.(a;s1).s2)= .a \u00b7 (ft(s1) . a) . ft(s2) Figure 8. MLF types to system-F types. 3.2 Translation \nof rigid bounds Figure8 de.nes the translation ofMLF types to SystemF types. The translation works on \nnormal forms to discard trivial bounds such as monotype bounds or unbound quanti.ers. The translation \nasgivenisvery satisfactoryastheonlyevidence passedisfor non\u00adtrivial .exible polymorphic bounds exactly \nthose bounds that were needed to allow type inference with .rst-class polymorphism in the .rst place. \nRigid bounds are simply inlined to get the correspondingSys\u00adtem F type. Unfortunately, this prevents \nus also from de.ning a direct typedirected translation on the standard MLF rules. In par\u00adticular, since \nthe equivalence andabstraction relation can work un\u00adder rigid bounds (through EQ-CONTEXT and A-CONTEXT), \nit is no longer the case that when two types are equivalent, that their Sys\u00adtemFtypes are equivalent, \ni.e. s1 = s2 does not imply s1 * = s2 *! Take for example the listsxs1 :: .(. = .a\u00df. a . \u00df . a). [. ] \nand xs2 :: .(. = .\u00dfa. a . \u00df . a). [. ]. The term if True then xs1 else xs2 is well-typed in MLF since \nthe types of xs1 and xs2 are equivalent, .(. = .a\u00df. a . \u00df . a). [. ] ={ EQ-CONTEXT,EQ-COMM } .(. = .\u00dfa. \na . \u00df . a). [. ] However, accordingtoFigure8,the correspondingSystemFtypes are not equal, and we end \nup with an ill-typed System F term! Nevertheless, not using an evidence translation for rigid bounds \nis most important in practice to avoid many trivial coercions between equivalent types and we consider \nthis a serious weakness of the earlier approachby Leijen andL\u00a8oh (2005). Furthermore, as we will see \nin Section 4, the direct translation of rigid bounds enables a variation of MLF that never passes anyevidence \nwhich in turns enables usgain insight in the relation between boxy type inference and MLF. Thus, the \nchallenge is to set up the typed translation in such a way that the above situation is prevented and \nwhere rigid bounds never need evidence translation, and we are going to tackle it head on in the following \nsections. 3.3 Canonical equivalence and abstraction Both the equivalence and abstraction relation can \nbe applied un\u00adder rigid bounds through their context rules (EQ-CONTEXT and A-CONTEXT). Therefore,to ensurethattheSystemFtypeofarigid \nbound never changes, we need to de.ne both a restricted equiv\u00adalence and restricted abstraction relation \nwhere equivalent types have equal SystemFtranslations. Theonly rule thatprevents equal SystemFtypesis \nEQ-COMM when quanti.ers are rearranged. As we see later, we cannot just remove the rearrangement rule \nsince abstraction must be able to rearrange rigid binders.Fortunately, since theSystemFtranslation inlines \nrigid bounds, rearranging rigid binders does not change the translated SystemFtype and such rearrangementis \nsound. De.nition 3.3.a (Canonical equivalence): We de.ne canonical equivalence, written as =c, as equal \nto the MLF equivalence re\u00adlationof Figure4,but the EQ-COMM rule is restricted to rearrange\u00adment of rigid \nbinders: CEQ-COMM a1 = a2 a1 ./ftv(s2) a2 ./ftv(s1) (Q) .(a1 = s1)(a2 os2).s =c .(a2 os2)(a1 = s1).s \nSimilarly,we de.ne canonical abstractionasanextensionof canon\u00ad ical equivalence. De.nition 3.3.b (Canonical \nabstraction): Canonical abstraction, written as E -c, is equal to the MLF abstraction relation in Figure5 \nbut the ruleA-EQUIVis restricted to canonical equivalence: (Q) s1 =c s2 CA-EQUIV -c (Q) s1 Es2 Canonical \nequivalence satis.es many properties of MLF equiva\u00adlence, forexample nf(s) =c s holds. Moreover,canonically \nequiv\u00adalenttypeshaveequalSystemFtypes.Tomakethis notion precise, we .rst de.nea SystemFsubstitutionextraction. \nDe.nition 3.3.c (Substitution extraction): The extraction of a monotype substitution from a pre.x Q, \nwritten as Q., is de.ned as: (\u00d8). = id (aos, Q). =[a . t] . Q. i. nf(s)= t (aos, Q). = Q. otherwise Similarly, \nwe can also de.ne the SystemF substitution extracted from a pre.x Q, written as QT: (\u00d8)T = id (a = s, \nQ)T =[a . s * ] . QT (a;s, Q)T =[a . t * ] . QT i. nf(s)= t (a;s, Q)T = QT otherwise Note that (Q1Q2)T \n= Q1T .Q2T for anywell formed pre.x Q1Q2. Futhermore, the domain of the substitution is a subset of domain \nof the pre.x: dom(QT).dom(Q). Using SystemFsubstitutions, we can now state our main theorems of canonical \nequivalence and abstraction: Theorem 3.3.d (Canonically equivalent types have equal SystemF types): (Q) \ns1 =c s2 . QT(s1 * )= QT(s2 * ) Theorem 3.3.e (Canonical abstraction has equal SystemFtypes): (Q) -c \n. QT(s1 * )= QT(s * s1 Es22 ) Both theorems are proved by straightforward induction over the rules of \ncanonical equivalence and abstraction. 3.4 Canonical instance with SystemFtranslation The canonical \ninstance relation, written as c,is de.nedin Figure9 and Figure 10. There are two differences from normal \nMLF instan\u00adtiation (de.ned in Figure 6): rule CI-ABSTRACT uses canonical ab\u00adstraction, and rule CI-COMM \nis reintroduces the ability to rearrange quanti.ers with .exible bounds. Furthermore, the canonical instan\u00adtiation \nnow derivesa SystemFwitness term forthe instantiation. c The derivation (Q) s1 s2 f states that s2 isa \ncanonical instance of s1 under pre.x Q, where the derived SystemFwitness f has type s1 * . s2 *, i.e.it \ninstantiatesa termwith SystemFtype s1 * into a term with type s2 * . To describe such witness functions \nconveniently, we use the notation. Anexpression e witha hole stands for a function .x \u00b7 e where is \nreplaced by the fresh variable x.For example, (Q) s1 c s2 f1 (Q) s2 c s3 f2 CI-TRANS (Q) s1 c s3 f2 (f1 \n) (Q,aov s) s1 c s2 f a/. dom(Q) CI-PREFIX (Q) .(aov s).s1 c .(aov s).s2 gen[.(a ov s).s2](f (inst[.(aov \ns).s1] )) (Q) s1 c s2 f CI-CONTEXT (Q) .(a ;v s1).s c .(a;w s2).s gen[.(a ;w s2).s] (let ve = w (fe) \nin inst[.(a ;v s1).s] ) Figure9. General rules for canonical instance withevidence trans\u00ad lation CI-BOTTOM \n(Q) . c s s * CI-ABSTRACT (Q) s1 E-c s2 (Q) s1 c s2 CI-HYP .(a;v s) . Q (Q) s c a v CI-RIGID (Q) .(a;v \ns1). s2 c .(a = s1). s2 gen[.(a = v s1).s2](inst[.(a ;v s1).s2] ) CI-COMM a1 = a2 a1 ./ftv(s2) a2 ./ftv(s1) \n(Q) .(a1 ;v s1)(a2 ;w s2).s c .(a2 ;w s2)(a1 ;v s1).s gen[.(a2 ;w s2). .(a1 ;v s1).s] (inst[.(a1 ;v s1). \n.(a2 ;w s2).s] ) Figure 10. Canonical instance with evidence translation = .x \u00b7 x  s * = .x \u00b7 x s * \n.y \u00b7 = .x \u00b7 .y \u00b7 x  The rule CI-BOTTOM instantiates the bottom type(.)to an arbitrary type s. The evidence \nterm thus needs to instantiate a term of type .a\u00b7a to s *,which corresponds to applying the types * in \nSystemF, and the derived evidence is s * . Rule CI-ABSTRACT is also straightforward. Due to Theorem \n3.3.e, we know that s1 and s2 have equal SystemFtypesand that the term stays the same, i.e. the evidence \nis the identity: . The evidence for rule CI-HYP needs to transform a type s * into a but how should it \ndo that if nothing is known about s? The solution to this problem is to annotate each .exible bound .(a;v \ns) in the pre.x with a witness term v of type s * . a. One can easily check that these terms are always \nin scope (just like thetypevariablesinthe pre.x).Therule CI-HYP simply applies the witness term to transform \ns * to a, i.e. v . Most of the other rules make use of two helper functions, gen[\u00b7] and inst[\u00b7], de.ned \nin Figure 11. These functions introduce evi\u00addence terms v for .exible bounds and remove trivial bounds. \nThe function gen[.(aov s1).s2] takesa SystemFtermof type s2 * and generalizes it to a term of type (.(aos1).s2) \n*. The gen[\u00b7] function ensures that in all cases the type variable a and the evi\u00addence term v of type \ns1 * . a are de.ned andin scope.For conve\u00adnience we use let bindings to de.ne v,even though SystemFdoes \nnot contain them, and one can read those let bindings as a sub\u00adstitution on witness terms.For rigid and \ntrivial bounds, gen[\u00b7] just substitutes s1 for a, and the evidence term v becomes the identity. gen[.(a \nov s).s0] :: s0 * . (.(a os).s0) * gen[.(a = v s).s0] =(let ve = e in )[a . s * ] gen[.(a ;v s).s0] =(let \nve = e in )[a . s * ] i. a/. ftv(s0) =(let ve = e in )[a . s * ] i. nf(s0)= a =(let ve = e in )[a . s \n* ] i. nf(s)= t =.a \u00b7 let ve = e a in i. nf(s)= . =.a \u00b7 .v : s * . a \u00b7 otherwise inst[.(a = s).s0] = \ninst[.(a ;v s).s0] = i. a/. ftv(s0) = i. nf(s0)= a = i. nf(s)= t = a i. nf(s)= . = a v otherwise \nFigure 11. Canonical type generalization and instantiation For an unconstrained bound.(a ;.), a type \nlambda generalizes overa.Foranon-trivial.exiblebound,wenotonly generalizeover the type a,but also bind \nthe evidence v as an argument. Dually, the function inst[.(a ov s1).s2] takes a System F term of type \n(.(a ov s1).s2) * and instantiates it to s2 * (or s1 * if nf(s2)= a), where it is assumed that a and \nv are in scope and where v has type s1 * . a. One can easily check that this is the case for all the \nuses of inst[\u00b7].For rigid and trivial bounds nothing has to be done.For an unconstrained bound we instantiate \nthe type ar\u00adgument to a, andfor a non-trivial .exible bound we instantiate the type argument and pass \nin the evidence function v as an argument. With these helper functions, the evidence translation for \nthe other rules is straightforward. Rule CI-RIGID uses inst[\u00b7] to instan\u00adtiate the .exible quanti.er \nand immediately applies gen[\u00b7] with a rigid bound, which substitutes a for s1 *, and binds v to the identity. \nAnother interesting rule is CI-CONTEXT. Since the bounded types themselves are instantiated, the types \nof the witness functions v and w are not equal and we need tobuild an witness transformer: using the \nevidence f :: s1 * . s2 *, we can de.ne the old witness v :: s1 * . a in terms of the new witness w :: \ns2 * . a, as v = w.f. To de.ne soundnessoftheSystemFtranslation,weneedtobe able to refer to the witness \nterms in the pre.x from the SystemF type environment, and we de.ne the following operation to extract \nsuch environment from the pre.x. De.nition 3.4.a (Sytem-F environment extraction): The environ\u00adment extraction \nfrom a pre.x Q is written as QG and de.ned as: (\u00d8)G = \u00d8 (a = s, Q)G = QG (a;v s, Q)G = v : s * . a, QG \nUsing environment extraction, we can state that the derived Sys\u00adtemF term is well-typed in SystemF. The \ntypingrelation of Sys\u00adtemF(G fF e : s)is standard and we omit it here. Theorem 3.4.b (Soundness of SystemFtranslation): \nIf two types s1 and s2 areinacanonical instance relation underapre.x Q with a witness f, then the witness \nf is well typed inSystemFunder the type environment extracted from Q, with type s1 * . s2 * : (Q) s1 \ns2 f . QT(QG) fF f : QT(s1 * . s2 * ) x : s . G CT-VAR (Q)G fc x : s x (Q)G fc e1 : t2 . t1 e1 (Q)G \nfc e2 : t2 e2  CT-APP (Q)G fc e1 e2 : t1 e1 e2 (Q)G, x : t1 fc e : t2 e CT-FUN (Q)G fc .x.e : t1 . t2 \n.(x : t1 * ) \u00b7 e (Q)G fc e1 : s1 e1 (Q)G, x : s1 fc e2 : s2 e2 CT-LET (Q)G fc let x = e1 in e2 : s2 (.(x \n: s1 * ) \u00b7 e2) e1 (Q,aov s1)G fc e : s2 e a/. ftv(G) CT-GEN (Q)G fc e : .(aov s1).s2 gen[.(aov s1).s2] \ne (Q)G fc e : s1 e (Q) s1 c s2 f CT-INST (Q)G fc e : s2 fe (Q)G fc e : s1 e  -c (Q) s Es1 CT-ANN (Q)G \nfc (e :: s): s e Figure 12. Type rules with evidence translation 3.5 Canonical type rules with SystemFtranslation \nFigure 12 de.nes canonical type rules for MLF that derive a corre\u00adsponding SystemFterm.Thetype rules \nareequivalenttothe corre\u00adspondingMLFtype rules(see Figure2)exceptforthe useof canon\u00adical instancein CT-INST \nand canonical abstractionin CT-ANN. The expression (Q)G fc e : s e states that under a pre.x Q and type \nenvironment G,theexpressione is well typedwith type s,and e isa corresponding SystemFterm with type s \n* . The type directed translation is straightforward. Rule CT-VAR simply returns x, since the condition \nx : s . G implies that x has type s * under the SystemF environment G *, (i.e. G * fF x : s *). In CT-APP, \ne1 and e2 both have monotypes and their System F types are equivalent, and we can directly apply the \ncorresponding System F terms too. The same holds for CT-FUN that directly translates intoa corresponding \nlambdaexpression. Rule CT-LET is interesting as theSystemFtranslation usesa polymorphic lambda expression \nsince SystemFdoes not contain let bindings. Generalization in rule CT-GEN uses the gen[\u00b7] function de\u00ad.ned \nin Figure 11 to generalize the term e with type s2 * into (.(a ov s1).s2) *. The instantiation rule (CT-INST)uses \nthe wit\u00adness function f of type s1 * . s2 *, derived with canonical instance to transform the term e \nto a term of type s2 *. Finally, type annota\u00adtions in CT-ANN use canonical abstraction.By Theorem 3.3.e,their \nSystemFtypes are equal and no translationisnecessary. Theorem 3.5.a (Canonical type inference derives \nwell typedSys\u00adtemF terms): If under a pre.x Q and type environment G an ex\u00adpression e is well typed with \ntype s anda translated SystemFterm e, then thereexistsa SystemF derivation such that undera Sys\u00adtemF \ntype environment consistingof the environment extraction of Q (namely QG)and the translated environmentG \n*, the term e is well typed with type s * . (Q)G fc e : s e . QT(QGG * ) fF QT(e): QT(s * ) Note that \nunder an empty pre.x this simpli.es to: () G fc e : s e . G * fF e : s * 3.6 Soundness By carefully \nchanging the original equivalence, abstraction, and in\u00adstance relation, we were able to derive a type \ndirected and sound SystemFtranslation for instantiation terms. But at the same time we are no longer \ndoing MLF instantiationbut canonical instantia\u00adtion,andwewouldliketo establishthatthenewrelationsaresound \nand completewith respecttotheMLF relations.Clearly,the canon\u00adical relations are sound with respect to \nMLF: Theorem 3.6.a (Canonical equivalence, abstraction, and instance are sound): (Q) s1 =c s2 . (Q) s1 \n= s2 -c (Q) s1 E. (Q) - s2 s2 s1 E (Q) s1 c s2 . (Q) s1 s2 Proof of Theorem 3.6.a: This is immediate \nsince all the new relations are sub-relations of the MLF relations. Equivalence includes all the rules \nof canonical equivalence, and allows rearrangement of .exible binders. Canonical abstraction equals MLF \nabstractionbut restricts equivalence to canonical equivalence. Finally, canonical instance includes an \nextra rule (CI-COMM)to rearrange .exible binders,but this is also included in MLF instantiation byE Q-COMM \n(viaA-EQUIVandI-ABSTRACT). 0 Asacorollary,itfollowsthatthe canonicaltyperulesarealsosound since the only \ndifference with the MLF type rules is the use of canonical instance and abstraction. Theorem 3.6.b (Canonical \ntype inference is sound): (Q)G fc e : s e . (Q)G f e : s 3.7 Completeness Completeness of the type rules \ncannot be established directly since the canonical relations are not complete with respect to the MLF \nrelations.Take forexample the followingequivalent types: (Q) .a\u00df. a . \u00df . a =.\u00dfa. a . \u00df . a These types \nare equivalentbyusing EQ-COMM to rearrange the .ex\u00adible binders. Since canonical equivalence restricts \nrearrangement to rigid binders, the above types are not canonically equivalent (as it should, since the \ncorrespondingSystemFtypes are different). This seemsafatal .awof our new rules: incompleteness would \nimply thatournewrulescanonlybeusedtotypeasubsetofthe programs accepted by MLF. Fortunately,the rules \nare incomplete only with respect to theor\u00adderof the quanti.ers.We can show that the canonical relations \nare complete with respect to the MLF relations under speci.c invari\u00adants where rigid types are in canonical \nform. In the next section we formalize this notion and establish a completeness theorem. 3.7.1 Canonicalform \nFigure 13 de.nes the canonical form ofatype s,written ascan(s). The canonical form is a rearrangement \nof the normal form, where the position of a quanti.er is uniquely determined by the occur\u00adrences of the \nbound type variable. Canonical forms satisfy the fol\u00adlowing properties: Properties 3.7.a i. (Q) s1 = \ns2 . Q.(can(s1)) = Q.(can(s2)) ii. ftv(can(s)) = ftv(s) Asa corrollaryof Property 3.7.a.i,wehaveunderan \nunconstrained pre.x that equivalent types have equal canonical forms: s1 = s2 . can(s1)= can(s2) The \nrearranged form makes use of the insertion function ins(\u00b7, \u00b7) to insert quanti.ers in their canonical \nposition. Insertion of into a can(s)= rf(nf(s)) rf(t )= t rf(.)= . rf(.(a os1).s2)= ins(aorf(s1), rf(s2)) \nins(a os, t )= .(aos).t ins(a os, .)= . ins(a1 os1, .(a2 os2).s) i. a1 = a2 . a2 ./ftv(s1) = if a1#(.(a2 \nos2).s) <a2#s then .(a2 os2). ins(a1 os1,s) else .(a1 os1)(a2 os2).s Figure 13. Canonical and rearranged \nform a#s = max(occurences(a, s) .{0}) occurences(a, s)= {o | select(skeleton(s), o)= a} select(., 1) \n= . select(a, 1) = a select(c t1 ... tn, 1) = c select(c t1 ... tn, i.o)= select(ti, o) skeleton(t )= \nt skeleton(.)= . skeleton(.(a os1).s2)= skeleton(s2)[a . skeleton(s1)] Figure 14. The position of type \nvariable monomorphic type or . has no effect, but otherwise quanti.ers may be rearranged. The side condition \nof the last insertion case can always be satis.ed by simple alpha renaming. The relative order between \nquanti.ersis now uniquely determinedbythe position of their bound variable in the type, written as a#s, \nand is de.ned in Figure 14. The position of a type variable in a type is de.ned as the maximum of all \nits occurrences of in the type, or 0 if the type variable is unbound. This case never occurs for a canonical \nform since the rearranged form is taken over the normal form which discards unbound quanti.ers. To de.ne \nthe occurrences of a type, we .rst de.ne the skeleton of a type(skeleton(s))as the full inlining of all \nits bounds. For example skeleton(.(\u00df ;...a . .).\u00df . a)=(a ..) . a The selection function select(\u00b7, \u00b7) \ntakes such skeleton and a posi\u00adtion, and returns an elementof thatskeleton.Forexample select((a ..) . \n\u00df, 1.1.1) = a select((a ..) . \u00df, 2.1) = \u00df select((a ..) . \u00df, 1.2.1) = . The occurrences of a type variable \nis simply the set of all positions of the type variable in the skeleton, for example occurences(a, .(\u00df \n;... a . .).\u00df . a)= {1.1.1, 2.1} occurences(\u00df, .(\u00df ;... a . .).\u00df . a)= \u00d8 occurences(\u00df, \u00df . a)= {1.1} \nDuring insertion, we have to be careful never to insert beyond dependent binders. In particular, we need \nto ensure that when quanti.ers are rearranged (in the then branch of the last case of insertion) that \na1 ./ftv(s2). Indeed, together with the side conditions on insertion these areexactly the conditions \nunder which we can apply EQ-COMM.Fortunately, the positionof typevariables respects dependence: Lemma \n3.7.b (Insertion respects dependencies): The de.nition of the position of a type variable respects dependence \nbetween binders. a1#(.(a2 os2).s) <a2#s . a1 ./ftv(s2) Proof of Lemma 3.7.b: First note that if a2 ./ftv(s), \nthen the position a2#s =0, and the position of a1 cannot be smaller. Otherwise, if a2 . ftv(s), we can \nprove Lemma 3.7.b by contradiction. Assume that a1 . ftv(s2) (1), where a2#s equals o1.1. In that case, \nthe set of occurrences of a in .(a2 os2).s, namely occurences(a, .(a2 os2).s), contains an occurrence \nfor a with the form o1.o2.1, which is larger or equal to o1.1 (since 0 cannot be part of an occurrence). \nSince the position is the maximum of the occurrences, we have a#(.(a2 os2).s).a2#s. By contradiction, \nthis invalidates the assumption (1), and implies a1 ./ftv(s2). 0 3.7.2 Completeness under canonicalform \nUsing canonical forms, we can now state a completeness theorem for canonical equivalence. Theorem 3.7.c \n(Completeness of canonical equivalence): When\u00adever two types are equivalent, then their canonical forms \nare also canonically equivalent: (Q) s1 = s2 . (Q) can(s1) =c can(s2) This can be provedby straightforward \ninduction over the rules of equivalence. For canonical abstraction, completeness does not hold directly \nsinceCI-HYP abstracts over rigid types in the pre.x. If those types are not in canonical form the rule \nmay not apply.To remedy this situation we are going to de.ne the notion of weak canonical form. De.nition \n3.7.d (Weak canonical form): A type s is in weak canonical form if all its rigid bounds are in canonical \nform. We write sc for typesin weakcanonical form.Apre.x Q is in weak canonical form if all its quanti.ers \nare in weak canonical form, and write Qc for such pre.x. The following properties hold for types in weak \ncanonical form: Properties 3.7.e i. (Qc) scc can(s), a type in weak canonical form instanti\u00adates to its \ncanonical form, and conversely: c sc ii. (Qc) can(s) . Using weak canonical form, we can now state a \ncompleness theo\u00ad rem for canonical abstraction: Theorem 3.7.f (Completeness of canonical abstraction): \nWhen\u00adever two types are in an abstraction relation under a pre.x Q, then their canonical forms are in \ncanonical abstraction relation under a pre.x Qc in weak canonical form: (Q) s1 E) can(s1) Ecan(s2) - \ns2 . (Qc-c For this theorem to hold, it is essential that canonical equivalence can rearrange rigid binders.Takeforexample \nthe following abstrac\u00adtion: .(a = sid). .(. ;sid). .(\u00df = sid). [\u00df ] . [. ] . [a] -c E{ A-PREFIX,A-CONTEXT,A-HYP, \nand EQ-MONO } .(a = sid). .(. ;sid). [a] . [. ] . [a] Alas, although the .rst type is in canonical form, \nthe second one is not. This happens because abstraction can change the occurrences of rigidly bound types \nthrough A-HYP. Therefore, rearrangement of rigid binders is necessary to derive canonical forms. Proof \nof Theorem 3.7.f: By induction over the rules of abstraction: Case A-EQUIV: We have (Q) s1 = s2, and \ntherefore by Theorem 3.7.c, (Qc) can(s1) =c can(s2).By ruleCA-EQUIVwe can now derive (Qc) can(s1) Ecan(s2). \n -c Case A-HYP: We have(a = s) . Q, and by therefore (a = can(s)) . Qc since Qc isin weak canonical form.By \nruleCA-HYP it follows that (Qc) can(s) Ea. -c Case A-CONTEXT: By induction, we have (Qc) can(s1) Ecan(s2) \n-c (1). Since can(.(a = s1).s)= rf(nf(.(a = s1).s)) we proceed by case analysis over the normal form: \nsubcase a ./ftv(s): In this case, it follows directly that can(.(a = s1).s)= can(s)= can(.(a = s2).s). \nsubcase nf(s1)= t1 (2): First we note that due to (2) and (1),can(s2)= t2 (3) for some monotype t2.We \ncan now derive under a pre.x Q: can(.(a = s1).s)= { (2) } can(s)[a . t1] E{ CA-EQUIV,CEQ-MONO } -c \n-c .(a = t1). can(s) E{ CA-CONTEXT,CA-EQUIV, (2) } -c .(a = can(s1)). can(s) E{ CA-CONTEXT, (1) } -c \n.(a = can(s2)). can(s) E{ CA-CONTEXT,CA-EQUIV, (3) } -c can(s)[a . t2]= { (3) }can(.(a = s2). can(s)) \nsubcase nf(s)= a: We have can(.(a = s1).s)= can(s1) (4), and can(s2)= can(.(a = s2).s). ByEQ-REFL,CA-EQUIV, \n(1), and transitity, we can derive (Qc) can(.(as1).s) Ecan(.(a = .(a = t2). can(s) E{ CA-EQUIV,CEQ-MONO \n} = -c s2).s). subcase otherwise: In this case can(.(a = s1).s) equals ins(.(a = can(s1)), can(s2)) where \nthe bound .(a = can(s1)) is inserted into can(s2). But by using CEQ-COMM to rearrange the rigid binder \nwe can bring it back to the front and we can derive (Qc) can(.(a = s1).s) E -c .(a = can(s1)). can(s). \nBy CA-CONTEXT and (1), we know that (Qc) .(a = can(s1)). can(s) E.(a = can(s2)). can(s). Finally, -c \nwe can again apply CEQ-COMM repeatedly to derive (Qc) .(a = can(s2)). can(s) E-c ins(.(a = can(s2)), \ncan(s)) where ins(.(a = can(s2)), can(s)) equals can(.(a = s2).s). Case A-PREFIX: Similar toA-CONTEXT. \nCase A-TRANS:Follows directlyby induction andCA-TRANS. The above completeness theorems are rather weak \nas theyrequire the types to be in canonical form.For canonical instantiation we havea stronger result \nwhereonlyrigid boundsneedtobein canon\u00adical form: Theorem 3.7.g (Completeness of canonical instance): \nWhen two types are in an instance relation under a pre.x Q, then their weak canonical forms are also \nin a canonical instance relation under the same pre.x in weak canonical form: scc (Q) s1 s2 . (Qc) 1 \ns2 c f Proof of Theorem 3.7.g: By induction over the instance relation. Case I-BOTTOM: We have (Q) .r \ns. Using CI-BOTTOM, we can derive (Qc) .rc sc . Case I-ABSTRACT: We have (Q) s1 - Es2. As a consequence \nof Theorem 3.7.f, (Qc) can(s1) Ecan(s2) holds (1). By Property 3.7.e.i -c and Property 3.7.e.ii, we can \nalso derive (Qc) sc rc can(s1) (2), and 1 (Qc) can(s2) rc sc (3). Combining (1), (2), and (3), usingCI-TRANS, \n2 we can derive (Qc) sc rc sc 12. Case I-HYP: We assume(a.s) . Q. This implies (a.sc) . Qc, and byCI-HYP, \n(Qc) sc rc a. Case I-RIGID: We have (Q) .(a.s1).s r.(a = s1).s). By Property 3.7.e.i, (Qc) sc rc can(s1) \n(4). The weak canonical form 1 of .(a.s1).s is .(a.sc ).sc. Using CI-CONTEXT and (4), we in\u00ad 1 stantiate \nto .(a.can(s1)).sc. ByCI-RIGID, this instantiates to .(a = can(s1)).sc which equals (.(a = s1).s2)c . \nCase I-TRANS: Immediateby induction andCI-TRANS. Case I-PREFIX: Immediateby induction andCI-PREFIX. Case \nI-CONTEXT: Immediateby induction andCI-CONTEXT. Using the completeness theorems on the canonical relations, \nwe can .nally state a completeness theorem for the canonical type rules. Theorem 3.7.h (Canonical type \ninference is complete): Ifwe can infer a type s for an expression in e under a certain pre.x Q and environment \nG, there exists a canonical type deriviation where s, Q, and G are in weak canonical form: (Q)G f e : \ns . (Qc)Gc fc e : sc e Proof of Theorem 3.7.h: By induction of the inference rules. Case T-VAR: We have(x \n: s) . G, and therefore, (x : sc) . Gc. By rule CT-VAR, we can derive (Qc)Gc .c x : sc . Case T-APP: \nImmediateby induction. Case T-FUN: Immediate by induction. Case T-LET: Immediate by induction. Case T-GEN: \nByinduction and Property 3.7.a.ii, we havea/. ftv(Gc),and either (Qc,a = can(s1)) Gc .c e : sc or (Qc,a \nsc )Gc .c e : s2c . 21 By rule CT-GEN, we can derive (Qc)Gc .c e : .(a = can(s1)).sc 2 or (Qc)Gc .c \ne : .(asc ).sc where both derived types are in weak 12 canonical form. Case T-INST: Wehave(Q)G . e : \ns1 (1),and(Q) s1 r s2 (2).Bythe inductionhypothesis and(1), wehave (Qc)Gc .c e : sc (3).By Theorem 1 \nc 3.7.g and (2), we can conclude (Qc) s1 c rsc , andbyCT-INST and (3), 2 we have (Qc)Gc .c e : s2c . \nCase T-ANN: We have (Q)G . e : s1 (4), and (Q) - s1 (5). s E By the inductionhypothesis and (4), we \nhave (Qc)Gc .c e : sc . Due 1 to Property 3.7.e.i, we know that (Qc) sc rc can(s1), and we can use 1 \nCT-INST to derive (Qc)Gc .c e : can(s1) (6). As a consequence of Theorem 3.7.f and (5), we have (Qc) \ncan(s1) Ecan(s2) (assuming the -c type annotation is converted to canonical form), and we can useCT-ABS \nwith (6) to derive (Qc)Gc .c (e :: s1): can(s1). UsingCI-INST and Property 3.7.e.ii, we can instantiate \nto (Qc)Gc .c (e :: s1): s1c . 0  3.8 Type inference MLF has an effective type inference algorithm that \ninfers principal types. It is beyond the scope of this paper to discuss type inference in detail,but \nwe remark that the standard MLF inference algorithm can be used to infer types to canonically,as long \nas we maintain the invariants required for completeness (Theorem 3.7.h). In particu\u00adlar, type annotations \nmust be normalized to canonical form, and the pre.x, type environment, and inferred types must be in \nweak canonical form. Ensuring that types are in weak canonical form is easy to do by requiring in the \nupdate algorithm (Le Botlan 2004, page 123) that rigid bounds are only updated with types in canoni\u00adcal \nform, rearranging binders as necessary. No further changes are required. The translation to SystemFtypes \ncan be done similarly to Leijen andL\u00a8oh (2005)but simpli.ed to remove translation for rigid bounds. 4. \nArestrictionto SystemFtypes We have de.ned an elegant type directed translation from MLF to System F, \nwhere only polymorphic .exible bounds require extra evidence and type annotations are needed only on \nlambda bound arguments that are used polymorphically. Even though this is prob\u00adably the best we can hope \nfor, it is interesting to consider a more restricted version. In particular, the (implicit) introduction \nof evidence arguments for polymorphic .exible bounds may be undesirable in practice. Take for example \nour example from Section 2.1: let ids =[id ] in (polyL ids, ids + [inc ]) where ids has type .(a ;sid). \n[a]. In the System F translation, the ids value is transformed into a function that takes an evidence \nargument of type s * id . a. This means that a programmer cannot (Q)G fc e1 : s1 .s0.if (Q)G f e1 : s0 \nthen (Q) s1 s0 (Q) s1 c ftype(s1) (Q)G, x : ftype(s1) fc e2 : s2 F-LET (Q)G fc let x = e1 in e2 : s2 \n-c (Q)G fc e : s1 (Q) s Es1 s is an F-type F-ANN (Q)G fc (e :: s): s Figure 15. New type rules for MLF= \nftype(s)= ftypen(nf(s)) where ftypen(t )= t ftypen(.)= . ftypen(.(a = s1).s2)= .(a = s1). ftypen(s2) \nftypen(.(a ;.).s)= .(a;.). ftypen(s) ftypen(.(a ;.Q.t ).s)= ftypen(.Q.s[a . t ]) Figure 16. Force to \nF-Type assume that let bound values are shared since theycould be trans\u00adlated into functions! The same \nsituation occurs with type classes too, and Haskell introduced the monomorphism restriction that re\u00adjects \nunannotated values that require evidence translation. 4.1 Rigid MLF We consider a restriction of MLF, \ncalled Rigid MLF (MLF=), that never requires evidence translation. To achieve this goal, all bound values \nin MLF= are restricted to standard SystemFtypes, i.e. types without polymorphic .exible bounds, and we \ncall such types F-types De.nition 4.1.a (F-types (Le Botlan 2004)): A type in normal\u00adform is an F-type \nif and only if all its .exible bounds are of the form .(a ;.).Atype is an F-type if an only if its normal \nform is an F-type. Types that are not F-types are exactly those with polymorphic .exible bounds, i.e.atype \n.(a ;s1).s2 where s1 is not equivalent to either a monotype t or .. De.nition 4.1.b (MLF=): We de.ne \nMLF= as a restriction of MLF where both type annotations and let bound values are re\u00adstricted to F-types. \nIn practice, this means that a programmer always writes standard F-type annotations and never MLF types \nwith .exible bounds. Fur\u00adthermore, the restriction of type annotations to F-types effectively restricts \nlambda bound arguments to F-types, and together with the restriction of let bound values to F-types this \nmeans that no evi\u00addence translation is ever necessary. Figure 15 gives the new type rules for let expressions \nand type annotations where we have left out the SystemF translation for clarity. The type annotation \nrule F-ANN just requires that type annotations have an F-type. The rule for let expressions is more involved.We \ncannot just require that the inferred type for the let binding is an F-type since we would lose principal \ntypings. For example, the term[id ] can havetwoF-types, namely [.a. a . a], and .a. [a . a] where neither \nis an instance of the other. Instead, the rule F-LET forces the inferred type to an F-type using the \nfunction ftype(s) de.ned in Figure 16. This function systematically translates a shallow type to an F-type. \nThe .rst four cases of ftypen(\u00b7) are easy: monomorphic types, ., rigid bounds, and unconstrained bounds \nare already in the correct form. The last case deals with non-trivial .exible polymorphic bounds.A concrete \nexample of this case happens for the term [id ] with type .(\u00df ;.a. a . a). [\u00df ]. There are two possible \nstrategies to con\u00advert such term to an F-type. First, we can instantiate and lift the quanti.ers outside \nthe bound, giving .a. [a . a], which we call variant HM. This type is what the Hindley-Milner system \nwould infer for this term, and therefore we chose this strategy for the def\u00adinition of ftypen(\u00b7). Another \npossibility is tokeep the type poly\u00admorphic and instantiate to a rigid bound .(\u00df = .a. a . a). [\u00df ], \nwhich we call variantF.We did not choose this variant since we feel that compatability with Hindley-Milner \nis more important. It is not enough to just force the inferred type for the let bound expressiontoan \nF-type. SincebothvariantHMandvariantFcanbe obtained by instantiation, we can always use the instantiation \nrule toderiveeithervariant,losingprincipaltypingsagain.The solution is simple though: in rule F-LET we \nspecify that the type derived for the let expression must be the most general type and cannot be an instance \nthereof. This most general type is then forced to an F\u00adtype. Requiring let bindings to most general types \nis not new and similar solutions are explored for example by Leroy and Mauny (1993), Garrigue andR\u00b4 emy \n(1999), and Vytiniotis et al. (2006). Standard MLF type inference can be used to infer types for MLF= \nwhere let bound values are of course forced to F-types and type annotations restricted to F-types. Since \nlambda bound arguments are therefore F-types, this implies that rigid bounds are always F-Types too.Types \nwhere all rigid bounds are F-types are called shallow types. Standard type inference works for MLF= because \nall types in MLF= are shallow, and Le Botlan (2004, Section 10.2) showed that standard MLF type inference \nis sound and complete for shallow terms, deriving shallow principal types. 4.2 Expressiveness of MLF= \nIn MLF= our original example let ids =[id ] in (polyL ids, ids + [inc ]) --rejected is no longer accepted. \nAll bound expressions now have simple F\u00adtypes, and ids gets the standard Hindley-Milner type .a. [a . \na] and cannot be passed to polyL which expects a list of polymorphic identity functions. Of course, the \nexpression ids + [inc ] is well\u00adtyped. However, we could type the polyL ids application if we add a type \nannotation though: let ids =[id ] :: [.a. a . a] in polyL ids This is well-typed since the annotation \nis a valid F-type and is not in.uenced by the ftype(\u00b7) coercion in F-LET. Of course, now the application \nids + [inc ] would be ill-typed. We can type check both applications if we inline the let binding and \nno longer try to share the ids value: (polyL [id ], [id ] + [inc ]) In ordertotype checkthisexample,thetype \ninferencer still assigns most general types with .exible polymorphic bounds to interme\u00addiate terms like \n[id ].The reader might worry that this still leads to evidence translation at runtime. However, all bound \nvalues have F-types and we can never abstract over non F-types. In practical terms this means that all \nevidence is always locally known and all remaining evidence translation can always be optimized away. \nHaving intermediate terms with non F-types is very important since it removes the need to annotate impredicative \ninstantiations, and in practice that reduces the number of required type annota\u00adtions signi.cantly.For \nexample, we did not need to annotate the application polyL [id ] even though the list is impredicatively \nin\u00adstantiated. The only type annotations necessary in MLF= are (1) on lambda bound arguments that are \nused polymorphically, and (2) on let bound expressions that contain .exible polymorphic types that should \nstay polymorphic. Admittedly, the second condition is harder to explain. On the bright side, MLF= stays \nfully compatible with Hindley-Milner and in practice few of such annotations are necessary. 5. Related \nwork There have been many proposed extensions to standard Hindley-Milner type inference to support higher-ranked \nor impredicative types. Jones (1997) describes a system that retains a strati.cation between monomorphic \ntypes and type schemes and embed poly\u00admorphic types inside type constructors, where constructor applica\u00adtion \ncorrespond to type abstraction, and pattern matching to type application. OderskyandL\u00a8aufer (1996) describea \ntype system for higher\u00adranked types where higher-ranked arguments need to be annotated with their type. \nPeyton Jones et al. (2007) extend this work where the type rules propagate known type information to \nreduce the annotation burden. Dijkstra (2005) describes a further extension that supports impredicative \ntypes and has bidirectional propagation of type annotations. In earlier work, Garrigue and R\u00b4 emy (1999) \ndescribe a system where polymorphic types are embedded inside monotypeswhere polytypes are marked whether \ntheyare annotated or declared. MLF (Le Botlan andR\u00b4 emy 2003) goesbeyond SystemFtypes to support type \ninference with .rst-class polymorphism. Several variants of MLF and their relation to other systems are \nexplored in (Le Botlan andR\u00b4emy andYakobowski (2007) present emy 2007).R\u00b4an ef.cient graphbased inference \nalgorithm for MLF that has the same complexity as normal Hindley-Milner type inference. Thework most \nclosely related to this article isbyLeijen and L\u00a8 oh (2005), who describe how MLF can be used with the \ntheory of quali.ed types (Jones 1994) and give an algorithm that translates MLF termstoSystemFwhereevidenceis \npassedforall bounded polymorphic types, including rigidly boundtypes. 5.1 Acomparison with boxy types \nRecently, Vytiniotis et al. (2006) introduce boxy type inference where inferred and annotated types are \nelegantly distinguished through boxes in the types. Just like MLF, boxy types support .rst-class polymorphism. \nMoreover,ithasproveditsvaluein prac\u00adtice since it has been implemented in version 6.6 of the Glasgow \nHaskell Compiler (GHC). Directly comparing boxy types and MLF is dif.cult since their formulations differ \nsubstantially, and since MLF is strictly more expressive than boxy types (due to .exible polymorphic \nbounds). MLF= on the other hand is just as expressive as boxy types where allvalues canbegiven SystemF \ntypes.The setof programs ac\u00adceptedbyboxytypesisexactlythe sameasforMLF= modulo type annotations. A interesting \nway of comparing the systems would therefore be to study how type checking behaves under common small \nprogram transformations,forexample,if fx is well typed, is apply f x also well typed? Let us .rst look \nat inlining of let bindings: if let x = e1 in e2 is accepted, is the inlining e2[x . e1] also accepted? \nbinding type HM MLF MLF= boxy monomorphic . . . . polymorphic . . . \u00d7 higher-rank - . . \u00d7 impredicative \n- . . \u00d7 In the above table HM stands for Hindley-Milner type inference. We make a distinction for each \nkind of binding type, where poly\u00admorphic stands for a rank-1 polymorphic Hindley-Milner type. In Hindley-Milner, \nMLF, and MLF= we can always inline a let bind\u00ading and still have a well-typed program. Surprisingly, \nthis does not hold for boxy type inference not even for rank-1 types. This is because the boxy type \nsystem relies crucially on type generaliza\u00adtion at let bindings. Let s assume that ids has type [.a. \na . a], and that we have a function choose of type .a. a . a . a. Now take the following program: let \nf = choose [] in f ids This program is well-typed in all systems (except HM of course) where the type \nof f is .a. [a] . [a] (i.e. a standard Hindley-Milner type). However, if we inline the binding to choose \n[] ids, theboxytypesystemrejectsthis programsinceitfailsto generalize the intermediate choose [] term \n(and annotations do not help ). We now take a look at the inverse of inlining: ife2[x . e1] is accepted, \nis the abstraction let x = e1 in e2 also accepted? binding type HM MLF MLF= boxy monomorphic . . . . \npolymorphic . . . . higher-rank - . ann ann impredicative - . \u00d7 \u00d7 In the abovetable ann means that the \nabstracted let binding might need an annotation. Of all systems, only MLF allows this transfor\u00admation. \nHM, MLF=, and boxy types allow it for standard Hindley-Milner typesbuthigher-rank types may need an annotation. \nThis happens speci.cally when a function returns a higher order func\u00adtion. Suppose g has type (Int . \n(.a. a . a)) . Int, then the expression g (.x.id) is well typed in MLF, MLF=, and boxy types. The abstraction \nhowever is only accepted in MLF: let f = .x.id in gf In both boxy types and MLF= we need to annotate \nthe binding. Without annotation, both systems assign the type.a\u00df. a . (\u00df . \u00df) which is not polymorphic \nenough. The binding f must be anno\u00adtated with the type .\u00df. \u00df . (.a. a . a), Impredicative types cannot \nbe abstracted in general in MLF= and boxy types. Whenever such type requires a non-trivial .exible polymorphic \nbound in MLF,both MLF= andboxy typesfailtotype it and with good reason: without evidence translation, \nthere is not evena possible SystemFtranslation(See Section 3.1). The .nal transformation we study is \nthe apply transformation: if e1 e2 is well typed, is apply e1 e2 also accepted? HM MLF MLF= boxy apply \n. . . ann In Section2 we argued that thisa particularly important transfor\u00admation since it enables general \nabstraction over polymorphic val\u00adues. Unfortunately, this property does not hold for boxy types as impredicative \ninstantiationneedsa type annotation.Take forexam\u00adple the application of runST (return 1) where runST \nhas type .s. ST s a.To type apply runST (return 1), we need to anno\u00adtate the full instantiation type \nof apply: (apply :: ((.s. ST s Int) . Int) . (.s. ST s Int) . Int) runST (return 1) Aheavyburden indeed! \n6. Conclusion and future work Wepresentedatypedirected translationofMLFto SystemFterms. This is important \nin practice in order to compile MLF typed pro\u00adgrams ef.ciently. In particular, when MLF is extended with \nqual\u00adi.ed typesitis essentialtohavea translationschemeto SystemF that can accomodate evidence translation \nfor quali.ed types, and we hope that the presented translation increases adoption of MLF. Even thoughMLFisvery \nattractiveasan inference systemfor .rst\u00adclass polymorphism, it is a drawback that users are exposed more \ncomplicated MLF types. Inspired by MLF=, we recently discov\u00aderedatype system for .rst-class polymorphism, \ncalled HMF,which is much simpler than MLF.It uses just regular SystemFtypes and is stillveryexpressive.Forexample,if \ne1 e2 is well typed, then apply e1 e2 is well typed too.We are currently studying the prop\u00aderties of \nthis system (Leijen 2007). References Atze Dijkstra. Stepping through Haskell. PhD thesis, Universiteit \nUtrecht, November 2005. Jaques Garrigue and Didier R\u00b4emy. Semi-expicit .rst-class poly\u00admorphism for ML. \nJournal of Information and Computation, 151:134 169, 1999. J.R. Hindley. The principal type scheme of \nan object in combina\u00adtory logic. Transactions of the American Mathematical Society, 146:29 60, December \n1969. Mark P. Jones. First-class polymorphism with type inference. In Proceedings of the Twenty Fourth \nAnnual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages. ACM Press, January 1997. \nMark P. Jones. Quali.ed types in Theory and Practice. Distin\u00adguished Dissertationsin Computer Science. \nCambridgeUniver\u00adsity Press, 1994. Didier Le Botlan. MLF:Une extension de ML avec polymorphisme de second \nordre et instanciation implicite. PhD thesis, INRIA Rocquencourt, May 2004. Available in English. DidierLe \nBotlanand DidierR\u00b4emy. MLF: RaisingMLtothepower of System-F. In Proceedings of the International Conference \non Functional Programming (ICFP 2003), Uppsala, Sweden,pages 27 38.ACM Press, aug 2003. Didier Le Botlan \nand Didier R\u00b4emy. Recasting MLF. Technical Report 6228, INRIA, Rocquencourt, June 2007. URL http: //gallium.inria.fr/~remy/project/mlf. \nDaan Leijen. HMF: simple type inference for .rst-class polymor\u00adphism. Work in progress, July 2007. Daan \nLeijen and AndresL\u00a8oh. Quali.ed types for MLF. In The In\u00adternational Conference on Functional Programming \n(ICFP 05). ACM Press, September 2005. Xavier Leroy and Michel Mauny. Dynamics in ML. Journal of Functional \nProgramming, 3(4):431 463, 1993. Robert Milner. Atheory of type polymorphism in programming. Journal \nof Computer and System Sciences, 17:248 375, 1978. Martin Odersky andKonstantinL\u00a8Putting type annotations \naufer. to work. In 23th ACM Symp. on Principles of Programming Languages (POPL 96), pages 54 67, January \n1996. Simon Peyton Jones, Dimitrios Vytiniotis, StephanieWeirich, and Mark Shields. Practical type inference \nfor arbitrary-rank types. Journal of Functional Programming, 17(1):1 82, 2007. DidierR\u00b4emy and BorisYakobowski. \nAgraphical presentation of MLF types with a linear-time uni.cation algorithm. In TLDI 07: Proc. of the \n2007ACM SIGPLAN int. workshop onTypes in languages design and implementation, pages 27 38, 2007. DimitriosVytiniotis, \nStephanieWeirich, and Simon Peyton Jones. Boxy types: type inference for higher-rank types and impredica\u00adtivity. \nIn The International Conference on Functional Program\u00adming (ICFP 06), September 2006.    \n\t\t\t", "proc_id": "1291151", "abstract": "<p>The MLF type system by Le Botlan and R&#233;my is a natural extension of Hindley-Milner type inference that supports full first-class polymorphism, where types can be of higher-rank and impredicatively instantiated. Even though MLF is theoretically very attractive, it has not seen widespread adoption. We believe that this partly because it is unclear how the rich language of MLF types relate to standard System F types. In this article we give the first type directed translation of MLF terms to System F terms. Based on insight gained from this translation, we also define \"Rigid MLF\" (MLF<sup>=</sup>), a restriction of MLF where all bound values have a System F type. The expressiveness of MLF<sup>=</sup> is the same as that of boxy types, but MLF<sup>=</sup> needs fewer annotations and we give a detailed comparison between them.</p>", "authors": [{"name": "Daan Leijen", "author_profile_id": "81100572466", "affiliation": "Microsoft Research, Redmond, WA", "person_id": "PP39086150", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291169", "year": "2007", "article_id": "1291169", "conference": "ICFP", "title": "A type directed translation of MLF to system F", "url": "http://dl.acm.org/citation.cfm?id=1291169"}