{"article_publication_date": "10-01-2007", "fulltext": "\n Experience Report: Scheme in Commercial Web Application Development Noel Welsh David Gurnell School \nof Computer Science Untyped Ltd University of Birmingham 111 Durley Dean Road Birmingham Birmingham B15 \n2TT B29 6RY UK UK nhw at cs dot bham dot ac dot uk dave at untyped dot com Abstract Over the past year \nUntyped has developed some 40 000 lines of Scheme code for a variety of web-based applications, which \nreceive over 10 000 hits a day. This is, to our knowledge, the largest web\u00adbased application deployment \nof PLT Scheme. Our experiences developing with PLT Scheme show that de.ciencies in the existing infrastructure \ncan be easily overcome, and we can exploit advanced language features to improve productivity. We conclude \nthat PLT Scheme makes an excellent platform for developing web-based applications, and is competitive \nwith more mainstream choices. Categories and Subject Descriptors D. Software [D.1 Program\u00adming Techniques]: \nD.1.1 Applicative (Functional) Progrmaming General Terms Economics, Languages Keywords Web, Scheme 1. \nIntroduction Languages such as Java, Python, and Ruby are popular for web\u00adapplication development in \nlarge part due to their well developed libraries that target this domain. Modern functional programming \nlanguages have powerful features that make them attractive to de\u00advelopers but these same languages typically \nhave many fewer li\u00adbraries than mainstream alternatives. A developer choosing a func\u00adtional language \nis gambling that the cost of library development is lower than the bene.ts accrued from a more expressive \nlanguage. Our experience with PLT Scheme shows this is the case. Over the last year we have delivered \nweb-based applications to the School of Biological and Chemical Sciences, Queen Mary University of London \n(QMUL) to produce customisable staff and course home pages, record coursework marks and attendance, record \nstudent registration information, and handle incoming stu\u00addent applications. The combined applications \nreceive about 10,000 requests per day in peak periods. All server-side code, some 40,000 lines, is written \nin PLT Scheme, with some client-side (web browser) code using the Flapjax functional-reactive framework \nfor Permission to make digital or hard copies of all or part of this work for personal or classroom use \nis granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n07, October 1 3, 2007, Freiburg, Germany. Copyright c &#38;#169; 2007 ACM 978-1-59593-815-2/07/0010. \n. . $5.00 Javascript (Meyerovich et al. 2007). We believe we are the .rst people to deploy a web application \nusing PLT Scheme on such a scale. 2. Architecture of the QMUL software The high level architecture for \nthe QMUL software is a pipeline, a fairly standard structure for a web application. The pipeline starts \nwith a HTTP request received from a web browser, and ending with an HTTP response send to the browser. \nA typical pipeline consists of the following stages: 1. choose computation: resume a previous one, or \nstart a new one; 2. authentication; 3. extraction and parsing of form data; 4. validation; 5. query \ndatabase; 6. process query results; 7. generation of continuations; 8. rendering user interface. \n We have developed two libraries to implement most of this func\u00adtionality. Lylux, with support from the \nPLT web server, implements all the stages that do not involve the database, whilst Snooze han\u00addles all \nthe database interaction. 2.1 Architecture of Lylux The main abstractions in Lylux are controllers, pipelines1,and \ncomponents. A controller is the start point for a web computation. Each dis\u00adtinct action in an application \n(for example, updating course infor\u00admation) is associated with a controller, and each controller is asso\u00adciated \nwith a unique URL and a unique processing pipeline. Con\u00adtrollers and pipelines are .rst class values \nso they can be composed in the usual ways. For example, the following code de.nes a con\u00adtroller called \nupdate-course, which is a function of a single argu\u00adment, and associates a pipeline that allows only \nsuperuser access. (de.ne-controller update-course (make-request-pipeline #t allow-superusers) (lambda \n(course) ...)) 1 Note that a pipeline in the Lylux sense starts processing after a computa\u00adtion is chosen \nin step 1 of the list above. Pipelines allow sharing of common preprocessing steps be\u00adtween controllers, \nand querying of pipeline stages. For example, code embedding a link to a controller can query the controller \ns pipeline for its security predicate and insert a greyed-out link if the current user is not able to \naccess the controller. A pipeline is simply a list of pipeline stages. For example: ;; make-request-pipeline \n: boolean (. boolean) . (list-of stage) (de.ne (make-request-pipeline use-idcheck? security-predicate) \n(list init-log-stage catch-exn-stage . . . ;; Other stages (make-security-stage security-predicate) log-entry-stage)) \nA pipeline stage is in turn a name and a function of any number of arguments: a success continuation \n(which does not return) plus any arbitrary number of additional arguments unique to a given pipeline. \nWe use this continuation passing style so pipeline stages can install values, such as exception handlers \nand parameters, in the dynamic extent of the succeeding stages. ;; init-log-stage : pipeline-stage (de.ne \ninit-log-stage (make-stage init-log (lambda (success . args) (with-log-preamble default-log-preamble \n(apply success args))))) Having de.ned a controller and a pipeline we can install a controller at a speci.c \nURL using code such as: (de.ne dispatch-table (list . . . ;; Other controllers (make-rule update-course \n(make-pattern root-uri \"/admin/courses/edit/\" (course-arg))))) Note that the URL includes a course-arg, \nwhich associates a fragment of the URL with a course, automatically retrieving the URL fragment to a \ncourse when starting the controller, and automatically converting a course to a URL fragment when a link \nto the controller is embedded in a page. We dispatch on the request URL with a single call to the dispatch \nfunction. Typically, code within a controller assembles a page from a number of components, and renders \nthe page with a call to re\u00adspond/page. A component is a coherent and reusable unit of func\u00adtionality \nwhich usually encapsulates some state. A page is the pri\u00admary container component, and we have developed \na number of widget components such as forms, text boxes, and lists. Each com\u00adponent is an object, written \nin PLT Scheme s object system (Flatt et al. 2006), and implementing an interface with methods to render \na component to HTML, determine if the component has changed since the last rendering, and update internal \nstate from a new re\u00adquest. State is stored in web cells (McCarthy and Krishnamurthi 2006), which interact \nwith continuations in a sensible manner. With a slight modi.cation to the web cell API we are able to \nautomati\u00adcally determine if a value has changed since the last rendering. 2.2 Architecture of Snooze \nThe principle abstraction in Snooze is the persistent structure, which extends PLT Scheme s structure \nde.nitions with database storage types. For example, a University course might be de.ned as follows: \n(de.ne-persistent-struct course ((code type:symbol) (name type:text) (credits type:integer) (rating type:real) \n(active type:boolean) (start type:time-tai))) Creating a persistent structures and saving it to the database \nis a few lines of code. Snooze also provides an SQL-like query languages, implemented as a combinator \nlibrary. For example, to .nd all courses ordered by name we can write: (s:select (s:alias a entity:course) \n(s:order (s:asc a name)) (s:limit limit offset)) Query results are represented as generators (Liskov \n1996), functions of no arguments that yield a new result from the query on each application. Generators \nare memory ef.cient, and we have developed the usual iterator functions (map, fold, and so forth) to \nmake working with them as easy as working with lists. We presently support the PostgreSQL and SQLite \ndatabase en\u00adgines, generating SQL customised to each.  3. Library Support Our software relies on many \nother libraries in addition to Lylux and Snooze. The PLT Scheme web server (Krishnamurthi et al. 2007) \nis perhaps the most critical library we use. It stands between the web browser and our application code, \nand provides an API that hides the complexity of parsing HTTP requests and generating HTTP responses. \nMore importantly it supports continuation based web applications, which provides several advantages we \ndiscuss later. Many other libraries in the PLT Scheme distribution are used in our daily coding. The \nprinciple ones are: the net library, which provides functions to encode and decode form-urlencoded data, \nand make HTTP GET and POST re\u00adquests;  keyword and optional-argument functions, implemented as macros, \nallow us to provide .exible interfaces to functions;  a number of SRFIs (Sperber et al. 2007), particularly \nstring and date libraries, cut, and eager comprehensions;  pattern matching, based on (Wright and Duba \n1995);  the contracts library (Findler and Felleisen 2002), used to en\u00adforce invariants in our programs. \n Two external libraries are crucial to our system. The SPGSQL driver for the PostgreSQL database (Culpepper \n2007) provides the back end we currently use to connect Snooze to our database. The SSAX XML parser (Kiselyov \nand Lisovsky 2002) is used to process XML data we receive from external systems. 4. Advantages of PLT \nScheme We were motivated to use PLT Scheme by the rich set of abstrac\u00adtions at our disposal. We now analyse \nhow these abstractions are used in the software system we have described above. Continuations allow us \nto program without the inversion of con\u00adtrol symptomatic of conventional web development. The advan\u00adtages \nare well documented; see (Krishnamurthi 2003) and (Bridgen et al. 2003) for example. The primary bene.t \nis that we completely remove a class of bugs brought about by the manual continuation\u00adpassing style transformation \nforced upon conventional web appli\u00adcations. Bookmarking URLs can be an issue in continuation based web \napplications. The URL contains a key to a continuation stored on the server. Continuations consume memory \non the web server, and so they must be expired at regular intervals to ensure bounded memory consumption. \nThis means bookmarked URLs will become stale with time. Recall that we associate each controller with \na unique URL. If we receive a request for an expired continuation we simply redirect the user to the \nstarting point of the controller associ\u00adated with the URL. This provides an acceptable solution. Choosing \nwhen and which continuations to expire is a more dif.cult problem. We discuss our experiences in Section \n5. First class functions are a natural accompaniment to continu\u00adations. Request handler procedures can \nbe embedded directly in links in HTML: the web server dispatches requests to the ap\u00adpropriate handler \n(Hopkins 2003). We also .nd many other uses for .rst class functions. For example the combinators in \nSnooze s query language provide better abstraction than if we were to use strings, and prevents SQL injection \nby correctly quoting all data in the query. Parameters are a form of thread-and continuation-local dynam\u00adically \nscoped variable (Moreau 1998) that provide us with a con\u00advenient way to pass con.guration and request \ndata to an applica\u00adtion. This prevents unwieldy argument lists, and race conditions that would result \nfrom using global variables. Hygienic macros provide extendable syntax (Dybvig 1992). Macros are hugely \nimportant in our programming. For example, we extend the PLT Scheme object system (itself written using \nmacros) in Lylux to include special syntax for declaring cells and child com\u00adponents, and we use this \ninformation to automatically propagate changes up the component hierarchy. The de.ne-persistent-struct \nform in Snooze is also implemented as a macro. PLT Scheme s module system (Owens and Flatt 2006) supports \nboth internal linking and external linking (module parameterised by other modules). The former is standard, \nbut the latter is not found in many languages. Parameterised modules are useful in a number of situations. \nFor example, Snooze is parameterised by the database backend it uses, and the web server can be easily \nassembled in many different con.gurations using this technology. 5. Issues Encountered During Development \nThere were a number of set-backs during development of the QMUL software, which fall into two categories. \nFirstly, we had a number of issues with libraries that had not been tested up load. Secondly, many of \nour libraries are missing features due to time constraints. 5.1 Problems Under Load We have struggled \nwith memory consumption in the PLT web server. Continuations in the web server are freed based on a least \nrecently used (LRU) used policy. Each continuation is assigned a set number of life points when it is \ncreated. Points decrease over time, and the rate of change increases when memory consumption is high. \nWhen there are no remaining points, references to the continuation are dropped and it may be reclaimed \nby the garbage collector. In most cases this policy keeps our memory consumption stable around 300MB \nwith no adverse effects. However we have come across situations this policy fails to behave well. Large \n.le uploads are problematics as the web server automat\u00adically decodes the entire .le into memory. Thus \na large .le causes all continuations to be freed, and users receive an error messages. This is aggravated \nby the LRU policy, as the most recently created continuation, the .le upload process, is the one that \nis taking up the most memory. This is an example of a failure of user isolation, a classic problem in \noperating systems. The .le upload user should not be able to impact other users of the system. So we \nsee the in\u00adteraction of two problems: a poor design choice, and a failure to implement user isolation \nin continuation management leading to a bad behaviour. There is a path to .x both problems. PLT Scheme \nprovides a port abstraction for .le handles, sockets, and other similar devices. The memory consumption \nof a port is dominated by it s small internal buffer and there are ef.cient port copying procedures. \nIt will be relatively simple, though tedious, to change the web server to present .le uploads as ports \nthat can then be decoded straight to disk. PLT Scheme also provides a memory accounting system (Wick \nand Flatt 2004) which will allow proper user isolation to be implemented in the LRU policy. We have had \nanother major issue with the web server crashing every two or three days. This was a major concern (and \ncause of embarrassment), and it took several weeks, with the support of Matthew Flatt, the primary developer \nof MzScheme, to isolate the fault to the logging module of the web server. What should have been a tail \nrecursive loop consumed stack space by installing a new exception handler with every recursion, exhausting \nthe stack after a few thousand iterations. This error would have been uncovered by any demanding use \nof the web server; we just had the bad luck to be the .rst. We lost between two and four weeks .xing \nthis error. Our earliest versions of Snooze used the SQLite database. We experienced problems with concurrent \naccess to the database under high load, and switched to the PostgreSQL database. This involved adding \nSSL support to the SPGSQL driver and took several weeks of development. 5.2 Missing Features We are \nhappy with the architecture of Snooze but there are many features we have not had time to implement, \nof which the most important are: relationships between persistent structures;  subtyping of persistent \nstructures;  our current query language is quite expressive but a touch baroque. We would like to reimplement \nit with a solid ground\u00ading in the relational algebra, and add support for additional features such as \nstored procedures. Lylux is less mature than Snooze. We are on our second major rewrite of Lylux, and \nstill feel we have not found the right abstrac\u00adtions. In particular the control .ow is too complicated \nand the level of abstraction too low. OO style event handlers invert the .ow of control, making pro\u00adgram \ncomprehension dif.cult with a concomitant increase in de\u00adbugging time. We would like to implement a functional \nreactive system along the lines of Yampa (Nilsson et al. 2002) and Fr-Time (Cooper and Krishnamurthi \n2006). Synchronous systems like Yampa are relatively limited in their expressiveness but fast and simple \nto implement. Asynchronous systems like FrTime are ex\u00adpressive but relatively computationally expensive, \nand more com\u00adplex to implement. We expect we would bene.t from a hybrid sys\u00adtem: AJAX systems are best \nviewed as asynchronous, but tradi\u00adtional web applications are synchronous. We haven t had the time to \ncomplete a prototype implementation to properly evaluate our needs. Many parts of a web application follow \na repetitive cycle of view/edit/commit pages. For these systems it should be possible to generate most \nof the code. There is some prior work on this problem (Achten et al. 2004), but we have not had time \nto fully explore the literature.  6. Comparison to Other Systems It is clear that by choosing to develop \nin PLT Scheme we have had to develop deal with issues that would not arise with a more mature platform. \nHowever, these costs are a one off. More important is to consider how our fundamental model compares \nagainst that offered by other systems. We do this here, comparing against J2EE and Ruby on Rails. Continuations \ngreatly simplify a number of issues in web pro\u00adgramming. Take, for example, the issue of storing data \nbetween requests. This is trivial in a continuation based system: the data is bound to a name with the \nusual scoping rules of the programming language. The Java Servlets and Ruby on Rails solution require \nthe user to set a location, keyed by string, in a framework provided ob\u00adject that lasts for the request, \nsession, or application lifetime. Us\u00ading strings as keys is prone to misspelling errors, and collisions \nbetween common names. Furthermore these bindings are not stat\u00adically apparent in the code and so not \namenable to static analysis. Finally, these solutions do not interact gracefully with the back but\u00adton. \nSnooze has obvious comparisons to Hibernate (Java) and Ac\u00adtiveRecord (Ruby on Rails). We start by noting \nthat Snooze lacks some features found in these other libraries, solely due to lack of time. Both Java \nand Scheme require that all names are statically known at run-time2, and must solve the problem of introducing \nrecord names from record de.nitions. Hibernate solves this prob\u00adlem by generating Java code from a XML \nspeci.cation, which re\u00adquires the programmer learn a new language and introduces another step to the \ncompilation process. The de.ne-persistent-struct macro is a convenient alternative. ActiveRecord has \na similarly succinct style, which is possible as Ruby allows run-time code to introduce names, at the \nexpense of compile time checking. Given that we lose no important .exibility with the Scheme system we \nprefer it over ActiveRecord. Ruby on Rails has poor support for components. Its primitive system only \nallows components to return HTML and there is no support for event handlers or other forms of dependency \ntracking. JavaServer Faces is a more advanced system, providing an object\u00adoriented framework that is \ncomparable to classic OO GUI frame\u00adworks and so can be seen as a more developed version of Lylux. We \nhave already noted that we feel FRP style is a superior solution. 7. Conclusions Our experience developing \nweb applications in PLT Scheme com\u00adpares favourably to our experience developing with other lan\u00adguages. \nWe have spent much effort developing libraries and .x\u00ading errors that would not have been an issue with \na more mature platform, but we can use a range of language features not avail\u00adable elsewhere. After an \ninitial one-off startup cost we feel this tradeoff has worked in our favour. We have shown that continuation \nbased web applications developed in PLT Scheme are feasible and robust. The basic technology is mature \nand what is required now is re.nement of the libraries. This will take time but the problems are not \ninsurmountable and in many cases straightforward to solve. Our experiences suggest the end result will \nbe a major improve\u00adment over presently available solutions.  Acknowledgments We wish to thank the developers \nof PLT Scheme, particularly Matthew Flatt and Jay McCarthy, for support and patience in deal\u00ading with \nour many questions, and Matthew Jadud and the anony\u00admous reviewers for their helpful comments. 2 We take \nrun-time to be the time after macro expansion time. Macros may introduce new names but run-time code \nmay not. References Peter Achten, Marko van Eekelen, Rinus Plasmeijer, and Arjen van Weelden. Arrows \nfor generic graphical editor components. Technical Report NIII-R0416, Radboud University Nijmegen, 2004. \nMichael Bridgen, Noel Welsh, and Matthias Radestock. Scheme in the real world: A case study. In International \nLisp Conference 2003, August 2003. Gregory H. Cooper and Shriram Krishnamurthi. Embedding dynamic data.ow \nin a call-by-value language. In European Symposium on Pro\u00adgramming, 2006. Ryan Culpepper. SPGSQL. http://planet.plt-scheme.org/,April \n2007. R. Kent Dybvig. Writing hygenic macros in Scheme with syntax-case. Technical Report TR-356, Computer \nScience Department, Indiana Uni\u00adversity, June 1992. Robby Findler and Matthias Felleisen. Contracts for \nhigher-order functions. In International Conference on Functional Programming (ICFP), 2002. Matthew Flatt, \nRobby Findler, and Matthias Felleisen. Scheme with classes, mixins, and traits. In Asian Symposium on \nProgramming Languages and Systems (APLAS), 2006. Peter Walton Hopkins. Enabling complex ui in web applications \nwith send/suspend/dispatch. In Scheme Workshop 2003, November 2003. Oleg Kiselyov and Kirill Lisovsky. \nXML, XPath, XSLT implementations as SXML, SXPath, and SXSLT. In International Lisp Conference (2002), \nSeptember 2002. URL http://okmij.org/ftp/papers/SXs.pdf. Shriram Krishnamurthi. The Continue server (or, \nhow I administered PADL 2002 and 2003). In Practical Aspects of Declarative Languages (PADL 03), January \n2003. Shriram Krishnamurthi, Peter Walton Hopkins, Jay McCarthy, Paul T. Graunke, Greg Pettyjohn, and \nMatthias Felleisen. Implementation and use of the PLT Scheme web server. Higher-Order and Symbolic Com\u00adputation, \n2007. Barbara Liskov. A history of CLU. In History of programming languages II, pages 471 510, New York, \nNY, USA, 1996. ACM Press. ISBN 0\u00ad201-89502-1. Jay McCarthy and Shriram Krishnamurthi. Interaction-safe \nstate for the web. In Scheme and Functional Programming, 2006, September 2006. Leo Meyerovich, Michael \nGreenberg, Gregory Cooper, Aleks Brom.eld, and Shriram Krishnamurthi. Flapjax. http://.apjax-lang.org, \nApril 2007. Luc Moreau. A syntactic theory of dynamic binding. Higher-Order and Symbolic Computation, \n11(3):233 279, December 1998. ISSN 1388\u00ad3690. Henrik Nilsson, Antony Courtney, and John Peterson. Functional \nreactive programming, continued. In Proceedings of the 2002 ACM SIGPLAN Haskell Workshop (Haskell 02), \npages 51 64, Pittsburgh, Pennsylvania, USA, October 2002. ACM Press. Scott Owens and Matthew Flatt. From \nstructures and functors to modules and units. In International Conference on Functional Programming (ICFP), \n2006. Mike Sperber, Francisco Solsona, David Van Horn, Donovan Kolbly, Shri\u00adram Krishnamurthi, Dave Mason, \nand David Rush. Scheme requests for implementation. http://srfi.schemers.org/, April 2007. Adam Wick \nand Matthew Flatt. Memory accounting without partitions. In International Symposium On Memory Management \nISMM 04, October 2004. A. Wright and B. Duba. Pattern matching for scheme. Technical Report TX 77251-1892, \nRice University, May 1995.  \n\t\t\t", "proc_id": "1291151", "abstract": "<p>Over the past year Untyped has developed some 40'000 lines of Scheme code for a variety of web-based applications, which receive over 10'000 hits a day. This is, to our knowledge, the largest web-based application deployment of PLT Scheme. Our experiences developing with PLT Scheme show that deficiencies in the existing infrastructure can be easily overcome, and we can exploit advanced language features to improve productivity. We conclude that PLT Scheme makes an excellent platform for developing web-based applications, and is competitive with more mainstream choices.</p>", "authors": [{"name": "Noel Welsh", "author_profile_id": "81337494453", "affiliation": "University of Birmingham, Birmingham, United Kingdom", "person_id": "P900684", "email_address": "", "orcid_id": ""}, {"name": "David Gurnell", "author_profile_id": "81337489786", "affiliation": "Untyped Ltd, Birmingham, United Kingdom", "person_id": "P900675", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291175", "year": "2007", "article_id": "1291175", "conference": "ICFP", "title": "Experience report: scheme in commercial web application development", "url": "http://dl.acm.org/citation.cfm?id=1291175"}