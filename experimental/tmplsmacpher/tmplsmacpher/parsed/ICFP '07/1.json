{"article_publication_date": "10-01-2007", "fulltext": "\n PROGRAM-ing Finger Trees in COQ Matthieu Sozeau Univ.Paris Sud, CNRS, Laboratoire LRI, UMR 8623, Orsay, \nF-91405 INRIA Futurs, ProVal,Parc Orsay Universit\u00b4 e, F-91893 sozeau@lri.fr Abstract Finger Trees (Hinze \nand Paterson 2006) are a general purpose persistent data structure with good performance. Their genericity \npermitsdevelopingawealthofstructureslike ordered sequencesor interval trees on top of a single implementation. \nHowever, the type systems used by current functional languages do not guarantee the coherent parameterization \nand specialization of Finger Trees, let alonethe correctnessof their implementation.Wepresentacerti.ed \nimplementation of FingerTrees solving these problems using the PROGRAMextensionofCOQ.Wenotonly implementthestructure \nbutalsoproveitsinvariantsalongtheway, whichpermitbuilding certi.ed structuresontopof FingerTreesinanelegantway. \nCategories and Subject Descriptors D.2.4 [Software/Program Veri.cation]: Correctness proofs,Formal methods; \nF.3.1[Speci\u00adfying andVerifying and Reasoning about Programs]: Mechanical veri.cation, Speci.cation techniques \nGeneral Terms Algorithms, Languages,Veri.cation Keywords Coq, DependentTypes, FingerTrees, Certi.cation \n1. Introduction FingerTrees are based on an optimizationof 2-3 trees whichgives constant or in the worst \ncase logarithmic amortized time to the usual sequence operations, from adding an element at either end \nto splitting at an arbitrary location. Suf.ce to say that it has been in\u00adtegrated as the Data.Sequence \nimplementation in H ASKELL 6.6 to witness thefact thatitisa practical, useful data structure. Our .rst \ncontribution will be to show that the implementation given by Hinze&#38;Patersonis correct, which means \nthat all functions are ter\u00adminating and that the invariants of FingerTrees are respected. In fact, as \nthe invariants are part of our data structure we will also carry the properties to the client side, which \nlead us to our sec\u00adond contribution, a certi.ed implementation of random-access se\u00adquencesbuiltontopof \nFingerTrees.Thisdevelopment 1wasmade possible using the PROGRAM extension of COQ. It is based on a high-level \nprogramming language(RUSSELL)which permits writ\u00ading functional programs with rich speci.cations and a \ntranslation to COQ generating proof obligations. This paper also serves as a gentle introductiontoPROGRAM-inginCOQ. \n1www.lri.fr/~sozeau/research/russell/fingertrees.en.html Permission to make digital or hard copies of \nall or part of this work for personal or classroom use is granted without fee provided that copies are \nnot made or distributed for pro.t or commercial advantage and that copies bear this notice and the full \ncitation on the .rst page.To copyotherwise, to republish, to post on servers or to redistribute to lists, \nrequires prior speci.c permission and/or a fee. ICFP 07, October 1 3, 2007, Freiburg, Germany. Copyright \nc &#38;#169; 2007ACM 978-1-59593-815-2/07/0010...$5.00 The remaining of this paper is organized as follows: \nin sections 2and3wegivea short introductiontoCOQ andRUSSELL respec\u00adtively, walking through simple examples. \nThen we move on to the implementationof FingerTrees,in section4, their specializationin section5 and \ntheirextractionin section6.We .nally discuss our method and results in section 7. No prior knowledge \nof the COQ toolis assumed,but practiceofa typed functional languageis rec\u00adommended.Familiarity with FingerTreesis \nnot required either. Notations Thebulkof this paper consistsofa setof literateCOQ .les processed by the \ncoqdoc tool. COQ code is typeset with the usual mathematical style; variable and de.nition names are \ntypeset in italic, inductive types and constructor names are typeset in sans\u00adserif and languagekeywords \nare typesetin typewriter font. 2. Preliminaries In this section we present COQ s underlying calculus \nand some features of the tool we use in the rest of the paper. It can be safely skippedbyCOQ users. 2.1 \nCIC power COQ is a proof assistant based on the Calculus of Inductive Con\u00adstructions(C IC),averypowerfultypesystemandlogical \nlanguage. It relies on the Curry-Howard isomorphism between proofs and programs, types and logical statements \nto provide an environment in which programming and proving are seemingly intermingled. CICisanextensionofthe \nCalculusof Constructions(CC),the rich\u00adest type system of Barendregt s .-cube, which integrates polymor\u00adphic, \ndependent types with highly expressive (co-)inductive types. The environmentbuilt around thiskernel allows \nusers to do inter\u00adactivetheorem proving of mathematical developments and certi.ed programming using the \nunderlying .-calculus.It providesfacilities to de.ne datatypes and functions likearegular functional \nprogram\u00adming languagebutitalsogivesthe abilityto writerich speci.ca\u00adtionsand construct proofsinthe same \nlanguageviewedasahigher\u00adorder logic. We presentthe typing rulesofCCin .gure1 asa reminder.We willextend \nthem when de.ningRUSSELL s type systemin section 3. The basic calculus is church-style .-calculus plus \na set of sorts S = {Prop}.{Type(i) | i . N} and the dependent product .x : A, B which types abstractions \n(rulesPROD,ABS,APP).We do not detail the relation R which allows an impredicative Prop sort and a predicative \nType hierarchy. The sort Type(0) represents computational types (e.g. lists, naturals) and Prop logical \nproposi\u00adtions. Both sorts are typed by Type(1) which is itself typed using the rule TYPE. An essential \nrule is CONV which internalizes the fact that\u00df-convertible types can be considered equal during type\u00adchecking(= \nis the \u00df-equivalence relation). Here lies the true power of the system: computation can be interleaved \nwith reasoning any\u00adwhere.Wedonot treatthefullkernelofCOQ,whichalso contain sort subtyping and inductive \ndatatypes as they are not essential to G f A : s WF-EMPTY WF-VAR s .S,x /. G f [] wf f G,x : A wf f G \nwf PROP G f Prop : Type(1) f G wf TYPE i . N G f Type(i): Type(i + 1) f G wf x : A . G VAR G f x : A \nG f T : s1 G,x : T f U : s2 PROD (s1,s2,s3) .R G f .x : T.U : s3 G,x : T f M : U G f .x : T.U : s ABS \nG f .x : T.M :.x : T.U G f f :.x : V.W G f u : V APP G f (fu): W [u/x] G f t : U G f U = T : s CONV \nG f t : T Figure 1. Calculus of Constructions describe the core features RUSSELL will add; inductives \nwill be described nextbyexample. Important properties of this system are Subject Reduction and Strong \nNormalization, i.e.: all well-typed terms reduce to a value in a .nite number of reductions, which ensures \nthat typing is de\u00adcidableintheC ONV rule.Withsuchexpressivepowerand strong metatheoretical properties \ncomes verbosity and in.exibility. We will present in the following sections what mechanisms help over\u00adcomethesedif.cultiesintheCOQtool.But.rstwewill \npresentthe salient featuresof inductivesinC OQ. Inductive types Inductive types are a generalization \nof the usual algebraic datatypesofML.Forexample we may de.ne the stan\u00addard polymorphic lists using the \ndeclaration: Inductive list (A:Type):Type := | nil :list A | cons :A. list A. list A. Here Ais an inductive \nparameter representing the type of ele\u00adments of the list and each constructor is declared with a product \ntype from its arguments types to the inductive type. This presen\u00adtation asa product comes from thefact \nthat constructor arguments may depend on each other and that each constructor may target a different \ninstanceofthefamily.Forexamplewemay declarevec\u00adtors (lists of .xed length) as: Inductive vector (A:Type):nat \n. Type := | vnil :vector A0 | vcons :A.. n, vector An . vector A(S n). The inductivesofCOQ (Paulin-Mohring \n1993)areinfact pa\u00ad rameterized, possibly nested, mutually recursiveinductivefamilies. An inductive family \nis a family of types indexed by a type or a value. Here forexample, vector isafamilyparameterizedbyatype \nAof elements and indexedby the naturals nat. The vnil constructor is the empty vector of length 0 and \nthe vcons constructorbuilds a vector of length S n from an object of type Aanda vector of length n. Finally,we \ncan de.ne nested inductive types using non-uniform parameters;this featureis neededtobeableto de.neFingerTrees. \nFixpoint pow map (AB:Type)(f :A. B) (l:pow list A){ struct l} :pow list B:= match lwith | pow nil . pow \nnil B | pow cons hd tl . pow cons B(f hd) (pow map (A\u00d7 A)(B\u00d7 B) (fun x :A\u00d7 A. (f (fst x), f (snd x))) \ntl) end. Figure 2. pow map de.nition AclassicalexampleofanesteddatatypeisthepowerlistofAwhere the tailofa \nlistisa listof pairsof A. The important point is that we can reinstantiate the parameter Ain the constructors. \nInductive pow list (A:Type):Type := | pow nil :pow list A | pow cons :A. pow list (A\u00d7 A). pow list A. \nWe can of course recurse on elements of these inductive types and in the last case we will even use polymorphic \nrecursion, a fea\u00adturethetypesystemofMLlacks.Forexamplethe map combinator on power lists can be de.ned \nas in .gure 2. To ensure the aforementioned properties are preserved when adding inductivefamilies, thekernel \nimplementsarelatively in.ex\u00adible syntactic criterion to discard non-structurally recursive de.ni\u00adtions. \nIn the pow map example, it checks thattl is indeedasubterm of lwhich the user marked as the structurally \ndecreasing argument using the {struct id} annotation. In this de.nition we alsoface the foremost dif.culty \nin using CIC as a programming language: verbosity. Clearly, writing all these types is not viable from \na soft\u00adware development point of view, so we must .nd a way to over\u00adcome this problem while still retaining \ndecidability of inference and type-checking. C OQ s solution to this problem is to use a higher\u00adlevel \nlanguageGALLINAwhich elaborates/compiles intoCIC. This approach does not change thekernel s language \nat all, so wekeep all the nice properties once our de.nitions have compiled into it. 2.2 COQ surface: \nGALLINA We will now present a few of COQ s surface language features which deal with the verbosity and \nabstraction power of CIC: im\u00adplicit arguments to omit some type information, notations to abbre\u00adviate \nand beautify the otherwise obfuscated de.nitions and sections to easily parameterize whole developments. \n2.2.1 Recovering inference Implicit arguments systems permit writing terms omitting as much inferable \ninformation as possible. Its effect is best described by an example application. Suppose we want to apply \nthe pow map function to a function f : A . B and a power list l : pow list A. Without implicit arguments, \nwe must give the type of f as the .rst arguments of the function, like this: pow map ABf l. In implicit \narguments mode, the .rst two arguments become implicit as the system knows that theywill be inferable \nat application time from the type of the functional argument f, hence we can write pow map fl to achieve \nthe same effect. This permits users to write de.nitions with a syntax very similar to languages based \non Hindley-Milner type inference, e.g. the pow map de.nition comes downtothecodein.gure3.Wedonot considerpartial \napplications here for which this mechanism is incomplete. 2.2.2 Notations: pretty parsing/printing Notations \narekindofhygienic macros which serveto abbreviateor beautify speci.cations and generallygiveamore mathematical \nfeel to writingCOQ.Forexample we can de.ne the type representing Fixpoint pow map (AB:Type)(f :A. B) \n(l:pow list A){ struct l} :pow list B:= match lwith | pow nil . pow nil | pow cons hd tl . pow cons (f \nhd) (pow map (fun x . (f (fst x), f (snd x))) tl) end. Figure 3. pow map de.nition with implicit arguments \nthe subset of elements of a type A having a particular property P as in .gure 4. Inductive sig (A:Type)(P:A. \nProp):Type := | exist :. a :A, Pa. sig AP. Notation { x :A| P} :=(sig A(fun x :A. P)) Figure 4. Subset \ntype in Coq An element of the type sig APis a tuple exist AP xp where x is a witness of type A and p \nis of type Pa, i.e. p is a proof that the predicate P holds for a. However it is much clearer to write \nthis type as {x : A | P } rather than sig AP and this is what the notation system permits. An alternative \nencoding of the vector inductive structure may be the lists of .xed lengths which we can de.ne using \nthis notation (the types of A and n can be infered automatically in this case): Definition vector An \n:= { x :list A| length x = n }. One can de.ne arbitrary notations, possibly for binding con\u00adstructs, \nand assign them priorities (levels) and associativities.For example we may de.ne composition using the \nsymbol . as a nota\u00adtion: Notation g . f :=(fun x . g(fx)) (at level 20, left associativity). Armed with \nthese tools we can start our .rst development. 2.2.3 Sections: implementing the monoid typeclass Asa \ngentle introductiontoCOQ,we willbuilda monoid datatype corresponding to the Monoid typeclassofH ASKELL.We \nrecall its signature: \u00d8 :: m class Monoid m where (8) :: m . m . m Instances should make sure the following \nproperties hold: left identity \u00d88 x = x right identity x 8\u00d8 = x associativity x 8 (y 8 z)=(x 8 y) 8 z \nWe .rst introduce the monoid laws we just described.We will use the section mechanism of COQ extensively \nin the following. Sec\u00adtions permitto writeabunchof de.nitions which are parameterized by some variables, \ne.g. for types and operations. When closing a section, every de.nition inside it is quanti.ed over the \nvariables it used. Section Monoid Laws. The carrier m type may be anytype. Variable m :Type. The identity \nelement mempty and the operation mappend. Variables (mempty :m)(mappend :m . m . m). We de.nefancynotations \nfor the element and operation. Notation e := mempty. Infix \u00b7 := mappend (right associativity, at level \n20). We now state the properties. Definition monoid id l t:Prop := . x, e \u00b7 x = x. Definition monoid \nid r t:= . x, x \u00b7 e = x. Definition monoid assoc t:= . xy z,(x \u00b7 y)\u00b7 z = x \u00b7 y\u00b7 z. End Monoid Laws. Everyvariable \nin Monoid Laws has been dischargedbynow,so we must apply each de.nition to particular mempty and mappend \nob\u00adjects.We can .nally de.ne the dependent record which represents monoids on m: Record monoid (m :Type):Type \n:= mkMonoid { mempty :m ;mappend :m . m . m ;monoid id l:monoid id l tmempty mappend ;monoid id r :monoid \nid r tmempty mappend ;monoid assoc :monoid assoc tmappend }. We will come back to monoids when implementing \nFinger Trees.We will now present theRUSSELL language whichwas the essential tool we needed to develop \nthem. 3. RUSSELL in COQ The lackof distinction between proofs and programsinType The\u00adory helps having \na clear, uni.ed semantics for the complete system but hinders users and implementers alike, because sometimes \nyou donotwanttohaveproofs polluting computations(e.g.wheneval\u00aduating a term, the way proofs are constructed \nshould not matter, only the algorithm) and you certainly do not want to write com\u00adplex programs using \na procedural language with automation like the language used in proof scripts of COQ but directly inputing \nterms andhave them interpretedinCOQ skernel language.A so\u00adlution to the .rst problem is given by the \nProp/Type distinction in COQ. If Prop is used as the type of propositions (e.g. conjunc\u00adtion, negation) \nand Type as the type of computational types (e.g. naturals, lists) then we can immediately see whether \nsomething is a proof or a program just by looking at its sort. This is used by theextraction mechanism(Letouzey2002)toextract \nonly the algo\u00adrithmical code from a C OQ term. However, the extraction is not used directly inside the \nproof-checker, so computations in COQ may freeze because of irreducible proofs in the term, even when \nthey are irrelevant; we will discuss this later issuein section7.For now we will concentrate on the problem \nof writing richly speci.ed programs in C OQ by taking advantage of this distinction between Prop and \nType. Usually, as soon as you have propositions appearing in the type ofafunction,youwillwriteitsbodyinCOQusing \ntactics insteadof usingthe functional language because otherwiseyouwouldhaveto directly manipulate proof \nterms. This is a showstopper because it becomes intractable as soon as you have a complex proof to do, \nespecially since there is is not so much support for incremental re.nementinC OQ, unlikeinAGDA (Coquand \n2006) orEPIGRAM (McBride and McKinna 2004), although the refine tactic cangive the same .avor of program \ndevelopment (Chlipala 2006). RUSSELLisaprogramminglanguagebuiltontopofCOQwhich permits writing only the \nalgorithmical code of strongly speci.ed functions and forgetting about the required proofs which COQ \nneeds to establish correctness (i.e. typecheck the term). Its main purposeistoactasaconvenient,permissivesourcelanguagewhich \nelaborates intoC IC, which canbe type-checkedby the safekernel of COQ. Here, permissive means the user \nis not restricted to using structural recursion, complete pattern-matching and total functions only, \nas we have seen up to now. Obviously, you have to give evidence that your source term can be seen as \na legitimate COQ term, which generally means that what you left out can be proved. This is done by solving \nobligations which are generated after the type-checking procedure of RUSSELL terms by an interpretation \nintoCIC.Foradetailed presentationofthis procedure,thereaderis directed to (Sozeau 2007). The generation \nof obligations is done in a similarwayasinPVS(Owreand Shankar 1997), using subsets to carry propositions.Wewill \ndescribethis essential featureofthe RUSSELL type system and its extension to the richer CIC calculus \nnext, then move on gradually to our motivating example: Finger Trees. 3.1 Subset equivalence Subset equivalence \nis a simple idea: two subsets over the same carriermaybe consideredequal,givenaproofthattheycontainthe \nsame elements.We can leave the properties out and just consider the carrier of subsets. That is, if we \nhave an object t of type T where we expect an object of type {x : T | P }, we may say ok, you willhavetogivemeaproof \nthat P [t/x] holdsbut we are good for now . Conversely, considering an object of type {x : T | P } as \nan object to type T is alright. This is the essential idea behind the typesystemofRUSSELL:it checkstypeequivalenceonthe \ncarriers only, ignoring if the properties really hold. We need only enrich thetypeconversion relationofCIC \nwiththerulegiven.gure5to formalize this idea. G f T = U : Type G,x : U f P : Prop G f T ={x : U | P } \n: Type Figure 5. Subset equivalence rule As an example, we can derive: G f N = N : Type G,x : N f x =0: \nProp G f 0: N G f N ={ x : N | x =0 } : Type G f 0: { x : N | x =0 } Afteratermhasbeentypedinthis system,wecan \nautomatically generate the obligations and produce a full-.edged, well-typed COQ term once these are \nsolved.Following theexample,a single obligation demanding that 0=0 be proved will be generated which \nwill easily be solved by re.exivity of equality. But we could have derived G f 0: { x : N | x 0 } in \nRUSSELL as well, in = which case the generated obligation could certainly not be solved except if G is \ninconsistent. This phase distinction is essential: as soon as we want to do any proof we jump into an \nundecidable world becausewehavethefullhigher-orderlogicofCOQ athand, so we must not have any proving \nto do if we want our type\u00adchecking to be decidable. This is to contrast with the approaches of other \ndependently-typed programming languages, from DML (Xi and Pfenning 1999) to EPIGRAM. In these languages \neither the expressive power is limited so that an automatic prover can solveobligations during type-checking \n(e.g. Pressburger arithmetic inDML) or thereis no limitbut proofs and code are intermingled in the same \nlanguage (for EPIGRAM, COQ and AGDA)or a mix of the two styles inATS (Xi 2004) or OMEGA (Sheard 2004) \nfor example. 3.2 RUSSELL s incarnation: PROGRAM Using RUSSELL we can write arbitrarily complex code \nwith ar\u00adbitrarily complex speci.cations, it will typecheck only if it is structurally well-typed.Wedonotcareaboutproofsatthetype\u00adchecking \nstep but later, when recombining obligations with the algorithmical skeleton we wrote. Let us de.ne the \nstrongly speci\u00ad.ed euclidean division of a by b where b must be non-zero. This function is de.ned by \nwell-founded recursion using the less-than order on the argument a: Program Fixpoint div (a : nat)(b:nat \n| b= 0){ wf lt } : { (q, r):nat \u00d7 nat | a = b\u00d7 q+r . r < b} := if less thanab then (0, a) else dest div \n(a -b)bas (q , r)in (S q , r). The Program vernacular indicates that we use the RUSSELL type\u00adchecker \nfollowed by the interpretation into COQ instead of C OQ s original type-checker. The construct dest t \nas p in b is equiv\u00adalent to a destructive let construct where p is an arbitrary pat\u00adtern (allowing one \nto pull values from nested tuples for example) but it also re.ects the equality between t and p in the \ncontext for later use in the obligations. We also use sugar for the binder (x : nat | P ) . (x : {x : \nnat | P }). Finally, the if construct works on anyinductive type with two constructors. This code type-checks \nand PROGRAM generates obligations which are discharged automatically by COQ s tactics except the one \nfor the inductive case.We can discharge it interactively using COQ s proof language. When all obligations \nare solved thePRO-GRAM system adds the completed de.nition of div in the environ\u00adment. We can then use \ndiv like any other COQ object, reasoning and computing with it as desired. We were able to discharge \nthe obligations becausehypotheses a<b or a = b were present in their contexts. However, these hypotheses \nare not automatically generated by COQ. They come directly from the term which uses a dependent function \nless than of type: .x y, {x<y} + {x = y}. Had we simply used a boolean function instead, we would have \nno information about the comparison in the obligations. Hence we must always take care of re.ecting the \nlogic in our code if we want to reason on it later. In case of boolean conditionals, we can always use \nthe combinator dec : .b, {b = true} + {b = false} to achieve this re.ection. 3.3 Extension to inductive \ntypes It is natural to extend the support for subset types in RUSSELL to inductive families. For example, \nwe have seen we can have two encodings of vectors, one using subsets and another using an inductivefamily. \nThefacility we added for handling subset types should then transpose easily to inductive types. Indeed \nwe can obtain theRUSSELL derivation: G f x : vector Am G f vector Am = vector An : Type G f x : vector \nAn The type conversion results from an instantiation of the rule given.gure6which statesthatan inhabitantofan \ninductivefamily .. I with indexes -also inhabits the type I -(coercion does not xi yi happen on parameters). \n.. G f I -.. I inductive family xi ,I -yi : Type xi = I - G f I -yi : Type Figure 6. Dependent inductive \nequivalence rule When interpreting into COQ, proof obligations will be gener\u00adatedtoshowthat indicesareequal.Fortheexampleabove,aproof \nof G f m = n : Prop will be required. This extension was crucial inthedevelopmentof Dependent FingerTrees \nwhereagoodpart of the obligations are generated due to applications of this rule. Duallytothis constructionusedforbuildingan \ninductiveobject with arbitrary index, we have enriched the pattern-matching con\u00adstruct to get information \nabout destructed values and their indexes (i.e. automatically re.ecting pattern-matching at the logical \nlevel). Informally, in our setting each branch of a pattern-matching con\u00adstruct will be typed in a context \nextended with equalities between the patternsandthe matchedvaluesupto their indices.Forexam\u00adple, in a \ncontext where v is of type vector A (S n), when typing the term match v with vnil . \u00b7\u00b7\u00b7 | vcons xn' v' \n. \u00b7\u00b7\u00b7 end the .rst branch will be typed in a context containing hypotheses S n = 0 and v . vnil, hence \nan absurd case. The equality sym\u00adbol . will be presented in \u00a7 4.4.1.We will also be ableto deduce that \nn = n' in the second branch because we will have an equality S n = S n' in the context (and constructors \nare injective). As a fur\u00adther re.nementof pattern-matching, we add inequalityhypotheses in the context \nof branches for which the pattern was intersecting with a previous one. Consider the following code: \nProgram Fixpoint div2 (n :nat): { n :nat | n =2\u00d7 n . n =2\u00d7 n +1} := match n with | S (S p). S (div2p) \n| x . 0 end. The second branch is typed in a context extended with the hypothesesx = n and .p, x = S \n(S p), which is crucial to solve the obligation n = 2 * 0 . n = 2 * 0 + 1. A conclusion on RUSSELL We \nthink having an unrestricted power of expression in the logic is essential to having useful soft\u00adware \ndevelopment and certi.cation tools and our method achieves it without losingthefacilitieswe are accustomedtoina \npractical programming language. So we get decidability of type-checking and our programs look exactly \nlike their simply-typed counterparts withnoproof handlingcode appearinginthe termbutwealsohave ahighlyexpressivelogicandacompletesystemtoproveandcheck \nstatements in this logic. 4. Dependent Finger Trees We will now illustrate RUSSELL s expressiveness by \npresenting a certi.ed implementation of Finger Trees in COQ. Finger Trees (Hinze and Paterson 2006) are \na functional, general purpose, ef\u00ad.cient data structure based on an optimization of 2-3 trees. It is \nimplemented in HASKELL as a nested datatype which is parame\u00adterizedbya typeof measures, which canbe instantiatedbyvarious \ntypestogive specializationsoftheFingerTrees.Thedata structure builds upon simpler structures like digits \nand 2-3 nodes which we will present .rst. 4.1 Digits Adigitis simplyabufferof oneto fourvalues. Section \nDigit. Variable A:Type. Inductive digit :Type := | One :A. digit | Two :A. A. digit | Three :A. A. A. \ndigit | Four :A. A. A. A. digit. Webuild simple functional predicates on digits for use in speci.\u00adcations. \nDefinition full (x :digit):Prop := match x with Four . True |. False end. We now de.ne addition of an \nelement to the left of a digit. Program Definition add digit left (a :A) (d:digit |\u00ac fulld):digit := \nmatch dwith | One x . Two ax | Two xy. Three axy a : A d : digit Hd : \u00ac full d x, y, z, w : A Heq d \n: d = Four x yz w False Figure 7. Obligation of add digit left | Three xyz . Four axyz | Four . ! end. \n It has become interesting here, as we de.ne a partial function.We can add to a digit if and only if \nit is not already full. So, we require the argument digit to be accompanied by a proof that it is not \nfull. Wewill use it to prove that the last branch is inaccessible. Note that we can pattern-match on \ndas if it was just a digit: properties have no in.uence on code, only on proofs. As in COQ, there has \nto be a branch for each and every con\u00adstructorinRUSSELL pattern-matchings,but we can use ! to assert \nthat a branch is inaccessible due to contextual information on the matched object.We must treatevery \nconstructor becauseexhaus\u00adtiveness of pattern matching with dependent types is undecidable in general. \nThe generated obligation (.gure 7) is easily solved, as wehavea contradictioninthe context:both \u00ac fulldand \nd= Four are present.We can de.neina similarfashion addition on the right and thevarious accessors on \ndigits(head, tail, last and liat). From now on we will omit the obligations and the proof scripts usedtosolvethem;theycanbefoundintheCOQcontribution. \nAs an other example of the usefulness of PROGRAM, consider de.ning the monoid ([], + ) on lists.To constructa \nmonoid imple\u00admentation (c.f. \u00a72.2.3), we have to apply the mkMonoid construc\u00adtor to [], + and proofs \nof identity and associativity.Fortunately, those can be .lled automatically by COQusing lemmas proved \nin the standard library. WhenPROGRAMprocesses the following def\u00adinitionit turnstheholes( )inthetermintoobligationswhichare \nthus automatically discharged.Weexplicitlygive the element and operation using the syntax(x:=t);theyare \nconsidered implicit ar\u00adguments by the system as theyare derivable from the types of the proofs. Program \nDefinition listMonoid (A:Type):monoid (list A):= mkMonoid (mempty:=nil)(mappend:=app). We shall now de.ne \nthe FingerTreesover some monoid and mea\u00adsure.We will seein section5how particular instantiationsof these \nwill give different structures. Section DependentFingerTree. Variables (v :Type)(mono :monoid v). The \nvariable v is the monoid carrier type, mono is the monoid implementation. As before, we use e and \u00b7 for \nthe monoid empty element and operation respectively. 4.2 Nodes FingerTrees are implemented using 2-3 \nnodes asin 2-3 trees, with the addition of a cached value that stores the combined measure of the subobjects. \nSection Nodes. Variables (A:Type)(measure :A. v). Notation I x I := (measure x). Intuitively, the \nmeasure represents an abstraction of the sequence of objects in the node (later, in the tree) considered \nfrom left to right.Taking the list monoid previously de.ned and the singleton measure [] gives the most \nconcrete abstraction of this sequence of elements: the sequence itself. The measure function is denoted \nby II in the following, when possible (notations local to a function are not supported).Wenowde.ne 2-3 \nnodes with cached measures: Inductive node :Type := | Node2 :. xy, { s :v | s = I x I\u00b7I yI}. node | Node3 \n:. xy z, { s :v | s = I x I\u00b7I yI\u00b7I z I}. node. We use a subset type here to specify the invariant on \nthe cached value. This invariant could not be checked using simple types, becauseitis dependentonthevalues \ncarriedbythe node. Moreover, it uses the measure function as a datatype parameter so it would require \nan additional abstraction mechanism like type classes or functorsto achieveitinaregularML-based functional \nlanguage. Aregular dependent product is used here instead. We have smart constructors node2 and node3 \nwhich compute the measure, e.g: Program Definition node2 (xy :A):node := Node2 xy (I x I\u00b7I yI). The \ngenerated obligations are trivially true as they are of the form x = x. Correspondingly, node measure \npulls the cached measure. Program Definition node measure (n :node):v := match n with Node2 s . s | Node3 \ns . s end. End Nodes. Although it may seem that the node measure function is indepen\u00addent of the measure \nfunction, it is not. Witness its type after we closed the section: .(A : Type)(measure : A . v), node \nmeasure . v The node datatype itselfis parameterizedby the measure function, hence all operations on \nnodes take it as an implicit parameter. Had we not added the invariant, we would not need this parameter, \nbut we could not prove much about node measures either, because theymight be anyelement of type v.We \ncould de.ne an inductive invariant on nodes asserting that their measures werebuilt using the measure \nfunction coherently,but wewould need to show that this invariant is preserved in each of the functions, \nwhile in our case we get it for free by typing. 4.3 The .ngertree datatype Before presenting the de.nition \nof .ngertree inCOQ,we introduce the original HASKELL datatype and justify whythe direct transla\u00adtion \nwould be unsatisfactory. In HASKELL, the FingerTree alge\u00adbraic datatype is de.ned as: data FingerTree \nva = Empty | Single a | Deep v (Digit a)(FingerTree v (Node va))(Digit a) The Empty constructor represents \nthe empty tree, the Single con\u00adstructorbuildsa singleton tree froman elementof a and the Deep constructoristhe \nbranching node.Itbuildsa FingerTree va froma cached measure of type v,two digits of a and a middle FingerTree \nv (Node va)of2-3 nodes of a with measures of type v. This is where the nesting occurs; it is best described \nby a picture (.gure 8). We could directly de.ne the FingerTree data structureinCOQ by translating the \nHASKELL de.nition. However doing so would Two Three  Two Empty One Node2 IcI\u00b7IdI Node3 IeI\u00b7IfI\u00b7IgI \nNode2 IhI\u00b7IiI Figure 8. Asample FingerTree.Atthe .rstlevelwehavea Deep node with a 2-digit of a at the \nleft and a 3-digit at the right. The middle tree is a FingerTree v (Node va)consistingofaDeep node with \nan Empty middle tree. It has a 2-digit of Node va at its left and a 1-digit at its right. The circled \nnodes represent elements of type a and the shaded ones indicate loci where cached measures are stored \ncause a rather subtle problem: the cached measures in two Finger Trees could be computed by two different \nmeasure functionsbut these trees would still have the same type because the FingerTree datatype is parameterized \nonly by the type of the computed mea\u00adsures and notby the measure function.Again, we couldlive withit \nandhavea predicate formalizing thefact that the measures appear\u00ading ina FingerTree werebuilt coherently \nwith some measure func\u00adtion,but preservationofthisinvariantwouldhavetobeprovedfor eachnewde.nitionon \nFingerTrees.Weprefertoviewthe measure function as an additional parameterof the FingerTree datatype.In \nthis case coherenceis ensuredbythetypesystem becausetwoFin\u00adgerTrees will have different types if they \narebuilt from different measure functions. Hence the following de.nition: A.ngertree inductive is parameterized \nby a type Aand a mea\u00adsure function measure :A. v on this type. Each .ngertree object is also indexedby \nits corresponding measure: Empty builds the empty tree of measuree;  Single x builds the tree with \nsole elementx of measure IxI;  Deep pr msmsf builds the tree of pre.x pr, subtree m of measure ms and \nsuf.x sf.Its measureisgivenbycombiningthe measures of its subtrees. The argument ms will be implicit \nwhen constructing Deep nodes, as it can be infered from the type of  m.Weplace this argument ms just \nbefore the middleFingerTree contrary to the original datatype in which the cached measure is the .rst \n.eld and stores the measure of the whole tree whereas for us the latterisgivenby the index. We present \nthe de.nition using inference rules for enhanced readability, omitting Aand measure in the premises: \nEmpty :.ngertree Ameasuree x :A Single x :.ngertree Ameasure(measure x) pr, sf :digitA, ms :v m :.ngertree \n(node measureA)(node measure measure)ms Deep pr msmsf :.ngertree Ameasure (digit measure measure pr \u00b7 \nms \u00b7 digit measure measure sf ) This inductivefamilyis indexedbyvaluesof type v. Whywe need a dependent \ntype follows from a simple observation. If we want the cached measure on the Deep node and the invariant \nthat the measureisreally the oneof the middle tree, we musthaveawayto refertothe measureofthe middletree,butweare \nactually de.ning trees, so we cannot recurse on them at this time. Note also that we need polymorphic \nrecursion to go into the middle subtrees of Deep nodes. Adding elements We can add an elementa to the \nleft of a tree t of measure sto geta tree with measure IaI\u00b7 s. Due to polymorphic recursion, our functions \nwill now always have A and measure arguments as they are real arguments which will change during recursive \ncalls. If t is empty, a singleton or a tree with a left pre.x which is not full, then we simply put a \nat the leftmost position of the tree. Otherwise, we needto reorganize the tree to make space at the left \nfor a, and this requires recursing polymorphicallyto add a node a to the left of the middle subtree in \nthe Deep node. Program Fixpoint add left (A:Type)(measure :A. v) (a :A)(s :v)(t:.ngertree measure s){struct \nt} : .ngertree measure (measure a \u00b7 s):= match tin .ngertree s return @.ngertree Ameasure (measure a \n\u00b7 s)with | Empty . Single a | Single b. Deep (One a)Empty (One b) | Deep pr st t sf . match pr with | \nFour bcde . let sub := add left (node3 measurecde)t in Deep (Two ab)sub sf | x . Deep (add digit left \na pr)t sf end end. The .rst matchexpression uses dependent elimination. Its meaning is that from a particular \n.ngertree of measure s each branch will build a .ngertree of measure measure a \u00b7 s where s has been substituted \nby the measure of the matched pattern. For example in the .rst branch we must build an object of type \n.ngertree measure (measure a \u00b7 e). However, the right hand side Single a has type .ngertree measure (measure \na), hence we must use the inductiveequivalence rule (.gure 6), which generates an obligation f measure \na \u00b7 e = measure a, easily solved using the right identity of the monoid. The in and return clauses are \nmandatory in COQ due to undecidability of higher-order uni.cation,but they can be dropped in RUSSELL, \nin which case substitution is replaced by equational reasoning. Had we dropped the clauses, we would \nhave the equation s = e in the context of the .rst branch hence the generated obligation s = e f measure \na \u00b7 s = measure a. This one would be solved by .rst substituting s by e in the goal then applying the \nright identity;we just postponed the substitution. The nested match expression uses an alias x for capturing \npre.xes which are not Four and applies the partial function add digit left de.ned earlier. There is an \napplication of the subset equivalence rule here, which generates an obligation to show that pr is not \nfull. It can be solved because we have .b c d e,pr = Four bcde in the context. It is an essential property \nof this function that the measure is preserved.To see that, let us instantiate the FingerTreeby the list \nmonoid ([], + ) and measure [] de.ned earlier.You can check here that adding to the left is prepending \nthe measure of the element to the measure of the FingerTree, hence consing to the sequence of elements \nof the tree with the list monoid interpretation. For each of the following operations, this correspondence \nwith the list instanciation of the measure will hold. 4.4 The view from the left... of a .ngertree We \nwill now construct views on the Finger Trees which decom\u00adposea tree into its leftmost element anda remaining \nFingerTree (View L)(or dually, the rightmostone and the preceding Fin\u00adgerTree).It servesto abstract fromthe \nimplementationandgivea list-like view of .ngertree, which is used to write functions which recurse on \n.ngertrees without having to deal with the intricacies of the structure (c.f. .gure 5.1). The View L \ninductive is a little less polymorphic, as it does not need carry the measure function which views ignore. \nHowever View L still stores the measure s ofthe rest of the tree in the cons L constructor(s will be \nimplicit), hence we need to abstract by the sequence s type seq which is indexed by v. It will be instanciated \nby .ngertree measure. Inductive View L (A:Type)(seq :v . Type):Type := | nil L :View L Aseq | cons L \n:A.. s, seq s . View L Aseq. Such a view will be constructed by the view Lfunction, by struc\u00adtural (polymorphic) \nrecursion on the .ngertree.We can seamlessly use the digit tail function which is partial (it accepts \nonly digits which are not One)and need not add anytype annotations when calling view Lrecursively on \nt . Note that we use a partial type ap\u00adplication(.ngertree measure)in the return type, which is perfectly \nlegal. Program Fixpoint view LA(measure :A. v) (s :v)(t:.ngertree measure s){struct t} : View L A(.ngertree \nmeasure):= match twith | Empty . nil L | Single x . cons L x Empty | Deep pr st t sf . match pr with \n| One x . match view Lt with | nil L . cons L x (digit to tree sf) | cons L a st t . cons L x (Deep \n(node to digit a)t sf) end | y. cons L (digit heady)(Deep (digit taily)t sf) end end. We can show thatview \nLpreservesthe measure of the input tree; had we indexed View L by the measure of the input tree, these \ngeneration lemmas would have appeared as obligations. Lemma view L nil :. A(measure :A. v)s (t:.ngertree \nmeasure s), view Lt= nil L . s = e. Lemma view L cons :. A(measure :A. v)s (t:.ngertree measure s)x \nst t , view Lt= cons L x (s:=st )t . s = measure x \u00b7 st . 4.4.1 Dependence hell Our views are useful \nto give an high-level interfaces to Finger Trees, but in their current state they are very limited as \nwe can write only non-recursive de.nitions on views. That is, we will not be able to convinceCOQthat \nfunctions de.nedby recursion on the view of a tree are just as valid as those de.ned by recursion on \nthe tree itself.Todothat,wemusthavea measureonourFingerTrees, e.g. their number of elements (named tree \nsize), from which we can triviallybuilda measure on the views View L size. Then itis only a matter of \nshowing that for all t, view Lt returns a view of size tree sizet to prove that a recursive call on the \ntail of a view is correct (c.f. \u00a75.1). However, doing such a thing is not as easy as it looks be\u00adcause \nview Lmanipulates objects of dependent types and reason\u00ading about them is somewhat tricky. An essential \ndif.culty is that the usual Leibniz equality is not large enough to compare objects in de\u00adpendent types \nas theymaybe comparablebutin different types.A simple example is that the proposition vnil = vcons xnv \nis not well-typed because vnil is of type vector 0andvcons xnv of type vector (S n)which are not convertible. \nIn our case, we want to say that an arbitrary tree t of mea\u00adsure s with view nil L must be the Empty \ntree, but those two trees do not have the same type.We apply the usual trick of het\u00aderogeneous equality \n(McBride 1999) : prove they must be in the same type. The inductive JMeq de.nes an heterogeneous equality \n(previously denoted by )in COQ. It is used to compare objects which are not of the same type. Its sole \nconstructor is JMeq re. of type . A a, JMeq AaAa. The point of this admittedly strange notion of equality \nis to postpone the moment at which we need to prove that the types of the compared objects are equal. \nWhen we arrive at this point, we can apply the JMeq eq axiom of type . A x y, JMeq AxAy . x = y to get \nback a regular equality between the objects. In the .rst lemma, we compare t of measure s with Empty \nof measure e;clearly, replacingJMeq by regular equalitywould yield a type error here. Lemma view L nil \nJMeq Empty :. A(measure :A. v)s (t:.ngertree measure s), view Lt= nil L . JMeq t(Empty (measure:=measure)). \n Now that we have shown the equality for a general s index, we can instantiate it with a particular one, \ni.e. e. Given that t is now of measure e, we can use the regular equality with Empty. Lemma view L nil \nEmpty :. A(measure :A. v) (t:.ngertree measure e), view Lt= nil L . t= Empty. These technical lemmas \nabout nil L and Empty will help usbuild our measure. Indeed, they are needed to prove the following: \nLemma view L size :. A(measure :A. v)(s :v) (t:.ngertree measure s), View L size (view Lt)= tree sizet. \nThis gives us a decreasing measure on view Lresults.We will use it whenbuilding the instances. Lemma \nview L size measure :. A(measure :A. v)(s :v) (t:.ngertree measure s)x st (t :.ngertree measure st ), \nview Lt= cons L x t . tree size t < tree sizet. We can also de.nedeep L, the smart constructor which \nrearranges atreegivenapotentiallyemptydigitforthepre.x.Itisadependent version of the internal function \nfor the Deep case of view L, which is used when splitting FingerTrees. The code has not changed at all \nfrom the non-dependent version hence we do not show it. How\u00adever, the speci.cation would greatly bene.t \nfrom an overloading mechanism tofactor the different measure specializations. Program Definition deep \nL(A:Type)(measure :A. v) (d:option (digit A))(s :v) (mid :.ngertree (node measure measure)s) (sf :digit \nA):.ngertree measure (option digit measure measured \u00b7 s \u00b7 digit measure measure sf ):= \u00b7\u00b7\u00b7 4.4.2 Back \nto normal We are now ready to implement regular deque viewing operations on our FingerTrees.We do not \nneed recursion on the trees here, so we can de.ne the operations for a .xed element type, measure function \nand measure index. Section View. Variables (A:Type)(measure :A. v)(s :v). We de.ne an isEmpty predicate \nfor some operations will be par\u00adtial, i.e. de.ned only for non-empty .ngertree objects.We do not match \ndirectly on the object to maintain the abstraction from the implementation. Definition isEmpty (t:.ngertree \nmeasure s):= match view Ltwith nil L . True |. False end. Emptiness is decidable. Definition isEmpty \ndec (t:.ngertree measure s): { isEmptyt } +{\u00ac isEmptyt }. The obvious operations are de.nable, we show \nthe liat operation dual to tail. Here we return the index along with the .ngertree in a dependent pair \nof type {s : v &#38; .ngertree measure s}, which corresponds more closely to the view that the cached \nmeasure is really data, not only an index used to re.ne a datatype. The pairing of a tree t with its \nmeasure m is denoted m :| t and reads m measures t . Program Definition liat (t:.ngertree measure s | \n\u00ac isEmptyt):{ s :v &#38;.ngertree measure s } := match view Rtwith | nil R . !| cons R st t last . st \n:| t end. End View.  4.5 Catenation &#38; splitting, dependently Wecan also de.ne catenation usingadependent \ntype which clearly states the function s speci.cation. The implementation is the same asthe oneof Hinze&#38;Paterson,exceptweprovedthe100obliga\u00adtions \ngenerated by PROGRAM concerning measures. The .ve mu\u00adtually recursive functions hidden here which de.ne \napp have the particularity of being quite big because theyimplement a special\u00adization of concatenation \nfor each combination of the digits at the rightof the left tree and the leftof the right tree. Hinze&#38;Paterson \neven recommend to produce the 200 lines long de.nition automat\u00adically to prevent mistakes. Here the de.nition \nis checked directly: the type itself expresses that we did not mess up the obvious prop\u00aderty of app on \nmeasures. Definition app (A:Type)(measure :A. v) (xs :v)(x :.ngertree measure xs) (ys :v)(y:.ngertree \nmeasure ys): .ngertree measure (xs \u00b7 ys). Notation x +:+ y := (app xy)(at level 20). The last and most \ninteresting operation from the speci.er s point of view,is splittinga treebya predicate on its measure.Webeginby \nsplitting a node. Section Nodes. Variables (A:Type)(measure :A. v). Variables (p:v . bool)(i:v). We split \na noden by .nding where some predicate pon measures turns to true, starting with an initial measure i \nand accumulating the measures of subtrees from left to right. We simply copy the invariantgivenby Hinze \nandPaterson (2006) here, thereis nothing to change, we only add the corresponding property on the measure \nwhich clearly generalizes the to list equation. The code is also a direct translation from HASKELL to \nRUSSELL except we use a regular tuple instead of a custom split datatype. We have also de.ned a split \ndigit function with the same speci.cation. Program Definition split node (n :node measure): { (l, x, \nr):option (digit A)\u00d7 A\u00d7 option (digit A)| let odm := option digit measure measure in node measure measure \nn = odml\u00b7I x I\u00b7 odm r . node to list n = option digit to listl+ [x] + option digit to list r . (l= None \n. p(i\u00b7 ls)= false). (r = None . p(i\u00b7 ls \u00b7I x I)= true)} := \u00b7\u00b7\u00b7 End Nodes. The interesting case is for \ntrees, as usual. Instead of returning a tuple, we use a dependent tree split inductive which directly \ncaptures the invariant that a split is a decomposition of a .ngertree preserving measures.Wealsoputtheinvariantsontheleftandright \ntrees, which can be used by clients to prove properties about their code. This is one of the most distinctive \nparts of this work: we derive not only reusable codebut also reusable proofs using rich types. Indeed, \nsplit tree canbe seenasaproof combinator, turning a property on a measure and monoid to a property on \nwords on this monoid. Section Trees. Variable p:v . bool. Inductive tree split (A:Type)(measure :A. v) \n(i:v):v . Type := mkTreeSplit :. (xsm :v)(xs :.ngertree measure xsm | isEmpty xs . p(i\u00b7 xsm)= false) \n(x :A)(ysm :v)(ys :.ngertree measure ysm | isEmpty ys . p(i\u00b7 xsm \u00b7 measure x)= true), tree split measurei(xsm \n\u00b7 measure x \u00b7 ysm). This inductive combines both subsets and dependent inductive types,but we can still \nwrite our code as usual. Approximately 100 lines of proof are necessary to discharge the generated obligations. \nProgram Fixpoint split tree (A:Type)(measure :A. v) (is :v)(t:.ngertree measure s |\u00ac isEmptyt) :tree \nsplit measureis := \u00b7\u00b7\u00b7 End Trees. This concludes our implementation of (dependent) Finger Trees withPROGRAM.To \nsumup,wehaveproven that: All functions are total, once properly annotated with their pre\u00adconditions. \n All functions respect the measure semantics and use them co\u00adherently.  All functions respect the invariants \ngiven in the paper by Hinze &#38;Paterson.  The complete .le we walked through comprises 600 lines of \nspeci.cations (declarations, types, programs, proof statements) and 450linesofproof.In comparisonthe \nsource.leprovidedbyHinze &#38;Paterson is 650 lines including comments.We argue that this is proofof \nthe scalabilityofRUSSELL asa programming language. 5. Instances Wewill nowinstantiate the.ngertree implementationbyparticular \nmonoids and measures to get higher-level structures. Obviously, we can instantiate the FingerTrees just \nlike in the original paper of Hinze&#38;Paterson using weak, simply typed speci.cations and extract the \ncode,but thatwould notbe tooexciting.Nevertheless, wewill.rstpresentawaytorecoverthe simply-typedinterfaceand \ninstantiateitto ordered sequences.Wewillthenfocusonprovinga particular specialization using the dependent \ninterface directly. 5.1 FingerTree: a non-dependent interface As shown before, we can wrap the measure \nand the tree in a dependentpairtooffera simpler interfaceto FingerTrees. Section FingerTree. Variables \n(vA:Type)(mono :monoid v)(measure :A. v). Definition FingerTree := { m :v &#38;.ngertree mono measure \nm }. This gives us a type FingerTree v monoAmeasure, which can be compared with the original FingerTree \nvadatatype inHASKELL. It adds the monoid implementation and measure function as explicit parameters whereasinHASKELL \ntheyare passed implicitely using the typeclass mechanism. Morally, the parameterization we did using \nthe section mechanism correspond to the systematic pre.xing of functions on FingerTree objectsbya Measured \nva constraint in HASKELL (Measured va is a class with a single function measure of type a . v where v \nmust havea Monoid instance).Wethink this equivalence indicates an interesting .eld of investigations \non how to integrate overloading in a language like RUSSELL, or a section system inHASKELL. Wedo not describe \nthe wrapping in detail, it is just destructuring aFingerTree object, calling the appropriate function \non .ngertrees and packing back the measure and the tree. However, an important point is that we can wrap \nviews too and obviously recover the associated measure: Inductive left view :Type := | nil left :left \nview | cons left :A. FingerTree . left view. Lemma view left size :. tx t , view leftt= cons left x \nt . tree size t < tree sizet. We can .nally wrap splitting onFingerTrees alonga predicate.We offer the \nsame simply-typed interface as HASKELL by de.nining the function split withpx. It splits anytree x by \n.rst checking if x is empty and if not calls the split function on it using the predicate pwith an empty \naccumulator. Program Definition split with (p:v . bool) (x :FingerTree):FingerTree \u00d7 FingerTree := if \nis empty dec x then (empty, empty) else let (l, x, r):= split pe x in (l, cons x r). End FingerTree. \nAs an example use of the simply-typed interface we develop the specializationof FingerTreesto Ordered \nSequences.The main idea is to use as a measure on elements of Athe element itself and have the monoid \nimplement an operation which returns the rightmost element in the tree. Then if the operations maintain \nthe invariant that the sequence of elements in the tree are ordered we have an ordered sequence where \nthe maximal element can be retrieved in constant time. Module OrdSequence(AO:OrderedType). We use modules \ninstead of the section mechanism as it gives compile-time instanciation which is exactly what we need \nhere. The module systemofCOQisa supersetofOCAML s.We suppose given an implementation of an ordered type \nAO. Definition A:Type := AO.t. Definition measure (x :A):=Some x. We measure one element by itself. Module \nKM := KeyMonoidAO. Import KM. The KeyMonoidmodule implements the monoid(None, keyop)on the type option \nA, where keyopis de.ned by: keyop xNone = x keyop (Some as y)= y Clearly this will give the rightmost \nelement of the structure as its measure if there is one. It also de.nes the function key gt which liftthe \noperationofthe orderedtypetothe monoid stype.Wecan then declare the ordered sequence type as FingerTree \napplied to the monoid and measure. Definition OrdSeq := FingerTree m measure. We can get the maximal \nelement in constant time by taking the measureof the whole FingerTree. Definition max (x :OrdSeq):=tree \nmeasure x. We skip the other operations de.ned in the original paper which permit to partition an ordered \nsequence or insert or delete in it, they are no more dif.cult to code. We focus on the merge oper\u00adation \nwhich is the only termination challenge in the whole devel\u00adopment. Merging of ordered sequences simply \ndoes a merge sort of the list of elements of both sequences. It does so using the left view de.ned earlier \nand hence needs to recurse on results of the view left function. Note however that the termination argument \nis complicated by the swapping of arguments for the recursive call. We can usepair size measure de.ned \nbelow to de.ne the function by well-founded recursion on the pair of sequences. The generated obligations \ncan be solved using the view left size lemma de.ned earlier. Definition pair size (x :OrdSeq \u00d7 OrdSeq):= \nlet (l, r):=x in tree sizel +tree size r. Program Fixpoint merge (x :OrdSeq \u00d7 OrdSeq) {measure pair \nsize} :OrdSeq := dest x as (xs, ys)in match view left xs with | nil left . ys | cons left x xs . dest \nsplit with (fun y. key gty (measure x)) ys as (l, r)in catl (cons x (merge (r, xs ))) end. 5.2 Dependent \nSequences. We will now de.ne random-access sequences as a specialization of .ngertree. This structure \nprovides insertion and deletion at both ends in constant amortized time, concatenation and splitting \nin log\u00adarithmic time and access(get)and mutation(set)operations in log\u00adarithmic time too.We willbuilda \ncerti.ed implementationof this structure by showing that the operations respect a functional spec\u00adi.cation. \nThis method slightly differs from the usual separation of operation de.nition and invariant proving. \nHere, invariant preserva\u00adtion will be proved simultaneously with the de.nition of operations. We de.ne \nsequences over a type of elementsA. Section DependentSequence. Variable A:Type. First, a useful de.nition: \nthe type below i represents the naturals below some i, so below 0is not inhabited. Definition belowi \n:= { x :nat | x < i}. Lemma not below 0:below 0. False. Weuse naturalsto measure sequencesby their length.Our \nmeasure is a bit special as it also carries a function giving the map realized by the Finger Tree. It \nis used solely for speci.cation and could be removed in extracted code using a dead code analysis or \neven rejected at extraction using a .ner type system. Definition v := { i:nat &#38;(belowi . A)}. We \nde.ne a notation for our measure objects: an object i . m is a dependent pair composed by an index i \nand a map m from naturals below ito elements of A. The epsilon will represent empty sequences. As it \ncontains no elements, no value is returned by the function. We have an obligation to show that in a context \nwith an hypothesis of type below 0, we can prove False: we just use not below 0. Program Definition e \n:v :=0 . (fun . !). Appending two maps requires some reindexing: the new map is formedby projectingthenewindexto \neitherthe.rstorthe second map. Program Definition append (xs ys :v):v := let (n, fx):=xs in let (m, fy):=ys \nin (n +m). (fun i. if less thanin then fxi else fy (i-n)). We canbuilda monoidseqMonoid from these operations, \nwe skip the proofs which are relatively easy. The measure of a singleton sequence built from x gives \nthe constant map to x. Program Definition single (x :A):v :=1 . (fun . x). We de.ne an abbreviation seq \nfor our sequence type. Sequences are a specialization of .ngertree with the seqMonoid monoid and single \nmeasure de.ned above. Hence an object of type seq (i. m) isa FingerTree representingasequenceof objectsof \nlength igiven by the map m. Definition seq (x :v):=.ngertree seqMonoid single x. We can get the length \nof the sequence in constant time as it is part of the cached measure. Program Definition length (s :v)(x \n:seq s):nat := dest s as size . in size. The constructor make n x creates a sequence of length n with \nvalue x in each cell. Note that obligations are generated to prove that e.g., when makenx is of type \nseq (n. fun . x)thenadd leftx (make nx)is of typeseq (S n . fun . x).Weprovethe preservationof semantics \nof our sequence s make operation directly here. Program Fixpoint make (i:nat)(x :A){ struct i} : seq \n(i. (fun . x)) := match iwith | 0. empty | S n . add left x (make n x) end. Wenowde.ne the strongly \nspeci.edgetfunction which gets the jth elementofasequence x of length i.Weensure that no out-of-bound \naccess is made because jis of type belowi and we assert that getin\u00addeed returnstherightvalueofthemap \nm. Note that m is never used in the code, only in the types. Again, some obligations are gener\u00adated to \nprove that this speci.cation is indeed a correct abstraction of the semantics of the code. It is crucial \nthat the split tree function be dependent and returna tree split object carrying proofs to solve these \nobligations. As before, the code stays simple and compact. However, we skip around 50 lines of proof \nneeded to discharge the obligations. The boolean predicate lt idxix tests whether an index iis less than \nthe .rst component of a measure x. Program Definition getim (x :seq (i. m)) (j:belowi):{ value :A| value \n= mj } := dest split tree (lt idxj)e x as mkTreeSplit lsl x rs r in x. The natural companion of get \nis set which given a sequence x of length isets its jth cell to value.We have as precondition that jis \nbelow i and as postcondition that the new sequence has value at its jth index and the same elements as \nx otherwise The function denotedby =n decides equality on naturals. Program Definition seti (m :belowi \n. A)(x :seq (i. m)) (j:belowi)(value :A): seq (i. (fun idx . if idx =nj then value else m idx)) := dest \nsplit tree (lt idxj)e x as mkTreeSplit lsl rsr in add rightlvalue +:+ r. Now that wehave de.ned our operations \nwithbuilt-ininvariants,it isasimplematterofusingthetype informationtorelate operations. Here we formalize \nhow getand set behave together. The proofs use solely the types of get and set, not their code. We show \nthat our sequences respect the two axioms of functional arrays: if getting at an index jjust set to value \nwe get value (get set), otherwise we get thevalue from the original map(get set diff ). Program Lemma \nget set :. im(x :seq (i. m)) (j:belowi)(value :A), value = get(set xjvalue)j. We were able to state \nthis lemma only because we are using the RUSSELL type-checker, indeed there is an automatically inserted \ncoercion at the right hand side of the equality to go from a subset of Ato an object of A(the implicit \ntype of an equality is .xed by its .rst argument). This seamless integration of PROGRAM with COQ as a \ntheorem prover is also an improvement over a previous attempt to provide a programming environment in \nCOQ, namely the Program tactic by Parent (1995). However, we are not yet able to get the most natural \nstatements in RUSSELL. In the next de.nition for example, we coerce objects jand k of type below i to \ntheir underlying nat components and the results of get to A. This is because the comparison of objects \nfrom subset types only makes sense on their .rst component, the witness, whereas comparing proofs is \nuseless. Our pragmatic solution is to let the user insert a cast to get the expected behavior, but in \na proof\u00adirrelevantType Theory the problem disappears because comparison of proofs become trivial.We discuss \nthis solutionin \u00a77.1. Program Lemma get set diff :. im(x :seq (i. m)) (j:belowi)(value :A)(k:belowi), \n(j:nat)= k. (get xk:A)= get(setxjvalue)k. Finally, we de.ne splitting of sequences. It requires creating \ntwo projections of the original map, hence the following: Program Definition split l(i:nat)(j:belowi) \n(idx :belowj):belowi := idx. Program Definition split r (i:nat)(j:belowi) (idx :below (i-j)): belowi \n:= j+idx. We can .nally split a sequencex at a particular index j, returning two sequences whose maps \nare just projections of the splitted x. Approximately a hundred lines of proof are necessary to discharge \nthe three obligations generatedbyPROGRAM. Program Definition split im (x :seq (i. m))(j:belowi): seq \n(j. (m . split lj)) \u00d7 seq ((i-j). (m . split rj)) := dest split tree (lt idxj)e x as mkTreeSplit lsl \nx rs r in (l, add leftxr). End DependentSequence. This gives us a certi.ed implementation of sequences \nin less than 500 lines whose dependent interface can be used directly to imple\u00adment programs and prove \nproperties at the same time. 6. Extraction We can extract the code we just certi.ed to both HASKELL and \nOCAML (bypassing the type checker for polymorphic recursion) toget certi.ed implementationsof FingerTreesand \nsequences.We are guaranteed to get the same algorithmic code than what we wrote using PROGRAM. This is \nan important aspect of developing with RUSSELL, because usually when developing programs with rich speci.cationsinC \nOQ onetendstousetheproof languageasmuch as the programming language and this can have devastating results \non the extracted code. Our method enforces a distinction between code and proofs that is healthyin this \nrespect. Unsurprisingly,ourextractedFingerTreeshaveindeedthe same performance as the original implementation: \nthey have the same code. The Data.Sequence implementation inH ASKELL is infact a specialization of the \nFingerTree implementation to a particular monoid and measure, avoiding dynamic lookups and unnecessary \nboxing. Had we used the module system of COQ to parameterize our development instead of the section mechanism, \nwe would have had this instantiation at no cost. However the lack of a powerful module system in HASKELL \nprevented us from doing that, as we would not be able to extract to it then. Unfortunately, extraction \nof our dependent sequences will not give excellent results because the measure contains a function giv\u00ading \nthe map which will be extracted even though it has no algo\u00adrithmical role.We areina case where only partof \nan index need be stored (unlike the setting of Brady et al. (2003)), so a .ner dis\u00ad tinction than Prop/Type \nhas to be found to distinguish between algorithmical and non-algorithmical content. Current work by B. \nBarras and B. Bernardo on an adaptation of the Calculus of Implicit Constructions (Miquel2001)asthe core \ncalculusofadependently\u00ad typed language ought to give the expressivity we seek. We concludethatRUSSELLisnotoverlyverboseandthatdoing \ntheproofsisactuallynota insurmountabletask,knowingthatmost of them were solved automatically using a \nnormalization tactic for monoid expressions. 7. Discussion 7.1 Proof-Carrying Code As displayed before, \nCOQ ultimately melts proof and code in its terms,soastobeabletocheckthe correctnessofanypartofaterm at \nanytime. On the surface, we can manage to separate the two ac\u00adtivitiesof coding and proving usingPROGRAM,but \nthere are parts of the system where it still bites. The same notable problem appear during proofs and \ncomputations.When proving, we arefaced with terms containing proofs we do not want to name or manipulate \nand when computing (in the call-by-value case only) the system itself is stuck with irreducible opaque \nproofs. However,in the twocases the proofs appear only in parts of the term that should not be reduced \nbecause they have no algorithmical content and need not be ma\u00adnipulated as their structure has no importance. \nThis is formalized by proof-irrelevance (PI), the statement that two proofs of the same proposition are \nequal. The meta theory of the Calculus of Construc\u00adtionsextended withPI has been studiedextensivelybyWerner \nand Miquel. Recently,Werner (2006) alsogavea methodto implement it effectively in COQ, which is currently \npursued by the author. It has also been studiedin the contextof ObservationalType Theory, the (would \nbe) core calculus of EPIGRAM 2. Having PI in the sys\u00adtemwouldmakethesetwoproblems disappearandwould probably \nimprove performanceof computations insideCOQ too. 7.2 A note on the implementation PROGRAM is composed \nof two distinct parts: the type-checker and the proof-obligation handling machinery.Infactonlya smallpart \nof the COQ type-checker needed to be changed, so RUSSELL s type-checker is just a different instantiation \nof the typing functor of COQ which is parameterized by the conversion algorithm. This is to contrast \nwith the work by Catherine Parent on the previous PROGRAM tactic which was a completely different solution \nfor program-synthesis in C OQ. The system was not integrated with COQ and so went unmaintained. 7.3 \nRelated Work RUSSELL can be seen as one point in the design space of pro\u00adgramming languages with dependent \ntypes. Its most distinctivefea\u00adture is the separation of code from proof, ` a laPVS, and its treat\u00adment \nof subsets and indexed data types. It is also original in the sense that it elaborates into a well-studied, \nsafe and mature lan\u00adguage while most other solutions coming from the programming languages community \nhave no such safety net or only for part of the system.RUSSELL couldinfactbe implementedinEPI-GRAM or \nAGDA rather easily as they are based on roughly the same foundationsasCOQ.ThemaindifferenceisthatCOQalready \nhas a comprehensive standard library and a tactic system. Com\u00adpared to programming languages like ATS, \nCONCOQTION (Fog\u00ad arty et al. 2007) or HASKELL, RUSSELL has no effects and only well-founded recursion.We \nfoundthatin practicethe programswe write usually haverelatively simple termination arguments and real \nnon-termination could be accommodated by using a coinductive encoding.We thinkhavinga layered approachto \ntreating compu\u00adtational effects using functional encodings like monads is a more disciplined approach \nto development and certi.cation than trying to designa systemwith some computationaleffectsbuilt-in,if \nthis is at all possible whilekeeping strong properties. Other certi.cations of tree-based data structures \ninclude a certi\u00ad.cationoftheAVL treesusedinOC AML andalso red-black trees in COQ (Filli atre and Letouzey2004). \nThe development was done by .rstbuildinga dependent interface and providinga simpler one on top of it. \nThe second author reported great success adapting the dependently-typed implementation whichwas originaly \ndone using tactics toP ROGRAM. 8. Conclusion Whatwewouldliketo assessisthatwriting programsinRUSSELL \nis not more dif.cult than in HASKELL, with the added bene.t of a complete environment for proving properties \nabout your programs inahighlyexpressivespeci.cation language. Clearly,thereis room for improvement on \nthe side of programming language technol\u00adogy,forexample somekindofoverloading mechanismwouldallow more \nconciseness,butRUSSELL is alreadyverypowerfulin terms of speci.cation possibilities and actual support \nfor proving proper\u00adties, as it (re-)lies on an already mature proof assistant. One thing we learned is \nthat once we begin to use dependent types, embrac\u00ading them completely becomeasensible and desirable goal, \ncarrying the strong properties bottom-up. PROGRAM allows to do this in a tractable and hopefully maintainable \nway. Acknowledgments Thanks to Christine Paulin-Mohring, Jean-Christophe Filli atre and the anonymous \nreferees for their insightful comments on drafts of this paper, along with Adam Chlipala and my colleagues \nof the DEMONS team for their lasting enthusisasm \u00b4and criticism. Finally,I thankYannR\u00b4egis-Gianas for \nintroducing me to FingerTrees. References Edwin Brady, Conor McBride, and James McKinna. Inductive families \nneed not store their indices. In Stefano Berardi, Mario Coppo, and Ferruccio Damiani, editors, TYPES,volume \n3085 of LNCS, pages 115 129. Springer, 2003. Adam Chlipala. Position paper: Thoughts on programming with \nproof assistants. In PLPV 06: Proceedings of the Programming Languages meetsProgramVeri.cationWorkshop, \nAugust 2006. Coq. The Coq proof assistant. coq.inria.fr. Thierry Coquand. Alfa/agda. In FreekWiedijk, \neditor, The Seven\u00adteenProversof theWorld, volume 3600 of LNCS, pages 50 54. Springer, 2006. Jean-Christophe \nFilli atre and Pierre Letouzey. Functors for proofs and programs. In David A. Schmidt, editor, ESOP,volume \n2986 of LNCS, pages 370 384. Springer, 2004. SethFogarty, EmirPasalic, Jeremy Siek, andWalidTaha. Conco\u00adqtion: \nindexed types now! In G. Ramalingam and EelcoVisser, editors, PEPM, pages 112 121.ACM, 2007. Haskell. \nThe Haskell programming language. haskell.org. Ralf Hinze and RossPaterson. Finger Trees:A Simple General\u00adpurpose \nData Structure. J. Funct. Program., 16(2):197 217, 2006. Pierre Letouzey.Anewextraction for coq. In Herman \nGeuvers and FreekWiedijk, editors, TYPES 02,volume 2646 ofLNCS,pages 200 219. Springer, 2002. Conor McBride. \nDependently Typed Functional Programs and Their Proofs. PhD thesis, University of Edinburgh, 1999. Conor \nMcBride and James McKinna. The view from the left. J. Funct. Program., 14(1):69 111, 2004. Alexandre \nMiquel. The implicit calculus of constructions. In TLCA, volume 2044 of LNCS, pages 344 359. Springer, \n2001. OCaml. The Ocaml programming language. caml.inria.fr. Sam Owre and Natarajan Shankar. The formal \nsemantics of PVS. Technical Report SRI-CSL-97-2, Computer Science Laboratory, SRI International, MenloPark, \nCA, August 1997. CatherineParent. Synthesizing proofs from programs in the Cal\u00adculus of Inductive Constructions. \nIn BernhardM\u00a8oller, editor, MPC, volume 947 of LNCS, pages 351 379. Springer, 1995. Christine Paulin-Mohring. \nInductive de.nitions in the system COQ. In Typed Lambda Calculi and Applications, volume 664 of LNCS, \npages 328 345. Springer, 1993. Tim Sheard. Languages of the future. SIGPLAN Notices, 39(12): 119 132, \n2004. Matthieu Sozeau. Subset coercions in Coq. In TYPES 06, volume 4502 of LNCS, pages 237 252. Springer, \n2007. BenjaminWerner.Onthe strengthof proof-irrelevanttype theories. 3rd International Joint Conference \non Automated Reasoning, 2006. Hongwei Xi. Applied Type System (extended abstract). In post-workshop Proceedings \nof TYPES 2003, pages 394 408. Springer-Verlag LNCS 3085, 2004. HongweiXiandFrank Pfenning.Dependenttypesin \npracticalpro\u00adgramming. In ACM SIGPLAN SIGACT Symposium on Princi\u00adples of Programming Languages (POPL), \nSan Antonio, Texas, pages 214 227, January 1999.    \n\t\t\t", "proc_id": "1291151", "abstract": "<p>Finger Trees (Hinze & Paterson, 2006) are a general purpose persistent data structure with good performance. Their genericity permits developing a wealth of structures like ordered sequences or interval trees on top of a single implementation. However, the type systems used by current functional languages do not guarantee the coherent parameterization and specialization of Finger Trees, let alone the correctness of their implementation. We present a certified implementation of Finger Trees solving these problems using the Program extension of Coq. We not only implement the structure but also prove its invariants along the way, which permit building certified structures on top of Finger Trees in an elegant way.</p>", "authors": [{"name": "Matthieu Sozeau", "author_profile_id": "81337493427", "affiliation": "LRI: Universit&#233; Paris Sud, Orsay, France", "person_id": "P900682", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291156", "year": "2007", "article_id": "1291156", "conference": "ICFP", "title": "Program-ing finger trees in C<scp>oq</scp>", "url": "http://dl.acm.org/citation.cfm?id=1291156"}