{"article_publication_date": "10-01-2007", "fulltext": "\n Experience Report: The ReactisValidationTool Steve Sims Daniel C. DuVarney Reactive Systems, Inc. {sims,duvarney}@reactive-systems.com \nAbstract Reactis is a commercially successful testing and validation tool which is implemented almost \nentirely in Standard ML. Our experi\u00adence using a functional language to develop a commercial product \nhas led us to the conclusion that while functional languages have some disadvantages, in the case of \nReactis the bene.ts of a func\u00adtional language substantially outweigh the drawbacks. Categories and Subject \nDescriptors D.1.1[Applicative (Func\u00adtional) Programming] General Terms Economics,Languages,Veri.cation \nKeywords Functional Programming, StandardML,SML,Reactis 1. Introduction R Reactis .1 is a testing and \nvalidation tool which is implemented almost entirely in Standard ML (SML). Reactis supports model\u00adbased \ndesign (MBD), a software development paradigm in which an executable model of a program s behavior is \ndeveloped prior to the actual implementation. Reactis currently processes models im- RR plemented in \nthe Simulink ./State.ow. 2 notation of The Math-Works, Inc. Reactis provides an environment in which \nmodels can be validated and debugged, and the conformance of implementa\u00adtions to models can be tested. \nReactive Systems, Inc. (RSI) was founded in 1999 in Falls Church,Virginia (USA), withthe supportofa Small \nBusinessIn\u00adnovation Research (SBIR)grant from NSF. The founders had ex\u00adperience developing academic model-checkingtools \nincluding the Salsaveri.er (Bharadwajand Sims 2000), the ConcurrencyFactory (Cleavelandetal.1996),andthe \nConcurrencyWorkbench(Cleave\u00adlandetal. 1993).ThegoalofRSIwastodevelop practical technolo\u00adgies for validating \nembedded control software. Embedded control softwareisan attractivetargetforveri.cation becauseittendstobe \n(1) small (due to the amount of memory in embedded processors), (2) simple (complex language features \nsuch as dynamic memory allocation are rarely used), and (3) safety-critical.  The practices of embedded \ncontrol systems developers were surveyed, and it was discovered that manyof these developers use Simulink/State.owmodelsasadesign \ntool. Simulinkisagraphical 1Reactis is a registered trademark of Reactive Systems, Inc. 2Simulink and \nState.ow are registered trademarks of The Mathworks, Inc. Permission to make digital or hard copies \nof all or part of this work for personal or classroom use is granted without fee provided that copies \nare not made or distributed for pro.t or commercial advantage and that copies bear this notice and the \nfull citation on the .rst page.To copyotherwise, to republish, to post on servers or to redistribute \nto lists, requires prior speci.c permission and/or a fee. ICFP 07 October 1 3, 2007, Freiburg, Germany \nCopyright c2007 ACM 978-1-59593-815-2/07/0010. . . $5.00 data-.ow language, consisting of blocks which \nprocess data and signal lines which carry data between blocks. State.ow supports the design of extended \n.nite automata (EFA) in manner similar to Statecharts(Harel 1987). State.ow EFA are usually embedded \nwithin a Simulink block and are used to control how data .owing through the block is processed. Model-based \nsoftware development of embedded control sys\u00adtemsis typically done usinga specify/design/implement methodol\u00adogy, \nas follows. First, the requirements of a control system are ex\u00adpressed as a set of constraints, such \nas the difference between the actual speed of the vehicle and the cruise control setting will never exceed5 \nmph. Based on these constraints, an engineer develops a State.ow/Simulink model, which undergoes testing \nand debug\u00adging until it is deemed to be correct, at which point it is handed offto another engineerwho \nimplementsaCprogram basedonthe Simulink model. TheCprogramis then testedexhaustively using hand-written \nand/or randomly-generated inputs, and the outputs are inspected to ensure that the constraints are satis.ed. \nReactis was envisioned as a tool which would support model\u00adbased development by automatically validating \nthe output of the design and implementation phases, e.g., Reactis would check to ensure that a model \nsatis.es its requirements, and that the behav\u00adior of the implementation is identical to the behavior \nof the model. Initially, model-checking was considered as a veri.cation mecha\u00adnism, but was deemed to \nbe impractical. Eventually guided sim\u00adulation was settled upon as the core validation technique. Guided \nsimulation works by interpreting a model and tracking the model s datavalues.After each assignment or \noutputevent, datavalues are checked to ensure that no relevant constraint is violated. At each branch \npoint, the data values involved are recorded. At the end of a simulation, a backwards data-.ow analysis \nis applied to the values which in.uenced branching in an attempt to choose new top-level inputs whichwill \ntriggeradifferentexecutionpathtobetaken.The use of runtime data makes the input value selection much \nmore ef\u00adfective than a purely static analysis. Reactis has been commercially sucessful, generating triple-digit \nrevenuegrowth for RSI since 2002. Currently there are dozens of automotive and several aerospace customers \nusing Reactis. These customers are located in the U.S., Japan, Germany, France, Eng\u00adland, India,Taiwan, \nCanada and Australia. 2. Overview of Reactis 2.1 Functionality Reactis currently consists of three primary \ncomponents. Reactis Simulator allows engineers to debug their modelsby pro\u00advidingahostof featuresforexecutingthem \ninteractively.Inad\u00addition to traditional debugger features (breakpoints, single-step execution, etc.), \nSimulator also supports coverage tracking, re\u00adplay, and reverse execution. Figure 1. Typical usageof \nReactisTester and Simulator. ReactisTester automatically generates test cases from models. These test \ncases may then be used to debug the model itself; theymay also be used to check conformance between one \narti\u00adfact (e.g. a Simulinkmodel of a digital controller) and another (e.g. a C implementation of the \ncontroller). The tool allows users to specify which coverage criteria to track in order to in\u00addicatehowexhaustivethe \ntesting should be.Atypical use-case illustrating the interaction between ReactisTester and Simula\u00adtor \nis depicted in Figure 1. ReactisValidator automatically checks for violations of user\u00adde.ned assertions, \nsuch as a car s anti-lock braking system should engage only when the brake pedal is pressed . The tool \ngives users the capability of instrumenting the model/program being analyzed with assertions that should \nremain true while the artifact executes; the tool then attempts to .nd violations of these assertions. \nIf a violation is found, the tool provides the user with diagnostic feedback in the form of an execution \nsequence leading to the violation. The tool uses the same cover\u00adagemeasuresasTesterto determinehow thoroughlytoexplore \na model, and it also allows users to de.ne customized coverage criteria. Tester and Validator both use \nstructural coverage criteria to determine how thoroughly to explore the artifact under analysis. These \ncriteria involve measures derived from the syntactic form of the model; examples include: state coverage \n(has every State.ow state in a model been entered at least once?); branchcoverage (has every Simulink \nbranch been executed at least once?); and MC/DC coverage(thelevelofcoveragerequiredforthe most safety-critical \naviation softwarebyFAA DO-178B regulations).  2.2 Architecture and Implementation The top-level architecture \nof Reactis is shown in Figure 2. From the beginning of our work on Reactis, we aimed to implement as \nmuch of the tool as possible in SML. Currently, the only major component not implemented in SML is the \nGUI, which is imple\u00admented in C++ using the WxWidgets cross-platform GUI library (WxWidgets). The GUI \nand back-end communicate over a socket. TheGUI respondsto userinputbysending instructionstotheback\u00adend. \nBack-end instructions are represented usingasimple language which the back-end parses and interprets. \nTheback-end also sends data back to the GUI, including the results of expression evalua\u00adtion, information \nabout target coverage, and the current state of the Simulink/State.ow/C interpreter. The Reactis back-end \nmay be further decomposed into three main parts. Simulink/State.ow interface. an interpreter for Simulink/State.ow \nmodels. Cinterface. an interpreter forCprograms. Testing andValidation Engine. the guided simulation \nroutines generate tests by simulating a model, capturing the inputs and outputsproducedbythe simulation,and \nselectinginputsateach step that exercise new parts of the model. SML proved tobe especially well-suited \nfor the the tasks of lan\u00adguage processinginthe frontendandstate-spaceexplorationinthe back-end. Reactiswasdeveloped \nwith andis currentlybuilt with the Stan\u00addard ML of New Jerseycompiler (Standard; Appel and MacQueen 1991). \nThe freely available compiler generates ef.cient native exe\u00adcutablesfora numberofdifferent platforms \n(includingWindows), isveryrobust(wehaveuncoveredonlyahandfulofbugs duringthe development of 250K lines \nof code), and supports separate compi\u00adlation. 3. Bene.ts of SML The choice of Standard ML as an implementation \nlanguage proved to be be an essentialfactor in the successful development of Re\u00adactis.A large portion \nof the Reactis code performs operations on abstract syntax trees, a particular strength of SML. The SML \npat\u00adtern matchingfacilityprovidesaconciseand comprehensible repre\u00adsentation of functions which operate \non syntactic entities, reducing programmer effort. The SML type system includes parametric polymorphism, \nwhich enables construction of well-typed reusable data structures, and type inference, which reduces \nsource code size and improves program readability. Furthermore, manybugs which would man\u00adifest themselves \nat runtime in a typical imperative language pro\u00adduce compile-time type errors during the type inference \nprocess, improving code quality and reducing debugging time. The type system meshes nicely with the SML \nmodule system, whichprovidesa well-typed mechanismforthedecompositionof programs into abstract, reusable \nsubsystems. SML Functorsfacil\u00aditate the production of parameterized modules without sacri.cing type safety. \nThe well-typed module system makes it possible for the SML/NJCompilationManager(Blume 2002, 1999)to automat\u00adically \ndetermine dependencies between modules with only a small amountof auxiliary informationprovidedbythe \nprogrammer. SML programs, like all functional programs, are inherently memory-safe. When the burden of \nmemory management is re\u00admoved from theprogrammer,development timeis reduced, anda primary source ofbugs \nand security vulnerabilities is eliminated, reducing debugging time and producing a more reliable and \nsecure system. SML functions are .rst classvalues, which canbe partiallyeval\u00aduated (when in curried form), \ncapture values, and passed as argu\u00adments to standard iterativefunctions such as map,apply,andfold. In \nlanguages which don tprovide .rst-class functional values, iter\u00adation control code is often duplicated \nmultiple times, resulting in more development time and more opportunities for defects to be introduced \ninto the program code. A.nal intangible bene.t of our choice to use SML is the ability to attract and \nretain highly skilled programmers. In our experience, programmers who have an enthusiasm for functional \nprogramming are also (at least so far) highly competent. The choice of SML as an implementation language \nmakes it possible to attract such programmers, due to the scarcity of functionalprogramming jobs. 4. \nDrawbacks of SML Naturally,theadvantagesofSMLdon tcome withouta cost. Since SML relies on garbage collection, \nand SML/NJ in particular al\u00ad Figure 2. Reactis architecture. locates activation records on the heap, \nmemory usage tends to be signi.cantly higher than for programs written in a language which allows .ne-grained \ncontrol of heap allocation, such as C. Further\u00admore,garbage collection makes the performance characteristicsof \na program somewhat unpredictable, unlike a program with explicit heap allocation in which runtime performance \ncan be more easily predicted from the the source code.To address performance issues, we have begun but \nnot yet completed a port to the MLton com\u00adpiler (MLton; Cejtin et al. 2000). MLton performs whole-program \ncompilation, which results in higher quality code at the cost of sig\u00adni.cantly longer compilation times \ndue to the lack of a separate compilation mechanism. Ourexperiments with compiling the Salsa invariant \nchecker (Bharadwajand Sims 2000) indicate that substan\u00adtial performance improvements mightbe possible \nwith MLton.We hope to continue to use SML/NJ for daily development, andMLton tobuild .nal releasesof \nReactis. Asecond disadvantageofSML/NJisthelackofadebuggingfa\u00adcility, which makes debugging with print \nstatements standard op\u00aderating procedure for debugging SML/NJ programs. Further com\u00adpounding this situation \nare cases where a customer at a remote site isexperiencingaproblemwithReactisbutis unwillingtosendthe \nmodelinvolvedin the malfunction.To helpin these situations, Re\u00adactis containsanextensive loggingfacility.Log \ngenerationis con\u00adtrolled from the GUI through a dialog box which allows a user to setaloglevel(an integervalue \ntypically ranging from0to5)for one or more of sixteen speci.c log categories.A remote user can generate \nand submit a log in cases where sendingthe model is not possible. We have also found logs to be useful \nwhile debugging Reactis locally, although they are not a substitute for an interactive debugger. A third \ndrawback of SML is the scarcity of development li\u00adbraries to support common applications such as database \naccess, graphical user interface development, numerical methods, etc. Dur\u00ading the development of Reactis, \nwe made frequent usage of the no\u00adlonger-foreign function interface generator (Blume 2001) in order to \ncreate SML interfacestoClibrary code whose functionalitywas requiredby Reactis.In the caseof the ReactisGUI, \nthe decision was made to implement the GUI in C++ rather than SML. As men\u00adtionedin Section2.2,theGUIis \nimplementedasa separate process which communicates with the rest of Reactis via a socket. 5. Conclusion \nBased on our experience developingReactis, we have reached the conclusion that, for the domain of language-based \ntools, the use of SML yieldsasigni.cant boostin programmer productivity.Todate, we estimate that approximately \n10 man-years of effort have been invested to develop the 250K lines of SML code which constitute Reactis, \nimplying about 25K lines per man-year. Assuming one line of SML equals 2-5 lines of C code would imply \na rate of 50K\u00ad125K linesofC code per man-year,a numberfar greater thanis typical.Webelievethatthisis \nprimarilyduetotwocauses.The.rst is that SML allows programs to be expressed more abstractly and concisely \nthan typical imperativelanguages, allowing programmers to concentrate more on fundamental algorithms \nrather than tedious operational details. The second is the SML type system, which catches morebugsat \ncompile-timeand reducesthe amountoftime spentdebugging.In ourexperience, Thesetwofactors outweighed any \nperformance issues and the lack of an SML/NJ-compatible debugger. The decision to use SML as the implementation \nlanguage for Reactis was certainly a gamble. Conventional wisdom indicated that using a somewhat obscure \nlanguage and a compiler with no commercial support that had only previously been used in academia was \nprobably not the wisest approach. In the case of Reactis, the gamble paid off, allowing a small team \nof programmers to produce a large and complex software system in less time without sacri.cing reliability. \nAcknowledgments The authorswouldliketoacknowledgetheeffortsofRanceCleave\u00adland, David Hansel and Scott \nSmolka, which were essential to the developmentof Reactis.Wewouldalsoliketo thanktheinventors of SML \nand the manypeople who have developed the compilers, libraries and other software components that bringit \nto life. References AndrewW. Appel andDavidB. MacQueen. Standardmlof new jersey. In J. Maluszy\u00b4 nski \nandM.Wirsing, editors, ThirdInternational Symposium on Programming Language Implementation and Logic \nProgramming, volume 528 ofLectureNotes in Computer Science,pages 1 13. Springer Verlag, 1991. Ramesh \nBharadwaj and Steve Sims. Combining constraint solvers with bdds for automatic invariant checking. In \n6th International Conference onTools and Algorithms for the Construction and Analysis of Systems (TACAS), \nvolume 1785 of Lecture Notes in Computer Science, pages 378 394, Berlin, April 2000. Springer-Verlag. \nMatthias Blume. Cm: The sml/nj compilation and library manager, user manual, May 2002. Distributed with \nSML/NJ since version 110.20. Matthias Blume. Dependencyanalysis for standard ml. ACMTransactions on Programming \nLanguages and Systems, 21(4), July 1999. Matthias Blume. No-longer-foreign:Teachinganml compilertospeakc \nnatively . Electronic Notes in Theoretical Computer Science, 59(1), 2001. Henry Cejtin, Suresh Jagannathan, \nand Stephen Weeks. Flow-directed closure conversion for typed languages. In Gert Smolka, editor, 9th \nEuropean Symposium on Programming (ESOP),volume 1782 ofLecture Notes in Computer Science, pages 56 71. \nSpringer, 2000. Rance Cleaveland, JoachimParrow,and Bernhard Steffen. The concurrency workbench:A semantics-based \ntool for theveri.cationof concurrent systems. ACMTransactions on Programming Languages and Systems, 15(1):36 \n72, January 1993. Rance Cleaveland, Philip M. Lewis, Scott A. Smolka, and OlegSokolsky. The concurrency \nfactory: A development environment for concurrent systems.InR. AlurandT. Henzinger, editors, Computer-AidedVeri.ca\u00adtion \n(CAV), volume 1102 of Lecture Notes in Computer Science, pages 398 401, New Brunswick, NJ, July 1996. \nSpringer-Verlag. David Harel. Statecharts:Avisual formalism for complex systems. Science of Computer \nProgramming, 8(3):231 274, June 1987. Mlton standard ml compiler. http://www.mlton.org/. Standard ml \nof new jersey. http://www.smlnj.org/. wxwidgets: Cross-platform gui library. http://www.wxwidgets.org/. \n \n\t\t\t", "proc_id": "1291151", "abstract": "<p><i>Reactis</i> is a commercially successful testing and validation tool which is implemented almost entirely in Standard ML. Our experience using a functional language to develop a commercial product has led us to the conclusion that while functional languages have some disadvantages, in the case of Reactis the benefits of a functional language substantially outweigh the drawbacks.</p>", "authors": [{"name": "Steve Sims", "author_profile_id": "81100429048", "affiliation": "Reactive Systems Inc., Falls Church, VA", "person_id": "PP39090539", "email_address": "", "orcid_id": ""}, {"name": "Daniel C. DuVarney", "author_profile_id": "81100003750", "affiliation": "Reactive Systems Inc., Falls Church, VA", "person_id": "P451450", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291172", "year": "2007", "article_id": "1291172", "conference": "ICFP", "title": "Experience report: the reactis validation tool", "url": "http://dl.acm.org/citation.cfm?id=1291172"}