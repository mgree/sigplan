{"article_publication_date": "10-01-2007", "fulltext": "\n ExtensiblePattern MatchingViaa Lightweight Language Extension Don Syme Gregory Neverov James Margetson \nMicrosoft Research, Faculty of Information Technology, Microsoft Research, Cambridge, U.K. Queensland \nUniversity of Technology, Cambridge, U.K. dsyme@microsoft.com Brisbane, Australia jamarg@microsoft.com \ngregory.neverov@gmail.com Abstract Pattern matching of algebraic data types (ADTs) is a standard fea\u00adture \nin typed functional programming languages, but it is well known that it interacts poorly with abstraction. \nWhile several par\u00adtial solutions to this problem have been proposed, few have been implemented or used. \nThis paper describes an extension to the .NET language F# called active patterns, which supports pattern \nmatching over abstract representations of generic heterogeneous data such as XMLand term structures, \nincluding where these are represented via object models in other .NET languages. Our design is the .rst \nto incorporate both ad hoc pattern matching functions for partial decompositions and views for total \ndecompositions, andyet remainsa simpleand lightweightextension.Wegiveade\u00adscription of the language extension \nalong with numerous motivat\u00ading examples. Finally we describe how this feature would interact with other \nreasonable and related language extensions: existential types quanti.ed at data discrimination tags, \nGADTs, and monadic generalizations of pattern matching. Categories and Subject Descriptors D.3.3[Programming \nLan\u00adguages]: Language Constructs and Features General Terms Languages, Design Keywords F#, Functional \nprogramming, ML,Pattern matching 1. Introduction Pattern matching in statically-typed functional languages \n(STFLs) isapowerfulfeature thatfacilitates the concise analysisof data via a switch-and-bind control \nconstruct. However a well-recognized problemwith pattern matchingisits inabilitytooperateon abstract \ndata types. This problem prevents pattern matching from being usedin scenarioswhere itseffectivenessis \nhighly soughtafter.For example many strict STFLs include a lazy list data structure but choose to hide \nthe implementation of the data type by exporting it as an abstract type. This precludes library users \nfrom pattern matchingover the data type, whichwouldbe an intuitive thing to do considering the dataisa \nlist.Forexample, considera module that exports functions to construct and analyse lazy lists: Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page.To copyotherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 07 October 1 3, 2007, \nFreiburg, Germany. Copyright c &#38;#169; 2007ACM 978-1-59593-815-2/07/0010...$5.00 type LazyList< a> \nval nonempty : LazyList< a> -> bool val hd : LazyList< a> -> a val tl : LazyList< a> -> LazyList< a> \nval consl : a -> Lazy<LazyList< a>> -> LazyList< a> val nil : LazyList< a> Tasks that were once very \nsimple to code using pattern matching become obtuse using these analysis functions, e.g., consider code \nthat sums elements of a list of integers pairwise using pattern matching1: let rec pairSum xs = match \nxs with | Cons(x, Cons(y,ys)) -> consl (x+y) (lazy (pairSum ys)) | Cons(x, Nil()) -> consl x (lazy nil) \n| Nil() -> nil becomes let rec pairSum xs = if nonempty xs then let x,ys =hdxs, tlxs if nonempty ys then \nlet y, zs = hd ys, tl ys consl (x+y) (lazy (pairSum zs)) else consl x (lazy nil) ) else nil Even if LazyList \nwere not an abstract type, pattern matchingwould still be problematic because of the need to force evaluation \nof the list in the middle of matching. Note that it is nested pattern matches that causes particular \nproblems in this regard. While this problem has long been recognized (Wadler 1987; Okasaki 1998), it \nbecomes more severe when STFLs are placed in the context of modern object-oriented programming frameworks \n(e.g., .NET and Java), which is the idea behind languages such as F# (Syme and Margetson 2006), Nemerle \n(Nemerle 2006) and Scala (Odersky 2006). Object-oriented code heavily employs ab\u00adstract types to realize \nencapsulation a fundamental design prin\u00adciple of object-oriented programming hence programmers of the \nlanguages cited above frequently encounter abstract typesbut can\u00adnot deal with them in a natural manner \nbecause of the limitations of pattern matching. This problem also manifests itself to authors of software \nli\u00adbraries. Revealing algebraic data types in a library design .xes the usage modelofthetypetosuchadegreethat \ntheir useinthe public 1Throughout this paper we use F# indentation-aware syntax that allows the OCaml \nin keyword to be omitted. APIs of framework components is hard to encourage. Indeed, it be\u00adcomes evident \nthat apart from simple cases such as lists, pairs and options, most algebraic data types are implementations \nof types, rather than descriptions of long-term maintainable abstractions. It is also evident that this \nis one of the reasons whypattern matching and algebraic data types have not been successfully transferred \nto object-oriented languages such as Java and C# despite proposals in that direction (OderskyandWadler \n1997). To summarize, pattern matching on concrete types is problem\u00adatic because it is not extensible; \n it encourages programmers to break abstraction boundaries;  it leads to libraries that are dif.cult \nto maintain and evolve;  it leads to a discontinuity in programming: programmers ini\u00adtially use pattern \nmatching heavily, and are then forced to aban\u00addon the technique in order to regain control over data \nrepresen\u00adtations.  The authors have witnessed all of these problems in practice in compiler, theorem \nprover and library implementations. This paper considers the problem as it applies to the F# lan\u00adguage. \nF# is a pragmatically-oriented dialect of ML based on the core design of OCaml. It interoperates with \nother .NET languages and bridges the gap between the functional and object-oriented worlds by providing \nboth ML-style functional programming and type-inferred object-oriented programming. By a minimalistic \nlan\u00adguage extension we are able to make pattern matching a powerful and .exible feature, whether it be \nused against internal or public, or functionalor object-orientedtypes.Whilewehaveworkedbymod\u00adifying F#, \nour results are applicable to any statically typed func\u00adtional language. Furthermore we believe our design \ncould be used asa basisfor introducinga pattern matchingfacilityin imperative object-oriented languages \nsuch as C# and Java. In this paper we do the following: We introduce the concept of anactive pattern \nin F#. Active pat\u00adterns can be used in any pattern expression, can be de.ned to operate on anytype, and \ncan be checked statically for complete\u00adness and redundancyofa match.We alsogive theevaluation semanticsof \nactive patternsbywayofapattern interpreter.  We present numerous examples of active patterns in action \nwhich demonstrate their success at functionally decomposing abstract data types.  We describe how active \npatterns are implemented in F#.2  We consider how this feature would interact with three other reasonable \nand related language extensions: existential types quanti.ed at data discrimination tags, GADTs, and \nmonadic generalizations of pattern matching.  The primary speci.c contribution of this paper is that \nit presents the .rst design for extensible pattern matching to incorporate both partial and total decompositions \nwithin the context of a regular, simple and lightweight extension to a language. In addition, this work \nis different to many previous attempts at extensible pattern matching in functional languages because \nit: considers the feature interactions mentioned above, potentially helping to smooth the path for the \nadoption of the design in other languages; 2Active patterns using the design described here have been \na fea\u00adture of F# since version 1.9.1. All the examples presented in this pa\u00adper run on the current release, \nwhich is available for download at research.microsoft.com/fsharp. addresses the need for functional \nlanguages to interoperate with object-oriented ones, and  is implemented and available for use in a \nmature programming language system.  The rest of this paper is structured as follows: in \u00a72 we describe \nthe active pattern mechanism in F#, mostly by example, and in \u00a73 we describe the operational semantics \nof pattern matching. In \u00a74 we look at further examples, and in \u00a75we discuss implementation issues. In \n\u00a76we look at interactions with other language features, and \u00a77summarizes and discusses related work. \n2. ActivePatternsinF# An active pattern is a pattern de.ned without reference to a dis\u00adcriminated union \ntype declaration.Atabasiclevelan active pattern is justa regular function,butitis de.ned usinga new syntactic \nel\u00adement called a structured name which gives it special signi.cance in the language. 2.1 SimpleTotalPatterns \n( Basic Bananas ) Patterns are used to decompose data into a number of sub-cases. To begin our exploration \nof active patterns we will consider the simplest pattern imaginable: one that decomposes data into only \none sub-case. Supposewehaveatypeforcomplex numbersandwishtowrite an addition function. The complex type \nis not an exported union typebutneverthelesswewishtowrite our add function by pattern matching.We cando \nthis using active patterns as follows:3 open Math.Complex let (|Rect|) (x:complex) = (x.RealPart, x.ImaginaryPart) \n letadd a b= match a, b with | Rect(ar,ai), Rect(br,bi) -> mkRect(ar+br, ai+bi) The .rst line de.nes \nan active pattern called Rect. The term (|Rect|) is a structured name, in this case a regular name en\u00adclosed \nin banana brackets. Structured names may appear any\u00adwhere where a regular name is used in a binding position. \nWhen a structured name is bound by let it has two effects. 1. The same effect as if it were a regular \nname: the structured name will be bound to an expression and added to the term environment. In this example \nthe name (|Rect|) will be bound to a value of type complex -> float * float. 2. The regular name will \nalso be added to the environment of pat\u00adterns, enabling it to be used in patterns where it is in scope. \nPre\u00adviously the onlywayof addinga new patternwasbyde.ninga new union type.  The type of the pattern \nis implied from the type of the function. In this case the Rect pattern matches complex and yields a \nresidual of float * float.Ifa structured nameis notboundtoa function value then it is not a valid pattern \nand a type error will result when its tags are used. In the add function, Rect is executed as part of \nthe pattern matching process. The add function is semantically equivalent to this code without active \npatterns: letadd a b= let ar,ai = Rect a let br,bi = Rect b mkRect(ar+br, ai+bi) Additionally we could \nde.ne another active pattern that trans\u00adforms the complex type into polar form. 3The F# library module \nComplex contains functions mkRect and mkPolar. let (|Polar|) (x:complex) = (x.Magnitude, x.Phase) let \nmul a b = match a, b with | Polar(m,p), Polar(n,q) -> mkPolar(m+n, p+q) Note the concrete representation \nof complex has not syntactically dictated the representation used to consume the type in this pro\u00adgram, \nas it would if we used pattern matching over the concrete structure. The concrete representation of complex \ncould change between rectangular and polar form, or between tuple and record types without impacting \na consumer s pattern matching code. The above functions could also have been written let add (Rect(ar,ai)) \n(Rect(br,bi)) = mkRect(ar+br,ai+bi) let mul (Polar(m,p)) (Polar(n,q)) = mkPolar(m+n,p+q) with the same \nresult. 2.2 Multiple CaseTotalPatterns ( Banana Splits ) Decomposing data into one sub-case is not a \nvery general task. We need active patterns to decompose data into one of manysub\u00adcases.We allow thisbyexpanding \nthe formatofa structured name. The bananas of a structured name can now enclose multiple names separated \nby splits,(|). Suppose we wish to create an active pattern interface to the standard F# lazy list type, \nwhich is abstract.We can write this in F# as follows: let (|Cons|Nil|) l = if nonempty l then Cons(hd \nl,tl l) else Nil Here the structured name (|Cons|Nil|) de.nes two regular names Cons and Nil. These regular \nnames are used on the right of the let binding to tag different cases of the pattern. The right-side \nof the let binding is given an anonymous sum type. Like tuples (i.e., anonymous product types), the F# \nlanguage also prede.nes a family of anonymous sum types as follows:4 type ( a, b) choice = | Choice2_1 \nof a | Choice2_2 of b type ( a, b, c) choice = | Choice3_1 of a | Choice3_2 of b | Choice3_3 of c (* \netc. *) These types are primarily used to encode the result of multiple case patterns. Hence in this \nexample the active pattern (|Cons|Nil|) will havetype a llist -> ( a * a llist, unit) choice. The compiler \ntranslates tags from the structured name to tags of the choice type in order. However the programmer \nnever needs to use the choice type directly with active patterns except in signatures. The names Cons \nand Nil are put in scope as patterns that match a llist and yield a * a llist and unit residuals respectively. \nThese names are used in patterns to match lazy lists without knowl\u00adedge of the underlying choice type. \nTheexample usedin the introduction can nowbe writtenina much more natural way: let rec pairSum xs = match \nxs with | Cons(x, Cons(y,ys)) -> consl (x+y) (lazy (pairSum ys)) 4.NET languages permit overloading by \narity of generic type constructor. At the time of writing the F# release only includes choice types up \nto n =7. It is trivial to havethe compiler encode choice types of greater n into these. | Cons(x, Nil()) \n-> consl x (lazy nil) | Nil() -> nil The pattern names de.ned by an active pattern have identity. This \nallows the compiler to perform completeness and redundancy analysis of match blocks, and generate ef.cient \ncode that does not recompute patterns that have already been applied. In compiled code active patterns \nare matched over their choice type representa\u00adtion. The pairSum example will compile to code like the \nfollowing which does not recompute the active patternsif the .rst rulefails. let rec pairSum xs = match \n(|Cons|Nil|) xs with | Choice2_1 (x, ys ) -> match (|Cons|Nil|) ys with | Choice2_1 (y,ys)) -> consl \n(x+y) (lazy (pairSum ys)) | Choice2_2 () -> consl x (lazy nil) | Choice2_2 () -> nil Alreadyactive patternsarepowerfulenoughtoprovidearobust \npattern interface to an existing object-oriented data type this is important for F# because programmers \nconstantly deal with code in the .NET base class library and from other languages.Forex\u00adample, the .NET \nbase class library provides a Type type that repre\u00adsents rei.ed run-time types and is used throughout \nthe frameworks re.ection and code generation APIs. The Type class is de.ned as follows: type Type with \nmember IsGenericType : bool member GetGenericTypeDefinition : unit -> Type member GetGenericArguments \n: unit -> Type[] member HasElementType : bool member GetElementType : unit -> Type member IsByRef : bool \n// an managed pointer member IsPointer : bool // an unmanaged pointer member IsGenericParameter : bool \nmember GenericParameterPosition : int In essence,thisclass interfaceistryingto communicatethata Type \nobject can be exactly one of the following: 1. A named typed with a name (represented by another Type \nobject) and list of type parameters. 2. Aarray type with a rank and element type. 3. Apointer type \nthat could be managed or unmanaged. 4. Atype parameter5  HowevertheAPIis subtle:forexample GetGenericTypeDefinition \nfails ifIsGenericType returns false, when you might expect it to be the identity function in this case. \nThis is a consistent cause of irritatingbugs when using this API. We can de.ne an active pattern that \nhides this complexity and captures the essential algebraic structure of Type objects: let (|Named|Array|Ptr|Param|) \n(typ : System.Type) = if typ.IsGenericType then Named(typ.GetGenericTypeDefinition(), typ.GetGenericArguments()) \nelif typ.IsGenericParameter then Param(typ.GenericParameterPosition) elif not typ.HasElementType then \nNamed(typ, [| |]) 5There are no binding constructs; type parameters are bound at method and class de.nitions. \nelif typ.IsArray then Array(typ.GetElementType(), typ.GetArrayRank()) elif typ.IsByRef then Ptr(true,typ.GetElementType()) \nelif typ.IsPointer then Ptr(false,typ.GetElementType()) else failwith \"MSDN says this can t happen\" \nWe can now write code that consumes this type in a functional manner to, say, pretty print a Type object: \nlet rec formatType typ = match typ with | Named (con, []) -> sprintf \"%s\" con.Name | Named (con, args) \n-> sprintf \"%s<%s>\" con.Name (formatTypes args) | Array (arg, rank) -> sprintf \"Array(%d,%s)\" rank (formatType \narg) | Ptr(true,arg) -> sprintf \"%s&#38;\" (formatType arg) | Ptr(false,arg) -> sprintf \"%s*\" (formatType \narg) | Param(pos) -> sprintf \"!%d\" pos and formatTypes typs = String.Join(\",\",Array.map formatType typs) \nor to collect the free generic type variables: let rec freeVarsAcc typ acc = match typ with | Array (arg, \nrank) -> freeVarsAcc arg acc | Ptr (_,arg) -> freeVarsAcc arg acc | Param _ -> (typ :: acc) | Named (con, \nargs) -> Array.fold_right freeVarsAcc args acc let freeVars typ = freeVarsAcc typ [] The pattern effectively \nallows us to view Type objects as if theyhad been de.ned using the following union type: type Type = \n| Named of Type * Type[] | Array of int * Type | Ptr of bool * Type | Param of int 2.3 PartialPatterns \n( Banana Slices ) Ourexamples sofarhave beenof active patterns that decompose types into a complete set \nof sub-cases. However this is not the only useful way to decompose data. Heterogeneous data types such \nas term structures, XML and strings can be analysed in manydifferent ways,mostofwhichareincompleteand \napplication-dependent.For example, say we have heterogeneous data stored as a string and we wantto pattern \nmatchoverthe stringtoextract structured data.We would like to write code as follows. match str with | \nParseInt i -> IntVal i | ParseFloat f -> FloatVal f | ParseDate d -> DateVal d | ParseColour c -> ColourVal \nc | _ -> failwith \"unrecognized data\" These four parse active patterns do not form a complete de\u00adcomposition \nof strings. Moreover they overlap because ParseInt and ParseFloat would both match the string \"0\". Furthermore \nthese patterns need not be de.ned together, indeed should not be de.ned together so that new parse patterns \ncan be added in the fu\u00adture.For these reasons these active patterns are partial and can be de.ned like \nso. let (|ParseInt|_|) s = let i= ref 0 if Int32.TryParse(s, i) then Some !i else None val colors : (string \n* colour) list let (|ParseColour|_|) s = try_assoc s colours Apartial active pattern is de.ned using \na structured name with a trailingunderscoreto indicatethe incompletenessofa match.A partial pattern either \nsucceeds and yields residual data oritfails. Afailure indicates that other patterns in the match block \nshould be tried. Structured names with an underscore are given an option type. Hence, (|ParseInt| |) \nhas type string -> int option and ParseInt may be used as a pattern that matches string and yields int. \nFor completeness our speci.cation includes structured names with multiple cases, e.g, (|ParseInt|ParseFloat| \n|). However we have yet to detect any practical bene.t in doing so. One ad\u00advantage of multiple case patterns \nin the previous section was that it enabled the compiler to perform completeness analysis on a match \nblock.Howeverthisislosthere becauseofthe inherent incomplete\u00adness of the pattern. The other advantage \nof multiple case patterns is that it can give more ef.cient match evaluation. However this is only effective \nif different cases share a signi.cant part of the ac\u00adtive pattern implementation. In practice we have \nfound this seldom occurs itis too easyto reuse separateexisting parse int and float functions than to \nwrite your own code that simultaneously parses an int and a float.For these reasons, partial active patterns \nwith multiple cases are not implemented in the current release of F#. Partial patterns have different \nevaluation semantics to total pat\u00adterns. Consider the function letf s= match s with | ParseInt 0 -> Zero \n| ParseFloat f -> NonZero f | _ -> failwith \"not a number\" If ParseInt and ParseFloat were part of the \nsame total active pattern then the expression f \"1\" would evaluate to the failwith clause. This is because \n\"1\" would be successfully parsed as an in\u00adteger but fail matching the integer 1 against 0. Then the second \nclause would be skipped because, by virtue of being in a total pat\u00adtern, ParseInt and ParseFloat areknowntobe \nmutuallyexclusive. Henceif one succeeds the other must automaticallyfail, and so the third clause is \nhit. However this does not happen when the patterns arede.nedas partial.The success (orfailure)ofa partial \npattern gives no information about how other partial patterns may succeed orfail. 2.4 ParameterizedPatterns \n( ScrapYour Banana Plate ) When using active patterns particularly partial ones it quickly becomes necessary \nto parameterize them to express queries such as Match an attribute A on an XML Node or Match any term \nin an abstract syntax tree involving a call to function M . Say we wanted a pattern that matches strings \nagainst a regular expression. To do this the active pattern must be parameterized on the regular expression.We \ncando this like so6: let (|ParseRegex|_|) re s = 6This code uses the standard regular expression library \nof the .NET frame\u00adwork. let m = Regex(re).Match(s) if m.Success then Some [ for x in m.Groups -> x.Value \n] else None This active pattern has the expected type string -> string -> (string list) option it returns \na list of matched groups from the regular expression. The type of ParseRegex as a pattern is more complicated. \nAt one level it could be viewed as single-case total pattern that matches string and yields string -> \n(string list) option,but that is not particularly useful. So instead initial arguments of an active pattern \ncan be applied at its usage site. So wecouldwriteafunctionthatswapsthepartsofahyphenatedword like so: \nlet swap s= match s with | ParseRegex \"(\\w+)-(\\w+)\" [l;r] ->r^\"-\"^ l |_ -> s Parameterizing an active \npattern results in the loss of its identity, hence the compiler cannot perform redundancy or completeness \nanalysisandaparameterized patternwillbe re-evaluatedeverytime it appears in a match block, even if it \nhas syntactically the same arguments, an issue we return to in \u00a75.1.2. 2.5 First-ClassPatternValues \n( First-Class Bananas ) Since activepatterns are simply functions theyare .rst-classvalues in the language \nand hence can be lambda abstracted. This is useful for writing higher-order activepatterns i.e.,a pattern \nparameter\u00adized on other patterns.Forexample, consider an unfold combinator that appliesapartial function, \nq,zero or more times (hereq has type t -> ( a * t) option and the input inp has type t): let qZeroOrMore \nq inp = let rec queryAcc rvs e = match q e with | Some(v,body) -> queryAcc (v::rvs) body | None -> (List.rev \nrvs,e) in queryAcc [] inp Consider a partial active pattern to match Lambda nodes in an expression tree: \ntype expr = | Lam of string * expr | App of expr * expr | Var of string let (|Lambda|_|) = function Lam(a,b) \n-> Some(a,b) | _ -> None Atotal pattern can now be de.ned using this as a .rst-class value: let (|Lambdas|) \ne = qZeroOrMore (|Lambda|_|) e Furthermore, qZeroOrMore could even have been written using a variable \nwith a structured name as a parameter: let qZeroOrMore (|Q|_|) inp = let rec queryAcc rvs e = match e \nwith | Q(v,body) -> queryAcc (v::rvs) body | _ -> (List.rev rvs,e) in queryAcc [] inp This shows that \nactive patterns really are justvalues with structured names. 2.6 Both Patterns( HaveYour BananaandEatItToo \n) Many STFLs such as F#, OCaml and SML 97 include either patterns pat | pat , which succeed if either \nthe left or right pat\u00adterns match (the patterns must bind identical variables at identical Structured \nName Kind Expected Return Type (|A|) Single-case total a (|A1|...|An|) Multi-case total (a1,...,an) choice \n(|A| |) Single-case partial a option (|A1|...|An| |) Multi-case partial (a1,...,an) choice option Table \n1. Kinds of active recognizers and their structured names types). As has been noted by Rossberg (2007a), \nthe natural dual to either patterns is both patterns pat &#38; pat that only suc\u00adceed if both the left \nand right patterns match. Both patterns are not particularly useful in traditional STFLs since most uses \ncan be combinedintoasingle pattern.However,thatchangeswhentheset of matching constructsisextensible.For \nthis reasonweextendF# matching with both patterns. We will see realistic examples of these in \u00a74.2. \n 2.7 Summary In this section we have presented the basic design of active patterns in F#. Active patterns \nare predicated on structured names. Struc\u00adtured names introduce new pattern names into the environment \nof patterns hence making pattern matching extensible. The abstract syntax of a structured name is (|id|...|id|{ \n|}?).Table1shows the different classes of structured names. Active patterns are simply functions and \nas such may take pa\u00adrameters and be parameters themselves. An active pattern function has type t1 . .... \ntN . tinp . t for some N = 0, where the N initial arguments are the parameters to the pattern and the \nlast argument is the input to be matched. The returntypemust conformtotheshape indicatedinTable1basedon \ntheformofthe structuredname,ifnotatype errorwillresultonuse. The input argument of type tinp can be anytype \nincluding abstract types, primitive types, union types and object types. Moreover a type can have anynumber \nof active patterns de.ned over it. 3. Operational Semantics In this section we give a model operational \nsemantics for pattern matchevaluation.Wedo thisintwo steps: 1. We give a naive semantics via an interpreter \nthat evaluates patterns rule-by-rule; 2.We informally outlinethe changes requiredtogivean Okasaki\u00adstyle \nsemantics (Okasaki 1998) that ensures that invocations of active patterns are cached, i.e., only executed \nonce for a given input. 3.1 ANaive Dynamic Semantics Since a naive semantics is not dif.cult, we avoid \nthe traditional approach of using inference rules. Instead we present a simple interpreter for pattern \nmatching, originally as an OCaml/F# pro\u00adgram and here presented in programmatic notation using only well\u00adfounded \nrecursion, pure lambda calculus constructs and simple data types.7 We only give the relevant pattern \nmatching portion of the dynamic semantics. 7An inference rule presentation is easy to derive from the \none we give, should it be deemed necessary. However inference rules are harder to type check, debug and \nmaintain than a simple interpreter. type env type expr type exprs = expr list type state type tag = string \ntype pat = | PPair of pat * | PTag of tag * | PActive of tag | PEither of pat | PBoth of pat * | PWild \n| PId of string | PConst of int type value = | VPair of value | VTag of string | VConst of int pat pat \n* exprs * pat pat  Tuple patterns Adata pattern * pat An active pattern or patterns and patterns patterns \nVariable patterns Constant patterns * value Pair values * value Tagged values Constants  type rule \n= pat \u00d7 expr type rules = rule list Figure 1. Input terms and values for the operational semantics The \ninput syntax terms are shown in Figure 1. As shown in Figure2we assume theexistenceofa typeof environments,a \ntype ofexpressions,afunction applyExpr toevaluate/applyexpressions, andafunction resolveActiveTagthat \nresolves an activepattern label to an expression andfurther information indicating the kind of the pattern \n(partial or total), the number of tags in the tag set of the pattern and the position of the tag in the \ntag set. In Figure3 wegivethe de.nitionsoffunctions matchPat and matchRules that match a single pattern \nand a set of rules respec\u00adtively. We pass an explicit state since evaluating F# expressions may change \na global state. The interesting points of the semantics are: Active patterns are .rst resolved to an \nexpression, the expres\u00adsion is applied (perhaps to some additional active parameter ar\u00adguments), and \na further pattern match executed for a pattern built usingSome, None, Choice1 1, Choice2 1, etc. pattern \ncon\u00adstructions. That is, the active pattern must resolve to a function expression which returns appropriate \nChoice-tagged data.  The environment is only extended after pattern matching: iden\u00adti.ers bound by the \npattern may not be used in the pattern. This is different to some other proposals for extensible pattern \nmatching (Rossberg2007b).We think this helps make patterns more readable and understandable.   3.2 \nApplying the Okasaki Condition Okasaki has argued convincingly that the only sensible semantics to apply \nto pattern match execution in a language with side effects is to require that activediscrimination functions \nbe run at most once against anygiven input within the context of a given collection of pattern rules \n(Okasaki 1998). It is easy to extend our semantics to cover this case.8 Within a single invocation of \nmatchRules the state s is aug\u00admented witha lookup tablekeyedby paths.Paths are lists of 8At the time \nof writing the F# compiler does not implement the Okasaki semantics, but does run the pattern compilation \nalgorithm we describe in \u00a75. This means it may run active patterns more than once against the same input. \nIt thus effectively assumes that active patterns do not have side effects, or if theydo then they are \nbenign. applyExpr : env \u00d7 state \u00d7 expr \u00d7 exprs \u00d7 value . state \u00d7 value resolveActiveTag: env \u00d7 string \n. expr \u00d7 bool \u00d7 int \u00d7 int type bind = string * value type binds = bind list Operator tobuilda Choice \ntag for the useof an active pattern identi.er: tagName m n = sprintf \"Choice%d_%d\" m n Operators to combine \npattern evaluations conjunctively and disjunctively: 2 f1 f2= .(s,binds). s ,matchRes = f1 (s,binds) \nmatch matchRes with | None . s ,None | Some(binds) . f2 (s ,binds) f1f2= .(s,binds). s ,matchRes = f1 \n(s,binds) match matchRes with | None . f2 (s ,binds) | Some(binds) . (s ,Some(binds)) Figure 2. Assumptions \nand preliminary de.nitions matchPat : env \u00d7 pat \u00d7 value . state \u00d7 binds . state \u00d7 binds option matchPat \n(env,pat,v) (s,binds) = match pat,v with | PPair(p1,p2), VPair(v1,v2) . 2 (matchPat(env,p1,v1) matchPat(env,p2,v2)) \n(s,binds) | PBoth(p1,p2) ,_ . 2 (matchPat(env,p1,v) matchPat(env,p2,v)) | PEither(p1,p2),_ . (matchPat(env,p1,v)matchPat(env,p2,v)) \n| PTag(s1,p ), VTag(s2,v ) when s1 = s2 . matchPat (env,p ,v ) (s,binds) (s,binds) (s,binds) | PConst(c1), \nVConst(c2) when c1 = c2 . (s,Some binds) | PWild,_ . (s,Some binds) | PId(nm),v . (s,Some ((nm,v)::binds)) \n| PActive(nm,args,p0), _ . f,total,numCh,n = resolveActiveTag(env,nm) s ,v = applyExpr(env,s,f,args,v) \np1 = if numCh = 1 then p0 else PTag(tagName numCh n,p0) p2 = if total then p1 else PTag(\"Some\",p1) matchPat(env,p2,v \n) (s ,binds) |_ . (s,None) matchRules: env \u00d7 rules \u00d7 value . state . state \u00d7 binds option matchRules(env,rules,v) \ns = match rules with | [] . (s,None) | (pat,expr) :: rules . s ,matchRes = matchPat (env,pat,v) (s,[]) \nmatch matchRes with | None -> matchRules (env,rules ,v) s | Some(binds) . (s ,Some(binds,expr)) Figure \n3. Pattern Matching: Naive Operational Semantics identi.ers. We assume functions lookup and record exist \nto read and write this table. At each initial call to matchPat the path is empty. In the recursive calls \nto matchPat the path is extended in different cases as follows: for PPair itisextendedbyL/Rontheleft/right \nrespectively; for PTag it is extended by the data tag; for PActivepatterns withnoargumentsitisextendedbythe \npattern tag; for PActive patterns with arguments it is extended by a freshly generated identi.er, for \nreasons covered in \u00a75.1.2; for other cases the path is not extended. The lookup table is consulted at \nPActivepatterns by replacing the application of applyExpr with: | PActive (nm,args,p ), _ . s,v = match \nlookup s path with | None . s ,v = applyExpr(env,s,f,args,v) s = record s path v s ,v | Some v . s,v \n... These changes are together suf.cient to ensure that we only invoke an unparameterized activepattern \non the same input at most once while matching a value against a set of rules, where paths are used to \ndetermine if two inputs are the same.  3.3 Static semantics We do not give a corresponding static semantics, \nas it follows the normal type-checking rules forpatterns. However we note the following: As expected, \nan additional case for active patterns is required and it follows the form of the corresponding case \nfor the dy\u00adnamic semantics with a constraint that the return type of the active pattern has the shapeexpected \nas speci.edinTable1.  Different total and partial patterns may be used in the same pat\u00adtern to match \nagainst the same inputs. However,this may impair the compiler s ability to analyse redundancy and incomplete\u00adness. \n The static semantics stay simple only if we do not attempt to specify redundancyand incompleteness \nchecking. These do not normally form part of the speci.cation of pattern matching in ML-family languages \nand are instead seen as compiler-speci.c features added to enhance programmer productivity. 9  4. Further \nExamplesof ActivePatterns In this section we look at three additional examples of the use of active patterns. \n4.1 Join Lists Join lists are a classic example of the use of view-like mechanisms in functional languages. \nTheyare also an example of recursive pat\u00adtern de.nitions. Here is the standard polymorphic join list \nexample in F# code: 9Recently Maranget (2007) has proved the correctness of some pattern matching algorithms \nwith respect to these properties, and we believe these techniques may be helpful for active patterns \nas well. type a jlist = | Empty | Single of a | Join of a jlist * a jlist let rec (|Cons|Nil|) = function \n| Single x -> Cons(x, Empty) | Join(Cons(x,xs), ys) -> Cons(x, Join(xs, ys)) | Join(Nil(), Cons(y,ys)) \n-> Cons(y, Join(ys, Empty)) | Empty | Join(Nil(), Nil()) -> Nil() let jhead js = match js with | Cons(x,_) \n-> x | Nil -> failwith \"empty list\" let rec jmap f xs = match xs with | Cons(y,ys) -> Join(Single(f y), \njmap f ys) | Nil() -> Empty The de.nition of the (|Cons|Nil|) total pattern is syntactically very close \nto the corresponding view de.nition as proposed in (Wadler 1987). This is pleasing: the pattern being \nde.ned can be used withinitsown de.nition,andtype inferenceworkseffectively for these de.nitions. 4.2 \nXML Matching XML is perhaps the most important structured heterogeneous data type in use today. In this \nsection we present an initial version of de.ning compositionalpatterns for XML fragments.We focus on \npatterns that traverse the immediate structureofXML trees, rather than query operators. The talented \nprogrammer is free to de.ne suitable new patterns, perhaps based on advanced query tools that may be \nimplemented by existing XML libraries such as XLinq (Meijer and Beckman 2006). Our example uses the System.Xml \nAPI of the .NET libraries. For our purposes this simply makes XML available as an untyped expression \ntree accessed via the following types and dot-notation members: type XmlNode with member Item : string \n-> XmlNode member Name : string member Attributes: XmlAttributeCollection member ChildNodes: XmlNode[] \ntype XmlAttributeCollection with member GetNamedItem: string -> string type XmlAttribute with member \nValue: string In this example our aim is to map XML representing a scene graph of 3D shapes into an algebraic \ndatatype, e.g. consider the following input: <Scene> <Intersect> <Sphere r= 2 x= 1 y= 0 z= 0 /> <Intersect> \n<Sphere r= 2 x= 4 y= 0 z= 0 /> <Sphere r= 2 x= -3 y= 0 z= 0 /> </Intersect> <Sphere r= 2 x= -2 y= 1 z= \n0 /> </Intersect> </Scene>\" AsuitableF#typetorepresentthisdataina strongly-typedfashion is: type scene \n= | Sphere of float * float * float * float | Intersect of scene list We .rst de.ne some general-purpose \nand simple active patterns that we can reuse for many XML samples. The partial pattern (|Elem| |) checks \nan element hasagiven name:10 let (|Elem|_|) name (inp: #XmlNode) = if inp.Name = name then Some(inp) \nelse None We next de.ne patterns (|Attributes|) to extract the attributes from a node, and (|Attr|) to \nlook for an attribute of a particular name and extracts is value: let (|Attributes|) (inp: #XmlNode) \n= inp.Attributes let (|Attr|_|) attr (inp: XmlAttributeCollection) = match inp.GetNamedItem(attr) with \n| null -> None | node -> Some(node.Value) Our .nal general-purpose pattern converts a string to a .oat: \nlet (|Float|_|) s = try Some(Float.of_string s) with _ -> None We can now write a derived pattern to \nmatch a collection of at\u00adtributes that representavector, e.g. x= -3 y= 0 z= 0 . Note this pattern cannotfailexceptby \nraising anexception: let (|Vector|_|) inp = match inp with | (Attr \"x\" (Float x) &#38; Attr \"y\" (Float \ny) &#38; Attr \"z\" (Float z)) -> Some(x,y,z) | _ -> None We can now write recursive functions to map \nXML nodes named Sphere or Intersect into the datatype:11 let rec (|ShapeElem|_|) inp = match inp with \n| Elem \"Sphere\" (Attributes (Attr \"r\" (Float r) &#38; Vector (x,y,z))) -> Some (Sphere (r,x,y,z)) | Elem \n\"Intersect\" (ShapeElems(objs)) -> Some (Intersect objs) | _ -> None and (|ShapeElems|) inp = [ for (ShapeElem \ny) in inp.ChildNodes -> y ] Finally we can wrap this up in a parse function that checks the top node \nis a Scene node and extracts the shapes from its child nodes: let parse inp = match inp with | Elem \"Scene\" \n(ShapeElems elems) -> elems | _ -> failwith \"not a scene graph\" let inp = \"... the XML above ...\" let \ndoc = new XmlDocument() let res = doc.LoadXml(inp) Wehavenowsuccessfully mapped an untyped XML document \ninto the following strongly typed data: res : scene = Intersect [ Sphere((2.0,1.0,0.0,0.0); 10 As in \nOCaml the notation #ty means a type variable constrained to be anysubtype of ty . 11 The de.nition of \nShapeElems uses F# list comprehension notation. Intersect [ Sphere(2.0,4.0,0.0,0.0); Sphere(2.0,-3.0,0.0,0.0) \n]; Sphere(2.0,-2.0,1.0.0.0) ] 4.3 Quotations F# allows a form of meta-programming where F# code can \nbe rei.edasvaluesat run-timeand manipulated(Syme2006b).Quasi\u00adquotationprovidesaconvenient meansof constructingcodevalues; \nhowever there is no convenient solution for deconstructing code values.Traditional pattern matching cannot \nbe used because code is represented by an abstract type. Even if it could, it is useful to have multiple \ndifferent decompositions to view code at the right level of abstraction for the analysis being performed, \ne.g., in terms of low-level lambda abstractions or in terms of high-level control structures. Matching \non quotations was a major consideration for the de\u00adsign of active patterns, initially sparked by quotation \nmatching in ForteFL (Grundy et al. 2006), and code patterns in MetaML (Taha and Sheard 1997). For example, \nquotation literals, writ\u00adten <@@ ... @@>, can be passed as parameters to active patterns which use the \nliterals to help drive the matching process: open Quotations open Quotations.Raw // interp : Quotations.Raw.Expr \n-> float let rec interp inp = match inp with | TopDefnApp <@@ sin @@> [x] -> sin (interp x) | TopDefnApp \n<@@ cos @@> [x] -> cos (interp x) | Double(x) -> x | _ -> failwith \"unrecognized\" printf \"res1 = %g\" \n(interp <@@ sin(cos(1.0)) @@>) In this example, the active pattern TopDefnApp from the F# library matches \nquotation terms that represent applications of a speci.c function indicated by its parameter, in this \ncase the F# functions sin and cos. 5. Implementation Inthis sectionwelookattwo aspects relatedtothe implementation \nof the mechanism described in this paper: pattern match compila\u00adtion and the representation of return \nresults. 5.1 Pattern Match Compilation For pattern match compilation F# uses the generalized pattern \ncom\u00adpilation algorithm of Scott and Ramsey(2000) with a left-to-right heuristic. Modifying this algorithm \nto implement a valid interpre\u00adtationof active patternswasfairly straight-forward. The algorithm of Scott \nand Ramsey (2000) works as follows. At each step, a heuristic chooses a point of investigation for a \ncollection of frontiers. Frontiers represent partially investigated pattern match rules.Apointofinvestigation \ncorrespondstoasingle decision point (e.g. a switch on an integer tag). Each point of investigationis \nrepresentedbya sequenceof integers calleda path, and, in the absence of active patterns, represents a \npath to a sub\u00adterm of the input term. Given the point of investigation, the frontiers are divided into \nthose edges that are relevant,i.e. where information from the investigation may result in the success/failure \nof the rule, and those that are tips, i.e. irrelevant. A decision tree node is then constructed that \nhas subtrees corresponding to projecting the success/failure of the investigation through the relevant \nedges. A default case is added for the tips. The process is then repeated until all frontiers are exhausted. \nMatch incompleteness warnings can be given if a .nal dummy rule is ever exercised. 5.1.1 Modi.cation \n1: Choosing the Edge Set In the absence of active patterns, the algorithm of Scott and Ram\u00adsey (2000) \nensures that all irrelevant frontiers have a trivial (i.e. wildcardorvariable) patternsatthepointofinvestigation.Withac\u00adtive \npatterns this assumption is no longer valid, because it might take several different investigations to \nrun several different active patternsagainstagiven input.We thus modi.ed the algorithm as follows: When \npartitioning edges, choose a pre.x of relevant edges based on the point of investigation, where all the \nedges are related to the same pattern. If the pattern has no identity, i.e., is a parameterized active \npattern, then only the .rst relevant edge is chosen. 5.1.2 Modi.cation2:Pattern IdentityandPath Identi.ers \nA second modi.cation to the algorithm of Scott and Ramsey (2000) is necessary to ensure a distinction \nbetween sub-terms and paths .Paths describe potential points of investigation in the pattern structure. \nIn the presence of active patterns, paths must record which active patterns have led us to a particular \nnested pat\u00adtern. Consider the following: let (|Bit|) n = let mask = 1ul <<< n in fun inp -> ((inp &#38;&#38;&#38; \nmask) <> 0ul) match 0b0001000100ul with | Bit 3 true -> printfn \"No!\" | Bit 2 false -> printfn \"No No!\" \n| Bit 2 true &#38; Bit 3 false -> printfn \"Yes indeed!\" | _ -> failwith \"\" If the Bit 3 pattern succeeds,but \nits true sub-pattern fails, then no information isgained about the success orfailure of the false sub-pattern \nof Bit 2 false. This is because the parameter to the pattern is different in each case, or, more speci.cally, \nbecause we don t consider parameterized patterns to have anykind of identity. In a naive extension of \nthe original algorithm these would be given identical path locations, which would be incorrect. For this \nreason, we extended the notion of path so that different instances of parameterized patterns encountered \nthrough pattern match compilation are allocated fresh, unique integers and these integers are used within \npaths. 5.1.3 Modi.cation 3: Rule Chunking The extensive use of active patterns (particularly partial \npatterns) can quickly lead to signi.cant (even exponential) blow up in the size of generated decision \ntrees (Okasaki 1998). This is partly due to the fact that failing sub-patterns can lead to duplications \nof the large frontier sets that are used to investigate multiple rules simultaneously. For this reason, \nwe additionally modi.ed the algorithm of Scott and Ramsey(2000) to abandon the use of large frontier \nsets when\u00adever partialpatterns are used. That is, when compiling N rules, we have a choice as to whether \nwe compile all rules simultaneously, or one-by-one,orin chunks.We choosea pre.xof rulesuptothe .rst that \nuses anykind of partial pattern. This may result in active patternsbeing called more timesthanmaybeexpected,but \nreduces code size substantially on some real-world examples.  5.2 Performance and the Representation \nof Return Results Performance is not the primary focus of this paper,for the following reasons: We believe \nthat even a naive implementation of the constructs described here would increase expressive power suf.ciently \nto justify their inclusion in a language. The inclusion of multi-way total patterns in the design inher\u00adently \ngives us a foundation for signi.cantly better performance than the proposed extensions for ad hoc matching. \nMulti-way total patterns allow multiple rules to be explored with a sin\u00adgle discrimination, as with regular \nmatching on discriminated unions.  Important cases such as conversion patterns (i.e., patterns such \nas (|Complex|))do not occur anyoverhead: they are just function calls that can be inlined and optimized \nas usual.  In addition, we know of several techniques that should, in theory, substantially improve \nthe performance of patterns but which we have not yet implemented. In particular, one performance consid\u00aderation \nis the representation used for return results of patterns. The current F# implementation uses: null \nfor a failing partial pattern (i.e. None is represented as null);  a boxed value for a succeeding partial \npattern (i.e. Some(1) results in a boxed integer);  asimple unboxedvalue for single-tag total patterns \nlikeComplex;  a boxed tagged value such as Choice3 1(1) for multi-tag total patterns .  Tuples in return \nvalues also currently require an extra allocation. This means the current implementation does perform \nallocations on manypattern calls. However, an easy technique that will eliminate nearly all allo\u00adcationsisavailableto \nus: .NET supports type-safe structs,i.e. types whose representationis nota heap-allocatedGC pointerbut \nrather an inline collection of values, generally immutable and copied as needed. While the F# compiler \ndoesn t yet use structs for options, choices and tuples, it is clear that these are excellent candidates \nto do so. This may also bring other performance bene.ts to F# code.12 However such a change must be thoroughly \nperformance tested as it has rami.cations well beyond the scope of this paper. 6. Feature Interactions \nand FutureWork In this section we look at how activepatterns interact with some related language features. \nThese features do not currently exist in F#, though some are likely to be added in due course. However,this \npaper aims to make a contribution relevant to languages other than F#, and hence we consider it essential \nto think through potential feature interactions in OCaml, Haskell and other statically typed functional \nlanguages. 6.1 Typesfor Recognizers Thetypeswehavegivenfor patternsuseanencodingofanonymous unlabeled \nsum-types tagged by the name choice: val (|Cons|Nil|): a llist -> ( a * a llist,unit) choice However, \nunlabeled sum types are not a particularly useful extension to functional languages. It is evident that \nOCaml-style polymorphicvariant typeswouldbe usefulhere: val (|Cons|Nil|) : : a llist -> [ Cons of ( a \n* a llist) | Nil ] Thisraisesthequestion:couldanactivepattern mechanismbebuilt entirely in terms of the \ntag information in a labeled sum type? This appears dif.cult without some kindof syntacticextension,butis \nan openquestion and is an interesting, especially for the OCaml community. 12 The designers of Nemerle \n(Nemerle 2006) have reported corresponding performance improvements for tuples in private correspondence. \n 6.2 Tag-Bound Existentials and GADTs Existentials are a natural extension to pattern matching in lan\u00adguages \nwith enriched datatypes(L\u00a8 aufer and Odersky1992) or sub\u00adtypingand runtime types.Forexample,the followingisthelikely \nsyntax for a proposed extension to F# where type variables can be existentially quanti.ed at pattern \nmatches involving type tests:13 match obj with | < a> :? List< a> as l -> ... | < a> :? a[] as arr -> \n... | < k, v> :? Dictionary< key, value> -> ... Thisextensionis notyet implementedinF#,butis implementable, \nby using some of the re.ection machinery of the .NET Common Language Runtime, and there are manyknown \nexamples where it would be useful. But whatof active patterns?Forexample,itwouldbe reason\u00adable to expect \nto be able to write recognizers that abstract one or more of these patterns: match obj with | < a> AnyListOrArray(l \n: a list) -> ... | ... However what is the type of AnyListOrArrray?One natural encod\u00ading is to permit \nanonymous existentials as part of the return type of patterns: val (|AnyListOrArray|_|) : obj -?> (. \na. a list) let (|AnyListOrArray|_|) (obj) : (. a. a list) = match obj with | < a> :? List< a> as l -> \nSome(l) | < a> :? a[] as arr -> Some(Array.to_list arr) | _ -> None Here we have assumed an extension \nto the type algebra of the form .a. t, and t1 -?> t2 is used as a shorthand for t1 -> t2 option. We have \nalso assumed an implicit pack operation on each branch of the result of the implementation of the active \npattern. Generalized Algebraic Data Types (GADTs) generalize exis\u00adtentials by allowing data construction \ntags to existentially quan\u00adtify constraints as well as variables (Xi et al. 2003). Here a natural encoding \nis again to enrich the type system to ensure that simple function types are rich enough to encompass \nthese constraints.For example, consider the following possible signature for a partial ac\u00adtive pattern \nto match lambda nodes in a strongly typed abstract term structure, one of the canonical examples of GADTs: \ntype Expr< a> // an abstract type val (|Lambda|_|) : Expr< a> -?> (. b c. ( a = b -> c) => Var< b> * \nExpr< c>) Here we have assumed an extension to the type algebra of the form .a. C => t, where C expresses \nequational type constraints, which are suf.cient to capture those that correspond to GADT declarations. \nWhile the above approach to existentials and GADTs is plausi\u00adble, it is also an intrusive addition to \na STFL, especially (but not only) with regard to type inference.For this reason it may instead be reasonable \nto explore non-type-based extensions that only per\u00admit the use of existentials as part of the return \ntype of patterns. This is indeed in the spirit of GADTs themselves which draw much of their expressive \npower by being a limited locale for existential 13 The F# pattern :? ty as id is a type-test pattern, \nand if it succeeds it binds id to the input value at the stronger type. In the current F# design no patterns \nmay bind type variables. In the proposed extension the existentials would be witnessed by solving the \ntype tests w.r.t. the runtime type of the input object. Match expressions: [[matchm < M >e with rules]] \n= let t=e in [[rules]]M,t Rules: [[p->e|rules]](M,t) = plus [[p]]M,t,e [[rules]]M,t [[\u00d8]](M,t) = zero \nPatterns: ' [[Cp]]M;t;e = bind (Ct)(fun t- > [[p]]M;tl;e) [[x]]M;t;e = let x=t in return e where each \nt is a fresh variable. Figure 4. Monadic desugaring of simple patterns quanti.cation. The logical conclusion \nof this design is that patterns have a more special status in the language than theycurrently do in the \ndesign we have described. 6.3 Monadic andTransactionalPattern Matching Sofar we have observed that partial \npatterns are functions of type a -> b option. The choice of the option is arbitrary and many other types \ncould be used. In particular, it is possible to generalize the return type of a pattern matching function \nto anything that implements Haskell s MonadPlus type class (Tullsen 2000). In future work we expect to \nextend F# with support for con\u00adstrained higher-kinded type parameters. In this case the return type of \nstructured names (|A| |) could feasibly be generalized to a M 14 when M :> MonadPlus. Regular pattern \nmatching cannot be immediately adapted to be\u00adcome monadic matching: for example, a monadic matching con\u00adstruct \nshould not necessarily run the monadic value produced. Instead we consider a monadic match expression \nof the form matchm<ty >, where the monad being used is explicitly speci.ed. Amatchm expression can then \nbe translated into a regular monadic expression usingrules such as those in Figure 4. The translation \nas\u00adsumes the monad of interest stays .xed throughout the pattern, i.e., that nested patterns match in \nthe same monad as the outer pattern. Useful instances of MonadPlus include lazy lists for back\u00adtracking \nevaluation andthe software transactional memory (STM) monad for transactional evaluation (Harris et al. \n2005). Different choices of matching monad produce remarkably different seman\u00adtics for the match block. \nFor lazy lists the plus operation is concatenation. This means that the results of multiple rules are \naggregated, which is quite different to the .rst-rule-succeeds interpretation of simple (option monad) \npattern matching. More interestingly, for STM monads the zero operation causes a transaction to re-execute \n(and potentially block) and the plus operation rolls back the effects of the .rst transaction if it fails \nand then executes the second. Hence a transaction monad can be used to control the use of side-effects \nin a pattern by rollingback effects whena patternfails. Thus at most one rule succeeds.For example, we \ncan use an active pattern to read from two concurrent MVar values in a transaction: val (|ReadMVar|_|) \n: a MVar -> a STM let f mv1 mv2 = atomically 14 The higher-kinded type parameter generalizes the occurrence \nof option. The constraint M :> MonadPlus dictates that M is an instance of MonadPlus. We assume the MonadPlus \ntype de.nes the standard mem\u00adbers return, bind, zero and plus. (matchm<STM> mv1, mv2 with | ReadMVar \nx, ReadMVar 0 -> x | _, ReadMVar y -> y) Reading from an MVar is a destructive, side-effecting operation. \nUsing the STM monad, if the .rst match case fails the effect of reading mv1 and mv2 is rolled-back before \nthe second match case is evaluated. The monadic interpretation of this code would be semantically equivalent \nto this Haskell code: f mv1 mv2 = atomically $ do { x <-readMVar mv1; y <-readMVar mv2; guard (y==0); \nreturn x } mplus do { y <-readMVar mv2; return y } 7. Assessment and RelatedWork This paper has presented \nthe .rst design for extensible pattern matching to incorporate both partial and total decompositions \nwithin the context of a regular, simple and lightweight extension. We have given a description of the \nlanguage extension along with numerous motivating examples. Finally we have looked at how this feature \ninteracts with other reasonable and related language extensions. Since this work .rst began in mid-2006 \nthere has been a mini-explosion in discussions, designs and prototypes of view\u00adlike mechanisms in programming \nlanguages (Syme 2006a; Emir and Odersky 2007; Rossberg 2007b; Peyton Jones 2007; Jambon 2007).Webelieveour \ndesign achieves the bestoverall functionality for a simple extension to the core of a statically-typed \nfunctional programming language. Peyton Jones et al. have started a lengthy and useful design note on \na possible extensible pattern-matching design for Haskell (Peyton Jones 2007). In this discussion theyhighlight \n.ve features that a view-like mechanism may have in Haskell: the value input feature,implicit maybes,transparent \nordinary patterns,nesting and integration with type classes, the last of which can be seen as a Haskell \nequivalent of views as .rst-class values. In the context of F#, the design described in this paper effectively \nhas all .veof these features, which correspond as follows: PeytonJones Classi.cation OurTerminology Value \ninput feature Parameterized patterns Implicit maybes Partial patterns Transparent ordinary patterns Total \npatterns Nesting Nesting of active patterns Integration with type classes Patterns as .rst-class values \nTo ourknowledge no other proposed design in this area achieves this combination of features with a single, \nsimple and consistent extension to the language. Manyof the existing proposals for extensible pattern \nmatching in other languages focus only on partial matching and leave total matching unaddressed (Erwig \n1997; Emir and Odersky2007). Two recent designs for languages close in spirit to F# are Ross\u00adberg s views \nand ad hoc patterns for HamletS (Rossberg 2007b), and Emir and Odersky s unapply or extractor methods \nfor Scala (Emir and Odersky 2007). Ignoring differences between object-oriented and functional syntax, \nthe Scala proposal essen\u00adtially matches the F# design for partial pattern matching, though the potential \nto combine the mechanism with the rich object constraint and composition system of Scala opens interesting \npossibilities. Rossberg s work introduces views as a new type-like de.nition construct, as in Wadler \ns initial proposal for views, and partial patternsviaa separateextensionto pattern matching.In someways \nthe proposal is richer (e.g., views are named and view aliases are supported), in other ways it appears \nless satisfactory (e.g., partial patterns and views are distinct mechanisms). Peyton Jones (2007) and \nEmir and Odersky(2007) give a good review of related work in this area. Many previous proposals to tackle \nthe problem of pattern matching and abstraction have con\u00adcentrated primarily on the supporting the de.nition \nof either views (Wadler 1987; Burton and Cameron 1993), Okasaki s proposal for Standard ML (Okasaki 1998) \nor partial patterns (Gostanza et al. 1996; Erwig 1997; Erwig and Jones 2000). Le Fessant and Maranget \n(2001); Maranget (2007) have proved the correctness of algorithms for optimizing pattern matching and \nfor pattern incompleteness and redundancy checking : it is very interesting to consider how to extend \ntheir techniques to active patterns.F \u00a8 ahndrich and Boyland (1997) have looked at permitting only statically \nchecked de.nitionsof patternsintermsofexisting patterns(as opposedto de.ning recognizersbyarbitrary functions). \nUsingextensible patternsas .rst-classvalueswas .rst proposedby Tullsen (2000), where he also observed \nthe monadic generalization we consider in 6.3, though not its potential application to trans\u00adactions. \nSophisticated forms of XML-speci.c language constructs and matching have been studied by a range of authors: \nHosoya and Pierce (2001); Benzaken et al. (2003). Acknowledgments We owe thanks to Simon Peyton Jones, \nMartin Odersky, Andreas Rossberg,PhilWadlerandBurakEmirfor discussionsonthistopic. We also thank CedricFournet, \nClaudio Russo, Georges Gonthier and Ralf Herbrich for helping with informal assessments of the design \nand its implementation. References V. Benzaken, G. Castagna, and A. Frisch. CDuce: An XML-centric general\u00adpurpose \nlanguage. In Proceedingsof 2003ACM SIGPLAN International Conference on FunctionalProgramming.ACMPress, \n2003., 2003. F.Warren Burtonand RobertD. Cameron. Pattern matching with abstract data types. Journal \nof Functional Programming, 3(2):171 190, 1993. Burak Emir and Martin Odersky. Matching Objects with Patterns. \nIn ECOOP 07, 2007. To appear. Martin Erwig. Activepatterns. In Implementation of Functional Languages. \nSpringer, 1997. Martin Erwig and Simon Peyton Jones. Pattern Guards andTransforma\u00adtionalPatterns. In \nHaskellWorkshop, 2000. ManuelF\u00a8ahndrich and JohnBoyland. Statically checkable pattern abstrac\u00adtions. \nIn International Conference on Functional Programming.ACM, 1997. PedroPalao Gostanza, Ricardo Pena, and \nManuel Nunez. A new look at pattern matching in abstract data types. In ICFP 96: Proceedings of the .rstACM \nSIGPLAN international conference on Functional program\u00adming, pages 110 121,NewYork,NY, USA, 1996.ACM \nPress. Jim Grundy,Tom Melham, and John O Leary.Are.ective functional lan\u00adguage for hardware design and \ntheorem proving. Journal of Functional Programming, 16(2):157 196, 2006. Tim Harris, Simon Marlow, Simon \nPeyton Jones, and Maurice Herlihy. Composable memory transactions. In Principles andPracticeofParallel \nProgramming.ACM, 2005. Haruo Hosoya and Benjamin Pierce. Regular expression pattern matching for XML. \nACM SIGPLAN Notices, 36(3):67 80, 2001. Martin Jambon. Micmatch. martin.jambon.free.fr/micmatch.html, \n2007. KonstantinL\u00a8 auferand Martin Odersky.AnextensionofML with .rst-class abstract types. In ACM SIGPLANWorkshoponMLandits \nApplications, SanFrancisco, California, pages 78 91, June 1992. Fabrice Le Fessant and Luc Maranget. \nOptimizing pattern-matching. In Proceedings of the 2001 International Conference on Functional Pro\u00adgramming.ACM \nPress, 2001. Luc Maranget. Warnings for pattern matching. Journal of Functional Programming, 17(3):647 \n656, 2007. Erik Meijer and Brian Beckman. XLinq: XML Programming Refactored. research.microsoft.com/~emeijer, \n2006. Nemerle. Nemerle website. nemerle.org, 2006. Martin Odersky. Scala website. scala.epfl.ch, 2006. \nMartin Oderskyand PhilipWadler. Pizza intoJava:Translating theory into practice. In Principles of Programming \nLanguages.ACM, 1997. Chris Okasaki. Views for Standard ML. In SIGPLANWorkshop on ML, Baltimore, Maryland, \nUSA, pages 14 23, September 1998. Simon Peyton Jones. View patterns: lightweight views for Haskell (wiki \nentry). hackage.haskell.org/trac/ghc/wiki/ViewPatterns, 2007. Andreas Rossberg. Generalizing layered \npatterns to conjunctive patterns. successor-ml.org, 2007a. Search for Generalizing Layered Pat\u00adterns \n. Andreas Rossberg. Hamlet S: To Become or Not To Become Succes\u00adsor ML. www.ps.uni-sb.de/hamlet/hamlet-succ-1.3.0S4.pdf, \n2007b. Appendix B.17 and B.19. Kevin Scott and Norman Ramsey. When Do Match-compilation Heuristics Matter?Technical \nReport CS-2000-13, UniversityofVirginia, 2000. Don Syme. Active patterns in F#. blogs.msdn.com/dsyme, \n2006a. Don Syme. Leveraging .NET meta-programming components from F#: Integrated queries and interoperable \nheterogeneous execution. In Pro\u00adceedings of theACM SIGPLANWorkshop on ML and its Applications, 2006b. \nDon Syme and James Margetson. F# website. research.microsoft.com/fsharp, 2006. WalidTaha andTim Sheard. \nMulti-stage programming withexplicit anno\u00adtations. In Partial Evaluation and Semantics-Based Program \nManipula\u00adtion.ACM, 1997. Mark Tullsen. First class patterns. In Practical Aspects of Declarative Languages. \nSpringer, 2000. Philip Wadler. Views: A way for pattern matching to cohabit with data abstraction. In \nPrinciples of Programming Languages.ACM, 1987. Hongwei Xi, Chiyan Chen, and Gang Chen. Guarded recursive \ndatatype constructors. In Proceedings of the 30thACM SIGPLAN-SIGACT sym\u00adposium on Principles of Programming \nLanguages, pages 224 235, New York,NY, USA, 2003.ACM Press. A. An ExampleWithout ActivePatterns Below \nis the example from \u00a72.2 without active patterns: open System let rec formatType (typ : Type) = if typ.IsGenericParameter \nthen sprintf \"!%d\" typ.GenericParameterPosition elif typ.IsGenericType || not typ.HasElementType then \nlet args = if typ.IsGenericType then typ.GetGenericArguments() else [| |] let con = typ.GetGenericTypeDefinition() \nif args.Length = 0 then sprintf \"%s\" con.Name else sprintf \"%s<%s>\" con.Name (formatTypes args) elif \ntyp.IsArray then sprintf \"Array(%d,%s)\" (typ.GetArrayRank()) (formatType (typ.GetElementType())) elif \ntyp.IsByRef then sprintf \"%s&#38;\" (formatType (typ.GetElementType())) elif typ.IsPointer then sprintf \n\"%s*\" (formatType (typ.GetElementType())) else failwith \"MSDN says this can t happen\" and formatTypes \ntyps = String.Join(\",\",Array.map formatType typs)   \n\t\t\t", "proc_id": "1291151", "abstract": "<p>Pattern matching of algebraic data types (ADTs) is a standard feature in typed functional programming languages, but it is well known that it interacts poorly with abstraction. While several partial solutions to this problem have been proposed, few have been implemented or used. This paper describes an extension to the .NET language F# called <i>active patterns</i>, which supports pattern matching over abstract representations of generic heterogeneous data such as XML and term structures, including where these are represented via object models in other .NET languages. Our design is the first to incorporate both ad hoc pattern matching functions for partial decompositions and \"views\" for total decompositions, and yet remains a simple and lightweight extension. We give a description of the language extension along with numerous motivating examples. Finally we describe how this feature would interact with other reasonable and related language extensions: existential types quantified at data discrimination tags, GADTs, and monadic generalizations of pattern matching.</p>", "authors": [{"name": "Don Syme", "author_profile_id": "81100612953", "affiliation": "Microsoft Research, Cambridge, U.K.", "person_id": "P68181", "email_address": "", "orcid_id": ""}, {"name": "Gregory Neverov", "author_profile_id": "81100148391", "affiliation": "Queensland University of Technology, Brisbane, Australia", "person_id": "PP37043830", "email_address": "", "orcid_id": ""}, {"name": "James Margetson", "author_profile_id": "81337491575", "affiliation": "Microsoft Research, Cambridge, U.K.", "person_id": "P900678", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291159", "year": "2007", "article_id": "1291159", "conference": "ICFP", "title": "Extensible pattern matching via a lightweight language extension", "url": "http://dl.acm.org/citation.cfm?id=1291159"}