{"article_publication_date": "10-01-2007", "fulltext": "\n Experience Report: Building an Eclipse-based IDE for Haskell Leif Frenzel himself@leiffrenzel.de Abstract \nThis paper summarizes experiences from an open source project that builds a free Haskell IDE based on \nEclipse (an open source IDE platform). Eclipse is extensible and has proved to be a good ba\u00adsis for IDEs \nfor several programming languages. Dif.culties arise mainly because it is written in Java and requires \nextensions to be written in Java. This made it hard to reuse existing development tools implemented in \nHaskell, and turned out to be a considerable obstacle to .nding contributors. Several approaches to resolve \nthese issues are described and their advantages and disadvantages dis\u00adcussed. Categories and Subject \nDescriptors D.2.6 [Programming Envi\u00adronments]: Integrated Environments Eclipse; D.3.2 [Program\u00adming Languages]: \nApplicative (functional) languages Haskell General Terms Languages  1. Introduction In April 2004, I \nstarted an open source project (EclipseFP 2007) to build a free Haskell IDE based on Eclipse (Eclipse \n2007).1 For a project that is based on volunteer work, reuse of existing function\u00adality is vital. The \ngoal was from the beginning to mostly integrate existing development tools (compilers, interpreters, \nrefactorer etc.) on top of a suitable IDE platform. I chose Eclipse, primarily be\u00adcause I was already \nfamiliar with its concepts and APIs. There are, however, a number of further reasons that make Eclipse \nan obvious candidate.2 Eclipse is free, developed by an open source project, has a lively community and \nis backed by large software companies who are members of the Eclipse Foundation and thus committed to \nsupport\u00ading maintenance and further development. It has well-de.ned APIs, and modularity and extensibility \nare built right into its core. More\u00ad 1 Since then, several developers have joined. The project is hosted \nat source\u00adforge.net and has now 5 developers; the development mailing list has cur\u00adrently 47 subscribers. \nI will use the .rst person plural when referring to our work as a group; I use the .rst person singular \nonly for some initial decisions made by me at the very beginning of the project. 2 A number of other \nprojects exist which implement Haskell IDEs, some from scratch, some based on other platforms than Eclipse. \nSince this is an experience report focused on a particular project, none of these are discussed here. \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n07, October 1 3, 2007, Freiburg, Germany. Copyright c &#38;#169; 2007 ACM 978-1-59593-815-2/07/0010. \n. . $5.00 over, language-neutral functionality and language-speci.c func\u00adtionality are separated by design, \nso that an IDE can be built upon the language-neutral layer (the Eclipse Platform ) without need to keep \nany speci.c support for other languages (such as Java). There is also a large number of reusable UI components. \nExtending Eclipse works by implementing Java classes (con\u00adforming to interfaces speci.ed by the Eclipse \nAPIs) and declar\u00ading them in an XML manifest .le. There is no support for ex\u00adtending Eclipse in other \nlanguages than Java.3 While this poses no problem for communities that want to extend Eclipse with support \nfor Java-related development tools (e.g. the popular CheckStyle code auditing tool), there is a tension \nin the case of communities around general-purpose programming languages, such as Haskell. This tension \nhas both technical and social aspects: existing tools and libraries are written in the target language \n-not in Java; and similarly, potential contributors are more likely to be interested in (and competent \nin) the target language -not in Java. 2. Integrating development tools Modern IDEs include source code \neditors that go far beyond mere syntax coloring and context-independent code completion. For ex\u00adample, \nEclipse users are used to have an Outline View available for their source .les, where top-level elements \nare presented; it can be used to quickly navigate to the location of these language elements in the source \ncode. Code portions such as comments or blocks can be folded, i.e. collapsed to a single line in the \neditor; this helps to fo\u00adcus the user s attention. With the text cursor located over a language element \n(e.g. a function name), the IDE highlights other locations in the source code where the same language \nelement appears, and it provides context options to navigate directly to its declaration, or to initiate \nan automated renaming refactoring. To beableto pro\u00advide such functionality, the IDE must be language-aware; \nin par\u00adticular, it must analyze the source text to a certain degree (which goes beyond mere text matching). \nThus it needs to be able to parse syntax trees, infer types etc. (Performance often matters in this con\u00adtext, \nsince editors must react quickly to changes that result from the user s typing.) The Haskell community \nhas already built the neces\u00adsary tools and libraries to do this, but of course these are written in Haskell. \nFor an Eclipse-based Haskell IDE thus the question arises how to integrate these tools and make their \nfunctionality available to the Plug-Ins that extend the Eclipse user interface. 2.1 Execute as external \nprogram Some tools can be integrated by requiring users to install them on their system independently \nof the IDE, and then have the IDE call the executable of the tool, passing necessary information as com\u00admand \nline arguments. A typical example would be a documentation 3 Although the possibility has been extensively \ndiscussed at the Eclipse Languages Symposium in 2005, and at several informal meetings during the annual \nEclipse developer conferences, no such support has been built into the Eclipse Platform so far, and there \nare no immediate plans to do so. generator, such as Haddock (Marlow 2007). The IDE just provides some \nuser interface for options that users may want to set, and it runs the tool in an external process over \nthe source .les managed in the IDE. With this approach, all of the integration code is writ\u00adteninJava.4 \nThere is no need for the two languages to integrate directly. This approach does not help in all cases, \nhowever. More often, a deeper integration with language-aware tools is needed for the IDE to build its \nuser interface presentation. This situation arises when implementing many coding aids such as those described \nin the pre\u00advious section. Calling an external program is not an option in such cases. This is not only \nbecause of performance requirements, but also because there is much more, and more structured, information \nthat needs to be marshalled (e.g. ASTs), compared with the case of integrating tools such as Haddock, \nwhere the necessary information is restricted to a list of .le names and a few option values. Further\u00admore, \nsome tools, such as refactoring programs, require interaction with users and therefore have to work closer \nwith the IDE and its user interface.5 There are several options for providing such a deeper integra\u00adtion. \nWe have investigated and (with one exception) implemented all of them at different stages in our project. \n 2.2 Call native Haskell via JNI/FFI To call compiled Haskell code (e.g. in dynamically linked libraries) \nmakes it possible to directly use existing Haskell APIs; and addi\u00adtional code may be written in Haskell. \nWe used this approach in our .rst attempt to implement the source code outline and code folding features \nin the Haskell editor of our IDE. The Haskell parser from Language.Haskell in the Haskell standard libraries \nwas used together with some additional logic to collect information from the AST, also implemented in \nHaskell. To call it from Java code, this was exported via Haskell s Foreign Function Interface (FFI), \ncompiled and linked together with some C code into a dynamically linked library (dll) and then accessed \nfrom an Eclipse Plug-In via the Java Native Interface (JNI). This enabled us to display the top-level \nlanguage elements in a Haskell source .le on Eclipse s Outline View and map them to source locations \nso that users could quickly navigate to them in the editor, and to compute source code regions for code \nfolding (e.g. collapse the entire region of import declarations in the editor). The main reason for dropping \nthis approach was that it was not possible to make it work on Linux systems, which was important to some \nof our contributors and users. We were only able to create a library suitable for dynamically loading \nit from inside an Eclipse Plug-In on Windows operating systems.6 We noted some additional disadvantages \nwhen taking this op\u00adtion: .rst, it requires to manage platform-speci.c binaries. Al\u00adthough this is supported \nby Eclipse, compared with platform\u00adindependent Java bytecode there is an overhead for building and release \nengineering. 4 The actual implementation of the Haddock integration in EclipseFP com\u00adprises 23 Java source \n.les with about 2850 lines of code and about 100 lines of auxiliary code in manifest .les (plus some \nuse of common functionality provided by other parts of the project). 5 The expectations of Eclipse users \nplay a role here, too. Refactoring tools in Eclipse-based IDEs provide detailed previews of the changes \nwhich are applied during the automated refactoring. There is a standard user interface in Eclipse for \nsuch situations which users have come to expect. 6 There is now support in GHC for position independent \ncode on PPC archi\u00adtectures, and there are plans to provide such support on Intel architectures in one \nof the next versions of the compiler. Once that is in place, this obstacle will be removed. Secondly, \nunhandled program errors in the native code cause the entire Java Virtual Machine (JVM) to crash. This \nbrings the entire IDE down, which is annoying for users. Moreover, since Eclipse Plug-Ins are normally \nwritten in Java, the IDE is able to handle program failures that occur in them. The behavior that users \nexpect is that the Plug-In causing the problem is disabled (possibly writing details to the error log), \nbut the rest of the IDE remains operating. With an error in a native library which was loaded by the \nJVM, this robustness cannot be warranted by Eclipse. 2.3 Re-implement in Java This makes the language-speci.c \nfunctionality very easy to call from an Eclipse Plug-In, and improves independence from speci.c operating \nsystems considerably. However, the limits of this option are obvious: It does not allow to reuse existing \nHaskell APIs at all.  Implementing all the functionality we are interested in would involve efforts \n(and most probably also formidable technical challenges) far beyond the means of our project.  It means \nusing a language that is arguably less convenient than Haskell for tasks such as analyzing and manipulating \nsource code.  There is a risk of lagging behind the evolution of the language itself.  Still, for lack \nof a better option, we have replaced the parser de\u00adscribed in the previous section with an all-Java one \nthat is generated using ANTLR, a parser generator (Parr 2007). Source code outline and code folding are \nnow based on this parser, and some additional editor features (e.g. code completion for function calls) \nhave been added. The gravest problem with this approach is that it discourages interested contributors, \nwho are typically either Haskell program\u00admers or Java programmers learning Haskell -both groups want \nto code in Haskell, not Java. 2.4 Compile Haskell to JVM bytecode An option that we have investigated \nis to implement all language\u00adaware functionality in Haskell (and access existing Haskell APIs), and compile \nall Haskell code involved to Java bytecode that can be executed in the same JVM that runs the Eclipse \nIDE. Although this would help with Haskell code written by our\u00adselves, we could not use existing libraries \n(such as the GHC API or HaRe, the Haskell Refactorer (Thompson et al. 2007)) unless we would also recompile \nthem and bundle them with our Eclipse Plug-Ins. Consequently there would be considerable maintenance \nissues. For most of the language-aware libraries it is very unlikely that they can be compiled without \ncode modi.cation into a Java bytecode version that runs on all platforms. But if we would have to main\u00adtain \na source branch of these libraries, we would commit to a huge maintenance effort. (Even if we were able \nto do this, we would still be in the questionable situation of duplicating almost all of the code from \nthese libraries.) We have found that none of the Haskell-to-JVM-bytecode com\u00adpilers (Meijer and Finne \n2000; Alliet 2007) available to date is suf\u00ad.ciently mature to support this approach, or to support a \ngeneral framework that allows to write Eclipse extensions in Haskell. How\u00adever, if such a compiler would \nbecome available at some future time, we would prefer this option over those described so far.7 7 An \nalternative we discussed is to use some language closely related to Haskell which does compile to JVM \nbytecode and is already stable (candi\u00addates would be the CAL language (Business Objects Labs 2007) or \nJaskell (Jaskell 2007)). But it would be equally impossible to reuse much of the 2.5 Haskell code as \nEclipse extension All options for integrating existing development tools that have been discussed above \nhave the additional drawback that they don t work well with Eclipse s concept of modularity and extensibility \n\u00adthey don t work together with Eclipse s Plug-In model. (Put differ\u00adently: these options are approaches \nto integrate Java and Haskell, but we re looking for a way to integrate Eclipse and Haskell.) We have \nrecently started to develop, and experiment with, a framework that addresses this issue. Unlike the unsatisfying \nsolu\u00adtions discussed so far, which tend to concentrate the native code inside one Eclipse Plug-In, it \nallows us to put Haskell code into arbitrary Plug-Ins, while there is a runtime that knows how to col\u00adlect, \nload and execute that code. This framework is fully integrated with Eclipse s Plug-In architecture and \ntherefore allows structur\u00ading applications as it is usually done there. In order to load and execute \nHaskell code, it uses hs-plugins (Stewart 2007), a Haskell library that supports dynamically loading \nand executing Haskell code (both source code and compiled object code). This new ap\u00adproach is designed \nto provide a general mechanism to declare ex\u00adtensions written in Haskell in a way that .ts into Eclipse \ns Plug-In model, but does not impose any restrictions resulting from the in\u00adtegration into Eclipse on \nthe Haskell code itself. The goal of this subproject is to .nd a way to enable access to Haskell code \nwhile avoiding the obstacles described in this paper.  3. Conclusion Building an IDE for any programming \nlanguage is a huge effort; to be able to build it on top of an existing platform is therefore in many \ncases the only road to success. The Eclipse Platform provides such a foundation, but since there is no \nsupport for extending it in other languages than Java, this complicates the task for small open source \nprojects such as the one described here. Without the possibility to write Eclipse extensions in Haskell, \nmany of the advanced (and attractive) IDE features that require a language-aware user interface cannot \nbe implemented. Apart from technical reasons (the necessary functionality is only available as Haskell \ncode, code duplication should be avoided, etc.), there is also a problem to .nd contributors for the \nimplausible task to implement a development environment for a language using a different, unrelated language. \nThis applies both to developers with advanced knowledge and to beginners -they all have a better motivation \nto write Haskell code than they have to write Java code. Yet over the recent years I have consistently \nreceived positive feedback and encouraging notes from users who are interested in a free, Eclipse-based \nHaskell IDE. The conclusion to draw from this should be to strive for .nding a way to make it possible \nto use existing Haskell code (and preferably to implement all of the Haskell-speci.c functionality in \nHaskell) from within an Eclipse extension. The developments mentioned in the previous sections are intended \nto lead into this direction. References [Alliet 2007] Alliet, Brian. LambdaVM: The Haskell to Java Translator. \nhttp://www.cs.rit.edu/ bja8464/lambdavm/ [Business Objects Labs 2007] Business Objects Labs. The CAL \nprogram\u00adming language. http://labs.businessobjects.com/cal/ [EclipseFP 2007] The EclipseFP project. EclipseFP: \nHaskell development support in the Eclipse IDE. http://eclipsefp.sourceforge.net [Eclipse 2007] The Eclipse \nproject. http://eclipse.org/eclipse/ [Jaskell 2007] The Jaskell project. http://jaskell.codehaus.org/ \n[Marlow 2007] Marlow, Simon. 2007. Haddock: A Haskell Documentation Tool. http://haskell.org/haddock/ \n[Meijer and Finne 2000] Meijer, Erik, and Finne, Sigbjorn. 2000. Lam\u00adbada: Haskell as a Better Java, \nProc. Haskell Workshop 2000. [Parr 2007] Parr, Terence. ANTLR: ANother Tool for Language Recogni\u00adtion. \nhttp://antlr.org/ [Stewart 2007] Stewart, Donald Bruce. hs-plugins: Dynamically Loaded Haskell Modules. \nhttp://www.cse.unsw.edu.au/ dons/hs-plugins/ [Thompson et al. 2007] Thompson, Simon, Reinke, Claus and \nLi, Huiqing. 2007. HaRe: the Haskell Refactorer. http://www.cs.kent.ac.uk/projects/ refactor-fp/hare.html \nexisting libraries then -unless we would port them to the chosen language. This seems unpractical, even \nfor small libraries, and there would again be a huge maintenance overhead in keeping these ports current \nwith respect to developments in their original versions.  \n\t\t\t", "proc_id": "1291151", "abstract": "<p>This paper summarizes experiences from an open source project that builds a free Haskell IDE based on Eclipse (an open source IDE platform). Eclipse is extensible and has proved to be a good basis for IDEs for several programming languages. Difficulties arise mainly because it is written in Java and requires extensions to be written in Java. This made it hard to reuse existing development tools implemented in Haskell, and turned out to be a considerable obstacle to finding contributors. Several approaches to resolve these issues are described and their advantages and disadvantages discussed.</p>", "authors": [{"name": "Leif Frenzel", "author_profile_id": "81337489024", "affiliation": "Innoopract, Karlsruhe, Germany", "person_id": "P900681", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291186", "year": "2007", "article_id": "1291186", "conference": "ICFP", "title": "Experience report: building an eclipse-based IDE for Haskell", "url": "http://dl.acm.org/citation.cfm?id=1291186"}