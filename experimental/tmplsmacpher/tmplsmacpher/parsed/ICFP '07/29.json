{"article_publication_date": "10-01-2007", "fulltext": "\n Implicit Phasingfor R6RS Libraries Abdulaziz GhuloumandR.KentDybvig Department of Computer Science, \nIndiana University, Bloomington, IN 47408 {aghuloum,dyb}@cs.indiana.edu Abstract The forthcoming Revised6 \nReport on Scheme differs from previ\u00adous reports in that the language it describes is structured as a \nset of libraries. It also provides a syntax for de.ning new portable li\u00adbraries. The same library mayexport \nboth procedure andhygienic macro de.nitions, which allows procedures and syntax to be freely intermixed, \nhidden, and exported. This paper describes the design and implementation of a portable version of R6RS \nlibraries that expands libraries into a core language compatible with existing R5RS implementations. \nOur implementation is characterized by its use of inference to de\u00adtermine when the bindings of an imported \nlibrary are needed, e.g., run time or compile time, relieving programmers oftheburden of declaring usage \nrequirements explicitly. Categories and Subject Descriptors D.3.3[Programming Lan\u00adguages]: Language Constructs \nand Features modules, packages; D.3.4[Programming Languages]: Processors compilers; prepro\u00adcessors General \nTerms Languages Keywords Scheme, binding phases, hygienic macros, libraries, macro expansion 1. Introduction \nThe language de.ned by the current draft of the Revised6 Report on Scheme (Sperber et al. 2007b) differs \nfrom the Revised5 Re\u00adport(Kelseyetal.1998)languagemost noticeablyinthatitisstruc\u00adtured as a base library \nalong with a set of additional libraries. It also provides programmers witha library form via which new \nli\u00adbrariesmaybe de.ned. Libraries de.nenewsyntactic constructsby associatingexportedkeywords with macro \ntransformers and new variable bindings by associating exported variables with computed values, which \nare oftenbut notalways procedures. Auseful feature ofR6RS libraries is that a library may export bothvariable \nandkeyword bindings. Because the transformations implemented by the keyword bindings are hygienic (Kohlbecker \net al. 1986), references to identi.ers introduced by an exported macro resolve to references in the lexical \nscope of the macro de.\u00adnition,i.e.,to bindingswithintheexportinglibrarythatmayormay not be exported explicitly \nby the library. This allows programmers tokeep hidden anybindings that should notbe visible outsideofa \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copyotherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n07 October 1 3, 2007, Freiburg, Germany. Copyright c &#38;#169; 2007ACM 978-1-59593-815-2/07/0010...$5.00. \nlibrary without inhibiting their use in the output of a macro trans\u00adformer. Requiring that keyword bindings \nbe separated from the variable bindings,as onemightdovia header .lesinC(Kernighan and Ritchie 1988), \nwould destroythis feature. While useful, theexportof bothvariable andkeyword bindings complicates the \nevaluation model, because variable and keyword bindings are needed duringdifferent phasesofevaluation:keyword \nbindings are needed when the importing code is compiled, while variable bindings are needed when the \nimporting code is run. The situationis further complicatedby thefact that macro transformers are themselves \nScheme procedures that may need to reference bindings imported from other libraries at compile time. \nWhen these other bindings are themselveskeywords, the bindings are needed when the compile-time code \nof the compile-time code is compiled, and so on. The .rst public draft of R6RS (Sperber et al. 2006) \nrequired programmers to declare the phases at which libraries are available for use. If a library is \nimported explicitly for run (the default), its keyword bindings are evaluated when the importing code \nis com\u00adpiled, and its variable bindings are evaluated when the importing codeis run. Similarly,ifa libraryisimportedexplicitly \nfor expand, bothkeyword andvariable bindings areevaluated when the import\u00ading code is compiled. Generally, \na library may be imported explic\u00aditly for a speci.c phase by specifying the meta level of its import, \nwhere run corresponds to meta-level 0 and expand corresponds to meta-level 1. For macros that expand \ninto transformers, negative meta levels may also be needed. When the importing code is itself a library, \nthe declarations and their semantics become even more complex. These declarations can become unwieldy. \nThe declarations are also imprecise in nature, as discussed in Section 4.4, which in turn leads to unnecessary \ncompile-time overhead as bindings are evaluated in some cases when theyare not actually needed. A better \nalternative is to shift the burden of determining and declaringthe phasesat which each library skeywordandvariable \nbindings must be evaluated from the user to the implementation. With this alternative, the implementation \ninfers the phases at which thevariable andkeyword bindingsofa library mustbeevaluated based on how the \nidenti.ers are actually used by the importing code. When a reference to a keyword imported from a library \nis encounteredduringthe compilationofthe importingcode,thekey\u00adword bindings of that library are evaluated. \nSimilarly, if the resid\u00adual code after macroexpansion containsa reference to an imported variable, the \nvariable bindings of the imported library will be eval\u00aduated at the run time of the residual code. Both \noccur automatically whether the importing code is run-time code, compile-time code, or code used at some \nhigher meta level. During the formal comment period for the .rst public R6RS draft, we developed such \nan implementation and found it indeed easier to use. It is also often signi.cantly more ef.cient, since \nli\u00adbraries are never loaded and initialized unnecessarily. The addi\u00adtionalef.ciency comes only atcompiletime,butwebelievethat \ncompile time is important. Furthermore, compile time may coin\u00adcide with run time through the use of Scheme \ns eval procedure or various run-time compilation techniques. Having implemented and seen the bene.ts \nof implicit phasing, we lobbied the R6RS editors to switch to implicit phasing. We got our way partly. \nThe subsequent draft (Sperber et al. 2007a) and each that followed allows implementations to support \neither implicit or explicit phasing. This means that programs to be run in an implementation that requires \nphase declarations must include them, but other programs can leave them out. A future version of the \nreport, e.g.,R7RS, may mandate either implicit or explicit phasing once the community settles on a de \nfacto standard, and we believe the relative simplicity and ef.ciencyof implicit phasing will win out \nin the end. This paper describes the implicit-phasing model and why we believe it to be superior to the \nexplicit-phasing model. It also de\u00adscribes our implementation ofR6RSlibraries, which consistsofa library \nmanager and a library expander. The library manager han\u00addles the dependencies among libraries, and the \nlibrary expander handles the expansion of individual libraries. To allow for max\u00adimum portability, the \nlibrary expander transforms a library into codeinasmall core language compatible withR5RS Scheme. Both \nthe library manager and library expander are themselves written as R6RS libraries and thus expand into \nR5RS compatible code. This makesR6RS libraries readily available, now, and runnable on most existingR5RS \nimplementations. Additionally, the library ex\u00adpander produces straightforward code amenable to optimizations \nlike copypropagation and procedure inlining. In particular, no run\u00adtime indirects are required to determine \nthe values of either local or importedvariable bindings.To date, wehave tested the imple\u00admentation under \nChez Scheme, Chicken Scheme, Gambit, Gauche, Ikarus, Larceny, and MzScheme. The remainder of this paper \nis organized as follows. Section2 brie.y describes the syntax and semantics of R6RS libraries and macros. \nSection3describes how the library manager handles de\u00adpendencies among libraries. Section 4 describes \nhow the library expander transforms a single library, including its constituent de.\u00adnitions andexpressions, \ninto the core language. Section4 also de\u00adscribeshow the libraryexpander triggers theevaluationof thekey\u00adword \nand variable bindings of other libraries as they are needed. Section5describesthe three productsofthe \nlibraryexpander:in\u00adformation about bindings, codetoevaluatekeyword bindings,and codetoevaluatevariable \nbindings. Section6describesthe corelan\u00adguageofthecode producedbytheexpander. Section7discussesthe expansion \nalgorithm. Section8discusses relatedwork, while Sec\u00adtion9presents our conclusions and possibilities for \nfuture research. 2. R6RS Libraries and macros A Scheme library, from a programmer s standpoint, is a \nset of private and exported de.nitions that provide functionality often related to a speci.c purpose. \nThe R6RS document de.nes a set of standard libraries that the programmer can extend using the library \nform. Bindings exported from one library can be im\u00adported into another library.Wesay that the imports \nde.ne the lan\u00adguage in which a library is written. A simple library of numeric procedures can be written \nas follows, where ---represents elided code. (library (numerics) (export fact ack fib) (import (r6rs)) \n(define (fact n) (if (zero? n) 1 (* n (fact (-n 1))))) (define (ack n m) ---) (define (fib n) ---)) The \n(numerics) library imports all the identi.ers that the (r6rs) library exports. From this set, (numerics) \nuses the keywords define and if and the variables zero?, *, and -among others. The (numerics) library \ncan be imported into other libraries using the same syntax used for importing the (r6rs) library. Alibrarymayneedto \ninitialize itself beforeanyofthevariables it de.nes are used.Inthe followingexample,alibraryoffacts about \nScheme is de.ned. The library uses the (hash-tables) library for quick access to thefactoids. The hash \ntable is populated when the library is initialized. (library (scheme-factoids) (export fact) (import \n(r6rs) (hash-tables)) (define ht (make-eqv-hash-table)) (define (fact x) (hash-table-ref ht x #f)) (hash-table-put! \nht 120 \"Scheme macros are written in Scheme.\") ---) Iftwolibrariesexportlike-named identi.ersthat representdifferent \nkeyword or variable bindings, theymay not be imported together without quali.cation into a third library \nor top-level program. A set of import quali.ers are provided to allow programmers to work around this \nand, more generally, exercise .ner control over the set of bindings imported from a library and the names \nused locally to refertothose bindings.An import-set consists of zero or more qual\u00adi.ers wrapped aroundalibrary \nreference, whichis itselfa paren\u00adthesized sequence of names. These quali.ers are only, except, rename, \nand prefix: (only import-set identifier ...) selects from the set of bindings selected by import-set \nonly those named by the given identi.ers. (except import-set identifier ...) selects all of the bindings \nselected by import=set except those named by the given identi.ers. (rename import-set (old new ) ...) \nselects all of the bindings selected by import-set, using the local name new for each binding namedbya \ncorresponding old. (prefix import-set prefix ) selects all of the bindings selectedby import-set, pre.xing \nthe name of each binding with the given pre.x. An import-set consisting of an unquali.ed library reference \nselects allofthe bindingsexportedbythe named library.The quali.ers are illustratedby the following Scheme \ntop-level program. (import (only (r6rs) display) (rename (scheme-factoids) (fact scheme-fact)) (prefix \n(except (numerics) ack fib) num:)) (display (scheme-fact (num:fact 5))) In addition to extending the \nlanguage by de.ning new variables, programmers can extend the syntax of the language by de.ning newkeywords. \nJust as define binds variables to values (or loca\u00adtions holding values), define-syntax binds keywords \nto trans\u00adformers.Atransformerisa procedure that accepts as inputa single value a syntax object representing \na macro call and returns a new syntax object. The right-hand-side of a macro binding form canbeanyexpressionthatevaluatestoa \ntransformer.Transformers can use the full Scheme language to implement their transforma\u00adtions, using \nsyntax-case to match and destructure the input and syntax to construct the output (Dybvig 1992; Dybvig \net al. 1992). Atransformer often simply rewrites the input in a straightfor\u00adward manner, extracting portions \nof the input and inserting them into the output, as illustrated by the de.nition of when in terms of \none-armed if below. (define-syntax when (lambda (x) (syntax-case x () [(when e0 e1 e2 ...) (syntax (if \ne0 (begin e1 e2 ...)))]))) The input to a transformer is always the entire syntactic form, includingthe \nidentifyingkeyword, whichis re.ectedbythe pattern given in the when transformer s syntax-case expression.Pattern \nvariables, such as e0, are used to name pieces of the input, with ellipses used to specify zero or more \noccurrences of the preceding pattern. These pattern variables are also used to insert the selected pieces \nof input into the output, as illustrated by the transformer s syntax template, using ellipses for pattern \nvariables that represent zero or more input subforms. The list appearing after the input in a syntax-case \nexpression is a list of literal identi.ers, used to recognize, e.g., the auxiliary keyword else in a \ncond or case expression. It is empty in the transformer expression above because when has no auxiliarykey\u00adwords. \nToavoid redundant speci.cationofthekeyword,an underscore, which matches any input, is often used in place \nof the keyword. Also, the form (syntax x) may be abbreviated to # x just as (quote x) may be abbreviated \nto x. So the de.nition above would typically be written more concisely as follows. (define-syntax when \n(lambda (x) (syntax-case x () [(_ e0 e1 e2 ...) # (if e0 (begin e1 e2 ...))]))) For simple transformers \nlike this, use of thesyntax-rules form results in still shorter code. (define-syntax when (syntax-rules \n() [(_ e0 e1 e2 ...) (if e0 (begin e1 e2 ...))])) The lambda expression and the syntax expression are \nimplicit in syntax-rules, which conveniently reduces the amount of syntac\u00adtic baggage when more generality \nis not required. An important characteristic of each de.nition of when is that the identi.er references \ninserted into the output of its transformer are scoped wherethe transformer code appears, not where the \nsyntactic form to be transformed appears. So the keywords if and begin inserted into the output of the \nwhen transformer resolve to the if and begin bindings in effect where when is de.ned, regardless of anyde.nition \nof if and begin inthe contextofa when expression. Arelated characteristic is that bindings introduced \nby a trans\u00adformer do not capture references in the input to the transformer. For example, given: (define-syntax \ncompose-self (syntax-rules () [(_ p x) (let ([t p]) (t (t x)))])) the expression (let ([t 3]) (compose-self \n(lambda (x) (+ x 1)) t)) expands into the equivalent of (let ([t1 3]) (let ([t2 (lambda (x) (+ x 1))]) \n(t2 (t2 t1)))) so that the binding of t introduced by compose-self does not capture the reference to \nt in its input. These characteristics are required by the hygienic nature of the macroexpander(Kohlbeckeretal.1986)and \nessentially meanthat syntax de.nitions, like procedure de.nitions, are lexically scoped. While lexical \nscoping is the default, transformers that violate lex\u00adical scoping, i.e., transformers that refer to \nbindings in the context of their input or that introduce bindings that capture references in theirinput, \ncan also be written,but we have no space or need to describe such transformers here. The following example \nillustrates a library that de.nes and exports the keyword cteval, whose transformer uses eval at expansion \ntime to perform compile-time evaluation and also list tobuildup the result. (library (compile-time-eval) \n(export cteval) (import (r6rs) (r6rs eval)) (define-syntax cteval (lambda (x) (syntax-case x () [(_ expression \nlibrary) (list # quote (eval (syntax->datum # expression) (environment (syntax->datum # library))))])))) \nThe de.ned syntax cteval (cteval (+ 1 2) (r6rs)) expands to (quote 3) by evaluating, at compile time, \nthe expression (+ 1 2) in the language de.ned by the (r6rs) library, and quot\u00ading the resulting value. \nWhile this degree of generality is seldom needed, the trans\u00adformer for cteval illustrates how the full \ngenerality of Scheme can be employed by a macro. Any identi.er imported from the (r6rs) library can be \nused both for run and expand, so even in the explicit declaration model, there is no need to declare \nthe phases explicitly for the example above. Our implementation extends this to arbitrary libraries and \nphases. In other words, the import form of a library de.nes the language in which the library body is \nwritten, regardless of phases. 3. Library management The libraries described in the preceding section \neach depend on other libraries,if only thebuilt-in (r6rs) library. In general, each library is expanded \nbefore it is imported into dependent libraries. The import forms of a set of libraries implicitly de.ne \na depen-dencygraph.Thegraphis necessarilyacyclic becausea libraryim\u00adport relationships cannot be recursive. \nFor example, suppose we have a top-level Scheme program that imports the student-db as follows: (import \n(r6rs) (student) (student-db) ---) (define print-student-record ---) (new-repl (lambda () (display \"Enter \na student name: \")) (lambda (x) (print-student-record (find-student x)))) The library manager determines \nfrom the import form of the top\u00adlevel program that the program depends on (r6rs), (student), and (student-db). \nEach in turn depends on its own set of li\u00adbraries. After following the (.nite) chain of imports, the \nlibrary manager determinesapartial orderingof dependencies thatis illus\u00ad Basedonthispartialorder,expansionofthis \nprogrammustproceed in the steps identi.ed in the graph, as elaborated below. Step0de.nes the (r6rs) \nlibrary. Although the library is likely to be constructed from several other libraries, we treat this \nlibrary as primitive, hence Step 0.  Step 1 expands the (structures) library. This de.nes the define-structure \nmacro that canbe usedin anylibrary that imports (structures) at a later step.  Step 2 expands the (student) \nlibrary. In this step, the student structure is de.ned by constructing a unique iden\u00adti.er for the structure \ntype along with a set of de.nitions and macros that provide the constructor, predicate, and accessor \noperations. Such procedures and macros (with the embedded structure identi.er) are available for later \nimports. The student structure identi.er does not change across invocations.  Step3expands the (student-db) \nlibrary. The expanded body of the library contains instances of student structures (generated at compile \ntime) andaprocedure find-student,for accessing the database.  Step 4 expands the top-level program, \nusing the outputs of previous stages.  3.1 Library visiting and invocation In cooperation with the library \nexpander, the library manager must arrange for the keyword and variable de.nitions of a library to beevaluatedatthe \nappropriate times.Theevaluationofkeyword de.nitions is referred to as visiting alibrary,whiletheevaluationof \nvariable de.nitionsand library initializationexpressionsis referred to as invoking a library.Alibrary \nmustbe visited whenitskeyword bindings are required, directly or indirectly, for the expansion of another \nlibrary or top-level program, and it must be invoked when its variable bindings are required for expansion \nof another library or top-level program or for a run of a top-level program. The process of visiting \nand invoking a library in our implementation is described in detail in Section 5. 3.2 Inconsistency \nof multiple expansions Although not speci.cally requiredby the draftR6RS, it turns out that every library \nmust be expanded exactly once to avoid incon\u00adsistencies that may appear in the set of identi.ers exported \nby a library. Using separately expanded versions of one library may yield to inconsistent and unlinkable \nprograms.A simpleexam\u00adple showing the possibility of producing such programs is shown below. (library \n(E0) (export x) (import (r6rs)) (define-syntax def (lambda (x) (define inline-constants? (cdr (assq inline-constants? \n(with-input-from-file \"config.ss\" read)))) (syntax-case x () [(_ name val) (if inline-constants? # (define-syntax \nname (identifier-syntax val)) # (define name val))]))) (def x 17)) (library (E1) (export f) (import (r6rs) \n(E0)) (define f (lambda () x))) If, during the expansion of (E1), (E0) is expanded and the con.g\u00aduration \n.le says not to inline constants, then the reference to x in (E1) will residualize to a reference to \nthe variable x exported by (E0). If linked with a version of (E0) that is expanded again, this timewith \ninliningof constants enabled,thevariable x will notexist at run time.  3.3 Exploiting single expansion \nThis single-expansion guarantee can be exploited by the program\u00admer when a compile-time constant is needed. \nThis is useful, for example, for de.ning structures1 that are guaranteed to have the same type across \nlibrary invocations, as illustrated in the following example. (library (structures) (export define-structure) \n(import (r6rs) (guid)) (define-syntax define-structure (lambda (x) (syntax-case x () [(_ name (fields \n...)) (with-syntax ([id (generate-id)] [maker ---] [pred? ---] ---) # (begin (define (maker fields ...) \n(vector id fields ...)) (define (pred? x) (and (vector? x) (= (vector-length x) (+ 1 (length (fields \n...)))) (eq? (vector-ref x 0) id))) ---))])))) Without the single-expansion guarantee, the programmer \nwould be forced to generate the uniqueidenti.er manually and to hard-code it at every structure de.nition. \nThe guaranteecanbeexploitedfurtherbytheabilityofthepro\u00adgrammer to generate, at compile time, structures \nwith the correct run timevalues.Forexample, suppose the library (student) de\u00ad.nes a student structure \nas follows. (library (student) (export make-student student? student-name ---) (import (structures)) \n(define-structure student (name id major)) ---) 1Astructure is represented as a vector with a unique \ntag. A user of the library can de.ne at compile time a database of studentswhichresultsin translatingtheentire \ndatabaseintoasingle quoted constant. Moreover, the call to student-name won t fail because of data mismatch \nin the structure identi.er of compile-time generated structures. (library (student-db) (export find-student) \n(import (r6rs) (student)) (define-syntax define-students (lambda (x) (syntax-case x () [(_ db-name [name \nid major] ...) (let ([students (apply map make-student (syntax->datum # ((name ...) (id ...) (major ...))))]) \n# (define db-name #,students))]))) (define-students student-db [\"jane\" \"111-11-1111\" journalism] [\"john\" \n\"222-22-2222\" psychology] ---) (define (find-student x) (memp (lambda (s) (equal? (student-name s) x)) \nstudent-db))) The single-expansion guarantee also allowsaprogrammerto record information that was current \nas of the time of expansion. For example, the following library, (compile-time), exports a sin\u00adgle macro, \nctime, that expands to a string representing the time the macro is called, supposing that the implementation \nprovides a (date/time) library that exports a time->string procedure. (library (compile-time) (export \nctime) (import (r6rs) (date/time)) (define-syntax ctime (lambda (_) (time->string (now))))) Using (compile-time), \na Scheme top-level program can print a greeting message showing the time the system was compiled, sup\u00adposing \nthat the implementation provides a (formatted-output) library that exports a printf procedure. (import \n(compile-time) (formatted-output)) (printf \"This program was compiled on ~a\\n\" (ctime)) The entire program \nexpands to the following code: (printf \"This is program was compiled on ~a\\n\" \"2007/04/02 23:17:04\") \nWe can de.ne a library (F) that exports a single procedure F-compile-time. The procedure returns a string \nrepresenting the time on which the library (F) was compiled. (library (F) (export F-compile-time) (import \n(r6rs) (compile-time)) (define (F-compile-time) (ctime))) Intuitively, expanding (F) results in code \nthat binds the variable F-compile-time with a procedure that returns a constant string: (define F-compile-time \n(lambda () \"2007/04/02 23:29:54\")) Consequently, anycall to the procedure F-compile-time would return \nthe same string. This is true regardless of the time or place in which the procedure F-compile-time is \ncalled.Forexample, the program (import (r6rs) (F)) (let-syntax ([t (lambda (_) (F-compile-time))]) (string=? \n(F-compile-time) (t))) calls the F-compile-time once when it is expanded, and once again when resulting \ncode is evaluated. The program expands to the following run time code which returns #t when evaluated. \n(string=? (F-compile-time) \"2007/04/02 23:29:54\") 4. Phased expansion model In Section 3, we discussed \nthe order in which libraries must be expanded, based on the dependencygraph implicit in the import forms. \nIn this section, we discuss how the library body itself is expanded. To expand a library L, we assume \nthat all imported librarieshave already beenexpandedto core forms.We start with a discussion of local \nidenti.ers, then proceed to a discussion of imported identi.ers. 4.1 Phase of local identi.ers We say \nthat thephase of an identi.er binding is the time at which the value of the binding is computed. The \nsimplest phase is phase 0, which is the run phase in a Scheme top-level program. The right-hand-side \nexpression of a top-level define-syntax form is a phase1 expression.In general,ifa macro de.nition appearsin \nphase n code, then its right-hand-side expression is in phase n + 1. Although there is no limit on the \nnumber of phases that an expression can have, the residual code of a phase n expression contains only \nphase n bindings. Anexpressioninphase0can accessanyphase0identi.erthatis inthelexical scopeoftheexpression.Inthe \nfollowingexample,the variables x, y, and f are all phase0bindings because theirvalues are determined \nat run time. (let ([x 5]) (define f (lambda (y) (+ y x))) (display (* x (f 3)))) Because an expression \nmust be expanded before it is evaluated, transformers, which are evaluated at expression expansion time, \ncannot accessthevaluesofvariablesthatarecomputedatruntime. For example, the following code cannot be \ncompiled because a referencetothe runtimevariable x is referencedatexpansion time, when the lambda expression \nis evaluated. (let ([x 5]) (define-syntax f (lambda (y) (+ x y))) (display (* x (f 3)))) We call the \nbinding of y a phase 1 binding since it appears in the right-hand-expression of a syntax binding form. \nOur syntax system rejects such an expression because it does not make sense in theR6RS language, which \nrequires that expressions be fully expanded beforetheyareevaluated.The programis rejected during the \nexpansion of the transformer expression at the point where the reference to x is found in (+x y). Asimilar \nrestrictionis enforced whena phase1bindingis ref\u00aderencedin phase0code.In the followingexample, (f 3) \nexpands to a reference to the compile-time variable. (let ([x 5]) (define-syntax f (lambda (y) # y)) \n(display (* x (f 3)))) This program is rejected because the phase 0 expression (f 3) expands to a reference \nto a phase 1 variable y. This program is rejected when the output of the call to (f 3) is re-expanded \nand the reference to y is discovered. In general, our syntax system rejects any attempt to residual\u00adize \na reference to a phase n local variable in a phase m context when n .m. It also rejects attempts to residualize \na reference to = a variable outside of its lexical boundaries. Only by using poorly styled code that \nuses expansion-time side effects can such anoma\u00adlous cases be triggered. 4.2 Phases of imported identi.ers \nIncontrast with local identi.ers, imported identi.ers represent code that has already been expanded, \nso there is no need to restrict their usage to speci.c phases. TheR6RS allows programmers to declare \nthe phases in which an imported library can be used. With the explicit-phase speci.cation, one would \nbe required to specify the exact run, expand, (meta 2), (meta 3), etc., for every phase in which a library \nis used. This is done via the for syntax, which is a wrapper for the import sets described in Section \n2: (for import-set phase ...) restricts the identi.ers speci.ed by import-set to use only at the speci.ed \nphases. For example, one would have to annotate the top-level program from Section 3.3 as follows. (import \n(r6rs) (for (F) run expand)) (let-syntax ([t (lambda (_) (F-compile-time))]) (string=? (F-compile-time) \n(t))) So, even though the two references to the F-compile-time vari\u00adable refer to the same binding that \nis exported from (F), an im\u00adplementation ofR6RS may reject the original program because the programmer \ndid not specify at which phases the references to the imported libraries are valid. The two references \nto F-compile-time in the code above can\u00adnot reference two distinct bindings of the same name because \nthe import form requires that all imported identi.ers be unique. There is no ambiguity in deciding where \nthe F-compile-time identi\u00ad.er came from, just as it is clear where the lambda identi.er came from. The \ndraftR6RS speci.es that the (r6rs) library exports its identi.ers to both run and expand phases in order \nto makeit con\u00advenient for users who do not care about phases. We extend the convenience to all libraries \nand all phases. In the .rst revision of the R6RS document, R5.91RS, explicit phase speci.cations were \nrequired and implementations were re\u00adquired to reject any library if its body was inconsistent with the \ndeclared phases of the imports. Soon after, two reference imple\u00admentationsofthe proposedR6RS library \nsemantics were provided, ours and one by Andr\u00b4 e van Tonder (Dybvig et al. 2006). Both implementors realized \nthat one of the report s speci.ed macros, identifier-syntax,was not implementablein theR6RS library system. \nEach proposed a different .x. The suggestion of the im\u00adplicit phasing camp lead to allowing implementations \nto infer the phases in which libraries are used while the library is being ex\u00adpanded. The suggestion \nof the explicit phasing camp lead to the inclusion of negative meta levels. To see whythis is needed, \nconsider a library that exports macro helpers (i.e., procedures and macros that are normally used at \nmacro-expansion time).Forexample, the library (Q) belowexports the procedure quote-5, which returnsa \nsyntax object representing the quoted number 5. (library (Q) (export quote-5) (import (r6rs)) (define \n(quote-5) # (quote 5))) The library (Q) can be used at compile time in another library as follows: (library \n(R) (export number-5) (import (r6rs) (Q)) (define number-5 (let-syntax ([m (lambda (x) (quote-5))]) (m)))) \nIn the explicit phase speci.cation model, the programmer must specify that the library (Q) should be \nimported in (R) for expand, or (meta 1), because it is used at library expansion time. Now because (Q) \nis imported for phase 1, the quote it produces is a phase 1 quote which cannot be inserted into the output \nof the macro m. Therefore, the (r6rs) library mustbeimported into (Q) for both run and (meta -1). Therefore, \nthe import of (Q) for (meta 1) combined with the import of (r6rs) for (meta -1) result ina (meta 0) quote \nthat is inserted in the run code of (R). Thus, we end up with the following, assuming the programmer \ndoes not mistakenly add unnecessary phase speci.ers while trying to get the program to compile. (library \n(Q) (export quote-5) (import (for (r6rs) run (meta -1))) (define (quote-5) # (quote 5))) (library (R) \n(export number-5) (import (r6rs) (for (Q) expand)) (define number-5 (let-syntax ([m (lambda (x) (quote-5))]) \n(m)))) In both models, the import form de.nes the meaning of the im\u00adported identi.ers.Forexample, one \ncannot import two identi.ers named quote for two phases and have them mean two different things. If quote \nis imported from (r6rs),thenitisthe sameR6RS quote at all phases. Explicit phasing merely restricts the \nphases in which the identi.ers can be referenced. In the implicit phase speci.cation model, reference \nto the vari\u00adable quote-5 in compile-time code makes (Q) implicitly imported for that phase. Since the \nR6RS-quote that quote-5 produces is placed in the run-time code of the output of the m macro, the quote \nis placedin phase0automatically. Aquestion arises: Does the set of libraries that can be written using \nthe implicit phase model differ from the set that can be explicitly speci.ed? If the two sets are the \nsame, then maybe we can write a program that statically derives the exact set of phases that may be required. \nInfact, however, the set of programs whose phases can be inferred is larger than the set that can be \nexplicitly speci.ed.Thisisduetothefactthatthesetofphasesthatthe library can specify is .xed. The following \ncontrived macro illustrates this problembyexpandingto referencestoitselfinasmanyphasesdeep as there are \nsub-expressions in its use site. (define-syntax let-syntax*** (syntax-rules () [(_ () body) body] [(_ \n((i* e*) ... (i e)) body) (let-syntax ([i (let-syntax*** ((i* e*) ...) e)]) body)])) While we do not \nknow if this problem will ever arise in practice, it does point out a limitation of the explicit phasing \nmodel. 4.3 Shared vs. separate bindings across phases In the preceding section, we discussed two models \nfor determining the phases in which an imported binding can be used. The explicit phasing model requires \nthe programmer to restrict the availability of an identi.er to a .xed set of phases, while the implicit \nphasing model makes all identi.ers available at all phases. Regardless of how the phases of the imported \nbindings are determined, the implementation must decide when libraries must be invoked.Ata minimum,weknowthatif \nlibrary X exportsvariable x that s referenced in the run time code of library Y , then X must be invoked \nbefore Y isinvoked.Failuretodosowould resultinan invalid reference. Similarly, if v is referenced in \ncompile-time code of library Z, then X must also be invoked at Z s compile time, and before anytransformer \ncode that might reference x is evaluated. Our implementation invokes a library, minimally, only when \nit is needed, using a simple demand-driven approach. When the need arises to invoke the library, it is \ninvoked, and not before. Once invoked, it is never invoked again in the same Scheme process. The library \ncan actually be in one of three states: uninvoked, invoking, and invoked. It is set in the invoking state \njust before it is initialized so that the system can detect attempts at circular invocations, which can \noccur only via improper use of eval. Asimilar mechanism is used to visit libraries on demand. While the \nsemantics described above is compatible with the R6RS requirements, the report also allows other semantics \nin which separate instancesofthesamelibraryexistforeveryphaseinwhich the library is imported and even \nfor the expansion or evaluation of different programs by the same Scheme process. Implementations that \ncreate separate instances in this manner must generally visit and/or invoke each library multiple times. \nOne reason why we chose to have no more than one instance is that repeatedlyevaluating transformer and/orvariable \nbindings and initializationcodemaybeexpensive,bothintimeand space.While this affects primarily compile \ntime, compile-time costs should not be ignored, and compilation can happen at run time when Scheme s \neval procedure is used. Another reason why we chose to have no more than one in\u00adstance of a library is \nthat system programming requires the ability to manage resources, some of which cannot be replicated. \nAn ex\u00adample of such a resource is the Scheme symbol table. If the sym\u00adbol table is de.ned in a Scheme \nlibrary, and a separate instance of that library is created for every phase, then calling the proce\u00addure \nstring->symbol on the same string at two different phases would incorrectly yield two non-eq? symbols2. \nManagement of non-generative records, pseudo random number generators, excep\u00adtion handlers, external \ndevices, etc., would be problematic if sepa\u00adrate instances of these resources exist independently. 4.4 \nInaccuracies of phase requirements Another drawback of explicit speci.cation is that programmers are \nsometimes forced to overestimate import requirements in order to achieve the minimal requirements theyneed. \nWe illustrate whythe explicit phase speci.cation overestimates the requirements by .rst questioning what \none might mean when one declares (import (for (Q) expand)) in library (R). On the one hand, it is possible \nthat (R) references one of (Q) s exports inalocal macro as shown in page 6. After (R) isexpanded, its \nresidual code contains (define number-5 5) and, therefore, (Q) s exports would not be used after (R) \ns expansion. On the other hand, it may be that (R) imported (Q) for expand because (R) exportsa macrothatexpandstoa \nreferenceto (Q) sexports in 2There would actually be multiple procedures named string->symbol, one per \nphase, each with its own copyof the symbol table. compile-time code. In this case, expanding (R) does \nnot reference anyof (Q) svariables,butexpanding the importerof (R) does. An explicitly phased implementation \nwould invoke (Q) once when (R) is expanded, and invoke it again when (R) is imported for expanding a \nthird library. This is guaranteed to do more work than necessary if the bindings are not required in \nboth situations, again increasing compile-time costs.  4.5 Bene.ts of explicit phasing? Given that the \nexplicit phasing model requires more work on the part of the programmer, does not allow the programmer \nto specify phases precisely, generally incurs more compile-time overhead, and limits the set of programs \nthat can be written, it isfair to ask whetherit has compensating bene.ts.We believeit does not. The only \nbene.t of explicit phasing to the programmer is that it allows the programmer to express his or her understanding \nof a suf.cient (but, unfortunately, often not necessary) set of phases at which the bindings of a library \nare required and to have this un\u00adderstanding testedby theexpander. This mightbe usefulif the user could \nuse this information to determine when the side effects of ini\u00adtializinga library occur,but the implementation \nhas broad latitude even under the explicit phasing model to initialize a library at the time or times \nof its choosing. Thus, side effects must generally be of the kind that affect only the library s own \nbindings, not the kind that are visible externally. Given this, explicit phasing seems, for the user \nat least, not to be a worthwhile exercise, and it is likely to be more frustrating than illuminating. \nFurthermore, we have found that the explicit phasing model is at least as dif.cult to implement.With \nboth models, the implemen\u00adtation must determine the phases at which an attempt to use each identi.eris \nmade.In theexplicit phasing model, the implementa\u00adtion must also record and check phase restrictions \nand report them to the programmer. The only compensation is that the implemen\u00adtation can eagerly initialize \na library based on the declared phases, obviating the need to do so on demand. 5. Components of an expanded \nlibrary When ourexpander processesa library,it reconstructs the library into a core-library form composed \nof three components orga\u00adnized by usage. The three components are the library meta data (describing the \nlibrary s products and dependencies), the library visit-time code (used to evaluate transformer de.nitions), \nand the library invoke-time code (used to evaluate variable de.nitions and initialization expressions). \nEach component is described below. 5.1 Library meta data When a library is expanded, the following meta \ndata is recorded: 1. The library name and version. This information is used by the expander when it processes \nimports in order to determine whether the library satis.es the version requirements that the importing \nlibrary speci.es. 2.Alibrary identi.er.Every timea libraryisexpanded,a globally unique identi.er is given \nto the expanded instance in order to distinguish it from other expanded instances of the same library. \nThis is used to detect violations of the single-expansion invariant that was discussed in Section 3, \nwhich might occur through improperly managed separate compilation. 3. Identi.ers of imported libraries. \nThis list of libraries is usedto resolve re-exported identi.ers. 4. Library substitution. This is an \nassociation list that maps the namesofthesetofexported identi.erstoasetofunique labels. When the library \nis used to expand another library, some of the names may be removed, renamed, or pre.xed with an identi.er \ndepending on the import modi.er(only, except, rename, and prefix). 5. Keyword locations. This is a mapping \nfrom labels to locations where every location denotes a global macro binding that is de.ned in the library. \nRe-exported keywords are looked up through the chain of imports (item 3). The values of the trans\u00adformers \nare obtained by evaluating the visit-time code (5.2). 6. Variable locations. This is a mapping from \nlabels to locations where every location denotes a global variable binding that is de.ned in the library. \nRe-exported variables are looked up through the chain of imports (item 3). The locations are initial\u00adized \nby evaluating the invoke-time code (5.3). 7. Visit requirements: This is a list of library identi.ers \nthat must be invoked before the visit-time code is evaluated. 8. Invokerequirements: Thisisalistof library \nidenti.ers that must be invoked before the invoke-time code is evaluated.  5.2 Visit-time code Whenalibraryisbeingexpandedanda \nreferencetoan imported macro bindingis found,the visit-time codeof theexporting library must be evaluated \nto obtain a list of transformers (one for each exported macro de.nition). The list of labels and the \nlist of trans\u00adformers are joined to obtain the mapping. The list is cached and the visit codeisneverevaluatedagain.The \nvisit-time requirementsof the library must be invoked before evaluating the visit-time code in order \nto initialize any variables that may be referenced in the code.  5.3 Invoke-time code Theinvoke-timecodeisevaluatedinorderto \ninitializethe locations that a library de.nes. This code may be evaluated at compile time, before any \ncode that references one of the library variables is evaluated. The code may also be invoked at run time \nif anyof the library variables may be referenced at run time. The invoke-time code is evaluated at most \nonce. Both the visit-time code and invoke-time code is pre-expanded and is, therefore, composed of core \nScheme expressions. The code may be run interpreted, may be compiled on the .y, or batch com\u00adpiled to \nnative form. Because the code does not contain any syn\u00adtactic extensions, it is easy to cross-compile \nthe code to different architectures. The same expanded code serves as a basis for many source-compatible \nbinary instances of the library. This is also the main reason why we separate the library meta data, \nits visit code, and its invoke code. The visit-time code is needed only for compil\u00ading other libraries \nand need not be shipped in the .nal application if the application performs no run-time compilation. \n6. Target language The target language of a library expander is not speci.ed by the report. Our system \ntakes advantage of this lack of speci.cation to target core language that can be evaluated by any complete \nimplementation ofR5RS. This section describes the core language that theexpander targets,howR6RS codeisevaluatedin \nanR5RS system, and how top-level locations are constructed. 6.1 Coreforms Theexpander transforms code \nfromR6RS library syntax to a core Scheme form.Acore Schemeexpression canbe de.ned according to the following \ngrammar. (Expr). (quote (datum)) . (Primitive) (e.g., cons, +, vector?) . (Variable) . (if (Expr)(Expr)(Expr)) \n . (set! (Variable)(Expr)) . (begin (Expr)(Expr) ...) . (letrec ([(Variable)(Expr)] ...) (Expr))  \n. ((Expr)(Expr) ...) (Formals). () |(Variable)| ((Variable) . (Formals)) This choice of core forms makes \nthe core language language rea\u00adsonably simple while avoiding loss of information during expan\u00adsion.For \nexample, let is not included among the core forms be\u00adcause expanding let to an application of a direct \nprocedure does not lose anyinformation, and we expect that optimizing compilers know how to treat them \nef.ciently. On the other hand, letrec is included because expanding letrec to the equivalent set of bind\u00adings \nand assignments loses information, andwould therefore inhibit certain optimizations(Waddell et al. 2005). \nTwo additional expression forms are also included in the core by default: (Expr). (case-lambda [(Formals)(Expr)] \n...) . (letrec* ([(Variable)(Expr)] ...) (Expr)) The .rstisageneralizationof lambda to multiple formal \nparameter lists, each with a corresponding body, and is used to support the source-language case-lambda \nform, which is includedin one of the standardR6RS libraries.For an implementation that does not support \ncase-lambda natively, the expander can be con.gured to produce lambda expressions instead, using a dynamic \ndispatch on the length number of arguments when other than one clause is appears.Weexpect thatimplementations \nthat will targetR6RS will eventually provide native support for the case-lambda form. The other, letrec*, \nis a variant of letrec that evaluates its bindings from left to right. This is useful for handling source\u00adlanguage \nletrec* expressions, library bodies, andlambda bodies. For an implementation that does not supportletrec* \nnatively, the expander can be con.gured to produce semantically equivalent set of bindings and assignments. \nIf desired, in fact, implementors can con.gure the expander to produce code in an even smaller core language, \nsuch as the following. (Expr). (quote (datum)) . (Primitive) . (Variable) . (if (Expr)(Expr)(Expr)) \n . (set! (Variable)(Expr)) . (lambda (Formals)(Expr)) . ((Expr)(Expr) ...)  Implementors can also \ncustomize the expander to recognize core forms that are not included in the set above. This feature can \nbe used to de.ne implementation-dependent core-language syn\u00adtax, e.g., for creating foreign functions. \nSuch core forms would presumably appear in the expanded code only when non-standard libraries provided \nby the implementation are imported by a pro\u00adgram s source code. As evident in the core-language grammar, \nlambda bodies con\u00adsist of a single expression, with no de.nitions, as do the bodies of letrec and letrec*. \nIn addition, the names used for the local and global bindings produced by the expander are disjoint each \nfrom each other and also from the set of core-language keywords and primitive names. An implementor may \n(but need not) take advan\u00adtage of these restrictions to simplify the parsing of core-language expressions \nwhen compiling or evaluating the output of the ex\u00adpander. 6.2 Core primitives Our system is an expander \nthat transforms R6RS libraries to the host implementation s core forms. The system does not itself de\u00ad.ne \nanyR6RS primitives that are not related to the syntax system. Syntax-related procedures that are provided \nby the system include syntax->datum,datum->syntax, free-identifier=?, etc., in addition to theR6RS eval \nand environment procedures. Imple\u00admentations that targetR6RS would have to provide de.nitions of the \notherR6RS primitives. The code of the expander itself uses a subset of the primitives that is either \nshared betweenR5RS andR6RS or is portably avail\u00adable in all implementations. 6.3 Evaluation of core \nexpressions The existence of expressions that must be evaluated at compile time implies that theexpander \nmust perform someevaluation while a library is being expanded. We identify three places where the expander \nrequires evaluation: 1. When the expander encounters a syntax binding form (such as define-syntax, let-syntax, \netc.), it expands and evaluates the transformer expressions in order to obtain the transformer procedure. \n 2. When the expander encounters a reference to a macro that is de.ned in another library, the visit-code \nof the exporting library must be evaluated in order to obtain the values of the transformers. 3. When \nthe expander encounters a reference to a variable that is exported from another library in compile-time \ncode (i.e., phase n for n> 0), the invoke-code of the exporting library must be evaluated in order to \ninitialize the exported locations.  The .nal output of the expander may also be evaluated, of course, \nbut that evaluation occurs after expansion has been completed and is outside of the control of the expander. \n 6.4 Top level locations Libraryvariables aregiven global locationsin theR5RS top-level namespace. Every \ntime a library is expanded, each of its variables isgivena unique top-levellocation. Direct accesstothe \nunderlying locations is restricted at the source level; the only way to access a top-level location is \nthrough a library that explicitly de.nes or imports it. Therefore, all library locations are shared in \none .at namespace,and accessto these locationsis managedbythe library expander. Whenevaluating previouslyexpanded \nor compiled libraries, the expander loads the appropriate .les using theR5RS load proce\u00addure. Every such \n.le is structured as a series of top-level variable de.nitions followed by an expression that initializes \nall such vari\u00adables (using set!). We generate the top-level define forms for all globally de.nedvariables \nbecause someR5RS implementations (legitimately) reject assignments to unde.ned variables. While most \nsystems eval procedures accept de.nitions,R5RS does not require eval to handle de.nitions, so we use \nload rather than eval to avoid portability problems. On the other hand, the evaluation of a transformer \nexpression never creates new top-level locations, soR5RS s eval usually suf\u00ad.ces forevaluating transformerexpressions.Transformers \nmay ref\u00aderence top-level bindings, however, and so need access to the en\u00advironmentinto which library \nbindings have been de.ned. In most implementations, this access is provided by calling eval with just \noneargument,theexpanded transformerexpression,orwithtwoar\u00adguments, theexpanded transformerexpression \nand the environment returnedby (interaction-environment). If neither mechanism is supported by an implementation, \nsome other, implementation\u00addependent mechanism, must be used to evaluate transformer ex\u00adpressions. In \norder to avoid name clashes between different library identi\u00ad.ers, globally unique names must be generated \nfor every global identi.er. Implementations that provide a read/write invariant gensym can utilize that \nextension for generating the names. The portable implementation generates sequentially different names, \nwith a sequence id that is incremented across invocations of the syntax system. The name generation routine \ncan be made more ro\u00adbustby customizingittothe speci.c implementation.Forexample, an implementation can \nuse a procedure speci.c to the operating\u00adsystem to generate globally unique identi.ers. 7. Expansion \nalgorithm The expansion algorithm used by our expander to process the de.\u00adnitions and expressions contained \nwithin a library is essentially the same as Waddell s syntax-case expansion algorithm (Waddell and Dybvig \n1999;Waddell 1999). It differs only in the handling of references to identi.ers that are determined not \nto be lexically bound.Waddell s algorithm looks for such bindingsin the imports of the enclosing top-level \nmodule, if any, and if not found there, theninthe top-level (interaction)environment.Ourexpander looks \nfor such bindings only in the imports of the current library or top\u00adlevel program, since the imports \nspecify the entire environment of the code within the library or top-level program. Also, when an imported \nbinding is found, the expander may trigger, through the library manager, the visiting or invocation of \nthe exporting library. 8. Related work 8.1 Chez Scheme modules Chez Scheme s support for libraries can \nbe roughly divided among the module, import, and eval-when forms, and various .le\u00adlevel procedures (e.g., \ncompile-file, include, load, visit, revisit).Modules controlthe visibilityof bindings,butthe useris required \nto manually load, visit, or invoke (revisit) code in order to make the modulesavailable when needed. \nThisisfacilitatedby the eval-when form, which allows the programmer to control manu\u00adally when .les are \nloaded. In most other respects, Chez Scheme s top-level module forms are similar to theR6RS library form. \nChez Scheme s module system is freely available in a portable implementation. The system has been successful \nand usedbymany implementations including Chicken Scheme, Gambit, Ikarus, SISC in addition to Chez Scheme \nand Petite Chez Scheme. Weused the portablesyntax-case implementation as the basis of our implementation, \nso the architecture of our system is similar. The major difference between the two systems is in the \nlevel of details that the user must specify. In our system, a library import form speci.es the environment \nin which the library is de.ned and expanding the body of the library determines when various pieces must \nbe made available. In Chez Scheme, such details must be handled explicitly by the user. The syntax of \nlibraries in our system differs from Chez Scheme s modules in the sense that libraries in our system \nare stand-alone entities while Chez Scheme s modules are syntactic forms that can be produced through \nmacro expansion. And while modules in Chez Scheme are de.ned in an external environment that s determined \nby where and when the module is compiled and loaded, our library system has no external environment. \n 8.2 MzScheme modules The R6RS library system is similar to the MzScheme module system (Flatt 2002). \nLike an MzScheme module, a library must specifyits importsexplicitly,sothe languagein whichthe library \ns code is written does not rely on the ambient environment of the expander or compiler. In contrast to \nour implementation, the expander in MzScheme instantiates a separate instance of every library for every \nphase in which it is imported; the expander enforces that uses of an im\u00adported library match the declared \nphases in which said library is im\u00adported. Additionally, MzScheme s module system guarantees the invocation \nof imported libraries at the declared phases regardless of whether the bindings of the module are used \nor not. The motivation for this decision was mainly the desire of the MzScheme implementors to implement \ncompile-time registry libraries into which different modules would intern compile-time information during \nmacroexpansion time. The problem onefaces in this setting is that information interned while one library \nis compiled will not persist when the library is loaded at subsequent stages. To guarantee proper registration, \ncompile-time code that side-effects the compile-time environment has to be invoked again when the library \nis visited.  8.3 Chicken eggs Chicken Scheme s eggs (Winkelmann 2007) provide a distribution mechanism \nfor Scheme code that differs from the other systemsde\u00adscribed herein that Chicken does not allow the \nmixingofhygienic macro de.nitions and procedure de.nitions in the same library. In\u00adstead, macros are \nde.ned separately and given global scope. Also, the programmer must write an egg-description .le which \nlists the exact dependencies, exports, and macros of the library while theR6RS library system is designed \nto allow that information to be extracted from the library itself. 9. Conclusion The import form of anR6RS \nlibrary speci.es the language in which the code contained within the library is written. With the implicit-phasing \nmodel described in this paper, the import form need not also specify when the bindings imported into \nthe library are available. Instead, the implementation determines from the ac\u00adtual use of each imported \nlibrary s identi.ers at which phases the library skeyword andvariable bindings are needed. Thus, the \npro\u00adgrammer is responsible for saying only what is needed, while the implementation is responsible for \ndetermining when. This paper also describes a portable implementation of R6RS librariesthat supportsthe \nimplicit phasing model.ItexpandsR6RS top-level programs and libraries into code in a core language that \nis a small subset of the R5RS language supported by most ex\u00adisting Scheme systems, which should facilitate \nrapid adoption of the library system and the remainder of theR6RS language. The system is compatible \nwith a variety of evaluation models, includ\u00ading interpreters, incremental compilers, and batch compilers. \nIt has already been ported to several popular Scheme systems: Chez Scheme, Chicken Scheme, Gambit, Gauche, \nIkarus, Larceny, and MzScheme. We have chosen in the implementation to evaluate the trans\u00adformer bindings \nand variable bindings of a library at most once per compilation session.We have made this choice to allow \nshar\u00ading of system-managed resources like symbol tables and random\u00adnumber generators across phase boundaries \nand also to reduce the cost of compiling programs that use manylibraries, some of which may require nontrivial \ninitialization,at multiple phases.Itwouldbe straightforward, however, to modify our implementation to \nmain\u00adtain separate environments for each phase and to evaluate trans\u00adformer and variable bindings once \nper phase. In particular, the im\u00adplicit phasing model does not inhibit doing so in any way. Since it \nis based on the portable syntax-case expander ex\u00adtracted from the Chez Scheme source code, our system \nsupports a few useful extensions featured by that expander, including local modules, local imports, and \nmeta de.nitions (Dybvig 2005). We plan also to implement local libraries, which differ from local mod\u00adulesinthata \nnested library sexportsmaybeusedinanyphasebe\u00adcause theycannot depend on the environment in which the \nlibrary appears. Local libraries are useful because they are encapsulated within the enclosing top-level \nlibrary (and thus invisible outside) and can be produced via macros. Acknowledgments Will Byrd, Ron Garcia, \nMichael Adams, and the anonymous re\u00adviewers all made suggestions that led to substantial improvements \nin the .nal version of this paper. References R.Kent Dybvig. Chez SchemeVersion7User s Guide. Cadence \nResearch Systems, 2005. R. Kent Dybvig. Writing hygienic macros in Scheme with syntax\u00adcase. Technical \nReport TR 356, Indiana University, 1992. URL citeseer.ist.psu.edu/dybvig92writing.html. R.Kent Dybvig, \nRobert Hieb, and Carl Bruggeman. Syntactic abstraction in Scheme. Lisp and Symbolic Computation, 5(4):295 \n326, 1992. URL citeseer.ist.psu.edu/article/dybvig93syntactic.html. R.Kent Dybvig, Abdulaziz Ghuloum, \nand Andr\u00b4evanTonder. R5.91rs library and syntax-case reference implementations, 2006. URL http://www.r6rs.org/refimpl/r6rs-syntax-case.tar.gz. \n Matthew Flatt. Composable and compilable macros: You want it when? In ICFP 02: Proceedings of the seventhACM \nSIGPLAN international conference on Functional programming, pages 72 83, 2002. URL http://doi.acm.org/10.1145/581478.581486. \nRichard Kelsey, William Clinger, and Jonathan Rees (Ed\u00ad itors). Revised5 report on the algorithmic language \nScheme. ACM SIGPLAN Notices, 33(9):26 76, 1998. URL citeseer.ist.psu.edu/kelsey98revised.html. BrianW.Kernighanand \nDennisM. Ritchie. TheCProgramming Language. Prentice Hall, second edition, 1988. Eugene Kohlbecker, Daniel \nP. Friedman, Matthias Felleisen, and Bruce Duba. Hygienic macro expansion. In LFP 86: Proceedings of \nthe 1986 ACM Conference on LISP and Functional Programming, pages 151 161, New York, NY, USA, 1986. ACM \nPress. ISBN 0-89791-200-4. doi: http://doi.acm.org/10.1145/319838.319859. Michael Sperber, William Clinger, \nR. Kent Dybvig, Matthew Flatt, An\u00adton van Straaten, Richard Kelsey, and Jonathan Rees. Revised (5.91) \nreport on the algorithmic language Scheme, September 2006. URL http://www.r6rs.org/versions/r6rs 91.pdf. \nWith H. Abelson, N.I. Adams,IV,D.H. Bartley,G. Brooks,R.B. Findler,D.P. Friedman, R. Halstead, C. Hanson, \nC.T. Haynes, E.Kohlbecker, J. Matthews, D.  Oxley, K. M. Pitman, G. J. Rozas, G. L. Steele, Jr., G. \nJ. Sussman, and M.Wand. Michael Sperber, William Clinger, R. Kent Dybvig, Matthew Flatt, and Anton van \nStraaten. Revised (5.92) report on the algorithmic language Scheme, January 2007a. URL http://www.r6rs.org/versions/r6rs \n92.pdf. With R. Kelsey, J. Rees, R. B. Findler, and J. Matthews. Michael Sperber,R.KentDybvig, Matthew \nFlatt,and Antonvan Straaten. Revised (5.97) report on the algorithmic language Scheme, June 2007b. URL \nhttp://www.r6rs.org/versions/r5.97rs.pdf. With R. Kelsey,W. Clinger,J. Rees,R.B. Findler, andJ. Matthews. \nOscarWaddell. Extending the Scope of Syntactic Abstraction. PhD thesis, Indiana University Computer Science \nDepartment, August 1999. URL http://cs.indiana.edu/~owaddell/papers/thesis.ps.gz. Oscar Waddell and \nR. Kent Dybvig. Extending the scope of syntac\u00adtic abstraction. In Conference Record of POPL 99: The 26th \nACM SIGPLAN-SIGACT Symposium on Principles of Programming Lan\u00adguages, San Antonio,Texas, pages 203 213,NewYork,NY, \n1999. URL citeseer.ist.psu.edu/waddell99extending.html. Oscar Waddell, Dipanwita Sarkar, and R. Kent \nDybvig. Fixing letrec: A faithful yet ef.cient implementation of Scheme s recursive binding construct. \nHigher Order Symbol. Comput., 18(3-4):299 326, 2005. ISSN 1388-3690. doi: http://dx.doi.org/10.1007/s10990-005-4878-3. \nFelixWinkelmann. CHICKEN User s Manual, 2007.   \n\t\t\t", "proc_id": "1291151", "abstract": "<p>The forthcoming Revised<sup>6</sup> Report on Scheme differs from previous reports in that the language it describes is structured as a set of libraries. It also provides a syntax for defining new portable libraries. The same library may export both procedure and hygienic macro definitions, which allows procedures and syntax to be freely intermixed, hidden, and exported.</p> <p>This paper describes the design and implementation of a portable version of R<sup>6</sup>RS libraries that expands libraries into a core language compatible with existing R<sup>5</sup>RS implementations. Our implementation is characterized by its use of inference to determine when the bindings of an imported library are needed, e.g., run time or compile time, relieving programmers of the burden of declaring usage requirements explicitly.</p>", "authors": [{"name": "Abdulaziz Ghuloum", "author_profile_id": "81337489577", "affiliation": "Indiana University, Bloomington, IN", "person_id": "P900671", "email_address": "", "orcid_id": ""}, {"name": "R. Kent Dybvig", "author_profile_id": "81100181541", "affiliation": "Indiana University, Bloomington, IN", "person_id": "PP14073331", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291197", "year": "2007", "article_id": "1291197", "conference": "ICFP", "title": "Implicit phasing for R6RS libraries", "url": "http://dl.acm.org/citation.cfm?id=1291197"}