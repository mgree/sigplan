{"article_publication_date": "10-01-2007", "fulltext": "\n Functional Pearl: The Great Escape Or, How to jump the border without getting caught David Herman Northeastern \nUniversity dherman@ccs.neu.edu Abstract Filinski showed that callcc and a single mutable reference cell \nare suf.cient to express the delimited control operators shift and reset. However, this implementation \ninteracts poorly with dy\u00adnamic bindings like exception handlers. We present a variation on Filinski s \nencoding of delimited continuations that behaves appro\u00adpriately in the presence of exceptions and give \nan implementation in Standard ML of New Jersey. We prove the encoding correct with respect to the semantics \nof delimited dynamic binding. Categories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language \nConstructs and Features Control structures General Terms Languages Keywords continuations, delimited \ncontrol, dynamic binding 1. Introduction First-class continuations are prevalent in mature implementations \nof functional programming languages such as Scheme (Kelsey et al. 1998) and Standard ML (Milner et al. \n1990). They often ap\u00adpear in undelimited form: call-with-current-continuation in Scheme (call/cc for \nshort) and the library function callcc of Standard ML of New Jersey both capture the entire program con\u00adtinuation. \nBut many applications call for delimited continuations, which are characterized by the ability to evaluate \nan expression as if in a new, empty evaluation context (Felleisen 1988; Danvy and Filinski 1989). Restricting \nthe scope of control effects protects the computational abstractions of idioms like threads, read-eval-print \nloops, and re.ective towers of metacircular interpreters (Felleisen 1988; Sitaram and Felleisen 1990; \nWand and Friedman 1986). The problem we solve here is one that arose from a practical need: could we \nimplement the delimited control operators shift and reset in Standard ML of New Jersey without modifying \nthe compiler? The answer would seem to be an obvious yes Sitaram and Felleisen (1990) showed that delimited \ncontrol can be expressed in terms of undelimited control, and Andrzej Filinski published a well-known \ntranslation of shift and reset for lan\u00adguages with callcc and mutable reference cells (Filinski 1994). \nHowever, recent work by Kiselyov et al. (2006) showed that Filin\u00adski s implementation does not work for \nlanguages with exceptions. Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \npro.t or commercial advantage and that copies bear this notice and the full citation on the .rst page. \nTo copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. ICFP 07 October 1 3, 2007, Freiburg, Germany. Copyright c . 2007 ACM 978-1-59593-815-2/07/0010. \n. . $5.00 Filinski s encoding is correct in a simple .-calculus. But a na\u00a8ive translation of this encoding \ninto ML results in a subtle bug: a rei.ed continuation closes over all of the dynamically bound exception \nhandlers. By contrast, the semantics of delimited dynamic bind\u00ading (Kiselyov et al. 2006) prescribes \nthat delimited continuations only close over a part of the dynamic environment. Perhaps it should not \nbe surprising that callcc and excep\u00adtions interact in non-trivial ways. Nevertheless, Filinski s SML \nim\u00adplementation of shift and reset was considered standard for a decade before the problem of exception \nhandlers was identi.ed. Kiselyov et al. (2006) describe the problem of dynamic binding in the presence \nof delimited control and offer solutions using either modi.ed semantics for dynamic variables or callcc \nor low-level primitives for concatenating and splitting dynamic environments. This paper demonstrates \nthat, for the particular problem of dy\u00adnamically binding exception handlers, no changes to the underlying \nsemantics are necessary. We present an implementation of shift and reset in the presence of exceptions \nand dynamically bound exception handlers using the same tools as the original Filinski encoding callcc \nand a single, mutable reference cell using a technique we call The Great Escape. The next section reviews \nthe semantics of shift and reset. Section 3 describes the original Filinski encoding, spells out the \nkey invariant for the simulation, and proves the simulation correct with respect to a semantics without \nexceptions. Section 4 intro\u00adduces exceptions and dynamically bound exception handlers to the speci.cation \nsemantics and illustrates the problems with the Filin\u00adski encoding. Section 5 presents our solution and \nproves it correct with respect to the updated semantics. Section 6 concludes. 2. Delimited continuations \nDelimited control operators generalize .rst-class continuations by allowing programs to perform subcomputations \nas if in a new, empty evaluation context. This creates a kind of computational sandbox for the evaluation \nof a subexpression, which is useful for separating multiple stages of computation. Control delimiters \nserve as computational abstraction boundaries, preventing child stages from capturing or returning to \nparent stages. For example, a simple read-eval-print loop implemented in Scheme might track the expression \ncount in a local accumulator n. A na\u00a8ive implementation directly evaluates the input with eval: (define \n(repl) (define (loop n) (display n) (display \" -\") (display (eval (read))) (newline) (loop (+ n \n1))) (loop 0)) The accumulator appears to be strictly increasing, but an interaction can capture the \ncurrent continuation and return to it later: 0-(de.ne k #f) 1-(call/cc (lambda (x) (set! k x))) 2-(k \n17) 17 2-(k 42) 42 2- Because call/cc captures the entire program continuation, the user interaction \nis able to escape the current context and return to an earlier point in the program history with a previous \nvalue for n. A better implementation of repl could use a control delimiter. The reset operator evaluates \nits argument expression as if in an empty context, which prevents code from capturing or re-entering \nthe continuation of the delimiter. In the case of repl, wrapping the call to eval protects the main loop \nfrom being captured by user code: (display (reset (eval (read)))) The corresponding operator shift is \nsimilar to call/cc, but it can only capture the local portion of the continuation up to the most recent \ndelimiter. With shift and the new repl, the interaction sequence behaves as expected: 0-(de.ne k #f) \n1-(shift (lambda (x) (set! k x))) 2-(k 17) 17 3-(k 42) 42 4- There is another important difference between \ncall/cc and shift: the jumps happen at different points. With call/cc, cap\u00adturing the current continuation \nhas no observable effect, but invok\u00ading a continuation aborts the current continuation. The reverse is \ntrue of shift; capturing a continuation immediately aborts it, but invoking a continuation does not abort. \nFor example, the result of (+ 1 (call/cc (lambda (k) 42))) is 43, whereas the result of (reset (+ 1 \n(shift (lambda (k) 42)))) is 42. That is, call/cc does not abandon the current context when k is not \ninvoked, but shift abandons the context immediately. Because they do not jump, continuations captured \nby shift can often be composed like ordinary functions. For example, the result of (reset (+ 1 (shift \n(lambda (k) (k (k 17)))))) is 19, because after shift aborts the local context, the two nested applications \nof k evaluate normally, without subsequent aborts. 2.1 Speci.cation Filinski de.nes the behavior of shift \nand reset via a double\u00adbarrelled (Thielecke 2002) continuation-passing interpretation in the .-calculus. \nEach function in the interpretation receives two extra arguments: a local continuation, representing \nthe immediate control context up to the dynamically nearest delimiter, and a meta\u00adcontinuation, representing \nthe rest of the control context after the delimiter (Wand and Friedman 1986). Biernacki et al. (2006) \ninstead use an elegant abstract machine semantics with two evaluation contexts to represent the two contin\u00aduations. \nWe use a simpli.ed version of this abstract machine, with only a control expression e, a local continuation \nrepresented as an evaluation context E, and a metacontinuation K, represented as a stack of local contexts \nE. e ::= x | v | ee |Sx.e | #e v ::= .x.e|.E. E ::= [] | Ee | vE K ::= halt | E:: K C ::= E[e],K The \nsyntax of this language is the untyped .-calculus with addi\u00adtional expression forms S for shift and # \nfor reset, as well as rei.ed continuations .E.. A program state C consists of a control expression e \nand its two continuations E and K. The rules for evaluating this language are mostly straightfor\u00adward: \nS E[.x.e v],K -. E[e[v/x]],K S E[Sx.e],K -. e[.E./x],K S E[#e],K -. e, E:: K S E[.E ' . v],K -. E[#E \n' [v]],K S v, E :: K -. E[v],K The .rst rule is standard \u00dfv reduction. Evaluation of a shift expression \nSx.e captures and aborts the current local continuation, binding it to x. The reset form #e pushes the \ncurrent local continuation onto the metacontinuation, protecting it from capture by subsequent calls \nto shift. Invoking a continuation .E ' . is more involved: the value v is plugged into the continuation \nE ' , and evaluated within the current evaluation context E, but with the addition of a new delimiter. \nThis prevents subsequent control effects in the body of E ' from capturing E. It is this extra delimiter \nthat distinguishes the behavior of S from the control operator F (Felleisen 1987; Danvy and Filinski \n1989; Sitaram 1994; Shan 2004; Kiselyov 2005; Biernacki et al. 2006). Finally, returning a value locally \npops the next local continuation off of the global stack and continues returning.  3. Filinski encoding \nArmed with a speci.cation, let us now take a look at the Filinski encoding, guided by a concrete implementation \nin SML/NJ. 3.1 Implementation In SML/NJ, a continuation of argument type a is represented as a special \nvalue of type a cont, and can be invoked with a library function val throw : a cont -> a -> b But the \nScheme-style representation of .rst-class continuations as functions is closer to the Filinski encoding, \nso Filinski s SML implementation provides a functional abstraction for continuations. To distinguish \nit from the built-in callcc, Filinski names this function escape after the similar construct of Reynolds \n(1972). signature ESCAPE = sig type void val coerce : void -> a val escape : (( a -> void) -> a) \n-> a end; Here the type void is intended to be uninhabited, so it can be used for functions that never \nreturn. With this in mind, the type for escape can be read as a Scheme-like functional callcc: its argument \nis a function that consumes a continuation function of type a -> void. The coerce function is analogous \nto throw in that it informs the ML type checker that an expression that never returns can have any type. \nThis much of the implementation is simple: structure Escape : ESCAPE = struct datatype void = VOID \nof void fun coerce (VOID v) = coerce v open SMLofNJ.Cont fun escape f = callcc (fn k=> (f (fn x => \nthrow kx))) end; The main library de.nes shift and reset and is parameterized over the type ans of intermediate \nanswers, the values returned by local continuations. signature CONTROL = sig type ans val shift : \n(( a -> ans) -> ans) -> a val reset : (unit -> ans) -> ans end; Figure 1 shows the implementation of \nthe Filinski encoding in SML/NJ. The reference cell mk serves as the representation of the metacontinuation, \nand the auxiliary function return simulates returning a value to the current metacontinuation by applying \nthe contents of mk. The implementation of shift calls escape to capture and bind the ML continuation \nto k, which serves as the representation of the local continuation E. The argument to f wraps the call \nto k with reset to implement the speci.ed behavior of applying E. The shift function relies on return \nto return its result directly to the current metacontinuation, rather than to its local continuation. \nOf course, in the speci.cation, this happens immediately by discarding the local context E before evaluating \nthe body, whereas in the implementation, this control effect happens after f returns. The reset function \nimplements the stack discipline of the metacontinuation. The function .rst captures the current ML con\u00adtinuation \nand binds it to k, representing the local continuation E. The metacontinuation cell is updated to a new \nfunction that, when applied, .rst simulates popping E from the stack by restoring the cell to its previous \nstate, before returning the result to k. Again, the result of the reset expression returns to the current \nmetacontinua\u00adtion via a .nal call to return. The bewildered reader may at this point be wondering how \nwe have managed to represent a delimited continuation E with an un\u00addelimited continuation k throughout \nthis implementation. To under\u00adstand why this works, we must consider the invariant maintained by this \nencoding.  3.2 Borders The challenge in representing delimited continuations with callcc is preventing \nthe extra information captured in an undelimited con\u00adtinuation from affecting the program behavior. The \nencoding relies on an invariant that every captured continuation contains a border that forces control \nto jump out of the captured continuation and re\u00adturn to the metacontinuation, effectively discarding \nthe extraneous portion of the undelimited continuation. To make this notion precise, consider a little \nmodel of our implementation language with undelimited .rst-class continuations and a single mutable reference \ncell: e ::= x | v | . | .e |Cx.e v ::= .x.e |.E. E ::= [] | Ee | vE | .E C ::= E[e], v We use a sans \nserif font to distinguish terms in the model of the implementation language from the model of the speci.cation \nlanguage. The up-arrow expression form . denotes a dereference of the single cell and the down-arrow \nform .e denotes assignment to the cell. The expression form Cx.e captures a continuation and binds it \nto x in the scope of e. A program state C consists of a continuation E, a control expression e, and the \ncurrent value v of the single reference cell. We can de.ne additional conveniences as syntactic sugar, \nsuch as let x . e in e ' =(.x.e ' ) e (e; e ' )= let . e in e ' =(. .e ' ) e where represents any variable \nnot free in e ' . The operational semantics for this tiny calculus is an untyped, call-by value .-calculus, \nmuch like Scheme or an untyped ML: C E[.x.ev], v ' -. E[e[v/x]], v ' C E[Cx.e], v -. E[e[.E./x]], v C \nE[.E ' . v], v ' -. E ' [v], v ' C E[.], v -. E[v], v C E[.v], v ' -. E[v], v As before, application \nfollows \u00dfv . The Cx.e form rei.es the entire program continuation E and binds it to x to evaluate e. \nApplication of a captured continuation E ' replaces the current continuation. The forms . and .v retrieve \nand update the value of the mutable cell, respectively. The simulation invariant, shown in Figure 3, \nformalizes the im\u00adportant components of the simulation. The judgment C ~ C indi\u00adcates that a con.guration \nC in the implementation machine simu\u00adlates a con.guration C in the speci.cation machine if it evaluates \nrelated terms in related continuations or if it simulates returning to the metacontinuation by applying \nthe current value of the cell to a related value. The judgment e ~ e relates expressions of the speci.cation \nand implementation machines. Delimited continuations are encoded as functions that apply related undelimited \ncontinuations under a reset. Plugging a value into a local continuation is encoded as application of \nthat continuation s encoding. A shift expression is simulated by capturing the current continuation and \nbinding k to a function that applies the captured continuation under a fresh delim\u00aditer; to simulate \nthe control effect of aborting the local continuation, the body expression is evaluated in the context \nof a border which gives the result to the metacontinuation. The encoding of reset captures the current \ncontinuation and binds it to a fresh k in order Figure 2. A continuation in the simulation. functor \nControl (type ans) : CONTROL = struct open Escape exception MissingReset type ans = ans  val mk : (ans \n-> void) ref = ref (fn _ => raise MissingReset) fun return x = coerce (!mk x) fun reset thunk = escape \n(fn k => let val m = !mk  in mk := (fn r=> (mk := m; k r)); return (thunk ()) end)  fun shift f = \nescape (fn k => return (f (fn v => reset (fn () => coerce (k v))))) end; Figure 1. The Filinski encoding \nin Standard ML of New Jersey. to push the current control context onto the metacontinuation; when the \nmetacontinuation is invoked, it pops this extra frame by revert\u00ading to its previous value. Again, the \nbody of the reset is evaluated under a border that returns its result to the metacontinuation. Judgment \nE ~ E states that a continuation in the implemen\u00adtation simulates a local continuation of the speci.cation \neven if it contains extra junk at the beginning, so long as the relevant local portion is delimited with \na border. The judgment E E relates just that local portion to the speci.ed local continuation. Finally, \nthe judgment v ~ K relates the reference cell of the im\u00adplementation machine to the metacontinuation. \nFor simplicity, we .x an initial continuation E0 and an initial value v0 in the reference cell; if a \ncomputation terminates, the .nal value is returned to E0 and the reference cell is reverted to v0 . An \nimplementation in the model ML can be directly derived from the invariant. .x. ..x.e. .e1 e2 . .Sk.e. \n.#e. = x = .x..e. = .e1 ..e2 . = Ck ' .let x . (let k . .x..#(k ' x).in .e.) in ((.) x) k ' .. FV(.e.) \n= Ck.(let m . (.) in ..x.(.m; kx) let x . .e.in ((.) x)) k .. FV(.e.) Translating a top-level program \ncon.guration e, halt to the con.guration E0 [.#e.], v0 yields a valid initial con.guration for the simulation. \nThe simulation theorem shows that Filinski s en\u00adcoding is a faithful implementation of the speci.cation. \n Lemma 1 (substitution preserves invariant) If e ~ e and v ~ v then e[v/x] ~ e[v/x]. Proof Structural \ninduction on e, e, v and v. . Theorem 1 (simulation, Filinski encoding) With the languages and simulation \ninvariant of Sections 2.1 and 3.2, S if C ~ C and C -. C ', then there exists a term C ' such that C \nC -. C ' and C ' ~ C ' . [I-EVAL] E[e] .v ' E ~ E e ~ e = v ~ K E[e], v ~ E[e],K [I-RETURN] v ~ v v ' \n~ K any E E[(v ' v)], v ' ~ v, K [I-VAR] [I-ABS] e ~ e x ~ x .x.e ~ .x.e [I-REIFY] e ~ #(yx) E ~ E \n.x.e[.E./y] ~.E. [I-SHIFT] k ' .. FV(e) e ~ e Ck ' ' .let x . (let k . .x.e ((.) x) [I-RESET] k .. FV(e) \n[I-APP] e ~ e e ' ~ e ' ee ' ~ ee ' [I-REFLECT] E ~ E v ~ v (.E. v) ~ E[v] e ' ~ #(k ' x) in e) in ~Sk.e \n e ~ e Ck.(let m . (.) in ..x.(.m; kx); ~ #e let x . e in ((.) x)) [I-BORDER] E E any E ' E ' [let x \n. E in ((.) x)] ~ E [I-OPERATOR] [I-OPERAND] [I-HOLE] E E e ~ e v ~ v E E [] [] Ee Ee vE vE [I-PUSH][I-EMPTY] \nv ~ K E ~ E .x.(.v0 ; E0 x) ~ halt .x.(.v; .E. x) ~ E:: K Figure 3. The simulation invariant. Proof By \ncases on the reduction rules of the speci.cation machine and the de.nition of the invariant relations, \nusing Lemma 1. . S* Corollary If C ~ C and C -. v, halt then there exists a value C * v such that C -. \nE0 [v], v0 and v ~ v.  4. Exceptions Theorem 1 assures us that the implementation is correct assuming, \nof course, that the model is a realistic re.ection of the implemen\u00adtation language. But what happens \nwhen the implementation lan\u00adguage contains exceptions? 4.1 SML Exceptions Let us see what happens if \nwe extend the model of the implemen\u00adtation language with a .xed set of exception constants eand excep\u00adtion \nhandlers h: e ::= ... | handle h . e v ::= ... | raise | e h ::= x | e Furthermore, we must be able to \ninstall exception handlers during evaluation. In SML/NJ, a captured continuation closes over its installed \nexception handlers so it suf.ces to add handler frames to the de.nition of evaluation contexts E: E ::= \n... | E handle h . e Now we can extend the implementation semantics with rules for raising and handling \nexceptions: C E[E ' [raise e] handle e . e], v -. E[e], v if E ' .E1 [E2 handle h . e ' ] = C E[E ' [raise \ne] handle x . e], v -. E[e[e/x]], v if E ' .E1 [E2 ' ] = handle h . e C E[E ' [raise e] handle e ' . \ne], v -. E[raise e], v ' e ' if E ' .E1 [E2 handle h . e ] and e = 4.2 Delimited dynamic binding To \nunderstand how exceptions interact with delimited control oper\u00adators, let us also add similar syntax \nto the speci.cation language: e ::= ... | e handle h . e v ::= ... | raise | e h ::= x | e Now we are \nfaced with a design decision, namely how delim\u00adited evaluation contexts interact with exception handlers. \nSpeci.\u00adcally, the question is what exception handlers captured continuation should close over: none \nof the current exception handlers;  all exception handlers in the current continuation; or  all exception \nhandlers in the current continuation, up to the nearest delimiter.  Kiselyov et al. (2006) argue that \nthe third option is the most sensible semantics. Indeed, if we use a representation of evalua\u00adtion contexts \nanalogous to Section 4.1, then rei.ed continuations capture exactly the bindings installed since the \nlast delimiter: E ::= ... | E handle h . e Exception handlers are an example of dynamic bindings, also \nknown as .uids or implicit parameters (Haynes and Friedman 1987; Hanson 1991; Moreau 1997; Lewis et al. \n2000). Because dynamic bindings are associated with their control context, context delimiters should \nalso delimit the scope of dynamic bindings. To wit: capturing a portion of that context should accordingly \ncapture only the relevant portion of current dynamic bindings. Further\u00admore, applying a captured delimited \ncontinuation should install its exception handlers in the context of the current handlers. In other words, \ninstalling a delimited continuation has the effect of splic\u00ading together two sets of handlers. The new \nrules of the speci.cation semantics are mostly analo\u00adgous to those of Section 4.1: S E[E ' [raise e] \nhandle e . e],K -. E[e],K if E ' .E1 [E2 handle h . e ' ] = S E[E ' [raise e] handle x . e],K -. E[e[e/x]],K \nif E ' .E1 [E2 = handle h . e ' ] S E[E ' [raise e] handle e ' . e],K -. E[raise e],K if E ' .E1 [E2 \nhandle h . e ' ] and e = e ' S E[raise e],E ' :: K -. E ' [raise e] if E .E1 [E2 = handle h . e] The \n.rst three rules correspond to the rules of the implementation semantics. The last rule speci.es that \nuncaught exceptions propa\u00adgate from child computations to parent computations. 4.3 Bug Unfortunately, \nthe above semantics is not the one implemented by the code in Section 3.1. For example, according to \nthe semantics of delimited dynamic binding, the following code fragment should evaluate to 1: reset (fn \n_ => (shift (fn k => (k 0) handle Fail _ => 1)) + (raise Fail \"uncaught\")) handle Fail _ => 2 Instead, \nthe Filinski implementation returns 2. The problem occurs when the Fail exception is raised in the original \ncontext of the reset expression; the raised exception blunders right past the border and is consequently \ncaught by the handle Fail => 2 guard. So much for an escape route.  5. The Great Escape The problem \nwith the invariant of Section 3.2 is that it does not prevent exceptions from crossing a border; it only \ntakes ordinary returns into account. The simulation invariant should guarantee that control never crosses \nthe border, whether by returning or raising an exception. Instead, when control reaches the border, it \nshould always be redirected to the metacontinuation. More generally, the problem is that we need some \nway of splic\u00ading together the dynamic bindings of two different continuations. Invoking a continuation \ninstalls the local exception handlers from the captured continuation in front of the global exception \nhandlers of the metacontinuation. But Standard ML does not provide primi\u00adtives for cutting and pasting \ndynamically bound exception handlers. The solution is to install a dynamic barrier, in the form of a \nuniversal exception handler handle x, that effectively blocks any handlers beyond the border. When the \nbarrier catches an exception, it redirects it to the metacontinuation to raise it again. This creates \nthe tunnel through which both returned values and raised excep\u00adtions alike can cross the border without \ngetting caught by the wrong handlers. The metacontinuation needs to be able to distinguish ordinary returns \nfrom raised exceptions, so every tunneled value is tagged as either a return or an exception: datatype \ntunneled = SUCCESS of ans | FAILURE of exn Any answer sent to the metacontinuation must be wrapped as \na SUCCESS, and any exception redirected to the metacontinuation is wrapped as a FAILURE. To complete \nthe protocol, the metacontin\u00aduation must always unwrap the tunneled value and either return or re-raise \nit. We call this trick The Great Escape. 5.1 The new invariant To keep things simple, we can model the \ntunneled datatype with a standard functional representation rather than adding sum types to the model. \nA tunneled value in the model is a higher-order function that consumes two function arguments s and f.A \nSUCCESS always applies the s argument to its answer value, and a FAILURE applies the f argument to its \nexception. The new encoding in the model ML wraps both locally returned values and locally uncaught exceptions \nas tunneled data, and the metacontinuation unwraps the tunneled data by returning values and re-raising \nexceptions. .Sk.e. = Ck ' .let x . (let k . .x..#(k ' x).in .e.) in ((.) .s..f.(s x)) handle x . ((.) \n.s..f.(f x)) k ' .. FV(.e.) .#e. = (((Ck.(let m . (.) in ..x.(.m; k x); let x . .e.in ((.) .s..f.(s x)) \nhandle x . ((.) .s..f.(f x)))) .x.x) raise) k .. FV(.e.) Figure 4 shows the new and updated rules for \nthe new simu\u00adlation invariant. The simple new expression forms relate by com\u00adponents. The implementations \nof shift and reset now wrap as a tunneled value either the local result or any locally uncaught ex\u00adception. \nA border separating the local portion of a continuation now guards both ordinary return and exceptional \nreturn. Theorem 2 (simulation, The Great Escape) With the languages of Sections 4.1 and 4.2 and the simulation \nS invariant of Section 5.1, if C ~ C and C -. C ' and then there S * ' C ' exists a term C ' such that \nC -. and C ' ~ C . Proof As before, using the new simulation invariant. . 5.2 Space ef.ciency The new \ntranslation is operationally correct, but for practical pur\u00adposes, it suffers terrible space ef.ciency. \nUsers do not expect the continuation captured by shift to consume as much space as a full continuation \ncaptured by callcc. In fact, every time the simulation captures a delimited contin\u00aduation, the simulation \ninvariant guarantees that control will never pass the border. Of course, the SML/NJ garbage collector \ncannot infer this information about our program invariant. The problem, then, is that continuation frames \nthat should be dead remain live in memory for too long. Happily, SML/NJ provides the following useful \nabstraction in the SMLofNJ.Cont library: val isolate : ( a -> unit) -> a cont The isolate function consumes \na function that does not return and converts it into a .rst-class continuation. Invoking this continuation \nabandons the current continuation and replaces it with the isolated function. [I-RAISE] [I-EXCEPTION] \nraise ~ raise e ~ e [I-HANDLE] e ~ e e ' ~ e ' e handle h . e ' ~ e handle h . e ' [I-SHIFT*] k ' .. \nFVee ~ e e ' ~ #(kx) Ck ' .let x . (let k . .x.e ' in e) in ~Sk.e ((.) .s..f.(sx)) handle x . ((.) .s..f.(fx)) \n[I-RESET*] k .. FV(e) e ~ e (((Ck.(let m . (.) in ~ #e ..x.(.m; kx); let x . e in ((.) .s..f.(sx)) handle \nx . ((.) .s..f.(fx)))) .x.x) raise) [I-BORDER*] E E any E ' E ' [let x . E in ((.) .s..f.(sx)) ~ E \nhandle x . ((.) .s..f.(fx))] [I-INSTALL] E E e ~ e handle h . e E handle h . e Figure 4. New and changed \n(*) rules for the simulation invariant. This is just what we need to inform the runtime to abandon the \nuseless portion of the current continuation whenever we capture a delimited continuation: fun abort thunk \n= throw (isolate thunk) () This function effectively performs a computation in the empty continuation. \nAs it turns out, every use of escape in the simulation sends its results to the metacontinuation, so \nwe never need the current con\u00adtinuation after capturing it. This means we can change the de.nition of \nescape to abandon the continuation with abort after capturing it. This corresponds to an alternative \nsemantics for escape: C E[Cx.e], v -. e[.E./x], v Unsurprisingly, the simulation invariant holds for \nthis alternative semantics as well; the only difference is that there is never extra junk in a captured \ncontinuation. Theorem 3 (simulation, The Great Escape, optimized) With the languages of Sections 4.2 \nand 5.2 and the simulation S invariant of Section 5.1, if C ~ C and C -. C ', then there exists a term \nC ' such that C -. C * C ' and C ' ~ C ' . 5.3 Implementation Figure 5 shows the new implementation \nin SML/NJ.  6. Conclusion We have shown that, with a proper exception-handling protocol, it is possible \nto express delimited continuations with undelimited continuations even in the presence of exceptions. \nWhile the general problem of splicing together dynamic bind\u00adings from two contexts is hard to achieve \nwithout additional prim\u00aditives in the implementation language, our encoding demonstrates that exception \nhandlers can be cut with a universal exception han\u00addler and pasted back together with an appropriate \nreturn proto\u00adcol. Pleasingly, this implementation .ts the feature set of Standard ML of New Jersey well, \ngiving us a non-native implementation of shift and reset with the correct semantics and appropriate space \nbehavior.  Acknowledgments I thank Jacob Matthews and Ryan Culpepper for the brainstorming that led \nto this work. I thank Mitchell Wand for his guidance and Matthias Felleisen and the anonymous reviewers \nfor their thorough and helpful comments.  References Dariusz Biernacki, Olivier Danvy, and Chung-chieh \nShan. On the static and dynamic extents of delimited continuations. Science of Computer Programming, \n60(3):274 297, 2006. ISSN 0167\u00ad6423. Olivier Danvy and Andrzej Filinski. A functional abstraction of \ntyped contexts. Technical Report 89/12, DIKU, University of Copenhagen, 1989. Matthias Felleisen. The \ncalculi of .v -CS conversion: A syntac\u00adtic theory of control and state in imperative higher-order lan\u00adguages. \nPhD thesis, 1987. Matthias Felleisen. The theory and practice of .rst-class prompts. In Symposium on \nPrinciples of Programming Languages, 1988. Andrzej Filinski. Representing monads. In Principles of Program\u00adming \nLanguages (POPL), pages 446 457, New York, NY, USA, 1994. ACM Press. ISBN 0-89791-636-0. Chris Hanson. \nMIT scheme reference manual. Technical Report AITR-1281, 1991. Christopher T. Haynes and Daniel P. Friedman. \nEmbedding contin\u00aduations in procedural objects. ACM Transactions on Program\u00adming Languages and Systems \n(TOPLAS), 9(4):582 598, 1987. ISSN 0164-0925. Richard Kelsey, William Clinger, and Jonathan Rees (Editors). \nRevised5 report on the algorithmic language Scheme. ACM SIGPLAN Notices, 1998. Oleg Kiselyov. How to \nremove a dynamic prompt: static and dy\u00adnamic delimited continuation operators are equally expressible. \nTechnical Report 611, Indiana University, March 2005. Oleg Kiselyov, Chung-chieh Shan, and Amr Sabry. \nDelimited dynamic binding. In International Conference on Functional Programming, 2006. Jeffrey R. Lewis, \nMark Shields, John Launchbury, and Erik Meijer. Implicit parameters: Dynamic scoping with static types. \nIn Symposium on Principles of Programming Languages, 2000. Robin Milner, Mads Tofte, and Robert Harper. \nThe de.nition of Standard ML. MIT Press, Cambridge, MA, 1990. ISBN 0-262\u00ad63132-6. Luc Moreau. A Syntactic \nTheory of Dynamic Binding. In Interna\u00adtional Joint Conference on Theory and Practice of Software De\u00advelopment \n(TAPSOFT/FASE 97), volume 1214, pages 727 741, Lille, France, April 1997. Springer-Verlag. John C. Reynolds. \nDe.nitional interpreters for higher-order pro\u00adgramming languages. In ACM Annual Conference, pages 717 \n740, August 1972. Chung-Chieh Shan. Shift to control. In Scheme Workshop, Septem\u00adber 2004. Dorai Sitaram. \nModels of Control and Their Implications for Programming Language Design. PhD thesis, 1994. Dorai Sitaram \nand Matthias Felleisen. Control delimiters and their hierarchies. Lisp and Symbolic Computing, 3(1), \n1990. Hayo Thielecke. Comparing control constructs by double-barrelled CPS. Higher-Order and Symbolic \nComputation, 14(2):141 160, 2002. Mitchell Wand and Daniel P. Friedman. The mystery of the tower revealed: \na non-re.ective description of the re.ective tower. In LISP and functional programming, 1986. structure \nEscape : ESCAPE = struct datatype void = VOID of void fun coerce (VOID v) = coerce v open SMLofNJ.Cont \nfun abort thunk = throw (isolate thunk) () fun escape f =  callcc (fn k => abort (fn () => (f (fn x \n=> throw k x); ()))) end; functor Control (type ans) : CONTROL = struct open Escape exception MissingReset \ntype ans = ans datatype tunneled = SUCCESS of ans | FAILURE of exn  val mk : (tunneled -> void) ref \n= ref (fn _ => raise MissingReset) fun return x = coerce (!mk x) fun reset thunk = (case escape (fn \nk => let val m = !mk  in mk := (fn r=> (mk := m; k r)); return (SUCCESS (thunk ()) handle x => FAILURE \nx) end) of SUCCESS v => v | FAILURE x => raise x) fun shift f = escape (fn k => return (SUCCESS (f (fn \nv => reset (fn () => coerce (k v)))) handle x => FAILURE x)) end; Figure 5. The Great Escape in Standard \nML of New Jersey. \n\t\t\t", "proc_id": "1291151", "abstract": "<p>Filinski showed that callcc and a single mutable reference cell are sufficient to express the delimited control operators shift and reset. However, this implementation interacts poorly with dynamic bindings like exception handlers. We present a variation on Filinski's encoding of delimited continuations that behaves appropriately in the presence of exceptions and give an implementation in Standard ML of New Jersey. We prove the encoding correct with respect to the semantics of delimited dynamic binding.</p>", "authors": [{"name": "David Herman", "author_profile_id": "81337490109", "affiliation": "Northeastern University, Boston, MA", "person_id": "PP37042694", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291177", "year": "2007", "article_id": "1291177", "conference": "ICFP", "title": "Functional pearl: the great escape or, how to jump the border without getting caught", "url": "http://dl.acm.org/citation.cfm?id=1291177"}