{"article_publication_date": "10-01-2007", "fulltext": "\n Adding Delimited and Composable Control to a Production Programming Environment Matthew Flatt1 Gang \nYu University of Utah Institute of Software, Chinese Academy of Sciences m.att@cs.utah.edu yug@ios.ac.cn \n Abstract Operators for delimiting control and for capturing composable con\u00adtinuations litter the landscape \nof theoretical programming language research. Numerous papers explain their advantages, how the oper\u00adators \nexplain each other (or don t), and other aspects of the oper\u00adators existence. Production programming \nlanguages, however, do not support these operators, partly because their relationship to ex\u00adisting and \ndemonstrably useful constructs such as exceptions and dynamic binding remains relatively unexplored. \nIn this paper, we report on our effort of translating the theory of delimited and composable control \ninto a viable implementation for a production system. The report shows how this effort involved a substantial \ndesign element, including work with a formal model, as well as signi.cant practical exploration and engineering. \nThe resulting version of PLT Scheme incorporates the expres\u00adsive combination of delimited and composable \ncontrol alongside dynamic-wind, dynamic binding, and exception handling. None of the additional operators \nsubvert the intended bene.ts of existing control operators, so that programmers can freely mix and match \ncontrol operators. Categories and Subject Descriptors D.3.3 [Programming Lan\u00adguages]: Language Constructs \nand Features Control structures General Terms Design, Languages 1. An F in Production Delimited-control \noperators have appeared far more often in re\u00adsearch papers (Felleisen 1988; Danvy and Filinski 1990; \nHieb and Dybvig 1990; Sitaram and Felleisen 1990; Queinnec and Serpette 1991; Sitaram 1993; Gunter et \nal. 1995; Shan 2004; Biernacki et al. 2006; Kiselyov et al. 2006; Dybvig et al. 2006) than in production \nprogramming environments (Gasbichler and Sperber 2002). One obstacle, at least for some run-time system \nimplementations, is the dif.culty of adding higher-order control to the existing implemen\u00adtation. A broader \nproblem, however, is that delimited control oper\u00adators semantically interfere with other pre-existing \noperators, such as dynamic-wind and dynamic bindings. 1 On sabbatical at the Institute of Software, Chinese \nAcademy of Sciences Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. ICFP 07, October 1 3, 2007, Freiburg, Germany. Copyright c . 2007 ACM 978-1-59593-815-2/07/0010. \n. . $5.00 Robert Bruce Findler Matthias Felleisen University of Chicago Northeastern University robby@cs.uchicago.edu \nmatthias@ccs.neu.edu Due to this semantic interference, simulations of delimited con\u00adtrol do not immediately \nyield production-quality implementations. For example, a Scheme library can use call/cc to simulate de\u00adlimited \ncontinuations (Sitaram and Felleisen 1990; Filinski 1994; Kiselyov 2005b; Dybvig et al. 2006), but other \nlibraries that use call/cc directly or that use dynamic-wind can interfere with the simulation (Dybvig \net al. 2006). Over the past year, we have integrated a full set of delimited\u00adcontrol operators within \nPLT Scheme, ensuring that all of them interact properly with the rest of the Scheme programming lan\u00adguage \n(Kelsey et al. 1998) as well as pre-existing extensions in PLT Scheme (Flatt 2007). Speci.cally, PLT \nScheme s prompts and composable continuations have a well-de.ned and useful interac\u00adtion with call/cc, \ndynamic-wind, dynamic binding via con\u00adtinuation marks (Clements et al. 2001), and exceptions. In this \npaper, we report on the key aspects of our experience with this process: the design, the semantic model, \nits role in the imple\u00admentation effort, and our initial uses. As expected, adding delim\u00adited continuations \nsigni.cantly simpli.ed the read-eval-print loop implementation in DrScheme (Findler et al. 2002) consistent \nwith the original motivation for prompts by Felleisen (1988). We also found that associating a prompt \nwith an abort handler clari\u00ad.ed our exception handling mechanisms. Finally, delimited control signi.cantly \nimproved the PLT web server s implementation. The rest of the paper proceeds as follows. In section 2, \nwe de.ne the task at hand. In section 3, we gradually introduce the control constructs of PLT Scheme \ndelimited control, continuation marks, exceptions, dynamic-wind and we explain how they interact. In \nsection 4, we present brie.y our formal model. In section 5, we comment on PLT Scheme s implementation \nof the model. In section 6, we report our practical experience. 2. Having It All A language ought to \nprovide a minimal set of constructs from which other constructs can be built (Kelsey et al. 1998). Unfortu\u00adnately, \nthe question of whether a set of constructs can support other constructs is not always easy to answer. \nConsider whether continuations can express (Felleisen 1991) exceptions. The answer is that continuations \nplus state can obvi\u00adously implement exceptions but they cannot express exceptions in a language that \nalready has call/cc (Laird 2002; Thielecke 2000; Riecke and Thielecke 1999). The failure boils down to \nthe fact that a program that uses call/cc can interfere with the im\u00adplementation of exceptions using \ncall/cc. A related confusion surrounds the relative expressiveness of call/cc, shift,and control. It \nis well understood (Gasbich\u00adler and Sperber 2002) that de.ning shift and reset in terms of call/cc produces \na shift with incorrect space complexity; continuation tails get captured by the call/cc encoding when \nthey would not be captured by a direct implementation of shift. It is less widely noted that the Danvy \nand Filinski (1990) imple\u00admentation of call/cc using shift, (. (f) (shiftk (k (f (. (x) (shiftc (k x))))))) \nhas a similar problem. In particular, their implementations turns ((. (c) ((call/cc call/cc) c)) (call/cc \ncall/cc)) into an in.nite loop of unbounded size, instead of bounded size, because prompts inserted by \nshift pile up. Similarly, the simula\u00adtions of control0 using shift by Shan (2004) and Kiselyov (2005a) \nare extensionally correct, but do not have the expected space complexity, again because prompts can pile \nup when using the simulated control0. Certainly, some control operators can be implemented in terms of \nsimpler control operators, especially when the simpler operators can be hidden to prevent external interference. \nThe goal of our work,however,is not to implement a minimal set of operators for the core of a run-time \nsystem. Instead, our goal is to specify an expressive set of operators for all PLT Scheme programmers, \nnot just to privileged modules. We consider it imperative that these operators smoothly function with \nthe already existing operators and that they do not violate the existing operators expected behaviors. \nProgrammers can thus freely compose all of the constructs. This goal drives our speci.cation to include \ndynamic-wind and call/cc as primitives, and to build on a form of prompts that accommodates exception \nhandling (Sitaram 1993). In doing so, we help to .ll a large gap between the frontiers of theory and \npractice: Dybvig et al. (2006) provide a thorough and up-to-date account of the theory and implementation \nof delimited continuations, but they note in closing that a complete account for a production language \nmust include exceptions and dynamic-wind.  Gasbichler and Sperber (2002) produced a direct implementa\u00adtion \nof shift and reset for Scheme48 (Kelsey and Rees 2007). Their work has not yet become part of the Scheme48 \ndistribution, partly because the interaction with dynamic bind\u00ading, exceptions, and dynamic-wind was \nnot worked out.2   3. Intuition, Speci.cation, and Rationale Adding delimited and composable continuations \nto PLT Scheme involves four aspects: the actual linguistic mechanism of capturing and applying such \ncontinuations;  the interaction with the existing dynamic-binding mechanism;  its use to implement \nan exception handling mechanism; and  the interaction with conventional, non-composable continua\u00adtions \nand the dynamic-wind mechanism.  All of this is subject to the constraint that existing constructs must \nrespect the control delimiter in the proper manner, while delimited and composable continuations must \nalso respect the existing con\u00adstructs intended guarantees. This section develops the intuition behind \nthe revised imple\u00admentation of control operators in PLT Scheme. Since intuition can be deceiving, we \nuse stylized pictures that easily map to an exe\u00adcutable reduction semantics (Matthews et al. 2004) based \non eval\u00aduation contexts. Most programmers intuit a program s execution as processing one expression at \na time, where some combination of a stack and 2 Michael Sperber, personal communication, 2007. program \ncounter speci.es how to continue with the expression s re\u00adsult. A programmer using a functional language \nfurther understands that this deconstruction happens at the expression level: evaluating a sub-expression, \nas opposed to calling a function, pushes onto the evaluation stack: (v1 (((. (x) x) v3) v2)) = ((. (x) \nx) v3) In the above picture, the expression to evaluate is shown in a box, and the chain of circles for \nthe context represents the current continuation. In each circle, [] indicates where a computed value \nis used in the continuation. This picture of an expression and continuation corresponds di\u00adrectly to \nthe usual way of de.ning a language with a reduction se\u00admantics, where evaluation is driven by a context \ngrammar E: e ::= x | v | (ee) v ::= (. (x) e) E ::= [] | (Ee) | (vE) E1[((. (x1) e1) v1)] E1[e1{v1/x1}] \nFormally, then, the continuation is the E1 that surrounds the cur\u00adrent redex, and an evaluation step \nmanipulates the redex term and continuation. Pictorially, an evaluation corresponds to manipulat\u00ading \nthe expression box and continuation chain: ((. (x) x) v3) Most reduction rules adjust only the expression \nbox and the contin\u00aduation frame just above it, but reduction rules for control operators may manipulate \nthe whole chain. 3.1 Continuations and Prompts In pictures, a call/cc operation that captures the current \ncontin\u00aduation copies the continuation chain into the redex box: v3) (call/cc(. (k) (k v3))) Applying \na captured continuation replaces the entire current contin\u00aduation with a captured one, .lling the bottommost \n[] of the applied continuation with a given value:  v3) (v3 v2) Formally, we model call/cc by extending \nthe set of values to include captured continuations, marked with a cont wrapper: v ::= ... | call/cc| \n(contE) E1[(call/cc(. (x1) e1))] E1[e1{(contE1)/x1}] [call/cc1] E1[((contE2) v1)] E2[v1] [cont1] As \nan alternative to call/cc, we could add a call/comp oper\u00adation to capture a composable continuation that \nextends the current continuation when applied, instead of replacing it:  (v3 v2) v ::= ... | call/comp| \n(compE) E1[(call/comp(. (x1) e1))] [call/comp2] E1[e1{(compE1)/x1}] E1[((compE2) v1)] E1[E2[v1]] [comp2] \nWe designate a composable continuation in pictures by placing an arrow at its top. The formal semantics \nuses comp instead of cont. Realistic implementations do not provide composable continua\u00adtions in quite \nthis way, however. In a realistic continuation, the ini\u00adtial frame terminates the computation, perhaps \nby exiting a process at the OS level, so that composition is not useful. Useful composi\u00adtion requires \na way to delimit the captured continuation, so that it does not include the process-terminating frame. \nOne way to delimit a continuation is to include a special kind of continuation node, a prompt (represented \nby %), that determines the end of the chain: ((call/comp(. (k) (k v3)))) ( v3) e ::= ... | (%e) E ::= \n... | (%E) E1[(%E2[(call/comp(. (x1) e1))])] [call/comp3] E1[(%E2[e1{(compE2)/x1}])] where E2 . E3[(%E4)] \nfor any E3, E4 In addition to enabling composable continuations, the delimit\u00ading effect of prompts on \nnon-composable continuations can help programmers create composable abstractions. For example, a pro\u00adgrammer \ncan wrap a prompt around a callback procedure, so that the callback s implementation can use continuations \nwithout gain\u00ading access to the dynamic context of the actual call. One such ex\u00adample is the call to eval \nin the implementation of a read-eval\u00adprint loop (REPL). It is a callback that should not allow access \nto (or be affected by) the implementation of the REPL (Felleisen 1988). As we consider the interaction \nof prompts with other con\u00adtrol operations, we want to ensure that this encapsulation property of prompts \nis preserved. Non-composable continuations can be expressed in terms of composable continuations if we \nadd an abort mechanism to the lan\u00adguage. Although abort is often bundled together with the capture operation \n(Felleisen 1988; Danvy and Filinski 1990; Dybvig et al. 2006), we provide it separately in anticipation \nof its interaction with other operations, especially dynamic-wind.The abort opera\u00adtor drops the current \n(delimited) continuation, substituting a given value in its place: (v1 v3) (abortv3) v ::= ... | abort \nE1[(%E2[(abortv1)])] E1[v1] [abort4] where E2 . E3[(%E4)] for any E3, E4 With respect to the many composable \ncontrol operators in the literature, we have opted for a variant where capture does not include the delimiting \nprompt, and composition does not introduce a prompt. Previous work explores the design space related \nto this choice in depth (Shan 2004; Kiselyov 2005a; Biernacki et al. 2006; Dybvig et al. 2006); when \ntaking into account space complexity, only the design that does not include or add a prompt is known \nto express the others (Dybvig et al. 2006). In summary, our primitives for delimited control include \nprompts, aborting to a prompt, capturing a continuation up to a prompt, and composing the current continuation \nwith a captured continuation. 3.2 Dynamic Binding via Continuation Marks For bindings that are associated \nwith a dynamic context instead of a lexical context, a delimited continuation should capture a corre\u00adsponding \ndelimited set of dynamic bindings (Kiselyov et al. 2006). PLT Scheme supports such dynamic bindings through \ncontinua\u00adtion marks (Clements et al. 2001). A distinguishing feature of con\u00adtinuation marks is that they \nprovide a particular guarantee about space consumption for bindings added in tail position with respect \nto existing bindings. This extra facet of continuation marks makes them suitable for use in debugging \ninstrumentation (Clements et al. 2001), security checks (Clements and Felleisen 2004), and redun\u00addant \ncontract elimination (Herman et al. 2007) in languages that guarantee tail recursion. As the name suggests, \na continuation mark is intuitively at\u00ad tached to a continuation frame. Each mark v7 v8 pairs a key v7 \nwith a value v8, and each continuation frame can have any num\u00adber of marks with distinct keys.3 More \nprecisely, a frame s marks are associated with its []; the pictures work best when we draw a frame s \nbindings on the node below it: } so wcmdoes not immediately wrap wcm v ::= ... | current-marks| cons| \n(listv ...) w ::= ((vv) ...) E ::= M | (wcmwM) M ::= [] | (Ee) | (vE) | (%E) E1[(current-marksv1)] \nE1[v2] [marks5] where v2 = [[E1, v1, (list)]]marks [[[], v1, e2]]marks = e2 [[(wcm(... (v1 v2) ...) E1), \nv1, e2]]marks = [[E1, v1, (consv2 e2)]]marks [[(wcmw E1), v1, e2]]marks = [[E1, v1, e2]]marks where v1 \n. Dom(w) ... completed later in .gure 1 ... As illustrated above, a current-marks procedure returns \nthe list of all bindings in the current context for a given key, starting with the nearest binding. The \ncall/cm procedure adds or replaces a binding in the current continuation s immediate frame: 3 The subscripts \non v7 and v8 are arbitrary, but meta-variables with the same subscript tend to play the same role across \nall examples.  v7 v8 (call/cm  (call/cm v10 v11 v7 v12 (. () (. () e1)) (call/cm v7 v12 (. () e1)))) \n v ::= ... | call/cm E1[(wcm((v1 v2) ...) (call/cmv3 v4 (. () e1)))] [wcm-add6] E1[(wcm((v1 v2) ... \n(v3 v4)) e1)] where v3 . (v1 ...) E1[(wcm(... (v3 v5) ...) (call/cmv3 v4 (. () e1)))] [wcm-set6] E1[(wcm(... \n(v3 v4) ...) e1)] E1[(call/cmv1 ...)] [wcm-intro6] E1[(wcm() (call/cmv1 ...))] where E1 . E2[(wcm(...) \n[])] for any E2 Since call/cm replaces any existing binding instead of creating a new one, inserting \ncall/cm calls with a .xed number of keys does not change the asymptotic space consumption of a program. \nNaturally, capturing a delimited sequence of continuation frames also captures the marks associated with \neach frame. The marks as\u00adsociated with the delimiting prompt frame s [] are included, since they were \nadded inside the prompt:  v7 v10 (v13 v7 v9 ) E1[(%E2[(wcmw (call/comp(. (x1) e1)))])] [call/comp7] \nE1[(%E2[e1{(compE2)/x1}])] where E2 . E3[(%E4)] for any E3, E4 The marks associated with the call/comp \nredex need not be captured, because the redex corresponds to the innermost [] in the captured continuation, \nwhich is .lled with a value when the continuation is composed. That is, at compose time, there is no \nopportunity to call current-marks in the innermost [] of a captured continuation. The marks drawn on \nan outermost captured frame, meanwhile, correspond to the redex frame at composition time. If the compos\u00ading \nredex already has marks, those existing marks must be merged with (or replaced by) marks from the captured \ncontinuation: ( v14) v7 v9  E1[((compE2) v1)] E1[E3[v1]] [comp8] where E3 = [[E2]]wcm [[(wcm() e1)]]wcm \n= e1 [[(wcm((v1 v2) (v3 v4) ...) e1)]]wcm = (call/cmv1 v2 (. () [[(wcm((v3 v4) ...) e1)]]wcm)) ... completed \nlater in .gure 1 ... This merging re.ects the interaction of tail-call guarantees for both continuation \nmarks and our composable continuations. One more detail requires attention: as de.ned, current\u00admarks \ninspects the marks of the complete continuation, poten\u00adtially defeating the encapsulation that is supposed \nto be provided by prompt. Therefore, current-marks must stop at the inner\u00admost prompt: E1[(%E2[(current-marksv1)])] \n[marks9] E1[(%E2[[[E2, v1, (list)]]marks])] where E2 . E3[(%E4)] for any E3, E4 In summary, our primitives \nfor dynamic binding are current\u00admarks and call/cm. Dynamic bindings are captured along with their associated \ncontinuations frames in a natural way; space guar\u00adantees are preserved by capturing and merging bindings \nconsis\u00adtently at the boundaries of continuations. 3.3 Exception Handling Although the Scheme standard \n(Kelsey et al. 1998) does not deal with exceptions, both PLT Scheme and a draft report for Scheme (Sperber \n(Ed.) 2007) include a two-layer design for ex\u00adception handling: A low-level layer provides the mechanism \nfor binding an ex\u00adception handler for a dynamic context. It also supports chaining to the next deeper \nhandler without leaving the dynamic context of the expression that threw the exception, in case the handler \ncan recover from the exception and resume the computation:4 (raisev3) ((. (x) e1) v3) A high-level layer \nis analogous to try catch in Java. It provides the mechanism for dispatching to a speci.c handler based \non the kind of the exception, and also for calling the handler in the context of the catching expression \ninstead of the throwing expression. The latter is the interesting facet: The constructs prescribed in \nthe preceding subsections suf.ce to implement handle, catch,and raise, instead of making exception operators \nprimitive. For the low-level layer, continuation marks support the binding of an exception handler to \na dynamic context, and the list of mark values returned by current-marks supports the implementation \nof chaining. For the high-level layer, prompts and aborts support escaping to the context of an exception\u00adcatching \nexpression. A prompt that is used to short-circuit a computation, however, can interfere with a prompt \nthat is installed by catch:  (v2 v3) To avoid this collision, we can distinguish prompts by using tags, \njust as the balloons above suggest (Sitaram and Felleisen 1990). Then, prompts for orthogonal purposes \nusing distinct tags can be composed in a larger program. To support prompt tags, we change the % form \nto start with a tag expression, and we change call/comp and abort to specify a tag: 4 For simplicity, \nwe ignore details concerning the exception handler that is in effect while running an exception handler, \nthough the draft-standard details .t in our model and implementation.  ) (v1 (call/comp (. (k) (abortv4 \nk)) v5) (abort v4 ) e ::= ... | (%ee) E ::= ... | (%Ee) | (%vE) E1[(%v1 E2[(call/comp(. (x1) e1) v1)])] \n[call/comp10] E1[(%v1 E2[e1{(compE2)/x1}])] where E2 . E3[(%v1 E4)] for any E3, E4 E1[(%v1 E2[(abortv1 \nv2)])] E1[v2] [abort10] where E2 . E3[(%v1 E4)] for any E3, E4 We also change current-marks to require \na prompt tag in addition to a mark key. For getting marks, capturing a continuation, or aborting, a prompt \ntag acts as a kind of capability: the current continuation must include a prompt using the tag. Along \nthe same lines as distinguishing different kinds of prompts, adding an abort handler to % helps distinguish \nnormal returns from aborts (Sitaram 1993): ((. (x) e1) v3) e ::= ... | (%eee) E ::= ... | (%Eee) | (%veE) \n| (%vEv) E1[(%v1 E2[(abortv1 v2)] v3)] E1[(v3 v2)] [abort11] where E2 . E3[(%v1 E4 v4)] for any E3, \nE4, v4 Abort handlers serve a more general purpose than implementing catch. For example, the reset half \nof a shift reset (Danvy and Filinski 1990) can be implemented by using % andanabort han\u00addler that re-installs \nthe prompt before applying the abort argument. This pattern leads to implementations of shift, reset, \ncon\u00adtrol,and prompt that work sensibly together, just as in Kise\u00adlyov s simulation (Kiselyov 2005b); \nsee the control.ss library distributed with PLT Scheme for details. Prompt tags and handlers can be implemented \nin terms of prompts without tags and handlers, but the untagged prompt oper\u00adators must be hidden from \napplication programmers (Sitaram and Felleisen 1990). Thus, from a programmer s perspective, tagged prompts \nwith handlers act as the primitives. Fortunately, these primitives easily express other control operators \nwith distinguished prompts (Gunter et al. 1995; Queinnec and Serpette 1991; Hieb and Dybvig 1990); again, \nsee the control.ss library for details. De.ning exception handling in terms of tagged prompts and continuation \nmarks leads to the right interaction of exception han\u00addlers and delimited control: delimited continuations \ncapture (only) exception handlers installed within the delimited region; a program cannot directly access \nan exception handler beyond the prompts whose tags are accessible; and exception-handler chaining uses \nthe chain in place at the time that an exception handler is called, as opposed to the chain in place \nwhen the exception handler is bound. The only way that exception handling needs further primitive support \nis to establish a speci.c protocol for exceptions. That is, to allow primitive operations to raise exceptions, \na mark key must be speci.ed for binding handlers via handle.The catch form then can be implemented using \nhandle and its own private prompt tag. In addition, a default prompt tag might be speci.ed as the target \nfor escapes by a built-in default handler: (handlee1 (. (x) e2)) = (call/cm handle-mark-key(. (x) e2) \n(. () e1)) (catche1 (. (x) e2)) = (%catch-tag (handlee1 (. (x) (abort catch-tag x))) (. (x) e2)) (raisev1) \n= (default-exn-handler (fold(. (v h) (h v)) v1 (current-marks handle-mark-key))) In summary, we have \nno need to introduce speci.c primitives for exceptions. In support of exceptions and other abstractions \nbuilt with delimited-control operators, however, we add tags and abort handlers as primitive features \nof prompts.  3.4 Dynamic Wind When interacting with external processes, a portion of a computa\u00adtion \nmay need to modify the state of the world on entry to, and on exit from, a computation (Friedman and \nHaynes 1985). For exam\u00adple, a computation may depend on a .le that is opened for writing. Scheme s dynamic-wind \nallows such state to be prepared and .nalized when jumping into or out of the middle of a computation \nvia continuations. A dynamic-wind call consumes three thunks: a pre-thunk to prepare state, a body-thunk \nto run the computation, and a post\u00adthunk to .nalize state. In the absence of continuation applications, \nthe pre-thunk is run for its side-effect, the body is run to obtain a result for the dynamic-wind call, \nand then the post-thunk is run for its side-effect before returning from the dynamic-wind. When a computation \nwrapped by a dynamic-wind is aborted, then the corresponding post thunk is executed. Similarly, when \na continuation application resumes a computation that is wrapped by dynamic-wind, then the corresponding \npre-thunk is run. Pictorially, we can represent pre-and post-thunks in a continua\u00adtion as spurs on a \ndw node that is produced by a dynamic-wind call. Aborting a computation runs spurs on the right, in the \norder that they are encountered by a line simulating the abort:  another chain). The graphical intuition \ncarries over to our pictures, however, if we juxtapose the source and destination contexts for a continuation \napplication within a single chain. Speci.cally, if we draw the redex box to the right of the current \ncontinuation, instead of below it, and if we outline the part of the current and target con\u00adtinuations \nthat are the same, then we can infer the Schemer s tree: Applying a continuation runs through the left \nspurs: ( v3) e2 Before pinning down more precisely what it means to run a spur, there is an additional \nfacet of Scheme s dynamic-wind to con\u00adsider. Suppose that a computation involving an open .le itself \nuses continuation jumps internally. Since the jumps are con.ned within the computation that uses the \n.le, the .le should not be closed and then re-opened (which can have any number of externally visible \neffects) for the internal jumps. Given this background, we can now restate our goal for com\u00adbining abort \nand composable continuations with call/cc and dynamic-wind: they must interact so that the programmer \ns in\u00adtended effects are paired with the intended computations, no matter how the computations are composed. \nPrompts provide a good way to think about this problem, and the control .lters of Hieb et al. (1994) \nprovide dynamic-wind-like behavior with delimited continuations. The designers of Scheme, however, were \ncon.ned to a language without prompts; in extend\u00ading PLT Scheme, in turn, we are con.ned by the existing \ncode base to provide call/cc and dynamic-wind in a way that is con\u00adsistent with Scheme. To make use of \ndynamic-wind without prompts, Scheme programmers envision their computation as a tree, where a con\u00adtinuation \napplication jumps from one leaf in the tree to another: When such a jump occurs, the pre-and post-thunks \nof the common part of the tree are ignored; only those in the different parts are run. The Scheme programmer \ns tree does not .t the picture of eval\u00aduation that we have been using (i.e., evaluation from one chain \nto That is, continuation application has to compare the current (up to the prompt) continuation and target \ncontinuation to see whether they haveacommon pre.x. Still, the graphical identity re.ected by the dotted \nbox is not quite the same identity as the tree nodes in a Scheme programmer s intuition. The tree nodes \ncorrespond to frame creations, not to frames that happen to be textually equivalent. In particular, two \ndw frames might have the same pre-and post-thunks, but correspond dynamically to opening different .les. \nTo enable the detection of dynamically equivalent dw frames, the evaluation of dynamic\u00adwind must generate \nan identity for the frame, which we draw as a variable in the frame. Evaluation of a continuation jump \ncan then use the identities of dw frames to determine sharing: v3) Without composable continuations, \na dw frame with a speci.c identity always appears at most once in a continuation, which simpli.es the \ncomparison for common chains. With composable continuations, however, a programmer can capture a group \nof dw frames and then re-assemble them with multiple instances and different intermediate frames: Should \nthese continuations be treated the same or different when jumping from one to the other? Treating them \nas different turns out to be impractical, because it can expose compiler optimizations. That is, a compiler \nmight optimize (+ 12) to 3; if frames are re\u00adally compared at the level of their content, then such optimization \ndifferences become detectable within the language (which is gen\u00aderally against the spirit of optimizations). \nOur solution is to make comparison consider only the dw frames when determining con\u00adtinuation sharing, \nso no pre-or post-thunks would execute when jumping from one of the above continuations to the other. \nOnly pre.xes with the same dw frames are a match. For exam\u00adple, when jumping from the .rst to the second \nof the following continuations:5  both of the post-thunks (e4 and e2) in the left-hand continuation \nare run, and then the pre-thunk (e3) of the right-hand continuation is run. Even though both continuations \nhave a dw frame labelled x2, the frame is not in a common pre.x, even ignoring non-dw frames. In particular, \nthe pre-and post-thunks associated with the x2 frame may behave differently depending on side-effects \nfrom the x1 frame s thunks, so the x1 frame s thunks should be run. Having determined the way that gray \narrows are drawn, we know which pre-and post-thunks are expected to run. We must still say exactly how \nthey are to be run, and our speci.cation must address three points: Each pre-or post-thunk should be \nexecuted in the dynamic environment of its dw frame, which may not match either the source or target \ncontinuations. For example, in  In addition to installing thunks for the jump of continuations, dynamic-wind \nmust evaluate the pre-thunk on normal entry and the post-thunk on normal exit. As always, the pre-thunk \nmust be evaluated in a context that does not include its dw frame, and the same for the post-thunk. To \naddress these points, we de.ne dynamic-wind and continu\u00adation application in a way that shifts pre-and \npost-thunks into the usual redex position, for which we are already de.ning dynamic binding and continuation \nmanipulation. We need three rules for dynamic-wind independent of con\u00adtinuations. The .rst turns a dynamic-wind \ninto a dw, generating an identi.er for the dw, and shifts the pre-thunk into the redex: At this point, \na dw expression has been created, but it is a sub\u00adexpression in a continuation, as opposed to being a \ncontinuation frame directly, so it does not yet create spurs in the continuation. Thus, the pre-thunk \nis run without spurs for its corresponding dw form. The generated begin continuation frame eventually \ndiscards the result from the pre-thunk, since it is executed only for its effect. As the pre-thunk produces \na value suppose that e1 locally reduces to v1, which is discarded the dw form shifts into its own frame \nwith spurs, and the body expression e2 becomes the redex:  the redex position: e2 v2 e3 see formal \nrule [dw-result] in .gure 1 below Again, the post-thunk is run in a context without spurs from its own \ndw. The value from the post-thunk is discarded via the generated begin expression. Finally, the rules \nfor continuation jumps with dw rely on an inferred gray arrow to determine the .rst pre-or post-thunk \nto run. Given this .rst thunk, the continuation and redex are transformed to evaluate the thunk s body \nin the correct dynamic context. Since e2 should be executed in a context where v7 is dynamically mapped \nto v10, whereas e4 should be evaluated in a context where v7 is mapped to v11. A pre-or post-thunk may \nitself capture a continuation, abort, or apply a continuation. Although the current Scheme standard leaves \nthis case unspeci.ed (Kelsey et al. 1998), both the PLT Scheme documentation and a recent draft standard \n(Sperber (Ed.) 2007) specify the behavior of continuation jumps in pre\u00adand post-thunks. 5 To arrive at \nthis corner case, suppose that the continuation e3 e4 is composed in the context ([] v2) with a value \nthat captures a non\u00adcomposable continuation, then composed again in (dw x1 e1 (v1 []) e2), with the next \nstep as a jump to the non-composable continuation. there are three forms that trigger jumps, we end up \nwith three new pictures: one for aborting, one for applying a composable continuation, and one for applying \na non-composable continuation. If aborting triggers a post-thunk, then the transformation trims the continuation \nthrough the dw frame, and otherwise resembles a normal dynamic-wind return:  e2 see formal rule [abort-post] \nin .gure 1 below The original abort is preserved in the transformation, so that it continues when the \npost-thunk completes. Eventually, when no pre\u00ador post-thunks need to run, our earlier rule completes \nthe abort. If applying a composable continuation involves pre-thunks, the transformation composes the \ncontinuation down to the dynamic\u00adwind frame. A generated begin frame composes the rest of the continuation \nwithin a dw form: see formal rule [comp-pre] in .gure 1 below Again, a continuation application is preserved \nin the transformation so that the composition continues after pre-thunk is .nished. Calling a non-composable \ncontinuation may involve either a pre-or post-thunk. The transformation partially adjusts the current \ncontinuation, as in the composable case. Unlike the composable case, however, the target continuation \nitself is not adjusted. Instead, further evaluation relies on recomputing the shared tree to deter\u00admine \nthe next thunk to run: =  see formal rule [cont-post] in .gure 1 below In the picture, stands for the \ncontinuation application in the redex box. Essentially the same pictorial rule works for pre-thunks, \nwhere captured continuation frames before the pre-thunk dw,ifany, are copied to the current continuation. \nOmitted from the last picture is the detail that a non-composable continuation must embed a prompt tag \nas well as a chain of contin\u00aduation frames, because sharing must be determined with respect to a particular \nprompt. See .gure 1 for the complete rule. In summary, direct support for Scheme-style dynamic-wind implies \ndirect support for non-composable continuations, because the latter implies an algorithm for selecting \npre-and post-thunks that does not fall out from the other operations. At the same time, the speci.cation \nof continuation aborts and composition must change so that these thunks are executed consistently. De.ning \nabort to trigger post-thunks, in turn, explains why we kept the abort operation separate from continuation \ncapture: merely cap\u00adturing a continuation should not require execution of pre-or post\u00adthunks.  4. Combined \nModel Figure 1 contains formal reduction rules corresponding to the intu\u00aditive rules and implementation \ndescriptions of the previous section. The model is actually formulated in PLT Redex (Matthews et al. \n2004), which is an executable domain-speci.c language for reduc\u00adtion semantics. The model comes with \na substantial test suite, de\u00adrived from PLT Scheme s test suite for control operators.6 To avoid transcription \nerrors, the typeset form of the model in .gure 1 is mechanically derived from the executable, tested \nspeci.cation. The portion of the model included in .gure 1 omits standard rules, such as \u00dfv-reduction. \nThe reduction relation is -. ,which is de.ned by [wcm-intro] and the rule e1 . e2 . E1[e1] -. E1[e2]. \nAll other reduction rules de.ne the local reduction relation .. A few aspects of the grammar deserve \nsome explanation. Speci.cally, the grammar of expressions e is recursive via m, thus constraining expressions \nso that a wcm form never immediately wraps another wcm form. Contexts are similarly constrained, but \nwith a further distinction between arbitrary evaluation contexts E and contexts W that have no dw frames. \nFurthermore, D is a con\u00adtext that is either empty or ends with a dw frame; it helps ensure deterministic \npattern matching for shared dw chains. The subset of values u identi.es the primitives that need an enclosing \nwcm frame to reduce; u is referenced by the [wcm-intro] reduction rule. The SAMEDWS and NOSHARED metafunctions \nguide the rules for aborts and continuation jumps. Speci.cally, SAMEDWS com\u00adpares two continuations to \ncheck whether they have the same dw 6 Available from http://www.cs.utah.edu/plt/delim-cont/.     \n  (%v1 v2 v3) v2 [prompt-v] (beginv e1) e1 [begin-v] (dynamic-wind(. () e1) (. () e2) (. () e3)) [dw] \n(begine1 (dwx1 e1 e2 e3)) where x1 fresh (dwx e1 v1 e3) (begine3 v1) [dw-v] (%v1 W2[(abortv1 v2)] v3) \nwhere W2 . E[(%v1 E v)] (v3 v2) [abort] (dwx1 e1 W2[(abortv1 v2)] e2) [abort-post] (begine2 (abortv1 \nv2)) where W2 . E[(%v1 E v)] (%v2 E2[(wcmw1 (call/compv1 v2))] v3)(%v2 E2[(wcmw1 (v1 (compE2)))] v3) \nwhere E2 . E[(%v2 E v)] [call/comp] ((compW1[(dwx1 e1 E2 e2)]) v1)[[W1[(begine1 (dwx1 e1 ((compE2) v1) \ne2))]]]wcm [comp-pre] ((compW1) v1) [[W1[v1]]]wcm [comp] (%v2 E2[(wcmw1 (call/ccv1 v2))] v3) [call/cc] \n(%v2 E2[(wcmw1 (v1 (contv2 E2)))] v3) where E2 . E[(%v2 E v)] (%v2 D2[E3[(dwx1 e1 W5[((contv2 D6[E4]) \nv1)] e2)]] v3) [cont-post] (%v2 D2[E3[(begine2 ((contv2 D6[E4]) v1))]] v3) where D2[E3] . E[(%v2E v)], \nSAMEDWS(D2, D6), W5 . E[(%v2E v)], NOSHARED(E3[(dwx1 e1 W5e2)], E4) (%v1 D2[W3[((contv1 k1) v2)]] v3) \n[cont-pre] (%v1 D6[W4[(begine1 (dwx1 e1 ((contv1 k1) v2) e2))]] v3) where k1 = D6[W4[(dwx1e1E5 e2)]], \nD2[W3] . E[(%v1 E v)], SAMEDWS(D2, D6), NOSHARED(W3, W4[(dwx1 e1 E5 e2)]) (%v1 D2[W3[((contv1 D6[W4]) \nv2)]] v3) [cont] (%v1 D6[W4[v2]] v3) where D2[W3] . E[(%v1 E v)], SAMEDWS(D2, D6), NOSHARED(W3, W4) (%v2 \nE2[(current-marksv1 v2)] v3) [marks] (%v2 E2[[[E2, v1, (list)]]marks] v3) where E2 . E[(%v2 E v)] (wcmw \nv1) v1 [wcm-v] (wcm((v1 v2) ... (v3 v4) (v5 v6) ...) [wcm-set] (call/cmv3 v7 (. () e1)))(wcm((v1 v2) \n... (v3 v7) (v5 v6) ...) e1) (wcm((v1 v2) ...) (call/cmv3 v4 (. () e1))) [wcm-add] (wcm((v1 v2) ... \n(v3 v4)) e1) where v3 . (v1 ...) E1[(u1 v1 ...)] E1[(wcm() (u1 v1 ...))] [wcm-intro] where E1 . E[(wcmw \n[])] e ::= m | (wcmwm) m ::= x | v | (ee ...) | (beginee) | (%eee) | (dwxeee) v ::= (listv ...) | (. \n(x ...) e) | (contvE) | (compE) | dynamic-wind| abort| current-marks | cons| u u ::= call/cc| call/comp| \ncall/cm w ::= ((vv) ...) E ::= W | W[(dwxeEe)] W ::= M | (wcmwM) M ::= [] | (v ... We ...) | (beginWe) \n| (%vWv) D ::= [] | E[(dwxe [] e)]  Figure 1. Combined grammar and reduction rules frames with the same \ntags; NOSHARED compares two continua\u00adtions to make sure that they do not have a common dw pre.x.  5. \nImplementation PLT Scheme version 360 included the .rst release of our new set of control operators. \nThat release contained several .aws: exception-handler chaining was determined at handler-installation \ntime instead of exception-raise time, and continuation jumping did not properly handle the subtleties \nof using control operators in dynamic-wind pre-and post-thunks. Aside from one detail discussed below, \nversion 370 (the current release) of PLT Scheme faithfully implements the model and passes its tests. \nNaturally, reconciling the tests of the model and implementation exposed a bug that we would not have \ndiscovered otherwise. When composing a continuation that was captured in a dynamic-wind pre-or post-thunk, \nand when the captured continuation includes a different dw frame that is also still in the current continuation \nat composition time, the implementation failed to run the captured pre-thunk. Only careful inspection \nof the model s behavior allowed us to see that the implementation s result was incorrect. The architecture \nof our implementation is similar to that of Dy\u00adbvig et al. (2006). To achieve the correct space complexity \nfor continuation composition, our implementation uses continuation marks to discover and eliminate empty \ncontinuations for the meta\u00adcontinuation. Continuation marks, in turn, are implemented with a cache in \neach continuation frame. This cache enables O(1) amor\u00adtized access to the .rst mark for a given tag. \nThis .rst-mark opera\u00adtion is used to ef.ciently .nd a prompt for a given tag. To simplify the preceding \npresentation, we have not used the actual names of primitives in PLT Scheme. The table in .gure 2 provides \na mapping from the paper forms to the implemented forms. The control.ss library distributed with PLT \nScheme provides more succinct names for combinations of these primitives. In addition to the name changes, \nthe actual implementation uses a distinct class of values for prompt tags, and it de.nes a default prompt \ntag. The make-continuation-prompt-tag and default-continuation-prompt-tag procedures produce fresh and \ndefault prompt tags, respectively. The latter is the de\u00adfault for call-with-current-continuation s second \nar\u00adgument, and a prompt using the default tag wraps every top-level evaluation; thus, Scheme programmers \ndo not need to change ex\u00adisting code that uses continuations. The default prompt tag is also part of \nthe built-in protocol for exception handling, in that the default exception handler aborts to the default \ntag after printing an error message. Consistent with this protocol, when an abort handler is omitted \nfor call-with\u00adcontinuation-prompt, the default abort handler accepts a single thunk argument that it \napplies under a new prompt (using the same prompt tag and the same default prompt handler). The continuation-mark-set-first \nprocedure is like current-marks, but it returns only the .rst element of the list. Besides .nding prompts \ninternally, this operation is useful for accessing dynamic bindings (with amortized constant-time access) \nfor the common case where only the current binding is needed. Our current implementation differs from \nthe model in one detail and by design: capturing a continuation preserves marks in the im\u00admediate continuation \nframe, instead of omitting them as prescribed in section 3.2. PLT Scheme provides a continuation-marks \nprocedure that extract marks from a given continuation, instead of from the current continuation, which \nmakes captured immediate marks accessible when they would be inaccessible otherwise. Al\u00adthough the continuation-marks \nprocedure has been at part of PLT Scheme for years, we have not yet found a use for it which suggests \nthat the operation should be removed, and that our implementation should be adjusted to match the model. \nin paper in PLT Scheme % call-with-continuation-prompt body is a thunk as the .rst argument; only the \n.rst argument is required; an abort handler can accept multiple values abort abort-current-continuation \naccepts any number of abort values call/cc call-with-current-continuation only the .rst argument is required \ncall/comp call-with-composable-continuation only the .rst argument is required call/cm with-continuation-mark \nbody is an expression instead of a thunk current-marks current-continuation-marks only the .rst argument \nis required; also: continuation-mark-set-first Figure 2. Operators in paper versus PLT Scheme (define \n(evaluate-from-port port complete-program?) (define tag (default-continuation-prompt-tag)) (define (loop) \n (let ([expr (get-next-expression port)]) (unless (eof-object? expr) ; Delimit each top-level evaluation: \n(call-with-continuation-prompt (. () (eval expr)) tag (if complete-program? ; Load mode: don't continue \n(. args (abort-current-continuation tag void)) ; REPL mode: run thunk and continue (. (thunk) (call-with-continuation-prompt \nthunk tag)))) (loop)))) ; Catch possible escape in load mode: (call-with-continuation-prompt loop)) \n Figure 3. Evaluation for REPL and Load PLT Scheme provides pre-emptive threads in addition to con\u00adtinuations. \nThreads can be mostly implemented with continuations, but not without interference from many other constructs \n(Gasbich\u00adler et al. 2003). Fortunately, threads that work with non-composable continuations also accommodate \nprompts and composable contin\u00aduations with few additional considerations. Indeed, adding prompts to PLT \nhelped remove a restriction on moving continuations among threads. Nevertheless, one facet of our thread \nimplementation in\u00adteracts badly with delimited continuations: dynamic bindings cre\u00adated with parameterize, \nwhich are inherited by newly created threads, are not consistently delimited by prompts. We expect to \n.x this problem, which stems from our current data-structure choice. 6. Experience Prompts help isolate \na REPL implementation from the expressions that it evaluates, and vice-versa. A text-based REPL must \nma\u00adnipulate state that implements a text stream; without prompts, a REPL s implementation is complicated \nby the possibility that the state-manipulating code might get captured in a continuation. In DrScheme \ns REPL for graphical programs, the problem is even worse, because expression evaluation requires a callback \nin a thread that is also used for GUI callbacks. Adding prompts to PLT Scheme allowed us to remove some \nerror-prone code in DrScheme and re\u00adplace it with a straightforward code that is 1/3 as long. We can \nalso more easily experiment with variations of REPL behavior in DrScheme, such as controlling the span \nof captured continuations when multiple expressions are submitted at once to the REPL. The abort protocol \nwith the default prompt tag provides further .exibility in de.ning the escape behavior for interactive \nevaluation. The MzScheme and DrScheme REPLs, for example, wrap evalua\u00adtion in a prompt using the default \ntag, and using a handler that loops to continue evaluation. The .le-loading procedure installs a simi\u00adlar \nprompt around each evaluation, so that a captured continuation does not include the load process; it \nuses an abort handler that re\u00adaborts, however, so that .le loading stops on the .rst exception: see .gure \n3. Exploiting abort handlers in this way for REPLs is far more maintainable than the previously used \ntangle of callbacks. A primary motivation for adding delimited continuations to PLT Scheme was the space \nof possibilities that it opens for improv\u00ading the PLT web server (Krishnamurthi et al. 2007). Servlets \nuse continuations to implement sessions, and such continuations pre\u00adviously captured parts of the driving \nserver process, leading to the same complexity in the server as for REPLs even worse, because the web \nserver is multi-threaded. Indeed, delimited continuations allow the server to handle multiple session-speci.c \nrequests con\u00adcurrently instead of sequentially. Delimited continuations may also enable more composable \nservlets by allowing multiple elements on a web page to be manipulated independently (analogous to multi\u00adple \nthreads), and by allowing servlets to act as .lters for the results of other servlets (analogous to Apache \ns mod gzip compression). Acknowledgements: The authors would like to thank Oleg Kise\u00adlyov and Ken Shan \nfor discussion about different control operators, Jay McCarthy for updates on the PLT web server, John \nClements for discussion on continuation marks and delimited continuations, Michael Sperber and Martin \nGasbichler for information on the Scheme48 implementation of shift and reset, and the anony\u00admous ICFP \n07 reviewers for their comments on the original draft. Matthew would like to thank Huimin Lin for hosting \nhis sabbatical.  References Dariusz Biernacki, Olivier Danvy, and Chung-chieh Shan. On the static and \ndynamic extents of delimited continuations. Science of Compututer Programming, 60(3):274 297, 2006. John \nClements and Matthias Felleisen. A tail-recursive machine with stack inspection. ACM Transactions on \nComputing Systems, 26(6):1029 1052, 2004. John Clements, Matthew Flatt, and Matthias Felleisen. Modeling \nan alge\u00adbraic stepper. In Proc. European Symposium on Programming, number 2028 in Lecture Notes in Computer \nScience, pages 320 334, April 2001. Olivier Danvy and Andrzej Filinski. Abstracting control. In Proc. \nACM Conference on Lisp and Functional Programming, pages 151 160, 1990. R. Kent Dybvig, Simon Peyton \nJones, and Amr Sabry. A monadic frame\u00adwork for delimited continuations. Journal of Functional Programming, \n2006. To appear. Matthias Felleisen. The theory and practice of .rst-class prompts. In Proc. ACM Symposium \non Principles of Programming Languages, pages 180 190, 1988. Matthias Felleisen. On the expressive power \nof programming languages. Science of Compututer Programming, 17(1-3):35 75, 1991. Andrzej Filinski. Representing \nmonads. In Proc. ACM Symposium on Principles of Programming Languages, pages 446 457, 1994. Robert Bruce \nFindler, John Clements, Cormac Flanagan, Matthew Flatt, Shriram Krishnamurthi, Paul Steckler, and Matthias \nFelleisen. DrScheme: A programming environment for Scheme. Journal of Func\u00adtional Programming, 12(2):159 \n182, March 2002. Matthew Flatt. PLT MzScheme: Language manual. Technical Report PLT\u00adTR2007-1-v370, PLT \nScheme, 2007. Daniel P. Friedman and Christopher T. Haynes. Constraining control. In Proc. ACM Symposium \non Principles of Programming Languages, pages 245 254, January 1985. Martin Gasbichler and Michael Sperber. \nFinal shift for call/cc: a direct im\u00adplementation of shift and reset. In Proc. ACM International Conference \non Functional Programming, pages 271 282, 2002. Martin Gasbichler, Eric Knauel, Michael Sperber, and \nRichard A. Kelsey. How to add threads to a sequential language without getting tangled up. In Proc. Workshop \non Scheme and Functional Programming, 2003. Carl Gunter, Didier R\u00b4emy, and Jon Riecke. A generalization \nof exceptions and control in ML-like languages. In Proc. ACM Conference on Func\u00adtional Programming and \nComputer Architecture, pages 12 23, 1995. David Herman, Aaron Tomb, and Cormac Flanagan. Space-ef.cient \ngrad\u00adual typing. In Proc. Trends in Functional Programming, 2007. Robert Hieb and R. Kent Dybvig. Continuations \nand concurrency. In Proc. ACM Symposium on Principles and Practice of Parallel Programming, pages 128 \n136, 1990. Robert Hieb, Kent Dybvig, and Claude W. Anderson, III. Subcontinuations. Lisp and Symbolic \nComputation, 7(1):83 110, 1994. Richard Kelsey, William Clinger, and J. Rees (Eds.). The revised5 report \non the algorithmic language Scheme. ACM SIGPLAN Notices, 33(9), September 1998. Richard A. Kelsey and \nJonathan Rees. Scheme48, 2007. URL http: //s48.org/. Oleg Kiselyov. How to remove a dynamic prompt: static \nand dynamic delimited continuation operators are equally expressible. Technical Report TR611, Indiana \nUniversity Computer Science, 2005a. Oleg Kiselyov. Generic implementation of all four *F* operators: \nfrom control0 to shift, 2005b. URL http://okmij.org/ftp/ Computation/Continuations.html#generic-control. \nOleg Kiselyov, Chung-chieh Shan, and Amr Sabry. Delimited dynamic binding. In Proc. ACM International \nConference on Functional Pro\u00adgramming, pages 26 37, 2006. Shriram Krishnamurthi, Peter Walton Hopkins, \nJay McCarthy, Paul T. Graunke, Greg Pettyjohn, and Matthias Felleisen. Implementation and use of the \nPLT Scheme web server. Higher-Order and Symbolic Com\u00adputation, 2007. To appear. James Laird. Exceptions, \ncontinuations and macro-expressiveness. In Proc. European Symposium on Programming, pages 133 146, 2002. \nJacob Matthews, Robert Bruce Findler, Matthew Flatt, and Matthias Felleisen. A visual environment for \ndeveloping context-sensitive term rewriting systems. In Proc. International Conference on Rewriting Tech\u00adniques \nand Applications, volume 3091 of Lecture Notes in Computer Science, 2004. Christian Queinnec and Bernard \nP. Serpette. A dynamic extent control op\u00aderator for partial continuations. In Proc. ACM Symposium on \nPrinciples of Programming Languages, pages 174 184, 1991. Jon G. Riecke and Hayo Thielecke. Typed exceptions \nand continuations cannot macro-express each other. In Proc. International Colloquium on Automata, Languages \nand Programming, pages 635 644, 1999. Chung-chieh Shan. Shift to control. In Proc. Workshop on Scheme \nand Functional Programming, pages 99 107, 2004. Dorai Sitaram. Handling control. In Proc. ACM Conference \non Program\u00adming Language Design and Implementation, pages 147 155, 1993. Dorai Sitaram and Matthias Felleisen. \nControl delimiters and their hierar\u00adchies. Lisp and Symbolic Computation, 3(1):67 99, 1990. Michael Sperber \n(Ed.). The revised5.97 report on the algorithmic language Scheme, 2007. Hayo Thielecke. On exceptions \nversus continuations in the presence of state. In Proc. European Symposium on Programming, pages 397 \n411, 2000. \n\t\t\t", "proc_id": "1291151", "abstract": "<p>Operators for delimiting control and for capturing composable continuations litter the landscape of theoretical programming language research. Numerous papers explain their advantages, how the operators explain each other (or don't), and other aspects of the operators' existence. Production programming languages, however, do not support these operators, partly because their relationship to existing and demonstrably useful constructs - such as exceptions and dynamic binding - remains relatively unexplored.</p> <p>In this paper, we report on our effort of translating the theory of delimited and composable control into a viable implementation for a production system. The report shows how this effort involved a substantial design element, including work with a formal model, as well as significant practical exploration and engineering.</p> <p>The resulting version of PLT Scheme incorporates the expressive combination of delimited and composable control alongside dynamic-wind, dynamic binding, and exception handling. None of the additional operators subvert the intended benefits of existing control operators, so that programmers can freely mix and match control operators.</p>", "authors": [{"name": "Matthew Flatt", "author_profile_id": "81100490544", "affiliation": "University of Utah, Salt Lake City, UT", "person_id": "PP39045354", "email_address": "", "orcid_id": ""}, {"name": "Gang Yu", "author_profile_id": "81337495019", "affiliation": "Chinese Academy of Sciences, Beijing, China", "person_id": "PP37044966", "email_address": "", "orcid_id": ""}, {"name": "Robert Bruce Findler", "author_profile_id": "81100028925", "affiliation": "University of Chicago, Chicago, IL", "person_id": "PP14022884", "email_address": "", "orcid_id": ""}, {"name": "Matthias Felleisen", "author_profile_id": "81100323458", "affiliation": "Northeastern University, Boston, MA", "person_id": "P194758", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291178", "year": "2007", "article_id": "1291178", "conference": "ICFP", "title": "Adding delimited and composable control to a production programming environment", "url": "http://dl.acm.org/citation.cfm?id=1291178"}