{"article_publication_date": "10-01-2007", "fulltext": "\n Bidirectionalization Transformation Based on Automatic Derivation of View Complement Functions Kazutaka \nMatsuda Zhenjiang Hu Keisuke Nakano Makoto Hamana Masato Takeichi The University of Tokyo Gunma University \nkztk@ipl.t.u-tokyo.ac.jp hamana@cs.gunma-u.ac.jp {hu,ksk,takeichi}@mist.i.u-tokyo.ac.jp Abstract Bidirectional \ntransformation is a pair of transformations: a view function and a backward transformation. A view function \nmaps one data structure called source onto another called view. The corre\u00adsponding backward transformation \nre.ects changes in the view to the source. Its practically useful applications include replicated data \nsynchronization, presentation-oriented editor development, tracing software development, and view updating \nin the database commu\u00adnity. However, developing a bidirectional transformation is hard, because one has \nto give two mappings that satisfy the bidirectional properties for system consistency. In this paper, \nwe propose a new framework for bidirectionaliza\u00adtion that can automatically generate a useful backward \ntransforma\u00adtion from a view function while guaranteeing that the two trans\u00adformations satisfy the bidirectional \nproperties. Our framework is based on two known approaches to bidirectionalization, namely the constant \ncomplement approach from the database community and the combinator approach from the programming language \ncommu\u00adnity, but it has three new features: (1) unlike the constant comple\u00adment approach, it can deal \nwith transformations between algebraic data structures rather than just tables; (2) unlike the combinator \nap\u00adproach, in which primitive bidirectional transformations have to be explicitly given, it can derive \nthem automatically; (3) it generates a view update checker to validate updates on views, which has not \nbeen well addressed so far. The new framework has been imple\u00admented and the experimental results show \nthat our framework has promise. Categories and Subject Descriptors I.2.2 [Arti.cial Intelligence]: Automatic \nProgramming Program transformation, Program syn\u00adthesis; D.1.1 [Programming Techniques]: Applicative (Functional) \nProgramming; H.2.3 [Database Management]: Language Data manipulation languages, Query languages General \nTerms Languages, Design Keywords Bidirectional Transformation, View Updating, Pro\u00adgram Transformation, \nAutomatic Program Generation, Program Inversion. Permission to make digital or hard copies of all or \npart of this work for personal or classroom use is granted without fee provided that copies are not made \nor distributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. 1. Introduction There are many situations in which one data structure, \ncalled source, is transformed to another, called view,insuch a waythat changes on the view can be transformed \nback to those on the orig\u00adinal data structure. This is called bidirectional transformation,and practical \nexamples include synchronization of replicated data in different formats (Foster et al. 2005), presentation-oriented \nstruc\u00adtured document development (Hu et al. 2004), interactive user interface design (Meertens 1998), \ncoupled software transforma\u00adtion (L\u00a8ammel 2004), and the well-known view updating mech\u00adanism which has \nbeen intensively studied in the database com\u00admunity (Bancilhon and Spyratos 1981; Dayal and Bernstein \n1982; Gottlob et al. 1988; Hegner 1990; Lechtenb\u00a8orger and Vossen 2003). To be concrete, suppose that \nwe have a list of students and professors (the source), and we want to create a view that consists of \nall the students. This view can be de.ned by the following view function. students : Source . View students \n[]= [] students (Student name grade major : ms) =Student name grade major :students ms students (Prof \nname position major : ms) =students ms To develop a bidirectional transformation, in addition to the \nview function one needs to de.ne another function, a backward trans\u00adformation function, which is used \nfor view updating, i.e., re.ects changes on the view (such as modi.cation of students names) to the source. \nThe following function studentsB 1 is a backward trans\u00adformation that accepts a changed view and the \noriginal source and produces a new source. studentsB :(Source \u00d7 View). Source studentsB ([],[]) = [] \n'' ' studentsB (Student ngm: ms,Student ngm: ss) '' ' =Student ngm: studentsB (ms,ss) studentsB (Prof \nnpm:ms,ss) =Prof npm:studentsB (ms,ss)  However, there are several limitations in manually writing a \npair of view function and backward transformation (such as students and studentsB) to develop a bidirectional \ntransformation. First, it is dif.cult to prove that the two functions satisfy the bidirectional property \nand form a bidirectional transformation (Section 2). Sec\u00adond, the consistency of the two functions is \ndif.cult to maintain. A small change in the view function may require a big change in the backward transformation \nfunction. For instance, suppose we want a view that contains only the names of the students who major \nin ICFP 07 October 1 3, 2007, Freiburg, Germany. Copyright &#38;#169; 2007 ACM 978-1-59593-815-2/07/0010. \n. . $5.00 1 The subscript B stands for backward . c Computer Science. While it is easy to give the following \nview func\u00adtion by composing another function with above the view function, it requires more thinking \nto write a backward transformation. cs students =cs . students cs []=[] cs (Student name grade CS :ss)=name \n:cs ss cs ( :ss)=cs ss Third, it is hard to automatically infer permitted changes in the view. Backward \ntransformation functions, such as studentsB,are usually partial functions, disallowing some changes to \nthe view. For example, studentsB does not allow insertion of a new student to the view. When the source \nand the view are huge, it is better to have an inference system for validating view changes rather than \nto directly compute backward transformation until an error message appears. Several methods for automatically \nderiving backward transfor\u00admation functions from view de.nition functions have been pro\u00adposed to overcome \nthese three problems. In the database commu\u00adnity, this issue, known as view updating problem, has been \nstudied for a long time (Bancilhon and Spyratos 1981; Dayal and Bernstein 1982; Gottlob et al. 1988; \nHegner 1990; Lechtenb\u00a8orger and Vossen 2003). One known approach (Bancilhon and Spyratos 1981) is to \ncon\u00adstruct an injective function from the view function so that changes on the image of the injective \nfunction can be re.ected back to its do\u00admain by inversion. To do this, lost information in the view genera\u00adtion \nis gathered as a complement for later backward transformation. Bancilhon and Spyratos proposed the concept \nof view complement function and the method of view updating under constant comple\u00adment. Generally speaking, \nfor a view function from a source to a view f :S . V a view complement function of f is a function from \nthe source to another view (called a complement view) g :S . V ' such that the tupled function (f M g):S \n. (V \u00d7 V ' ) is injective. This view complement function, g, provides the infor\u00admation that does not \nappear in the view generated by f. Then, for an original source s, the updated source s ' corresponding \nto an up\u00addated view v can be calculated by s ' =(f M g)-1(v, g(s)). Therefore, if a view complement function \ng can be derived and the inversion of (f M g)can be calculated, that means we know how to re.ect changes \non the view to the source. Since the derived backward transformation depends on g, we should choose an \nap\u00adpropriate g. For example g = idS is the worst one because the derived backward transformation is de.ned \nonly on the input (s, v) by v =f(s), i.e., no updates are allowed. This approach has been applied to \nsolving the view updating problem in the relational data\u00adbase system (Cosmadakis and Papadimitriou 1984; \nLaurent et al. 2001; Lechtenb\u00a8orger and Vossen 2003). In fact, derivation of view complement functions \nand inversion calculation are simpli.ed in the context of relational databases because views and sources \nare sets of .at tuples, and view functions are queries in a simple form being closed under composition. \nHowever, though tree-structured data, e.g. XML, is now widely used, how to apply the approach to view \nfunctions that can deal with general algebraic data structures such as trees is still an open problem. \nThe challenge is to .nd a suitable form for these view functions such that they not only have enough \ndescriptive power and view complement functions but are suitable for later inversion calculation. Another \napproach, which has received increasing attention in recent years, is to design a set of general combinators \n(Foster et al. 2005; Hu et al. 2004; Meertens 1998) for constructing bigger bidirectional transformations \nby composing smaller ones. A set of primitive bidirectional transformations, each being de.ned by a pair \nof view function and backward transformation, is prepared, and a new bidirectional transformation is \nde.ned by assembling the primitive transformations with a .xed set of general combinators (Section 2.4.2). \nThis approach has proved to be practically useful for domain-speci.c applications, because primitive \nbidirectional transformations for a speci.c application are easily determined, designed, and implemented. \nMoreover, this approach is general and can deal with trees other than relational tables provided that \nsuitable primitive bidirectional transformations on trees are given. However, for an involved application \nor in a more general setting, a lot of primitive bidirectional transformations may need to be prepared, \nand it is still hard to verify whether a pair consisting of a view function and a backward transformation \nforms a (primitive) bidirectional transformation. In this paper, we propose a new bidirectional transformation \nframework that combines the advantages of the above two ap\u00adproaches: automatic bidirectionalization and \nability to deal with tree structures. We follow the combinator approach of keeping sep\u00adarate the design \nof primitive bidirectional transformations and the design of composition methods for gluing smaller transformations, \nbut we borrow the idea of the view complement approach to ob\u00adtain primitive bidirectional transformations \nthat can manipulate ar\u00adbitrary algebraic data structures. The key to our framework is a suitable language \nfor describ\u00ading primitive view functions. It should be suf.ciently powerful to specify various view functions \nover algebraic data structures, sim\u00adple enough for derivation of view complement functions and in\u00adversion, \nand suitable for use as components to be composed with others. We choose a general .rst-order functional \nlanguage and re\u00adquire view functions that are de.ned in the language to be af.ne (each variable is used \nat most once) and in the treeless form (no intermediate data structure is used in the de.nition). In \nfact, this class of functions has been considered elsewhere in the context of deforestation (fusion transformation) \n(Wadler 1990), where treeless functions are used to describe basic computation components. In our framework, \nview complement functions can be automat\u00adically derived from view functions, and the derived view comple\u00adment \nfunctions are suitable for tupling and inversion. Moreover, updatability of views can be represented \nby a regular tree language with which one can statically check whether changes in views are valid or \nnot without really performing backward transformation. We have implemented all the ideas in this paper \nusing a bidirec\u00adtionalizing system for automatically constructing backward trans\u00adformation functions \nfrom view functions. The derived backward transformation function is correct in the sense that it forms \na bidi\u00adrectional transformation with the view function, useful in the sense that all the tracing information \nbetween the source and the view is recorded in such a way that any change in the view element that has \na corresponding element in the source can be re.ected to the source, powerful in the sense that it can \ndeal with bidirectional transforma\u00adtion between arbitrary algebraic data structures such as lists and \ntrees, and equipped with an inference system for validating changes in the view. This paper is organized \nas follows. We start by explaining the basic concepts of bidirectional transformation in Section 2. Then, \nafter presenting an overview of our system in Section 3, we de.ne a language for view de.nition in Section \n4, show how to derive view complement functions in Section 5, explain how to generate backward transformation \nfunctions based on tupling and inversion in Section 6, and give an algorithm for updatability check in \nSec\u00adtion 7. We illustrate the whole bidirectionalization procedure with a concrete example in Section \n8. Finally, we discuss related work in Section 9, and conclude the paper and highlight some future di\u00adrections \nin Section 10. For proofs (of all theorems), which are omitted in this paper, please see Matsuda et al. \n(2007). 2. Bidirectional Transformation In this section, we brie.y review notations, the basic concept \nof bidirectional transformation (i.e., view updating) (Bancilhon and Spyratos 1981; Dayal and Bernstein \n1982; Gottlob et al. 1988; Hegner 1990; Lechtenb\u00a8orger and Vossen 2003; Foster et al. 2005), and the \ntechnique of bidirectionalization based on derivation of view complement functions (Bancilhon and Spyratos \n1981). These will serve as the basis of our approach. 2.1 Notations Our notations, if not explained, \nfollow Haskell2, a functional pro\u00adgramming language. For a partial function f, we write f(x).if f(x) \nis de.ned, and write f(x)= .otherwise. For a function f : X . Y and a function g : X . Z, we de.ne a \ntupled function (f M g): X .(Y \u00d7Z) by (f M g)(x)=(f(x),g(x)). For a partial function f : X .Y and a partial \nfunction g : X . Y , we write f . g to denote .x . X, f(x).. f(x)= g(x). Intuitively, f .g means that \ng is more widely de.ned than f.  2.2 View Function and Backward Transformation Let V be the set of views \nand S be the set of sources. A total function f : S .V that constructs a view from a source is called \nview function. The following is an example of a view function mapfst(Nil)= Nil mapfst(Cons(Pair(a, b),x)) \n= Cons(a, mapfst(x)) that maps the source, a list of pairs, to the view, a list that contains all the \n.rst components of the pairs in the original list. A function that translates an update on views to that \non sources is called a backward transformation function. An update from x to x ' is denoted as x j x \n' ; e.g., Nil j Cons(A, Nil) represents the update on the view of mapfst from Nil to Cons(A, Nil).Given \na view function f : S . V ,a backward transformation function . :(S \u00d7V ) .S of f translates f(s) j v, \nan update on views, to s j .(s, v), an update on sources, while satisfying the property: .s .S, .v .V, \n.(s, v)..f(.(s, v)) = v. This property reads that the updated source produced by the back\u00adward transformation \nshould not change the view with the view function. In other words, for a source element s and v = f(s), \nlet u be a view update v j v ' and u ' a translated source update s j .(s, v ' ), then the following \ndiagram commutes. u V V ff ff S S u ' It might be easier to understand a backward transformation function \n. :(S\u00d7V ) .S as a mapping that accepts an original source and a changed view as input and produces a \nchanged source as the result. It is worth noting that backward transformation functions are partial: \n.(s, v).means that an update on views of f(s) j v is 2 Haskell 98 Report: http://www.haskell.org/onlinereport/ \n translated to an update on sources of s j .(s, v),and .(s, v)= . means that it prohibits the view update \nf(s) j v. Moreover, back\u00adward transformation functions are not unique, and different de.ni\u00adtions give \ndifferent translation policies. For instance, the following is a backward transformation function of \nthe view function mapfst: j s if v = mapfst(s) .(s, v)= . otherwise, which means that any change in \nthe view is ignored and the source remains unchanged. 2.3 Bidirectional Properties A backward transformation \nfunction . and a view function f should satisfy some bidirectional properties to guarantee consistency \nafter bidirectional transformation is carried out. The following properties follow those in the closed \nview updating (Bancilhon and Spyratos 1981; Hegner 1990), where the source is completely hidden from \nthe users when the view is updated. Let s .S and v, v ' .V . A backward transformation function . :(S \n\u00d7V ) .S and a view function f : S .V should satisfy the following bidirectional properties. ACCEPTABILITY \n.(s, f(s)) = s UNDOABILITY .(s, v)...(.(s, v),f(s)) = s COMPOSABILITY ' '' .(s, v)...(.(s, v),v )...(.(s, \nv),v )= .(s, v ) Acceptability means that if there is no change in views there should be no change in \nsources. Undoability means that all trans\u00adlated updates can be canceled by updates on views. Composability \nmeans that the update translation should preserve the compositional structure3, and translated results \ndo not depend on the update his\u00adtory. 2.4 Bidirectionalization Bidirectionalization is a program transformation \nthat derives a backward transformation function from a view function such that the two functions satisfy \nthe bidirectional properties. It is very much related to the known view update problem in the database \ncommunity, which discusses how to translate updates on views to updates on sources. We shall review two \napproaches on which our method is based. 2.4.1 Constant Complement Approach Bancilhon and Spyratos (1981) \nproposed a general approach to bidirectionalization called constant complement view updating. De.nition \n1 (View Complement Function). A function g : S . V ' is said to be a (view) complement function to a \nview function f : S . V , if the tupled function f M g : S . (V \u00d7V ' ) is injective. Intuitively, a view \ncomplement function of a view function pro\u00advides information that is not visible in the view to a complement \nview such that information from both views can uniquely deter\u00admine a source. For example, let add be \na function de.ned by add(x, y)= x+y. Then, the function fst de.ned by fst(x, y)= x is a view complement \nfunction of add. Note that the ranges of view function f and its complement function g can be different. \nIn fact, '' 3 Note that u1 =f(s)jv is translated to u =sj.(s, v), u2 =vjv 1 '' is translated to u = \n.(s, v)j .(.(s, v),v ), and their composition 2 ' '' u = u1 . u2 = f(s)j v is translated to u = s j \n.(s, v )= ' '' s j .(.(s, v),v )=u . u2. 1 the range of the view complement function is unimportant. \nThis gives us freedom in derivation of view complement functions. Finding a view complement function \nof a view function amounts to bidirectionalization, provided that inversion of can be calculated out \n(Bancilhon and Spyratos 1981). If a view complement function exists, a backward transformation function \ncan be obtained by in\u00adversion. Let f be a view function and g be its view complement function. The function \nupd.f,g. de.ned by upd.f,g.(s,v)=(f M g)-1(v,g(s)) (UPD) is a backward transformation function and satis.es \nbidirectional properties. The function upd.f,g. may be partial. For example, de.nes the same function \nas .in Section 2.2, which upd.mapfst,id. is de.ned only on the input (s,v) by v = mapfst(s). This general \nbidirectionalization framework has been used to bidirectionalize queries on relational database system \n(Cosmadakis and Papadimitriou 1984; Laurent et al. 2001; Lechtenb\u00a8orger and Vossen 2003): derivation \nof view complement functions and inver\u00adsion calculation is not dif.cult in this setting because views \nand sources are tuples and view de.nition functions are queries with a normal form being closed under \ncomposition. It is, however, un\u00adclear how to extend this approach to view functions that can deal with \ngeneral algebraic data structures such as trees. In this paper, we intend to solve this problem.  2.4.2 \nCompositional Approach The compositional approach (Foster et al. 2005; Hu et al. 2004; Meertens 1998) \nis to derive backward transformation functions based on the compositional structure of view functions. \nA view function is supposed to be de.ned by a primitive view function, or  a composition of simpler \nview functions via several combina\u00adtors.  The combinators for gluing view functions includes familiar \ncon\u00adstructs from functional programming languages: composition: f . g de.ned by (f . g) x = f(gx) mapping: \nmap f de.ned by map f [x1,...,xn]=[fx1,...,f xn] product: f \u00d7 g de.ned by (f \u00d7 g)(x,y)=(fx,g y) conditional: \nif pthen f else g de.ned by j fx, if px (if pthen f else g) x= gx, otherwise It has been shown (Foster \net al. 2005) that if one can prepare backward transformation functions for primitive view functions, \none can get backward transformations for view functions that are constructed by primitive view functions \nand the above combinators for function gluing. The present paper shows how to automatically derive backward \ntransformations for primitive view functions over arbitrary algebraic data structures.  2.5 Better Backward \nTransformation Generally, there are many backward transformation functions for a given view function. \nRecall the constant complement approach to bidirectionalization and the view function add in Section \n2.4.1. All View Function Bidirectional Transformation Engine Deriving Complement Function Tupling Inversion \n  Figure 1. System Architecture functions below are view complement functions of add fst(x,y)= x sub(x,y)= \nx- y idpair (x,y)=(x,y) and will lead to the following backward transformation functions based on the \napproach in Section 2.4.1. upd.add,fst.((x,y),v)=(x,v- y) upd.add,sub.((x,y),v)= ((v+(x- y))/2,(v- (x- \ny))/2) ((x,y),v)=(x,y), if v = x+ y upd.add,idpair . These backward transformation functions have different \nupdatabil\u00adity: the .rst two allow any modi.cation of the view, but the last one disallows arbitrary modi.cation \nof the view because view v must be thesameas x+ y. Bancilhon and Spyratos (1981) introduce the following \npreorder, under which smaller view complement func\u00adtions give more updatability. De.nition 2 (Collapsing \nOrder). Let f : S . V, g : S . V ' be functions. The collapsing order, -, is a preorder de.ned by ' '' \nf -g .. . s,s . S, g(s)= g(s ) . f(s)= f(s ). Order f -g means that, with respect to the results of \nmappings, f collapses input more than g. Hence, all elements in the input col\u00adlapse into one in the result \nby the minimal functions, i.e., constant functions, and nothing collapses by the maximal functions, i.e., \nthe injective functions. For the above examples, idpair is greater than the others because it keeps the \nvalues of the input. The functions fst and sub are not comparable. Note that a complement view keeps \ninformation that does not appear in the view, and that the backward transformation func\u00adtion derived \nfrom the view complement function should forbid any change in the information that the complement has \nkept. So, a smaller view complement function gives a better backward trans\u00adformation function because \nit keeps less information. Formally, we have the following theorem (Bancilhon and Spyratos 1981). Theorem \n1. Let f : S . V be a view function, and g1 : S . V ' and g2 : S . V '' be two complement functions of \nf.If g1 -g2, then upd.f,g2. upd.f,g1. holds. 3. An Overview Before we discuss the details of our new \napproach to bidirection\u00adalization, we present an overview of our system, explaining its ar\u00adchitecture \nand relation with the later sections and illustrating with an example how it derives backward transformation \nfunctions from view functions that manipulate arbitrary algebraic data structures, including trees. Figure \n1 shows the architecture of our bidirectionalization sys\u00adtem. The input to our system is a view function. \nThe output consists of a backward transformation function and a checker that validates changes in the \nview. A change in the view is said to be valid if it can be re.ected back to the source by the backward \ntransformation function. The core part is the bidirectional transformation engine mapping from the input \nto the output. 3.1 View Function Views are generated by application of view functions to sources. View \nfunctions are de.ned in a compositional way like f =(f1 . f2)\u00d7 map f3. More precisely, a view function \nis a combination of primitive view functions and the gluing combinators, which were explained in Section \n2.4.2. Each primitive function is in the af.ne, treeless form de.ned by a constructor-based .rst-order \nfunctional language with pattern matching (Section 4). The patterns and constructors in the language \nmake it easy to code primitive view functions from one algebraic data structure to another. As a simple \nexample, consider generation of a view of a list from two lists by appending them together. This view \nfunction can be de.ned in our language as follows. append(Nil,y) = y append(Cons(a, x),y) =Cons(a, append(x, \ny)) It decomposes the data by pattern matching and constructs new data by data constructors.  3.2 Bidirectional \nTransformation Engine Since our view functions are compositional, our bidirectionaliza\u00adtion basically \nconsists of two parts: bidirectionalizing primitive view functions, and  bidirectionalizing the gluing \nview functions combinators.  Given that bidirectionalization of combinators has been well stud\u00adied (Foster \net al. 2005; Hu et al. 2004), we will focus on bidirec\u00adtionalization of primitive view functions, though \nthe whole system should combine the two. 3.2.1 Deriving View Complement Functions Our system starts by \nautomatically deriving a small (with respect to the collapsing order in De.nition 2) view complement \nfunction for a given view function so that tupling the two functions gives an injective function (Section \n5). For example, a view complement function automatically derived by our system for append is as follows. \nappendc(Nil,y) = B1 appendc(Cons(a, x),y) =B2(appendc(x, y)) In this de.nition, B1 and B2 are data constructors \nautomatically generated by the system. A close look at the de.nition reveals that the derived view complement \nfunction actually computes the length of the .rst argument. One can easily verify that although append \nis non-injective, tupling append and appendc , append M appendc , is injective.  3.2.2 Deriving Backward \nTransformation Functions by Tupling and Inversion After obtaining the view complement function, our system \ngen\u00aderates a backward transformation function based on two program transformations, tupling and inversion, \nbased on the constant com\u00adplement approach to bidirectionalization (Section 6). For the example append, \nour system .rst automatically derives the following de.nition for the tupled function appendM , append \nM appendc . M append(Nil,y) y, B1) =(appendM(Cons(a, x),y) =(Cons(a, s), B2(t)) M where (s, t) =append(x, \ny) Then, it derives the following inverse of the tupled function. M-1 (append)(y, B1) =(Nil,y) (appendM)-1(Cons(a, \ns), B2(t)) =(Cons(a, x),y) M-1 where (x,y) =(append)(s, t) Finally, it applies Equation (UPD) in Section \n2.4.1 and produces the following backward transformation function. upd.append,appendc.(s, v) =(appendM)-1(v, \nappendc(s)) To see what the derived backward transformation function ac\u00adtually is, let us rename upd.append,appendc. \nto appendB. Applying the fusion transformation (Wadler 1990) can yield the following de.nition. appendB((Nil,y),v) \n=(Nil,v) appendB((Cons(a, x),y), Cons(b, v)) =(Cons(b, s),t) where (s, t) =appendB((x, y),v) That is, \nappendB is such a function, accepting the original source (x,y)and a new view v and returning a new source \n(x ' ,y ' ),where x ' is the .rst n elements of v and y ' is the rest. Here, n is the length of x. 3.2.3 \nGenerating View Update Checker As seen in the above example, a derived backward transformation function \nmay be partial: function appendB is de.ned only if the length of the updated view is not less than the \nlength of the .rst list in the original source. Therefore, the backward transformation will fail if an \nupdated view does not fall in its domain. Our system automatically generates from a given view func\u00adtion, \ntogether with the original source, a view update checker, rep\u00adresented by a tree automaton, which can \ncheck whether an update on the view is valid or not. Section 7 explains in detail how to gen\u00aderate view \nupdate checkers, including a generated automaton for the example append in this section. 4. View De.nition \nLanguage In this section, we introduce our language, VDL, for de.ning view functions. It is a .rst-order \nfunctional programming language that is similar to Wadler s language for de.ning basic functions for \nfusion (Wadler 1990). 4.1 The Language VDL The syntax and semantics4 of the language is given in Figure \n2. A program of our language consists of a set of function de.nitions, and each function is de.ned by \nseveral rules of the form f(p1,...,pn) =e. To simplify our presentation, we assume that there is no \noverlap among rules of the same function, i.e., no two patterns in the left\u00adhand side overlap. There \nare two important syntactic restrictions on each rule dec\u00adlaration. 4 Note that VDL has the call-by-value \nsemantics, where values are expres\u00adsions that consists of only constructor symbols in C. Syntax: rule \n::= f(p1,...,pn) = e p ::= C(p1,...,pn) constructor pattern | x variable pattern e ::= C(e1,...,en) \nconstructor application | f(x1,...,xn) function call | x variable where C .Cand f .Fare of arity n,and \nx.X. Operational Semantics: e1 .v1 \u00b7\u00b7\u00b7 en .vn (Con) C(e1,...,en) .C(v1,...,vn) f(p1,...,pn) = e.R ..,f(p1.,...,pn.)= \nf(v1,...,vn) e. .u (Fun) f(v1,...,vn) .u where e. denotes the expression that is obtained by replacing \nany variable xin ewith the value .(x),and v1,...,vn denotes values: values are expressions that consist \nonly of constructor symbols in C. Figure 2. View De.nition Language The expression, e,of arule isina \ntreeless form (Wadler 1990), i.e., a function call, which may appear inside a constructor application \nbut never appears inside another function call. It can be seen in Figure 2 that each argument to a function \ncall is a variable instead of an expression. This restriction ensures no intermediate data structure \nin e.  Variable occurrences in a rule are af.ne, i.e., every variable in the left-hand side of a rule \noccurs at most once in the corre\u00adsponding right-hand side. This restriction ensures that there is no \nduplication of data.  These two syntactic restrictions play an important role in our auto\u00admatic bidirectionalization \nframework, simplifying the generation of a view complement function from a view function written in VDL. \nThough restricted, this language is suf.ciently powerful to de\u00adscribe many interesting view functions. \nIt is not dif.cult to see that the view functions we have seen so far, such as students, mapfst, and \nappend, can be coded in VDL with slight syntactic modi.ca\u00adtion. In the following, we give more examples \nof view functions in VDL. Example 1 (Identity View Function). The simplest view function is the identity \nfunction, which creates a view that is the same as its source. It can be de.ned in VDL as follows. id(x) \n= x Example 2 (Projection View Functions). The projection view func\u00adtions are useful for selecting a \ncomponent from the source. They can be de.ned in VDL as follows. fst(x,y) = x snd(x,y) = y Example 3 \n(Constant View Functions). A constant view function is useful for creating a view that is independent \nof its source. An example of the constant view function is de.ned in VDL as follows. nil(x) = Nil Example \n4 (Recursive View Functions on Natural Numbers). Many view functions are de.ned recursively by traversing \nover data structures. For example, the view function for addition of two natural numbers is de.ned by \n add(Z,y) = y add(S(x),y) = S(add(x,y)). As in Haskell, we use a symbol starting with an uppercase letter \nto denote a constructor and a symbol starting with a lowercase letter to denote a function or a variable. \nFunction add is de.ned by travers\u00ading over one data structure in the source, while the following func\u00adtion, \nmax, for computing the maximum of two natural numbers is de.ned by simultaneously traversing over two \ndata structures in the source. max(Z,y) = y max(S(x),Z) = S(x) max(S(x),S(y)) = S(max(x,y)) Example \n5 (Recursive View Functions on Lists and Trees). Our language can be used to de.ne view functions on \nvarious data structures such as lists and trees. As a view function on lists, the function zip for zipping \ntwo lists is de.ned below. zip(Nil,y) = Nil zip(Cons(a,x),Nil) = Nil zip(Cons(a,x),Cons(b,y)) = Cons(Pair(a,b),zip(x,y)) \n As a view function on trees, the function for .ipping a binary tree is de.ned below. .ip(Leaf) = Leaf \n.ip(Node(n,l,r)) = Node(n,.ip(r),.ip(l))  4.2 Notations for Manipulating Programs in VDL In the rest \nof this paper, we will discuss several program transfor\u00admations and prove important properties for them. \nTo do this, we give a more formal de.nition of our programs in VDL, and prepare some notations and functions \nfor later program manipulation. Formally, a program P in our language VDL is a 4-tuple (R,F,C,X) where \n Ris a set of rules (see Figure 2),  Fisa set of function symbols with associated arities,  Cis aset \nof constructor symbols with associated arities, and  Xis aset of variables  such that all sets are \npairwise disjoint. We call an expression gen\u00aderated only by constructor symbols in Ca value or a tree \nvalue and use TC to denote the set of all values. A substitution is a mapping . : X.TC that assigns to \na variable a value. We denote by e. an expression obtained by replacing each variable xin ewith a tree \n.(x). As discussed before, we do not allow rule overlapping in R. Formally, Ris non-overlapping if for \nany two distinct rules f(p1,...,pn) = e ' '' f(p1,...,p n) = e there is no substitution .satisfying \n(p1,...,pn). =(p1' ,...,p n' ).. . We sometimes use vector notations -e to denote sequence e1,...,en \nwhen the length of sequence n is not concerned. For . example, a rule f(p1,...,pn) = eis denoted as \nf(-p) = e. For a rule r, we write Vars(r) to denote the set of all variables occurring in r, UsedVars(r) \nthe set of all variables occurring in the right-hand side of r,and LostVars(r)= Vars(r) \\UsedVars(r). \nTo prove the properties of programs, we sometimes need to distinguish function symbols from their meanings. \nWe denote the semantics of f by [[f]]P . Under the operational semantics of VDL, shown in Figure 2, a \nprogram P yields a partial function [[f]]P : (TC \u00d7\u00b7\u00b7\u00b7\u00d7TC).TC for each function symbol f .F: j v if f(v1,...,vn). \nv,[[f]]P (v1,...,vn)= . otherwise. Note that when it is clear from the context, [[f]]P is sometimes simply \nwritten as [[f]]or even f. We add two semantic restrictions to VDL to avoid pathological situations in \nthe proofs of the properties of programs written in VDL.First,a set of constructors C contains at least \ntwo constructors and one is zero-arity. Second, VDL does not contain functions that are unde.ned everywhere. \nFor example, the following function f is unde.ned everywhere. f(x) =f(x) 5. Deriving View Complement \nFunctions We shall develop algorithms for derivation of view complement functions from view functions \nso that tupling them gives an in\u00adjective function. Compared to the algorithms in Cosmadakis and Papadimitriou \n(1984), Laurent et al. (2001) and Lechtenb\u00a8orger and Vossen (2003), our algorithms are capable of dealing \nwith functions on tree data structures. We start with a direct algorithm, and then improve it with a \nminimizing procedure with injectivity and range analysis. 5.1 A Direct Solution For a given view function \nf : S . V, to derive its complement function g : S . V ', we should be clear about where the non\u00adinjectivity \nof f comes from. Recall that a complement function g of f is a function that makes the tupled function \n(f M g): S . (V \u00d7 V ' )injective.So, if f is injective, its complement function g can be an arbitrary \nfunction from S to V ' (of course, updatability of the backward transformation depends on which g to \nchoose). If f is non-injective, g should return different values for any distinct arguments x,y . S such \nthat f(x)=f(y). Syntactically, there are basically two possible cases for a view function to be non-injective: \n1. Some variables on the left-hand side of a rule disappear in the corresponding right-hand side. For \nexample, function fst(x,y) =xis non-injective. 2. The ranges of two right-hand sides of a view function \noverlap. For example, the following f is obviously non-injective:  f (A) =A f (B) =A. Using this observation, \nwe give an algorithm to derive a comple\u00adment function of a view function. Below, we use the context notation. \nA context K is a tree value containing special holes 01,...,0n and we denote by K[e1,...,en] an expression \nobtained by replacing 0i with ei for each i in {1,...,n}. Any expression in treeless form can al\u00adways \nbe separated as a context, function calls and variables as -. -- .. K[f1(x1),...,fn(xn),x]. Algorithm \n1 (Derivation of Complement Function: ALGc). Input: A program P =(R,F,C,X )for view functions. Output: \nA program Pc for view complement functions. Procedure: 1. For each rule r .R -. --- . .. r =f(p) =K[f1(x1),...,fn(xn),x] \nconstruct a rule c ---- . ... r =fc(p) =Br(f1 c(x1),...,fnc(xn),y) . where {-y} =LostVars(r)and Br is \na fresh constructor, and fc,f1 c,...,fc n .F are function symbols corresponding to f,f1,...,fn respectively. \n2. Create a program as follows. Pc =({r c | r .R},{fc | f .F},{Br | r .R}.C,X ).0 Theorem 2 (Soundness \nof ALGc). Let P =(R,F,C,X ) be a program and Pc =(Rc ,Fc ,Cc ,X c) the derived program by ALGc. Then, \nfor every function symbol f .F, [[fc]]is a com\u00adplement function of [[f]]. Note that by ALGc, a function \nis de.ned if and only if its com\u00ad -. - . plement function is de.ned, i.e., f(v ). if and only if fc(v \n).. Example 6. Consider function fst de.ned by fst(x,y) =x. In this de.nition, the second argument, \ny, is discarded. Algo\u00adrithm ALGc derives the rule fstc(x,y) =B1(y). Here, B1 is the newly-introduced \nconstructor for the .rst rule. Later, we use the constructor Bi for the ith rule. That is, function fstc \ncomplements lost value y in the de.nition of fst. Example 7. Consider the function add de.ned in Example \n4. In this de.nition, all variables are preserved from the left-hand side to the right-hand side of each \nrule. Algorithm ALGc derives the following two rules. addc(Z,y) = B1 addc(S(x),y) =B2(addc(x,y)) This \nfunction addc actually returns the information of the .rst argument. Example 8. Consider the function \nmax de.ned in Example 4. Algorithm ALGc derives the following three rules. max c(Z,y) = B1 max c(S(x),Z) \n= B2 max c(S(x),S(y)) =B3(max c(x,y)) This complement function is basically equivalent, with respect \nto the collapsing order, to the following function, minle,which returns the minimum of arguments and \na boolean value indicating whether the .rst argument is less than or equal to the second. j (x,1) ifx= \ny minle(x,y)= (y,0) ifx>y In general, there can be in.nitely many complement functions for a given view \nfunction. Ideally, we want to obtain a complement function that is minimal with respect to the collapsing \norder. The function, fstc, derived by ALGc is a minimal complement of fst, but a complement function \nderived by ALGc is not always a mini\u00admal one. Next we will consider how to obtain smaller complement \nfunctions. 5.2 Making it Smaller Algorithm ALGc does not always return a minimal complement function. \nFor example, consider the following function not. not(True) =False not(False) =True Since the function \nnot is injective, a minimal complement of this function can be any constant function. But Algorithm ALGc \nde\u00adrives the rules not c(True) =B1 not c(False) =B2 which is obviously not a constant function. To derive \nsmaller complement functions, we improve Algo\u00adrithm ALGc by analyzing injectivity of function, and calculat\u00ading \nranges of the right-hand-side expressions. These two kinds of analysis are useful to minimize complement \nfunctions for the fol\u00adlowing reasons: 1. If the input function is recognized to be injective, we should \nreturn a constant function. This requires determination of the injectivity of a function. Fortunately, \nthis is decidable in VDL. In the next subsection, we present an algorithm to determine injectivity. \n2. Let e be an expression that may contain free variables. By the range of an expression e, we mean the \nset of evaluated values of all possible ground instances of e, i.e., the set de.ned by  Range(e)= {v \n|.. : X.TC,e. .v}. Suppose that we have two rules f(C1(x)) = e1 f(C2(x)) = e2. If the ranges of e1 and \ne2 do not overlap, fc(C1(x)) and fc(C2(x)) can be safely collapsed to the same value for some input, \nand hence [[fc]] becomes smaller. In Section 5.2.2 we present an algorithm to calculate the range of \nan expression by using a tree automaton. 3. In addition to the above, the range analysis is helpful to \nremove unnecessary unary constructors. For example, let f be a view function and fc be its complement \nfunction. f(C1(x)) = D1(f(x)) f(C2) = D2 f(C3) = D2 fc(C1(x)) = B1(fc(x)) fc(C2) = B2 fc(C3) = B3 The \nunary constructor, B1, can be removed if the ranges of D1(f(x)) and D2 do not overlap. This is because \nthe ranges of right-hand-side expressions of tupled function (f M fc) do not overlap if for any two rules \nr1,r2 of f either the ranges of right-hand-side expressions of r1,r2 or r1 c ,r2 c do not overlap. The \nobtained complement function de.ned as fc(C1(x)) = fc(x) fc(C2) = B2 fc(C3) = B3 is smaller than the \noriginal complement function. 5.2.1 Injectivity Analysis We present an algorithm that determines the \ninjectivity of a func\u00adtion. The algorithm consists of three major steps. In every step, the algorithm \nmarks functions if they are non-injective and otherwise proceeds to other steps. All functions unmarked \nat the end are in\u00adjective. Algorithm 2 (Injectivity Checking: ALGi). Input: A program P =(R,F,C,X) for \nview functions. Output: For each function f .F, f is injective or f is non\u00ad injective . Procedure: 1. \nMark those functions that have a rule discarding variables. 2. Mark those functions whose ranges of \nright-hand sides of two distinct rules overlap. 3. Repeat Mark those functions that call marked functions. \nUntil no marking can be done.  4. Return f is non-injective if f is marked, otherwise return f is injective \n. 0  Theorem 3 (Soundness and Completeness of ALGi). For every function symbol f .F, ALGi returns f \nis injective if and only if [[f]] is an injective function.  5.2.2 Range Analysis For every expression \noccurring in a program, we can construct an automaton that accepts exactly the trees in the range of \nthe expression. Our idea was based on the existing result that the image of a linear tree transducer \nis a regular tree language (Engelfriet 1975). Let P =(R,F,C,X) be a program and Ebe a set of expres\u00adsions \noccurring in R. For an expression e.E, we construct a non\u00addeterministic (bottom-up) .nite tree automaton \nAe over C. This au\u00adtomaton is a tuple (Q,C,{qe},.) with a set of states Q,a setof constructors C, the \nunique .nal state qe, and a set of transition rules . where Q= {qf |f .F}.{qe. |e ' .E}.{q*} . consists \nof q* .qe. with e ' = x.Eand x.X, qf .qe. with e ' = f(...) .Eand f .F, C(qe1 ,...,qen ) .qe. with \ne ' = C(e1,...,en) .E, qe. .qf for f(...) = e ' .Rand C(q*,...,q*) .q* with C .C. The following lemma \nstates that automaton Ae exactly accepts the trees in the range of e. Lemma 1 (The Range of Expressions). \nLet P =(R,F,C,X) be a program. For each expression eoccurring in P,a tree tis in the range of eif and \nonly if the tree automaton, Ae, accepts t. The ranges of two expressions e and e ' overlap if and only \nif the language accepted by the intersection of two tree automata Ae and Ae. is not empty. Since .nite \ntree automata are closed under intersection and the emptiness of a .nite tree automaton is decidable \n(Comon et al. 1997), we have the following corollary. Corollary 1. For a program P =(R,F,C,X), whether \nthe ranges of two expressions in Roverlap or not is decidable. 5.2.3 Deriving Smaller Complement Functions \nWith injectivity and range analysis, we can improve Algorithm ALGc and derive smaller complement functions. \nWe change three parts in the original algorithm. First, we remove fc(...) for every injective function \nf from arguments of B in ALGc in the construction of the complement, because a complement function of \nany injective function is a constant function and can be ignored. Second, we use the same constructor \nfor those rules of fc when the ranges of the right-hand-side expressions of these rules do not overlap. \nThird, we remove a unary constructor from a rule for fc, if the range of the right-hand-side expression \nof the corresponding rule of f does not overlap with the ranges of other rules of f. As a preprocessing \nstep, we calculate a partition of R= R1 \u00b7\u00b7\u00b7Rk such that for each rule subset Ri the following hold. \nFor all r,r ' .Ri, rand r ' de.ne the same function.  For all r,r ' .Ri, the sum of non-injective functions \nand lost variables in both rules are the same.  For all r,r ' .Ri, the ranges of the right-hand-side \nexpressions of rand r ' do not overlap.  Algorithm 3 (Improvement of ALGc: ALGsc). Input: A program \nP =(R,F,C,X) for view functions and a partition of R= R1 \u00b7\u00b7\u00b7Rk. Output: A program Pc for view complement \nfunctions. Procedure: For each rule rfor de.ning f .F: -. --- . .. r =f(p) =K[f1(x1),...,fn(xn),x].Rj \ndo the following: 1. Construct a rule -. -. . '' . c -' c' c- rpre =fc(p) =Bk(f1 (x1),...,fm (xm),y) \n-. -. '' '' where the function calls f1(x1),...,f m(xm)are obtained -. -. from f1(x1),...,fn(xn)all injective \nfunction calls removed, . and {-y}=LostVars(r). 2. If rpre is in the form of - . -'' . c fc (p) =Bj (f \n(x )) and the right-hand-side expression of r does not overlap with the right-hand-side expression of \nany other rule r ' for f .F, construct a rule . c -'c fc.-' r =(p) =f (x ), otherwise, construct a rule \ncc r =rpre. 3. Create a program as follows. Pc =({r c |r .R},{fc |f .F},{Bj |Rj },X) 0 Theorem 4 (Soundness \nof ALGsc). Let P =(R,F,C,X)be a c ,Fc ,Cc ,Xc program and Pc =(R)the derived program by ALGsc. Then, \nfor every function symbol f .F, [[fc]]is a com\u00adplement function of [[f]]. Example 9 (Role of Rule Partition). \nConsider the function, f,de\u00ad.ned by r1 =f (A1) =C1 r2 =f (A2) =C2 r3 =f (A3) =C1 and suppose that R ={r1,r2}{r3}. \nThen, Algorithm ALGsc returns the following complement function. f c (A1) =B1 f c (A2) =B1 f c (A3) =B2 \nHowever, if R = {r1}{r2,r3}, ALGsc will return another complement function. f c(A1) =B1 f c(A2) =B2 f \nc(A3) =B2 So different rule partitions can lead to different complement functions. This is why we separate \nrule partitions from Algo\u00adrithm ALGsc. Example 10 (Complements of Injective Functions). Consider the \nfunction, mapnot, de.ned as follows. mapnot(Cons(a,x)) =Cons(not(a),mapnot(x)) mapnot(Nil) = Nil not(True) \n= False not(False) = True In contrast with mapfst de.ned above, mapnot is injective. With injective analysis \nwe know that mapnot and not are injective functions, so ALGsc returns the following complement functions \nmapnotc(Cons(a,x)) =B1 mapnotc(Nil) = B1 notc(True) = B2 notc(False) = B2 which is a minimal complement \nfunction of mapnot with respect to the collapsing order. It is worth remarking that Algorithm ALGsc will \nderive con\u00adstant functions for injective functions if a partition of R is R = Rf1 \u00b7\u00b7\u00b7Rfn where Rfi is \nthe set of all rules for fi.The exis\u00adtence of such a partition is easily checked by the range analysis. \nExample 11 (Removing Constructors). Consider the function zip in Example 5. Algorithm ALGsc returns zipc(Nil,y) \n= B1(y) zipc(Cons(a,x),Nil) = B2(a,x) zipc(Cons(a,x),Cons(b,y)) =zipc(x,y) which is a minimal complement \nfunction of zipc. Note that ALGsc has removed the constructor from the third rule, compared to the old \nalgorithm, ALGc. The complement functions obtained by ALGsc have two good characteristics. First, they \nhave the same form as view functions, which makes the later tupling step and the inversion step easy. \nSec\u00adond, as will be seen later, the updatability of backward transforma\u00adtion functions with these complement \nfunctions is easy to under\u00adstand. 6. Generating Backward Transformation Functions After obtaining a view \ncomplement function fc :S . V ' for a given view function f :S . V, we get the following backward transformation \naccording to Equation (UPD). .(s,v)=(f M fc)-1(v,fc(s)) That is, a backward transformation function \ncan be derived if the tupled function, (f M fc), and its inverse (f M fc)-1 can be effectively derived. \nThe point is how to calculate an inverse program. Although this is generally dif.cult, now we need merely \nto treat the tupled func\u00adtion of the form (f M fc). Thanks to the correspondence between the rules of \nf and fc, we can obtain a program of (f M fc)which is in a good form for this inversion. In the following, \nwe show how tupling and inversion can be done automatically. 6.1 Calculation of Program of (f M fc) A \nprogram for tupled function (f M fc)can be straightforwardly calculated because the rules of f and the \ncorresponding fc have the same patterns and the same form of recursive calls in the right-hand sides. \nHowever, we cannot directly describe the tupled function in the treeless form because of the tuple structure, \nwhich needs to be treated specially. We extend language VDL with where-clauses and tuples: rule ::=\u00b7\u00b7\u00b7 \n| f(p1,...,pn) =(e1,...,em) where (x1,...,xk) =g(y1,...,ym) ... ' '''' (x1,...,xk. ) =g (y1,...,y m. \n) where e1,...,en do not include any function calls, i.e., they have the same forms as patterns, and \nall variables appear on the left-hand sides of the where-clause are different from those on the right\u00adhand \nsides. The two restrictions above are the treeless condition of tupled functions. Additionally, this \nnew form of rules must satisfy the af.ne condition. That is, all variables used at most once (actually, \nall variables are used exactly once in tupled functions). The operational semantics is straightforwardly \nextended. Note that this extension is behind the scene of the view de.nition users; it is only used internally \nduring bidirectionalization transformation. Algorithm 4 (Tupling). Input: A where-free program P. Output: \nA program PM for tupled functions. Procedure: 1. Let Pc be the program derived from P by ALGsc. 2. \nFor each non-injective function f, and for each rule rof f in P do  (a) Let r c be the corresponding \nrule for rin Pc . (b) Structure rand r c in the following forms  - . -. -- .. r =f(p) =K[t,u, x] -. \n- . c -'' ' . fc r =(p) =K [t ,x ] where - . -. - t : non-injective function calls f1(y1 ),...,fn(y. \nn), . -. - -t ': function calls of the forms f1 c(y1),...,fnc(y. n), . -- -.. u: injective function calls \ng1(z1 ),...,gm(zm). (c) Prepare fresh variables ti,ti' ,uj for i .{1,...,n},j . {1,...,m}. (d) Construct \nthe rule, r M, as follows:  -. - .MM-. .--'' -.. ' r =f(p) =(K[t , u ,x],K [t ,x ]) ' M. - where {(ti,ti) \n=fi (yi )}i.{1,...,n} - . {uj = gj(zj )}j.{1,...,m} 3. For each injective function g, and for each rule \nr of g in P, construct the rule, r ', as follows in the similar way: ' --- . .. r =g(p) =K[u ,x] - . \nwhere {uj = gj(zj )}j.{1,...,m} 4. Gather all r M and r ' to form PM . 0 This algorithm correctly gives \na program of tupled functions, -. - . i.e., [[fM]](t )=([ f]]M [[fc]])(t ). An example is given in Sec\u00adtion \n8.  6.2 Calculation of Program of (f M fc)-1 Next, we calculate an inverse program for (f M fc)-1 from \nthe program of (fMfc). The basic idea is to swap the left-hand side and the right-hand side of each rule \nand to apply inversion recursively. Algorithm 5 (Inversion of Tupled Functions). Input: A program PM \n=(R,F,C,X)for tupled functions. Output: A program -1 `. \u00af\u00b4 M-1 -1 (P)=R,f|f .F ,C,X for tupled functions. \nProcedure: For each rule rin R --' .- .. r =f(p) =(e) where {(ti,ti) =fi(yi )}i.{1,...,n} - . {uj = \ngj(zj )}j.{1,...,m} construct the rule r -1 in R-1 as follows. -1 -1.. . ' ---f-1 r =f(e) =(p)where {(yi \n) =i (ti,ti)}i.{1,...,n} --1 . {(zj ) =gj (uj)}j.{1,...,m} 0 Theorem 5 (Correctness). Let P be a program, \nand (PM)-1 the generated program. Then, (u1,u2)=[ fM]]P 0 (t1,...,tn)implies (t1,...,tn)=[[(fM)-1]](P \n0)-1 (u1,u2). Note that the obtained inverse program may be nondeterminis\u00adtic. However, since the original \nfunction to be inversed is injective in our framework, it is possible to uniquely determine a rule with \na domain analysis similar to the range analysis discussed before, when the inverse program is executed. \nAn example of inversion is giveninSection8. 7. Generating View Update Checker A view update checker \nis designed to decide whether or not an up\u00addate on views is valid without execution of the backward transfor\u00admation. \nAn update on views is said to be valid if it can be success\u00adfully re.ected to the source by the derived \nbackward transforma\u00adtion function. Recall that in our framework, a backward transfor\u00admation is given \nby upd.f,fc.(s,v) =(f M fc)-1(v,fc(s)).This means that, for a view function f and the original source, \ns, we can check whether or not a view update is valid by con.rming whether (v,fc(s))is in the range of \n(f M fc),where v is an updated view. We de.ne below a nondeterministic (bottom-up) tree automaton for \nvalidating view updates. The tree automaton has three kinds of states: state q* is reached by any view, \nstate qf is reached by a view in the range of f,and state qft 0 is reached by a view v such that (v,t)is \nin the range of fM. Therefore, when the .nal state is a state qft00, the tree automaton exactly accepts \na view v such that (v,t0) is in the range of fM (i.e., (v,t0)is in the domain of (fM)-1). De.nition 3 \n(View Update Checker). Let P be a program, Pc be a complement program derived by our algorithm, t0 be \na comple- M ,FM ,CM ,XM ment view, and P=(RM )be a tupled program of P and Pc.A view updating checker \nis de.ned as a tree automaton t0 AU =(Q,CM ,{q },.)where f t Q={q*}.{qf |f .F}.{qf0 |fM .FM,tis a subtree \nof t0} .consists of the following transition rules: C(q*,...,q*).q* with C .C, . -.. ..--- K[qfr,q* \n] . qf with f(p) = K[ -t,x] .R and . ti =fi ' (-e),and - . r. rr t--t .. K[qqgq*].qf0 with fr0, r , \n23 -. - .- M-.--'' ' . .. f(p) =(K[t,u, x],K [t ,x ]) . .RM 4 ''M-5 where {(ti,ti) =fi (yi )}i.{1,...,n} \n. ' - {uj = gj(zj )}j.{1,...,m} -. - . '' '' ''' where t is a subtree of t0 and t =K [t ,x ].. Theorem \n6 (Validity of View Update Checker). A view updating t0 checking tree automaton AU =(Q,CM ,{q 0 },.)in \nDe.nition 3 f exactly accepts view vsuch that (v,t0)is in the range of fM . We show examples of automatically \ngenerated view update checkers for some view functions. Note that the view update check\u00ading automata \nbelow have been reduced where unnecessary states have been removed. Example 12. Consider function append \nand its complement func\u00adtion in Section 3. When the initial source is (s1,s2)=(Cons(True,Cons(False,Nil)),Nil), \n the view is append(s1,s2)= Cons(True,Cons(False,Nil))and the complement view is appendc(s1,s2)=B2(B2(B1)). \nThen, the view update checker generated by our system is the B2 (B2 (B1)) automaton A=(Q,C,{q 0 },.)where \nappend B2 (B2(B1 )) B2 (B1) B1 Q={q*,qappend0 ,qappend0 ,qappend0}and .consists of the transition rules \nof  t.q* where t.{True,False,Nil},  Cons(q*,q*).q*,  B2 (B1) B2(B2 (B1)) Cons(q*,q , append0).qappend0 \n B1 B2(B1 ) Cons(q*,q append0 ) .qappend0 ,and q* .q B1 append0 . In fact, this automaton only accepts \nlists that are 2 or longer, which means one can only update the view of lists in such a way that its \nlength is not less than 2. Example 13. Consider the function, .lter,de.ned as .lter(Nil) = Nil .lter(Cons(A1,x)) \n= Cons(A1,.lter(x)) .lter(Cons(A2,x)) = Cons(A2,.lter(x)) .lter(Cons(A3,x)) = .lter(x) and the complement \nfunction derived by our algorithm as follows. .lterc(Nil) = B1 .lterc(Cons(A1,x)) = B2(.lterc(x)) .lterc(Cons(A2,x)) \n= B2(.lterc(x)) .lterc(Cons(A3,x)) = B3(.lterc(x)) When the initial source is s= Cons(A2,Cons(A3,Cons(A1,Nil))), \nthe view is .lter(s)= Cons(A2,Cons(A1,Nil)) and the comple\u00adment view is .lterc(s)= B2(B3(B2(B1))). Then, \nthe view update checker derived by our system is automa- B2(B3 (B2(B1 ))) ton A=(Q,C,{q },.) where .lter0 \nB2 (B3(B2 (B1))) B3 (B2(B1 )) B2 (B1) B1 Q= {q.lter0 ,q.lter0 ,q.lter0 ,q.lter0 } . consists of transition \nrules B3 (B2(B1 )) B2 (B3(B2(B1 ))) Cons(t,q ) .q where t .{A1,A2}, .lter0 .lter0 B1 B2(B1 ) Cons(t,q \n.lter0) .q.lter0 where t.{A1 ,A2}, B2(B1 ) B3 (B2(B1 )) q ,and .lter0 .q.lter0 Nil .q B1 .lter0 . This \nautomaton accepts lists that are 2 long, and each list element is either A1 or A2. 8. An Example To give \na whole picture of how our system works concretely, recall the example in the Introduction. The following \nview function, students, is the same as that in the Introduction, except that we write Cons for (:) and \nNil for []. students(Nil) = Nil students(Cons(Student(name,grade,major)),ms)) = Cons(Student(name,grade,major),students(ms)) \nstudents(Cons(Prof(name,position,major)),ms)) = students(ms) The function, students, extracts all student \nmembers from a mem\u00adber list. This behavior of students is similar to the function, .lter. The derived \ncomplement function by our algorithm is as follows. studentsc(Nil) = B1 studentsc(Cons(Student(name,grade,major)),ms)) \n= B2(studentsc(ms)) studentsc(Cons(Prof(name,position,major)),ms)) = B3(name,position,major,studentsc(ms)) \nTupling the two functions students and studentsc gives studentsM(Nil) =(Nil,B1) M students(Cons(Student(name,grade,major),ms)) \n=(Cons(Student(name,grade,major),x),B2(y)) M where (x,y) = students(ms) M students(Cons(Prof(name,position,major),ms)) \n =(x,B3(name,position,major,y)) where (x,y) = studentsM(ms), and inversion of this tupled function \nyields the following result. (studentsM)-1(Nil,B1) = Nil M-1 (students)(Cons(Students(n,g,m),x),B2(y)) \n= Cons(Student(n,g,m),ms) where ms M)-1 =(students(x,y) (studentsM)-1(x,B3(n,p,m,y)) = Cons(Prof(n,p,m),ms) \n M-1 where ms ) =(students(x,y) Then, a backward transformation . = upd.students,studentsc. can be derived \n(after some fusion transformation) as follows. .(Nil,Nil)= Nil .(Cons(Student(n,g,m),ms),Cons(Student(n \n' ,g ' ,m ' ),ss)) '' ' = Cons(Student(n ,g ,m ),.(ms,ss)) .(Cons(Prof(n,g,m),ms),ss) = Cons(Prof(n,g,m),.(ms,ss)) \n This is exactly the same function as studentsB in the Introduction. Now one can freely change the names \nin the view, and the backward transformation can re.ect them to the source. Consider thecasewhere thesource \nsis as follows. s= Cons(Student(X,DC,CS),Cons(Prof(Y,AP,CS),Nil)) Let v be the view generated by the \nview function, students,on s, i.e., v = Cons((Student(X,DC,CS),Nil). Updating view v to Cons(Student(X,DC,Math),Nil) \nis acceptable and results in the following source. Cons(Student(X,DC,Math),Cons(Prof(Y,AP,CS),Nil)) \nHowever, both inserting and removing elements, e.g., updating the view to Nil, are prohibited. This updatability \ncan be precisely represented by an automaton. Let v1 = B2(B3(Y,AP,CS,B1)) v2 = B3(Y,AP,CS,B1) v3 = B1, \n then updatability of v with respect to source s is captured by automaton A=(Q,C,{q v1 },.),where students \nv1 v2 v3 Q= {q ,q ,q ,q*} students students students . consists of transition rules C(q*,...,q*) .q* \nwhere C .C, v2 v1 Cons(Student(q*,q*,q*),q ) .q students students , v3 v2 q .q ,and students students \n Nil .q v3 students . Note that the view, Cons((Student(X,DC,CS),Nil), is accepted by the automaton, \nA, but the view, Nil, is not. 9. Related Work Our work is based on the idea of deriving (relational) \ncomplement functions on relational databases, where view functions are ex\u00adpressed in terms of relational \nalgebras. Cosmadakis and Papadim\u00aditriou (1984) showed that .nding minimal complement functions when views \nare de.ned only by projections is NP-Complete. Lau\u00adrent et al. (2001) proposed an algorithm to compute \ncomplement functions when views are de.ned by projections, selections, and joins. They also discussed \nthe conditions for minimal complement functions. Their algorithm is expensive because it uses the results \nof NP-Complete sub-problems. Lechtenb\u00a8orger and Vossen (2003) improved on Laurent et al. s work. They \nproposed a polynomial\u00adtime algorithm for computing complement functions when views are de.ned by projections, \nselections, joins, and renaming. Their algorithm computes smaller complement functions than Laurent et \nal. s, and the obtained complement functions are minimal when view functions contain no projection. Our \nwork can be considered an extension of these works such that view functions can be de\u00ad.ned on tree-like \ndata structures other than tuples. Moreover, our approach is based on syntactic program transformations, \nwhereas the existing methods focus more on function semantics. Our work was greatly motivated by works \non bidirectional transformation on trees. In addition to the work by Foster et al. (2005) that proposed \na combinatorial approach to the problem (as discussed in the Introduction), Hu et al. (2004) showed how \nbidi\u00adrectional transformation can be used to maintain data dependency in the tree view, which can be \nseen as an application that develops constraint maintainers on trees (Meertens 1998). Mu et al. (2004) \nimproved the consistency of Hu et al. s framework by imposing restrictions on updating operators. These \nframeworks are domain\u00adspeci.c and designed for speci.c applications. In contrast, our work is more general. \nOur work is also related to work on updating XML views constructed from relational data. Wang and Rundensteiner \n(2004) applied the work in Dayal and Bernstein (1982) to XML views over relational data. Braganholo et \nal. (2004) proposed an algorithm to map updates on XML views to relational data. However, they did not \nconsider the case where the source is XML too, and our method may shed a new light on their problems. \n10. Conclusion This paper presents a new transformational approach to bidirec\u00adtionalization that can \nautomatically derive backward transforma\u00adtion programs from view de.nition programs written in a simple \nfunctional language. The new bidirectionalization method is built upon three program transformations: \nautomatic derivation of com\u00adplement functions, tupling transformation, and inverse transforma\u00adtion. These \nthree transformations are composed together through programs in a treeless and af.ne form, which simpli.es \nand enables implementation of the transformations and automatic generation of a view update checker. \nOur approach is different from many exist\u00ading approaches where only a bidirectional interpreter is derived \nand execution of the interpreter requires passing the source through all the interpretation steps, our \napproach does produce a program for backward transformation. This makes it possible to utilize an opti\u00admizing \ncompiler for more ef.cient execution of backward transfor\u00admation. There are several issues that are worth \nlooking into in the future. First, it would be interesting to see if our view language could be extended \nwith regular patterns and the restriction on variable uses could be relaxed so that more view functions \ncould be de.ned and backward transformation could be derived. Second, we want to see if our bidirectionalization \nframework can be adapted to other bidirectional semantics. The bidirectional properties (semantics) used \nin this paper are known as closed update semantics where sources are invisible to the users who want \nto modify views. There is another useful semantics called open update semantics where both the source \nand the view are visible to users. Third, although the system has been implemented, we would like to \ntest it with more practical applications. References F. Bancilhon and N. Spyratos. Update semantics of \nrelational views. ACM T. Database Syst., 6(4):557 575, 1981. V. P. Braganholo, S. B. Davidson, and C. \nA. Heuser. From XML view updates to relational view updates: old solutions to a new problem. In VLDB \n04: International Conference on Very Large Data Bases, pages 276 287, 2004. H. Comon, M. Dauchet, R. \nGilleron, F. Jacquemard, D. Lugiez, S. Ti\u00adson, and M. Tommasi. Tree automata techniques and applications. \nhttp://www.grappa.univ-lille3.fr/tata, 1997. S. S. Cosmadakis and C. H. Papadimitriou. Updates of relational \nviews. J. ACM, 31(4):742 760, 1984. U. Dayal and P. A. Bernstein. On the correct translation of update \noperations on relational views. ACM T. Database Syst., 7(3):381 416, 1982. J. Engelfriet. Bottom-up and \nTop-down Tree Transformations A Com\u00adparison. Math. Syst. Theory, 9(3):198 231, 1975. J. N. Foster, M. \nB. Greenwald, J. T. Moore, B. C. Pierce, and A. Schmitt. Combinators for bi-directional tree transformations: \na linguistic ap\u00adproach to the view update problem. In POPL 05: Proceedings of the 32nd ACM SIGPLAN-SIGACT \nsymposium on Principles of program\u00adming languages, pages 233 246, 2005. G. Gottlob, P. Paolini, and R. \nZicari. Properties and update semantics of consistent views. ACM T. Database Syst., 13(4):486 524, 1988. \nS. J. Hegner. Foundations of canonical update support for closed database views. In ICDT 90: Proceedings \nof the Third International Conference on Database Theory, pages 422 436, 1990. Z. Hu, S.-C. Mu, and M. \nTakeichi. A programmable editor for developing structured documents based on bidirectional transformations. \nIn PEPM 04: Proceedings of the 2004 ACM SIGPLAN symposium on Partial evaluation and semantics-based program \nmanipulation, pages 178 189, 2004. R. L\u00a8ammel. Coupled software transformations (extended abstract). \nIn First International Workshop on Software Evolution Transformations, pages 31 35, 2004. D. Laurent, \nJ. Lechtenb\u00a8orger, N. Spyratos, and G. Vossen. Monotonic complements for independent data warehouses. \nVLDB J., 10(4):295 315, 2001. J. Lechtenb\u00a8orger and G. Vossen. On the computation of relational view \ncomplements. ACM T. Database Syst., 28(2):175 208, 2003. K. Matsuda, Z. Hu, K. Nakano, M. Hamana, and \nM. Takeichi. Bidirection\u00adalization transformation based on automatic derivation of view comple\u00adment function. \nTechnical Report 2007-44, Graduate School of Informa\u00adtion Science and Technology, the University of Tokyo, \n2007. L. Meertens. Designing constraint maintainers for user interaction. http://www.cwi.nl/~lambert, \n1998. S.-C. Mu, Z. Hu, and M. Takeichi. An algebraic approach to bidirectional updating. In APLAS 04: \nSecond ASIAN Symposium on Programming Languages and Systems, pages 2 18, 2004. P. Wadler. Views: a way \nfor pattern matching to cohabit with data abstrac\u00adtion. In POPL 87: Proceedings of the 14th ACM SIGACT-SIGPLAN \nsymposium on Principles of programming languages, pages 307 313, 1987. P. Wadler. Deforestation: Transforming \nprograms to eliminate trees. Theor. Comput. Sci., 73(2):231 248, 1990. L. Wang and E. A. Rundensteiner. \nOn the updatability of XML views published over relational data. In ER 2004: International Conference \non Conceptual Modeling, pages 795 809, 2004.    \n\t\t\t", "proc_id": "1291151", "abstract": "<p><i>Bidirectional transformation</i> is a pair of transformations: a <i>view function</i> and a <i>backward transformation</i>. A view function maps one data structure called source onto another called view. The corresponding backward transformation reflects changes in the view to the source. Its practically useful applications include replicated data synchronization, presentation-oriented editor development, tracing software development, and view updating in the database community. However, developing a bidirectional transformation is hard, because one has to give two mappings that satisfy the bidirectional properties for system consistency.</p> <p>In this paper, we propose a new framework for bidirectionalization that can automatically generate a useful backward transformation from a view function while guaranteeing that the two transformations satisfy the bidirectional properties. Our framework is based on two known approaches to bidirectionalization, namely the constant complement approach from the database community and the combinator approach from the programming language community, but it has three new features: (1) unlike the constant complement approach, it can deal with transformations between algebraic data structures rather than just tables; (2) unlike the combinator approach, in which primitive bidirectional transformations have to be explicitly given, it can derive them automatically; (3) it generates a view update checker to validate updates on views, which has not been well addressed so far. The new framework has been implemented and the experimental results show that our framework has promise.</p>", "authors": [{"name": "Kazutaka Matsuda", "author_profile_id": "81392597731", "affiliation": "The University of Tokyo, Tokyo, Japan", "person_id": "P900680", "email_address": "", "orcid_id": ""}, {"name": "Zhenjiang Hu", "author_profile_id": "81100253989", "affiliation": "The University of Tokyo, Tokyo, Japan", "person_id": "PP15027466", "email_address": "", "orcid_id": ""}, {"name": "Keisuke Nakano", "author_profile_id": "81100633478", "affiliation": "The University of Tokyo, Tokyo, Japan", "person_id": "PP37043404", "email_address": "", "orcid_id": ""}, {"name": "Makoto Hamana", "author_profile_id": "81100447578", "affiliation": "Gunma University, Kiryu, Japan", "person_id": "PP37042168", "email_address": "", "orcid_id": ""}, {"name": "Masato Takeichi", "author_profile_id": "81100466948", "affiliation": "The University of Tokyo, Tokyo, Japan", "person_id": "PP15032927", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291162", "year": "2007", "article_id": "1291162", "conference": "ICFP", "title": "Bidirectionalization transformation based on automatic derivation of view complement functions", "url": "http://dl.acm.org/citation.cfm?id=1291162"}