{"article_publication_date": "10-01-2007", "fulltext": "\n iTasks: Executable Speci.cations of Interactive Work Flow Systems for the Web Rinus Plasmeijer Peter \nAchten Pieter Koopman Software Technology Department, Institute for Computing and Information Sciences, \nRadboud University Nijmegen, Toernooiveld 1, 6525ED Nijmegen, Netherlands {rinus,P.Achten,pieter}@cs.ru.nl \nAbstract In this paper we introduce the iTask system: a set of combina\u00adtors to specify work .ows in a \npure functional language at a very high level of abstraction. Work .ow systems are automated sys\u00adtems \nin which tasks are coordinated that have to be executed by humans and computers. The combinators that \nwe propose support work .ow patterns commonly found in commercial work .ow sys\u00adtems. Compared with most \nof these commercial systems, the iTask system offers several advantages: tasks are statically typed, \ntasks can be higher order, the combinators are fully compositional, dy\u00adnamic and recursive work .ows \ncan be speci.ed, and last but not least, the speci.cation is used to generate an executable web-based \nmulti-user work .ow application. With the iTask system, useful work .ows can be de.ned which cannot be \nexpressed in other sys\u00adtems: work can be interrupted and subsequently directed to other workers for further \nprocessing. The implementation is special as well. It is based on the Clean iData toolkit which makes \nit possible to create fully dynamic, in\u00adteractive, thin client web applications. Thanks to the generic \npro\u00adgramming techniques used in the iData toolkit, the programming effort is reduced signi.cantly: state \nhandling, form rendering, user interaction, and storage management is handled automatically. The iTask \nsystem allows a task to be regarded as a special kind of per\u00adsistent redex being reduced by the application \nuser via task com\u00adpletion. The combinators control the order in which these redexes are made available \nto the application user. The system rewrites the persistent task redexes in a similar way as functions \nare rewritten in lazy functional languages. Categories and Subject Descriptors D.2.11 [Software Engi\u00adneering]: \nSoftware Architectures Domain-speci.c architectures; D.1.1 [Programming Techniques]: Applicative (Functional) \nPro\u00adgramming; D.3.2 [Programming Languages]: Language Classi\u00ad.cationsApplicative (functional) languages; \nH.4.1 [Information Systems Applications]: Of.ce Automation Work.ow manage\u00adment; H.5.3 [Information Interfaces \nAnd Presentation]: Group and Organization Interfaces Web-based interaction General Terms Design; Languages \nKeywords Clean; iData; iTask Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \npro.t or commercial advantage and that copies bear this notice and the full citation on the .rst page. \nTo copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c \npermission and/or a fee. ICFP 07, October 1 3, 2007, Freiburg, Germany. Copyright c . 2007 ACM 978-1-59593-815-2/07/0010. \n. . $5.00 1. Introduction The iData toolkit (Plasmeijer and Achten 2006a,b) is a high level library for \ncreating interactive, thin client, web applications. It is a domain speci.c language embedded in the \npure, lazy functional programming language Clean. In order to validate the expressive\u00adness of the toolkit, \na number of non-trivial web applications have been developed, such as a web shop, a project administration \nsys\u00adtem (Plasmeijer and Achten 2006b), and a conference management system (Plasmeijer and Achten 2006c). \nBased on these case stud\u00adies, we observe that the iData toolkit is well suited to create com\u00adplex GUI \nforms, which can be used to create and change values of complex data types. However, the iData toolkit \ndoes not provide special support for the speci.cation of complex control .ows. An iData web application \nruns on a server and is started from scratch each time a page is demanded from a client. To realize a \ncontrol .ow, the application programmer needs to keep track of the current application state by means \nof data storages. This can lead to pro\u00adgrams that are dif.cult to comprehend and maintain, and it does \nnot scale well. In order to include control .ow to the iData toolkit, we have been inspired by contemporary \nwork .ow systems. Work .ow sys\u00adtems are automated systems in which work .ow situations are spec\u00adi.ed \n(typically in a graphical way) that need to be executed by hu\u00admans and computers. Current commercial \nwork .ow systems (such as Business Process Manager, COSA Work.ow, FLOWer, i-Flow 6.0, Staffware, Websphere \nMQ Work.ow, and YAWL) mainly deal with control .ow rather than data. Hence, it is not cut and clear whether \nthe data .ow oriented approach of the iData toolkit is suit\u00adable to support work .ows. In this paper \nwe present the iTask system. It is a combinator li\u00adbrary for the speci.cation of interactive multi-user \nweb-based work .ows. It is built on top of the iData toolkit, and both can be used within the same program. \nIt covers all known work .ow patterns that are found in contemporary commercial work .ow tools (van der \nAalst et al. 2002), and is thus suited to describe real-world ap\u00adplications. Moreover, we introduce a \nnumber of novel combinators to specify dynamic, higher-order, and recursive work .ows. The iTasks system \nmakes good use of the functional host language, and extend these patterns with strong typing, higher-order \nfunctions, lazy evaluation, and a monadic style of programming. Its founda\u00adtion upon the generic (Hinze \n2000; Alimarine 2005) features of the iData toolkit yields compact, robust, reusable and understandable \ncode. Work .ows are de.ned on a very high level of abstraction. It truly is an executable speci.cation, \nas much is done and generated automatically. This requires a signi.cant amount of explanation be\u00adfore \nwe show the expressive power in the examples. We start with a short overview of the iData toolkit in \nSect. 2. By making use of generic programming techniques, web forms (iData elements or editors) are generated \nand handled automatically for the used types. Arbitrarily complex dependencies between iData elements \ncan be de.ned in a functional style. Such editors behave in a similar way as cells in a spreadsheet: \nmaking a change in one of the editors automatically affects the contents of every editor that depends \non its value. In Sect. 3 we explain why this standard behav\u00adior of an editor is not suitable to express \ncontrol .ows conveniently and we show how this is solved in a suitable way: data editors be\u00adcome task \neditors. The concepts and their implementation are ex\u00adplained in a stripped down version of the iTask \nsystem: the iTask Core System. In Sect. 4 we illustrate the power of the full system by giving a representative \nset of work .ow examples. In Sect. 5 we reveal the most interesting aspects of the real implementation \nof the iTask system. We end with the discussion of related work in Sect. 6 and conclusions in Sect. 7. \n 2. The iData Toolkit In this section we present the classic iData toolkit. With this iData toolkit \none can create dynamic interactive web applications. These web applications are geared towards the manipulation \nof data, typical examples are calculators and web shops. The web ap\u00adplication at the server side performs \nall essential work, the browser at the client side just displays the HTML-code produced by the web application \nand passes the user input to the web application. This distribution of work is called a thin client architecture. \nFirst, we give an informal explanation of iData elements, which are the building blocks of the iData \ntoolkit (Sect. 2.1). Second, we present the programming paradigm (Sect. 2.2). 2.1 iData elements iData \nelements are the fundamental building blocks of the iData toolkit. An iData element is a typed unit that \nprovides the applica\u00adtion user with a GUI (an HTML form) that allows her to edit values of that given \ntype only. This editor can be derived automatically from the (recursive) type using the generic programming \nfacilities of Clean. If the generic behavior is not the desired one, the pro\u00adgrammer can de.ne a tailor \nmade form for all values of a speci.c type or even for individual values. In this paper, we use a few \nof the available toolkit functions to create iData elements. An iData element is created with a function \nof synonym type HStIO that transforms an opaque environment of type *HSt into a tuple containing its \nform and the new *HSt: ::HStIOd :== *HSt . (Form d,*HSt) A Form contains state information about the \niData element as well as the associated HTML code for the form corresponding to the iData element. *HSt \nis an opaque environment that contains the internal administration that is required for creating HTML \npages and handling forms. It can be updated destructively, hence the uniqueness type attribute *. Please \nconsult (Plasmeijer and Achten 2006a) for details of HSt. Passing a unique *HSt around between iData \nelements orders the manipulations of the iData elements. This effect is similar to using the IO monad \nin Haskell, but uniquely attributed states are passed around explicitly. The overloaded function mkIData \ncreates an iData element. mkIData is an explicit HSt environment transformer function. Its sig\u00adnature \nis (in Clean, type classes are enumerated at the end of a type signature, after the | symbol): mkIData \n:: (InIDataId d) .HStIO d | iData d class iData d | gForm {|l|}, iCreateAndPrint, gParse{|l|} , gerda \n{|l|}, TC d class iCreateAndPrint d | iCreate, iPrint d class iCreate d | gUpd {|l|} d class iPrint d \n| gPrint{|l|} d mkIData uses generic functions (in this case of kind *) to create iData elements (do \nnot confuse this kind with the uniqueness attribute). These are collected in the type class iData which \ngathers the six generic cornerstone functions of the iData toolkit. They can be used for values of any \ntype to automatically create an HTML form (gForm), to handle the effect of any edit action with the browser \nincluding the creation of default values (gUpd), to print or serialize any value (gPrint), to parse or \nde-serialize any value (gParse), to store, retrieve or update any value in a relational database (gerda), \nor to serialize and de-serialize values and functions in a Dynamic (using the compiler generated TC class). \nmkIData is applied to an (InIDataId d) argument that describes the type and value of the iData element \nthat is to be created: :: InIDataId d :== (Init, FormId d) :: Init = Const | Init | Set mkFormId :: String \nd .FormId d The function mkFormId creates a default (FormId d) value, given a unique identi.er string1 \nand the value of the iData element. Note that in Clean the arity of functions is denoted explicitly by \nwhite\u00adspace between the arguments, hence the arity of mkFormId is two. The Init value describes the use \nof that value: it is either a Constant or it can be edited by the user. In case of Init, it concerns \nthe initial value of the editor. Finally, it can be Set to a new value by the program. A(FormId d) value \nis a record that identi.es and describes the use of the iData element: :: FormId :: Lifespan d = { id \n:: String, ival :: d , lifespan :: Lifespan, mode :: Mode }= Database | Persistent | PersistentRO | Session \n| Page | Temp :: Mode = Edit | Submit | Display | NoForm The lifespan .eld controls the storage of the \nvalue of the iData element: it can be stored persistently on the server side on disk in a relational \ndatabase (Database) or in a .le (Persistent with RO read-only), it can be stored locally at the client \nsite in the web page (Session, Page (default)), or one can decide not to store it at all (Temp). Storage \nand retrieval of data is done automatically by the system. The mode .eld controls the rendering of the \niData value: by default it can be Edited which means that every change made in the form is communicated \nto the server, one can choose for the more traditional handling of forms where local changes can be made \nthat are all communicated when the Submit button is pressed, but it can also be Displayed as a constant, \nor it is not rendered at all (NoForm). To facilitate the creation of non-default (FormId d) values, the \nfollowing straightforward type classes have been de.ned: class (<@) infixl 4 att :: (FormId d) att .FormId \nd class (>@) infixr 4 att :: att (FormId d) .FormId d instance <@ String, Lifespan, Mode instance >@ \nString, Lifespan, Mode For instance, (mkFormId \"answer!\" 42 <@ Display) describes an iden\u00adti.er for an \niData element of type Int that has label \"answer!\", value 42, and cannot be edited by the user. When \nevaluated, (mkIData (init, iDataId)) basically performs the following actions: it .rst checks whether \nan earlier incarnation of the iData element (identi.ed by iDataId.id, i.e. the name of the iData element) \nexists. If this is not the case, or init equals Set, then iDataId.ival is used as the current value of \nthe iData element. If it already existed, then it contains a possibly user-edited value, which is used \nsubsequently. Hence, the .nal iData element is always up\u00adto-date. This is recorded in the (Form d) record: \n1 The use of strings for form identi.cation can be a source of (hard to locate) errors in the iData system. \nThe iTask system eliminates these issues by an automated systematic identi.cation system. = The  = :: \n= :: = Figure 1. (a) An Int editor. (b) A Person editor. A web application is any function that computes \nan HTML page, using an *HSt environment. Hence, its type is *HSt . (Html, *HSt). The function mkHtml, \nwhen given a string (to name a page) and HTML code (the body of the page), is such a function. The wrapper \nfunction doHtmlServer transforms it into an interactive program. doHtmlServer :: (*HSt . (Html,*HSt)) \n*World .*World mkHtml :: String [BodyTag] *HSt . (Html,*HSt) As an example, we show the complete code \nof a web application that allows users to edit integer values (see Fig. 2(a) for a screen shot). In Clean, \n. is a non-recursive let-de.nition which scope extends downwards. module singleIntegerEditor import StdEnv, \nStdHtml Start world = doHtmlServer tiny world tiny :: *HSt . (Html,*HSt) tiny hst . (intF,hst) = mkIData \n(Init,mkFormId \"answer!\" 42) hst = mkHtml \"Simple Example\" intF.form hst Notice that whenever the user \ncommits a change in one of the forms on a page with iData, the information is sent to the server which \nthen starts the corresponding Clean application from scratch. The application automatically recovers \nthe (possibly persistent) values of all iData elements, including those that may have been edited by \nthe user. In the tiny application, the effect is that the previous change made by the user is noticed \nand shown. This is not exciting, but by connecting iData elements, we can make interesting applications. \nFigure 2. (a) A single integer editor. (b) Display the sum of two integer input .elds.  2.2 Interconnecting \niData An interactive web application programmed with iData usually consists of a collection of interconnected \niData elements. Inter\u00adconnecting means that the value of iData elements may depend on the value of others. \nWe express this dependency as a function. The application programmer can exploit two important aspects \nof iData elements. First, the behavior of iData elements (discussed in Sect. 2.1) implies that they can \nbe shared, i.e.: multiple occurrences of the same iData identi.er within the interconnection relation \nall re\u00adfer to the same iData element. Second, the rendering of an iData el\u00adement (the .form .eld of its \nForm record) is perfectly separated from its behavior. The rendering can be used arbitrarily many times, \nor even not at all. Each rendering refers to the same iData element. We exploit these features in the \niTasks toolkit in the next sections. As stated at the end of Sect. 2.1, the web application is restarted \nfrom scratch every time a user event is posted to it from the client side. The interconnection relation \ndetermines dynamically which iData elements recover their, possibly edited, states and also de\u00adtermines \nwhat HTML output should be returned to the client side. The ability to recover all of its states is a \ncrucial feature of the iData system, because a web application is restarted on each event and hence has \nno notion of the previous state at that moment. As an example of interconnecting iData elements, consider \na program that creates two integer edit boxes and an integer display containing the sum of values of \nthe two edit boxes (Fig. 2(b)): Start world = doHtmlServer add world 1. add :: *HSt . (Html,*HSt) 2. \nadd hst 3. . (i1F,hst) = mkIData (Init,mkFormId \"i1\" 0) hst 4. . (i2F,hst) = mkIData (Init,mkFormId \n\"i2\" 0) hst 5. . (i3F,hst) = mkIData (Set, mkFormId \"sum\" 6.  (i1F.value + i2F.value)<@Display) hst \n7. = mkHtml \"Sum\" [STable [] [i1F.form,i2F.form,i3F.form]] hst 8. The two input elements are activated \nin lines 4 5. Their possibly edited values are used by the sum display in lines 6 7. Their forms are \ndisplayed in a single column in line 8. Notice the declarative nature of interconnecting iData elements: \none speci.es two input boxes and the display of their sum in a third, and this is indeed what we get \nover and over again whenever a user changes one of the input values. In that sense, the behavior of an \niData application can be compared with value changes made in a cell of a spreadsheet. The rendering and \nhandling of input is done automatically. Notice that making of a HTML-table that contains the forms of \nthe three iData elements is separated from the creation of the elements themselves.  3. Introduction \nto iTasks The following iData exercise was given to us by Phil Wadler: Suppose that you want two integer \nforms to appear one after another on the screen and then show the sum of them, how do you program this \nusing iData? The key concept in the iData toolkit is that an interactive appli\u00adcation is a collection \nof interconnected editors. From this point of view, the concept of a terminated editor is not the standard \nbe\u00adhavior of an iData editor. Instead, the collection of editors stays alive after each edit operation, \nallowing the user to enter other data as is also common in a spreadsheet. The exercise above illustrates \nthe need to specify the control .ow between editors as well. This is technically possible since all editors \nare created dynamically. How\u00adever, there is no speci.c support in the iData library to do this con\u00adveniently \nand in our case studies we have encountered similar situ\u00adations in which control .ows could be de.ned \nwith iData elements, but in an ad-hoc way. In this section we explain the principle of the iTasks toolkit. \nWe .rst show in Sect. 3.1 how a standard iData editor can be changed into an iTask editor by extending \nit with a storage for its evaluation state and a con.rmation button, which can be used by the user to \ncon.rm that the iData element is no longer required. This is de.ned entirely within the iData toolkit. \nWith this technique, an ad-hoc solution to Wadler s exercise can be constructed. This solution, however, \ndoes not scale up with real programs. In Sect. 3.2 we show a solution to Wadler s exercise using an extended \neditor and a monadic combinator library in a way that does scale well. 3.1 Handling a Sequence of Forms \nin iData We de.ne a special function to make a taskEditor. It is an ordinary editor extended with a Boolean \niData state in which we record whether the editor task is .nished. It is not up to an iData editor to \ndecide whether a task is .nished, but this is indicated by the user by pressing an additional button. \nHence, a standard iData editor is extended with a button and a boolean storage. These elements are created \nby the library functions simpleButton and mkStoreForm: simpleButton :: String String (d .d) .HStIO (d \n.d) mkStoreForm :: (InIDataId d)(d .d) .HStIO d | iData d (simpleButton l name f ) creates an iData element \nwhose appearance is that of a push button with given name. It is identi.ed with label l. When pressed \n(which is an edit operation by the user), its value is the function f, otherwise it is the identity function. \n(mkStoreForm iD f ) creates an iData element that applies f to its current state. With these two standard \nfunctions from the iData toolkit we can enhance any iData editor with a button and boolean storage: taskEditor \n:: String String a *HSt . (Bool,a,[BodyTag],*HSt) 1. | iData a 2. taskEditor btnName label v hst 3. \n. (btn, hst) = simpleButton btnLabel btnName (const True) hst 4. . (done, hst) = mkStoreForm (Init,mkFormId \nstoreLabel False) 5. btn.value hst 6. . (f, btnF) = if done.value ((>@) Display,Br)(id,btn.form) 7. \n . (idata,hst) = mkIData (Init,f (mkFormId editLabel v)) hst 8. = (done.value,idata.value,idata.form \n++ [btnF],hst) 9. where editLabel = label +> \"_Editor\" 10.  btnLabel = label +> \"_Button\" 11. storeLabel \n= label +> \"_Store\" 12. In the function taskEditor we create, as usual, an iData element for the value \nv (line 8). The label argument is used to create three additional identi.ers for the value (editLabel), \nthe button element (btnLabel), and the boolean storage element (storeLabel). In Clean, Strings are arrays \nof unboxed Chars. For convenient String concatenation, the overloaded operators (x+>str) and (str<+x) \nare used which concatenate the string representation of x and str. The trigger button (line 4) is a simple \nbutton that, when pressed, has the function value (const True), and which is the identity func\u00adtion id \notherwise. The boolean storage is created as an iData stor\u00adage (lines 5 6). It is interconnected with \nthe trigger button by its value: it applies the function value of the button to its boolean value (initially \nFalse). Therefore, the value of the boolean storage becomes True only if the user presses the trigger \nbutton. If the user has indicated that the editor has terminated, then the trigger but\u00adton should not \nappear (Br encodes <br>), and the iData element should be in Display mode, and otherwise the trigger \nbutton should be shown (btn.form) and the iData element should still be editable (line 7). In this way, \nthe user is forced to continue with whatever user interface is created after pressing the trigger button. \nBy using taskEditor instead of a regular editor we can formulate a solution to Wadler s exercise. sequenceIData \n:: *HSt . (Html,*HSt) sequenceIData hst . (done1,v1,form1,hst) = taskEditor \"Done\" \"v1\" 0 hst . (done2,v2,form2,hst) \n= taskEditor \"Done\" \"v2\" 0 hst  = mkHtml \"Naive solution:\" [ BodyTag form1 , if done1 (BodyTag form2) \nEmptyBody , if done2 (BodyTag [Txt \"+\" ,Hr [],toHtml (v1+v2)]) EmptyBody ] hst In this solution, different \nHTML code is generated depending on which iData element is .nished. In this case, the exercise was not \nhard, but the resulting code is not very declarative either. We have to explicitly analyze in which state \nthe program is (which tasks are .nished or not). Clearly, this style of programming will not scale to \nprograms where many different control .ows are possible. Additionally, we need to invent unique identi.ers \n(\"v1\", \"v2\", ...) for every iData element. However, the basic idea of extending iData elements with a \nboolean storage and trigger button turns out to be a valid one. We use it in the next section to create \na scalable solution.  3.2 The iTask Core System The reason why most web applications are much harder \nto pro\u00adgram, read and understand when compared with desktop applica\u00adtions is that desktop applications \ncan directly interact with the en\u00advironment at any point in time because they are directly connected \nwith that environment. Due to the client-server architecture, a web application cannot do this. A web \napplication emits an HTML page and terminates. It has to store information somewhere to handle the next \nrequest from the user in an appropriate way. It has to recover the relevant states, .nd out what it was \ndoing and what it has to do next. The resulting code is hard to understand. A conceivable alternative \napproach is to adopt the Seaside ap\u00adproach (Ducasse et al. 2004). If the application can automatically \nremember where it was, programs become easier to write and read. Since a Clean application is compiled \nto native code, suspending execution, as Seaside does, involves creating core dumps of the run-time system. \nHowever, a work .ow system needs to support several users that work together. The action of one user \ncan in.u\u00adence the work of others. A core dump only re.ects the work of one user. For this reason, we \npropose a simpler set-up of the system: we start the same application from scratch, as we already did, \nand use iData elements to remember the state for all users. For a pro\u00adgrammer, the application still \nappears to behave as if it continues evaluation after an I/O request from a browser. In this section \nwe introduce the main principles of the iTasks system. For didactic reasons we restrain ourselves to \na strongly simpli.ed iTasks core system. This core system is single user and has limited possibilities \nto manipulate tasks. With the core system, we create a satisfying solution to Wadler s exercise. In Sect. \n4 we extend this to a full .edged multi-user system. 3.2.1 Editors as Primitive iTask in the Core System \niTasks are de.ned on top of iData. An iTask is a state transition function of the following type: ::Task \na :== *TSt . (a,*TSt) Later in this section we show how tasks can be sequentially com\u00adposed. iTasks work \non a unique state *TSt which extends the unique iData state *HSt with a boolean value activated to indicate \nthe status of a task (when a task is called it tells whether it has to be activated or not, when a task \nhas been evaluated it tells whether it is .nished or not), a tasknr for the automatic generation of fresh \ntask iden\u00adti.er values, and html which accumulates all HTML output. For each of these .elds, we introduce \ncorresponding update functions (set_activated, set_tasknr, and set_html). :: *TSt = { hst :: *HSt , activated \n:: Bool , tasknr :: TaskID , html :: [BodyTag] }:: TaskID :== [Int] set_activated :: Bool *TSt .*TSt \nset_tasknr :: TaskID *TSt .*TSt set_html :: [BodyTag] *TSt .*TSt We .rst introduce a function that lifts \nan extended iData ele\u00adment, as described in Sect. 3.1, to an iTask: editTask :: String a .Task a | iData \na editTask name a = doTask editTask where editTask tst=:{tasknr,hst,html} . (done,na,nhtml,hst) = taskEditor \nname (toString tasknr) a hst = (na,{tst &#38; activated = done, hst = hst, html = html ++ nhtml}) editTask \ntakes an initial value of any type and delivers an iTask of that type. When the task is activated, an \nextended iData element is created by calling taskEditor. Any iData element automatically remembers the \nstate of any edit action, no matter how complicated the editor is. The HTML code produced by taskEditor \nis added to the accumulator of the iTask state. In the end all HTML code of all iTasks can be displayed \nby showing the HTML of the top-task. There can be many active iTasks, so in practice this is probably \nnot what we want. However, for the core system this will do. The function doTask is an internal wrapper \nfunction that is used within the iTasks toolkit for every iTask (note that o is function composition). \ndoTask :: (Task a) .Task a | iCreate a doTask mytask = evalTask o incTaskNr where evalTask tst=:{activated, \ntasknr} | not activated = (default, tst) . (val, tst) = mytask tst = (val,{tst &#38; tasknr = tasknr}) \n doTask .rst ensures that the task number is incremented. In this way, each task obtains a unique number, \nwhich eliminates the shortcom\u00ading that was mentioned in Sect. 3.1. Tasks are numbered system\u00adatically, \nin the same way as chapters, sections and subsections are numbered in a book or in this paper: tasks \non the same level are numbered subsequently with incTaskNr below, whereas a subtask j of task i is numbered \ni.j with subTaskNr below. Fresh subtask numbers are generated with newSubTaskNr. We use a reversed list \nof integers for this administration. incTaskNr tst = {tst &#38; tasknr = case tst.tasknr of [] . [0] \n[i:is] . [i+1:is] }subTaskNr i tst = {tst &#38; tasknr = [ i:tst.tasknr]}newSubTaskNr tst = {tst &#38; \ntasknr = [-1:tst.tasknr]} The systematic numbering is important because it is also used for garbage collection \nof subtasks (see Sect. 5). Next doTask checks whether the task indeed is the next task to be activated \nby inspecting the value of tst.activated: If not activated, the default value is returned. This explains \nthe overloading context restriction of doTask. As a consequence, an iTask always has a value, just as \nan iData element.  If activated, the task can be executed. This means that the user can select this \ntask via the web interface, and proceed by generating an input event for this task. Task de.nitions are \ncompositional, so the started tasks may consist of many subtasks of arbitrary complexity. When a task \nis started, it is either activated (or re-activated for further evaluation) or, in case the task has \nalready been .nished in the past, its result is stored as an iData object and is retrieved. In any of \nthese cases, the result of a task (either .nished or not yet .nished) is returned to the caller of doTask \nand the task number is reset to its original value.  It is assumed that any task sets activated to True \nif the task is .nished (indicating that the next task can be activated), and to False otherwise. In the \nlatter case the user still has to do more work on it in the newly created web page.  3.2.2 Basic Combinators \nof the Core System Now we introduce iTask combinators for the sequential composi\u00adtion of iTasks. Thanks \nto uniqueness typing we can freely choose how to thread the unique iTask state *TSt: either explicitly \nin the Clean style or implicitly using a monadic style. In the implemen\u00adtation of the iTask system we \nhave chosen for the explicit style: it gives more .exibility because we have direct access to both the \nunique iTask state *TSt and the unique iData state *HSt as is shown in the de.nition of editTask. However, \nto the application pro\u00adgrammer *TSt is an opaque environment, and for her we provide a monadic interface. \n(=>>) infix 1 :: (Task a)(a .Task b) .Task b (.> ) infixl 1 :: (Task a)(Task b) .Task b return :: a .Task \na It is convenient to have an alternative return_D function that also displays the returned value. Its \nde.nition is straightforward: return_D :: a .Task a | gForm{|l|}, iCreateAndPrint a return_D a = doTask \n(.tst . (a,{tst &#38; html = tst.html ++ toHtml a}) When a task is in progress, it is useful to provide \nfeedback to the user what she is supposed to be doing. For this purpose two combinators are introduced. \n(p ?>>t) is a task that displays prompt p as long as task t is running, whereas (p !>> t) always displays \nprompt p as soon as task t is activated. (?>>) infix 5 :: [BodyTag](Task a) .Task a | iCreate a (?>>) \nprompt task = prompt_task where prompt_task tst=:{html = ohtml,activated} | not activated = (default,tst) \n. (a,tst=:{activated,html = nhtml}) = task {tst &#38; html = []} | activated = (a,{tst &#38; html = ohtml}) \n| otherwise = (a,{tst &#38; html = ohtml ++ prompt ++ nhtml}) (!>>) infix 5 :: [BodyTag](Task a) .Task \na | iCreate a (!>>) prompt task = prompt_task where prompt_task tst=:{html = ohtml,activated} | not activated \n= (default,tst) . (a,tst=:{html = nhtml}) = task {tst &#38; html = []} = (a,{tst &#38; html = ohtml ++ \nprompt ++ nhtml}) With these de.nitions, the solution to Wadler s exercise, given by sequenceITask in \nFig. 3, becomes surprisingly simple. Notice that the solution not only works for integers, since sequenceITask \nis overloaded. It works for any type on which iData and + are de.ned. The implementation is concise, \nwhich is completely due to the power of the underlying iData library. sequenceITask :: Task a | iData, \n+a sequenceITask = editTask \"Done\" default =>> .v1 . editTask \"Done\" default =>> .v2 . [Txt \"+\" ,Hr []] \n!>> return_D (v1+v2) Figure 3. The sum exercise, as an iTask application. The screen shot shows that \nthe iTasks implementation adds a tracing option at the top of the window. For each user, the main tasks \nare displayed in a column. The selected main task is displayed next to this column.  3.2.3 Re.ection \n(Part I) The behavior of the described core system is a combination of re\u00adevaluating the application \nand having the extended iData elements retrieve their previous states that are possibly updated with \nthe latest changes done by the application user. The Clean application is still restarted from scratch \nwhen a new page is requested from the browser. However, the application will now automatically .nd its \nway back to the tasks it was working on during the previous incarnation. Any iTask editor created with \neditTask automatically remembers its contents and state (.nished or not) while the other iTask combinators \nare pure functions which can be recalculated and in this way the system can determine which other tasks \nhave to be inspected next. Tasks that are not yet activated might deliver some default value, but it \nis not important because it is not used anywhere yet, and the task produces no HTML code. In this way \nwe achieve the same result as in Seaside, albeit that we reconstruct the state of the run-time system \nby a combination of re-evaluation from scratch and restoring of the previous edit states. 3.2.4 Work \nFlow Pattern Combinators of the Core System The core system presented above is extendable. The sequential \ncomposition is covered by the combinators =>> and .>>. In this section we introduce parallel composition, \nrepetition and recursion. In Sect. 6 we discuss their relation with work .ow patterns found in contemporary \nwork .ow tools. The in.x operator (t1 -&#38;&#38;-t2 ) activates subtasks t1 and t2 and ends when both \nsubtasks are completed; the in.x operator (t1 -||-t2 ) also activates two subtasks t1 and t2 but ends \nas soon as one of them terminates, but it is biased to the .rst task at the same time. In both cases, \nthe user can work on each subtask in any desired order. A subtask, like any other task, can consist of \nany composition of iTasks. (-&#38;&#38;-) infixr 4 :: (Task a)(Task b) .Task (a,b) | iCreate a &#38; \niCreate b (-&#38;&#38;-) taska taskb = doTask and where and tst=:{tasknr} . (a,tst=:{activated=adone}) \n= mkParSubTask 0 tasknr taska tst . (b,tst=:{activated=bdone}) = mkParSubTask 1 tasknr taskb tst = ((a,b),set_activated \n(adone &#38;&#38; bdone) tst  (-||-) infixr 3 :: (Task a)(Task a) .Task a | iCreate a (-||-) taska taskb \n= doTask or where or tst=:{tasknr} . (a,tst=:{activated=adone}) = mkParSubTask 0 tasknr taska tst . (b,tst=:{activated=bdone}) \n= mkParSubTask 1 tasknr taskb tst = ( if adone a ( if bdone b default) ,set_activated (adone || bdone) \ntst ) mkParSubTask :: Int TaskID (Task a) .Task a mkParSubTask i tasknr task = task o newSubTaskNr o \nset_activated True o subTaskNr i The function mkParSubTask is a special wrapper function for sub\u00adtasks. \nIt is used to activate a subtask and to ensure that it gets a correct task number. Another iTask combinator \nis foreverTask which repeats a task in.nitely many times. foreverTask :: (Task a) .Task a | iCreate a \nforeverTask task = doTask (foreverTask task o snd o task o newSubTaskNr) As an example, consider the \nfollowing de.nition: t = foreverTask (sequenceITask -||-editTask \"Cancel\" default) In t the user can \nwork on sequenceITask, but while doing this, she can always decide to cancel it. After completion of \nany of these alternatives the whole task is repeated. More general than repetition is to allow arbitrary \nrecursive work .ows. A crucial combinator for recursion is newTask. newTask :: (Task a) .Task a | iCreate \na newTask task = doTask (task o newSubTaskNr) (newTask t) promotes any user de.ned task t to a proper \niTask such that it can be recursively called without causing possible non\u00adtermination. It ensures that \nt is only called when it is its turn to be activated and that an appropriate subtask number is assigned \nto it. Consider the following example of a recursive work .ow: getPositive :: Int .Task Int getPositive \ni = newTask (getPositive i) 1. where 2. getPositive i = [Txt \"Type in a positive number:\"] 3. ?>> editTask \n\"Done\" i =>> .ni . 4. if (ni > 0) (return ni)(getPositive ni) 5. Function getPositive requests a positive \nnumber from the user. If this is the case the number typed in is returned, otherwise the task calls itself \nrecursively for a new attempt. This example works .ne. However, it would not terminate if getPositive \ncalls itself directly in line 5 instead of indirectly via a call to newTask. Remember that every editor \nreturns a value, whether it is .nished or not. If it is not yet .nished, it returns default. The default \nvalue for type Int happens to be zero, and therefore by default getPositive goes into recursion. The \nfunction newTask will prevent in.nite recursion because the indicated task will not be activated when \nthe previous task is not yet .nished. Hence, one has to keep in mind to regard getPositive as a task \nthat can be recursively activated, and not as a plain recursive function. The combinator repeatTask repeats \na given task, task, until the predicate p holds. repeatTask task p = t default where tv = newTask (task \nv) =>> .nv . if (p nv)(return_D nv)(t nv) Using this combinator the task getPositive can be expressed \nas: getPositive = repeatTask (.i . [Txt \"Type in a positive number:\"] ?>> editTask \"Done\" i)(.x .x>0) \nNote the importance of the place of newTask. If it would be moved to the recursive call, by replacing \n(tv) by newTask (tv), the task would always be executed immediately for a .rst time (i.e. without waiting \nfor activation). This is generally not the desired behavior. 3.2.5 Re.ection (Part II) With the combinators \npresented above, iTasks can be composed as desired. As discussed in Sect. 3.2.4, one can imagine all \nkinds of additional combinators. For all well-known work .ow patterns we have de.ned iTask combinators \nthat mimic their behavior. In the next section we discuss the most important ones and show their usage. \nThe actual implementation of the combinators in the iTask library is more complicated than the combinators \nintroduced in the core system. There are additional requirements, such as: Presentation issues: One can \nconstruct complicated tasks that have to be presented to users systematically and clearly. The system \nneeds to prompt the user for information on the right moment, remove feedback information when it is \nno longer needed, and so on. A user might have to work on several tasks in any order she wants. Such \ntasks have to be presented clearly as well, e.g. by creating a separate web page for each task and a \nbutton to navigate between these tasks. Multiple users: A work .ow system is a multi-user system. Tasks \ncan be assigned to different users, persistent storage and re\u00adtrieval of information in a database needs \nto be handled, think about version control, ensure consistent behavior by ruling out possible race conditions, \nensure that the correct information is communicated to each user, inform a user that she has to wait \non information to be produced by someone else, and so on. Ef.ciency: Real world work .ow systems run \nfor years. How can we ensure that the system will scale up and that it can reconstruct itself ef.ciently? \nFeatures: One can imagine many more options one would like to have. For instance, it might be important \nthat tasks are per\u00adformed on time. A manager might want to know which tasks and/or persons are preventing \nthe completion of other tasks. In the next section we present the iTask combinators including sup\u00adport \nfor these features. The consequences this has for the imple\u00admentation of our core system is described \nnext.   4. Overview of the iTasks System In this section we present the main concepts of the iTasks \ntoolkit by means of a number of examples. Please note that despite their small size, they do represent \ncomplex work .ow situations that occur in the real world. Some of these situations can not be handled \nby contemporary work .ow speci.cation tools. 4.1 Sequence and choice: a single step coffee machine Coffee \nvending machines are popular examples to illustrate se\u00adquencing and choice. We present an example of \na coffee machine that offers the user either coffee or tea. After choosing, the user pays the proper \namount of money and obtains the selected product. This also terminates the coffee machine: Start world \n= doHtmlServer (singleUserTask coffeemachine) world coffeemachine :: Task (String,Int) coffeemachine \n= [Txt \"Choose product:\"] ?>> chooseTask [(p <+ \": \" <+ c, return prod) \\\\ prod=:(p,c) .products ] \n=>> .prod=:(p,c) . [Txt (\"Chosen product: \" <+ p)] ?>> pay prod (buttonTask \"Thanks\" (return prod)) \nwhere products = [(\"Coffee\",100),(\"Tea\",50)] pay (p,c) t = buttonTask (\"Pay \" <+ c <+ \" cents\") t The \ncombinators that are used in this example are: buttonTask :: String (Task a) .Task a | iCreateAndPrint \na chooseTask :: [(String, Task a)] .Task a | iCreateAndPrint a (buttonTask lt) enhances a task t with \na push button labeled with l that needs to be pressed .rst by the user before she can do t. Choosing \nbetween alternatives of labeled actions li and tasks ti is given by chooseTask [(l0 ,t0 )... (ln ,tn \n)]. The resulting value is the value of the selected task ti. The function singeUserTask is a wrapper \nfunction that converts an iTask to an iData environment transformer function: singleUserTask :: (Task \na) *HSt . (Html,*HSt) | iCreate a  4.2 Repetition, recursion and state: a coffee machine The coffee \nmachine in the previous example offers a single bever\u00adage, and terminates. It is extended to an eternal \nvending machine with the foreverTask combinator: Start world = doHtmlServer (singleUserTask (foreverTask \ncoffeemachine)) world The previous example abstracted from the paying task: the function (pay (p,c) t) \noffers a labeled action to pay the full amount of money, and then continues with task t. In a more re.ned \nmodel, the user is able to insert coins until the inserted amount of money exceeds the cost of the product. \nMoreover, she can also choose to abandon the paying task and not get the selected drink at all. This \nis suitably modeled with a recursive task speci.cation: getCoins :: ((Bool,Int,Int) .Task (Bool,Int,Int)) \ngetCoins = repeatTask get (.(cancel,cost,_) .cancel || cost = 0) where get (cancel,cost,paid) = newTask \n\"pay\" ([Txt (\"To pay: \" <+ cost)] ?>> chooseTask [(c+> \" cents\" , return (False,c)) \\\\ c .coins ] -||\u00adbuttonTask \n\"Cancel\" (return (True,0)) =>> .(cancel,c) .return (cancel,cost-c,paid+c)) coins = [5,10,20,50,100,200] \n The crucial combinator in this de.nition is newTask which was introduced in Sect. 3.2.4 (the additional \nstring argument is used for tracing). Clearly, we regard getCoins not as a common recursive function, \nbut as a de.nition of a recursive task that has to be activated when the previous task, which might be \nthe previous invocation of getCoins, is .nished. We can now rede.ne the pay function of Sect. 4.1: pay \n(p,c) t = getCoins (False,c,0) =>> .(cancel,_,paid) . [Txt (\"Product = \"<+if cancel \"cancelled\" p <+\". \nReturned money = \"<+(paid-c))] ?>> t It should be noted that getCoins and pay illustrate that tasks may \ndepend on the actual values that are generated within the system. These kind of work.ows are hard to \nmodel with current day work .ow speci.cation tools.  4.3 Multi-User Work.ows The solution to Phil Wadler \ns exercise that was given in Sect. 3, was a single user application. Work .ow systems usually involve \narbitrarily many users. This is supported by the iTask system. multiUserTask :: Int (Task a) *HSt . (Html,*HSt) \n| iCreate a :: UserID :== Int We identify users with index values i = 0. The wrapper function (multiUserTask \nnt) creates a work .ow system, de.ned by t for users 0 ...n - 1. For quick testing, it provides an additional \nuser interface for selecting the proper user. By default, tasks store their information on the client \nside. If one wants to use the system with multiple users over the net, one has to store iTask information \npersistently on the server side. To conveniently control this, we introduce similar operations as <@ \nand @>(Sect. 2.1). class (<<@) infix 3 att :: (Task a) att .Task a class (@>>) infix 3 att :: att (Task \na) .Task a instance <<@ Lifespan, Mode instance @>> Lifespan, Mode The operators can be applied to any \ntask or task expression to set the attributes of all underlying iData elements. So, (task<<@Persistent) \nstores the information of all the underlying iData in .les while (task<<@Database) stores the information \nin a relational database. Storage and retrieval is handled automatically (Sect. 2). Assigning a task \nt to user i with some motivation m is done by (m ,i)@:t. If there is no motivation, then one uses i@::t. \n(@:) infix 3 :: (String,UserID)(Task a) .Task a | iCreate a (@::) infix 3 :: UserID (Task a) .Task a \n| iCreate a Suppose that the .rst integer editing task in Wadler s exercise should be performed by user \n1, the second by user 2, and the result is shown to user 0 (the default user). The code becomes: sequenceMU \n:: Task a | iData, +, zero a sequenceMU = (\"Enter a number\" ,1) @: editTask \"Done\" zero =>> .v1 . (\"Enter \na number\" ,2) @: editTask \"Done\" zero =>> .v2 . [Txt \"+\" ,Hr []] !>> return_D (v1 + v2) Start world \n= doHtmlServer (multiUserTask 2 sequenceMU <<@ Persistent) world The iTask system ensures that each user \nsees only tasks assigned to them. This is essentially a .lter of the full task tree, because any task \nmay decide to assign tasks to any other user.  4.4 Speculative tasks and multiple users: deadlines Work \n.ow systems need to handle time-related tasks: some task t has to be .nished before a given time T or \nit is canceled. In this example we show how this is expressed with the iTasks toolkit. The time related \ncombinators are the following: waitForDateTask :: HtmlDate .Task HtmlDate waitForTimeTask :: HtmlTime \n.Task HtmlTime waitForTimerTask :: HtmlTime .Task HtmlTime The algebraic types HtmlDate and HtmlTime \nare elements of the iData toolkit that have been specialized to show user convenient date and time editors. \nwaitForDate(Time)Task terminates in case the given date (time of day) has passed; waitForTimerTask terminates \nafter a given time interval. In our example, we use the latter combinator to delegate work: delegateTask \nwho time t 1. = (\"Timed Task\" ,who)@: 2. waitForTimerTask time .>> return Nothing 3. -||-4. [Txt (\"Please \nfinish task before\" <+ time)] 5. ?>> (t =>> .v .return (Just v)) 6. ) 7. (delegateTask i dt t) assigns \na task t to user i that needs to be .n\u00adished before dt time (line 5 6) is passed. If the user does not \ncom\u00adplete the task on time, delegation fails, and should also terminate (line 3). The main work .ow situation \nis modeled as follows: deadline :: (Task a) .Task a | iData a 1. deadline t 2. = [Txt \"Choose person \nyou want to delegate work to:\"] 3. ?>> editTask \"Set\" (PullDown size (0,map toString [1..n])) 4. =>> \n.who . 5. [Txt \"How long do you want to wait?\"] 6. ?>> editTask \"SetTime\" default =>> .time . 7. [Txt \n\"Cancel delegated work if you get impatient:\"] 8. ?>> delegateTask who time t 9. -||-10. buttonTask \"Cancel\" \n(return Nothing) =>> check 11. where check result 12. = case result of 13. (Just value) . [Txt (\"Result \nof task: \" <+ value)] 14. ?>> buttonTask \"OK\" (return value) 15. Nothing . [Txt \"Task expired/canceled; \ndo it yourself!\"] 16. ?>> buttonTask \"OK\" t 17. The main task consists of selecting a user to whom a \ntask t should be delegated (lines 3 5), deciding how much time this user is given for this exercise (lines \n6 7), and then delegating the task (line 9). We also model the situation that the current user gets impatient, \nand decides to abandon the delegated task (line 11). Either way, we know whether the task has succeeded \nand display the result and terminate (lines 14 15), or the current user has to do it herself (lines 16 \n17). The work .ow described by (deadline t) de.nes a single dele\u00adgation. It can be transformed into an \niteration with the foreverTask combinator that we have also used in Sect. 4.2. We are obviously creating \na multi-user system, and hence use the multiUserTask wrap\u00adper function for some constant n> 0. As example \ntask we reuse the task getPositive from Sect. 3.2.4. This .nalizes the example: Start world = doHtmlServer \n(multiUserTask n (foreverTask (deadline getPositive) <<@ Database)) world 4.5 Parameterized tasks: a \nreviewing process In this example we show that iTasks and iData cooperate in close harmony. We present \na reviewing process in which the product of a user is judged by a reviewer who can either approve, reject, \nor demand rework of the product. The latter is described with an algebraic data type: :: Review = Approved \n| Rejected | NeedsRework TextArea TextArea is an algebraic data type that is specialized by the iData \ntoolkit as a multi-line text edit box that can be used by the reviewer to enter comments. A reviewer \ninspects the product v that needs to judged, and makes a decision. This is de.ned concisely as: review \n:: a .Task Review | iData a review v = [toHtml v] ?>> chooseTask [(\"Rework\" , editTask \"Done\" (NeedsRework \ndefault) <<@ Submit) ,(\"Approved\" , return Approved) ,(\"Reject\" , return Rejected) ] Any task result \nthat can be displayed can also be subject to review\u00ading, hence the restriction to the generic iData class. \nThe main task is to produce a product v according to some task t that can be judged by a reviewer u. \nIf the reviewer demands rework of v, the task should be restarted with that particular v, because the \nuser would have to completely recreate a new product otherwise. Therefore, the product and the task to \nproduce it are given as a pair (a, a .Task a), and the result of the main task is to return a product \nand its review (a,Review). This is done as follows: taskToReview :: UserID (a,a .Task a) .Task (a,Review) \n| iData a 1. taskToReview reviewer (v,task) 2. = newTask \"taskToReview\" 3. ( task v =>> .nv . 4. reviewer \n@:: review nv =>> .r . 5. [Txt (\"Reviewer \" <+ reviewer <+ \" says \"),toHtml r] 6. ?>> buttonTask \"OK\" \n7. case r of 8. (NeedsRework _) .taskToReview reviewer (nv,task) 9. else .return (nv,r) 10. ) The task \nis performed to return a product (line 4), which is reviewed by the given reviewer (line 5). Her decision \nis reported (line 6), and only in case of a demanded rework, this has to be repeated (line 9). For the \nexample, we select a two-user system (multiUserTask 2) in which user 0 creates the product, and user \n1 reviews it: Start world = doHtmlServer (multiUserTask 2(taskToReview 1(default,t))) world t v = [Txt \n\"Fill in Form:\"] ?>> editTask \"TaskDone\" v <<@ Submit Note the high degree of parameterization and therefore \nreusability of the code: taskToReview handles any task, and by providing only a type signature to t above, \nwe get a form task for values of that type for free. For example, when t is of type Person (Sect. 2.1) \nan editor for this type is created automatically.  4.6 Higher order tasks: shifting work A distinctive \nfeature of the iTask system is that tasks can be higher order: data can be communicated but also (partially \nevaluated) tasks can. One can create task closures, i.e. tasks that already have been partially evaluated \nby someone and ship them to some other user who can continue to work on it. :: TClosure a = TClosure \n(Task a) (-!>) infix 4 :: (Task s)(Task a) .Task (Maybe s, TClosure a) | iCreateAndPrint s &#38; iCreateAndPrint \na The proper generic functions have been specialized for type TClosure such that it acts as a container \nof tasks. Any task can be put in a value of this type, but we want to be able to put a partially evaluated \ntask in it. Therefore we need a way to interrupt a task that is being evaluated. (stop -!> t) (the implementation \nof -!> is dis\u00adcussed in Sect. 5.4) is a variant of an or-task which takes two tasks: whenever stop is \ndone, t is interrupted and this possibly partially evaluated task is delivered as result. However, t \ncan also .nish nor\u00admally, and the fully completed task is delivered. The result of stop, therefore, is \nonly returned when it .nishes before t. delegate :: (Task a)[UserID] .Task a | iData a 1. delegate task \nset = newTask \"delegate\" doDelegate 2. where 3. doDelegate 4. = findSomeone =>> .who . 5. who @:: stopTask \n-!> task =>> .(stopped,TClosure task) . 6. if (isJust stopped)(delegate task set) task 7. findSomeone \n8. = orTasks [(\"Wait \" <+ who 9. , who @:: buttonTask \"I will do it\" (return who)) 10. \\\\ who .set] 11. \nstopTask = buttonTask \"Stop\" (return True) 12. The function delegate .rst tries to findSomeone to perform \nthe task (line 5). All persons in set are asked whether they want the task. The .rst user who accepts \nthe task obtains it and she can work on it. However, the work can be interrupted by completion of stopTask \nwhich ends when the user has pushed the Stop button. If this is the case, all persons are asked again \nto volunteer for the job. The one who accepts, obtains the task in the state as it has been left by the \nprevious worker and she can continue to work on it. The whole recursively de.ned process .nally ends \nwhen the delegated task is fully completed by someone. The conditions for stopping a task can be arbitrarily \ncomplex. For instance, by using stop2 not only the user herself can stop the task, but someone else can \ndo it for her as well (e.g. the user who delegated the task in the .rst place), or it can be timed out. \nstop2 user time = stopTask -||-(user @:: stopTask) -||-timer time timer time = waitForTimerTask time \n.>> return True  5. Implementation As mentioned earlier in Sect. 3.2.5, the actual implementation is \nmore complicated because it needs to support more features. We discuss the most interesting aspects by \nbuilding on the core system. 5.1 Handling Multiple Users On each event every iTask application is (re)started \nfor all its users. All tasks are recalculated from scratch, but only for one user the tasks are shown. \nBy default, tasks are assigned to user 0. As presented in Sect. 4.3, users can be assigned to tasks with \nthe operators @: and @::. We give the HTML accumulator within the TSt environment (Sect. 3.2.1) a tree \nstructure instead of a list structure, and we keep track of the user to whom a task is assigned, as well \nas the identi.cation of the application user: :: *TSt = { ... , myId :: UserID // id of task user , userId \n:: UserID // id of application user , html :: HtmlTree } // accumulator for html code :: HtmlTree = BT \n[BodyTag] | (@@:) infix 0(UserID,String) HtmlTree | (-@:) infix 0 UserID HtmlTree | (+-+) infixl 1 HtmlTree \nHtmlTree | (+|+) infixl 1 HtmlTree HtmlTree defaultUser = 0 (BT out) represents HTML output; ((u ,name)@@:t) \nassigns the html tree t to user u where name is the button with which the user can select this task; \n(u-@:t) also assigns the html tree t to user u, but now t should not be displayed. The remaining constructors \n(t1+-+t2 ) (and (t1+|+t2 )) place output t1 left (above) of output t2. In a single-user application, \nthe only user is defaultUser; in a multi-user application, the current user can be selected with a menu \nat the top of the browser window. This feature is added for testing, for the .nal application one needs \nof course to add a decent login procedure. Initially, myId is defaultUser, userId is the selected user, \nand the accumulator html is empty (BT []). After evaluation of a task, the accumulator contains all HTML \noutput of each and every activated iTask. It is not hard to de.ne a .ltering function that extracts all \ntasks for the current user from the output tree. Version management is important as well for a multi-user \nweb enabled system. Back buttons of browsers and cloning of browser windows might destroy the correct \nbehavior of an application. For every user a version number is stored and only requests matching the \nlatest version are granted. An error message is given otherwise after which the browser window is updated \nshowing the most recent version. Since we only have one application running on the server side, storage \nand retrieval of any information is guaranteed to be indivisible such that problems in this area cannot \noccur. Another aspect to think about is that the completion of one task by one user, e.g. a Cancel action, \nmay remove tasks others are working on (see e.g. the deadlines example in Section 4.4). This effects \nthe implementation of all choice combinators: one has to remember which task was chosen to avoid race \nconditions. 5.2 Optimizing the Reconstruction of the Task Tree An iTask application reconstructs itself \nover and over each time a client browser is manipulated by someone. The more progress made in the application, \nthe more tasks are created. Hence, the evaluation tree increases in size and it takes longer to reconstruct \nit. For a real world work .ow application this is unacceptable. We optimize the reconstruction process \nsimilar to the normal rewriting that takes place in the implementation of functional lan\u00adguages such \nas Clean and Haskell. When a closure is evaluated, the function call is replaced by its result. Similar, \nwhen a task is .nished, it can be replaced by its result. We have to store such a result persistently, \nfor which we can of course again use an iData element. However, it is not necessary to optimize each \nresult in order to avoid the creation of too many iData storages. We can freely choose between recalculation \n(saving space) or storing (sav\u00ading time). In the iTask toolkit we have decided to optimize big tasks \nonly. Combinators such as repeatTask produce only interme\u00addiate results and can be replaced by the next \ncall to itself. For these kinds of combinators the task tree will not grow at all. However, user de.ned \ntasks that are created with newTask are likely being used to abstract from such big tasks. Here is what \nthe actual newTask combinator does, as opposed to the core version of Sect. 3.2.4. newTask :: (Task a) \n.Task a | iData a 1. newTask t = doTask (.tst=:{tasknr,hst} 2. . (taskval,hst) = mkStoreForm (Init,storeId) \nid hst 3. . (done,v) = taskval.value 4. | done = (v,{tst &#38; hst = hst}) 5. . (v,tst=:{activated \n= done,hst}) 6.  = t {tst &#38; tasknr = [-1:tasknr],hst = hst} 7. | not done = (v,{tst &#38; tasknr \n= tasknr}) 8. . (_,hst) = mkStoreForm (Init,storeId)(const (True,v)) hst 9. = (v,{tst &#38; tasknr = \ntasknr, hst = hst}) 10. ) 11. where storeId = mkFormId (tasknr +> \"_New\") 12. (False,default) <@ Session \n13. A storage is associated with task t (line 3) that initially has a default value (lines 12 13). If \nthe task was .nished in the past, it is not re\u00adevaluated. Instead, its value is retrieved from the storage \n(line 4 and 5), otherwise it needs to be evaluated (lines 6 7). If the user actions have not terminated \ntask t, then it has not produced a .nal value yet, thus the storage need not be updated (line 8). If \nthe user has terminated the task, then the storage is updated with the .nal value (line 9), and a boolean \nmark to prevent re-evaluation of this particular redex . 5.3 Garbage Collection of iData Objects The \noptimization described above will prevent the task evaluation tree from growing, but all persistent iData \nobjects created in previ\u00adous runs are not garbage collected automatically. Although certain results are \nnot needed for the computation of the task tree anymore, one nevertheless might want to keep them for \nother reasons. Con\u00adsider the gathering of statistical information such as who has per\u00adformed a certain \ntask in the past? and which tasks have taken a long time to complete? , or one wants to remember a result \nof a task, but not of any of its subtasks. For this reason, we have pro\u00advided an option that can be switched \non and off to automatically take care of the garbage collection of tasks and their subtasks, no matter \nwhere they are stored. The numbering discipline plays a cru\u00adcial role in identifying which subtasks belong \nto a given task, such that any choice of garbage collection strategy can be implemented. 5.4 Higher-Order \nTasks A distinctive feature of the iTask toolkit is the ability to commu\u00adnicate higher-order tasks that \nhave been partially evaluated (Sect. 4.6). In the real world it is obvious that work that has been done \npartially can be handed over to other persons who .nish the work. This is not one of the standard work \n.ow patterns that can be found in contemporary work .ow tools (see (van der Aalst et al. 2002)). We show \nthat the iTask toolkit does support this work .ow pattern, and that it does so in a concise way. The \ncomplete realization of the (p-!>t) is as follows: (-!>) infix 4 :: (Task s)(Task a) .Task (Maybe s,TClosure \na) 1. | iCreateAndPrint s &#38; iCreateAndPrint a 2. (-!>) pt = doTask (.tst=:{tasknr,html} 3. . (v,tst=:{activated \n= done,html = task}) 4. = t {set (BT []) True tst &#38; tasknr = taskId} 5. . (s,tst=:{activated = halt,html \n= stop}) 6. = p {set (BT []) True tst &#38; tasknr = stopId} 7. | halt = return (Just s, TClosure (close \nt)) 8. (set html True tst) 9. | done = return (Nothing,TClosure (return v)) 10. (set (html +|+ task) \nTrue tst) 11. | otherwise = return (Nothing,TClosure (return v)) 12. (set (html +|+ task +|+ stop) False \ntst) 13. ) 14. where close t = t o (set_tasknr taskId) 15.  set html done = (set_html html) o (set_activated \ndone) 16. stopId = [-1,0:tasknr] 17. taskId = [-1,1:tasknr] 18. Both the suspendable task t and the terminator \ntask p are evalu\u00adated (lines 4 5 and 6 7). Their current renderings are task and stop respectively, and \nthey both contain the most recent user edit oper\u00adations. The most exciting spot is line 8: if p is .nished \n(condition halt is true), then the task t as far as it has been evaluated has to be returned. However \none has to realize that a task t is only a recipe that is executed by applying it to its state. When \na task is executed, it always returns a result and a state, even if the task is not yet .nished. This \nalso holds for task t when it is activated in line 5. There actually are no partially evaluated task \nclosures in this system, there are only tasks and when they are applied they return their result. The \ncrucial issue is how to return a partially evaluated task if none exist? The answer is given in line \n15! Remember that an iTask application can reconstruct itself completely from scratch. This property \nalso holds for any iTask expression in the applica\u00adtion. The only thing we need is the task recipe and \nthe state of a task, and in particular, the task number stored in this state. Given a task number and \na task we can reconstruct the work done so far! So by passing the task function and the task number to \nsomebody else, the work can be reconstructed and the person can continue the work. Line 15 assures that \nan interrupted task is reapplied on the original task number when it is restarted.  6. Related Work \nIn the realm of functional programming, many solutions that have been inspiring for our work have been \nproposed to program web ap\u00adplications. We mention just a few of them in a number of languages: the HaskellCGI \nlibrary (Meijer 2000); the Curry approach (Hanus 2001); writing XML applications (Elsman and Larsen 2004) \nin SMLserver (Elsman and Hallenberg 2003). One sophisticated sys\u00adtem is WASH/CGI by Thiemann (2002), \nbased on Haskell. Here, HTML is produced as an effect of the CGI monad whereas we con\u00adsider HTML as a \n.rst-class citizen, using data types. Instead of storing state, WASH/CGI logs all user responses and \nI/O opera\u00adtions. These are replayed when needed to bring the application to its desired, most recent \nstate. In iTasks, we replay the program once instead of the session, and restore the state of the program \non-the\u00ad.y using the storage capabilities of the underlying iData. Forms are programmed explicitly in \nHTML, and their elements may, or may not, contain values. In the iTask toolkit, forms and tasks are generated \nfrom arbitrary data types, and always have a value. In\u00adterconnecting forms in WASH/CGI is done by adding \ncallback ac\u00adtions to submit .elds, whereas the iData toolkit uses a functional dependency relation. Two \nmore recent approaches that are also based on functional languages are Links (Cooper et al. 2006) and \nHop (Serrano et al. 2006). Both languages aim to deal with web programming within a single framework, \njust as the iData and iTask approach do. Links compiles to JavaScript for rendering HTML pages, and SQL \nto communicate with a back-end database. A Links program stores its session state at the client side. \nNotable differences between Links and iData and iTasks are that the latter has a more re.ned control \nover the location of state storage, and even the presence of state, which needs to be mimicked in Links \nwith recursive functions. Compiling to JavaScript gives Links programs more expressive and computational \npower at the client side: in particular Links offers thread-creation and message-passing communication, \nand .nally, the client side code can call server side logic and vice versa. The particular focus of Hop \nis on rendering graphically attractive applications, like desktop GUI applications can. Hop implements \na strict separation between programming the user interface and the logic of an application. The main \ncomputation runs on the server, and the GUI runs on the client(s). Annotations decide where a computation \nis performed. Computations can communicate with each other, which gives it similar expressiveness as \nLinks. The main difference between these systems and iTasks (and iData) is that the latter are restricted \nto thin-client web applications, and provide a high degree of automation using the generic foundation. \niData components that reside in iTasks are abstractions of forms. A pioneer project to experiment with \nform-based services is Mawl (Atkins et al. 1997). It has been improved upon by means of Powerforms (Brabrand \net al. 2000), used in the <bigwig> project (Brabrand et al. 2002). These projects provide templates which, \nroughly speaking, are HTML pages with holes in which scalar data as well as lists can be plugged in (Mawl), \nbut also other templates (<bigwig>). They advocate compile-time systems, because this al\u00adlows one to \nuse type systems and other static analysis. Powerforms reside on the client-side of a web application. \nThe type system is used to .lter out illegal user input. The use of the type system is what they have \nin common with our approach. Because iData are encoded by ADTs, we get higher-order forms for free. Moreover, \nwe provide higher-order tasks that can be suspended and migrated. Web applications can be structured \nwith continuations. This has been done by Hughes (2000), in his arrow framework. Queinnec (2000) states \nthat A browser is a device that can invoke contin\u00aduations multiply/simultaneously . Graunke et al. (2001) \nhave ex\u00adplored continuations as one of three functional compilation tech\u00adniques to transform sequential \ninteractive programs to CGI pro\u00adgrams. The Seaside (Ducasse et al. 2004) system offers an API for programming \nweb pages using a Smalltalk interpreter. When wait\u00ading for new information from the browser, a Seaside \napplication is suspended and continues evaluation as soon as input is available. To make this possible, \nthe whole state of the interpreter s run-time system is stored after a page has been produced and this \nstate is recovered when the next user event is posted such that the applica\u00adtion can resume execution. \nIn contrast to iTask, Seaside has to be a single user system by construction. Our approach is simpler \nyet more powerful: every page has a complete (set of) model value(s) that can be stored and recovered \ngenerically. An application is resurrected by restarting the very same program, which recovers its previous \nstate on-the-.y. Our combinator library has been inspired by the comprehensive analysis of work .ow patterns \nby van der Aalst et al. (2002) of over more than 30 contemporary commercial work .ow systems. These patterns \nare typically based on a Petri-net style, which implies that patterns for distributing work (also called \nsplitting) and merging (joining) work are distinct and can be combined more or less arbitrarily. In the \nsetting of a strongly typed combinator style such as iTasks, it is more natural to de.ne combinator functions \nthat pair splitting and merging patterns. For instance, the two combinators -&#38;&#38;-and -||-that \nwere introduced in Sect. 3.2.4 pair the and split and join and or split synchronizing merge patterns. \nConceptually, the Petri-net based approach is more .ne-grained, and should allow the work .ow designer \ngreater .exibility. However, we believe that we have captured the essential combinators of these systems. \nWe plan to study the relationship between the typical functional approach and the classic Petri-net based \napproach in the near future. Contemporary commercial work .ow tools use a graphical for\u00admalism to specify \nwork .ow cases. We believe that a textual spec\u00adi.cation, based on a state-of-the-art functional language, \nprovides more expressive power. The system is strongly typed, and guaran\u00adtees all user input to be type \nsafe as well. In commercial systems, the connection between the speci.cation of the work .ow and the \n(type of the) concrete information being processed, is not always well typed. Our system is fully dynamic, \ndepending on the val\u00adues of the concrete information. For instance, recursive work .ows can easily be \nde.ned. In a graphical system the .ows are much more static. Our system is higher order: tasks can communicate \ntasks. Work can be interrupted and conditionally moved to other users for further completion. Last but \nnot least: we generate a com\u00adplete working multi-user web application out of the speci.cation. Database \nstorage and retrieval of the information, version manage\u00adment control, type driven generation of web \nforms, handling of web forms, it is all done automatically such that the programmer only needs to focus \non the .ow speci.cation itself. 7. Conclusions The iTask system is a domain speci.c language for the \nspeci.ca\u00adtion of work .ows, embedded in Clean. The speci.cation is used to generate a multi-user interactive \nweb-based work .ow manage\u00adment system. We hope to have convinced the reader that the notation we of\u00adfer \nis concise as well as intuitive. For functional programmers the monadic style of programming should look \nfamiliar. Users of com\u00admercial work .ow systems, who design work .ows, typically use a graphical formalism \nfor this purpose. For this group of potential users a text based approach is likely to be harder to understand. \nIt should be investigated in what way a mapping from a graphical approach to the textual approach can \nbe constructed. The iTask toolkit covers all standard work .ow patterns in a combinatorial style. Moreover, \nit adds further expressive power in terms of a strongly typed system, dynamic run-time behavior, and \nhigher-order tasks that can be suspended, passed on to other users, and continued. At the same time it \ngenerates a multi-user interactive web-based application that automatically handles sessions, state and \nstate storage, HTML rendering, and more. This latter feature is due to building the iTask toolkit on \ntop of the iData toolkit. This project provides further evidence that the iData concept is a versatile, \nelementary unit to create interactive web applications. One particular helpful design decision was to \nseparate handling values and constructing the rendering of the application in the iData toolkit. This \nallows the iTask toolkit to separately handle the .ow of information and the .ltering of the correct \nHTML code for the end user. The iData enabled us to do task rewriting in a similar way as expressions \nare rewritten in languages such as Clean and Haskell. Finally, iTasks pro.t from these advantages, and \nstrengthen them by extending the expressive power by de.ning work .ow system on a sophisticated high \nlevel of abstraction. Future work will be the investigation of more unusual useful work .ow patterns. \nWe will investigate how the system will scale up in terms of performance when applications run longer \nand have more users. Also we are working on a new option for the evaluation of tasks on the client side \nusing Ajax technology in combination with an ef.cient interpreter for functional languages (Jansen et \nal. 2006).  Acknowledgments The authors would like to thank Phil Wadler for his inspiring exercise, \nErik Zuurbier for the many discussions on the state-of\u00adart of contemporary work .ow systems and as a \nsource of many examples, Wil van der Aalst for commenting on the difference between the combinator approach \nand contemporary work .ow speci.cation languages, Maarten de Mol and Arjen van Weelden for reading the \ndraft version of the paper, and the anonymous reviewers for their constructive comments. References \nArtem Alimarine. Generic Functional Programming -Conceptual Design, Implementation and Applications. \nPhD thesis, Univer\u00adsity of Nijmegen, The Netherlands, 2005. ISBN 3-540-67658-9. David Atkins, Thomas \nBall, Michael Benedikt, Glenn Bruns, Ken\u00adneth Cox, Peter Mataga, and Kenneth Rehor. Experience with a \nDomain Speci.c Language for Form-based Services. In Usenix Conference on Domain Speci.c Languages, October \n1997. Claus Brabrand, Anders M\u00f8ller, Mikkel Ricky, and Michael I. Schwartzbach. Powerforms: Declarative \nclient-side form .eld validation. World Wide Web Journal, 3(4):205 314, 2000. Claus Brabrand, Anders \nM\u00f8ller, and Michael I. Schwartzbach. The <bigwig> Project. In ACM Transactions on Internet Technol\u00adogy \n(TOIT), 2002. Ezra Cooper, Sam Lindley, Philip Wadler, and Jeremy Yallop. Links: Web programming without \ntiers. In Proceedings of the 5th International Symposium on Formal Methods for Compo\u00adnents and Objects \n(FMCO 06), CWI, Amsterdam, The Nether\u00adlands, 7 -10 November 2006. Springer-Verlag. to appear. St\u00b4Sea\u00ad \nephane Ducasse, Adrian Lienhard, and Lukas Renggli. side -A Multiple Control Flow Web Application Framework. \nIn St\u00b4 ephane Ducasse, editor, Proceedings ESUG 2004 Interna\u00adtional Conference Research Track, volume \nTechnical Report IAM-04-008, pages 231 254. Institut f\u00a8 ur Informatik und Ange\u00adwandte Mathematik, University \nof Bern, Switzerland, November 7 2004. Martin Elsman and Niels Hallenberg. Web programming with SMLserver. \nIn Fifth International Symposium on Practical Aspects of Declarative Languages (PADL 03). Springer-Verlag, \nJanuary 2003. Martin Elsman and Ken Friis Larsen. Typing XHTML Web appli\u00adcations in ML. In International \nSymposium on Practical Aspects of Declarative Languages (PADL 04), volume 3057 of LNCS, pages 224 238. \nSpringer-Verlag, June 2004. Paul Graunke, Shriram Krishnamurthi, Robert Bruce Findler, and Matthias Felleisen. \nAutomatically Restructuring Programs for the Web. In M. Feather and M. Goedicke, editors, Proceedings \n16th IEEE International Conference on Automated Software Engineering (ASE 01). IEEE CS Press, September \n2001. M. Hanus. High-Level Server Side Web Scripting in Curry. In Proc. of the Third International Symposium \non Practical Aspects of Declarative Languages (PADL 01), pages 76 92. Springer LNCS 1990, 2001. Ralf \nHinze. A new approach to generic functional pro\u00adgramming. In The 27th Annual ACM SIGPLAN-SIGACT Symposium \non Principles of Programming Languages, pages 119 132. Boston, Massachusetts, January 2000. URL urlciteseer.nj.nec.com/hinze99new.html. \nJohn Hughes. Generalising Monads to Arrows. Science of Com\u00adputer Programming, 37:67 111, May 2000. Jan \nMartin Jansen, Pieter Koopman, and Rinus Plasmeijer. Ef.\u00adcient Interpretation by Transforming Data Types \nand Patterns to Functions. In H. Nilsson, editor, Proceedings Seventh Sympo\u00adsium on Trends in Functional \nProgramming, TFP 2006, pages 157 172, Nottingham, UK, The University of Nottingham, April 19-21 2006. \nErik Meijer. Server Side Web Scripting in Haskell. Journal of Functional Programming, 10(1):1 18, 2000. \nRinus Plasmeijer and Peter Achten. The Implementation of iData -A Case Study in Generic Programming. \nIn A. Butter.eld, edi\u00adtor, Proceedings Implementation and Application of Functional Languages -Revised \nSelected Papers, 17th International Work\u00adshop, IFL05, LNCS 4015, Department of Computer Science, Trinity \nCollege, University of Dublin, September 19-21 2006a. Rinus Plasmeijer and Peter Achten. iData For The \nWorld Wide Web -Programming Interconnected Web Forms. In Proceed\u00adings Eighth International Symposium \non Functional and Logic Programming (FLOPS 2006), volume 3945 of LNCS, Fuji Su\u00adsono, Japan, Apr 24-26 \n2006b. Springer Verlag. Rinus Plasmeijer and Peter Achten. A Conference Management System based on iData. \nIn Z. Horvath and V. Zsok, editors, Proceedings of the 18th International Symposium on Implemen\u00adtation \nand Application of Functional Languages, IFL 06, Bu\u00addapest, Hungary, Eotvos Lorand University, Faculty \nof Infor\u00admatics, Department of Programming Languages and Compilers, Sept 4 6 2006c. To appear in Springer \nLNCS. Christian Queinnec. The in.uence of browsers on evaluators or, continuations to program web servers. \nIn Proceedings Fifth In\u00adternational Conference on Functional Programming (ICFP 00), September 2000. Manuel \nSerrano, Erick Gallesio, and Florian Loitsch. Hop, a lan\u00adguage for programming the web 2.0. In Proceedings \nACM SIG-PLAN International Conference on Object-Oriented Program\u00adming, Systems, Languages, and Applications \n(OOPSLA 2006), pages 975 985, Portland, Oregon, USA, October 22-26 2006. Peter Thiemann. WASH/CGI: Server-side \nWeb Scripting with Ses\u00adsions and Typed, Compositional Forms. In S. Krishnamurthi and C.R. Ramakrishnan, \neditors, Practical Aspects of Declara\u00adtive Languages: 4th International Symposium, PADL 2002, vol\u00adume \n2257 of LNCS, pages 192 208, Portland, OR, USA, Jan\u00aduary 19-20 2002. Springer-Verlag. W.M.P. van der \nAalst, A.H.M. ter Hofstede, B. Kiepuszewski, and A.P. Barros. Work.ow patterns. QUT Technical report, \nFIT-TR\u00ad2002-02, Queensland University of Technology, Brisbane, 2002.  \n\t\t\t", "proc_id": "1291151", "abstract": "<p>In this paper we introduce the iTask system: a set of combinators to specify <i>work flows</i> in a pure functional language at a very high level of abstraction. Work flow systems are automated systems in which <i>tasks</i> are coordinated that have to be executed by humans and computers. The combinators that we propose support work flow patterns commonly found in commercial work flow systems. Compared with most of these commercial systems, the iTask system offers several advantages: tasks are statically typed, tasks can be higher order, the combinators are fully compositional, dynamic and recursive work flows can be specified, and last but not least, the specification is used to generate an executable web-based multi-user work flow application. With the iTask system, useful work flows can be defined which cannot be expressed in other systems: work can be interrupted <i>and</i> subsequently directed to other workers for further processing.</p> <p>The implementation is special as well. It is based on the Clean iData toolkit which makes it possible to create fully dynamic, interactive, thin client web applications. Thanks to the generic programming techniques used in the iData toolkit, the programming effort is reduced significantly: state handling, form rendering, user interaction, and storage management is handled automatically. The iTask system allows a task to be regarded as a special kind of persistent redex being reduced by the application user via task completion. The combinators control the order in which these redexes are made available to the application user. The system rewrites the persistent task redexes in a similar way as functions are rewritten in lazy functional languages.</p>", "authors": [{"name": "Rinus Plasmeijer", "author_profile_id": "81100025522", "affiliation": "Radboud University Nijmegen, Nijmegen, Netherlands", "person_id": "PP37043723", "email_address": "", "orcid_id": ""}, {"name": "Peter Achten", "author_profile_id": "81100207955", "affiliation": "Radboud University Nijmegen, Nijmegen, Netherlands", "person_id": "P486481", "email_address": "", "orcid_id": ""}, {"name": "Pieter Koopman", "author_profile_id": "81100027633", "affiliation": "Radboud University Nijmegen, Nijmegen, Netherlands", "person_id": "P900685", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291174", "year": "2007", "article_id": "1291174", "conference": "ICFP", "title": "iTasks: executable specifications of interactive work flow systems for the web", "url": "http://dl.acm.org/citation.cfm?id=1291174"}