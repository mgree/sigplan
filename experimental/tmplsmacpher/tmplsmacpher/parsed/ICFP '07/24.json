{"article_publication_date": "10-01-2007", "fulltext": "\n Experience Report: A Haskell Interpreter for CellML Jonathan Cooper Computing Laboratory, University \nof Oxford jonathan.cooper@comlab.ox.ac.uk Abstract In this paper we present our use of functional programming \n(FP), speci.cally Haskell, to provide an operational semantics for a domain-speci.c language, CellML, \nthat describes mathematical models of biological processes. We analyse the bene.ts and short\u00adcomings \nof this approach, in comparison with other semantic de.\u00adnitions for CellML. It is our claim that using \nFP for our semantics results in a more concise and useful artifact for describing what such a model means. \nThe use of lazy evaluation removes the need to explicitly determine an evaluation order for the model, \nresulting in a more elegant inter\u00adpreter. Crucially, using FP enables us to prove the correctness of \noptimisation techniques for such models. This gives us more con.\u00addence in scienti.c deductions from simulation \nresults. We compare the Python implementation of these optimisation techniques with our use of Haskell \nin proving their correctness. Categories and Subject Descriptors D.3.1 [PROGRAMMING LANGUAGES]: Formal \nDe.nitions and Theory; I.6.2 [SIMULA-TION AND MODELING]: Simulation Languages General Terms Languages, \nStandardization Keywords Haskell, CellML 1. Introduction Computer simulations have long played an important \nrole in the physical sciences. Mathematical modelling of physical systems can aid our understanding, \nelucidating the underlying mechanisms which give rise to the behaviour we observe. The use of these techniques \nin the life sciences community has been more limited, mostly due to the fact that biological systems \nare incredibly com\u00adplex, but this is a rapidly growing area of research, worked on by many groups around \nthe world. One of the challenges in this area is that of utilising models de\u00adveloped by others implementing \na published cell model is rarely a straightforward exercise. Simple typos can easily be introduced by \neither the author or the reader. Documentation of the model (e.g. initial conditions and units, as well \nas more general comments) can be lacking, making it dif.cult to produce working code from an ab\u00adstract \nmathematical description. Some authors have tried to over\u00adcome this problem by publishing source code \nimplementing their model on the internet (e.g. Luo and Rudy (1994)), which greatly Permission to make \ndigital or hard copies of all or part of this work for personal or classroom use is granted without fee \nprovided that copies are not made or distributed for pro.t or commercial advantage and that copies bear \nthis notice and the full citation on the .rst page. To copy otherwise, to republish, to post on servers \nor to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP 07, October 1 3, 2007, \nFreiburg, Germany. Copyright c . 2007 ACM 978-1-59593-815-2/07/0010. . . $5.00 Steve McKeever Computing \nLaboratory, University of Oxford steve.mckeever@comlab.ox.ac.uk reduces errors, but does not prevent \nthem when porting a model to another simulation environment (that is, a piece of software or a software \nframework for simulating such models). Since newer environments are likely to be more advanced, it is \ndesirable to be able to port models easily. Also, if each cell model is written in an ad-hoc coding format, \nit is then dif.cult to integrate these in a co\u00adherent manner into higher-level simulations (e.g. coupling \nmodels of the electrical activity of single cells, with mechanics, to model the beating of a whole heart). \nThe XML-based modelling language CellML (Lloyd et al. 2004) was developed by the Bioengineering Institute \nat the Univer\u00adsity of Auckland to facilitate the exchange of biological cell-level models. As such, its \nfocus is on enabling those developing mathe\u00admatical models of cellular phenomena to write their models \neasily in an abstract, well-de.ned form. CellML describes the structure and mathematics of a model, not \nhow it should be simulated; that is the work of a simulation environment, which generates executable \ncode representing the model in some programming language. Given the existence of multiple simulation \nenvironments, it is vital that they agree on the meaning of a CellML model if ex\u00adchanging models in this \nformat is to be effective. We thus need a clear semantics of CellML. This has been provided by the speci.\u00adcations \n(Hedley and Nelson 2001; Cuellar et al. 2006) available on the cellml.org website. These, as with other \nXML speci.cations, are lengthy documents written in semi-formal English, describing the structure of \nCellML documents and the intended behaviour of CellML processing software, and are very thorough. There \nare lim\u00aditations to this approach, however, which we have sought to address by de.ning a formal semantics \nfor CellML. Our semantics focusses on the subset of CellML required for describing the types of mathematical \nmodels we are interested in, namely .rst order systems of ordinary differential equations (ODEs), which \namong other applications can describe the electrical behaviour of heart cells. An extremely simpli.ed \nexample is given by dVI = ,I = gV, C,g constants dtC which is encoded by the following CellML document. \n<model name= example > <units name= millisecond > <unit prefix= milli units= second /> </units> <component \nname= A > <variable name= time units= millisecond public_interface= out /> <variable name= voltage units= \nvolt public_interface= out /> <variable name= current units= ampere public_interface= in /> <variable \nname= C units= farad initial_value= 1 />  Figure 1. The example CellML model in diagrammatic form, with \narrows showing the .ow of control. <math xmlns=\"http://.../MathML\"> <apply><eq/> <apply><diff/> <bvar><ci>time</ci></bvar> \n<ci>voltage</ci> </apply> <apply><divide/> <ci>current</ci> <ci>C</ci> </apply> </apply> </math> </component> \n<component name= B > <variable name= V units= volt public_interface= in /> <variable name= I units= \nampere public_interface= out /> <variable name= g units= siemens initial_value= 0.3 /> <math xmlns=\"http://.../MathML\"> \n <apply><eq/> <ci>I</ci> <apply><times/> <ci>g</ci> <ci>V</ci> </apply> </apply> </math> </component> \n<connection> <map_components component_1= A component_2= B /> <map_variables variable_1= voltage variable_2= \nV /> <map_variables variable_1= current variable_2= I /> </connection> </model> A few features of CellML, \nexempli.ed by this model, deserve comment. Firstly, the equations have been split into separate com\u00adponents, \nas can more easily be seen in Figure 1. These allow us to group related mathematics, promoting model \nreuse individual components can be imported into new models. Connections specify how the values of variables \nare transfered between components; the direction of these connections is implied by the variable interfaces. \nSecondly, all quantities in the model have associated physical units, and models may de.ne their own \nunits for convenience, as is done here for milliseconds. Finally, we note that a real model should also \ninclude metadata, describing for example the model authors, related publications, and a change history. \nIn Section 2 we compare our semantics with the speci.cations, describing both its bene.ts and de.ciencies. \nWe have found that using Haskell to de.ne an operational semantics is natural and el\u00adegant. One of the \nbene.ts is that a formal semantics allows us to prove the correctness of optimisations for CellML, and \nthis is de\u00adscribed in more detail in Section 3. In particular, implementing par\u00adtial evaluation also \nwithin Haskell makes the proof of this technique relatively straightforward. Section 4 provides some \nintrospection, comparing our Haskell interpreter with our Python implementation of our optimisation techniques. \nFinally, we summarise our .ndings in Section 5. 2. Formal semantics using Haskell Our operational semantics \nfor CellML consists of an abstract data type describing a CellML document, and a Haskell interpreter \nfor data with this type. (Note that a CellML model is not translated into a Haskell program there is \nan interpretive layer.) The example model above is encoded as follows. example = Model \"example\" units \ncomponents connections units = [ UDef \"millisecond\" (SimpleUnits 1 (-3) (BaseUnits \"second\") 0)] components \n= [ MkComp \"A\" [] [ VarDecl \"time\" \"millisecond\" , VarDecl \"voltage\" \"volt\" , VarDecl \"current\" \"ampere\" \n , VarDecl \"C\" \"farad\"] [ Assign (Var \"C\") (Num 1 \"farad\") , Assign (Ode \"voltage\" \"time\") (Apply \nDivide [(Variable \"current\"), (Variable \"C\")])] , MkComp \"B\" [] [ VarDecl \"V\" \"volt\" , VarDecl \"I\" \n\"ampere\" , VarDecl \"g\" \"siemens\"] [ Assign (Var \"g\") (Num 0.3 \"siemens\") , Assign (Var \"I\") (Apply \nTimes [(Variable \"g\"), (Variable \"V\")])]] connections = [ VarMap (\"A\",\"voltage\") (\"B\",\"V\") , VarMap \n(\"B\",\"I\") (\"A\",\"current\")] The semantics we have chosen is much like a lazy functional language, and \nso implementing the interpreter in such a language is a natural choice. CellML is a declarative language \nas we have said above, CellML describes the structure and mathematics of a model, not how it should be \nsimulated. This is analogous to a functional language, in which the focus is on what is to be computed, \nnot how it should be computed. Lazy evaluation was chosen in order to avoid having to explic\u00aditly determine \nan evaluation order for the expressions making up the model. While a CellML model is organised into components, \nthese logical groupings are useful from a model reuse perspective, rather than for evaluation one cannot \nevaluate each component in turn. In our example for instance (see Figure 1), voltage and time are passed \ninto component A from the evaluator (solid ar\u00adrows), then voltage is passed to component B (dashed arrow) \nin order to compute I, which is passed back to A (dotted arrow) to compute the right hand side of the \nODE. Real models have an even more complex .ow. While the evaluation order can be determined by a topological \nsort, it seemed more natural to us to have eval\u00aduation performed on demand , and an FP implementation \nis well suited to this. (Incidentally, if we are to allow for implicit equa\u00adtions at a later date, the \nevaluation order becomes even harder to determine, and we expect lazy evaluation to be even more useful.) \nA semantics should give a well-de.ned meaning to all con\u00adstructs in the language. Certainly ours gives \na single meaning to any term in our subset of CellML. We avoid any issues with non\u00adtermination by including \na static check that ensures there are no cycles within the mathematics (e.g. a = f (b),b = g(a)). A simple \nrecursive evaluation then suf.ces. Compared with the CellML speci.cations, our interpreter has several \nbene.ts. It is both concise and precise, making it easier to grasp conceptually as a whole. The CellML \n1.0 speci.cation is a 74 page document; our Haskell interpreter is less than 1000 lines of comments and \ncode. Being amenable to computer manipulation, it also offers the possibility of being compared automatically \nagainst other implementations, although this is not an avenue we have explored as yet. We have implemented \na static semantics, as well as the dynamic semantics discussed above. The most interesting feature of \nthe static semantics is determining whether the model makes consistent use of physical units (Cooper \nand McKeever 2007). Developing a formal model of the use of units within CellML alerted us to several \ninconsistencies in the related sections of the speci.cation, and these problems have been reported back \nto the CellML team (who have noted the issues, but not yet updated the speci.cations). The use of physical \nunits is complex, and we .nd our abstract description of their behaviour in Haskell considerably easier \nto comprehend, even than the Python implementation (see Section 4). This opinion is not restricted to \nfunctional programmers: our semantics is being used as the basis for the inclusion of units within a \nsimulation environment1 developed by the Physiology Department in the University of Oxford. The developer \nconsiders that our semantics has given him a deeper understanding of the problem and allowed a faster \nimplementation. He did, however, .nd the more complex algorithms hard to follow until he had taught himself \nsome Haskell and run them on some examples. Our formal semantics for CellML does have limitations, how\u00adever. \nThe primary one is that it only gives a semantics for a sub\u00adset of CellML. There are features we have \nnot implemented as yet, such as allowing implicit equations, for example of the form a + b = c + d, and \nhence systems of algebraic equations2. While such features are used by very few existing CellML models \n(and hence have not been a high priority), their inclusion is necessary if this is to be a complete semantics \nfor CellML, and this will be worked on when time permits. We also do nothing with the meta\u00addata included \nwithin CellML documents. This may seem innocu\u00adous, but it is being proposed to include certain parameters \ncontrol\u00adling simulation runs (e.g. the type of numerical algorithm to use) within this metadata, thus \nenabling more faithful reproduction of published results graphs. A second, more subtle, point is that \nthe interpreter operates on an abstract description of the CellML document (as shown above), rather than \ndirectly on the XML tree structure. This implies that an extra translation step is required to obtain \na model in a form suitable for interpretation. This approach bene.ts from the separation of structure \nand function, but care needs to be taken to ensure this translation faithfully preserves the meaning \nof the model. A useful extension would be to use HXT or HaXmL to perform this transformation, and prove \nit correct , though we are uncertain as to what this proof would look like. 1 http://cor.physiol.ox.ac.uk \n2 simultaneous linear equations, for example 3. Correctness proofs of optimisation techniques Biological \nsystems are extremely complex, and hence computer simulation of any interesting system takes considerable \ntime. It is thus important to be able to automatically optimise simulation codes generated from a CellML \nmodel, enabling more science to be performed. There are various optimisation techniques that may be used, \nbeyond standard compiler optimisations; some are described by Cooper et al. (2006). With any optimisations \nwe use, however, it is crucial to be con.dent that they are correct, in order to have con.dence that \nthe results of our simulations are valid derivations from our models. If simulation results differ from \nempirical data, it is important to know whether the mathematical model or the simulation code is at fault. \nA formal semantics affords the possibility of proving the cor\u00adrectness of any optimisation strategy. \nHow easy this process is de\u00adpends on the style of the semantics. Since Haskell has referential transparency, \ncorrectness proofs using the interpreter are tractable. We have found that our semantics has made the \nproof of the partial evaluation technique in Cooper et al. (2006) fairly straightforward, since implementing \npartial evaluation reuses much of the inter\u00adpreter. (A paper on this proof is in preparation.) Proofs \nfor the other optimisation techniques we have investigated (the use of lookup ta\u00adbles to compute approximations \nto expensive expressions using in\u00adterpolation, and model transformation to facilitate the use of adap\u00adtive \nnumerical methods), however, require continuous mathemat\u00adics, and the choice of semantics has little \nbearing on the dif.culty of the proof. 4. Comparison with Python implementation Implementing both the \nsemantics and the optimisation techniques in Haskell is ideal for proofs of correctness. There is an \nalterna\u00adtive implementation of our static semantics and our optimisation techniques available3 which \nwe use in practice for applying the op\u00adtimisations to CellML models, written in Python. The two imple\u00admentations \nare complementary, each with their own strengths. The primary raisons d etre for the Python implementation \nare pragmatic. The main author has considerable experience with Python, and it is a popular language \nwithin the bioinformatics community. It is also used for pre-existing CellML-related soft\u00adware, notably \nthe model repository4, and other CellML tools are written using the object-oriented paradigm. Hence during \ninitial implementation of our techniques we decided the use of Python would be most appropriate. However \nit is effectively impossible to prove correctness using the Python implementation. While we can be con.dent \nthat it is a correct implementation, it is too large (at over 9000 lines) to allow an elegant proof. \nThe plumbing introduced by the data binding library obscures the essential algorithms, and the heavy \nuse of state makes proof dif.cult. Python, being a dynamically typed imperative language, also lacks \nthe desirable features of Haskell that facilitate program proofs. Hence when we came to proving the correctness \nof our techniques, we decided to use Haskell, for the reasons described earlier. On the other hand, the \nPython implementation is more com\u00adprehensive. It essentially operates directly on the XML tree (using \na data binding library), and endeavours to do something sensible with any data or metadata that it is \nnot transforming. Since CellML is designed to be extensible, this .exibility is useful. The Python implementation \nhas also been optimised; while optimisation of the Haskell implementation is possible, doing so would \nbe likely to 3 https://chaste.ediamond.ox.ac.uk/cellml/ 4 http://www.cellml.org/models obscure the meaning, \nmaking proof more complex, and making the semantics de.nition less useful. With hindsight, we can see \nbene.ts to having the primary im\u00adplementation in Haskell the possibility of proving it correct by construction, \nfor example. We still feel that Python is a better .t for the user community, however. 5. Conclusion \nWe have described our experience in using Haskell to de.ne an operational semantics for CellML. The semantics \nis considerably more concise and precise than the CellML speci.cations, and hence is more useful for \nformal manipulation of CellML models. In par\u00adticular, using FP has enabled us to prove the correctness \nof an op\u00adtimistion technique (partial evaluation) for CellML; this gives us con.dence that the results \nof simulations using optimised models are valid derivations from the original mathematical models. While \nour semantics does not cover the entirety of CellML, and could not replace the speci.cations, it has \nproven useful, and this was made possible through the use of FP.  References Jonathan Cooper and Steve \nMcKeever. A model-driven approach to au\u00adtomatic conversion of physical units. Softw. Pract. Exper., 2007. \ndoi: 10.1002/spe.828. Jonathan Cooper, Steve McKeever, and Alan Garny. On the application of partial \nevaluation to the optimisation of cardiac electrophysiological simulations. In PEPM 06: Proceedings of \nthe 2006 ACM SIGPLAN symposium on Partial evaluation and semantics-based program manip\u00adulation, pages \n12 20, New York, NY, USA, 2006. ACM Press. ISBN 1-59593-196-1. doi: 10.1145/1111542.1111546. Autumn Cuellar, \nPoul Nielsen, Matt Halstead, David Bullivant, David Nickerson, Warren Hedley, Melanie Nelson, and Catherine \nLloyd. CellML Speci.cation 1.1, February 2006. http://www.cellml.org/ specifications/cellml 1.1/ [6 Mar \n2007]. Warren Hedley and Melanie Nelson. CellML Speci.cation 1.0, August 2001. http://www.cellml.org/specifications/cellml \n1.0/ [14 November 2006]. Catherine M. Lloyd, Matt D.B. Halstead, and Poul F. Nielsen. CellML: its future, \npresent and past. Progress in Biophysics and Molecular Biology, 85:433 450, 2004. doi: 10.1016/j.pbiomolbio.2004.01.004. \nChing-hsing Luo and Yoram Rudy. Dynamic model of the cardiac ven\u00adtricular action potential simulations \nof ionic currents and concentra\u00adtion changes. Circulation Research, 74:1071 1097, 1994. http: //rudylab.wustl.edu/research/cell/methodology/. \n  \n\t\t\t", "proc_id": "1291151", "abstract": "<p>In this paper we present our use of functional programming (FP), specifically Haskell, to provide an operational semantics for a domain-specific language, CellML, that describes mathematical models of biological processes. We analyse the benefits and shortcomings of this approach, in comparison with other semantic definitions for CellML.</p> <p>It is our claim that using FP for our semantics results in a more concise and useful artifact for describing what such a model means. The use of lazy evaluation removes the need to explicitly determine an evaluation order for the model, resulting in a more elegant interpreter. Crucially, using FP enables us to prove the correctness of optimisation techniques for such models. This gives us more confidence in scientific deductions from simulation results. We compare the Python implementation of these optimisation techniques with our use of Haskell in proving their correctness.</p>", "authors": [{"name": "Jonathan Cooper", "author_profile_id": "81546017456", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "PP37030305", "email_address": "", "orcid_id": ""}, {"name": "Steve McKeever", "author_profile_id": "81100426693", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "PP14150365", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291190", "year": "2007", "article_id": "1291190", "conference": "ICFP", "title": "Experience report: a Haskell interpreter for cellML", "url": "http://dl.acm.org/citation.cfm?id=1291190"}