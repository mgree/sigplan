{"article_publication_date": "10-01-2007", "fulltext": "\n User-Friendly Functional Programming for Web Mashups Rob Ennals DavidGay Intel Research Berkeley 2150 \nShattuckAvenue, Penthouse Suite Berkeley, CA 94704 {robert.ennals,david.e.gay}@intel.com Abstract MashMaker \nis a web-based tool that makes it easy for a normal user to create web mashups by browsing around, without \nneeding to type, or plan in advance what they want to do. Likeawebbrowser, Mashmakerallows usersto createmashups \nby browsing, rather than writing code, and allows users to book\u00admark interesting things they.nd, forming \nnew widgets reusable mashup fragments. Likeaspreadsheet,MashMaker mixes program and data and allows \nad-hoc unstructured editing of programs MashMakeris alsoa modern functional programming language with \nnon-side effecting expressions, higher order functions, and lazy evaluation. MashMaker programs can be \nmanipulated either textually, or through an interactive tree representation, in which a program is presented \ntogether with the values it produces. In order to cope with this unusual domain, MashMaker contains a \nnumber of deviations from normal function languages. The most notable of these is that, in order to allow \nthe programmer to write programs directlyontheirdata,alldatais storedinasingletree,and evaluationofanexpressionalwaystakesplaceata \nspeci.cpointin this tree, which also functions as its scope. Categories and Subject Descriptors D.3.2[Language \nClassi.ca\u00adtions]:Very high-level languages; H.4.3[Information Systems Ap\u00adplications]: Information Browsers \nGeneral Terms Languages, Human Factors, Design, Manage\u00adment Keywords Mashup, web, end-user programming, \nbrowser 1. Introduction There has recently been lots of interest in so called mashup sites web sites \nthat combine information, processing, or visualiza\u00adtions from several web sites to provide information \nthe user could not easily obtain by manually browsing the base web sites sepa\u00adrately. One of the .rst \nsuch sites was HousingMaps.com, which uses a map from Google Maps to visualize houses available for rent \non Craigslist.org. Otherexamples includeWeatherBonk.com which combinesvarious sourcesof information about \nweather,Bid\u00adNearby.com which .nds items being sold nearby on sites such as EBay.com and Craigslist.org, \nDiggDot.com which combines Permission to make digital or hard copies of all or part of this work for \npersonal or classroom use is granted without fee provided that copies are not made or distributed for \npro.t or commercial advantage and that copies bear this notice and the full citation on the .rst page.To \ncopyotherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. ICFP 07 October 1 3, 2007, Freiburg, Germany. Copyright c &#38;#169; 2007ACM 978-1-59593-815-2/07/0010...$5.00 \nDigg.com with Slashdot.org, andWikiMapia.com which combines WikiPedia.org with Google Maps to provide \ninformation about physical locations. At the time of writing, ProgrammableWeb.com lists around 2,100 \nknown mashup sites and the number is growing rapidly. While there are a large number of mashup sites \nin existence, there are many more that could usefullybe created.Forexample, asfar as the authors areaware, \nnoexisting mashup site can answer anyof the following questions1: Which of these houses on Craigslist \nhas lots of good restaurants nearby accordingtoYelp, andwouldbe less thana30 minute commute to work according \nto Google Maps?  Which of these events on Upcoming clash with things on my Google Calendar?  How much \nwould each of these recipes from Epicurious cost to makeifIboughtthe ingredientsatSafeway?  How much \nof my weekly expenditure according to Bank of America goes to companies who donate money to political \npartiesIdon tlike according to OpenSecrets?  What is the best route through town according to GoogleMaps \nthatallowsmetovisithighlyratedshops accordingtoYelpthat sell suggested Christmas presents appropriate \nfor each of my friends according to FindGift?  It seems reasonable to assume the number of such useful \nques\u00adtions users might ask is huge. New web sites, containing new infor\u00admation, appear on the web every \nday, and the number of possible ways of combining them is huge, particularly when one considers the affect \nof combining three, or four, or more different web sites to answer a question. At the time of writing, \nProgrammableWeb lists over 450 web sites with published APIs intended to be used by mashups, and millions \nmore web sites can be used via scrap\u00ading (Schrenk 2007). If each mashup site were only able to answer \na single question, based on a .xed set of source web sites, then it seems the number of mashup sites \nneeded would be impractical both for the pro\u00adgrammers who create them, and the users who have to .nd \nthem. The obvious solution seems to be generic mashup sites that allow end users to easily combine information \nfrom multiple web sites to answera wide rangeof questions. Indeed several groupshavebuilt such generic \nmashup creation sites (see Section 5). In this paper, we describe MashMaker, a tool that makes it easy \nto create mashups, for users ranging from na\u00a8ive to expert. The 1If such a mashup site does exist then \nthat merely goes to underscore one of our other points having such a large number of mashup sites makes \nit very hard to .nd a site that can answer a speci.c question. design of Mashmaker is guided by a number \nof principles that support this goal: Program as you browse: creation of mashups should be viewed as \nan extension of the normal web browsing habits.  Direct manipulation: users should be able to work directly \non the data that theyare interested in, without having to think about abstract concepts such as programs. \n Least surprise: local changes should produce local effects.  Pay as you go: unskilled users should \nbe able to gain some bene.t withvery littleeffort,but more skilled users shouldbe able to do powerful \nthings.  Code sharing: mashups, and elements used to create mashups should be shared across users. \n MashMaker is a combination of a custom functional program\u00adming language andaweb-based user interface.Webelievemashups \nare an excellent application domain for a programming language. Moreover, many web sites can be modeled \nas functions from form parameters to structured results. As a result, the majority of mashups combine \nside-effect-free queries and list manipulation, making them an excellent application domain for a functional \npro\u00adgramming language. In addition to functional languages, Mashmaker draws inspira\u00adtion from spreadsheets, \nweb browsers, and .le systems.Time has shown that these are all metaphors that normal users are able \nto use productively, and as a result, all three have been very successful. Weexplainin Section2how eachof \nthese tools has in.uenced the design of MashMaker, in ways that support the principles outlined above. \n1.1 The Language and the Interface The heart of MashMaker is a functional programming language. A simpli.ed \ngrammar for this language is given in Figure 1. MashMaker has several signi.cant differences from previous \nfunc\u00adtional languages. Most of these differences stem from thefact that the MashMaker language is designed \nto be accessed through a spreadsheet-style user interface, rather than as a textual program. Like a spreadsheet, \nMashMaker stores every value that is com\u00adputed in a single, central data structure (in this case a tree). \nThere are no intermediate values that get thrown away. This tree contains every intermediate value that \nwas computed on the wayto produc\u00ading the .nal result. Even the values computed internally by a func\u00adtion \ncan be made visible by expanding the function call. MashMakerhasno conceptofascope,orofalocalvariable.An \nexpressionisevaluatedata speci.c locationinthedatatree,andall variable references refer to .elds at the \ncurrent location. This is again similar to a spreadsheet, in which cell references are relative to the \ncurrent location, and temporary values are stored directly in the data. The language also has some more \nconventional features: it is dynamically typed, function arguments are bound by name rather than order, \nevaluation is lazy, and functions are .rst class values. We describe the MashMaker language in more detail \nin Section 3. The novel features of MashMaker are not just in the core lan\u00adguage,but alsointheway thatweexpose \nthis language througha user interface. In particular: MashMaker s tree viewshows thevalue that the currentexpres\u00adsion \nevaluates to. Each node in this tree contains an internal reference back to the subexpression that de.ned \nthat node. This is made practicalby thefact that the MashMaker language con\u00adsiderseachevaluationtohavea \nlogical positioninthedata tree. (Section 2.3). Value v ::= c constant (.le) |\u00d8 empty directory | v K(k \n. v) extension | s, .(x0 ...xn).e.x closure with body e, env s and result selector x SubnodeKey k ::= \nx Property with name x | Unnamed child Expression e ::= c constant |\u00d8 empty directory | e K(q . e) extension \n| .(x0 ...xn).e.x lambda | e (e) function application | this current context | p link to another node \n| X global ExtensionPath q ::= k new subnode |*.q for all children | x.q inside property x ReferencePath \np ::= x variable | x.p inside property x | !.p inside parent Scope s ::= v0 : ... : vn stack of parent \ndir values v Figure 1. Simpli.ed grammar for the MashMaker core language MashMaker allows operations \nsuch as map, fold, and .lter to be applied through direct manipulation of data (Section 2.3.1).  MashMaker \nautomaticallysuggests functions that a user might apply to their data, based on the functions that other \nusers have applied to similar data. This allows less skilled users to create mashups simply by clicking \non suggestions, without having to do any programming or having to think about what websites might connect \ntogether (Section 2.4).  MashMaker s user interface allows users to write expressions in a simpli.ed \nform. This form allows users to avoid quoting constants, and automatically infers arguments for lambda \nex\u00adpressions (Section 3.5).  All data is live , meaning that functions automatically recom\u00adpute their \nvalues in response to changing data (Section 3.6).  MashMaker bundles functions up together with associated \nmetadata to form widgets reusable mashup fragments (Section 2.4).  Users can interact with MashMaker \nat a number of different levels making it useful for anyone from a complete beginner to a skilled programmer \n(Section 2.5).   1.2 Why this Paper is Interesting This paper makes several interesting and novel contributions: \nWe propose the use of a functional language for the creation of web mashups.  Figure 2. Craigslist apartment \nlisting imported into MashMaker Wepropose several changes to the standard functional paradigm, in order \nto make such languages more suitable for this domain. In particular, we present a model made on tree \nextension, in which an expression is evaluated with respect to a location in a data tree.  We demonstrate \nthat this approach is practical, through the creation of MashMaker, which is, in our opinion2, the .rst \ntruly general purpose mashup creation tool that is usable by normal users. MashMaker is currently undergoing \na closed beta test program, and we plan to open it up to the general public soon.  2. The MashMaker \nDesign In this section we sketch the overall design of the MashMaker system, and explain how it draws \ninspiration from .le systems, spreadsheets, and web browsers. 2.1 An Illustrative Example Since MashMaker \nis quite different from most functional lan\u00adguages,itis perhaps helpfultosetthe scenewithawalk throughof \nan actual session using the current version of the MashMaker tool. 1. Alice is planning to rent an apartment, \nso she navigates her normal web browser to Craigslist.com and has a look at the apartments listed there. \nAlice looks at the apartments listed by Craigslist and would like to know more about them. In particular, \nshe would like to know which apartments have good restaurants nearby. Since Craigslist can t do this \nitself, Alice realizes she needs to use MashMaker. 2. Alice clicks on the Add to MashMaker button on \nher web browser bookmark bar to launch MashMaker and view the Craigslist housing web page within the \nMashMaker proxy\u00adbrowser. MashMaker starts up as an AJAX web application, within Alice s web browser, \nhosted by the central MashMaker webserver (Figure 2). The right hand window shows the web page Alice \nis looking at, and the left hand side shows a tree representation of the web site. In this case, there \nis a node for the Craigslist query, witha child node for each apartment. Each ofthese apartmentnodeshasasetof \npropertynodes,expressing properties of that apartment such as its price and the number of bedrooms. \n 2Terms such as truly general purpose and usableby normal are hard to de.ne formally, so some might \ndisagree with this statement. Figure 3. Using a Google Maps visualization for an apartment Figure 4. \nJoiningYelp to Craigslist 3. MashMaker notices that Craigslist apartments are things that usershavepreviously \ndisplayedon maps,soitprovidesabutton at the top of the window allowing Alice to add a map to each apartment. \nAlice clicks on this button to get a map for each apartment (Figure 3). 4. Alicewouldliketo seeYelp \nrestaurantreviews neareach apart\u00adment,but is disappointed to see that MashMaker has not pro\u00advidedabuttontodo \nthis automatically.She will thus needto teach MashMaker about this connection herself. 5. Alice navigates \nto Yelp and searches for food at an arbitrary address. When the result of the query appears, she clicks \non Add to MashMaker to suck this query page into MashMaker. The resultingYelp node is called food nearby \nand contains nodes for all restaurants near to the speci.ed address. 6. Alice now has both Craigslist \nand Yelp in her MashMaker scratch spacebut they are not yet connected. Alice copies the Yelp node into \none of the apartments3. She then expands the form panel to reveal the form de.ning the Yelp query, and \nchangesthe address .eldoftheYelpformtobe =address a reference to the address property of the enclosing \napartment   Figure 5. Yelp displays restaurants near the apartment  Figure 6. Filtering apartments \nusing a lambda expression node(Figure4).Eachapartmentnowhasa foodnearby prop\u00aderty, showing the restaurants \nnear to that apartment (Figure 5). 7. Now that Alice has created this food nearby node, Mash-Maker learns \nthat this is a property that users might want to de.ne for Craigslist apartments. In the future, if another \nuser views a Craigslist apartment, MashMaker will provide a food nearby button to allow other users to \nadd this same property. 8. Currently food nearby shows all restaurants near to each apartment,but Aliceispicky,andsoisonlyinterestedin \nhighly rated restaurantsvery neartothe apartment. MashMakerknows thatprevious usershave applieda .lter \noperationtoYelp list\u00adings, so it suggests that Alice apply a .lter operation here (Fig\u00adure 5). Alice \nclicks on thisbutton and types distance < 1 AND rating > 4 as the condition4 (Figure 6). Alice could \nalternatively have used an interactive user interface to compose this query. Alice renames the result \nof the .lter to good restau\u00adrants within walking distance .  3This corresponds to a map operation (Section \n2.3.1). 4This is actually a lambda expression, despite the absence of lambda sym\u00adbol or explicit arguments \n(Section 3.5). 9. This new property is dependent on the existence of a food nearby property, and so \nwill not be suggested by MashMaker for Craigslist apartments that lack this property.5 Thinking that \nthis property might be useful for other users searching for apartments on Craigslist, Alice decides to \nbundle up the new property, together with the other properties it depends on, as a new widget.To do this, \nshe clicks bookmark as new widget , and tells MashMaker which of the properties that this property depends \non shouldbe considered to be arguments, rather than being internal to the widget. In this case, the address \nis an argument, and food nearby is internal. In the future, when another user browses a Craigslist apartment, \ngood restaurants within walking distance may be suggested to them. 10.Toallowthemselvestogetanoverallviewofthequalityofeach \napartmentonoffer,Aliceaddsanumberof additional properties (commute time to work, crime level, average \nincome) and uses the calculator widgetto de.nea scoring metricby combining these features. She then sorts \nall the databy this metric. Section 3.2 shows the functional program that this editing ses\u00adsion created. \n 2.2 Learning from File Systems Likea.le system, MashMaker presentsalldataasatree(Figure2). All nodes \nin this tree are immutable. The underlying implementa\u00adtion uses sharingtoavoid duplicating data,but users \nare encouraged to think of their data as being in a tree. Like a .le system, each node either has its \nown content (a .le), or subnodes (a directory). The content can be of arbitrary type, for example, some \ntext, a number, an expression, an image, a URL. Each subnode is either a property with an explicit name, \nor a child with no name. It is assumed that all children will represent things of roughly equivalent \ntype, whereas the types of properties will vary, and correspond to their names. MashMaker s tree view \nshows a text summary for each node. If the node is a named property, then this summary is preceded by \nthe property name. The summary for a simple .le node is a text summary of the content (e.g. the text \nfor a text node). The summary for a directory node is a user-con.gurable combination of the summaries \nfor its properties by default the summary of the .rst property. MashMaker s right hand pane shows a \nvisualization of the se\u00adlected node. If the node is a .le, then this will be a visual repre\u00adsentation \nof the .le s data. In some cases, this will be a computed representationof otherdatainthetree,forexampleamap,a \ngraph, or a table. If the node s content is a URL then that URL is shown. Similarly, text, images, and \nother visualizations can be shown in this panel.. Figure1showsthe notationforsuchtreevaluesin MashMaker \ns underlying language.We write \u00d8 to denote an empty directory, and ' v K (k . v) to denote the directory \nthat results from extending the directory v witha new subnode v' where k is if the subnode is a child \nand a property name if the subnode is a property. As the underlying language is purely functional, alldependencies \nbetween nodes are explicit, preserving the principle of least surprise. For convenience, one can write[k0 \n. v0,...,kn . vn] as an abbreviation for \u00d8K(k0 . v0)K...K(kn . vn).Toillustrate the waythis notationworks,hereisthe \nnotationforthevalueshownin Figure 5: 5See Section 2.4 to see why. [ food nearby . ..., craigslist housing \n. [ url . ..., . [ title . Rare JordanPark Listing , food nearby . [ .{title . Tawan s ThaiFood ,...}, \n.{title . Assab Eritrean ... ,...} ], google map . ...,... ],... ],... ]  Somewhat unusually fora programming \nlanguage,but entirely inkeeping witha .le system, MashMaker allows identi.er names to contain spaces. \nMashMaker s data representation is also heavily in.uenced by XML6. In particular, the idea of distinguishing \nbetween properties and children is taken from XML. The key differences are that, unlikeXML, MashMaker \nallows properties to be arbitrary subtrees, rather than just simple text, and MashMaker nodes do not \nhave tag names.We believe that this representation is simpler for users to understandthanXML,butitis \nclose enoughtoXMLthatitiseasy to encode each in the other. 2.3 Learning from Spreadsheets One of thekey \nprinciples behind mashmaker is that users should create mashups through direct manipulation of their \ndata, rather than writing an abstract program. To support this goal, we have taken much inspiration from \nspreadsheets. Spreadsheets haveachieved remarkable success in allowing nor\u00admal usersto write relatively \ncomplicated programs.Oneofthekey features that has allowed spreadsheets to do this is their avoidance \nof unnecessary separation between a program and the data it is working with. In a conventional programming \nlanguage, the pro\u00adgrammer writes a program in isolation of any argument data. As theywrite this function, \ntheymust imagine what it will do with ar\u00adguments theymight give it. By contrast, a spreadsheet avoids \nthis separationbyallowingthe programmertoapply operations directly to a speci.c piece of data and then \ncopying the operation to other data if it seems to work. MashMaker borrows sixkeyfeatures from spreadsheets: \n Program and data mixed in one central workspace.  All data is stored explicitly in the workspace. There \nare no local variables .  An expression is evaluated at a speci.c location, and refers to other data \nrelative to its current location.  Map and fold are described through direct manipulation of data, rather \nthan using abstract functions.  Text entered by a user is assumed to be a constant, unless proceeded \nby = .  Expressions re-evaluate automatically in response to changing arguments7.  6Originally ourplanwasto \nuseXMLasthedata model,butweeventually decided that a simpli.ed model would be easier for users. 7There \nare some systems issue here. In particular, how does one determine that a web site has changed, and how \ndoes one avoid querying a web site too often? However these are off-topic for this paper, so we will \nnot discuss them further. The tree view on the left side of the MashMaker window shows the value that \nthe user s current program evaluates to. Each node is either a de.ned node, meaning that there is a user-speci.ed \nexpression de.ning its value, or it is a result node, meaning that it is part of the result of evaluating \na parent de.ned node. In the user interface, result nodes have a green ball as their icon while de.ned \nnodes havean icon corresponding to the function that de.nes them. Ade.nednode containsan internal referencetotheexpressionthat \nde.nes it, allowing the user to easily edit this expression. Each expression is evaluated by referring \nto the values of other nodes near it in the tree. Just as a spreadsheet allows a user to edit a formula \nusing the formula bar, but avoids displaying the formula in the normal display, MashMaker allows a user \nto edit the form arguments for a de.ned node using the form panel which pops down from the top of the \nright hand side whena user clicks on its icon.For advanced users, MashMaker also allows the user to turn \non a spreadsheet\u00adstyle formula bar, which displays the current expression textually, in MashMaker s underlying \nfunctional language. 2.3.1 Map and Fold An appealing feature of spreadsheets is the way theyallow a user \nto map a single expression over a collection of objects by simply writingaformulainonecell,andthencopyingtheexpressiontoall \ndata rows below. This approach allows the user to easily see how their expression is evaluated for each \ndata element. MashMaker takes a similar approach. If a user adds a new property to a node, then similarly \nde.ned properties are automatically created for all sibling nodes.Forexample,in Section 2.1, when the \nuser addeda google map to one apartment, a map was automatically added to all other apartments. All these \nexpressions use the same de.ning expression, and when the user uses the form panel to change the arguments \ntheychange the arguments for all the other replicas too. Asina spreadsheet,a MashMaker user can easily \nlookata speci.c application of the expression to some data and see directly how it evaluates. Similarly,spreadsheetsprovideaneasywayfor \nusersto fold an operation over a collection of objects. fold is infamous within the functional programming \ncommunity as being a dif.cult function for beginners; they either can t remember the argument order, \nor theyhave dif.culty thinking about exactly what a function will do when folded over a collection of \ndata. However those same users have little dif.culty performing fold operations in a spreadsheet. In \na spreadsheet, all a user has to do to fold their function over data rather than simply map it is write \nan expression that refers to the cell above, and then read out the .nal value from the bottom. Following \nthisexample, MashMaker allows usersto write fold-like operationsusingthebuiltin prev propertytorefertotheprevious \nsibling. If there is no previous sibling then prev returns the value of the user-de.ned init property, \nor an empty value if this is not de.ned. MashMaker also appropriates spreadsheet syntax for distin\u00adguishing \nconstants from expressions within the user interface. By default, any text entered by a user is assumed \nto be a string con\u00adstant, unless it is proceeded by = .We chose this default partly becauseitis what \nusers arefamiliar withand partlytoavoidthe needforbeginning usersto learn aboutexpressions beforetheycan \nedit form arguments. This feature is not part of the textual repre\u00adsentation of the MashMaker language \n it is simply part of the user interface.  2.4 Learning from Web Browsers Another guiding principle \nof MashMaker is program as you browse , meaning that creating a mashup should feel like the nor\u00admal web \nbrowsing process. The web browser is perhaps the most successful user interface of modern times. This \nsimple interface allows users to .nd infor\u00admation and perform sophisticated queries by merely following \na sequence of links and occasionally typing data into forms. MashMaker follows this model as much as \npossible. When a user is looking at a particular node, MashMaker will automatically suggest additional \nfunctions that theymight want to apply by pro\u00advidingbuttons acrossthetopoftheviewpane(Figure5). Clicking \non oneof thesebuttons will insertanew node whose de.ningex\u00adpression extracts data from the data already \navailable (e.g. food nearby .nds its address argument from the existing address prop\u00aderty). Theexpectationisthatmost \nusersof MashMakerwillneveruse thekeyboard orexpand the widget pane. Instead theywillexplore theirdata \nentirelybyclickingon MashMaker suggestions.Ineffect, MashMaker extends the web browsing experience by \nadding new links that users can follow. The suggestions that MashMaker makes are derived from ob\u00adservations \nof functions that other users have previously applied to similar-looking data, following the code sharing \nprinciple. For example, in Section 2.1, once one user had added a node to a Craigslist apartment whose \nde.ning expression was food nearby = Yelp([address = address, what = \"food\"]), MashMaker will automatically \nsuggest adding a node with the same de.nition for all other Craigslist apartments. Another behavior that \nMashMaker borrows from web browsers is bookmarks. If a user is using a web browser, they can use book\u00admarks \nto remember interesting pages that they have found, or to share aninteresting page with friends. The \nequivalent behavior in MashMakeris user-de.ned widgets.To createa user de.ned wid\u00adget, the user navigates \nto an interesting result that they would like to remember for later or share with friends and clicks \nbookmark as newwidget (Figure 4). MashMaker will then prompt the user to select which of the nodes that \nthe result depends on should be con\u00adsidered arguments and which should be considered internal to the \nfunction. Non-expert users will typically opt for the default all nodes the result depends on are internal, \ncausing the entire mashup tobe bookmarked,justasifthe userhad bookmarkedanormalweb page. This approach \nallows users to experiment with their function on real data before abstracting it as a function. Perhaps \nmore im\u00adportantly, it allows users to browse around aimlessly, looking for something interesting, without \nnecessarily having to think in ad\u00advance that theymight be going to create a function at the end. Even \nwhen theydo createa function, ourintentionis that theythinkof what theyare doing as bookmarking an interesting \ndiscovery,rather than writing a function. 2.5 Multi-Level MashMaking We have designed MashMaker with \nthe intention that it should be usablebyanyonefroma completenovicetoanexpert programmer (following the \npay as you go principle). In particular, we antici\u00adpate that users will use MashMaker at the following \nlevels, where each level requires a little more skill from the user and allows the user to do more powerful \nthings: 1. Basic Users: Never unfold the widget panel. They explore their data purely by clicking on \nAdd to MashMaker in their browser, and clicking on suggestion buttons to add enhance\u00adments to their data. \nBasic users will sometimes bookmark things they .nd, using the default bookmark settings (Sec\u00adtion 2.4). \nBasic users do not even have to see the tree on the left, since all the information they need is visible \nin the view pane on the right. 2. Normal Users: Occasionally expand the widget panel to edit form parameters. \nThe changes theymake .ow through into the suggestions made to all users. 3. Skilled Users: Connect up \nnew sites that have not previously been connected, using copyand paste and simple expressions that refer \nto other properties. 4. Semi-Expert Users: Use semi-automated scraper-creation tools (not yet written) \nto create scraper widgets for new web sites. 5. Expert Users: Write complex expressions directly in \nMash\u00adMaker s core language. 6. Gurus:Teach MashMakerhowto understandthe contentofnew websites, either \nby uploading a hand-written XML description (the current state), or by using an interactive tool (the \nfuture).  Weexpectthateachcategorywill containanorderof magnitude fewer people than the previous category. \nHowever, even though the number of highly skilled users may be small, their presence is essential since \nit is theywho import the web sites and write the functions that less skilled users later use. 3. The \nMashMaker Language In the previous sections we have explained the general model of how MashMaker works \nand the mental model that it presents to a user. In this section we will describe in more detail the \nfunc\u00adtional programming language that is at the heart of MashMaker, and in particular the concept of \ndirectories and tree extension (Sec\u00adtion 3.2). 3.1 Core Syntax Figure1gives the grammar forexpressionsin \nMashMaker s core language. This grammar deals with a simpli.ed version of the full MashMaker language. \nIn particular we omit the expression forms for specialbuilt-in functions such as prev. Values were describedin \nSection 2.2.Avalueis eithera con\u00adstant .le value (of arbitrary type), a directory with property and child \nsubnodes,oralambdaexpression.Adirectoryis eitherempty, or is a smaller directory that has been extended \nwith an additional subnode8. It is legal for a directory to contain multiple properties with the same \nname, however one will only be able to look up the value of the last one. MashMaker is dynamically typed, \nin common with the Lisp familyof languages,and,of course, spreadsheets.Ifadynamictype error occurs then \nthe erroneous node stext summary and viewpane will explain what went wrong. Anexpressionisevaluatedwith \nrespecttoits locationinthedata tree.The locationis representedasa stackof parentvalues,eachof whichisadirectory.Ifanexpression \nlooksupavariable,the lookup is relative to the current location. The innermost directory value in the \nlocation is known as the context. Expressions take the following forms: Aliteral constantc  An empty \ndirectory \u00d8  An extension e K (q . e ' ) adds a new subnode to e. e is required to evaluate to a directory, \nand q is an extension path that says where the new subnode should appear. Theexpression e ' is evaluated \nat e, so e ' can refer to any properties in the directory that e evaluates to. We discuss extensions \nin more detail in Section 3.2.  8Note that, unlike normal list concatenation, we add new elements to \nthe end, rather than the beginning of a directory. For convenience, one can write[q0 . e0,...,qn . en] \nas an abbreviation for \u00d8 K(q0 . e0) K... K(qn . en). Alambda expression.(x0 ...xn).e.x de.nes a closure \nvalue whose arguments have names x0 ...xn and whose body is the expression e. The returnvalueis computedbyevaluating \ne to a directory and then selecting the property called x. MashMaker identi.es function arguments by \ntheir label, rather than their order. For syntactic convenience, one can omit the .nal .x part of a \nlambda expression, meaning that the result is the entire value, rather than some property of it.  Afunction \napplicatione (e ' ) applies e to e ' . e must evaluate to a function and e ' must evaluate to a directory \nwith properties matching the names of all the arguments of e.  Writing this , allows an expression to \nrefer directly to the current location as a directory value.  A path reference p looks up a property \nrelative to the current location. By default, only properties in the current context are matched,but \nthe !x form allows oneto search the parent loca\u00adtions.   3.2 Tree Extensions The key new construct \nin the MashMaker language is the tree extension: e Kq . e ' This constructiskeytothe connection betweenthe \ncore Mash-Maker language and the MashMaker user interface, since it denotes the action of adding new \ncomputed nodes to the data tree. In this construct, e is the base of the current tree, q isapathtothe \nposition at which the user has inserted a new node, and e ' is the expression used to de.ne the new node. \nThe path q can include the wildcard symbol, * , meaning that the restofthepath shouldbe appliedtoall \nchildren.Infact, thereis nowaytoaddanew subnodeforjust one child node.If one wishes to add a subnode \nto one child node then one must add it to all of them. Here is the simple expression that the user created \ninteractively in the example in Section 2.1. [ houses . Craigslist Housing([area . sfbay]), houses.*.map \n. Google Maps([address . address]), food nearby . Yelp([what . food , where . ...]), houses.*.food nearby \n. Yelp([what . food , where . address]), houses.*.good food nearby . Filter([what . food nearby, how \n. .(distance, rating).(distance < 1) . (rating > 5)]), ] Here, we see that the user took Craigslist \nHousing andextended it to add a new de.ned node called map inside each apartment. The value of each map \nwas computed with reference to the ad\u00address property of that apartment. The user also added an additional \ntop-level node called food nearby and de.ned food nearby and good food nearby nodes for each apartment.Within \nthe user in\u00adterface, each of these de.ned nodes contains an internal reference to the program subexpression \nthat de.nes it, allowing the user to easily edit function arguments. Theuserinthatexamplealsode.nedthefollowingglobal \nfunction: GoodFood Nearby = .(address).( [ food nearby . Yelp([what . food , where . address]), good \nfood nearby . Filter([what . food nearby, how . .(distance, rating).(distance < 1) . (rating > 5)]), \n].good food nearby) We can see that this function was created by copying the food nearby and good food \nnearby properties out of the scratch-space data tree, recording thefact that address was anexternal input, \nand noting that good food nearby is the result value.  3.3 Semantics Figure7givesa big-step operational \nsemanticsfor strictevaluation of MashMaker expressions. The real semantics for MashMaker is lazy, however \nthis strict semantics allows us to more easily present language constructs such as tree extension, without \nthe distraction oflazyevaluation.We discusslazyevaluation morein Section3.4. The evaluation relation \nis of the following form: s, e . v where s is the location at which the expression is evaluated. This \nis a stack of parent values, each of which is a directory value. The innermost parent value is known \nas the context.We write v : s to denote a location with context v on top of the rest of the location. \n e is the expression being evaluated  v is the value that e evaluates to in the location s  Most of \nthese rules should be easy to follow: (CONST) and (EMPTY) are already values, and so do nothing  (EXTEND-NEW) \nadds a new subnode to a directory. The new node is evaluated in a context that includes all previous \nproper\u00adties,but not anyproperties added to the directory subsequently.  (EXTEND-EMPTY), (EXTEND-ALL) \nand (EXTEND-SKIP) add an extension to all child nodes. (EXTEND-SKIP) skips over property nodes, (EXTEND-ALL) \nextends the last child node, and then recursively extends the others.  (EXTEND-PROP1) and (EXTEND-PROP2) \nextend a named property. (EXTEND-PROP1) matches the last property and ex\u00adtends it. (EXTEND-PROP2) skips \nover a non-matching prop\u00aderty.  (LAM) builds a closure, stashing the current location as the environment. \n (APP) applies e to e ' . e is evaluated to a closure with body e '' . e ' is evaluated to a directory \nv ''.A new contextisbuiltby extending the closure environment with properties from v '' that match the \nclosure arguments. The closure body e '' is evaluated in this context and the property x is selected \nfrom the result.  (THIS) simply grabs the current context value.  (VAR), (FIELD), and (PARENT) follow \na path from the current location.   3.4 Lazy Evaluation LikeHaskell(PeytonJones2003b),all MashMakerexpressionsare \nevaluated lazily. The current consensus in the programming lan\u00adguage community seemstonowbethatlazyevaluationisthewrong \nevaluation model for conventional programming languages (Peyton Jones 2003a). This is because the bookkeeping \noverhead of lazy (EXTEND-NEW) (EXTEND-EMPTY) (CONST) (EMPTY) ' '' s, e . vv : s, e . v s,e .\u00d8 s, c . \nc s, \u00d8.\u00d8 s, e Kk . e ' . v ' K(k . v) s, e K*.q . e ' .\u00d8 (EXTEND-ALL) (EXTEND-SKIP) '''' '' s, e . v1 \nK( . v2) s, v1 K*.q . e . v1 v1 : s, v2 Kq . v2 s, e . v1 K(x . v2) s, v1 K*.q . e . v1 ''' '' s, e K*.q \n. e . v1 K( . v2) s, e K*.q . e . v1 K(x . v2) (EXTEND-PROP1) (EXTEND-PROP2) '''' '' s, e . v1 K(x . \nv2) v1 : s, v2 Kq . e . v2 s, e . v1 K(x . v2) x= x s,v1 Kx.q . e . v1 ' ' ''' s, e Kx.q . e . v1 K(x \n. v2) s, e Kx.q . e . v1 K(x . v2) (LAM) s, .(x0 ...xn).e.x . (s, .(x0 ...xn).e.x) (APP) '' '' s, e \n. (v : s ,.(x0 ...xn).e .x) ' '' ''' '' ''' '' ''' ''' ' '' '''' '''' s, e . v (x0 . v0 ) . v ... (xn \n. vn ) . v (v ' K(x0 . v0 )) K... K(xn . vn ))) : s ,e . vv : s, x . v s, e(e ' ) . v (VAR) (FIELD) (PARENT) \n(THIS) ' '' ' ''' (x . v) . v (x . v ) . vv : v : s, p . v s,p . v v : s, this . v '' ' v : s, x . vv \n: s, x.p . vv : s, !.p . v Figure 7. Operational semantics for strict MashMaker evaluation evaluation \nmakes programs run slowly, the complex evaluation be\u00adhavior makes performance hard to predict, and programmers \noften have to battle with space leaks due to long chains of lazy thunks. MashMaker, however, is not a \nconventional programming lan\u00adguage.We believe that the unusual application domain that Mash-Maker works \nin makes lazy evaluation highly appropriate. In par\u00adticular: In the case of web mashups, the bookkeeping \ncost of remember\u00ading how to evaluate something is tinycompared to the massive cost of fetching and scraping \na web site, thus it is only neces\u00adsary for a very small number of expressions to be unneeded for the \nbookkeeping cost to be more than paid back.  Even if fetching a web site was cheap, it is important \nfor us to minimize the number of queries we make to a remote server, to avoid overwhelming a server (Section \n3.7).  Typical mashup programs work with relatively small amounts of data that are not directly presented \nto the user, and so space leaks arefar lessofa problem.  Manyweb sites are already essentially lazy.Forexample \nwhen one makes a search using Google, it does not return all results in one page,but instead produces \nresults lazily as one presses the next buttons.  MashMaker s lazy evaluation works largely as one would \nex\u00adpect. The value of a node is only evaluated when it is either de\u00admanded by the evaluation of another \nnode, or the user attempts to view it through the graphical interface. 3.5 Lambda Expressions in the \nUser Interface The MashMaker user interface has somewhat unusual treatment of lambda expressions. While \nthe syntax in the underlying core languageisfairly conventional, with lambdaexpressionsexplicitly marked \nas such and arguments explicitly listed, the user interface attempts to hide this from users as much \nas possible. Although MashMaker is dynamically typed, theWidget meta\u00addata forafunction includesa.ag for \neach argument saying whether it is a closure. If an argument is a closure then the forms UI inter\u00adprets \ntext entered for that argument a little differently than for non\u00adclosure arguments. Anytext entered is \nassumed to be the body of a lambda expression, and any variables in the expression that are not bound \nat the current location are assumed to be lambda arguments. Advanced users can tell that this alternative \ntext handling is in use by noticing a . icon next to the argument text box.  3.6 Live Data All data \nin MashMaker is live, meaning that it may change over time and will react to changes in other parts of \nthe data tree. If a tree is the result of a web query, then this tree will update over time, as the source \nweb site changes 9. The MashMaker language is designed to handle changing data well.In particular, since \nMashMakeroverlaysextensionsover gen\u00aderated data (Section 3.2), rather than modifying it in-place, these \nextensions will be automatically applied to new versions of the underlying data. Also, since the MashMaker \nextension construct automatically adds new properties to all children of a node, these properties will \nalso apply to any new children that are added to the tree.  3.7 Throttling One important practical issue \nthat has to be dealt with whenever one createsamashupistheneedtoavoidplacingtoomuchloadon the web sites \nsupplying data. If one has an agreement with the web site provider then it is likely to specify a maximum \nload, and if one 9Eitherby pollingtheweb siteata.xedfrequency,orwaiting untilthe user asks for a refresh. \n does not have an explicit agreement then placing too much load on a server could cause the owners to \nblock the mashup system s IP address. As a result of this, it is necessary for MashMaker to throttle \nthe rateatwhich requestscanbemadetoexternalwebsites.Indeedthis rate is one of the primary issues that \ndetermines the performance of aMashup,sinceifamashupneedstomaketoomanyrequests,then it will have to slow \nitself down in order to avoid sending requests too rapidly. This performance restriction has motivated \nMashMaker not only to use lazy evaluation (Section 3.4), but also to use a number of other tricks (not \ndiscussed in this paper) to minimize the number of requests that need to be made to external web servers. \n 3.8 When Websites turn Bad One limitation of MashMaker, as with most other tools that scrape information \nfrom web sites, is that mashups can break if the under\u00adlying websiteschange.Ifawebsitechangesthe structureofthedata \nit produces, or changes its HTML such that the current scraper no longer understands it, then mashups \nthat depend on this data will no longer function correctly. In the long term, we hope this this problem \nwill become less severe as websites increasingly publish semantic information in well de.ned data formats. \nMore generally, MashMaker is not intended to be used for mission critical applications where data integrity \nis essential. Instead, its focus is on applications where it is more important to be able to produce \ninteresting data than to be certain that the data is correct. 4. Evaluating Usability Following Peyton \nJones et al. (2003), we evaluate the usability of MashMaker using the Cognitive Dimensions of Notations \n(CDs) framework (Blackwell et al. 2001). CDs provide a vocabulary that enumerates concepts important \nto users who are engaged in pro\u00adgramming tasks. While evaluation against cognitive dimensions is subjective, \nand is not a substitute for thorough user testing, these concepts have been shown over time to be important \nto human problem solving and it is important to consider each when design\u00adinga usable interface.We list \nthe cognitive dimensionsin Figure8 and evaluate MashMaker against these dimensions below: Abstraction \nGradient: MashMaker can be used at a number of different levels of abstraction, allowing use by users \nrang\u00ading from complete beginner to experienced programmer (Sec\u00adtion 2.5).  Consistency: New widgets \nare created using the same mecha\u00adnism as creating simple expressions. All work in MashMaker is done using \nthe same simple mechanism of applying widgets and setting form parameters.  Error Proneness: Unlike \nnormal spreadsheets, MashMaker automatically ensures that when a user adds a property to a set of children \nthe de.ning expression is identical for all children.  Hidden Dependencies and Role Expressiveness: \nWhen a node is selected, all dependent or source nodes are automat\u00adically highlighted to make it clear \nthat there is a dependency.  Premature Commitment: Users do not have to decide in ad\u00advance what they \nare looking for,but instead canwander aim\u00adlessly,looking for something useful. If they.nd something they \nlike, they can bookmarkit asa new function widget,but they need not decide in advance that this is what \nthey are going to do.  Progressive Evaluation: There is no requirement that a pro\u00adgram be in anysense \ncomplete in order for the user to look at its result. Similarly, likea spreadsheet,if someevaluationsfail \n Abstraction gra- What are the minimum and maximum lev\u00ad dient els of abstraction? Can fragments be encap\u00ad \nsulated? Consistency When some of the language has been learnt, how much of the rest can be inferred? \nError-proneness Does the design of the notation induce careless mistakes ? Hidden depen- Is every dependency \novertly indicated in dencies both directions? Is the indication perceptual or only symbolic? Premature \ncom- Do programmers have to make decisions mitment before theyhavethe information theyneed? Progressive \nCan a partially-complete program be exe\u00ad evaluation cuted to obtain feedback on how am Ido\u00ad ing ? Role- \nCan the reader see how each component of expressiveness a program relates to the whole? Viscosity How \nmuch effort is required to perform a single change? Visibility and juxtaposability Is every part of the \ncode simultaneously vis\u00adible (assuming a large enough display), or is it at least possible to compare \nany two parts side-by-side at will? If the code is dis\u00adpersed, is it at least possible to knowin what \norder to read it? Figure 8. Cognitive Dimensions (taken from Peyton Jones et al. 2003) then this does \nnot affect the behavior of non-dependent parts of the program. Viscosity: MashMaker ssupport for user-de.ned \nfunctions, au\u00adtomatic synchronization of property de.nitions across multiple children, and its general \npreference for linking of data rather than copying, make it easy to make widespread changes.  Visibility \nand Juxtaposability: Unlike conventional program\u00adming languages, MashMaker juxtaposes program and data \nto\u00adgether, so the programmer can easily see the effects of evaluat\u00ading their expressions. While MashMaker \ndoes not allow one to view multiple forms or multiple view panels in the same win\u00addow, MashMaker does \nallow one to view the same data store with multiple browser windows, allowing one to put arbitrary information \nside-by-side.  Based on this analysis, and also our personal experiences using MashMaker, we believe \nthat our design is fundamentally sound. However, in order to demonstrate this objectively, we need to \nper\u00adformaproper userstudy,and indeedwe intendtodothisinthe near future. 5. Related Work In this section, \nwe explain how MashMaker relates to previous work on Mashup creation and end-user programming in general. \nIn prior work, we described the basic MashMaker tool from a database angle (Ennals and Garofalakis 2007). \n 5.1 Mashup Creation Tools Mashups are an increasingly hot topic, and thus there have been many efforts \nto simplify their creation. Relative to MashMaker, these previous tools generally fall into two groups: \nthose which are easyto use,but canonly createa limitedfamilyof mashups; andthosewhichare relativelydif.culttouse,butcan \ncreateawide range of mashups. Google MyMaps 10 and MapCruncher 11 make it easy for end users to create \nmashups involving maps. Swivel.com makes it very easy for end users to create graph mashups from multiple \ndata tables. However, while each of these tools is easy to use, and excellent at producing mashups of \na speci.c type, none of them is as general purpose as MashMaker. Yahoo Pipes 12 is a powerful tool that \nallows users to process data from RSS feeds. While, at the time of writing, the small set of operations \navailable in Pipes makes it less .exible than MashMaker,it seemslikelythatthetoolwillbeextendedtogiveit \nequivalentexpressivepower.Thekeydifference betweenPipesand MashMaker is that, unlike MashMaker, pipes \npresents the program as an explicit graphical data.ow graph, rather than mixing it with the data being \nbrowsed. Marmite (Wong and Hong 2006) takes a pipeline-based ap\u00adproach, similartoApple sAutomator 13.Thedatafromawebsite \nis routed through a sequence of pipeline stages, each of which is con.gurable, and can produce dataofa \ndifferent type. LikeYahoo Pipes, the program is separated from the data and presented as a graph, rather \nthan being embedded in the data like a spreadsheet. LikeMashMaker,Marmite will automatically suggest \noperations to apply to data. Unlike MashMaker, these suggestions are based on the type of the data (similar \nto Jungloids (Mandelin et al. 2005)), rather than based on the behavior of previous users. Anthracite \n14 is similar to Marmite, but requires that the user be familiar with complex concepts such as HTML and \nregular expressions. Creo (Faaborgand Lieberman 2006) augments web pages with additional links that can \nobtain additional information about items on a web page. Like MashMaker, Creo will automatically make \nsuggestions and can learn by example from things that users do with their data. Unlike MashMaker, Creo \nis limited to adding addi\u00adtionalhyperlinks to web pages and cannot performbulk data pro\u00adcessing tasks. \nGoogle Mashup Editor,Plagger.org, Ning.com, Javascript Data.ow Architecture (Lim and Lucas 2006), and \nWeb Mashup Scripting Language (Sabbouh et al. 2007) are powerful tools for creating mashups,but theyrequire \nthat the user write code. ClearSpring.com, Widsets.com, WidgetBox.com, and Apple s Dashboard 15 allow \nusers to write small graphical web widgets and then lay them out together on a screen. DataMashups.com \nadditionally allows users to connect these widgets together (e.g. the output of this widget is the input \nto that widget),but complex tasks require considerable programmer skill. HunterGatherer (Schraefel et \nal. 2002) and Internet Scrap\u00adbook (Sugiura and Koseki 1998) allow users to extract parts of multiple \nweb sites and composite them together,but are not able to perform complex processing on these sites and \nextract collections of data. Like MashMaker,C3W (Fujimaetal.2004) usesa spreadsheet metaphor. C3W uses \na standard .at two-dimensional spreadsheet to connect web sites together. If a user de.nes values for \na web site s input cells, then it will produce results in its output cells, clipped from the web page. \nUnlike MashMaker, C3W uses a .at two dimensional grid, rather than a tree. This prevents one writing \nmashups that produce nested data, such as producing a list of restaurants for each of several apartments. \n10 http://maps.google.com 11 http://research.microsoft.com/mapcruncher 12 http://pipes.yahoo.com 13 http://www.apple.com/ \n14 http://www.metafly.com/products/anthracite 15 http://www.apple.com/ TreeSheet (Leonard 2004) represents \ndata as an XML tree,but unlike MashMaker, programming is done using imperative scripts, rather than functional \noverlays. Within the database community, SEMEX (Cai et al. 2005) and DataSpaces (Franklin et al. 2005) \nhave looked at data-integration how to get transform various data sources into a suitable structure \nso that they can be combined with queries.  5.2 End-User Programming Tools MashMaker also bears some \nsimilaritytoanumberof end-user pro\u00adgramming tools thathave not been used for creating web mashups: Programmable \nStructured Documents (PSDs) (Takeichi et al. 2003; Hu et al. 2004; Liu et al. 2005) allow one to extend \na stan\u00addard XML document by embedding elements in the tree that are computed from other elements. An \nexpression de.ning an XML node can referto other nodesusingXPathexpressionsandthenpro\u00adcess the nodes \nusing arbitrary Haskell functions. Like MashMaker, PSDs are based on a functional language (in this case \nHaskell) and areevaluated lazily. UnlikeMashMaker PSDs deal with static XML documents, rather than live \ndata. Indeed, since PSDs include ex\u00adpressions directly in a document, rather that overlaying changes \non topof generated datainaway that canbe automatically re-applied, theycould not be used to add additional \nproperties to livedata with\u00adout changes to the model (Section 3.6). Subtext (Edwards 2005) is a programming \ntool that allows one to look at a program together with the results of its evaluation. In Subtext,every \nnodein the data tree correspondsto theexecutionof a single program line with speci.c data and is annotated \nwith the value produced. Function calls are expanded as subtrees and func\u00adtion de.nitions contain example \narguments that the programmer can adjust to interactively see how their program will behave. Like MashMaker, \nsubtext allows programmers to easily see how their program will behave when applied to particular arguments. \nUnlike MashMaker, the Subtext interface is program-centric, rather than data-centric meaning that data \nis layered on top of a program, rather than overlaying a program on top of data. MashMaker s function \ncreation system is in.uenced by the work of Peyton Jones et al. (2003) in extending Microsoft Excel to \nsupport user-de.ned functions. Like MashMaker, they allow one to de.ne a new function by selecting a \nresult cell and then using a graphical interface to specify which other cells are arguments. MashMaker \nssuggestion systemis in.uencedbyJungloids(Man\u00addelin et al. 2005) and Google Suggest 16. Like Jungloids, \nMash-Maker suggests operations that are appropriate to the data one has at hand. Like Google Suggest, \nMashMaker learns from the behav\u00adior of other users. More generally, MashMaker draws on past work on Program\u00adming \nby Example (Cypher et al. 1993; Lieberman 2001), and pre\u00advious work on programming approaches for beginners \n(Kelleher andPausch 2005). 6. Conclusions We have presented MashMaker, a tool that allows end-users to \neasily create web mashups. While MashMaker is, at its core, a functional language, it contains a number \nof deviations from the standard functional paradigm. By taking ideas from such popular tools as .le systems, \nspreadsheets, and web browsers, we have produced a tool that we believe is well suited to the task of \nmashup creation. This project is interesting as a programming language research project both because \nit approaches an application domain for which programming languages havenot historically been seen as \nthe solu\u00adtion, and also because, in the process of .tting our language to this 16 http://labs.google.com/suggest/ \n domain, we have produced a language that has many differences from previous functional languages. We \nhave implemented MashMaker as an AJAX web applica\u00ad tion, currently made available within our organization \nas part of a closedbeta program.Weplantomakeit publicallyavailablein the near future. In the long term, \nthe success of MashMaker will be judged based on the extent to which real users adopt it, and the scale \nof the bene.t theyare able to obtain from it. For more information on MashMaker, and access to the public \nbeta when it opens, please go to the following url: http://berkeley.intel-research.net/rennals/mashmaker/ \nmashmaker.html Acknowledgments Thisworkhas bene.tedfromtheinputofmanypeople.Particular thanks shouldgotoMinosGarofalakis,EricPaulos,andIan \nSmith. References AlanF. Blackwell, Carol Britton, Anna Louise Cox, Thomas R. G. Green, Corin A. Gurr, \nGadaF. Kadoda, MariaKutar, Martin Loomes, Chrysto\u00adpher L. Nehaniv, Marian Petre, Chris Roast, Chris Roe, \nAllan Wong, and RichardM.Young. Cognitive dimensionsof notations: Design tools for cognitive technology. \nIn CT 01: Proceedings of the 4th Interna\u00adtional Conference on Cognitive Technology, pages 325 341, London, \nUK, 2001. Springer-Verlag. ISBN 3-540-42406-7. Yuhan Cai, Xin Luna Dong, Alon Halevy, Jing Michelle Liu, \nand Jayant Madhavan. Personal information management with SEMEX. In SIG-MOD 05: Proceedings of the 2005ACM \nSIGMOD international con\u00adference on Management of data, pages 921 923, NewYork, NY, USA, 2005. ACM Press. \nISBN 1-59593-060-4. doi: http://doi.acm.org/10. 1145/1066157.1066289. Allen Cypher, Daniel C. Halbert, \nDavid Kurlander, Henry Lieberman, David Maulsby, Brad A. Myers, and Alan Turransky, editors. Watch whatIdo:programmingby \ndemonstration. MIT Press, Cambridge, MA, USA, 1993. ISBN 0-262-03213-9. Jonathan Edwards. Subtext: uncovering \nthe simplicity of programming. In OOPSLA 05: Proceedings of the 20th annualACM SIGPLAN confer\u00adence on \nObject oriented programming, systems, languages, and applica\u00adtions, pages 505 518, NewYork, NY, USA, \n2005.ACM Press. ISBN 1-59593-031-0. doi: http://doi.acm.org/10.1145/1094811.1094851. Robert Ennals and \nMinos Garofalakis. Mashmaker : Mashups for the masses (demo paper). In Proceedings of the 2007 ACM SIGMOD \nInternational Conference on Management of Data (SIGMOD 2007), 2007. AlexanderFaaborgand Henry Lieberman.Agoal-oriented \nweb browser. In CHI 06: Proceedings of the SIGCHI conference on HumanFactors in computing systems, pages \n751 760, NewYork, NY, USA, 2006.ACM Press. ISBN 1-59593-372-7. doi: http://doi.acm.org/10.1145/1124772. \n1124883. Michael Franklin, Alan Halevy, and David Maier. From databases to datas\u00adpaces: A new abstraction \nfor information management. In SIGMOD Record, 2005. Jun Fujima, Aran Lunzer, Kasper Hornb\u00e6k, andYuzuruTanaka. \nClip, con\u00adnect, clone: combining application elements tobuild custom interfaces for information access. \nIn UIST 04: Proceedings of the 17th annual ACM symposium on User interface softwareand technology,pages \n175 184,NewYork,NY,USA, 2004.ACM Press. ISBN 1-58113-957-8. doi: http://doi.acm.org/10.1145/1029632.1029664. \nZhenjiang Hu, Shin-Cheng Mu, and Masato Takeichi. A programmable editor for developing structured documents \nbased on bidirectional trans\u00adformations. In PEPM 04: Proceedings of the 2004 ACM SIGPLAN symposiumonPartialevaluationand \nsemantics-basedprogram manip\u00adulation, pages 178 189,NewYork,NY, USA, 2004.ACM Press. ISBN 1-58113-835-0. \ndoi: http://doi.acm.org/10.1145/1014007.1014025. CaitlinKelleher and RandyPausch. Lowering the barriers \nto programming: A taxonomy of programming environments and languages for novice programmers. ACM Comput. \nSurv., 37(2):83 137, 2005. ISSN 0360\u00ad0300. doi: http://doi.acm.org/10.1145/1089733.1089734. Thomas Leonard. \nTree-Sheets and Structured Documents. PhD thesis, University of Southampton, 2004. Henry Lieberman. Your \nwish is my command: programming by example. Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, \n2001. ISBN 1-55860-688-2. Seung Chan Slim Lim and Peter Lucas. Jda: a step towards large-scale reuse \non the web. In OOPSLA 06: Companion to the 21stACM SIG-PLAN conference on Object-oriented programming \nsystems, languages, and applications, pages 586 601, New York, NY, USA, 2006. ACM Press. ISBN 1-59593-491-X. \ndoi: http://doi.acm.org/10.1145/1176617. 1176631. DongxiLiu, ZhenjiangHu,and MasatoTakeichi.Anenvironmentfor \nmain\u00adtaining computation dependencyin XML documents. In DocEng 05: Proceedings of the 2005 ACM symposium \non Document engineering, pages 42 51, NewYork, NY, USA, 2005.ACM Press. ISBN 1-59593\u00ad240-2. doi: http://doi.acm.org/10.1145/1096601.1096616. \nDavid Mandelin, Lin Xu, Rastislav Bodik, and Doug Kimelman. Jungloid mining: helping to navigate the \nAPI jungle. In PLDI 05: Proceedings of the 2005ACM SIGPLAN conference on Programming language design \nand implementation, pages 48 61, New York, NY, USA, 2005. ACM Press. ISBN 1-59593-056-6. doi: http://doi.acm.org/10.1145/1065010. \n1065018. Simon Peyton Jones. Wearing the hair shirt: a retrospective on Haskell (invited talk). In ACM \nSIGPLAN Conferenge on Principles of Program\u00adming Languages (POPL 03), 2003a. Simon Peyton Jones, editor. \nHaskell 98 Language and Libraries: the Revised Report. Cambridge University Press, may 2003b. SimonPeytonJones,AlanBlackwell,andMargaret \nBurnett.Auser-centred approach to functions in Excel. In ICFP 03: Proceedings of the eighth ACM SIGPLAN \ninternational conference on Functional programming, pages 165 176,NewYork,NY,USA, 2003.ACM Press. ISBN \n1-58113\u00ad756-7. doi: http://doi.acm.org/10.1145/944705.944721. Marwan Sabbouh, Jeff Higginson, Danny Gagne, \nand Salim Semy. Web mashup scripting language (poster). In 16th InternationalWorldWide Web Conference, \n2007. M.C. Schraefel,DanielWigdor,YuxiangZhu,andDavid Modjeska. Hunter gatherer: within-web-page collection \nmaking. In CHI 02: CHI 02 extended abstracts on Human factors in computing systems, pages 826 827,NewYork,NY,USA, \n2002.ACM Press. ISBN 1-58113-454-1. doi: http://doi.acm.org/10.1145/506443.506617. Michael Schrenk. Webbots, \nSpiders, and Screen Scrapers. No Starch Press, 2007. Atsushi Sugiura andYoshiyukiKoseki. Internet scrapbook: \nautomating web browsing tasks by demonstration. In UIST 98: Proceedings of the 11th annual ACM symposium \non User interface software and technology, pages 9 18, NewYork, NY, USA, 1998.ACM Press. ISBN 1-58113\u00ad034-1. \ndoi: http://doi.acm.org/10.1145/288392.288395. MasatoTakeichi, ZhenjiangHu, KazuhikoKakehi,Yashushi Hayashi,Shin-Cheng \nMu, and Keisuke Nakano. TreeCalc: towards programmable structured documents. In Japan Society for Software \nScience andTech\u00adnology, 2003. Jeffrey Wong and Jason Hong. Marmite: end-user programming for the web. \nIn CHI 06: CHI 06 extended abstracts on Human factors in computing systems,pages 1541 1546,NewYork,NY,USA, \n2006.ACM Press. ISBN 1-59593-298-4. doi: http://doi.acm.org/10.1145/1125451. 1125733.   \n\t\t\t", "proc_id": "1291151", "abstract": "<p>MashMaker is a web-based tool that makes it easy for a normal user to create web mashups by browsing around, without needing to type, or plan in advance what they want to do.</p> <p>Like a web browser, Mashmaker allows users to create mashups by browsing, rather than writing code, and allows users to bookmark interesting things they find, forming new widgets - reusable mashup fragments. Like a spreadsheet, MashMaker mixes program and data and allows ad-hoc unstructured editing of programs.</p> <p>MashMaker is also a modern functional programming language with non-side effecting expressions, higher order functions, and lazy evaluation. MashMaker programs can be manipulated either textually, or through an interactive tree representation, in which a program is presented together with the values it produces.</p> <p>In order to cope with this unusual domain, MashMaker contains a number of deviations from normal function languages. The most notable of these is that, in order to allow the programmer to write programs directly on their data, all data is stored in a single tree, and evaluation of an expression always takes place at a specific point in this tree, which also functions as its scope.</p>", "authors": [{"name": "Rob Ennals", "author_profile_id": "81331491980", "affiliation": "Intel Research, Berkeley, CA", "person_id": "P884775", "email_address": "", "orcid_id": ""}, {"name": "David Gay", "author_profile_id": "81100039538", "affiliation": "Intel Research, Berkeley, CA", "person_id": "PP39024398", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291187", "year": "2007", "article_id": "1291187", "conference": "ICFP", "title": "User-friendly functional programming for web mashups", "url": "http://dl.acm.org/citation.cfm?id=1291187"}