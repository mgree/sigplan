{"article_publication_date": "10-01-2007", "fulltext": "\n Tangible Functional Programming Conal M. Elliott LambdaPix conal@conal.net Abstract We present a user-friendly \napproach to unifying program creation and execution, based on a notion of tangible values (TVs), which \nare visual and interactive manifestations of pure values, including functions. Programming happens by \ngestural composition of TVs. Our goal is to give end-users the ability to create parameterized, composable \ncontent without imposing the usual abstract and lin\u00adguisticworking styleof programmers.We hope that sucha \nsystem willput the essence ofprogramming into the hands of many more people, and in particular people \nwith artistic/visual creative style. In realizingthis vision, we develop algebras for visual presen\u00adtation \nand for deep function application, where function and ar\u00adgument may both be nested within a structure \noftuples, functions, etc. Composition gestures are translated into chains of combinators that act simultaneously \non statically typed values and their visual\u00adizations. Categories and Subject Descriptors D.2.6 [SOFTWARE \nEN-GINEERING]: Programming Environments graphical environ\u00adments, interactive environments General Terms \nHumanFactors, Languages, Theory Keywords interactive programming, end-user programming,ges\u00adtural composition, \ncombinator libraries, arrows, interactive visual\u00adization 1. Introduction The activities of creating and \nexecuting interactive programs typi\u00adcallydiffer greatlyin formand thought process. Program creation (including \nmodi.cation) happens in an abstract and linguistic set\u00adting, while program execution is a (relatively) \nconcrete and visual experience. Suppose users of interactive programs could also create such programs \nwith a simple extension of their current style of interac\u00adtion. First, such a development would enable \nmany more people to createandshare computational content.Second,itwouldallowthis content to be created \nwithout imposing the abstract, linguistic mode of creativity.This freedommaygivebirthtonewkindsof programs \nwhose creationis nurturedbya concrete andvisual environment. This paper presents an approach to unifying \nprogram creation and execution, based on a notion of tangible values (TVs), which serve two roles. First, \nthey allow interactive inspection of values Permission to make digital or hard copies of all or part \nof this work for personal or classroom use is granted without fee provided that copies are not made or \ndistributed for pro.t or commercial advantage and that copies bear this notice and the full citation \non the .rst page.To copyotherwise, to republish, to post on servers or to redistribute to lists, requires \nprior speci.c permission and/or a fee. ICFP 07, October 1 3, 2007, Freiburg, Germany. Copyright c &#38;#169; \n2007ACM 978-1-59593-815-2/07/0010...$5.00 (including functions). Second, they enable composition, to \ncreate new TVs. In this way, end-users become programmers, without the usual division between (a) the \nrun-time world of visual interaction, and (b) the compile-time world of syntax. Users run and create \n(functional) programs by interacting with the same visual repre\u00adsentation.WehaveimplementedthisideaofTVsinasystem \ncalled Eros. The work described in this paper makes the following contribu\u00adtions: An algebra of interactive \nvisualizers for presenting typed val\u00adues. In contrast to Haskell s show function, which produces strings \nand is not generally useful for functions, our approach produces GUIs and is especially useful for functions. \nTVs are formulated by simply pairing values and visualizers, combined for convenience and separable for \ncomposability.  A new approach to end-user functional programming. Users create and compose functional \nprograms gesturally (purely without syntax), by working directly with the same concrete visualizations \nused for interactive inspection. Speci.cally, a user selects compatibly-typed input and output widgets, \ntypi\u00adcally in different TVs. The result is a fusion of the two source TVs, containing all of the original \ninputs and outputs except for the connected input and output. Due to the structured na\u00adture ofvisualizers \nand TVs, higher-order programming is fully supported.  Anew functional programming style,in whichaburied \nfunc\u00adtion canbe appliedtoanycompatiblytypedburiedvalue.This programming style, which we call deep application \n, sub\u00adsumes function application and function composition. If the function s domain has a structured \ntype (say nested pairs), it maybe appliedtoa portionofa domainvalue, yieldinga resid\u00adual function.Deepapplicationis \nbasedonasetof combinators, used in a simple way, to describe three paths in the type struc\u00adture leading \nto (a) theburied function, (b) the relevant portion of that function s domain value, and (c) to the argument \nvalue.  Generalization of these techniques to apply beyond functions, via a new Arrow subclass.We formulate \ngestural composition in this general setting, and specialize to tangible values.  Thenexttwosections \ndemonstratethe user sexperienceof visu\u00adalizing and composing TVs.Section4then presents the deep appli\u00adcation \ncombinators and their use, as applied to standard functions. To prepare for the gestural setting, the \ntools are then generalized in Section5 witha new DeepArrow type class. Section6 brie.y addresses the \nmechanics of translating a user s gestures into (in\u00advisible) applicationof the deep application combinators. \nSection7 describes support for persistence and (run-time) compilation, via a data type and corresponding \narrow instance that .ts it into our framework. We conclude with a discussion of related and future work. \n Figure 1. Simple, non-interactive visualizations Figure 2. Composite visualizations 2. InteractiveVisualizationofValues \nThe standard Haskell library comes with a Show type class for rendering values into strings. Class instances \nexist for manytypes, including numbers and booleans, and for type constructors, includ\u00ading tuples and \nlists. Additional instances may be de.ned or, for algebraic data types, derived automatically. Notably \nmissing, how\u00adever, is a means of rendering functions. Moreover, some types are rendered more naturally \nvisually, e.g., graphs, structured 2D or 3D graphics, some functions, and formatted text. 2.1 GUIs as \nvisualizations Functionsand visual presentationcanbothbe supportedby render\u00ading values into (possibly \ninteractive) GUIs. In their simplest form, these GUIs may have a single widget, as in Figure 1, which \nshows simple non-interactivevisualizations of pi,True,and the unit disk. Visualizations may also be constructed \nout of simpler ones, as in Figure 2. In those examples, pairs are rendered as horizontal juxtaposed visualizations \nseparatedby a thinvertical space. (The purpose of the space is explained below.) To visualize functions \nin general, a simple technique suf.ces: create an interactive presentation that allows the user to sample \nthe function dynamically, i.e.,vary inputvalues interactively, while watchingthe corresponding output \nchanges.By visualizinga func\u00adtion,we mean function inasemantic sense,asamapping (usually in.nite), rather \nthan any sort of syntax ( code )for the function. Figure3shows some function visualizations.Eachtaketheformof \nan input for the function sdomain stacked abovea visualization for the function s range. Between input \nand output is a thin horizon\u00adtalspace.A uservariestheinputvaluesand immediately seesthe result of applying \nthe function to the new value. Figure 3. Functions (input above output) Figure 4. Multiple arguments \nvia pairing or currying Functions of more than one argument may be handled in the usual two ways, via \ntupled arguments or currying. Both variants are shown in Figure 4, where1 magSq :: R2 . R magSq (x, y)= \nx 2 + y 2 For magSq, the pair-valued input is composed out of two inputs. For(<) :: R . R . Bool, the \nvisual composition is a single real\u00advalued input above a single function-valued output, which consists \nof a real-valued input above a Bool-valued output. The structure of a visualization directly re.ects \nthe structure of the type ofthevisualizedvalue.In otherwords,theGUI s structure is a type visualization, \ni.e., visual syntax for a type. In Figure 1, the types are all atomic(double, Bool, and Region), so each \nvisualization is atomic (i.e., contains a single widget). In Figure 2, the types are pairs of atomic \ntypes, so the visualizations contain twowidgets horizontallyabuttedand connectedbyavertical space, which \nrefers to the pair itself. That vertical space is the visual counterpartforthe commainapairtype stextual \nsyntax. Similarly, inFigure3,thetypesare functionsfromoneatomictypeto another, so the visualizations \nagain contain two widgets, vertically abutted and connectedbya horizontalspace, correspondingtothe arrowin \ntextual syntax. Just as arrow is right-associative, vertical stacking is bottom-associative , as in the \nexample on the right in Figure 4. In additionto inspectingvalues,ausermayhoveroveranypiece of visual \nstructure to see the corresponding type s textual syntax. Figure5shows atomic types corresponding to \natomic sub-widgets, while Figure6 shows composite types corresponding to compos\u00adite widgets. (Note the \ndown-associativity.) The value presented in Figures5and6is .ab . magSq b < a 2 . 1For brevity, we use \nthe following type synonyms throughout this paper: type R = Double type R2 =(R, R) Figure 5. Atomic \ninputs and outputs Figure 6. Composite inputs and outputs Figure 7. Example with slider and graphic \n ThevalueshowninFigures5and6mayalsobe visualizedquite differently,asinFigure7.Thisversionisbasedon modelingspatial \nregions as R2 . Bool,as in (Hudak andJones 1994; Elliott 2003). This visualization reveals that the function \ndescribes a disk, with the .rst argument determining the radius. Points inside the region (mapped to \nTrue by the function) are painted black. 2.2 Inputs and Outputs To give the terms visualization , input \n, and output precise meaning, we de.ne two type constructors, Output and Input. Values of type Output \na, which we also call a visualizers , describe how to present values of type a toa user.Valuesof type \nInput a describe how to get values of type a from a user.2 2The reason we package interactive visualizers \nvia type constructors in\u00adstead of type classes (as Show)is to allow more than one way to input or outputa \nsingle type.For convenience, Eros alsoprovides classesto assign default inputs and outputs to types, \nsuch as as those used in Figure 4. iGet :: WGet a . Input a iPair :: Input a . Input b . Input (a , b) \noPut :: WPut a . Output a oPair :: Output a . Output b . Output (a , b) oLambda :: Input a . Output \nb . Output (a . b) Figure 8. The visualizer algebra The visualizations shown so far are all generated \nby outputs composed via the visualizer algebra shown in Figure 8. The types WPut a and WGet a are functions \nthat take a container sub\u00adwindow and add some number of widgets to present values to or get values from \na user. Forexample, the visualizationin Figures5and6is described by o1, where o1 :: Output (R . R2 . \nBool) o1 = oLambda iRead (oLambda (iPair iRead iRead) oCheck) iRead = iGet readWGet oCheck = oPut checkBoxWPut \nreadWGet :: Read a . WGet a checkBoxWPut :: WPut Bool Note that in the de.nition of o1 there are four \ninputs (three iRead and one iPair)and three outputs (twooLambda and one oCheck), as re.ectedin Figures5and6. \nAsinglevalue canbe visualizedin differentways.For instance, the value displayed with o1 in Figures 5 \nand 6 may also be dis\u00adplayed as in Figure 7, using o2, where type Region = R2 . Bool o2 :: Output (R \n. Region) o2 = oLambda iSlider oRegion iSlider = iGet sliderWGet oRegion = oPut regionWPut sliderWGet \n:: WGet R regionWPut :: WPut Region  2.3 TangibleValues Each ofthe visual examples above combines a \nvalue with a means of visualizing that value. This combination, which we call a tan\u00adgible value (or TV \n), is what the user inspects and, as described later, creates. data TV a = TV (Id a)(Output a) The Id \ntype constructor is just a wrapper around values: newtype Id a = Id a This wrapper will make some later \nde.nitions a bit more uniform. More importantly, Id serves as a placeholder for an alternative in Section \n7 that enables persistence and compilation. The Haskell expressions appearing at the top of TVs rely \non that alternative. Theyappearin this paper for claritybut are probably not desirable for our target \naudience. --Pre-de.ned (in Parts menu) udisk, checker :: Region uscale, rotate :: R . Region . Region \nintersect :: Region . Region . Region --De.ned below scaleDisk :: R . Region scaleChecker :: R . Region \nrotScaleChecker :: R . R . Region intersectDisk :: R . Region . Region diskChecker :: R . R . R . Region \nscaleDisk ds = uscale ds udisk scaleChecker cs = uscale cs checker rotScaleChecker cs ang = rotate ang \n(scaleChecker cs) intersectDisk ds reg = intersect (scaleDisk ds) reg diskChecker cs ang ds = intersectDisk \nds (rotScaleChecker cs ang) Figure 9. Region examples in conventional syntactic form  3. Gestural Composition \nTVs are not just a way to view values, but also to create them. As such, they serve as a tangible (concrete \nand visual) means of programming. Gestural composition , illustrated in this section, causes an output \nof one TV to be fed directly into an input of another TV. The result is a fusion of the two source TVs, \ni.e., a new TV containing all of the original inputs and outputs except for the connected input and output, \nwhich vanish. Figures10 through14showthe stagesofdevelopmentofapa\u00adrameterized visual design (or an interactive \nvisual design, de\u00adpending on perspective). Figure 9 shows conventional syntactic de.nitions corresponding \nto the gestural development. The user selects uscale and udisk from Parts, resulting in the left and \nmiddle GUIs shown in Figure 10. The uscale GUI has a slider for the .rst argument and an evaluator for \nthe second argu\u00adment. This evaluator passes the input string to GHC (for parsing, type-checking, and \nrun-time compilation), via hs-plugins (Pang et al. 2004). In this case, the input image is xPos, which \nis the half-spacetotherightoftheYaxis. Now we come to gestural composition.To replace the second input \nof uscale with the output of udisk, the user right-clicks .rst the region input and then the region ouput. \nThe result is the appearance of the right-most GUI. Note that the matched region inputandoutputhavevanished,leavingjustthe \nsliderinputandthe region output from uscale.3  Eros gives visual feedback to aid composition, highlighting \ninputs in blue when the cursor passes over them. After an input is chosen, type-compatible outputs are \nhighlightedingreen,andonly those outputs are candidates for connection. Figure 11 continues the interactive \ndevelopment. The user adds uscale (left) and checker (middle), and then links uscale s region input (as \nwith udisk above) with checker to get a scalable checker (right). In Figure 12, the user next adds rotate \n(left) and links its Region input to the scaled checker s Region output. The result is a checker that \nscales and rotates interactively. Again, with each of the input/output linkings,the resultingTVisahybridofthetwo \ngiven TVs,except for the matching input and output, whichvanish. Next the user wants to intersect the \nscaling disk with the scal\u00ading, rotating checker. Figure 13 shows the .rst composition step, connecting \nthe .rst region input of intersect (of type Region . Region . Region)with the region output of the scaling \ndisk of Figure 10, to get a TV of type R . Region . Region. Figure 14 then shows the .nal composition \nstep, .lling in the remaining re\u00adgion input (left over from intersect)with the region output of the scaling, \nrotating checker. The previous examples are only nominally higher-order, in that regions, though functions, \nare shown with an atomic visualizer. 3All of the examples in this section follow the form of this example: \nTV with selected input on the left, TV with selected output in the middle, and resulting composition \non the right. For clarity, we show simultaneously input and output selections with cursors and type annotations, \nthough in reality, .rst the input is selected and then the output.   Figure 15 demonstrates Eros s \nsupport for higher-order gestural programming, to construct the intersect function, using the fol\u00adlowing \nfunctions. liftB2 :: (Bool . Bool . Bool ) . (Region . Region . Region) (&#38;&#38;) :: Bool . Bool . \nBool  In the liftB2 TV on the left, the userhas temporarily chosen equal\u00adity as the input Boolean operation \nand xPos and udisk as the input regions.For composition, the trick is to use one of the composite, function-valued \noutput handlesin the middleTV(logical conjunc\u00adtion). Erosisnot limitedtovisual designsbut canbeusedwithany \ntypefor which visualizers canbe constructed.Asa .nalexample, Figure16 shows anexample using standardHaskell \nfunctions.A sentence is broken up into words and then the words are sorted. Figure 17 then puts the sorted \nwords back together into a new sentence.  The Tweak menu allows the user to restructure a GUI by ap\u00adplying \nduplication, swapping, currying and uncurrying, argument reordering, pair member extraction, and re-association \nof pairs. In particular, duplication allows an output to be used more than once. 4. DeepApplication Eros \nimplements gestural composition by translating gestures into sequences of the combinators developed in \nthis section. As illustrated in Section 3, there are three gestures to translate: (a) selection of an \ninput, (b) selection of an output to be matched upwithaninputto createanewhybridTV,and(c) applicationof \none of the reshaping tools in the Tweak menu to create a new TV. Semantically,these three gestures collapse \ninto twoactions. The .rst is extraction of a function in response to gesture (a). The second action is \napplication of a function to a buried argument, whichis performedin responseto gestures(b)and(c).Forexample, \nconsider Figure12.To create the TV on the right, the user selects the Region input from the left TV and \nthen the Region output (the checker board) from the middle TV. The left TV presents rotate :: R . Region \n. Region By selecting the Region input of rotate, the user indicates not rotate itselftobe applied,but \nrathera related function: ' rotate:: Region . R . Region ' rotatereg r = rotate r reg ' In other words, \nrotate= .ip rotate. Then in selecting the region output of the middle TV, the user indicates that the \npreviously cho\u00adsen function(rotate')is to be applied not to the whole (function\u00advalued)TV,butjusttothe \nresultofthe function.In otherwords, rotate' is tobe composed with the checker-scaling function. Thus, \nthe result is rotate' . (.a . uscale a checker) which is equivalent to the expression shown in the right \nTV: .ab . rotate b (uscale a checker) The rest of this section presents the combinators used in trans\u00adlating \nuser gestures, breaking them into three groups. The .rst group enables application of functions deeply \n, i.e., toburied ar\u00adguments. The second group extracts buried functions as well, so that the result may \nbe applied (perhaps deeply). The .nal group extracts individual parts of a function argument, corresponding \nto the inputs of Section 2.2. Typically, all three of these groups are combined to create a new value \nvia gestural composition. Although our combinators may be viewedas an editing algebra, theywork on values, \nrather than syntax. 4.1 Transformation Embedders When composing (whether gesturally or syntactically), \nwe often want to apply a function to part of a value. If we re composing syntactically, we simply insert \nthefunction application somewhere insideofanexpression ratherthanatthetop.Workingwithvalues, rather than \nsyntax, requires corresponding semantic tools.4 Sup\u00adpose, for example, that we have a pair expression \n(e1, e2) and we want to apply a function expression f just in the .rst half. If working syntactically, \nwe would change the pair expression to (fe1, e2) .Workingwithvalues,wecan instead embed afunc\u00adtion f \ninto a function that works on pairs, and then apply that pair\u00adtransforming function. Similarly, we can \nembed a function g to work on pairs by transformingthe second element. Thus, we have two embedders: .rst \n:: (a . a ' ) . ((a, b) . (a ' , b )) second :: (b . b ' ) . ((a, b) . (a , b ' )) .rst f = .(a, b) . \n(fa, b ) second g = .(a, b) . (a , gb) Note that, as needed, .rst and second apply their .rst arguments \nto part of a pair value, carrying along the other half of the pair. When working syntactically, we often \napply functions under lambdas. The corresponding value-level, embedding combinator is just function composition.We \nuse the name result asa synonym for . , for consistencywith .rst and second and, more im\u00adportantly, for \ngeneralizing in Section 5. result :: (b . b ' ) . ((a . b) . (a . b ' )) result g = . f . g . f What \nabout deeper embeddings, say doubly layered? Given a value of type (a, (b, c)),wemightwantto transformjustthe \nb part and leave the rest intact. In other words, we dlike an embedder secondFirst :: (b . b ' ) . ((a, \n(b, c)) . (a, (b ' , c))) Fortunately, this deeper embedder can be de.ned easily from second and .rst: \nsecondFirst = second . .rst since, given f :: b . b ', we have .rst f :: (b, c) . (b ' , c), and second \n(.rst f ) :: (a, (b, c)) . (a, (b ' , c)). We can make longer composition chains to transform more deeplyburied \narguments.Forexample,givenavalueof type (a . (f , b . (c, g)), e),we mightwantto applya functiontojustthe \nc part and leave the rest intact. 4There is a difference in .exibility between working with syntax and \nwith semantics(values).Forexample,given theexpression 3+4 , a syntactic programmer can insert a function \napplication around 4 . When working with values, we simply have 7, so the change would have to be made \nat an earlier point in development. emb1 :: (c . c ' ) . (a . (f , b . (c , g)), e) . (a . (f , b . (c \n' , g)), e) emb1 = .rst . result . second . result . .rst  Notefromthisde.nitionthatadeep embedderis \nformedsimplyby listingthepathfromthe whole(root)value leadingtoaburiedpart. For instance, to de.neemb1, \nwe wrote down the steps in reaching c within the type of the second argument(.rst of the pair, result \nof that function, second of that pair, etc.) Let s return to our examples from Section 3 for examples \nof forming and using transformation embedders. In Figure 13, the intersect function is applied to the \nresult of scaleDisk function. Thus intersectDisk = result intersect scaleDisk Likewise,in Figure14,anargument-.ippedversionof \nintersectDisk is applied to the (region-valued) result of the result of the curried function rotScaleChecker. \nThus diskChecker = (result . result)(.ip intersectDisk) rotScaleChecker  4.2 Function Extractors Instead \nof a buried argument, we might instead have a buried function, e.g., .x . x * x in (.x . x * x, \"square\").To \napply aburied function in a syntactic setting, one can .oat the lambda to the top of the containing expression \n(following an .-expansion if there is no explicit ., and a-converting where needed to avoid variable \ncapture).For instance, (.x . x * x, \"square\") becomes .x . (x * x, \"square\"). Again, working with values \nrather than syntax requires a differ\u00adent trick. The following three function-extracting combinators are \nhandy: funF :: (c . a , b) . (c . (a , b)) funS :: (a , c . b) . (c . (a , b)) funR :: (a . c . b) . \n(c . (a . b)) funF (f , b)= .c . (fc, b) funS (a, f )= .c . (a, fc) funR g = .c . .a . gac Returning \nto our example, if h =(.x . x * x, \"square\"), then funF h isa function ready to apply.For instance, funF \nh 3 = (9, \"square\"). Next consider more deeply buried functions. Recall that the combinators .rst, second, \nand result from Section 4.1 were di\u00adrectly composed for arbitrarily deep application. Our new combi\u00adnators \nfunF , funS, and funR, however, do not have types suitable for composition with each other.To .x this \nproblem, de.ne three slightly more complex combinators. Each one maps an extractor into another one that \nreaches more deeply. funFirst :: (d . (c . a)) . ((d , b) . (c . (a , b))) funSecond :: (d . (c . b)) \n. ((a , d) . (c . (a , b))) funResult :: (d . (c . b)) . ((a . d) . (c . (a . b))) Givenawaytoextractafunctionfromthe \n.rst elementofapair, funFirst produces a way to extract a function from the pair itself. Similarly for \nfunSecond and funResult. As an example function extractor, fxt1 :: (d . (c . b)) . (e . (a, d), f ) . \n(c . (e . (a, b ), f )) fxt1 = funFirst . funResult . funSecond  To perform an extraction, apply the \nextractor to the identity func\u00adtion: xt1 :: (e . (a, (c . b)), f ) . (c . (e . (a, b ), f )) xt1 = fxt1 \nid  In Section 4.3, we will see alternatives to id. The three composable function extractors are de.ned \neasily in termsofthe simpler, non-composable ones.For instance,toextract a functionburied somewherein \nthe .rst elementofapair,extract the function from the .rst element and then extract one last level to \nthe top. funFirst h = funF . .rst h funSecond h = funS . second h funResult h = funR . result h Theexamplesof \nSection3 useonlyvery simple function ex\u00adtractors, namely id and funResult.For instance, in Figure 12, \nthe user selected the (region-valued) input of the result of the function rotate :: R . Region . Region. \nTheextracted functionis there\u00adfore rotate ' :: Region . R . Region rotate ' = funResult id rotate Of \ncourse, in this case, a simpler de.nition would be rotate ' = funR rotate. As mentioned above, we use \nfunResult in general, because the simpler funR (a synonym for the standard .ip func\u00adtion) lacks the composability \nproperty required to extract deeply buried functions. 4.3 Input Extractors Recall from Section3 that \nourgoalisto allowa userto connect compatibly typed inputs and outputs. The function extractors in Section \n4.2 are helpfulbut not suf.cient for this goal, since they do not reach into structured inputs.5 For \nexample, considerf :: ((a, b), c) . d.We could consider f to have .ve inputs , of types a, b,c, (a, b),and \n((a, b), c). Any of these .ve inputs could be eliminated by .lling it in with a cor\u00adrespondingly typed \nvalue, possibly leaving a residual input. Elimi\u00adnating the input of type b would yield a result of type \n(a, c) . d (which has three inputs, of types a, c, and (a, c)). The usual no\u00adtionof functionapplicationisaspecialcase,inthateliminatingthe \ninput of type ((a, b), c) results in a value of type d. Tosupport eliminationofpartofafunctionargument,we \nde.ne sometoolsfor inputextraction .Theideaisto transformthegiven function into a (possibly curried) \nfunction of just the desired input, whichmay thenbe applied directly.Forexample,to eliminatethe b input \nfrom f , we would .rst transform f into a function of type b . (a, c) . d, and then apply the transformed \nfunction. The simplest case is that in which the input is the whole function argument, so there is nothing \nto be done to extract the input. If the chosen input is directly within a pair type, extraction is also \neasy, using one of the following two functions: inpF :: ((a, b) . c) . (a . (b . c)) inpS :: ((a, b) \n. c) . (b . (a . c)) inpF = curry inpS = .ip . curry A trickier case is where the chosen input is more \ndeeply buried. For example, consider how to eliminate the b input in a function of type ((a, b), c) . \nd or ((a, (b, e)), c) . d.We will want to make input extractors with the following types: 5For now, we \nuse the word input to mean part of a function argument, rather than as de.ned in Section 2.2 for TVs. \nIn Section 5, we will general\u00adize these techniques to a setting that applies to TVs. ixt1 :: (((a, b \n), c) . d) . (b . ( a , c) . d) ixt2 :: (((a, (b, e)), c) . d) . (b . ((a, e), c) . d) We cannot use \nthe simple combinatorsinpF and inpS, because theydo not have composable types (as with the simple combinators \nfunF,funS,andfunR from Section 4.2).Toget composability,de\u00ad.nethefollowingtwocombinators, which promote \ninputextractors from simpler to more complex types: inpFirst :: (( a . c) . (d . ( a ' . c))) . (((a, \nb) . c) . (d . ((a ' , b) . c))) b ' inpSecond :: (( b . c) . (d . ( . c))) . (((a, b) . c) . (d . ((a \n, b ' ) . c))) Given a way to extract a d input from an a input, leaving an a ' residual input, inpFirst \nyields a way to extract a d input from an (a, b) input, leaving an (a ' , b) residual input. Similarly \nfor inpSecond. De.nitions can be inferred from the types: inpFirst h f d (a ' , b)= h (.a . f (a, b)) \nda ' inpSecond h f d (a, b ' )= h (.b . f (a, b)) db ' Input extraction works by using compositions \nof inpFirst and inpSecond to target an application of inpS or inpF .For example, ixt1 and ixt2, whose \ntypes aregiven above, are easilyde.ned: ixt1 = inpFirst inpS ixt2 =(inpFirst . inpSecond) inpF Typically, \nwe will have to combine function and input extractors. For instance, usingfxt1 from Section 4.2 with \nixt2, xt2 :: (e . (g, (((a, (b, e)), c) . d)), f ) . (b . (e . (g, (((a, e ), c) . d)), f )) or, spelled \nout, xt2 =( funFirst . funResult . funSecond . inpFirst . inpSecond ) inpF  If xt2 is applied to a suitably-typed \nvalue, the resulting function can be directed, via a function embedder, at an argument of type b buried \ndeeply inside some other value. Theexamples from Section3do not need inputextractors (other than the \nidentity), because theydo nothave pair-valued inputs. 4.4 DeepApplication De.nitions andExamples We \nnow have the tools to fully implement the constructions given in Section3. See the conventional syntactic \nde.nitionsin Figure9 for comparison. Using our new tools, we have the following de.nitions. To clearly \nrelate our combinators with gestural composition, de.ne the following higher-order function for deep \napplication : deep :: (d . (a . b)) --function extractor . d --function container ' . b ' . ((a . b) \n. (a )) --transformation embedder . a ' --argument container  . b ' --overall result deep xtr fc emb \nac = emb (xtr fc) ac  The de.nitions in Figure 18 exactly parallel the gestural com\u00adpositionsgivenin \nSection3.In each gestural composition, the user selects (a) an input, determining the (combined function \nandinput) extractor xtr and function-containing value fc, and (b) an output, determining the embedder \nemb and the argument-containing value ac. In these examples, the name idA is synonymous with id (the \nidentity function), though it will be generalized in the next section. scaleDisk = deep (funResult idA) \nuscale id udisk intersectDisk = deep (id idA) intersect result scaleDisk scaleChecker = deep (funResult \nidA) uscale id checker rotScaleChecker = deep (funResult idA) rotate result scaleChecker diskChecker \n= deep (funResult idA) intersectDisk (result . result) rotScaleChecker Figure 18. Deep Application Examples \n 5. Generalizing DeepApplication The combinators from Section4 enable the gestural composition ofpurevalues.Wewant,however,to \ncomposenotjustthevalues, but visualizersfor thosevalues.Infact,wewantto composevalues and visualizers \nin tandem, i.e., tangible values (TVs), as described in Section 2. In this section, we generalize the \ncombinators so that theyapply more broadly, including to visualizers and TVs. 5.1 An ArrowforVisualization \nThe .rst and second combinators used in Section 4.1 are already de.ned quite broadly, for arrow types \n(Hughes 2000). class Arrow (r) where .rst :: (a r a ' ) . ((a, b) r (a ' , b )) second :: (b r b ' ) \n. ((a, b) r (a , b ' )) arr :: (a . b) . (a r b) (> ) ::(a r b) . (b r c) . (a r c) The de.nitions \nof .rst and second in Section 4.1 belong to the function Arrow (i.e., the . instance of Arrow), where \nalso arr is the identity and (> ) is reverse function composition. To handle visualization, we ll need \nanotherArrow instance, to represent transformation ofthe outputs introduced in Section 4. The following \nsimple de.nition suf.ces: newtype OFun a b = OFun (Output a . Output b) We de.ne theOFun instance of \nArrow in close analogy with the . instance. Recall the de.nitions of .rst and second for functions (Section \n4.1): .rst f = .(a, b) . (fa, b ) second g = .(a, b) . (a , gb) The de.nitions for OFun are almost identical, \nusing output pairs rather than value pairs. In order to pattern-match on structure, we represent outputs \nand inputs as generalized algebraic data types (Peyton Jones et al. 2006) that directly mirror the visualizer \nalgebra in Figure 8.6 instance Arrow OFun where .rst (OFun f )= OFun (.(OPair a b) . OPair (fa) b) second \n(OFun g)= OFun (.(OPair a b) . OPair a (gb))  Arrow composition is de.ned via function composition. \nOFun f > OFun g = OFun (f > g) Given only a pure function, arr has no useful way of render\u00ading values. \nOne could signal an error or yield an output that dis\u00adplays a warning message. Unavailability of arr \ncomes up in other contexts (Alimarine et al. 2005), so it may be worth introducing a Arrow superclass \nwithout arr. 5.2 An ArrowforTangibleValues Recall from Section 2.3 that a tangible value is simply a \nvalue and an output. Providing an arrow instance for TVs is a simple matter of combining the function \narrow for transforming values and the OFun arrow for transforming outputs. data TvFun a b = TvFun (a \n. b)(OFun a b) The instance de.nition then operates onvalues and their visual\u00adizers in tandem. instance \nArrow TvFun where .rst (TvFun f ox)= TvFun (.rst f )(.rst ox) second (TvFun f ox)= TvFun (second f )(second \nox) TvFun f ox > TvFun f ' ox ' = TvFun (f > f ' )(ox > ox ' ) arr f = TvFun (arr f )(arr f )  5.3 \nDeep Arrows Section 4 introduced additional combinators besides .rst and second. To generalize these \ncombinators beyond values, we de\u00ad.ne a new type class DeepArrow, as shown in Figure 19. Besides the methods \nintroduced in Section 4, the DeepArrow class contains several more that are useful for manipulating outputs \nand TVs. Most of the DeepArrow methods are generalizations of familiar functions. As shown in Figure \n20, the function instance of DeepArrow de.nes result as function composition (as in Section 4.1) and \notherwise uses arr togivevery simple de.nitions.Anyarrow with a useful arr can use these same arr-based \nde.nitions. The OFun instance of DeepArrow is de.nedbymimicking the function instance. instance DeepArrow \nOFun where result (OFun ox) = OFun ( . (OLambda a b) . (OLambda a (ox b))) funF = OFun ( . (OPair (OLambda \nc a) b) . (OLambda c (OPair a b))) lAssocA = OFun ( . (OPair a (OPair b c))  . (OPair (OPair a b) c)) \n... 6Note that the functions in the right-hand sides of the de.nitions may fail, because pair-valued \noutputs may be constructed byOPut rather than OPair. Our gestural setting, however, ensures that .rst \nand second get appliedonlyto outputs constructedbyOPair.Ina less constrained setting, a simple alternative \nto partiality of .rst and second would be mapping a non-OPair to an OPut-based output that displaysawarning \nmessageina GUI component. class Arrow (r) . DeepArrow (r) where result :: (b r b ' ) . ((a . b) r (a \n. b ' )) funF :: (c . a , b) r (c . (a , b)) funS :: (a , c . b) r (c . (a , b)) funR :: (a . c . b) \nr (c . a . b ) curryA :: ((a , b) . c ) r ( a . b . c ) uncurryA :: ( a . b . c ) r ((a , b) . c ) lAssocA \n:: ( a , ( b , c)) r ((a , b) , c ) rAssocA :: ((a , b) , c ) r ( a , (b , c)) idA :: a r a dupA :: \na r (a, a) fstA :: (a , b) r a sndA :: (a , b) r b swapA :: (a , b) r (b , a) .ipA :: DeepArrow (r) \n. (a . c . b) r (c . a . b) .ipA = funR inpF :: DeepArrow (r) . ((a, b) . c) r (a . (b . c)) inpF = curryA \ninpS :: DeepArrow (r) . ((a, b) . c) r (b . (a . c)) inpS = curryA > .ipA Figure 19. DeepArrow class \n Given the function and OFun instance of DeepArrow, the TvFun instance (for transforming TVs) is de.ned \nto work on values and their visualizers in tandem (as with the Arrow instance de.ned in Section 5.2). \ninstance DeepArrow TvFun where result (TvFun f ox)= TvFun (result f )(result ox) idA = TvFun idA idA \ndupA = TvFun dupA dupA fstA = TvFun fstA fstA ... rAssocA = TvFun rAssocA rAssocA De.ning generalized \nversions of the input extractors inpFirst and inpSecond is considerably trickier. The function-based \nde.ni\u00adtions from Section 4.3 use . abstraction and hence do not translate directly to an arrow setting.We \nuse an indirect approach. First re\u00adexpress the .-basedversionsin combinator(.-free) form, and then replace \nthe combinators with generalized versions. The combina\u00adtor versions are as follows, with a breakdown \nof these de.nitions given Figure21. These de.nitions use lexically scoped typevari\u00adables (Peyton Jones \nand Shields 2002), to relate the types of the locally de.ned qi to the type of the top-level de.nitions. \ninpFirst h = result uncurry . result .ip . .ip . result h . .ip . curry inpSecond h = result uncurry \n. .ip . result h . curry The generalized de.nitions then follow simply by replacing each function-based \ncombinator with its generalized version from Arrow or DeepArrow (replacing g .f with f > g ). Figure \n22 instance DeepArrow (.) where result =(.) funF = arr (.(f , b) . .c . (fc, b)) funS = arr (.(a, f ) \n. .c . (a, fc)) funR = arr .ip curryA = arr curry uncurryA = arr uncurry lAssocA = arr (.(a, (b, c)) \n. ((a, b), c)) rAssocA = arr (.((a, b), c) . (a, (b, c))) idA = arr id dupA = arr (.x . (x, x)) fstA \n= arr fst sndA = arr snd swapA = arr (.(a, b) . (b, a)) Figure 20. DeepArrow instance for functions inpFirst \n:: .aa ' bcd. (( a . c) . (d . ( a ' . c))) . (((a, b) . c) . (d . ((a ' , b) . c))) inpFirst h f = q6 \nwhere q1 = curry f :: a . (b . c) q2 = .ip q1 :: b . (a . c) q3 = result h q2 :: b . (d . (a ' . c)) \nq4 = .ip q3 :: d . (b . (a ' . c)) q5 = result .ip q4 :: d . (a ' . b . c) q6 = result uncurry q5 :: \nd . ((a ' , b) . c) inpSecond :: .abb ' cd. (( b . c) . (d . ( b ' . c))) . (((a, b) . c) . (d . ((a, \nb ' ) . c))) inpSecond h f = q4 where q1 = curry f :: a . (b . c) q2 = result h q1 :: a . (d . (b ' . \nc)) q3 = .ip q2 :: d . (a . (b ' . c)) q4 = result uncurry q3 :: d . ((a, b ' ) . c) Figure 21. Derivations \nof inpFirst and inpSecond shows the generalized types and de.nitions of the function and input extractors \nof Section 4. 5.4 TransformingValues In order to use our DeepArrow values to transform other values, \nwe introduce a class that relates an arrow (e.g., . , OFun, or TvFun)with a wrapper type (e.g.,Id, Output, \nor TV ). The class method toArr turns wrapped functions into arrow values, while $$ turns arrow values \ninto functions on wrapped values.7 7This (multi-parameter) class de.nition uses functional dependen\u00adcies \n(Jones 2000), expressing that each of the type parameters uniquely determines the other. This detail \nhelps the compiler resolve some ambigui\u00adties in type inference and is otherwise unimportant. funFirst \n:: DeepArrow (r) . (d r (c . a)) . ((d , b) r (c . (a , b))) funSecond :: DeepArrow (r) . (d r (c . b)) \n. ((a , d) r (c . (a , b))) funResult :: DeepArrow (r) . (d r (c . b)) . ((a . d) r (c . (a . b))) funFirst \nh = .rst h > funF funSecond h = second h > funS funResult h = result h > funR inpFirst :: DeepArrow (r) \n. (( a . c) r (d . ( a ' . c))) . (((a, b) . c) r (d . ((a ' , b) . c))) inpSecond :: DeepArrow (r) . \n(( b . c) r (d . ( . c))) b ' . (((a, b) . c) r (d . ((a, b ' ) . c))) inpFirst h = curryA > .ipA > result \nh > .ipA > result .ipA > result uncurryA inpSecond h = curryA > result h > .ipA > result uncurryA Figure \n22. Generalized function and input extractors class FunArr (r) w | (r) . w, w . (r) where toArr :: w \n(a . b) . (a r b) ($$) :: (a r b) . wa . wb  The simplest FunArr instance relates . and the identity \nwrapper: instance FunArr (.) Id where toArr (Id f )= f f $$ Id a = Id (fa)  An OFun can transform an \nOutput, with toArr discarding the Input, and $$ applying the output function. instance FunArr OFun Output \nwhere toArr (OLambda res)= OFun (const res) OFun ox $$ oa = ox oa  Finally, a TvFun can transform a \nTV , working in tandem (as usual) on values and visualizers: instance FunArr TvFun TV where toArr (TVf \nfo)= TvFun (toArr f )(toArr fo) TvFun f ox $$ TV idao = TV (f $$ ida)(ox $$ o)  5.5 DeepApplication \nThe deep application higher-order function, deep from Sec\u00adtion 4.4, generalizes simply: deep :: FunArr \n(r) w . (d r (a . b)) --function extractor . wd --function container . ((a r b) . (a ' r b ' )) --transformation \nembedder . wa ' --argument container  . wb ' --overall result deep xtr fc emb ac = emb (toArr (xtr \n$$ fc)) $$ ac  With this new de.nition, the examples in Figure 18 all work for tangible values, exactly \nas written (assuming TV versions of the pre-de.ned udisk, checker etc from Figure 9). That is, the de.nition \nsimultaneously constructvalues and visualizers for those values.Onlythe de.nitiontypesdiffer.Forinstance(cf.Figure9), \nscaleDisk :: TV (R . Region) diskChecker :: TV (R . R . R . Region) 6. Translating Gestures to DeepApplication \nWhere are we now? Recall that our goal is to enable an end-user to construct pure values including higher-order \nvalues with a concrete presenta\u00adtion in the form ofGUIs. This combination, which we call tangi\u00adble values \n(TVs), allows interactive inspection, as shown in Sec\u00adtion2. Section3illustrated gestural composition \n,in whicha user matchesup compatibly-typed inputsand outputsofexistingTVsto create new TVs. The newly \ncreated TV is a fusion of the two TVs, with the connected input and outputremoved. Sections4and5pro\u00advided \nthe all of the tools (combinators) we need, andin a general enough setting, to support gestural composition. \nTo put all of these pieces together, Eros uses the GUI structure and user gestures to synthesize combinator \nchains, which are then usedto createnewTVs.EachGUIisatreeofinputandoutputsub-GUIs (individual widgets \nand composites). Every input node has an associated a function extractor (Sections 4.2 and 4.3) that \ncan ex\u00adtractthatinputallthewaytotheroot, resultingina functionwhose domain is the type of the extracted \ninput. Similarly, every output node has an associated transformation embedder (Section 4.1)that can deeply \napplya user-chosenTV transformation(TvFun from Section 5.2) at the given output node. 7. Persistence \nand Compilation While the .rst de.nition of TV (Section 2.3) suf.ces for interac\u00adtion and composition, \nit does not support persistence or compila\u00adtion. These latter goals can both be achieved by introducing \na term representation to be used in place of the Id constructor in the def\u00adinition of TV , and a corresponding \nDeepArrow instance in place of . in the de.nition of TvFun. data TV a = TV (Term a)(Output a) data TvFun \na b = TvFun (TFun a b)(OFun a b) For simplicity,we use higher-order abstract syntax (as apparent in \nthe Lam constructor below), which frees us from dealing with variable capture and a-conversion (Pfenning \nand Elliott 1988). Be\u00adcause wewanted static typing wherever possible, the term represen\u00adtation is a generalized \nalgebraic data type (GADT) (Peyton Jones et al. 2006).8 type TX ab = Term a . Term b data Term :: *.* \nwhere Lit :: String . a . Term a App :: Term (a . b) . Term a . Term b Lam :: PatShape a . TX ab . Term \n(a . b) Fst :: Term ((a, b) . a) Snd :: Term ((a, b) . b) Pair :: Term (a . b . (a, b)) newtype TFun \na b = TFun (TX ab) 8In the GADT de.nition for Term, the .rst line says that Term maps types to types. \nThe indented lines that follow list the Term constructors and their types. instance Arrow TFun where \nTFun f > TFun g = TFun (f > g) .rst (TFun g)= toArr (Lam (SPair SVar SVar)(.ab . Pair @ f (Fst @ ab) \n@ Snd @ ab)) ... instance DeepArrow TFun where result (TFun tx)= TFun ( inLets (.ab@(Lam sa ) . Lam sa \n(tx . (ab@ )))) idA = TFun id ... instance FunArr TFun Term where toArr tf = TFun (toArrT tf ) TFun tx \n$$ ta = inLets tx ta toArrT :: Term (a . b) . TX ab toArrT f = inLets (f @ ) --Apply under \u00df-redices \ninLets :: TX ab . TX ab inLets tx (App (Lam s f ) t)= Lam s (inLets tx . f ) @ t inLets tx term = tx \nterm Figure 23. Term transformation instances The last three Term constructors are necessary only for \nsimpli\u00ad.cations made during term construction, together with limitations in type checking for GADTs. \nOngoing improvements to GADT type checking may address this issue, allowing us to simplify the term representation \nand improve simpli.cation. For pretty-printing, lambda terms have pattern shapes : data PatShape :: *.* \nwhere SVar :: PatShape a SPair :: PatShape a . PatShape b . PatShape (a, b) 7.1 Evaluation and Compilation \nEvaluation is very simple. The only novel case is Lam. The trick there is to apply the contained function \nto a new literal. eval :: Term a . a eval (Lit a)= a eval (App fun arg)=(eval fun)(eval arg) eval (Lam \ntfun)= .x . eval (tfun (Lit \"_\" x)) eval Fst = fst eval Snd = snd eval Pair =(, ) Termevaluationis simplebutinvolves \nrepeated interpretation. Forfasterexecution, Eros transforms terms into stringsof Haskell code and invokes \nGHC, by means of hs-plugins (Pang et al. 2004). Thereisa noticeablebut quite tolerable pauseduring compilation \n(typically well under a second, after GHC is .rst loaded). Haskell code generation is also used to generate \nthe syntactic descriptions seen near the top of TVs in the .gures throughout this paper. 7.2 TermTransformation \nTerms are transformed viaTFun, de.ned above. Figure 23 shows how TFun serves as a deep arrow and how \nit is used to transform terms. The function inLets isveryhandyfor term simpli.cation.It applies applies \na term transformation under a sequence of outer let -bindings (represented as \u00df-redices). The in.x @ \noperator is a simplifying smart constructor for function application. The toArr method (turning a function-valued \nterm into a TFun)just makes a (smart) application inside of outer lets. 8. RelatedWork 8.1 Visual Programming \nLanguages Eros has similar goals to those of visual (or graphical ) pro\u00adgramming languages (VPLs), namely \nmaking programming more accessible through a concrete and visual style of construction. The user experience \nof Eros, however, is meant to be profoundly more direct that of VPLs. Eros users construct and interact \ndirectly with values (semantics) rather than indirectly through code (syntax). (Our use of a term representation \nis not essential and is intended to be hidden from the user.) In addition to the philosophical and psychological \nshift, work\u00ading with values rather than code has a signi.cant effect on scala\u00adbility. The size and complexity \nof a TV depends only on its type, not its construction.For this reason, users can construct TVs with \nconsiderable internal complexity while maintaining visual simplic\u00adity. The key to retaining simplicity \nis that each deep application step eliminates the connected input and output. The newly created TV is \nthus strictly less complex than the combined complexity of the two source TVs. In contrast, the composition \nstep in VPLs (as also with textual languages) creates a visual representation that is strictly larger \nthan the combined sizes of the source components, so VPLs quickly clutter visual space. On the other \nhand, by preserv\u00ading and displaying syntactic structure, VPLs allow editing of that structure, unlike \nEros. (An easy partial solution for Eros would be togive eachTVabutton that regenerates its source TVs.) \nMost VPLs make a strict stylistic separation between func\u00adtions and values (typically rendered as boxes \nand arrows). VPLs thus tend not to support higher-order programming, though there areexceptions (Poswigetal. \n1994;Kelso 1994; Najorkand Golin 1990). Eros allows functions to be visualized differently, and yet is \nfully higher-order. Not only are a function s inputs and outputs accessible and connectable,but sois \nthe function itself. 8.2 Spreadsheets The most popular end-user programmingenvironmentisthe spread\u00adsheet, \nwhich has an execution model much like Eros s. Once rela\u00adtionships are established, input cells canbe \nalteredby the user, and related output cells update automatically. Moreover, the relation\u00adships are often \nestablished gesturally, using a mouse to select input cells and operation.Wakeling (2007) demonstrated \nuse of (purely syntactic) functional code in the cells of a standardspreadsheet. On the other hand, Eros \nremedies some of the signi.cant limi\u00adtations of spreadsheets. Eros supports a rich, static type system. \nIn particular, it fully supports higher-order functional programming. Spreadsheets typically do not even \nsupport de.nability of func\u00adtions, though see Peyton Jones et al. (2003). The Forms/3 sys\u00adtem (Burnett \net al. 2001), while still .rst order, relaxes the usual spreadsheet style with free-form layout and graphical \ntypes. Another spreadsheet system that explores graphical types is Spreadsheets for Images (SI) (Levoy1994). \nThe author remarks that SI is more scalable because it spends its screen space on operands rather than \noperators, which are usually more interesting to the user . On the other hand, SI shows all intermediate \nvalues as with spreadsheets in general and unlike Eros. SI has a mixed functional/imperative style, exposing \nregisters and commands that explicitly write into registers. It also lacks the early feedback made possible \nby static typing. 8.3 Vital Vital (Hanna 2002) is a document-oriented system that presents both (syntactic) \nsource code and the results of evaluating the code, with richfacilities forvalue visualization. Syntactic \nediting results in automatic value update, and direct-manipulation editing of val\u00adues results in update \nof corresponding expressions. In contrast to Eros,Vital s direct manipulationis usedto edit .rst-order \nvalues, rather than to explore (possibly higher-order) values, and functions are created syntactically. \n9. Limitations and FutureWork Eros could be improved in a number ofsigni.cant ways. Polymorphism.How \ncan one concretely visualize polymorphic values? The very tangibility of our enterprise would seem to \npreclude parametric polymorphism, at a considerable loss of expressiveness. A possible solution is inspired \nby the idea of type abstraction in explicitly polymorphic .-calculi (Reynolds 1974). In place of a type \nabstraction, a polymorphic TV could havea sortof viz-abstraction ,adifferentkindofinput(e.g.,a menu) \nwith which a user can choose a visualizer and, in doing so, a type. Initially, these special inputs would \nhave default values (as regular inputs do). When the user selects a different visualizer, uses of the \npreviously chosen visualizer would get dynamically replaced.  Naturalness. Gestural composition could \nbe made much more natural and intuitive. For instance, to .ip the arguments of a function, the user must \nselect .ip from the Tweak menu. At the very least, a visual representation of .ip would be friendlier. \nBetter yet would be for the user to grab and move the inputs directly. Similarly for duplication, currying,pair \nreassociation and the other methods of the DeepArrow class (Figure 19).  Fluidity and optimization. \nEspecially with improvements to gestural composition, the user experience would be enhanced byevenfaster \ngenerationofnew TVs.For instance, one could imagine dragging an output over various inputs and having \nthe tentative composition results shown immediately. If the user moves on without completing the connection \n(the drop of drag&#38;drop), the compositionvanishes. The main obstacle to thislevelof .uidityis the \ntime takenbydynamic compilation.  Haskell integration.It isfairly easy to import de.nitions from Haskell \nlibraries and make them available in Eros. However, it couldbe more convenient still.For instance, there \ncouldbea pre-processor that reads Haskell source .les, interpreting cer\u00adtain comments as declaring what \nvisualizers to use (including lower and upper bounds for slider inputs).A form of integra\u00adtion that is \ncompletely lacking now is the ability to save TVs toaHaskell module.Given the persistent representation \nfrom Section 7, we know of no obstacle to doing so.  10. Acknowledgments The inspiration for Eros came \nout of conversations with Holly Croydon. Sean Seefried and Simon Peyton Jones made several helpful suggestions \non improving presentation. Sean suggested the name tangible values . References Artem Alimarine, Sjaak \nSmetsers, ArjenvanWeelden, Markovan Eekelen, and Rinus Plasmeijer. There and back again: arrows for invertible \nprogramming. In Haskell 05: Proceedings of the 2005 ACM SIGPLAN workshop on Haskell, pages 86 97, New \nYork,NY, USA, 2005.ACM Press. Margaret Burnett, John Atwood, Rebecca Walpole Djang, James Reichwein, \nHerkimer Gottfried, and Sherry Yang. Forms/3: A .rst-order visual language to explore the boundaries \nof the spreadsheet paradigm. Journal of Functional Programming, 11 (2):155 206, 2001. Conal Elliott. \nFunctional Images. In The Fun of Programming, Cornerstonesof Computing series.Palgrave, March 2003. Keith \nHanna. Interactive visual functional programming.InSPey\u00adton Jones, editor, ICFP 02: Proceedings of the \nSeventh ACM SIGPLAN International Conference on Functional Program\u00adming, pages 100 112.ACM, October 2002. \nPaul Hudak and Mark P. Jones. Haskell vs. Ada vs. C++ vs Awkvs...anexperimentin softwareprototypingproductivity. \nTechnical report,Yale, 1994. John Hughes. Generalising monads to arrows. Science of Computer Programming, \n37:67 111, May 2000. Mark P. Jones. Type classes with functional dependencies. In ESOP 00: Proceedings \nof the 9th European Symposium on Programming Languages and Systems,pages 230 244,London, UK, 2000. Springer-Verlag. \nJoelKelso.Avisual representation for functional programs.Tech\u00adnical Report CS/95/01,Western Australia, \nAustralia, 1994. Marc Levoy. Spreadsheets for images. In SIGGRAPH 94: Pro\u00adceedings of the 21st Annual \nConference on Computer Graph\u00adics and Interactive Techniques, pages 139 146, NewYork, NY, USA, 1994.ACM \nPress. M.A. Najork andE.Golin. Enhancing show-and-tell witha poly\u00admorphic type system and higher-order \nfunctions. In Proceed\u00adings of the IEEE Workshop 1990 on Visual Languages, pages 215 220, Skokie, IL, \n1990. Andr\u00b4e Pang, Don Stewart, Sean Seefried, and Manuel M. T. Chakravarty. Plugging Haskell in. In \nProceedings of the ACM SIGPLAN Workshop on Haskell,pages 10 21.ACM Press, 2004. Simon Peyton Jones and \nMark Shields. Lexically scoped type variables. March 2002. Simon Peyton Jones, Alan Blackwell, and Margaret \nBurnett. A user-centred approach to functions in Excel. In ICFP 03: Pro\u00adceedings of the eighth ACM SIGPLAN \ninternational conference on Functional programming, pages 165 176, New York, NY, USA, 2003.ACM Press. \nSimon Peyton Jones, Dimitrios Vytiniotis, StephanieWeirich, and GeoffreyWashburn. Simple uni.cation-based \ntype inference for GADTs. In Proceedings of the Eleventh ACM SIGPLAN In\u00adternational Conference on Functional \nProgramming, Portland, Oregon, September 2006.ACMSIGPLAN. Frank Pfenning and Conal Elliott. Higher-Order \nAbstract Syntax. In Programming Language Design and Implementation, 1988. J\u00a8org Poswig, Guido Vrankar, \nand Claudio Moraga. VisaVis: a higher-order functional visual programming language. Journal of Visual \nLanguages and Computing, 5(1):83 111, 1994. JohnC.Reynolds.Towardsatheoryoftype structure.In Program\u00adming \nSymposium, Proceedings Colloque sur la Programmation, pages 408 423, London, UK,1974. Springer-Verlag. \nDavidWakeling. Spreadsheet functional programming. Journal of Functional Programming, 17(1):131 143, \n2007.   \n\t\t\t", "proc_id": "1291151", "abstract": "<p>We present a user-friendly approach to unifying program creation and execution, based on a notion of \"tangible values\" (<i>TVs</i>), which are visual and interactive manifestations of pure values, including functions. Programming happens by gestural composition of TVs. Our goal is to give end-users the ability to create parameterized, composable content without imposing the usual abstract and linguistic working style of programmers. We hope that such a system will put the essence of programming into the hands of many more people, and in particular people with artistic/visual creative style.</p> <p>In realizing this vision, we develop algebras for visual presentation and for \"deep\" function application, where function and argument may both be nested within a structure of tuples, functions, etc. Composition gestures are translated into chains of combinators that act simultaneously on statically typed values and their visualizations.</p>", "authors": [{"name": "Conal M. Elliott", "author_profile_id": "81339498305", "affiliation": "LambdaPix, San Andreas, CA", "person_id": "P900674", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291163", "year": "2007", "article_id": "1291163", "conference": "ICFP", "title": "Tangible functional programming", "url": "http://dl.acm.org/citation.cfm?id=1291163"}