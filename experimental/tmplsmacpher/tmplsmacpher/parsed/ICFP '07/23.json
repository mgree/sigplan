{"article_publication_date": "10-01-2007", "fulltext": "\n AGeneric Usage Analysis with Subeffect Quali.ers Jurriaan Hage Stefan Holdermans Arie Middelkoop Department \nof Information and Computing Sciences, Utrecht University P.O. Box 80.089, 3508 TB Utrecht, The Netherlands \n{jur,stefan,ariem}@cs.uu.nl Abstract Sharing analysis and uniqueness typing are static analyses that \naim at determining which of a program s objects are to be used at most once. There are manycommonalities \nbetween these two forms of usage analysis.Wemake their connection precisebydevelopingan expressive generic \nanalysis that can be instantiated to both sharing analysis and uniqueness typing. The resulting system, \nwhich com\u00adbines parametric polymorphism with effect subsumption, is speci\u00ad.ed within the general framework \nof quali.ed types, so that readily available tools and techniques can be used for the development of \nimplementations and metatheory. Categories and Subject Descriptors D.3.3[Programming Lan\u00adguages]: Language \nConstructs and Features Polymorphism; F.3.2[Logics and Meanings of Programs]: Semantics of Program\u00adming \nLanguages Program analysis General Terms Languages, Theory Keywords sharing analysis, uniqueness typing, \ntype and effect systems, quali.ed types 1. Introduction Sharing analysis and uniqueness typing are static \nanalyses that both aim at determining which objects in a functional program are guaranteed to be used \nat most once and, dually, which objects may be used more than once. It has been recognized that there \nare manyoverlaps between the techniques used in the speci.cation of type-based sharing analyses and the \nde.nition of calculi with uniqueness typing (Wansbrough and Peyton Jones 1999). In this paper we make \nthe connection between these analyses precise by presenting a single, generic type and effect system \nthat may be instantiated to both sharing analysis and uniqueness typing. Our speci.c contributions are \nthe following: We show how the differences between sharing analysis and uniqueness typing amount to inversion \nof a subsumption re\u00adlation between usage properties. In our approach, the speci.c direction of this relation \nis the sole parameter of a generic sys\u00adtem that captures the commonalities between the two analyses (Section \n3.1). Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page.To copyotherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. ICFP \n07, October 1 3, 2007, Freiburg, Germany. Copyright c &#38;#169; 2007ACM 1-59593-815-2/07/0010... $5.00 \n We present an explicitly typed calculus that serves as a target for both sharing analysis and uniqueness \ntyping, and equip it with a type and effect system that features type polymorphism as well as effect \npolymorphism (Section4).Ageneric analysis is then developed by conservatively extending the well-known \nHindley-Milner typing discipline (Milner 1978) and de.ning a type-preserving translationfrom implicitly \ntyped source terms into explicitly typed target terms (Section 5). Our analysis comes with a correctness \nresult (Section 4.4) and a principal\u00adtype property that facilitates the derivation of an incremental \ninference algorithm (Section 5.3).  A notable characteristic of our type and effect system is that it \nprovides parametric polymorphism and subeffecting as its only means of subsumption. In particular, we \ndo not extend the subsumption relation between usage properties to a sub\u00adsumption relation between types, \nas is often done in related systems (Barendsen andSmetsers 1993;Wansbrough andPey\u00adton Jones 1999; Gustavsson \n1999).We argue that this speci.c design choice has at most a modest impact on the expressive\u00adness of \nour analyses, while it allows for an implementation that is considerably less complicated than it would \nhave been in the presenceofa full subtype relation (Section3.5).  Subeffecting is incorporated into \nour system as a form of ad\u00adhoc polymorphism. This enables us to model all use of sub\u00adsumption within \nthe framework of quali.ed types (Jones 1994), so that implementations and metatheory can, to a large \nextent, be developed by reusing tools and techniques that are readily available for this framework (Section \n3.3).  At this point, our use of terminology deserves some clari.ca\u00adtion. Some authors (see Section6fora \ndiscussionof relatedwork) use the term usage analysis for what we call sharing analysis . We, in turn, \nreserve the name usage analysis for a general cate\u00adgoryofanalysesthat containsboth sharing analysisand \nuniqueness typing. Our choice for the term sharing analysis is motivated by our inclination to stress \nthe complementary nature of sharing and uniqueness. This complementariness is elaborated upon in the \nfol\u00adlowing section. 2. Two Notions of Usage In this section, we brie.y introduce sharing analysis (Section \n2.1) and uniqueness typing (Section 2.2), and highlight the differences between these two analyses (Section \n2.3). For a more thorough introduction to type-based sharing analysis, the reader is referred to Turner \net al. (1995). An introduction to uniqueness typing is given by Barendsen and Smetsers (1993). For further \nreferences, see Section 6. Both sharing analysis and uniqueness typing are primarily tar\u00adgeted at languages \nwith lazy, i.e., call-by-need, evaluation strate\u00adgies, such as Haskell (Peyton Jones 2003) and Clean \n(Plasmeijer andVan Eekelen 1998).Variations,however, may alsobeof usein other contexts(e.g.,Turneretal.1995; \nMogensen1998;Kobayashi 1999). In this paper, though, we limit ourselves to call-by-need lan\u00adguages. 2.1 \nSharing Analysis Call-by-need evaluation is usually implemented by means of up\u00addatable closures.For instance,in \nthe program let x = 2+ 3in x + x, thevariable xrepresentsaclosure that initially contains the subterm \n2+ 3. After the .rst demand for x, this closure is updated with the value 5. The second demand for x \nnow immediately retrieves the computedvalue and so theevaluationof2 + 3is effectively shared between \nthe occurences of x in the body of the local de.nition. However, in the following program, let y= 2+ \n3in 2* y, the value of the variable yis demanded only once and, hence, its evaluation will notbe shared. \nTherefore, updating the closure for y makes little sense. In general, it is unnecessary to update a closure \nif its value is demanded no more than once. Instead, after it has produced its value, such a closure \ncan be removed from memory altogether. Now, the goal of a sharing analysis is to determine for each of \na program s subterms, whether or not its evalua\u00ad tion may be shared. The information obtained from sharing \nanalysis can, other than for avoiding unnecessary updates, also be used to faciliate a series of program \ntransformations(Turner et al. 1995;Wansbrough and Peyton Jones 1999; Gustavsson and Sands 1999). A sharing \nanalysis typically classi.es terms into two groups: those that are guaranteed to be used at most once \nand those that may be used more than once.Type-based sharing analyses record these classi.cationsintypederivations.Forthe \n.rstexampleabove, for instance, such an analysis produces the typing x :. Int. Here, . indicates that \nthe evaluation of x may be shared.For the second example we have y:1 Int, indicating that y is used at \nmost once. In type-based program analysis, annotations such as1and . are often referred to as effects \n(Gifford 1986; Talpin and Jouvelot 1994; Nielson and Nielson 1999). In the speci.c context of usage analysis, \nwe call them usage effects or usage annotations. Usage effects also appear within function types. Consider, \nfor instance, the function double x = 2* x and its typing double :. Int1 . Int. . The domain and codomain \nof the function type are annotated with usageeffects.Theeffect1onthe domain indicatesthat double uses \nits argument at most once; the effect . on the codomain indicates that results produced by double may \nbe used more than once. The remaining . ranges over the whole typing and expresses that the function \nitself may be shared. 2.2 UniquenessTyping Uniqueness typing is concerned with maintaining referential \ntrans\u00adparency in the presence of destructive updates or, more general, side-effecting computations.Its \npurposeistodetermine foreachofa program s subterms, whetherornotitsvalueis required to be unique. Here, \nuniqueness means that a value is used at most once. As an example, consider a function fPutChar that \nappends a character to a .le and returns the updated .le: fPutChar : Char . File . File. Such a function \ndoes not violate referential transparency if it is granted private access to its second argument. Systems \nwith unique\u00adness typing allow for this demand to be expressed in the type of fPutChar: fPutChar :. Char. \n. (File1 . File1). . The 1-annotations in this typing indicate that fPutChar needs to be passed a unique, \ni.e., nonshared, .le argument and that the .le it produces is then also unique. The .-annotations indicate \nthat uniqueness of the character argument is not required, and that the function itself and its partial \napplications may be used more than once. Often, uniqueness typing enforces objects that are subjected \nto side-effecting, such as .les, to be passed around single-threadedly. For instance, the following program \nis ill-typed, let f = readFile \"DATA\" in (fPutChar O f, fPutChar K f), because the .le f is used twice \nin the body of the local de.nition. In contrast, the program let f = readFile \"DATA\" in fPutChar K (fPutChar \nO f) is type-correct: the .le f is used only once.  2.3 Divergence Before we look into the differences \nbetween sharing analysis and uniqueness typing, we point out that there is a great deal of com\u00admonality \nbetween the two: both analyseskeep track of how many times values are used, and both do so by classifying \nterms into unique (single-use) terms and shared (multi-use) terms. Further\u00admore, both analyses may record \nusage properties in the types of terms. To see where divergence arises, consider again the function double, \nits sharing analysis double :. Int1 . Int. , and its use in the program let x = 2+ 3in (double x) * x. \nHere, x is used twice in the body of the local de.nition and, hence, itsevaluationis shared. Still,asfaras \nsharing analysisis concerned, it is all right to pass x to double, even though the parameter type of \nthe latter is annotated with 1. Indeed, if we pass double an updatable closure,nothingbad happens.Duringtheevaluationof \ndouble x the closure of x is updated with the result of the addition (after all, we passed in an updatable \nclosure) and when the closure is entered for the second time (i.e., when the right operand ofthe multiplication \nis demanded), it immediately delivers 5. In summary: in sharing analysis, a function with a unique parameter \ntype may just as well be passed a shared closure as argument. However,passingauniqueargumenttoa functionwithashared \nparameter type is not allowed. To see why, imagine what would happen if we pass a nonupdatable closure \nto a function that uses its argument more than once. The .rst useofthe argument then leaves the closure \nunupdated and, as a result, consecutive accesses have to re-evaluate the contained term.Worse, an optimising \ncompiler may well emit code that, after what is assumed to be its only use, reclaims the memory occupied \nby the closure and so introduce unexpected run-time errors. In uniqueness typing, things are just the \nother way around. In a function s uniqueness type, a 1-annotation in parameter position speci.es that \nthe function requires private access to its argument; passing in a shared value may then compromise referential \ntrans\u00adparency.On the other hand, passinga uniquevalue toa function withashared parametertypeis .ne:an \n.-parameter does not mean thata function deniesprivate access,it rather indicates that unique\u00adness is \nnot required. To recapitulate: in sharing analysis, a shared parameter type expresses a demand (i.e., \nto pass in an updatable closure) on the caller of a function, while a unique parameter type expresses \nthe absence of such a demand; in uniqueness typing, a demand (i.e., to pass in a unique argument value) \nis expressed by a unique parameter type and absence of this demand is expressed by a shared parameter \ntype. In the next section, we demonstrate how this distinction between sharing analysis and uniqueness \ntyping is addressedby our generic usage analysis. 3. AGenericApproach In this section, we highlight the \nmost distinguishing features of our generic type and effect system: its use of subeffecting (Sec\u00adtion \n3.1) and polyvariance (Section 3.2), its use of quali.ed types (Sections 3.3 and 3.4), and the absence \nof a subtype relation (Sec\u00adtion 3.5). 3.1 Subeffecting In Section 2.3 we sawthat, in sharing analysis, \nshared closures may be passed safely to functions that use their argument at most once as well as to \nfunctions that may use their arguments more than once. In our system, this is expressed in terms of a \nsubeffect relation.To enable subeffecting, we impose an ordering oneffects:1 c .. Forsharing analysis,subeffectingnowexpressesthatitissafeto \nreplace the effect component of an analysis by a smaller (or equal) effect value: .' f t :t f . . .' \n(T-SUBDOWN) . t f t : This subeffecting rule is used to prepare the effects of function arguments.For \ninstance,ifwehave establishedthatthevalue asso\u00adciated with an integer variable x may be used more than \nonce, x :. Int, and x is passed to a function that uses its argument at most once, say double, double \n:. Int1 . Int. , then T-SUBDOWN may be used to make the effect of x compatible with the parameter effect \nof double: x :1 Int. Of course,rule T-SUBDOWN isnotsafefor uniquenesstyping.In uniquenesstyping, sharedvalues \ncannotbepassedto functionsthat expect unique arguments,but, in contrast, it is no problem to pass unique \nvalues to functions with .-parameters. So, for uniqueness typing, we need a subeffecting rule that allows \neffect components to be enlarged: .' f t :t f . ; .' . (T-SUBUP) f t :t Note how rules T-SUBDOWN and \nT-SUBUP differ in the direc\u00adtion of the effect inequality. Interestingly, in our formulation, this difference \nin the subeffecting rules is the only essential distinction between sharing analysis and uniqueness typing. \nIn our generic us\u00adage analysis, this distinction is made explicit in a single rule for subeffecting that \nis parameterized by the direction of the effect in\u00adequality, much like: .' f t :t f . 0 .' (T-SUBGEN) \n. t f t : Here, the symbol 0 denotes the parameter of a type and effect system that subsumes sharing \nanalysis (if 0 is instantiated with .) as well as uniqueness typing (if 0 is instantiated with ;).Moreover, \n0 is the only parameter of the generic analysis and the rule for subeffecting is the only rule in the \nsystem that explicitly invokes the parameter. It is important to realize that the difference between \nsharing analysis and uniqueness typing does not amount to a reversal of the ordering on effects: our \nsystem is parameterized by a speci.c use of the ordering relation in the rule for subeffecting, not by \nthe ordering itself.Weshowwhythisis importantbelowin Section3.4, when we discuss the containment restriction. \n 3.2 Polyvariance As shown in the previous subsection, subeffecting is used to adapt the effect of a \nfunction argument, so that it matches the parameter effect of the function it is passed to. Dually, our \ngeneric analysis also provides a means to adapt the type of a function to .t the argu\u00adment it is applied \nto, namely, effect polymorphism or polyvariance. For instance, thefact that,in sharing analysis,a function \nthat uses its argument at most once does not put any demand on the usage propertyof its argument, canbeexpressedby \nassigning such a function a type that is polymorphic in the effect of its parameter, e.g, double :. .p. \nIntp . Int. . Here, p is an effect variable thatmaybe instantiatedwithboth1and ., which is consistent \nwith our observation that a function with a single-use parameter, such as double, can be passed a single-use \nargument as well as a multi-use argument. Afunctioncanbepolyvariantnotonlyinits parameter,butalso in \nits result.Forexample, whether the resultof double is used at most once or more than once depends on \nthe context in which it is produced. Hence, we abstract over the result effect and yield double :. .pq. \nIntp . Intq. The type of double can now be instantiated to Int1 . Int1, Int1 . Int. , Int. . Int1, and \nInt. . Int., which are all indeed valid analysis results for double. 3.3 Subeffect Quali.cation Our \nuse of subeffecting and polyvariance allows our analyses to be, to a large extent, context sensitive: \ntheyallow for the type and effect of a term to be adapted to the context in which the term is used.To \nsee why it is bene.cial to include both subeffecting and polyvariance in a single system, let us look \ninto the analysis of higher-order functions. Asanexampleofa higher-order function, considerthe function \napply, applyf x = fx, that applies its .rst argument to its second. Let us assume for now that apply \nonly operates on shared integer functions. Now, how should we annotate the type of the second parameter \nx?Amoment s re.ection reveals that which effects are valid for x depends on the parameter effect of f. \nIn sharing analysis, if f has a 1-parameter, then both 1 and . are valid annotations for x; if f has \nan .\u00adparameter, then the type of x should actually be annotated with .. Similarly, in uniqueness typing, \nan .-annotation for the parameter of f means that x can be annotated with1 as well as ., while if f requires \na unique argument, then x shouldinfactbe unique. These observations are compactly capturedbya so-called \nquali.ed type: apply :. .p1 p2 qr. (p1 0 p2) . (Intp1 . Intq). . (Intp2 . Intq)r . In this type, the \npredicate p1 0 p2 denotes a subeffect quali.er;it expresses that the only valid simultaneous instantiations \nfor p1 and p2 are those that satisfy the inequality p1 0 p2. Quali.ed types (Jones 1994) are a general \nframework for com\u00adbining parametric and ad-hoc polymorphism in type systems. This framework is best known \nfor providing a theoretical foundation for Haskell s type classes (Kaes 1988;Wadler and Blott 1989). \nOther applications include subtyping, extensible records, and implicit pa\u00adrameter passing (Lewis et al. \n2000). Using quali.ed types in our analysis allows us to usefamiliar tools and techniques for the development \nof implementations and metatheories.Forexample,if weextend anexisting Haskell com\u00adpiler with an implementation \nof our usage analysis, we are able to reuse a great deal of infrastructure that is already present for \nthe support of type classes. Moreover, since the theory of quali.ed types is formulated independently \nfrom the exactform of the pred\u00adicates that make up the quali.er language, it is expected that our approach \ncan also be applied to other program analyses, such as binding-time analysis and strictness analysis. \n 3.4 Containment The typing of the function apply in the previous subsection demon\u00adstrates the use of \nsubeffect quali.ers in our system. However, the given analysis of apply is still rather imprecise,due \nto our assump\u00adtion that apply only operates on shared integer functions. Indeed, a higherdegreeof context \nsensitivity canbe achievedby abandoning this assumptionandabstractingoverthetypeandusagepropertyof the \nfunction argument. Abstracting over the type is straightforward and amounts to plain type polymorphism. \nAbstracting over the us\u00adage propertyis moreinvolvedhere,sincewehavetodealwiththe possibility that apply \nis partially applied. Tosee why,suppose thatapply is appliedtoafunctionargument f only: if such a partial \napplication applyf is used more than once, then so is the argument f. So, abstracting over the usage \nproperty of f, we have to be careful to maintain a relationship between the effect for f and the effect \nfor partial applications of apply.Wedo so by introducing an additional quali.er r1 ; r2 that speci.es \nthat the function argument is used as least as often as the associated partial application: apply :. \n.abp1 p2 qr1 r2. (p1 0 p2, r1 ; r2) . (ap1 . bq)r1 . (ap2 . bq)r2 . Whatweseehereisactuallyan instanceofamoregeneralscheme: \nif a value is contained within a structure, we must assume that it is used at least as often as the containing \nstructure. This phe\u00adnomenon is called the containment restriction; Barendsen and Smetsers (1993) call \nit uniqueness propagation. Note that the second quali.er in the type of apply isexpressed in terms of \nthe relation ;. In particular, it is not expressedin terms of the parameter 0. The containment restriction \napplies to both sharing analysis and uniqueness typing and in both cases it is expressed in terms of \nthe ordering1 c .. So, here it is crucial that our generic systemis not parameterizedby the ordering \noneffectsbut, instead, by the direction of the subeffect relation. Remark. A noteworthy subtlety arises, \nin uniqueness typing, from the interaction between subeffecting and the containment re\u00adstriction. Assume, \nfor instance, that containment forces the annota\u00adtionfora particularpartialapplicationtobe1.Then,itmaywellbe \nthat subeffecting later enables us to lift this annotation to ., effec\u00adtively bypassing the containment \nrestriction, which is, clearly, un\u00addesirable.To prevent this, Barendsen andSmetsers (1993)exclude functions \nfrom being subjected to subeffecting.For our purposes, however, this is too limiting, for it would unnecessarily \naffect shar\u00ading analysis as well. De Vries et al. (2007) take an interesting and more liberal approach \nby relaying enforcement of the containment restriction on functions to their application sites. We conjecture \nthat this technique .ts well into our system. In the remaining of thispaper,however,we shall ignorethe \nissuealtogetherand simply assume that subeffecting is never applied in a manner that con.icts with containment, \nleaving a more satisfying treatment as future work.  3.5 Subtyping A .nal distinguishing aspect of our \nsystem is that it does not in\u00adclude subtyping. Most related systems (most notably Barendsen and Smetsers \n1993;Wansbrough andPeyton Jones 1999; Gustavs\u00adson1999)extendthe orderingoneffectstoashape-conformantpar\u00adtial \nordering on types and then employthis partial ordering to derive acompliant subtype relation.However,incorporatingafull \nsubtype relation complicatesthedesignand implementationofausageanal\u00adysis considerably, since the analysis \nhas to deal not only with in\u00adequalities betweeneffects,but also with inequalities between types. Moreover, \nthe shapes of the types in.uence the inequalities that have to hold between effects and instantiations \nof type variables may therefore introduce additional effect inequalities. In contrast, in our approach, \ninequalities only arise between ef\u00adfects and instantiating type variables does not lead to new inequal\u00adities. \nThe resulting system, with subeffecting and polyvariance, .ts nicely into the theory of quali.ed types \nand is, in practice, about as expressive as a system with subtyping, even though the inferred types are \ndifferent. For example, consider the following function, two x = 2, that ignores its argument and produces \nthe constant 2.A sharing analysis based on subtyping typically assigns two its least restric\u00adtive type: \ntwo :. .a. a 1 . Int. . Let us now assume that two is applied to a shared integer value x in a context \nin which the function application needs to be stored ina nonupdatable closure.A subtyping analysis then \ninstantiates a to Int and invokes subtyping to coerce the type of two into Int. . Int1. Our analysis, \non the other hand, .rst assigns two its most polyvariant type, two :. .apq. ap . Intq , and then adapts \nthis type to the context ofthe call site by instanti\u00adating a with Int, p with ., and q with 1. 4. Target \nLanguage In this section, we present an explicitly and impredicatively typed language in the style of \nSystemF (Girard 1972; Reynolds 1974), that serves as a target language for the analysis we develop in \nSection 5. This target language, of which the syntax is presented in Section 4.1, can be used as a back \nend for both sharing analysis and uniqueness typing. Sharing analysis and uniqueness typing are motivatedbypartic\u00adularities \nin the operational behaviour of the programs theyoperate upon: respectively, the distinction between \nupdatable and nonup\u00addatable closures, and the presence of side-effecting computations. Identi.ers x . \nVar (term variables) a . TyVar (type variables) \u00df . EffVar (effect variables) d . EvVar (evidence variables) \nh. Loc (heap locations) Term language t. Tm := x | u u . PreTm := ..x. : t. t| tx | tu. | .a. t| t t \n| .\u00df. t| t . | .d : p. t| t . | let x. = t in t| . t w . Whnf := ..x. : t. t| .a. w | .\u00df. w | .d : p. \nw | . w . . Ev := d | i | . . . |.|T Type and effect language t . Ty := a | t . . t. |.a. t |.\u00df. t | \np . t . . Eff := \u00df | 1| . p . Pred := .. Typing contexts G . Ctx := \u00d8| G, x :. t | G,d : p Reduction \ncontexts H. Hp := \u00d8| H, h . (t; .). S. Stk := \u00d8| S, #h| S, @h| S, .a | S, @t | S, .\u00df | S, @. | S, .d \n: p | S, @. | S,.@ . . Env := \u00d8| ., x . h | ., a . t | ., \u00df . . | ., d . . Figure 1. Syntax of the target \nlanguage Proofs of correctness for these analyses need to take these particu\u00adlarities into account. So, \nto demonstrate the correctness of our shar\u00ading analysis, we equip our target language with an operational \nse\u00admantics for call-by-need evaluation that distinguishes between up\u00addatable and nonupdatable closures \n(Section 4.2).Correctness of the analysis then follows from the soundness properties of a typing re\u00adlation \nfor target terms (Section 4.3) with respect to this particular operational semantics (Section 4.4). A \ncorrectness result for uniqueness typing remains as future work. (Note that the way in which such a result \nis obtained de\u00adpends heavily on the way in which we address the issues thatarise from the interaction \nbetween subeffecting and the containment re\u00adstriction; see Section 3.4.) 4.1 Syntax Figure 1 shows the \nsyntax of our target calculus. In the term language we distinguish between variable terms and nonvariable \nterms. The latter are referred to as preterms and are ranged over by the metavariable u. As we will see \nin Section 4.2, the explicit distinction between variables and preterms merely facilitates the de.nition \nof an operational semantics. Preterms subsume function abstractions,twoformsoffunction application(onewithavariable \nin argument position, one with a preterm), abstractions and appli\u00adcations for types, effects, and evidence \n(see below), nonrecursive local de.nitions, and explicit subeffect coercions. Explicit effect annotations \nappear on function abstractions, function parameters, pretermarguments,and let-bindings.Thesetofvariablesthat \noccur free in a term tis written as fv(t). Quali.ersarebuiltfromeffectexpressionsandasingle inequal\u00adity \nsymbol . Predicates of the form .1 ; .2 are just syntactic sugar for .2 .1. Evidence expressions act \nas explicit proofs that predicates hold: the constructors i and . establish, respectively, the re.exivity \nand transitivity of the ordering on effects, while . and T denote that1and . are, respectively,the least \nand maximal element of the effect ordering. In the term language, evidence is used to witness the validity \nof explicit subeffect coercions . t.For example, the function that applies its .rst argument to its second \n(cf. apply in Sections 3.3 and 3.4)is,in our target language, encodedby .a. .b. .p1. .p2. .q. .r1. .r2. \n.p: p1 0 p2. .r : r1 ; r2. ..fr1 : ap1 . bq . .r2xp2 : a. f (px)p1 . Here, the subeffect coercion px \nuses the evidence argument pto witness the adaptation of the effect p2 of x to the parameter effect p1 \nof the function f.  4.2 Operational Semantics To capture lazy evaluation in an operational semantics, \nwe employ a variation of Sestoft s simple abstract machine for call-by-need reduction (Sestoft 1997). \nThe main difference between ours and Sestoft s semantics is that the latter limits all function arguments \nto variables. As a result, closures are created only at let-bindings and simply passed through at lambda-bindings. \nAlthough this restric\u00adtion can be met easily for instance, by assuming a preprocessor that turns all \napplications of the form tu. into local de.nitions let x. = u in tx with x ./fv(t) we choose not to include \nit in our system, allowing closures to be introduced at application sites as well and thus retaining \na certain degree of .exibility in the term language. However, to determine whether or not evaluation \nof an application indeed produces a new closure, we have to be able to tell apart arguments that do give \nrise to closures from those that do not. This amounts exactly to our distinction between preterms and \nvariables. The operational semantics of our target language is nowde.ned by means of a reduction relation \nbetween abstract-machine con.g\u00adurations. Such con.gurations consist of a heap H, a control term t, astackS,and \nan environment.. Heaps act as .nite maps from heap locations hto effect-annotated closures (t; .)..We \nwrite H(h) for the closure associated with the rightmost binding for hin H. The set of all locations \nbound in His written as dom(H), whereas H\\ h stands for the heapobtainedbyremoving all bindings for hfrom \nH. Tokeep trackofevaluation contexts,we maintaina stackof con\u00adtext markers. A marker #h, for example, \nindicates that the term under evaluation is to be written to the heap at location h. Like\u00adwise, a marker \n@hindicates that the control term is to be applied to the closure stored in h. Other markers denote abstraction \nand application contexts for types, effects, and evidence, and subeffect\u00ading contexts.Environmentsmakebeta-substitutionexplicitbymap\u00adpingtermvariablestoheap \nlocations,typevariablestotypes,effect variablestoeffects, andevidencevariablestoevidenceexpressions. \nWe write.(x) for the location that is associated with the rightmost binding for x in .. In the samefashion, \nwe write .(a), .(\u00df), and .(d) to retrievethe rightmost bindingsfortype,effect,andevidence variables. \nThe reduction rules for the abstract machine are shown in Fig\u00adure 2. Each rule speci.es a single evaluation \nstep. The idea is that the machine takes such steps repeatedly until its stack is empty and its control \nterm has reached weak-head normal form. The reduction rules are syntax-directed: for each possible combination \nof a con\u00adtroltermandastack,atmostoneruleapplies. Lazinessisachieved through interplaybetween the rules \nR-VARMANY andR-WHNFUPD. Theformerexpressesthat,whena shared closureis entered,anup\u00addate marker is pushed \non the stack. The latter prescribes that, when the control term reaches weak-head normal form with an \nupdate marker on top of the stack, the heap is updated accordingly. Rule H; .\u00df. w1;(S' , @.); . -. H; \nw1; S' ;(., \u00df . .) Reduction H; t; S; . -. H' ; t ' ; S' ; . ' (R-EFFABSEFFAPP) .(x)= hH(h)=(t ' ; . \n' )1 H; t1 .; S; . -. H; t1;(S, @.); . (R-EFFAPP) (R-VARONCE) H; x; S; . -. H\\ h; t ' ; S; . ' t1 ./Whnf \n(R-EVABS) . .{\u00df, . } H; .d :: p. t1; S; . -. H; t1;(S, .d :: p); . .(x)= hH(h)=(t ' ; . ' ). (R-VARMANY) \nH; x; S; . -. H; t ' ;(S, #h); . ' H; .d :: p. w1;(S' , @.); . -. H; w1; S' ;(., d . .) (R-EVABSEVAPP) \nH; ..1x.2 : t. t1;(S' , @h); . -. H; t1; S' ;(., x . h) (R-ABSAPP) H; t1 .; S; . -. H; t1;(S, @.); . \n(R-EVAPP) h./dom(H) .(x)= h . (R-LET) (R-APPVAR) H; let x= t1 in t2; S; . -. (H, h. (t1; .).); t2; S;(., \nx . h) h./dom(H) H; t1 x; S; . -. H; t1;(S, @h); . t1 ./Whnf (R-SUB) H; t1 u.; S; . -. (H, h. (u; .).); \nt1;(S, @h); . H; . t1; S; . -. H; t1;(S,.@); . (R-APPPRETM) H(h)=(t ' ,. ' ). t1 ./Whnf (R-TYABS) H; \nw;(S' , #h); . -. (H, h. (w; .).); w; S' ; . H; .a. t1; S; . -. H; t1;(S, .a); . (R-WHNFUPD) H; .a. w1;(S' \n, @t ); . -. H; w1; S' ;(., a . t ) H; w;(S' , .a); . -. H; .a. w; S' ; . (R-WHNFTYABS) (R-TYABSTYAPP) \nH; w;(S' , .\u00df); . -. H; .\u00df. w; S' ; . (R-WHNFEFFABS) H; t1 t; S; . -. H; t1;(S, @t ); . (R-TYAPP) H; \nw;(S' , .d : p); . -. H; .d : p. w; S' ; . (R-WHNFEVABS) t1 ./Whnf (R-EFFABS) H; w;(S' ,.@); . -. H; \n. w; S' ; . (R-WHNFSUB) H; .\u00df. t1; S; . -. H; t1;(S, .\u00df); . Figure 2. Updateavoiding operational semanticsfor \nthe target language R-VARONCE says that, after theyare entered, nonupdatable closures are immediately \nremoved from the heap. Further examination of the reduction rules reveals that types and evidence do \nnot have any operational signi.cance. They are merely there to guide type checking (see Section 4.3) \nand to fa\u00adcilitateproofs. The same holds for subeffect coercions. Also, ef\u00adfect abstractions and effect \napplications play no decisive r ole in the evaluation of terms. The only effect expressions that do in.u\u00adence \nthe operation of our abstract machine are those that appear on preterm arguments and let-bindings. These \nare the effects that are used as heap annotations and thus drive the decision whether or not entered \nclosures are updated. However, note that we are careful not to subject the effects on closures to beta-substitution: \nthis would cause effect abstractions and applications to have nontrivial opera\u00adtional meaning after all. \nInstead, whenever we encounter an effect variable as the annotation on an entered closure, we conservatively \nassume the closure is to be updated; see rule R-VARMANY. As a result, implementations can safely employ \nan erasure se\u00admantics and strip offoperationally insigni.cant abstractions, appli\u00adcations, and coercions, \nbefore actually interpreting a program or generating code for it. This way, we assure that our usage \nanaly\u00adsis does not impose the unnecessary run-time overhead associated with the evaluation of types, \neffects, and evidence.  4.3 Typing To be able to statically ensure that a given program in the target \nlanguagedoesnot go wrong ,weemployatypeandeffect system that speci.es which target terms are well-typed \nwith respect to a context G. Such contexts map term variables to types and effects (through entries of \nthe form x :. t ), and evidence variables to quali.ers (through entries of the form d : p).We write G(x) \nfor the rightmost binding for x in G and, similarly, G(d) for the rightmost binding for d in G. The set \nof type variables that occur free in G is written as ftv(G);the set of free effect variables inG is denoted \nby fev(G).We write G \\ x for the environment that is obtained by removing all bindings for x from G. \nTheeffect typing relationis speci.edin Figure3through judge\u00adments of the form G f t :. t, indicating \nthat, in context G, term t can be assigned type t and effect .. When typing terms that have two or more \nsubterms, i.e., func\u00adtion applications (T-APPVAR and T-APPPRETM)and local de.ni\u00adtions (T-LET), we split \nup all potentially unique variables that ap\u00adpear in the context (so, these include those that are boundto \na vari\u00adable effect), and distribute them over the contexts that are passed down to the subterms. This \nsplitting of contexts is described by rules of the form G=G1 N G2. Our use of context splitting en\u00adsures \nthat uniquevariables are indeed usedat most once alongevery possible path in a program s control-.ow \ngraph. The well-formedness of evidence expressions is established by a set of subsidiary rules of the \nform G f . : p, indicating that, in context G, evidence . is a valid proof of predicate p. These rules \nare invoked in T-ABS, to meet the containment restriction for function abstractions, and in T-SUB, to \nenforce the validity of evidence expressions that witness explicit subeffect coercions. Note how T-SUB \nmakes use of the system parameter 0, that is(cf. Section 3.1) instantiated to either (for sharing analysis) \nor ; (for uniqueness typing).  4.4 Soundness To demonstrate the soundness of the type and effect system, \nwe extend the typing relation on terms to a typing relation on full pro\u00adgrams, i.e., abstract-machine \ncon.gurations. The resulting relation is de.ned by a set of rules of the form H; .; S f t :. t and is \nshown in Figure 4. Intuitively, the rules for program typing unwind the stack to re\u00adconstruct the evaluation \ncontext. The type of a program is then es\u00adtablished in a typing context that is obtained through an auxiliary \njudgement H; . f G. This auxiliary judgement combines the sub\u00ad  Figure 3. Type and effect system of \nthe target language Store typing H; \u00d8 f \u00d8 H; . f G (S-EMPTY) H(h) = (t ' , . ' ). H; . ' ; S1 f t ' :. \nt H; .; S1 f t :. t H; .; S1, #hf t :. t (P-UPD) H; .1 f G1 H(h) = (t; . ' ). H(h) = (t ' , . ' ). ' \nH; . ' ; \u00d8 f t ' :. ' t ' H; . ' f G ' G ' f t :. t H; .1, x . hf G1, x :. t (S-VAR) H; .; S1 f t :.1 \nt '. ' . t . H; .; S1, @hf t :. t (P-APP) H; .1 f G H; .1, a . t f G (S-TYVAR) H; .; S1 f .a. t :. t \nH; .; S1, .a f t :. t (P-TYABS) H; .1 f G H; .1, \u00df . . f G (S-EFFVAR) H; .; S1 f t t ' :. t H; .; S1, \n@t ' f t :. t (P-TYAPP) H; .1 f G1 G1 f . : p H; .1, d . . f G1, d : p (S-EVVAR) H; .; S1 f .\u00df. t :. \nt H; .; S1, .\u00df f t :. t (P-EFFABS) Program typing H; .; Sf t :. t H; .; S1 f t . ' :. t H; .; S1, @. \n' f t :. t (P-EFFAPP) H; . f G G f t :. ' t ' .(. ' ) = . .(t ' ) = t H; .; \u00d8 f t :. t (P-EMPTY) H; .; \nS1 f .d : p. t :. t H; .; S1, .d : p f t :. t H; .; S1 f t . :. t H; .; S1, @. f t :. t (P-EVABS) (P-EVAPP) \nH; .; S1 f . t :. t H; .; S1, .@ f t :. t (P-SUB) Figure 4. Program typing stitutions that are recorded \nin the program s environment with the types of the terms on the heap to produce a compliant typing con\u00adtext. \nIn rule P-EMPTY, we write .(.) and .(t ) for the application of the substitution recorded in . to, respectively, \nan effect . and a type t . An important point to make is that the well-typedness of a pro\u00adgram is not \nenough to guarantee that the abstract machine does not get stuck . As pointed out in Section 4.2, evidence \nabstractions and evidence applications play no r ole in controlling the operation of the abstract machine. \nThis enables the de.nition of a sound era\u00adsure semantics,but also forces us to be careful when establishing \nthe correctness of our sharing analysis.For instance, if we consis\u00adtently extend our target calculus \nwith integer constants, the follow\u00ading program is well-typed, .p: . 1. let twice1 = .1f. : Int1 . Int1 \n. .1x1 : Int. f (fx)1 in twice (p(.1y1 : Int. y)). 2, but neverthelessfails hopelessly when run on our \nabstract machine. To seewhy,considerthe top-levelevidence abstraction.It indicates that the program expects \nevidence p for the predicate . 1. Obviously, our evidence typing rules preclude the validity of any such \nevidence, but in the body of the evidence abstraction, we can nevertheless assume that the evidence is \nprovided and, so, we use it here to lift the effect of the nonupdatable abstraction .1y1 : Int. y. However, \nevidence and type abstractions have no real operational meaning, so machine reduction effectively ignores \nthe top-level lambdasand immediately startstheevaluationofthe local de.nition. Inside the local de.nition, \nthe program behaves as if evidence for . 1 was indeed provided, and the machine gets stuck inside the \nbody of twice, when it tries to enter the closure for the abstraction .1y1: Int. yfor the second time \nand .nds it removed from the heap. So, to demonstrate the correctness of our sharing analysis, we need \na stronger condition than mere well-typedness of target pro\u00adgrams.To this end, we introducea notionof \nsatis.ability, that pre\u00adscribes that instances of polymorphic types leave the ordering on effects antisymmetric: \nDe.nition 1. 1. Atyping context G is consistent if there does notexistevidence ., such that G f . : . \n1. .1 .2 2. Atype t is satis.able in G if (a) t = a, or (b) t = t1 . t2 with t1 and t2 satis.able in \nG, or (c) t = .a. t1 with t1 satis.able in G, or (d) t = .\u00df. t1 with t1 satis.able in G, or (e) t = p \n. t1 with, for all d, (G,d : p) consistent and t1 satis.able in (G,d : p). With satis.ability in place, \nsoundness for the target language with respecttothe operational semanticsof Figure2is established, as \nusual, by theorems for progress and preservation: Theorem2(Progress). Let 0 = . If H; .; Sf t :. t ,then \neither (a) t . Whnf and S = \u00d8, or else (b) the existence of an h with h./dom(H) implies that H; t; S; \n. -. H' ; t ' ; S' ; . ' for some H' , t ' , S' and . ' . Theorem 3 (Preservation). Let 0 = and H; .; \nS f t :. t with H; . f G, such that G is consistent and t satis.able in G. If ; t ' ; S' ; . ' ; S' f \nt ' . H; t; S; . -. H' ; . ', then (a) H' :t , and (b) thereexistsa consistent G ' with H' ; . ' f G \n' and t satis.able in G ' . 5. Effect Reconstruction Of course, we do not expect programmers to write \nprograms in our target language: getting all explicit annotations right is tedious Term language bt. \nd:= x | .x.btb= t inbTm t|bt| let x bt Type and effect language t . ct . . tb. bTy := a | b S .b. QualTy \n:= tb| p . .b S sb. TyScheme := .b|.a. sb|.\u00df. sb Typing contexts b. b G . d:= G, x :s | Gb,p Ctx \u00d8| b \nFigure 5. Syntax of the source language and error-prone. Instead, we rely on an algorithm that analyses \nan unannotated source program and then decorates it with the appropriate annotations. Developing and \nimplementing such an algorithmisfarfromtrivial,butinour approachwecan fortunately reuse the machinery \nthat is already available within the framework of quali.ed types. In this section, we introduce an implicitly \ntyped source language (Section 5.1) and discuss its translation into the target language (Section 5.2). \nThe translation is driven by derivations in a type and effect system for source terms. This type and \neffect system, which is a conservative extension of the Hindley-Milner system (Section 5.4), has a principal-type \nproperty, that drives the devel\u00adopment of an incremental algorithm for effect reconstruction (Sec\u00adtion \n5.3). 5.1 Source Language The surface language of our system is an implicitly typed, let\u00adpolymorphic \nlambda-calculus witha Hindley-Milner-like type sys\u00adtem (Milner 1978). Its syntaxisgivenin Figure5.To \ndistinguish them from their counterparts in the target language, we decorate metavariables and nonterminals \nof the source language with hats , as inbtand d Tm, The typing rules for source terms are, together with \nauxiliary rules for context splitting and predicate entailment, presented in Figure6.Typing contextsare \nessentially the same as thosein the target language with the notable exception that predicates are not \nassociated with evidence variables. The type language is strati.ed into monomorphic types, quali.ed types, \nand type schemes. We write fev(sb) for the effect variables that appear free in a type scheme sb. In \ncontrast to the typing rules for the target language, the typing rulesin Figure6 are not syntax-directed. \n 5.2 Translation In a way, the typing rules for the source language make up the actual usage analysis. \nProvided with a type derivation for a term bt, we can systematically produce an annotated type t, such \nthat t is a completion ofbt: De.nition 4. 1. A source term bt is completed by a target term t if and \nonly if Ltd = bt, where Ltd is given by: Lxd = x L..1x.2 : t. t1d = .x. Lt1d Lt1 xd = Lt1d x Lt1 u= Lt1dLud \n .d L.a. t1d = Lt1d Lt1 t d = Lt1d L.\u00df. t1d = Lt1d Lt1 .d = Lt1d  Figure 6. Generic usage analysis \nfor the source language L.d : p. t1d = Lt1d Lt1 .d = Lt1d Llet x. = t1 in t2d = let x = Lt1d in Lt2d \nL. t1d = Lt1d. 2. Asource context Gbis completed by a target context G, if, and only if, LGd =Gb, where \nLGd is given by: L\u00d8d = \u00d8 LG1, x :. t d = LG1d, x :. Lt d LG1,d : pd = LG1d, p. To systematically obtain \ncompletions from well-typed source terms, we de.ne a translation from type derivations in the source \nlanguage into target terms. As a typical example of a rule in this type-driven translation scheme, consider \nV :: Gb,p f bt :. .b1 (UA-QUAL)= .d : p. [Vl.,pn. d G f bt :p . .b1 b. . where d/. cod(.). Here, V ranges \nover derivations of the judgement Gb,p f bt :. .b1. The parameter . represents a mapping from predicates \nto evidence variables. Given such a mapping, we can turn derivations of predicate entailments into evidence, \nas in p . Gb (E-MONO)= .(p). b G p For reasons of space, we do not present the entire translation here, \nbut the remaining rules are unsurprising and straightforward. Of course, we are only interested in well-typed \ncompletions of source terms. Hence, the translation necessarily preserves well\u00adtypedness. As we have \nseen in Section 4.4, it is also crucial for the correctness of our analyses that the types of target \nterms are satis.able. We therefore impose a satis.ability restriction on the type schemes assigned to \nsource terms (cf. De.nition 1), and then show that the translation into target terms preserves types \nand maintains satis.ability: De.nition 5. 1. Atyping context Gbis consistent if Gb . 1is not derivable. \n 2. A type scheme sbis satis.able in Gbif (a) sb= tb, or (b) sb= p . .b1 with (Gb,p) consistent and .b1 \nsatis.able in (Gb,p), or (c) sb= .a. sb1 with sb1 satis.able in Gb, or (d) sb= .\u00df. sb1 with sb1 satis.able \nin Gb.  Theorem6(Soundness of theTranslation). Let Gbbe consistent and V a derivation of Gbf bt :. sbwith \nsbsatis.able in Gb. Then, for [Vl. . = t, Ltd = bt, G f t :sb, and sbsatis.able in G, for each G with \nLGd =Gband G(.(p)) = p for all p . dom(.). .  5.3 PrincipalType Schemes An implementation of our usage \nanalysis is only useful if it uses an algorithm that produces completions corresponding to the best assignable \ntype and effect for a given source term. Recall from Section 3.5 that, in our system, best does not necessarily \nmean least restrictive . Instead, we are interested in the most general type. When a term is used, this \ntype can then be instantiated with the most desirable usage propertiespermittedby the context. Im\u00adplementations \nare thus required toproduce completions that corre\u00adspond to (derivations of) the so-called principal \ntype scheme (Hind\u00adley1969) of a source term. A principal type scheme for a termbt is a type scheme that \nis assignable to bt and that is more general than all other assignable type schemes: De.nition 7. Atype \nschemesbisa solution forbtin Gb, if Gbf bt :. sbfor some effect .. De.nition 8. 1. Atype tbis a generic \ninstanceof sbin Gb, if Gbf bt :. sbimplies Gbf b. b t :t . 2. Atype scheme sbis moregeneral than sb' \nin Gb, if every generic instance of sb' in Gbis also a generic instance of sbin Gb. Not all instantiations \nof a type scheme for a term depend on the context in which the term is used. Consider, for instance, \nthe term (.x. .y. x)(.x. x)(.x. x) and its principal type scheme .a. .p. .p1. .p2. .q1. .q2. .r. pp1 \n. p1 0 p2 . q1 0 q2 . a r . a r . The predicates in this type scheme arise from the containment restriction \nfor abstractions and the use of subeffecting at application sites. However, how the effect variables \np, p1, p2, q1, and q2 are instantiated does not matter to any speci.c use of the term; the only effect \nvariables that do matter are those that appear in the tb\u00adpart of a type scheme. So, in our example, the \nonly relevant effect variable is r. Effectvariablesthatdonot appearinthe tb-partofatype scheme are called \nambiguous (cf. Jones 1994, Section 5.8) and we do not allow them to appear in inferred type schemes. \nInstead, our shar\u00ading analysis seizes on the opportunity and disambiguates ambigu\u00adous variables by instantiating \nthem with their most desirable effect value. In our example, we then infer the type scheme .a. .r. a \nr . a r, and have the function arguments and the partial application an\u00adnotated with 1. Note that our \napproach to disambiguation to a large extent coincides with the use ofdefaulting in Haskell (Peyton Jones \n2003, Section 4.3.4). De.nition 9. 1. The set of active effect variables of a type scheme sb, written \naev(sb), is given by aev(tb)= fev(tb) aev(p . .b1)= aev(.b1) aev(.a. sb1)= aev(sb1) aev(.\u00df. sb1)= aev(sb1). \n2. The set of generic effect variablesof a type scheme sb, written gev(sb), is given by gev(tb)= \u00d8 gev(p \n. .b1)= \u00d8 gev(.a. sb1)= gev(sb1) gev(.\u00df. sb1)= {\u00df }. gev(sb1). 3. The set of quali.ed effect variables \nof a type scheme sb, written qev(sb), is given by qev(tb)= \u00d8 qev(p . .b1)= fev(p) . qev(.b1) qev(.a. \nsb1)= qev(sb1) qev(.\u00df. sb1)= qev(sb1). De.nition 10. A type scheme sbis unambiguous, if gev(sb) n qev(sb) \n. aev(sb). The best completionofasource termisnowgivenbyaderiva\u00adtion of its most general unambiguous, \nsatis.able type scheme. De.nition 11. An unambiguous, satis.able solution sbis a princi\u00adpal unambiguous, \nsatis.able type scheme of bt in Gb, if sbis more general than every unambiguous, satis.able solution \nof btin Gb. Theorem12 (PrincipalType Schemes). If a termbt has an unam\u00adbiguous, satis.able solution in \nGb, then it has a principal unambigu\u00adous, satis.able type scheme in Gb. Disambiguation is crucial for \nthe effectiveness of our sharing analysis: without it, no closure will ever be marked as nonupdat\u00adable. \nFurthermore, aggressive disambiguation has a positive im\u00adpact on the performance of inference algorithms, \nsince it allows for smaller predicate sets. Predicate sets are also kept small be\u00adcause we restrict our \nattention to satis.able type schemes, because assuming satis.ability enables us to subject predicates \nto improve\u00adment (Jones 1995): if we encounter predicates of the form \u00df 1 or .\u00df, we infer that \u00df istobe \ninstantiatedto, respectively,1 or .. Furthermore, a related technique, simpli.cation, can be applied \nto safely remove trivial predicates like1 \u00df, \u00df\u00df, and \u00df 1 as well as predicates that are already implied \nby the transitivity of the ordering on effects. The incremental type-reconstruction algorithm of Jones \n(1995), itself anextensionof AlgorithmW(Damas and Milner 1982), can now be adapted for inferring appropriate \nprincipal type schemes for terms and simultaneously reconstructing the associated com\u00adpletions. 5.4 \nApplicability The type and effect system of Figure 6 is a conservative exten\u00adsion of the Hindley-Milner \nsystem. Moreover, every term that is typeable in the Hindley-Milner system is also typeable in the type \nand effect system. Writing LsbdHM and LGbdHM for the type scheme and context obtainedby stripping all \nannotations and predicates and such from, respectively, sband Gb, and GHM fHM bt : sHM for typing judgements \nin the Hindley-Milner system, we have: Theorem 13 (Conservative Extension). 1. If Gbf bt :. sb, then \nLGbdHM fHM bt: LsbdHM. 2. If GHM fHM bt : sHM, then there exist Gb, sb, and ., such that GHM .  LGbdHM \n= , Lsbd = sHM, and Gbf bt :sbwith Gbconsistent, and sbunambiguous and satis.able in Gb. 6. RelatedWork \nEarly work on sharing analysis is due to Goldberg (1987) who uses abstract interpretation to derive information \nabout the usage of partial applications. Marlow (1994) also de.nes an abstract interpretation; he measures \nthe number of updates performed by a naive implementation of call-by-need evaluation and estimates that, \nfor a typical program, 70% of all such updates are actually unnecessary. Launchbury et al. (1992) formulate \na sharing analysis in terms ofasubstructural type system. Their analysis distinguishes between terms \nthat are used never, terms that are used at most once, and termsthatmaybeusedmorethan once.Turneretal.(1995) \npresent a comparable type-based analysis, thatis less conservativebut does not keep track of terms that \nare never used. Mogensen (1998) presents an adaptation that does detect unused terms. Another extension \nto the system of Turner et al. is given by Wansbrough and Peyton Jones (1999). In contrast to the aforemen\u00adtioned \nanalyses, their analysis operates on a polymorphically typed source language with user-de.ned algebraic \ndata types. Moreover, their type system incorporates a subtyping relation, which makes that the analysis \nis, to some extent, context sensitive. In practice, however, the analysis turns out to perform rather \npoorly, especially in the context of curried function de.nitions. The proposed solu\u00adtiontothisproblemistoextendthetypesystemwithalimitedform \nof polyvariance thatisdubbed simple polymorphism (Wansbrough andPeyton Jones 2000;Wansbrough 2002). Simple \npolymorphism restricts the quanti.ed effect variables of a type scheme to those that simultaneously occur \nin covariant and contravariant positions. Furthermore, it does not permit quanti.ed type variables to \nbe sub\u00adjected to subtype coercions. The main motivation for the inclusion of simple polymorphism is that \nit adds of the power of full polyvari\u00adance,whileitallowsforacombinationwithsubtypingthatdoesnot suffer \nfrom the complications that arise when full polyvariance is to be mixed with subtyping. Still, an inference \nalgorithm for simple polymorphism is complicated in its own right. Our approach tokeeping the mixture \nof polyvariance and sub\u00adsumption manageableis,inasense, oppositeto thatofWansbrough and Peyton Jones. \nInstead of employing a more limited form of polyvariance, we employa more limited form of subsumption, \ni.e., we do not extend the subeffecting relation to a full subtyping re\u00adlation. While an analysis based \non simple polymorphism behaves, foralargeclassof realistic programs,more conservativelythansys\u00adtems that \ncombine full polyvariance and subtyping (e.g., Gustavs\u00adson and Svenningsson 2001; Gustavsson 2001), the \ncombination of full polyvariance and subeffecting is, in practice, just as expressive as full polyvariance \nand shape-conformant subtyping. Gedell et al. (1999) measure the impact of polyvariance, sub\u00adtyping, \nwhole program analysis, and the treatment of user-de.ned algebraic data types on the performance of type-based \nusage anal\u00adyses. Theyshow that all these features increase the precision of the analysis,but that acceptable \nresults can still be obtained if one of them is left out. They do not address the option of replacing \nfull subtypingby mere subeffecting.Our useofquali.ed types allows for an implementation by means of an \nincremental inference algo\u00adrithm. Hence, our analysis can, almosteffortlessly,be usedina set\u00adting that \ndemands separate compilation; it then conservatively as\u00adsumes that top-level de.nitions may be used more \nthan once. Still, analysis results will be better if they are obtained by means of a whole program analysis.Wehavenotyet \naddressedthe analysisof user-de.ned algebraic data types: although the details remain fu\u00adture work, we \nexpect to encounter the same trade-offs as described by Gedell et al. Uniqueness typing was .rst described \nfor a monovariant sys\u00adtem by Barendsen and Smetsers (1993). Later, the same authors added uniqueness \npolymorphism, i.e., polyvariance (Barendsen and Smetsers 1995). Recently,de Vriesetal. (2007)de.neda \nunique\u00adness type system that incorporates rank-n polymorphism. Most of the existing systems for sharing \nanalysis and unique\u00adness typing come with real-life implementations and experimental data. Our system \nhas not reached this level of maturity yet; im\u00adplementing our analysis in a large-scale compiler is left \nas future work. The similarity between type-based sharing analyses and systems with uniqueness typing \nwas .rst signalled by Wansbrough and PeytonJones(1999, Section2.2),whoobservedadegreeofduality betweenthetwo \nanalysesand statedthat itwouldbe interestingto see whether the duality can be made more precise .We believe \nto have done so in this paper. 7. Conclusions and FurtherWork We have formulated a generic usage analysis \nwith subeffecting and polyvariance, that can be instantiated to both sharing analysis and uniqueness \ntyping. Building the analysis upon the theory of quali.edtypes enablesusto reuseagreatdealof metatheoretical \ntools and implementation techniques. The Clean language, for example, features both type classes and \nuniqueness typing.With our approach,a Clean compiler can implement both type classes and uniqueness typing \non top of a common infrastructure for quali.ed types. Furthermore, the error messages that the existing \nimplementation of Clean produces for programs with incorrect uniqueness properties are often not very \ndescriptive. Heeren (2005) describes a type-inference framework that aims at producing understandable \ntype-error messages. The part of his framework that deals with type inferencing in the context of type \nclasses applies, essentially, to all systems with qualifed types.We are therefore planning to implement \nour analysis within Heeren s framework; we hope to obtain a system for uniqueness typing that produces \ntype-error messages that are better suited to the needs of the programmer than those produced by the \nClean compiler. Another interesting direction for future work is to extend the effect language of our \nsystem with a constant that expresses that a valueisneverused.This additionalexpressivenesshasalreadybeen \nput to use for sharing analysis (Launchbury et al. 1992; Mogensen 1998),buthasnotyetbeenexploredinthe \ncontextof uniqueness typing. Finally, we plan to investigate to what extent our approach to context-sensitive \nusage analyses is applicable to other program analyses, such as binding-time analysis and strictness \nanalysis. Acknowledgments The authors would like to thank Edsko de Vries and Rinus Plas\u00admeijer for discussing \nwith us the tension between subsumption and containment for function types. We are also grateful to the \nfour anonymous referees for their detailed and constructive comments. This work was supported in part \nby the Netherlands Organization for Scienti.c Research through its project on Scriptable Compil\u00aders (612.063.406) \nand by Microsoft Research through its Euro\u00adpean PhD Scholarship Programme. References Erik Barendsen \nand Sjaak Smetsers. Conventional and uniqueness typing in graph rewrite systems. In R. K. Shyamasundar, \neditor, Foundations of SoftwareTechnology and Theoretical Computer Science, 13th Confer\u00adence, Bombay, \nIndia, December 15 17, 1993, Proceedings, volume 761 of Lecture Notes in Computer Science, pages 41 51. \nSpringer-Verlag, 1993. Erik Barendsen and Sjaak Smetsers. Uniqueness type inference. In Manuel V. Hermenegildo \nand S. Doaitse Swierstra, editors, Program\u00adming Languages: Implementation, Logics and Programs, 7th Interna\u00adtional \nSymposium, PLILP 95, Utrecht, The Netherlands, September 20 22, 1995, Proceedings, volume 982 of Lecture \nNotes in Computer Sci\u00adence, pages 189 206. Springer-Verlag, 1995. Lu\u00b4is Damas and Robin Milner. Principal \ntype-schemes for functional programs. In Conference Recordof the Ninth AnnualACM Symposium on Principles \nof Programming Languages, Albuquerque, New Mexico, January 1982, pages 207 212.ACM Press, 1982. Edsko \nde Vries, Rinus Plasmeijer, and David Abrahamson. Uniqueness typing rede.ned.InZolt\u00b4anHorv\u00b4ath,Vikt\u00b4oriaZs\u00b4ok,andAndrew \nButter\u00ad.eld, editors, Implementation and Application of Functional Languages, 18th InternationalWorkshop, \nIFL 2006, Budapest, Hungary, September 4 6, 2006, Revised SelectedPapers, volume 4449 of Lecture Notes \nin Computer Science, pages 181 198. Springer-Verlag, 2007. Tobias Gedell,J\u00a8orgen Gustavsson, and Josef \nSvenningsson. Polymorphism, subtyping, whole program analysis and accurate data types in usage analysis. \nIn NaokiKobayashi, editor, Programming Languages and Sys\u00adtems, 4th Asian Symposium, APLAS 2006, Sydney,Australia,November \n8 10, 2006, Proceedings, volume 4279 of Lecture Notes in Computer Science, pages 200 216. Springer-Verlag, \n1999. John M. Gifford, David K. Lucassen. Integrating functional and imper\u00adative programming. In Proceedings \nof the 1986 ACM Conference on LISPand FunctionalProgramming,August4 6,1986, Cambridge,Mas\u00adsachusetts, \nUSA, pages 28 38.ACM Press, 1986. Jean-Yves Girard. Interpr\u00b4\u00b4etation fonctionelle et elimination des \ncoupures de l arithm\u00b4erieur. etique d ordre sup\u00b4PhD thesis, Universit\u00b4eParis VII, 1972. Benjamin Goldberg. \nDetecting sharing of partial applications in functional programs. In Gilles Kahn, editor, Functional \nProgramming Languages and Computer Architecture,Portland, Oregon, USA, September 14 16, 1987, Proceedings, \nvolume 274 of Lecture Notes in Computer Science, pages 408 425. Springer-Verlag, 1987. J\u00a8Space-Safe Transformation \nand Usage Analysis for orgen Gustavsson. Call-by-Need Languages. PhD thesis,G\u00a8oteborgUniversity, 2001. \nJ\u00a8orgen Gustavsson.Atype based sharing analysis for updateavoidance and optimisation. In Proceedings \nof the thirdACM SIGPLAN International Conference on Functional Programming (ICFP 98), Baltimore, Mary\u00adland, \nUSA, September 27 29, 1998, pages 39 50.ACM Press, 1999. J\u00a8orgen Gustavsson and David Sands. A foundation \nfor space-safe trans\u00adformations of call-by-need programs. Electronic Notes in Theoretical Computer Science, \n26:69 86, 1999. J\u00a8orgenGustavssonandJosefSvenningsson.Ausage analysiswith bounded usage polymorphism \nand subtyping. In Markus Mohnen and Pieter W.M.Koopman, editors,Implementation of Functional Languages, \n12th International Workshop, IFL 2000, Aachen, Germany, September 4 7, 2000, SelectedPapers, volume 2011 \nof Lecture Notes in Computer Science, pages 140 157. Springer-Verlag, 2001. Bastiaan Heeren. Top QualityType \nError Messages. PhD thesis, Utrecht University, 2005. J. Roger Hindley. The principal type-scheme of \nan object in combinatory logic. Transactions of the Americal Mathematical Society, 146:29 60, 1969. MarkP. \nJones. Quali.edTypes: Theory and Practice. Cambridge Univer\u00adsity Press, Cambridge, 1994. MarkP. Jones. \nSimplifying and improving quali.ed types. In Conference Recordof FPCA 95 SIGPLAN-SIGARCH-WG2.8 Conference \non Func\u00adtional Programming Languages and Computer Architecture. La Jolla, CA, USA, 25 28June 1995, pages \n160 169.ACM Press, 1995. Stefan Kaes. Parametric overloading in polymorphic programming lan\u00adguages. In \nHarald Ganzinger, editor, ESOP 88, 2nd European Sym\u00adposium onProgramming, Nancy,France, March21 24, 1988,Proceed\u00adings,volume \n300 ofLectureNotes in Computer Science,pages 131 144. Springer-Verlag, 1988. Naoki Kobayashi. Quasi-linear \ntypes. In POPL 99, Proceedings of the 26th ACM SIGPLAN-SIGACT Symposium on Principles of Program\u00adming \nLanguages,January 20 22, 1999, San Antonio, TX, pages 29 42. ACM Press, 1999. John Launchbury, Andy Gill, \nJohn Hughes, Simon Marlow, Simon Pey\u00adton Jones, and PhilipWadler. Avoiding unnecessary updates. In John \nLaunchbury andPatrick M. Sansom, editors, Functional Programming, Glasgow 1992, Proceedings of the 1992 \nGlasgowWorkshop on Func\u00adtional Programming,Ayr, Scotland, 6 8July 1992,Workshops in Com\u00adputing, pages \n144 153. Springer-Verlag, 1992. Jeffrey R. Lewis, John Launchbury, Erik Meijer, and Mark Shields. Im\u00adplicit \nparameters: Dynamic scoping with static types. In POPL 2000, Proceedings of the 27thACM SIGPLAN-SIGACT \nSymposium on Prin\u00adciples of Programming Languages,January19 21, 2000, Boston, Mas\u00adsachusetts, pages 108 \n118.ACM Press, 2000. Simon Marlow. Update avoidance analysis by abstract interpretation. In Kevin Hammond \nand JohnT. O Donnell, editors,1993 GlasgowWork\u00adshopon FunctionalProgramming,Ayr,pages 170 184. Springer-Verlag, \n1994. Robin Milner.Atheoryof type polymorphismin programming. Journal of Computer and System Sciences, \n17(3):348 375, 1978. Torben\u00c6. Mogensen.Typesfor0,1or many uses.In Chris Clack,Kevin Hammond, and AnthonyJ.T. \nDavie, editors, Implementation of Func\u00adtional Languages, 9th International Workshop, IFL 97, St. Andrews, \nScotland, UK, September 10 12, 1997, SelectedPapers,volume 1467 of Lectures Notes in Computer Science, \npages 112 122. Springer-Verlag, 1998. Flemming Nielson and Hanne Riis Nielson. Type and effect systems. \nIn Enst-R\u00a8udiger Olderog and Bernhard Steffen, editors, Correct System De\u00adsign, Recent Insightand Advances, \n(to Hans Langmaackon the occasion ofhisretirementfromhisprofessorshipattheUniversityof Kiel),volume 1710 \nof Lecture Notes in Computer Science, pages 114 136. Springer-Verlag, 1999. Simon Peyton Jones, editor. \nHaskell 98 Language and Libraries: The Revised Report. Cambridge University Press, Cambridge, 2003. Rinus \nPlasmeijer and Marco van Eekelen. Concurrent Clean language report version 1.3. Technical Report CSI-R9816, \nUniversity of Ni\u00adjmegen, 1998. John C. Reynolds. Towards a theory of type structure. In Bernard Robi\u00adnet, \neditor, Programming Symposium, Proceedings Colloque sur la Pro\u00adgrammation, Paris, France, April 9 11, \n1974, volume 19 of Lecture Notes in Computer Science, pages 408 423. Springer-Verlag, 1974. Peter Sestoft. \nDeriving a lazy abstract machine. Journal of Functional Programming, 7(3):231 264, 1997. Jean-PierreTalpinand \nPierreJouvelot.Atypeandeffect discipline. Infor\u00admation and Computation, 111(2):245 296, 1994. DavidN.Turner,PhilipWadler,and \nChristian Mossin. Onceuponatype. In Conference Recordof FPCA 95 SIGPLAN-SIGARCH-WG2.8 Con\u00adference on \nFunctional Programming Languages and Computer Archi\u00adtecture. LaJolla, CA, USA, 25 28June 1995, pages \n1 11.ACM Press, 1995. PhilipWadler and Stephen Blott. How to make ad-hoc polymorphism less ad-hoc. In \nConference Recordof the Sixteenth AnnualACM Symposium on PrinciplesofProgramming Languages,Austin,Texas,January \n1989, pages 60 76.ACM Press, 1989. Keith Wansbrough. Simple Polymorphic Usage Analysis. PhD thesis, University \nof Cambridge, 2002. KeithWansbrough and Simon Peyton Jones. Simple usage polymorphism. In Preliminary \nProceedings of the ThirdWorkshop onTypes in Compi\u00adlation (TIC 2000), 2000. The proceedings of the workshop \nhave been published as a technical report (CMU-CS-00-161) at Carnegie Mellon University. Keith Wansbrough \nand Simon Peyton Jones. Once upon a polymorphic type. In POPL 99, Proceedings of the 26thACM SIGPLAN-SIGACT \nSymposium on Principles of Programming Languages,January 20 22, 1999, San Antonio, TX, pages 15 18.ACM \nPress, 1999.   \n\t\t\t", "proc_id": "1291151", "abstract": "<p>Sharing analysis and uniqueness typing are static analyses that aim at determining which of a program's objects are to be used at most once. There are many commonalities between these two forms of usage analysis. We make their connection precise by developing an expressive generic analysis that can be instantiated to both sharing analysis and uniqueness typing. The resulting system, which combines parametric polymorphism with effect subsumption, is specified within the general framework of qualified types, so that readily available tools and techniques can be used for the development of implementations and metatheory.</p>", "authors": [{"name": "Jurriaan Hage", "author_profile_id": "81100273210", "affiliation": "Utrecht University, Utrecht, Netherlands", "person_id": "P151577", "email_address": "", "orcid_id": ""}, {"name": "Stefan Holdermans", "author_profile_id": "81337489874", "affiliation": "Utrecht University, Utrecht, Netherlands", "person_id": "P900686", "email_address": "", "orcid_id": ""}, {"name": "Arie Middelkoop", "author_profile_id": "81337491663", "affiliation": "Utrecht University, Utrecht, Netherlands", "person_id": "P900673", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291189", "year": "2007", "article_id": "1291189", "conference": "ICFP", "title": "A generic usage analysis with subeffect qualifiers", "url": "http://dl.acm.org/citation.cfm?id=1291189"}