{"article_publication_date": "10-01-2007", "fulltext": "\n On BarronandStrachey sCartesianProductFunction Possibly theworld s .rstfunctionalpearl Olivier Danvy \nMichaelSpivey Department of Computer Science, University of Aarhus Oxford University ComputingLaboratory \nIT-parken, Aabogade 34 Wolfson Building, Parks Road DK-8200Aarhus N, Denmark Oxford OX13QD, England danvy@brics.dk \nmike@comlab.ox.ac.uk Abstract Overfortyyears ago,DavidBarron andChristopherStracheypub\u00adlished a startlingly \nelegant program for the Cartesian product of a list of lists, expressing it with a three nested occurrences \nof the function we now callfoldr .Thisprogramisremarkablefor its time becauseofitsmasterfuldisplayofhigher-orderfunctionsandlexi\u00adcal \nscope,and weput itforward aspossibly the .rst everfunctional pearl. We .rst characterize it as the result \nof a sequence of pro\u00adgram transformations, and then apply similar transformations to a programfor theclassicalpowersetexample.Wealsoshow \nthat us\u00ading a higher-order representation of lists allows a de.nition of the Cartesianproductfunction \nwhere foldr is nested only twice. Categories and Subject Descriptors D.1.1[Software]: Program\u00adming Techniques \nApplicative (Functional) Programming; K.2 [Computing Milieux]:HistoryofComputing General Terms Languages \nKeywords CPL  1. Introduction In 1966, David Barron and Christopher Strachey contributed a chapteron \nProgramming toabook entitled Advances in Program\u00adming and Non-numerical Computation edited by Leslie \nFox, then Professor ofNumericalAnalysis atOxford(Barron andStrachey 1966). The volume was assembled from \nlecture notes used at a summerschoolheld inOxford in1963,andBarronandStrachey s chapter was put together \nby David Barron with the help of tape recordingsofStrachey s lectures(Barron1975).Although osten\u00adsiblyanintroduction \nto(then) modernideasinprogramming,the chapter could more accurately be described as a shop window for \nthefeaturesof theauthors newprogramminglanguageCPL. CPL was far ahead of its time, in the sense that \nit was too ambitious ever to be fully implemented with contemporary ma\u00adchinesand software(Hartley2000).Partlythroughitssimplervari\u00adantBCPL(Richards2000), \nintroduced asa language inwhich the CPL compiler could be written, CPL did have a wide in.uence, however.BCPLin \nturngaverise to the languagesBandCinwhich Permission to make digital or hard copies of all or part of \nthis work for personal or classroomuseisgrantedwithout feeprovidedthat copies arenotmadeordistributed \nforpro.t orcommercialadvantageand thatcopiesbearthisnotice andthefullcitation onthe.rstpage.To copy otherwise,to \nrepublish,topostonserversorto redistribute tolists, requirespriorspeci.cpermission and/ora fee. ICFP \n07, October 1-3, 2007, Freiburg, Germany. Copyright c . 2007ACM978-1-59593-815-2/07/0010. . .$5.00 the \nUNIX system was written, and so its indirect in.uence remains widespread even today. Barron and Strachey \ns chapter contains several examples of CPL programs in different styles, and among them is a purely functional \nprogram for computing the list of all factors of a given number.In thebestfunctional style, thisprogram \nisacomposition of simplerparts: 1. Userepeateddivisionto.nd a list ofprimefactorsofthegiven number in \nascending order. 2. Group equal factors and multiply them together to get lists of theprimepowers thatdivide \nthegivennumber. 3. Use a Cartesian product function to choose one of the powers of eachprime ineachpossibleway. \n 4. Multiply together theprimepowers togiveall thefactorsofthe number.  What interests us here is the \nCartesian product function, which Barron and Strachey introduce with the example that Product applied \nto the list [[a,b],[p,q,r],[x,y]] yields [[a,p,x],[a,p,y],[a,q,x],[a,q,y],[a,r,x],[a,r,y], [b,p,x],[b,p,y],[b,q,x],[b,q,y],[b,r,x],[b,r,y]], \nwith each list in the result containing one element from each of the listsintheinput,andinthesameorder.Later,theyprovidethe \nfollowing startlingde.nitionof thisfunction: let Product[L]= Lit[f,List1[NIL],L] where f[k,z]= Lit[g,NIL,k] \nwhere g[x,y]= Lit[h,y,z] where h[p,q]= Cons[Cons[x,p],q]. Here, Lit is the higher-order function that \npresent-day functional programmers callfoldr : foldr :: (a . \u00df . \u00df) . \u00df . [a] . \u00df foldr fa xs = visit \nxs where visit [] = a visit (x : xs)= fx (visit xs) UsingsomemorenotationfromHaskelltogetherwiththe xs \ncon\u00adventionfor list variables,theprogramcanberewrittenasfollows: product :: [[a]] . [[a]] (P) product \nxss = foldr f [[ ]] xss where f xs yss = foldr g[] xs where gx zss = foldr hzss yss where hys qss =(x \n: ys): qss. (Wehavecompressedthelayouta littletosavespace.) This de.nition of Product is astounding in \nseveral ways, and (although it isasubjectivepoint)weput itforwardaspossibly the .rst everfunctionalpearl, \nin thesenseof apresentationof apurely functional computer program that is remarkable for its succinct \nelegance.It makes accomplished use ofhigher-orderfunctions(the three nested occurrences of foldr ), and \nof lexical scoping (the occurrence of x inthelast lineisboundbytheenclosingde.nition where gx zss = ... \n, and the occurrence of yss in the third line issimilarlyboundby where f xs yss = ... ). Though higher-order \nfunctions such as map were known in Lisp,whichhadaclear in.uenceonStrachey swork oftheperiod, Lisp at \nthe time lacked any equivalent for the function foldr , had dynamic scope by default, and did not readily \nsupport local function de.nitions. The archive of Strachey s working papers at the Bodleian Library in \nOxford (Strachey 1961) contains many versionsof theCartesianproductfunction,beginning in late1961; it \nwas evidently one of Strachey s favourite examples. A number of listings show him testing various versions \nby translating them intoLisp. However, in a handwritten note dated 2 November 1961, Stra\u00adchey goes beyond \nthe Lisp style of the time and investigates the properties oftwo recursive operators R1 and R2 that correspond \nto foldr and foldl. Strachey .rst notes that R1 applied to cons has the effect of append and R2 applied \nto cons has the effect of reverse.He thenshowsthat theCartesianproductfunctioncan also be expressed in \nterms of R1 using nested lambda-expressions wherefreevariablesof the innerexpressionareboundbytheouter \nlambda, giving in essence the program shown above. Though this program could have been translated into \nLisp using the FUNARG mechanism, there isnoevidence thatStracheydidso. In this article, we reconstruct \na sequence of steps that might have led to Barron and Strachey s program, relate these to a more modern \nderivationthat startswitha list comprehension,and treat another example power set in a similar way, \nbefore .nally showinghow aprogram of stillhigher order can compute product using only two applications \nof foldr . As for the authors of the present article, Danvy .rst came across this arrestingly beautiful \nde.nition of the Cartesian prod\u00aduct inPatrickGreussay sVLISP16 manual(1978,page3 3),and Spivey inFox \nsbook(BarronandStrachey1966).Naturally,we were not the .rst to marvel at the programming achievements \ndescribed in Barron and Strachey s chapter and epitomized by the de.nition of product shown above. Michael \nGordon (1973; 1979; 2000) showed that any function that is de.ned using Lit but no other recursion does \nan amount of work that is bounded as a function of the length of the longest list in the input. This \nallowed him to show that Lit cannot be used to de.ne many fa\u00admiliar functions on trees (represented as \nnested lists), where the input may be deeply nested but contains only lists of bounded length. 2. Cartesian \nproduct explained Barron and Strachey do not quite pull out of a hat the de.nition of Product from Section \n1. Noting that the problem of de.ning Product is quite dif.cult , they begin with the following de.ni\u00adtion, \nwhich wehavere-expressed usingpattern matchingfor clarity. product [] =[[]] (P0 ) product ([]: )=[] product \n((x : xs): xss)= map f (product xss) ++ product (xs : xss) where f ys = x : ys. The authors show a trace \nof the execution of the program and note, Althoughthisprogramisingenious,thisisaveryinef.cient process, \nbeforeproposingthefollowing moreef.cient version.1 product [] =[[]] (P1 ) product (xs : xss)= f1 xs (product \nxss) where f1 [] yss = [] f1 (x : xs) yss = f2 x (f1 xs yss) yss where f2 x zss [] = zss f2 x zss (ys \n: yss)=(x : ys): f2 x zss yss. Thentheywrite, Thisprocesscanbeexpressed moreelegantly in theformshown \ninSection1ofthepresentarticle, leavingthe reader with no more than an elliptic explanation of this tour \nde force.  3. Cartesian product reconstructed In this section, we present a sequence of transformation \nsteps that leads from the ingenious but inef.cient version P0 to the more ef.cient stepping stone P1 \nand on to the de.nition in terms of foldr . Introducing an auxiliaryfunction Thefunctionproduct inprogram \nP0 usesrecursiononboththe list of lists and on the list that is its .rst element. Let us introduce an \nauxiliaryfunction htoseparatethe tworecursions,specifyingitby hxs xss = product (xs : xss). Disentangling \nthe program in this way leads to the following ver\u00adsion of product: product [] =[[]] (P0 ' ) product \n(xs : xss)= hxs xss where h[] xss = [] h(x : xs) xss = map f (product xss) ++ hxs xss where f ys = x \n: ys. Computing the main recursive calljust once Inprogram P0 ' , the recursive call product xss is \ncomputed repeat\u00adedly, since xss is an unchanging argument of h.Itisbetter tocom\u00adpute thiscalljustonce,and \nwearrangefor thisby replacing hwith a newfunction h ' , speci.edby h ' xs (product xss)= hxs xss. This \nreplacement leads to the following rearrangement of the pro\u00adgram: product [] =[[]] (P0 '' ) product (xs \n: xss)= xs (product xss) h ' where h ' [] yss = [] h ' + h ' (x : xs) yss = map f yss +xs yss where \nf ys = x : ys. Since the value of product (xs : xss) depends on the value of product xss, we can view \nthe result of product in this program as a synthesized attribute(Johnsson1987). Thisform ofproduct is \neasily reached alsobybeginning with a de.nitionthat usesgeneratorsintheformof a list comprehension: product \n[] = [[]] product (xs : xss)=[ x : ys | x . xs,ys . product xss ]. 1In transcribing the de.nition of \nf1 , we have replaced the expression f2 x zss (f1 xs zss), an equivalent of which appearedinthe originalpaper, \nwith the corrected expression f2 x (f1 xs zss) zss. If we de.ne h ' xs yss =[ x : ys | x . xs,ys . yss \n], then we immediatelyget theequation h ' product (xs : xss)= xs (product xss). Applyingthe laws [ E \n| p . [],q . ys ] = [] and [ E | p . x : xs,y . ys ] =[ E[x/p] | y . ys ] ++ [ E | p . xs,q . ys ] thengives \ntherecursivede.nitionof h ' . Eliminating append Thede.nition of h ' includes the equation, h ' (x : \nxs) yss = map f yss ++ h ' xs yss. We can eliminate the use of ++ byintroducing afunction p, speci\u00ad.edby \npxzss yss = map f yss ++ zss where f ys = x : ys Now we can replace the expression map f yss ++ h ' xs \nyss with px(h ' xs yss) yss.We can alsoderive a recursivede.nition of p: pxzss [] = zss, pxzss (ys : \nyss) = f ys : map f yss ++ zss =(x : ys): pxzss yss. Putting these de.nitions together, and renaming \nh ' as f1 and p as f2 ,gives theprogram P1 that appears inSection2.2 Introducing foldr Thenext stepis \ntoobservethatinprogram P1 , product [] =[[]] (P1 ) product (xs : xss)= f1 xs (product xss) where f1 \n[] yss = [] f1 (x : xs) yss = f2 x (f1 xs yss) yss where f2 x zss [] = zss f2 x zss (ys : yss)=(x : \nys): f2 x zss yss, each of product, f1 and f2 canbe rewritten using foldr .First, product xss = foldr \nf1 [[ ]] xss, and second, f1 xs yss = foldr (gyss)[] xs, where gyss xzss = f2 x zss yss.Third, we see \nthat gyss xzss = foldr (hx) zss yss where hxys qss =(x : ys): qss.  Exploiting nested scopes The .nal \nstep is to note that the argument yss of f1 is passed on unchanged as an argument of g, and the argument \nx of g ispassed on as an argument of h.There is no need to make these arguments explicit, and they can \nbe lambda-dropped (Danvy and Schultz 2000) and left as free variables of g and h respectively. Renaming \nf1 as f then gives the form of the program P that was shown in Section1. 2The idea of introducing an \nextra parameter in order to eliminate ++ is a recurring theme in Strachey s working papers, often expressed \nin terms of a deforested function mapa f xs ys that computes map f xs ++ ys.  4. Applicationtothepowersetfunction \nAsimilarsequenceof transformationstepscanbeapplied toother functions. For example, let us consider the \npower set function de.nedby powerset :: [a] . [[a]] (Q0 ) powerset [] = [[]] powerset (x : xs)= map (x:) \nyss ++ yss where yss = powerset xs. Applyingit to the list [a,b,c] yields [[a,b,c],[a,b],[a,c],[a],[b,c],[b],[c],[ \n]]. As with the version P0 ' of theCartesianproductfunction, thisde.\u00adnition contains a use of ++ that \ncanbeeliminatedbyintroducing a newfunction, in thiscasespeci.edby fxyss zss = map (x:) yss ++ zss. The \nsecond equation in Q0 thenbecomes powerset (x : xs)= fxyss yss where yss = powerset xs, and wecanderive \ntherecursivede.nition, fx[] zss = zss fx(ys : yss) zss =(x : ys): fx yss zss. Theprogramcannowbeexpressedin \ntermsof foldr :giving powerset xs = foldr g[[ ]] xs where gxyss = fxyss yss, and fxyss zss = foldr (hx) \nzss yss where hxys qss =(x : ys): qss. Whenweputtheresultsofthesecalculations together,x canbe lambda-dropped, \nand we obtain a program in the style of Barron andStrachey: powerset xs = foldr g[[ ]] xs (Q1 ) where \ngxyss = foldr hyss yss where hys qss =(x : ys): qss. Of course, we could also have used mapa here to \nstart with(see Footnote2).Inanycase,thisprogram isessentially thesameasone attributedbyGordon(1973;1979) \ntohiscolleagueDaveduFeu. 5. Cartesian product revisited Consider for a moment a function that computes \nthe Cartesian productofjustfour lists: product of four :: [a] . [a] . [a] . [a] . [[a]] product of four \nxs ys zs ws = concat (map f xs) where fx = concat (map gys) where gy = concat (map hzs) where hz = concat \n(map kws) where kw = [[x,y,z,w]]. Thisprogramisexactlytheresultoftranslatingthe listcomprehen\u00adsion [[x,y,z,w] \n| x . xs,y . ys,z . zs,w . ws ]. Let us think about the purpose of the local function g that comes in \nthe middle of the nest of .ve functions. For .xed values of x and y, it computes the list of all lists \n[x,y,z,w] where z and w are respectivelydrawnfrom the lists zs and ws: in other words, map ([x,y]++) \n(product of two zs ws), where ([x,y]++) is the function that maps any list ps to the list [x,y] ++ ps. \nThis observation suggests that it might be fruitful to consider a recursivede.nitionof afunction that,given \nxss and us, computes map (us++) (product xss). Evenbetter,wecanexploitan ideaofHughes(1986),andrepresent \nthe list us by the function h =(us++). Thus, we make the speci.cation, prod :: [[a]] . ([a] . [a]) . \n[[a]] prod xss h = map h(product xss), and calculate a recursivede.nition of prod asfollows: prod [] \nh = map h(product [ ]) =[h[ ]], prod (xs : xss) h = map h(product (xs : xss)) = f xs (prod xss) h, \nwhere f :: [a] . (([a] . [a]) . [[a]]) . ([a] . [a]) . [[a]] isafunctionsuch that if c = prod xss then \nf xs ch = map h(product (xs : xss)). We can immediately calculate aclause thatde.nesf when xs = []: f \n[] ch = map h(product ([] : xss)) = map h[] = []. To derive the second clause in a de.nition of f, we \nmust use the equation product ((x : xs): xss)= map (x:) (product xs) ++ product (xs : xss), together \nwith the laws map h(ps ++ qs)= map hps ++ map hqs and map h(map g) zss = map (h\u00b7 g) zss: f (x : xs) ch \n= map h(product ((x : xs): xss)) = map h(map (x:) (product xss)) ++ map h(product (xs : xss)) = prod \nxss (h\u00b7 (x:)) ++ f xs ch = c (h\u00b7 (x:)) ++ f xs c h. Here, h\u00b7 (x:) denotes the composition of h with the \nfunction (x:) that adds the element x at the front of a list. Thus h \u00b7 (x:) is the function h ' such \nthat h ' xs = h(x : xs). In contrast to the synthesized attributes that were present in the successive \nversions of product inSection3, thefunction hplays theroleofan inherited attributehere. Insummary,wehavederived \ntheprogram, product xss = prod xss id where prod [] h =[h[ ]] prod (xs : xss) h = f xs (prod xss) h \nwhere f [] ch = [] f (x : xs) ch = c (h\u00b7 (x:)) ++ f xs ch, whichgivesexactly thesameresultasBarronandStrachey \nspro\u00adgram(P) inSection1.If wewere tousea .rst-orderrepresentation of lists here, we would naturally de.ne \na version of the product function where the individual sublists of the result appeared in re\u00adverse: product \nxss = prod xss [] where prod [] h ' =[reverse h ' ] prod (xs : xss) h ' = f xs (prod xss) h ' where f \n[] ch ' = [] f (x : xs) ch ' = c(x : h ' ) ++ f xs ch ' , And indeed,andDanvy andNielsenpointout(2001),defunction\u00adalisingHughes \nrepresentationgives this .rst-orderrepresentation, including an application of reverse in therightplace. \nOnce again, we would like to play the trick of eliminating ++ from this program, but this is made a little \nmore dif.cult by the presence of the functional argument c :: ([a] . [a]) . [[a]]. To deal with this, \nsuppose that c ' :: ([a] . [a]) . [[a]] . [[a]] is related to c bythe equation c ' hzss = ch ++ zss which \nholds for all zss; we specify a new pair of functions prod ' and f ' bythe equations, prod ' :: [[a]] \n. ([a] . [a]) . [[a]] . [[a]] prod ' xss hzss = prod xss h++ zss f ' :: [a] . (([a] . [a]) . [[a]]) . \n([a] . [a]) . [[a]] . [[a]] f ' xs c ' hzss = f xs ch ++ zss Now we can calculate, prod ' [] hzss = h[]: \nzss prod ' (xs : xss) hzss = f xs (prod xss) h++ zss = f ' xs (prod ' xss) hzss f ' [] c ' hzss = zss \nf ' (x : xs) c ' hzss = c (h\u00b7 (x:)) ++ f xs ch ++ zss ' '' = c (h\u00b7 (x:)) (f xs chzss). In theend,thisapparentlycircularderivationisjusti.edbyinduc\u00adtion \non the list structure of the input. We have thus derived the recursivede.nition, prod ' [] hzss = h[]: \nzss ' '' prod (xs : xss) hzss = f xs (prod xss) hzss where f ' [] c ' hzss = zss ''' '' f (x : xs) chzss \n= c (h\u00b7 (x:)) (f xs chzss). This version is ready to be expressed in terms of foldr . By writ\u00ading prod \n' = foldr f ' u for a suitable function u, then putting product xss = prod ' xss id [], we obtain product \nxss = foldr f ' u xss id [] (P2 ) where uh zss = h[]: zss f ' xs c ' hzss = foldr gzss xs where gx qss \n= c ' (h\u00b7 (x:)) qss. This version of product gives exactly the same result as Barron and Strachey s program \n(P), but contains only two occurrences of foldr , corresponding to the two levels of list structure in \nthe argument, and uses only inherited attributes. The extra mileage comesfrom our more extensive use \nofhigher-orderfunctions.  6. In conclusion Was Barron and Strachey s Cartesian product function really \nthe .rst everfunctionalpearl?There are, admittedly, still earlierpearls of insight by others that deserve \nto be celebrated: notably the work of Church on lambda-de.nability, of Curry on Combinatory Logic, and \nof McCarthy on Lisp. Nevertheless, the work we have explored in this article is distinctive in its own \nright, for Barron and Strachey were writing explicitly about computer programs as objects of study. They \nexploited the expressive possibilities of a higher-order,purelyfunctional style,both inwriting theCartesian \nproduct function itself, and in using it as part of a larger program for .nding factors. The lectures \nat that 1963 summer school must havebeenbewildering tosomemembersofBarronandStrachey s audience,many \nofthemperhapsbrought up onadiet ofAutocode, and only dimly aware of the new ideas in Lisp and Algol 60. \nYet the lessons that were taught then are still worth learningtoday, over fortyyears later. Acknowledgments \nWe are grateful to the staff of the Bodleian Library in Oxford for theirfriendlyef.ciency,andto theICFP \nreviewersfor theirhelpful comments. References David Barron. 1975. Christopher Strachey: a personal \nreminis\u00adcence. Computer Bulletin,2(5):8 9. David W. Barron and Christopher Strachey. 1966. Program\u00adming. \nInLeslieFox, editor, Advances in Programming and Non-Numerical Computation,pages49 82.PergammonPress. \nOlivier Danvy and Lasse R. Nielsen. 2001. Defunctionaliza\u00adtion at work. In Harald S\u00f8ndergaard, editor, \nProceedings of the Third International ACM SIGPLAN Conference on Prin\u00adciples and Practice of Declarative \nProgramming (PPDP 01), pages 162 174, Firenze, Italy. ACM Press. Extended version availableas theresearch \nreportBRICSRS-01-23. Olivier Danvy and Ulrik P. Schultz. 2000. Lambda-dropping: Transforming recursive \nequations into programs with block structure. Theoretical Computer Science, 248(1-2):243 287. A preliminary \nversion was presented at the 1997 ACM SIG-PLAN Symposium on Partial Evaluation and Semantics-Based ProgramManipulation(PEPM1997). \nMichaelJ.C.Gordon.1973.Aninvestigationoflit.TechnicalRe\u00adportMemorandunMIP-R-101,SchoolofArti.cialIntelligence, \nUniversity ofEdinburgh. Michael J. C. Gordon. 1979. On the power of list iteration. The Computer Journal,22(4):376 \n379. Mike Gordon. 2000. Christopher Strachey: recollections of his in.uence. Higher-Order and Symbolic \nComputation, 13(1/2): 65 67. PatrickGreussay. 1978. Lesyst`eParis\u00ademeVLISP16. Universit\u00b48-Vincennes etLITP. \nDavid Hartley. 2000. Cambridge and CPL in the 1960s. Higher-Order and Symbolic Computation,13(1/2):69 \n70. JohnHughes.1986.Anovel representationoflistsanditsapplica\u00adtion to the function reverse . Information \nProcessing Letters, 22(3):141 144. Thomas Johnsson. 1987. Attribute grammars as a functional programming \nparadigm. In Gilles Kahn, editor, Functional Programming Languages and Computer Architecture, number \n274 in Lecture Notes in Computer Science, pages 154 173, Portland,Oregon.Springer-Verlag. Martin Richards. \n2000. Christopher strachey and the Cambridge CPL compiler. Higher-Order and Symbolic Computation, 13 \n(1/2):85 88. Christopher Strachey. 1961. Handwritten notes. Archive of working papers and correspondence. \nBodleian Library, Oxford, Catalogue no.MS.Eng. misc.b.267.   \n\t\t\t", "proc_id": "1291151", "abstract": "<p>Over forty years ago, David Barron and Christopher Strachey published a startlingly elegant program for the Cartesian product of a list of lists, expressing it with a three nested occurrences of the function we now call <i>foldr</i>. This program is remarkable for its time because of its masterful display of higher-order functions and lexical scope, and we put it forward as possibly the first ever functional pearl. We first characterize it as the result of a sequence of program transformations, and then apply similar transformations to a program for the classical power set example. We also show that using a higher-order representation of lists allows a definition of the Cartesian product function where <i>foldr</i> is nested only twice.</p>", "authors": [{"name": "Olivier Danvy", "author_profile_id": "81100394275", "affiliation": "University of Aarhus, Aarhus, Denmark", "person_id": "PP15031217", "email_address": "", "orcid_id": ""}, {"name": "Michael Spivey", "author_profile_id": "81407592637", "affiliation": "University of Oxford, Oxford, England UK", "person_id": "PP37044113", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/1291151.1291161", "year": "2007", "article_id": "1291161", "conference": "ICFP", "title": "On Barron and Strachey's cartesian product function", "url": "http://dl.acm.org/citation.cfm?id=1291161"}