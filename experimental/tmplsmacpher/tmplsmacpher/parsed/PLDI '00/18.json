{"article_publication_date": "05-01-2000", "fulltext": "\n Type-Based Race Detection for Java Cormac Flanagan Stephen N. Freund* Compaq Systems Research Center \nDepartment of Computer Science 130 Lytton Ave. Stanford University Palo Alto, CA 94301 Stanford, CA 94305-9045 \ncormac.flanagan@compaq.com freunds@cs.stanford.edu Abstract This paper presents a static race detection \nanalysis for multithreaded Java programs. Our analysis is based on a formal type system that is capable \nof captur\u00ading many common synchronization patterns. These patterns include classes with internal synchronization, \nclasses that require client-side synchronization, and thread-local classes. Experience checking over \n40,000 lines of Java code with the type system demonstrates that it is an e.ective approach for eliminating \nraces con\u00additions. On large examples, fewer than 20 additional type annotations per 1000 lines of code \nwere required by the type checker, and we found a number of races in the standard Java libraries and \nother test programs. Introduction Race conditions are common, insidious errors in multi\u00adthreaded programs. \nA race condition occurs when two threads manipulate a shared data structure simultane\u00adously, without \nsynchronization. Race conditions often result in unexpected program behavior, such as pro\u00adgram crashes \nor incorrect results. They can be avoided by careful programming discipline: protecting each data structure \nwith a lock and acquiring that lock before manipulating the data structure [Bir89]. Since a lock can \nbe held by at most one thread at any time, careful adherence to this lock-based synchronization discipline \nensures a race-free program. Current programming tools provide little support for this synchronization \ndiscipline. It is easy to write a * This work was completed while the author was employed at the Compaq \nSystems Research Center. Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, or republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. PLDI 2000, Vancouver, British Columbia, Canada. Copyright 2000 ACM 1-58113-199-2/00/0006. \n. . $5.00. program that, by mistake, neglects to perform certain crucial synchronization operations. \nThese synchroniza\u00adtion errors are not detected by traditional compile-time checks. Furthermore, because \nthe resulting race condi\u00adtions are scheduler dependent, they are di.cult to catch using testing techniques. \nA single synchronization error in an otherwise correct program may yield a race condi\u00adtion whose cause \nmay take weeks to identify [SBN+97]. This paper investigates a static analysis system for detecting race \nconditions in Java programs. The anal\u00adysis supports the lock-based synchronization discipline by tracking \nthe protecting lock for each shared .eld in the program and verifying that the appropriate lock is held \nwhenever a shared .eld is accessed. We express the reasoning and checks performed by this analysis as \nan extension of Java s type system. This work builds on an earlier paper that describes a race-free type \nsystem for a concurrent object calcu\u00adlus [FA99a]. We start by adapting that type system to a core subset \nof Java. This initial type system is suf\u00ad.cient to verify some example programs as race free. In order \nto accommodate larger, more realistic, multi\u00adthreaded programs, we extend the initial type system with \na number of additional features. These features include: 1. classes parameterized by locks, which allow \nthe .elds of a class to be protected by some lock ex\u00adternal to the class; 2. the notion of objects that \nare local to a particu\u00adlar thread and therefore safely accessible without synchronization; and 3. mechanisms \nfor escaping the type system in places where it proves too restrictive, or where a partic\u00adular race condition \nis considered benign.  To evaluate the utility of the resulting type sys\u00adtem, we implemented a type \nchecker and tested it on a variety of Java programs totaling over 40,000 lines of code. These programs \ninclude the standard Java in\u00adput/output package java.io; an interpreter for the web scripting language \nWebL; and Ambit, a mobile object calculus implementation. Checking these programs using our type system \nre\u00adquires adding some additional type annotations. This annotation burden is not excessive; typically \nfewer than 20 annotations were required per 1000 lines of code. Most of the annotations were inserted \nbased on feedback from the type checker. This annotation process proceeded at a rate of roughly 1000 \nlines of code per programmer-hour. During this process, we discovered a number of race conditions in \nthe pro\u00adgrams being checked, including one race condition in java.util.Vector,four in the java.io package, \nand .ve in the WebL implementation. Although it is far from complete, the type system proved su.ciently \nex\u00adpressive to accommodate the majority of synchroniza\u00adtion patterns present in these programs. The presentation \nof our results proceeds as follows. Section 2 introduces a small concurrent subset of Java, which we \nuse to provide a formal description of our type system. Section 3 describes an initial race-free type \nsystem. We extend the system to include classes parameterized by locks in Section 4 and thread-local \nclasses in Section 5. Section 6 describes our prototype implementation, including the escape mechanisms. \nSec\u00adtion 7 discusses our experiences checking several Java programs. We relate this work to other projects \nin Sec\u00adtion 8, and we conclude in Section 9. The Appendix contains a formal description of the type system. \n2 A Multithreaded Subset of Java This section introduces a small multithreaded subset of Java, ConcurrentJava. \nThis language is derived from ClassicJava [FKF98], a sequential subset of Java, and we adopt much of \nthe type structure and semantics of ClassicJava. 2.1 Syntax and Informal Semantics ConcurrentJava supports \nmultithreaded programs by including the operation fork e which spawns a new thread for the evaluation \nof e. This evaluation is per\u00adformed only for its e.ect; the result of e is never used. Locks are provided \nfor thread synchronization: each ob\u00adject has an associated lock that has two states, locked and unlocked, \nand is initially unlocked. The expression synchronized e1 in e2 is evaluated in a manner similar to Java \ns synchronized statement: the subexpression e1 is evaluated .rst, and should yield an object, whose lock \nis then acquired; the subexpression e2 is then eval\u00aduated; and .nally the lock is released. The result \nof e2 is returned as the result of the synchronized expression. While evaluating e2, the current thread \nis said to hold P ::= defn* e (program) defn ::= class cn body (class decl) body ::= extends c { .eld* \nmeth* } (class body) .eld ::= [final]opt tfd = e (.eld decl) meth ::= tmn(arg *) { e } (method decl) \narg ::= tx (variable decl) s, t ::= c | int (type) c ::= cn | Object (class type) e ::= new c (allocate) \n| x (variable) | e.fd (.eld access) | e.fd = e (.eld update) | e.mn(e *) (method call) | let arg = e \nin e (variable binding) | synchronized e in e (synchronization) | fork e (fork) cn . class names fd . \n.eld names mn . method names x, y . variable names Figure 1: The grammar for ConcurrentJava. the lock. \nAny other thread that attempts to acquire the lock blocks until the lock is released. A newly forked \nthread does not inherit locks held by its parent thread. The syntax of the synchronized and fork expres\u00adsions \nand the rest of ConcurrentJava is shown in Figure 1. A program is a sequence of class de.nitions together \nwith an initial expression, which is the starting point for the program s execution. Each class de.nition \nassociates a class name with a class body consisting of a super class, a sequence of .eld declarations, \nand a sequence of method declarations. A .eld declaration includes an initialization expression and an \noptional final modi.er; if this modi.er is present, then the .eld cannot be updated after initialization. \nA method dec\u00adlaration consists of the method name, its return type, number and types of its arguments, \nand an expression for the method body. Types include class types and integers. Class types include class \nnames introduced by the program, as well as the prede.ned class Object, which serves as the root of the \nclass hierarchy. Expres\u00adsions include the typical operations for object alloca\u00adtion, .eld access and \nupdate, method invocation, and variable binding and reference, as well as the concur\u00adrency primitives. \n 2.2 Locks Against Races We present example programs in an extended language with integer and boolean \nconstants and operations, and the constant null.We use e1; e2 to abbreviate let x = e1 in e2,where xdoes \nnot occur free in e2,and we sometimes enclose expressions in braces for clarity. Multithreaded ConcurrentJava \nprograms are prone to race conditions, as illustrated by the follow\u00ading program, which allocates a new \nbank account, and makes two deposits into the account in parallel: class Account { int balance = 0 int \ndeposit (int x) { this.balance = this.balance +x } } let Account a = new Account in {fork { a.deposit(10) \n}fork { a.deposit(10) } } The program may exhibit unexpected behavior. In par\u00adticular, if the two calls \nto deposit are interleaved, the .nal value of balance may re.ect only one of the two deposits made to \nthe account, which is clearly not the intended behavior of the program. Thus, the program contains a \nrace condition: two threads attempt to ma\u00adnipulate the .eld balance simultaneously, with incor\u00adrect results. \nWe can .x this error by protecting the .eld balance by the lock of the account object and only accessing \nor updating balance when that lock is held: class Account { int balance = 0 int deposit(int x) { synchronized \nthis in { this.balance = this.balance +x } } } The modi.ed account implementation is race free and will \nbehave correctly even when multiple deposits are made to the account concurrently. 3Types Against Races \nIn practice, race conditions are commonly avoided by the lock-based synchronization discipline used in \nthe ex\u00adample above. This section presents a type system that supports this programming discipline. The \ntype system needs to verify that each .eld has an associated pro\u00adtecting lock that is held whenever the \n.eld is accessed or updated. In order to verify this property, the type system: 1. associates a protecting \nlock with each .eld decla\u00adration, and 2. tracks the set of locks held at each program point.  We rely \non the programmer to aid the veri.cation process by providing a small number of additional type annotations. \nThe type annotation guarded by l on a .eld declaration states that the .eld is protected by the lock \nexpression l; the type system then veri.es that this lock is held whenever the .eld is accessed or updated. \nThetypeannotation requires l1,...,ln on a method declaration states that the locks l1,...,ln are held \non method entry; the type system veri.es that these locks are indeed held at each call-site of the method, \nand checks that the method body is race-free given this as\u00adsumption. We extend the syntax of .eld and \nmethod declarations to include these type annotations. .eld ::= [final]opt tfd guarded by l = e meth \n::= tmn(arg *) requires ls { e }ls ::= l* (lock set) l ::= e (lock expression) We refer to the extended \nlanguage as RaceFreeJava. To ensure that each .eld is consistently protected by a particular lock, irrespective \nof any assignments per\u00adformed by the program, the type system requires that the lock expression in a \nguarded by clause be a .nal expression. A .nal expression is either a reference to an immutable variable1, \nor a .eld access e.fd,where e is a .nal expression and fd is a .nal .eld. The type system also requires \nthat the lock expressions in a requires clause be .nal for similar reasons. The core of our type system \nis a set of rules for rea\u00adsoning about the type judgment P; E; ls f e: t. Here, P (the program being \nchecked) is included in the judgment to provide information about class de.nitions in the program; E \nis an environment providing types for the free variables of e; ls is a set of .nal expressions describing \nthe locks that are held when the expression e is evaluated; and t is thetypeof e.Thus, the type rules \ntrack the set of locks held each program point. The rule [exp fork] for fork e checks the expression \ne using the empty lock set since new threads do not inherit locks held by their parent. [exp fork] P \n; E; \u00d8fe : t P ; E; ls ffork e : int 1All variables are immutable in RaceFreeJava, but only .nal vari\u00adables \nare in Java. The rule [exp sync] for synchronized e1 in e2 checks that e1 is a .nal expression of some \nclass type c,and then type checks e2 in an extended lock set that includes e1, re.ecting the fact that \nthe lock e1 is always held when evaluating e2. [exp sync] P ;E f.nal e1 :cP ;E;ls .{e1}fe2 :t P ;E;ls \nfsynchronized e1 in e2 :t The antecedent P ; E f.nal e1 : c checks that e1 is a .nal expression of type \nc. The rule [exp ref] for e.fd checks that e is a well\u00adtyped expression of some class type c and that \nc declares or inherits a .eld fd of type t,guarded by lock l. [exp ref] P ;E;ls fe :c P ;E f([final]opt \ntfd guarded by l = e' ).c P ;E f[e/this]l .ls P ;E f[e/this]t P ;E;ls fe.fd :[e/this]t It remains to \ncheck that the lock l guarding fd is held at this program point; i.e., that l denotes the same lock as \nsome expression l' in the current lock set. This requires checking the semantic equivalence of the two \nexpres\u00adsions l and l', which is in general undecidable. One approach is to conservatively approximate \nse\u00admantic equivalence by syntactic equivalence, and sim\u00adply to check that l = l'. This approximation \nis overly conservative in many cases however. In particular, oc\u00adcurrences of this in the lock expression \nl refer to the object being dereferenced, which is the same object as that denoted by e. To account for \nthe aliasing of this and e, the type system replaces all occurrences of this in l by e, and then checks \nthat [e/this]l = l' for some l' in the current lock set. This check is performed by the antecedent P \n; E f [e/this]l . ls. It is a sound approx\u00adimation of semantic equivalence and has been su.cient for \nall programs we have inspected. A similar aliasing situation arises in the next sec\u00adtion, where we introduce \ntypes containing lock expres\u00adsions. To accommodate this future extension, we in\u00adclude the appropriate \nsubstitutions for types here, and yield [e/this]t as the type of the .eld access after check\u00ading that \nit is a well-formed type. The rule [exp assign] for e.fd = e' ensures that the appropriate lock is held \nwhenever a .eld is updated. The rule [exp invoke] for a method invocation ensures that all locks in the \nrequires clause of a method dec\u00adlaration are held at each call site of the method. [exp assign] P ;E;ls \nfe :c '' ).c P ;E f(tfd guarded by l = eP ;E f[e/this]l .ls P ;E;ls fe' :[e/this]t P ;E;ls fe.fd =e' \n:[e/this]t [exp invoke] P ;E;ls1 fe :c P ;E f(tmn(sj yjj. 1...n ) requires ls2 {e' }).c P ;E;ls1 fej \n:[e/this]sj P ;E f[e/this]ls2 .ls1 P ;E f[e/this]t P ;E;ls1 fe.mn(e1...n ) :[e/this]t The remaining \ntype rules are straightforward and similar to those of ClassicJava.The complete set of type judgments \nand rules is contained in Appendix A. 3.1 Race-Free Bank Accounts We can use this type system to verify \nthat the synchro\u00adnized bank account implementation is race free. We must .rst add a type annotation stating \nthat the .eld balance is guarded by this.When no locks are re\u00adquired to invoke a method we omit its requires \nclause, as we have done for deposit. class Account {int balance guarded by this = 0 int deposit(int x) \n{ synchronized this in {this.balance = this.balance +x } } } let Account a = new Account in { fork { \na.deposit(10) } fork { a.deposit(10) } } An alternative implementation of the bank account may rely \non its clients to perform the necessary syn\u00adchronization operations: class Account { int balance guarded \nby this = 0 int deposit(int x) requires this { this.balance = this.balance +x } } let Account a = new \nAccount in {fork { synchronized a in a.deposit(10) }fork { synchronized a in a.deposit(10) } } In this \nexample, the method signature int deposit(int x) requires this explicates the requirement that the object \ns lock must be acquired before calling deposit. Since the necessary lock is indeed held at each call \nsite, this program is also well typed and race free. 4 External Locks The type system of the previous \nsection can verify the absence of races in a number of interesting ex\u00adamples. However, larger, more realistic \nprograms fre\u00adquently use a variety of synchronization patterns, some of which cannot be captured by the \nsystem presented so far. To accomodate such programs, we extend the RaceFreeJava type system with additional \nfeatures. This section presents classes parameterized by locks, and Section 5 introduces thread-local \nclasses. The type system requires that every .eld be guarded by a .nal expression of the form x.fd1.\u00b7\u00b7\u00b7.fd.Since \nn the only variable in scope at a .eld declaration is this, the .elds of an object must be protected \nby a lock that is accessible from the object. In some cases, however, we would like to protect the .elds \nof an object by some lock external to the object. For example, all of the .elds in a linked list might \nnaturally be protected by some object external to the list. To accommodate this programming pattern, \nwe ex\u00adtend RaceFreeJava to allow classes to be parameter\u00adized by external locks: defn ::= class cn<garg \n* > body garg ::= ghost tx (ghost decl) c ::= cn<l* > | Object A class de.nition now contains a (possibly \nempty) se\u00adquence of formal parameters or ghost variables.These ghost variables are used by the type system \nto verify that the program is race free; they do not a.ect the run-time behavior of the program. In particular, \nthey can appear only in type annotations and not in regu\u00adlar code. A class type c consists of a class \nname cn parameterized by a sequence of .nal expressions. The number and type of these expressions must \nmatch the formal parameters of the class. Type checking of parameterized classes is handled via substitution. \nIf class cn<ghost t1 x1,...,ghost tn xn> body is a well-formed class de.nition, then for any .nal ex\u00adpressions \nl1,...,ln of the appropriate types, we consider cn<l1,...,ln> to be a valid instantiated class type, \nwith associated instantiated class de.nition class cn<l1,...,ln> [l1/x1,...,ln/xn]body A few modi.cations \nto the type rules are necessary to accommodate parameterized classes. These modi.ca\u00adtions are described \nin Appendix B. 4.1 Using External Locks To illustrate the use of external locks, consider the dic\u00adtionary \nimplementation of Figure 2. A dictionary maps keys to values. In our implementation, a dictionary is \nrepresented as an object containing a linked list of Nodes,where each Node contains a key, a value, and \na next pointer. For e.ciency reasons, we would like to protect the entire dictionary, including its linked \nlist, with the lock of the dictionary. To accomplish this, the class Node is parameterized by the enclosing \ndictionary d;the .elds of Node are guarded by d;and each method of Node requires that d is held on entry. \nEach method of Dictionary .rst acquires the dictionary lock and then proceeds with the appropriate manipulation \nof the linked list. Since all .elds of the linked list are protected by the dictionary lock, the type \nsystem veri.es that this program is well typed and race free. 5 Thread-Local Classes Large multithreaded \nprograms typically have sections of code that operate on data that is not shared across multiple threads. \nFor example, only a single thread in a concurrent web server may need to access the infor\u00admation about \na particular request. Objects used in this fashion require no synchronization and should not need to \nhave locks guarding their .elds. To accommodate this situation, we introduce the concept of thread-local \nclasses. We extend the grammar to allow an optional thread local modi.er on class de.nitions and to make \nthe guarded by clause on .eld declarations optional in a thread-local class: defn ::= [thread local]opt \nclass cn<garg * > body .eld ::= [final]opt tfd [guarded by l]opt = e An example of a thread-local class \nappears in Fig\u00adure 3. The class Crawler is a concurrent web crawler that processes a page by iterating \nover its links and forking new threads to process the linked pages. The LinkEnumerator class, which parses \nthe text of the page to .nd links, is not shared among threads. Therefore, it is declared as a thread \nlocal class and contains un\u00adguarded .elds. A simple form of escape analysis is used to enforce single-threaded \nuse of thread-local objects. A type is thread-shared provided it is not a thread-local class type. The \ntype system must ensure that thread-local objects are not accessible from thread-shared objects. Therefore, \na thread-shared class declaration must (1) have a thread-shared superclass and (2) contain only shareable \n.elds. A .eld is shareable only if it has a thread-shared type and is either .nal or protected by a lock. \nAlso, the free variables of a forked expression must be of a thread-shared type. The rules for thread-shared \ntypes and fork appear in Appendix C. class Node<ghost Dictionary d> { class Dictionary {String key guarded \nby d = null Node<this> head guarded by this = null Object value guarded by d = null Node<d> next guarded \nby d = null void put(String k, Object v) { synchronized this in { void init(String k, Object v, Node<d> \nn) if (this.contains(k)) { requires d { this.head.update(k,v) node.key = k; } else {node.value = v; \nlet Node<this> node = node.next = n new Node<this> in { }node.init(k,v,this.head); void update(String \nk, Object v) requires d { this.head = node if (this.key.equals(k)) {} this.value = v } } else if (this.next \n!= null) {} this.next.update(k,v) } } ... }} ... } Figure 2: A synchronized dictionary. thread local \nclass LinkEnumerator { class Crawler {String text = null final Set visited = new Set int index = 0 void \nprocess(String url) { if (!visited.add(url)) {void init(String t) { let String text = loadPageText(url) \nin this.text = t let LinkEnumerator enum = }new LinkEnumerator in { boolean hasMoreLinks() { ... } enum.init(text); \nString nextLink() { ... } while (enum.hasMoreLinks()) { } let String link = enum.nextLink() in fork \n{ this.process(link) }}}}} ... } let Crawler c = new Crawler in c.process(\"http://www.research.compaq.com\") \nFigure 3: A concurrent web crawler using a thread-local enumeration class. Interestingly, our type system \npermits a thread-local class to have a thread-shared superclass. This design permitsustomaintain Object \n(which is thread-shared) as the root of the class hierarchy, as it is in Java. How\u00adever, it also permits \na thread-local object to be viewed as an instance of a thread-shared class and hence to be shared between \nthreads. This sharing does not cause a problem unless the object is downcast back to the thread-local \ntype in a thread other than the one in which it was created. This downcast would make un\u00adguarded .elds \nin the subclass visible to more than one thread. To eliminate this possibility, our type system forbids \ndowncasts from a thread-shared type to a thread-local type. This restriction applies to explicit cast \nopera\u00adtions2 and, also, to the implicit downcasts that occur during dynamic dispatch. To avoid such implicit \ndown\u00adcasts, our type system requires a thread-local class not to override any methods declared in a thread-shared \nsuperclass. Alternatively, if these static requirements are too re\u00adstrictive, a compiler could insert \ncode to track the al\u00adlocating thread of each object and dynamically check that thread-shared to thread-local \ndowncasts are only performed by the appropriate thread. 6 Implementation We have implemented the RaceFreeJava \ntype system for the full Java language [GJS96]. This race condition checker, rccjava, extends the type \nsystem outlined so far with the missing Java features, including arrays, in\u00adterfaces, constructors, static \n.elds and methods, inner classes, and so on. Only thread-local arrays posed any technical challenges, \nbut space considerations prohibit a full discussion of those challenges here. The additional type information \nrequired by rccjava is embedded in Java comments to preserve compatibility with existing Java tools, \nsuch as compil\u00aders. Speci.cally, comments that start with the charac\u00adter # are treated as type annotations \nby rccjava.See Figure 5 for an example. The rccjava tool was built on top of an existing Java front-end \nthat includes a scanner, parser, and type checker. The extensions for race detection were rela\u00adtively \nstraightforward to add to the existing code base and required approximately 5,000 lines of new code. \nThe major additions were maintaining the lock set dur\u00ading type checking, implementing syntactic equality \nand substitution on abstract syntax trees, and incorporating classes parameterized by locks. 2RaceFreeJava \ndoes not contain explicit casts, but the Java lan\u00adguage does. An important goal in the design of rccjava \nwas to provide a cost-e.ective way to detect race conditions statically. Thus, it was important to minimize \nboth the number of annotations required and the number of false alarms produced. In order to attain this \ngoal, rccjava was designed tobeable torelax theformal typesystem in several ways and, also, to infer \ndefault annotations for unannotated code. These features are described below. 6.1 Escape mechanisms Rccjava \nprovides mechanisms for escaping from the type system when it proves too restrictive. The simplest escape \nmechanism is the no warn annotation, which turns o. certain kinds of warnings on a particular line of \ncode, e.g. f.a = 3; //# no warn race This annotation is commonly used if a particular race condition \nis considered benign. Also, rccjava may be con.gured with a command line .ag to ignore all errors of \na particular kind. For example, the -no warn thread local override .ag turns o. the restrictions whereby \na thread-local class cannot override a method of its thread-shared super\u00adclass. The holds annotation \nasserts that a particular lock is held at a given program point: //# holds f f.a=3; This annotation puts \nf into the lock set for the remain\u00adder of block of statements in which it appears. As with the no warn \nannotations, rccjava may be con.gured to make global assumptions about when locks are held. For instance, \nwhen run with the command line .ag -constructor holds lock , rccjava assumes that the lock this is held \nin constructors. This is sound as long as references to this are not passed to other threads before the \nconstructor call returns. Violations of this assumption are unlikely, and using it eliminates a large \nnumber spurious warnings.  6.2 Default Annotations Although type inference for the rccjava type system \nre\u00admains for future work, rccjava does construct default annotations for unannotated classes and .elds. \nThe heuristics used to compute default annotations are: A class with no annotations and no synchro\u00adnized \nmethods is thread local by default, unless the class is java.lang.Object or a subclass of java.lang.Thread. \n Unguarded non-.nal instance .elds in thread shared classes are guarded by this.  Unguarded non-.nal \nstatic .elds are guarded by the class object for the class to which they belong.  A guarded by annotation \nis permitted on a class declaration, and it applies to all .elds of the class.  These heuristics are \nnot guaranteed to produce the cor\u00adrect annotations, but experience has shown that they save a signi.cant \namount of time while annotating large programs. Roughly 90% of the classes in the test pro\u00adgrams described \nbelow are treated correctly by these heuristics. Evaluation To test the e.ectiveness of rccjava as a \nstatic race de\u00adtection tool, we used it to check several multithreaded Java programs. Our test cases \ninclude two rep\u00adresentative single classes, java.util.Hashtable and java.util.Vector, and several large \nprograms, includ\u00ading java.io, the Java input/output package (version 1.1) [Jav98]; Ambit, an implementation \nof a mobile ob\u00adject calculus [Car97]; and an interpreter and run-time environment for WebL, a language \nfor automating web\u00adbased tasks [KM98]. These .ve programs use a variety of synchroniza\u00adtion patterns, \nmost of which were captured easily with rccjava annotations. Rccjava was run with the com\u00admand line .ags \n-no warn thread local override and -constructor holds lock for these tests (see Section 6.1). Although \nthese .ags may cause rccjava to miss some potential races, they signi.cantly reduce the number of false \nalarms reported and provide the most e.ective way to deal with existing programs that were not written \nwith this type system in mind. Table 1 summarizes our experience in checking these programs. It shows \nthe number of annotations and time required to annotate each program, as well as the number of race conditions \nfound in each program. The time includes both the time spent by the programmer inserting anno\u00adtations \nand the time to run the tool. Figure 4 breaks down the annotation count into the di.erent categories \nof annotations, normalized to the frequency with which they appear in 1000 lines of code. For the large \nprograms, fewer than 20 annotations were required per 1000 lines. Most of these annotations were clustered \nin the small number of classes manipulated from di.erent threads. The majority of classes typi\u00adcally \nrequired very few or no annotations. Evidence of this pattern is re.ected in the statistics for the sin\u00adgle \nclass examples, which have higher annotation fre\u00adquencies than the larger programs. Hashtable has a high \noccurrence of annotations concerning class param\u00adeters and arguments because it contains a linked list \nsimilar to that of Figure 2. Interestingly, restructur\u00ading Hashtable to declare the linked list as an \ninner class within the scope of the protecting lock reduces the number of annotations to 25.    We \ndiscovered race conditions in three of the .ve case studies, despite most of the code in these examples \nbeing well tested and relatively mature. Of the four races found in java.io,one was .xed in JDK version \n1.2. We also found benign race conditions in all test cases. Figure 5 contains an excerpt from java.util.Vector \nthat illustrates a typical race condition caught during our experiments. Suppose that there are two threads \nmanipulating a shared Vector object. If one thread calls lastIndexOf(elem) for some elem, that method \nmay access elementCount without acquiring the lock of the Vector object. How\u00adever, the other thread may \ncall removeAllElements (which sets elementCount to 0) and then call trimToSize (which resets elementData \nto an array of length 0). Thus, an array out of bounds exception will be triggered when the .rst thread \nenters the binary version of lastIndexOf and accesses the elementData array based on the old value of \nelementCount. Declar\u00ading both versions of lastIndexOf to be synchronized removes this race condition. \n8 Related Work A number of tools have been developed for detecting race conditions, both statically and \ndynamically. War\u00adlock [Ste93] is a static race detection system for ANSI C programs. It supports the \nlock-based synchronization discipline through annotations similar to ours. How\u00adever, Warlock uses a di.erent \nanalysis mechanism; it works by tracing execution paths through the program, but it fails to trace paths \nthrough loops or recursive function calls, and thus may not detect certain races. In addition, Warlock \nassumes, but does not verify, the thread-local annotations introduced by the program\u00admer. However, these \nsoundness issues have not pre\u00advented Warlock from being a practical tool. It has been used to catch races \nin several programs, including an X-windows library. The extended static checker for Java (Esc/Java) \nis a tool for static detection of software defects [LSS99, DLNS98]. It uses an underlying automatic theorem \nprover to reason about the program s behavior and to verify the absence of certain kinds of errors, such \nas null dereferences and index out of bounds errors. ESC/Java supports multithreaded programming via \nannotations similar to our guarded by and requires clauses, and  Program Lines Of Code Programmer Time \n(hrs) Annotations Races Found java.util.Hashtable java.util.Vector java.io.* Ambit WebL 440 430 16,000 \n4,500 20,000 0.5 0.5 16.0 4.0 12.0 60 10 139 38 358 0 1 4 0 5 Table 1: Programs analyzed using rccjava. \njava.util.Hashtable java.util.Vector java.io.* Ambit . . WebL 79.5 136          Annotation \nCategory Figure 4: Number of rccjava annotations added to each program. veri.es that the appropriate \nlock is held whenever a guarded .eld is accessed. However, it may still permit race conditions on unguarded \n.elds, since it does not verify that such unguarded .elds only occur in thread\u00adlocal classes. Overall, \nEsc/Java is a complex but pow\u00aderful tool capable of detecting many kinds of errors, whereas rccjava is \na lightweight tool tuned speci.cally for detecting race conditions. Aiken and Gay [AG98] also investigate \nstatic race detection, in the context of SPMD programs. Since synchronization in these programs is performed \nusing barriers, as opposed to locks, their system does not need to track the locks held at each program \npoint or the association between locks the .elds they protect. Their system has been used successfully \non a number of SPMD programs. Eraser is a tool for detecting race conditions and deadlocks dynamically \n[SBN+97], rather than statically. This approach has the advantage of being able to check unannotated \nprograms, but it may fail to detect certain errors because of insu.cient test coverage. A variety of \nother approaches have been developed for race and deadlock prevention; they are discussed in more detail \nin an earlier paper [FA99b]. A number of formal calculi for Java have been pre\u00adsented in recent literature. \nThese include attempts to model the entire Java language [DE97, Sym97, NvO98] and, also, smaller systems \ndesigned to study speci.c features and extensions [IPW99]. We chose to use the ClassicJava calculus of \nFlatt, Krishnamurthi, and Felleisen [FKF98] as the starting point for our study. There have been many \nsuggested language ex\u00adtensions for supporting Java classes parameterized by types [OW97, BOSW98, AFM97, \nBLM96, CJ98].   class Vector {Object elementData[] /*# guarded by this */; int elementCount /*# guarded \nby this */; synchronized void trimToSize() { ... }synchronized boolean removeAllElements() { ... } synchronized \nint lastIndexOf(Object elem, int n) {for (int i=n;--i >= 0 ; ) if (elem.equals(elementData[i])) { ... \n}} int lastIndexOf(Object elem) {return lastIndexOf(elem, elementCount); // race!!! } ... } Figure 5: \nExcerpt from java.util.Vector. Our work uses a di.erent notion of parameterization, Because the type \nsystem is modular, it enables race namely, classes parameterized by values (more specif-conditions to \nbe detected early in the development cy\u00adically, lock expressions). Apart from this distinction, cle, \nbefore the entire program has been written. The our class parameterization approach most closely fol-type \nsystem does require the programmer to write ad\u00adlows that of GJ [BOSW98], in that information about ditional \ntype annotations, but these annotations also class parameters is not preserved at run time. function \nas documentation of the locking strategies used The lock sets used in our type systems are similar to \nby the program. e.ects [JG91, LG88, Nie96] since the locks held on entry To reduce the annotation overhead \nfurther, we are to an expression constrain the e.ects that it may pro-currently studying the issue of \ntype inference. We are duce. It may be possible to adapt existing techniques also considering rccjava \nextensions to support addi\u00adfor e.ect reconstruction [TT94, TT97, ANN97, TJ92] tional synchronization \npatterns. These extensions may to our setting to reduce the number of type annotations include methods \nparameterized by locks and support required. for reader-writer locks. Our type system veri.es that objects \nof a Availability: We intend to make the rccjava pro\u00ad thread local type are never shared between threads. \ntotype implementation available for download from Much work has been done on the related problem http://www.research.compaq.com. \nof inferring which objects are not shared between threads [CGS+99, Bla99, BH99, WR99, ACSE99]. This Acknowledgments: \nThanks to John Mitchell for com\u00adwork has primarily focused on optimizing synchroniza\u00adments on an earlier \ndraft of this paper, and to Hannes tion operations, but it may be possible to adapt this Marais and Mart\u00b4in \nAbadi for several useful discussions. work to reduce or eliminate the need for thread local annotations. \nReferences [ACSE99] Jonathan Aldrich, Craig Chambers, Emin Gun Sirer, Conclusions and Future Work and \nSusan Eggers.Static analyses for eliminating un\u00adnecessary synchronization from Java programs.In Race \nconditions are di.cult to catch using traditional Proceedings of the Sixth International Static Analy\u00adsis \nSymposium, September 1999. testing techniques. They persist even in common, rel\u00ad atively mature Java \nprograms. In this paper, we have [AFM97] Ole Agesen, Stephen N.Freund, and John C. Mitchell.Adding type \nparameterization to the Java presented a type system for catching race conditions language.In Proceedings \nof ACM Conference on Ob\u00adstatically and described rccjava, an implementation of ject Oriented Languages \nand Systems, October 1997. this system for Java. Our experience with rccjava in-[AG98] Alexander Aiken \nand David Gay.Barrier inference. dicates that this technique is a promising approach for In Proceedings \nof the 25th Symposium on Principles of Programming Languages, pages 243 354, 1998. building more reliable \nmultithreaded software.  [KM98] Thomas Kistler and Johannes Marais.WebL a pro\u00adgramming language for \nthe web. Computer Networks and ISDN Systems, 30:259 270, April 1998. [LG88] John M.Lucassen and David \nK.Gi.ord.Polymorphic e.ect systems.In Proceedings of the ACM Conference on Lisp and Functional Programming, \npages 47 57, 1988. [LSS99] K.Rustan M.Leino, James B.Saxe, and Raymie Stata.Checking Java programs via \nguarded com\u00admands.Technical Report 1999-002, Compaq Systems Research Center, Palo Alto, CA, May 1999.Also \nappeared in Formal Techniques for Java Programs, workshop proceedings.Bart Jacobs, Gary T.Leav\u00adens, Peter \nMuller, and Arnd Poetzsch-He.ter, editors. Technical Report 251, Fernuniversitat Hagen, 1999. [Nie96] \nFlemming Nielson.Annotated type and e.ect sys\u00adtems. ACM Computing Surveys, 28(2):344 345, 1996. Invited \nposition statement for the Symposium on Models of Programming Languages and Computa\u00adtion. [NvO98] Tobias \nNipkow and David von Oheimb.Javalight is type-safe -de.nitely.In Proc. 25th ACM Symposium on Principles \nof Programming Languages,January 1998. [OW97] Martin Odersky and Philip Wadler.Pizza into Java: Translating \ntheory into practice.In Proc. 24th ACM Symposium on Principles of Programming Languages, January 1997. \n[SBN+97] Stefan Savage, Michael Burrows, Greg Nelson, Patrick Sobalvarro, and Thomas E.Anderson.Eraser: \nA dynamic data race detector for multi-threaded pro\u00adgrams. ACM Transactions on Computer Systems, 15(4):391 \n411, 1997. [Ste93] Nicholas Sterling.Warlock: A static data race anal\u00adysis tool.In USENIX Winter Technical \nConference, pages 97 106, 1993. [Sym97] Don Syme.Proving Java type soundness.Techni\u00adcal Report 427, University \nof Cambridge Computer Laboratory Technical Report, 1997. [TJ92] Jean-Pierre Talpin and Pierre Jouvelot.Polymorphic \ntype, region and e.ect inference. Journal of Func\u00adtional Programming, 2(3):245 271, 1992. [TT94] Mads \nTofte and Jean-Pierre Talpin.Implementation of the typed call-by-value lambda-calculus using a stack \nof regions.In Proceedings of the 21st Sympo\u00adsium on Principles of Programming Languages, pages 188 201, \n1994. [TT97] Mads Tofte and Jean-Pierre Talpin.Region-based memory management. Information and Computa\u00adtion, \n132(2):109 176, 1997. [WR99] John Whaley and Martin Rinard.Compositional pointer and escape analysis \nfor Java programs.In Proceedings of ACM Conference on Object Oriented Languages and Systems, November \n1999. [ANN97] [BH99] [Bir89] [Bla99] [BLM96] Torben Amtoft, Flemming Nielson, and Hanne Riis Nielson.Type \nand behaviour reconstruction for higher-order concurrent programs. Journal of Func\u00adtional Programming, \n7(3):321 347, 1997. Je. Bogda and Urs H\u00a8olzle.Removing unnecessary synchronization in Java.In Proceedings \nof ACM Con\u00adference on Object Oriented Languages and Systems, November 1999. Andrew D.Birrell.An introduction \nto programming with threads.Research Report 35, Digital Equipment Corporation Systems Research Center, \n1989. Bruno Blanchet.Escape analysis for object-oriented languages.Application to Java. In Proceedings \nof ACM Conference on Object Oriented Languages and Systems, November 1999. J.Bank, B.Liskov, and A.Myers. \nParameterized Types and Java.Technical Report MIT/LCS/TM\u00ad553, Massachussetts Institute of Technology, \n1996. [BOSW98] Gilad Bracha, Martin Odersky, David Stoutamire, [Car97] [CGS+99] [CJ98] [DE97] [DLNS98] \n[FA99a] [FA99b] [FKF98] [GJS96] [IPW99] [Jav98] [JG91] and Philip Wadler.Making the future safe for the \npast: Adding genericity to the Java programming lan\u00adguage.In Proceedings of ACM Conference on Object \nOriented Languages and Systems, October 1998. Luca Cardelli.Mobile ambient synchronization.Tech\u00adnical \nReport 1997-013, Digital Systems Research Cen\u00adter, Palo Alto, CA, July 1997. J.D.Choi, M.Gupta, M.Serrano, \nV.C.Sreedhar, and S.Midki.. Escape analysis for Java. In Proceedings of ACM Conference on Object Oriented \nLanguages and Systems, November 1999. Robert Cartwright and Guy L.Steele Jr.Compatible genericity with \nrun-time types for the Java program\u00adming language.In Proceedings of ACM Conference on Object Oriented \nLanguages and Systems, October 1998. S.Drossopoulou and S.Eisenbach. Java is type safe probably.In European \nConference On Object Ori\u00adented Programming, pages 389 418, 1997. David L.Detlefs, K.Rustan M.Leino, Greg \nNelson, and James B.Saxe. Extended static checking. Re\u00adsearch Report 159, Compaq Systems Research Cen\u00adter, \n130 Lytton Ave., Palo Alto, CA 94301, USA, December 1998. Cormac Flanagan and Mart\u00b4in Abadi.Object types \nagainst races.In Proceedings of CONCUR, August 1999. Cormac Flanagan and Mart\u00b4in Abadi.Types for safe \nlocking.In Proceedings of European Symposium on Programming, March 1999. Matthew Flatt, Shriram Krishnamurthi, \nand Matthias Felleisen.Classes and mixins.In Proc. 25th ACM Symposium on Principles of Programming Languages, \npages 171 183, January 1998. James Gosling, Bill Joy, and Guy Steele. The Java Language Speci.cation.Addison-Wesley, \n1996. Atsushi Igarishi, Benjamin Pierce, and Philip Wadler. Featherweight Java: A minimal core calculus \nfor Java and GJ.In Proceedings of ACM Conference on Object Oriented Languages and Systems, November 1999. \n JavaSoft.Java Developers Kit, version 1. 1.http://java.sun.com, 1998. Pierre Jouvelot and David Gi.ord.Algebraic \nrecon\u00adstruction of types and e.ects.In Proceedings of the 18th Symposium on Principles of Programming \nLan\u00adguages, pages 303 310, 1991. A The Initial Type System This appendix presents the type system described \nin Section 3. We introduce class parameters and thread-local classes in Appendices B and C, respectively. \nWe .rst de.ne a number of predicates used in the type system informally. These predicates are based on \nsimilar predicates from [FKF98], and we refer the reader to that paper for their precise formulation. \nPredicate Meaning ClassOnce(P) no class is declared twice in P WFClasses(P) there are no cycles in the \nclass hierarchy FieldsOnce(P) no class contains two .elds with the same name, either declared or inherited \nMethodsOncePerClass(P) no method name appears more than once per class OverridesOK(P) overriding methods \nhave the same return type, parameter types, and requires set as the method being overridden A typing \nenvironment is de.ned as E ::= \u00d8|E, arg We de.ne the type system using the following judgments. Judgment \nMeaning fP : t program P yields type t P fdefn defn is a well-formed class de.nition P; E fwf E is a \nwell-formed typing environment P; E fmeth meth is a well-formed method P; E f.eld .eld is a well-formed \n.eld P; E ft t is a well-formed type P; E fs<: t s is a subtype of t P; E fdefn defn is a class de.ned \nin P P; E f.eld .c class c declares/inherits .eld P; E fmeth .c class c declares/inherits meth P; E f.nal \nl : t l is a .nal expression with type t P; E fls ls is a well-formed lock set P; E fl .ls l appears \nin ls P; E fls1 .ls2 lock set ls1 is contained in ls2 P; E; ls fe: t expression e has type t The typing \nrules for these judgments are presented below. fP : t P fdefn [prog] [class] ClassOnce(P) WFClasses(P) \nE = cn this FieldsOnce(P) MethodsOncePerClass(P) P; E Ic OverridesOK(P) P; E I.eldi P; E Imethi P = \ndefn1...n eP Idefni P; \u00d8; \u00d8Ie: t P fclass cn extends c {.eld1...j meth1...k} fP : t P; E fwf P; E fdefn \n[env empty][env x][class definition] P; E Itx .Dom(E) P; E Iwf class c ... .P P; \u00d8fwf P; E,tx fwf P; \nE fclass c ... P; E ftP; E ft1 <: t2 [type c][type Object][type int][subtype refl][subtype class] P; \nE Iclass c ... P; E Iwf P; E Iwf P; E ItP; E Ic1 <: c2 P; E fcP; E fObject P; E fint P; E ft<: t P; E \nIclass c2 extends c3 ... P; E fc1 <: c3 P; E f.eld .cP; E f.eld .c [field][field declared][field inherited] \n' P; E Ifinal l : cP; E Iclass c ... { ... .eld ... } P; E Iclass c extends c... ' P; E; \u00d8Ie: t P; \nE f.eld .c P; E I.eld .cP; E f[final]opt tfd guarded by l = e P; E f.eld .c P ; E f method P ; E f meth \n. c [method] [method declared] [method inherited] P;E It P;E Ils P;E Iclass c ... { .. . meth ... } P;E \nIclass c extends c ' ... ' P;E, arg1...n ;ls Ie :t P ; E f meth . c P;E Imeth .c P ; E f tmn(arg1...n \n) requires ls {e } P ; E f meth . c P ; E f.nal e : t P ; E f ls [lock set][final var][final ref] P;E \nIwf P;E Iwf P;E Ifinal e :c ' .l .ls. .c. P;E Ifinal l :c E =E1, tx,E2 P;E I(final tfd guarded by l \n= e ).c P ; E f lsP ; E f.nal x : tP ; E f.nal e.fd : t P ; E f l . ls P ; E f ls1 . ls2 [lock set elem] \nl .ls P;E Ils P ; E f l . ls [lock set subset] P;E Ils1 P;E Ils2 P ; E f ls1 . ls2 ls1 .ls2 P ; E f \ne : t [exp sub][exp new][exp var] P;E;ls Ie :sP;E Is<:tP;E Ils P;E IcP;E Ils E =E1, tx,E2 P ; E; ls \nf e : tP ; E; ls f new c : cP ; E; ls f x : t [exp ref][exp assign] P;E;ls Ie :cP;E;ls Ie :c '' ' P;E \nI([final]opt tfd guarded by l = e ).cP;E I(tfd guarded by l = e ).c P;E I[e/this]l .ls P;E I[e/this]l \n.ls ' P;E I[e/this]tP;E;ls Ie :[e/this]t ' P ; E; ls f e.fd :[e/this]tP ; E; ls f e.fd = e :[e/this]t \n[exp invoke][exp let] P;E;ls1 Ie :cP;E;ls Ie1 :t j .1...n ' P;E, tx;ls Ie2 :s P;E;ls1 Iej :[e/this]sj \nP;E I[e1/x]s P;E I[e/this]ls2 .ls1 P ; E; ls f let tx = e1 in e2 :[e1/x]s P;E I[e/this]t P ; E; ls1 f \ne.mn(e1...n ) :[e/this]t P;E I(tmn(sj yj ) requires ls2 {e }).c [exp sync][exp fork] P;E Ifinal e1 :cP;E;ls \n.{e1}Ie2 :tP;E Ils P;E;\u00d8Ie :t P ; E; ls f synchronized e1 in e2 : tP ; E; ls f fork e : int B Parameterized \nClasses This section extends the type system with classes parameterized by lock expressions. We extend \ntyping environments to include ghost variables: E ::= \u00d8|E, arg |E, garg An instantiated class de.nition \nhas the form: ci ::= class c extends c {.eld* meth* } There is one new judgment form. Judgment Meaning \nP ; E f ci ci is a valid instantiated class de.nition for P We rede.ne well-typed classes to include \nghost parameters, and we also introduce new rules for constructing environments and instantiating parameterized \nclasses. Rules that have subscripts in their names, such as [class2], replace earlier rules of the same \nname. Rules that do not have subscripts are used in addition to the previous rules. P; E f wf P; E f.nal \ne : t [env ghost][class2] [final var2] P; \u00d8Iti P; E It P; E Iwf gargi = ghost ti xi x.Dom(E) E = E1,[ghost]opt \ntx,E2 = garg1...n ,cn<x1...n > this P; E Ic E P; E,ghost tx f wf P; E f.nal x : t P; E I.eldi P; E Imethi \nP Iclass cn<garg1...n > extends c {.eld1...j meth1...k} [class instantiation] P; E f ci class cn<ghost \nti x i.1...n i > body .P P; E Ifinal li : si P; E Isi <: ti P; E f class cn<l1...n > [li /x i.1...n i \n]body C Thread-Local Classes This section extends the type system with thread-local classes. The following \njudgments are added to the system: P f defn Judgment Meaning P f t shared values of type t can be shared \nbetween threads P f .eld shareable .eld has a thread-shared type and is guarded by a lock or is .nal \nP; E; c f meth meth does not override a method from any thread-shared super type of c The typing rules \nfor these judgments are presented below. Rules [Exp Ref]and [Exp Assign]must also be updated to support \nunguarded .elds. P f t shared [class shared] [Object shared] [int shared] class cn<garg1...n > extends \nc {.eld1...j meth1...k}.P P f cn<x1...n > shared P f Object shared P f int shared P f .eld shareable \n [shareable guarded field] P It shared [shareable final field] P It shared P f [final]opt tfd guarded \nby l = e shareable P f final tfd = e shareable P f defn [class3] P; \u00d8Iti gargi = ghost ti xi E = garg1...n \n,cn<x1...n > this P; E Ic P; E I.eldi P; E Imethi P Ic shared P I.eldi shareable P Iclass cn<garg1...n \n> extends c {.eld1...j meth1...k} P; E; c f meth [local class] P; \u00d8Iti gargi = ghost ti xi E = garg1...n \n,cn<x1...n > this P; E Ic P; E I.eldi P; E Imethi P; E; cImethi  P Ithread local class cn<garg1...n \n> extends c {.eld1...j meth1...k} [override ok] [] ' ' P; E Ic<: c ' .c. ' .P Ic shared .P; E I(... \nmn( ...) requires ...) .c P; E; c f tmn(arg1...n ) requires ls {e } P; E f ci [local class instantiation] \nthread local class cn<ghost ti x i.1...n i > body .P P; E Ifinal li : si P; E Isi <: ti P; E f class \ncn<l1...n > [li /x i.1...n i ]body P; E; ls f e : t [exp fork2] P; E; \u00d8Ie : t .x.FV(e).P IE(x) shared \nP; E; ls f fork e : int 232   \n\t\t\t", "proc_id": "349299", "abstract": "<p> This paper presents a static race detection analysis for multithreaded Java programs. Our analysis is based on a formal type system that is capable of capturing many common synchronization patterns. These patterns include classes with internal synchronization, classes thatrequire client-side synchronization, and thread-local classes. Experience checking over 40,000 lines of Java code with the type system demonstrates that it is an effective approach for eliminating races conditions. On large examples, fewer than 20 additional type annotations per 1000 lines of code were required by the type checker, and we found a number of races in the standard Java libraries and other test programs.</p>", "authors": [{"name": "Cormac Flanagan", "author_profile_id": "81100538763", "affiliation": "Compaq Systems Research Center, 130 Lytton Ave., Palo Alto, CA", "person_id": "PP14187273", "email_address": "", "orcid_id": ""}, {"name": "Stephen N. Freund", "author_profile_id": "81100165065", "affiliation": "Department of Computer Science, Stanford University, Stanford, CA", "person_id": "PP14068105", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/349299.349328", "year": "2000", "article_id": "349328", "conference": "PLDI", "title": "Type-based race detection for Java", "url": "http://dl.acm.org/citation.cfm?id=349328"}