{"article_publication_date": "05-01-2000", "fulltext": "\n SymbolicBoundsAnalysisof Pointers,ArrayIndices,andAccessedMemoryRegions. RaduRuginaandMartinRinard \nLaboratoryforComputerScience MassachusettsInstituteofTechnology Cambridge,MA02139 frugina,rinardg@lcs.mit.edu \nAbstract Thispaperpresentsanovelframeworkforthesymbolic boundsanalysisofpointers,arrayindices,andaccessedmem\u00adoryregions.Ourframeworkformulateseachanalysisprob\u00adlemasasystemofinequalityconstraintsbetweensymbolic \nboundpolynomials.Itthenreducestheconstraintsystem toalinearprogram.Thesolutiontothelinearprogram providessymboliclowerandupperboundsforthevalues \nofpointerandarrayindexvariablesandfortheregionsof memorythateachstatementandprocedureaccesses.This approacheliminatesfundamentalproblemsassociatedwith \napplyingstandardfxed-pointapproachestosymbolicanal\u00adysisproblems.Experimentalresultsfromourimplemented \ncompilershowthattheanalysiscansolveseveralimportant problems,includingstaticracedetection,automaticparal\u00adlelization,staticdetectionofarrayboundsviolations,elimi\u00adnationofarrayboundschecks,andreductionofthenumber \nofbitsusedtostorecomputedvalues. Introduction Thispaperpresentsanewalgorithmforstaticallyextracting informationabouttheregionsofmemorythataprogramac\u00adcesses.Toobtainaccurateinformationforprogramswhose \nmemoryaccesspatternsdependontheinput,ouranalysis issymbolic,derivingpolynomialexpressionsthatboundthe \nrangesofthepointersandarrayindicesusedtoaccessmem\u00adory.Ourprototypecompilerusestheanalysisinformation \ntosolvearangeofproblems,includingautomaticracede\u00adtectionforparallelprograms,automaticparallelizationof \nsequentialprograms,staticdetectionofarrayboundsviola\u00adtions,staticeliminationofarrayboundschecks,and(when \nitispossibletoderiveprecisenumericbounds)automatic computationoftheminimumnumberofbitsrequiredto holdthevaluesthattheprogramcomputes. \nWehaveappliedourtechniquestodivideandconquer programsthataccessdisjointregionsofdynamicallyallo\u00ad .ThisresearchwassupportedinpartbyNSFGrantCCR-9702297. \nWeintendtomaintainafull,updatedversionofthispaperat www.cag.lcs.mit.edu/.rinard/paper/pldi00.updated.ps. \nPermissiontomakedigitalorhardcopiesofallorpartofthisworkfor personalorclassroomuseisgrantedwithoutfeeprovidedthatcopies \narenotmadeordistributedforproftorcommercialadvantageand thatcopiesbearthisnoticeandthefullcitationonthefrstpage.To \ncopyotherwise,orrepublish,topostonserversortoredistributeto lists,requirespriorspecifcpermissionand/orafee. \nPLDI2000,Vancouver,BritishColombia,Canada. Copyright2000ACM1-58113-199-2/00/0006...$5.00. catedarrays[16,13,8].Theseprogramspresentachalleng\u00adingsetofprogramanalysisproblems:theyuserecursionas \ntheirprimarycontrolstructure,theyusedynamicmemory allocationtomatchthesizesofthedatastructurestothe problemsize,andtheyaccessdatastructuresusingpointers \nandpointerarithmetic,whichcomplicatesthestaticdisam\u00adbiguationofmemoryaccesses. Thestraightforwardapplicationofstandardprograman\u00adalysistechniquestothisclassofprogramsfailsbecausethe \ndomainofsymbolicexpressionshasinfniteascendingchains. Thispaperpresentsanewframeworkthateliminatesthis \nproblem.Insteadofusingtraditionalfxed-pointalgorithms, itformulateseachanalysisproblemasasystemofinequality \nconstraintsbetweensymbolicboundpolynomials.Itthen reducestheconstraintsystemtoalinearprogram.Theso\u00adlutiontothelinearprogramprovidessymboliclowerand \nupperboundsforthevaluesofpointerandarrayindexvari\u00adablesandfortheregionsofmemorythateachstatementand procedureaccesses.Theanalysissolvesonesymboliccon\u00adstraintsystemperprocedure,thenonesymbolicconstraint \nsystemforeachstronglyconnectedcomponentinthecall graph. 1.1StaticRaceDetection Explicitlyparallellanguagesgiveprogrammersthecontrol \ntheyneedtoproduceextremelyefcientprograms.The drawbackisthatexplicitparallelismcansignifcantlycom\u00adplicatethedevelopmentprocess.Oneofthemaincompli\u00adcationsisthepossibilityofdataraces,orunanticipatedin\u00adteractionsthatoccuratmemorylocationsaccessedbypar\u00adallelthreads.Adivideandconquerprogramhasadata \nracewhenonethreadwritesalocationthatanotherpar\u00adallelthreadaccesses.Ouranalysisstaticallycomparesthe regionsofmemoryaccessedbyparallelthreadstodeter\u00admineiftheremaybeadatarace.Ifnot,theprogrammer \nisguaranteedthattheprogramisrace-freeandwillexecute deterministicallywithnounanticipatedinteractions.Our \nanalysisthereforeeliminatesaprimarycomplicationassoci\u00adatedwithparallelprogramming. 1.2AutomaticParallelization \nThedifcultyofdevelopingparallelprogramshasledtoa largeresearchefortdevotedtoautomaticallyparallelizing \nsequentialprograms[1,3,17,23].Ouranalysisiscapable ofautomaticallyparallelizingsequentialdivideandconquer \nprograms.Weemphasizethefactthattraditionalparal\u00adlelizationtechniquesareoflittleornouseforthisclassof \nprograms|theyaredesignedtoanalyzeloopneststhat accessdensematricesusingafneindexexpressions,notre\u00adcursiveproceduresthatusepointersandofsetsintodynam\u00adicallyallocatedarrays. \nOuranalysisallowsustobeneutralontheissueofex\u00adplicitparallelismversusautomaticparallelization.Ifthe programmerpreferstowriteaparallelprogram,ourcom\u00adpilerwillhelpeliminateoneofthekeyproblems,dataraces. \nIftheprogrammerpreferstowriteasequentialprogram,our compilerwillautomaticallyparallelizetheprogramsothat \nitexecutesefcientlyonparallelmachines. 1.3DetectingArrayBoundsViolations Forefciencyreasons,low-levellanguageslikeCdonot \ncheckthatarrayaccessesfallwithinthearraybounds.But arrayboundsviolationsareaseriouspotentialproblem,in \nlargepartbecausetheyintroduceunanticipatedanddifcult tounderstandinteractionsbetweenstatementsthatviolate \nthearrayboundsandthedatastructuresthattheyincor\u00adrectlyaccess. Becauseouralgorithmscharacterizetheregionsofmem\u00adoryaccessedbystatementsandprocedures,theyallowthe \ncompilertocertifythataprogramwillneverviolatethe arraybounds.Thisistrueevenforprogramsthatdynam\u00adicallyallocatearraysandusepointerarithmetictoobtain \nlong-livedpointersintothemiddleofarrays. 1.4EliminatingArrayBoundsChecks SafelanguageslikeJavaeliminatethepossibilityofunde\u00adtectedarrayboundsviolationsbydynamicallycheckingthat \neacharrayaccessfallswithinthearraybounds.Aproblem withthisapproachisthecostofexecutingtheextrainstruc\u00adtionsthatcheckforarrayboundsviolations. \nBecauseouralgorithmscharacterizetheregionsofmem\u00adoryaccessedbystatementsandprocedures,theyallowthe compilertoeliminatearrayboundschecks.Iftheregions \naccessedbyastatementorprocedurefallwithinthearray bounds,thecompilercansafelyeliminateanyassociated checks.Onceagain,ouranalysisallowsustobeneutralon \ntheissueofarrayboundschecks.Iftheprogrammerwould prefertouseanunsafelanguage,thecompilercancertify thattheprogramdoesnotviolatethearraybounds.Ifthe \nprogrammerwouldprefertouseasafelanguage,thecom\u00adpilercanautomaticallyeliminatethearrayboundschecks. 1.5BitwidthAnalysis \nAlthoughouranalysisisdesignedtoderivesymbolicbounds, itextractsprecisenumericboundswhenitispossibletodo \nso.Inthiscase,itcanboundthenumberofbitsrequired torepresentthevaluesthattheprogramcomputes.These boundscanbeusedtoeliminatesuperfuousbitsfromthe \nstructuresusedtostorethevalues,reducingthememory andenergyconsumptionofhardwarecircuitsautomatically \ngeneratedfromprogramswritteninstandardprogramming languages[2,6,27]. 1.6Contributions Thispapermakesthefollowingcontributions: \n.AnalysisFramework:Itpresentsanovelframework forthesymbolicboundsanalysisofpointers,arrayin\u00addices,andaccessedmemoryregions.Thisframework \nformulatestheanalysisproblemusingsystemsofsym\u00adbolicinequalityconstraints. .SolutionMechanism:Standardprogramanalyses \nuseiterativefxed-pointalgorithmstosolvesystemsof inclusionconstraintsordatafowequations[21].But fxed-pointmethodsfailtosolveourconstraintsystems \nbecausethedomainofsymbolicexpressionshasinf\u00adniteascendingchains.Insteadofattemptingtoiterate toasolution,ournewapproachreduceseachsystem \nofsymbolicconstraintstoalinearprogram.Theso\u00adlutionofthislinearprogramtranslatesdirectlyintoa solutionforthesymbolicconstraintsystem.Thereis \nnoiterationandnopossibilityofnontermination. .PointerAnalysis:Itshowshowtousepointeranal\u00adysistoenabletheapplicationoftheanalysisframe\u00adworktoprogramsthatheavilyusedynamicalloca\u00adtion,pointersintothemiddleofdynamicallyallocated \nmemoryregions,andpointerarithmetic. .AnalysisUses:Itpresentsalgorithmsthatusethe analysisresultstosolveseveralimportantproblems, \nincludingstaticracedetection,automaticparalleliza\u00adtion,detectionofarrayboundsviolations,elimination ofarrayboundschecks,andreductionofthenumberof \nbitsusedtostorethevaluescomputedbytheprogram. .ExperimentalResults:Itpresentsexperimentalre\u00adsultsthatcharacterizetheefectivenessofthealgo\u00adrithmsonasetofbenchmarkprograms.Ourresults \nshowthatthealgorithmscanverifytheabsenceof dataracesinourbenchmarkparallelprograms,de\u00adtecttheavailableparallelisminourbenchmarkserial \nprograms,andverifythatbothsetsofbenchmarkpro\u00adgramsdonotviolatetheirarraybounds.Theycan alsosignifcantlyreducethenumberofbitsrequired \ntostorethestateofourbenchmarkbitwidthanalysis programs. Theremainderofthepaperisorganizedasfollows.Sec\u00adtion2presentsarunningexamplethatweusethroughout \nthepaper.Section3presentstheanalysisalgorithms,while Section4presentssomeextensionstothesealgorithms.Sec\u00adtion5presentsexperimentalresultsfromourimplementa\u00adtion.Section6discussesrelatedwork.WeconcludeinSec\u00adtion7. \n2Example Figure1presentsasimpleexamplethatillustratesthekinds ofprogramsthatouranalysisisdesignedtohandle.The \ndcIncprocedureimplementsarecursive,divide-and-conquer algorithmthatincrementseachelementofanarray.The \nexampleiswritteninCilk,aparalleldialectofC[14]. 2.1ParallelismintheExample Inthedividepartofthealgorithm,thedcIncproceduredi\u00advideseacharrayintotwosubarrays.Itthencallsitselfrecur\u00adsivelytoincrementtheelementsineachsubarray.Because \nthetworecursivecallsareindependent,theycanexecute concurrently.Theprogramgeneratesthisparallelexecution \nusingtheCilkspawnconstruct,whichexecutesitsargument functioncallinparallelwiththerestofthecomputationin \ntheprocedure.Theprogramthenexecutesasyncinstruc\u00adtion,whichblocksthecallerprocedureuntiltheparallelcalls \nhavefnished.Aftertheexecutionofseveralrecursivelev\u00adels,thesubarraysizebecomesassmallasCUTOFF,atwhich \npointthealgorithmusesthebasecaseprocedurebaseInc tosequentiallyincrementeachelementofthesubarray. 1:#defineCUTOFF16 \n2: 3:voidbaseInc(int*q,intm){ 4:inti; 5:i=0; 6:while(i<=m-1){ 7: *(q+i)+=1; 8: i=i+1; 9:} 10:} 11:voiddcInc(int*p,intn){ \n12:if(n<=CUTOFF){ 13: baseInc(p,n); 14:}else{ 15: spawndcInc(p,n/2); 16: spawndcInc(p+n/2,n-n/2); 17: \nsync; 18:} 19:} 20:voidmain(intargc,char*argv[]){ 21:intsize,*A; 22:scanf(\"%d\",&#38;size); 23:if(size>0){ \n 24: A=malloc(size*sizeof(int)); 25: /*codethatinitializesA*/ 26: dcInc(A,size); 27: /*codethatusesA*/ \n28:} 29:} Figure1:DivideandConquerArrayIncrementExample ThisexamplerefectsthestructureofmostoftheCilk \nprogramsdiscussedinSection5inthatitidentifessub\u00adproblemsusingpointersintodynamicallyallocatedmemory blocks.Thisstrategyleadstocodecontainingsignifcant \namountsofpointerarithmetic.Arguablybetterprogram\u00admingpracticewoulduseintegerindicesinsteadofpointers. \nOurpointeranalysisalgorithmandformulationofthesym\u00adbolicanalysisallowsustobeneutralonthisissue.Our algorithmcansuccessfullyanalyzeprogramsthatidentify \nsubproblemsusinganycombinationofpointerarithmetic andarrayindices.Alsonotethattheexclusiveuseofar\u00adrayindicesinsteadofpointerarithmeticdoesnotsignif\u00adcantlysimplifytheanalysisproblem|thecompilermust \nstillreasonaboutrecursivelygeneratedaccessestoregions ofdynamicallyallocatedmemoryblocks. 2.2RequiredAnalysisInformation \nThebasicproblemthatoursymbolicanalysismustsolveis todeterminetheregionsofmemorythateachprocedureac\u00adcesses.Theanalysisrepresentsregionsofmemoryusingtwo \nabstractions:allocationblocksandsymbolicregions.There isanallocationblockforeachallocationsiteintheprogram, \nwiththememorylocationsallocatedatthatsitemergedto\u00adgethertoberepresentedbythesite'sallocationblock.In \nourexample,theallocationblockarepresentsthearrayA allocatedatline24inFigure1. Symbolicregionsidentifyacontiguoussetofmemorylo\u00adcationswithinanallocationblock.Eachsymbolicregionhas \nalowerboundandanupperbound;theboundsaresymbolic polynomialswithrationalcoefcients.Intheanalysisresults \nforeachprocedure,thevariablesineachboundrepresentthe initialvaluesoftheparametersoftheprocedure.Inourex\u00ad \n ample,thecompilerdeterminesthateachcalltobaseInc readsandwritesthesymbolicregion[q0,q0+m0.1]within theallocationblockaandthateachcalltodcIncreadsand \nwritesthesymbolicregion[p0,p0+n0.1]withina. 1 Thecompilercanusethisinformationtodetectdata racesandarrayboundsviolationsasfollows.Tocheckfor \ndataraces,itcomparesthesymbolicregionsfromparallel callsitestoseeifaregionwrittenbyonecalloverlapswith \naregionaccessedbyaparallelcall.Ifso,thereisapotential datarace.Ifnot,thereisnorace.Tocomparetheregions \naccessedbythetworecursivecallstodcInc,forexample,the compilersubstitutestheactualparametersatthecallsite \ninforthecorrespondingformalparametersintheextracted symbolicregions.Itcomputesthatthefrstcallreadsand \nwrites[p,p+(n!2).1]inaandthatthesecondcallreadsand writes[p+(n!2),p+n.1]inThecompilercomparesthe a.boundsoftheseregionstoverifythatneithercallwritesa \nregionthatoverlapswitharegionaccessedbytheothercall, whichimpliesthattheprogramhasnodataraces.Notethat \ntherationalcoefcientsintheboundpolynomialsallowthe compilertoreasonaboutthecalculationsthatdivideeach \narrayincrementproblemintotwosubproblemsofequalsize. Todetectarrayboundsviolations,thecompilercompares \nthesizesofthearraysagainsttheexpressionsthattellwhich regionsofthearrayareaccessedbyeachprocedure.Inthe \nexample,theappropriatecomparisonisbetweenthesizeof thearraywhenitisallocatedinthemainprocedureand theregionsaccessedbythetop-levelcalltodcIncinthe \nmainprocedure.Thetop-levelcalltodcIncreadsandwrites [A,A+size.1]inThissymbolicregioniscontainedwithin \na.thedynamicallyallocatedblockofmemorythatholdsthe array,sotheprogramcontainsnoarrayboundsviolations. \nIntheremainderofthepaper,wepresentthealgorithms thatthecompilerusestoanalyzetheprogramandsolvethe setofproblemsdiscussedintheintroduction.Weusethe \narrayincrementprograminFigure1asarunningexample toillustratehowouralgorithmswork. 3AnalysisAlgorithm \nTheanalysishastwogoals:tocomputeanupperandlower boundforeachpointerandarrayindexvariableateach programpointand,foreachprocedureandeachallocation \nblock,tocomputeasetofsymbolicregionsthatrepresent thememorylocationsthattheentirecomputationofthe procedureaccesses.Itcomputestheboundsasapolynomi\u00adalswithrationalcoefcientsandvariablesthatrepresentthe \ninitialvaluesoftheparametersoftheenclosingprocedure. 3.1StructureoftheCompiler Figure2presentsthegeneralstructureofthecompiler,which \nconsistsofthefollowinganalysisphases: .PointerandRead-WriteSetsAnalysis:Thecom\u00adpilerfrstrunsaninterprocedural,context-sensitive, \nfow-sensitivepointeranalysisthatanalyzesbothse\u00adquentialandparallelprograms[25].Itthenperforms aninterproceduralread-writesetsanalysis,whichuses \ntheextractedinformationtocomputetheallocation blocksaccessedbyeachinstructionandeachproce\u00addureintheprogram.Theremainingphasesrelyon \nthisphasetodisambiguatereferencesviapointers. 1Hereweusethenotation[l,h]todenotetheregionofmemory betweentheaddresseslandh,inclusive.AsisstandardinC,we \nassumecontiguousallocationofarrays,andthattheaddressesofthe elementsincreaseasthearrayindicesincrease.Wealsousetheno\u00adtationp0todenotetheinitialvalueoftheparameterp. \n Figure2:StructureoftheCompiler .SymbolicAnalysis:Thisphaseproducessetsofsym\u00adbolicregionsthatcharacterizehoweachprocedureac\u00adcessesmemory.Itfrstextractssymbolicboundsfor \neachpointerandarrayindexvariable,thenusesthis informationtocomputesymbolicboundsfortheac\u00adcessedregionswithineachallocationblock. \n.UsesoftheAnalysisResults:Thisphaseusesthe symbolicmemoryaccessinformationcomputedbythe earlierstagestosolvetheproblemsdiscussedabovein \ntheintroduction. Thesymbolicanalysisconsistsofthefollowingsubphases: .IntraproceduralBoundsAnalysis:Thisphasede\u00adrivessymbolicboundsforeachpointerandarrayindex \nvariableateachprogrampoint. .IntraproceduralRegionAnalysis:Foreachallo\u00adcationblock,thisphasecomputesasetofsymbolic \nregionsthatcharacterizeshowtheproceduredirectly readsorwritestheallocationblock. .InterproceduralRegionAnalysis:Foreachallo\u00adcationblock,thisphasecomputesasetofsymbolic \nregionsthatcharacterizeshowtheentirecomputation oftheprocedurereadsorwritestheallocationblock. Boththeboundsanalysisandtheinterproceduralregion \nanalysisuseageneralsymbolicanalysisframeworkforbuild\u00adingandsolvingsystemsofsymbolicinequalityconstraints \nbetweenpolynomials.Recursiveconstraintsmaybegener\u00adatedbyloopsinthecontrolfow(inthecaseofthebounds analysis),orbyrecursivecalls(inthecaseoftheregionanal\u00adysis).Bysolvingarbitrarysystemsofrecursiveconstraints, \nthecompilerisabletohandlearbitraryfowofcontrolat boththeintraproceduralandinterprocedurallevel. 3.2BasicConcepts \nTheanalysisusesthefollowingmathematicalobjectstorep\u00adresentthesymbolicboundsandaccessedmemoryregions: \n.AllocationBlocks:Thereisanallocationblockafor eachstaticordynamicallocationsiteintheprogram, withthevariabledeclarationsitesconsideredtobethe \nstaticallocationsites.Alloftheelementsofeacharray aremergedtogethertoberepresentedbytheallocation blockfromthearray'sallocationsite.Forprograms \nwithstructures,eachfeldofeachstructurehasits ownallocationblock. .ProgramVariables:Vfisthesetofpointerand \narrayindexvariablesfromtheproceduref.Inour example,V=fq,m,ig.vpdenotesthevalueof baseInc thevariablevattheprogrampointpivistheinitial \n0 valueofaparametervofagivenprocedure. ReferenceSets:Cfisthesetofinitialvaluesof theparametersoftheproceduref.Cfiscalledthe \nreferencesetoff.Inourexample,CbaseInc=fq0,m0g. . Polynomials:PSisthesetofmultivariatepolynomi\u00adalswithrationalcoefcientsandvariablesinS.Also, \nPS=P.[f+1,-1g.Pistheanalysisdomainfor SCf theprocedurefiallsymbolicanalysisresultsforfare computedaselementsofCf. \nNotethateventhoughthepolynomialsrepresentinte\u00adgervalues,theyhaverationalcoefcients,notinteger coefcients.Rationalcoefcientsenablethecompiler \ntoreasonaboutaddresscomputationsthatcontaindi\u00advisionoperators.Thesekindsofaddresscomputations arecommoninourtargetclassofdivideandconquer \ncomputations,whichusethemtodivideaprobleminto severalsubproblemsofequalsize. SymbolicBounds:Foreachvariablevandprogram \npointp,theanalysiscomputesasymboliclowerbound lv,pandupperbounduv,pforthevalueofvatp.The analysiscomputestheseboundsassymbolicpolyno\u00admialswithrationalcoefcientsandvariablesfromthe \nreferencesetoftheenclosingprocedure. Inourexample,theanalysiscomputesli,p=0and ui,p=m0-1,wherepistheprogrampointbeforeline \n7inFigure1.  SymbolicRegions:AsymbolicregionRinthedo\u00admainofaprocedurefisapairofsymbolicbounds fromtheanalysisdomainoff:R2PCfXPCf,R= \n[l,u],withl,u2PCfilisthelowerboundanduisthe upperbound.Eachsymbolicregionrepresentsacon\u00adtinguoussetofmemorylocationswithinanaccessed \nallocationblock.  SymbolicRegionSets:AsymbolicregionsetRS inthedomainofaprocedurefisasetofsymbolic regionsfromf:RS.PCfXPCf.Foreachprocedure \nfandallocationblocka,theanalysiscomputestwo symbolicregionsetstorepresentthelocationsthat theentirecomputationoffaccesses:RWf,a,which \nrepresentsthelocationsthatfwritesina,andRRf,a, whichrepresentsthelocationsthatfreadsina.In ourexampletheanalysiscomputes: \n RW RW baseInc,a=RRbaseInc,a=f[q0,q0+m0-1]g dcInc,a=RRdcInc,a=f[p0,p0+n0-1]g whereaistheallocationblockforthearrayallocated \natline24inFigure1. B 1 _ B 2 /H /H /H li,3<i<ui,3 lm,3<m<um,3 *(q+i)+=1; i=i+1; B 3 _  Figure3:SymbolicBoundsattheStartofBasicBlocks \n3.3IntraproceduralBoundsAnalysis Inthisphase,thecompilercomputessymboliclowerandup\u00adperboundsforeachpointerandarrayindexateachprogram \npoint.Theboundsareexpressedaspolynomialswithratio\u00adnalcoefcients.Thevariablesinthepolynomialsrepresent \ntheinitialvaluesoftheformalparametersoftheenclos\u00adingprocedure.Weillustratetheoperationofthisphaseby showinghowitanalyzestheprocedurefromFig\u00ad \nbaseInc ure1. 3.3.1InitialSymbolicBounds LetB=fBjj1:j:lgbethesetofbasicblocksinthe control-fowgraphoftheproceduref.Foreachvariable \nv2VfandbasicblockBj,thecompilergeneratesasymbolic lowerboundlv,jandasymbolicupperbounduv,jforthe valueofvatthestartofBj.Figure3presentsthecontrol\u00adfowgraphandinitialsymbolicboundsfortheprocedure \nbaseIncfromourexample. 3.3.2SymbolicAnalysisofBasicBlocks Thecompilernextsymbolicallyexecutestheinstructionsin \neachbasicblocktoproducenewsymbolicboundsforeach variableattheendoftheblockandatallintermediatepro\u00adgrampointswithintheblock.Theseboundsareexpressed \naslinearcombinationsofthesymbolicboundsfromthestart oftheblock.Figure4presentstheresultsofthisstepinour \nexample.2Wenextexplainhowthecompilerextractsthese bounds. Duringtheanalysisofindividualinstructions,thecom\u00adpilermustbeabletocomputeboundsofexpressions.The \nanalysiscomputesthelowerboundL(e,p)andupperbound U(e,p)ofanexpressioneataprogrampointpasfollows. Ifecontainsatleastonevariablewithinfnitebounds,then \nL(e,p)=-1andU(e,p)=+1.Otherwise,thefollowing equationsdefnethebounds.Notethatintheseexpressions, +,-,and.operateonpolynomials.Eachexpressionisa \nlinearcombinationofthesymbolicboundsl,pandu,p. vv 2Ourcompilerdecouplestheanalysisofiandmfromtheanalysis \nofq(seeSection4.3).Wethereforepresenttheanalysisonlyfori andm.  /H /H /H li,3<i<ui,3 lm,3<m<um,3 *(q+i)+=1; \nli,3<i<ui,3 B 3 lm,3<m<um,3 _ i=i+1; li,3+1<i<ui,3+1 lm,3<m<um,3  Figure4:SymbolicBoundsattheEndofBasicBlocks \nL(c,p)=c L(v,p)=vl,p L(e1+e2,p)=L(e1,p)+L(e2,p) n c.L(e,p)ifc0 L(c.e,p)= c.U(e,p)ifc:0 U(c,p)=c U(v,p)=vu,p \nU(e1+e2,p)=U(e1,p)+U(e2,p) n c.U(e,p)ifc0 U(c.e,p)= c.L(e,p)ifc:0 Foranassignmentinstructionioftheformv=e,where \nv2Vfandeisalinearexpressionintheprogramvariables, theanalysisupdatestheboundsofvtobetheboundsof e.Formally,ifpistheprogrampointbeforeiandp \n0 isthe programpointafteri,then: 0 lv,p=L(e,p) uv,p0 =U(e,p) Foraconditionalinstructionioftheformv:eorv?e, \nwherev2Vfandeisalinearexpressionintheprogram variables,theanalysisgeneratesanewupperorlowerbound forvonthetruebranchoftheconditional.Iftheconditional \nisoftheformv?e,thenewlowerboundofvisthelower boundofe.Iftheconditionalisoftheformv:e,the newupperboundofvistheupperboundofe.Formally, \nifpistheprogrampointbeforetheconditionalandtisthe programpointonthetruebranchoftheconditional,then: lv,t=L(e,p)ifiisoftheformv?e \nu,=U(e,p)ifiisoftheformv:e vt InitializationConditions: li,1=-1ui,1=+1 lm,1=m0 um,1=m0 SymbolicConstraints: \nli,2:00:ui,2 li,2:li,3+1ui,3+1:ui,2 lm,2:lm,1 um,1:um,2 lm,2:lm,3 um,3:um,2 li,3:li,2 um,2-1:ui,3 lm,3:lm,2 \num,2:um,3 ObjectiveFunction: min:(ui,2-li,2)+(um,2-lm,2)+ (ui,3-li,3)+(um,3-lm,3) Figure5:SymbolicConstraintSystemforBoundsAnalysis \nAllotherboundsremainthesameasthecorresponding boundsfrombeforetheconditional. Forallotherinstructions,suchasassignmentsofexpres\u00adsionsthatarenotlinearintheprogramvariables(butsee \nSection4.3foranextensionthatenablestheanalysisto supportpolynomialexpressionsincertaincases),callin\u00adstructions,ormorecomplicatedconditionals,theanalysis \ngeneratesconservativebounds.Allofthevariablesthatthe analyzedinstructionwriteshaveinfnitebounds,andallof \ntheothervariableshaveunchangedbounds.Thepointerand read-writesetsanalysescomputethesetofwrittenvariables. \n3.3.3ConstraintGeneration Thealgorithmnextbuildsasymbolicconstraintsystemover thelowerandupperbounds.Thesystemconsistsofasetof \ninitializationconditions,asetofsymbolicconstraints,and anobjectivefunctiontominimize: Theinitializationconditionsrequirethatatthestartof \ntheentrybasicblockB1,theboundsofeachpointer orarrayindexparameterv2Vfmustbeequalto v0(thevalueofthatvariableatthebeginningofthe \nprocedure).Forallothervariables,thelowerbounds aresetto-1andtheupperboundsto+1.  Thesymbolicconstraintsrequirethattherangeofeach \nvariableatthebeginningofeachbasicblockmustin\u00adcludetherangeofthatvariableattheendoftheprede\u00adcessorbasicblocks.Formally,ifBjisapredecessorof \nBk,lv0 ,janduv0 ,jaretheboundsofvattheendofBj, andlv,kanduv,karetheboundsofvatthebeginning  :l00 ofBk,thenlv,kv,janduv,j:uv,k. \nTheobjectivefunctionminimizestheupperbounds andmaximizesthelowerbounds.Thereforetheob- PPl jectivefunctionis:min:(uv,j-lv,j). \nv2Vf j=2 Theinitializationconditionsandsymbolicconstraintsen\u00adsurethesafetyofthecomputedbounds.Theobjectivefunc\u00adtionensuresatightsolutionthatminimizesthesymbolic \nrangesofthevariables.Figure5presentstheconstraint systeminourexample. Theanalysisnextextractstheboundsintermsofthe \nreferenceset(theinitialvaluesoftheparameters).Theal\u00adgorithmdoesnotknowwhattheboundsare,butitproceeds \nundertheassumptionthattheyarepolynomialswithvari\u00adablesinthereferenceset.Itthereforeexpressesthebounds \nassymbolicpolynomials.Eachtermofthepolynomialhasa rationalcoefcientvariablecj.Thegoaloftheanalysisisto \nfndaprecisenumericalvalueforeachcoefcientvariablecj. Inourexample,theboundsareexpressedusingcoefcient \nvariablesandthevariablesfromthereferencesetfq0,m0g: li,2=c1q0+c2m0+c3 ui,2=c13q0+c14m0+c15 lm,2=c4q0+c5m0+c6 \num,2=c16q0+c17m0+c18 li,3=c7q0+c8m0+c9 ui,3=c19q0+c20m0+c21 lm,3=c10q0+c11m0+c12um,3=c22q0+c23m0+c24 \n Theinitializationconditionsdefnetheboundsatthebegin\u00adningofthestartingbasicblockB1: lm,1=m0um,1=m0li,1=-1ui,1=+1 \n 3.3.4SolvingtheSymbolicConstraintSystem Thisstepsolvesthesymbolicconstraintsystembyderiving arationalnumericvalueforeachcoefcientvariable.We \nfrstsummarizethestartingpointforthealgorithm. Thealgorithmisgivenasetofsymboliclowerand upperbounds.Theseboundsareexpressedasaset \nofsymbolicboundpolynomialsPi2PC,whereCis thereferencesetofthecurrentlyanalyzedprocedure. Eachtermineachsymbolicboundpolynomialconsists \nofacoefcientvariableandaproductofreferenceset Ptri,1 ri,s variables:Pi=ci.x1...xs. i=0 Thealgorithmisalsogivenasetofinequalitycon\u00adstraintsbetweenpolynomialexpressionsandanob\u00adjectivefunctiontominimize.Formally,thesymbolic \nconstraintsystemcanbeexpressedasapair(I,O), whereIfQ:RjQ,R2PCgisthesetofsym\u00adbolicconstraintsandO2PCistheobjectivefunc-tion.ThepolynomialexpressionsQ,R,andOare \nlinearcombinationsofthesymbolicboundpolynomi\u00adals.TheanalysisdescribedinSections3.3.2and3.3.3 producestheseexpressions. \n Thealgorithmsolvestheconstraintsystembyreducing ittoalinearprogramoverthecoefcientvariablesfrom thesymbolicboundpolynomials.Itgeneratesthelinear \nprogrambyreducingeachsymbolicinequalityconstraint toseverallinearinequalityconstraintsoverthecoefcient \nvariablesofthesymbolicboundpolynomials.Formally,if PP tQri,1 ri,s tRri,1 ri,s Q=c.x...xsandR=c.x...xs, \ni i=0i1i=01 then: (Q:R)2Iisreducedto:c Qi:c Ri,forall0:i:t Becausethepolynomialexpressionsarelinearcombinations \nofthesymbolicboundpolynomials,thecoefcientsc Riand Q ciarelinearcombinationsofthecoefcientvariablesfrom \nthesymbolicboundpolynomials. Thealgorithmalsoreducesthesymbolicobjectivefunc\u00adtiontoalinearobjectivefunctioninthecoefcientvariables. \nThisreductionminimizesthesumofthecoefcientsinthe polynomialexpression.Formally,iftheobjectivefunctionis \nP Ori,1 ri,s O=ti=0 ci.x1...xs,then: t PO min:Oisreducedto:min:ci i=0 Symbolic GeneratedLinear Constraints \nConstraints l l l i,2:0:c1:0c2:0c3:0 i,2:li,3+1:c1:c7 c2:c8 c3:c9+1 m,2:m0 :c4:0c5:1c6:0 c6 l m,2:lm,3 \n:c4:c10 c5:c11 :c12 l i,3:li,2 :c7:c1 c8:c2 c9:c3 l m,3:lm,2 :c10:c4 c11:c5 c12:c6 u i,2?0:c13?0c14?0c15?0 \nu u i,2?ui,3+1:c13?c19 c14?c20 c15?c21+1 m,2?m0 :c16?0c17?1c18?0 u m,2?um,3 :c16?c22 c17?c23 c18?c24 \nu i,3?um,2-1:c19?c16 c20?c17 c21?c18-1 u m,3?um,2 :c22?c16 c23?c17 c24?c18 ObjectiveFunction: min:((c13+c14+c15)-(c1+c2+c3))+ \n((c16+c17+c18)-(c4+c5+c6))+ ((c19+c20+c21)-(c7+c8+c9))+ ((c22+c23+c24)-(c10+c11+c12)) Figure6:LinearProgramforBoundsAnalysis \nAtthispointtheanalysishasgeneratedalinearprogram. Thesolutiontothislinearprogramdirectlygivesthesolu\u00adtiontothesymbolicconstraintsystem. \nWeemphasizethatthesymbolicconstraintsystemisre\u00adducedtoalinearprogram,nottoanintegerlinearpro\u00adgram.Thecoefcientvariablesinthelinearprogramare \nrationalnumbers,notintegernumbers. Figure6showsthegeneratedlinearprograminourex\u00adample.Itpresentsthesymbolicconstraintsonthelefthand \nsideandthegeneratedlinearconstraintsontherighthand side.Forexample,theconstraintli,2:li,3+1meansthat \n(c1q0+c2m0+c3):(c7q0+c8m0+c9)+1,whichinturn generatesthefollowingconstraints:c1:c7,c2:c8and c3:c9+1.Solvingthelinearprogramyieldsthefollowing \nvaluesofthecoefcientvariables: c1=0c2=0c3=0c13=0c14=1c15=0 c4=0c5=1c6=0c16=0c17=1c18=0 c7=0c8=0c9=0c19=0c20=1c21=-1 \nc 10=0c11=1c12=0c22=0c23=1c24=0 Thisgivesthefollowingpolynomialsforthelowerandupper bounds: l i,2=0ui,2=m0 \nlm,2=m0 um,2=m0 l i,3=0ui,3=m0-1lm,3=m0 um,3=m0 Finally,theseboundsareusedtocomputethesymbolic boundsofthevariablesateachprogrampoint,givingthe \nfnalresultshowninFigure7.Notethattheanalysisdetects thatthesymbolicrangeoftheindexvariableibeforethe \nstoreinstruction*(q+i)+=1is[0,m0-1].Inasimilar manner,theboundsanalysisisabletodeterminethatthe rangeofthepointerqatthisprogrampointis[q0,q0],which \nmeansthatq=q0beforethestoreinstruction. 3.3.5PositivityAnalysis Bothofthetransformationsthatreducethesymboliccon\u00adstraintsystemtoalinearprogramassumethatthevariables \n  _ 0<i<m0-1 m0<m<m0 *(q+i)+=1; 0<i<m0-1 B3 m0<m<m0 _ i=i+1; 1<i<m0 m0<m<m0  Figure7:ResultsoftheBoundsAnalysis \n inthereferencesetCfarepositive.Wecanapplysimilar transformationsifweknowthatavariableisnegative.But \nifwedonotknowthesignofavariableinCf,wecannot reducethesymbolicsystemtoalinearprogram.Thealgo\u00adrithmthereforeperformsasimpleinterproceduralpositivity \nanalysistocomputethesignofthearrayindexvariablesin thereferenceset.Itdoesnotcheckpointervariables,since \ntheyalwaysrepresentpositiveaddresses. 3.4RegionAnalysis Foreachprocedurefandallocationblocka,theregionanal\u00adysiscomputesasymbolicregionsetthatrepresentsthere\u00adgionsofathatfreadsorwrites.Anintraproceduralanal\u00adysisfrstbuildstheregionsthateachprocedureaccessesdi\u00adrectly.Aninterproceduralanalysisthenusesthesesymbolic \nregionstobuildsymbolicconstraintsystemsthatspecify theregionsaccessedbythecompletecomputationofeach procedure.Thealgorithmsolveseachconstraintsystemby \nreducingittoalinearprogram.Thisapproachsolvesthe hardproblemofcomputingsymbolicaccessregionsforre\u00adcursiveprocedures. \n3.4.1RegionCoalescing Atcertainpointsintheanalysis,thealgorithmmustcoalesce overlappingregions.Figure8presentstheregioncoalescing \nalgorithm.Itfrsttriestocoalescethenewregionwithsome otheroverlappingregionintheregionset,inwhichcasethe \nboundsoftheoverlappingregionareadjustedtoaccommo\u00addatethenewregion.Ifnooverlappingregionisfound,the algorithmaddsthenewregiontotheregionset. \nCallGraph SCCDAG non-recursive AlgorithmCoalesce(RegionR,RegionSetRS) let R = [lf u ] if (9[l0f u 0]2 \nRS, l : l0 : u 0 : u) then return (RS -f [l0f u 0]g)[ f [lf u ]g else if (9[l0f u 0]2 RS, l : l0 : u \n: u 0) then return (RS -f [l0f u 0]g)[ f [lf u 0]g else if (9[l0f u 0]2 RS, l0 : l : u 0 : u) then return \n(RS -f [l0f u 0]g)[ f [l0f u ]g else if (9[l0f u 0]2 RS, l0 : l : u : u 0) then return RS else return \nRS [ f [lf u ]g Figure8:RegionCoalescingAlgorithm AlgorithmIntraproceduralRegionAnalysis() for(eachprocedurefandeachallocationblocka)do \nlocalRRlocal RW==f f,af,a for(eachallocationblockaccessintheprogram)do letf=thecurrentprocedure; letp=thecurrentprogrampoint; \nleta=theaccessedallocationblock; lete=theaddressexpressionoftheaccess; R=[L(efp)fU(efp)] new if(writeaccess) \nlocal local thenRW=Coalesce(RnewfRW) f,af,aRRlocal local elsef,a=Coalesce(RnewfRRf,a) Figure9:IntraproceduralRegionAnalysisAlgorithm \n3.4.2IntraproceduralRegionAnalysis Figure9presentsthepseudo-codefortheintraprocedural regionanalysis.Thealgorithmfrstinitializesthereadre- \nRRlocal local gionsetsf,aandwriteregionsetsRWf,a.Thesesets characterizetheregionsofmemorydirectlyaccessedbyf. \nItthenscanstheinstructionstoextracttheregionexpres\u00adsions,usingtheboundsanalysisresultstobuildtheregion \nexpressionforeachinstruction.Italsocoalescesoverlapping regionexpressionsfromdiferentinstructions. Ifaisthememoryblockdynamicallyallocatedinthe \nmainprogramintheexample,theresultoftheintraproce\u00adduralanalysisforbaseIncanddcIncis: RW local RRlocal \nbaseInc,a=f[q0fq0+m0-1]gdcInc,a=f RRlocal local baseInc,a=f[q0fq0+m0-1]gRWdcInc,a=f Theregionanalysisusesthepointeranalysisinformationto \ndeterminethatthestoreinstructioninbaseIncaccessesthe allocationblocka. 3.4.3InterproceduralRegionAnalysis \nTheinterproceduralregionanalysisusestheresultsofthe intraproceduralregionanalysistocomputeasymbolicre\u00adgionsetfortheentirecomputationofeachprocedure,in\u00adcludingalloftheproceduresthatitinvokes.Itfrstbuilds \nthecallgraphofthecomputationandidentifesthestrongly non-recursive main scc1=fmaing component dcInc \n scc2=fdcIncg  . recursive component .  .  baseInc scc3=fbaseIncg component  Figure10:CallGraphandSCCDAGinExample \n connectedcomponents.Itthentraversesthestronglycon\u00adnectedcomponentsinreversetopologicalorder,propagating \ntheaccessregioninformationbetweenstronglyconnected componentsfromcalleetocaller.Withineachstronglycon\u00adnectedcomponentwithrecursivecalls,itgeneratesasym\u00adbolicconstraintsystemandsolvesitusingthealgorithm \nfromSection3.3.4.Figure10showsthecallgraphandits stronglyconnectedcomponentsforourexample. 3.4.4SymbolicUnmapping \nAteachcallsite,theanalysismodelstheassignmentsofac\u00adtualparameterstoformalparameters,thenusesthismodel \ntopropagateaccessregioninformationfromthecalleetothe caller.Theanalysisofthecalleeproducesaresultinterms \noftheinitialvaluesofthecallee'sparameters.Buttheresult forthecallermustbeexpressedintermsofthecallerparam\u00adeters,notthecalleeparameters.Thesymbolicunmapping \nalgorithmperformsthischangeofanalysisdomainforeach accessedregionRfromthecallee. ThealgorithmfrsttransformstheregionRfromthe \ncalleedomaintoanewregionR0 byreplacingthefor\u00admalparametersfromthecalleewiththeactualpa\u00adrametersfromthecallsite.Thenewregion[lfu]=R0 \nexpressestheboundsintermsofthevariablesofthe caller.  Thealgorithmnextusestheresultsoftheintraproce\u00adduralboundsanalysispresentedinSection3.3tocom\u00adputealowerboundforlandanupperboundforuin \ntermsofthereferencesetofthecaller.Thesetwonew boundsarethesymboliclowerandupperboundsfor theunmappedregionSUcs(R),thetranslationofthe \nregionRfromthecalleedomaintothecallerdomain atthecallsitecs.  LetCallSites(ffg)bethesetofallcallsiteswithcaller \nfandcalleeg.Weformalizethesymbolicunmappingas follows. Mapping:FortwosetsofvariablesSandT,amap\u00adpingMfromStoTiseitherafunctionM2S!P. \nT (afunctionfromStosymbolicpolynomialsinT),or aspecialmappingMunk,calledtheunknownmapping. CallSiteMapping:Foracallsitecs2CallSites(ffg), \nwedefneacallsitemappingMcs2(Cg!P.)[ Vf fMunkgasfollows: { iftheactualparameterscanbeexpressedaspoly\u00adnomialsp1,:::,pm2P. \nVf thenMcs(vi)=pi, S U cs1(R) = [p0,p0+n0-1] callerdomain Procedure:dcInc wherev1,:::,vmaretheformalparametersofg. \nReferenceset:fp0,n0g { otherwise,Mcs=Munk. SymbolicUnmappingofaPolynomial:Givena polynomialP2PSandamappingM2S!P. \nT,we defnethesymbolicunmappingSUM(P)2P. Tofthe polynomialPusingMasfollows: 6 [p,p+n-1] Boundsinformationatcallsite: \np0:p:p0,n0:n:n0 6 CallsitebaseInc(p,n) Pri 1 ri s withmappingM: P=ci x1xs P M:fq0,m0g!fp,ng 1)ri 1)ri \ns SUM(P)=ci M(x M(xs SymbolicUnmappingofaRegionataCallSite: GivenaregionR=[l,u]2PCfXPCfandacallsite cs2CallSites(f,g)withcallsitemappingM6=Munk, \nwedefnethesymbolicunmappingSUcs(R)2PCfX PCfoftheregionRatcallsitecsasfollows: SUcs(R)=[L(SUM(l),cs),U(SUM(u),cs)] \nIfM=Munk,thenSUcs(R)=[-1,+1]. SymbolicUnmappingofaRegionSetataCall Site:GivenaregionsetRSandacallsitecs,we \ndefnethesymbolicunmappingSUcs(RS)oftheregion setRSatcallsitecsasfollows: SUcs(RS)=fSUcs(R)jR2RSg SymbolicUnmappingofRegionSetsforAllo\u00adcationBlocks:Givenanaccessedallocationblocka \nandacallsitecs2CallSites(f,g),theaccessedregion cs setsRRfcsfa=SUcs(RRgfa)andRWffa=SUcs(RWgfa) describetheregionsofaaccessedbygatcallsitecs, \nintermsofthereferencesetoff. Giventhesedefnitions,theinterproceduralanalysisfor non-recursiveproceduresisstraightforward.Thealgorithm \nsimplytraversesthecallgraphinreversetopologicalor\u00adder,usingtheunmappingalgorithmtopropagateregionsets \nfromcalleestocallers. Figure11showsthesymbolicunmappingprocessatcall sitecs1,wheredcIncinvokesbaseIncinourexample.The \ncompilerstartswiththeregionexpressionRWbaseIncfa= [q0,q0+m0-1]computedbytheintraproceduralregionanal\u00adysis.HereaistheaccessedallocationblockfrombaseInc. \nThecompilercreatesacallsitemappingMthatmapsthe formalparametersq0andm0tothesymbolicexpressionsrep\u00adresentingthecorrespondingactualparametersatthecall \nsite:M(q0)=pandM(m0)=n.Theanalysisusesthis mappingtotranslateRWbaseIncfaintothenewregionR0= [p,p+n-1].Finally,thecompilerusestheboundsofpand \nnatthecallsitetoderivetheunmappedregion: SUcs1(RWbaseIncfa)=[L(p,cs1),U(p+n-1,cs1)] =[p0,p0+n0-1] TheunmappedregionSUcs1(RWbaseIncfa)=[p0,p0+n0-1] \ncharacterizestheregionsinaaccessedbythecallinstruction baseAdd(p,n)intermsoftheinitialvaluesoftheparameters \nofdcAdd,p0andn0. calleedomain R=[q0,q0+m0-1]Procedure:baseInc Referenceset:fq0,m0g Figure11:SymbolicUnmappingExample \n 3.4.5AnalysisofRecursiveProcedures Onewaytoattacktheanalysisofrecursiveprocedures istouseafxed-pointalgorithmtopropagateregionsets \nthroughcyclesinthecallgraph.Butthisapproachfails becausethedomainofmultivariatepolynomialshasinfnite \nascendingchains,whichmeansthatthealgorithmmaynever reachafxedpoint.First,theboundsinsomedivideand conquerprogramsformaconvergentgeometricseries.There \nisnofnitenumberofiterationsthatwouldfndthelimitof suchaseries.Second,recursiveprogramscangeneratea staticallyunboundednumberofregionsintheregionset. \nOuralgorithmavoidstheseproblemsbygeneratingasys\u00adtemofrecursivesymbolicconstraintswhosesolutiondeliv\u00adersaregionsetspecifyingtheregionsofmemoryaccessed \nbytheentirestronglyconnectedcomponent.Thesymbolic constraintsystemissolvedbyusingthealgorithmpresented \ninSection3.3.4toreducethesymbolicconstraintsystemto alinearprogram.Themainideaistogenerateasetofcon\u00adstraintsthat,ateachcallsite,requiresthecallerregionsets \ntoincludetheunmappedregionsetsofthecallee.Wenext discusshowthecompilercomputestheregionsetsforaset Sofmutuallyrecursiveprocedures. \nStep1.Defnethetargetsymbolicbounds.Thecompiler frstdefnes,foreachrecursiveproceduref2Sandalloca\u00adtionblocka,afnitesetofreadregionsandafnitesetof \nwriteregions.Ananalysisofthebasecasesoftherecursion determinesthenumberofregionsineachset. rdrdrdrd RRffa=f[lffaf1,uffaf1],:::,[lffafj,uffaj]g \nfwrwrwrwr RWffa=f[lffaf1,uffaf1],:::,[lffafk,uffafk]g Theboundsoftheseregionsarethetargetboundsinour \nanalysisframework.Foreachproceduref2S,thesebounds arepolynomialexpressionsinPCf.Toguaranteethesound\u00adnessoftheunmapping,theconstraintsystemrequiresthe \ncoefcientsofthevariablesintheseboundstobepositive. Consider,forexample,thecomputationoftheregionsets \nforthestronglyconnectedcomponentS=fdcIncgfrom ourexample.3Sincethebasecaseforthisprocedurewrites 3Thecompilerdecouplesthecomputationofwriteregionsetsfrom \nthecomputationofreadregionsets(seeSection4.3).Wetherefore presenttheanalysisonlyforthewritesetof dcInc. \n asingleregionwithintheallocationblocka,thecompiler generatesasinglewriteregionfordcInc: LocalAccessConstraints: \nwrwr dcIncfa RW=f[ldcIncfafudcIncfa]g C Theboundsofthisregionarepolynomialswithvariablesin dcInc=fp0fn0g.Thealgorithmusesthefollowingbounds: \nwr l dcIncfa=C1p0+C2n0+C3 wr u dcIncfa=C4p0+C5n0+C6 whereC1,C2,C4,andC5arepositiverationalcoefcients. \nStep2.Generatethesymbolicsystemofconstraints.The analysisnextgeneratestheconstraintsystemfortheregion \nboundsdefnedinthepreviousstep.Thesystemmusten\u00adsurethattwoconditionsaresatisfed.First,thelocalregion setsmustbeincludedintheglobalregionsets: \nlocal RReRRffa8f2S local ffa RWeRW8f2S ffaffa Second,foreachcallsite,theunmappedregionsetsofthe calleemustbeincludedintheregionsetsofthecaller: \nSUcs(RRgfa)eRRffa8f2Sf8cs2CallSites(ffg) SUcs(RWgfa)eRWffa8f2Sf8cs2CallSites(ffg) Figure12summarizestheconstraintsinthegeneratedsys\u00adtem.Asintheintraproceduralcase,theobjectivefunction \nminimizesthesizesofthesymbolicregions. Figure13presentsthesystemofsymbolicconstraintsfor theinterproceduralanalysisofdcInc.BecausedcIncdoes \nnotdirectlyaccessanyallocationblock,therearenolo\u00adcalconstraints.Theanalysisgeneratescallsiteconstraints \nforthecallsitescs1,cs2,andcs3,atlines13,15,and 16inFigure1respectively.Atcallsitecs1,whichin\u00advokesbaseInc,theanalysissymbolicallyunmapsthecallee \nregion[q0fq0+m0-1]togeneratetheunmappedregion [p0fp0+n0-1].Theboundsofthisunmappedregiongen\u00aderatethefrsttwoconstraintsinFigure13.Therecursive \ncallsitescs2andcs3generatesimilarconstraints,except wrwr thatnowtheanalysisunmapstheregion[ldcIncfafudcIncfa]= \n[C1p0+C2n0+C3fC4p0+C5n0+C6].Thepositivityof C1,C2,C4,andC5ensuresthecorrectnessofthesymbolic unmappingforthisregion.Thelastfourconstraintscor\u00adrespondtothecallsiteconstraintsforcs2andcs3after \nperformingthesymbolicunmapping. Step3.Reducethesymbolicconstraintstoalinearprogram andsolvethelinearprogram.Theanalysisnextusesthe \nreductionmethodpresentedinSection3.3.4toreducethe symbolicconstraintsystemtoalinearprogram.Thislin\u00adearprogramcontainsconstraintsthatexplicitlyensurethe \npositivityoftherationalcoefcientsofthevariablesinthe bounds.Thesolutionofthelinearprogramdirectlyyields \nthesymbolicregionsetsoftherecursiveproceduresinS. Asfortheboundsanalysis,ifthelinearprogramdoesnot haveasolution,thecompilerconservativelysetstheregions \nofalltheproceduresinSto[-1f+1].Inourexample, thealgorithmreducesthesymbolicconstraintstothelinear programinFigure14.Thesolutionofthislinearprogram \nyieldsthefollowingexpressionsfortheboundsdefnedin thefrststep: wr wr dcIncfadcIncfa l=p0fu=p0+n0-1 ThewriteregionfordcIncistherefore[p0fp0+n0-1].The \ncompilersimilarlyderivesthesamereadregionfordcInc. rd rd local lffa<l^u<uffa8f2Sf8[lfu]2RRffa wr wr local \nl<l^u<u8f2Sf8[lfu]2RW ffaffaffa CallSiteConstraints: rd rd lffa<L(SUMcs(l)fcs)^U(SUMcs(u)fcs)<uffa 8f2Sf8cs2CallSites(ffg)f8[lfu]2RRgfa \nwr wr lffa<L(SUMcs(l)fcs)^U(SU(u)fcs)<uffa M cs 8f2Sf8cs2CallSites(ffg)f8[lfu]2RWgfa ObjectiveFunction: \nPrdrdwrwr min:[(u-l)+(u-l)] ffaffaffaffaf2S Figure12:InterproceduralSymbolicConstraintsforaSet SofMutuallyRecursiveProcedures \nCallSiteConstraints: C1p0+C2n0+C3 C4p0+C5n0+C6 <> p0 p0+n0-1 C1p0+C2n0+C3 C4p0+C5n0+C6 <> C1p0+C2 n0 \n2+C3 C4p0+C5 n0 2+C6 C1p0+C2n0+C3 C4p0+C5n0+C6 <> C1(p0+n0 2)+C2(n0-n0 2)+C4(p0+n0 2)+C5(n0-n0 2)+ C3 \nC6 ObjectiveFunction: min:(C4p0+C5n0+C6)-(C1p0+C2n0+C3)  Figure13:InterproceduralSymbolicConstraintsforWrite \nRegionsofS=fdcIncginExample C1<1C<0C3<0 2 C>1C>1C>-1 456 C1<C1 C2<C2/2C3<C3 C4>C4 C5>C5/2C6>C6 C1<C1 \nC2<C1/2+C2/2C3<C3 C>CC>C4/2+C5/2C>C 44566 C1>0C2>0C4>0C5>0 min:(C4+C5+C6)-(C+C+C3) 12 Figure14:GeneratedLinearProgramforWriteRegionsof \nS=fdcIncginExample Finally,thecompileranalyzesthemainprocedure.Here thecallsitemappingforcallsitecs4,whereproceduremain \ncallsdcInc,isunknownMcs4=Munk,sothesymbolicun\u00admappinggeneratesthewhole-arrayregion[-1,+1]forthe proceduremain.Theinterproceduralanalysisthereforede\u00adrivesthefollowingregionsetsforthearrayallocatedinmain: \nRW baseInc,a=RRbaseInc,a=f[q0,q0+m0-1]g RW dcInc,a=RRdcInc,a=f[p0,p0+n0-1]g RW main,a=RRmain,a=f[-1,+1]g \nThisinformationenablesthecompilertodeterminethat therearenoarrayboundsviolationsbecauseofthecallsto baseIncanddcInc.Itcanalsousetheanalysisresultsto \ndeterminethattherearenodataracesintheseprocedures. Ifithadbeengivenasequentialversionoftheprogram,the \nanalysisresultswouldallowthecompilertoautomatically parallelizeit. 4Extensions Wenextpresentsomeextensionstothebasicsymbolicanal\u00adysisalgorithmpresentedsofar.Theseextensionsarede\u00adsignedtoimprovetheprecisionorefciencyofthebasic \nalgorithm,ortoextenditsfunctionality. 4.1CorrelationAnalysis Thecompilerusescorrelationanalysistoimprovethepre\u00adcisionoftheboundsanalysis.Correlatedvariablesareinte\u00adgerorpointervariableswithmatchingincrementsinloops.4 \nWhentheloopincrementscorrelatedvariablesbuttheloop conditionspecifesboundsonlyforsomeofthecorrelated \nvariables,thecompilercanusecorrelationanalysistoauto\u00admaticallyderiveboundsfortheothercorrelatedvariables. \nvoidMerge(int*l1,int*h1, int*l2,int*h2,int*d): while((l1<h1)&#38;&#38;(l2<h2)) if(*l1<*l2){*d=*l1;d++;l1++;} \nelse {*d=*l2;d++;l2++;} Figure15:CorrelatedVariablesinMergesort Figure15showsanexampleofcorrelatedvariablesinthe \nmainloopoftheMergeprocedureinMergesort.Here,the variablesd,l1,andl2arecorrelated,buttheloopcondition \nspecifesupperboundsonlyforl1andl2(l1<h10and l1<h20).Correlationanalysisenablesthecompilerto automaticallyderiveanupperboundfordatthetopofthe \nloopbody:d:d0+(h10-l10)+(h20-l20)-2. Thecompilerdetectscorrelatedvariablesbygenerating acorrelationexpressionewiththepropertythattheexecu\u00adtionoftheloopbodydoesnotdecreaseeifandonlyifthe \nvariablesinehavematchingincrements.Ingeneral,eisa linearcombinationofthecorrelatedvariables.Inourexam\u00adple,e=l1+l2-d.Notethatbecausetheloopdoesnot \ndecreasee,everyincrementofdhasamatchingincrement ofeitherl1orl2. Toprovethattheloopdoesnotdecreasee,thecompiler \nextractsanewlowerboundforeattheprogrampointqat 4Theanalysisalsocorrectlyhandlesincrementsanddecrementsby \narbitraryconstants. thetopoftheloopbody(fowofcontrolpassesthroughq onceforeveryloopiteration).Thecompilergeneratesanew \ncorrelationvariablevwiththepropertythatv=ethrough\u00adouttheloop,andtreatsvspeciallyintheboundsanalysis, \nensuringthatitsboundsarevalidboundsfore.Atthepro\u00adgrampointpbeforetheloop,theanalysissetsthebounds ofvtoL(e,p)andU(e,p).Whenaninstructionintheloop \nbodyincrementsoneofthevariablesine,theanalysisei\u00adtherincrementsordecrementsbothboundsofv,depending onthesignofthecoefcientofthevariableinthecorrela\u00adtionexpression.Inourexample,theanalysisincrementsthe \nboundsofvwhenaninstructionincrementsl1orl2,and decrementstheboundsofvwhenaninstructionincrements d.Forallotherinstructionsthatwriteoneofthevariables \nine,theanalysissetstheboundsofvtotheboundsofe.In ourexample,thisspecialtreatmentofvenablestheanalysis \ntocomputeL(v,q)=l10+l20-d0,whereqistheprogram pointatthetopoftheloopbody. Thislowerboundl10+l20-d0:v=l1+l2-d \ntranslatesimmediatelyintoanupperboundford:d:(l1+ l2)-(l10+l20-d0).Thecompilerusesthetestconditions l1<h10andl2<h20toeliminatel1andl2fromthe \ninequality,derivingtheupperboundfordatthetopof theloop:d:(h10-1+h20-1)-(l10+l20-d0)= d0+(h10-l10)+(h20-l20)-2. \n4.2IntegerDivision Aspresentedsofar,thealgorithmassumesthatdivisionis exact,i.e.,itisidenticaltorealdivision.Butaddresscal\u00adculationsindivideandconquerprogramsoftenuseinteger \ndivision.Forpositiveexpressionse,thecompilerusesthe followingequationstoeliminateintegerdivisionoperations \nfromlowerandupperboundpolynomials: (jk) eL(e,p)-n+1 L,p= nn (jk) eU(e,p) U,p= nn Thecompilerusessimilarequationsifeisnegative,orif \nthereisnoinformationaboutthesignofe.Withthesemod\u00adifcations,thesymbolicanalysisalgorithmcorrectlyhandles \nprogramswithintegerdivision. 4.3ConstraintSystemDecomposition Aspresentedsofar,thealgorithmgeneratesasinglelinear \nprogramforeachsymbolicconstraintsystem.Ifitisnot possibletostaticallyboundoneofthepointerorarrayin\u00addexvariables(intheintraproceduralboundsanalysis)orone \nofthesymbolicregions(intheinterproceduralregionanal\u00adysis),thelinearprogramsolverwillnotdeliverasolution, \nandthealgorithmwillsetallboundsinthesystemtocon\u00adservative,infnitevalues,eventhoughitmaybepossibleto staticallycomputesomeofthebounds.Weavoidthisform \nofimprecisionbydecomposingthesymbolicconstraintsys\u00adtemintosmallersubsystems.Thisdecompositionisolates, \nasmuchaspossible,variablesandregionswithoutstatically computablebounds. Thedecompositionproceedsasfollows.Wefrstbuilda \nboundsdependencegraph.Thenodesinthisdirectedgraph aretheunknownsymbolicboundslv,panduv,inthecon\u00ad p straintsystem(intheintraproceduralboundsanalysis)or \nthelowerandupperboundsofthesymbolicregions(in theinterproceduralregionanalysis).Theedgesrefectthe dependencesbetweenthebounds.Foreachsymboliccon\u00adstraintoftheformb:eorb:e,wherebisasymbolic \nboundandeisanexpressioncontainingsymbolicbounds, thegraphcontainsanedgefromeachboundinetob.In\u00adtuitively,thereisanedgefromoneboundtoanotherifthe \nsecondbounddependsonthefrstbound.Thealgorithm usestheboundsdependencegraphtodecomposetheoriginal constraintsystemintosubsystems,withonesubsystemfor \neachstronglyconnectedcomponentinthegraph.Itsolves thesubsystemsinthetopologicalorderofthecorresponding \nstronglyconnectedcomponents,withthesolutionsfowing alongtheedgesbetweenthestronglyconnectedcomponents \noftheboundsdependencegraph.Thesystemdecomposition ensuresthat: Theboundsofunrelatedvariablesandregionsfallinto \ndiferentandunrelatedsubsystems.Theanalysisthere\u00adforecomputestheboundsindependently,andafailure tocomputeaboundforonevariableorregiondoes \nnotafectthecomputationoftheboundsfortheother variablesandregions. Theboundsofavariableatdiferentprogrampoints \nfallintodiferentsubsystemsiftheprogrampointsare notinthesameloop.Thus,outsideloops,thesystem decompositionseparatesthecomputationofboundsat \ndiferentprogrampoints. Unrelatedlowerandupperboundsofthesamevariable atthesameprogrampointfallintodiferentandunre\u00adlatedsubsystems.Theanalysiscanthereforecompute \napreciselowerboundofavariableevenifthereisno informationabouttheupperboundofthatvariable, andviceversa. \nThedecompositionalsoimprovestheefciencyofthe algorithm.Thesmaller,decomposedsubsystemssolvemuch fasterthantheoriginalsystem.Mostofthesubsystems \naretrivialsystemswithonlyonetargetbound,andweuse specialized,fastsolversforthesecases. Finally,thesystemdecompositionenablesthealgorithm \ntoextendtheintraproceduralanalysistohandlenonlinear polynomialbounds.Wefrstextendthebasicblockanaly\u00adsisfromSection3.3tohandleassignmentsandconditionals \nwithnonlinearpolynomialexpressionsintheprogramvari\u00adables.Thesenonlinearexpressionsgeneratenonlinearcom\u00adbinationsoftheboundslanduinthesymboliccon\u00ad \nvpvp straintsystem.Unfortunately,thelinearprogramreduction cannotbeappliedinthiscasebecauseofthepresenceof \ntermsthatcontainproductsofthecoefcientvariables. Thesystemdecompositionallowsthecompilertouse asimplesubstitutionalgorithmtosolvethisproblemand \nsupportnonlinearboundsexpressionsprovidedthattherel\u00adevantboundsarenotpartofacycleintheboundsdepen\u00addencegraph.Oncethecompilerhassolvedonesubsystem, \nitcanreplaceboundsinsuccessorsubsystemswiththeso\u00adlutionfromthesolvedsubsystem.Thissubstitutionelim\u00adinatesnonlinearcombinationsofboundsinthesuccessor \nsubsystems,enablingtheanalysistousethelinearprogram reductionorspecializedsolverstoobtainasolutionforthe \nsuccessorsubsystems. 4.4AnalysisContexts Aspresentedsofar,thesymbolicinterproceduralanalysis generatesasingleresultforeachprocedure.Inreality,the \npointeranalysisgeneratesaresultforeachcontextinwhich eachproceduremaybeinvoked[25].Thesymbolicanalysis \n alsogeneratesaresultforeachcontextratherthanaresult foreachprocedure. Thepointeranalysisalgorithmusesghostallocationblocks \ntoavoidreanalyzingproceduresforequivalentcontexts[25]. Wethereforeextendtheunmappingalgorithmdiscussedin \nSection3.4.4toincludeatranslationfromtheghostallo\u00adcationblocksintheanalysisresulttotheactualallocation \nblocksatthecallsite. 5ExperimentalResults WeusedtheSUIFcompilerinfrastructure[1]toimplement acompilerbasedontheanalysisalgorithmspresentedinthis \npaper.WeextendedtheSUIFsystemtosupportprograms writteninCilk,aparallelversionofC[4].Givenasequential \nCprogram,ourcompilerwillautomaticallyparallelizeit. GivenaCilkprogram,ourcompilerwilldetermineifitisfree \nofdataraces.Forbothkindsofprograms,ourcompilerwill determineifitmayviolateitsarraybounds.Ourcompiler \nwouldalsoeliminatearrayboundschecksiftheunderlying language(C)hadthem.Wepresentexperimentalresultsfor \nseveraldivideandconquerprograms: Fibonacci:StandardrecursiveFibonaccibenchmark.  Quicksort:Divideandconquerquicksort. \n Mergesort:Divideandconquermergesort.  Heat:Solvesheatdifusiononamesh.  Knapsack:Solvesthe0/1knapsackproblem. \n BlockMul:Divideandconquerblockedmatrixmul\u00adtiply.Allocatestemporaryarraysonthestack.  NoTempMul:Divideandconquerblockedmatrix \nmultiplywithnotemporaryarrays.  LU:DivideandconquerLUdecomposition. Wehavesequentialandparallelversionsofallprograms. \nWewouldliketoemphasizethechallengingnatureofthe programsinthisbenchmarkset.Mostofthemcontainmul\u00adtiplemutuallyrecursiveprocedures,andhavebeenheavily \noptimizedbyhandtoextractthemaximumperformance. Asaresult,theyheavilyuselow-levelCfeaturessuchas pointerarithmeticandcasts.Ouranalysishandlesallof \ntheselow-levelfeaturescorrectly. 5.1DataRaceDetectionandArrayBoundsViolations Theanalysisverifesthatalloftheparallelprogramsexcept \nKnapsackarefreeofdataraces.ThedataraceinKnapsack isusedtoprunethesearchspace.Thisdataraceisinten\u00adtionalandpartofthealgorithmdesign,butcausesnonde\u00adterministicbehavior.Theanalysiswasalsoabletoverify \nthatnoneofthebenchmarksviolatesthearraybounds. 5.2AutomaticParallelization Theanalysiswasabletoautomaticallyparallelizeallofthe \nsequentialprogramsexceptKnapsack,whoseparallelization wouldhaveadatarace.Ingeneral,theanalysisdetectedthe \nsamesourcesofparallelismasintheCilkprograms.Weran thebenchmarksonaneightprocessorSunUltraEnterprise Server.Table1presentsthespeedupsofthebenchmarks \nwithrespecttothesequentialversions,whichexecutewith noparallelizationoverhead.Insomecasestheparallelized \nversionrunningononeprocessorrunsfasterthanthese\u00adquentialversion,inwhichcasetheabsolutespeedupisabove \noneforoneprocessor.WeranQuicksortandMergesorton arandomlygeneratedfleof8,000,000numbers,andBlock\u00adMul,NoTempMulandLUona1024by1024matrix. \nProgram NumberofProcessors 1 2 4 6 8 Fibonacci 0.76 1.52 3.03 4.55 6.04 Quicksort 1.00 1.99 3.89 5.68 \n7.36 Mergesort 1.00 2.00 3.90 5.70 7.41 Heat 1.03 2.02 3.89 5.53 6.83 BlockMul 0.97 1.86 3.84 5.70 7.54 \nNoTemp 1.02 2.01 4.03 6.02 8.02 LU 0.98 1.95 3.89 5.66 7.39 Table1:AbsoluteSpeedupsforParallelizedPrograms \nPercentageofPercentageof ProgramEliminatedEliminated RegisterBitsMemoryBits convolve35.94%25.76% histogram30.56%73.86% \nintfr36.72%1.59% intmatmul47.32%35.42% jacobi42.71%75.00% life65.92%96.88% median43.75%3.12% mpegcorr58.20%53.12% \npmatch59.38%47.24% Table2:BitwidthAnalysisResults 5.3BitwidthAnalysis Bitwidthanalysishasrecentlybeenidentifedasaconcrete \nvaluerangeproblem[27].Eventhoughouralgorithmisde\u00adsignedtoextractsymbolicbounds,itextractsexactnumeric \nboundswhenitispossibletodoso.Byadjustingoural\u00adgorithmtocomputeboundsforallvariablesandnotjust pointersandarrayindices,weareabletoapplyouralgo\u00adrithmtothebitwidthanalysisproblem.Table2presents \nexperimentalresultsforseveralprograms.Wereportreduc\u00adtionsintwokindsofprogramstate:registerstate,which \nholdsscalarvariables,andmemorystate,whichholdsarray variables.Ouranalysisisabletosignifcantlyreducethe \nnumberofbitsrequiredtoholdthestateoftheprogram. 6RelatedWork Wediscussseveralareasofrelatedwork:researchinsym\u00adbolicmemoryaccessregionanalysis,arrayboundscheck \nelimination,racedetection,andparallelizingcompilers. 6.1SymbolicMemoryAccessRegionAnalysis Researchershavepreviouslyproposedseveralalgorithmsfor \nthesymbolicanalysisofaccessedmemoryregionsinsequen\u00adtialprograms[18,24,15].Thesealgorithmsusefxed-point \napproachestoanalyzerecursiveprograms,employingava\u00adrietyofad-hoctechniques(suchasartifciallylimitingthe \nnumberofiterationsorusingimprecisewideningoperators) toavoidtheproblemofinfniteascendingchainsinthedo\u00admainofsymbolicexpressions.Inaddition,previoustech\u00adniquestendedtoexploittheloopstructureoftheprogram \ntodeterminetheregionsofmemorydirectlyaccessedby eachprocedure,ratherthanprovidingageneralframework forarbitrarycontrolfow.Thispaperreplacestheselimited \ntechniqueswithaclean,generalformulationoftheproblem. Asaresult,ourtechniquescansuccessfullyanalyzeawider \nrangeofprograms.Andwehavegeneralizedourtechniques toanalyzebothsequentialandparallelprograms. 6.2ArrayBoundsCheckElimination \nThereisalonghistoryofresearchonarrayboundscheck elimination[5,19,22,20].Atypicalgoalistomovechecks outofloopsortodetectthattheloopterminationcondition \nensuresthatarrayaccesseswithintheloopdonotviolate thearraybounds.Thegoalofoptimizingchecksinloops tendstoproduceintraproceduralanalysesthatfocusonthe \nsimpleconditionalsthatoccurfrequentlyinprogramsthat useloopsastheirprimarycontrolstructure. Ourapproachisdesignedtohandleprogramsthatuse \nrecursionastheirprimarycontrolstructure.Itispossible tousetheextractedpointerandindexvariableboundsto \neliminatechecksatindividualarrayaccesssites.Ourcom\u00adpilerinsteadcheckstheextractedsymbolicregionsagainst \nthesizeofthearrayattheallocationsitetoverifythatin\u00advokedproceduresdonotviolatethearraybounds.Because \noursourcelanguagedoesnothavearrayboundschecks,our implementedcompilerusesthisinformationtodetectar\u00adrayboundsviolations.Butforlanguageswitharraybounds \nchecks,theinformationwouldenablethecompilertoelimi\u00adnateallchecksinthecallgraphrootedattheinvokedpro\u00adcedure.Tomakethisapproachworkforourtargetclassof \napplications,wehadtousesymbolicpolynomialswithratio\u00adnalcoefcientsinsteadofthesimplerexpressionsoftenused \ninpreviousapproachesthataredesignedtoworkwellfor loop-basedprograms.Unlikesomepreviousresearchers,we \nhavenotattemptedtoeliminatepartiallyredundantchecks ormovecheckstolessfrequentlyexecutedprogrampoints. \n6.3RaceDetection Dataracesarewidelyrecognizedasaseriousproblemfor parallelprogrammers.Severalresearchershaveattackedthe \nproblembydevelopingpackagesthatdynamicallyrecordin\u00adformationaboutthememorylocationsthatparallelthreads \naccess,thenusetheinformationtodeterminethepresenceor absenceofracesinaspecifcexecutionoftheprogram[11,9]. \nInthiscontext,adataraceoccurswhenonethreadwrites amemorylocation,anotherthreadaccessesthesamemem\u00adorylocation,andtheaccessesarenotprotectedbymutual \nexclusionorsignal/waitsynchronization.Ouralgorithms diferinthattheycanstaticallycertifythatallexecutions \noftheprogramarefreeofdataraces,andinthattheyare designedforprogramsthatusefork/joinsynchronization, notmutualexclusionorsignal/waitsynchronization. \nResearchershavealsodevelopedstaticanalysesthatal\u00adlowprogrammerstodeclarethecorrespondencebetween locksandthepiecesofdatathattheyprotect[28,10,12]. \nTheanalysisthenchecksthattheprogramcorrectlyholds theappropriatelockwhenitaccessesdata.Weviewthese techniquesasorthogonaltoours.Ourtechniquesdetermine \nwhenparallelthreadsaccessdisjointregionsofdynamically allocatedarrays;lock-basedanalysesensurethatparallel \nthreadsholdthecorrectlockwhentheyaccessshareddata. 6.4ParallelizingCompilers Previousresearchinparallelizingcompilershasfocusedon \nparallelizingloopneststhataccessdensematricesusingafne accessfunctions[1,3,17].Thetechniquespresentedinthis \npaper,ontheotherhand,aredesignedforprogramswithre\u00adcursiveprocedures,dynamicmemoryallocation,andpointer \narithmetic.Onamorephilosophicallevel,wehavegener\u00adalizedouralgorithmstothepointwheretheyunifytheau\u00adtomaticparallelizationproblemforsequentialprogramsand \nthestaticracedetectionproblemforparallelprograms. Manyparalleltreetraversalprogramscanbeviewedas divideandconquerprograms.Shapeanalysisisdesignedto \ndiscoverwhenadatastructurehasacertain\\shape\"such asatreeorlist[7,26].Severalresearchershaveusedshape \nanalysisasthebasisforcompilersthatautomaticallyparal\u00adlelizedivideandconquerprogramsthatmanipulatelinked \ndatastructures.Commutativityanalysisviewscomputa\u00adtionsassequencesofoperationsonobjects[23].Itgener\u00adatesparallelcodeifallpairsofoperationscommute.We \nviewbothcommutativityanalysisandshapeanalysisasor\u00adthogonaltoouranalyses. Conclusion Thispaperpresentsanewanalysisframeworkforthesym\u00adbolicboundsanalysisofpointers,arrayindices,andac\u00adcessedmemoryregions.Standardprogramanalysistech\u00adniquesfailforthisproblembecausetheanalysisdomain \nhasinfniteascendingchains.Insteadoffxedpointalgo\u00adrithms,ouranalysisusesaframeworkbasedonsymbolic constraintsreducedtolinearprograms.Ourpointeranal\u00adysisalgorithmenablesustoapplyourframeworktocom\u00adplicatedrecursiveprogramsthatusedynamicmemoryal\u00adlocationandpointerarithmetic.Experimentalresultsfrom \nourimplementedcompilershowthatouranalysiscansuc\u00adcessfullysolveseveralimportantprogramanalysisproblems, \nincludingstaticracedetection,automaticparallelization, staticdetectionofarrayboundsviolations,eliminationof \narrayboundschecks,andreductionofthenumberofbits usedtostorecomputedvalues. Acknowledgements WewouldliketothankAlexSalcianuandBrianDemsky \nfortheirhelpingeneratingtheexperimentalresults.We wouldalsoliketothankDarkoMarinovfordiscussionsre\u00adgardingtheboundsdependencegraphandMarkStephenson \nforprovidinguswiththebitwidthanalysisbenchmarks. References [1]S.Amarasinghe,J.Anderson,M.Lam,andA.Lim.Anoverview \nofacompilerforscalableparallelmachines.InProceedingsof theSixthWorkshoponLanguagesandCompilersforParallel \nComputing,Portland,OR,August1993. [2]C.ScottAnanian.SiliconC:Ahardwarebackendfor SUIF.Availablefromhttp://fex-compiler.lcs.mit.edu/SiliconC/ \npaper.pdf,May1998. [3]W.Blume,R.Eigenmann,K.Faigin,J.Grout,J.Hoefinger, D.Padua,P.Petersen,W.Pottenger,L.Raughwerger,P.Tu, \nandS.Weatherford.EfectiveautomaticparallelizationwithPo\u00adlaris.InInternationalJournalofParallelProgramming,May \n1995. [4]R.Blumofe,C.Joerg,B.Kuszmaul,C.Leiserson,K.Randall, andY.Zhou.Cilk:Anefcientmultithreadedruntimesystem. \nJournalofParallelandDistributedComputing,37(1):55{69, August1996. [5]R.Bodik,R.Gupta,andV.Sarkar.ABCD:Eliminatingarray \nboundschecksondemand.InProceedingsoftheSIGPLAN'00 ConferenceonProgramLanguageDesignandImplementation, \nVancouver,Canada,June2000. [6]M.Budiu,S.Goldstein,M.Sakr,andK.Walker.BitValueinfer\u00adence:Detectingandexploitingnarrowbitwidthcomputations. \nInProceedingsoftheEuroPar2000EuropeanConferenceon ParallelComputing.Munich,Germany,August2000. [7]D.Chase,M.Wegman,andF.Zadek.Analysisofpointersand \nstructures.InProceedingsoftheSIGPLAN'90Conferenceon ProgramLanguageDesignandImplementation,pages296{310, \nWhitePlains,NY,June1990.ACM,NewYork. [8]S.Chatterjee,A.Lebeck,P.Patnala,andM.Thottethodi.Re\u00adcursivearraylayoutsandfastmatrixmultiplication.InProceed\u00adingsofthe11thAnnualACMSymposiumonParallelAlgo\u00adrithmsandArchitectures,SaintMalo,France,June1999. \n[9]G.Cheng,M.Feng,C.Leiserson,K.Randall,andA.Stark.De\u00adtectingdataracesinCilkprogramsthatuselocks.InProceedings \nofthe10thAnnualACMSymposiumonParallelAlgorithms andArchitectures,June1998. [10]D.Detlefs,K.R.Leino,G.Nelson,andJ.Saxe.Extendedstatic \nchecking.TechnicalReport159,CompaqSystemsResearchCen\u00adter,1998. [11]A.DinningandE.Schonberg.Detectingaccessanomaliesinpro-gramswithcriticalsections.InProceedingsoftheACM/ONR \nWorkshoponParallelandDistributedDebugging,SantaCruz, CA,May1991. [12]C.FlanaganandS.Freund.Type-basedracedetectionforjava. \nInProceedingsoftheSIGPLAN'00ConferenceonProgram LanguageDesignandImplementation,Vancouver,Canada, June2000. \n[13]J.FrensandD.Wise.Auto-blockingmatrix-multiplicationor trackingBLAS3performancefromsourcecode.InProceedings \nofthe6thACMSIGPLANSymposiumonPrinciplesandPrac\u00adticeofParallelProgramming,LasVegas,NV,June1997. [14]M.Frigo,C.Leiserson,andK.Randall.Theimplementationof \ntheCilk-5multithreadedlanguage.InProceedingsoftheSIG\u00adPLAN'98ConferenceonProgramLanguageDesignandIm\u00adplementation,Montreal,Canada,June1998. \n[15]M.Gupta,S.Mukhopadhyay,andN.Sinha.Automaticparal\u00adlelizationofrecursiveprocedures.InProceedingsofthe1999 \nConferenceonParallelAlgorithmsandCompilationTech\u00adniques(PACT)'99,NewportBeach,CA,October1999. [16]F.Gustavson.Recursionleadstoautomaticvariableblocking \nfordenselinear-algebraalgorithms.IBMJournalofResearch andDevelopment,41(6):737{755,November1997. [17]M.W.Hall,S.Hiranandani,K.Kennedy,andC.Tseng.In\u00adterproceduralcompilationofFortranDforMIMDdistributed\u00admemorymachines.InProceedingsofSupercomputing'92,Min\u00adneapolis,MN,November1992.IEEEComputerSocietyPress, \nLosAlamitos,Calif. [18]P.HavlakandK.Kennedy.Animplementationofinterproce\u00adduralboundedregularsectionanalysis.IEEETransactionson \nParallelandDistributedSystems,2(3):350{360,July1991. [19]P.KolteandM.Wolfe.Eliminationofredundantarraysubscript \nrangechecks.InProceedingsoftheSIGPLAN'95Conference onProgramLanguageDesignandImplementation,SanDiego, \nCA,June1995. [20]V.Markstein,J.Cocke,andP.Markstein.Optimizationofrange checking.InProceedingsoftheSIGPLAN'82Symposiumon \nCompilerConstruction,Boston,MA,June1982. [21]F.Nielson,H.Nielson,andC.Hankin.PrinciplesofProgram Analysis.Springer-Verlag,1999. \n[22]J.Patterson.Accuratestaticbranchpredictionbyvaluerange propagation.InProceedingsoftheSIGPLAN'95Conference \nonProgramLanguageDesignandImplementation,SanDiego, CA,June1995.ACM,NewYork. [23]M.RinardandP.Diniz.Commutativityanalysis:Anewanaly\u00adsistechniqueforparallelizingcompilers.ACMTransactionson \nProgrammingLanguagesandSystems,19(6):941{992,Novem\u00adber1997. [24]R.RuginaandM.Rinard.Automaticparallelizationofdivide \nandconqueralgorithms.InProceedingsofthe7thACMSIG-PLANSymposiumonPrinciplesandPracticeofParallelPro\u00adgramming,Atlanta,GA,May1999. \n[25]R.RuginaandM.Rinard.Pointeranalysisformultithreaded programs.InProceedingsoftheSIGPLAN'99Conferenceon \nProgramLanguageDesignandImplementation,Atlanta,GA, May1999. [26]M.Sagiv,T.Reps,andR.Wilhelm.Solvingshape-analysisprob\u00adlemsinlanguageswithdestructiveupdating.ACMTransactions \nonProgrammingLanguagesandSystems,20(1):1{50,January 1998. [27]M.Stephenson,J.Babb,andS.Amarasinghe.Bitwidthanalysis \nwithapplicationtosiliconcompilation.InProceedingsofthe SIGPLAN'00ConferenceonProgramLanguageDesignand \nImplementation,Vancouver,Canada,June2000. [28]N.Sterling.Warlock:Astaticdataraceanalysistool.InPro\u00adceedingsofthe1993WinterUsenixConference,January1994. \n\t\t\t", "proc_id": "349299", "abstract": "<p> This paper presents a novel framework for the symbolic bounds analysis of pointers, array indices, and accessed memory regions.  Ourframework formulates each analysis problem as a system of  inequality constraints between symbolic bound polynomials. It then reduces the constraint system to a linear program. The solution to the linear program provides symbolic lower and upper bounds for the values of pointer and array index variables and for the regions of memory that each statement and procedure accesses. This approach eliminates fundamental problems associated with applying standard fixed-point approaches to symbolic analysis problems. Experimental results from our implemented compiler show that the analysis can solve several important problems, including staticrace detection, automatic parallelization, static detection of arraybounds violations, elimination of array bounds checks, and reduction of the number of bits used to store computed values. </p>", "authors": [{"name": "Radu Rugina", "author_profile_id": "81100094619", "affiliation": "Laboratory for Computer Science, Massachusetts Institute of Technology, Cambridge, MA", "person_id": "P237448", "email_address": "", "orcid_id": ""}, {"name": "Martin Rinard", "author_profile_id": "81100087275", "affiliation": "Laboratory for Computer Science, Massachusetts Institute of Technology, Cambridge, MA", "person_id": "P192534", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/349299.349325", "year": "2000", "article_id": "349325", "conference": "PLDI", "title": "Symbolic bounds analysis of pointers, array indices, and accessed memory regions", "url": "http://dl.acm.org/citation.cfm?id=349325"}