{"article_publication_date": "05-01-2000", "fulltext": "\n . ContaminatedGarbageCollection DanteJ.Cannarozzi,MichaelP.Plezbert,andRonK.Cytron WashingtonUniversityBox1045 \nDepartmentofComputerScience St.Louis,MO63130USA Abstract Wedescribeanewmethodfordeterminingwhenanobject \ncanbegarbagecollected.Themethoddoesnotrequire markingliveobjects.Instead,eachobjectXisdynam\u00adicallyassociatedwithastackframeM,suchthatXis \ncollectablewhenMpops.BecauseXcouldhavebeendead earlier,ourmethodisconservative.Ourresultsdemonstrate \nthatthemethodnonethelessidentifesalargepercentageof collectableobjects.Themethodhasbeenimplementedin \ntm Sun'sJavaVirtualMachineinterpreter,andresultsare presentedbasedonthisimplementation. Introduction \nIneducation,research,andindustry,useofgarbage-collected languagessuchasJavaandMLremainsstrong.However, \ndespitemanyadvances,thecostofautomaticgarbagecol\u00adlectioncontinuestobeprohibitiveinsomeareas,notably embedded,real-time,andscientifcapplications. \n.CPUcyclesmustbedevotedtocollectingthegarbage. Incrementalsystemsamortizethecost,andextrapro\u00adcessorscanhidethecostifthoseprocessorshavenoth\u00adingbettertodo. \n.Theneedforcollectioncanoccuratunpredictableand inopportunetimes. .Storagebecomesfragmentedunlessobjectsaremoved, \nbutobjectrelocationfoolsmoststoragesystems.An objectcanbeincache,butknownbyitsformerad\u00address.Accessoftheobjectatthenewaddressresults \ninafaultfollowedbyafetchfromslowerstorage. .Traditionalgarbagecollectorsmarkliveobjects.While generationalcollectioncanlimitsuchmarkingtoa \nsubsetofaprogram'sliveobjects,themarkingphase pollutesthecacheastheliveobjectsaretouched. .SponsoredbytheNationalScienceFoundation,undergrant \nNCR9628218;contactauthorcytron@cs.WUSTL.edu Permissiontomakedigitalorhardcopiesofallorpartofthisworkfor \npersonalorclassroomuseisgrantedwithoutfeeprovidedthatcopies arenotmadeordistributedforproftorcommercialadvantageand \nthatcopiesbearthisnoticeandthefullcitationonthefrstpage.To copyotherwise,orrepublish,topostonserversortodistributeto \nlists,requirespriorspecifcpermissionand/orafee. PLDI2000,Vancouver,BritishColumbia,Canada. Copyright2000ACM1{58113{199{2/00/0006...$5.00. \nInthispaper,weproposeandevaluatetheperformanceofa newscheme,thecontaminatedgarbage(CG)collector.This \nnewcollectorhasthefollowingproperties: .Itcanoperateinconcertwithatraditionalcollector, decreasingthefrequencywithwhichthetraditional \ncollectormustbecalled. .Itdoesnotrequirea\\marking\"phase,sothatdata cachesremainvalidevenasobjectsarecollected. \n.Itcollectsareasonablepercentageofdeadobjects. .Itcorrectlyidentifesdeadobjects,butobjectsthatit thinksarelivemayinfactbedead. \nToelaborateonthelastpoint,CGcollectionisconservative, thoughnotinthetraditionalsenseofthatterm.Conserva\u00adtivecollectionhasbeenproposedforlanguages(suchasC) \ninwhichreferencevariablescannotbepreciselydetermined; suchcollectorsareconservativebecausetheymaybeforced \ntotreatavalueasapointer[3].TheCGcollectoriscon\u00adservativeinadiferentwayandfordiferentreasons,aswe explainshortly. \nOurpaperisorganizedasfollows:Section2explains ourapproachusingasimpleexample.Section3describes animplementationofaCGcollector,alongwithcompli\u00adcationsthatarisefrommultiplethreadsandnativecode. \nSection4comparesourapproachwithpreviouswork.Sec\u00adtion5presentsexperimentsbasedonthisimplementation. Section6presentsconclusionsandideasforfutureworkin \nthisarea. 2Approach Ourideaisbasedonthefollowingpropertyofsingle\u00adthreadedprograms(multiplethreadsareaddressedinSec\u00adtion3).EachobjectXintheheapisliveduetoreferences \nthatultimatelybeginintheprogram'sruntimestackand 1 staticareas.Whenthesetofframescontainingdirector indirectreferencestoXispopped,thenXisnolongerlive \nanditcanbecollected. Moreover,owingtothenatureofastack,thesetof framesthatkeepXlivemustcontainsomeframeMthat \nislast-to-be-popped(oldest)amongtheset'sframes.The livenessofXcanthusbetiedtoframeM:whenframeM pops,Xcanbecollected. \n1Weviewstaticreferencesasstemmingfromaprogram'sinitial stackframe. 5 0 Figure1:Framesthatkeepobjectslive. \n2.1Example WeillustratetheCGcollectorusingtheexampleshownin Figure1.Thestackframesareshownnumberedfrom0to5 \nframe5isyoungestframe,andframe0isnotpoppeduntil theprogramfnishes.Eachframecorrespondstoamethod invocation,andthelocalvariablesforeachmethodreside \nwithinthemethod'sframe.Theobjects,labeledwithletters AthroughF,resideintheheap.ArrowsinFigure1depict \nthereferencesfromthemethods'localvariablestotheheap objects.ThoughnotshowninFigure1,weassumeeach objectXhasafeldxthatiscapableofreferencingany \notherobject.Also,weassumeinthisexamplethatany methodcanaccesstheprogram'sstaticvariables. GiventheframereferencesshowninFigure1,thelive\u00adnessoftheobjectsisasfollows. \nObjectReferencingFramesEarliestFrame A 3,53 B 2,52 C 1,51 D 4,54 E 00 AlthoughAisreferencedbytwoframes,theobjectislive \nuntilframe3ispopped.Thisillustratesanimportantprop\u00adertyofourapproach.WitheachobjectX,weassociatea singleframeMsuchthatwhenMispopped,Xisknown \ntobedead|wethensaythatX'slifedependsonframeM, orthatMisX'sdependentframe. Asaspecialcase,weassociateframe0withobjects \nthatarereferencedbystaticvariables.Thus,CGcollection determinesthatvariablessuchasEinFigure1appeartobe \nliveforthedurationoftheprogram.Frame0alsoservesto representobjectsforwhichwe(currently)cannotdetermine \nadependentframe,asdiscussedinSection3. WiththesituationshowninFigure1,itisclearthatD couldbecollectedwhenframe4pops.However,programs \ncancauseoneobjecttoreferenceanother,whichhasthe efectofchanginganobject'sdependentframe.Wenext examinethelivenessofeachobjectasthefollowingprogram \nexecutesstatementsthatcauseoneobjecttoreferencean\u00adother.AllofthesestatementsareexecutedwithinFigure1's \nframe5|theframeofthecurrentlyactivemethod.Forour example,weassumethismethodhasaccesstoallobjectsas follows.ObjectsAthroughDarereferencedusingframe \n5'sparameters(localsintheJVM) objectEisstaticand globallyaccessible. B:b=A (1 C:c=B (2 D:d=C (3 E:e=D \n(4 E:e=. (5 Figure2:Instructionsafectobjectlifetime. Theefectsoftheprogram'sstepsonthelivenessofthe \nheapobjectsaredescribedasfollows. 1BnowreferencesA.Withthisreferenceestablished,A canbecollectednoearlierthanB.Thus,A'sdependent \nframeischangedfrom3to2. WesaythatBhascontaminatedAbytouching(refer\u00adencing)it. 2CnowcontaminatesBwhichstillreferencesA.Thus,the \nlivenessofbothBandAmustbeadjusted,sothatthey arenowdependentonframe1. 3AlthoughDnowcontaminatesC,Ddependsonframe \n4,whichwillbepoppedbeforeCisdead.Thus,the dependentframesofA,B,andCarenotchanged| thoseobjectsalldependonframe1. \nHowever,Dnowhasaccesstothoseobjects.IfD's livenesschanged,thenthelivenessofthoseobjects mightalsobeafected.Ouralgorithmtrackssuch \ninformationefciently,thoughconservatively. 4Sureenough,EnowcontaminatesD,whichmakesallthe objectstakeonitsliveness.Thus,allobjectsbecome \ndependentonframe0. 5AlthoughEhascontaminatedD,Enolongerreferences it.Ideally,thisshouldreverttheactuallivenessofA{ \nDtothesituationafter4.Forexample,Acanbe collectedwhenframe1pops. Inourapproach,however,contaminationcannotbe \nundone.OnceEcontaminatestheothervariables(in\u00addirectly,bycontaminatingD),theybecomedependent onframe0.Theirdependencecannotbeimprovedto \nayoungerframe. Anextremeexampleofthisisthe\\staticfngerof death\".Supposeastaticvariablereferenceseveryheap \nobject.Ateachcontamination,theafectedobject becomesdependentonframe0,whichisn'tpopped untiltheprogramfnishes.AsshowninSection5, \nactualprogramshavebettermanners. Anunresolvedissuefromtheabovediscussionconcernshow totracktheefectsofaprogram'sfuturebehaviorafter. \n3 TheproblemisthatDdoesn'tchangeanyobject'slifetime byreferencingC.However,futurechangestoD'sdependent \nframemayafectobjectsthatcanbereferencedfromD. Weaccommodatethisproblembyassertingthatcon\u00ad taminationissymmetric,afectingbothXandYwhenX \nreferencesY.Thus,intheaboveexample,D'sdependent framebecomessynonymouswithC's,sothatfuturechanges toDarecorrectlyaccommodated.Unfortunately,thiscon\u00ad \nservativelymakesDdependentonframe1after3executes. 2.2Summary Insummary,theCGcollectoroperatesasfollows. \n.Wemaintainanequiliveequivalencerelationovera program'sheap-allocatedobjects.Objectsinthesame blockoftheinducedpartitionareviewedashavingthe \nsamelifetimeandaredependentonthesameframe. Equilivesetsgrowthroughunionoperations;anequi\u00adliveset'sdependentframecanchangeastheprogram \nexecutes,butalwaysbymovingtoanolderframe. .WhenaframeMpops,allequilivesetsassociatedwith Mcontainobjectsthatmustbedead.Suchobjects \ncanbesafelycollectedwhenMpops.Iftheobjects arealreadyinsomekindoflistL,thentheobjectscan bereturnedtotheavailablestoragepoolbyjoining \nLtothefree-storagelist.Thiscanbeaccomplished withtwostorageaccesses,whichshouldnotdisrupt theefectivenessofthedatacache. \n.TwoblocksAandBoftherelationaremerged(by aunionoperation)whenobjectsA2AandB2B contaminateeachother.Thiscouldhappenbecause \nAreferencesB,orbecauseBreferencesA. Anexceptiontothispolicyoccursinanoptimization describedinSection3.4. \n Whenanewblockisformedbymergingtwoexisting blocks,thenewblockisdependentontheolder(lower\u00adnumbered)oftheexistingblocks'dependentframes. \n ThelivenessofanobjectX,andthereforeX'sblock, isafectedifamethodreturnsXtoitscaller.The livenessofX'sblockmustbeadjustedsothatits \ndependentframeispoppednosoonerthanitscaller's.  Therefexiveandtransitiveaspectsofequiliveareaccurate. \nHowever,thesymmetricpropertyintroducesconservative\u00adness,asillustratedwiththeexampleofDabove. Ourapproachisthereforeconservative|thoughnotbe\u00adcausewecan'ttellwhatisareferenceandwhatisnot[3]. \nTheCGcollectormayoverestimatethelifetimeofanobject. Forsuchobjects,traditionalgarbagecollectionmaycollect \ntheobjectwhenwewouldnot.Wethereforeevaluateour approachinSection5byshowingthepercentageofobjects thatarecollectableusingCG. \nOurapproachdoeshavethefollowingadvantagesover traditionalcollection. Traditionalcollectionrequiresmarkingliveobjects. \nWhilegenerationalcollectors[18,10]canlimitthem\u00adselvestomarkingasubsetoftheliveobjects,this phaseofgarbagecollectionpollutesthecache(and \nmoredistantvirtualmemorycomponents)withob\u00adjectsthatarenotreferencedactivelybytherunning program[9]. \n Maintainingtheequiliverelationcanbeaccomplished efcientlyifthedisjointsetsofobjectsaremaintained usingTarjan'sunionbyrankandpathcompression \nheuristics[7].Theresultingoverheadisa(nearly) constantamountofworkperstoragereference.  3Implementation \nWeimplementedourapproachinthecontextofSun'sJava system,JDK1.1.8.Ourchangeswereconfnedtothose portionsoftheJavaVirtualMachine(JVM)[11]thatdeal \nwithobjectcreation,framecreation(inresponsetomethod calls),methodreturn,andthebase(traditional)garbage \ncollection.Sun's1.1.8systemofersthefollowingJVMin\u00ad terpreters. Thereferenceinterpreteris  Amoreefcientinterpreterquentlyexecutedportionsguage. \n Tofacilitateourimplementation,writtenentirelyinC. implementsthemostfre\u00adin(Sparc)assemblylan\u00ad webasedourworkonthe \nCversion.However,thechangeswemadearecompatible withthearchitectureofthe(speedier)assemblyversion. Wenextsketchourbasicimplementationanddescribe \nhowweaccommodateinterpreter-generatedstaticreferences andthemoreconceptuallydemandingcharacteristicsofthe \nJVM|namely,multiplethreadsandnativecode. 3.1DataStructuresandModifcations Sun'sJVMinterpretermanagesobjectsusinghandles.Each \nhandlecontainsapointertotheobject'scurrentlocationas wellasareferencetoanappropriatemethodtablefor(vir\u00adtual)method-lookup.Referencesbetweenobjectsindirect \nthroughthehandles.Thus,ifobjectsarerelocated(dur\u00adinggarbagecollection,forexample),thenonlythehandle's \npointertotheobjectneedstobeupdated. Theinterpreterofersastancallandmethod-return.Eachontoathread-specifcstack[1]. \nToimplementourapproach,systemasfollows. objects:Weaugmentedeachaccommodateunion/fnddardtreatmentofmethod\u00adactivationrecordispushed \nwemodifedSun'sJDK1.1.8 objecthandlewithfeldsto oftheequiliveblocks. Astraightforwardimplementationwouldrequireone \n\\ancestor\"feldandoneintegerfeldtorepresentthe rank(fordetailsonTarjan'salgorithm,see[7]).Of course,\\primitive\"objects(suchasintegers)donot \nusehandlesandthusdonotincuranyoverhead. Amorecleverrepresentationcanbeachievedbynoting thatthelowerbitsofJVMobjectpointersarealready \nreserved,andarethereforeassumedtobezero.The equilivesetscanthenbemaintainedsothattherank neverexceedsapredeterminedthreshold.Thus,the \nunion/fndalgorithmcanbeimplementedwithone additionalwordperobjecthandle. Ourapproachrequirestheabilitytodetermineany \nobject'sdependentframe.Inastraightforwardimple\u00admentation,thiscanbeachievedsimplybyintroducing apointerintothehandle,suchthatthepointerrefer\u00adencesthetheobject'sdependentframe. \nThispointercanbeeliminatedifeachequiliveset's representativeelementpointstothedependentframe fortheentireset. \nInsummary,theresultsreportedinthispaperwere obtainedbyintroducingfour32-bitwordsintowhat wasformerlya64-bitobjectheader.Althoughgood \nresultswereobtained,suchoverheadisexcessive,es-peciallyforsmallobjects.Reductionofthisoverhead usingtheaboveideasisthesubjectoffuturework. \nAnarrayistreatedasjustanotherobject|wedonot diferentiateanarray'selements.Thus,anyobject storedintoanarraycausesthearrayandtheobjectto \ncontaminateeachother. frames:Whenaframeispopped,theequiliveobjectsthat dependontheframecanbecollected.Thus,each \nframeisequippedwithareferencetoalistofitsde\u00ad pendentequiliveblocks. staticvariables:Wemaintainalistofobjectsthatare \ndependentonour\\frame0\".Suchvariablesarenever collectedbyourapproach. Essentially,theJVMinterpretermusttakeactionfor \nthoseJVMinstructionsthatcauseoneobjecttoreferto another.TheJVMinstructionsetconvenientlyseparates thesebywhetherthereferencingobjectisstatic. \n.Whenanobjectiscreated,itisassociatedwiththe frameofthecurrentlyactivemethod. .Theareturninstructioncausesamethodtoreturn \nanobjecttoitscaller.Theobject'sequiliveblockis adjustedtodependonthecaller'sframe,unlessthe objectisalreadydependentonanolderframe. \n.TheputfieldinstructioncausesobjectXtoreference Y.IfYisnotnull,thenXandYcontaminateeach other,asdescribedearlier. \nInthespecialcasewhereYisalreadystatic,theopti\u00admizationdescribedinSection3.4avoidscontaminating X. .Theputstaticinstructioncancauseastaticvariable \ntoreferenceanobject.Ifso,thereferencedobject's equiliveblockisaddedtothelistofframe-0dependent blocks. \nWebeganwithalmostnofamiliarityofSun'sJVMinter\u00adpreter.Nonetheless,ittookonly6weekstoimplementour approachinthatsystem.Whilethisisatributetothe \ninterpreter'sdesign,italsounderscoresthesimplicityofour approach.Similarly,thecodegeneratorofanative-code \ncompilercouldeasilybemodifedtoemitthenecessarycode tomaintainourstructures. 3.2Interpreter-generatedstaticreferences \nForourapproachtowork,itmustbeabletotakeaction whenoneobjectreferencesanother.Forcodewrittenin Java,thisrequirementposesnoproblem.However,the \ninterpretercanitselfgeneratereferencestoobjects,andwe hadtointegratesuchreferencesintoourgarbagecollector. \nAgoodexampleofthiskindofproblemistheintern() methodoftheStringclass.Aprogramcouldgenerate multipleStringobjects,eachwiththesamecontents.The \nintern()methodmapsanyStringtoauniqueoccurrence withitscontents.Thus,givenanytwostrings,equalityof theircontentscanbetestedusing\\==\"oncethestringsare \nmappedusingintern().JDK1.1.8implementsintern() usingahashtable|internaltotheinterpreter|tomaintain referencestotheuniqueoccurrencesofanyStringmapped \nviaintern().Thereferencesfromthehashtableareessen\u00adtiallystatic,sinceaStringmustmaptothesamereference \nviaintern()forthedurationofaprogram. BecausethisactivityisnotpartoftheJVMinstruction stream,wehadtoinsertcallsintheStringclasstotellour \ncollectorthatanyStringmappedviaintern()isstatic. TheclassloaderandJNI-processingcomponentswere othersourcesofstaticreferencestotheheap.Mostlikely, \nanyimplementationofJVMwillmaintainsuchreferences. Touseourapproach,theseneedtobeidentifedandproper callstoourcollectormustbeinserted. \n3.3MultipleThreadsandNativeCode A 5 5 4 4 3 3 2 2 1 1 0 0 Thread 1 Thread 2 Figure3:Twothreadssharinganobject. \nThediscussionsofarhasbeenlimitedtosinglethreads andJava-sourceprograms.Inthissection,wedescribeour currentlysimpletreatmentofmultiplethreadsandnative \ncode.Moresophisticationispossible,butthatisasubject offuturework. Ourassumptionthatanobjectisdependentforitslifeon \nasinglestackframedoesnotholdifaprogramsharessuch anobjectamongmultiplethreads,asshowninFigure3. WithinThread1,Aisdependentonframe3 \nhowever, Thread2canalsoaccessAuntilitsframe1ispopped. Forthepurposesofthispaper,wedynamicallydiscover \nobjectsthatareaccessedbymultiplethreadsandwetreat theirequiliveblocksasstatic|dependentontheprogram's \nframe0. Sun'sJVMsystemallowsnative(e.g.,C)codetobe interspersedwithJavacode|eachcancalltheother.A mechanism(objectpinning)isalreadyprovidedsonative \ncodecanrelyonanobject'saddress.However,whenCcode callsJavamethods,itispossiblethatobjectsarecreated andreturned,perhapsbriefy,tothenativecaller.Tobe \nconservative,wecatchsuchallocationsandtreattheequilive blocksasiftheywerestatic. 3.4AnOptimization WhiletheapproachdescribedinSection2iscorrect,we \nidentifedasituationforwhichwecanoferabettertreat\u00adment.Considertheresultsoftheassignment A:a=S whereSisstatic|associatedwiththelast-to-be-popped \nstackframe.AsdescribedinSection2,ourapproachwould uniontheequiliveblockscontainingAandS.Asaresult, Awouldalsoberegardedasstatic,existingforthelifetime \noftheprogram.However,inthiscase,suchactionisunnec-essarilyconservative.TheobjectSisalreadydetermined \nnottobecollectableuntiltheprogramisover.Nofurther actioncancauseStoberegardedasmorelivethanthat. Thus,ifSisbelievedtolastforthedurationoftheprogram, \nthereisnoreasontojoinA'sequilivebockwithS'swhenA referencesS. TherresultspresentedinSection5includethisoptimiza\u00adtion,exceptforonecolumninFigure4whichisdesignedto \nshowthebeneftsoftheoptimization. 4Previouswork Wilsonpresentsanexcellentsurveyofstorageallocation[19] \nandcollection[18]techniques.Allknownmethodsforexact garbagecollectionrequiremarkingliveobjectstosomeex\u00adtent.Generationalcollectionlimitsthescopeofthemarking \nphasetoasetofobjectsthatarebelievedmostlytobedead. Onewayofcomparingourworkistoexaminehowvari\u00adousapproachesviewthenotionofageneration. \n.Traditionalgenerationalcollectiondefnesagenera\u00adtionbythelongevityofitsobjects.Thisseparates newerfromolderobjects,sothatgarbagecollection \ncanconcentrateonthenewer(presumablyshorter\u00adlived)objects.Morerecently,ithasbeenproposed tofocusonotherthantheyoungestgeneration[15]. \n.Thetrainalgorithm,discussedbelow,viewsobjects notonlyintermsoftheirlongevity,butalsointerms oftheirinterconnection.Objectsthatreferenceeach \nothertendtobeclusteredinthesamegeneration.This nicelyaccommodatescyclicdatastructures,asthey becomefreeatthesametime. \n.Ouralgorithmattemptstoclusterobjects,notinterms oftheirlongevity,butintermsoftheirexpectedexpi\u00adration.Whentheymustdie|nothowlongtheyhave \nlived|isourkeyconcern.Wedynamicallycompute thetimeatwhichaclusterofobjectsmustbedead, basedonthereferencesamongtheobjects. \n4.1Generallyrelatedwork Appel[2]hasobservedthatstack-allocatedstorage(i.e., localvariables)canbemanagedmoreefcientlyusingthe \n(moregeneral)heap.Insteadofreclaimingeachframein\u00addividuallyuponitsmethod'sreturn,multipleframesare collectedwhengarbagecollectiontranspires.Insummary, \nAppelproposestotreatstack-allocatedobjectsasheap\u00adallocated.Weareessentiallytryingthedualofthatap\u00adproach:wemodelheap-allocatedobjectsasiftheywere \nallocatedinastackframe,butwecontinuallyrevisewhich stackframeholdsaheap-allocatedobject. Staticanalysistechniques[5,13,20]attempttodeter\u00adminethelifetimeofobjects,byfndingenvironmentsfrom \nwhichsuchobjectscannotescape.Therepresentationfor suchenvironmentscanbeastackframe[12],sothatobjects \naredirectlyassociatedwitha\\deeper\"stackframethanthe methodinwhichtheyareinstantiated. Also,thenotionofanenvironment-escapehasbeengen\u00aderalizedtothatofaregion[17,16].Regionsareperhapsthe \nclosestinnaturetotheideasexpressedinthispaper.As withourapproach,regionscandecreasetheneedformark\u00adbasedgarbagecollection.Aregionessentiallyintroduces \nastack-basedpairofallocationanddeallocationsitesfor anobject,wherethesitesaredeterminedbystaticanalysis \nandnotbyaprogram'ssyntax.Thedistinguishingfeature betweenregionsandourworkisthatregionsaredetermined \nstatically,whileourapproachoperatesdynamically. Itisnotclearthatregionsarebetterorworsethanour approach. \n.Ourapproachcontinuallyenlargesthe\\region\"asso\u00adciatedwithanobject,whentheobjectisreferenced byobjectswithlongerlifetimes.Forexample,thein\u00adstructionsequenceshowninFigure2leavesallobjects \ndependentonframe0inourapproach.Staticanalysis (suchasproposedinthe\\regions\"work)couldeasily showthatAcouldbecollectedwhenframe1pops. \n.Becausestaticmethodsmustaccommodateanypath throughaprogram,itispossiblethatourapproachcan farebetterbecauseitadjuststheexpectedexpiration \nofobjectsdynamically,asdeterminedbyactualexe-cutionpathsinaprogram.Thus,wemightdetermine thatanobjectcanbereleasedatapointpriortothat \nwhichstaticanalysiscanshowthattheobjectisfree. Theintegrationofourmethodwithstaticapproachesisthe subjectoffuturework. \n4.2Thetrainalgorithm Ourapproachisinfuencedbythetrainalgorithm[10,14]. Thatalgorithmcontinuallyreorganizestheheapsothat \nobjectsthatreferenceeachotherareclusteredatthetime thatsuchobjectsaredead.Inthejargonofthetrainalgo\u00adrithm[10],ourapproachcanbeexpressedasfollows.Each \nstackframeisassociatedwithatrain.Whenthestackframe ispopped,allcarsoftheframe'strainareknowntobe free,sowesimplyreturnthoseobjectstotheheap.The \ntrainalgorithmmovesobjectsbetweencarsoftrainsduring garbagecollection,withthegoalofclusteringobjectsthat \nreferenceeachother.Insteadofmovingindividualobjects, ourapproachessentiallyjoinstwotrains,leavingthemat\u00adtachedtotheappropriatestackframe.Wearelessprecise \nthanthetrainalgorithm,becausewedealwithobjectsonly intermsoftheircontainingtrains.Also,oncetrainsare \njoined,wedonotconsiderseparatingthem. Thetrainalgorithmismoreprecise,but|likeallgenera\u00adtionalapproaches|itrequireskeepingtrackofcertainkinds \nofreferences.Insummary,ourapproachdoesnotsupplant thetrainalgorithm.Bothapproachesareincremental:ob\u00adjectsthataredeadmaygouncollectedforsometime.Our \napproachavoidsmarking,andstorageisreturnedasmethod framesarepopped.Theintegrationofourmethodwiththe trainalgorithmisthesubjectoffuturework,asdiscussed \ninSection6. 5Experiments WeimplementedourapproachasdescribedinSection3.4. Wethenconductedexperimentsontheapproachusingthe \nprogramsdescribedinFigure4. .Thefrstprogramisastudent'scompilerproject(the parsingandsemanticanalysisphases),writtenbya \nJavanovice.Nothoughtwhatsoeverwasexpendedon efcientuseofobjects.Thesizeofthisprogramis infated:6088ofthelinesweregeneratedbyscanner\u00adandparser-generatingtools. \n.Theprogramstravandcornerscomputenavigation information(basedonshortest-path),usingUSCensus roaddescriptions[4].Theseprogramswerewrittenby \naJavaexpert,hand-optimizedtominimizetheneed forgarbagecollection.Ttravisamultithreadedver\u00adsionoftrav,designedtooperateasanapplet.Simi\u00adlarly,Tcornersisamultithreadedversionofcorners. \nTheappletversionsloadthedatainaseparatethread, undercontrolofappletbuttonsthatcansuspendor resumetheloading. \n.ThebottomsetofprogramsaretheSPECsuite[8]. Here,theywererunontheirsmallestproblemsizes.2 2Themtrtprogramisamultithreadedversionofraytrace;how\u00adever,multiplethreadsarerequiredforcomputationonlyforthelarger \nproblemsizes.Thus,ourresultsforthesetwoprogramsarevery similar. NameDescriptionLinesObjectsCollectable \nofsourcecreatedNooptWithopt jmm Compilerfromacourse 7552 20634 78% 79% corners Findsroadintersections \n4378 177477 36% 99% Tcorners Threadedversionofabove same 187450 36% 38% trav SolvesTSP,givesdir'ns 5747 \n542933 61% 79% Ttrav Threadedversionofabove same 552936 61% 61% compressjessraytracedbjavacmpegaudiomtrtjack \nModifedLempel-ZivExpertSystemRayTracer DatabaseManagerJavaCompilerMPEG-3decompressorRayTracer,threadedPCCTStool \n920570375010209485N/A3750N/A 5144461292770528088261277578276108410479 11%36%98%24%23%8%98%70% 14% 42% \n98% 41% 30% 9% 98% 90% Figure4:Benchmarks;Percentageofobjectscollectablebyourapproach,withoutandwiththeoptimizationdescribedin \nSection3.4. 5.1CollectableObjects Foreachbenchmark,Figure4showsthenumberofobjects createdduringitsrun.Therighttwocolumnsshowthe \npercentageofallobjectsthatwerecollectedbyourmethod. Therightmostcolumnshowsthepercentageofcollectable \nobjectswhentheoptimizationdescribedinSection3.4is enabled;thisisofcoursethepreferredimplementation.For \ncomparisonpurposes,wealsoshowthepercentageofobjects collectablewithouttheoptimization.Allotherobjectswere \ntreatedbyourmethodasstatic|liveuntiltheendofthe program.Givenourapproach,suchobjectsareeitherde\u00adclaredstaticorelsetheyarereferencedindirectlybyastatic \nobject. Theray-tracing,path-navigating,andjackprograms wereover90%collectableusingtheCGcollector.Thempeg\u00adaudioandcompressprogramsdonotgeneratemanyob\u00adjects;theobjectsthataregeneratedarefairlylong-lived. \nThus,wedidnotcollectmuchforthoseprograms,butnei\u00adtherwouldanexactapproach.Fortheotherbenchmarks, wearefrom30%{60%successful.Althoughthosenumbers \nmayseemlow,evenifweareonly50%successful,thismeans thatthetraditionalcollectorwouldbecalledhalfasoften \naswithoutourapproach. 5.2SizeandAgeoftheEquiliveBlocks RecallthatblockscontainingobjectsAandBaremerged \nwhenAreferencesB(orBreferencesA).Forthefollowing reasons,wewerecuriousaboutthenumberofobjectsthat accrueineachblockpriortotheblock'scollectionusingCG. \n.Blocksthatcontainasingleobjectareexact:nounions areperformedandsowecanreturnsuchobjectsatthe nextmethod-return. \n.Ifmostblocksaresize1,thenanapproachthatlooks onlyforsuchblocksmightworkwellwithouttheover\u00adheadofourmoregeneralapproach. \n.RecallingourexamplefromSection2,wewereforced tooverestimateD'slifetimewhenitwasmergedwith C.Ourapproachcouldbeimprovedbykeepingtrack \nofdependentframesper-objectinsteadofper-block. However,thiswouldbeunreasonableiftherewere manyobjectsperblock. \nFigure5showsthesizeofthecollectableblockscreated duringtherunsofourbenchmarks.Althoughmostblocks containmorethanoneobject,themajorityofblocksdo \ncontainthreeorfewerobjects. Next,wemeasuredthedistancetodieforobjectsthat wewereabletocollect.SupposeanobjectXisbornin \nframeM.WhenXisfnallycollected,itmustdependona frameatleastasoldasM.Thesingletonblocksmentioned earlier|forwhichourinformationisexact|maynotdiein \ntheirallocatingframe,becauseaframecanreturnaresult toitscaller.Figure6showstheage,inframedistance, ofobjectswhentheydie.Objectsthatarecollectedin \nthe0columnneverescapetheframeinwhichtheywere allocated.Manycollectableobjectsfallintothatcategory. However,mostareassociatedwitholderframes.Forthe \njackbenchmark,almostallobjectsallocatedinaframeare detectedcollectablewhenthatframe'scallerreturns. Forthoseobjectsthatdieintheirbirthframes,itmay \nbeworthconsideringhowsuchobjectscouldbecollected soonerthantheirdependentframepops.Thesingleton setscanbecollectedonceitcanbeshownthatnolocal \nvariablereferencestheobject.AsdescribedinSection4, staticapproachesmayservewellhere. 5.3ThreadBehavior \nBecausewetreatmultiplethreadsconservatively,wemea\u00adsuredthenumberofobjectsthatwereforcedintothestatic \nsetwhentheywereaccessedbymultiplethreads.Recallthat objectsinthestaticsetaretreatedbyourapproachaslive \nfortheprogram'sduration.Figure7showsthatmostofour benchmarkshadveryfewthread-sharedobjects.Themtrt andraytraceprogramsareequippedtorunmultithreaded, \nbutdidnotinfactusemultiplethreadsforthedatasizeswe supplied.Ontheotherhand,theapplet-versionsofcorners \nandtravgenerateagraphinonethreadthatisusedby another.Thegraphitselfistreatedstaticallybecauseofthis threadsharing.Also,anyobjectreferencedbythegraph, \norreferencingthegraph,becomesunionedwiththegraph's objects.Allsuchobjectsaretreatedaslivefortheprogram's \ndurationinourapproach.Suchharshtreatmentofthread\u00adsharedobjectsisunnecessary,asdescribedinSection6. NameTotal \nNumberofblocksofsize Percent Collectable123456{10.10Exact jmm 16283 2038 1070 2676 953 53 13% Tcorners \n71510 10320 4849 14413 572 1193 14% corners 174901 10315 4848 11988 514 1193 1 6% Ttrav 336894 48571 \n6682 81260 3521 757 482 38 14% trav 429132 141846 6681 80772 3463 757 482 45 33% compress 709 206 110 \n32 7 2 1 2 29% jess 19604 3380 1829 3158 19 68 10 31 17% raytrace 272552 40516 9491 1503 1835 3 4278 \n2 15% db 3323 819 138 321 4 2 1 3 25% javac 7768 3413 640 340 176 142 72 2 44% mpegaudio 717 214 108 \n39 8 2 1 1 30% mtrt 271622 40323 9366 1476 1799 2 4278 2 15% jack 366818 136001 85463 13517 4719 30 27 \n1 37% Figure5:Distributionofblocksizes. Name Distancefrombirthtodeathframes. 012345.5 jmm45743842433622041327 \nTcorners 15 14 9 11 50 1 16297 17460 9655 14 48 corners 15 14 6 9056 13824 14925 15 59 8 40 40 102312 \nTtrav 49 48 3 11 51 5 10339 87609 86 00 3 83029 89 16 trav 21 02 9 5766 13 54 823 2761 4 6 compress \n17 4 19 3 158 84 64 25 11 jess 6152 3679 67 09 503 62 18 24 81 raytrace 35 80 6 23 82 3 29071 13876 11 \n44 9 63 83 152144 db 66 7 62 0 12 07 603 72 22 129 javac 3602 1954 13 40 221 40 6 88 157 mp eg a u dio \n18 1 20 4 173 74 56 18 11 mtrt 35 58 1 23 75 9 29003 13685 11 26 0 62 87 152047 jack 79 97 7 263071 19495 \n2521 1717 22 15 Figure6:A g e a t d eathofobjects w ecollect. Name Tota l Percentage numof ofstaticobjects \nstaticobjects duetothreads jm m 4347 0% Tcorners 115940 98% corners 2546 0% Ttrav 216042 98% trav 113801 \n0% compress 4434 0% jess 26523 0% raytrace 4444 1% db 4763 0% javac 18357 0% mp e g a u dio 6859 0% \nmtrt 4430 1% ja ck 43659 0% Figure7:Percentageofobjectsthatwetreatasstatic(live fortheprogram'sduration)duetosharingamongthreads. \n5.4PerformanceandOverhead Finally,weexaminetherun-timeoverheadofourapproach inFigure8.WebeganwithSun'sJDK1.1.8(callthisthe \nbasesystem)andmodifedittouseourCGalgorithm.The rightmostcolumnofFigure8showsthespeedupobtainedby CG.Recallthatourapproachincursoverheadformaintain\u00adingtheequiliveblocks.Also,actionistakenateachstore \nandreturnoperation.Thebasesystemdoesnotincursuch overhead,butdoespausetogarbagecollectwhenitsheap becomesrelativelyfull. \nTherightmostcolumnshowsfrom4%{24%improvement inexecutiontimeusingCG.Thisrepresentsanabsolutesav\u00adingsoftimeusingourapproachoverthebasesystem,even \nthoughweperformextraworkateverystoreoperation. Thus,thesavingscanbeattributedtoavoidanceofthetra\u00additionalgarbagecollector.Moreover,wesetuptherunsto \navoidheapcompaction.Thus,thesavingsstemsprimarily fromavoidingthemarkingphaseofgarbagecollection. Thecornersandtravprogramsarenotimprovedbyour \napproach.However,thesewerehand-optimizedbyanexpert toavoidgarbagegeneration.Thus,theoverheadsurfaces \nbutwithoutthebeneftsfortheseprograms. Toisolatetheoverheadofmaintainingtheequilivesets, weranthebasesystemwiththe\\-noasyncgc\"fag|and \ngaveitplentyofstorage|sothatitneverrangarbagecollec\u00adtion.Thus,themiddlecolumnofnumbersinFigure8shows \nthespeedup(typicallyslowdown)ofourapproachoverthe basesystemwhenthebasesystemneverneedstocollect.In afewcases,westillbeatthebasesystem,probablybecause \nthecacheperformanceisbetterforCGthanforasystemthat nevercollects(andthusneedsalotofprimarystorage). 5.5LargerSPECruns \nWenextexaminedtheperformanceofourapproachonthe \\larger\"SPECbenchmarks.Thesearereallythesamepro\u00adgramsusedpreviously,butwithlongerrunningtimes.As \nshowninFigure9,mostofthebenchmarksgeneratedsub\u00adstantiallymoreobjects.Theexceptionstothisarecompress andmpegaudio,whicharecomputationalinnature.Inter\u00adestingly,ourapproachworkedonlybetterintermsofthe \npercentageofcollectableobjects.Notably,dbwentfrom 41%collectableinthesmallrunto99%collectableinthe Figure8:Timingresults.Therightmostcolumnshowsthe \nspeedupofourmethodoverthetraditionalcollectorinthe JDK1.1.8system.Themiddlecolumnisexplainedinthe text. \nName Ourtime Speedupover Speedup over (seconds) JDK-noasyncgc JDK jm m 4.77 .9 8 1.14 Tcorners 57 .0 \n.8 7 .9 1 corners 55 .0 .9 1 .8 9 Ttrav 142.0 .8 9 .8 9 trav 140.0 .9 0 .8 9 compress 772.34 .9 9 1.05 \nje ss 11 .5 1.00 1.24 raytrace 63 .9 1.00 1.20 db 3.2 1.00 1.14 ja vac 7.9 1.00 1.17 mpegaudio 86 .3 \n.9 9 1.04 mtrt 62 .2 .9 8 1.20 ja ck 157.5 1.00 1.10 largerun.Similarly,thenumberofobjectsthatwecan \ncollectexactly(becausetheywereuncontaminated)mostly improvedinthelargeruns,exceptfordb. NameObjectsCollectableExactly \nCreatedWithoptCollectable compress6,95928%27% jess7,924,66141%42% raytrace6,346,97899%82% db3,211,53199%0% \njavac5,879,70391%12% mpegaudio7,5829%30% mtrt6,585,97499%80% jack6,863,34490%37% Figure9:Specbenchmarks,largeruns. \nFinally,wecompareexecutiontimesfortheSPECbench\u00admarksinFigure10.The\\small\"speedupsarereprisedfrom Figure8;includedalsoarethespeedups(andslowdowns) \nofourmethodforthemedium-andlarge-scalerunsofthe benchmarks. Ourapproachworkedwellforthesmallruns,andit \nshouldbenotedthateventhe\\small\"runstakesubstantial time.Aswemovetothemedium-andlarge-runs,our approachstartstoloseground.Webelievethisishappening \nforthefollowingreasons. .Figure9showsthestatisticsforhowwellwecancollect objectsforthelargeruns.Althoughalargepercentage \narecollectable,itmaybethecasethatwecollectthem toolatetodothelong-runningprogramsanygood. Indeed,wefoundthatwehadtoallocatemorestorage \ntothelongruns.Indoingso,theprogramshardly collectedatallwhenrunwithtraditionalgarbagecol\u00adlection. .Figure9showsthatwhenthempegaudioandcompress \nprogramsrunlonger,theydonotallocatemoreob\u00adjects.Ourapproachcontinuestoincuroverheadbut thisisneverofsetbyanyrealcollectionofobjectsfor \ntheseprograms. nam e Small Medium Large compress 1.05 .95 jess 1.24 .88 .6 6 raytrace 1.20 .85 .6 8 db \n1.14 .83 .4 8 javac 1.17 .86 .7 0 mpegaudio 1.04 .97 mtrt 1.20 1.1 9 .6 7 jack 1.10 1.1 0 .6 9 Figure10:SpeedupofourapproachoverJDK1.1.8.For \ntheLargerun,mpegaudioandcompresstookoveranhour tocompletewitheithersystem. .Becauseourmethodisconservative,andowingthena\u00adtureofcontamination,theprecisenessofourcollector \nonlydegradeswithtime. .Whenaframepops,wereturnallofitsdependentob\u00adjectstotheheap.Currently,ourdatastructuresdonot \nmeshwellwiththefreelistoftheheap-allocator.As aresult,wereturnobjectsone-at-a-timetotheheap. Byreconcilingourdatastructurewiththefreelist's, \nwecanreturnallobjectswithasingleoperation. Basedonourexperimentation,wenextpresentideasfor futurework. \n6Conclusions Wehavepresentedasimplebutconservativeapproachfor trackinganobject'sdependentframe.Ourexperiments \nshowthefollowing. .Areasonablepercentageofobjectsarecollectableby ourapproach(Figure4andFigure9). .OfthoseobjectsthatareCG-collectable,mostoccur \ninblockswiththreeorfewerobjects(Figure5). .Forsomeprograms(suchasjackandjess),most objectsthatwecancollectarecollectedwithinone \nortwoframesoftheirbirth(Figure6).Forotherpro\u00adgrams(suchasraytraceandmpegaudio),amajority ofobjectsarecollectedmorethan5framespasttheir \nbirthframe. .Althoughourapproachperformswellforthesmall runsoftheSPECbenchmarks,performanceisloston thelongerruns. \nInresponsetotheseobservations,ourplansforthefuture includethefollowing. Togainbetterinsightintowhenandhowwellobjects \ncanbecollected,weplantoidentifythepointatwhich .anobjectbecomescollectable .traditional(exact)garbagecollectioncollectsit \n.CGcollectsit Whileitappearsthatalargenumberofobjectscanbe reclaimedefcientlybyourapproach,ourresultssuggestthe \nfollowingpossibilitiesforfuturework. .Theoperationsneededtomaintaintheequilivesets aresufcientlysimplethattheymightbeincorporated \ndirectlyintoastoragearchitecture. .Theequilivesingletonsetscouldbemaintained\\by type\".Thus,whenaframeispopped,therewouldbe \nacollectionoffreeobjectsofagiventype.Insteadof returningsuchobjectstoageneralfree-storagepool, theycouldberecyledthenexttimeobjectsofthat \nc typeareneeded.ForlanguageslikeJava,whereob\u00adjectsofagiventypealwaystakethesamesize(except forarrays),suchobjectrecyclingcouldhaveabig \npayof. Moreover,thiscouldimprovethereferencelocalityof aprogram.Others[6,9]havesuggestedusinggarbage \ncollectionasatimetoreorganize(live)storagetoim\u00adprovelocality.IfCGcanrecyclethedeadstorage,then thenextinstantiationofanobjecttypemayhaveits \ndataalreadyincache. .Onitsown,ourapproachneverimprovesthedepen\u00addentframeofanequiliveblock.However,itmaybe \npossiblethatsuchinformationcouldberesetwhen traditionalcollectionisperformed.Suchfreshstarts maygiveourapproachmorelatitudeinfndingdead \nobjects. .Becausemanyobjectsappeartobecollectablewhen theirbirthframepops,itisworthconsideringhow suchobjectscouldbecollectedsooner.Inparticular, \nanobjectinasize-1setcanbecollectedonceitsdepen\u00addentframenolongerreferencestheobject.Thiscould happenwellbeforetheexecutingmethod'sframepops. \nStaticanalysis[5,16]mayhelpdeterminewheresuch variablesdie.Also,itispossiblethatanefcient dynamicschemecoulddetectthatsuchvariablesare \ndead. .Staticanalysismightalsohelpbydeterminingthecon\u00additionallivenessofobjects.IfobjectXcanbeshown tobeasliveasobjectY,andwecantellthatXis \ndead,thenYmustalsobedead. .Ourtreatmentofthread-sharedobjectsistoconsider themlivefortheprogram'sduration.Instead,aset \nofdependentstackframescouldbeassociatedwith anequiliveblock.Furtherinvestigationisneededto exploretheexpenseandbeneftsofamoregeneral \napproach. .Ourapproachcouldcomplimentthetrainalgorithm bycollectingobjectswhenmethodsreturn.Exact collectionmightberequiredlessfrequently.Also,the \ntrainalgorithmcouldupdateourstructureswhenit doesrun,sharpeningtheefectivenessofourapproach. Acknowledgements \nWethankGuySteeleJr.andSunMicrosystemsforaccess totheirJavainterpreter.WealsothankthePLDIprogram committeefortheirreviewofourworkandtheirhelpful \ncomments.Inparticular,wearegratefultoMadsToftefor showingustheimportantconnectionofourapproachwith \\regions\". \nReferences [17]MadsTofteandJean-PierreTalpin.Implementation [1]A.V.Aho,R.Sethi,andJ.D.Ullman.Compilers: \nPrinciples,Techniques,andTools.Addison-Wesley, Reading,Mass.,1986. [2]AndrewAppel.Empiricalandanalyticstudyofstack \nversusheapcostforlanguageswithclosures.Journal ofFunctionalProgramming,6(1):47{74,1996. [3]Hans-JuergenBoehm.Spaceefcientconservative \ngarbagecollection.SIGPLANNotices,28(6):197{ 206,June1993.ProceedingsoftheACMSIGPLAN '93ConferenceonProgrammingLanguageDesignand \nImplementation. [4]USCensus.Tigermappingservice,the\"coasttocoast\" digitalmapdatabase.Technicalreport,USCensus \nBureau,1999.http://tiger.census.gov/. [5]D.R.Chase.GarbageCollectionandOtherOptimiza-tions.PhDthesis,Dept.ofComputerSci.,RiceU., \nHouston,TX,August1987. [6]TrishulChilimbiandJamesLarus.Usinggenerational garbagecollectiontoimplementcache-consciousdata \nplacement.ProceedingsoftheInternationalSymposium onMemoryManagement,1998. [7]ThomasH.Cormen,CharlesE.Leiserson,and \nRonaldL.Rivest.IntroductiontoAlgorithms.TheMIT Press,Cambridge,Mass.,1990. [8]SPECCorporation.Javaspecbenchmarks.Technical \nreport,SPEC,1999.AvailablebypurchasefromSPEC. [9]ScottHaug.Automaticstorageoptimizationvia garbagecollection.Master'sthesis,WashingtonUni\u00adversity,1999. \n[10]RichardL.Hudson,RonMorrison,J.EliotB.Moss, andDavidS.Munro.Garbagecollectingtheworld: Onecaratatime.InOOPSLA'97ACMConferenceon \nObject-OrientedSystems,LanguagesandApplications |TwelthAnnualConference,volume32(10)ofACM SIGPLANNotices.ACMPress,October1997. \n[11]TimLindholmandFrankYellin.TheJavaVirtual MachineSpecifcation.Addison-Wesley,1997. [12]AlastairReid,JohnMcCorquodale,JasonBaker,Wil\u00adsonHsieh,andJosephZachary.Theneedforpre-dictablegc.ProceedingsoftheSecondWorkshopon \nCompilerSupportforSystemSoftware,1999. [13]CristinaRuggieriandThomasP.Murtagh.Lifetime analysisofdynamicallyallocatedobjects.InConference \nRecordoftheFifteenthAnnualACMSymposiumon PrinciplesofProgrammingLanguages,pages285{293, SanDiego,California,January1988. \n[14]JacobSeligmannandStefenGrarup.Incremental maturegarbagecollectionusingthetrainalgorithm. ProceedingsofECOOP'95,pages235{252,1995. \n[15]DarkoStefanovic.PropertiesofAge-BasedAutomatic MemoryReclamationAlgorithms.PhDthesis,Univer\u00adsityofMassachusetts,Amherst,1999. \n[16]MadsTofte.Abriefintroductiontoregions.Proceedings oftheInternationalSymposiumonMemoryManage\u00adment(ISMM),pages186{195,1998. \nofthetypedcall-by-valueA-calculususingastackof regions.InConferenceRecordofPOPL'94:21st ACMSIGPLAN-SIGACTSymposiumonPrinciples \nofProgrammingLanguages,pages188{201,Portland, Oregon,January1994. [18]PaulR.Wilson.Uniprocessorgarbagecollectiontech\u00adniques(LongVersion).SubmittedtoACMComputing \nSurveys,1994. [19]PaulR.Wilson,MarkS.Johnstone,MichaelNeely,and DavidBoles.Dynamicstorageallocation:Asurveyand \ncriticalreview.InHenryBaker,editor,Proceedings ofInternationalWorkshoponMemoryManagement, volume986ofLectureNotesinComputerScience, \nKinross,Scotland,September1995.Springer-Verlag. [20]KwangKeunYiandWilliamsLudwellHarrison.Inter\u00adproceduraldataowanalysisforcompile-timememory \nmanagement.TechnicalReportCSRD1244,University ofIllinoisatUrbana-Champaign,CenterforSupercom\u00adputingResearchandDevelopment,Urbana,IL61801, \nUSA,August1992.\n\t\t\t", "proc_id": "349299", "abstract": "<p>We describe a new method for determining when an object can begarbage collected. The method does not require marking live objects.  Instead, each object <italic>X</italic> is <italic>dynamically</italic>associated with a stack frame <italic>M</italic>, such that <italic>X</ital ic>is collectable when <italic>M</italic> pops. Because <italic>X</italic> could have been dead earlier, our method is conservative. Our results demonstrate that the method nonetheless identifies a large percentage of collectable objects. The method has been implemented in Sun's Java Virtual Machine interpreter, and results are presented based on this implementation </p>", "authors": [{"name": "Dante J. Cannarozzi", "author_profile_id": "81100386888", "affiliation": "", "person_id": "P59759", "email_address": "", "orcid_id": ""}, {"name": "Michael P. Plezbert", "author_profile_id": "81100555771", "affiliation": "", "person_id": "P198461", "email_address": "", "orcid_id": ""}, {"name": "Ron K. Cytron", "author_profile_id": "81100565597", "affiliation": "", "person_id": "P248646", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/349299.349334", "year": "2000", "article_id": "349334", "conference": "PLDI", "title": "Contaminated garbage collection", "url": "http://dl.acm.org/citation.cfm?id=349334"}