{"article_publication_date": "05-01-2000", "fulltext": "\n EfcientAlgorithmsforBidirectionalDebugging BobBoothe ComputerScienceDept. UniversityofSouthernMaine \nPortland,ME04104-9300 boothe@cs.usm.maine.edu Abstract Thispaperdiscussesourresearchintoalgorithmsforcre\u00adatinganefcientbidirectionaldebuggerinwhichalltradi\u00adtionalforwardmovementcommandscanbeperformedwith \nequaleaseinthereversedirection.Weexpectthatadding thesebackwardsmovementcapabilitiestoadebuggerwill greatlyincreaseitsefcacyasaprogrammingtool. \nTheefciencyofourmethodsarisesfromouruseof eventcountersthatareembeddedintotheprogrambeing debugged.Thesecountersareusedtopreciselyidentifythe \ndesiredtargeteventonthefyasthetargetprogramexe\u00adcutes.Thisisincontrasttotraditionaldebuggersthatmay trapbacktothedebuggermanytimesforsomemovements. \nForreversemovementswere-executetheprogram(possibly usingtwopasses)toidentifyandstopatthedesiredear\u00adlierpoint.Ourcounterbasedtechniquesareessentialfor \nthesereversemovementsbecausetheyallowustoefciently executethroughthemillionsofeventsencounteredduring \nre-execution. Twootherimportantcomponentsofthisdebuggerare itsI/Ologgingandcheckpointing.Welogandlaterre\u00adplaytheresultsofsystemcallstoensuredeterministicre\u00adexecution,andweusecheckpointingtoboundtheamountof \nre-executionusedforreversemovements.Shortmovements generallyappearinstantaneous,andthetimeforlonger movementsisusuallyboundedwithinasmallconstantfac\u00adtorofthetemporaldistancemovedback. \n1Introduction Thepurposeofaprogramdebuggeristoassisttheuserin locatingprogrammingerrors.Standardcapabilitiesallow \nstoppingaprograminmid-execution,deliberatelyandpre\u00adciselymovingalongitsexecutionpath,andexaminingthe \nstateoftheprogram,suchasitsvariablesandstack.Atra\u00additionalforwarddebugger,suchasdbxorgdbcanmoveonly inthedirectionofforwardexecution.Theuserspecifesan \namounttomoveforward,usuallytothenextstatementor tothenextbreakpoint,andthedebuggerexecutesforward untilitreachesthatpoint.Forwardmovementisnatural \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for profit or commercial advantage \nand that copies bear this notice and the full citation on the first page. To copy otherwise, or republish, \nto post on servers or to redistribute to lists, requires prior specific permission and/or a fee. PLDI \n2000, Vancouver, British Columbia, Canada. Copyright 2000 ACM 1-58113-199-2/00/0006 $5.00. andwellunderstood,howeveritisoftenexactlytheoppo\u00adsiteofwhatwouldbemostconvenientforausertryingto \ntrackdownthecauseofanerror. Inthispaperwediscussourresearchintoalgorithms forcreatinganefcientbidirectionaldebuggerinwhichall \ntraditionalforwardmovementcommandscanbeperformed withequaleaseinthereversedirection.Wehavenamedour prototypebidirectionaldebuggerbdb. \nAddingthesebackwardsmovementcapabilitiestoade\u00adbuggerwillgreatlyincreaseitsefcacyasaprogramming tool.Bugsbecomeevidenttotheuserwhenerroneousout\u00adputisproducedorwhenanerrordetectionroutinenotices \nsomethingwrong.Ratherthanstartatthebeginningof theprogram'sexecution,farremovedfromthelocationof thebug,theprogrammercannowstartatthepointwhere \nthebugmanifestsitself.Fromthispointtheycandirectly chasedowninreversehowtheprogramgotthereandwhere incorrectvaluesoriginated. \nIncontrast,currentdebuggingpracticeofteninvolvesa frustratingprocessoftryingto\\sneakuponabug\".In aforwarddebugger,ifwewishtoarriveatapointjust \npriortowhereourbugoccurs,wehavenochoicebutto startatthebeginningoftheprogram.Insteppingthrough theprogram,weoftenmustguessifacertainfunctionis \nworthexaminingorifweshouldstepoverit.Ifweset abreakpointweoftenmustguesshowmanybreakpoints tocontinuepastuntilwewillarriveattheoneofinterest. \nIfweevermakeasinglemisjudgmentandsteppastthe bug,wemuststartoveratthebeginningoftheprogram andtryagain.Forbugsthatoccurdeepintotheprogram, \nwemuststepboldlyforwardorriskspendinganeternity inchingourwaythroughtheprogram.Howeverthemore boldlywestepforward,themoreweriskoversteppingthe \nbug.Withabidirectionaldebuggeritwillbecometrivial toundoa\\steppedpastthebug\"mistake.Moreover,with anefcientbidirectionaldebuggeritwillbefareasierand \nfastertosimplystartatthemanifestationofthebugand workone'swaybackwards. BdbworkswiththeCandC++languagesrunningon \nDigital/CompaqAlphabasedUNIXworkstations,butthe techniquesdevelopedinthisresearcharewidelyapplicable. \n1.1BriefBackground&#38;Overview Therehavebeentwogeneralapproachesforbuildingbidirec\u00adtionaldebuggers:\\historylogging\"and\\re-execution\".The \nhistoryloggingapproachcreatesalogofthevaluestaken onbyeveryvariableastheprogramexecutes.Itsproblems are:(1)therapidgrowthofthehistorylogand(2)the \noverheadofcollectingandsavingsomuchinformation.The re-executionapproachinsteadtransparentlyre-executesthe \nprogramtothedesiredearlierpoint.Itsdifcultiesare:(1) locatingthedesiredearlierpointwhilere-executingforward, \n(2)theoverheadinvolvedinre-executing,and(3)ensuring deterministicre-execution.Wewilldiscusstherelatedre\u00adsearchinmoredetailattheendofthispaperafterwehave \nexplainedourownwork. Inourresearchwehaveusedthere-executionapproach. Weaddressissue1(locatingearlierpoints)byembedding \ncountersintotheprogrambeingdebugged,andstopping onlywhenthedesiredcountsarereached.Weaddressis\u00adsue2(overheadofre-execution)byusingtruere-execution \nratherthanemulation.Weaddressitbythelowoverheadof ourembeddedcounters,andweaddressitbyusingperiodic checkpointstolimittheextentofre-executiontoalimited \nportionofthetotalexecution.Weaddressissues3(deter\u00administicre-execution)bycapturingandloggingtheoriginal \nreturnvaluesofsystemcallsandthenlaterreplayingthose valuesduringre-execution. 1.2Efciency Themovementalgorithmsthatwedescribeinthispaper \nmaynotatfrstglanceappeartobeparticularlyefcient; weinsertvoluminouscallstocounterroutines,were-execute \ntheprogrameventomoveshortdistancesbackwards,and insomecaseswewillevenperformmultiplere-execution passes.However,thecountercallsaresimpleandhaveonly \nmoderateoverhead,andweusecheckpointingtolimitthe amountofre-executionperformed.Inthefnalanalysisof thewholesystem,allshortforwardorreversemovements \nwillappearinstantaneoustoahumanoperator,andlonger movementsgoingfarintothefutureorfarbackintothepast \nwillcompletewithinsmallconstantfactorsofthetemporal distancemoved.Whilethecomputerisdoingalotofwork ontheuser'sbehalf,onthehumantimescalethisdebugger \nappearstoworksnaturallyandquiteefciently. 1.3ShortcomingsofTrapBasedDebugging Atraditionaldebugger,suchasgdb,dynamicallyinserts \ntrapinstructionsatanticipatedstoppingpoints.Forexam\u00adple,fora\\next\"commanditinsertsatrapatthestartof thenextstatement.Fora\\breakpoint\"itinsertsatrapat \nthetargetstatement,andfora\\fnish\"commanditinsertsa trapatthereturnaddressofthecurrentfunctioncall.The \ndebuggerthenexecutestheprogramuntilithitsthetrap statement. Thisgenerallyworkswellbutcansuferseriousperfor\u00admancedegradationincaseswherethedebuggerperformsa \nlargenumberoftrap/resumecyclesbeforeitarrivesatthe desiredpoint.Anobviousexampleoccurswhentheuser issuesacountedcommandsuchas\\continue10000\".This \nmightbeused,forexample,togettothelastiterationof aloop.Inthiscasethedebuggerwillgothrough10000 trap/resumecycles.Gdbincursanoverheadofapproxi\u00admatelyonemillionprocessorcyclesforeachtrap/resume \ncycleduetothecostofcontextswitchingandthesystem callsusedtoevaluatethestateoftheprogramaftereach trap. \nAlessobvioussituationoccurswhentheusertriesto \\next\"overarecursivecall.Thestatementthatthetrap isplacedatmaybeencounteredthousandsorevenmillions \noftimesbeforetherecursivecalliscompleted,andeachof theseincursatrap/resumecycle.Asimilarsituationoccurs \nwhentryingtofnishoutofanontop-levelrecursivecall. step_cntr() { step_cnt++; if(step_cnt==sc_stop_val) \nTraptothedebugger; } func_entry() { call_depth++; } func_exit() { call_depth--; } Figure1:Thebasicstepcounter,functionentry,andfunc\u00adtionexitroutines. \nWearealsoawareofotherperformanceanomaliesand bugsintrappedbaseddebuggers,butthesedonotappear tobeasuniversalastheaforementionedproblems.Allof \ntheseproblemshavebeeneliminatedbythenewtechniques usedinbdb. 2CounterBasedMovements Wehaveabandonedthetraditionaldebuggerimplementa\u00adtiontechniqueofinsertingtrapinstructionsatpotential \nstoppingpointsintheprogrambeingdebugged.Initsplace wehavedevelopedtechniqueswhichuseacollectionofem\u00adbeddedcounterroutinestotracktheprogressoftheprogram \nandstopitpreciselyatthefnaltargetlocation.Whilethese embeddedcountersaddsomeoverhead,theyallowustoef\u00adfcientlyandpreciselymovebackwardstoearlierpointsin \ntheexecutionbyre-executingtheprogramandstoppingat earliercountervalues. Wehaveimplementedtheforwardmovements:\\step\", \n\\continue\",\\next\",and\\fnish\",andtheanalogousback\u00adwardsmovementswhichwehavenamed:\\bstep\",\\bcon\u00adtinue\",\\previous\",and\\before\".Allofthesecommands \ncanbegivenacountargumenttogotothenth occurrence. Wehavealsoimplemented\\until\"and\\buntil\"movements tofndwherevariableschange,andweprovideageneral \nundomovement. Ourbasiccountersarea\\stepcounter\"anda\\calldepth counter\".Whentheprogramiscompiledfordebugging,we \ninsertcallstothestepcounteratthetraditionaldebugger steppingpoints(eachlinestartinganewstatement).We \nalsoinsertateachfunctionentryandexitpointacallto incrementordecrementthecalldepthcounter.Pseudocode forthesecountersisshowninFigure1.(Theactualcodeis \nthesameexceptthatthefunctionnamesareprefxedwith \\bdb \"toreducethepossibilityofnameconficts,andthe variablesareactuallymembersofaglobalstructure.) \nThestepcounterprovidesanunderlyingtimelinefor measuringtheexecutionoftheprogrambeingdebugged.It isusedbyallofthemovementcommands.Thecalldepth \ncounterisusedbythemorecomplexmovementssuchasfn\u00adishingthecurrentfunctioninvocation.Insertingthesecalls \natcompiletimeestablishescallsitesforcallstothecounter routines.Formanyofthemovementsweusespecialized \ncounterroutines.Thesespecializedcountersareinserteddy\u00ad namicallyeitherbyreplacingthecallatanindividualcall \nsiteorbychanginganindirectjumptoredirectanentire classofcountercalls. 2.1Step&#38;Bstep Thestepmovementisthesimplestdebuggermovement.It \nstepstothenextsourcelevelstatementintheprogram, steppingintofunctioncalls.Likewisebstepstepstothe precedingstatement,possiblysteppingbackintoapreceding \nfunctioncall. Thesemovementsareimplementedsimplyandefciently usingthestepcounter.Thiscounterincrementsaglobal \nstepcountandcomparesittoastoppingvalue.Whenthe stoppingvalueisreachedthecounterroutineexecutesatrap whichtransferscontrolbacktothedebugger.Thisisef\u00adcientevenforhugevaluesofnbecausetheuserprogram \nonlytrapsbacktothedebuggeronce.Fortypicaluserpro\u00adgramsrunningona600MHzprocessor,weseeabout20 millionstepspersecond,withanoverheadoflessthana \nfactor2.(Wewillprovidemorecomprehensiveperformance measurementsinSection4.)Incontrast,atraditionalde\u00adbuggerbogsdownunbearablyforlargecountsbecauseit \ntrapsateachstepasdescribedinSection1.2. Weuse64-bitcounters,whicharevastlymorethanad\u00adequateforanyconceivableprogramexecutiontoday.How\u00adeverifcomputerperformancecontinuestoimproveatits \ncurrentexponentialrate,in30yearswewillneedtocon\u00adsiderthepossibilityofcountersrollingoverorconsiderusing \nlargercounters. Therealbeneftofthestepcounter,however,isforstep\u00adpingbackwards.Supposetheuserhasruntheirprogramfor \n1secondandstoppedwherethestepcountis20million,to bsteponestepwesetthestopvalueto1lessthanthecur\u00adrentcountandre-executetheprogramfromthebeginning. \nWithanefcientstepcounterthistakesonly1secondsince itonlytrapstothedebuggerwhenitisdone.(InSection5 wewilldiscussouruseofcheckpointingtoboundtheextent \nofre-executionproportionaltothedistancemovedback.) Thepointsatwhichuserissuedmovementcommands willstopwhenusingbdbarethesetofsteppointsinthe \nprogram.Thishasasidebeneftofprovidingasimplemech\u00adanismforcontrollingwhatbodyofcodeisofinteresttothe user.Mosttraditionaldebuggershavetheoftenundesirable \nbehaviorofsteppingintolibraryroutines.Inmostcases,es\u00adpeciallyforstudents,thisisannoyingandfrustrating.This \ndoesn'thappenforbdbbecausethelibraryfunctionswere notcompiledfordebuggingandthusdonotcontainanycalls \ntobdbcounterroutines.Libraryroutinesarethusstepped overasiftheywerebasicatomicoperations.Asophisticated \nuser,workingonalargesoftwareproject,mightnotwant thedebuggertostepintocertaintrustedsoftwaremodules (suchastheconstructorcallsandothermemberfunctions \nofaclass).Theycanachievethisbysimplynotcompiling thoseflesfordebugging. 2.2Continue&#38;Bcontinue th \n\\Continuen\"meansrunforwarduntilwereachthen statementwithabreakpoint.Analogously\\bcontinuen\" th totheusermeansrunbackwardsuntilwereachthen \npreviousstatementwithabreakpoint.Ofcoursewecan't reallyrunbackwards,butinsteadwelocatethedesiredpoint \nwhilere-executingforward. Figure2showsasimplediagramthatwewillusetohelp inexplainingmanyofourmovementalgorithms.Thefg\u00adureshowsanexecutiontimelinemovingfromlefttoright. \nbcont cont Figure2:Executiontimelineshowing\\continuing\"either forwardorbackwardtotheclosestbreakpoint. \nbrkpt_cntr() { step_cnt++; brkpt_cnt++; if(brkpt_cnt==bc_stop_val ||step_cnt==sc_stop_val) Traptothedebugger; \n} Figure3:Thebreakpointcounterfunction. Thetickmarksrepresentthebasicsteppoints.Thecircle representsthecurrentpositionofthedebuggeralongthe \nexecutionpath,andtheX'srepresentstepspointsatwhich breakpointsoccur.Figure2thusshowswhatwillhappenif \ntheuserissueseitheracontinueorbcontinuecommand:the debuggerwilleithermoveforwardorbackwardtothenext breakpoint.Thisisanabstractviewofprogramexecution \nthatsimplyfocusesontheexecutiontimeline.Language constructssuchasloopswouldjustappearaslongsequence ofsteppoints.Themultiplebreakpointsshownonthisdi\u00adagrammightinfactrepresentasinglebreakpointplacedin \ntheprogramthatisencounteredrepeatedlyforeachitera\u00adtionofaloop. Thesetofsteppointlocationsinaprogramoccurat \nfxedlocationsdeterminedatcompiletime,butbreakpoints areinsertedandremovedatruntime.Whereatraditional \ndebuggerinsertsatrapinstruction,weinsertacalltothe breakpointcounterinstead.Thiscallreplacesthenormal \ncalltothestepcounter,andthusthebreakpointcounter replicatestheworkofthedisplacedsoftwarecountercall aswellasincrementingandtestingthebreakpointcount. \nThiscounterroutineisshowninFigure3.Theperformance advantageofusingcounterroutinesoverthetraditionaltrap \ninstructionsiscrucialduringre-executionwhenwemayhave toproceedpastthousandsofbreakpointoccurrencesbefore \nwearriveattheoneofinteresttotheuser. Sincebreakpointsareinsertedanddeletedthroughout adebuggingsession,wedon'thaveasinglereliabletime \nlinelikewedowiththestepcounter.Anychangetothe setofbreakpointsinvalidatesouraccumulatedbreakpoint counts.Thisdoesn'timpactourabilitytoperformforward \nmovementsbecausewejustcareabouttherelativechangein thebreakpointcountwhenexecutingforward.Howeverfor \nbackwardsmovements,whenthesetofbreakpointschanges, ourtaskbecomesharder.Ourimplementationusestwore\u00adexecutionpasses.Thefrstpassestablishesavalidbreak\u00adpointcountuptothecurrentposition.Thesecondpassthen \nexecutestotheappropriatebreakpointcountforthedesired numberofbreakpointsmovedback.Oncebreakpointcounts \nhavebeenre-establishedinthisfashion,futurebcontinue's requirejustonepass. Formostofourbackwardsmovementstherewillbesit\u00aduationsinwhichtwopassesarerequired.Althoughwehave \nalsoinvestigatedpossibleonepassalgorithmsformostof thesemovements,whentheoverallperformanceisconsid\u00ad \n Figure4:Sequenceofpointsvisitedbynext.Shadingrep\u00adresentsthebasedepthlevelbelowwhichsteppingpoints wouldnotbestoppedatbynext. \neredinSection4wewillconcludethatthetwopassal\u00adgorithmsarepreferable.Furthermore,whencheckpointis addedinSection5,thetimespentonthesecondpasseswill \nbemostlyeliminatedanyways. 2.3Next Nextandpreviousarethemostchallengingandinterest\u00adingofthemovementstoimplement.Theyhavetheirown \nspecializedcounterroutinesforcountingoccurrencesofthe desiredevent.Thenextcounter,forexample,countsthe \npointsthatwouldbestoppedatbyaseriesofnextcom\u00admands.Thesespecializedcountersreplacethestandardstep counter.Sincethecallstothestepcountersthroughoutthe \nprogramareinfactindirectcalls,wecanefcientlychange anentireclassofcountercallsbymodifyingjustasingle \njumpinstruction. Nextmovestothenextsourceline;itskipsoverfunction calls,anditstepsoutoffunctionswhentheyreturn.To \nimplementthisweneedamethodtoknowwhenwestep intoandreturnfromcallssothatwecansuspendcounting ofnextpointsappropriately.Thecalldepthcounterson \nfunctionentryandexitintroducedatthestartofSection2 wereinventedforthispurpose.Thecalldepthistracked forallmovementcommandssothatwewillhaveitscorrect \nvaluewhenitisneededforcommandssuchasnext. Thealgorithmusedforcountingnextpointswillbeex\u00adplainedwiththeaidofFigure4.Inthisfgure,achange \ninleveldownrepresentsacalltoafunctionandthusan increaseincalldepth,andachangeinleveluprepresentsa functionreturnandadecreaseincalldepth.Figure4thus \nshowswhatwillhappenastheuserissuesaseriesofnext commandsoracountednextcommand. Toperformanextoperation,thedebuggerstartsby \nsettingavariablenamed\\base depth\"tothecurrentcall depth.Thebasedepthisrepresentedbyshadinginthe fgure.Steppointsoccuringbelowthebasedeptharenot \ncountedasnextpoints,andthusnextwillcorrectlyskipover functioncalls.Whenanextoperationreturnsupfromthe \nbasedepth,asshowninthediagrambythe5tharrow,the basedepthisraisedsothatfuturecountingwillrefectthe newbasedepthoffurthernextoperations. \nThepseudocodeforthecounterroutinesusedbynextare showninFigure5.Asdescribedsofar,thetestingofthestep counterdoesn'tmakesensebecausewearelookingfornext \npointsratherthansteppoints.Howeverwithcheckpointing (describedinSection5)thestepcounterwillbeusedbythe \ndebuggertoregaincontrolatcheckpointboundaries.There isalsoasecondversionofthenextcounterroutine(not shown)thatincrementsandteststhebreakpointcounter \ninadditiontowhatisshownhere.Thissecondversionis calledfromlocationscontainingbreakpoints,anditallows \nstoppinganextmovementprematurelywhenitencounters next_cntr() { step_cnt++; if(call_depth==base_depth) \nnext_cnt++ if(next_cnt==nc_stop_val ||step_cnt==sc_stop_val) Traptothedebugger; } next_func_exit() { \ncall_depth--; if(call_depth<base_depth) base_depth--; } Figure5:Specializedversionsofcounterroutinesfornext. \n Figure6:Sequenceofpointsvisitedbyprevious. abreakpointbeforereachingitstargetdestination. 2.4Previous \nPreviousisourbackwardsanalogueofnext.Itmovesto thepreviousline;itstepsoverfunctioncallsandbackup andoutofafunctionentry.ThisisillustratedinFigure6. \nNextandpreviousarenotactuallyinverses.Forexample inFigure6,anextfromthecurrentpointwouldadvance tostep20,butapreviousfromstep20wouldskipoverthe \nprecedingfunctioncallallthewaybacktostep11. Althoughpreviousisconceptuallysimilartonextinthat itdoesn'tstepbelowthebasedepthanditstepsupoutof \nfunctions(justinreverse),itismoredifculttoimplement becausewecan'treallyexecuteinreverse,butinsteadwe \nmustfgureoutthecorrectstoppingpointwhilere-executing forward!Indesigningthisalgorithm,weconsideredseveral \ndiferentapproaches.Wepresentherethealgorithmthat waschosenasthebestcompromisebasedonspeed,space, andtheexpectedcommoncasesforusage. \nWeuseatwopassalgorithmwhichweexplainusingFig\u00adure7.Thefrstpassgathersinformation.Itstartsbycount\u00adingeverysteppointasapotentialpreviouspoint.Whenit \nstepsintoafunctioncall(whilemovingforward),itcontin\u00aduescountingpreviouspointssincethefunctionjuststepped \nintomightturnouttobeafunctionthatwouldbestepped outofinreversebyprevious.Whenwereturnfromafunc\u00adtioncall(whilemovingforward),welearnthatthefunction \njustcountedwouldthusnothavebeenvisitedbyaprevi\u00adouscommandsincepreviouswouldneverstepdowninto afunctioninreverse.ThissituationisshowninFigure7: \n(whilemovingforward)theprogramstepsintoafunction whengoingfromstep6tostep7,anditsubsequentlysteps finish \n3 Figure7:Previouscountscalculatedonfrstpass. prev_cntr() { step_cnt++; if(call_depth<=base_depth) prev_cnt++ \nif(prev_cnt==pc_stop_val ||step_cnt==sc_stop_val) Traptothedebugger; } prev_func_exit() { call_depth--; \nif(call_depth<base_depth) { prev_top_sc=step_cnt+1; prev_top_depth=call_depth; prev_cnt=0; } } Figure8:Specializedcounterroutinesforprevious. \noutofthatfunctionwhengoingfromstep9tostep10.At thispoint,anypreviouspointsthatwerecountedinthat functionareinvalid(thoseatsteppoints7,8,and9inthe \nexample).Inourchosenalgorithmwesimplyabandonthe currentcountandstartafresh. Wehavelabeledthenewstartingpointas\\top\".This \nwillbethetopoftheupcomingcountedsequenceofde\u00adscendingsteps.Ourcounterroutinessaveawaythevalues ofthestepcountandthecalldepthatthispoint.Thesewill \nbeusedinthesecondpasstohelpnavigatetothedesired stoppingpoint. Aswecontinuecounting,ifwestepintofunctionsbelow \nthebasedepthofthestartingpositionofthiscommand(as shownbyshadinginFigure7),westopcountingprevious pointsuntilwereturnuptothebasedepth.Wedonothave \ntoreset\\top\"inthiscasesincewehavenotmiscountedany previouspoints. Afterthefrstpassthedebuggerconsidersthegathered \ninformation.Intheexample,weareatthe7thprevious pointsubsequentto\\top\".Iftheuserhadaskedtoprevious from1to6previouspoints,weproceedtothesecondpass \nandre-executetothatpoint.Intheunlikelyeventthat theuseraskedtopreviousfurtherbackthanthetoppoint, thedebuggerperformsadditional\\frst\"passesgathering \npreviousinformationpriortothetoppoint. ThecounterroutinesforthefrstpassareshowninFig\u00adure8.Thesecondpassusesthenormalstepcountertoreach \nthetoppoint,andfromthereitusesthepreviouscounter Figure9:Destinationsoffnishcommands. toreachthedesiredpreviouspoint. \nWechosethisalgorithmbecauseitworkswellfortheex\u00adpectedcommoncaseusageofprevious.Atypicaluserwillei\u00adthermovetothepreviousstatement,orpossiblyuseasmall \ncountvaluetomovetosomewherethattheycouldpredict thedestination.Thiswouldlikelybeinsidethesamefunc\u00adtioninvocationorjustbackingoutofit.Sinceintwopasses \nwecanreachanypreviouspointwithinthesamefunction invocationorarbitrarilyfarbackalongadescendingchain ofcalls,wehandlethecommoncasesintwopasses.(There \nisonesubtlesituationdiscussedinSection3thattakes3 passestoreachthecallingfunction.) Weexploitthefactthatatypicaluserwillissueaseriesof \npreviouscommands.Repeatedcommandstakeonly1pass becausetherelevantcountershavealreadybeengathered andsavedforfutureuse.Eveninthecasewhereweprevious \nbacktothetoppoint,asubsequentpreviouswillstilltake only1passbecauseforthatcasewegathernewprevious countsduringre-executiontothetoppointinpreparation \nforthepossiblerepeatedcommand. Justasanextmovementwillbeinterruptedbythefrst interveningbreakpoint,soshouldapreviousmovement.We \nwishtopreservetheuser'sillusionthatthedebuggerisexe\u00adcutingbackwards,sothisbreakpointwouldinfactoccur \nchronologicallyafterwereachthedesiredpreviouspoint whilere-executingforward.Bdbhandlesthissituationby \nnotingbeforehandhowmanyprecedingbreakpointsareex\u00adpected,andiftheyhavenotallbeenpassedbythetimewe reachthetargetpoint,bdbadvancestheprogramforward \nuntilithitsthelastofthesebreakpoints.Justasfornext, therearespecializedversionsofthepreviouscountersthat \nareusedatbreakpointlocations. 2.5Finish&#38;Before Thefnishcommandcontinuesuntilitfnishesexecutionof \nthecurrentfunction.Afnishncommandfnisheslevels n ofnestedcalls.ThisisshowninFigure9. Finishcanbeimplementedstraightforwardlybytesting \nthecalldepth.Thedebuggerinstallsthefnishcounterrou\u00adtineinplaceofthestepcounterinthechild,setsthestop\u00adpingpointtothedesiredcalldepth,andresumesthechild. \nAteachsteppointthefnishcountercheckstoseeifthecall depthhasreachedthedesireddepthandtrapsbacktothe debuggerwhenitisreached. \nBeforeisonceagainsimilar,butmoredifcultthanits analogousforwardmovementbecausewemustidentifythe correctstoppingpointwhileexecutingforward.Figure10 \nshowsthedestinationsofexamplebeforecommands. Inourchosenimplementationweagainuseatwopass algorithm.Thefrstpassdeterminesthestepcountcor\u00adrespondingtothedesiredbeforepoint.Duringthefrstre\u00adexecutionpassthebeforecountersavesthestepcountwhen\u00ad \n Figure10:Destinationsofbeforecommands. everthecurrentcalldepthisequaltothedesireddepthof thebeforecommand.Thelastsuchvaluesavedcorresponds \ntothedesireddestination.Thesecondpassnowsimplyre\u00adexecutestothestepcountdeterminedbythefrstpass. Thisalgorithmiscapableofmovinganarbitrarynum\u00adberoflevelsbackupthecallstackusingonlytwopasses. \nInpracticeweexpectauserwilloftenincrementallybefore backonelevelatatime,andweoptimizeforthiscaseby identifyingthesubsequentbeforepointduringthesecond \npass.Thistheneliminatestheneedofthefrstpassforeach repeatedbeforecommand. 2.6Until&#38;Buntil Avaluablefeatureofadebuggeristheabilitytorununtil \naspecifedvariablereachesadesiredvalue.Unfortunately thishasbeenunbearablyslowintraditionaldebuggers(a \nslowdownfactorof85,000hasbeenreportedfordbx[13]). Wahbe,Lucco,andGraham[13]demonstratedanefcient techniqueforimplementing\\databreakpoints\"usingcode \naugmentationtomonitormemoryupdates.Theyinserted codeatallmemorywriteinstructionstocheckaccessedad\u00addressesagainstatwo-levelsegmentedbitmaprepresenting \nthecollectionofmonitoredaddresses. Wehavedevelopedasimpler,althoughnotasgeneral implementation,byreplacingourstepcounterswithatest \ntomonitorthevalueatasinglememorylocation.Wethus onlytestforchangesinadatavalueatoursteppingpoints. Thisisadequateforfndingtheexactstatementatwhicha \ndatavalueischanged,butitdoen'tidentifytheassembly languageinstruction. Weprovidemovementcommandsoftheform\\until \nx==10\"tocontinueuntilaspecifedvariablereachesaspec\u00adifedvalue,andcommandsoftheform\\untilx\"tocontinue untilaspecifedvariablechanges. \nBuntilisouranalogousbackwardsmovement.Thismay bethemostvaluablemovementofthisdebugger.Witha singlecommandtheusercanfndwhereavariabletookon \nanobservederroneousvalue.Sucherrorscanotherwisebe extremelydifculttofndiftheyresultfromanapparently unrelatedoperationsuchasapointerproblemoroverrun\u00adninganarray'sbounds. \nAteverysteppointourcounterroutinesmonitorthe valueattheaddressofthespecifedvariableandtesttosee ifitmatchesthedesiredcondition.Toperformaforward \nuntilwestopatthefrstmatch.Toperformabuntilwe usethefrstpasstorecordthelaststeppointatwhichthe conditionwassatisfed(aswere-executeforward),andthen \nasecondpasstore-executetothatpoint. Ourimplementationdoeshaveoneimportantadvantage overthatofWahbe,Lucco,andGraham'sinthatoursisable \nx = func1() + func2(); call depth 1 step cnt: 123 10 11 2 456789 func1() func2() Figure11:Subtletywhenclimbingoutofafunction. \ntostopataspecifedvalueforavariable,whereastheirsis onlyabletodetectthemodifcationofavariable. 2.7Undo \nUndoingmovementsinbdbiseasyusingtheunderlyingtime lineprovidedbythestepcounter.Ontheundostackwesave theinitialstepcountbeforeperformingeachmovementcom\u00admand.Toundoamovement,wesimplyretrievetheoriginal \nstepcountfromtheundostackandthaneitherexecutefor\u00adwardtothatpoint,orre-executetogetbacktoit. 3ImplementationSubtleties \nThereareanumberofsubtletiesingettingthemovements preciselycorrect.Figure11showsoneexample.Thestate\u00adment\\x=func1()+func2();\"occursatstep3inthedia\u00adgram.Theexecutionofthisstatementisspreadoutover \ntheregionbetweenstep3andstep10:thefrstcalloccurs atstep3,thesavingofitsreturnvalueandthecalltofn2 ucoccursatthespikebetweenthesteps6and7,andthef\u00adnalsumandassignmenttoxoccursjustpriortostep10. \nThespikeisdrawntoindicateapossiblephantomstopping point. Thequestionarisesshouldaforwardmovementleaving \nfunc1(orabackwardsmovementleavingfunc2)stopat thespike?Forinstance,shouldastepfrompoint6stopat thespike,orstopatpoint7?Wedecidedtostoponlyat \nourcountedstoppingpointsbetweenstatements.Forus,a stepfrom6stopsat7,andanextorfnishfrom6returns tothecallingfunctionandstopsat10. \nToupholdthisrule,ourimplementationofpreviousre\u00adquires3re-executionpassesforthespecialcaseofmoving backpastaspike,suchasfrompoint7toitsdestinationat \npoint3.Intheexample,whenourfrstre-executionpass hitsthefunctionexitfollowing6,itresetsthe\\top\"point to7.Thenwhenbdbnoticesthatthe\\top\"pointisatthe \ncurrentposition,itknowsthataspikeoccurred.Itthen raisesthebasedepthandre-executesanother\\frst\"pass, whichproperlyidentifesthedesireddestinationatpoint3. \nTraditionaldebuggersdiferonthematterofstoppingat thespike.Gdbstopsatthespikeonlyforfnish,whereas MicrosoftVisualStudioalwaysstopsatthespike. \nWefeelthatitisactuallypreferableforfnishandbefore tostopatthespikebecauseitmakesiteasiertogetinto thesecondfunction:onecouldstepintothefrstfunction, \nfnishthatfunction,andthenstepintothesecondfunction. Wehavedesignedbutnotyetimplementedcounterroutines \ntoaccomplishthis. Thekeyideaistohavethefunctionexitcountertest forthestoppingconditionandtrapbacktobdb.Wewould \nthenusethetraditionaldebuggertechniqueofinsertinga ForwardMovementsBackwardMovements command slowdown \nstep 1.95 continue 1.95 next 2.48 fnish 2.33 until 2.34 command 1stuseslowdown1stpass+2ndpass repeateduse \nslowdown bstep 1.95 1.95 bcontinue 1.95+1.95 1.95 previous 2.49+1.95 1.95 before 2.20+2.20 2.20 buntil== \n2.71+1.95 (always2passes) buntil!= 3.15+1.95 (always2passes) Table1:Worstcasesofmeasuredexecution temporarytrapinstructionsatthereturnaddressandthen \ncontinuingforwardtothattrap.Thiswouldnotsuferfrom theperformanceproblemsencounteredbytraditionalde\u00adbuggerswhenfnishingarecursivecallbecauseourcounter \nisabletoadvancepastalloftheprematurefunctionreturns. Thespikeisnotatanexactcountedsteppoint,and thusonourundostackwewouldneedtonotethespecial \ncircumstancebywhichwearrivedatthispointsothata futureundowouldreturntothespike. 4OverheadofCounterRoutines \nTheoverheadofourcounterbasedmovementalgorithms variesbasedonthecomplexityofthecodestatementsin theprogrambeingdebugged.Inparticular,heavyuseofli\u00adbraryfunctionslendsitselftoloweroveralloverheadbecause \nmoreworkisdonebetweenuserlevelsteppingpoints.We used5recentstudentassignmentsastestcases.Thesewere: ananagramfnder,acryptographicdecipheringprogram,a \ndynamicprogrammingalgorithmforfndingtheeditdis\u00adtancesbetweenproteins,aniterativesuccessiveoverrelax\u00adationcode,andanX-Windowsferndrawingprogram.The \nmostimportantperformancemeasurementistheoverhead ofthebasicstepcounterbecausethisisusedfornormal forwardexecution.Forthefvestudentassignments,this \noverheadwas94%,31%,95%,56%,and0%respectively. (Theoverheadwasnegligibleforthefernprogrambecause itsexecutiontimeisdominatedbyX-Windowsrelatedsys\u00adtemcalls.)FortheSPECCINT95benchmarks129.com\u00adpress,130.li,and147.vortexwemeasuredoverheadsof95%, \n124%,and103%respectively.Wecalculatedtheseoverheads relativetotheperformancewhencompiledfornormalde\u00adbugging.Oursystemstartswiththeoutputof\\gcc-g\", \nandthusouroverheadisinadditiontothenormaldebug\u00adgingperformancedegradation. Table1showstheexecutionslowdownfactorsforall \nofbdb'ssupportedmovementsfortheeditdistancetest case,whichwastheonethatshowedthegreatestslowdowns amongourstudentsassignments.Inactualuse,foranyshort \nmovement(whichisthemajorityofmovementcommands) bdbrespondsinstantaneouslyonahumantimescale,and thusforshortmovementstheslowdownfactorsareunim\u00adportant.Wecareaboutslowdownsonlyforlongrunning \nmovements.Alloftheseresultsweregatheredovertheen\u00adtireexecutionofthetestprograms.Thiswasdone,forex\u00adample,withcommandssuchas\\step1000000000\",orby \nsettingabreakpointattheendoftheprogram. Forforwardmovements,theslowdownisincurredover thedistancemovedforward.Forbackwardsmovementswe \nhavereportedtheslowdownfactorsforthefrstandsec\u00adondpassesseparately.Theseslowdownfactorsareincurred overthere-executioninterval.Forsomemovementsthe \nslowdownfactorsofthetwopassesdiferbecausediferent slowdownfactorsforeachmovement. counterroutinesareused.Forexampleinthecaseofpre\u00advious,thefrstpassusesthepreviouscounterfortheentire \nre-executioninterval,butthesecondpassusesthesimpler stepcounterforthemajorityoftheintervaluntilthelast \ndescendingcallchainonwhichitusesthepreviouscounter. Itisdifculttocompareourresultstothoseofrelated projectsbecausemostofthemprovidedatbestonlylimited \nperformancemeasurements,andadmittedlymostofthese projectsweremoreinterestedinprovidingbackwardslook\u00adingfunctionalitythanintheperformanceaspects.Wethus \ncompareourselvestothemostrelevantnumbersavailable tous.NetzerandWeaver[9]builtanexecutionreplayde\u00adbuggerforlongrunningprogramsbasedonprogramtracing \nwithanemphasisonminimizingthesizeofthetracefle. Theyreportedslowdownfactorsrangingfrom1.75to7.0. FeldmanandBrown[3]builtadebuggerbaseduponfrequent \n(andfast)checkpointingandthenprograminterpretationto moveforward.Theirinterpreterincurredaslowdownfactor \nof140.Ourslowdownfactorscomparefavorablytobothof these,whichsuggeststhatre-executionisamoreefcient methodology. \nFromourexperienceusingbdb,wefeeltheperformance achievedbyourcounterbasedmovementsismorethanade\u00adquate.Howeverifonewishedtopushtheperformancelevel \ntoitslimits,amoreaggressiveimplementationcouldreduce theoverheadsubstantially.Inanexperimentweappliedthe \nfollowingoptimizationstothebasicstepcounter:removing theindirectiononcountercalls(byinsteadcopyingthede\u00adsiredcounterroutinetothefxedcallsite),usingastream\u00adlinedcallingconvention,usingdedicatedregisterstohold \ncountervalues(asdonebyMellor-Crummey&#38;LeBlanc[7] andWahbe,Lucco&#38;Graham[13]),andcountingdownto \nzero(alsoasin[7]).Togetherthesereducedtheoverheadby 75%.Theoverheadofthestepcounterintheeditdistance \napplicationwasreducedfrom95%to24%.Thiscompares toanoverheadof10%forMellor-Crummey'sinlinesoft\u00adwarecounterand42%forWahbe'sdatabreakpoints.We \noferthesenumbersnottosaythatourimplementationis slowerorfasterthantheseimplementations,sinceclearly theyarealldoingdiferentthings,butrathertoindicate \nwhatisachievabletoareaderwhoisinterestedinmaxi\u00admumperformance. 4.1OnePassAlgorithms Anothersourceofpossibleperformanceimprovementmight \ncomefromusingonepassalgorithmsforsomeoftheback\u00adwardsmovements.Forinstancebymaintaininganarrayof breakpointscounts,oneforeachlocation,wecouldelimi\u00adnatetheextrapassforbcontinuethatisneededafterthe \nuserchangesthesetofbreakpoints.Bymaintainingastack ofthelastpointsateachcalldepth,wecouldeliminatethe \nextrapassesforpreviousandbefore. Figure13showstheinformationneededbya1passpre\u00ad checkpoint interval Figure12:Checkpointsarethinnedtoleaveanexponentially \ncall step prev prev cnt: 123 depth cnt cnt 13 3 step cnt: 2 11 8 3 14 11 4 16 13 Figure13:The1passpreviousalgorithmsavesthelaststep \nandpreviousvaluesateachcalldepth. viousalgorithm.Ateachcalldepthitstoresthevaluesof thestepandpreviouscounterscorrespondingtothelast \npointatthatdepth.Uponexitingfromafunctionourtwo passalgorithmdiscardedthepreviouscount,recordedthe \\top\"point,andstartedcountingafresh.Insteadthe1pass \nalgorithmcansimplyretrieveandcontinuecountingfrom thecorrectpreviouscountrecordedbeforetheintervening \nfunctioncall. Thedrawbackoftheseonepassalgorithms,however,is thatallofthisadditionalinformationwouldneedtobegath\u00aderedduringregularforwardexecution,justincaseitwas \nneededlater.Fastforwardexecutionismoreimportant. Forlongrunningprograms,themostimportantperfor\u00admancemeasurementistheslowdownfactorincurredbythe \nbasicstepcounterwhenexecutingforward.Forfnding problemsfarintoaprogram'sexecution,auserislikelyto eitherinsertabreakpointatararecaseorinanerrordetec\u00adtionroutine,ortolettheprogramrununtilitencounters \nafaultorspuriousexit.Atthispointtheywoulduseshort backwardsmovementstoinvestigatewhathappened.The longforwardexecutionjustusesthestepcounter. \nThisismeanttobeapracticaldebuggingtechniquethat canbeusedonrealprogramsrunningforminutes,hours,or evendays(suchasanetworkserver).Checkpointing(dis\u00adcussednext)willallowtheusertoquicklymovebacktore\u00adcenteventsevenafterhavingexecutedforhours.Forevents \nfurtherinthepast,ourcheckpointingalgorithmwillprovide responsetimesproportionaltothedistancemovedback. \n5Checkpointing Weexpectexecutiontimeinatraditionaldebuggertobe roughlyequivalenttothetemporaldistancemovedforward, \nandweexpectshortmovementstobeperformedwithout noticeabledelay.Thisiswhatweconsider\\efcient\"per\u00adformance;theonlytimeamovementincursnoticeabledelay \niswhenthestoppingpointissomuchfartheralongtheexe\u00adcutionpaththatthedelayincurredwouldbeexpected,and thesedelaysshouldbeproportionalwithinasmallfactorto \nthedistancemoveforward.Traditionaldebuggersprovide thismostofthetime,butfailtoprovidegoodperformance \nincreasingseriesofintervalsbehindthecurrentposition. forcasesthatcausethemtoexecutealargenumberoftraps \nbacktothedebuggerasdiscussedinSection1.2.Bdb's counterbasedmethodsperformallforwardmovements(in\u00adcludingthosecasethataredifcultforatraditionaldebug\u00adger)efcientlyandaccurately. \nWelikewisefeelthesameperformancegoalshouldbe appliedtobackwardsmovements.Movementsashortdis\u00adtancebackshouldbeperformedwithoutnoticeabledelay, \nandlongermovementsshouldtaketimeroughlyequivalent tothedistancemovedback.Wehaveusedcheckpointingto addressthisgoal. \nWecreatecheckpointsatregularintervalsbyforkingthe processbeingdebugged.Byusingforktocreatecheckpoints, \nwetakeadvantageoftheoperatingsystem'sefcientcopy onwritepolicy.Forperformancemeasurementsweuseda checkpointintervalof1/10ofasecond.Intheforworst\u00adcaseforthestudentapplicationsthisincurredanadditional \nperformanceoverheadof7%,andonaverageanoverhead ofonly3%.ForthemuchlargerSPECapplicationsthe overheadrangedfrom9%to45%.Increasingthecheckpoint \nintervalto1secondbroughtthecheckpointingoverheadfor theSPECapplicationsdowntoarangeof1%to14% Shortbackwardsmovementsonlyneedtore-executein \nthelastinterval,andthusallshortmovementswillfnish quickly.Forexample,ourslowestmovement\\buntil!=\"on ourworstcaseapplicationpresentedinTable1hasatwo \npassalgorithmwithatotalslowdownfactorof5.1.Relative toitsforwardexecutionwithaslowdownfactorof1.95,for \na1/10ofasecondcheckpointintervalthisworstcasefora shortmovementwouldrequireonly0.26seconds. 5.1ExponentialCheckpointThinning \nToavoidoverwhelmingtheprocessorwithcheckpoints,we startthinningthemoutastheybecomeolder.Figure12 showsaneatlythinnedsetofcheckpointsrepresentativeof \nwhatourcheckpointthinningalgorithmwillaspireto.Our goalistocreateasmallsetofcheckpointsfromwhichwe canre-executetoanyearlierpointinatimeproportionalto \nthedistancemovedback.Inthefgurethecheckpointsare retainedat:1,2,4,8,and16intervalsbackfromthecur\u00adrentposition(representedbytheblackdot).Theseintervals \nwouldcontinuetogrowexponentiallyaspowersof2asthey wentfurtherbackintimeuntilthebeginningofthepro\u00adgram'sexecution.Observethatthesizeofeachcheckpoint \nintervalinthisexampleisequaltothedistancebetweenthe endofthatintervalandthecurrentposition.Henceany priorexecutionpointiscontainedwithinacheckpointinter\u00advalthatisnolongerthandistancebetweenthatexectution \npointandthethecurrentposition. Ourthinningpolicy,isdesignedtoachieveasetofcheck\u00adpointintervalsthatmaintainsthispropertythatnoexe\u00adcutionpointeverbeinacheckpointintervalwhosesizeis \ngreaterthanthedistancefromthecurrentpositionback tothatpoint.Thesecheckpointintervalsareadjustedas Figure14:Abackwardsmovementexploresthecheckpointlocatestheclosestintervalcontainingtheeventofinterest.performedontheintervalcontainingthestoppingevent. \nwedynamicallyexecuteforward.Eachtimewereachthe startofanewcheckpointinterval,wescanthecurrentlist ofcheckpointsandthinoutanycheckpointsuchthatthein\u00adtervalbetweencheckpointswouldnotgrowlargerthanthe \ndistancefromtheendoftheresultingcombinedintervalto thecurrentexecutionpoint.Thisdoesindeedcreatease\u00adriesofexponentiallylargercheckpointintervalsastheyget \nfurtherback,althoughsincethesearecreateddynamically onthefyasweexecuteforward,theyarerarelyasneatly proportionedatexactpowersof2asintheexample. \n5.2OnePassMovements Backwardsmovementsexplorethesecheckpointintervalsin reversetofndtheclosestprecedingintervalcontainingthe \npointofinterest.Byourintervalconstruction,theinter\u00advalcontainingthestoppingpointcannotbelargerthanthe \ndistancemovedback,andalsothesumofthesizesofthe otherintervalsexplored,asweworkourwaybacktothe desiredinterval,isalsolessthanorequaltothedistance \nmovedback.Togetherthisboundsthesumofthesizesof thecheckpointintervalsexploredtobelessthanafactorof 2timesthetemporaldistancemovedback. \n5.3TwoPassMovements Theprecedingargumentappliestosinglepassbackwards movements.Fortwopassbackwardsmovementswemust \nconsiderthecostofthesecondpass.Thiswillbeexplained withthehelpofFigure14.Thisfgureshowsthesetof exponentiallythinnedcheckpointintervalsfromtheprevious \nfgurealongwithnumberedarrowsindicatingtheorderofre\u00adexecutionsperformedwhenseekingthepointmarkedwith theX.Thispointcouldbeanypointsoughtbyatwopass \nmovement:alocationbreakpoint,apreviouspoint,abefore point,oradatavaluebreakpoint.Wewillrefertoitasa breakpointinourdiscussion. \nThefrstre-executionpassisseekingtofndtheclosest precedingintervalcontainingthebreakpoint.Itexplores thecheckpointintervalsinreverseorderuntilaninterval \ncontainingabreakpointisfound.(Ifwewerelookingfor acountedbreakpoint,anyintervalsfoundcontainingfewer \nthanthedesiredcountwouldsimplydeductthenumberof breakpointsfoundinthatintervalfromthedesiredtotal.) Onlyonebreakpointisshown,buttheintervalcouldinfact \ncontainmultiplebreakpointoccurrences.Ifso,wewantthe lastone(orthedesirednumberbackincaseofacounted intervalsinreverse,startingfromthecurrentposition,untilit \nFormovementsrequiringtwopasses,thesecondpassisonly movement).Inanycase,sincewedonotknowhowmany willoccurwithintheinterval,thefrstpasswillcountthe \nnumberofoccurrences,andthesecondpasswillexecuteto thedesiredcount. Aswere-executeeachinterval,wefllinanymissing \ncheckpointsforthatinterval.Whenwecompletethere\u00adexecutionofalargecheckpointinterval,wewillthushavea freshsetofcheckpointintervalsthatobeyourpropertyof \nnonebeinglargerthanthedistancebackfromthecurrent point(whichisnowattheendoftheintervaljustflledin). Thisisshowninthefgureonlyforcheckpointintervalnum\u00adber5.Checkpointsareinfactnotneededforlaterexecution \npointsbecauseanylaterpointcanbereachedthroughfor\u00adwardexecutioninlineartime,andthusbythetimethe debuggerfnishesinterval5,itmayhavealreadydiscarded \nanyflledincheckpointsforintervals1through4aswellas eventhecheckpointsseparatingthoseintervals. Giventhisfllinginofcheckpoints,forthesecondpassof \natwopassmovementalgorithmweonlyneedtore-execute inthesinglesmallcheckpointintervalfoundtocontainthe breakpoint.Intheexamplethisisinterval6. \nInthecaseshown,thetotalre-executionis17.5intervals, andthedistancemovedbackis10.5intervals,foranetre\u00adexecutionfactorof1.7timesthedistancemovedback.This \nstillfallswithinourfactorof2bound.Theonlyplacewhere itcanexceedthisboundiswithinthelast(intheforward \ndirection)sub-intervalofaflledininterval.Forexampleif thedestinationpointwasjustalittlebitpriortointerval \n4,thetemporaldistancemovedbackwouldbe8+.and thetotalneededre-executionwouldbe17...Thisleads toaboundfor2passalgorithmsofafactortwotimesthe \ntemporaldistancemovedbackplusoneminimumcheckpoint interval. 5.4FasterandSlowerCases Theabovediscussionisvalidforthefrstbackwardsmove\u00admentexecuted.Unfortunatelywithmultiplebackwards \nmovementsoursystemcanexperienceperformanceanoma\u00adliesthatdonotmeetourgoals.Onesuchcaseoccursafter theuserhassteppedbackalongdistancetoapointnear \nthestartofalargecheckpointinterval(suchasthestart ofinterval4).Thatmovementactuallyperformsverywell, \nrequiringre-executionofonly1timesthedistancemoved back,ratherthantheupperboundof2times.Howevera subsequentshortstepbackintotheprecedinglargecheck\u00ad \npointinterval(interval5inthiscase)requiresre-execution ofthatentireinterval,thuspayingthepriceforourgood \nluckontheprecedingmovement.Theperformanceonthe shortmovementconsideredbyitselfdoesnotmeetourper\u00adformancegoal. \nTherearealsocaseswhereweperformmuchfasterthan expected.Thedebuggermaintainsanypotentiallyuseful counterinformationgatheredforeachcheckpointinterval. \nForexample,forbreakpointsthedebuggerrecordsthenum\u00adberofbreakpointvisitsandaversionnumberrepresenting \nthesetofbreakpointsatthetimethecountsweregathered. UsingtheexamplefromFigure14,ifbreakpointcountshad \nbeengatheredduringforwardexecutionandwewerenow lookingforthesamesetofbreakpointsinreverse,thede\u00adbuggerwouldknowthatnobreakpointsoccurredinintervals \n1through4,anditwouldalsoknowthenumberofbreak\u00adpointsoccurringininterval5.Itwouldthemonlyneedto performthesecondpassre-executiononinterval5.The \ntotaltimeforthisbeingabouthalfthetemporaldistance movedback. Thesesavedcountsarecombinedandsplitascheckpoints \nareremovedorinsertedintocheckpointintervals.Theycan alsosometimesbeusedforfasterthanexpectedforward movements,ifforexamplethedebuggeralreadyknowsthat \nnobreakpointsoccurinacertaininterval. 5.5FastUndo A.nalfeatureweprovideisafastundo.Whenstarting anewmovement,wealwaysretaintheclosestcheckpoint \nprecedingthestartingpoint.Ifaskedtoundothemovement, wecanthenexecutetothestartingpointquicklyfromthe \nretainedcheckpoint.Thusiftheuseraccidentallycontinues fromsomepoint,seekingsomeeventthatdoesnotoccur, \nwhentheyrealizeithastakentoolong,theycaninterrupt thedebugger,issueanundocommand,andimmediatelybe backwheretheywere. \n5.6SpaceUsage Thesetofcheckpointsgrowslogarithmicallyasafunction oftheexecutiontime,andthecheckpoints(createdbyfork\u00adingaprocess)areeachthesizeoftheprocess.Weexpect \ninpracticethattherewillbemucheconomyinspaceusage gainedbyanoperatingsystemthatusesacopyonwrite policy,forthenthespaceneedswillonlyinvolvethepage \ntablesandthosepagesthathavechangedbetweencheck\u00adpoints.Wehavenotevaluatedtheextentofthisbene.t. Therearetradeo.sthatcouldbemadetodecreasethe \nnumberofcheckpointsneeded.Forexamplewecouldin\u00adcreasethecheckpointintervalto1second.Thiswouldlead toanoticeablebuttolerableincreaseinthere-execution \ntimeforshortbackwardsmovements(intherangeoffrom 1to3seconds).Thiswouldalsogreatlyreducethecheck\u00adpointcreationoverhead.Forsituationsinvolvingtryingto \nlocatesporadicbugsthatappearafterdaysofexecution, acheckpointintervalof1minutewouldseemreasonable. Oncethedebuggerstoppedonanerror,wecouldthenre\u00adducethecheckpointintervalandin1minutestime.llinthe \ncheckpointsforthelastminutelongintervalbyre-executing thatinterval. Wealsomightsetalimitonhowfarbackauserisableto \nmove,perhapsafewminutes,andthendiscardanycheck\u00adpointsolderthanthatlimit.Thiswouldgiveusacon\u00adstantboundonthenumbercheckpoints.Alternatively,we \ncouldsetaconstantboundonthenumberofcheckpoints andthenatpointswhentheneedforcheckpointsexceeded thebound,wecouldrelaxthefactorof2oncheckpointthin\u00adning.Thiswouldgraduallyincreasethefactorof2boundon \nre-executiontimerelativetothetemporaldistancemoved back. Therecertainlyareotherreasonableoptionsforman\u00adagingthesetofcheckpoints.TolmachandAppel[12]ina \nprojectwithmanysimilaritiestoourown,chosetoman\u00adagetheircheckpointsasacache.Thiswasmotivatedby theirargumentthatuseractivityislikelytobeclustered \naroundcertainpointsalongtheexecutiontimeline,and thatcachingwouldretainthosecheckpointsthatwereused. \n6I/OReplay Animportantrequirementforsuccessfulre-executionisthat theprogramre-executedeterministically.Caseswherewe \nmightgetnondeterministicbehaviorincludeseedingaran\u00addomnumbergeneratorbaseduponthetimeofday,ormod\u00adifyinga.lesothatwereaddi.erentvaluesfromitupon \nre-execution. Weprovidetheabilitytocapturethereturnvaluesfrom systemcallsandreplaythemduringre-execution.Forex\u00adample,onre-executionofasystemcalltogetthetimeof \nday,wereturnthetimefromtheoriginalsystemcall,and thustheprogramwouldseedtherandomnumbergenerator thesame.Onre-executionofaread,wereturntheoriginal \ndataread,eventhoughitmaynotactuallybeinthe.le anymore.Forawriteweactuallyonlyneedtorecordand replaythereturnedstatusvalue. \nUNIXprovidesamechanismfortrappingtothedebugger upontheentryandexitofsystemcallsbythechild.Unfor\u00adtunatelythisprovedinadequateforourpurposesandwehad \ntoresorttoamorecumbersomemethodusingexplicittrap instructionsbeforeandafterthesystemcallinstruction. \nNoneofourtestcasesusedforperformanceevaluation actuallybehavenondeterministically,andbydefaultI/O loggingisdisabled.Wereportheretheperformanceimpact \nwhenI/Ologgingisenabled. Forthe.rst4applications,whichhavevaryingbutnot overwhelmingI/Ousage,wemeasuredtheirI/Ologging \noverheadsas3.5%,72%,75%,and0.1%.Howeverthefern program,whichiscompletelyI/Obound,hadanoverhead of5100%,whichtranslatestoaslowdownbyafactorof52. \nReplayingfromtheI/Ologincursroughlyhalftheoverhead incurredwhencreatingit. Therearealsosituationsinwhichourre-executionper\u00adformancemayactuallybemuchfasterthentheoriginalpro\u00adgram'sexecutiontime.Inanetworkserverapplication,or \naninteractiveapplication,alargefractionofthewallclock timemaybeexpendedwaitingforeventssuchasmessages \norkeyclicks.Duringre-executionwereplaytheevents,but wedon'treplaythewaitingtime.Forasimpletexteditor, \nwecouldprobablyreplayhoursofusertimeinafewminutes orevenseconds. Alargeportionofprogramswrittentodayareinterac-tivegraphicalapplications.Thesearebothnondeterminis\u00adtic(becausetheyareinteractive)andpotentiallyI/Obound \n(becauseofthegraphics).FurtherimprovementsinourI/O loggingareclearlyneededtoaccommodatetheseapplica\u00adtions, \nFurthermore,ourI/Ologgingandreplayoccursatthe processboundary.InanX-Windowsapplication,whenwe backupthestateoftheprocess,wecanseewhathappened \nwithintheprocess,whatthevaluesofitsvariableswere, andwhatX-Windowscallsweremade.Butwedon'tsee thegraphicswindowredrawn.Thisisoutsidetheprocess \nbeingdebugged,andthusitisonlyafectedbytheI/Oper\u00adformedbytheoriginalprocessandnotbythere-execution processes.Backingupthegraphicstatealongwiththein\u00adternalprocessstatewouldbeavaluableaddition.Thiswas \nnicelydoneinareversibleLISPdebuggerbyLiebermanand Fry[6]. 6.1Difculties I/Ologgingisacomplextask.Thereare262Unixsystem \ncalls.Somearesimplesuchas\\getpid\",andjusthaveregis\u00adterreturnvalues.Otherssucha\\read\"requirethebufering \nofpossiblylargeinputs.The\\readv\"systemcallhaseven morecomplexbuferingrequirementsduetoitsvectorof bufers,andothersystemcallssuchas\\ioctl\"havebeen \nusedforamyriadofdiferentpurposesandareaquagmire ofspecialcases. Formostsystemcallswecapturetheirreturnvalues \nwhentheoriginalprogramexecutesthesystemcall,and wereplaythosecapturedvalueswhenre-executingthesys\u00adtemcall.Howevertherearesomesystemcallsthatactually \nneedtobere-executed.Forexample,\\obreak\"isusedto changethetopoftheheapwhenmorespaceisneededfor dynamicmemoryallocation.Wemustre-executeitsothat \nthere-executionprocesswillhaveitsheapextendedaswell. Ofthe262systemcalls,wehaveimplemented(orpar\u00adtiallyimplementedinthecaseof\\ioctl\")I/Oreplayforonly \n35ofthem.Thesearetheonesthatwehaveseenusedin ourtestprograms.Muchfurtherworkcouldbedoneonthe I/Oreplayaspectsofbdb. \n7RelatedResearch Thereisadiversebodyofresearchaddressingmanyoftheis\u00adsuesbroughttogetherinthisproject.Mellor-Crummeyand \nLeBlanc[7]developedafastsoftwarecounterforprogram replay.Kessler[5]usedcodeaugmentationtoprovidefast \nbreakpointsforprofling.Wahbe,LuccoandGraham[13]in\u00advestigatedfastdatabreakpointsduringforwardexecution. \nFeldmanandBrown[3]basedtheirreversibledebuggeron checkpointing.PanandLinton[10]discussedloggingsystem \ncallsandreplayingthemfordeterministicre-execution. Themostcommonapproachtoproducingbidirectional debuggershasbeentocreateahistorylogofallchangesto \nvariables[1,2,6,8,9,11,14].Twoofthebestsuchprojects werethosebyLiebermanandFry[6]andbyMoher[8].Both providedarichsetofbidirectionalmovements,butwerelim\u00aditedtoshortrunningprogramsbecauseoftherapidgrowth \nofthehistorylog.Theyalsowerebasedoninterpretersso theyincurredlargeexecutionslowdowns.Agrawal[1]and Netzer[9]bothaddressedthehistorylogsizeproblemby \ncondensingthechangestoacoarsesetofpoints,butatthe costoflessfexibilityinbackwardsmovements. Re-executionhasbeenusedprimarilyfordeterministic \nforwardreplayofparallelprograms[4,10].Feldmanand Brown[3]builtadebuggerforsequentialprogramsbased uponfrequent(andfast)checkpointing,inconjunctionwith \naninterpretertomoveforwardfromcheckpoints,butthey werehamperedbytheslowspeedofinterpretation.The mostsignifcantuseofre-executiontodateforbidirectional \ndebuggingwasanMLdebuggerbyTolmachandAppel[12]. Theyusedastepcountertoprovidestepandbstepmove\u00admentswithareportedaverageslowdownof2.7.Continue \n1,bcontinue1,andnext1wereprovidedbyusingalarge bitvectorwithonebitforeverysourcelocationandapro\u00adcessofusingalogarithmicnumberofre-executionpassesto \nbinarysearchovertimeintervals.Thisbinarysearchwas performednotonlyforbackwardbreakpoints,butalsofor forwardbreakpoints!Theirbitfagandbinarysearchalgo\u00adrithmalsolimitedthemtomovingbyasinglebreakpointat \natime,soefcientcountedbreakpointswerenotpossibleun\u00addertheirsystem.Theygavenoperformancemeasurements forthesemorecomplexmovements. \n8Conclusions Wehavedevelopedacombinationoftechniquesanddemon\u00adstratedthroughaworkingimplementationthatitispossible \ntobuildabidirectionalprogramdebugger,thatispractical, efcient,precise,andapplicabletoaverybroadspectrum \nofprograms. Centraltothisaccomplishmentisourtechniqueofem\u00adbeddingcallstocounterroutinesatsteppingpointsand \natfunctionentryandexitpointsthroughoutthepro\u00adgrambeingdebugged.Astheuserissuesdebuggingmove\u00admentcommands,wecanefcientlyswitchtheentireset \nofcallstoagroupofcustomizedcountersdesignedtoim\u00adplementthedesiredmovement.Wehavedevelopedsim\u00adplecounterroutinestoprovideacompletesetofboth \nforwardandbackwardsmovements:stepn,continuen, nextn,fnishn,until==,until!=,bstepn,bcontinuen, previousn,beforen,buntil==,buntil!=,andageneral \nundo. Theefciencyofourdebuggerarisesfromouruseof programre-executiontoreconstructearlierprogramstates \nalongwithperiodiccheckpointingtolimittheamountof re-executionneeded.Wehavedevelopedamethodofex\u00adponentialcheckpointthinningthatallowsustolocateand \nmovebacktoanynearbypointsquicklyandtoreachpoints furtherbackwithinamaximumtimeboundofroughlytwice thetemporaldistancemovedback.Ourexponentialthin\u00adningofcheckpointslimitsthenumberofcheckpointsneeded \ntoalogarithmicfunctionoftherangeofbackwardsmove\u00adments. FinallyI/Ologgingandreplayallowustoensurede\u00adterministicre-executionforthoseprogramsthatotherwise \nmightre-executeinanondeterministicfashion. Abidirectionaldebuggersuchasbdbcanalleviatemuch ofthetediuminusingatraditionaldebuggerbygreatlysim\u00adplifyingandexpeditingtheprocessoftracingthecauseof \nabugbackwardsfromthepointwhereitbecomesmanifest. Furthermore,thetrepidationofsteppingpastsomethingof \nimportance,whenusingaforwardonlydebugger,isless\u00adenedsinceundoingincorrectmovementsisnowsimpleand immediate.Wehopethatthesuccessofthisprojectwill \nspurwidespreadincorporationofbidirectionalcapabilities intocommercialdebuggers. 9Acknowledgments Wegratefullyacknowledgethehardworkofthegraduate \nstudentswhohelpedbuildthisproject:RobertZulawnik, SteveDorato,RichardBest,andCharlesCarr.Weappre\u00adciatetheenthusiasmandencouragementofearlyviewersof \nthisresearch,andwethankNSFfortheirsupportthrough grantCCR-9619456.Finally,wethankthePLDIreviewers fortheirthoughtfulcommentsandsuggestions. \n References [1]HiralalAgrawal,RichardA.DeMillo,andEugeneH. Spa.ord.AnExecution-BracktrackingApproachtoDe-bugging.IEEESoftware,8(3):21{26,May1991. \n[2]R.M.Balzer.Exdams:Extensibledebuggingandmon\u00aditoringsystem.InProc.SpringJointComputerConf., pages567{589.AFIPSPress,Reston,VA,1969. \n[3]StuartI.FeldmanandChanningBrown.Igor:asys\u00adtemforprogramdebuggingviareversibleexecution.In Proc.SIGPLANWorkshoponParallelandDistributed \nDebugging,pages112{123,Jan.1989. [4]RobertJ.Fowler,ThomasJ.LeBlanc,andJohnM. Mellor-Crummey.AnIntegratedApproachtoParal\u00adlelProgramDebuggingandPerformanceAnalysison \nLarge-ScaleMultiprocessors.InProc.SIGPLANWork\u00adshoponParallelandDistributedDebugging,pages163{ 173,Jan.1989. \n[5]PeterB.Kessler.Fastbreakpoints:Designandimple\u00admentation.InProc.SIGPLAN'90PLDIConf.,pages 78{84,June1990. \n[6]HenryLiebermanandChristopherFry.SoftwareVi\u00adsualization,chapterZStep95:AReversible,Animated SourceCodeStepper,pages277{292.MITPress,1998. \n[7]J.M.Mellor-CrummeyandT.J.LeBlanc.Asoft\u00adwareinstructioncounter.InASPLOS-IIIProceedings, pages78{86,April1989.AppearedasSIGPLANNo\u00adtices24(SpecialIssue). \n[8]T.G.Moher.PROVIDE:AProcessVisualizationand DebuggingEnvironment.IEEETransactionsonSoft\u00adwareEngineering,14(6):849{857,June1988. \n[9]RobertH.B.NetzerandMarkH.Weaver.Optimal tracingandincrementalreexecutionfordebugginglong-runningprograms.InProc.SIGPLAN'94PLDIConf., \npages313{325,June1994. [10]DouglasZ.PanandMarkA.Linton.Supportingre\u00adverseexecutionofparallelprograms.InProc.SIG-PLANWorkshoponParallelandDistributedDebug\u00adging,pages124{129,Jan.1989. \n[11]DanielG.Shapiro.Sni.er:aSystemthatUnderstands Bugs.Master'sthesis,MITDept.ofEE&#38;CS,1981. [12]AndrewTolmachandAndrewAppel.Adebuggerfor \nstandardML.J.FunctionalProg.,Jan.1993. [13]RobertWahbe,StevenLucco,andSusanL.Graham. Practicaldatabreakpoints:Designandimplementa\u00adtion.InProc.oftheSIGPLAN'93PLDIConf.,pages \n1{12,1993. [14]M.V.Zelkowitz.Reversibleexecution.Communications oftheACM,16(9):566,September1973.\n\t\t\t", "proc_id": "349299", "abstract": "<p>This paper discusses our research into algorithms for creating anefficient bidirectional debugger in which all traditional forward movement commands can be performed with equal ease in the reverse direction. We expect that adding these backwards movement capabilities to a debugger will greatly increase its efficacy as a programming tool.</p><p>The efficiency of our methods arises from our use of event countersthat are embedded into the program being debugged.  These counters areused to precisely identify the desired target event on the fly as thetarget program executes.  This is in contrast to traditional debuggers that may trap back to the debugger many times for some movements.  For reverse movements we re-execute the program (possibly using two passes) to identify and stop at the desired earlier point. Our counter based techniques are essential for these reverse movements because they allow us to efficiently execute through the millions of events encountered during re-execution.</p><p>Two other important components of this debugger are its I/O logging and checkpointing.  We log and later replay the results of system callsto ensure deterministic re-execution, and we use checkpointing to bound theamount of re-execution used for reverse movements.  Short movements generally appear instantaneous, and the time for longer movements is usually bounded within a small constant factor of the temporal distance moved back. </p>", "authors": [{"name": "Bob Boothe", "author_profile_id": "81100208999", "affiliation": "Computer Science Dept., University of Southern Maine, Portland, ME", "person_id": "P31169", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/349299.349339", "year": "2000", "article_id": "349339", "conference": "PLDI", "title": "Efficient algorithms for bidirectional debugging", "url": "http://dl.acm.org/citation.cfm?id=349339"}