{"article_publication_date": "05-01-2000", "fulltext": "\n h a s C + + , TM , fo r in a n ew f oo , w h p o in e a n d in h p o in y h a w m t o n T M h p oin \ny p e is n o t e id en ClassA{ public staticvoid foo(C c) { ... Bb=goo();//b1 b.Bbar();//cs1 c.Bbar();//cs2 \nclassB{ publicvoid{ ... Bbar () } } staticBgoo(){returnnew B(); // cs3 } } public void bar(Cc1) class \nC extendsB { { foo(c1); // cs4 } } } Figure1:Anexampleprogram. andcreateaspecializedversionoftheoptimizedcode.We \ngeneratecodecalledtheextantsafetytesttobeexecuted duringruntimeforasafeinvocationofthespecializedcode. \nWithinourframeworkweguaranteethatoncespecialized codeisinvoked,itwillexecutecorrectlyandsafelyforthat \ninvocationevenwhennewclassesareloaded. WenowillustrateourframeworkusingtheexampleofFig\u00adure1.WeusethenotationC::mtomeanthatthemethod \nmisdefnedinclassC.ClassesA,B,andCaretheonly classesavailableforof-lineanalysis.Werefertoclasses availablefortheofineanalysisas\\extantclasses,\"andan \nobjectwhoseruntimetypeisanextantclassasan\\extant object.\"Withrespecttothe\\closed-world\"programofthe extantclasses,\\extantanalysis\"determinesthattheclassof \ntheobjectpointedtobybatcs1isguaranteedtobewithin theclosedworld:theclass(B)oftheobjectcreatedatcs3. Adatafowanalysiswithrespecttotheclosed-worldpro\u00adgramdeterminesthatthemethodinvocationb.Bbar()at \ncs1hasonlyonetarget,i.e.,B::Bbar().Foranyinvocation offoo(Cc),therefore,b.Bbar()atcs1canbedevirtualized \nandinlined. Extantanalysisalsodeterminesthattheobjectpointedto byatcs2isthesameasthatpointedtobyparameter \nccattheentryoffoo(Cc).A::foo(Cc),beingapublic method,canbeinvokedfromoutsidetheclosedworld,and theobjectpointedtobycatcs2canbeextantornon\u00adextant.Adatafowanalysiswithrespecttotheclosed-world \nprogramdeterminesthatifcatcs2pointstoanextant object,themethodinvocationc.Bbar()atcs2hasonly onetarget,B::Bbar().Whereasb.Bbar()atcs1canbe \ndirectlyinlined,aruntimetestisneededtoguardtheinlined B::Bbar()invokedatcs2. SincecdoesnotchangewithinA::foo(Cc),wecanfur\u00adtherspecializetheentirebodyoffoo(Cc)withrespectto \ntheassumptionthattheruntimetypeofcisextant.We designatethespecializedversionoffoo(Cc)asfoo'(Cc). Thisspecializedversioncanbesafelyinvokedbyanycall \nsiteinvokingthemethodthatpassesanextantobjectas theparameter.Sincec1atcs4ispassedastheparame\u00adtertoA::foo(Cc),wecanplacearuntime\\extantsafety \ntest\"priortocs4.Atruntime,thistestdetermineswhether c1pointstoanextantobject.Ifso,thespecializedfoo'(C \nc)isinvoked;ifnot,theoriginalfoo(Cc)isinvoked.The transformedcodeatA::bar()lookslike if(c1pointstoanextantobject) \nfoo'(Cc); else foo(Cc); Extantanalysisstaticallydeterminesthesetofcallsites suchascs1wherethetargetmethodisguaranteedtobein \ntheclosedworld,andcallsitessuchascs2wherethetarget methodcanbewithinoroutsideoftheclosedworld.In theextantanalysisframework,wealsodetermineprogram \nlocations(suchascs4forcallsitecs2)forplacingaruntime extantsafetytestthatcanmaximizeoptimizationopportu\u00adnities,anddeterminehowtogenerateandperformsucha \ntest. DetlefsandAgesen[15]introducetheconceptofpreexistence inthecontextofadynamiccompiler.Hereinliningonly \ntakesplaceforthosecallsitesforwhichtheobjectpointed tobythereceiverexpressionhasalreadybeenallocatedat \nthemomentofinvocationofthecontainingmethod.Using theirpreexistencetechnique,themethodinvocationatcs1 \ncannotbeinlined,becausetheobjectpointedtobybisnot allocateduntilaftertheinvocationoffoo(). Anotherapproachtodevirtualizationandinliningisbased \nonaruntimetypecheckofthereceiverexpression[20].Us\u00adingthistechnique,onecandevirtualizeandinlinec.Bbar() \natcs2asfollows: if(cinstanceofB||cinstanceofC){ //devirtualizeandinlineB::Bbar() } else { c.Bbar(); } \nIncontrasttotheruntimetypecheck,ourextantsafetytest cancovertheentirespecializedmethod.Thisoferstheop\u00adportunityforoptimizationsacrossthemultiplestatementsof \nthespecializedmethod.Further,thestatementscoveredby asingleextanttestcancrossmethodorclassboundaries,in \nwhichcaseinterproceduraloptimizationscanbeperformed acrossmuliplelevelsofmethodinvocations. 197 InthispaperwedonotaddresstheJavafeaturesofreloading \nandtheJavaNativeInterface.2 WeimplementedtheframeworkusingtheJalape~noVir\u00adtualMachine[1]andexperimentedonasetofSPECjvm98 \nbenchmarkprogramsandonportBob[4].Wepresentour preliminaryexperimentalresultinSection6. Themaincontributionsinthispaperareasfollows: \n Weintroduceaframeworkforinterproceduralopti\u00admizationthatdoesnotrequireinvalidationduringex\u00adecutionwhenanewclassisloaded. \n Weintroduceananalysistechnique,calledextantanal\u00adysis,toidentifycoderegionsthatcanbespecialized andtoidentifypointsintheprogramthatcanbeaf\u00adfectedbydynamicclassloading. \n Weuseparametricdatafowanalysisasabasisfor performingoptimizationsonthespecializedcodere\u00adgions.  Weintroduceanextantsafetytestthatcanbeper\u00adformedduringexecutiontosafelyinvokethespecial\u00adizedcoderegions.Weshowhowtogenerateandper\u00adformsuchtests.Wealsoformalizethesafetyproper\u00adtiesofanextantsafetytest. \n WeexperimentedwithourframeworkusingJalape~no VirtualMachine.Wepresentbothstaticanddynamic resultstoevaluateourframework. \n Therestofthepaperisorganizedasfollows:Section2de\u00adscribestherelationshipbetweenJavadynamicclassloading \nandtheframeworkforofineanalysis/optimizationusedin thispaper.Section3describesextantanalysis.Section4 \ndescribesourtechniquesforidentifyingcandidatecodere\u00adgionsforspecializationandgeneratingspecializedcodere\u00adgions.Section5describestheplacementandgenerationof \nextantsafetytests.Section6describesourimplementation andexperimentalresults.Section7discussesrelatedwork, \nandSection8givesourconclusion. 2. DYNAMIC CLASS LOADING AND THE CLOSED WORLD InJavathereareseveralwaysinwhichanewclasscanbe \nloaded.AccordingtotheJavaspecifcation,duringexecu\u00adtionanewclassshouldbeloadedifthereisareferenceto anelement(suchfeldsormethods)ofthenewclass[18; \n26].Therearetwootherwaysofloadinganewclassin Java:(1)viaClass.forName()constructsand(2)viauser defnedclassloaders[25].3 \nWhenJavaisimplementedinastaticenvironment,such asJAX,IBMHPCJ,NaturalBridge,orMarmot,thestatic compilerexpectsthewholeprogramtobepresentduring \ntheanalysis[22;17;28;33]HPCJ,forinstance,searches allmethodsandclassesthatarereachablefromthemain() 2TheseJavafeaturescouldpotentiallymodifycodeon-the\u00adfyandsocouldafectourassumptionsabouttheclosed \nworld. 3Classloadersallowthesamefullyqualifedclassestohave diferentruntimetypesduringexecution.Aruntimetypeof \nanobjectisapairhL,Ci,whereLthedefningclassloader forC.Theofineanalysisphasemustbeawareofclass loaderstoensuretypesafetyoftheprogram[25;31]. \nmethodinthemainapplicationclass.Butwhenitencoun\u00adtersaClass.forName()oruserdefnedclassloaders,itrelies \nontheusertoprovideallpossibleclassesthatcanbeloaded atsuchpoints.Ifauserfailstoprovideallclassesthatcan \nbedynamicallyloadedatsuchpoints,thenHPCJwould potentiallygenerateincorrectcode. Inourframeworkwealsorelyontheusertoprovidemethods \nandclassesthatcanparticipateintheofineanalysisand optimizationphase.ButunlikeastaticJavaenvironment, \nourframeworkguaranteescorrectnesseveniftheuserdoes notprovideallofthedynamicallyloadableclasses.Wecall \nthesetofclassesandmethodsthatparticipateinofine analysisandoptimization,theclosed-worldprogram.There \nareseveralwaystoconstructtheclosed-worldprogram:(1) usethesamestrategyasthatofastaticJavacompiler,such \nasHPCJ,exceptthattheuserneednotspecifyallpossible classesthatcanbeloadedatClass.forName()pointsorby user-defnedclassloaders;(2)useproflinginformationand \nincludeonlyhotmethodsandclasses;and(3)theusercan specifythesetofallclassesandmethodsthatparticipatein \ntheclosedworld. 3. EXTANT ANALYSIS Inthissectionwedescribeextantanalysis.Firstwedefne certainusefulterms. \nClassinheritancerelationshipsinJavacanberepresented usingaClassInheritanceGraph(CIG)G(N,E,r)where Nisasetofnodesrepresentingeitheraclassoraninter\u00adface,Eisasetofedgesrepresentinginheritancerelation, \nandrisadistinguishedrootnoderepresentingtheclass java.lang.Object.Wewillsometimesusethetermtypeto meaneitheraclassoraninterface,sub-typetomeansub\u00adclassorsub-interface.Anedge(x,y)2Erepresentsthat \nxisanimmediatesuper-type(alsocalledtheparenttype) ofy,andyisanimmediatesub-type(alsocalledthechild type)ofx.Ifthereisapathfromatypextoanothertypey \ninG,thenxiscalledtheancestortypeofy,andyiscalled thedescendenttypeofx. Givenadeclarationoftheform\\Tp\",Tiscalledthedeclared \ntypeofthereferencevariablep.Duringprogramexecution thetypeRoftheobjectthatppointstocanbeanyclass thatis(directlyorindirectly)derivedfromT.Wewillcall \nRtheruntimetypeorconcretetypeoftheobjectthatpis pointingto.Nowletpbeareference(toanobject)and p.foo()amethodcall.Wecallpinp.foo()thereceiver \nexpression,andthetypeofthereceiverexpressionisthe runtimetypeofp.Wewillusethetermvirtualcallto includebothinvokevirtualandinvokeinterfacecalls. \nDefinition3.1(Closed-WorldSet).Thesetofcla\u00adssesandmethodsthatparticipateinof-lineanalysisandop\u00adtimizationiscalledtheClosed-Worldset,andisdenotedby \nCW. Definition3.2(ConnectedClosed-WorldSet). LetxandybeanytwoclassesinaCWsuchthatxisanan\u00adcestorofyintheCIG.LetPbeasetofallpathsbetweenx \nandy.CWissaidtobeaconnectedclosed-worldifandonly ifalltypesinParealsoinCW.CWissaidtobearoot\u00adconnectedclosed-worldifxistheclassjava.lang.Object \n(i.e.,therootoftheCIG). Aclosedworld'shavingthe\\connected\"propertysimplifes theanalysisandaidsinprogramoptimization.Through\u00ad \n publicvoidm1(StringcName) { Bp; if(...) S1: p=newB(); //extant else { S2: Classc=Class.forName(cName); \nS3: Objecto=c.newInstance(); S4: p=(B)o; //non-extant } S5:for(...) { S6: p.Bbar(...); //pisextantornon-extant \n} } Figure2:ExampleforExtantAnalysis outthispaperwewillassumearoot-connectedclosedworld, unlessotherwisestated. \nDefinition3.3.AclassC(oramethodM)isextantif andonlyifC(orM)isinCW.AnobjectOisextantif andonlyifitsruntimetypeisextant. \nWewillsometimesstatethataclassormethodisnotextant throughuseofthetermnon-extant. Definition3.4.Areference(suchasareceiverexpres\u00adsion)isunconditionallyextantataprogrampoint(callsite) \nifandonlyifitcanonlypointtoanextantobjectatthatpro\u00adgrampoint(callsite);otherwiseitisconditionallyextant. \nSinceweusethetermsclassandtypeinterchangeablywe sometimessaythata\\typeisextant\"insteadofsayingthat a\\classisextant.\" \nDefinition3.5.Avirtualcallsiteisunconditionallyex\u00adtantifandonlyifthereceiverexpressionatthatcallsiteis \nunconditionallyextant(otherwiseitisconditionallyextant). Astaticcallsiteisextantifandonlyifthetargetmethodof \nthecallsiteisinCW. Extantanalysisisadatafowproblemforcomputingthe \\extantstate\"ofthereceiverexpressionateachvirtualcall \nsite.Extantanalysisisperformedduringtheofineanaly\u00adsisphase.Thelatticeforextantanalysisconsistsofthree \nelements:UNKNOWN(T),unconditionallyextant(UCE), andconditionallyextant(CEor.).LetES=fTUCE .g bethesetoflatticeelements(extantstates).LetA2ES, \nthen.^A=.,andT^A=A.Ifareceiverexpressionis conditionallyextant,wecanthenestablisha\\degreeofex\u00adtantness\".Forinstance,ifwecandeterminestaticallythat \nareceiverexpressioncanneverpointtoanextantobject, thenwesayitisunconditionallynon-extant(UCNE).4 We 4 \nSometimesitisconvenienttoassumeafourelementlat\u00adticefTUCE UCNE .g,withUCE^UCNE=..For instance,ifweknowthatareferencewillalwayspointto \nanon-extantobject,thenwecansetitsextantstateto UCNE.AswewilldiscussinSection4,ifthereceiverex\u00adpressionofavirtualcallsitehasextantstateUCNE,thenit \nisnotbenefcialtooptimizewithrespecttosuchcallsites. willusetheconceptof\\degreeofextantness\"inSection4 \nforspecialization. Wecomputetheextantstateofthereceiverexpressionof eachinvocationsiteintwosteps: 1.Theextantstateofthereceiverexpressionissetto.if \nthetargetmethodisnotimplementedinthedeclared typeDofthereceiverexpression,orinanyancestor ordescendantofDinCW. \n2.Foranyotherreceiverexpressions,applythemeet(^) operationtotheextantstatesofthesetofcompile\u00adtimeobjectsthereceiverexpressioncanpointto. \nIfthesetofcompile-timeobjectsofthereceiverexpression isempty,theextantstateofthereceiverexpressionissetto \n.forsafetyinoptimization.Thiscanhappenforareceiver expressionreachedbyaparameterofanon-publicmethod intheclosedworld. \nThesetofcompile-timeobjectsareferencevariablecan pointtocanbecomputedbyapplyingapointeranalysis algorithm[16;34;24;9;32;30].Acompile-timenaming \nschemesimilartothoseusedinpointeranalysisidentifes compile-timeobjects[7;30]. Theextantstateofacompile-timeobjectisinitializedwith \nUCE(unconditionallyextant)iftheobjectisallocatedwith atypethatisintheclosedworld.Otherwise,itsextant \nstateisinitializedwith.. 5 InJavaapublicmethodcanbeinvokedfromoutsidethe closedworld.LetM(:::)beamethodthatcanbeinvoked \nfromoutsidetheclosedworld.Ifpisareferenceparameter ofM,thenpcanalsopotentiallypointtoanon-extantob\u00adject.Torefectthis,whenacompile-timeobjectispassed \nasaparametertoapublicmethod,weapplyameetwith. totheextantstateofthecompile-timeobject.IfMisnot reachablefromanymethodintheclosedworld,eachrefer-enceparameterofMisassignedacompile-typeobjectwith \nextantstateof..WecallmethodssuchasM(:::)entry boundarypointstotheclosedworld. Whenareferencevariableispassedasaparametertoa \nmethodinvocationonapotentiallynon-extantobject,the extantstateoftheobjectsindirectlyreachablefromthe \nparametercanbecomenon-extantbecausetheobjectscan bereplaced.Weapplyameetwith.totheextantstate ofobjectsindirectlyreachablefromparameterspassedto \namethodinvocationonapotentiallynon-extantobject. Reachabilityinformationisimplicitinthepointeranalysis \nsolution. Astatementwhichperformsareadofastaticreferencevari\u00adableisalsoanentryboundarypoint,assuchavariablemay \nhavebeenmodifedbyanotherthreadduringtheexecution ofthecontainingmethod.6 Therefore,whenacompile-time \nobjectbecomesreachablefromastaticreferencevariable,we alsoapplyameetwith.totheextantstateofthecompile\u00adtimeobject. \nConsidertheexampleshowninFigure2.AtS1therefer\u00adencevariableppointstoanextantobject(assumingthat Bisextant),whereasatS4,pcanpotentiallypointtoa \nnon-extantobject(assumingthatthevalueofcNameisnot 5 ItsextantstateisinitializedwithUCNEinthefourelement \nextant-statelattice. 6Wecannoteliminatestaticvariablesfromconsiderationby usingtechniquessimilarto\\lambda-lifting\"forfreevari\u00adables,duetomultiplethreads. \n knownduringof-linephase).ThereforeatS6,thereceiver expressionpcaninvokeamethodBbar(...)thatmaynot beintheclosedworld. \nProperty3.1.Ifareceiverexpressionpatacallsite p:foo()isunconditionallyextant,thenduringexecutionall possibletargetmethodsofthecallarewithintheclosedworld. \nAnimportantimplicationoftheabovepropertyisthatwe neverneedaruntimetypecheckwithrespecttoanoptimiza\u00adtionofsuchunconditionallyextantcallsites.Forinstance, \nwecandirectlydevirtualizeandinlinesuchcallsiteswith\u00adoutanyruntimetypechecksif,duringofineanalysis,we \ncandeterminethatthereisonlyonetargetforsuchvirtual calls. Ifareceiverexpressionisconditionallyextant,thenthecall \nsitecanpotentiallyinvokemethodsoutsidetheclosedworld. Wecallsuchcallsitesexitboundarypointsoftheclosed \nworld.Theinvocationofp.Bbar(...)atS6inFigure2 isanexampleofanexitboundarypoint.Weneedtospe\u00adcializecoderegionscontainingoptimizationsdependingon \nsuchcallsites,wheretheinvocationofthespecializedcode isguardedbyaruntimetypecheck. Inthenexttwosectionswewilluseextantanalysisinfor\u00admation(1)tocomputecoderegionsthatarecandidatesfor \nspecialization;and(2)tocomputetheextantsafetytestfor determiningwhethertocallthespecializedorunspecialized \ncodeduringexecution.  4. CODE SPECIALIZATION Inthissection,usingextantanalysis,wewillfrstshowhow toidentifymethodsorpartsofmethodsascandidatesfor \nspecialization(Section4.1).Wethenshowhowtousecon\u00adceptsfromparametricdatafowanalysistogeneratespe\u00adcializedcode.(Section4.2). \n 4.1 Identifying Specialization Inourframeworkamethodorapartofamethodisalways specializedwithrespecttoanexitboundarypointinthe \nclosedworld.Intheprevioussectionweusedextantanaly\u00adsistodeterminetheextantstateofareceiverexpression.If \ntheextantstateofthereceiverexpressionpatavirtualcall sitep:foo()isUCE,thenwecanperformunconditionalop\u00adtimizationwithrespecttosuchcallsites.Butiftheextant \nstateofpis.wecandooneofthefollowing(depending onthe\\degreeofextantness\"):(1)donotperformanyop\u00adtimizationwithrespecttosuchexitboundarypoints;or(2) \nperformoptimizationswithrespecttosuchexitboundary pointsbutguardtheoptimizedcodeusingadynamictest. Intheremainderofthissectionwedescribehowtoiden\u00adtifycoderegionsthatarecandidatesforoptimization.We \noptimizecodewithrespecttoanexitboundarypointsonly ifitisbenefcialtodoso.Thereforeintheremainderof thissectionweassumethatthereceiverexpressionisnot \nunconditionallynon-extant. Tomotivatetheproblem,considerthesimpleexampleshown inFigure3.Assumethatallclassesshowninthefgurebe\u00adlongtotheclosedworld.Thecompile-timeobjectcreated \natS10andpassedtomethodA::Abar( )asthefrstpa-rameter,i.e.c1,hasitsinitialextantstateasUCE.Since A::Abar( \n)isapublicmethod,theextantstateofthe compile-timeobjectisappliedtoameetwith.,resulting intheextantstateofCE.c1ispassedtoparametercof \nA::Afoo(Cc)atS1.Theextantstateofreceiverexpres\u00adsioncatS5doesnotchangeinA::Afoo(Cc),andweap\u00adplyspecializationtoA::Afoo(Cc)tocreateaspecialized \nA::Afoo'(Cc)inwhichwedirectlydevirtualizeandinline c.Bbar(b)atS5(withoutanyruntimeguardscontrolling theinlinedmethod).A::Afoo(Cc)isspecializedherewith \nrespecttotheexitboundarypointdefnedatS5.Duringex\u00adecutionweperformanExtantSafetyTest(EST)atS1tode\u00adterminewhethertocallthespecializedversionA::Afoo'(C \nc)ortocalltheunspecializedversionA::Afoo(Cc).Once A::Afoo'(Cc)isinvoked,itcansafelyexecuteforthatin\u00advocationevenifanewclassisloadedthatcanoverridethe \nmethodB::Bbar(Bb). NowconsiderthemethodA::Agoo(Cc,Strings).We cannotspecializethewholemethodA::Agoo(...)wherein \nwecandirectlyinlinec.Bbar(b).InbothA::Afoo(Cc)and inA::Agoo(...),thereceiverexpressioncforinvocations \nofc.Bbar(b)atS5andS9,respectively,canpointtoanon-extantobject.ButinthecaseofA::Afoo(Cc)anewclass canbeloadedonlypriortotheexecutionofS1,whereas \ninthecaseofA::Agoo(...)anewclasscanbeloadedat S7,andthereceiverexpressionatS9canpointtothenewly loadedclass.WecanspecializepartofA::Agoo(...)by \nplacinganextanttestjustpriortoS9tocheckwhetherthe receiverexpressioncanpointtoanon-extantobjectgener\u00adatedatS8.Inthenextsectionwewillshowhowtogenerate \nandplaceextanttests. Nextweestablishtwokeypropertiestodeterminewhich methods(orpartsofmethods)arecandidatesforsafespe\u00adcialization.Intuitively,givenanexitboundarypointsX,we \ncanplaceanESTjustpriortoX.Butwewanttomovethis testasearlyaspossibletocreateopportunitiesforotherop\u00adtimizations.Thenextpropertyessentiallystateshowfarup \ncanthetestbemovedfromanexitboundarypoints. Property4.1.Letmbeaprogrampoint,letXbean exitboundarypoint,andletP(m,X)bethesetofallpro-grampathsfrommtoXintheprogram.Thestatementsin \nP(m,X)canbesafelyspecializedwithrespecttoXif,during execution,(1)theredoesnotexistanon-extant(runtime) \nobjectOnethatcanreachXbeforereachingmand(2)any objectthatreachesbothmandXisextant. InProperty4.1,ifmisanentrypointtoamethodM,then \nwecanspecializethewholemethodMwithrespecttoX. TheportionsofMthatdonotlieonapathfrommtoX willnotafectthesafetyofthespecialization.Letusdissect \nProperty4.1intothreeparts:(1)programpointm,(2)the setofpathsP(m,X),and(3)theexitboundarypointX. Atcompile-timewewanttoidentifymsuchthatP(m,X) \ncanbesafelyoptimizedandspecializedwithrespecttoX. ToinvokethespecializedcodewewanttoplaceanEST ESTmatmthatensuressafeinvocationofthespecialized \ncode.ForaninvocationofapathPinP(m,X)tobesafe, wehavetoensurethatwheneverPisexecuted,thereceiver expressionrexatXpointstoanextantobject.Letpxbethe \nreceiverexpressionatX,andEST(px)beanESTperformed atXthatreturnstrueifandonlyifpxpointstoanextant object.AnyESTESTmthatweplaceataprogrampoint \nmshouldsatisfythefollowingproperty: Property4.2.AnESTatprogrampointm,denotedas ESTm,issafewithrespecttoEST(px)ifESTmimplies \nEST(px),expressedasESTmvEST(px). ClassA{ classB{ publicvoidAbar(Cc1,Strings) publicvoidBbar(Bb) {{ S1:Afoo(c1); \n... S2:Agoo(c1,s); } }} privatevoidAfoo(Cc) classCextendsB{ { ... S4:Bb=newB();//extant publicvoidEfoo() \nS5:c.Bbar(b); { } ... } privatevoidAgoo(Cc,Strings) } { ... classD{ S6:if(...){ ... S7: Classx=Class.forName(s) \npublicvoidDbar(Aa1) S8:Objectc=x.newInstance();//non-extant { } S10:Ccc=newC(); S9:c.Bbar(b); S11:a1.Abar(cc,\"...\"); \n... } }} } Figure3:Aclosed-worldprogram. Inotherwords,wheneverESTmistrue,EST(px)shouldbe true.ButifESTmisfalse,EST(px)canbeeithertrueor \nfalse.WecallESTmasurrogateofEST(px).WesayESTm isstrongerthanESTn(orESTnisweakerthanESTm)if ESTnvESTm,whereESTmandESTnaretwosurrogates \n(possiblyatthesameprogrampoint)ofEST(px). ConsidertheexampleprograminFigure3.Thesetofob\u00adjectspointedtobythereceiverexpressioncatS5isthe \nsameasthesetofobjectspointedtobycattheentryof A::Afoo().ButthisisnottrueinthecaseofA::Agoo(). ThereforeA::Agoo()cannotbefullyspecialized.Butifwe \nplaceanESTimmediatelypriortoS9,thepartofthepro\u00adgramfromtheESTpointtotheexitboundarypointcan bespecialized.InSection5,weshowhowtocomputethe \nEST.  4.2 Specialization Using Parametric Data Flow Analysis Intheprevioussectionweillustratedhowtospecializemeth\u00adodsforadevirtualizationoptimization.Theoptimization \nwasbasedonaclosed-worldanalysisperformedwithrespect toanexitboundarypoint.Aclosed-worldanalysiswhich \nisparameterizedwithrespecttoexitboundarypointsisan exampleofaparametricdatafowanalysis[29;8].Forde\u00advirtualization,thecandidatemethod(orpartialmethod)for \nspecializationcontainstheexitboundarypoint.Thereare optimizations,suchasstackallocationbasedonescapeanal\u00adysis[11],wherethemethodtobespecializeddoesnotcon\u00adtaintheexitpointonwhichitdepends.Forsuchproblems \naninterproceduralparametricdatafowanalysisisneeded togeneratethespecializedmethods. Parametricdatafowanalysisisbasedonaugmentingdata \nfowanalysiswiththecomputationofconditionsonwhich thevalidityoftheanalysisdepends.Lethc,fidenoteadata \nfowfactfwhosetruthvaluedependsontheconditionc. SupposeTisatransformationthatusesthisfact.Thenthe transformationTiscorrectiftheconditioncholdsduring \nprogramexecution.Oncetheconditioncbecomesfalse,the transformationTisunsafe. Considerescapeanalysisforcompile-timegarbagecollec\u00adtion.Letp=newR()beanallocationsiteinamethod \nMthatwewishtotransformtop=newstackT().This transformationTissafeonlyifwecanprovethattheob\u00adjectsallocatedatthissitecannotescapeM.LetObethe \ncompile-timeobjectnameforthissite.Usingparametric escapeanalysiswecancomputeparameterizedescapeinfor\u00admationh:,Oi,where:isthesetofexitboundarypoints \nthatcouldpotentiallyafecttheescapementofO.Assume OdoesnotescapeMundertheconditionthatnoneofexit boundarypointsin:willtargetamethodoutsidetheclosed \nworld.NowwecanspecializeTwithrespecttoallexit boundarypointsin:,andplaceanESTguardingthespe\u00adcializedtransformation.WespecializeTonlyifwecanfnd \naplacementforanESTthatwillsatisfyProperty4.2.  5. EXTANT SAFETY TEST ExtantSafetyTests(ESTs)arecondition-checksthatguard \nthesafeexecutionofaspecializedmethod(orportionsof amethod).Thesetestsdependonruntimeinformation. ThereareseveralwaystoperformtheEST.Anytestthat \nweperform,however,mustsatisfyProperty4.2.Consider Figure3.WecanplacethefollowingESTatS4: S4:if(EST(c1))Afoo'(c1)/*specialized*/ \nelse Afoo(c1)/*unspecialized*/ EST(c1)returnstrueifc1pointstoanextantobject,oth\u00aderwiseitreturnsfalse.EST(c1)isasurrogateforEST(c)at \nS2.ESTsthatqueryobjectsforsafetycanbeimplemented byaddingabitintheclasstable,andsettingthebitto1 forextantclasses.Fornewlyloadedclasses(thatarenot \nintheclosed-world)thisbitissetto0.Duringruntimewe canquerytheclasstabletocheckiftheobjectisextantor non-extant. \nESTcanalsobeperformedoncontrolfowpredicates.Con\u00adsiderthefollowingexample: booleancond=bar(); if(cond) \n{ y=new_eT();//createanextantobject ... //assumeyisstillpoints //toextantobject } elseif(...) y=new_neS();//createanon-extantobject \nS20:y.foo(); Intheaboveexample,whenevercondistrue,ypointsto anextantobject.Therefore,condcanbeconsideredasa \nsurrogateforEST(y)atS20,andthepartofprogramcon\u00adsistingofthe\\then\"portioncanbespecializedwithrespect toy.foo()atS20. \n5.1 Using the Sparse Evaluation Graph Weusethesparseevaluationgraph(SEG)[10]fordetermin\u00adingtheextanttestsandtheirplacements.TheSEGisagen\u00aderalizationofstaticsingleassignment(SSA)[13]andcanbe \nappliedtobothforwardandbackwardmonotonedatafow problems,whileoferingthesamebeneftsasthoseofSSA appliedtoforwarddef-usebaseddatafowproblems.Un\u00adlikeSSA,whereadefnitiontriggersformationof.-nodes, \nintheSEGonlyastatementwithanon-identitytransfer functionfortheanalysistriggersformationof.-nodes.For \nextantanalysis,statementsthatafectthevalueofareceiver expressionhaveanon-identitytransferfunction.TheSEG \nhasthefollowingusefulproperties: Eachuseofavariablehasasingledefnitionpoint.  .-nodesareintroducedtomergemultipledefnitions \ncomingfromdistinctcontrolfowpaths.LetSbethe setofdefnitionpointsofavariableWeintroduce.\u00adnodesattheiterateddominancefrontierIDF(S). \n Givenavariablev,letSEGd(v)denotethedefnition pointoftheuseofv.SEGd(v)willdominatetheuse pointofv. \n Now,letXbeanexitboundarypoint,andvbethereceiver expressionatX.Theprogrampointm=SEGd(v)will satisfyProperties4.1and4.2fortheexitboundarypoint \nX.Therefore,allprogramstatementsbetweenmandX inclusivecanbesafelyspecializedwithrespecttoX. IftheSEGdefnitionpointistheentryofamethod,wecan \nplacetheESTateachcallsiteinvokingthemethodinstead ofattheentryofthemethod.PlacingtheESTinacaller canenablefurtheroptimizationsinthecallerwithrespect \ntothecalledmethod. Finally,sincetheruntimetypeofacompile-timeobjectis determinedatcompiletimeinJavabytheallocationsite,we \ncanregardcompile-timeobjectswithanidenticalruntime typeasthesamecompile-timeobject.Thiswillreducethe \nnumberofmergepointsand,thereby,allowtheplacement ofESTearlierintheprogram. 5.2 Optimization of Extant \nSafety Tests LetPP(m,X)bethesetofprogrampointswhichoccurin oneormoreofthepathsinP(m,X).Giventwosurrogates \nESTmandESTnofEST(px),ESTmispreferabletoESTn if ESTnvESTm ^PP(n,X)PP(m,X): Forexample,ifSEGd(v)(describedinSection5.1)isasim\u00adplecopyfromareferencevariable,suchas\\v=w;\",the \nextanttestappliedtoattheprogrampointn=SEGd(w) wwhosedefnitionofwreachestheuseofwatmisprefer\u00adabletothatappliedtovatm.Thisprocessofidentifying \napreferableextanttestcanberepeateduntilthedefnition isamergenode(i.e.,a.node)orthedefnitionisanas\u00adsignmentofade-referencesuchas\\v=p.f1;\".Another \ninstanceofafavoredESTisonethatcancovermultiple exitboundarypoints. Onecanperformseveraloptimizationstoidentifythemost \npreferableamongmultipleESTs.PartialRedundancyElim\u00adination(PRE)foreliminatingpartiallyredundantESTsis \noneexample.AnESTE1 ispartiallyredundantifthetruth valueofanearlierESTE2 impliesthetruthvalueE1 for certainprogrampaths. \nUsingproflinginformationorstaticanalysis,wecanalso hoistESTstoinfrequentlyexecutedprogrampoints.For example,astaticanalysisappliedtotheexamplecodeseg\u00admentbelowmightidentifythatalltheobjectspointedtoby \npatS100areextantiftheobjectpointedtobyheadatS1 isextant.Inthatcase,wecanplaceanextanttestforthe objectpointedtobyheadatS1thatcoversalltheobjects \npointedtobypatS100intheloopbody. .. . S1: for (Tp=head;p!=null;p=p.next) { .. . S100:p.m(...); .. . } \nThereexistsatradeofbetweenthestrength(i.e.precision) ofanextanttestandthesizeofthesetofprogrampoints \nthatcanbespecialized.AlthoughESTnvESTm,ESTn mightbefavoredoverESTmifPP(m,X)PP(n,X){the increasedsizeofthespecializedcode,atthecostofthelarger \nfailurerateofESTn,mightstillimprovetheoverallperfor\u00admanceoftheoptimizedcode.Proflingandstaticanalysis \ncanhelpdeterminewhether(andwhere)theprecisionofan extanttestcanbesacrifcedfortheincreasedsizeofthe specializedcode. \n  6. IMPLEMENTATION AND EMPIRICAL RESULTS Table1showsthebenchmarkprogramsusedinourexper\u00adiments.ExceptforportBoballbenchmarksarefromthe \nSPECjvm98suite.Weperformedtwokindsofexperiments: (1)measuringclosed-worldcharacteristics;and(2)measur\u00adingextantanalysischaracteristics.WeusedtheJalape~no \nVirtualMachineasourexperimentalplatform.TheJalape~no VirtualMachineisanimplementationofJavawrittenin \n(mostly)pureJava[1]. Program Description aCWClass CWMeth aCWMeth compress Compression/Decompression \n25 313 112 jess NASA'sCLIPSexpertsystem 112 640 400 db Databasesearchandmodify 16 328 104 javac Sourcetobytecodecompiler \n71 659 399 mpegaudio Decompressaudiofle 55 479 270 mtrt Multithreadedimagerendering 38 460 235 jack Parsergeneratorgeneratingitself \n59 563 59 portBob PortableBusinessObjectBenchmark 46 751 398 Table1:DescriptionsoftheBenchmarksUsedinOurExperiments. \nProgram Calls CWCW aCWCW %CWCW %aCWCW VC vCWCW %vCWCW compress 18162511 18162219 18156434 99.99 99.99 \n15752583 15752361 99.99 jess 5987201 5781028 5292904 96.55 88.40 5690075 5502619 96.71 db 2191950 2191541 \n81112 99.98 3.70 1552273 1551941 99.97 javac 3075125 2782215 1313793 90.47 42.72 2488027 2259527 90.81 \nmpegaudio 9434285 9417509 9245643 99.82 98.00 6227385 6227169 99.99 mtrt 23098433 22698823 20882723 98.26 \n90.41 21149934 20929658 98.95 jack 6177988 6177408 867514 99.99 14.04 4281738 4281478 99.99 portBob 3201292 \n3174413 1485197 99.16 46.39 1762623 1752009 99.39 Table2:Closed-WorldCharacteristics. 6.1 Closed-World \nCharacteristics Weusedaprofle-basedapproachtoconstructtheclosed world.WefrstinstrumentedtheJalape~noVirtualMa\u00adchinetocollectmethodprofleinformation(i.e.,thenum\u00adberoftimesamethodisexecuted)andconstructtheset \nofmethodsandclassesincludedintheclosedworld.For theSPECjvm98suite,weusedthedatasizeof1duringthe proflingandtheclosed-worldconstructionphase.Forport-Bobweusedadatasizeneededforconstructingaminimum \npopulation(pleasesee[4]fordetailsaboutportBob).We includedmethodsthatwereexecutedatleastonceinthe closedworld.Theclosedworldcontainsboththeapplica\u00adtionmethodsandtheJavalibrarymethods,butdoesnot \nincludemethodsfromtheJalape~noVirtualMachine.The closedworldforeachofSPECjvm98programsalsoincludes themethodsoftheSPECjvm98driverwhichexecutedat \nleastonce. InTable1theaCWClasscolumnindicatesthenumberof classesintheapplicationthatcontainatleastonemethod \nintheclosedworld.TheaCWMethcolumnindicatesthe numberofmethodsintheapplicationthatwereincludedin theclosedworld.TheCWMethcolumnindicatesthenum\u00adberofmethodsintheclosedworld,includingJavalibrary \nmethodsused(butnotmethodsofJalape~no). Toanalyzethedynamiccharacteristicsoftheclosedworld, weagaininstrumentedtheJalape~noVirtualMachine.For \nthisweusedthedatasizeof10forSPECjvm98,andthe populationsizeof10%forportBob.Table2showsthedy\u00adnamicresultsthatwecollected.ThecolumnCallsshowsthe \ntotalnumberofmethodcalls.TheCWCWcolumnshows thenumberofcallsinwhichboththecalleeandthecaller wereintheclosedworld.TheaCWCWcolumnshowsthe \nnumberofcallsinwhichboththecallerandthecalleeare withintheapplication. FortheSPECjvm98suiteonaverage,for97.87%ofthe \nmethodcalls,thecallerandthecalleearewithintheclosed world(column%CWCW).ForportBobthispercentageis 99.16%.Thissuggeststhatonecanperformoptimisticin\u00ad \nterproceduraloptimizationsassumingtheclosedworldisthe wholeprogram,andinlargeparttheoutsideworlddoesnot \npollutetheclosedworld.The%aCWCWcolumninTable2 showsthepercentageofcallsthatarewithintheapplica\u00adtion.Thepercentageherevariesfrom3.7%to99.99%.The \nbenchmarksdbandjackmakeasignifcantnumberofcalls toJavalibrarymethods.Forsuchprograms,includingJava librariesintheclosedworldgivesbetterresults. \nThelastthreecolumns(VC,vCWCW,and%vCWCW)are numbersrelatedtovirtualcalls.ForbothSPECjvm98and portBobalargepercentageofvirtualcallsarewithinthe \nclosedworld.  6.2 Extant Analysis WeimplementedextantanalysisonthetopoftheJalape~no OptimizingCompiler[1].Tables3,4,and5showtheresults \nofourexperiment.Weusedtheclosed-worldprogramcon\u00adstructedduringproflingforouranalysis.Weusedmethod profleinformationtoobtaindynamiccounts.Inalltheta\u00adblestheprefx\\Dy\"indicatesaweighteddynamiccountof \nthestaticinformation. Weimplementedtheextantanalysisalgorithmdescribedin Section3,assumingaroot-connectedclosedworld.Wealso \nmakecertainreasonableoptimisticassumptionswithrespect toentryboundarypoints:(1)thatpublicmethodsarenot \ncalledfromoutsidetheclosedworld;and(2)theextantstate ofcompile-timeobjectsremainsunchangedwhentheybe\u00adcomereachablefromstaticreferencevariables;and(3)when \nareferencevariableispassedasaparametertoamethod, theextantstateofthecompile-timeobjectsreachablefrom \ntheparameterremainsunchanged.Inthelastcase,however, weapplyameetwith.totheextantstateofacompile-time \nobjectreturnedbythemethod.Theclosed-worldcharacter\u00adisticsdescribedintheprevioussection,whichshowahigh \npercentageofmethodcallstobeintheclosedworld,support theseoptimisticassumptionswithrespecttoentryboundary \npoints. Step1,asstatedinSection3,isusedtocomputetheextant Program VC UNEVC %UNEVC compress 700 87 12.4 \njess 1671 143 8.56 db 822 95 11.5 javac 2986 374 12.52 mpegaudio 988 86 8.70 mtrt 1645 92 5.59 jack 1735 \n105 6.05 portBob 2221 145 6.53 Table3:Non-extantvirtualcallcharacteristicsbasedonclasshierarchyanalysis. \nstateofthereceiverexpressionforeachinvocationsite.We implementedasimpleclasshierarchyanalysistoconstruct \nthecallgraph.Duringthecallgraphconstruction,foravir\u00adtualcallsitep:foo(),itischeckedwhetherthemethodfoo() \nisdefnedwithintheclosedworldinaclassthatiseitherthe declaredtypePofp,orisanancestororadescendentclass \nofP.Ifthereisnosuchmethodfoo(),thenthereceiver expresspismarkedasUCNE(unconditionallynon-extant). Otherwise,theextanttypeofpremainsUNKNOWN(.). \nThecolumnUNEVCinTable3showsthenumberofuncon\u00additionallynon-extantvirtualcallsdiscoveredbythisanaly\u00adsis.Onaverageabout8.98%ofvirtualcallsareidentifedto \nbeunconditionallynon-extant. Wemeasuredthenumberofvirtualcallsthatarecandi\u00addatesfordevirtualizationbasedontheirhavingonetarget \nmethodintheclosedworld.Letp:foo()beavirtualcall, andletDbethedeclaredclassofp.Ifthereisexactlyone implementationoffoo()inDorsomeancestorordescen\u00addentclassofD,thenp:foo()isacandidatefordevirtual\u00adization.Asaspecialcase,iffoo()isimplementedinclass \nDandisdeclaredasfinal,thenthereceiverexpressionis unconditionallyextantandthecallp:foo()canbedirectly \ndevirtualized.Table4illustratesthesemeasurements.Col\u00adumnUnVCrepresentsallvirtualcallswhoseextanttypeis \nUNKNOWN(.)aftertheanalysisofStep1describedabove. (UnVCissameasVC-UNEVCshowninTable3).The columnDeVindicatesthosecallsinUnVCthatarecandi-datesfordevirtualization.ColumnDyDeVrepresentsthe \ncorrespondingdynamicnumbers.ColumnDeVFrepresents allcallsinDeVthatareunconditionallyextantbasedon theirbeingdeclaredasfinal. \nOnaverage91.20%oftheUNKNOWNvirtualcallsarecan\u00addidatesfordevirtualizationandthecorrespondingdynamic percentageis79.97%.Ofthecallsthatarecandidatesfor \ndevirtualization,onaverage,58.94%areunconditionallyex-tant(thecorrespondingdynamicaverageis61.40%).Thus \nonaverage53.75%oftheUNKNOWNvirtualcallsareun\u00adconditionallyextantduetobeingdeclaredasfinal(the correspondingdynamicnumberis49.10%).Theseuncondi\u00adtionallyextantcallscanbedirectlydevirtualized.Forthe \nremainingUNKNOWNvirtualcalls(i.e.,46.25%staticper\u00adcentageand50.89%dynamicpercentage),furtheranalysis, \ndescribedinthenextsection,isneededtodeterminetheir extanttype.  6.3 Extant Analysis Using Pointer Analysis \n Wealsoimplementedasimplefow-insensitive/context-insensitive pointeranalysistocomputetheextanttypeforallUN\u00adKNOWNreceiverexpressions,asdescribedinStep2ofSec\u00adtion3.Forpointeranalysisweidentifedfourkindsofrele\u00ad \nvantstatements. .p=neweT(),anallocationsitewhereextantobjects arecreated; .p=newneT(),anallocationsitewherenon-extant \nobjectsarecreated; .p=q,referencecopystatement.Wesimplifedp:f=q andp=q:fasp=q.Thiswaywedonotdistinguish \namongobjectsaccessedviaobjectfelds.Wealsodo notdistinguishamongarraycomponents. .Callstatements.AsstatedinSection6.2,wemakean \noptimisticassumptionthattheextantstateofcompile\u00adtimeobjectsreachablefromareferencevariablepassed asaparameterremainsunchangedinthecallee. \n 6.4 Summary Figure4summarizeshowvirtualcallsinSPECjvm98and portBobareclassifed.UNEVCinthefgureissameasthe \nUNEVCshowninTable3.Hereweanalyzethepiechartfor portBob.Wecanslicethe2221virtualcallsinportBob intosixcategories.AsshowninTable3,6.5%ofvirtualcalls \nareunconditionallynon-extant.ThelabelNDeVrepresents thenumberofvirtualcallsthathavemorethanonetarget \nmethodwithintheclosedworld.Only2.3%ofthevirtual callshavemorethanonetarget.Theremaining91.2%of thevirtualcallsarecandidatesfordevirtualization.DeVF \nindicatesthenumberofthesecallsthatareunconditionally extantbasedontheirbeingdeclaredasfinal.Thereare \n34.1%ofsuchcalls,whichcanbedirectlydevirtualized.The remaining57.1%ofvirtualcallsaresubjecttopointeranal\u00adysisforfurtherclassifcation.Pointeranalysisdetermines \nthatanadditional29.9%ofallvirtualcallsareuncondition\u00adallyextant(andsocanbedirectlydevirtualized),0.1%are \nconditionallyextant(devirtualizationrequiresanEST),and anadditional27.1%areunconditionallynon-extant. \nTable5showstheextantcharacteristicsfordevirtualization basedonthissimplepointeranalysis.ColumnDeVNFindi\u00adcatesthosevirtualcallsthatarecandidatesfordevirtualiza\u00adtionandarenotunconditionallyextant(asdeterminedby \ntheanalysisoftheprevioussection).Forthesevirtualcalls, pointeranalysisisusedtodeterminewhetherthereceiver \nexpressionofsuchcallspointstoextantand/ornon-extant objects.ThecolumnsUEDev,CEDeV,andUNEDeV,show whichofthesevirtualcallsareunconditionallyextant,con\u00additionallyextant,andunconditionallynon-extant,respec\u00adtively. \n Program UnVC DeV %DeV DyVC DyDeV %DyDeV DeVF %DeVF DyDeVF %DyDeVF compress 613 566 92.33 15683774 15677145 \n99.96 389 68.73 15676404 99.99 jess 1528 1451 94.96 367189 291140 79.29 840 57.89 212151 72.87 db 727 \n662 91.06 58457 34020 58.19 417 62.99 26463 77.79 javac 2612 2362 90.43 193642 106550 55.02 1622 68.67 \n60921 57.17 mpegaudio 902 841 93.24 815313 635285 77.92 613 72.89 600129 94.47 mtrt 1553 1499 96.52 4705232 \n4345162 92.35 481 32.09 233123 5.36 jack 1630 1198 73.50 2154117 1755851 81.51 849 70.87 1139311 64.89 \nportBob 2076 2026 97.59 786832 751933 95.56 758 37.41 140235 18.65 Table4:Devirtualizationcharacteristics. \nProgram DeVNF UEDeV CEDeV UNEDeV Raw % Raw % Raw % compress StDy 177 43 24.29 6 3.39 128 72.32 741 96 \n12.95 120 16.19 525 70.85 jess StDy 611 268 43.86 88 14.40 255 41.73 78989 34327 43.46 17223 21.80 27439 \n34.74 db StDy 245 84 34.28 8 3.26 153 62.45 7557 193 2.55 129 1.70 7235 95.70 javac StDy 740 372 50.27 \n187 25.27 181 24.45 45629 37264 81.66 3897 8.54 4468 9.79 mpegaudio StDy 228 43 18.86 6 2.63 179 78.51 \n35156 175 0.50 121 0.34 34860 99.16 mtrt StDy 1018 812 79.76 6 0.59 200 19.65 4112039 3974777 96.66 122 \n0.003 137140 3.33 jack StDy 349 226 64.75 36 10.31 87 24.93 616540 239825 38.89 274135 44.46 102580 16.64 \nportBob StDy 1268 663 52.29 3 0.24 602 47.48 746300 173721 23.28 39405 5.28 533174 71.44 Table5:Devirtualization \n 7. DISCUSSION AND RELATED WORK IntheJavacommunity,therearetwocamps:the\\vir\u00adtualmachine\"campthatemphasizesthedynamicnature \nofJavasuchasdynamicclassloading,andthe\\staticcom\u00adpiler\"campthatwouldliketoapplywholeprogramanaly\u00adsisandoptimizationforperformance.7 \nSupportingdynamic classloadingforfullJavacompliancewhileapplyingstatic wholeprogramanalysis/optimizationforperformancehas \nbeenviewedasanoxymoron,andadoptingonehasmeantin largepartabandoningtheother.Theextantanalysisinthe presentworkprovidesameanstoaccommodatethisseem\u00adinglycontradictorygoaloffullJavacmplianceandstatic \nwholeprogramanalysis/optimization.Themorecloselythe CWmatchestheruntmecharacteristicsoftheapplication \nforanexecution,thebettertheperformanceoftheexecu\u00adtion.Theextanttestsstillensureacorrectexecution,albeit \nwithapoorerperformance,ifCWpoorlymatchestherun\u00adtimecharacteristicsoftheexecution. Wehaveusedspecializationofpartsoftheprogramasthe \nprincipalmechanismfortheoptimizationsbasedonextant analysis.Specializationisatechniqueforinstantiatinga \nprogramwithrespecttosomeruntimeinvariants[14;12]. Weapplyextantanalysistodeterminetheruntimeinvari\u00adantsthatweuseinspecializingmethodsandpartialmeth\u00adods.Onedisadvantageofspecializationisthatitcanin\u00adcreasecodesizeandsoshouldbeappliedonlyto\\hotmeth\u00adods\"[12]. \n7ThisobservationismadebyoneofthePLDIreviewers. ExtantCharacteristics. Anystaticanalysisandoptimization,however,canbeper\u00adformedtotheprogrampartsthatextantanalysisfndsun\u00adconditionallyextant.Staticanalysisandoptimizationcan \nalsobeappliedtoprogrampartsfoundtobeconditionally extant,byguardingtheexecutionoftheoptimizedcode withdynamicextanttests.Atradeofexistsbetweenthe \noverheadduetodynamicextanttestsandtheimprovedper\u00adformancebytheoptimization,whichstaticanalysisand/or \nruntimeproflingcanhelpanalyze. Extanttestsoferbetteroptimizationopportunitiesthan testsbasedontheruntimetypeofanobjectthattypically \nguardagainstincorrectspecializationforareceiverexpres\u00adsion[20].Incontrasttosuchruntimetests,asingleex\u00adtanttestcancovermultiplestatements,andtherebyofers \ntheopportunityforoptimizationsacrossthemultiplestate\u00adments.Further,themultiplestatementscoveredbyasingle \nextanttestcancrossmethodsorclassboundaries,inwhich caseinterproceduraloptimizationssuchasinliningcanbe \nperformedacrossmultiplelevelsofmethodinvocations. DetlefsandAgesen[15]introducetheconceptofpreexistence \ninthecontextofadynamiccompilersothatinliningonly takesplaceforthosecallsitesforwhichitcanbeproved thattheobjectpointedtobythereceiverexpressionhas \nbeenallocated.Theirpreexistenceanalysisisrelatedtoour intraproceduralextantanalysis.OnelimitationofDetlefs \nandAgesen'sschemeisthattheinliningtransformationin amethodmmayhavetobeinvalidatedandthemethod mmayhavetoberecompiledforsomefutureinvocation \nofm.Theirschemecouldemployasimpledynamicextant SPECjvm98 11.2% 9.3% 3.3% 9.4%  UNEVC NDeV 17.5% DeVF \nUEDeV CEDeV UNEDeV 49.4% portBob 6.5% 2.3% UNEVC NDeV DeVF UEDeV CEDeV 34.1% 0.1% UNEDeV 29.9% Figure4:VirtualcallcharacteristicforSPECjvm98andportBob \ntest,basedonthetargetoftheobject,toguardagainst incorrectexecutionofinlinedcode.Ourframeworkismore generalthanpreexistenceandruntimetypecheckinginthat \nitcanbeappliedtooptimizationsotherthaninlining,such asescapeanalysis. Ourformulationofparametricdatafowanalysisisrelated \ntootherwork.BurkeandTorczonformulatearecompi\u00adlationtestthatcomparescurrentinterproceduralinforma\u00adtionwithannotationsetsthatrecordthoseinterprocedural \nfactswhichmustcontinuetoholdforapreviouscompila\u00adtiontoremainvalid[5].Theirmostprecisecomputationof annotationsetsinvolvesaugmentingdatafowanalysisto \ncomputeauxiliaryinformationwhichisassociatedwiththe elementsofadatafowsolution.Chatterjeeetal.parame\u00adterizepoints-toanalysisforcompilinglargeprogramswith \nmultiplemodules[8].Theyobtainsummaryfunctionsfor points-toanalysisofmethodsbyinferenceoftherelevant conditionsontheunknowninitialvaluesforparametersand \nglobalsatmethodentry.Rountevetal.proposeaframe\u00adworkforanalyzingprogramfragmentsthatisanextension ofChatterjeeetal.'swork[29]. \nStaticJavacompilerswhichperforminterproceduralanaly-sisandoptimization,suchasHPCJ[22]andMarmot[17], donotallowdynamicclassloadingduringprogramexecu\u00adtion.JAX(JikesApplicationeXtractor)[33]isabytecon\u00adverterforcompressingapplicationclassfles.Itperforms \nwholeprogramanalysis,butagainmakesa\\closed-world\" assumption.HotspotandotherJITcompilersdonotsup\u00adportaggressiveinterproceduraloptimizations[27;23] \n 8. CONCLUSIONS Inthispaperwesolveanimportantproblemforefcientex\u00adecutionofJava:thatofinterproceduraloptimizationinthe \npresenceofdynamicclassloading.Wedescribeaframework forinterproceduraloptimizationthatdoesnotdependupon \nruntimeinvalidationandrecompilation.Theframeworkis basedontheoptimizationofaclosed-worldprogramprior \ntoexecution.Aruntimesafetytestisusedtoenforcecor\u00adrectness.Ourexperimentalresultsholdoutthehopethat withtheframeworkdescribedhere,wecanexpectthata \nlargepercentageofaJavaprogramcanbeoptimizedasif Javadidnothavethecapabilityfordynamicclassloading. 9. \nACKNOWLEDGEMENTS FirstandforemostwewouldliketothankMarkWegman forhisconstantsupportandencouragement.Wewould \nliketothankDeepakGoyal,JohnField,HariniSrinivasan, GaneshRamalingam,VivekSarkar,RajeshBordaw,and PeterSweeneyfortheirhelpfulcommentsonvariousdrafts \nofthispaper.WewouldliketothankJalape~noteammem-bers,especiallyDerekLieber,DaveGrove,andSteveFink, fortheirhelpwiththeJalape~nosystem.Finally,wethank \ntherefereesandthecommitteemembersofPLDIfortheir insightfulcomments. 10. REFERENCES [1]B.Alpern,D.Attanasio,J.J.Barton,A.Coc\u00adchi,D.Lieber,S.Smith,andT.Ngo.Implement\u00adingJalape~noinJava.InACMConferenceonObject\u00adOrientedProgrammingSystems,Languages,andAp\u00adplications,1999. \n[2]B.Alpern,M.Charney,J.-D.Choi,T.Cocchi,and D.Lieber.Dynamiclinkingonashared-memorymulti\u00adprocessor.InInternationalConferenceonParallelAr\u00adchitecturesandCompilationTechniques,1999. \n[3]D.F.BaconandP.F.Sweeney.Faststaticanalysis ofC++virtualfunctioncalls.InACMConferenceon Object-OrientedProgrammingSystems,Languages,and \nApplications,pages324{341,Oct.1996. [4]S.Baylor,M.Devarakonda,S.Fink,E.Gluzberg, M.Kalantar,P.Muttineni,E.Barsness,R.Arora, \nR.Dimpsey,andS.Munroe.Javaserverbenchmarks. IBMSystemsJournalSpecialIssueonJavaPerfor\u00admance,39(1),2000. \n[5]M.BurkeandL.Torczon.Interproceduraloptimiza\u00adtion:Eliminatingunnecessaryrecompilation.ACM TransactionsonProgrammingLanguagesandSystems, \n15(3):367{399,July1993. [6]C.Chambers.TheDesignandImplementationofthe SelfCompiler,anOptimizingCompilerforObject\u00adOrientedProgrammingLanguages.PhDthesis,Stan\u00adfordUniversity,1992. \n[7]D.R.Chase,M.Wegman,andF.K.Zadeck.Analysis ofpointersandstructures.InSIGPLAN'90Conference onProgrammingLanguageDesignandImplementation, \npages296{310,June1990.SIGPLANNotices25(6). [8]R.Chatterjee,B.G.Ryder,andW.A.Landi.Rele\u00advantcontextinference.In26thAnnualACMSIGACT-SIGPLANSymposiumonthePrinciplesofProgram\u00admingLanguages,Jan.1999. \n [9]J.-D.Choi,M.Burke,andP.Carini.Efcient fow-sensitiveinterproceduralcomputationofpointer\u00adinducedaliasesandsideefects.In20thAnnualACM \nSIGACT-SIGPLANSymposiumonthePrinciplesof ProgrammingLanguages,pages232{245,Jan.1993. [10]J.-D.Choi,R.Cytron,andJ.Ferrante.Automaticcon\u00adstructionofsparsedatafowevaluationgraphs.In18th \nAnnualACMSymposiumonthePrinciplesofProgram\u00admingLanguages,pages55{66,Jan.1991. [11]J.-D.Choi,M.Gupta,M.Serrano,V.C.Sreedhar,and \nS.Midkif.EscapeanalysisforJava.InACMConfer\u00adenceonObject-OrientedProgrammingSystems,Lan\u00adguages,andApplications,1999. \n[12]C.ConselandF.Noel.Ageneralapproachforrun-time specializationanditsapplicationtoC.InIn1996ACM SymposiumonPrinciplesofProgrammingLanguages, \npages145{156.ACM,January1996. [13]R.Cytron,J.Ferrante,B.K.Rosen,M.N.Wegman, andF.K.Zadeck.Anefcientmethodforcomputing \nstaticsingleassignmentformandthecontroldepen\u00addencegraph.ACMTransactionsonProgrammingLan\u00adguagesandSystems,13(4):451{490,1991. \n[14]J.Dean,C.Chambers,andD.Grove.Selectivespe\u00adcializationforobject-orientedlanguages.InSIGPLAN '95ConferenceonProgrammingLanguageDesignand \nImplementation,pages93{102,June1995.SIGPLAN Notices,30(6). [15]D.DetlefsandO.Agesen.Inliningofvirtualmethods. \nInthe13EuropeanConferenceonObject-OrientedPro\u00adgramming,pages258{278,1999. [16]M.Emami,R.Ghiya,andL.J.Hendren.Context\u00adsensitiveinterproceduralpoints-toanalysisinthepres-enceoffunctionpointers.InSIGPLAN'94Conference \nonProgrammingLanguageDesignandImplementation, pages242{256,June1994.SIGPLANNotices,29(6). [17]R.Fitzgerald,T.B.Knoblock,E.Ruf,B.Steensgaard, \nandD.Tarditi.Marmot:Anoptimizingcompilerfor Java.TechnicalReportMSR-TR-99-33,MicrosoftRe\u00adsearch,June1999. \n[18]J.Gosling,B.Joy,andG.Steele.TheJavaLanguage Specifcation.AddisonWesley,1996. [19]U.Holzle,C.Chambers,andD.Ungar.Debuggingopti\u00admizedcodewithdynamicdeoptimization.InSIGPLAN \n'92ConferenceonProgrammingLanguageDesignand Implementation,June1992.SIGPLANNotices27(6). [20]U.HolzleandD.Ungar.Optimizingdynamically\u00addispatchedcallswithrun-timetypefeedback.InSIG\u00adPLAN'94ConferenceonProgrammingLanguageDe\u00adsignandImplementation,pages326{336,June1994. \nSIGPLANNotices,29(6). [21]U.HolzleandD.Ungar.Athirdgenerationselfim\u00adplementation:Reconcilingresponsivenesswithperfor\u00admance.InACMConferenceonObject-OrientedPro\u00adgrammingSystems,Languages,andApplications,pages \n229{243,1994. [22]IBMCorporation.IBMHighPerfor\u00admanceCompilerforJava,1997.See http://www.alphaWorks.ibm.com/formula/hpc. \n[23]K.Ishizaki,M.Kawahito,T.Yasue,M.Takeuchi, T.Ogasawara,T.Suganuma,T.Onodera,H.Komatsu, andT.Nakatani.Design,implementation,andeval\u00aduationofoptimizationsinajust-in-timecompiler.In \nACM1999JavaGrandeConference,pages119{128, June1999. [24]W.LandiandB.Ryder.Asafeapproximatealgorithm forinterproceduralpointeraliasing.InSIGPLAN'92 \nConferenceonProgrammingLanguageDesignandIm\u00adplementation,pages235{248,June1992.SIGPLAN Notices27(6). [25]S.LiangandG.Bracha.Dynamicclassloadinginthe \nJavavirtualmachine.InACMConferenceonObject-OrientedProgrammingSystems,Languages,andAppli-cations.ACM,1998. \n[26]T.LindholmandF.Yellin.TheJavaVirtualMachine Specifcation.TheJavaSeries.Addison-Wesley,1996. [27]S.Meloan.Thejavahotspot[tm]performanceengine: \nAnin-depthlook,1999. [28]NaturalBridge.BulletTrainoptimizingcompiler andruntimeforJVMbytecodes,1996.See \nhttp://www.naturalbridge.com. [29]A.Rountev,B.Ryder,andW.Landi.Datafowanal\u00adysisofprogramfragments.InProceedingsofthe7th \nSymposiumontheFoundationsofSoftwareEngineer\u00ading,1999. [30]M.Sagiv,T.Reps,andR.Wilhelm.Solvingshape\u00adanalysisproblemsinlanguageswithdestructiveup\u00addating.ACMTransactionsonProgrammingLanguages \nandSystems,20(1):1{50,Jan.1998. [31]V.Saraswat.Javaisnottype-safe,1997. InformationavailableinWebpageat \nhttp://www.research.att.com/~ vj/bug.html. [32]B.Steensgaard.Points-toanalysisinalmostlineartime. In23rdAnnualACMSIGACT-SIGPLANSymposium \nonthePrinciplesofProgrammingLanguages,pages32{ 41,Jan.1996. [33]F.Tip,C.Lafra,P.F.Sweeney,andD.Streeter.Prac\u00adticalexperiencewithanapplicationextractorforJava. \nInACMConferenceonObject-OrientedProgramming Systems,Languages,andApplications,Nov.1999. [34]R.P.WilsonandM.S.Lam.Efcientcontext-sensitive \npointeranalysisforCprograms.InSIGPLAN'95Con\u00adferenceonProgrammingLanguageDesignandImple-mentation,pages1{12,June1995.SIGPLANNotices, \n30(6).  \n\t\t\t", "proc_id": "349299", "abstract": "<p>Dynamic class loading during program execution in the Java Programming Language is an impediment for generating code that is as efficient as code generated using static whole-program analysis and optimization. Whole-program analysis and optimization is possible for languages, such as C++, that do not allow new classes and/or methods to be  loaded during program execution. One solution for performing whole-program analysis andavoiding incorrect execution after a new class is loaded is to invalidate and recompile affected methods. Runtime invalidation and recompilation mechanisms can be expensive in both space and time, and, therefore, generally restrict optimization.</p><p>To address these drawbacks, we propose a new framework, called the <italic>extant analysis  framework</italic>, for interprocedural optimization  of programs that support dynamic class (or method)loading. Given a set of classes comprising the <italic> closed world</italic>, we perform an offline static analysis which partitions references into two categories:(1) <italic>unconditionally extant</italic> references which point only to objects whose runtime type is guaranteed to be in the closed world; and (2) <italic>conditionally extant</italic> references which point to objects whose runtime type is not guaranteed to be in the closed world. Optimizations solely dependent on the first categorycan be statically performed, and are guaranteed to be correct even with any future class/method loading. Optimizations dependent on the second category are guarded by  dynamic tests, called  <italic> extant safety tests</italic>, for correct execution behavior.We describe the properties for extant safety tests, and provide algorithms for their generation and placement.</p>", "authors": [{"name": "Vugranam C. Sreedhar", "author_profile_id": "81100375252", "affiliation": "IBM T.J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY", "person_id": "P292332", "email_address": "", "orcid_id": ""}, {"name": "Michael Burke", "author_profile_id": "81406595896", "affiliation": "IBM T.J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY", "person_id": "PP39069885", "email_address": "", "orcid_id": ""}, {"name": "Jong-Deok Choi", "author_profile_id": "81423596242", "affiliation": "IBM T.J. Watson Research Center, P.O. Box 704, Yorktown Heights, NY", "person_id": "PP43124361", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/349299.349326", "year": "2000", "article_id": "349326", "conference": "PLDI", "title": "A framework for interprocedural optimization in the presence of dynamic class loading", "url": "http://dl.acm.org/citation.cfm?id=349326"}