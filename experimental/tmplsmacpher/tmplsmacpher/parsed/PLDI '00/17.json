{"article_publication_date": "05-01-2000", "fulltext": "\n EfetiveSynhronizationRemovalforJava ErikRuf MirosoftResearh Redmond,W erikruf mirosoft.om Abstrat Wepresentanewtehniqueforremovingunneessarysyn\u00adhronizationoperationsfromstatiallyompiledJavapro\u00adgrams.Ourapproahimprovesuponurrentefortsbased \nonesapeanalysis,asitaneliminatesynhronizationoper\u00adationsevenonobjetsthatesapetheiralloatingthreads. Itmakesuseofaompat,equivalene\u00adlass\u00adbasedrepre\u00adsentationthateliminatestheneedforfxedpointoperations \nduringtheanalysis. Wedesribeandevaluatetheperformaneofanim\u00adplementationintheMarmotnativeJavaompiler.For \nthebenhmarkprogramsexamined,theoptimizationre\u00admoves100%ofthedynamisynhronizationoperationsin single\u00adthreadedprograms,and0\u00ad99%inmulti\u00adthreadedpro\u00adgrams,atalowostinadditionalompilationtimeandode \ngrowth. Introdution TheJava..programminglanguage[GJS96]providessyn\u00adhronizationonstruts(synhronizedmethodsandbloks) \ntopermitsafeuseofonurrently\u00adaesseddatastrutures. Theseonstrutsareusedpervasivelyinboththestandard librariesandtheruntimesystem.Inmanyases,alarge \nnumberoftheseoperationsmaybesafelyremovedwithout ompromisingprogramsemantis,thusimprovingperfor\u00admane.Removingtheseoperationsmanuallymaybeinon\u00advenient,error\u00adproneorevenimpossible.1 \nAdynamisynhronizationoperationinthreadTonan objet0iseliminablewhenevernootherthreadT. attempts tosynhronize0duringtheexeutionoftheguardedode. \nAlgorithmsforautomati,statieliminationofsynhroniza\u00adtionoperationsproveonservativeapproximationsofthis \nondition.Existingworkfallsbroadlyintotwoategories. Oneapproah[BS96,FKR+00]provesthattheprogram spawnsnothreads,makingontentionimpossibleandall \n.MostJava-to-byteodetranslatorsimplementthestringonate\u00adnationprimitive'+'viaaalltoasynhronizedlibrarymethod.Short \nofreimplementingstrings,usersannotavoidthisbehavior. Permissiontomakedigitalorhardopiesofallorpartofthisworkfor \npersonalorlassroomuseisgrantedwithoutfeeprovidedthatopies arenotmadeordistributedforproftorommerialadvantageand \nthatopiesbearthisnotieandthefullitationonthefrstpage.To opyotherwise,torepublish,topostonserversortoredistributeto \nlists,requirespriorspeifpermissionand/orafee. PLDI2000,anouver,BritishColumbia,Canada. Copyright2000 \nCM1-58113-199-2/00/0006...$5.00. synhronizationoperationsremovable.Thisisbothfastand efetive,buthasthedisadvantagesofhavingnoefeton \nmultithreadedprogramsandbeingunsoundinthepresene ofnotifationoperations.2 Theseondapproah[ACSE99,Bla99,BH99,CGS+99, \nWR99]provesthattheobjet0annotesapeitsreating thread,andthusannotbesubjettoontention.Thisap\u00adproahfarespoorlyonprograms(evensingle\u00adthreadedones) \nwheresynhronizeddatastruturesarestoredinstativari\u00adables;themediansynhronizationremovalratioforsingle\u00adthreadedprogramsinexistingsystemsisbelow55%.The \nompile\u00adtimeostsofesapeanalysisanalsobeproblem\u00adati:ontext\u00adsensitivedependene\u00adgraph\u00adbasedimplemen\u00adtationssuhas[WR99]antakeanhourormoretoopti\u00admizeprogramsof104statements[Rin99].Someapproahes \nimproveperformaneattheostofpreision:[BH99]is ontext\u00adinsensitiveandmodelsonlyasingleleveloffeld dereferenes,while[Bla99]blursdistintionsbetweensib\u00adlingfelds.[ACSE99]supplementsesapeanalysisbyelim\u00adinatingsynhronizationoperationsthatarealwaysguarded \nbyothersynhronizationoperations.Thispromisingex\u00adtensionislimitedbyost/preisionissuesinanunderlying pointeranalysis,whihdoesnotsaleuptoprogramssuh \nasjavauporjava.Ingeneral,itisdi\u00c6ulttoassess theompile\u00adtimeostsofesape\u00adanalysis\u00adbasedimplemen\u00adtationsasonly[Bla99]dislosesanalysistimes. \nWepresentasimpleyetefetiveextensiontothees\u00adapeanalysisapproah,alongwithahighperformaneim\u00adplementationtehnique.Ouroptimizationahievesasu\u00adperiordegreeofsynhronizationremovalatalowostin \noptimizationtime.Ithandlesbothsynhronizedmethods andbloks,andpreservestheJavasynhronization,mem\u00adory,andnotifationsemantis.Thedistinguishingfeatures \nofourapproahare: .Expliitmodelingofinter-threadobjetfow. Insteadofpreservingallsynhronizationonesaping \nobjets,ouroptimizationfndsaseswhereanobjet issynhronizedonlybyasinglethread(notneessar\u00adilyitsreatingthread)duringprogramexeution,and \neliminatessynhronizationforthisase.Thisaddi\u00adtionalpreisionsignifantlyimprovestheoptimization insomeases,yetisobtainedatlittleadditionalost. \n.Removingsynhronizationguardingawait,notify,or notifyAllmayausetheoptimizedprogramtothrowa IllegalMonitorStateExeptionnotthrownintheoriginalpro\u00adgram.Suhoperationsmakelittlesenseinsingle-threadedode, \nbutmaybepresentinodefragmentsorlibrariesalsointendedfor multi-threadeduse. .Anequivalenelassbasedrepresentationwith \npolymorphisummaries.Ouroptimizationmodels aliasinginafow\u00adinsensitivemannerbygroupingpoten\u00adtiallyaliasedexpressionsintoequivalenelasses,and \nmodelssynhronizationbehaviorasattributesofthese equivalenelasses.Therepresentationisonstruted inasinglepasswithoutfxedpointoperations,anden\u00adablesontext\u00adsensitiveanalysisandspeializationvia \nasimplemappingfuntion.Itissu\u00c6ientlyompat thatlargeprograms(1O5statements)anbeoptimized withoutdepthlimitingorotherexpliitabstrationof \nnonreursivefeldaesspaths. Thispaperdesribesouroptimizationandevaluatesits utilityonbothsingle\u00adandmulti\u00adthreadedprograms,aswell \nasitsostsintermsofompilationtimeandodeexpansion. 2Overviewandmotivation 2.1Expliitthreadmodeling Inontrastwithesapebasedtehniques,whihpreserve \nsynhronizationonobjetsreahablefromglobalstate(and thusvisibletomultiplethreads),ourgoalistopreserve synhronizationonlyonobjetspotentiallysynhronizedby \nmorethanonethreadinstaneduringprogramexeution. Thisrelativelyoarseabstrationoftheproblemyields beneftsinseveralases.Itallowsfortheremovalofglobal \nsynhronizationinsingly\u00adexeutingthreads,whihanarise when\"helper\"threads(e.g.,asynhronousI/O,userinter\u00adfaeode,orwathdogtimers)areaddedtoanotherwise \nsingle\u00adthreadedprogramhavingstatiinstanesofthread\u00adsafedatastrutures.Anotherommonaseinvolveslibrary abstrationsthatsafelyshareinternaldatastrutures(e.g., \nbuferpoolsorgraphisresoures)viaastatilokobjet, butarethenusedonlybyasinglethread.Intheimportant degenerateaseofpurelysingle\u00adthreadedprograms,thisab\u00adstrationrendersallsynhronizationoperationsremovable. \nMakingthisfnerdistintionrequirestwoextensionsto esapeanalysis.First,itisneessarytotrakvaluefow throughglobalstate,ratherthanmerelymarkingglobally\u00adreahablevaluesas\"esaped.\"Inotherwords,analiasanal\u00adysis,ratherthananesapeanalysis,isrequired.Thisisa \nsimpleextension,sineesapeanalysesalreadymodelom\u00adplexvaluefow,inludingaliasing,forloalstate.Seond, theanalysismustbeabletoidentifythethreadinstanes \ninwhihpartiularesapingvaluesaresynhronized.In ourimplementation,thisisaomplishedviaastraightfor\u00adwardall\u00adlosureanalysisthatboundstheodeexeutedby \nthreadinstanes. Aprimarylimitationofthisapproahisthatitonly provespropertiesthatholdforanobjet'sentirelifetime. \nThus,itfailstoreognizeaseswhereontentionislimited topartiularprogramsopes(e.g.,fork\u00adjoinparallelism)or \nloksopes(e.g.,enlosingsynhronization). 2.2Equivalenelassbasedrepresentation Likemanyothersystems[Bla99,CGS+99,CmHOO,WR99], \nouroptimizationahievesontextsensitivitybyonstrut\u00adingreusable,polymorphimethodsummariesthatanbe independentlyappliedatmultipleallsites.Inmostexist\u00adingwork,aliasingismodeledviadireteddependenears \nenoding\"points\u00adto\"relationships,whileesapeproperties areformulatedasreahabilityqueriesovertheresultingde\u00adpendenegraphs. \nInaneforttominimizeanalysistimeandspaeusage, ouroptimizationreliesonanequivalenebasedrepresenta\u00adtion,inwhihpotentiallyaliasedvaluesareforedtoshare \nommonrepresentativenodes.Thishoieenablessingle passfow\u00adinsensitiveanalysisofanyunitofodewithout theneedforiterationtomodelfowarossbakars(e.g., \nloopsandreursion)intheprogram'sfowgraph. Theonvenieneande\u00c6ienyofthisrepresentation omeataostinpreision.Withinmethods,thediretion\u00adalityoffowislost,resultinginfalsealiasingbetweenmulti\u00adplevaluesassignedintoasinglevariableorfeld.Asimilar \nproblemariseswithreursion,wherewegiveupontextsen\u00adsitivitywithinareursiveomponenttoavoiditeratingthe analysis. \n3Algorithm 3.1Preliminaries ThealgorithmisimplementedintheMarmotnativeom\u00adpilationsystemforJava[FKR+OO].Marmotimplements \nmostJava1.1semantisandlibraries,butdoesnotsupport dynamiloadingandlimitstheuseofrefetion.Theresult\u00ading\"losed\u00adworld\"assumptionenablesanumberofwhole\u00adprogramanalyses,inludingtheonstrutionofastatiall \ngraph(usingRapidTypeAnalysis[BS96]andintraproedu\u00adraltypepropagation)usedbyouroptimization. Forpurposesofthisexposition,theMarmotintermedi\u00adaterepresentationanbeviewedasastatially\u00adtypedthree\u00adaddressformatwithloalvariablesinstatisingleassign\u00adment(SSA)form[CFRW91].Controloperationsotherthan \nreturnandthrowareirrelevantastheanalysisisfowinsen\u00adsitive.Bothsynhronizedbloksandmethodsareimple\u00admentedwithexpliitronitorEnterandronitorExitprim\u00aditives. \n3.2Phase1:Computingthreadproperties Thefrstoptimizationphaseidentifesthreadalloationsites (inludingthoseinlibraryode,plusanartifialsiteforthe \nmainthread)andomputestwoattributesforeahsite: .thesetofmethodspotentiallyexeutedbythethread beingalloated,and \n.whetherthealloationsite(andthusthethread(s)it alloates)anbeexeutedmorethanoneatruntime. Ateahthreadalloationsite,theorrespondingrun \nmethod(s)arederivedfromthethread'stypeandlasshi\u00aderarhyinformation.Inthespeialaseofasitet=new Thread(r),whererisaninstaneofRunnable,weom\u00adputer'stypeviaintraproeduraltypepropagation.Inmany \nases,risalloatedintheurrentmethod,enablingr.run tobepreiselyidentifed.Aallgraphlosureanalysisfnds allmethodsreahablefromtherunmethod(s)andandas\u00adsoiatesthemwiththealloationsite. \nAthreadalloationsiteismarkedasmultiplyexeuted ifitisinaloop,isreahablefromanon\u00adlass\u00adinitialization methodhavingmultipleormultiply\u00adexeutedallsites,or \nisreahablefromarunmethodassoiatedwithamultiply exeutedthreadalloationsite.Anannotationmehanism allowssitestobedelaredassingly\u00adexeuted;weusethisin \nlibraryodeforsitesthatalloatemultiplethreadsknown nottobesimultaneouslylive. 3.3Phase2:Buildingmethodsummaries \nTheseondoptimizationphaseomputes . foreahglobalvalue(refereneonstantorstatifeld) andits(transitive)feldsandarrayelements,theset \nofalloationsitesofthreadspotentiallysynhronizing thevalue,and .foreahmethod,thealiasandsynhronizationefets \nofthemethodandits(transitive)allees. AliassetsTheoptimizationrepresentsruntimevalues withinstanesofthealiassetdatastruture: \naliasSet::=. (feldMap,synhronized,synThreads,global). The.aseindiatesanonreferenevalue,whilethetuple \nasedesribesareferenevalue.Thetupleelementsdefne propertiesofthevalue: feldMap.Amappingfromfullyqualifedinstanefeld \nnamestoaliassetsfortheorrespondingfeldvalues; thedistinguishedfeldname$ELTdenotestheontents ofanarrayobjet. \n synhronized.Aboolean,trueifthevaluemaybethe targetofasynhronizationoperation.  synThreads.Foresapingvalues,asetofthreadallo\u00adationsitesrepresentingthethreadinstanesthatmay \nsynhronizethevalue.  global.Aboolean,trueifthevalueanbereahedfrom arefereneonstantorstatifeld(i.e.,itesapes).If \ntrue,allaliassetsreahableviafeldMapmustalsohave global=true.Thisensuresthatreferentsofanesaping objetalsoesape. \n Aliassetssupportaunifationoperationthatmergestwo aliassetsinplaeviaaunion\u00adfnddatastruture[ASU86]. Theresultingaliasset'sattributesarethejoinoftheinput \nattributesunderthefuntion,boolean,set,andbooleanlat\u00adties,respetively.Inaddition,joiningthefeldmapsauses \naliassetsorrespondingtofeldnamespresentinthedomains ofbothmapstobeunifed.Theuniferisalsoresponsible fornotiingwhenapotentiallysynhronizedvalueesapes. \nThus,unifyingaglobalaliassetwithanon\u00adglobal,synhro\u00adnizedaliassetausesthesynThreadsattributeoftheresult \ntobeaugmentedwiththesetofthreadalloationsitesas\u00adsoiatedwiththeurrentmethod.3 Anotheroperation,newinstanereation,allowstheab\u00adstrationofthealiasingandsynhronizationpropertiesof \nanaliasset.Newinstanereationreturnsanaliassetiso\u00admorphitoanexistingone,inwhihonlyglobalaliassets aresharedbetweentheoldandnewinstanes. \nAliasontextsThealiasontextdatastruturemodels thealiasingandsynhronizationbehaviorofparameter,nor\u00admalresult,andexeptionresultvaluestransmittedbetween \nallsitesandmethods.Itisatuple aliasContext::=((io,...,in),r,e) 3Inefet,theoptimizationreordsthefatthatathreadexeutes \nasynhronizationoperationonavalueVatthepointwhereVes\u00adapes,notatthepointwhereVissynhronized.Doingsoimproves \npreisionbeauseVmaynotesapeallthreadsthatsynhronizeit. whereii,r,andearealiassetsorrespondingtotheparam\u00adeter,return,andexeptionvalues.Aliasontextsareused \ntorepresenttheinformationbothformethods(inwhihase theiirepresentformalvaluesreeivedfromthealler,and randerepresentvaluesreturnedtothealler)andforall \nsites(inwhihasetheiirepresentatualvaluestransmit\u00adtedtotheallee,andranderepresentvaluesreturnedby theallee).Wealltheformeruseamethodontextandthe \nlatterasiteontext. Likealiassets,aliasontextssupportunifationandnew instanereation.Unifationisthepointwiseextensionof \naliassetunifationtotuples.Thealiasontextreturned bynewinstanereationpreserves(reursively)allrelation\u00adshipsbetweentheoriginalii,r,ande. \n3.3.1Interproeduralanalysis Theinterproeduralanalysisassoiateseahglobalvalue withanaliassetandeahmethodwithamethodontext. \nItbeginsbybindingeahstatifeldandobjetonstant (e.g.,stringliteralorstatiallyalloatedarray)toanew aliassetwithglobal=true.Italsoonstrutsinitialalias \nsetsforompiler\u00adgeneratedruntimedatastrutureswhose initializationisnotexpliitintheintermediateode(e.g., \nlassobjets,interningandrefetiontables,et). Theanalysisthenpartitionsthestatiallgraphinto stronglyonnetedomponents(Sees)andtraversesthem \ninbottom\u00aduptopologialorder.ProessinganSeeonsists ofreatinganinitialmethodontextobjetforeahmethod intheSee,thenapplyingtheintraproeduralanalysisto \neahoftheSee'smethodsindividually. 3.3.2Intraproeduralanalysis Theintraproeduralanalysisensuresthatanyaliasingor \nsynhronizationbythemethodanditsalleesisappropri\u00adatelyrepresentedinthemethod'sontextandinglobalalias sets.Itbeginsbyassoiatingeahformalparametervariable \nwiththeorrespondingformalaliassetfromthemethod ontext.Itthenwalksthemethod'sstatements,unifying aliassetsusingtherulesinFigure1.Beauseloalvari\u00adablesobeySSAinvariants,ourimplementationsavestime \nandspaebybindingloalstonewaliassetslazilyuponuse, andimplementsassignmentstounboundloalsbyupdating thebindingtableinsteadofperformingunifation. \nOnlystatementsthatmodifyreferenevariablesorval\u00aduesareproessed.Primitiveoperationsthatinduealiasing ausethealiassetsofpotentiallyaliasedexpressionstobe \nunifed.Forexample,theassignmentx.f=y(wherexand yareloalvariables)ausestheanalysistounifyy'salias setwiththealiassetreturnedbyx.feldmap(i),wherexis \nthealiassetforx.Similarly,analyzingthrowzunifesz's aliassetwiththoseofallrelevanthandlers(inludingthe \nreturned\u00adexeptionvalueeofthemethodontextifzould beunaughtbythemethod).4 ThesynhronizationoperationsronitorEnterand \nronitorExitsetthesynhronizedpropertyoftheirargu\u00admentaliasset.Inaddition,iftheargumentaliassetisglobal, \nallthreadalloationsitesreahingtheurrentmethodare addedtotheargumentaliasset'ssynThreadsproperty. Atmethodinvoations,theanalysisonstrutsasite \nontextSwhoseformal,return,andexeptionaliassets 4Weansafelyignoreimpliitexeptionsfromprimitives,asthese \narealwaysnewlyonstruted,unaliasedobjetswithoutreferene felds. Domains vEVloalvariables gEGglobalvalues(onstants,statifelds) \nfEFfeldnames a,r,EAaliassets m,sECmethod,siteontexts m,pEMmethods sESthreadreationsites tETtypes AnalysisState \nGAS:G.Aaliassetlookupforglobals AS:V.Aaliassetlookupforloals MC:M.Cmethodontextlookup CALLEES:MXV.2Mmethodtargetlookup \nSCC:M.2Mseelookup TC:M.2Sthreadreationsitelookup AnalysisRules statementation vo=vl unify(AS(vo),AS(vl)) \nvo=(t)vl v=gunify(AS(v),GAS(g)) g=v vo=vl.funify(AS(vo),AS(vl).Jeldmap(f)) vl.f=vo vo=vl[]unify(AS(vo),AS(vl).Jeldmap($...)) \nvl[]=vo v=q(vo,...,vn)Vviunify(AS(v),AS(vi)) v=...Tnoation ......vunify(AS(v),r) .....vunify(AS(v),) \n............vAS(v).synhronized=true ...........vifAS(v).global AS(v).synThreads= AS(v).synThreadsUTC(m) \n v=p(vo,...,vn)lets=((AS(vo),...,AS(vn)),AS(v),) VpiECALLEES(p,vo) letm=MC(pi) ifSCC(m) =SCC(pi) letm. \n=newlnstane(m) unify(s,m.) else unify(s,m) Figure1:Intraproeduralanalysisrulesforrelevantstate\u00admenttypes.Therulesassumethatthestatementsbe\u00adinganalyzedbelongtoamethodmwithmethodontext \n((ao,...,an),r,e),wheretheASrelationmapsformalvari\u00adablestotheorrespondingai.Thisdesriptionslightlyover\u00adsimplifesthehandlingofexeptionsandassignmentstolo\u00adals(seetext). \norrespondtotheatual,result,andrelevantexeptionalias setsattheallsite.Ittheniteratesoverthemethodsin\u00advokedbytheallsite,performingoneofthefollowingtwo \noperations: 1.Nonreursivetarget.Theanalysisomputesanewin\u00adstaneM. ofthemethodontextMandunifesitwith thesiteontextS.5Thishastheombinedefetof \n(1)refetingallee\u00adsidealiasestotheallsite,and(2) propagatingallee\u00adsidepropertiestotheallsite.Cre\u00adatinganewinstaneeahtimeamethodisapplied \npreventstheaumulationofall\u00adsite\u00adspeifinforma\u00adtioninthemethodontext,allowingontext\u00adsensitive analysis. \n2.Reursivetarget.Inthisase,theanalysisunifesthe methodontextMandsiteontextS.Whilethisintro\u00adduesontextinsensitivityatreursiveallsites,ithas \nalargeperformanebeneftinthattheanalysisdoes notneedtoiterateovertheentireSCCuntilafxed pointisreahed.6 \nAfteramethodhasbeenanalyzed,theanalysisdropsthe referenetotheloalvariablemapping,allowingallaliassets \nnotesapingthemethod'sstakframetoberelaimed.Sub\u00adsequentphasesrequiringinformationaboutloalvariables reonstituteitbyreexeutingtheintraproeduralanalysis.7 \n3.3.3Example Figure2showspartofatoyvetorlassandthreeof itslientsimmediatelypriortosynhronizationoptimiza\u00adtion.WeuseaJava\u00adlikesyntaxfortheintermediate \node,inwhihvirtualallshavebeenstatiallybound, andeahstatementexeutesasingleoperation.Inaddi\u00adtion,expliitmonitorEnter,monitorExit,andathop\u00aderationsareusedtoimplementthesynhronizedmethod \nSimpleVetor.elementAtandthesynhronizedbloken\u00adirlingtheellipsisinmethodtest3.Theresultsofthefrst analysisphaseareshownasomments:wewillassumethat \nbothT1andT2representsingle\u00adinstanethreadalloation sites. Theseondphasebeginsbyassigninganewalias setao \n=({},false,{},r e)tothestativariable SimpleVetor.v,andomputesthebottom\u00adupshedule <init>,elementAt,testO,test1,test2.Themethodon\u00adtextonstrutedfor<init>is((al),.,a3),whereal= \n({elements-a2},false,{},false)anda2anda3havede\u00adfaultattributes(({},false,{},false)).Thisontextindi\u00adatesthattheformalparametermayhaveafeldelements \ndesribedbya2,andthereisnoreturnvalue.Neitherthe formal,anyvaluereahablefromit,noranythrownexep\u00adtionanbesynhronizedby<init>. \n50urimplementationfoldstheseoperationsintoasingle,parallel traversalofMandS. 6GiventherelativeimpreisionoftheRTAbasedallgraph,SCCs \nansometimesbequitelarge(e.g.,mosttoStringmethodsendup inasingleSCC).Iterationisfurtherompliatedbythesizeofthe \naliasontextdatastrutures,andbeauseonvergeneisnotguar\u00adanteed(e.g.,the\"addtoheadoflinkedlist\"methodwillgrowits \nlistargumentoneahiteration).Weexperimentedwithanadap\u00adtive,iteration\u00adbasedshemethatoulddegenerateintothediret\u00adunifationshemedesribedabove.Inmostases,thespaebounds \nwereviolatedbeforeonvergenewasahieved,solittletonoaddi\u00adtionalpreisionwasobtained. 7Beauseallalleemethodontexts,evenforreursiveallees,are \nompleteatreonstitutiontime,thenonreursivestrategy(item1 above)isalwaysused. lassSimpleVetor{ Objet[]elements; \nstatiSimpleVetorv; /*invokedbyTi,T2*/ stativoid<init>(SimpleVetorthisi){ Objet[]temp=newObjet[i0]; thisi \nelements=temp; } /*invokedbyTi,T2*/ statiObjetelementAt(SimpleVetorthis2, intindex){ monitorEnter(this2) \ntry{ Objet[]elts=this2 elements; Objetelt=elts[index]; monitorExit(this2); returnelt; } ath(Throwablet){ \nmonitorExit(this2); throwt; } } } /*invokedbyTi*/ stativoidtesti(){ SimpleVetorvi=newSimpleVetor; SimpleVetor \n<init>(vi); Objetoi=SimpleVetor elementAt(vi,0); } /*invokedbyTi*/ stativoidtest2(){ SimpleVetorv2=newSimpleVetor; \nSimpleVetor <init>(v2); Objeto2=SimpleVetor elementAt(v2,0); SimpleVetor v=v2; } /*invokedbyT2*/ stativoidtest3(){ \nSimpleVetorv3=SimpleVetor v; Objeto3=SimpleVetor elementAt(v3,0); monitorEnter(o3); try{ monitorExit(o3); \nreturn; } ath(Throwablet){ monitorExit(o3); throwt; } } Figure2:Exampleprogramfragments ThemethodontextforelementAtis((a4,.),a,a7), \nwherea4 =({elements-a5},true,{},false),a5 = ({$ELT-a6},false,{},false),anda6anda7havedefault attributes.Inthisase,thefrstparametermaybesyn\u00ad \n6 hronized,andtheontentsofitselementsarraymaybe returned. Theintraproeduralanalysisontest1fndsthatthe \nvalueofvariablev1maybesynhronized,butdoes notesapeeitherintoeithertest1'smethodontext oraglobalaliasset.Analyzingthefrstthreestate\u00admentsoftest2yieldasimilaronfgurationofloals, \nwithv2boundtoa8=({elements-ag},true,{},false), ag=({$ELT-alO},false,{},false),ando2boundto alO,wherealOhasdefaultattributes.Theassignment \nSimpleVetor.v=v2unifesa8withaO,produing(due totheunifationofglobalandanonglobalaliassets)the aliassetaO=a8=({elements-ag},true,{T1},true) \nwhereag=({$ELT-alO},false,{},true)andalO = ({},false,{},true).Atthispoint,weknowthatvandv2 maybealiasesholdingavaluethatesapesandissynhro\u00adnizedbyathreadalloatedatsiteT1,andthatthevaluein \no2esapesbutisnotsynhronized. Theanalysisoftest3bindsv3toaO.Theapplia\u00adtionofelementAtmarksaOassynhronizedunderthe \nthreadalloatedatT2andbindsthevariableo3toalO. Thesynhronizationofo3ausesalOtobemarkedas synhronized,butonlybyT2.Attheendofphase2, \nthemethodontextsfor<init>andelementAtareas givenabove,whilethealiassetforSimpleVetor.v,v2, andv3isaO=({elements-ag},true,{T1,T2},true), \nwhereag =({$ELT-alO},false,{},true),and alO=({},true,{T2},true). 3.4Phase3:Speializationandtransformation \nThethirdoptimizationphasepropagatessynhronizationin\u00adformationfromallsitestoallees,andusesthisinformation \ntoremoveorsimplifysynhronizationoperationsinallees. Italsoonstrutsspeializedversionsofmethodswheredif\u00adferentallsitesallowdistintsimplifations. \n3.4.1Interproeduralanalysis Theinterproeduralanalysisproessesseesinatop\u00addown topologialorderwhilemaintainingper\u00adseequeuesofspe\u00adializationrequests(intheformof(method,methodContext) \npairs).Theanalysisiterativelyexeutestheintraproedu\u00adralanalysisoverallspeializationrequestsformethodsina \ngivenseeuntilallhavebeensatisfed. 3.4.2Intraproeduralanalysis Theintraproeduralanalysisbothoptimizesthemethod \nbody(removingorsimplifyingsynhronizationoperations andrediretingallstospeializedtargets)andrequests thereationofspeializedmethodbodies.Givena \n(method,methodContext)pair,theanalysisbeginsbyexe\u00adutingtheintraproeduralanalysisofsetion3.3.2,assoi\u00adatingeahloalvariablewithanaliasset.Itthenwalksthe \nmethod'sstatements,rewritingsynhronizationoperations andallsasfollows. Synhronizationoperations.Analiassetissaid \ntobeontentionfreeifitssynThreadssetisempty orontainsasinglethreadalloationsitethatexe\u00adutesatmostone.Givenastatementoftheform \nmonitorEnter(o)ormonitorExit(o),whereohas aliasset0,theanalysishekstoseeif0isontention free.Ifso,itremovesthestatementand,ifthepro\u00adgramismulti\u00adthreaded(i.e.,theanalysisfoundanon\u00adartifialthreadalloationsite),insertsamemorybar\u00adrierprimitivesothatlateroptimizationswillobeythe \nJavamemorysemantisatthispoint. .Callsites.Givenaallstatement,theanalysison\u00adstrutsasitesummarySfromtheatual,return,and \nreahableexeptionhandleraliassets.Foreahtarget methodwithmethodontextM,itonstrutsanew instaneM. ofMandthenwalksM. \nandSinpar\u00adallel;foreahaliassetm. inM. thatissynhronized, thesynThreadSetattributeoftheorrespondingalias \nsetsisaddedtothesynThreadSetattributeofm..8 TheupdatedM. isthenomparedwithbothMand themethodontextsofallexistingorpendingspeial\u00adizationsofthetargetmethod,undertheonditionthat \ntwoaliassetsmathiftheirontentionfreestatusisthe same.Ifnomathisfound,themethodislonedand arequesttospeializethelonedmethodonM. \nisen\u00adqueued.IfM. doesnotmathM,theallisrewritten toinvoketheappropriatespeializedmethod.9 Marmot'sintermediaterepresentationisonstruted \nfromtheJavabyteode,whihusesexpliitsynhroniza\u00adtionoperationstoimplementsynhronizedbloks.Beause byteodeverifationdoesnotproveanyinvariantsabout \ntheuseoftheseoperations,itisuptotheoptimizertofnd orrelatedgroupsofmonitorEnterandmonitorExitopera\u00adtionstoremove. \nEnter/exitorrespondenesthatdonotspanmethod boundariesareeasilyhandledbyouroptimization.Within amethod,allpotentiallyaliasedobjetshaveidentialsyn\u00adThreadsattributes,ensuringthatallsynhronizationopera\u00adtionsonapartiularobjetwillbepreservedoreliminated \nasawhole.Allofourbenhmarks(and,presumably,all byteodegeneratedbyreasonableJavafrontends)haveonly intra\u00admethodenter/exitorrespondenes. \nCorrespondenesthatspanmultipleproeduresaremore di\u00c6ult,asremovingorpreservingasynhronizationop\u00aderationinonemethodmayrequiretheremovalorpreser\u00advationofoneormoreorrespondingoperationsinan\u00adothermethod.Ourspeializationstrategyhandlesthisby \naggressivelyspeializingalleeswithrespettotheon\u00adtentionstatusofvaluesatallsites,ensuringthataller and(speialized)alleemethodswillalwaysagreeonthere\u00admoval/preservationhoieforanygivenruntimevalue.Less \naggressivespeializationstrategies(inwhihontextsindu\u00adingdiferingontentionpropertiesanshareaommonspe\u00adialization)mustplaeadditionalrestritionsonsynhro\u00adnizationremoval. \n8Thereisnoneedtotransferaliasinginformationfromaller toallee,(e.g.,byunifyingsiteandmethodontexts)sineall \npotentially-aliasedaller-sideexpressionswillhaveidentialaliassets. 9Indiretallsrequireadditionalefort,astheallmustinvokethe \nspeializedloneonlyforasubsetofthereeiverobjetsarrivingat runtime.Tohandlethis,newseletors(methodnames)areintro\u00adduedattheappropriatepointsinthelasshierarhy;thesetail-all \ntheappropriateloneswithidentialarguments.Suh\"trampolines\" allowspeializationstobesharedattheostofadditionaldiretall \noperations.ThisoverheadislatereliminatedbytheMarmotode generator,whih\"inlines\"thetailallsintothedispathtablesand \nremovesthetrampolinemethodbodies. 3.4.3Example a WeontinuetheexampleofSetion3.3.3intothefnaltrans\u00adformationoftheoptimization.Thisphasemakesnohanges \ntotesti,asthesynThreadsattributeofvi'saliasset(and itselements)mathesthatofthisiandthis2'saliassets. \nThesameistruefortheinvoationof<init>intest2.Sine thesynThreadsattributeofv2'saliassetdenotesmultiple \nthreadsandtheorrespondingaliassetinelementAt'son\u00adtextdoesnot,test2'salltoelementAtisreboundtoa lone,elementAt2,withontext((a11,.),a13,a14),where \n11=({elements-a12},true,{Ti,T2},/alse),a12= ({$ELT-a13},/alse,{},/alse),anda13anda14havede\u00adfaultattributes.Inotherwords,elementAt2isaspeializa\u00adtionofelementAtthatpreservessynhronizationbehavior \nontheformalparameterthis2. ThealltoelementAtintest3isalsoretargetedto elementAt2.Loalo3isfoundtohavethealiasseta1O= \n({},true,{T2},true),whihissynhronized,butonlybya singletonthread.Thismeansthatallthreesynhroniza\u00adtionoperationsono3areeliminable,sotheyarereplaed \nbymemorybarrierprimitives. The<init>methodisnotproessedbeauseithasnei\u00adthersynhronizationoperationsnorallees.Proessingof \nelementAtfndsthatthis2annotbesynhronized(reall thatbothinvoationsthatpassedsynhronizedarguments wererediretedtoelementAt2),andsuessfullyreplaes \nthesynhronizationoperationsonthis2withbarriers.The aliasseta11intheontextforelementAt2issynhronized bytwothreads,ausingallthreesynhronizationoperations \ntobepreserved. 3.5Otherissues 3.5.1Complexity Theworst\u00adasetime/spaeomplexityoftheoptimization isatleastexponentialinprogramsize.Amethodm1re\u00adturninganewpair,bothofwhosearmspointtothemeth\u00adods'sargument,willhaveareturnaliassetwithfeldmap \n{left-a,right-a}whereaistheformalaliasset.A methodm2ontainingaasadeofkallstom1anon\u00adstrutaformalaliassetwithafeldmapofsize2k. \nThatsaid,fewprogramsonstrutlargereursivedata strutureswithouttheuseofiterationorreursion.Given thattheanalysisdoesnotexplorereursivepathsinon\u00adtrolfowgraphsortheallgraph,exponentialasadesof \nthesortdesribedabovearerare.Themethod\u00adloalna\u00adtureofmanyobjetsalsolimitsdupliation,assuhobjets donotontributetomethodsummaries.Inpratie,opti\u00admizationostsaregreaterthanlinearinprogramsizebut \nremainmanageable(>7500stmts/se)evenforourlargest benhmarks. 3.5.2Eventnotifationoperations TheJavathreadingmodelsupportseventnotifationvia \ntheObjet.wait,Objet.notify,andObjet.notifyAll methods,allofwhihrequirethattheirthisargumentbe loked(otherwiseanexeptionisthrown).Preservingthis \nbehaviorinthefaeofsynhronizationeliminationrequires someadditionalefort. Whenanotifationmethodisinvokedonanobjet,a \nbooleannotifedattributeintheobjet'saliassetissetto true.Whentheanalysisfndsanotherwiseremovablesyn\u00adhronizationoperationwhosealiassethasnotifed=true,it \nreplaestheoperationwithaspeializedversionthatper\u00adformsenoughbookkeepingtosatisfythenotifationmeth\u00adods,withoutatuallyperforminganymahine\u00adlevelsynhro\u00adnizationoperations.10 \n3.5.3Objetloning ThemethodJava.lang.Objet.lonereturnsanewobjet whosereferenefeldsarealiasedtotheorrespondingfelds \nintheoriginal.Representingthisusingtheshemedesribed aboveisdi\u00c6ultbeausetheanalysismayaddfeldstothe argumentobjetlongaftertheappliationoflonehasbeen \nproessed.Expliitlyonstrutingaliasesforallpossible feldswouldbeimpratial. Instead,wemovethefeldMapattributeofthealiasset \ndatastrutureintoaseparateontentsobjetthatsupports unifationandnewinstanereation.Fieldandarrayele\u00admentoperationsonaliassetsaredelegatedtotheontents \nobjet,whileunify/newinstaneoperationsareperformed reursivelyontheontentsobjet.TheObjet.lone methodanthenbegivenaspeialmethodontextinwhih \ntheontentsobjetsoftheargumentandreturnvaluesare aliased,butthevaluesthemselvesarenot.Thisavoidsfalse \naliasingofthebaseandloneobjets,butisstillimpreise onfeldvaluesthatareimmediately,stronglyupdatedbya sublass'slonemethod. \n3.5.4Indiretsynhronizationremoval Forarestritedase,ouroptimizationisabletoremove synhronizationoperationsonobjetssubjettoontention \nbymultiplethreads.IntheMarmotruntime,anobjet's lokandhashodedataarestoredinaorresponding,dy\u00adnamiallyreatedextensionobjet.Theobjetextension \noperationmustsynhronizeonagloballok,ratherthanon theobjetbeingextended,astheobjet'slokisnotyet reated. \nTheanalysisdesribedabovedoesnoteliminateexten\u00adsionsynhronizationinmultithreadedprogramsbeausethe objetbeingsynhronized(thegloballok)isindeedsyn\u00adhronizedbymultiplethreads.Weextendtheanalysisby \naddingthealiassetattributesextendedandextThreads, whihmirrorsynhronizedandsynThreads,buttrakex\u00adtensioneventsratherthansynhronizationevents.Exten\u00adsionoperationsonobjetswithontention\u00adfreeextThreads \nsetsarerediretedtoaversionthatdoesnotperformsyn\u00adhronization. 3.5.5Single-threadedprograms Thethread\u00adalloation\u00adsiteanalysisdesribedinSetion3.2 \ndelaresaprogramsingle\u00adthreadedwhenitisunabletolo\u00adateanythreadonstrutionsitesotherthanthatforthe mainthread.Thisknowledgeallowsouralgorithmtoavoid \ntheinsertionofmemorybarrieroperations.Italsoen\u00adablestheuseofagarbageolletorandruntimesystem ustomizedforthesingle\u00adthreadedase. \n3.5.6Performaneimprovements Welowertheoptimization'sompiletimeostsbyavoid\u00adingworkthatannotenabletheremovalofsynhronization \nlaTheJalapenosystem[CGS+99]performsasimilaroptimization dynamiallybyprediatingmahine-levelsynhronizationprimitives \nonabitinthelokobjet. IIa originalimplementation voidf(Objetobj){ if(obj==null){ obj=(default); } } IIb \nmodifiedimplementation voidf(Objetobj2){ if(obj2==null){ f2((default)); }else{ f2(obj2); } } voidf2(obj){ \n } Figure3:Rewritingamethodtoavoidaliasingtheparam\u00adeterobjwiththeglobal\u00advaluedexpression(default). operations.Duringtheseondphase,weidentifymethods \nthatannot(transitively)exeutesynhronizationopera\u00adtions.Suhmethodswillneverrequireremovalofsynhro\u00adnizationoperationsorretargetingofallsites,andthusan \nbeignoredinthetransformationphase.Thisoptimization reduesostsbyasmuhas50%. Anotheroptimizationlowersmemoryusageandredues \nunifation,omparison,andnewinstaneostsbyom\u00adpressingmethodontexts.Analiassetanberemovedfrom aontextif(1)itisnotsynhronized,(2)itisnotglobal,(3) \nitonlyappearsoneintheontext,and(4)allofitsfelds areremovable.Restritions(2)and(3)ensurethataliases arepropagatedfromalleestoallers.Whiletheadditional \nontexttraversalrequiredbyompressionaninreaseosts onoursmallerbenhmarks,itreduesoptimizationtimes byasmuhas30%onlargerones. \n3.5.7Avoidingfalsealiasing Figure3(a)showssoureodeforaommonJavaidiomin whihanullformalparametervalueisreplaedwithade\u00adfaultvaluepriortotheexeutionofamethodbody.Ourop\u00adtimizationassignsaommonaliassettothevariableobjand \ntheexpression(default).If(default)denotesaglobalvalue, themethodsignatureforfwillbemarkedasglobal.Sine \nglobalsaremodeledmonomorphially,thealiassetsofthe atualparametersatalloff'sallsiteswillbeunifedeven thoughfinduesnoallee\u00adsidealiasing.Inthisase,the \n(otherwiseonvenient)bidiretionalnatureofunifation\u00adbasedfowisproblemati. Iftheidentityofthedefaultvaluedoesn'tmatter,the \nprogrammeranavoidthisproblembyonstrutingnew defaultvalues(e.g.,vianeworloning)asneessary.Ifiden\u00adtitydoesmatter,oronstrutionistooexpensive,onean \nusethestrategyofFigure3(b).Bindingobjviaparame\u00adterpassinginsteadofassignmentkeeps(default)'saliasset \noutoftheontextsofbothfandf2,avoidingundesirable aliasingatallsitesinvokingf.Forthedualaseinwhiha globalvalueisreturned,onlythenew/loneapproahanbe \nused.TheMarmotlibraryusestheseapproahesinmeth\u00ad name methods stmts dynsyns synovhd desription java 1,877 \n40,758 1.693E+7 15.62% javaompilingjlex4times javaup 859 21,657 5.926E+5 5.19% javaupgeneratingJavaparser \njess 1,339 26,172 4.797E+6 5.97% expertsystemshell jlexl00 536 15,698 1.665E+8 57.66% jlexgeneratinglexerforsample.lex,100times \nmarmot 8,193 211,332 1.172E+8 10.33% ompilejavatonativeode mtrt 716 16,500 7.486E+5 1.49% multithreadedraytraer \nmultimarmot 8,225 212,160 1.183E+8 9.99% multithreadedompileofjava plasma 1,038 17,857 4.159E+4 0.01% \nonstrainedplasmafeldsimulation/visualization slie 1,059 18,697 1.388E+4 0.02% viewerfor2Dsliesof3Dradiologydata \nvolano 741 13,085 4.623E+7 5.52% hatroomsimulator Figure4:Benhmarkprograms.Methodandstatementountswereperformedontheintermediateformjustpriortoappliationof \nthesynhronizationoptimizationalgorithm. 100% name synoperations original opt 90% omplete partial 80% \njava1.693E+7 0 3,740 javaup 70% 5.926E+5 00 jess4.797E+6 00 60% jlex1001.665E+8 00 50% marmot1.172E+8 \n0 0 mtrt 7.486E+5 948 0 40% multimarmot1.183E+8 7.810E+7 0 30% plasma4.159E+4 3,188 0 slie 20% 1.388E+4 \n8,664 0 volano4.623E+7 4.610E+5 0 10% 0% Figure5:Dynamisynhronizationmeasurements.     odsoftheStringandStringBufferlasseswhenthenull \nvalueisreplaedbythestring\"null\".Italsoreturnslones ofstringliteralsinsomeontextswherereturningasingle \nvalueausesundesirablealiasing. 4Results 4.1Benhmarkprograms Wetestedouralgorithmonfvesingle-threadedandfve \nmulti-threadedprograms,desribedinFigure4.Most oftheseprogramsarewellknown.Marmotisthe byteode-to-native-odeompilerdesribedin[FKR+00], \nwhilemultiMarmotisaversionofmarmotreonfguredto performper-methodoptimizations(amountingtoapprox\u00adimately25%oftotalompilationtime)intwoparallel \nthreads.Plasmaandsliearemodifedversionsofpubli-domainappletode.11VolanoistheVolanoMark..1.0net\u00adworkingbenhmark;weoptimizedboththelientandserver \nbutreportresultsonlyforthelient. Themethodandstatementountswereperformedaf\u00adterunreahablemethods(inboththebenhmarkprogram \nandthelibraries)wereremovedbya\"treeshake\"pass.The \"synhronizationoverhead\"olumnapproximatesthefra\u00adtionofexeutiontimespentperformingsynhronizationop\u00aderationsintheunoptimizedprogram.Weomputedthis \nvaluebymeasuringtheaverageostofanexeutingan emptysynhronizedblok(7.5E-8seonds,or58mahine yles),multiplyingitbythenumberofdynamisynhro\u00adnizationoperations,anddividingbytheunoptimizedexe\u00ad \n..Availablefromtheauthor. Figure6:Frationofsynhronizationoperationsremoved utiontime.12Interestingly,thesingle-threadedprograms \nexeutefarmoresynhronizationoperationsasafuntion ofrunningtimethanthemulti-threadedprogramsdo. Testingwasperformedonadual-proessor770MhzIntel \nPentiumIIIworkstationwith512MBofmemoryunderWin\u00addows2000Professional.Allresultsarethemeanofmultiple exeutions;standarddeviationswerenominal. \n4.2Synhronizationremoval Figure5showsdynamisynhronizationountsfortheorig\u00adinalandoptimizedversionsofthebenhmarkappliations. \nThe\"partial\"ategoryreferstooperationsthatwereonly partiallyremovedtopreservethenotifationsemantis(.f., \nsetion3.5.2);onlyjavahadremovalsofthissort. Figure6presentsthefrationofsynhronizationsre\u00admovedineahofthreesenarios.Theleftmostolumn \nofeahbarrepresentsouroptimizationwithallmethods treatedasexeutinginallthreads,restritingremovalsto thoseenabledbyesapeanalysis.Asanesapeanalysis, \noursystemisroughlyomparabletoexistingwork,exept onjava,whereitdoesmuhbetter,andjess,whereitfails almostompletelyduetoanimpreisionintheallgraph \nausingfalsealiasingwithastati.Theentralolumnrep\u00ad ..Thisfgureoverestimatestheostofreursivesynhronization \n(nomahinelevellokisrequired)andunderestimatestheostofini\u00adtialsynhronization(alokobjetmustbealloated)andontention \n(queueoperationsarerequired).Theestimatedoesnotaountfor seondaryefetsduetoahes,missedoptimizations,et. \nname exeutiontime 4.3Exeutiontime    original opt gopt java 8.13 6.44 5.97 javaup 0.86 0.76 0.66 \njess 6.03 5.63 5.12 jlex100 21.66 8.37 8.09 marmot 85.10 71.35 61.83 mtrt 3.78 3.73 3.73 multimarmot \n88.85 80.67 80.67 plasma 22.41 22.51 22.51 slie 4.64 4.64 4.64 volano 6.29 6.29 6.29 Figure7:Exeutiontimemeasurements(user+kerneltimein \nseonds). Figure8:Speedup. Figure7presentsexeutiontimesforunoptimizedandop\u00adtimizedversionsofthebenhmarkprograms.Forprograms \nfoundtobesingle\u00adthreadedbyouranalysis,weexamined twostrategies.Thefrstperformssynhronizationelimi\u00adnationonly,whiletheseondpassesathreadingfagto \ntheodegeneratorandruntimesystem,enablingtheuse ofmemoryalloationandolletionprimitivesspeialized forthesingle\u00adthreadedase. \nInFigure8,eahspeedupresultisdividedintothreeseg\u00adments.Thelowersegmentrepresentsanestimatedspeedup omputedfromthemeasuredsynhronizationountsand \ntheaverage\u00adasesynhronizationostdesribedinSe\u00adtion4.1.Together,thelowertwosegmentsrepresentthe speedupmeasuredwhenouroptimizationisapplied.This \nvalueexeedstheestimatebeausesynhronizationremoval enablesadditionaloptimization.14Thesumofallthreeseg\u00admentsisthespeedupmeasuredwhentheoptimizationand \nthesingle\u00adthreadedfagareenabled.Inaseswherenontriv\u00adialspeedupisahieved,theadditionaloptimizationsaount \nforasignifantfrationoftheimprovement(themajority oftheimprovementin4of6ases). Otherthanmultimarmot,whihimprovedby10%,the \nmulti\u00adthreadedbenhmarksdidnotbeomefasterasare\u00adsultofsynhronizationremoval.Mtrtperformsallofits synhronizationaspartofloadingitsdatafle,whihrepre\u00adsentsasmallfrationoftheoverallomputation.Allofthe \nsynhronizationinplasmaandslieoursintheAWT libraries;theinnerloopsoftheappletsarefoatingpoint omputationsthatdonotperformsynhronization.Noper\u00adformaneimprovementwasobtainedonvolano,asveryfew \nsynhronizationoperationswereremoved. 4.4Statiosts resentstheoptimizationwiththreadinformationenabled. \nThisversionahieved100%eliminationinsinglethreaded odeandimprovementsoverouresapeanalysisinplasma andslie. \nTherightmostolumnrepresentsaroughupperbound onthedegreeofsynhronizationremovalpossibleusingteh\u00adniquesthatproveanobjettobesynhronizablebyatmost \nonethreadduringtheobjet'slifetime.Weomputedthis valuebyinstrumentingthelibrarytoountthenumberof objetssynhronizedbymorethanonethreadduringexe\u00adution,andassumingthatallothersynhronizationswere \nremovable.Inmtrt,theoptimizationimproveduponthe boundbeausesomesynhronizationoperationsreferening multiply\u00adsynhronizedobjetswerefoundtoberemovable \n(.f.,setion3.5.4).Inmultimarmot,workerthreadsper\u00adformingper\u00admethodoptimizationsneverontendforper\u00admethoddata,butsinethatdataisreahedfromashared \nsymboltable,alargenumberofunneessarysynhronization operationsarepreserved.Allthreesenariosfarepoorly \nonvolano,where98%ofthesynhronizationtakesplae onBufferedlnputStreamobjetsthataresynhronizedby multiplethreads.13 \n13Ananalysistrakingrelationshipsbetweenloksmaybeableto removethesesynhronizations,whihappeartobeguardedbyan \nesaping,butlessfrequentlysynhronized,DatalnputStreamobjet. Figure9presentsvariousstatimeasuresofouroptimiza\u00adtion.Theabsoluteostsofthesynhronizationanalysiswere \nquitelow(seonds),andrepresentedonlyasmallfration ofoverallompilationtime.1 Atthesametime,byshrink\u00adingmethodsizes(removingsynhronizationode)andin\u00adreasingmethodounts(generatingspeializedmethods), \ntheoptimizationsignifantlyalteredtheostsofsubse\u00adquentphasesoftheMarmotoptimizingompiler.Overall ompilationtimesfellby79%injavaup,butroseby20% \ninmultimarmot.Withtheexeptionofjava,whihon\u00adtainsnotifationoperations,thesingle\u00adthreadedprograms didnotrequirespeialization.Formultithreadedprograms, \ntheaveragenumberofspeializationspermethodranged from.08(mtrt)to.20(volano). Theoptimization'sefetontheamountofodegener\u00adated16variedgreatly.Insomeases,theremovalofsyn\u00adhronizationode(whihMarmotalwaysinlines)morethan \nompensatedfortheadditionofspeializedmethodsandany 14Inthesingle\u00adthreadedase,memorybarriersareeliminated,en\u00adablingasmallamountofadditionalloadahing.Mostofthebeneft \nomesfromadditionalinliningmadepossible(underMarmot'ssize\u00adbasedheuristis)byredutionsinmethodsizeswhensynhronization \nodeisremoved. 15Itisworthnotingthattheanalysisalloatesalargeamountof storagewhileanalyzingamethod,muhofwhihbeomesdeadwhen \nthemethodsummaryisonstruted.Notsurprisingly,theoptimiza\u00adtionperformsbetterunderMarmot'sgenerationalgarbageolletor \nthanunderitsopyingolletor. 16The\"odegrowth\"olumninFigure9refersonlytoexeutable odegeneratedfortheuserprogramandJavalibraries.Itdoesnot \ninludeCorassemblyruntimeode,statidata,orstatimetadata. name opt fraof omp spes tramps ode time omp time \ngrowth (se) time hange java 4.17 6.75% 3.45% 3 0 9.88% javaup 1.01 2.75% -79.15% 0 0 -21.76% jess 1.59 \n4.55% -14.05% 0 0 6.82% jlex100 0.56 3.28% -8.79% 0 0 -1.03% marmot 22.00 5.41% 12.99% 0 0 20.35% mtrt \n0.86 3.85% 2.73% 58 49 -0.93% multimarmot 28.03 6.46% 20.38% 1198 775 4.32% plasma 1.11 4.04% 10.59% \n132 124 8.73% slie 1.16 3.90% 18.35% 152 124 12.43% volano 0.73 3.91% 10.69% 148 86 7.8% Figure9:Statistatistis.Optimizationtimeinludestheostofallgraphonstrution. \nadditionalinliningenabledbymethodsizedereases.For thesingle\u00adthreadedprograms,almostalloftheodesizein\u00adreaseisattributabletotheinliningofalloationoperations \nunderthesingle\u00adthreadedstoragemanagementregime. 5Relatedwork Thissetiondesribesworknotaddressedintheintrodu\u00adtionorinthetext. \n5.1Synhronizationoptimizations [DR96,DR97]desribeshemesforaggregatingmultiple ritialregionsguardedbythesamelokintoasingle,larger \nritialregion,andforreplaingmultiplelokobjetswith asinglelokthatguardsallofthesubobjets'operations. Thesetehniquesreduethenumberoflokoperationsper\u00adformedattheriskofreduingparallelismduetooarserlok \ngranularity.[Tse95]automatiallyrestruturesparallelpro\u00adgramstoreplaebarriersynhronizationwithlessexpensive \noperations,ortoremoveitentirely.Inbothases,thetrans\u00adformationsweredevelopedforapartiularstyleofthread \nsynhronizationproduedbyaparallelizingompiler,soit isnotlearthattheyaresoundforgeneralmonitorsynhro\u00adnizationasinJava. \nAnotherwaytoreduetheruntimeostofsynhroniza\u00adtionoperationsistoimplementthemmoree\u00c6iently.The IBM\"thinloks\"work[BKMS98]andtheMarmotlokim\u00adplementation[FKR+OO]areexamplesoffastlokingmeh\u00adanisms. \n5.2Relatedanalyses Theonstrutionofabstratsummaryfuntionsforuse ininterproeduralanalysisdatesbakatleasttothe \n\"funtionalapproah\"of[SP81].Aliasanalysisbased onequivalenelassesandunifationwasintrodued in[Ste96b,Ste96a].Reentworkintheontextofsummary\u00adbasedpointeranalysisinludes[CRL99,CmHOO]andthe \nsummary\u00adbasedesapeanalyses[Bla99,CGS+99,WR99] disussedintheintrodution.[FRDOO]exploresaombina\u00adtionofequivalene\u00adlass\u00adbasedanalysisandproeduresum\u00admariesthatsupportshigher\u00adorderproedures. \n6Futurework Whileouroptimizationdidverywellonsingle\u00adthreaded benhmarksandhadsomesuessinthemultithreadedase, \nthereismuhworktobedoneformultithreadedprograms. Ouroptimizationtreatsallthreadsasthoughtheyrunfor thedurationofprogramexeution,whilemanyprograms \n(inludingrultirarrot)useforkfjoinstrategiesinwhih threadlifetimesarefarshorter.Thissuggeststhepursuit \nofmoretemporallysensitivestrategies.Anotheropenissue isthetreatmentofthreadsthemselves;allexistinganalysis, \ninludingours,treatalldatareahablefromthreadobjets asesaping.Morepowerfultehniquesarerequiredtoshow thatsomestateheldininstanevariablesofthreadsremains \nunaliased. Ourfowanalysisisfragileinthepreseneofylesin theallgraph(e.g.,jess).Possibleimprovementsinlude \nenhaningtheMarmotstatiallgraphanalysisviaontext sensitivetehniquesormodelingofpolymorphidatastru\u00adtures.Alternatively,weouldavoidtheuseofastatiall \ngraphbyenodingmethoddispathintotypesandusing theinstantiationonstraintbasedfowanalysistehnique of[FRDOO].Athirdoptionwouldallowlimiteduseofsetsof \naliasSettorepresentvaluesinaseswhereunifationyields falsealiases[SH97]. Thehighspeedofouranalysisopensseveralopportuni\u00adties.Onepossibilityistousetheanalysisasapreproessing \nphasetoreduetheostofamorepreisemodel.Anotheris aniterative,pessimistiallgraphoptimizationinthestyle of[HH98],inwhihtheanalysisisusedtomodellasssets, \nwhihareusedtoimprovetheallgraph,enablingreanaly\u00adsis,et.,untilonvergeneisahieved. Weplantoapplyequivalene\u00adlass\u00adbasedsummarization \ntehniquestootherinterproeduralproblemssuhasstak alloation,memorydisambiguation,andtypepropagation. Finally,webelieveitisimportanttoontinuethesearh \nforandthedevelopmentofadditional,morerealistimul\u00adtithreadedprogramsforuseinthedesignandtestingof optimizations. \n7Conlusion Wehavedesribedanefetive,e\u00c6ienttehniqueforstati\u00adallyremovingunneessarysynhronizationoperationsfrom \nJavaprograms.Thedistinguishingfeaturesofthisapproah are .theuseofthreadlosureandaliasanalysesrather thanesapeanalysis,enablingmorepreisemodeling \nofvaluefowinthefaeofglobalvariablesandmultiple threads,and .theuseofequivalenelassbasedmethodsummaries, \nenablingsimple,fast,non-fxed-point,ontext-sensitive analysisandtransformation. Ouroptimizationhandlesbothsynhronizedmethods \nandbloks,andpreservestheJavasynhronization,mem\u00adory,andnotifationsemantis.Ourexperiments,performed intheontextofanoptimizingompiler,demonstrateim\u00adprovementsindynamisynhronizationountsandexeu\u00adtiontimeinbothsingle-andmulti-threadedprograms,ata \nreasonableostinompilationtimeandodegrowth. Aknowledgments WethankthemembersoftheAdvanedProgrammingLan\u00adguagesgroupatMirosoftResearhfortheirsupportof \ntheMarmotompilerinfrastruture,BjarneSteensgaardfor fndinguniferbugs,andtheanonymousrefereesfortheir suggestions. \nReferenes [ACSE99]J.Aldrih,C.Chambers,E.G.Sirer,andS.Eg\u00adgers.Statianalysesforeliminatingunneessarysyn\u00adhronizationfromJavaprograms.InSAS'gg,LNCS. \nSpringer\u00adVerlag,September1999. [ASU86]A.V.Aho,R.Sethi,andJ.D.Ullman.Compilers: Priniples,Tehniques,andTools.Addison\u00adWesley, \nReading,MA,USA,1986. [BH99]J.BogdaandU.H6olzle.Removingunneessarysyn\u00adhronizationsinJava.InProeedingsofthe14th \nConfereneonObjet\u00adOrientedProgrammingSys\u00adtems,Languages,andAppliations(OOPSLA'gg), November1999. [BKMS98]D.F.Baon,R.Konuru,C.Murthy,andM.Serrano. \nThinloks:FeatherweightsynhronizationforJava. InProeedingsoftheSIGPLAN'g8Confereneon ProgrammingLanguageDesignandImplementation, \npages258-268,June1998. [Bla99]B.Blanhet.Esapeanalysisforobjetorientedlan\u00adguages.appliationtoJava.InProeedingsofthe14th \nConfereneonObjet\u00adOrientedProgrammingSys\u00adtems,Languages,andAppliations(OOPSLA'gg), November1999. [BS96]D.F.BaonandP.F.Sweeney.Faststatianalysis \nofC++virtualfuntionalls.InProeedingsOOP\u00adSLA'g6,ACMSIGPLANNoties,pages324-341, Otober1996.PublishedasProeedingsOOPSLA \n'96,ACMSIGPLANNoties,volume31,number10. [CFRW91]R.Cytron,J.Ferrante,B.K.Rosen,andM.N. Wegman.E\u00c6ientlyomputingstatisingleassign\u00admentformandtheontroldependenegraph.ACM \nTransationsonProgrammingLanguagesandSys\u00adtems,13(4):451-490,Otober1991. [CGS+99]J.\u00adD.Choi,M.Gupta,M.Serrano,V.C.Sreedhar, \nandS.Midkif.EsapeanalysisforJava.InPro\u00adeedingsofthe14thConfereneonObjet\u00adOriented ProgrammingSystems,Languages,andAppliations \n(OOPSLA'gg),November1999. [CmH00]B.\u00adC.ChengandW.meiHwu.Modularinterpro\u00adeduralpointeranalysisusingaesspaths:Design, \nimplementation,andevaluation.InProeedingsofthe SIGPLAN2000ConfereneonProgrammingLan\u00adguageDesignandImplementation,June2000. \n[CRL99]R.Chatterjee,B.G.Rynder,andW.A.Landi. Relevantontextinferene.InProeedings26th ACMSIGPLAN\u00adSIGACTSymposiumonPriniples \nofProgrammingLanguages,pages133-146,January 1999. [DR96]P.DinizandM.Rinard.Lokoarsening:Eliminat\u00adinglokoverheadinautomatiallyparallelizedobjet\u00adbasedprograms.InProeedingsoftheNinthWork\u00adshoponLanguagesandCompilersforParallelCom\u00adputing,LNCS1239,pages285-299,August1996. \n[DR97]P.DinizandM.Rinard.Synhronizationtransfor\u00admationsforparallelomputing.InProeedings24th ACMSIGPLAN\u00adSIGACTSymposiumonPriniples \nofProgrammingLanguages,pages187-200,1997. [FKR+00]R.Fitzgerald,T.B.Knoblok,E.Ruf,B.Steens\u00adgaard,andD.Tarditi.Marmot:Anoptimizingom\u00adpilerforJava.Software:PratieandExperiene, \n30(3):199-232,Marh2000. [FRD00]M.F6ahndrih,J.Rehof,andM.Das.Salable ontext\u00adsensitiveIowanalysisusinginstantiation \nonstraints.InProeedingsoftheSIGPLAN2000 ConfereneonProgrammingLanguageDesignand Implementation,2000. \n[GJS96]J.Gosling,B.Joy,andG.Steele.TheJavaLan\u00adguageSpeifation.TheJavaSeries.Addison\u00adWesley, Reading,MA,USA,June1996. \n[HH98]R.HastiandS.Horwitz.Usingstatisingleassign\u00admentformtoimproveIow\u00adinsensitivepointeranaly\u00adsis.InProeedingsoftheSIGPLAN'g8Conferene \nonProgrammingLanguageDesignandImplementa\u00adtion,pages97-105,June1998. [Rin99]M.Rinard.Personalommuniation.1999. \n[SH97]M.ShapiroandS.Horwitz.FastandaurateIow\u00adinsensitivepoints\u00adtoanalysis.InProeedings24th ACMSIGPLAN\u00adSIGACTSymposiumonPriniples \nofProgrammingLanguages,pages1-14,January 1997. [SP81]M.SharirandA.Pnueli.Twoapproahestointerpro\u00adeduraldataIowanalysis.InProgramFlowAnalysis: \nTheoryandAppliations,hapter7,pages189-284. Prentie\u00adHall,1981. [Ste96a]B.Steensgaard.Points\u00adtoanalysisbytypeinferene \nofprogramswithstruturesandunions.InInterna\u00adtionalConfereneonCompilerConstrution,num\u00adber1060inLetureNotesinComputerSiene,pages \n136-150,April1996. [Ste96b]B.Steensgaard.Points\u00adtoanalysisinalmostlin\u00adeartime.InProeedings23rdACMSIGPLAN\u00adSIGACTSymposiumonPriniplesofProgramming \nLanguages,pages32-41,January1996. [Tse95]C.Tseng.Compileroptimizationsforeliminatingbar\u00adriersynhronization.InProeedingsoftheFifthACM \nSIGPLANSymposiumonPriniplesandPratiesof ParallelProgramming,pages144-155,July1995. [WR99]J.WhaleyandM.Rinard.Compositionalpointerand \nesapeanalysisforJavaprograms.InProeedings ofthe14thConfereneonObjet\u00adOrientedProgram\u00admingSystems,Languages,andAppliations(OOP\u00adSLA'gg),November1999.\n\t\t\t", "proc_id": "349299", "abstract": "<p>We present a new technique for removing unnecessary synchronization operations from statically compiled Java programs. Our approach improves upon current efforts based on escape analysis, as it can eliminate synchronization operations even on objects that escape their allocating threads. It makes use of a compact, equivalence-class-based representation that eliminates the need for fixed point operations during the analysis. </p><p>We describe and evaluate the performance of an implementation in theMarmot native Java compiler.  For the benchmark programs examined, the optimization removes 100% of the dynamic synchronization operations in single-threaded programs, and 0-99% in multi-threaded programs, at a low cost in additional compilation time and code growth.</p>", "authors": [{"name": "Erik Ruf", "author_profile_id": "81100400397", "affiliation": "Microsoft Research, Redmond, WA", "person_id": "P78858", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/349299.349327", "year": "2000", "article_id": "349327", "conference": "PLDI", "title": "Effective synchronization removal for Java", "url": "http://dl.acm.org/citation.cfm?id=349327"}