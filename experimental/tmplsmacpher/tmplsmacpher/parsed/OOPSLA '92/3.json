{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum fo the Proceedings Experience Report- Chembench: Redesign of a Large Commercial Application \nUsing Object-Oriented Techniques Report by: Glenn Olander Biosym Technologies 1. Introduction While \nthe advantages of using the object-oriented design paradigm when embarking on the the design of a new \nsystem have been established, the ramifications of using these techniques in the redesign of an existing \nsystem are less well-known. Our experience with Chembench, a class library which reimplements the framework \nof an existing molecular modeling application, offers some insight into the benefits of using object-oriented \ntechniques when changing the architecture of an existing system. This paper discusses our rationale for \nundertaking this effort, the choices we faced for an approach, our experiences during the project, and \nthe current status.  2. Background The Insight II application is an interactive molecular modeling system \nwhich was originally intended as a protein modeling package. This workstation-based graphical application \nis approximately eight years old and was originally developed as a joint effort between Monsanto Corporation \nand the University of California, San Francisco. It is primarily used by research chemists in both academic \nand industrial institutions for visualization, simulation, and analysis of molecules, and is most often \nused as a 5-10 October 1992 tool for basic research and pharmaceutical development. By 1988 Insight II \nhad grown into approximately 120,000 lines of C, entirely based on a procedural model. As the system \ngrew, the limitations imposed by the heritage as a system based on a procedural- oriented paradigm became \nincreasingly apparent. Most notable was the ever increasing difficulty of maintaining reliability when \nextending the capabilities of the system. By this time we were searching for a solution to this reliability \nproblem, Also at this time our products were anticipated (in retrospect this was an accurate anticipation) \nto grow into a family of molecular modeling applications, extending beyond protein modeling to include \nother chemistry disciplines such as synthetic polymers and inorganic catalysts. While these disciplines \nare different in many ways, they are all fundamentally chemistry applications. In view of this commonality \namong the applications, we recognized the opportunity for sharing a common core among them, thus making \napplication development more efficient through the use of previously-existing components and making the \nvarious applications appear integrated to the user via the use of a common set of underlying data representations. \nThe Insight II system would be useful as an application core since it had much of the general chemistry \ncapability that we desired. However, its procedural structure, lack of encapsulation, and inconsistency \nmade it difficult to  -W-Addendum to the Proceedings use and extend. If the goal of efficient application \ndevelopment were to be achieved, these problems would have to be addressed. Adding to the problems we \nwere faced with at the time was the fact that we wished to offer an open architecture product to customers \nwhich would permit them to create their own applications within our framework. If we could use our application \ncore as an open architecture product, then the common underlying data representations which customers* \napplications shared with applications from Biosym would result in a cohesive suite of tools for solving \ncustomer problems. However, the same inconsistency and lack of encapsulation problems that were barriers \nto the other objectives rendered the implementation of Insight II inappropriate for this purpose as well. \nAn essential element of any successful open architecture is a static interface which continues to be \nsupported as new versions of the underlying system are released. We needed an interface which reflected \na model of a system which we were comfortable supporting well into the future.  3. System Architecture \nThe solution to these problems was clear: create a new application framework, based on newer software \narchitecture technology. In particular, object-orientation, promised to offer solutions to many of the \nextensibility, efficiency, and reliability problems we were faced with. How to go about this rearchitecting \nwas not so clear, especially in view of the fact that we had a substantial investment in an large body \nof code which, at a functional level, had the capabilities we desired. Two options were considered. (1) \nCatastrophic. In the catastrophic approach, a team of developers would reimplement the core of the system \nas a class library. No interfaces from the old version of the system would be preserved. The advantage \nto this approach would be that a fully object-oriented architecture would be in place. The disadvantage \nis that applications would have to be completely rewritten to change from the old core interfaces to \nthe new. Taking the applications off-line for this migration was particularly distasteful, since, due \nto limited resources, it meant that effort expended on this port would necessarily mean a corresponding \ndecrease in the amount of new functionality added to applications during this time period. (2) Evolutionary. \nIn the evolutionary approach, a jacket would be placed around the old core which gives it the appearance \nof an object-  oriented class library. The jacket code would perform any necessary transformations to \ndata coming from/going to the old core to make it behave in the desired manner. This approach had the \nsignificant attraction that applications based on the old core interfaces would continue to work. We \nwere well-aware of the potential disadvantages, however. Namely, it would probably take longer to fully \naccrue the benefits of object-oriented technology, the jacket would be constrained by some limitations \nin the old core, the transformations may cause performance to suffer, etc. We chose the evolutionary \napproach. The reasoning was analogous to the rationale offered by many object-oriented success stories: \nit is best to introduce the technology in a gradual manner, then build on a growing number of successes \nto demonstrate its soundness. In 1990 we started on the implementation of this class library for molecular \nmodeling applications: Chemhench. 4. Implementation Methodology Our strategy of encapsulating the old \ncore with an surrounding jacket is a key characteristic of Chembench. It allows new application code \nto be written using the Chembench class library, realizing many of the advantages of the object-oriented \ndesign paradigm. The old application code continues to work with the old core, but as time allows, it \nis migrated to the new interfaces. When all of the application code which uses a particular core functional \narea has been migrated, that portion of the core may then be reimplemented in a truly object-oriented \nfashion. It is optimized for the intended usage patterns and the overhead of performing transformations \nfrom the old model to the new model is eliminated. Any new classes to be added to Chembench are implemented \nin an object-oriented manner from the beginning, since they don t have the burden of supporting an old \ninterface to existing application code. The C implementation of the application code dictated a C binding \nfor the Chembench library. We fully encapsulated the objects, requiring function calls for all accesses \nto objects, including the querying and modification of attributes. It was only through this complete \nencapsulation that we would be able to eventually reimplement each class without disturbing applications. \nIn addition to offering a C binding to applications, we chose to implement the jacket layer in C. Among \nthe reasons for this were the fact that one of the platforms on which Chembench was to run had no OOPSLAW \n-14-Vancouver, British Columbia C++ available at the time, and also we wanted to be able to bring in \ndevelopers who had no C++ training into the project to help with jacket layer implementation. Our inheritance \nmechanism is similar to the mechanism used by the X toolkit. In this system, each object has a pointer \nto a table of pointers to member functions which is shared by all objects of each class, thus offering \nclass derivation in C. At the interface level, we ve emphasized consistency across classes. The conventions \nand rules that an application programmer learns when using one class are adhered to by all classes, thus \nmaking it easier to learn to use new parts of the system.  5. Managerial Issues The project has been \nstaffed by a small group of four developers, occasionally supplemented by developers contributed by application \ngroups. The membership of the group has been rather dynamic. This has contributed to a healthy evolution \nof ideas. Some principles were established at the beginning of the project and have persisted. Others \nwere modified over time, although the ability to make changes in basic doctrines has diminished with \nthe growth of the system. Training has been accomplished internally, and together with documentation \nhas been a major focus of the effort. We have used seminars, bulletin boards, news letters, and open \nforum meetings as means to disseminate information about Chembench to the internal development staff. \nWe have emphasized high-quality documentation, including printed manuals and on-line reference material, \nand have put a premium on making example code available to help illustrate usage of Chembench. While \nthe Chembench group has done the bulk of the implementation, design decisions have been made communally, \nwith the participation of application group representatives. These efforts have not been accompanied \nby the usual inefficiencies of design by committee presumably because the customers or domain experts \nin these projects are themselves software developers and are familiar with the necessary compromises \nto be made. The project has spanned several product releases, which have been between six and twelve \nmonths long. These release have forced us to break up larger projects into smaller pieces so that we \nhave a coherent whole at the time a release is to ship. These intermediate milestones have also served, \nhowever, to provide convenient checkpoints at which we can reevaluate objectives and review progress. \n 6. Results After two years, we have provided Chembench interfaces to nearly all of the features of \nthe old core and have created a number of entirely new classes. Progress on the migration of old application \ncode to Chembench interfaces has been modest, but new applications written in the mean time are primarily \nChembench-based. At this point in the project we ve made substantial progress towards our primary objective \nof improving the maintainability and extensibility of the system. This is evidenced by an increased rate \nof new feature introduction (the total system size including applications has more than doubled since \nthe start of the project) and decreased rate of reported bugs. One reason for this enhanced reliability \nhas been the fact that old application code which has been converted to use Chembench has become much \neasier to maintain since Chembench offers a more convenient and coherent interface to core services than \nthe old system. Also, we ve been able to grow to support new applications. Most notably, we ve been able \nto undertake major extensions to the system while maintaining reliability. Similar extensions prior to \nChembench were either abandoned or were done by expedient means which had disastrous long-term consequences. \nThe new architecture makes major enhancements practical and efficient: even members of application groups \nhave been able to add substantial new classes based on classes offered in Chembench. This improved productivity \nhas been sufficient to counter balance the negative impact of discarding the jacket code which is created, \nthen replaced when a class is reimplemented after all application code has been migrated to the new interface. \nOur most notable frustrations have been in the classes where we wanted to change an implementation, but \nwere prevented from doing so because the migration to Chembench was incomplete. In these cases we were \nfaced with migrating large amounts of old application code which made direct data structure access before \nthe reimplementation could be undertaken. This migration has been made more difficult because the model \nwhich Chembench presents to applications is often different than the old system, meaning that migration \nis usually more than a matter of substitution of a function call for a direct data structure access. \nInstead, logic changes in the application are often required. We have generally compromised in these \ncases, migrating only enough code to permit a modest implementation change. S-10 October 1992 -l5-Addendum \nto the Proceedings Our objective of keeping applications running throughout the entire process has also \nbeen successfully met. Previously existing application code has not required modification to continue \nworking while the jacket layer has been put into place and used. The choice to not use C++ has posed \nsome problems, but as was mentioned earlier, we had compelling reasons not to use it. We are anticipating \nswitching to C++ in the future and initial investigations show that because of the class structure we \nve imposed on our system, the switch should be very easy. Finally, we now have a system which is suitable \nas an open architecture. Because of the object-oriented nature of the system, it offers sufficient encapsulation \nand interface consistency that it may be used by customers as a basis for applications of their own, \nor extensions to applications offered by Biosym Technologies. OOPSLA % -16. Vancouver, British Columbia \n \n\t\t\t", "proc_id": "157709", "abstract": "", "authors": [{"name": "Glenn Olander", "author_profile_id": "81332519137", "affiliation": "", "person_id": "P98490", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157712", "year": "1992", "article_id": "157712", "conference": "OOPSLA", "title": "Chembench: redesign of a large commercial application using object-oriented techniques", "url": "http://dl.acm.org/citation.cfm?id=157712"}