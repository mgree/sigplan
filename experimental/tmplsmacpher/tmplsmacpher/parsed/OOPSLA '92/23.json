{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 to the Vancouver, British Columbia, Canada 5 - 10 October 1992 Proceedings Workshop \nReport- Experiences of Use Cases and Similar Concepts Organizer: Fredrik Lindstrom Objective Systems \nSF AB Independent of the method used, projects that need to test their product must use a concept that \ndescribes its intended usage. Object-oriented methods like Objectory, OOA, RDD, and OOD describe the \nusage through use cases, threads of execution, scenarios, and mechanisms. The workshop s goal was to \ndiscuss the experiences of using such concepts and ways to represent them. All the 8 accepted position \npapers were presented by the authors. After each presentation, each attendee identified issues that were \ncollected and listed per presentation. The last hour of the day was spent classifying the identified \nissues. The categories are: solved, grey, research, Solved represents issues that the participants could \nresolve. Grey represents issues were the participants couldn t agree on the category. Research refers \nto issues that the participants found difficult, The workshop report is divided in two main parts. The \nfirst comprises the summaries of the workshop participants contributions. The second comprises the identified \nand classified issues. Further, one participant, Ivar Jacobson, identified the need for a manifesto paper \nabout usage modelling of object-oriented systems. That is, a paper that defines mandatory, optional, \nand research issues for the subject. Writing such a paper is an open challenge left to the reader. Especially \nthose that attended the workshop. 1. Summary of position papers 1.1. Bennet, D. Evaluating Behavior \nAllocation in Use Cases Summing up, D. Bennet focuses on evaluating the behavior allocation decisions \nmade during the internal design. To evaluate the behavior allocation, he collects the complete interface \n(both incoming and outgoing messages) of each object into a separate diagram. He calls the diagram the \ninterface view of the object. By studying this diagram, a designer can evaluate an object s cohesiveness \nand consistency. For example, if an object sends most of its messages to the same receiver, the designer \ncould consider joining the two objects. Bennet also uses four different object types to evaluate the \nstability of the behavior allocation. For each type, Bennet has a set of rules that prescribes how it \nshould interact with other types. The goal of these rules is to ensure that the system is stable against \nchanges. In the evaluation process, when an object fails to conform to its type s rule, the designer \nshould consider joining or splitting the object. As a technique for encouraging a good allocation in \nthe first attempt, he arranges the objects by type in the interaction diagram. 1.2. Betz et al., A Critical \nAssessment of Interaction Diagrams for Use cases Betz et al. have used interaction diagrams for design \nof software systems. They like interaction diagrams since they have found that the diagrams enhance the \nunderstanding of an object-oriented system. But, they find the following deficiencies of the diagrams: \n(1) Looping is hard to show! (2) Conditionals are hard to show. (3) Messages to self are hard to show. \n (4) Anything that isn t a message is hard to show. Even innocuous things like assignment are problematic. \nAnd for hybrid 00 languages, ordinary function calls are hard to show. Also, in hybrid languages, creation \nand construction methods don t have convenient receivers. (5) Return values are problematic. On one \nhand, if we don t show them, we can t discuss subsequent messages to the returned object. On the other \nhand, if we do show them, say as tokens under the message, they appear too early in the chronology of \nthe diagram.  Also, they have found that the activity of creating a diagram more valuable than the final \ndiagram. After its creation it is difficult to keep the diagram consistent with the code. 1.2.7. Comments \nand discussions Students block when they start to use the diagrams. Why? One hypothesis, proposed by \na participant, is that computer scientist don t understand time. One proposal was to ban representation \nof control from TMDF. That is, disallow representation of loops etc. Instead, use them as Buhr s timethreads. \n 1.3. Buhr IX, Architecture Through Pictures: Timethreads, ideas, notations and applications A timethread \nis a path along which time monotonically increases. Its purpose is to give an example of macroscopic \nbehavior. A timethread starts at some point of stimulus, and touches elements of the design. The order \nof the touch depends on when the design elements are activated in response to the stimulus. The timethread \nends at some point of completion of processing or delivery of response from the design elements. The \nvisual representation of a timethread is a curve traced through elements of a design. Timethreads, however, \nare viewed as abstractions in their own right that exists independently of the visual representation \nor of the details of the elements through which the curves are drawn. Timethreads omit local control \nflow details, such as: where control of the sequencing resides; and the pattern of call and return to \ncontrol design elements. Thus, they are more abstract than threads of control, making them more useful \nfor macroscopic behavior. Prof. Buhr has observed timethreads to be critical to the thinking of designers \nof real-time systems in industry. They must ensure that elapsed times along timethreads that traverse \nmany components are small, and that orchestration of multiple timethreads that may be in progress concurrently \nis correct and robust. Buhr has observed them used by such designers as tools not only for design understanding \nand design-analysis, but also for design-discovery. For the latter purpose, they need to be viewed as \nabstractions in their own right that exist independent of details that remain to be decided. For example, \na set of timethreads could exist as design elements before the objects they touch have been identified \nor defined. Without objects, a thread would link activity segments that could later be bound to objects. \nIn fact, this is one way of designing. Define a bunch of threads with activity segments and then cut \nthe threads to form thread segments containing one or more activities that can be combined and allocated \nto objects. In a final design model, threads are of course bound to objects. The issue is that the binding \nshould be possible in any order, objects to threads, or threads to objects, at any point in the design \nprocess. 7.3.7. Comments and discussions Informalness is important. Timethreads work as examplars of \na system s behavior, not as complete specifications. Therefore, it seems that they cannot, for example, \nbe used for generation of the code of a system. Despite this, real-time designers use them and find them \nan effective explanation tool. How is control allocated? Allocating control is a design decision that \nshould be done after we have decided that two parts interact at all. Then, when the process interaction \nparadigm is decided, allocation of control is straightforward. 1.4. A. A. R. Cockburn, Using Formalized \nTemporal Message-flow diagrams The TMDF (Temporal Message Flow Diagrams) are an attractive diagramming \ntechnique to understand the behavior of a system. The protocol and telecommunication communities use \nthem as an established technique and, inspired from their success, the object-oriented community has \nstarted to use them, e.g Interaction Diagrams (in Objectory), Event Traces (in OMT), and Timing Diagrams \n(Booth). What can we learn from the earlier usage of TMDF? A. Cockburn presented experiences from a formalization \nand tool project within the protocol community. The lesson that Cockburn et al. learned was that designers \nliked TMDFs to gain an intuitive understanding of a system. Too formalized, however, the TMDF become \nbrittle, and thus, too painful to use for the designers. A TMFD gives a view of cross-system activity \nfor one of many possible scenarios. It is actually an event trace with a selective filter. Protocol designers \nknow that a system can be described to another person quickly by a set of carefully selected TMFDs. In \nthis way, a TMFD gives the intention of the design. The other way to describe the system is to use a \nset of communicating finite state machines (CFSMs). Though the TMFDs and the CFSMs are complementary, \nboth are a two dimensional view of a three dimensional system (events X states X machines), Cockbum et \nal. experienced that the TMFDs have the advantage of intuitively showing the correct operation of the \nsystem. According to Cockburn, there are two ways of visualizing TMDFs. The first, the time view, uses \none connection per message to show the messages order between objects. The second, the top view, is a \nprojection of the messages onto one plane. To show the ordering in the top view, the messages must be \nnumbered. The time view has two disadvantages compared to the top view, and one advantage. In a time \nview, it is difficult to show choices between sequences and to show the system s interconnections. The \nadvantage of the time view is that it scales with complexity. It can get longer and wider, and it can \nbe composed hierarchically, so that the full description can be explored at different levels of detail \nand in different contexts. Alistair s experience is that on one hand, people prefer the top view for \nshort sequences and where there is no back-and-forth between objects. On the S-10 October 1992 other \nhand, they prefer time views for long or complicated sequences. For those of you that are interested \nin the formalization of TMDFs, see (Cockbum, 1991; Cockburn &#38; Citrin, 1991). 1.4.7. Comments and \ndiscussions A sure way to lose track of the intention of a system is to regard it as a set of communicating \nstate machines. . Whatever diagram techniques that we use, we must be able to show lost messages. We \nhave to accept that incompleteness will always be an aspect of development of large systems. 1.5. Hedlund, \nM. A Representation of Object Behavior in LOTOS As a part of an ESPRIT project, LOTOSPHERE, Ascom Tech \nhas carried out a study of the possibilities of using LOTOS, a formal CCITT language, in software development. \nWhile transfering the experiences to Ascom Hasler, M. Hedlund et al have studied how to use LOTOS with \nthe Objectory development process. Out of many possibilities, they selected to use LOTOS as a verification \ntool for use case designers. That is, check the completeness and the consistency of the use case specification. \nWhile doing experiments with this scenario, Hedlund et al discovered inconsistencies in use case descriptions \nof a real application. The benefits of using LOTOS (or any other formal language) as a verification tool \nare twofold. First, it is good way to introduce formal techniques in an organization. To begin with, \nonly an isolated verification team has to learn about the techniques, since LOTOS specification does \nnot form a basis for implementations and need, therefore, not be maintained. Second, it seems that the \ntechnique discovers design errors that otherwise will be found later in the development cycle. When the \nresearch group modelled the use cases from the design, they found several design errors. They classified \nthem into: - missing operation calls. The execution of the LOTOS model showed that the use case designer \ndid not specify operation calls that should have been made. - missing relations. The execution of the \nLOTOS model showed that objects lacked relations. The use case designer had assumed that a sending object \nhad a reference to the receiving object.  Addendum to the Proceedings - missing attributes of the objects. \nOperations that change the state of an object must have a state to change, the LOTOS model s execution \nshowed that attributes were missing. When the research group used LOTOS as a verification tool, they \nmanually translated the use case descriptions (i.e the use cases interaction diagrams and design document) \nto corresponding LOTOS templates. After that, they completed the templates with information on operation \nfunctionality and state change. Next, all the LOTOS specifications were collected into one specification \nfor the whole system. This was the specification that was the subject to the verification, Since LOTOS \nis based on the concept of processes communicating though gates, Hedlund had to find a representation \nof objects in LOTOS. In general, this is a straight forward exercise in modelling an object as a set \nof processes.  7.5.7. Comments and discussions The LOTOS modelling was carried out entirely by hand, \nand therefore, it was expensive. Therefore, it cannot be done for a complete, large model. Instead, this \ntype of verification pays off for critical behavior of the system. However, this could change if it would \nbe possible to make the translation process semi-automatic. 1.6. Jacobson, I The Use case construct \nin Object-Oriented Software Engineering Real systems consists of a large set of interacting objects. \nHow do we describe that kind of system? There are many different ways of doing this and Dr. Jacobson \npresents one, the usecase approach. Its has two main traits. First, it focuses on the users and their \nusage of the system. Second, if focuses on building different object models of the system. From an external \nperspective, a use case is a set of behaviorally related transactions that a user demands of the system. \nBesides being a description of the usage of the system, a use case also works as a view of the internal \nstructure of the system. Different object models become related through a use case since the use case \nwill have a view of both models. In OOSE, use cases are identified during the fist phase of development, \nrequirement analysis. They are related to the users through the concept of actors. Where, in OOSE, an \nactor is a role that an actual user plays. The idea is to identify the ways a user will use the system \nand to guarantee that the system will satisfy at least those ways. For each use case, per object model, \na use case specifier draws a dynamic and a static view. The first, the dynamic view, shows how objects \ninteract during the execution of that specific use case. The second, the static view, shows the static \nassociations between objects, for example before, during, and after the use case s execution. In the \ndesign object model, when the interaction is on a detailed level, the dynamic view could be an interaction \ndiagram. In Objectory, the development process is driven by the use cases. This means that they are part \nof the input to all processes and that they serve as an equivalence relation (in the sense of (Katz, \n1990)) between different object models. For a more complete description of use cases and examplars of \nwhat they look like, see (Jacobson, Christersson, Jonsson, &#38; overgaard, 1992). 7.67 Comments and \ndiscussions Usecasescanbeusedasawaytomeasure resource requirements, e.g., what is the performance when \n100 users execute instances of the same use case. 1.7. Nakajima, T Experiences of using OMT for a Reactive \nsystem Tsuyoshi Nakajima has participated in a Mitshubishi project for a soft real-time project. In the \nproject, Mitshubishi started with using standard OMT, but finished with a rearranged version. During \nthe project, Nakajima discovered some problems: The system engineers in this project needed some tools \nto communicate with their customer. The Object Diagrams (ODs) in OMT are not suitable for this purpose \nsince the customer had only functional requirements. In object modeling we have to describe the global \ninformation structure of the whole system. This is impossible for large system development. OMT doesn \nt clearly describe procedures for behavioral design. It is impossible to write all scenarios for each \ntransaction. To overcome the problems, Nakajima used the following approach: use Structured Analysis(SA)-style \nfunctional decomposition and local object modeling in analysis phase. use EFDs in behavioral design. \n(EFDs are scenarios for each transaction, including main paths and error paths.) change the design view \nto Statecharts that describe behavior of each class after some EFDs are designed. 1.7.1. Comments and \ndiscussion Another experience that shows that for some systems the behavior is equally important as the \ninformation structure. 1.8. Wallin, S. Experiences from usage of use cases within the design of a large \nreal-time application From Stefan Wallin s experience, a documentation of objects only does not yield \nan understanding of a system. Use cases or similar concepts are needed for a complete understanding of \nthe system. Equally important for understanding, is that a large system needs to be structured into layers, \nwhere different parts of the organization are responsible for one layer. Taken together, this means that \nnot one person can be responsible for the use case in terms of the lowest level objects. Instead, the \nresponsibility of the use case must be divided between different persons. Further, Stefan believes that \nthe greatest benefit lies in using descriptions of behavior at the level of layers or subsystems, not \nat the level of individual classes. A major problem was to select at what granularity of events to apply \na description technique of use cases, namely interaction diagrams (i.e TMFD). The project found it impossible \nto use interaction diagram to describe all events that the system received. Instead, they decided to \nonly use interaction diagrams when: a) the diagram added clarifying value; and b) when the interaction \nbetween objects was complex. Also, the value of using interaction diagrams at the class level is questionable. \nDoing this brings up problems with showing inheritance, virtual functions, classes/instances etc. All \nof which need to be resolved, but not at the stage when the diagram is drawn. In the project, they found \npros and cons with using use cases as a pushing concept for the design. The cons are: a) the system runs \nthe risk of being functionally structured instead of object structured; b) using interaction diagrams, \nit is impossible to cover all sequences; c) some behavior of the system can only indirectly be deduced \nfrom the users requirements, for example, screen updating.  5-10 October 1992 -127. The pros are: a) \nthe system will fulfill the user requirements, b) use case modelling limits the extent of an object model. \nFrom a testing point of view, they found that interaction diagrams could not be used as definitions of \nexpected results. Since the project used the diagrams as exemplars, they covered less than 50% of the \ncode. Instead, for testing, Wallin proposes to use pre and post conditions in terms of object states \nand object interconnections. Wallin proposes that a use case should be an entity composed of different \nviews. Among them are: a) user functionality that can be described with al) a list of functions a2) object \nmodel a3) formal interface languages b) Object interaction described by bl) interaction diagrams b2) \ntransaction diagrams  7.8.1. Comments and discussions The interaction diagrams are an important thinking \ntool, but they are difficult to use for specification. That is, interaction diagrams should be used as \nexamplars, not as specifications.  2. Classification of identified issues 2.1. Solved Identification \nof static relationship between objects. Also the static relationships between objects can be identified \nper use case. A static relation is an object reference that it copied to and kept between method invocations \nof the object. Is there a way to execute TMDF (interaction diagrams) directly? Yes, e.g., see Hedlunds \nposition paper. However, the possibility is a double-edged sword, see Cockburn s experiences. How do \nwe show loops, conditionals, assignments, and calls to functions not associated with objects in TMDF? \nThe somewhat unsatisfactory way to show them in a TMDF is to annotate the diagrams with text. Assignment, \nhowever, is slightly different since it represents a change of the object s state. In Cockburn et al \ns approach, they represent the state variable as a separate column under the object. Then, the assignment \nis shown as a change a value associated with the column. Addendum to the Proceedings 4. Separation \nof control from sequence? Timethreads abstracts control from sequence, that is, who is in charge of sending \na message is separated from because a message will be sent before anther message. In a diagram, this \nshowed with removing arrowheads from lines. 5. Abstraction layers in use cases/diagrams. Use cases can \nbe expressed in terms of structural elements at any level of abstraction of a system. 6. Notation for \nobject relations in interaction diagrams. Use a separate diagram and relate the resulting two diagrams \nto each other. For example, through letting both of them visualize the same use case. 7. Relation between \nuse cases and interaction diagrams. One to many.  8. Top view versus time view. See Cockbum s position \npaper. Both of them are needed.   2.2. Grey In terms of use cases, you localize objects. But when \nthe views are merged, how do you handle name conflicts? Implications on usefulness of use cases to identify \nsystem behavior when there are no users (i.e the users don t know what they want to do with the system). \nE.g., in the design of research systems, where the developers must synthesize the use cases. How do use \ncases relate to prototyping? How do use cases help to build reusable subsystems instead of building components \nat lower level of granularity? 2.3. Research 2.3.1. General 1. Is it important to define use cases from \na high, abstract level rather than from the level of messages and pseudo code of an underlying language? \n2 What do we mean by (or include in) the term use case ? 3. Use cases appear to be a powerful and useful \nconcept for designing and integrating system development, but how does one identify them properly in \nterms of level of abstraction and granularity?  4. How do we evaluate the goodness of use cases, does \nit exist some evaluation criteria?  OOPSLA 92 5. What are the impacts of having a closed system view, \nthat could be decomposed recursively, of use cases.  6. Are TDMF inherently unstable? If they are, should \nwe maintain them after the design phase? 7. What makes a behavior description of a system object-oriented? \n 8. What is the semantic domain of use cases? 9. In the book OOSE, use cases are considered objects. \nHowever, there is not much going beyond that in terms of the utility of the representation, especially \noperations on use cases.   2.3.2. Informality Use cases &#38; scenarios retain the intention (the why \n) of the design. Doing this, they will always be incomplete. How do we refine it to completeness? Why \nis it that readers don t get a pictorial feel for the architecture of a system by looking at the time \nview of TMFD? Should use cases be descriptive exemplars or complete specifications? A use case is a description \n(exemplar) rather than a specification. We, as people, expand the exemplars to fill a range of validity. \nA range that formal specification, until the techniques improve, has difficulty to fill. What method \nshould be followed to refine timethreads without control to timethreads with control ? Some external \nscenarios only appear during the internal design. that is, the external scenarios cannot be extracted \ndirectly from users needs but from internal behavioral models, such as Object Life Cycle Modelling. This \nwas offered as a single observation, and it needs further investigation. 3. Summary Most of the issues \nthat the workshop categorized as solved dealt with techniques for describing the usage at the design \nlevel. Here, a general term for the diagram techniques, Temporal Message Flow Diagrams, was rediscovered. \nIn the research category, one open question is how to interpret a description (of use case, timethrcads \netc.). Should a human reader interpret it as an example or as a complete specification? If the former \nsimplifies the transfer of the system s intention, then the human reader probably prefers it. What s \nmore, the exemplar interpretation also would satisfy one important axiom of object-orientation, to make \nsoftware systems understandable to non-computer scientist. Obviously, this workshop dealt more with use \ncases than with other usage describing concepts. On the other hand, the findings of the workshop are \ngeneral enough to apply to other concepts. For example, a developer can choose threads of execution, \nscenarios, or mechanism and still face the pros and cons identified in Wallin s paper. Now that we have \nidentified the need for usage models, how do we compare them. I would like to end with two questions \nfor future workshops a) Given a usage model of a system, what makes it suitable for object-oriented systems? \nb) What makes a usage model better from a system development point of view? 4. Participants To all of \nyou, thank you for creating an interesting and enjoyable workshop at OOPSLA 92. Your enthusiasm and interest \nin the subject we worked on made it my best day of OOPSLA 92. We have created a mail daemon at Objective \nsystems, usecase@os.se. The daemon will distribute your mail to all of the persons below. Alistair Cockbum, \nIBM Application Development Consulting Practices, alistair@vnet.ibm.com Barbara McAdorey, BNR, barbie@bnr.ca \nBrent Knight, student, bknight@sanjuan.uivc.ca Chamond Liu, IBM, chamond@vnet.ibm.com Doug Bennet, 76665.172@COMPUSERVE.COM \nFredrik Lindstrom, Objective systems SF AB, freli@os.se Ivar Jacobsson, Objective systems SF AB, ivar@os.se \nKatherine Betz, IBM, katherine@vnet.ibm.com Raymond Buhr, Carleton University, buhr@sce.carleton.ca Robert \nCoyne, Carnegie Mellon University, Robert.Coyne@cs.cmu.edu Sakam Zanato, University de Brest, zamata@ubolib.cicb.fr \nStaffan Enebohm, Ericsson Telecom, staffan@aom.ericsson.se Stefan Wallin, Erisoft AB, Stefan.Wallin@sa.erisoft.se \nSteve Goetz, IBM, goetze@vnet.ibm.com 5. References Cockbum, A. A. R. (1991). A Formalization of Temporal \nMessage-Flow Diagrams. In B. Jonsson, J. Parrow, &#38; B. Pehrson (Eds.), Protocol Specification, Testing, \nand Verification. Elsevier Science Publishers, B.V. (North-Holland). Cockburn, A. A. R., &#38; Citrin, \nW. (1991). An Executable Specification Language for History- Sensitive Systems. (Computer Science No. \n74762). IBM Research. Jacobson, I.,Christersson, M., Jonsson, P., &#38; overgaard, G. (1992). Object-Oriented \nSoftware Engineering. Wokingham: ACM Press. Katz, R. H. (1990). Toward a Unified Framework for Version \nModeling in Engineering Databases. ACM Computing Surveys, 22(4), 375408. Contact information: Fredrik \nLindstrom Objective Systems SF AB Box 1128 S-164 22 Kista Sweden E-mail: freli@os.se Phone: +46 8 703 \n45 42    \n\t\t\t", "proc_id": "157709", "abstract": "", "authors": [{"name": "Fredrik Lindstr&#246;m", "author_profile_id": "81332512924", "affiliation": "", "person_id": "PP31087347", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157732", "year": "1992", "article_id": "157732", "conference": "OOPSLA", "title": "Experiences of use cases and similar concepts", "url": "http://dl.acm.org/citation.cfm?id=157732"}