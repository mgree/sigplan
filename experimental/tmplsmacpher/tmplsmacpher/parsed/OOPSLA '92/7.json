{"article_publication_date": "12-01-1992", "fulltext": "\n Addendutn A 92 to the Vancouver, British Columbia, Canada 5 - 10 October 1992 Proceedings Experience \nReport- Development of Reusable Test Equipment Software Report by: Alan Dotts Don Birkley Tektronix \nInc. Introduction In 1986 Tektronix Oscilloscope group began a new project with three goals in mind: \nCreate two families of digital oscilloscopes Provide a platform for future product development Provide \na common look and feel to the user interfaces of the products based on this code A small team was assembled \nto define and investigate the project. The software team was intent on improving productivity by building \nan environment that would take advantage of the most advanced tools available, and encourage the development \nof reusable software modules. The project occurred in toughly three phases: Search for technologies and \nmethodologies Design and implementation of prototype code, and development of key tools The implementation \nof production software  Search for New Technology A significant amount of time was invested researching \ndevelopment environments. Object 5-10 October 1992  UshgDSmalltalk and C oriented design looked promising \nand several languages and environments were studied. To achieve the common look and feel goals it was \nimportant to have an environment which allowed user interfaces to be prototyped and tested quickly. F \nrototyping of the user interface began using Smalltalk-80. Smalltalk was found to be a very powerful \nfast prototyping environment. The user interface prototype and simulator were up and working very quickly. \nThe Smalltalk development environment was impressive, but considered inappropriate for embedded systems. \nSmalltalk was too big, too slow, and it would be difficult to solve the language problems associated \nwith getting Smalltalk into ROM. C++ was examined and eliminated due to its very limited class libraries \nand development environment at the time. Objective C1 looked promising. It had many of the advantages \nof the Smalltalk environment in terms of object paradigms, simple object syntax, polymorphism, basic \nclass libraries, and reasonable debugging facilities. It was expected that Objective Objective C is a \ntrademark of Productivity Product International -31-Addendum to the Proceedings C would be smaller, \nfaster, and easier to get into ROM than Smalltalk. A project to develop a new user interface for an older \nproduct provided an opportunity to test Objective C. The Smalltalk user interface simulator was used \nto simulate the new menus for this older product. The code was then ported to Objective C. The port turned \nout to be nontrivial. As it turned out, Objective C did not offer significant speed advantages over Smalltalk, \nthere were problems getting the Objective C class libraries into ROM, and the ROM and RAM requirements \nwere larger than expected. At this point the job of porting this code to C looked easier than continuing \nwith Objective C. The port to C went quickly and the menus were running in the embedded instrument in \nabout three weeks. The code produced in this experiment benefited greatly from the object oriented design \nin the Smalltalk prototype. This code was cleaner, more compact, and easier to understand than previous \nefforts using C alone. The disadvantage with this approach is that the code had to be maintained in the \nC environment. The original Smalltalk prototype could be refactored and evolved much more easily than \nthe menu code that had been ported to C. In spite of the maintenance issues it still seemed that our \nbest strategy for delivering a product to market was to prototype the code in Smalltalk and rewrite in \nC for the production code. The team was continuing to grow and many of the oscilloscope subsystems were \nbeing prototyped in Smalltalk. The experiences with the Smalltalk development environment were continuing \nto be quite positive. At this point we were approached by Dave Thomas of Object Technology International \n(OTI). OTI had been working on tools for embedded Smalltalk development. Tektronix contracted with OTI \nto provide production quality tools for embedded Smalltalk development. These tools allowed us to: Efficiently \nROM the Smalltalk image and interpreter Call C functions from Smalltalk for low level hardware access \nManage the various configurations of Smalltalk code easily Design and Prototype Phase During the design \nphase we concentrated on creating reusable components. Several things helped make the code more reusable: \nFrameworks of pluggable components were created. For each framework there was a list building blocks \nfrom which the desired functionality could be created. The user interface tool kit was the most successful \nexample of this. The class descriptions were separated from the code which created and initialized instances \nof objects. This was done using configuration files that were created for each menu and each major subsystem \nin the oscilloscope. Each configuration file contained Smalltalk code which created the major objects \nand initialized the instance variables. For example: The rules for allocating digitizer hardware resources \nbetween input channels could be put into one of the configuration files. If a new instrument with different \ndigitizer hardware or number of input channels was created the rules for allocation could be modified \nin the configuration file, and the associated Smalltalk class would not have to change. A virtual hardware \nlayer was created. A set of standard interfaces to the hardware was defined. These interfaces were to \nbe used by any follow on products and the code above could be reused. The concept of a class was extended \nto the C code. A directory structure was created that mirrored the organization of the Smalltalk code. \nPrototyping helped to iterate to a more reusable solution. During this phase team members were designing \nthe subsystems, creating prototype code, and supporting the hardware teams. Design reviews and code walkthroughs \nwere held. By the end of this phase prototype code was running which implemented much of the functionality \nof a scope. There was still much concern about the speed of Smalltalk. Significant effort was spent optimizing \nthe user interface code at the expense of flexibility. As the project progressed however, features were \nadded, and requirements changed. The lack of flexibility became a major issue. The code was rewritten \nto add some of the flexibility of the original prototype and speed was acceptable. Implementation of \nProduction Software Management changed the focus of the project at this point. Instead of creating a \nreusable platform the team was directed to get two products to market as quickly as possible. Reusability \nand extensibility suffered, as designers were forced to deal quickly with issues that did not quite fit \ntheir models. Much of the prototype code was discarded. However, some sections of the code, like the \nuser interface, had been refactored several times, and were left in tact. OOPSLA 92 -32-Vancouver, British \nColumbia The unsuitability of the code was the result of both lack of Smalltalk experience in the original \ndesign team and lack of clear architecture definition at the beginning of the project. The biggest problem \nwith this code base is a lack of good architecture. The architecture which does exist in our system was \nthe result of the combined efforts of several of the senior designers. The single most important thing \nwhich could have been done to improve the reusability of this code and decreased time to market would \nhave been to have assigned a system architect to the project. The code was integrated on a weekly basis \nduring this phase of the project. This proved to be very useful. It allowed us to keep a close watch \non incompatibilities between subsystems and deal with them quickly.  Code Structure The code can be \ndivided into three sections: 9 The user interface code, written in Smalltalk. 9 The model layer written \nin both Smalltalk and C. This layer defined the oscilloscope architecture, the high level instrument \ncontrol code, and the hardware drivers. The hardware drivers were written in C, and the other code was \nwritten in Smalltalk. The real time system, written in C and assembly language. Results In June of 1991 \nthe first two products using this code base, the TDS520 and TDS540, were introduced. These products have \nbeen very successful. In the year and a half since that time we have produced a second major release \nof the base code with an enhanced feature set. In addition three new major product families, a total \nof seven new products, have been delivered to market. The TDS420 and TDS460 were introduced in January \n1992, the TDS620 and TDS640 in February 1992, and the TDS820 in April 1992. The cost and time for developing \nthe original two instruments was consistent with previous product development cycles of this magnitude \nat Tektronix. The cost and time for developing the follow on products has been significantly lower than \nprevious attempts. The quality of this product has greatly exceeded that of previous products. The fact \nthat relatively little time has had to be spent on bug fixes has allowed more rapid development of follow-on \nproducts. Code generated: Smalltalk classes -450 classes -8000 methods Smalltalk Configuration code \n-9500 lines C code -50,000 Reuse experienced: Smalltalk classes I -90% I Smalltalk configuration -60% \nC code -60% The high reuse numbers achieved in the Smalltalk configuration code was due to the common \nlook and feel in the user interface. Since the user interfaces between the follow-on products are all \nsimilar most of the user interface configuration code could be reused.  Observations Most of the people \non this project were experienced software engineers. Many had been involved with the development of several \noscilloscopes. There was very little Smalltalk experience at the beginning of this project, however. \nThe people who knew Smalltalk at the beginning of the project created the most reusable code. Those who \nlearned Smalltalk and made a serious effort to create reusable modules improved their skills significantly. \nSmalltalk provided a very nice environment for fast prototyping and development. The class libraries \nprovided good basic software functionality. The debugging facilities allowed for very fast turn around \nwhen fixing problems in Smalltalk. A significant amount of reusable code was created. The user interface \ntool kit is an excellent example of generic modules. In addition abstract code modules were created for \nother oscilloscope functions. The tools provided by OTI worked well. In particular ENVY/Manager2 , the \nconfiguration management tools provide a mechanism for defining class ownership and merging the code \nfrom large groups of people. They give the programmer easy ways to develop and test code without causing \nproblems for other developers. They provide the system integrator the ability to easily define and version \nany configuration of code desired. 2 ENVY is a trademark of Object Technology International Addendum \nto the Proceedings S-10 October 1992 -33- The mixed environment caused a number of problems: Debugging \nacross the C/Smalltalk boundary was difficult. The Smalltalk debugger is a very nice tool, but does not \ncross the C/Smalltalk boundary. When debugging across this boundary multiple debugging environments are \ninvolved and debugging is more difficult. Smalltalk and C do not share the same name space. If a Smalltalk \nobject is passed from SmalItalk to C, a,C data structure must be created which maps onto the object. \nMaintenance issues arise when instance variables are added or deleted from the class. If the C data structure \nis not updated to reflect these changes errors occur. To limit this problems most of the parameters passed \nbetween C and Smalltalk were integers. Even when passing integers problems would occur when we were passing \nenumerated types like Red, Blue, and Green. Corresponding header files and pool dictionaries were created \nin order to access these settings by the same names in both languages. To keep the header files and pool \ndictionaries synchronized a tool was created to generate these from a common source file. 9 Training \nwas more time consuming and more difficult in the mixed environment. The environment required multiple \nbuild procedures and environments. One each for Smalltalk and C and a third to link the two together. \nThe Smalltalk configuration management tools did not extend to the C world. We created our own configuration \nmanagement tools for C which worked reasonably well but have not scaled well as more instruments are \nusing the base code. The ROMing tools were the first of there kind for the Smalltalk environment. We \ncould not have done this job without them, but they suffered from two basic problems: The ROMing tools \nfor Smalltalk were quite slow. Because of the amount of speed and space optimization required the time \nneeded to convert from a development image to ROMed image was approximately six hours. Any error found \nafter ROMing was tedious to fix and verify. Errors could be made in the ROMing specification process. \nThese errors could not be detected until after ROMs had been created, at which point they were difficult \nto debug. Effort was expended in limiting garbage creation in an attempt to reduce both ram usage and \ngarbage collection time.  Continued Development The investment in this code base is significant. To \nprotect this investment a team has been put into place to manage the reusable pieces of this code base. \nThe charter of this group is to provide product teams with clean reusable code modules, to identify and \ndocument reusable design work and to define a migration path to the next generation software platform. \nOur future success depends on our ability to maintain and improve the code base. This requires careful \nmanagement of changes and coordination of the product groups using the code. The long term viability \nof the library depends on carefully adding appropriate functionality as required for new products. A \nprocess must be established for applications developers to make change requests to the base code. They \nare the customers of this code and if it can not meet their needs then it has no reason for existing. \n Conclusions The SmalltalkK combination provides a very good environment for prototyping and developing \nembedded systems applications. The advantages of Smalltalk and object oriented design were realized in \nthe user interface tool kit, and abstract models for triggers, acquisition systems, and other oscilloscope \nsystems. The code written in Smalltalk is the most reused in the system, but is not efficient when directly \naccessing the hardware. The ability to call C solves this problem. The ENVY/Manager provides excellent \nconfiguration management tools. There is a cost associated with reusing code. A code base which is not \nmanaged will be copied until there is no base left. A code base which is not upgraded will soon become \nuseless. Training requires more time and effort in a mixed environment. OOP is not a replacement for \ngood design or architecture. Our project benefited from the fact that we were under pressure to create \na real product. Early in the project emphasis was placed on creating code that would be highly reusable. \nOur most successfully reused code however, evolved from code which was written to solve specific problems \nin the product. OOPSLAW 34-Vancouver, British Columbia While it is important to consider reuse in the \ndesign phase, code that was written from the start with reuse as its primary goal was often too complex \nand too general to work well. The need to deliver a product to market forced us to create usable code. \nIf we had continued trying to achieve the ultimate in reusable code we might not have finished anything. \nWe now have the opportunity to continue to develop and benefit from the use of this code base. 5-10 \nOctober 1992 Addendum to the Proceedings   \n\t\t\t", "proc_id": "157709", "abstract": "", "authors": [{"name": "Alan Dotts", "author_profile_id": "81100641027", "affiliation": "", "person_id": "P12382", "email_address": "", "orcid_id": ""}, {"name": "Don Birkley", "author_profile_id": "81100073352", "affiliation": "", "person_id": "P67957", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157716", "year": "1992", "article_id": "157716", "conference": "OOPSLA", "title": "Development of reusable test equipment software using Smalltalk and C", "url": "http://dl.acm.org/citation.cfm?id=157716"}