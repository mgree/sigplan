{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 to the Vancouver, British Columbia, Canada 5-10 October 1992 Proceedings Invited la/k- \n The End of Objects and the Last Programmer Report by: Grady Booth Rational In 1989, Francis Fukuyama, \na former deputy director of the U. S. State Department s Policy Planning Staff, wrote an article for \nNational Interest, entitled The End of History, in which he asserted that recent dramatic world events, \nincluding the dissolution of the USSR, represented a fundamental and final change in the evolution of \ngovernments. In 1992, he expanded upon this article in his book The End of History and the Last Manl. \nHis observations regarding the state of global affairs and the role of the individual in such matters \nhave a intriguing parallel to the growth and maturation of object- oriented technology. Consider for \na moment Fukuyama s premises. He suggests that there are two motors of history, which drive the evolution \nof all social institutions. First, there is the logic and direction of modem science. Scientific inquiry \nis a rational process whose resulting knowledge is cumulative and, ultimately, irreversible (although \nsome knowledge may be lost, the underlying truths upon which this knowledge is founded persist, leading \nto their eventual rediscovery ). The fruits of science greatly affect the distribution and efficient \nuse of scarce human and natural resources, serve as a tool for governments (particularly, as a means \nof affecting the outcome of military actions), permit 1 Fukuyama, F., The End of History and the Last \nMan. 1991. New York, New York: The Free Press. S-10 October 1992 the creation of new economic markets, \nand, ultimately, directly influence the quality of life for the individual. The second motor of history \nis the individual s struggle for recognition. This innate drive for significance and meaning in the presence \nof a much larger and potentially dehumanizing society causes individuals to fight for human dignity, \nto rise above their current conditions, and in the process, change themselves and often change the nature \nof the social institutions around them. Fukuyama observes that these two forces tend to drive even culturally \ndisparate societies toward capitalist democracies2. Consider, for example, the rate at which free international \nmarkets and representative governments have been adopted during the past few decades. Today, democratic \ngovernment is the dominant social structure, whereas in the 1700 s, such structures were largely experimental \nFukuyama speaks of this as marking the end of history, because it represents a logical, stable, and final \nsocial organizatiod. Fukuyama goes on to 2 Capitalist, in the sense of supporting free market economies; \ndemocratic, in the sense of establishing a participatory form of government. 3 As Larry Constantine has \npointed out to me, we must always be wary of such sweeping conclusions. Every age has generally viewed \nitself as the pinnacle of human achievement, which no future generation could ever -3 -Addendum to the \nProceedings observe that such an end of history engenders a crisis in the spiritual condition of man, \nmanifest in the homogenization of society. The role of the so- called last man in this age is strikingly \ndifferent than in previous ages. As we study the growth and maturation of the computer sciences over \nthe past half-century, we find markedly similar circumstances. We suggest that there are two motors that \ndrive advancements in software development. The first of these is the logic and direction of modem software \nengineering. Although we hesitate branding this as a science4, there has indeed been a clear, observable, \nand directed advancement in the industry s approach to the theories underlying software development. \nSecond, software development represents a struggle against complexity. In the words of Fred Brooks, complexity \nis an essential, not an accidental, property of all software. Our premise is that these forces drive \nus toward object-oriented technology. To paraphrase Fukuyama, we speak of this as the end of objects, \nmeaning not that the object-oriented paradigm is already passe, but rather, that this paradigm denotes \na logical, stable, and final organizing principle for software development. As a consequence, this leads \nus to consider the role of the individual developer (the so- called last programmer ) in the presence \nof this stable state. Perhaps the most significant trend in software engineering has been the drive toward \nmore expressive forms of abstraction. Starting with a focus upon algorithmic abstraction in the 1950s \nand OS, the 70s brought about a greater focus upon data abstraction and now, fueled to a large measure \nby work in abstract data types in the 70s and 8Os, there is a focus upon object-oriented abstraction$. \nAs Yonezawa and Tokoro point out, the term object emerged almost independently in various surpass. The \nsame lesson undoubtedly applies to object- oriented technology and software-engineering in general. 4 \nA truly scientific discipline is characterized by controlled experimentation and rational inquiry that \npermits the presentation of theories and then the validation or disputation of those theories in a repeatable, \nopen fashion. Relative to the maturation of disciplines such as physics, chemistry, or mechanics, the \nfield of software engineering is comparatively at the level of banging rocks together. 5 Actually, it \ngoes back much further in history than this. Aristotle is perhaps the first person to have articulated \nthe dichotomy of process- versus object-oriented abstraction. fields in computer science, almost simultaneously \nin the early 1970s. to refer to notions that were different in their appearance, yet mutually related. \nAll of these notions were invented to manage the complexity of software systems in such a way that objects \nrepresented components of a modularly de- composed system or modular units of knowledge representatiot6. \nLevy adds that the following events have contributed to the evolution of object- oriented concepts: 0 \nAdvances in computer architecture, including capability systems and hardware support for operating systems \nconcepts . Advances in programming languages, as demonstrated in Simula, Smalltalk, CLU, and Ada . \nAdvances in programming methodology, including modularization and information hiding We would add to \nthis list three more contributions to the foundation of the object model: * Advances in database models \nResearch in artificial intelligence Advances in philosophy and cognitive science These lists suggest \na remarkable confluence of ideas in very disparate elements of the computer sciences, all pointing toward \nobject-oriented abstractions. With regard to the struggle against complexity, Dr. Tim Standish has pointed \nout that one can never eliminate the complexity inherent in a software system, one can only hope to manage \nthat complexity8. We have elsewhere suggested that all well-structured systems that exhibit such organized \ncomplexity share five common characteristics: Complexity takes the form of a hierarchy The choice of \nwhat components in a system are primitive is relatively arbitrary and is largely up to the discretion \nof the observer Intracomponent linkages are generally stronger than intercomponent linkages Hierarchical \nsystems are usually composed of only a few different kinds of subsystems in various combinations and \narrangements 6 Yonezawa, A., and Tokoro, M., 1987. Object-Oriented Concurrent Programming: An Introduction, \nin Object- Oriented Concurrent Programming. Cambridge, MA: The MIT Press, p. 2. 7 Levy, H., 1984. Capability-Based \nComputer Systems. Bedford, MA: Digital Press, p. 13. 8 Private communication. A complex system that works \nis invariably found to have evolved from a simple system that worked9 In all fairness, it is important \nto point out that there are local disturbances to this other wise pristine picture of the object-oriented \nworld. Business and economic factors introduce noise to this picture, manifest in a number of technology \nbattlegrounds for which sometimes the biggest or first, not necessarily the technically superior, controls \nthe outcome. For example, we see such conflict in the domain of operating systems (DOS versus Windows/NT \nversus UNIX versus OS/2-the list goes on and on). Interestingly, however, the most recent generation \nof such operating systems at least present an object-oriented model to the user and some, such as Taligent \ns forthcoming operating system or Microsoft s Windows/NT, have a much deeper object-oriented infrastructure. \nA related battle is playing itself out in the domain of graphical user interfaces (Motif versus OpenLook \nversus Windows versus the Macintosh look and feel-and again the list continues). Continuing, there are \nfierce language wars ongoing (C versus C++ versus Smalltalk versus Ada versus Cobol) but again, the clear \ntrend in modem programming languages has been the drive for support of the object-oriented paradigmlO. \nPartly fueling these rather localized skirmishes1 1 are two fundamental technology trends, including: \nThe drive toward greater distribution and connectivity, together with vastly increased bandwidth of networks \n. The dramatic decline of the cost of MIPS and memory, culminating in what amounts to surplus computing \nresources at the hands of the individual 9 Booth, G., 1991. Object-Oriented Design with Applications. \nRedwood City, California: Benjamin/Cummings Publishing Company lo Consider in particular the evolution \nof C++ from C, the adoption of object-oriented constructs by Ada in AdBx, and the consideration of object-oriented \nextensions to Cobol. l1 We don t mean to sound flippant, but most of these battles are indeed localized \nskirmishes. A decade from now, we will look back and find that-through technical or numerical superiority-some \nwinner will emerge. Predicting which one will win is the domain of the soothsayer, but participating \nin the dance of inventing new technology that ultimately adds value to the discipline of software development, \nis what makes this business so much fun This drive toward object-oriented abstractions, fueled by social \nand economic pressures that drive us to automate more and more domains, has lead to the application of \nthe object-oriented paradigm to virtually every computational domain. At one extreme, we have encountered \nsystems of global significance, such as for multinational banking, or Singapore s effort to computerize \nmany aspects of its people s daily life, for which the object-oriented paradigm is viewed as perhaps \nthe only means of economically architecting an enduring system. At the other end of the spectrum, we \nhave encountered the use of the object-oriented paradigm for such singular domains as pacemakers, the \nautomation of bowling alleys and cookie production, and the management of public utilities. This indeed, \nin a manner of speaking, represents the end of objects: object-orientation, in the steady state, is a \nstabilizing principle upon which we can organize the broadest spectrum of complex software systems12. \nStill, we observe that even in this steady state, software development will continue to involve a sea \nof strategic and tactical details. Ultimately, the speed and accuracy with which we can develop becomes \na fundamental limiting factor in our ability to produce software. The element of the object-oriented \nparadigm that makes this such a stabilizing principle is that of architecture, or, again in Fred Brooks \nterms, conceptual integrity. Consider architecture as viewed by architects of physical structures. This \ndiscipline distinguishes architecture from accidental organization by its: . Suitability for use by \nhuman beings in general and its adaptability to particular human activities . Stability and permanence \nof its construction . Communication form of experience and ideas through Structures such as cathedrals \nare typical of this model. The craft of designing cathedrals perhaps reached its pinnacle in the Middle \nAges: cathedrals such as the Yorkminster represented public facilities intended to last for centuries, \nand required a clear architectural vision, since the structure would likely l2 We completely acknowledge \nthat not all domains are well-suited to the object-oriented paradigm, just as a liberal democracy is \nnot well-suited to, for example, a nation emerging from a massive and overwhelming natural disaster. \nHowever, our discipline is sufficiently immature, such that we do not yet have sufficient information \nto predict what domains are most applicable, and what are not. not be completed in the lifetime of its \noriginal architect. Now, software systems are not yet so long lived, but the fluidity of our industry \ndemands a similar focused architectural vision. Indeed, of the hundreds of object-oriented software developments \nwe have encountered (many successful, several unsuccessful), the singular characteristic present in all \nthe successful projects, and missing in the unsuccessful ones, was that of an architectural vision. We \ndefine architectural vision as the crafting of systems that are constructed in well-defined layers of \nabstraction, for which there is a clear separation of concerns between the interface and the implement- \nation of each layer; ultimately, we seekto build simple architectures, in which common behaviors are \nachieved through common mechanisms. We cannot state this point strongly enough: at all times, it is essential \nto maintain a clear vision of the system s strategic and tactical architecture. Back to physical architectures, \nwe may classify different structures by their form and function. Thus, we speak of domestic, religious, \ngovernmental, recreational, educational, and commercial architect- ures. Each genre of structure is so \ndenoted by a unique set of properties. So it is with object-oriented software systems. Among the well-structured \nsystems we have encountered, we have observed the following kinds of software architectures: Client/server \nGUI-centric DBMS-cent&#38; Intermediate representation-centric Blackboard Subsumption13 These all represent \nstrategic architectures, meaning that they have a sweeping, global impact upon the overall origination \nof a system. On a more local level, we have the tactical architecture, which affects the patterns whereby \nobjects collaborate with one another. l3 Most of these kinds of architectures are likely intuitive, except \nfor the last category. The concept of subsumption architectures has been pioneered by Dr. Rodney Brooks, \nof the MIT Artificial Intelligence Laboratory. Dr. Brook s work focuses on the creation of small, autonomous, \ninsect-like robots. In subsumption architectures, there is no central locus of control; rather, each \nsubsystem independently is responsible for a small set of behaviors and, like Minsky s concept of the \nsociety of mind, work together to form a whole whose behavior is much greater than that of the individual \nparts. Return again to the domain of physical architectures. At the time of Michaelangelo, the study \nof machines had led to the codification of certain kinds of simple machines, which-when assembled in \nways unique to the given problem-provided some essential behavior. This classification of machines included \nscrews, levers, gears, couplings, and belts14. Restating this in software terms, we call such simple \nmachines mechanisms. Simply stated, a mechanism provides some system behavior through the behavior associated \nwith a set of objects. In all non-trivial systems, we find such patterns of collaborating objects; in \nwell-structured object-oriented systems, we usually find a small set of well-engineering mechanisms, \nwhich are reused throughout the system. Because such abstractions are pervasive, it is for this masons \nthat we state the class is a necessary but insufficient unit of decomposition. In other words, all non-trivial \napplications demand the presence of abstractions that cannot properly be captured in a single cla&#38; \n. Just as for strategic architectures, we have observed a number of different kinds of mechanisms in \nwell- structured object-oriented systems: 9 Dependency Event handling Error detection Memory management \nDrawing Messaging Persistence Ergo, we are arguing that, at the end of objects, the object-oriented \nparadigm continues to scale up: both strategic and tactical architectures are amenable to the object-oriented \nparadigm. Why then do we say that, even at the end of objects, software development involves a sea of \ndetails? The root of this problem lies with the central problem of all things object-oriented: the discovery \nand invention of objects, or-in direct terms-how do we figure out what objects and classes to use in \nour system? Classification is at the heart of this problem, for classification is the means whereby we \norder l4 In all, about 20-25 different kinds of machines. K5 For example, the MVC paradigm in Smalltalk \nis not defmed by any single class, but requires knowledge of this triad of classes; in C++, a single \nclass is insufficient to express the abstraction of an entire GUI, such as Motif; rather, such a facility \nis best expressed as a set of collaborating classes. knowledge. Recognizing the sameness among things \nallows us to expose the commonality within key abstractions and mechanisms. Unfortunately, our problem \nis made difficult, because there is no such thing as a perfect classification: there are profound classifications, \nand there are profoundly stupid ones-the role of the architect requires an ability to distinguish between \nthe two. The fact that classification is central to all things object-oriented is what requires object-oriented \nsoftware development to be both iterative and incremental16. We speak of development as being iterative \nbecause it require several cycles throughout the analysis/design/implement process; it is incremental \nbecause, at each cycle, we seek to reach closure a little bit at a time. Of course, left to their own \ndevices, programmers often never reach closuret7. As Humphry has observed, the degree of discipline that \nexists in a software development organization is a measure of its maturity. He has proposed the following \nlevels of process maturity: Chaotic Repeatable Defined Managed Optimizing At the level of chaosl* , the \ndevelopment team is in freefall, meaning that the iterative and incremental process is out of control. \nIn well-structured object-oriented systems, we have observed that there exists a balance between the \nunrestrained efforts of individual developers (which we speak of as the micro process of development) \nand a broader, disciplined effort by the team as a whole (which we speak of as the macro process). Stated \nanother way, the micro process is closely related to Boehm s spiral model, and serves as the framework \nfor an iterative and incremental approach to development; the micro model is what he individual developer \ndoes on a day to day basis. The macro process is more closely related to the traditional waterfall lifecycle, \nand serves as the controlling framework of the micro process; the macro model involves the successive \nrefinement of architectural prototypes, each of l6 Actually, the problem of classification is central \nto every scientific discipline. l7 Wherein Boehm s spiral model of software development becomes a death \nspiral. l* Unfortunately, the most common state of most software development organizations. which moves \ncloser to the ultimately desired functionality of the end system. This leads us to now consider the role \nof the individual developer (the so-called last programmer ). To this end, we distinguish among opposing \nroles. First, we have the hacker versus the team player. The image of the hacker as the lone, Rambo-style \nprogrammer is appealing, perhaps because-given the fluidity of software-anything is possible: it s just \na simple matter of programming. Indeed, some killer applications have emerged from lone developers (consider \nVisiCalc, the forerunner to a whole industry of personal productivity tools such as Lotus l-2-3, and \nwhich in turn helped fuel the dramatic growth in sales of personal computers). The problem with relying \nupon the individual super- developer is that economics dictate that most of the world s software development \nbe achieved by mere mortals and we as an industry cannot really upon the (unpredictable) breakthroughs \nof individuals19. For this reason, we must consider, in the steady state, the last programmer as a team \nplayer. Similarly, we have the analysis versus the designer versus the coder. In some organizations, \nthese roles are strongly institutionalized-to the degree that some organizations build separate buildings \nfor each group of people! Given the incremental and iterative nature of object-oriented software development, \nwe prefer to consider a subtly different structure: the abstractionist versus the implementor. Our experience \nhas been that, in most object-oriented developments, some but not all of the developers have sound skills \nin finding and articulating abstractions, whereas others are better suited to taking such abstractions \nand assembling them to form some meaningful application. In the healthiest projects, there is a mutual \nrespect between both kinds of developers, and a reasonable and manageable tension between the generality \nand pragmatics that each group, respectively, focuses upon. A project staffed with no abstractionists \nwill generally never settle upon a resilient architecture, and similarly, a project staffed with only \nabstractionists will tend to over-engineer the architecture, and devise unimplementable mechanisms. l9 \nAlthough, in our industry, we seem to be able to create whole new markets overnight through the efforts \nof such individuals.  Contact Information: Grady Booth Rational egb@rational.com  \n\t\t\t", "proc_id": "157709", "abstract": "", "authors": [{"name": "Grady Booch", "author_profile_id": "81100557878", "affiliation": "Rational", "person_id": "PP31047618", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.377098", "year": "1992", "article_id": "377098", "conference": "OOPSLA", "title": "The end of objects and the last programmer (Invited talk)", "url": "http://dl.acm.org/citation.cfm?id=377098"}