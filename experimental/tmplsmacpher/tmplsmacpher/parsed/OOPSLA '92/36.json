{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 to the Vancouver, British Columbia, Canada 5 - 10 October 1992 Proceedings Poster Submission- \n A Proposal for Object Oriented Modula-2 Report by: Richard Thomas Queensland University of Technology \n Introduction Object Oriented Modula-2 (OOM (pronounced ohm }) is a true object oriented superset of \nModula-2. OOM is currently a research project at the Queensland University of Technology. The language \nhas been designed over an extended period of time. Each new feature of the language was examined and \ncompared against many other object oriented languages. During the design of the language many examples \nwere hand compiled to ensure that the final language was usable, consistent, and produced correct code. \nOOM is planned to be a preprocessor that takes in OOM code and outputs IS0 Modula-2 code. At this point \nin time the OOM preprocessor is currently being written. In this paper all of the proposed extensions \nto Modula-2 will be considered, and comparisons will be made with Modula-3 and Oberon-2 to show the niche \nthat OOM fills in the language field.  TheLanguage The major extension to Modula-2 has been the addition \nof a reserved word CLASS which is a new type. A CLASS is a template of an object, encapsulating both \nthe data and the methods as features of the CLASS. Variables of type CLASS then become objects that embody \ntheir data and access to the routines that manipulate their data. The new CLASS type has the facility \nto separate the class interface from its implementation. Anything declared in a class interface is a \nvisible component of an object of that class. Any code that has an object in its scope can access any \nvisible component of that object. To access a visible component of an object a qualified identifier must \nbe used: objectName.visibleComponentName For a method to refer to the current object that this method \nis acting upon the method uses the built-in variable current, which is equivalent to Smalltalk s self \nidentifier [ 11. OOM does not have automatic memory management. Every CLASS has two methods, Create and \nDestroy, which it inherits from the base class ANY. The Create method is used to create a new object \nof this CLASS type and must be the first message sent to an object variable. The Destroy method is used \nto remove an existing object from memory. When an object variable is destroyed, or before it is created, \nthe variable has the value NIL. Both Create and Destroy can be redefined, like any other method, by the \nprogrammer to allow these methods to execute initialization or finalization code for the object, as well \nas their respective built-in operations. Inheritance is indicated in a CLASS through an INHERIT clause. \nMultiple inheritance is done by an inheritance clause listing more than one class. Multiple inheritance \nintroduces two difficulties to a language, name conflicts and repeated inheritance. Name conflicts between \ndifferent features of different classes are resolved by the programmer with an explicit RENAME list. \nAny class that is listed more than once in the INHERIT clause is just  5-10 October 1992 171-Addendum \nto the Proceedings considered to be inherited the one time, but all RENAME lists for that class are considered \nto have occurred, and are evaluated in the order that they appear in the INHERIT clauses. In the case \nof repeated inheritance through the superclass hierarchy, the repeatedly inherited class will be considered \nto have been inherited only once, but multiple copies of the class features will be allowed through the \nrenaming facility. Within a subclass a superclass feature may be redefined to do something different. \nTo ensure that superclass features are not accidentally redefined, each redefined feature declaration \nmust be preceded by the keyword REDEFINE. Any feature that is redeclared in a subclass, and is not preceded \nby REDEFINE, is a compile error. All objects in OOM are dynamically bound, allowing for polymorphic access \nto features. With dynamic binding and polymorphism an object can hold an object of its own class type \nor of one of its ancestor class types. Dynamic binding means that the actual feature that is accessed \nby a message might not be determinable until runtime.  Comparisons with other Modula-2 Descendants Oberon \nand Oberon-2 Professor Niklaus Wirth has designed Oberon as a successor to his now familiar language \nModula-2. Oberon itself has since been extended by Professor Wirth and his colleague Dr. Moessenboeck \nwith object oriented features, creating Oberon-2. One of the prime &#38;sign goals of Oberon and Oberon-2 \nwas to create a simple language. Oberon has a concept of type extension, allowing existing data definitions \nto be reused [2]. Type extension, in Oberon, is the facility to take a record type and use it as the \nbase for a new extended type. An extended type is then assignment compatible with the base type. Oberon-2 \nthen adds the facility of having type bound procedures 133. A type bound procedure is bound to a record \ntype and can only operate on variables of that type, or extended types. These facilities along with procedure \nvariables allow object oriented programming to be done in Oberon-2. Oberon-2 and OOM differ in the language \nfeatures that Oberon has eliminated from Modula-2. The greatest difference between OOM and Oberon-2 though \nis the style in which code is written. OOM s class type encapsulates data and operation not only in the \nview of the program but also visibly to the programmer reading the code. As there is no class in Oberon-2, \neven though data and operations are encapsulated conceptually, code and related data can be spread apart \nin locale. This style could tend to OOPSLA 92 make code less readable and not aid in the development \nof maintainable systems. Modula-3 Researchers at Olivetti and Digital developed Modula-3 to be a safe \nlanguage that would meet the needs of modem programmers [4]. Modula3 goes considerably beyond the scope \nof just extending Modula-2 with object oriented facilities. Modula-3 not only includes object oriented \nfeatures, but also includes exception handling, garbage collection, light weight processes (threads) \nand the containment of unsafe features within marked modules [4]. Although these other extensions have \ntheir own merit, they are beyond the scope and goals of the OOM project. There are differences in the \nobject oriented facilities that Modula-3 has compared with OOM. Modula-3 only provides single inheritance, \nwhile OOM has multiple inheritance. Inheritance in Modula-3 focuses on subtyping, whereas inheritance \nin OOM focuses on code reuse. Syntactically the declaration of a class is quite different between Modula-3 \nand OOM. In Modula-3 methods are only defined in the class declaration. Any procedure that matches the \nmethod definition can later be assigned to be used for that method. This system of attaching methods \nto classes is more flexible, and aid s code reuse with a subtyping system, but puts more work on the \nprogrammer to check which procedure is being used as a method at a particular time. The OOM system of \nclass declaration is simpler and more naturally reflects the idea of a class being a typed module (encapsulating \ndata and operations). OOM and Modula-3 have grown out of two very different research projects. Modula-3 \nis an extensive systems language with many features. Whereas OOM focuses on object oriented features, \nresulting in a small simple language. The simpler style of OOM allows the programmer trying to learn \nhow to program object orientedly to focus on the concepts of object oriented programming rather than \non the syntax of the language.  Conclusion As object oriented programming gain s popularity it is imperative \nfor tools to be made available that allow programmers to easily learn how to use this new methodology. \nThe OOM proposal is seeking to provide a tool that allows an easy path to learning the object oriented \nprogramming methodology. -172 -Vancouver, British Columbia References 1. Goldberg, A. and D. Robson. \nSmalltalk40: The Language and its Implementation. Addison-Wesley (1983). 2. Wirth, N. The Programming \nLanguage Oberon revision l/10/90 Swiss Federal Institute of Technology (1990). 3. Moessenboeck, H. and \nN. Wirth. Differences between Oberon and Oberon-2 Swiss Federal Institute of Technology (1991). 4. Cardelli, \nLuca et al. Modula-3 Report (revised). Digital Equipment Corporation, Ing. C. Olivetti and C., SpA (1989). \n  Contact information: Richard Thomas School of Computing Science Queensland University of Technology \nGF O Box 2434 Brisbane, Qld., Australia 4001 email: R.Thomas@qut.edu.au or richard@fitmail.fit.qut.edu.au \n 5-10 October 1992 - 173 -Addendum to the Proceedings  \n\t\t\t", "proc_id": "157709", "abstract": "", "authors": [{"name": "Richard Thomas", "author_profile_id": "81332531815", "affiliation": "", "person_id": "PP14146250", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157745", "year": "1992", "article_id": "157745", "conference": "OOPSLA", "title": "A proposal for object oriented Modula-2", "url": "http://dl.acm.org/citation.cfm?id=157745"}