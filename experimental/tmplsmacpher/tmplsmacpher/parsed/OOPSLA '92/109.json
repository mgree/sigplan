{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 to the Vancouver, British Columbia, Canada 5 - 10 October 1992 Proceedings  Educators \nSymposium- Teaching Object-Oriented Software Architecture by Example: The Games Factory Report by: Hermann \nHiini Jucker Informatik Igor Metz Universitit Bern 1 Introduction This paper describes the outline of \nour lecture and the experience we have had when introducing object- oriented programming, design, and \nsoftware architecture to students of different educational and vocational backgrounds. While other courses \non object-oriented programming only show how to implement things in an object- oriented way, we emphasize \non the production of reusable class libraries and frameworks. 1 .l Objectives of our lecture The purpose \nof our lecture is to let the students develop a reusable class library in an easily understood application \ndomain. It is our intent to realize such a class library through several iterations. This conforms to \nour own and other people s experience (Russo et al., 1990) that several design, implementation and application \niterations are needed before a class library becomes really reusable. This specially applies for so calledframeworks; \nclass libraries that embody an abstract design for solutions to a whole family of related problems (Johnson \nand Foote, 1988). During an iteration step students realize that the tools they have seen so far are \nnot sufficient to cope with the new demands. This allows us to introduce new methods and tools in a just \nin time manner. This way the students learn why these new tools are needed and how they can be used to \ndesign and implement the class library in the next step. 1.2 The application domain The choice of a \ngood classroom application was not easy. On one hand we wanted it to be sufficiently simple such that \nstudents can fully understand it within short time. On the other hand the application must be complex \nenough and reveal some non-trivial design patterns and implementation techniques, such as collections, \ngenericity, part-of, and kind-of hierarchies. It must also be possible for the participants to visually \ntrace the execution of the resulting application without sophisticated debugging or algorithm animation \nsystems. We decided to choose a domain where every participant is assumed to be a domain expert: Video \ngames. Even if the participants did not implement video games before, they at least played such games. \nIn our lectures we design and implement a class library which can be used to build two video games called \nSNAKE (a variant of the UNIX worm (6) game) and BRICK (a variant of the game BREAK (Miller et al., 1980; \nHuni, 1986) or Brickles (Winograd, 199 1)). The implementation of both games is done with C++ (Ellis \nand Stroustrup, 1990) under UNIX {SUN SparcStation and DEC Station) for ASCII terminals (using the curses \npackage) and Xl 1 (using the SRGP graphics library (Foley et al., 1990)).  2 Lecture phases Our lecture \nis divided into four phases. The purpose of the first phase is to present the foundations of OOP. In \nthe second phase the evolution of software engineering is demonstrated on the sample application, and \na library of reusable classes emerges. During the third phase we emphasize object-oriented architecture. \nPhase four demonstrates the applicability of our reusable components to similar games. 2.1 Phase I: The \nfoundations As already pointed out, students who attend our lecture have quite different backgrounds. \nWhile computer science students tend to have a very good theoretical knowledge of software engineering \n(SE), they lack the understanding of problems which arise in real-life software development. Software \nengineers from industry on the other hand know how to cope with their every day problems very well, but \noften lack a sound knowledge of software engineering. To bring all participants to the same level we \nshortly present the basics of software engineering and OOP terminology. But a major part of this first \nphase is currently the introduction to C++ . 2.2 Phase II: Tracking the evolution of software engineering \nWe begin with SNARE as it is the simpler of these two games. During this whole phase, the students have \na rather passive role. We follow the historical evolution of SE and present increasingly powerful solutions. \nEvery solution is dissected, its deficiencies are discussed, and a better solution is presented. This \nleads us from a functional solution through a modular decomposition (object-based), to a class- based \napproach, and at last to an object-oriented design. The result of this process is a simple class library \nwhich allows easy implementation of a narrow family of snake-games. At this point, the students understand \nenough to design a simple application on their own. During the presentation of these different solutions \nwe gradually introduce new notations. At first, the students think that we use some ad hoc methods, but \nas the lecture proceeds, they recognize that we only use simplified variants of Class Responsibility \nCollaboration cards (CRC) (Beck and Cunningham, 1989), Class Collaboration Graphs (CCG) (Wirfs- Brock \net al., 1990) and the Booth notation (Booth, 1991). The object scenario notation which we employ throughout \nthis paper is our own variation of Booth s object diagrams augmented by names of variables. 2.2.7 Structured \nsolution After an informal presentation of the kind of game that we aim to build, we distribute the source \ncode listing of the worm game (Toy, 1988) together with a graphical representation of its reverse engineered \ncall-graph.This is an interesting reference against which we can compare our future designs in terms \nof good SE practice. Figure 1: The object scenario from the modular decomposition  2.2.2 Modular decomposition \nFor most students it is hard to figure out a sound partitioning into modules. We propose a responsibility \ndriven approach (Wirfs-Brock and Wilkerson, 1989) in small groups, using CRC cards as design tool. This \nresults in a set of 3 CRC cards (Snake, Game, Screen) which we use to construct a class collaboration \ngraph and an object scenario. At the same time, we introduce timing diagrams (Booth, 1991) as an alternative \nto the animation of object scenarios. During this process, the interfaces of the modules are being shaped \nand we might start implementing the module bodies. But as time is usually short, we distribute the working \ncode (plain ANSI C) and let the students experiment with it for a while. 2.2.3 Class based approach \nThe evolution from modules to classes is driven by the desire to construct an additional game with 2 \nsnakes competing for points. We already stress the point, that as much design and code as possible should \nbe usable in both game variants. Turning all our modules into classes does not change much in the CRC \ncards, the CCG and the timing diagrams. But it shows up in the object scenario (see Figure 2) as there \nare two objects of class Snake to be represented. An important change from the module based solution \nis the fact, that different objects of class Snake need to be independently referenced from class Game. \nThis is much easier to explain and comprehend, if one has a powerful graphical diagram technique available. \n 2.2.4 Segregating a class library Up to this point, our view is strongly application oriented. Once \na first prototype is running, our goals shift more towards generality and reusability. The class based \nsolution may be generalized to allow for an arbitrary number of snakes. Instead of replacing the two \nSnake variables of class Game by an array of Snakes, we propose to use a generic list class, taken from \nthe Interviews class library (Linton et al., 1992). We also recognize here, that a two dimensional Point \nis a fundamental abstraction used in our game. By introducing this new class, we can streamline clumsy \nexpressions in the current code and gain another highly reusable and independent component. I Figure \n2: The object scenario from the class based approach Finally, we segregate the game-independent classes \nScreen, Point and List { T} into a reusable library called libbase. Thus, our application shrinks tremendously. \nIt only consists of the two classes Snake and Game and one module for the main (application)-program. \n 2.2.5 Object-oriented solution Because it is rather difficult to have 10 people playing snakes on the \nsame keyboard, watching the same screen, we propose to introduce a new kind of snake, called AutoSnake, \nwith the behaviour of a semi-intelligent individual, AutoSnakes choose their way at random, probing the \nenvironment (e.g. the screen) for obstacles. Our previous snakes become PlayerSnakes as they react on \nkeystrokes from someone playing the game. Class Snake still furnishes most of the snake s state and behaviour. \nThe only method that is taken care of in the derived classes is interpret (aKey). AutoSnakes ignore \nthe parameter and just think about their new direction. Figure 3 shows the class collaboration graph \nof the object-oriented solution.  2.3 Phase III: Introducing design patterns While phase II was dedicated \nto the introduction of object-oriented design methods and programming with C++, we focus in phase III \non ways to achieve high reusability and great flexibility. Our key approach is composition. We demonstrate \ndifferent flavors of composition on a complete, practical example. In object-oriented development one \ncan identify some design structures that emerge repeatedly. These structures are called design patterns \nand are likely to be helpful again and again. A useful collection of design patterns is described in \n(Gamma, 1992). We believe that the identification of such design patterns enables the students to carry \nover these pieces of abstract design into their own future projects. Figure 3: The class collaboration \ngraph from the object-oriented solution  2.3.1 Exploring the design space With the tool set from the \nprevious phase, we launch the design of BRICK, Again, we start by distributing a design document based \non functional decomposition to give a baseline with which to compare the final outcome. The students, \nin teams of four, are then asked to produce their own design using CRC cards and some of the learned \ndesign notations. We feel that it is very beneficial to the students to discuss and apply their views, \nideas and approaches on a new problem when already having experience with a similar one. The groups usually \ncome up with a design adapted from the SNAKE example. Most of them also recognize that there is much \nin common between the visual elements (we call them GameItems) of BRICK and provide for derived classes. \nWe ask them to present their design to the class. This forces the students to apply the previously learned \ngraphical notations and to use them to explain how their abstractions collaborate. 2.3.2 Behavior composition \nSince BRICK s behavior is considerably mom complex than SNAKE s, some additional innovations are required. \nIn a subsequent discussion, we tackle the main stumbling point: What happens when a moving GameItem touches \nanother GameItem? We can sketch a model for this scenario, which is appropriate for our purpose, as follows: \nDepending on the kind of touched GameIt- the touching GameItem suffers a kind of reflex. Depending on \nthe kind of touched GameItem, the touched GameItem suffers a kind of hit. An initial naive design would \nrelegate these responsibilities to the derived classes of GameItem where individual methods provide the \ndesired behavior. This would result in a large number of derived classes. OOPSLA 92 Figure 4: The class \ncollaboration graph of BRICK s revision 1 We can do better by using one of the design patterns of behavior \ncomposition. Every GameItem features a ReflexBehavior and a HitBehavior slot (variable). These slots \nare filled at creation-time of GameItem with references to objects of classes derived from a class TouchBehavior. \nSpecific TouchBehaviors include VerticalBounce, HorizontalBounce, Absorbtion and Withdrawal. Such function \nobjects are applied to the involved GameItems whenever a collision occurs. This non-trivial architecture \nis very flexible, extensible and economic in terms of the number of classes that need to be defined. \nFigure 4 shows the CCG of this first revision of Brick. As time is normally too short to implement the \nwhole game in class, the students receive a prepared implementation with all classes that are needed. \nWe provide the libbase class library from phase I in an extended edition. The class Screen becomes an \nabstract class with derived classes for ASCII and Xl 1 terminals. Because all GameItems in BRICK are \nof rectangular shape, an additional class Rectangle is also provided. The classes from the problem domain \n(GameBoard, GameItem, TouchBehavior, MovingGameItem,Ball,Paddle)make uptheir own class library called \nlibgame. In exercises, the students build variants of the game by adding different TouchBehaviors and \nusing them to customizeGameItexns through composition. 2.3.3 Structure composition A key observation \nthat can be made with any class library that gradually becomes an application framework shows, that between \nmajor extensions, there always happens a phase of consolidation. We -264-Vancouver, British Columbia \ntherefore want to demonstrate, that we can broaden the applicability of the class library by migrating \nsome knowledge and behavior into new classes and reorganizing some class relationships. In addition, \nwe streamline the class protocols and become able to add (with little effort) some previously omitted \nabstractions and fix a number of pathological special Cases. The initial design intentionally omits \nsome features like the Wall of Bricks, which could be implemented by simply positioning a number of individual \nBricks on the GameBoard. Our next goal is to realize the Wall abstraction. While we discuss how to integrate \nthis additional concept into our architecture, we make an interesting observation: Class GameBoard and \nWall have a lot in comnwn: They both manage a collection of Game Items. But it is also clear that class \n Wall should be protocol-compatible with class Game Item. We want to manipulate a Wall as if it were \nan individual Game Item A case for multiple  inheritance? No! Again, experience with design patterns \nsuggests a viable solution: We rearrange our class hierarchy and incorporate a new intermediate abstraction \nCompositeGameItem from which we derive both, Wall and GameBoard. This is a rather massive change in the \noverall organisation of our game class library. It is worthwhile because class GameBoard shrinks, class \nCompositeGaxneItem may be reused in still more ways and class Wall can be built almost for free. Moreover, \nthe algorithms employed in class CompositeGameItern havealready been implemented in our original class \nGameBoard. All the TouchBehavior classesand the whole base library (Screen,Point, . ..) remain untouched. \nFigure 5 shows the class collaboration graph for the affected classes. MovingGame1te.m n IlKJVC.TO SimplffimneItem1 \nf f I = z,t Figure 5: The partial class collaboration graph of BRICK s revision 2 As the students do \nnot have enough design experience for this step, we show them how this can be achieved. The important \nmessage to take home is indeed a design pattern of structure composition. CornpositeGameItems support \nthe same protocol as SimpleGameItems. One can therefore recursively build up tree structures of GameItems. \nThe intermediate nodes are CompositeGameItems whereas the leave nodes are always SirnpleGaxneItems and \nthe root node is of class GameBoard. The algorithms used to traverse these trees of GameItems (to search \nfor a conflict, to distribute ticks) are distributed over the classes derived from class GameItem We \nprovide the working code of the game library revision 2, without the implementation of class wall (though \nwe provide a suggested interface declaration). To complete this exercise, the students need to understand \nthe communication between the collaborating components. Again, we supply an object scenario (see Figure \n6) and encourage them to draw timing diagrams. Figure 6: An object scenario of BRICK s revision 2  \nThere is an important potential for optimizations in all classes derived from CompositeGameItem. If the \nnumber of components referenced by a CompositeGameItem is large, data structures and traversalalgorithms \nfrom computational geometry may be implemented in these places without affecting the whole game architecture. \n 2.4 Phase IV: Refinement through reuse Until now our framework solves only a narrow family of problems: \nwe can build video games where moving items run into other items. The goal of this phase is to further \ngeneralize it in order to allow the implementation of even more types of games. In a first step we verify \nthat the mechanisms of structure and behaviour composition prove effective for more complex settings. \nWe therefore redesign the Snake game by reusing a maximum of our existing framework. Taking the object \nscenario of Brick revision 2, we just replace aBall (see Figure 6) by aSnake (see Figure 7). The new \nclass Snake is derived from class MovingGameItem The tail of the snake is implemented as a CoxnpositeGameItem \nthat containsa chain of GameItems. This experiment demonstrates that we really have built a reusable \nframework, as we can take advantage of all components with only minor cleanup on the existing code. Figure \n7: A partial object scenario of SNAKE revisited   3 Conclusions Our course is different in many aspects \nfrom other introductions to OOP and OOD we are aware of. One of them is that we follow the just in time \nprinciple to introduce object-oriented design methods of increasing complexity. We have also used the \nexample from phase III in a condensed mode (one day) to introduce product management, marketing, and \nother non-technical people that collaborate with developers to the ideas of object-oriented technology \nand application frameworks. This was only possible, because the graphical notations we employed carry \nenough architectural information and because nearly everyone is a domain expert in video games! While \nother courses on object-oriented programming and design stop after having shown how to implement things \nin an object-oriented style, we emphasize the production of reusable class libraries. Starting with an \napplication we go through several design cycles and extract class libraries of different levels of abstraction. \nAn independent implementation of the game BRICK has been done by John Pugh and Wilf Lalonde in Smallralk \n(Lalonde and Pugh, 1990; Bell et al., 1992), which can be positioned in sharp contrast to our reuse emphasis. \nWe not only develop classes to play a single game, but we generalize our class library in order to implement \na family of games. The product of our multi-cycle approach becomes an application framework.  Acknowledgement \nThe authors would like to thank Rene Bach, Jiri Dvorak, Erich Gamma, Stefan Leue and James Litsios for \nreading and commenting the draft of this paper. References Beck, K. and Cunningham, W. (1989). A laboratory \nfor teaching object-oriented thinking. In Meyrowitz, N., editor, OOPSLA 1989 Proceedings, pages l-6. \nBell, D., Morrey, I., and Pugh, J. (1987,1992). Software Engineering: A Programming Approach. Prentice \nHall, Englewood Cliffs, N.J. Booth, G. (1991). Object Oriented Design with Applications. Benjamin/Cummings. \nBudd, T. A. (1991). An Introduction to Object Oriented Programming. Addison-Wesley. Ellis, M. A. and \nStroustrup, B. (1990). The Annotated C+ + Reference Manual. Addison-Wesley. Foley, J. D., van Dam, A., \nFeiner, S. K., and Hughes, J. F. (1990). Computer Graphics: Principles and Practice. Systems Programming \nSeries. Addison- Wesley. Gamma, E. (1992). Objektorientierte Software-Entwicklung am Beispiel von ET+Qesign- \nMuster, Klassenbibliothek, Werkzeuge. Springer Verlag. To appear. Huni, H. (1986). Definition et realisation \nd un langage orient&#38; objet, implementant le concept de delegation. Master s thesis, Swiss Federal \nInstitute of Technology, Lausanne. Johnson, R. and Foote, B. (1988). Designing Reusable Classes. Journal \nof Object-Oriented Programming, 1(2):22-35. Lalonde, W. and Pugh, J. (1990). Inside Smalltalk, Volume \n1. Prentice Hall, Englewood Cliffs, N.J. Linton, M. A., Calder, P. R., Interrante, J. A., Tang, S., and \nVlissides, J. M. (1992). Interviews Reference Manual. Version 3.1-Beta. Stanford University. Available \nfor anonymous ftp from interviews.stanford.edu. Loomis, M. E. S., Shah, A. V., and Rumbaugh, E. (1987). \nAn object modeling technique for conceptual design. In ECOOP 87 Proceedings. Miller, A. R., Miller, J., \nand Schaffer, A. (1980). Breakforth into Forth. Byte, 5(8):150-163. Russo, V. F., Madany, P. W., and \nCampbell, R.H. (1990). C++ and operating systems performance: A case study. In USENJX C++ Conference \nProceedings, pages 103-114. Toy, M. (1988). Worm.c 5.5 (Berkeley). UNIX BSD sources. Ask Archie. Winograd, \nK. (1991). Brickles plus 2.0. Shareware program. For Macintosh, ask Archie. Wirfs-Brock, R. and Wilkerson, \nB. (1989). Object- Oriented Design: A Responsibility-Driven Approach. SIGPLAN Notices, 24(10). Wirfs-Brock, \nR., Wilkerson, B., and Wiener, L. (1990). Designing Object-Oriented Software. Prentice Hall.  Contact \ninformation: Hermann Hiini Jucker Informatik Anlikerweg 5 CH - 3626 Hiinibach hueni@iam.unibe.ch Igor \nMetz Institut fiir Informatik und angewandte Mathematik Universitat Bern, CH - 3012 Bern metz@iam.unibe.ch \n   \n\t\t\t", "proc_id": "157709", "abstract": "", "authors": [{"name": "Hermann H&#252;ni", "author_profile_id": "81332505625", "affiliation": "", "person_id": "PP31082390", "email_address": "", "orcid_id": ""}, {"name": "Igor Metz", "author_profile_id": "81100049635", "affiliation": "", "person_id": "P115927", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157828", "year": "1992", "article_id": "157828", "conference": "OOPSLA", "title": "Teaching object-oriented software architecture by example: the games factory", "url": "http://dl.acm.org/citation.cfm?id=157828"}