{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 to the Vancouver, British Columbia, Canada 5-10 October 1992 Proceedings Experience Report- \n Creating Well Formed Class Inheritance Schemes in C++ Report by: Frederic H. Wild Cadre Technologies \nInc. Abstract How do we know when we have a well formed inheritance scheme? What are the criteria that \nwe can use to judge? These are important questions that we must consider. For most people, inheritance \nis a rather new design discipline, and its implementation in C++ allows ample opportunity to create both \ngood and bad examples of its use. In this paper we explore how the design criteria for inheritance is \nboth similar to, and different from, conventional design considerations. We also discuss a set of anomalies \nthat should be removed from proposed C++ inheritance schemes [ 11, which can be used to judge whether \ninheritance constructs are well formed or not. Project Context This experience paper is derived from \nthe development and maintenance activities surrounding the creation of a C++ based graphical editor. \nIn 1986, we embarked on an attempt to realize the benefits of object-oriented technology. It was then \nearly on in the life-time of C++ (in the 1.x versions of the language). Certain logistical challenges \nwere present back then, but our belief that using C++ would be a great benefit spurred us on (for example, \nwe ported the AT&#38;T translator to run on some of the platforms we supported where commercial versions \nof C++ had not yet been released). S-10 October 1992 The people that made up the team were very familiar \nwith the application domain, and with the use of traditional structured methods, but they were new to \n00. Some training was given, but it focused primarily on C++ language features. The design discipline \nthat we acquired came more or less on the fly, from needs that were generated by our own discomfort with \ncertain practices that we had applied. As we maintained the code over the course of three years, we reflected \non what we had done, often trying to relate the things that we found with design guidelines from more \ntraditional design disciplines. We became interested in why we had let certain problems creep in in the \nfirst place, and what twist in thinking needed to take place to avoid these problems in the future. \n Designing for Inheritance When we consider the activities of creating a software system, and within \nthem, the point where inheritance can be applied, we may notice something interesting. Inheritance is \na construction view, as opposed to an operational view of the system. A so called construction view is \nconcerned with how the entities in the system come into being, while an operational view is concerned \nwith how the system s components interact. The operational view considers the system s traditional characteristics, \nsuch as how the system -17. Addendum to the Proceedings responds to events, or how data is transformed. \nThese traditional views are important because they tell us what entities must exist in the system, and \nhow their interfaces must be structured to honor the client- server relationships that they share. Notice \nthough, that the system s operational considerations are perfectly orthogonal to any consideration of \nhow those entities come into being. All that matters from an operational perspective is that the system \ns components exist, and that they behave in specified ways. On the other hand, the construction view \nis concerned with how an entity s abstraction (class) is built. It may be self-contained, or it may be \na single member of a deeply leveled inheritance scheme. The construction view has been known, in some \nform, to many languages (macros 121and generics [3] being among them), but the mechanism of inheritance \nis one of the more powerful ones of those yet introduced. With the power of inheritance also comes the \nability to create unwanted complexity. It is therefore subject to much closer design scrutinization than \nother less powerful construction mechanisms. It is worthy of consideration as a separate design activity \nwith its own set of guidelines and measures. Module interconnections characterize the complexity of a \nsoftware system. In C++, classes can be thought of as modules in the sense that they are configuration \nitems. Conceptually, they each comprise a set of declarations and code that should be thought about as \na unit. When looking at the dependencies between units in an object-oriented system, class-to-class relationships \nneed to be inspected and evaluated to ensure that the class system is well structured. The goal of the \nsystem construction activity is to create classes that embody the abstractions required by the application \nin a well factored and efficient manner. We want the inheritance scheme that results to be natural, adaptable, \nmaintainable, and usable. For these goals to be satisfied, we need to avoid the typical anomalies that \nwork against them. Identifying these anomalies is the subject of the section to follow.  Watch Out \nfor These The structure of this section follows the format of identifying and describing anomalies, each \nin turn, that should be removed from proposed class inheritance schemes. Since identifying defects is \noften easier than identifying positive points, we wilI discuss specifically the violations of good principles \nthat one should watch for and remove. 1. Do not allow subclasses to attempt to inherit subsets of a class \nattributes. Rationale: Simplicity prevails when inheritance is taken literally. Class users will benefit \nfrom the intuitive nature of literal subclassing, and developers will not need to code around semantic \nmismatches. A class should not attempt to inherit only selected characteristics from its parent. If there \nseems to be a need to do this, chances are good that the class system is not well suited to accept the \nclass being added; adjustments in the class scheme are necessary. The relationship between a parent class \nand a child should be ensured to be a strong is a relationship. If subclasses are not considered to be \nliterally everything that their parent classes are, augmented with additional local attributes, complex \nimplementations will be invited to make the subclasses work around imposed differences. Trying to inherit \nonly a few attributes from a parent class is often accompanied by much overriding of the semantics associated \nwith functions, resulting in a number of dead functions and dead instance variables in the classes above. \nAttempting to create a situation of partial inheritance should be avoided because it also complicates \nthe usage paradigm for clients of the class, who must ultimately understand the class interface and behavior \nas a composite of alI of the classes that provide inherited attributes to the given class, combined with \nthe given class local attributes. There is no C++ construct to allow only selected attributes of a parent \nclass to be inherited, which makes such choices invisible to browsing tools, and to the application designer \nwho is seeking to use a class. If a class does not fit naturally under a parent class, don t force it \nto fit. It is far better to modify the taxonomy of the class system, and how its clients use it, to allow \nthe desired class to have a more natural home. To do otherwise creates a number of special cases that \ndegrade the intuitive nature and appeal of a well designed class system. 2. Do not bury orthogonal attributes \nwithin the same class or inheritance hierarchy. Rationale: Creating a class-one that can be called a \ngood member of a class system-is both a matter of what one chases to define local to a class, and what \none decides to leave to potential subclasses. Each member of a class system should introduce a single \nset of essential and cohesive characteristics that will be required by all members that are subclassed \nbeneath it. Following this advice will yield more reusable classes, because the management of unrelated \nsets of attributes will be factored out and packaged separately, allowing a better choice of exactly \nwhich characteristics are available through Orthogonal attributes should be placed in separate inheritance \nwhen creating a new class. classes. For example, Figure 1 shows two schemes for the upper levels of a \nclass system of graphical object classes. -A--B- Line Arrow Polygon Arrow Polygon Object Object Figure \n1 -Two Possible Inheritance Schemes The example in Figure 1-A shows the attributes associated with an \nobject that is labeled being buried in the lineage of a PolygonObject. The scheme in Figure 1-B is preferable \nbecause it allows better freedom of choice for future situations. Specifically, Figure 1-A shows that \nall LabeledObjects are Graphicalobjects, but since the notion of an object being labeled (having text \nattached to it) is not dependent on the attributes pertinent to GraphicalObjects (objects composed of \na number of lines of various styles and colors), it makes sense to treat the attribute of being labeled \nor not as a separate concern, as in Figure 1 -B. Adding a relationship between, say, some subclass of \nArrow and LabeledObject is an open possibility in the scheme depicted in Figure 1-B. In this example \nwe have shown how to use multiple inheritance to our advantage. S-10 October 1992 3. Do not allow subclasses \nto access their parent s instance variables. Rationale: The internal state of a class--even one in an \ninheritance scheme-should be under the full control of the class. Each class should own its own state \ninformation (instance variables) and be solely responsible for maintaining the consistency of its state \ninformation. Any access to the state of a class, either in modifying or querying the state, should go \nthrough functions that allow the class to guarantee that it remains in some invariant condition across \ncalls. Allowing classes to hold the representation of their internal state information private to them \nis a good encapsulation practice. It localizes the consideration of the class internal representation \nto the class functions.  -w- Addendum to the Proceedings To follow this practice, use functions, declared \nas protected functions, that, where necessary, allow access to a class state information from its child \nclasses via these functions. This allows the child classes to stay out of the business of knowing their \nparent class internal representation, and allows the parent class the flexibility of treating its state \nas a black box, accessible via a well defined interface that can be held consistent over a variety of \ninternal representations. A class instance variables should remain private to the class. Child classes \nshould be thought of as clients of their parent classes. This way of thinking promotes good encapsulation, \nand minimizes the number of hard dependencies that will exist between classes in a class system. Allowing \nclasses to access their parent s instance data is a direct C++ analog to common coupling [4]. Common \ncoupling is a degree of coupling too strong to be desirable, because all code that accesses the common \ndata needs be considered with a full understanding of the behavior of all of the other code that accesses \nthe common data. 4. Do not create non-intuitive classes merely for the sake of reuse. Rationale: For \nthe most part, classes should reflect readily identifiable problem and solution space entities. The temptation \nalways exists for the designer to create a number of abstract classes for the sake of achieving more \ncompact and factored code, but if the classes created for this purpose are non- intuitive, their existence \nwill perturb the obviousness of the class system, resulting in lower ease-of-use and maintainability \nscores. Careful consideration should be given to the taxonomy of classes, asking at each level whether \nor not the attributes of a class are essential, from an entity type standpoint. When the existence of \na class is defended on the primary grounds that it fits well with the chosen implementation mechanisms, \nthis should raise suspicion. If the proposed clients of the class system would see no reason to create \nan instance, or set of instances, of the proposed class, the class may very well be non-essential. As \na general guideline, the external attributes of a class should be the deciding factor for its placement \nin the class scheme, not its hidden internal implementation mechanisms. 5. Do not use inheritance where \ngeneralization would be more appropriate. Rationale: The concepts of generalization and specialization \nshould be applied where appropriate. A popular misuse of inheritance can be found in situations where \nit is used to apply different fixed values to one or more attributes of a superclass. In cases like these, \nspecialization has been used where generalization may have been the more appropriate choice. As an example \nof this, consider a class that implements a menu item in a user interface-let s call it MenuItem. Assume \nfurther that each menu item possesses an attribute containing the text that it displays, and an action \nthat is invoked when the item is selected (Figure 2). (Note in Figure 2 that the items LOAD-TXT and SAVE-TXT \nare supposed to be thought of as #defined string literals that define the displayed text of each operation.) \nclana LoadIt- : public Manu1tam ( public: LoadItan() : taxt (LOAD-TXT) 0 DoAction() ; )  ala** &#38;v.ItQ \n: public Mahu1tem ( public: sav~It.lrl(): tart WAVE-TXT) (1 DoAction() ; f Figure 2 -Subclassing Used \nto Set a Distinquishing Attribute If we use inheritance to create subclasses of It would be much better \nto allow the value of the MenuItem for each menu item in the application, as displayed text, and the \npointer to an action routine, shown, we will possibly produce hundred of to be modifiable values of their \ncorresponding subclasses. These specialized subclasses will exist attributes via MenuItem instance-based \nfunctionsonly to serve very few (in many cases one) instances (Figure 3). of them. The discriminating \nfactor among peer subclasses will be be the value of an attribute that they share. class MenuItem ( \n private: String text: int action(); public: MenuItem () ; MenuItem(char *txt, int f()) : -MenuItem \n0 SetText(char *txt) ; SetAction (int f () ) ; Figure 3 - Generalization This would allow the client \napplications to set these attributes to suitable values in their instances of the MenuItem. It also allows \nthe class system to be created independently of the application domain supported by the clients. No further \nsubclasses are required, since any menu item, possessing proper displayed text and behavior, can be created \nfrom instances of the MenuItem class. The trade-off recommended here is one of generalization over specialization. \nOverall, it is not a good idea to use values of attributes to distinguish subclasses. Instead, use the \nfor additional attributes to guide the need to create subclasses. On the other hand, one should avoid \nopting for generalization in places where specialization would be more appropriate. Conditional behavior \nshould be minimized within a class. In the example above, all instances of a MenuItem are handled in \nthe same manner. That is, the values of the attributes are data to the same algorithm, not variables \nthat change or select the processing performed by the class operations. When someone makes a proposal \nfor the setting of an attribute to change the behavior of a class, it should be taken as a signal that \na subclass should be considered instead. of the Menultem Class  Conclusion We have discussed a number \nof common anomalies in class inheritance constructions that should be discovered and removed from class \nsystems. Doing so will eliminate a number of malformations that tend act to reduce the quality of a class \nsystem. Hopefully, adding this checklist of common inheritance mistakes to the list of items to look \nfor during design or code reviews, will serve to weed out some of the more popular reasons why people \nfail in their first attempt to create an implementation of a software system according to an object-oriented \nparadigm. It took about 3 years of time for everyone on our development staff to begin thinking right \nabout object-oriented design. We are now quite stable with our second generation class system, and we \nare looking forward to building our third. It has been an expensive but rewarding exercise, and having \nnow made it through to the other side of the learning period, we are now doing much better at creating \nlong-lived and valuable components according to object-oriented design guidelines. C++, as a language, \nhas a number of mechanisms that must be understood well before the language will stop biting you from \nbehind. A recent book exposing these items [5] has become part of our staple training materials on C++. \n References 1. B. Stroustrup, The C++ Programming Language, Addison-Wesley, 1987. 2. B. Kemighan, \nD. Richie, The C Programming Language, Prentice-Hall, Englewood Cliffs, New Jersey, 1978.  3. Ada Programming \nLanguage, Department of Defense, Washington, DC, ANSI/MIL-STD 1815A-1983.  4. W. P. Stevens, G. J. Myers, \n&#38; L. L.Constantine, Structured Design, IBM Systems Journal, Vol 13, No 2 (May 1974), 115139.  5. \nS. Meyers, Effective C++: 50 Specific Ways to Improve Your Designs, Addison Wesley, 1992 Contact information: \nFrederic H. Wild Cadre Technologies Inc. 222 Richmond St. Providence, RI, USA 02903 Phone: USA (401) \n351-5950   \n\t\t\t", "proc_id": "157709", "abstract": "<p>How do we know when we have a well formed inheritance scheme? What are the criteria that we can use to judge? These are important questions that we must consider. For most people, inheritance is a rather new design discipline, and its implementation in C++ allows ample opportunity to create both good and bad examples of its use. In this paper we explore how the design criteria for inheritance is both similar to, and different from, conventional design considerations. We also discuss a set of anomalies that should be removed from proposed C++ inheritance schemes [1], which can be used to judge whether inheritance constructs are well formed or not.</p>", "authors": [{"name": "Frederic H. Wild", "author_profile_id": "81100625745", "affiliation": "", "person_id": "P86800", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157713", "year": "1992", "article_id": "157713", "conference": "OOPSLA", "title": "Creating well formed class inheritance schemes in C++", "url": "http://dl.acm.org/citation.cfm?id=157713"}