{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 to fhe Vancouver, British Columbia, Canada 5-IO October 1992 Proceedings Workshop Report- \n Objects in Large Distributed Applications (OLDA-II) Report by: Peter Dickman ERCIM Fellow, INESC Lisboa. \n Scope and Goals of the Workshop The OLDA-II workshop was the successor to the OLDA workshop held as \npart of OOPSLA 91 in Phoenix, Arizona. The primary goal of both of these workshops was to bring together \nacademics, industrial researchers, and developers interested in large-scale distributed object-based \napplications and the support they require. In contrast to many other workshops, which focus on a particular \ntopic in some detail, the OLDA workshop deliberately provides a vertical slice through the problem domain. \nThat is, one of the principal goals of the workshop is to bring together developers and researchers from \na variety of communities: application builders: software engineering methodologists; systems builders; \nand researchers investigating very low-level issues. In addition, this year one focus of the workshop \nwas on language issues, with a panel of language developers. The reason for doing this is two-fold, firstly \nin distributed systems low-level architectural issues can profoundly influence application design and \nhigh-level issues such as fault-tolerance. Secondly, there is a clear need for integration of the many \naspects of systems into coherent wholes: much current research is on single issues, yet the solutions \nproposed often have consequences for related problems and solutions. The workshop attracted 45 participants \nin all, from ten different countries, representing a range of universities, research laboratories and \nindustrial S-10 October 1992 concerns. In addition, the attendees from the workshop-Object-Oriented Programming \nLanguages: the Next Generation, joined us for half of the lunchtime panel session, described below. In \naddition to the five panelists, fifteen presentations were given, all but one of which were ten minutes \nlong. With hindsight, ten minutes was not quite long enough, the fifteen minute slots of the first OLDA \nworkshop provided more scope for detail to be presented; however the brief presentations and substantial \nallowance of time for discussion (almost half of each session) generated a lively and informal atmosphere. \nIn the next two sections the topics presented and discussed are briefly summarised. I apologise if I \nhave misquoted or misrepresented anybody, in this brief overview of a long and tiring day!  The Short \nPresentations The morning and afternoon were both divided into two sessions, with each of the four following \na very loose theme. The two morning sessions were dedicated to papers on individual systems issues: basic \nproblems being addressed in the first session; resource allocation and load balancing being the focus \nof the second. Obviously, whole workshops can be, and are, dedicated to the topics addressed, so the \npapers selected were chosen to highlight a single interesting feature, or to show how a particular collection \nof ideas could fit together coherently. -a-Addendum to the Proceedings approach is that it reduces the \nlevel of cache Basic Problems in Object Support invalidation caused by the garbage collector. The first \nsession consisted of three presentations. The first, of double length, by Mark Day [ 11, presented Thor, \na distributed object-oriented database in which objects are stored persistently at highly-available servers \n(object repositories). The performance goal for Thor is a single network round- trip and at most one \ndisk read per object fetched, even though object scan be moved between repositories. This was achieved \nusing a combination of location- dependent names, unique identifiers in objects (only) and pre-fetching \nof surrogates (indirection elements pointing at remote objects). Thor has been prototyped at MIT in the \nArgus distributed programming language, and one of the topics discussed was the appropriateness of a \nlanguage with an in-built transaction mechanism for the development of a system with a different model \nof transactions. Mark suggested that this mismatch had led to some inefficiencies in the prototype, but \nthat the experience with Argus had been extremely positive. Work on a full implementation of Thor is \nnow under way at MIT, based on their experiences with the prototype version, and the Harp replicated \nfiling system. The second presentation, by James Davidson of CimflexTeknowledge [2], broadened the problem \ndomain somewhat, to show how they had addressed problems of object management in a distributed system \nwithout relying on a (logically) centralized solution, such as an Object Request Broker. Aimed at coarse-grained \nobjects on a LAN, the two main features of their approach are the use of forwarding instances for transparent \nmessage forwarding and the addition to XDR of: a LISP interface; the ability to transmit type specifiers; \nthe ability to transmit ADTs; and conversion of class definitions (but not methods) between languages. \nThe final presentation in the session, by Rammohan Kordaleof Georgia Tech [3], addressed the problem \nof garbage collection. His algorithm was aimed at Distributed Shared Memory systems, and hence was somewhat \noutside the scope of the workshop, but featured an interesting approach to locality maintenance, tuned \nspecifically for certain types of DSM system. One standard technique in garbage collecting a distributed \nsystem is to perform local collections on each node, and to somehow combine these actions into a higher \nlevel protocol that garbage collects the system as a whole. This paper presented an algorithm, based \non maintaining bitmaps of free/in-use memory and propagating information between local collectors, in \nwhich the local collections corresponded to logical heaps that crossed node boundaries, rather than nodes \nin the distributed system. The advantage of such an Load Management The second session also involved \nthree presentations, on the theme of resource management and, in particular, issues in object placement \nand load balancing. Eric Jul, of the University of Copenhagen, acted as session chair. The first paper, \nby Arun Chatterjee of Motorola [41, presented detailed experiments testing the hypothesis that classes \n(viewed as abstract behaviour types) provide a suitable level of abstraction for profile-based resource \nallocation. The experiments led to the development of an automated resource allocator for distributed \n00 programs executing on the ESP distributed execution environment. Profiles for several application \nprograms were shown, together with a set of heuristics used to generate allocation rules from class profiles. \nThe run-time allocation of instances to nodes (at instance creation time) was then based on a combination \nof the static profile information and dynamic load measurements. A number of distinct strategies for \nobject placement were compared, and the heuristic based approach, using both static class profiles and \ndynamic system measurements, was shown to be both efficient and effective in automatically allocating \nresources. Yvon Gourhant of TCD, then presented work on the clustering of objects in the Amadeus system \n[5]. This was the first of three presentations (two short papers and one panel paper) based on work from \nthe ESPRIT Comandos project, the others being [17,10]. The approach is based on a mixed dynamic and programmer-driven \nscheme (in contrast to the preceding work, which mixed dynamic and profiler- generated data) and is integrated \nwith both garbage collection and load-balancing, whilst being primarily aimed at the optimization of \ninter-object communication and disk I/O traffic. The algorithm (which is currently being implemented \nand measured) is loosely based on the Greedy algorithm, but is applied locally for the construction of \nclusters which may span a few nodes of the system. Reclustering is performed during garbage collection \n(a point which proved somewhat contentious during the following discussion), in contrast to the IK system, \npresented later by Pedro Sousa, which reclusters during the termination of contexts. The final paper \nof the morning was given by Wouter Joosen of the Catholic University of Leuven, Belgium; he presented \nthe load balancing support of the XENOOPS project [63 in which adaptive data parallel applications are \naddressed in the context of multiprocessor and distributed systems. In this project, on-going work is \nmeasuring performance of several different approaches to load balancing, using simulation on a transputer \nbased system. Three distinct approaches to system decomposition: random, hierarchical and domain-based, \nare being used to combine together load-balancer mutator pairs in the system. The talk addressed the \nimpact of scalability and included some preliminary results from the experimental work. One issue raised \nduring the discussion was the trade- off between the costs and benefits of load balancing, object placement \nand (re)clustering. The dynamic nature of inter-object relationships introduces additional complexity \ninto the problem of object distribution, and the costs of current techniques appear to still be rather \nhigh. Software Engineering The first session in the afternoon consisted of four papers on the loose theme \nof issues in the construction of large distributed object-based software systems. Sharon Lamb of Motorola \nacted as session chair. The first paper, presented by Oliver Frick of the University of Karlsruhe [ 121, \nreported the work of a combined University/Industrial Research Lab project on the modelling of large, \nco- operative (hence inherently distributed), multi-media applications. Three related pieces of work \nwere briefly mentioned: an integrated tool set and development language; a new project to investigate \nspecific issues raised by co-operative and multi-media systems; and a particular example application. \nThe aim of providing a combined modelling and implementation language has led to support for a variety \nof abstraction styles, a very sophisticated generic model and a highly integrated tool set and environment. \nJames Lee presented work under way at Columbia University [ 131, in which dynamic behaviour extension \nis supported at run-time (i.e. after instance creation) by means of a (partially) reflective language \nmodel. In particular, the addition of transient orthogonal effects (called shadowing) to the primary \nbehaviour, as a debugging aid, for example, is seen as of great importance in this work. A preliminary \nimplementation of the proposal has been completed, and example uses are now being investigated. Two case \nstudies mentioned concern the support of, respectively, persistence and object migration. It was suggested \nthat the clean separation of behaviour and run-time policy reduces complexity in applications and thus \neases the implementors burden. A similar goal, in a different context, was met in the third paper of \nthe session. Valerie Issamy, of IRISA in Rennes, presented the exception handling mechanism of the distributed \nlanguage Arche [141. Arche is intended to simplify the construction of reusable distributed applications \nfor the Gothic system. It includes both an explicit synchronization mechanism and a notion of multi-procedure. \nThese are used in invoking methods of object groups, with all members of the group synchronising prior \nto execution of the call. Furthermore, such a multi- procedure can issue co-ordinated calls (which may \nthemselves be multi-procedures) that require further synchronization. Such mechanisms are of great value \nwhen developing fault-tolerant code, but raise issues related to the semantics of exception handling. \nThe presentation focussed on the Arche exception handling mechanism, which extends termination- style \nexceptions to handle multiple responses from the parallel multiprocedure call. Unlike previous work on \nparallel exception handling, parameterized exceptions are supported in Arche. Exceptions are modelled \nas classes and concerted exceptions were described in the context of a synchronous multiparty communication \n(such as a multiway rendezvous) as well as multi-procedures. Several applications have been developed \nin the Arche language, and the experience gained in doing so suggests that multioperations and concerted \nexceptions are of significant value to the programmer of a fault- tolerant application. The final paper \nin this session [ 151, presented by Dennis Kafura of Virginia Tech, described early work in the Synergy \nproject. The presentation focus&#38; on the implementation of network protocols in an 00 framework. In \nparticular a structuring of multi- layer protocols (such as the OS1 7-layer model) in terms of inheritance, \nwith the lowest level as the base class, rather than in the more usual approach based on inclusion, was \npresented. It was suggested that such an approach avoids copying of data, and the resulting monolithic \nprotocol objects that result were contrasted during the discussion with the more pipelined approach of \nthe X-kernel. Whole Systems The last session of the day, and also the longest, contained five papers \naround the theme of whole systems and practical experience. The first of these papers [ 161 was presented \nby Doug Johnson of Texas Instruments, and described a distributed 00 platform developed for the MMST \nCIM system. It deliberately only provides an 80% solution, but appears to be useful for a large class \nof applications that require powerful support for distribution whilst being able to tolerate certain \nrestrictions. The assumptions were that the system would consist of tens or hundreds of workstations, \nmostly on a single LAN (with fast, reliable communications), trusted applications and moderately granular \ndistribution. Using a single flat namespace for distributed objects and a partial garbage collector that \ncannot collect distributed cycles has proved to be a successful approach. To date distributed cycles \nof garbage have not proved to be a problem. The two major components of the system were the Remote Object \n Communication service and the Global Virtual Image service. These provided message-passing services \nand reliable replicated objects (ROC); and persistent object storage together with sharing and consistency \nservices (GVI). Wherever possible commercial or public domain packages were used to implement these facilities, \nTCP/IP, Isis and Gemstone being used for point-to-point communication, replication and multicast, and \npersistent storage, respectively. The IK system [ 171 from INESC in Lisbon, described by Pedro Sousa, \nalso avoids certain difficult problems, aiming at providing a usable but potentially imperfect system. \nScalability issues were addressed, with the points at which the distribution transparency would begin \nto break down being highlighted. Suggestions for a new scalable version of IK were also discussed, including \na potentially unsafe algorithm for distributed garbage collection that proved to be somewhat controversial \nin the discussion that followed. Spring is an experimental distributed operating system based on the \nuse of strongly typed 00 interfaces to describe all services. Brian Lewis of Sun Microsystems Laboratory \ndescribed the Navigator [18], a monitoring system for distributed applications on Spring. The Spring \nNavigator is an extensible system of Spring services and window- based tools, that make it easier for \nprogrammers to understand, profile and debug Spring software. The Navigator primarily operates at the \ninterface level, using information about., and available in, interfaces through an instrument and dashboard \nmetaphor. As the Navigator is itself a Spring application, it derives all of the benefits that this entails, \nin particular location transparency, which permits it to invoke methods on objects in the same address \nspace or other ones, potentially on different machines. The Navigator is highly extensible and new instruments \nmay be added dynamically through the use of remote address spaces. The Navigator offers clear evidence \nof the power of simple standard interfaces and the usefulness of generic tools; experience with it also \ndemonstrated the importance of early consideration being given to the failure modes of distributed systems! \nClosely related to the instrumentation issues raised by the preceding paper are the more general questions \npertaining to system management. Raouf Boutaba, of the University of Paris VI, described the Domains \nproject, an ESPRIT-funded development of an architecture for the integrated management of all resources \nin a distributed system [ 191. He concentrated on presenting an 00 approach to modelling and implementing \nthe management of large distributed systems. A taxonomy of forms of control was presented, along with \na logical controller to support them. A collection of management services necessary to support these \ndistinct forms of control was described and these various components were then combined into a complete \narchitecture. The last paper of the workshop took a rather different, prototype based approach, to the \nproblem of system modelling. Steven Forgey of Digital Equipment Corporation described the development \nof a wide-area peer-to-peer distributed object base, and its utilization in the rapid prototyping of \nenterprise designs and applications [20]. Their goal was to support a training seminar by providing an \nenvironment for the rapid (1-4 hour) iterative prototyping of distributed applications, implementing \nthe process-based designs that were being generated throughout the two-week long seminar. The success \nof this project, using a message- passing model supported by a wide-area object base with implicit concurrency, \npersistence and distribution, was founded on its location-transparent persistent object store and the \nprovision of a loosely- typed dynamically-bound object language, with graphics, tree manipulation, mathematical \nand messaging functions already provided.  The Panel on Language Issues The lunchtime session was organised \nrather differently to the remainder of the day. We were joined by the attendees of the other workshop-00 \nProgramming Languages: the Next Generation, and a supply of Chinese food, for a panel session on Programming \nLanguages for Distributed Object- Based Applications. The invited panelists were: . Norman Hutchinson \n(Emerald) Barbara Liskov (CLU, Argus) Satoshi Matsuoka (the ABCL family) Michel Riveill (Guide) . Robert \nStrom (Hermes) The panelists had been asked to consider the weaknesses of current languages, and in particular \ntheir own, as tools for developing large distributed applications; and to suggest issues that must be \nconsidered in developing future languages for this purpose. It was taken as a given that current languages \nare not really adequate for such work. Satoshi Matsuoka, of the University of Tokyo began the session, \nintroducing the concept of reflection (including the hybrid group architecture) and the ABCL family [9] \nof reflective programming languages. Reflection is an extremely powerful mechanism, offering flexibility \nthat can be utilised in ways that induce confusion, as well as for its intended purpose of tuning and \nimproving systems. He pointed out that the Metaobject Protocol methodology pioneered in CLOS aims to \nconfine reflective modification in some respects, and that restrictions of some form are undoubtedly \ndesirable in production (as against research) reflective languages. Barbara Liskov of MIT then discussed \ntwo (of many) issues that arise in designing an object-based language for distributed computing: the \nbasic model of computing: and the role of the type hierarchy, polymorphism and inheritance in supporting \nprogram evolution [8]. She contrasted the client/server model of computation, which is predominant in \ndistributed computing, with the blackboard model. In that model a universe of passive objects forms a \ncommunication space, with external active processes communicating with each other by invoking methods \nof objects in the blackboard. Thus one process may place a request in some queue object, that is later \ndequeued and acted upon by some other process. Such a model highlights many questions in distributed \nsystems, for example it is useful when any one of several equivalent servers could satisfy a request, \nwhereas current multicast mechanisms do not provide an appropriate solution for this situation in client/server \narchitectures. The blackboard model was first introduced in the field of parallel computing, so issues \nsuch as fault tolerance have not yet been addressed and there are difficulties in achieving the desired \nlevels of performance. Since the blackboard model is closely related to work in 00 databases (particularly \ndistributed 00 databases, such as Thor), it is interesting to think about the primitives provided by \na programming language in which all communication occurs through objects in a persistent object store. \nIn an evolving program, the type hierarchy allows objects to continue to function when new subtypes, \nnot known at the time the objects were implemented or instantiated, come into existence. In particular \nan actual argument in a method invocation may be of any subtype (in particular, a new subtype) of the \ntype specified in the interface. That is, the supertype acts as a form of implicit union of the supertype \nand all (eventual) subtypes. This is particularly important in distributed applications, since the components \nof such applications are likely to be very long-lived and must continue to function in the presence of \nnew variants of existing types. 00 languages also support program evolution by allowing multiple implementations \nof types to coexist. Thus, a distributed application can use different implementations for objects of \nthe same type in different parts of the system. This requires care, however, if communication occurs \nbetween the two subsystems using these objects. Canonical message passing is a partial solution to this \nproblem, but evolution over time of the canonical representation must also be supported. There is also \nan implementation question concerning the shifting of existing objects to some new implementation or \nsubtype: which objects should be transformed, when this is to be done and how it can be performed are \nall non-trivial issues. The type hierarchy supports subtype polymorphism, in addition parametric polymorphism \n(in which modules can be pararneterized by types) is needed. This second facility allows evolution of \ninterfaces without constraining the types to be related, and without requiring that the methods involved \naccept one anothers objects as arguments. Finally, Barbara suggested that multiple inheritance was introduced \nprimarily because the inheritance mechanism was being used as a single means of supporting distinct features: \ncode sharing, type hierarchy and parametric polymorphism. She conjectured that single inheritance would \nprove adequate in a language that provided other support for the last two requirements. Michel Reveill, \nof Bull-IMAG Systems, presented the Guide language, developed in Grenoble as part of the ESPRIT Comandos \nproject [IO]. The Guide project objective is to design and implement a platform for the programming of \nlarge and complex distributed applications that manipulate persistent data. To this end the Guide language \nand distributed operating system feature separate definition of types and classes, conformant subtypes, \nexceptions, support for complex persistent objects and location transparency. One particular focus of \nthe work has been the support for concurrent activities, through a synchronization mechanism for object \nsharing. Experience with the language has confirmed the value of: garbage collection, location transparency, \nand the separation of types and classes. Guide also demonstrated: that safety (through strong-typing \nand compile time checking) can be combined with the flexibility of dynamic binding and subtyping; the \nusefulness of integrated ACL-based protection mechanisms; and that object models can have fully developed \nsynchronization and exception handling mechanisms designed into them. The Hermes language was then discussed, \nby Robert Strom of IBM [ 111. A Hermes program is a set of communicating lightweight processes each operating \nwithin one of many (possibly shared) address spaces. Hermes is also strongly typed, with scalars (integers, \nbooleans, globally unique identifiers etc), safe aggregate constructors (records, variants and tables), \nand communication types (typed ports and messages). All Hermes types may be passed in messages, subject \nto the typing constraints enforced by the ports. This emphasis on safety and checking extends to initialization \ntests, using dataflow analysis and pre and post-conditions to ensure that variables will be in an appropriate \nstate when operations are applied to them. The final panel presentation was by Norman Hutchinson, of \nthe University of British Columbia, who was one of the Emerald designers at the University of Washington \n[7]. Emerald, like CLU, has profoundly affected the languages which have been developed more recently. \nNorm briefly introduced Emerald, pointing out that it s biggest advantage is that it has a single uniform \nobject model, but that it also has a major disadvantage: that it only has one form of object. At this \npoint Barbara Liskov pointed out that Argus has two distinct forms of objects (Guardians and CLU-style \nobjects), which is its big advantage; but that it also has a drawback, namely that it has two forms of \nobject. Unfortunately Satoshi missed his chance to point out that in a reflective system it would be \npossible to switch between having one and two different forms of object, and thus get the worst of both \nworlds (at a price, of course). Norm went on to discuss three major areas in which he felt large advances \nwould be both possible and useful: clustering, attributes and optimization. Clustering is essential to \nthe effective provision of fault-tolerance, mobility and persistence; yet single interface super-objects \ndo not provide for the dynamic nature of the inter-object relationships. Furthermore appropriate clustering \npolicies may be application dependent, and the requirements will not be uniform for all instances of \na class. In large-scale distributed applications there are many possible implementations for a given \nobject, with respect to concurrency, failures, persistence and so forth. To permit a separation of concerns, \nthe mechanism for specifying these attributes should be independent of, and orthogonal to, the code implementing \nthe operations on the object. Finally, it is critical that the performance of objects is commensurate \nwith the characteristics demanded of them, thus the Emerald compiler, for example, uses dataflow analysis \nto determine when certain expensive features are not used and optimizes the object accordingly. If the \ncost of features is to apply only to the objects that use those features, much thought must be given \nto optimization in future languages The discussion that followed the panelists presentations was divided \ninto two parts (due to the intervening break for food), with only the OLDA attendees present for the \nsecond part. Apart from the obligatory religious discussion about dynamic versus static checking (in \nwhich the OLDA attendees clearly favoured performing as many checks as possible at compile-time), a number \nof other issues were touched upon. Just to select one, the lack of a transaction mechanism in Emerald \nwas noted, and comments made earlier in the day about the Argus transaction mechanism were picked up \nupon. The consensus was that support for transactions is essential, let alone desirable, for application-level \nlanguages, but that this could be provided by means of building blocks. It would, of course, be necessary \nto provide some pre-assembled transaction mechanism(s) for use by naive programmers, but that a tools \nspecialist should be given the power to develop special purpose mechanisms quickly and easily for use \nby colleagues in large development teams. One critical point that was made is that it is important that \nthe powerful ideas developed in research languages become available to a wider community. This cannot \nbe achieved either by ad-hoc retrofitting of features to inappropriate existing languages or by simply \nexpecting industrial software developers to use unsupported languages with research-quality compilers \nand minimal development environments. Although this is often what has happened in the past, it is far \nfrom adequate and there is a need for industrial development of one or more modem high-quality languages \n(and support systems: libraries, tools etc.) for distributed programming. Unfortunately, the preference \nof industry that multiple, financially secure, providers exist before a language can be safely relied \nupon, means that many well-designed languages will not be widely used. Summary Summarizing such a wide-ranging \nworkshop is a hopeless task. The main goal, of bringing together a cross-section of people with related \nbut differing interests, and allowing them to show each other the problems and their inter-relationships, \nwas certainly achieved. It was also clear that much work remains to be done in all of the sub-fields \nwe touched upon. Nonetheless, a number of interesting problems have already been solved to some degree, \nand it is encouraging that usable, if somewhat limited, systems have been developed in industry which \ntake advantage of those solutions. As further advances are made, the task of the large distributed application \ndeveloper will continue to be eased, and the range of applications will undoubtedly broaden. Thanks to \nall of the attendees, both those who gave presentations and those who merely joined in the discussion; \nand thanks also to the Chinese food counter who sold us a huge take-away lunch at such DO1 Michel Riveill. \nshort notice. An overview of the Guide language. D11 Arthur Goldberg, Robert Strom and  References PI \nPI [31 [41 El [91 Mark Day, Barbara Liskov, Umesh Maheshwari and Andrew Myers. Naming and Locating Objects \nin Thor. James Davidson. Manipulating Objects in Distributed Applications Rammohan Kordale, John Shilling \nand Mustaque Ahamad. Garbage Collection in Distributed Shared memory Systems. Arun Chatterjee. The Class \nis an Abstract Behaviour Type for Resource Allocation of Distributed Object- Oriented Programs. Yvon \nGourhant, Sylvain Louboutin, Vinny Cahill, Andrew Condon, Gradimir Starovic and Brendan Tangney. Dynamic \nClustering in an Object-Oriented Distributed System. Wouter Joosen, Yolande Berbers, Stijn Bijnens and \nPierre Verbaeten. Dynamic Load Balancing in Large Scale Distributed memory Systems: the XENOOPS Approach. \n Norman Hutchinson (2 items). A brief introduction to Emerald. The Future of Distributed Programming \n I-a%wW* Barbara Liskov (2 items). A brief overview of Argus. Issues in the Design of Distributed Object- \nbased Languages. Satoshi Matsuoka and Akinori Yonezawa. Reflective Computation in ABCL-Family of Languages \nfor Distributed Computation-An overview. Shaula Yemini. Hermes: A High-Level Process-Model Language \nfor Distributed Computing. WI Max Muhlhauser and Oliver Frick. Towards a Modelling Framework for Cooperative \nMultimedia OLDAs. 1131 James Lee, Erik Hilsdale, Wenwey Hseush and Gail Kaiser. Dynamic Orthogonal Composition \nin MeldC. r.141 Valerie Issamy. Exception handling in the Distributed Object-Oriented Language Arche. \n 1151 Dennis Kafiua and Greg Lavender. Synergy: A Foundation for Large-Scale Distributed Applications. \nWI Doug Johnson, Mark Anderson and Rick Carlos. A Pragmatic Distributed Object System. 1171 Pedro Sousa \nand Miguel Castro. Scaling Up the IK Platform WI Brian Lewis. The Navigator: A Scalable System for Monitoring \nDistributed Object-Oriented Applications. [I91 Raouf Boutaba. An Object Oriented Approach to Large Scale \nDistributed Systems Management. Em John Churin and Steven Forgey. Enterprise Prototyping with a Distributed \nObject Base.  Contact information: Peter Dickman ERCIM Fellow, INESC Lisboa. Email: dickman@gmd.de \n  \n\t\t\t", "proc_id": "157709", "abstract": "", "authors": [{"name": "Peter Dickman", "author_profile_id": "81100441864", "affiliation": "", "person_id": "PP31076550", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157722", "year": "1992", "article_id": "157722", "conference": "OOPSLA", "title": "Objects in large distributed applications (OLDA-II)", "url": "http://dl.acm.org/citation.cfm?id=157722"}