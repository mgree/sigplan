{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 to the Vancouver, British Columbia, Canada 5-10 October 1992 Proceedings Poster Submission- \n Operations and Collections; Some Architectural Choices Report by: L.Desmond and D.B.Anderson Essex University \nMany methods arise for solving the problem but Abstract these fall into four groups from two orthogonal \nissues; whether the operation is a function or an We want to talk about the importance of low-level object, \nand whether the operation scans the software architectures and how to use them. In order collection or \nthe society does. Figure 1 gives the four to do this we look at the example of carrying out methods in \nC++. operations on elements in a collection. We look at the possible solutions and the properties of \neach of these solutions. The Issues The four properties of interest are: efficiency- The Example speed, \ncode size, memory use, expressivity- simplicity, clarity, easy to spot, reuse-when adding In this discussion \nwe use the specific example of new operations and new types of society, and finding the average age of \nthe members of a society to encapsulation-when adding a new, develop and express our ideas, i.e. the \nmembers are in implementation of the collection. These properties some collection and we have to get \nthe age of each are of course related. and average them. class Club ( Collection *members; public: int \nageOfMember(index n); int numberOf Memberso;} int averageAge(Club *aClub); class Club ( Collection *members; \npublic: int ageOfMember(index n); int numberOfMembers(); 1 return aserver->result(); class ClubStatisticServer; \nclass ClubAverageServer :public ClubStatisticServer ( public: virtual int aFunc(Club . ,index) = 0; int \ndoOn(Club aClub) ( int total=O; for (index=first;index=last;index++) total+=aFunc(aClub,index); return \ntotal/numberOfMembers(); 1 class Club ( collection members; public: int averageAge(); } class Club ( \nCollection *members; public: int apply(PersonStatServer *aServer) ( for(index=first;index=last;index++) \n aserver->doOn(member[index]); I I class PersonStatServer; class PersonAverageServer :public PersonstatServer \n( int count,total; public: PersonAverageServer(); virtual int aFunc(Person . )=O; void doOn( Person \naMember) (count++;total+=aFunc(aMember);} int result0 (return total/count;); } class PersonAverageAgeSetver: \n:public PersonAverageSewer ( public: int aFunc(Person *a) (return a->age();} }  Figure 1 - The 4 methods \nin C++ by survey-a survey of users was used to measure clarity and simplicity, and by expanding-the code \n  How We Got the Results was expanded to include a new operation and a new Each property can be measured \nfor the examples collection, for example each of the above four above; due to space restrictions Table \n1 shows only examples were expanded to include code for finding some of these. the maximum height of \nthe members of the society. The results were obtained in three ways; by measuring-i.e. code size and \nspeed can be measured, Metric Aver(Club) Club.Aver() Efficiency Code Size 3/2/13 3/2/I 1 Speed 4470 4430 \nSimplicity H H Reuse Code Reused L L Code written 1Pb l/o/l Code adjusted WOK) HP/o Table 1 - Discussion \nIt is easy to write code to beat a metric at the cost of another. So, for example, we may increase the \nspeed of a method at the cost of clarity. This makes compiling the metrics difficult and arises because \nonly two orthogonal issues, four methods, were looked at; if more methods were added this would not occur. \nSo, for example, if we added another four methods using inline functions the metrics would change. Different \nmethods are clearly good for different things. The method used in the final software should be chosen \nby deciding which property is most important in a particular case. So, for example, Club.uppfy(Auer) \nis slower and larger but far more clear, reusable and expandable than Aver(Club).  Conclusions When \nwriting software it is important to have a knowledge of the possible methods for solving individual problems, \nso that an appropriate one can be chosen. It is also as important to know which properties each method \nprovides and how properties are affected by changing methods. Also important are the properties themselves \nand how to measure them. In large projects more than one collection and operation may exist. This leads \nto the use of more than one method. This itself can be viewed as an architecture, or meta-architecture, \nwith properties. i.e. no mixing of methods leads to clearer code overall, but may affect clarity and \nefficiency in individual areas. All through this paper we have looked at these methods as low-level software \narchitectures. This is due to the need for properties and choice at the S-10 October 1!#2 -MS- Aver.on(Club) \nClub.apply(Aver) 5/5/20 515/24 9610 16200 L L H H 3tY16 3l3r.20 UOP UOP Results component and system \nlevel. i.e. with low and high level software architectures.  Future Work The future work falls into \nthree areas; Properties-more work is needed on types of properties and how to measure them. Architectures-more \nexample architectures are needed like the collection example given here. Architecture Handbook-there \nis a need for a collection of architectures and instructions on how to use them and combine them to create \nsoftware. Acknowledgements We would like to thank G. Ramachers, J. Danials and G. Birch for the initial \ndiscussion of the example and S. Lovejoy for her help in forming this paper. We would also like to thank \neveryone who replied to the News survey posting of methods from which some of the results were drawn. \n References [Cop921 Advanced C++. J.O.Coplien, Addison- Wesley, 1992  Contact information: LDesmond \nD.B.Anderson Essex University, Wivenhoe Park Colchester, Essex, ENGLAND. CO4 3SQ E-mail: desmI@essex.uc.uk \nand bruce@essex.uc.uk   \n\t\t\t", "proc_id": "157709", "abstract": "<p>We want to talk about the importance of low-level software architectures and how to use them. In order to do this we look at the example of carrying out operations on elements in a collection. We look at the possible solutions and the properties of each of these solutions.</p>", "authors": [{"name": "L. Desmond", "author_profile_id": "81100605232", "affiliation": "", "person_id": "P165457", "email_address": "", "orcid_id": ""}, {"name": "D. B. Anderson", "author_profile_id": "81332488080", "affiliation": "", "person_id": "P51955", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157749", "year": "1992", "article_id": "157749", "conference": "OOPSLA", "title": "Operations and collections; some architectural choices", "url": "http://dl.acm.org/citation.cfm?id=157749"}