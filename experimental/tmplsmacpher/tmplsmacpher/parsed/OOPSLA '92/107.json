{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 to the Vancouver, British Columbia, Canada 5-10 October 1992 Proceedings Educators Symposium- \n Teaching Practical Object-Oriented Report by: Mahesh H. Dodani The University of Iowa Abstract This \npaper describes the effort undertaken at the University of Iowa to institute a software engineering curriculum \nat the graduate level. We describe our experiences over 2 years in developing a pilot 2-semester course \nin object-oriented software engineering. This pilot course had the goals of introducing practical and \nrealistic object-oriented software engineering to students, and developed several innovative techniques \nto achieve this goal on a very limited budget. 1. Motivation and Goals Over the last three years, the \nauthor has developed a curriculum that teaches Object-Oriented (00) software engineering at the graduate \nlevel. This effort has culminated in the setting up of a joint Master of Science level software engineering \nsubtrack between the Departments of Computer Science and Electrical and Computer Engineering at the University \nof Iowa, which makes its debut in the 1992/1993 academic year. This paper summarizes the innovative aspects \nof the 00 software engineering courses. The curriculum was motivated both by local industry as well as \ndepartmental interests and the research interests of the author. The local industry was interested in \nsoftware engineering courses that emphasized both formal specification and verification techniques, and \n00 methodologies. These industries were also interested in emphasizing 5-10 October 1992  Software Engineering \n the practice of software engineering, along with the underlying theory and methodologies. The graduate \ncurriculum in the Computer Science Department emphasizes formal theory and methods, and has been attempting \nto balance the graduate experience by including courses that apply formal models in practice. The authors \nresearch interest focuses on developing appropriate formal models for practical 00 software engineering. \nThus, the development of the software engineering curriculum provided an appropriate basis for focusing \nthese efforts, The goal of the curriculum was therefore to provide experience in both the theory and \npractice of realistic 00 software engineering. This goal translates into the following objectives: multiperson \nteam projects . real world projects experience with all phases of the software engineering lifecycle \nuse of practical formal models and methodologies experience with the processes involved in software development \n The rest of this paper describes our attempt at developing a curriculum that addresses all the above \nobjectives, and is organized as follows. In the next section we describe the details of the 2-semester \nsoftware engineering course. This section describes how each of the objectives were tackled, and also \n251-Addendum to the Proceedings describes our choices for the development environment, books, and tools. \nIn the following section, we discuss the lessons we learned from our experience with the course and highlight \nthe major problems we encountered. The final section summarizes our contributions, and outlines the future \nof our software engineering curriculum. 2. The 2-Semester Course on 00 Software Engineering In the following, \nwe outline our approaches to handling the objectives outlined in the previous section. [A] Multiperson \nTeams: The students were divided up into 3 and 4 person teams within the first two weeks of the semester. \nA questionnaire that solicited information regarding the previous experiences of each student on languages, \nsystems, and team work formed the basis for the selection of teams. The questionnaire also solicited \ninformation on available times for students to work on projects and meet with team members. [B] Real \nWorld Projects: The students were allowed to choose any project that had the following characteristics: \nThe project had to be an interactive tool employing some form of graphical user interface. Also, the \ntool was to be integrated within some existing environment. The intention was to expose students to tackling \nboth user interface and application frameworks. Typical examples of projects chosen by students over \nthe two year period include various graphical editors for drawing and circuit design, and CASE tool that \naid in the use of some 00 methodology (e.g. Booth methodology [Booch9 11 for 00 design, and Coad and \nYourdon methodology [Coad9la] for 00 Analysis). [C] Lifecycle Phases: The teams developed their project \nthrough all phases of a typical software engineering lifecycle. The projects developed analysis, design, \nimplementation, and testing documents in support of their project. During the latter part of the course, \nprojects were shuffled between groups to simulate the maintenance phase. In this phase, teams first evaluated \nthe software they received, and then performed some perfective maintenance task. They documented their \nefforts in a maintenance document. [D] Practical Formal Models and Methodologies: The 00 software engineering \nmethodology was emphasized. Each team was required to produce object, dynamic, and functional models \nin the analysis phase. The students were free to choose the specification mechanism for each model. However, \nthey were encouraged to follow well established practical specification mechanisms (e.g. [Booch91], [Coad9la,b], \n[Rumbau91]). These models were then used throughout the development lifecycle, and elaborated on in the \ndesign and implementation phases. Testing goals, strategies, and libraries were developed as soon as \nanalysis was complete. An iterative methodology was enforced. [E] Software Engineering Process: Teams \nwere expected to follow strict processes for software development. These processes were enforced in two \nways: documentation and Project Managers @ MS). Teams had to document their software development process \nthrough plans, progress reports, weekly status reports, technical reviews, in addition to the documentation \nof the software product (which included the object, dynamic, and functional models; the class hierarchy; \nthe test suite; and user manuals). A Project Manager (PM) was associated with each team. The PM was an \nadvanced graduate student who had either taken the course and/or demonstrated abilities to manage a project. \nPMs met with their groups on a weekly basis, and were in charge of ensuring that appropriate software \nengineering processes were followed through all phases of the lifecycle. In the following, we outline \nour choices of the development environment, books, and tools for the course: [l] Development Platform: \nWe chose Smalltalk- [Goldbe84, Goldbe as our implementation platform mainly for the following reasons: \nIt is a pure 00 environment that tends to immerse the user in 00 concepts completely. All the code is \navailable to the user, which makes it easier to understand the available classes. Furthermore, extensive \nclass hierarchies allow realistic projects to be built. Finally, it was relatively inexpensive to get \neducational licenses for PCs and Mats which were the platforms available for instruction at the University. \n[2] Books: The choice of books was much more difficult. Currently available books related to 00 software \nengineering tend to deal with a particular language, issue, or methodology. Thus, we chose a methodology \nbook (e.g. [Booch9 11, [RumbaughS) l]), and augmented it with a general purpose software engineering \nbook (e.g. [Pressma 1, SchachBO]). Finally, we made available as additional references (in the library) \nmost of the pertinent literature on 00 software engineering which (besides the references already mentioned) \ninclude conference proceedings ([OOPS86-911, research books and journals ([JOOP], [Shriver87], [Kim89]), \nand books on specific languages and systems ([Lalond90a, bl, [Cox87], [Meyer88], [Mode1881, [Smal188a, \nbl, [Wilson89]]). [3] Tools: Our choice of tools to support the software engineering methodology and \nprocess were based mainly on economics and availability. We chose MacProject II for project planning \nand tracking, CVS for revision and version control, email for communication, and MsWord for documentation. \nAll methodology based CASE tools were built in house, by encouraging student projects that were oriented \ntowards 00 software engineering. We have built CASE tools that aid in analysis, design, debugging, and \ntesting.  3. Experiences: Problems and Lessons Learned We discuss our experiences in the following three \ncategories: development environment, course organization/content, and evaluation. In each category we \nhighlight the lessons learned and problems that we faced. [A] Development Environment: Our choice of \nSmalltalk as the development environment led to several problems. The first was the learning curve for \nbecoming proficient with Smalltalk. We alleviated this problem in several ways. First, we tried to include \na least one member on each team with some 00 experience (especially in Smalltalk). Then, we devised several \ninteresting exercises in the beginning of the first semester that exposed the key class hierarchies. \nWe also made our PMs (who were experts in Smalltalk) along with several research students available as \ngurus. Finally, we allowed teams to experience Smalltalk by letting them understand and substantially \nmodify an interactive system written in Smalltalk (usually taken from previous projects!). Most of students \nproblems were related to understanding the complicated Model-View-Controller (MVC) user interface framework \nin Smalltalk, These problems have been alleviated to some extent by the more recent books on Smalltalk \n[Lalond90a,b]. Another major problem with Smalltalk is the lack of tools to support multiperson development \nand version control. The most recent version of Smalltalk claims to support several of these issues, \nwhich we hope will allow future offerings of this course to run more smoothly. The most important result \nof using Smalltalk is that students were able to develop real world projects, and were exposed to typical \n00 class hierarchies. [B] Course Organization/Content: We have used two radically different approaches \nin the organization of the course over the last two years. In the first year, we covered each software \nengineering phase in strict sequence; starting with analysis and design in the first semester, and finishing \nwith implementation, testing and maintenance in the second. The first semester also included a six week \nintroduction to 00 concepts and programming in Smalltalk, along with lectures on group dynamics and project \nmanagement. The team projects spanned across both semesters as well, following roughly the same sequencing \nof the phases. The greatest advantage of this approach was that the projects spanned across a large period \nof time, and it was therefore possible to devote a reasonable amount of time (four to five weeks) on \neach phase. However, we discovered several shortcomings. First and foremost, it was very difficult to \nprovide a total experience of an iterative methodology, as students did not have a good grasp of the \nentire software engineering process. Furthermore, teams did not gain enough experience with 00 programming \nand the development environment to be able to reasonably develop large scale projects. Finally, teams \ndid not spend enough time in the maintenance phase to get a good feel of how to mange and maintain class \nhierarchies for EUSC In the second year, we used a totally different approach in an attempt to alleviate \nsome of the shortcomings of the previous year. The entire first semester was spent covering all the software \nengineering phases from an 00 perspective. Teams were given projects from the previous year to evaluate, \nmanage, and maintain. This allowed students to be exposed to the artifacts of the analysis, design, implementation, \nand testing processes; and most importantly to gain deep understanding and expertise in the use of the \nclass hierarchies and tools of the development environment. The last four weeks of the first semester \nwere used to specify the requirements of the team projects, perform an initial analysis, and produce \ndetailed project plans. The bulk of the software development was relegated to the second semester. The \ninitial models produced during the analysis phase were elaborated on during the design, implementation \nand testing phases. An iterative methodology was enforceable, and led to very stable analysis and design \nmodels. The success of this approach is best summed up in the words of an evaluator (with years of industrial \nsoftware development experience) of the course: The student groups have done some very impressive work. \nI am attaching one of the group s progress reports. This document is, in my opinion, on a par with or \nexceeds the very best exampies of such work that I have seen in businesslindustry. Examination of its \ncontents make clear the fact that students are experiencing a compkte range of software engineering topics \nfrom analysis to testing. Furthermore, the document is evidence of the  fact that they are learning \nto apply appropriate methods and techniques. [Decker921 The main disadvantage of this approach is the \nlack of time spent in implementation and testing leading to prototype-quality software. We will tackle \nthis problem in our new M.S. subtrack in software engineering by forcing students to go through two preparatory \ncourses (one on software engineering, and the other on formal models) to ensure that they are adequately \nexposed to the necessary background before embarking on developing software. This will allow us to devote \nmore time on actual software development. The amount of information and work entailed by such a course \ncan be overwhelming for many students. The bottom line is that most students are exposed to a different \nsoftware development philosophy (00), user interface issues, team interaction, documentation, formal \npresentations, and developing a large software product, for the first time. The experiences from these \ncourses is that students typically spend between 15-20 hours/week outside class time. Spending such an \neffort on a single course is difficult (if not impossible) for most students taking a standard load. \nStudents who wanted to take the course were advised extensively as to what to expect from the course, \nand adjusted their load for the semester appropriately. [C] Evaluation: Evaluating the performance of \nthe students in this course is a nightmare. We tried to break down the evaluation into two major categories: \nindividual performance and group performance. Individual performance was based on class assignments, \nexaminations, and contributions to the project. Group performance was based entirely on project work \n(including documentation, presentation, testing, etc.). Evaluation were performed by the instructor, \nPM, and students. The instructor evaluated overall documentation, and software development. PMs provided \nindividual and group evaluation every 3 weeks. Teams evaluated each others projects. 4. Conclusions \nand Future Directions We have successfully incorporated a practical and realistic 00 software engineering \ncurriculum at the graduate level. Most of the problems with administering such a course have been tackled \nin interesting ways. Real world team projects, and the use of practical methodologies and development \nprocesses are the major components of the course. Our experiences with this curriculum has led to the \ndevelopment of a 36-hour Master level software engineering subtrack. The software engineering core of \nthis subtrack are four courses that must be taken in strict sequence over 2 years. The first introduces \nsoftware engineering and team work. The second course concentrates on formal methods in software engineering, \nThe final two courses are aimed at developing a real world software product using the models and methodologies \ndeveloped in the first two courses. The catalog descriptions of these four courses is provided in Appendix \nA. Students that have completed the above four core courses can take a project management course (also \ndescribed in Appendix A) as an elective. This project management course covers both instruction on methods \nand processes for project management, as well as a practicum of actually managing one of the projects \nwithin the core courses. The subtrack makes it debut in the 1992/1993 academic year. References [Booch91] \nGrady Booth, Object-Oriented Design with Applications, Benjamin-Cummings, 1991. [Coad9 la] Peter Coad, \nand Ed Yourdon, Object-Oriented Analysis, Prentice Hall, 1991. [Coad9lb] Peter Coad, and Ed Yourdon, \nObject-Oriented Design, Prentice Hall, 1992. [Cox87] Brad Cox, Object-Oriented Programming: An Evolutionary \nApproach, Addison-Wesley, 1987. IDecker William F. Decker, Teaching Review of Mahesh Dodani, Department \nof Computer Science, The University of Iowa, 14 MLH, Iowa City, IA 52242, March, 1992. [Goldbe84] A. \nGoldberg and B. Robson, Smalltalk- 80: The Interactive Programming Environment, Addison-Wesley, 1984. \n[Goldbe A. Goldberg and B. Robson, Smalltalk- 80: The Language, Addison-Wesley, 1989. [JOOP] Journal \nof Object-Oriented Programming. [Kim891 W. Kim and F. H. Lochovsky (eds), Object-Oriented Concepts, Databases, \nand Applications, ACM Press 1989. [Lalond90a] W. Lalonde and J. Pugh, Inside Smalltalk: Volume 1, Addison-Wesley, \n1990. lLalond90bl W. Lalonde and J. Pugh, Inside Smalltalk: Volume 2, Addison-Wesley, 1990. Meyer881 \nBertrand Meyer, Object-Oriented Software Construction, Prentice-Hall, 1988. [Mode1881 Mitch Model, The \nModel-View- Controller (MVC) ParadigmUser Interfaces, OOPSLA 88 Tutorial, ACM, 1988. [OOPS86] OOPSLA \n86, ACM SIGPLAN Notices, vol. 21, no. 10,1986. [OOPS87] OOPSLA 87, ACM SIGPLAN Notices, vol. 22, no. \n12,1987. [OOPS88] OOPSLA 88, ACM SIGPLAN Notices, vol. 23, no. 12,1988. [OOPS89] OOPSLA 89, ACM SIGPLAN \nNotices, vol. 24, no. 12, 1989. [OOPS90] OOPSLA 89, ACM SIGPLAN Notices, vol. 25, no. 12, 1990. [OOPS91] \nOOPSLA 90, ACM SIGPLAN Notices, vol. 26, no. 12,199l. [Pressma Pressman, R; Sofhvare Engineering: A Practitioner \ns Approach, 3rd Edition, McGraw-Hill, 199 1. lRumbau91] Rumbaugh, J. et al; Object-oriented Modeling \nand Design, Prentice-Hall, 1991. [Schach90] Stephen Schach, Software Engineeting, Asken Associates, 1990, \n[Shriver87] B. Shriver and P. Wegner (eds), Research Directions in Object-Oriented Programming, MIT Press, \n1987. [Sma1188a] The Smalltalk- Programming System, Version 2.5, Manual for the Macintosh, ParcPlace \nSystems, 1988 [Smal188b] SmalltalklV Reference Manual, Digitalk Systems, 1988. [Wilson891 David Wilson, \nNeal Goldstein, Smalltalk, MacAPP, and NextStep: A Comparison of 3 Object-Oriented Development Systems, \nOOPSLA 89 Tutorial, ACM, 1989.  Appendix A: Subtrack Course Descriptions 22C:180 Fundamentals of Software \nEngineering 3 s.h. Introduction to software engineering process: problem analysis, requirements definition, \nspecification, design, implementation, testing/maintenance, integration, project management; human factors; \nsoftware validation and verification; group project experience. Prerequisite: senior standing in computer \nscience or electrical and computer engineering. Same as 55:180 22C:181 Formal Methods in Software Engineering \n3 s.h. Study of formal models and methods and their application in all phases of software engineering \nprocess; operational, algebraic, model-based and property-based specification methods; verification of \nconsistency and completeness of specification; verification of properties of software; exercises in specification \nconstruction and verification using method-based tools. Prerequisite: 22C: 180. Same as 55:181. 22C: \n182 Software Engineering Project I 3 s.h. Team project work on software engineering of real software \nproduct; estimation, risk analysis, scheduling, tracking and control, software metrics; CASE tools and \nproject management techniques. Students must register for 22C:183 in the following semester. Prerequisite: \n22C: 180 and 22C: 18 1. Same as 55: 182. 22C: 183 Software Engineering Project II 3 s.h. Continuation \nof 22C: 182, which is prerequisite. Same as 55: 183. 22C: 189 Software Engineering Project Management \nl-2 s.h. Resource requirements estimation, planning and management; risk analysis; scheduling, tracking \nand control; personnel supervision, training, evaluation; process determination and management including \nchange control and configuration management; technical project leadership and assessment. Students register \nfor two consecutive semesters and assist in supervision of teams in concurrent offerings of 22C:182 and \n22C: 183. Prerequisite: 22C: 182, 22C:183, and consent of instructor. Contact information: Mahesh H. \nDodani Department of Computer Science The University of Iowa Iowa City, Iowa 52242 email: dodani@cs.uiowa.edu \nPhone: (319) 335-0713  \n\t\t\t", "proc_id": "157709", "abstract": "<p>This paper describes the effort undertaken at the University of Iowa to institute a software engineering curriculum at the graduate level. We describe our experiences over 2 years in developing a pilot 2-semester course in object-oriented software engineering. This pilot course had the goals of introducing practical and realistic object-oriented software engineering to students, and developed several innovative techniques to achieve this goal on a very limited budget.</p>", "authors": [{"name": "Mahesh H. Dodani", "author_profile_id": "81100485732", "affiliation": "", "person_id": "P186094", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157825", "year": "1992", "article_id": "157825", "conference": "OOPSLA", "title": "Teaching practical object-oriented software engineering", "url": "http://dl.acm.org/citation.cfm?id=157825"}