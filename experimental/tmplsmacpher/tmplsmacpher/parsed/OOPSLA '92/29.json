{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 fo the Vancouver, British Columbia, Canada 5-10 October 1992 Proceedings Poster Submission- \n Towards a Discipline of Class Composition Report by: Franz Weber Forschungszentrum Informatik (FZI) \n Abstract imitation-which may be used to express the compatibility requirements for class composition \nAssembling classes to form systems is a key concept [Weber 921. By giving a design strategy, we show \nin object-oriented software development. However, that highly reusable class hierarchies may be achieved \nin order to be composed, classes have to be using these notions. compatible in a certain way. In current \nobject- oriented languages the compatibility with a specific  Object-Oriented behaviour is expressed \nby inheritance from a class  Composition Mechanisms which describes this behaviour. Unfortunately inheritance \nis neither intended to express Three major composition mechanisms are available in compatibility nor \ndoes it enforce compatibility. This object-oriented programming: aggregarion, genericdeficiency may lead \nto inconsistent systems. instantiation, and inheritance. Therefore, in the project 10-14 inheritance \nis restricted to express compatibility between classes. Aggregation means a record-like composition of \none Two kinds of compatibilities are distinguished: object by attributes which contain sub-objects of \ncompatibility required for the integration of other classes. The integration of different kinds of subsystems \n(conformance) and compatibility sub-objects into this object requires that the classes required for reuse \n(imitation). A formal basis for the of the sub-objects may vary within a range of classes discipline \nis developed in order to get which all are compatible with a certain behaviour. mathematically precise \nnotions and to enable the Generic classes are patterns for class definitions verification of object-oriented \nsystems. A design which may be reused by the parametrization with strategy is built on top of these compatibility \nother classes. Assumptions on the class parameters notions. In actual case studies the discipline has \nare made for the definition of a generic class. These already shown to support a clean design and to \nassumptions must be satisfied by the classes which promote the reusability of class hierarchies. are \nsubstituted for the class parameters during generic instantiation.  Issues Composition by inheritance \nmeans to inherit the Based on the introduction of object-oriented implementation of a superclass and \nto redefine and composition mechanisms, we conclude that extend the features of the superclass. In this \ncase, traditional inheritance is not a sufficient inherited method definitions which are not redefined \ncompatibility criterion. Instead we will find two rely on requirements which have to be fulfilled by \nnotions of compatibility-conformance and 5-10 October 1992 149 - Addendum to the Proceedings the actual \nimplementations of other methods in the subclass.  Traditional Inheritance Usages In traditional approaches \na subclass inherits from a superclass by adopting all attributes and methods of this class. The subclass \nmay hide or redefine these attributes and methods. It may extend its inherited definition with additional \nattributes and methods. This mechanism may be used for several purposes. One common use of inheritance \nis speciulization. A subcIass inherits from a superclass if an instance of the subclass is a special \ncase of the superclass. In this case the behaviour of the subclass forms a subset of the behaviour of \nthe superclass. Another use of inheritance is the quick implementation of new classes. The subclass establishes \nits behaviour by inheriting almost all functionality from the superclass and doing a few redefinitions. \nInheritance may also be used to extend the functionality of a class or to implement a variation of a \nclass. All these usages of inheritance have in common that they do not necessarily imply a behavioural \ncompatibility of the subclass with the superclass. Current approaches to class composition in object- \noriented languages are, however, based on inheritance relations. Conformance and Imitation To guarantee \nthe correctness of the assignment of an object to an attribute, a conformance (subtyping) relation is \nrequired between the class of the object to assign and the class the attribute is declared of. Conformance \nmeans a full behavioural compatibility of the subclass with the superclass. It allows objects of different \nsubclasses but conforming to one common superclass to be freely mixed and matched together. Conformance \nis also the prerequisite for correct parameter passing. Requirements for class parameters of generic \nclasses may be expressed by declaring certain classes as bounds for these class parameters. In common \nobject-oriented languages, a class may be substituted for a class parameter in a generic instantiation \nif this class is a subclass of the bound of the class parameter. To guarantee the correctness of a generic \ninstantiation, an imitation relation between the bound and the actual class parameter is required. Imitation \nmeans that the behaviour of the subclass and the behaviour of the superclass follow the same pattern. \nThis is sufficient for the replacement of the definition of the superclass by the subclass as a whole \n(but not on an object per object basis as with conformance). Imitation is also the prerequisite for correct \ncomposition with inheritance. Design Strategy The design strategy of 10-14 is built on the compatibility \nnotions introduced above. Basically, the design strategy consists of separating modeliing (what is to \nbe done) from implementation (how it is done). Systems built according to the object-oriented approach \nmay be described as a collection of objects which exchange messages. Thus, we may model such a system \nby giving the behaviour of each object. This can be done by defining a set of abstract classes describing \nthis behaviour. In analogy to modular programming we call these classes interface classes. A lot of these \ninterface classes may have functionality in common. This common functionality should be factored out \nexplicitly to get a set of orthogonal interfaces. Classes which express the common functionality of interfaces \nare called conceptual classes in 10-14. Interface classes must imitate the conceptual classes they inherit \nfrom. Implementations have to be provided for the interface classes. Theses classes are called implementation \nclasses. For each interface class there may be several implementation classes. Implementation is done \nby abstract programming. This means that all entities are only used via an interface class. No implementation \ndetail of an entity, such as its instance variables, is exploited in other classes. An implementation \nclass may either conform to its interface or imitate its interface depending on the purpose of the implementation \nclass. The quick implementation of interfaces must be especially supported. It is possible to build partial \nimplementations for each interface class which may be inherited and reused by implementation classes. \nPartial implementations rely on the fact that it is often possible to implement methods in terms of others \nindependent of the representation details of an implementation class. These method implementa- tions \nmay thus be reused in all implementation classes. The relation between an implementation class inheriting \nfrom a partial implementation is the imitation relation. This design strategy supports the development \nof class hierarchies, which are easy to understand, which contain classes that may be safely composed \nand have thus a high degree of reusability.  Current Status and Further Work So far we have identified \nand described the basic concepts which should be contained in 10-14. Beside the concepts discussed, this \nincludes the logical specification of class behaviour, the formal OOPSLA 92 -1.50-Vancouver, British \nColumbia proof of the validity of both kinds of inheritance and the formal development of classes. There \nare high correcmess requirements for safety critical appli- cations and for catalogues of reusable software. \nTherefore, we think that a formal approach for software development is needed for such applications. \nWe have also fixed a set of case studies to evaluate 10-14. In the future we will apply 10-14 to the \ncase studies mentioned above. With these case studies we intend to show that our software development \nmethod is a practically useful strategy. Additionally, we want to investigate what kind of proof obligations \noccur when validity of inheritance is proved and how they may be discharged Furthermore, we will explore \nthe usage of interactive and automatic theorem provers for carrying out such proofs.  References [weber \n911 Franz Weber. Reusable Sofware Catalogues-Design and Retrieval Support. Technical Report ProSt 91/3. \nFZI, 1991. PWeber 921 Franz Weber. Getting Class Correctness and System Correcmess Equivalent. Proceedings \nof TOOLS USA 92. Prentice Hall, 1992, to appear. Contact information: Franz Weber Forschungszentrum \nInformatik (FZI) Haid-und-Neu-St&#38;e 10-14 D-75 Karlsruhe 1, Germany e-mail: fweber@fzi.de S-10 October \n1992 -1.51. Addendum to the Proceedings  \n\t\t\t", "proc_id": "157709", "abstract": "<p>Assembling classes to form systems is a key concept in object-oriented software development. However, in order to be composed, classes have to be compatible in a certain way. In current object-oriented languages the compatibility with a specific behaviour is expressed by inheritance from a class which describes this behaviour. Unfortunately inheritance is neither intended to express compatibility nor does it enforce compatibility. This deficiency may lead to inconsistent systems. Therefore, in the Project &#8220;10&#8211;14&#8221; inheritance is restricted to express compatibility between classes. Two kinds of compatibilities are distinguished: compatibility required for the integration of subsystems (conformance) and compatibility required for reuse (imitation). A formal basis for the discipline is developed in order to get mathematically precise notions and to enable the verification of object-oriented systems. A design strategy is built on top of these compatibility notions. In actual case studies the discipline has already shown to support a clean design and to promote the reusability of class hierarchies.</p>", "authors": [{"name": "Franz Weber", "author_profile_id": "81332534603", "affiliation": "", "person_id": "PP31099045", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157738", "year": "1992", "article_id": "157738", "conference": "OOPSLA", "title": "Towards a discipline of class composition", "url": "http://dl.acm.org/citation.cfm?id=157738"}