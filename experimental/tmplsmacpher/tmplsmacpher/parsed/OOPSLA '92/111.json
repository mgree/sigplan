{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 to the Vancouver, British Columbia, Canada 5-IO October 1992 Proceedings The Object-Oriented \nReport by: Joseph Bergin Pace University This paper describes the design of a course in Data Structures \nfrom the object oriented standpoint. It discusses objectives and how they are met as well as course materials \nand strategies. This course has been offered to Sophomores at Pace University since 1990. Materials, \nincluding a manuscript for a textbook, have been developed in both C++ and Object Pascal. The C++ version \nof the text is to be published by McGraw-Hill in 1993. Background: Data structures and the idea of data \nabstraction has been fundamental to computer science education since the early days. In Curriculum 68 \n[ 11 there was a separate course covering data structuring techniques and simple algorithms for their \nmanipulation. Material covered included lists, trees and graphs as well as searching and sorting algorithms. \nA decade later, Curriculum 78 [2] includes much of this material in the second course. This course includes \nsimple notions of efficiency, complexity, and correctness. More recently the Task Force on the Core of \nComputer Science [4] has included this material as the first of nine fundamental areas of computer science. \nExamination of these course proposals shows a trend in computer science education of migrating topics, \ntechniques, and ideas from advanced/ graduate/ professional levels down to elementary and even introductory \nlevels. Program verification [5], for example, was once thought to be a very advanced Educators Symposium- \n  Data Structures Course topic, suitable for graduate students. Today it is commonly introduced in the \nsecond course [6]. The course described in this paper is an evolutionary development of the data structures \ncourse that hopes to strengthen students development in the early semesters by introducing and emphasizing \nthe ideas of abstraction and encapsulation. Objectives: The following, though not a complete list, give \nan idea of the thinking of the author in developing this course and its materials. It was believed that \nevolutionary change was better than a revolution, in that it would be more likely to find acceptance \nand be less risky for the students involved. 1. Use a language which is small and easy to master. 2. \nIntroduce and reinforce the idea of abstraction, especially procedural abstraction and data abstraction. \n 3. Develop and emphasize interrelationships between data abstractions. 4. Modularize programs and \nemphasize data encapsulation and data hiding. 5. Give students the opportunity to see, use, and modify \nlarger programs. Programs should be sufficiently large and complex that simple software engineering techniques \nare required.  6. Introduce, develop, and thoroughly integrate object oriented programming technology \nand style.  7. Introduce fundamental data structuring techniques and algorithms.  8. Introduce and \ndevelop programming with indirection. 9. Introduce and develop algorithm verification.  10. Introduce \nand develop algorithm analysis. 11. Introduce development of programs from specifications. 12. Introduce \nstudents to topics fundamental to computer science and its history, such as finite automata, grammars, \ndata representation, etc.  Language Choice: Because of its emphasis on data encapsulation, the first \ndecision was to employ object oriented technology in this course. The idea of class in object oriented \nprogramming closely matches the idea of data abstraction with close binding between data structures and \nthe procedures that modify them. Object oriented programming also typically starts with a large source \nlibrary as a given. This seems to fit well with the idea of quick development of larger programs which \ncan be useful in meeting the objectives of this course. Also, the emphasis in object oriented programming \non data centered design seems to match the main goals of this course quite well. It was felt that merely \nemploying an object oriented style in a language like standard Pascal was not appropriate. Pascal s chief \ndrawback in the curriculum is that it already requires too much from the programmer s style to mitigate \nits drawbacks. Requiring more seems to be a step backwards. Choice of language then becomes a problem. \nThe obvious choice is Smalltalk, but this seemed to require changes in following courses that many would \nnot be willing to make. If the goal were to choose an object oriented language for the entire curriculum \n(or most of it) then Smalltalk would be a good choice. Languages that were considered for this project \ninclude Smalltalk, Simula, Eiffel, C++ [7], and Object Pascal [HI. With the hope that the complexity \ncould be contained through use of a suitable subset of the language, the choice was made to use C++, \nthough the materials also exist in an Object Pascal format. The book on which the course is based [3] \nis built around a class library of approximately 90 base classes, with over a thousand methods, distributed \ninto about 40 compilation units. Other suitable languages are Modula-3 and the latest Object Extensions \nto Pascal as they are being defined by the Joint Pascal Committee of ANSI/IEEE. Methodology: The data \nstructures course must deal first with the ideas of data abstraction and secondly with the design and \nimplementation of several common algorithms. Data abstraction provides the theoretical basis on which \nthe data structures and algorithms stand, Typically the data structures presented are stacks, queues \nand other linear structures as well as binary trees and some types of general trees. Some, but not all \ncourses, will deal with various numeric representations (large integers, complex numbers, etc.). More \nambitious courses will deal with simpler aspects of graphs and their representations. For all of these, \nvarious implementations are presented and there is a discussion of the tradeoffs inherent in the various \nimplementations. Algorithms typically taught are searching and sorting, including tree walks and binary \nsearch trees of various kinds. In object oriented programming the user typically has a large software \nlibrary in source form at his or her disposal. Development proceeds by examining the library (class hierarchy) \nfor classes similar to what is needed in the current application and either using them directly, or creating \nnew classes derived from those already there. Much of the functionality is inherited horn the classes \nalready in place and does not need to be rewritten. A typical application consists of more than 75% existing \ncode. A typical class library has two rather different components. The first of these is the interface \nlevel, which consists of classes to implement the user interface. Generally this code consists of classes \nto create windows and menus, handle the keyboard and mouse, and handle common functions like printing \nand filing. The course does not consider this level of component. The second level of functionality contains \nlow level or data level constructs that are used across a wide range of applications. These fall primarily \ninto two categories, the collections and the magnitudes. Collections consist of lists, stacks, queues, \netc. and are responsible for managing aggregates of objects. Magnitudes include things which can be compared \nby size, such as the numeric classes as well as associations which are fundamental to dictionaries. The \ndata structures course will focus on this latter level of functionality. The application programmer will \ntypically write bridge or glue code, which fits between the interface level code and the data level code, \nand which implements the specific features of the application. While the production programmer must certainly \nbe an expert in the use of the interface level code to create an application, the content of this code \nis too rich in detail and too poor in intellectual content to spend much time with in a foundation course. \n The key idea of the course is to examine the elements in the class hierarchy of Figure 1 (inheritance \nshown using indentation), and to use objects of these classes in several moderately large applications \nof varying difficulty. Most of this library of software is made available to students. All of the interfaces \nof all of the units are made available in machine readable source form. All methods that are trivial \nto implement but needed for the correct operation of interrelationships in the library are also provided. \nOther methods, which we expect students to build, are given to students in skeleton form such as: void \nSList::insert(PObject o){ 1; In fact it may be useful to present all of the library in source form, \nwith the idea that here we have one implementation, and some assignments will be to improve it, and others \nto replace major parts of it with better implementations. Students will thus see and use a larger quantity \nof software than they can be expected to write. The quantity is sufficient that structuring mechanisms \nare necessary for its understanding. Note: This is a conceptual hierarchy. The actual implementation \nis different. OBJECT Magnitude association character integer fraction largeInteger complex (exercise \nonly) Collection bag set dictionary (actually an implementation of a function) list stack queue \n DEQueue sortedList binaryTree binarySearchTree AVL Tree (introduce) generalTree (firstChild-nextSibling) \n234 Tree (introduce) S-10 October 1992 -279- BTree (introduce) fixedSizeCollection interval string \ngraph Figure 1. These components are not all handled to the same level of detail. It is important to \nfocus on the linear and tree structures within collections as this is the area richest in algorithms. \nIt is also necessary to deal with associations and some of the numeric classes within magnitudes to give \nbalance (not everything is a collection) and to present fundamental ideas about data representation and \nimplementation needed at this level in the curriculum. It is important in presenting this material that \nthe instructor do more (much more) than present various implementations. It is necessary at all times \nto reinforce the ideas of software specification and the idea that if we can trust that software meets \nthe specification it can be used without regard to the implementation. This encourages, in the minds \nof the students, a de-coupling of the ideas of a data structure from its implementation. Therefore the \ncourse could (and the book does) proceed from (1) a general discussion of object oriented programming, \nto  (2) a general description of a specific class hierarchy, to  (3) a specific discussion and description \nof the specifications of the classes in the above list, to (4) applications which use the above classes \nin important ways, and finally to (5) implementations of major elements of the classes.  Some applications, \nwhich can easily take advantage of the above, are finite automata simulators (using lists, stacks, and \ndictionaries), symbolic calculators (lists, trees), infix to postfix translators (stacks, strings, queues), \nand simple database or spreadsheet programs (lists, numeric and string classes). These have the additional \nadvantage of showing students some of the intellectual background of computer science, such as the Turing \nmachine. Two deeper applications are program parsers and verifiers (using trees) and database design \nnormalizers (strings, sets). A program verifier is an especially rich area, in that it teaches much about \nseveral fundamental ideas of computer science as well as requiring solid data structuring mechanisms \nfor its organization.  Addendum to the Proceedings It is important to first impart a notion that the \nsoftware may be used once its specification is understood. This can be achieved via a discussion of the \ninterfaces of several important classes. Following is an (unannotated) version the interface for the \nlist class and its associated classes. Pre- and post-conditions should be developed in class for many \nof the methods, especially those like SList::insertFirst and SList::remove which modify the storage structures. \nFigure 2. is an excerpt from the header file of the compilation unit that exports SList. Most of the \nprotected/private details have not been included here. //REQUIREMENTS For Use // initLists(); class \nSList: class SListIterator; class SListPosition; typedef SList * PList; typedef SListIterator * PListIterator; \ntypedef SListPosition * PListPosition:  enum WhereFound {IsHere, IsNext, NotFound}; class SList: public \nSCollection { public: SList(void); virtual -SList(void); virtual PObject first(void); virtual void insert(PObject); \nvirtual void remove(PObject); virtual void removeFirst(void); virtual PIterator newIterator(void); virtual \nPListPosition newPosition(void); virtual char empty(void); virtual char element(PObject); virtual void \nwriteIt(void); protected: class SListNode; typedef SListNode *PListNode; // nested protected class \nSListNode class SListNode : public SObject ( public: SListNode(PObject); virtual PObject value(void); \nvirtual void writeIt(void) ; virtual PListNode next (void) ; ); // end list node class ); // end list \nclass class SListPosition : public SPosition { public: SListPosition (PList L); virtual void next(void); \nvirtual void insertFirst(PObject); virtual void insertAfter(PObject); virtual PObject at(void); virtual \nvoid atPut(PObject); virtual char last(void) ; virtual void toFirst(); virtual void deleteNext (void); \nvirtual WhereFound search(PObject); 1; class SListIterator: public SIterator { public: SListIterator(PList \nL); virtual char nextItem(PObject6); virtual void reset(void); 1; void initLists(void);  Figure 2. Only \na small part of this needs to be presented initially, Note however that an attempt has been made to separate \nfunctionality into four classes: nodes hold references to data, a list is a linked list of nodes, positions \nrefer abstractly to locations in the list (physically, to nodes), and iterators implement ways of applying \nsome function to all elements of a list. The nodes, however, are implemented as a hidden nested class, \nwhich means that, to a client program, they are invisible. Thus, to a client, the list consists of a \nlist of values, not nodes. Ideally the implementation variables of the classes (not shown here) are not \npresented in the first cycle, so that the fact that we have a linked implementation is not obvious at \nfirst. Once the specifications of the classes in the hierarchy are discussed in some detail students \nmay proceed to examine applications that use it. Figure 3. is a complete declaration of a deterministic \nfinite automaton simulator class. The implementation uses our string, character, association, and dictionary \nclasses. Implicitly, it also uses lists and sets. PDFANode newDFANode(char IsFinal); class SDFANode: \npublic SObject( public: SDFANode(char final = FALSE); virtual -SDFANode(void); virtual char member(classtype \nc); virtual void writeIt(void); virtual void addNeighbor(PDFANode nbr, PCharacter transition): virtual \nvoid run(PString tape): virtual PObject Clone(void); protected: PDictionary fNbrs; char fIsFina1; \n virtual int sizeOf(void); 1; //REQUIREMENTS For Use // initLists() ; // initCharacters(); Figure \n3. This class implements a DFA as a distributed set of nodes. Each node maintains a dictionary containing \nthe names and references to its neighbors, in effect a projection of the transition function onto a node. \nA dictionary is a set of associations (pairs) and a set is built from a list. Importantly, we may use \nthese abstractions before examining the implementations. The run method proceeds by examining the string \nit is sent, if it is not empty it strips the first character, looks in its dictionary for a match, which, \nif found, causes the node to send a run message to the corresponding neighbor node. Following development \nof a few such applications using the class library students can begin to examine the implementations \nof the classes and to develop parts of it themselves. Emphasis should be on the development of general \npurpose, reusable, well designed components, carefully implemented. It is here that one emphasizes abstraction, \nencapsulation, information hiding, representation, and the separation of specification and implementation. \nEmphasis will of course be on those methods exhibiting interesting algorithms.  S-10 October 1992 -Bl- \nThis is the most important segment of the course, dealing as it does with the fundamental data structures \nand their implementation and the algorithms necessary for their manipulation. It is here that object \noriented programming has the largest benefit. To use C++, it is necessary to design and write down a \nspecification for a class before you write down an implementation. The specification is nicely encapsulated \nin a class declaration and made public by a compilation unit using a header file. One can then develop \nvarious implementations of the class and easily integrate them into software designed to use them. In \nthe above example, a dictionary is a specialization of a set, which has a list member variable, which \ncurrently has a linked representation. The implementation of a dictionary could be changed and the above \nDFA unit linked to the changes and we could explore the differences in efficiency. It is also necessary \nto teach the various logical relationships between abstractions and how they translate to relationships \nbetween classes. Students should learn about isA, isLike, hasA, and collaborates with relationships. \nThey should also learn that inheritance may be used to implement all but the last of these relationships, \nbut with different degrees of success, especially in large projects.   Difficulties: There are a number \nof difficulties that must be creatively overcome. The first, and most important difficulty is that object \noriented programming is a different paradigm than students may be used to. It is important to deal specifically \nwith a mental model of programming that is useful in OOP. The model of autonomous actors interacting \nvia messages, able to send and receive messages, and able to save and modify a purely local state is \nvery useful. I augment this model with the idea of a processor being passed along with a message and \nthe receiver using the processor to execute a method in fulfillment of the message, returning the processor \nalong with any returned results to the sender. We must be specific in defining programming as doing data \ndecomposition of a system rather than procedural decomposition. Said another way, the data decomposition \ncomes first, with the procedural decomposition following. The next difficulty is the relative complexity \nof C++. This has been met by building the library using only a subset of available features, thus lessening \nthe load that students must bear in the language area so that they may focus on the ideas of data abstraction \nand design. The library does not use reference variables (except reference parameters), operator Addendum \nto the Proceedings overloading, tricky syntactical forms, or many of the operators of C++. It also focuses \nentirely on indirect (pointer to) objects. On the other hand, it makes extensive use of inheritance and \nvirtual functions, as well as a limited amount of class nesting and multiple inheritance (mixin classes). \nThe library was developed with pedagogical, rather than commercial, goals as the primary consideration. \nIt has been used successfully, however, in a number of applications. The next difficulty is that the \noverall methodology of creating a general purpose library of low level reusable service modules does \nnot lend itself well to programming with arrays. The data structures course, however, traditionally discusses \nsorting and searching of arrays. The array class, which treats arrays as objects, overcomes this difficulty. \nWe may therefore treat all of the standard topics in an object- oriented framework. Another difficulty, \nto some, will be the use of explicit pointer variables. Students will be programming extensively with \npointers so as to obtain the benefits of polymorphism via virtual functions. In standard imperative languages \nthere is almost a prohibition against aliasing. This has arisen because of the difficulty of writing \ncorrect programs which contain aliases. In object oriented programming abasing is a fundamental technique. \nIt is the basis of the collection classes. Two different sets will contain references to the same objects, \nrather than different objects with the same bit representation. The problems about aliasing don t go \naway however, as C++ does not have garbage collection. It is necessary, therefore to deal conceptually \nwith the idea of object lifetimes, and the creation/disposal problem. Some of the classes discussed are \nan attempt to overcome the fact that C++ is a hybrid language. It has well designed objects, but it also \nhas simpler constructs like integers, characters, and structs. We want to have a generic stack class \nin which we may hold data of any type. Therefore we declare stacks to be stacks of objects and implement \na class of integers and one of characters so that we may stack these as well as more complex things. \nBut then there are conceptual issues relating to the identity of the objects in such classes. For example, \nin the integer class there should be only a single object representing six. Different references to an \nobject live should all refer to the same object. This requires careful implementation and introduces \na natural use of hash tables within the system itself. As such, the difficulty has been turned to an \nadvantage as it shows an important use of one of the structures developed in the course. Another possible \nsolution to this would be to use templates, but I have not done so to avoid a level of complexity in \nthe class structure that is only needed in a few cases. This solution also makes heterogeneous collections \nnatural. Another difficulty that arises in the use of C++ is that the language does not give full support \nto the idea of interrelated data abstractions. If friendship were inherited then this could be easily \novercome, but, as it is, it is occasionally necessary to choose to implement a class as a subclass of \nanother class to obtain visibility of certain implementation details, when it would be more natural to \nuse an instance variable instead. An example occurs when trying to build a bag abstraction using a list. \nIf bag doesn t inherit from list (logically it should not) but uses an instance variable of type list, \nthen you can get no access to the nodes out of which the list is built. Even when you do inherit from \nlist it is difficult to build a more suitable node class for bags and get full access to it through the \nexisting list code. Solutions to this in C++ are hard to find. One option is to make nodes public, but \nthen clients may manipulate them. One option is to rewrite the list classes so that bags are friends. \nAnother is to inherit from list and use protected functions of the parent classes for access. Finally, \none may rebuild much of the list infrastructure to gain the added functionality. All of these have drawbacks. \nUnfortunately, the cleanest way is to rebuild which entails redoing much of the work of positions and \niterators as well as lists and nodes. Finally, instructors should be aware that this course has a lot \nof material to cover. In fact, however, the time spent on discussing the concepts of object- oriented \nprogramming and the structure of the library can be made up later due to the increased efficiency with \nwhich one can teach when students may see the overall structure, and also have a growing library of modular \nunits on which they may build.  Benefits: The largest benefit of using object oriented programming \nin the data structures course is that C++ naturally uses data encapsulation (into classes) which makes \nit easier to emphasize data abstraction. The language also permits separation of functionality into related \nclasses. This was shown in the list class, in which the ideas of nodes, lists, positions and list iterators \nare built in different classes, and their relationship emphasized by inclusion in the same unit. I have \nhad a chance to examine the later work of students who have learned this approach. My experience is that \nstudent s will use the methodology later, even when programming in languages that do not support the \nobject oriented paradigm at all (e.g. Pascal). They seem to do a better job than others in decomposing \ntheir programs rationally. Their data structures are single purpose, with clearly defined interfaces, \nmanipulated only through associated procedures. They partition a problem logically into compilation units \nwhich implement a single abstraction or set of related abstractions. They also tend to re-use more of \ntheir previous work than other students do. To achieve this, however, requires that the student truly \nunderstand the concepts of object oriented programming. Those who see it as a mechanical approach to \nreuse or as a simple addendum to regular programming do not do so well.  Conclusion: It is time that \nwe bring more powerful paradigms into the computer science curriculum. Object oriented programming is \na powerful method with advantages for learning as well as for efficient software construction. To be \nsuccessful it should be introduced at an early point and where it will have the greatest benefit. To \nbe successful it must be completely adopted, and not treated as an add on to a traditional course. To \nbe object oriented it must deal with issues beyond language, such as the class hierarchy. As an interim \nstep, the data structures course seems to be a good choice for the introduction. Note: A preliminary \nreport on this project was presented at the Symposium on Object Oriented Programming Emphasizing Practical \nApplications (SOOPPA) held at Marist College, Poughkeepsie, NY, in September 1990. Bibliography: Ul \nAtchison, W., et al, Curriculum 68, ACM Curricula Recommendations for Computer Science, Vol 1. 1983. \nm Au&#38;g, R., et al, Curriculum 78, ACM Curricula Recommendations for Computer Science, Vol 1. 1983. \n131 Bergin, J., A Course In Data Abstraction: The Object-Oriented Approach using C++, to be published \nby McGraw-Hill in 1993. [41 Denning, P. et al. Computing as a Discipline, CACM V32 Nl, January 1989. \n[51 Ellis, M, and Stroustrup, B., The Annotated C++ Reference Manual, Addison-Wesley, 1990. Gries, D., \nThe Science of Programming, Springer-Verlag, 1981. Kruse, R., Data Structures &#38; Program Design, 2nd \nEd. Prentice-Hall, 1987. Tesler, L., Object Pascal Report, Apple Computer, 1985.  Contact information: \nJoseph Bergin Pace University New York, NY 10038 berginf@pacevm.bitnet   \n\t\t\t", "proc_id": "157709", "abstract": "", "authors": [{"name": "Joseph Bergin", "author_profile_id": "81314493368", "affiliation": "", "person_id": "PP31072425", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157831", "year": "1992", "article_id": "157831", "conference": "OOPSLA", "title": "The object-oriented data structures course", "url": "http://dl.acm.org/citation.cfm?id=157831"}