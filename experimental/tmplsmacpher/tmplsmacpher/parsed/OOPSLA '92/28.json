{"article_publication_date": "12-01-1992", "fulltext": "\n Vancouver, British Columbia, Canada 5-IO October 1992 Texas: Good, Fast, Report by: Vivek Singhal Sheetal \nV. Kakkad Paul R. Wilson The University of Texas at Austin Overview The Texas persistent store is a portable \nand efficient system providing persistence and huge address spaces for C++. Texas uses pointer swizzling \nat page fault time to translate addresses from a long ( persistent ) format to the actual hardware- supported \nformat, using virtual memory access protections to shield the program from ever encountering untranslated \npointers. Pointer swizzling at page fault time provides performance comparable to a normal demand-paged \nvirtual memory, and makes the implementation surprisingly simple-Texas is only a few thousand lines of \ncode, running on unmodified SVR4 Unix and ULTRIX, and it is compatible with most existing C++ compilers. \nTexas is freely available and may easily be included in application programs. 1 Background Persisfent \nprogramming languages allow programmers to avoid saving data to files, and instead to simply make heap \ndata persist from one run of a program to another. That is, rather than explicit translation, objects \nfrom a pointer-linked heap format to a low-level file data representation, they may be transparently \nflushed out to disk intact. This avoids the loss of pointer semantics (i.e., object identity) which typically, \nfollows from conventional l/O.  Addendum  A 92 to the Proceedings Poster Submission- Cheap Persistence \nfor C++ Persistent programming languages free programmers from this burden, but they require special \nimplementation techniques to allow the use of a very large pointer-linked heap in place of most file \noperations. Persistent heaps may be very large, because all of the objects in a large system may be addressed \nindividually, rather than being separated into files. Checkpointing and recovery are essential, to avoid \nthe corruption of file-like data in the face of crashes. We use pointer swizzling at page fault time \nto address huge amounts of data without incurring continual runtime costs; we are also implementing log-structured \nstorage and sub-page logging to keep checkpointing costs low. 2 Pointer Swizzling at Page Fault Time \n Huge address spaces require long pointers, but most hardware does not directly support them. For high \nperformance systems, it is desirable that most pointers be represented in the actual hardware address \nformat. Pointer swizzling systems convert pointers from a long representation into actual hardware addresses \nas needed. Conventional pointer swizzling systems incur significant overhead, however, because each pointer \naccess requires a check to see if it has been swizzled yet. This checking cost reduces the efficiency \nof programs and complicates the implementation of the language-the compiler 5-10 October 1992 - 14.5 \n- Addendum to the Proceedings must be able to cope with multiple pointer formats, and emit the proper \nchecking arid conversion code. Pointer swizzling at page fault rime lJVi191, LLOW9 1, WK92] avoids these \nproblems by using the virtual memory system to trigger the checking and translation of pointers before \nthey are ever encountered by the running program. The compiled code needn t know anything about long-format \npointers, and may perform pointer operations in the usual way, i.e. dereferencing a pointer is a single \nmachine instruction. To accomplish this, virtual memory access protections are used to ensure that the \nswizzling of pointers happens one step ahead of the program s actual access patterns. All pages of memory \nare access protected initially (using mprotect ( ) ); when a page is faulted on, all of the pointers \nin the page are translated. To enable this translation, it must be possible to determine where in the \nhardware-supported address space the pointer should point i.e. where the pointed- to object is or will \nbe in the virtual memory address space. If the pointed-to page is not already in the address space, a \npage of address space must be reserved for it. Once that is done, the translation is trivial. The high \nbits of the address are changed from the long format to the short format, i.e., the virtual memory page \nnumber is substituted for the longer persistent page number. Combined with the offset within the page, \nthis yields an actual virtual memory address. Address translation thus occurs in a pagewise wavefront \nahead of the running program-when a page is touched, the protection fault handler reserves address space \npages for any other pages it holds pointers to. This does not require the actual movement of data into \nthose pages, however. The actual copying of data can be just as lazy as in a normal virtual memory-the \nreserved pages of address space can simply be access protected and filled in later, as needed. Given \nflexible virtual memory primitives (such as Mach s), no backing store needs to be allocated for such \npages until they are actually touched. In our scheme, pointer swizzling is nearly, orthogonal to issues \nof actual storage. Swizzled pages may be paged out to backing store; conversely, page contents may be \nunswizzled and written back to the persistent store, independently of their being mapped into virtual \nmemory.  3 Log Structured Storage To be useful, a persistent store must provide more than just large \naddress spaces. It must also provide crash recovery features to avoid the corruption of long-lived data. \nIdeally, it should provide very fast checkpointing to support fine-grained transactions like a database. \nLike our approach to address translation, we use page-wise techniques for checkpointing. This avoids \ncontinual overhead in marking changed objects so that they can be identified and saved (written out to \ndisk or other nonvolatile memory) at a checkpoint. If a page was modified after a checkpoint, that page \nwill be written out to a log as part of the next checkpoint. Currently, we use simple write-ahead logging; \nchanged pages are written in two phases. First, changed pages are written to a log file. Once all of \nthe changes are thus committed to non-volatile memory, the persistent store itself is updated. If a crash \noccurs during the first phase, the partial changes will be thrown away at restart time, restoring the \nprior checkpointed state. If a crash occurs during the second phase, the phase can be repeated until \nall of the updates have been made without crashing. While this simple minded scheme works, it is unnecessarily \ninefficient. We are currently implementing a log-structured storage system, which is essentially the \nlower levels of a log- structured file system [RO9 1, SKW921. In the log- structured storage module, \npages have no permanent location on disk, and changed page versions are simply written to the log once. \nChanges can be committed in an all-or-nothing, fashion by writing a single record that updates indexing \ninformation, incorporating all the changes atomically. Log- structured storage also allows changes to \nbe written contiguously (irrespective of which logical blocks are being written), making it possible \nto write a large number of changed blocks without seeking. We expect log-structured storage to make our \npagewise persistent store competitive with conventional objectwise schemes. If not, and performance is \nlimited by sheer disk bandwidth, we expect sub-page logging to make up the difference. Rather than writing \nout entire dirty pages, we can keep clean copies of written-to pages, and only write out the difference \nbetween the two. This requires some extra memory to store the clean versions, and extra CPU cycles to \nperform the diffing of pages, but we believe it is good trade-off, and that it s increasingly attractive \nas CPU speeds increase relative to disk speeds [SKW92]. 4. Language and Compiler Issues Pointer swizzling \nat page fault time requires very little cooperation from the compiler and/or the programmer. Because \ncomplied code never encounters OOPSLA 92 -146-Vancouver, British Columbia pointers that haven t already \nbeen swizzled, conventional compilers can be used. We currently use the Free Software Foundation s GNU \nC++ 2.2 compiler. The main constraint is that existing code be relinked with a modified heap allocation \nroutine, which records how pages are divided up into chunks for object allocation, and which puts runtime \ntype descriptors in the headers of objects. (The latter is already an optional feature of GNU C++, but \nthe same effect can be achieved for most compilers with the use of a simple preprocessor.) Pointer swizzling \nat page fault time imposes surprisingly few restrictions on programming styles. (The main one is the \navoidance of pointer fields in the variant part of untagged unions.) Old code that doesn t follow the \nrules can still be used if it is not necessary for the old style objects to be persistent and use long \npointers. 5 Conclusions Texas is a simple persistent store which is easy to use and offers good performance. \nPointer swizzling at page fault time simplifies the interface between the language implementation and \nthe persistent store. Texas performance is competitive with conventional virtual memories lWK921, while \noffering persistence and crash recovery. Log- structured storage and sub-page logging promise high performance \nfor fine-grained checkpointing as well [SKW92].  References lLLOW911 Charles Lamb, Gordon Landis, Jack \nOrenstein, and Dan Weinreb. The ObjectStore database system. Comm. ofthe ACM, 34(10):50-63, October 1991. \n[RO91] Mendel Rosenblum and John K. Ousterhout. The design and implementation of a log structured file \nsystem. In Thirteenth ACM Symposium on Operating Systems Principles, pages 1-15, Pacific Grove, CA, October \n1991. [KW92] Vivek Singhal, Sheetal V. Kakkad, and Paul R. Wilson. Texas: an efficient, portable persistent \nstore. In Fifth Intl. Workshop on Persistent Object Systems, Pisa, Italy, September 1992. [Wilgl] Paul \nR. Wilson. Operating svstem support for small objects. In Zntl. Workshop on Object Orientation in Operating \nSystems, Palo Alto, CA, October 1991. IEEE Press. Revised version to appear in Computing Systems. [WK92] \nPaul R. Wilson and Sheetal V. Kakkad. Pointer swizzling at page fault time. In Inti. Workshop on Object \nOrientation in Operating Systems, pages 364-377, Paris, France, September 1992.  Contact information: \nVivek SinghaI Sheetal V. Kakkad Paul R. Wilson Department of Computer Sciences The University of Texas \nat Austin Austin, Texas 78712-1188 oop@cs.utexas.edu S-10 October 1992 - 147 - Addendum to the Proceedings \n \n\t\t\t", "proc_id": "157709", "abstract": "", "authors": [{"name": "Vivek Singhal", "author_profile_id": "81100064182", "affiliation": "", "person_id": "P291872", "email_address": "", "orcid_id": ""}, {"name": "Sheetal V. Kakkad", "author_profile_id": "81100033041", "affiliation": "", "person_id": "P263122", "email_address": "", "orcid_id": ""}, {"name": "Paul R. Wilson", "author_profile_id": "81100530836", "affiliation": "", "person_id": "PP39081095", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157737", "year": "1992", "article_id": "157737", "conference": "OOPSLA", "title": "Texas: good, fast, cheap persistence for C++", "url": "http://dl.acm.org/citation.cfm?id=157737"}