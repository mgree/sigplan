{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum to the Proceedings Poster Submission- Interfacing Different Object-Oriented Programming Languages \n Report by: Scott Danforth IBM Object Technology Products non-OOP) languages-both for subclassing, and \nfor Abstract object creation. This extends the utility of OOP class This poster presentation illustrates \nthe use of SOM libraries and makes it possible to define multi- (the IBM System Object Model) for interfacing, \nlanguage objects, whose supporting methods and different object-oriented programming (OOP) instance variables \nare provided by different languages. Our approach allows classes defined in languages.one OOP language \nto be used by different (possibly L Figure 1 - SOM provides a Common Object Model for use by different \nlanguages S-10 October 1992 -l95-Addendum to the Proceedings  Summary SOM 111 can be used to integrate \nclasses provided by different OOP languages, making these classes available across language boundaries-even \nto non- OOP languages. This is illustrated in Figure 1, which shows SOM as a central hub integrating, \ndifferent languages and object models. This figure illustrates two important aspects of our approach. \nFirst, SOM is used as a central component, available for use by a variety of different languages regardless \nof their object models. Second, becauseof this, the order @ problem of interfacing, different languages \nis reduced to an order N problem. Ll SOM is not a programming language; SOM classes are made available \nin a language-neutral fashion via an API accessible to both OOP and non-OOP languages. This is an initial \nstep in the direction of interfacing different OOP languages, and is illustrated in Figure 2. In this \nfigure, a SOM class named A defines the methodfoo, and usage bindings for this class are provided to \nthe client languages LI and L2 (the language used to implement the SOM class is not important - the SOM \nAPI is used to define the class and register a procedure that supports thefio method on objects that \nare instances of this class). SOM L2 ,.--0A.---.-.-..   I-mI.--------.... 1-1-1.. 0 --1-w.. * /..--0---0A \nDefinition foo Ll Proxy L2 Proxy Figure 2 -Defining and exporting SOM classes to different languages \nusing Proxies When a given client language has an object model, it is possible to provide usagebindings \nfor a SOM class via a proxy class, expressed in terms of the given client language. Users of the client \nlanguage then see SOM classes in terms of the client language and the client language implementation \ncan provide type checking support for SOM class and SOM object usage. When a client language does not \nhave an object model, usage bindings cannot be expressed in terms of classes. Then, some other language-specific \napproach is used to hide the details of using the SOM API, and the proxy-based techniques we illustrate \nhere are modified accordingly. Stated in terms of Figure 2, an example of interfacing different OOP language \nwould be to (1) allow LI to subclass its proxy for A, creating a new class B that overridesfoo, (2) create \na SOM class proxy corresponding to this new class, and (3) make the new class available (by SOM proxy) \nto L2 as well. Figure 3 illustrates the logical form of one possible solution to this problem, using \narrows to represent proxy classes deferral to appropriate definition of foo. OOPSLA 92 -l96-Vancouver, \nBritish Columbia Figure 3 -Interfacing different In general, three requirements of a solution to the \noverall problem of interfacing different OOP languages can be identified: 1. Method calls (i.e., virtual \nfunctions) must be correctly dispatched. This is arranged by appropriate definition of classes. As illustrated \nin the poster presentation, SOM s capability for dynamic class definition is extremely useful in this \nregard. 2 When the calling language is different from the language in which the method is implemented, \nit is necessary to provide argument conversion (i.e., from a SOM object to a client language object, \nor vice versa). This requirement embodies deceptively subtle complications when the client language itself \ndoes argument conversion when calling methods (e.g., as in C++). 3. To provide the full benefits of \npolymorphism, proxy classes should be related in their class hierarchy in the same way as the corresponding \nSOM classes are related. object-oriented languages Many details of importance in light of the above \nthree requirements are not illustrated by Figure 3. These are considered in the poster presentation. \nReferences [ll OS/2 2.0 Technical Library System Object Model Guide and Reference, IBM document 1066309,1992. \n Contact information: Scott Danforth IBM Object Technology Products IBM Zip 9370 11400 Burnet Road Austin, \nTX 78758 Office: 512-838-8074 Fax: 512-838-1032 shd@ot.austin.ibm.com S-10 October 1992 -l9l-Addendum \nto the Proceedings \n\t\t\t", "proc_id": "157709", "abstract": "<p>This poster presentation illustrates the use of SOM (the IBM System Object Model) for interfacing, different object-oriented programming (OOP) languages. Our approach allows classes defined in one OOP language to be used by different (possibly non-OOP) languages&#8212;both for subclassing, and for object creation. This extends the utility of OOP class libraries and makes it possible to define &#8220;multilanguage&#8221; objects, whose supporting methods and instance variables are provided by different languages.</p>", "authors": [{"name": "Scott Danforth", "author_profile_id": "81100337977", "affiliation": "", "person_id": "PP39070816", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157752", "year": "1992", "article_id": "157752", "conference": "OOPSLA", "title": "Interfacing different object-oriented programming languages", "url": "http://dl.acm.org/citation.cfm?id=157752"}