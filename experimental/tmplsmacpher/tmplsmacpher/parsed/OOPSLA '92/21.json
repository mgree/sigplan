{"article_publication_date": "12-01-1992", "fulltext": "\n Vancouver, British Columbia, Canada 5 - IO October 7992 Towards Report by: Bruce Anderson, University \nof Essex Introduction This report describes the workshop, but also describes the context in which it \ntook place. We did not use the workshop (nor its precursor at OOPSLA 91) to present our work (which we \ndid by reading the position papers), but to work together. Such an environment does not automatically \nproduce outputs useful to those who did not attend, but is a source of emerging ideas, new approaches, \nand new relationships. These ideas, approaches and relationships generate the context described here. \n Some Context Architecture We take architecture to mean the structuring paradigms, styles and patterns \nthat make up our software systems. They are overarching or pervasive structures. They are important in \nmany ways: they allow us to talk usefully about systems without talking about their detail; a knowledge \nof them gives us design choices; attention to this level can make systems have the properties we want, \nespecially reusability and extensibility Of course every system has an architecture, but if it has not \nbeen consciously created then the system may well be more muddled, both conceptually and in its code, \nthan is necessary. Addendum  A 92 to the Proceedings Workshop Report- an Architecture Handbook We \ndo not define architecture. Like Health or Quality, we can reach a productive shared understanding for \nthe purpose at hand without making a definition. Different groups will have different understandings, \nand these will be reflected in different practices: processes, checklists, libraries, diagrams. And different \nhandbooks. Note also that a system may contain several architectures, and that it may have a different \narchitecture when viewed from a different perspective. Many of our powerful yet ambiguous woids may be \nbrought into play: we are using an object-oriented paradigm to build a generic- application framework \nvia a delegation approach. Handbooks Once some level of consensus is reached in a community, it is possible, \nand worthwhile, to produce a handbook. So a company (for internal use) or a publisher (for sale) can \nfind someone (an editor) to put together such a book. The source materials for such a book would be found \nin the community; there would be technical issues of choosing versions and values, but these would come \nmainly from the already-existing consensus of practitioners. There is currently no handbook of software \narchitecture available, because at the moment there is no universal, or even large, community of software \narchitects, so any architecture handbook would have to be based instead on the theories of its author. \n The Architecture Handbook Project is different because it is an attempt to create understanding, and \neven consensus, by writing a handbook before it is really time. So our Architecture Handbook is a device, \na way to focus our attention and to have a concrete goal, to stop excessive theorising. For example, \nthe importance of communities of practice became apparent from some of our difficulties in producing \na free-standing handbook. Including I always try to work in an including and interactive manner in workshops. \nFor example at OOPSLA in 1991 our programme was as follows: imagining a finished handbook, and then writing \ncontents pages-using a guided fantasy to prep= . pyramids (i.e. pairs then fours then . . . ) to merge \nthe individual pages to three versions displaying the three versions along with lists of issues raised \nparallel activities - some people wrote some of the overview material -others wrote technical entries \nending the workshop with what I have learned  All this activity (note-no prepared presentations!) resulted \nin 48 pages of material from about 30 participants. So we are building an Architecture Handbook Project \ncommunity. Categorization of Architectural Information The kit for potential authors of position papers \nincluded a framework of six categories of information as the main structure of the current Handbook. \nThree categories refer to components and structures-configurations (patterns of things e.g. Blackboard), \nblocks (providing functionality e.g. Stream), and mechanisms (pervasive methods e.g. Delegation). The \nother three are attributes (e.g. memory use), principles (e.g. separation of concerns) and dimensions \n(e.g. declarative/imperative). Configurations Configurations are patterns of things or relationships \nbetween things. For example a Blackboard architecture is a set of modules that work together in a specific \nway. A configuration is principally useful or interesting because it describes relationships (in 00, \nmediated by message-passing, I think) between some other elements. Thus MVC is indexed under configuration \nbecause its novelty is in the relationship; all inputs are dealt with by the controller, all outputs \nby the view, the model doesn t know it is being viewed, and so on. We can further break this down-the \none-way relationship is another entry-in that other entries are referred to. The elements in the configuration, \nthe M, V and C, have certain properties, but otherwise are not described, or describable, here. The details \nof Smalltalk-MVC would be in the exemplary systems section. Blocks Blocks are things which provide functionality, \nas a black box. Thus a Stream may be used to link the output from one place to the input at another. \nSimilarly the idea of sorted collection is a block. It is a useful idea, and not one that a Fortran programmer \nwould be likely to have, because it is hard to tie up the data-storage and the keeping-it- sorted in \nFortran. We might also have the more general data-with-global-property-as-object in the handbook. Mechanisms \nMechanisms are ways of doing things. For example, we can use Delegation to divide up functionality into \ndifferent parts. They are styles or methods that are used throughout a system or subsystem-you couldn \nt point to one directly (like a Block) or say which things were in one (Configuration). Further examples \nare message-passing, constraint-satisfying, or call-backs. Of course these are not exclusive headings. \nWe might view Broadcast as a configuration or a mechanism, Event handler as a configuration or a block, \nand Buffer as a block or a mechanism, Nor are they three levels. The other three headings refer to a \ndifferent kind of information: Attributes Some of the properties of a system are derived from its architecture, \nor from the architectural elements it uses; for example, performance. We list and discuss these briefly \nin the chapter on attributes, and then in each entry we say how its use will affect those attributes. \nPrinciples Principles are good ideas that sum things up well; for example, separation of concerns. They \nare too abstract to be used constructively, but can be used imaginatively, for example how are we doing \nwith respect to principle X? or can we use Y here? . They form a useful shorthand in architects talk. \nIn each entry we say which principles are exemplified by the construct. Dimensions Dimensions are useful \ndescriptions based on pairs of opposing concepts, for example declarative- imperative. We locate entries \non the relevant dimensions. These categories are intended to be suggestive rather than taxonomic. They \nare ways in to the entries in the book. There could be, and should be, other ways too. However, ways \nin are not the same as categories, as categories may not be helpful in looking for information or inspiration. \nIn particular talking about data and function as categories means you won t get to objects easily.  \nThe Position Papers Kent Beck, First-Class Software- Patterns and Idioms: Proto-patterns for the Smalltalk \nCollection Classes* Ron Casselman, Carleton- Graph Propagation Operations Desmond D Souza,- Abstracting \nthe Five W s of Object Interactions Dick Felsinger, RCF Associates- Top Level Frameworks of Interface \nand Application Classes for Event Driven Systems Erich Gamma, UbiLab- The ET++ Look Subsystem John Gilbert, \nObjective Softwars Task and Startup Sanjiv Gossain, Project Technology- Use of Architectural Patterns \nin a Telecommunications System Martin Griss, HP Labs- Software Bus Architectures Richard Helm and John \nVlissides, IBM Watson- An Object-Oriented Architecture for Constraint-Based Graphical Editing Ralph Johnson, \nIllinois- Constraints Doug Lea, Syracuse/Oswego- States as Classes Elgin Lee, ParcPlace- Delegating \nand Distributing Policy Decisions to Increase Applicability Giuseppe Menga, Torino- G++, A Framework \nfor 00 Design and Prototyping of Concurrent Distributed Systems Frances Paul&#38;h, Siemens- The Architecture \nof the Extendible Directed Graph Editing System Rik Smoody, smOOdynamics- Foci  The Workshop Itself \nThe workshop began with participants arriving, greeting each other and being introduced, to a background \nof music by Will Ackerman. Our fist activity was a guided fantasy leading to the production of rapid, \nperhaps impressionistic, sketches of a handbook entry, to a background of Baroque music. We discussed \nthese in pairs, then put up the resulting features and headings on the flipchart. These lead to the 1993 \nArchitecture Handbook Entry Format:  Entry Format- 1993 Architecture Handbook TITLE (punchy, carefully \nchosen) DIAGRAM (symbolic, suggestive) MARGINAL ICONS (for the quick flipper) PROBLEM (brief statement) \nSOLUTION (brief statement) REQUIREMENTS/DEPENDENCIES DETAILS OF SOLUTION FURTHER CONSEQUENCES DISADVANTAGES \nSPECIFIC ATTRIBUTES VARIATIONS &#38; RELATED ENTRIES AVAILABILITY EXAMPLE IMPLEMENTATION CODE FOR EXAMPLE \nAUTHOR, DATE, ACKNOWLEDGEMENTS REFERENCES Our second activity was to look at casting the entries we had \nwritten for the workshop into this format. This was done in pairs, each explaining to, and helping, the \nother. Lunch was brought in so that we could keep working; after eating we went for a walk and to run \nerrands. Participants regrouped to the strains of the Roaches Speak. Next we went round in a circle, \neach person briefly describing the entry they had been working on. Our fourth activity was to look at \nthe issues raised by this work of structuring, and this produced the following list of points; we decided \nnot to try to resolve these issues, though we did discuss them briefly. issues raised by structuring \nsaying A is like B except for C comparing with familiar alternatives sourcebook, catalogue, pattern book \nor data book? describing complex relations e.g. event attachment naming complex relations,  e.g. event \nattachment compatibility/constraints between mechanisms frameworks--classification keywords per entry \nconstruction hints level of implementation detail hyperbook or leather-bound? composing patterns, multi-level \nlinking transformation (versus construction) essay-like versus structured grouping entries into generalisations \ndifferent outlines for different classes of entries  We went on to another round, this time describing \nour work of the last twelve months. In particular Richard Helm, Erich Gamma and John Vlissides described \ntheir work on patterns, and Bruce Anderson talked about his work at Hewlett-Packard. Design Patterns: \nAbstraction and Reuse of 00 Design (from an IBM Internal Report; a related paper was submitted to ECOOP \n93) Abstract We propose design patterns as a mechanism for expressing object-oriented design structures. \nDesign patterns identify, name and abstract common themes in object-oriented design. They capture the \nintent behind a design by identifying objects, their collaborations, and the distribution of responsibilities. \nDesign patterns play many roles in the object-oriented development process: design patterns provide a \ncommon vocabulary for design, reduce system complexity by naming and defining abstractions, constitute \na base of experience for building reusable software, and act as design building blocks from which more \ncomplex systems can be built. Design patterns can be considered reusable micro-architectures that contribute \nto an overall system architecture. Examples Virtual Constructor, Abstract Factory, Adapter, Wrapper, \nMediator, Strategy. Work on Architecture and Community (from notes by Bruce Anderson) Architecture in \nthe software process We can talk specifically about the architecture of a system, or generically about \nan architectural shape or form. One is used by analogy, the other by instantiation. Suitable architectures \ndo not just arise during design (or coding!), but must be specifically created early on in the product \nlifecycle. Part of envisioning a product portfolio consists of creating a suitable architecture to provide \nthe facilities needed, for example extensibility. As the product family matures, the architecture will \nbe refined, but not as quickly as the products. Very often architectural work is done unconsciously, \nso that while there is some overall pattern, it is not necessarily coherent or even suitable. Some teams \ndevelop an explicit architecture, but not many places have a sufficient repertoire that they can make \nconscious and calculated architectural choices. Working with Organisations One way we work on our ideas \nabout community- building and organisational development is by imagining programmes to carry them out. \nHere is a description of products and services of an in-house initiative for a large and diverse company \nseeking to improve its architectural core competency. . Peer development programme . Mentoring programme \n. Architectural awareness workshop . Architectural skills workshop . Process evaluation and planning \nservice . Architectural state review Finally we discussed our future plans, and decided to produce a \nbook; not an architecture handbook, but a book summarising our work so far-perhaps a Towards an Architecture \nHandbook Book. As a first step towards the book we agreed to produce entries on various topics. Entries \nplanned for our first publication 9 Kent Beck: Changing Concrete Behaviour (C) . Ron Casselman: Graph \nPropagation (C?, M?) Desmond D Souza: Grouping by Roles-the W s (?) Erich Gamma: Reusing Collection Classes \n(B) John Gilbert: Task (C, B, M) . Sanjiv Gossain: Separating Interface from Application (C) Richard \nHelm: Constraint-Solving (B, M) Doug Lea: Software Bus (C) Doug Lea: States as Classes (C, M?) Elgin \nLee: Policy Delegation (B?) Giuseppe Menga: G++ and the Client-Server Model (C) . Frances Paulisch: \nGeneric Graph Editing (C, M?) Rik Smoody: Focus (M?) John Vlissides: Merging Architectures (C) Bruce \nAnderson (editing, structure, framework) Ralph Johnson (editing, structure, framework) Martin Griss (guru) \n  Acknowledgements This work began during a conversation with Ralph Hodgson, and was initially encouraged \nby by Joe Schwartz and Erich Gamma. Many people at several workshops and BOFs have contributed. I am \ngrateful to the Hewlett-Packard Software Initiative, especially to Kim Harris, Ron Crough and Bob Walstra, \nfor help and support in organising the workshop.  Contact information: Bruce Anderson Electronic Systems \nEngineering University of Essex Colchester Essex CO4 3SQ England E-mail: bruce@essex.ac.uk  \n\t\t\t", "proc_id": "157709", "abstract": "", "authors": [{"name": "Bruce Anderson", "author_profile_id": "81100101845", "affiliation": "", "person_id": "PP31071387", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157730", "year": "1992", "article_id": "157730", "conference": "OOPSLA", "title": "Towards an architecture handbook", "url": "http://dl.acm.org/citation.cfm?id=157730"}