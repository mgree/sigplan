{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 fo fhe Vancouver, British Columbia, Canada 5-70 October 1992 Proceedings Tutorials- \n Concepts of Object-Oriented Programming Raimund K. Ege, Florida International University This tutorial \ndefines and teaches the basic concepts of environment, and gives an overview of the features of object-oriented \nprogramming, illustrates the object-oriented languages and environments. This advantages of object-oriented \ntechniques over tutorial will let you make an informed decision conventional programming, introduces \nthe about what language/environment will best serve components of an object-oriented programming your \nprogramming needs. Object Design for Modularity, Reuse and Quality Douglas Bennett, Design Ways Turning \nbuzzwords like modularity, reusable components, extensibility, testability, and robustness into reality \nrequires more than just a compiler for an object-oriented language, or even an integrated development \nenvironment. These properties must be designed into the software product. This tutorial shows how to \nmake design decisions so the product will do what its users want and so the buzzwords actually show up \nin the product. The tutorial will work through the steps of a design project, documenting user and producer \nneeds, modeling the thing objects, describing behavior with event response models, and, finally, developing \nan architecture for the product. Part of each step is evaluating the design against the magic words. \nThe result will be a product structure that is probably very different from conventional software architectures, \nbut one that can be measured against the design criteria. This tutorial teaches the explicit design of \nsoftware. It uses notations from several existing methods. You may use your own notations, if you wish. \n A Comparison of Object-Oriented Analysis and Design Methods Martin Fowler This tutorial shows how to \nlook inside design and several of the most well-known methods, including analysis methods to see how \nthey differ, and more Booth, Coad/Yourdon, Odell/Martin, Rumbaugh, importantly, how they are the same. \nIt examines In general, each method is made up of several techniques (e.g. ER modeling, state transition \ndiagrams) each of which emphasizes a particular aspect of the system. These techniques can be classified \nas being for structural (data), behavioral or architectural modeling. The tutorial shows the techniques \neach method uses and how different methods use different dialects of the same Integrating Analysis and \nDesign Methods Derek Coleman &#38; Paul Jeremaes, HP Labs, England Most of those who practice object-oriented \nanalysis and design do not follow any standard method exactly, but combine different techniques to suit \ntheir own unique requirements. Each method employs its own set of models, notations, and processes, so \nit can be difficult to combine them. This tutorial shows how to design a method by providing a framework \nfor understanding and evaluating current methods, applying it to three recent methods (OMT (Rumbaugh \net al), Responsibility Driven Design/CRC cards, Booth 91 Method), and combining them to produce a new \nmethod, FUSION, that builds on their best aspects. Object-Oriented Concurrent Programming Jean-Pierre \nBriot, Institute Blaise Pascal, France This tutorial treats object-oriented concurrent programming (OOCP) \nas the natural generalization of object-oriented programming. OOCP decomposes a large program into a \ncollection of small modules that run and interact concurrently and are capable of exploiting parallel \nhardware. The tutorial describes various levels of integration between object-oriented programming and \nconcurrency, leading to the notion of an active object, which unifies object and activity, message passing \nand synchronization. The tutorial introduces Concurrent Smalltalk to describe concepts, constructs, and \nmethodology. Examples include programming with continuations, techniques, varying the notation and introducing \nnew concepts. It uses examples to show how the same system is expressed in different ways by the various \nmethods. The tutorial also compares the design approach advocated by each method. This tutorial will \nhelp you decide which method will work best for you. In addition, you will learn how ideas from different \nmethods can be combined to better suit the system under analysis. The tutorial introduces a set of criteria \nfor evaluating methods from the viewpoint of the object-oriented concepts they support, the kinds of \nmodels and notations they employ and the process steps that they recommend. The criteria provides a way \nto understand the underlying similarities and differences between methods. The criteria were developed \nas part of a program to assess what kind of method should be made available to HP engineers, which led \nto the development of the FUSION method. The tutorial ends with a brief account of the usefulness of \nFUSION in practice. divide and conquer, and pipelining. It also shows how to implement active objects, \nand uses Actalk as an example. Finally, it compares various OOP models and languages, with a special \nfocus on the Actor computation model. Although the tutorial uses Smalltalk for examples, you don t need \nto know Smalltalk to understand it; a quick introduction to Smalltalk syntax is included. It assumes \nthat you understand object-oriented programming well, but little more about concurrency than intuitive \nconcepts of processes and synchronization.  Types for the Working Programmer Andrew Black, DEC There \nhas been recent progress in understanding types for object-oriented languages, but most of it has had \nlittle or no impact on real programmers. This tutorial aims to extract from the confusion those topics \nthat are important to programmers who must use or choose an object-oriented language. The tutorial explains \nthe role of types in object-oriented languages, what types can do for programmers, and how the trend \ntowards distributed and heterogeneous systems and object-oriented databases influences what it means \nfor a program to be type- correct. Types for the Language Designer Michael Schwartzbach &#38; Jens Palsberg, \nAarhus University, Denmark The type systems of object-oriented languages have specific goals: they serve \nas partial documentation, they provide modularity, and they ensure safety and efficiency at run-time. \nThere are many choices in the design of a type system, and it is hard to evaluate their tradeoffs. This \ntutorial teaches a coherent theory of type systems for object-oriented languages that can be used for \nboth explicit systems (where the programmer supplies type annotations) and implicit systems (where the \ncompiler must perform type inference), and forty systems based on interfaces, classes, and sets of classes. \n Simulation with DEVS-CLOS Suleyman Sevinc, University of Sydney , Australia This tutorial has two purposes: \nto show how the features of CLOS affect a design and to describe the design of a general-purpose simulation \nsystem. The tutorial is designed for those who want to understand the practical importance of the unique \nfeatures of CLOS and also those who would like to learn how to use or build object-oriented simulation \nsystems. The tutorial emphasizes the underlying model of object-oriented programming in CLOS and distinguishes \nit from other models. It also describes the requirements of a simulation system and the The tutorial \ndescribes the difference between objects and values, what types are and why they are good for you, what \nrefinement and subtyping are, what problems they solve, and what problems they do not; why contravariance \nisn t an unnatural act; why inheritance is a relationship between programs, not between classes. By the \nend of the tutorial, you will understand how abstract concepts like subtyping can help you solve practical \nproblems such as deciding when one piece of code can be substituted for another. The tutorial defines \nan idealized object-oriented language, inspired by Smalltalk, and develops several type systems for it. \nThis uniform framework makes it easy to compare different approaches. The tutorial explores the limitations \nof static type checking and shows how dynamic type checking can be introduced. It demonstrates how subclassing \nis different from subtyping, how specification types differ from implementation types, and the influence \nof a type system on separate compilation. design of DEVS-CLOS, a publicly available simulation system. \nDEVS-CLOS is an extension to CLOS that supports modeling and simulation. It supports visualization, supports \nhierarchical design of simulations, allows first-order logic in models, and supports adaptive system \nsimulation. The tutorial shows how a system like DEVS-CLOS can be used to solve typical simulation problems, \nand how CLOS concepts like multimethods, multiple inheritance, pre- and post-methods and dispatching \nalgorithms were used in the design of DEVS-CLOS.  Advanced CLOS and Meta-Object Jon L. White, Lucid \nOne of the important characteristics of CLOS is its dynamic flexibility to change descriptions, programs, \nand even data objects on the fly. A typical CLOS system is implemented by a set of meta-objects, which \ncan be changed by the programmer, essentially letting you create a new language. Thus, CLOS is a reflective \nprogramming language. The main purpose of this tutorial is to teach you how to put a me&#38;object protocol \nto a practical use. In addition to describing the implementation of a typical CLOS system and discussing \nthe various issues raised by the book Art of the Meta-Object Brotocol, it gives practical examples of \nmeta- Protocols object extensions including techniques for making user-defined metaclasses, for making \nalternations to SLOT-VALUE so that certain slots can be persistent, and for making metaclasses whose \nclasses automatically keep a table of all their instances. The tutorial is aimed at the CLOS programmer \nor the programming language expert who would like to learn more about reflective programming using a \nmeta-object protocol. The emphasis is on practical uses of a me&#38;object protocol, not on the philosophy \nof reflection.  Introduction to Object-Oriented Database Management Systems David Maier, Oregon Graduate \nInstitute This tutorial begins by explaining object-oriented database management systems (OODBMS) in \nterms of what is the value added beyond record-oriented database systems and object-oriented programming \nlanguages. It presents most of the current commercial OODBMS and several advanced prototypes with particular \nattention to distinguishing them in their data models, application interfaces and system architectures. \nIt will also contrast the OODBMS approach with extended relational systems. A goal of the tutorial is \nto give participants an appreciation for the consequences of design choices made in the different systems. \nIt Object-Oriented Software Development Karl Lieberherr, Northeastern University The Demeter Method \nis a formal method that lifts object-oriented software development to a higher level of abstraction by \nusing a graphical specification language for describing object-oriented programs. Executable programs \nare automatically generated by a CASE tool (the Demeter System/C++) from the graphical high-level descriptions. \nUnlike other specification languages, the Demeter Method allows you to keep the binding of methods to \nclasses flexible under changing class structures. The higher level of abstraction leads to shorter and \nmore reusable programs than by programming directly in OOPSLA 92 -220- concludes with a critique of current \nmarket offerings, and suggests there are significant regions of the design space to explore, and needs \nof advanced applications that are still largely unmet by any database product. This tutorial is designed \nboth for those considering investing in OODBs and those who just want to understand the technology. It \nassumes knowledge of object-oriented programming concepts, and some familiarity with conventional database \nsystems, particularly relational databases.  with the Demeter Method one of today s object-oriented \nlanguages such as C++, Smalltalk, Eiffel or CLOS. Because the Demeter Method is regularly taught at NU \nboth at the graduate and undergraduate level with the 10 week quarter system, it has become, by necessity, \nvery easy to learn. This tutorial is for professionals who want to learn powerful, formally defined high-level \nconcepts that describe the programming task in terms of data- model-based graphs and their subgraphs. \n Object-Oriented User Interfaces Dave Collins, IBM The principles of objects, polymorphism, classes, \nand inheritance can apply to the end user s external view of a user interface, just as it can apply to \nthe language that is used to implement it. This tutorial shows how to design (not implement) a user interface \nthat is truly object-oriented. It gives guidance on the design of the externals of object-oriented user \ninterfaces, and shows how developers can capitalize on the isomorphism between the user s conceptual \nmodel of the interface and the constructs provided by Evaluating Reusable Class Libraries Timothy Korson, \nClemson University Object-oriented technology not only affects the way we design individual applications, \nit holds the potential of ushering in the software industrial revolution. A key to the success of object \ntechnology is the widespread availability of high quality class libraries. These class libraries are \nthe re-usable parts of the software industry. This tutorial teaches how to evaluate object-oriented libraries. \nThe same criteria can be used for selecting Object Engineering R. Stonewall Ballard, Component Software \nCorporation Converting an object-oriented design into class definitions in an object-oriented language \noften requires many engineering decisions. It is easy to make these decisions incorrectly for languages \nthat give the programmer a lot of control over data representation, such as C++. This tutorial covers \nlow-level issues in building extensible and evolvable programs, issues that are important if you want \nto build well-balanced abstractions. It describes how to use multiple inheritance properly  Teaching \nObject-Oriented Programming James C. McKim Jr., Hartford Graduate Center A course in object-oriented \nprogramming and design should address the claims made for the object- S-10 October 1992 -221- object-oriented \nprogramming languages. The tutorial exposes a (perhaps surprisingly) deep analogy between object-oriented \nprogramming languages and object-oriented user interfaces. This analogy is valuable because it can be \nused to map external user interface design in a clear and natural way onto object-oriented application \nframeworks. The tutorial is illustrated with historical examples, many on videotape. commercial libraries \nor for designing libraries for use in-house. The tutorial also describes practical criteria for specifying \nand cataloging in-house corporate software libraries. In addition to these technical criteria, the tutorial \nalso shows you the corporate infrastructure that is necessary for enabling large scale reuse. in spite \nof the compiler, when to use forwarding instead of inheritance, how to encapsulate state, and when to \nuse references instead of copying objects. This tutorial teaches how to convert object-oriented designs \ninto code that is easy to extend and reuse. Many of the issues are more interesting to C++ programmers \nthan Smalltalk programmers, and C++ is the language used for examples, but most of the issues are language \nindependent.  and Design oriented paradigm, namely that it promotes reuse, models the problem space, \nfacilitates maintenance, Addendum to the Proceedings incorporates changes easily, and shortens the development \nlifecycle. One way (perhaps the only way) for students to test such claims is to build a small but high \nquality product as part of the course. This tutorial shows how to have students in a conventional computer \nscience program build such a product, and addresses such issues as how to pick good projects, whether \nand how students should Object-Oriented Project Management Kenneth Rubin &#38; Adele Goldberg, ParcPlace \nObject-oriented projects have to be managed properly to obtain the most benefits from object-oriented \ntechnology. This tutorial explains the effect of object-oriented technology on costs, staffing and choice \nof methodology. It describes the pitfalls that attend object-oriented projects so that you can avoid \n Introduction to Object-Oriented Design Lori Stipp &#38; Grady Booth, Rational This tutorial describes \nthe Booth method for object- oriented design, including details of the notation and the design process. \nIt describes the principles that are necessary for thinking and abstracting in terms of classes and objects. \nThe tutorial includes a number of examples, including war stories from specific projects. It also covers \nextensions to the notation work together in teams, how to keep students on schedule, and how to divide \na project into a sequence of deliverables within the context of a one semester course. The tutorial also \ndescribes how to scale back the approach so that students in short courses , common in industry, can \nget maximum benefit in the limited time that is allowed. them, and explains the key processes, including \ndevelopment style, use of prototyping, and reuse. It gives specific guidelines for organizing projects, \nmanaging a reuse library, estimating the size and cost of projects, and introducing object-oriented technology \ninto an organization. beyond that described in Object-Oriented Design with Applications. This tutorial \nis a condensed version of Booth s popular tutorial given at past OOPSLA s. If you have attended that \nin the past then you should attend tutorial 18 instead of this one.  The Pragmatics of Building Object-Oriented \nSystems Grady Booth, Rational This tutorial expands upon the process described in Booth s Object-Oriented \nDesign with Applications to provide a prescriptive, iterative process for object- oriented development. \nIt describes both the macro and micro process of development. It gives guidelines for managing iterative \ndevelopment, and addresses the pragmatic issues of milestones and A Case Study of Domain Analysis: Martin \nFowler &#38; Thomas Cairns, St Mary s Hospital Medical School , England Three years ago the UK National \nHealth Service decided to develop a generic model to describe all aspects of its management and operation. \nSeveral OOPSLAW planning, staffing, integration and release management, reuse, testing, quality assurance \nand metrics, documentation, tools, and technology transfer. This tutorial assumes that you are familiar \nwith Booth s design method.  Health Care projects were launched to describe the health care process \nusing the object-oriented modeling technique Ptech (now published by James Martin and Jim -222-Vancouver, \nBritish Columbia Odell). One of these projects, the Cosmos project, produced the Cosmos Clinical Process \nModel (or CCPM), which describes the medical record. The CCPM contains approximately 70 object types \nin a highly abstract structure describing clinical procedures, observations, evidence and assessment, \naccountabilities and contracts, care planning, and clinical knowledge. The model has gained widespread \ninterest in both the UK and Europe and will be used as the focus for a number of EEC sponsored projects, \nand is taking a leading standardization role in Europe. The Analysis and Design of Distributed Mehmet \nAksit, University of Twente The design of distributed object-oriented systems involves a number of considerations \nthat rarely arise in sequential object-oriented design or in non-object- oriented languages. The tutorial \ndescribes analysis and design techniques for data abstraction, inheritance, delegation, persistence, \natomicity, concurrency, synchronization, and coordinated The CCPM is an example of the result of domain \nanalysis. Its use of abstractions, some of which are applicable outside health care, and its use of an \noperational/knowledge divide can guide those working on large-scale generic models in other areas. The \ntutorial describes the relationship between generic and specific models since these issues are key in \nthe acceptance of a highly generic application area model by those with specific applications to develop. \nThe question of adapting an object-oriented method for particular needs is also addressed. Systems behavior \nin a distributed object-oriented framework. Special attention will be paid to the uniform integration \nof these concepts with the object- oriented paradigm. Discussions will be accompanied by examples that \narose from constructing such systems.  Specification Techniques for Object-Oriented Software Mahesh \nH. Dodani, University of Iowa There are many techniques for specifying software. However, they are not \nusually presented in a way that is directly applicable to object-oriented software. This tutorial surveys \nboth operational and descriptive specification techniques, shows how to use them in several popular object-oriented \nsoftware engineering methods, and provides case studies of developing useful, formal specification mechanisms \nthat are appropriate for object-oriented software engineering. The tutorial first describes criteria \nfor choosing specification mechanisms from both a theoretical  Writing Efficient C++ Programs Scott \nMeyers, Brown University This tutorial teaches the competing meanings of high performance; the characteristics \nof object- oriented systems that can decrease performance; how to locate and eliminate computational \nbottlenecks in C++ programs; and the trade-offs between high performance and system reusability, maintainability, \nand portability. It describes in detail the factors that affect the performance of C++ software. Whether \n(syntax and semantics, specifying properties, reasoning about properties, verification) and practical \n(ease of use, modularity, applicability, supporting tools) perspective. These criteria are then used \nto survey several popular operational (data flow diagrams, finite state machines, and petri nets) and \ndescriptive (entity-relationship models, logic, and algebraic specifications) specification mechanisms. \nFinally it shows how to extend two of these techniques (algebraic specifications and finite state machines) \nso that they are suitable for object- oriented software engineering. your primary concern is high system \nspeed, small system size, fast recompilation, or a combination of these, this tutorial provides you with \nthe tools necessary to come up with an appropriate object- oriented design, to implement it efficiently \nin C++, and to fine-tune it for maximum performance. destructors frequently hamstring applications. \nThis often surprising. Contrary to popular belief, virtual functions usually exact a negligible performance \nyou need to achieve it. cost, while unexpected calls to constructors and The Design and Management \nof C++ Class Libraries Arthuir Riel, Vanguard Training Producing reusable C++ class libraries takes more \nthan just knowing the language: it requires careful design. This tutorial shows how to create truly reusable \nC++ class libraries. It includes how to design a minimal public interface, variable-size Hardware Support \nfor Object-Oriented Mario Wolczko, University of Manchester, England When the performance penalty of \nobject-oriented systems is mentioned, a common response is to blame antiquated hardware designs for not \nsupporting object-oriented languages as they deserve, To what extent can the performance gap between \nconventional languages and object-oriented languages be closed using hardware? What architectural changes \nbenefit object-oriented systems, and by how much? There have been many attempts to make hardware that \nbetter supports object-oriented programming. This tutorial describes these systems, and the extent that \nthey have succeeded or failed in their aims. These systems include SOAR, Rekursiv and objects, memory \nleakage, heuristics for operator overloading, designing reusable base-classes, using inheritance and \ncontainment, and deciding how to place classes in a class library. Systems MUSHROOM, as well as some \nfeatures from mainstream architectures such as SPARC. Issues covered include: choice of instruction set, \ndesign of the memory system including caches and virtual memory hardware, scaleability, use of parallelism, \nand hardware/software trade-offs. A common misconception is that if something is implemented in hardware \nthen it must be fast. One aspect of the tutorial is to show that there are limits to what hardware support \ncan achieve. However, better hardware can reduce the cost of some language features, such as dynamic \nbinding, and can make a system more scaleable.  Efficient Implementation of Object-Oriented Programming \nLanguages Craig Chambers, University of Washington David Ungar, Sun Labs This tutorial is for those who \nlike to know how object-oriented languages work under the hood, why some things are expensive while other \nthings are cheap, and why language definitions include certain restrictions. This tutorial provides that, \nand more. It describes features of object-oriented languages that are difficult to implement efficiently, \nand how this has affected language designs. It describes state-of-the-practice and state-of-the-art techniques \nfor implementing languages like C++ and Smalltalk. OOPSLA 92 -224- Language features include dynamic \nbinding and generic operations, inheritance, user-defined control structures, static type systems, multiple \ninheritance and virtual base classes, and mixing object-oriented and non-object-oriented programming. \nThe tutorial also addresses questions like: What are the trade-offs in using the various implementation \ntechniques? What problems remain that block more efficient object-oriented language implementations? \nWhat might be promising areas for future research? Vancouver, British Columbia  Constraint-Based Languages \nand Systems Bjom Freeman-Benson , University of Victoria, Canada Alan Boming, University of Washington \nA constraint is a relation that should be satisfied, for example, that a line remain horizontal, that \na resistor in an electrical circuit simulation obey Ohm s Law, or that the height of a bar in a bar chart \nbe proportional to some number in an application program. Constraints have been used in a variety of \nlanguages and systems, particularly in user interface tool kits, in planning and scheduling, and in simulation. \nThey provide an intuitive declarative  Visual Programming Languages from Allen L. Ambler, University \nof Kansas Margaret M. Burnett, Michigan Technical University Visual programming language research has \nevolved greatly since its early days. At first, attempts at visual programming mostly took the form of \nflowchart-like diagrams. But in recent years, a wide number of innovative approaches have been incorporated \ninto visual languages, including object- oriented programming, form-based programming, programming by \ndemonstration, and dataflow programming. Unfortunately, while many of these systems represent important \nideas, only a few have been successful as complete visual programming languages. This tutorial explains \nwhy this is true,  Intermediate Smalltalk: Practical Design Trygve Reenskaug, TASKON , Norway Careful \ndesign before programming is as important in Smalltalk as in other languages. This tutorial describes \ntechniques that have proven useful in commercial development of large Smalltalk systems. The tutorial \nshows how to develop a  Writing Efficient Smalltalk Programs Ken Auer, Knowledge Systems Corp. Smalltalk \nhas a reputation for being slow and a memory hog. In reality, the Smalltalk environment style of programming \nthat integrates well with object-oriented systems. This tutorial teaches what constraints are, how to \nuse them in applications such as user interfaces, how to implement them (including how to implement constraint \nhierarchies), and how to embed them in object-oriented and logic programming languages. You don t have \nto know anything about constraints, but it would be helpful to have a strong background in programming \nlanguages. an Object-Oriented Perspective and describes ways in which the problem can be addressed. \nThis tutorial explores the issues behind the successes and failures of earlier approaches from a design \nperspective. It identifies characteristics of successful visual programming languages, and explains how \nto design an object-oriented language that maintains those characteristics. It shows solutions to a number \nof problems by looking at existing visual programming languages, including Prograph.  and Implementation \nlanguage independent design and then go to detailed programming and testing. The examples will be based \non Smalltalk- and use the release 4.1 graphical user interface framework. offers many ways to create \ninefficient code, and programmers often exploit those opportunities. efficient code, some of which may \nnot be available in more traditional languages. Whether an application exploit, rather than sacrifice, \nthe benefits of good is efficient or not has more to do with the way the object-oriented design. You \nshould have at least six programmer has used the available tools than the months experience with Smalltalk \nwriting non-toy tools themselves. programs to get the most benefit from the tutorial.  Testing Object-Oriented \nSoftware Edward Berard, Berard Software Engineering Testing of object-oriented software is just as important \nas testing non-object-oriented software, but the process is fundamentally different because of such factors \nas information hiding, encapsulation, and inheritance. This tutorial teaches you the terms and concepts \nof testing software in general, and object-oriented software in particular; how to apply a number of \ndifferent testing techniques to object- oriented software; how to construct test cases; and an appreciation \nof what is involved in planning a successful software testing effort. The testing techniques that are \ncovered include both white-box testing such as basis path testing and coverage testing, and black-box \ntesting techniques such as equivalence class partitioning and boundary value analysis. This course is \ndesigned for those with experience in object-oriented software engineering who would like to follow a \nmore rigorous approach to testing.  Object-Oriented Geometry and Graphics Jan Krc-Jediny &#38; Augustin \nMrazik, ArtInAppleS, Czechoslovakia Spatial information is an important part of operations; hierarchically \nstructured objects for geographic information systems, CAD and CAM maintaining topological information; \nobject identity systems, and user interfaces for visualization of any and problems arising from change \nof spatial objects kind of information. The object-oriented approach to in the database and user interface, \ntransactions and spatial object modelling results in much more copies of objects; dependencies of spatial \nobjects and understandable designs than non-object-oriented their copies in the MVC user-interface architecture. \napproaches. You should have experience in building user- This tutorial describes the design of several \nkey interfaces and should have some background in components of a system for dealing with spatial analytical \ngeometry. Examples are shown in information which are: analytical geometry closed Smalltalk, so a basic \nknowledge of Smalltalk would with respect to union, intersection and complement be helpful. The Design \nof an Object-Oriented Operating System: A Case Study of Choices Roy H. Campbell &#38; Nayeem Islam, University \nof Illinois Peter W. Madany, SUN Microsystems This tutorial describes the object-oriented design of a \nChoices is an object-oriented multiprocessorcomplete operating system, written to be object- operating \nsystem that runs native on SPARC oriented, with a user and application interface that is stations, Encore \nMultimaxes, and IBM PCs. The object-oriented. The main objective is to illustrate system is built from \na number of frameworks thatobject-oriented design trade-offs by studying a large implement a general \nfile system, persistent store for object-oriented system, the Choices operating persistent objects, process \nswitching, parallel system. processing, distributed processing, interrupt handling, virtual memory, networking, \nand interprocess communication. If you bring an IBM/PC 386-based portable computer running MS-DOS to \nthe course then you may experiment by writing application programs for PC-Choices. All participants will \nreceive a copy of PC-Choices on a floppy. Participants should have experience with building object-oriented \nsystems and have a basic understanding of operating systems design. Reading knowledge of C++ is helpful, \nbut not necessary.  Teaching Object-Think with Multi-Sensory Engagement Peter Coad, Object International, \nInc. This is a tutorial about how to teach the big picture of objects, especially in an industrial environment \nwhere time is short. It is based on the whole brain theory and multi-sensory engagement. The tutorial \nshows over twenty specific techniques for teaching using multi-sensory engagement, many of these unified \ninto The Object Game, which lets those new to objects see and manipulate them. The tutorial describes \na set of specific techniques for leading someone into more effective object think, and compares and contrasts \nwhole-brain multi-  Schema Updates for Object-Oriented sensory engagement with other object think techniques, \nsuch as graphics, languages, and CRC cards. This tutorial is designed for those trying to teach object-oriented \ndevelopment who have been frustrated by the inability of some people to reach effective object think. \nIt will also be of interest to those planning to teach object-oriented programming, or if you are responsible \nfor selecting such a course.  Database Systems Roberto Zicari , Johann Wolfgang Goethe University, \nGermany OODBMS are often used for complex data whose structure is likely to change over time, yet the \nproblem of schema updates has not been completely solved by any commercial or research OODBMS. This tutorial \ndescribes the schema modification problem and why it is important, what is really offered by products, \nwhat a good solution would be like, and whether we are likely to see it soon. The tutorial reviews several \ncommercial OODBMS products that provide facilities for updating the schema, namely: Gemstone (Servio \nCorporation), ITASCA(Itasca), 02(02Technology), ObjectStore (ObjectDesign), Ontos (Ontologic) and Statice \n(Symbolics). It also describes the solutions proposed in some experimental research prototypes and the \nopen problems that remain.   \n\t\t\t", "proc_id": "157709", "abstract": "<p>Concepts of Object-Oriented Programming<br>Raimund K. Ege, Florida International University</p><p>This tutorial defines and teaches the basic concepts ofenvironment, and gives an overview of the features ofobject-oriented programming, illustrates the object-orientedlanguages and environments. This advantages of object-orientedtechniques over tutorial will let you make an informed decisionconventional programming, introduces the about whatlanguage/environment will best serve components of anobject-oriented programming your programming needs.</p>", "authors": [{"name": "Raimund K. Ege", "author_profile_id": "81100466008", "affiliation": "", "person_id": "PP39075836", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157761", "year": "1992", "article_id": "157761", "conference": "OOPSLA", "title": "Concepts of object-oriented programming (abstract)", "url": "http://dl.acm.org/citation.cfm?id=157761"}