{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 to the Vancouver, British Columbia, Canada 5-10 October 1992 Proceedings Educators Symposium- \n The Impact of Object-Oriented Software Engineering in the Introductory Computer Science Curriculum Report \nby: Raj Tewari and Frank Friedman Temple University The planning and design phases of the work reported \nherein are being partially supported by National Science Foundation Grant # USE 9156079. 1. Introduction \nEven though the Computing Curricula 91 [l] report has a broader scope than any of its predecessors, and \nreflects the rapid evolution in the discipline of computing and its pedagogy, it explicitly recognizes \nthe need for curriculum innovation and experimentation [9]: While the task force was sympathetic to \nthe desirability of developing a concise set of curriculum guidelines, it was decided that there is still \na need for diversity and well-intentioned experimentation in computing curricula; it is hoped this report \nwill encourage this-It is intentionally designed to encourage curriculum innovation and evolution, enabling \neducators to respond in a timely fashion to future changes in the discipline rather than to simply update \nearlier models. Some of the fundamental and recurring concepts in computing that have been identified \nin [9] are: complexity of large programs, the concept of binding, abstract data types, evolution of requirements, \nlevels of abstraction, and the importance of software reuse. We present an improved curriculum with respect \nto these important and recurring concepts. This curriculum will enable students to better tackle the \ncomplexities of programming and design in a variety of application areas, provide them with a better \nfoundation to take advanced undergraduate and graduate level courses, and provide a good background for \nreading and understanding contemporary computer science literature. A revised, three-course sequence \nof programming courses is described first and some early results of our experiences in these courses \nare presented. Experiences in the use of the use of the object- oriented paradigm in these early courses \nare compared to past instruction using a heavy procedural-oriented point of view. We have also had some \nexperience in building on the early courses object-oriented emphasis when teaching some advanced courses. \nWe include a section on these experiences as well, limited to courses in Programming Languages, Compiler \nDesign, and a senior level introductory survey course in Software Design.  2. Problems with Existing \nCurriculum One of the most important decisions facing educators today is the choice of the programming \nlanguage paradigm and the choice of a specific language within the chosen paradigm. The choice of the \nfirst teaching language is critical because it impacts the kinds of abstractions that can be built by \nstudents, as mentioned in [2]: Just as the choice of available materials and technology affects both \nthe architect s vision of what can be built and the constructions that are actually attempted, so language \nconstrains the programmer s ambitions and abilities. The choice of the first teaching language is therefore \ncritical . . . Recent changes in the introductory curriculum made in existing courses that we are considering \nhave been minor, in most cases to accommodate new or different hardware. Meanwhile, the situation in \nthe software market, advanced undergraduate courses, and graduate education has undergone considerable \nchanges. There is a need to better equip students for performing more effectively in an increasingly \ncompetitive marketplace, and to face the increasing rigors of advanced undergraduate and graduate studies \nas the computing field matures. We will identify several emerging trends that necessitate a revision \nof the curriculum. As pointed out by Mary Shaw [5], there has been a shift in research attention in computing \nin each of the last three decades. The primary software engineering paradigm that could be identified \nin the decade 1960 (+-5) was programming any-which-way, characterized by small programs, elementary understanding \nof control flows, emphasis on representing structure and symbolic information, and a state space that \nwas not very well understood. The tools and methods of this decade were assemblers and core dumps. The \ndecade of 1970 (+-5) emphasized programming-in-the-small, characterized by algorithms and programming, \ndata structures and types, simple input/output specification, small and simple state space, individual \neffort. The tools and methods were programming languages, compilers, linkers and loaders. The 1980 (+-5) \ndecade witnessed the shift to programming-in-the-large, characterized by interfaces, long-lived databases \n(symbolic and numeric), systems with complex specification, a large structured state space, team efforts \nand system lifetime maintenance. The tools and methods were environments, integrated tools and documents. \nWe extend Shaw s framework to the 1990 (+-5) decade. Characteristic environments in this decade include \nmulti-windowed user interfaces incorporating multi-media, large relational and object-oriented databases, \ndistributed and real-time computing, highly complex system specifications, large structured and unstructured \nstate spaces, and group effort. The tools and methods are windowed source code debuggers, integrated \nprogram development environments, hypertext encoded documents (active documents), heterogeneous systems \nintegration, and windowing toolkits. These represent an opportunity for us at universities to revise \nour curricula to emphasize new tools, techniques, and paradigms. If we place our programming courses \nin the above context, we find that we are teaching students technology that is essentially programming-in-the-small. \nWe are currently lagging two generations, and we suspect that there are a large number of computer science \ndepartments in the country that are teaching based on the programming-in-the-small paradigm. By assigning \nsmall isolated problems based on individual programming effort, we are perpetuating the craft nature \nof software, instead of focusing on the realities of the software market that demand mastering the complexities \nof intricate toolkits and programming-in-the-large. The reasons for this in the past may have been lack \nof faculty expertise, lack of modem computing facilities, and a lack of suitable tools such as low cost \ncompilers, debuggers, profilers, and integrated development environments. We feel that this is a specially \ngood time for revising the curriculum to address some of the above problems, since optimizing compilers \nfor several languages that emphasize good software engineering principles and software reuse, are becoming \nwidely and inexpensively available on a variety of platforms from PC s to Unix workstations. In addition, \nintegrated program development environments, large general and special purpose class libraries, both \ncommercial and public domain, are becoming widely available. We are currently integrating these tools \nin our courses. Faculty expertise in object- oriented concepts and languages is now adequately developed \nin our department through a combination of research and teaching interests, and attendance in conferences \nsuch as ACM Object-Oriented Programming, Systems and Languages (OOPSLA) ts1. A few educational institutions \nhave very recently begun to introduce object-oriented thinking and languages in their introductory courses \n[4,6]. However, to the best of our knowledge no institution has done a major curriculum overhaul for \nthe three course introductory sequence in a coordinated manner for introducing the object- oriented paradigm. \n 3. Goals The choice of the first language for teaching computer science is heavily influenced by personal \npreferences of decision makers, and in some cases seems to be almost a religious issue. Proponents of \na particular language paradigm will in most cases have a strong conviction that they should teach their \nfavorite language. However, this is not necessarily the best choice for beginning students. While, we \nprefer the object-oriented approach* (exemplified by C++, Smalltalk etc.), as an alternative to the procedural \napproach (exemplified by Pascal, C etc.), others prefer the functional paradigm (Lisp or Scheme), and \nstill others prefer the logic paradigm. There is a debate in the object-oriented camp about the benefits \nof pure object-oriented languages such as Smalltalk, over hybrid languages such as C++, and vice-versa. \nWe are of the view that recent versions of these languages provide comparable capabilities, albeit with \ndiffering ontologies. The goals and objectives of our revised curriculum are: 1. Introduce students to \nkey software development concepts such as modularization, abstraction, information hiding, separation \nof concerns, and software reuse, early in the introductory curriculum to enable them to learn good software \nengineering concepts. This is accomplished through a combination of case study examples and programming \nassignments. The assignments vary in scope from those requiring from-scratch development to those that \ninvolve corrective maintenance and/or the augmentation of a basic system to one of enhanced capability. \n 2. Enable students to develop small to moderately sized individual and group projects that emulate industrial \nsettings. Again, some from-scratch development as well as maintenance and augmentation are required. \n  4. Course Work and Projects In this section, we summarize those aspects of the Temple CIS undergraduate \ncurriculum that have changed as a result of the introduction of the object- oriented paradigm. The discussion \nis limited to the first three programming courses, and in three advanced courses, one each in Programming \nLanguages, Compiler Design, and Software Design. The changes described have also impacted undergraduate \nindependent study courses taken by our students. In the first course procedural abstraction is introduced \nin two stages. The first stage is presented 1 There is debate in the object-oriented camp about the benefits \nof pure object-oriented languages such as Smalltalk, over hybrid languages such as CH. and vice- versa. \nWe are of the view that recent versions of these languages provide comparable capabilities, albeit with \ndiffering ontologies. early in the course, even before the rudiments of decision structures and loops. \nMidway through the course, data abstraction is covered. The advantages of being able to define new abstractions \n(new data types) are presented even before students are introduced to the fundamental data forms. Software \nengineering concepts such as structured programming (top-down design, modularization, limited module \ncoupling, cohesive modules, etc.), encapsulation, information hiding, object definition, and component \ngenerality and reuse are stressed throughout the course, especially in the second half. By this time, \nstudents have the tools necessary to study examples of the development of systems illustrating these \nconcepts and to practice such development themselves. A subset of the C++ language is used for illustration \nand laboratory practice. The second course builds on this foundation, focusing on concepts of software \nreuse through function and class libraries, and introducing the basic concepts of programming-in-the-large \nthrough integrated software development environments. The concept of type hierarchies (implemented using \ninheritance) is introduced. There is an increased emphasis on good engineering practice as opposed to \nthe old focus on data structures and notations. The study, understanding and reuse of data structures \n(lists, trees, graphs etc.) and the operations on these structures is stressed, rather than the from-scratch \ndevelopment of these data structures and related algorithms. Some introductory material on algorithm \nanalysis is also presented. By the time students have reached the third of the three-course programming \nsequence, the concepts introduced in the first two courses can be put into practice in software maintenance, \nenhancement and development projects of moderate complexity. This work is carried further into more advanced \ncourses, such as those on the comparative study of some classical software design techniques. These courses \nare all project-oriented and therefore provide ample opportunity for the application of the engineering \nguidelines and concepts studied in the first two courses. Example projects include translators, loaders \nand interpreters for simple, pseudo assembly codes, compilers and interpreters for subsets of Pascal \nor C, applications using graphical user interfaces, and game simulations.  5. Textbooks and Instructional \nMaterials A number of books on object-oriented programming using C++ are currently available [3,7, 10, \n111. However, none of these textbooks are suited for teaching at the introductory level, since their \nlevel of exposition is much higher than would be suitable for first and second year undergraduates. Most \nof the textbooks assume prior knowledge of a procedural language, preferably C. Since, C++ is a hybrid \nlanguage most of these books have some coverage on procedural programming also. C++ is the language \nof choice for our curriculum in the object-oriented category, for a number of reasons such as good market \nacceptance, availability of inexpensive and optimized compilers on most platforms, availability of several \nclass libraries including some excellent public domain systems such as ET++, Interviews, NIHCL 3.0. C++ \nalso offers a C linking interface for advanced courses such as Operating Systems and Compilers. Furthermore, \nnew version of C++ has been released by AT&#38;T Unix Systems Laboratories, the cfront version 3.0, which \nincludes the implementation of templates. The template facility significantly adds to the capability \nof introducing parameterized types and type independent programming in C++. 6. Experience and Lessons \nLearned Our efforts to date have been hampered somewhat by the lack of suitable computer systems support \nfor student labs and projects, and by the lack of a uniform student population in the courses. We are \nthe only two faculty (in a department of 19) currently using the C++ object-oriented engineering focus \nat the undergraduate level. Other faculty members are using the procedural approach. As a result, even \nour advanced courses have a wide variation in registrants, ranging from those who have had at least two \nsemesters of exposure to object- based engineering concepts (as described earlier) to those who have \nhad no exposure to these ideas. Our advanced level problems are therefore more severe than those encountered \nat the introductory level. We have found it much easier to get across the basic concepts of abstraction \nand good program engineering practice earlier in the curriculum, than to have to do it later, after students \nhave had two years of practice in the procedural paradigm alone (or worse, two years of practice in the \nany-which-way approach). One major impediment involves getting students to truly understand argument \npassing and separate compilation and name space. This is no less the case in C++, despite its advantages \nover Pascal in the actual practice of modularization and the top- down approach. Difficulties in the \npractice of the object-oriented paradigm are also discussed. These problems are clearly more severe in \nadvanced courses (for students with no background) than at the introductory level. We have found a surprising \namount of student confusion regarding the notions of types, attributes, and objects.  References Dl \nACM/IEEE-CS Joint Curriculum Task Force. Computing Curricula 91. ACM and IEEE Press, Feb. 1991. PI S. \nM. Kaplan and R.E. Johnson. On Language Choice for the Introductory Computer Science Course. In Information \nProcessing, pages 563-X8,1989. 131 S. B. Lippman. C++ Primer, 2nd Edition. Addison-Wesley, Reading, \nMA 1991. r41 R. J. Reid. Object-Oriented Programming in C++. ACM SIGCSE Bulletin, 23(2):9-14, June 1991. \n151 M. Shaw. Prospects for an Engineering Discipline of Software. IEEE Software, 7(6):15-24, Nov. 1990. \nEl S. Skublics and P. White. Teaching Smalltalk as a First Programming Language. ACM SIGCSE Bulletin, \n23(l): 231-234, March 1991. 171 B. Stroustrup. The C++ Programming Language, 2nd Edition, Addison-Wesley, \nReading, MA 1991. Bl R. Tewari. Object Allocation in Distributed Applications. In Workshop on Objects \nin Large Distributed Applications, ACM OOPSLA 91, October 1991. 191 A.B. Tucker et al. Computing Curricula \n91. Communications of ACM, 34(6):70-84, 1991. WI R.S. Wiener and L.J. Pinson. An Introduction to Object-Oriented \nProgramming and C++. Addison-Wesley, Reading, MA, 1988. [ill R. Winder. Developing C++ Software. John \nWiley &#38; Sons, 1990.  Contact information: Raj Tewari and Frank Friedman CIS Department Temple University \nPhiladelphia, PA 19122 E-mail: tewari@cis.tempie.edu  \n\t\t\t", "proc_id": "157709", "abstract": "", "authors": [{"name": "Raj Tewari", "author_profile_id": "81100237768", "affiliation": "", "person_id": "PP14092287", "email_address": "", "orcid_id": ""}, {"name": "Frank Friedman", "author_profile_id": "81339499936", "affiliation": "", "person_id": "PP31076787", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157834", "year": "1992", "article_id": "157834", "conference": "OOPSLA", "title": "The impact of object-oriented software engineering in the introductory computer science curriculum", "url": "http://dl.acm.org/citation.cfm?id=157834"}