{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 to the Vancouver, British Columbia, Canada 5-IO October 1992 Proceedings Educators Symposium \nInvited Talk-Finding an Educational Perspective for Object-Oriented Development Report by: Linda M. Northrop \nVisiting Professor United States Air Force Academy Abstract The object-oriented model has become exceedingly \nattractive as the best answer to the increasingly complex needs of the software development community. \nThe initial boasts regarding quality, reuse, concurrency, and scalability are now being substantiated \nby documented software development experience. It is certainly appropriate, then, for educators who teach \ncomputer science (the current preparation for emerging software developers) to examine where object-oriented \ndevelopment best fits into the computer science curriculum. How much of the paradigm-language, analysis, \ndesign, management--ought to be addressed? At what level in an undergraduate program are object-oriented \ntechniques appropriate? What are the risks involved? How is the object-oriented approach effectively \ntaught? Historical Perspective When the history of software began, software developers and educators \nwere essentially craftsmen. A piece of software was tailor made using creativity, brute force and determination. \nSoftware development was taught according to individual interpretations of how the craft was practiced. \nIn its nascent stage as an educational discipline, computer science focused on the mastery of programming \nlanguages, but largely ignored instruction of any real technique for appropriately using the languages. \nAnalysis and design were black art; the very idea of a design or an analysis approach was an anathema. \n The Structured Approach In the late 1960 s the software community was made aware of the uncontrollable \nmonsters being created by this predominantly ad hoc approach to software development. Labeled as the \nsoftware crisis, this realization precipitated a movement to determine, embrace and teach a more scientific \nprocess for the creation of software. The craftsmen eventually acquiesced. They began to structure their \ncode and thereby impose order, predictability and readability. Moreover, they began to realize that coding \nwas only a portion of the software development process. They formalized design and analysis techniques \nto precede the structured programming. This was the late 1970 s and early 1980 s. There was essentially \none problem to solve-that of sequential information systems with non-hierarchical data-and one way to \nsolve it-the structured approach. On the educational front there were throngs of students who sought \nto major in the new field of computer science. Computer science became the prescribed educational preparation \nfor the S-10 October 1992 -245-Addendum to the Proceedings increasingly more disciplined software developers. \nThe structured approach was preached but there weren t enough qualified computer science faculty, and \nthere were few standards against which to measure a computer science curriculum.  The Challenge of Complexity \nDuring these same decades hardware capability increased dramatically. There was also tremendous growth \nin the sophistication and breadth in the problem domains for which software was attempting to be designed. \nThe need to support hierarchical data, vastly larger systems, real-time applications, and distributed \nsystems emerged. Maintenance of software became an insurmountable problem and so modularity and reusability \nalso became increasingly important. It became clear that functionality was not the only facet that could \nor should be abstracted. Moreover, the structured approaches failed to adequately address the scale and \ncomplexity that beset the software developers. Programming languages which utilized the enhanced architecture \ncapabilities and addressed these more sophisticated needs were developed. Richer data structures were \nincorporated to address more complex data needs. Somewhat later, language experts pioneered the concept \nof abstract data types which encapsulated data structure and functionality. A whole family of languages, \nincluding CLU, Ada and Modula, which supported both separately compilable modules and abstract data types \nwas created. Design approach had to be reconsidered in light of the abstract data type perspective and \nhence object-based techniques were described and developed. As the world of software development became \nsignificantly more complex and sophisticated, the academic realm of computer science became more rigorous, \nstandardized and richer in content. It became very evident that there was much more to teach and learn, \nand much more mathematics and science involved than was anticipated in the prior decades. Unfortunately, \nfewer and fewer students manifested interest in the increasingly difficult discipline. Computer science \neducators felt a need to maintain a precarious balance between achieving the expected depth and breath \nin the more mature computer science major and retaining a sufficient student population. The Present \nIts early years are now history and the field of software development has emerged from adolescence. Software \ndevelopers are no longer craftsmen. They are scientists who are interested in process as well as product; \nthey call themselves software engineers. Nonetheless, the challenges of complexity, maintenance, and \nscale have not been satisfactorily met. In the academic arena, computer science faculty are highly qualified \nand computer science programs are challenging and rich. Yet in too many instances graduating computer \nscience majors are not adequately prepared to become software practitioners and conquer the problems \nthat need to be solved in the software development industry. It is this landscape against which the object-oriented \nmovement presents itself. The Object-Oriented Movement The object-oriented movement is being heralded \nwith religious fervor as the best answer to these increasingly complex needs of the software development \ncommunity. Using Bertrand Meyer s imaginative description of this movement, a tidal wave is reaching \nthe shores of the programming world. Pure object-oriented programming languages, Smalltalk and Eiffel, \nwhich were originally thought to involve performance problems are being successfully used to implement \nsystems from diverse problem domains. The hybrid language C++ is being universally adopted. Structured \nprogramming languages, such as Pascal and Ada, are being revamped to sport object-oriented capabilities. \nJournals, trade magazines and organizations have recently been created specifically to address object- \noriented issues. Object-oriented analysis and design methodologies are rapidly being defined and popularized. \nObject-oriented CASE tools to support the new technique are becoming increasingly available. Software \ndevelopment companies are winning contracts based upon bids that specify object-oriented development \ntechniques. Increased quality, increased reusability, increased ability to successfully accommodate scale \nand concurrency are among the reported rewards for embracing this latest strategy in software development. \nHowever, the novelty and the current popularity alone do not make the object-oriented approach to software \ndevelopment viable. This new model has become exceedingly attractive because: it better encapsulates \nobjects and services, according to recent psychological studies it is closer to the way we think, it \npermits more direct connection to the problem domain, it focuses on objects which are inherently more \nstable than functions, and it extends across the life cycle. Moreover, the initial boasts regarding quality, \nreuse, concurrency, and scalability are now being substantiated by documented software development experience. \nMost significantly, however, the object-oriented approach is the natural outgrowth of the period of adolescence \nfrom which OOPSLAW -2&#38;-Vancouver, British Columbia software development has emerged. This model is \nthe next logical step in the evolution of software methodologies. Certainly then, it is appropriate for \ncomputer science educators to carefully examine where the object- oriented approach fits into the computer \nscience curriculum. Actually there are five questions that seem cogent: 1) Should the object-oriented \nparadigm be included in what is taught? 2) If so, how much of the paradigm-language, analysis, design, \nmanagement-ought to be addressed? 3) At what level in an undergraduate program- introductory, upper level-are \nobject-oriented techniques appropriate? 4) What are the risks involved? 5) How is the object-oriented \napproach effectively taught?  Author s Experience I will base my response to these questions upon both \ndirect and indirect, both industrial and academic, experience with the object-oriented model. Over the \npast five years my close encounter with the object- oriented model has included: teaching object- oriented \ntechniques as part of software engineering training to software practitioners, using object- oriented \nmethodology in large scale software development, teaching object-oriented topics to undergraduate students, \ncreating and teaching an object-oriented development course to upper level undergraduate computer science \nstudents, and directing research in object-oriented development. The object-oriented development course \nwas somewhat unique for an undergraduate curriculum in that the focus was at the higher levels of the \nobject model. I made a concerted effort to prevent the course from becoming an Object-Oriented Programming \ncourse. Syntactical issues were down- played. The concepts of the object model and a methodology for \nperforming object-oriented analysis and object-oriented design were covered in great detail before there \nwas any real discussion of an object-oriented language and implementation. The impact of the object-oriented \nparadigm on software development was also a major thread woven throughout the course. Language presentation, \nafter a cursory look at syntax, was approached from an implementation issues stance. Performance, concurrence, \nabstraction, typing, binding, and inheritance were carefully examined. Project assignments involved analysis, \ndesign and implementation. The fact that the object-oriented approach to software development is still \nbeing refined was stressed. There were not always predefined answers to the questions raised. I have \nlearned through this course and my other experiences that despite its documented potential, people do \nnot meet the object-oriented paradigm with equal enthusiasm nor equal success. As is seen from the historical \ntrace, the object-oriented approach is both more abstract and more comprehensive than its predecessors, \nand from my experience it seems to correspondingly require more maturity and depth to grasp. Moreover, \nI have evidence to support that mastering the object- oriented languages is not the difficult part of \nlearning the model. Rather, the activities preliminary to coding, namely analysis and design, are much \nmore challenging. Furthermore, those individuals with a grounding in software engineering more readily \nbecome expert at the object-oriented approach. Inherent in the object-oriented model is an iterative \nprocess and a real sense of team development. Both students and practitioners who are comfortable with \niteration and collaboration find the object-oriented approach a more natural fit. The converse is also \ntrue. Furthermore, through teaching and applying the object-oriented model, I have become acutely aware \nof its pitfalls. Most of these drawbacks are directly related to the immaturity of the model. Management \ntechniques, testing strategies, and metrics have yet to be adequately experimented with and described. \nWhile there has been improvement, the terminology and the symbology have yet to be distilled into a consistent \nand digestible package. Lack of experience with the model has in some instances caused stalemate in the \ndevelopment of large systems. The most significant outcome of my experience, however, is the realization \nthat the object-oriented approach does fulfill most of its advertised potential. The resultant software \ncan be of higher quality.  Including the Object-Oriented Model Hence, the documented benefits of embracing \nthe object-oriented approach in software development coupled with my own experience with object- oriented \ndevelopment, support a resounding affirmative to question number one. The object- oriented paradigm has, \nby reputation and natural evolution, forced its way into a position which is impossible to ignore or \nat least is irresistible from an academic standpoint. 5-10 October 1992 -247-Addendum to the Proceedings \nHow Much to Include The natural impulse, at least from current discussion in academic circles, is to \nfocus on object-oriented programming-the new languages, environments and libraries of reusable code. \nHowever, in my view neither the object-oriented coding nor the study of the syntax of an object-oriented \nlanguage explores the real benefits of the object-oriented model. As discovered during the structured \nmovement, better coding is not the answer to the software crisis any more than coding is the greatest \nhurdle for computer science students. The object-oriented model needs to be exploited for its problem \nsolving potential. The abilities to better analyze and design a solution and to determine what should \nand can be reused are the key issues if a curriculum is to truly benefit from inclusion of object-oriented \nmaterial. Students absolutely need to experience object-oriented analysis and object-oriented design. \nThus, in answer to question two, there ought to be a look at ALL aspects of the object-oriented model, \nnot just programming. At What Level But then moving to question three, at what level ought the inclusion \nof object-oriented topics begin? Unfortunately, as I have learned the object-oriented model itself is \nstill relatively immature. The issues in programming, much less analysis, design and management, have \nnot yet settled down and for pedagogical purposes been adequately distilled, formalized and described. \nMoreover, the processes of object-oriented analysis, object-oriented design and object-oriented management \nseem from my experience to require a level of maturity not typical in first year undergraduates. For \nnow, until the object-oriented model has been better solidified, an incremental educational strategy \nseems appropriate. That is, introduce object-oriented programming early in the curriculum (CS 1 or CS2 \nor CS2), object- oriented design perhaps in a data structures course, object-oriented language issues \nin a programming language course and certainly object-oriented development in all its glory in a software \nengineering course at the upper level. A course such as the object-oriented development one I have described, \nperhaps offered as a topics course, might be a good initial step to introducing object-oriented material \ninto a computer science curriculum. This course could then be eventually replaced as the material covered \nis incorporated, as suggested above, into more appropriate places in the curriculum. Eventually the object-oriented \nmodel should become an integral part of all levels of the undergraduate computer science curriculum. \n The Risks Involved In response to question four, there is definitely an associated risk, the cost of \nsuch growth is by no means negligible. Issues such as: equipment, compilers, CASE support, books, and \nfaculty experience, are significant. Change always involves some pain. Faculty need to learn and experiment \nto be able to effect the curricula changes suggested above. Also, there is the issue of what the object- \noriented material adds to an already overloaded curriculum. In my mind, there really ought not be a necessity \nto eliminate other computer science topics. Rather, there is a need to refine and distill the current \ntopics to a level that is appropriate to current understanding. In view of this risk some might argue \nthat the time is not right. My response is that educators cannot afford not to take the risk lest they \ndeny their students an opportunity to learn the best of what this generation of software developers has \nput forth and the undeniable basis for the next generation. Effectively Teaching the Object-Oriented \nApproach The response to the final question: How is the object-oriented model effectively taught? is \nperhaps the most difficult to address. The object- oriented approach is still in its adolescent stage \nand documented evidence of effective teaching strategies are only beginning to emerge. From my own experience \nthe pedagogy employed ought not be strictly logical. Teaching the object-oriented approach is NOT like \nteaching mathematics or the syntax of a language. A healthy combination of theory and practice presented \nin a variety of ways is necessary. That is, text and other reading assignments, closed and open laboratories, \ndesign exercises, papers, discussions, group projects, presentations, and in-class walkthroughs of object \ninteraction all have been successfully orchestrated in my classes to produce encouraging results. To \nmake the approach come alive, instructor commitment and experience with the model are essential. Conclusion \nIn summary, it is my conviction that at any cost the entire object-oriented model ought to be incorporated \ninto the undergraduate computer science curriculum in doses developed in an evolutionary way appropriate \nto the current understanding of the object-oriented model itself. It is imperative that students understand: \nthe historical significance of the model and its natural evolution from its ancestors, the current promise \nit holds for some of the most problematic demands on software OOPSLA 92 -248-Vancouver, British Columbia \ndevelopers, and the fact that the object-oriented approach is not the definitive answer to the software \ncrisis but the most significant prospect to date.  BIBLIOGRAPHY [BOO911 Grady Booth, Object Oriented \nDesign with Applications, Benjamin/Cummings Publishing Company, 1991. [BUD911 Timothy Budd, An Introduction \nto Object-Oriented Programming, Addison-Wesley Publishing Co, Inc., 1991. [COA90] Peter Coad and Edward \nYourdon, Object Oriented Analysis 2nd Edition, Prentice-Hall, Inc., 1990. [CUL82] R.S. Culver and J.T. \nHackos, Perry s Model of Intellectual Development, Engineering Education, December 1982. lMEY881 B. Meyer, \nObject-Oriented Software Construction, Prentice-Hall, Inc., 1988. lPRE92] Roger Pressman, Software Engineering \nA Practitioner s Approach, third edition, McGraw-Hill Inc., 1992. [NOR901 Linda Northrop, Software Engineering, \nProduct Software Engineering Training, Eastman Kodak Company, Rochester, New York, 1990. [NOR9 11 Linda \nNorthrop, Object-Oriented Development-the Promise and the Reality, National Science Foundation Object-Oriented \nWorkshop, Rochester, New York, 1991 (unpublished). [NOR911 Linda Northrop, Object-Oriented Development \nCourse, Department of Computer Science, United States Air Force Academy, 1991. [NOR911 Linda Northrop, \nWilliam Richardson, Design Evolution: Implications for Academia and Industry, Software Engineering Education, \nedited by J. Tomayko, Springer-Verlag, New York, 1991. lNOR921 Linda Northrop, Object-Oriented Technology-Spreading \nthe Word, Twenty-Third SIGCSE Technical Symposium, Kansas City, Missouri, 1992. [NOR921 Linda Northrop, \nWilliam Richardson, Teaching the Object-Oriented Model in an Undergraduate Computer Science Curriculum, \nNECC Workshop on Object- Oriented Technology, Dallas, Texas, June 1992. [PUG901 John Pugh, Object-Oriented \nProgramming in the Computer Science Curriculum, SIGCSE Bulletin, Vo122, Feb 1990. iRUM James Rumbaugh, \nMichael Blaha, William Premerlani, Frederick Eddy, William Lorensen, Object-Oriented Modeling and Design, \nPrentice-Hall, Inc., 1991.  Contact information: Linda M. Northrop Visiting Professor United States \nAir Force Academy 5-10 October 1992 -249-Addendum to the Proceedings  \n\t\t\t", "proc_id": "157709", "abstract": "<p>The object-oriented model has become exceedingly attractive as the best answer to the increasingly complex needs of the software development community. The initial boasts regarding quality, reuse, concurrency, and scalability are now being substantiated by documented software development experience. It is certainly appropriate, then, for educators who teach computer science (the current preparation for emerging software developers) to examine where object-oriented development best fits into the computer science curriculum. How much of the paradigm&#8212;language, analysis, design, management&#8212;ought to be addressed? At what level in an undergradute program are object-oriented techniques appropriate? What are the risks involved? How is the object-oriented approach effectively taught?</p>", "authors": [{"name": "Linda M. Northrop", "author_profile_id": "81100024501", "affiliation": "", "person_id": "P172075", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157823", "year": "1992", "article_id": "157823", "conference": "OOPSLA", "title": "Finding an educational perspective for object-oriented development", "url": "http://dl.acm.org/citation.cfm?id=157823"}