{"article_publication_date": "12-01-1992", "fulltext": "\n Addendurn A 92 to the Vancouver, British Columbia, Canada 5-10 October 1992 Proceedings Poster Submission- \n Developing Language Neutral Class Libraries With The System Object Model (SOM) Report by: Mike Conner \nNurcan Coskun Scott Danforth Larry Loucks Andy Martin Larry Raper Roger Sessions IBM Corporation Object-oriented \nprogramming is quickly establishing itself as an important methodology in developing high quality, reusable \ncode. The most promising packaging technology for reusable object-oriented code seems to be based on \nclass libraries. Current technologies for packaging class libraries have several problems, the most important \nof which is that they are highly language biased. Class libraries developed in one language cannot be \nused with other languages. For example, a class library developed in C++ cannot be used by a Smalltalk \nprogrammer, and a Smalltalk library is of no use to a Cobol programmer. The System Object Model (SOM) \nis a new packaging technology designed to address this and other packaging issues. SOM defines a protocol \nboundary in which classes and objects can be registered irrespective of the object model in which they \nare developed. The design of this protocol boundary is such that objects and definitions registered in \nthe boundary are naturally and efficiently accessible (and even subclassable) from a number of different \nprogramming languages. The architecture of this boundary and the supporting runtime and tools constitute \nSOM. In addition to defining a language neutral object model, SOM offers a number of features considered \nimportant in the packaging of industrial strength class libraries. These include support for dynamic \nloading and linking of classes; the ability to update class libraries without requiring that client applications \nbe recompiled; the ability to ship class libraries without source code; and the ability to use object-oriented \ntechnology from traditional procedural programming languages. It is important not to erode the quality \nof object support in existing object-oriented languages with respect to syntax, performance, flexibility, \nor development support. That is, SOM is designed to work with existing object-oriented languages, not \nto replace them. One of the ways programmers use classes is through subclassing. Support for cross language \nsubclassing is more difficult than cross language use, but this form of customization of reusable components \nis the major advantage of object technology over well structured procedure libraries, and is an important \nfocus of SOM. 5-10October 1992 -Ku-Addendum to the Proceedings Most commonly used programming languages \nare not object-oriented and have difficulty using and creating class libraries. However the SOM tools, \ncombined with the SOM runtime, provide support for these languages so that the use and definition of \nclass libraries is quite natural. These SOM provided object-oriented extensions are not intended to eliminate \nthe need for object-oriented languages. Object-oriented languages will continue to offer many benefits \nto object developers and users. The SOM extensions are meant to provide those who choose procedural languages \nto use object-oriented tools. In the current version of SOM as released on OS/2 2.0, we provide full \ntool support for only C language bindings. For a description of using these C language bindings, see \n[Sessions and Coskun], [Coskun and Sessions] and [SOM]. We also have experimental C++ bindings, designs \nfor Smalltalk bindings, and bindings to an experimental object- oriented version of REXX. We are working \nwith a wide variety of language suppliers, both internally and externally to provide language bindings \nto as many languages as possible. SOM is designed to augment existing object-oriented languages, not \nto compete with them. Object- oriented languages already have object models. For these languages, SOM \noffers a language neutral packaging technology and upwardly compatible binary libraries. C++, for example, \nis a very efficient object-oriented language, with direct support for encapsulation, polymorphism, and \ninheritance. Many programmers arc already familiar with the language, and a large body of C++ code is \nalready in existence. C++ has an object model that is optimized to meet the needs of c++. However C++ \nas a technology for packaging class libraries has some significant drawbacks that SOM can help address. \nThe most important is that class libraries written in C++ can be used only from C++. C++ libraries cannot \nbe used by such commercially important languages as Cob01 and Fortran, or even by other object-oriented \nprogramming languages such as Smalltalk. SOM solves this problem by allowing C++ libraries to be packaged \nin a language neutral form that they can be used (and subclassed) from any language with SOM bindings. \nAnother problem with C++ class libraries is that their binary versions are not upwardly compatible. When \na new CH class library is released client code typically has to be fully recompiled, even if the changes \nare unrelated to public interfaces. This problem is discussed in detail in [Sessions]. When a C++ class \nlibrary is packaged with SOM many changes can be made to the library source without requiring recompilation \nof client code. SOM allows methods to be moved up the class hierarchy, instance variables to be deleted, \nnew methods or instance variables to be added, and new classes to be inserted into the class hierarchy. \nAny of these changes would require C++ clients to recompile their code, had they been using standard \nC++ class libraries. The design of the SOM protocol boundary was faced with seemingly conflicting requirements. \nOn the one hand it needs a great deal of flexibility to span the different method resolution, memory \nmanagement and runtime support strategies employed by various different programming languages and object \nmodels. On the other hand, it must have little or no performance overhead in cases where, for example, \na C++ program is using a class written in C++. SOM achieves both of these goals by using language neutral \nobjects in the protocol boundary. These objects present an interface that is either very abstract (saying \nnothing about method resolution for example) or very optimized depending on the view of the using program. \nFor example, a C program might look up a method via an offset into a method procedure table while a Smalltalk \nprogram might access that same method via a dispatch function that completely hides the resolution mechanism. \nA key aspect of this approach is the SOM Object Interface Definition Language (OIDL). OIDL provides a \nlanguage neutral class definition and is the basis for the tools that support access to the protocol \nboundary. We have several compilers, one for each language binding. In the future, we are planning on \nsupporting CORBA IDL [CORBA]. SOM provides three types of method dispatch mechanisms: offset lookup, \nname lookup and dispatch function. The @ser lookup is the fastest method dispatch mechanism and is designed \nto be used by the compiled, statically typed languages. This type of method dispatch exposes method signatures \nand some aspects of the class hierarchy. The name lookup is the second fastest method dispatch mechanism \nand only exposes method signatures. The name lookup mechanism should be used when there is a requirement \nto hide all aspects of the class hierarchy. It is also useful when the only information known at compile \ntime is the method signature. The dispatch function mechanism has more overhead in comparison to offset \nlookup and name lookup techniques, but is much more flexible and can be used to send messages to the \nSOM objects dynamically. Dispatch resolution allows object providers OOPSLA 92 -192-Vancouver, British \nColumbia complete control over the resolution process, allowing even such resolution models as the one \nused in the Common Lisp Object System (CLOS), which dispatches based on the types of more than one method \nparameter. Dispatch resolution also allows object providers an efficient, and centralized point to perform \nparameter translation, memory management and other things that are necessary when interfacing a dynamically \ntyped execution environment (such as Smalltalk or CLOS) to another execution environment. The existing \nprogramming language bindings can support SOM through one of three techniques: macros, procedure wrappers \nand stub methods. Languages like C and C++ have powerful macro processors which can be used to extend \nthem to support SOM. Languages like Pascal and Fortran do not have macro processors and instead use procedure \nwrappers for each method. The main function of the procedure wrapper is to hide method resolution computation. \nDynamic Languages like Smalltalk and CLOS use stub methods which convert language specific object parameters \ninto simple SOM values (int, double, etc.) as appropriate, and then wrap the return value in a language \nspecific object. Stub methods can be very small and dynamically generated when a language makes use of \nthe dispatch function mechanism for method resolution. SOM has moved well beyond the research state. \nIt is actively being used throughout IBM and has been accepted as the standard packaging technology for \nclass libraries within IBM. It is part of the OS/2 2.0 toolkit and its release on AIX is anticipated. \nIBM has already shipped its first product based on SOM: the newly released Workplace Shell of OS/2 2.0. \nIBM is actively working with a wide variety of language vendors and industry standard groups to make \nSOM a non-proprietary and generally accepted technology.  References [CORBA] The Common Object Request \nBroker Architecture and Specification. OMG Document Number 9 1.12.1, Object Management Group, Framingham, \nMassachusetts. [Coskun and Sessions] Class Objects in SOM, by Nurcan Coskun and Roger Sessions. OS2/2. \n[Sessions] Class Construction in C and C++: Object-Oriented Programming Fundamentals, by Roger Sessions. \nPrentice Hall, Englewood Cliffs, New Jersey, 1992. [Sessions and Coskun] Object-Oriented Programming \nin OS/2 2.0, by Roger Sessions and Nurcan Coskun. IBM Personal Systems Developer, Winter, 1992, 107-120. \n[SOM] OS!2 2.0 Technical Library System Object Model Guide and Reference, IBM Dot S 1066309.  Contact \ninformation: Roger Sessions I.B.M. Corporation Object Technology Group 11400 But-net Road Austin, Texas \n78758 5-10 October 1992 - 193 -Addendum to the Proceedings  \n\t\t\t", "proc_id": "157709", "abstract": "", "authors": [{"name": "Mike Conner", "author_profile_id": "81339494815", "affiliation": "", "person_id": "PP31075242", "email_address": "", "orcid_id": ""}, {"name": "Nurcan Coskun", "author_profile_id": "81339495404", "affiliation": "", "person_id": "PP39030237", "email_address": "", "orcid_id": ""}, {"name": "Scott Danforth", "author_profile_id": "81100337977", "affiliation": "", "person_id": "PP39070810", "email_address": "", "orcid_id": ""}, {"name": "Larry Loucks", "author_profile_id": "81541331056", "affiliation": "", "person_id": "PP311180100", "email_address": "", "orcid_id": ""}, {"name": "Andy Martin", "author_profile_id": "81332514528", "affiliation": "", "person_id": "P18792", "email_address": "", "orcid_id": ""}, {"name": "Larry Raper", "author_profile_id": "81100094835", "affiliation": "", "person_id": "P168647", "email_address": "", "orcid_id": ""}, {"name": "Roger Sessions", "author_profile_id": "81100217460", "affiliation": "", "person_id": "PP31095975", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157751", "year": "1992", "article_id": "157751", "conference": "OOPSLA", "title": "Developing language neutral class libraries with the System Object Model (SOM)", "url": "http://dl.acm.org/citation.cfm?id=157751"}