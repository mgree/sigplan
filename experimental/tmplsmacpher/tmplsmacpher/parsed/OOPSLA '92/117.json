{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 to the Vancouver, British Columbia, Canada 5-10 October 1992 Proceedings Educators Symposium- \n A Case for, and an Instance of, Objects in CSI Report by: Rick Decker Stuart Hirshfield Hamilton College \n I. The Problem: Teaching Introductory Programming Despite considerable effort and a great deal of \nrhetoric, the past two decades have seen relatively little progress in the effectiveness with which we \nteach computer programming. Indeed, the most common programming languages for teaching (Pascal, BASIC, \nFORTRAN, C) are essentially the same ones that we have used for the past 20 years. To be sure, the implementations \nof these languages have become increasingly sophisticated. The languages are now more expressive, offer \nadditional features to address software engineering concerns, and support more sophisticated interactive \nprogramming and debugging, but the paradigm for teaching programming has remained essentially intact. \nWe teach procedural languages-languages in which the basic unit of abstraction is a procedure, or an \nalgorithm, and there is a clean distinction between an algorithm and the data it operates on. We do so \nknowing that such languages have well-documented theoretical and practical limitations. Simply stated, \nprocedural languages (1) do not support the development of efficient, reusable software, (2) are ill-suited \nto modelling real-world applications and, so, are not particularly useful for system design, and (3) \nare difficult to teach, perhaps because of (1) and (2), and perhaps because they impose an algorithmic \nmethod (as opposed to data- oriented) of problem solving that is counter- intuitive to many otherwise \nbright students. This algorithmic method enforces a tactical paradigm, in which the emphasis and level \nof organization are oriented more or less to the details of coding. The principles of program design \nare not enforced by procedural languages like Pascal; rather they are addressed by add-ons which have \nbeen introduced to make the programming process more efficient. We are trying to make our students program \nin the ways we learned through years of practice by tacking these principles on top of a language that \ndoes not support them directly as part of its design philosophy. These byproducts of our varied and well-intentioned \nefforts at teaching procedural programming--our CS 1 students-range from those who, after three weeks \nof the semester, are irretrievably lost and will never learn to program a loop, all the way to those \nwho whiz through CS 1 and quite possible go on to major in CS and graduate. All but the very best are \nill-prepared to work as professional programmers because they have yet to develop what are currently \nregarded as basic software engineering skills. That is, they have difficulty analyzing and designing \nlarge- scale programs, and producing code that is readable, reliable, verifiable, reusable, maintainable, \nand so on. Our collective response to these failings has been, first, to blame the students, citing their \nlack of preparation, eroding quantitative skills, and lack of effort. More constructive, at least, have \nbeen our attempts to adapt the pedagogical techniques we have used to teach Pascal to our audience. For \nexample, hindsight being what it is, it seems incredible that it has taken us 20 years to recognize that \nprogramming is best taught as a contact sport. Students, we now know, learn best through directed, hands-on \ninteraction with the computer (hence, the current movement toward formal lab experiences in programming \ncourses) and by reading meaningful working programs that provide a context for language learning. Early \nprogramming textbooks tended to be either rigid technical manuals detailing the implementation and syntactic \ndetails of a particular implementation, or were general discussions of programming principles that were \nof little practical value. Only within the past five years or so have there appeared principled texts \nthat address explicitly programming and problem solving skills in particular languages. This past year \nhas seen many of these texts expanded to include lab manuals, and other newer texts have been developed \nthat embrace the lab approach from the outset. To be sure, such insights have produced modest quantitative \ngains in teaching effectiveness. Still, the larger qualitative questions-all of which translate into \nstudents can t see the big picture -remain. That is, students cannot be motivated to appreciate how things \nthat don t seem vital to CS 1 (like the need for subprograms, parameters, information hiding, effective \nuser interface) are truly important in real programs. It may be that the current batch of procedural \nprogramming texts do about as good a job as can be expected in teaching Pascal as a first language. If \nthat is the case, perhaps we should re- consider what we are teaching novice programmers instead of just \nhow we are teaching them. II. The Source: Algorithmic Languages It should not surprise us that our students \ncan t appreciate the big picture when what we spend most of our time teaching them in CS 1 is the little \npicture. CS 1 students are taught how to implement algorithms and data structures, how control structures \nwork, the differences between local and global variables, the details of parameter passing, and the like. \nIf the bigger issues of problem- solving, design, and software engineering are so important, why are \nwe investing an entire first course in teaching the equivalent of modem-day assembly language? Most real \nprograms have to manage a large amount of data of different types, in very simple ways. Their complexity \nlies in the organization at the strategic level of program design and user interface, and not in the \ntactical details, which generally are devoted to simple things like comparisons, counting, moving data \naround, and what the screen should look like to the user. Why beat our CS 1 students over the head trying \nto get them to invent hashing on their own, when real programs are judged on whether they come in on \ntime, how appealing they will be to the user, and how easy it will be to upgrade to a new version? Also, \nwhy try to teach them to cope with organizational complexity in procedural terms? It just doesn t work \nvery well. When we think about how experienced programmers write programs, it s obvious-now-that we rely \non a stock of paradigms. Thinking up something completely new is hard-we write programs by recognizing \nthat a task is similar to a task we ve either seen before or have (perhaps laboriously) written on our \nown. The traditional CS 1 assignment almost invariably requires something the students have never seen \nbefore. This is equivalent to giving them a research project to complete each week. Is it any wonder \nthat the dropout rate is often as high as 40% in introductory programming courses? We re asking our students \nto do something that would be demanding for the best of us-coming up with completely new concepts on \na weekly basis. We believe the source of the CS 1 problem is the type of languages we have been teaching. \nIt is time to recognize that procedural languages and the prevailing process-state model of computing \nthat they reflect are perhaps historical accidents. They reflect the inner workings of the machine and \nsupport most directly the little picture. So, while we preach to our students the value of top-down problem \nsolving techniques to programming, we teach them languages designed to express detailed algorithms, \nIll. The Solution: Object-Oriented Programming We have decided, at long last, to begin to practice what \nwe have been preaching, and adopt a language that supports top-down teaching. We propose and are currently \ndesigning a new CS 1 course to reflect the position that the object-oriented paradigm is the one best-suited \nfor teaching introductory programming. In it we introduce objects from the very beginning, deferring \ntreatment of algorithms and analysis until the CS 2 course where it occurs most naturally. While not \nan entirely new position (others have tried it with limited success), our course is innovative in that \nit applies a number of proven pedagogical techniques to the teaching of object- oriented programming. \nSo, our course is lab-based, providing students with detailed, directed, experimental laboratory exercises \nwhich help them to explore the principles of OOP in a controlled fashion. Each lab is based on a complete, \nworking, motivating, and interesting sample program for students, first, to read, and then to experiment \nwith in the lab. Finally, each chapter describes programming in the broader context of computer science \nby introducing a computer science topic that is related to the sample program. For example, when we talk \nabout hardware, artificial intelligence, or computer applications, the corresponding lab program is a \nlogic breadboard, an expert system shell, or a spreadsheet. How, though, can students appreciate the \npower and utility of objects unless they have access to a world of objects that they can experiment with \nand learn from? We are going to provide students, on their lab disks, with the equivalent of a world \nof program- ming objects that will allow-and encourage-them to work like professional programmers right \nfrom the start of their programming careers. This world will implement many of the classes, objects, \nand methods that students will need to understand the sample programs and lab exercises. The idea of \nproviding programmers with an expansive collection of built-in programming tools is not new. Indeed, \nit is central to many high-level programming languages (Smalltalk s class library) and even machines \n(the Macintosh Toolbox). While such collections are useful to professional programmers, experience has \nshown us that novices are overwhelmed by both the low-level nature of the library routines, as well as \nby their sheer volume. Our world will consist of a less voluminous, higher-level collection of built-in \nobjects that are tailored specifically to our sample programs and to the text. Initially, students will \nuse the object world by interacting with sample programs that will be provided to illustrate specific \nOOP and C++ features. As they become more familiar with C++, students will be exposed to the details \nof the world so that they can read the implementations of the objects that they have been using. Then, \nthey will be shown how they can modify and extend the existing object world to suit the needs of a particular \nprogram, Finally, they will be taught how to define their own objects. The details of the the programming \nworld, in particular, the algorithmic details of C++, will be revealed slowly and only as needed to illustrate \nthe principles of objects. We will, perhaps for the first time, be in a position to teach top-down programming \nand top-down design techniques using a programming environment that supports top-down development.  \nIV. Pedagogical Implications From the standpoint of course content, this approach is justified on the \ngrounds that OOP effectively addresses all of the aforementioned shortcomings of Pascal-like languages. \nGenerally speaking, OOP allows-even encourages-one to address the big picture by emphasizing a strategic \napproach to programming. A strategic approach involves a concentration primarily on the top-level design \nconsiderations, reduces the need to get involved in details at an inappropriate time in the design process, \nand encourages the building of programs from established collections of predefined code. Indeed, OOP \nsupports directly many of the concepts that are among the most difficult to convey in procedural terms: \ncode reuse, information hiding, the need and value of subprograms, and program design. Note too that \nOOP reflects both how real programmers develop real programs, and more generally, how we humans solve \nproblems. Even the language of OOP ( object, class, inheritance, etc.) has a psychological bent. This \nallows us to pursue the metaphors and to solve problems in more human-like (as opposed to computer-like) \nterms. This orientation may explain, at least in part, the appeal of Smalltalk to children, the utility \nof OOP to large-scale problems, and the difficulties we have encountered in trying to teach procedural \nlanguages to students who can t seem to learn them. As regards teaching methods, that is, how we teach, \nusing OGP allows our teaching approach to match our teaching philosophy-both are now top- down. Our approach \nhas been to apply the pedagogical principles that we have learned from teaching Pascal (many of which \nhold no matter what type of language is being taught) to the task of teaching object-oriented programming. \nAs we mentioned before, others have tried using OOP early on in the CS curriculum, mostly using the Smalltalk \nsystem. Two common problems have been encountered, both of which appear, at this early stage, to be overcome \nby our approach. First, if students already know a Pascal-like language, the paradigm shift is often \ndifficult (as anyone who has learned an object-oriented language after knowing procedural languages can \nattest). This problem is reduced by making an object-oriented language the first programming language \na student learns. If our top- down philosophy really works as advertised, the shift in the other direction \n(from object-oriented to procedural) should be with the current, as opposed to against it. The other \ncommon complaint is that Smalltalk is so tightly coupled to its environment and to its powerful class \nlibraries that it is overwhelming to all but the best students. We use C++ as our language, primarily \nfor practical reasons (it is closer to Pascal, which is still the language of the Advanced Placement \nExam; it has wide industry support; and, it is a true object-oriented language). Instead, though, of \nleaving students to find their way through a maze of classes, we introduce OOP principles as we need \nthem in lab. The lab materials have been designed to guide students through the world of objects is a \ngraduated fashion. That is, students learn to use objects as a means to customize objects as a means \nto defining objects of their own. This graduated approach not only makes object- oriented concepts accessible \nto novice programmers, but also leads them directly, and in top-down fashion, to a more standard CS2 \ncourse in which algorithms can be explored in full detail. The only ones who may not be overwhelmed \nby these alleged virtues of introducing OOP in CS 1 are those who would be asked to teach it. Teachers \nhave been reluctant to use OOP in introductory courses because OOP is viewed as an advanced programming \ntechnique. In the sense that it enhances and facilitates the development of complex software systems, \nit is. We believe, though, that with appropriate pedagogy, OOP can be taught from the start. Doing so \nintroduces students to programming in higher-level, conceptual terms, by encouraging them to think of \nprograms as collections of familiar objects. It also avoids the difficult paradigm shift that most programmers-even \nprofessionals-have reported in learning C++ after already knowing Pascal. The difficulty they have had \nlearning C++ as a second (or later) language may also explain some teachers notion that it is a tool \nfor advanced programmers only. These fears can be overcome by convincing instructors that adopting an \nOOP approach is to their-and their students -advantages both practically and theoretically. OOP offers \nthe potential for helping our students to be become competent professional programmers who do not have \nto re-learn how to program in the real world. It also allows out teaching approach to match our teaching \nphilosophy and our curriculum-all can at last be top down. Contact information: Stuart Hirshfield (primary \ncontact) Department of Mathematics and Computer Science Hamilton College 198 College Hill Road Clinton, \nNY 13323 (315) 859-4136 shirshji@hamilton.edu Rick Decker Department of Mathematics and Computer Science \nHamilton College 198 College Hill Road Clinton, NY 13323 (3 15) 859-4785 rdecker@hamilton.edu   \n\t\t\t", "proc_id": "157709", "abstract": "", "authors": [{"name": "Rick Decker", "author_profile_id": "81100438821", "affiliation": "", "person_id": "PP31076020", "email_address": "", "orcid_id": ""}, {"name": "Stuart Hirshfield", "author_profile_id": "81100259122", "affiliation": "", "person_id": "P270695", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157840", "year": "1992", "article_id": "157840", "conference": "OOPSLA", "title": "A case for, and an instance of, objects in CS1", "url": "http://dl.acm.org/citation.cfm?id=157840"}