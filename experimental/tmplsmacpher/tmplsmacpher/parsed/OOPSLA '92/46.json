{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 to the Vancouver, British Columbia, Canada 5 - 10 October 1992 Proceedings Poster Submission- \n A Visual Environment for Distributed Object-Oriented Multi-Applications Report by: Robert Strom Daniel \nYellin IBM T. J. Watson Research Center Traditional computing environments are oriented towards standalone \nprograms. These programs are self-contained-they interact with the user via a virtual terminal or a window, \nand with other applications via a centralized file system. However, there is an increasing trend towards \nmultiapplications. Multiapplications are collections of programs which interact directly with one another. \nFor example, I may wish to connect my mail service with a filter which automatically logs my mail, and \nroutes bills and receipts to a home finance program. Multiapplications may even be distributed over multiple \nmachines. For example: my home finance program may be connected to my bank; I and a colleague may be \ncollaborating on a paper, or playing chess. There is a considerable body of work on infrastructure to \nfacilitate creation of multiapplications by programmers: for instance, operating system support (Mach, \nWindows), commercial RRC packages such as DCE RPC, and high-level languages (Emerald, Hermes, Concert/C). \nThere is less such support for the end-user wishing to configure multiapplications. The most widely available \nsystems are based on Object Linking and Embedding. Although this is a useful step, it is still derived \nfrom the paradigm of applications communicating via files. Highly interactive applications, such as queries, \nprocess control, real- time music jamming, etc., require other interaction paradigms. These paradigms \nare supported at the low-level for programmers, but not for end-users. Another reason to support new \ninteraction paradigms is the desire to let users break their applications into smaller components and \nreconfigure them. For example, a word processor package contains components such as editors, formatters, \nspelling checkers, etc. A MIDI music package contains components such as sequencers, quantizers, patch \neditors, score editors, etc. Users may wish to break up large packages into small components in order \nto mix and match components from different sources. The smaller the component, the less appropriate is \na file-passing paradigm, and the more appropriate an object-based paradigm based on message exchange. \nThis paper describes an operating environment for distributed interacting multiapplications. It incorporates \nan underlying object-based programming model, based on the process model of Hermes [2] and Concert/C \n[ 11. It incorporates an end- user visualization of this model, whose look and feel is based on analogies \nto familiar modular equipment found in the home, such as cable boxes, cable splitters, TVs, VCRS, stereos, \netc. S-10 October 1992 -2&#38;-Addendum to the Proceedings The computation model is as follows: The computational \nobjects are called components. Components may own data, and execute programs. The programs manipulate \nthe local data, and exchange messages with other components via connectors. Connectors have an interface \ntype, which defines the protocol (data type, and sequence) of messages sent by the component and expected \nfrom other components. Components are implemented by the processes of languages such as Hermes and Concert/C; \nconnectors by collections of ports. Each component is either owned by a deskfop in the network, or by \nanother component. When a component is on a desktop, it is visualized as a window or icon. The connectors \nare visualized as decorations called plugs, sockets and slots. Plugs and sockets on a desktop may be \ninterconnected with wires. The shape and/or color of plugs, sockets, slots and wires reflects their interface \ntype. Wires may cross desktops: such wires will appear to vanish into a hole in the desktopl. Each window \non the desktop has its own graphical user interface whose appearance and function is application-specific. \nThe appearance and function of the decorations, however, is uniform across the desktop. The following \noperations are supported: Wiring Plugs and Sockets: The user can make and break connections between plugs \nand sockets of matching interface type by clicking and dragging, This causes bindings to be established \nbetween the corresponding ports in the underlying programs, allowing them to communicate. Dropping Objects \ninto Slots: The user can drop either a component or an unattached wire connector into a slot. This transfers \nthe ownership of the component or of the wire connector from the desktop to the receiving component-the \ncomponent owning the slot. The object which was dropped disappears from the desktop. The capability to \nmanipulate the component or to connect the wire is now transferred from the end user to the program in \nthe receiving component. Receiving Objects from Slots: A component may on its own initiative emit a component \nor wire connector from an output slot. This is the reverse of dropping: the ownership of the object is \ntransferred from the emitting component to To avoid cluttering the desktop, the plugs, sockets, and \nwires may be hidden away when the user is not interested in examining or changing the configuration. \nthe end user at the desktop; the formerly invisible object becomes visible. Notice in particular that \na distributed connection can be achieved by dropping a component or wire into a mailbox component on \none desktop and having it re-emitted from a mailbox component on another desktop. Packaging and Unpackaging: \nThe user can change the level of granularity at which he or she views components or connectors. A collection \nof components can be packaged into a single component. The user may specify that certain windows and \ncertain connections of the package be hidden. Once packaged, the new composite component is manipulated \n(dropped, emitted, killed, etc.) as a single unit on the desktop. Unpackaging is the reverse operation \nwhich reveals the previously hidden structure of a composite component and allows the individual parts \nto be reconnected, dropped, destroyed, etc. Connectors may also be packaged: for example, a collection \nof two plugs and a socket may be grouped to form a three-pin connector.  References (1) Joshua Auerbach, \nMark Kennedy, Jim Russell, and Shaula Yemini. Inter-process communication in concert/C. Technical Report \nRC1734 1, IBM T. J. Watson Research Center, October 1991. (2) Robert E. Strom, David P. Bacon, Arthur \nGoldberg, Andy Lowry, Daniel Yellin, and Shaula Alexander Yemini. Hermes: A Language for Distributed \nComputing.  Prentice Hall, January 1991.  Contact information: Robert Strom strom@watson.ibm.com Daniel \nYellin dmy@watson.ibm.com IBM T. J. Watson Research Center PO Box 704 Yorktown Heights, NY 10598 OOPSLA \n92 -206-Vancouver, British Columbia   \n\t\t\t", "proc_id": "157709", "abstract": "", "authors": [{"name": "Robert Strom", "author_profile_id": "81100300843", "affiliation": "", "person_id": "PP79024040", "email_address": "", "orcid_id": ""}, {"name": "Daniel Yellin", "author_profile_id": "81407591756", "affiliation": "", "person_id": "PP77041097", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157755", "year": "1992", "article_id": "157755", "conference": "OOPSLA", "title": "A visual environment for distributed object-oriented multi-applications", "url": "http://dl.acm.org/citation.cfm?id=157755"}