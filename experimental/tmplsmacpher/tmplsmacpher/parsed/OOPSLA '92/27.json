{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 to the Vancouver, British Columbia, Canada 5-IO October 1992 Proceedings Poster Submission- \n n;: A New Approach to the Design of Distributed Report by: Dinesh C. Kulkami Arindam Banerji David L. \nCohn University of Notre Dame A Vision of Computing s Future Modem computer hardware technology allows \na single architecture to be used for a range of machines from supercomputers to toasters. Hardware designers \nhave recognized that an architecture should be scalable and system software developers must address the \nsame issue. Scalability means that the architecture must beflexible enough to satisfy diverse hardware \nand application needs. The key to operating system flexibility is to base the architecture on a high-level \ngraph model and to use the generalized object model and metacomputing. The resulting framework is a uniform \nobject model for application and system software. Classically, operating system flexibility means that \nthe architecture must handle various processor capabilities, differing memory and disk sizes and a vast \nrange of peripheral devices. Today, it also includes dealing with multiprocessor systems, diverse network \ntopologies and multimedia input/output. In the future, as radio-based networking becomes common, changes \nwill be dynamic, requiring the flexible operating system to adapt as elements of a distributed system \nmove into and out of range. Different classes of applications have different requirements. The valuable \ndata managed by an S-10 October 1992   Operating Systems OODB must be maintained over long periods \nof time while a multimedia application requires guarantied bandwidth. The necessary services and the \nrelative emphasis on different functionalities vary drastically. The x architecture is designed as a \nframework, for flexible operating systems and support software. It is based on this vision of the future \nand is a first step towards adaptive operating systems. It starts with a high-level model of applications \nand incorporates facilities for changing abstractions as a fundamental feature. Graph Model for Applications \n We contend that applications can be effectively modeled as dynamic directed graphs. The nodes of the \ngraph represent objects and the arcs are relationships between the objects. The objects may be active, \nactivatable or simple data objects. The arcs may be object references, activation protocols, delegation \ntargets and so forth. The graph is dynamic since new nodes can be created, old ones can be purged and \nrelationships can be changed. For example, a CAD model of a robot could have a set of data objects containing \nthe descriptions of the robot s components and a set of links that be these data objects together. The \nlinks would represent the -Ml-Addendum to the Proceedings is composed of relationship. Thus, the robot \narm is composed of a hinge and a gripper and so on. I For another application, an arc connecting two \nnodes could represent a client-server relationship between two objects. Events make the graph model dynamic. \nAn event could simply be a method invocation by a client object or it could be an asynchronous activation \ncaused by an interrupt or an exception. Mapping onto Resources System software maps abstract application \nmodels onto the computational reality as shown in the figure. The programmer first expresses the application \nthrough a language and then the run-time environment and operating system control the resources which \nrealize the application. The system software mapping should hide possible changes in the computational \nreality. Thus, if more processors become available at run time, they should be used effectively. The \nservices offered by the abstractions and their implementation must be tailorable. For example, a reference \nwhich crosses a machine boundary may use a name server but when its target is on the local machine, it \nshould be possible to use a simple pointer. A Framework for Mapping - n: K defines a uniform object \nmodel for both application mapping and system software. Its architecture is based on three main notions: \nResources-elements of the computational reality. Events-the causalities of computation. Interfaces-structured \npresentation of resources and events. 7c specifies how these three ideas are combined into a flexible \nobject-based framework. The elements of the computational reality, such as the computational, storage \nand communication resources, are encapsulated into resource objects. Similarly, abstract resources like \nlocks and messages are also presented as resource objects. A programmer can use these objects in various \nways. They can be used as is, or several can be combined or additional services can be defined. Events \nare typed entities which encapsulate important state changes in the system. They have three aspects: \ngeneration, notification and handling. Each object clearly specifies the events that it might generate \nand the events that it can handle. Notification mechanism allows decoupling of event generation and event \nhandling. Applications see resource objects and events through interfaces. The interfaces contain the \ntype specification for the services provided by the object and also for the events generated by the object. \nThese three components am glued together by the R environment. The environment provides services traditionally \nfound in operating systems, language tools and run-time support systems. It is not a rigid structure \nand applications can alter it by incorporating value-added services. The generalized object model gives \nthe environment flexibility in the resolution of activation targets. Reification of otherwise implicit \nfeatures supports metacomputation which allows modifications to the environment. Finally, version set \ninterfaces streamline the management of changes caused by metacomputadon. The changes are propagated \nby metaobjects to their acquaintances, thereby providing a lazy propagation mechanism suitable for distributed \nsystems. The flexible features can be illustrated with a sequence of distributed shared data abstractions. \nAt the basic level, the distributed shared data appears to a programmer like a normal region of memory. \nAny support for distribution, such as replication and coherency control, is invisible. Similarly, any \nassociated metadata, such as type information for translation between architectures, would be hidden. \nThe abstraction is refined if the metadata is reified and made available for modification. A further \nrefinement is to make the application aware that the data is virtually shared through coherent replicas. \nFinally, the coherency manager itself could be reified to allow the programmer to change the coherency \npolicy to improve performance. OOPSLA 92 - 142 - Vancouver, British Columbia  Goals The long term goal \nof the TC project is to develop a framework within which operating systems can be assembled using basic \ncomponents and their refinements. It focuses on change as the most important aspect and handles it through \nmetacomputation and interfaces.  Contact information: Dinesh C. Kulkami Arindam Banerji David L. Cohn \nDistributed Computing Research Laboratory University of Notre Dame Notre Dame, IN 46556, U.S.A. contact: \ndlc@cse.nd,edu 5-10 October 1992 -143-Addendum to the Proceedings  \n\t\t\t", "proc_id": "157709", "abstract": "", "authors": [{"name": "Dinesh C. Kulkarni", "author_profile_id": "81332510269", "affiliation": "", "person_id": "PP31085656", "email_address": "", "orcid_id": ""}, {"name": "Arindam Banerji", "author_profile_id": "81100284849", "affiliation": "", "person_id": "P21439", "email_address": "", "orcid_id": ""}, {"name": "David L. Cohn", "author_profile_id": "81100363116", "affiliation": "", "person_id": "PP39070567", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157736", "year": "1992", "article_id": "157736", "conference": "OOPSLA", "title": "&#960;: a new approach to the design of distributed operating systems", "url": "http://dl.acm.org/citation.cfm?id=157736"}