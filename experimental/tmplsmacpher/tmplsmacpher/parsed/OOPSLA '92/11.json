{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 to the Vancouver, British Columbia, Canada 5 - IO October 1992 Proceedings Panel Report- \n From Events to Objects: The Heresy of Event-Orientation Report by: Larry L. Constantine Lucy A. D. Lockwood \nConstantine &#38; Lockwood, Consultants Note by preparer: The following material provides a paraphrased \ndigest of the panel discussion and questions, not a verbatim transcript. Framing the Issue [Larry Constantine] \nAlthough approaches may differ widely, every object-oriented development method must solve essentially \nthe same set of problems. Any application involves a set of basic ideas or underlying constructs that \ndefine a subset of the application domain. These constructs imply a variety of options for realization \nin data structures. In addition, applications involve behavioral elements: things the system must respond \nto and things it must perform. Together, these may be thought of as comprising a collection of partial \nand fragmented models. One way to look at a complete object-oriented analysis and design method is that \nit must associate the elements of these partially correlated models and merge them into a single unified \nmodel in which all behavior has been allocated to specific object classes as embodiments of underlying \nconstructs. An important question is just what are the consequences of approaching this issue from different \npoints of view. The dominant S-10 October 1992  in a World of Objects methodologies and orientations \nin object-oriented today, what might be termed the traditional approaches, begin with the constructs \nin the application domain, the domain entities or classes, as the initial focus and primary point of \nreference. A more heretical view is found in the approaches developed by the panelists, who make certain \nof the dynamic behavioral aspects of the application, the events and event sequences, the primary material \nfrom which an object-oriented architecture is delivered. Event Partitioning [John Palmer] If you look \ncarefully at many different object- oriented methods you find evidence of event-think in addition to \nobject-think. Some ten years ago, essential systems analysis articulated the crucial notion of event-object \npartitioning, recognizing that two themes are required for effective partitioning of large problems: \nevent partitioning for functional behavior, object partitioning for information. Events alone are inadequate \nand objects/classes alone can t do it. We need two partitioning themes or orientations, regardless of \nthe form of implementation downstream. Some problems are more effectively solved with both -5s-Addendum \nto the Proceedings partitioning themes than with class-oriented thinking alone, including: 1) systematic \nways for derivation and validation of pre- and post-conditions 2) integration of system level messages \nwith specification of system operations, enhancing traceability from interfaces through to the components \nin the requirement specification and design 3) identification and validation of complete end-to-end sequences \nof behavior that apply in a specific circumstance 4) validation of object integrity, making sure that \nall methods actually perform mutually consistent state-changes on encapsulated data 5) allocation of \nmethods to particular object classes easier transition to event-driven software 7) better support of \nspiral development ala Boehm 8) improved traceability of requirements, which are often expressed in terms \nof events and event responses 3 Originally, essential systems analysis partitioned data flow diagram \nin terms of events and data stores in terms of objects or classes. Functional partitionings, whether \nrepresented in terms of data flow diagrams or message flows, can be derived from an events list, which \nis one of the first deliverables. Using proper abstraction guidelines to avoid unnecessary or inappropriate \ndetail, this model can be tied to system level events in a system context diagram. Event partitioning \ncan be applied to entity relationship models or to an object class schema. These are partitioned as a \nway of breaking down what would otherwise be a huge domain analysis into manageable parts. Event partitioning \nat the dynamic model level and the object schema level, to use OMG terminology, also provides a scheme \nfor project organization. Experience over the past ten years has shown this approach to be useful for \nsystems of all sizes. A series of process steps have proven effective across all of the phases of the \ndevelopment life cycle. 1) Specify the context for the work, for example, class or object schema, operational \nflows. 2) Model the requirements by events, producing event-oriented models, for example, small segments \nof the object schema showing only classes affected by a single event. 3) Integrate the separate models \ntogether.  Use Case Driven Design [Ivar Jacobson] Object-orientation is often presented as radically \nnew technology, but it has been used for decades in Scandinavia. Simula was introduced in Norway in 1967, \nthe same year Ericsson started using object- based technology. Software development is model building \nand object- oriented software development is building object- oriented models. An object model consists \nof a number of nodes representing objects--classes or instances-and arcs representing associations between \nthese. Unfortunately, real systems have many objects. How do you identify them all? How do you describe \ntheir interactions and behavior? Many simple methods fist identify objects and then assign each one to \na person who must design it and determine interfaces with objects assigned to colleagues. This does not \nwork for large, real systems. The solution is to consider systems from one view at a time, showing how \na set of objects will interact in doing something meaningful. Then various views can be gathered to specify \neach object from all the different views. Many ways of thinking of views can be taken, but one of the \nmost important is in terms of users and the different ways in which users will act on the system, that \nis, in terms of use cases. This has the advantage that the complete set of use cases satisfies all the \nneeds of the user. The use case approach starts with a use case model presenting an external view of \nthe system. It begins by identifying classes of users and the roles they play in relation to the system. \nEach different role is terrwd an actor. A use case is simply one complete way of using a system that \nmakes sense to an actor. Use cases and actors are considered to be objects in the sense that they can \nbe instantiated, have an internal local state, and have restricted communication. Any one user or actor \nmay be involved in any number of use cases. The use case model incorporates communication relationships \nas well as class relationships, since one use case can inherit properties of another. A use case model \nis an easy way to communicate requirements to users and clients even if they are not familiar with the \ntechniques or notations of object orientation. For each use case an object model is developed that identifies \nall the objects that will participate in the behavior required for the use case. An interaction diagram \ndescribes how the objects interact with each other. Use cases serve many roles. They represent an external \nview of the system. They are a structuring tool for a simplified internal view avoiding complex models \nwith many classes and interrelationships. They represent the glue between different object models, being \nusable in analysis, design, and implementation. Use cases also are useful in identifying and defining \ntest cases, allowing test development to begin early in the life cycle. Because they are defined as meaningful \ncases of usage by end users, they are useful for organizing documentation. Use cases facilitate estimating \nsystem and component size. Use cases also define user-oriented atomic units of functionality for change \nand for versioning.  The Synthesis Method [Meilir Page-Jones] Event partitioning and object partitioning \nseem to conflict, since they come at partitioning from different philosophies. The Synthesis Method, \nan attempt to blend the two ways, was developed independently but closely resembles the work of Jacobson. \nA problem arises in how to represent the complete modular structure of a system being designed. In structured \ndesign this is accomplished with a structure chart showing all the modules and interactions among them. \nIf the equivalent object- oriented model is drawn, the result is a complex, incomprehensible mess. Some \nobject-oriented methods, therefore, abandon the notion of a complete design model entirely. To be useful \nat all, a structural model of a real object-oriented system must be partitioned or subsetted in some \nway. The Synthesis Method solves this problem by incorporating the ideas of McMenamin and Palmer into \nan object-oriented approach, using events as the basis for defining meaningful sub-models. An event is \ndefined in this approach by five criteria, all of which must be met. To be a bona fide event, a candidate \nmust: 1) occur at some point in time 2) come from the environment, that is, outside the system 3) not \nbe under the system s control, but under the environment s 4) be relevant to the system 5) be recognizable \nby the system. An event thread consists of the complete sequence of actions in response to an event. \nIn practice, event threads form branching tree structures. More remote portions of such an event thread \nare not very interesting from the point of view of the application. Interest tends to center around an \nevent manager component that coordinates essential behavior. An event neighborhood can be defined by \na radius around this event manager, further simplifying the view. Since, for any given event thread (or \nuse case), most methods are bystanders, only those methods actually participating in the event need be \nshown. Events are abstractions that may be considered to be lexical, syntactic, or semantic. For example, \nthe user pressing the left mouse button is a lexical event, something elementary that simply happens \nand is basically uninterpretable by the system other than to note its occurrence. The press of the mouse \nbutton with the cursor over the quit button is syntactic, depending on immediate context, in this case \nallowing the system to recognize that the user wants to quit. Semantic events depend on the entire context \nin which the event occurs, so that the system knows what it is the user is quitting. Overall, the Synthesis \nMethod starts with a charter for the system or project defining what the system is to do and not do. \nA context model is developed, along with an event model. A role relationship or role association model \nis created, which is related to but somewhat different from an entity relationship model. The method \nthen moves to approaches based on abstract data types and event neighborhoods. The resulting life cycle \nis a little more complex than either a waterfall or spiral development model and might better be thought \nof as a jacuzzi life cycle model. The reusable class library is the most important thing of all, as it \nmakes the difference between an object-oriented project and a standard one. It has a profound but subtle \neffect on all parts of the project; ignoring it can be a big mistake. Question: Would a use-case approach \nemployed among teams lower reusability, with objects being reinvented by different teams? [Palmer]: At \nthe time events are identified, we really don t know enough about what classes are needed, so we risk \nthrowing away reusable classes. It takes awhile before we can settle on what classes are worth reusing. \nThis takes some productive stumbling. Event partitioning works best when used as an exploratory technique \nwith an integration process built in. As soon as a ream member finds a class that can be re-used across \nmultiple teams, he posts it to a bulletin board. [Jacobson]: There are several ways to deal with this. \nWe can identify, use-case by use-case, the objects participating in each use-case. Then an architecture \ngroup matches and integrates them into one consistent set of objects. In the design phase, interaction \ndiagrams are developed use-case by use- case, and an architecture group again reviews them to identify \nsimilar messages. A good CASE tool helps identify which are similar and which disjoint. A layered system \ndesign is recommended, with a foundation, then generic application objects, and on top of that the real \napplication. [Page-Jones]: Of methods familiar to me, the use-case or the event neighborhood idea works \nthe best for medium to large size systems, which is not to say that it works perfectly. Realizing that \nreusability is a potential problem, one can use manual inspection or have a tool to do the integration, \nas Ivar mentioned Fortunately, as the library becomes more stable over the years, because classes are \ngiven rather than constructed as the result of individual projects, the problem will diminish, although \nit never goes away. In the beginning, you need to put a lot into it because of the phenomenon known as \nConway s Law, which really hits hard on object oriented systems, that is, the structure of the system \nreflects the structure of the organization that put it together. Question: How does one integrate the \ndesign of systems using runtime polymorphism, as in Smalltalk, in which one can t trace the thread of \ncontrol in advance, with event techniques in which it appears that use-cases are documented statically? \n[Page-Jones]: By the very nature of object orientation one doesn t care very much and may not even know \nwhat goes on in the farther details of an event thread. There are times where you may want to examine \nit for efficiency s sake. For example, if you are going nineteen levels down and nineteen levels back \nup repeatedly, it s not going to be as fast, and you may want to make the effort to diagram each of these \nthreads. [Jacobson]: One way is through design documentation, although this doesn t reflect the details \nof implementation. A second approach is to develop the system in a layered fashion, not showing the interaction \nwith the lower layer. [Palmer]: Polymorphism is an extremely difficult issue across all object oriented \nmethods, not just event-oriented ones. Two cases of polymorphism are moderately reasonable to deal with. \nIn one, all the objects are within a particular sub-tree, all having the same supertype, or are derived \nclasses from a common supertype. Then the supertype can be used as either the data store or object receiving \nthe message as a place holder for those polymorphic extensions down the line. The second case is the \nobject receiving a particular message across all sorts of subtrees. Here we look for an object that serves \nto collect the grab bag of all those individual instances together and use it as a way of directing messages \nso they don t show, thus not forcing a static binding situation when polymorphism is wanted. Question: \nIfevent partitioning is used to arrive at objects during the analysis phase, what do you do if in the \ndesign phase you discover the system must be distributed across processors? Might methods other than \nevent partitioning be better suited to modeling distributed systems? [Page-Jones]: The best solution \nI ve seen to this very difficult problem is the Object Request Broker from the Object Management Group. \nOne of the problems is deciding which of the many ways to partition the system. Here are three levels-objects, \nmethods, and lines of code-and also classes and objects. One way to divide the system is to put all the \nclasses on one machine and all the objects on another-a database machine type of approach. Or all the \nSeattle customers could be put on the Seattle machine and the Atlanta customers on the Atlanta machine-half \nthe population of objects in one place and half in another. The other situation is to halve classes, \nwith half the methods of a class residing on one machine, the other half on the other. In Synthesis we \nmade a mistake initially and assumed we could use the Ward-Mellor approach very easily, doing the essential \narchitecture first and later in the project making a cut into the processor architecture. It turned out \nto be a very awkward way to do things. Now, if it looks like there are multiple processors on the horizon, \nwe begin early thinking about those multiple processors and how those different cuts might be made. [Palmer]: \nThe allocation of conceptual requirements at design time takes us back to the three step process shown \nearlier: establish context, partition by events, integrate across events. When we get to the design stage, \nevent-by-event we can make our determination of what goes where and then, after a certain point, integrate \nthe work that we ve done. Question: What is the difference between Jacobson s use-case and Palmer s event-partitioning \napproaches? [Palmer]: Event partitioning is the idea of chopping up the work by events across the entire \nlife cycle. From what I ve seen use-case comes close to that. [Constantine]: It appears from the panelists \npublished works and drafts that the abstractions of events used in Synthesis and in Palmer s work are \nvery close, but use-case adds a slightly different semantic twist with some special value in and of itself, \nemphasizing the notion of a well-defined sequence or scenario of interaction with the user or with the \noutside. There is a very large overlap among the approaches and their key concepts, but they are not \nidentically equivalent. Question: These approaches panel appear to be looking at macro events as collections \nof micro events instead of reconceptualizing and simplifying them. Could one end up focused on what amounts \nto a bits-and-bytes level with objects, where the system ends up not at all as described? [Page-Jones]: \nAlthough both macro and micro level events-the semantic events and the lexical events- are important, \nin the life cycle of the project semantic event need to be addressed first. For example, it is most important \ninitially to define the fact of an event user wants to shut down reactor without regard for how it s \ngoing to be shut down; that can be decided later. Ideally, the system would intuit what the user wants, \nbut the reality of systems today is that the user has to translate that mental concept into hand movements. \nThe system has a mirror image of that translation, which must translate hand movements to infer the mental \nconcept that caused those movements. The system has to deal with that issue, but it is secondary even \nif clearly important. Question: How does use-casefit into modeling of real-time systems with many inputs \ncoming in at random or whh Poisson distribution? How does use-case handle the situation of stimuli coming \nin that have effects on each other in perhaps infinite combinations? [Jacobson]: Use-case had been successfully \napplied to large real-time systems. [Page-Jones]: It has largely been in the real-time area of telecommunications \nswitching systems, where the issues of queuing, Poisson distribution, normal distribution, and so forth, \nare very germane, that Jacobson s approach has been employed. In the Synthesis Method, at the beginning \nof the process a fundamental and radical assumption is made that the implementation is perfect, that \nis, the processes execute infinitely fast. In other words, event threads execute in zero time, therefore \nthere is no possibility for an object to be hung up with processing when another event comes in. However, \neventually we must build the system on a real machine, where an object may have hung up processing while \nanother event of greater importance comes along. So you need the facility for locking objects, the ability \nto roll back and roll forward to quiescent states that are self-consistent. In some cases one calls in \na statistical and queuing theory expert to do the analysis to see how bad things are. However, the mechanisms \nare fairly well understood, what has to be locked, for what reasons, to what level and so forth. [Palmer]: \nEvent partitioning is also a part of the Ward-Mellor real-time work, and Hatley and Pirbhai have done \nsome thinking in the area of event partitioning.  Contact information: Larry L. Constantine Lucy A. \nD. Lockwood Constantine &#38; Lockwood, Consultants Cambridge, Massachusetts   \n\t\t\t", "proc_id": "157709", "abstract": "", "authors": [{"name": "Larry L. Constantine", "author_profile_id": "81100375146", "affiliation": "", "person_id": "P168432", "email_address": "", "orcid_id": ""}, {"name": "Lucy A. D. Lockwood", "author_profile_id": "81100106839", "affiliation": "", "person_id": "P174135", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157720", "year": "1992", "article_id": "157720", "conference": "OOPSLA", "title": "From events to objects: the heresy of event-orientation in a world of objects", "url": "http://dl.acm.org/citation.cfm?id=157720"}