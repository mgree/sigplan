{"article_publication_date": "12-01-1992", "fulltext": "\n Addendum A 92 to the Vancouver, British Columbia, Canada 5-IO October 1992 Proceedings Demonstrations- \n Sniff: A Pragmatic Approach to a C++ Programming Environment Walter R. Bischofberger UBS Informatica \nLaboratory Sniff is a pragmatic C++ programming environment which has been implemented during the last \nfifteen months. Sniff is implemented in C++ with the ET++ application framework. It runs on a large number \nof UNIX workstations under several window management systems such as OSF-Motif, OpenWindows, and Sunview. \nSniff is an open environment providing browsing, cross-referencing, design visualization, documentation, \nand editing support. It delegates compilation and debugging to any C++ compiler and debugger of choice. \nSniff has been in internal use at UBS (Union Bank of Switzerland) since August 1991. Since then several \n Composition Based Object-Oriented Methodology and Supporting Tools Jan Bosch University of Twente, Netherlands \nAt the University of Twente, the Netherlands, we have been developing methods and techniques in the area \nof object oriented analysis and design. Our major contribution is the so-called Composition Based Object \nOriented Software Development (COOSD) methodology, which includes methods, computational models, and \nsupporting tools. We have applied this methodology in about 20 pilot developers have applied Sniff in \ndeveloping non- trivial software systems as well as in evolving Sniff. Public domain distribution off \nSniff will commenced in May 1992. The main goal in developing Sniff was to create an efficient portable \nC++ programming environment which makes it possible to edit and browse large software systems textually \nand graphically with a high degree of comfort, without wasting huge amounts of RAM or slowing down in \nan annoying way. A further goal was to achieve applicable results within one person year.  Software \nDevelopment (COOSD) studies and we have been organizing tutorials in Europe. The supporting tools, organized \nin an Integrated CASE tool environment, support the developer both in the analysis and in the design \nprocess, whereafter automatic translation of the design, described in a high-level object oriented language, \ncalled SINA, to C++ is offered.  Object-Oriented Communication Server for Banking Applications Ion Cartiant \nSYSOFT SA, France In France, there is a generalized file transfer method used for customer-bank information \nexchange, on X25 networks and on telephone switched lines (BSC 2780/3780 like protocol). It is used by \n(almost) all France-based banks, and thousands of customers. RONDO is an 00 file server, supporting these \nprotocols. It was developed in BORLAND C++, with TURBO VISION graphics library. Without the included \nfiles, the overall code lines, as reported by the project manager, are 22,000. The server works fine \non a 386 based PC, DOS 5.0. RONDO s capabilities are: support up to four file transfers on public switched \ncommunication lines, and four file transfers on X25 virtual circuits, simultaneously, . on-line verification \nof incoming files for format correctness, and . on-line surveillance and administration. The demonstration \ns purposes are: present a real-time application of the 00 technology, including interrupt control and \nencapsulation of an OEM X25 driver (not 00); present a brand new user comfort for DOS communication \napplications; real time information about incoming transfers; optional operator zoom on different monitors: \n status, statistics, log, traffic, trace, file verification; configuration control; client diagnosis \nand support; present the internal objects grouped in 4 domains: communication, administration, user interface, \nand system extension.  Through graphic objects, this technology brings a spectacular new comfort to \nDOS users with less overhead than in graphical environments. For developers it provides reusable objects \nand simple building logic. Multiple-View CASE Support for Object-Oriented Design Shang-cheng Chyou StructSoft, \nInc. Object-Oriented Programming (OOP) has been recognized to have great potential in producing high \nquality, large reusable software. However, we often find it difficult to write good C++ or Smalltalk \nprograms. Without good program designs we will not reap the benefits of OOP. On the other hand, Object-Oriented \nDesign (OOD) is considerably more complex than that of the traditional design disciplines such as Structured \nDesign. Therefore, without the help of powerful CASE tools, we may not achieve the benefits of OOD and \nOOP. This demonstration will present TurboCASE, a multi-methodology supporting CASE tool that supports \nboth Object-Oriented Analysis (OOA) and OOD. TurboCASE provides multiple views to help software designers \ncreate good OOD models. TurboCASE allows you to create and maintain Class Hierarchy, Class Collaboration, \nClass Definition, and Class Design Diagrams. The Class Hierarchy Diagram not only shows the class hierarchy, \nbut also OOPSLAW -230- helps resolve how polymorphism works. The class Collaboration Diagram gives three \nlevels of abstraction showing how objects communicate with each other. The Class Definition Diagram shows \nthe methods and instance variables of the class, as well as providing the ability to browse the capabilities \nof the class inherited from the class hierarchy. The Class Design Diagram allows you to design a class \nsimilar to that of the Structured Chart with full support of the method signature specification. These \ndiagrams are integrated through a project database, thereby providing multiple views of the software \ndesign. TurboCASE also provides intelligent help to refine the design such as abstracting the common \nbehaviors of classes into an abstracted class. Subsystems can be designed top-down as well as bottom-up \nby abstracting from system components. These capabilities greatly reduce the complexities of the designs \nand help achieve optimal solutions. Vancouver, British Columbia  Applying Text and Graphic Tools in \nParallel: Exploring Multimedia Approaches for Accelerating Object Think Which is better-text or graphics-for \nexploiting and communicating object-oriented results? Both! To illustrate the desirability, effectiveness, \nand impact of using both mediums, this demonstration works through a small OOA/OOD model with text and \ngraphics-on two large screens, side-by-side, in parallel. The demonstration includes practical insights \non how to use both text and graphics for better developing and communicating object-oriented results. \nIt also includes a look at the theories which point to a dramatic need for a more multi-faceted approach. \nSpecial emphasis is placed on the theory of seven intelligences-linguistic, mathematical/logical, spatial, \nmusical, body- kinesthetic, interpersonal, and intrapersonal. Two tools for visualizing objects-text \n(Smalltalk) and graphics (from the ObjecThink Series)--are applied side-by-side, in parallel. Participants \nexperience first-hand the need-and the impact+f applying multimedia approaches to stimulate more effective \nobject think.  Audition: A Tool for Visual Interactive Modeling Andrew Drinnan and David Morton National \nResearch Council of Canada This demonstration presents Audition, an object- oriented language and environment \ndesigned to allow the easy creation of visual and interactive programs. It uses a metaphor of Performers \nand Stages, as first inspired by the XEROX Pam Rehearsal World project. Performers are the main interaction \nunits. They are visible and mouse or message activated; sample types include DisplayPerformers, Turtles, \nGraphs, and Gauges. Performers are grouped on Stages; stages maintain local name spaces so that Performers \ncan be named and intercommunicate using their local names. While Performers are members of a class, they \nmay also be specialised through the addition of instance-specific behaviour Graphical Animation of Object-Oriented \nMarko Heikkinen and Petri Pulli Technical Research Centm of Finland We have built an extension to a prototype \nCASE tool called ESPEX, that makes it possible to execute graphically Wasserman s Object-Oriented Structured \nDesign (OOSD) notation. The tool itself is implemented in the Smalltalk 80 programming environment. The \ntool contains a window-based menu-driven graph editor and an integrated graph simulator with animation \nsupport. Animation means and structure; this may also be inherited from other performers. Just as inheritance \nmodels is-kind-of relationships, performers collected on a stage visibly and logically model is-part-of \nrelationships, in a more flexible way than instance variables. An application is usually just a specialised \nstage and its specialised performers. The performer-stage paradigm gives rise to models that are at once \nwell factored across their participating performers and yet are fully encapsulated within a stage. Audition \nis a threaded interpreted language implemented in itself. At present we are using Audition to investigate \nplanning aids and simulations for industrial situations.  Software Designs that the movements of data \nitems and messages between objects are visualized on a workstation display. We have implemented simulation \nfor object instances. We are using moving tokens with data values attached on top of them. Tokens flow \nfrom objects to other objects, carrying the essential data with them. The moving tokens indicate clearly \nthe active parts of the model, while the data values also make it possible to visualize the actual computations \nthat take place in the objects. Another advantage of moving tokens is that it is possible to attach time \nstamps to tokens. With the help of the time stamps it is possible to simulate experimenting with animation \ntechniques for dynamic creation and deletion of objects. We model objects hierarchically, so that an \nobject can be composed of other lower level objects. At the lowest level objects are described with predicate/transition \nPetri nets, and the computations with IPTBS Meta-IV, Smalltalk-80, or C. The work presented demonstrates \nthat it is possible and feasible to animate object-oriented design notation using a token moving approach. \nHowever, there is still much work to be done on the animation of dynamic instantiations and deletion \nof objects. We believe that graphical animation tools are the enabling technology for teamwork and for \nconceptual communication in the future concurrent engineering working environments. The work presented \nin this demo was carried out in the IPTES project. IPTBS is partially funded by the European Communities \nunder the ESPRIT programme. Object-Oriented Engineering of Distributed Applications Dr. Max Muhlhauser, \nUniversity of Kaiserslautem Lutz Heuser, Digital Equipment GmbH, W. Germany The Universities of Kaiserlautern \nand Karlsruhe are cooperating with the CEC Karlsruhe, a research center of Digital Equipment CmbH, in \nthe area of software engineering for distributed applications. This demonstration will showcase DOCASE, \na software engineering environment for distributed applications, using object-oriented technology. The \ndemonstration will provide insight into the methods, languages, tools and environments used in the life-cycle \nof distributed applications. With the term distributed applications , we put an emphasis on structured \nparallelism (which comes more or less naturally with the logical structure and inherent parallelism and \ndistribution of an application), not so much on the fine-grained parallelism exploited by applications \nsuch as image processing etc. With more and more complex (dynamic, multiparty, cooperative) distributed \napplications to be developed in computer integrated manufacturing, office automation, CSCW, and other \ndomains, we think that this topic is both very much up to date and a topic which is not sufficiently \ntaught. The live demonstration will show a distributed application which will allow researchers of arbitrary \ndisciplines to coordinate their work with other members of a research team. The underlying meta model \nis generic and instantiated by developing a set of concrete object types together with a GUI. HotDraw: \nA Structured Drawing Editor Framework for Smalltalk Ralph Johnson University of Illinois HotDraw is a \nframework for structured drawing editors that has been floating around the Smalltalk community for several \nyears under several incarnations. It was originally developed by Kent Beck and Ward Cunningham, but has \nbeen reimplemented many times since then. Most of these implementations were proprietary. Our design \nextends the original one by making constraints more composable and by adding metafigures, but the system \nis instantly recognizable by anyone familiar with one of the earlier implementations. We wrote a version \nof HotDraw for ObjectWorks\\Smalltalk Release 4.0 that we are OOPSLA 92 distributing. We will describe \nand demonstrate the basic framework and several applications built from it, such as a visual programming \nlanguage, a tool for inspecting Smalltalk objects by drawing pictures of them, an environment for learning \nSmalltalk by issuing commands and writing scripts for visible objects, and a PERT chart editor. These \napplications illustrate several advanced Smalltalk techniques, such as light-weight classes, compiling \ncode on the fly, and dynamically redirecting messages by overriding doesNotUnderstand:. Time permitting, \nwe ll explore the implementation of HotDraw and how it uses these techniques. -232-Vancouver, British \nColumbia  Demeter Tools/C++ Karl Lieberherr, Ian Holland, Walter Hursch, Ignacio Silva-Lepe, and Cun \nXiao We are demonstrating the Demeter Tools/C++, a CASE research prototype developed at Northeastern \nUniversity, including the latest tools described in papers presented at ECOOP 91, ER 90, CSM 89 and OOPSLA \n89 and in the Software Engineering Journal (1991). The Demeter system has been under development since \n1985 and has been regularly used and refined with support from companies such as IBM, Mettler- Toledo \nand SAIC. Demeter Tools/C++ consists of the following tools: 1. Design level (programming language independent): \n cddraw: to draw a class dictionary learn: Learns class dictionary for object examples 9 optimize: Optimizes \nclass dictionary sem-check: Checks class dictionary for violations and proposes changes to the class \ndictionary . parse-generate, run-parser: Checks conformance between class dictionary and objects cd-compare: \nCompares two class dictionaries cd-abstract: Finds the largest class dictionary common to both input \nclass dictionaries xrefi Draws a graphical representation of a class dictionary 2. Generation level (C++ \nspecific): generate: Generates C++ class library from input class dictionary propagate: Generates C++ \nmember functions from propagation pattern headers: Generate C++ function interfaces from implementation \n3. Implementation level (C++ specific): Class library of predefined member functions for object manipulation \n(e.g., reading, writing, drawing, accessing, etc.)  Open Zeitgeist: A Modular Object-Oriented DBMS Moira \nMallison and Edward R. Perez Texas Instruments Inc. The Open OODB project at Texas Instruments has defined \nan extensible object-oriented database management system, composed of functional models with well-documented \ninterfaces. The Open OODB architectural framework consists of two components. The meta-architecture provides \nthe framework used by Open OODB to achieve extensibility. It provides kernel facilities to support a \ncomputational model based on event extension, which allows system builders and application developers \nto seamlessly extend the behavior of normal operations in object-oriented programming languages, The \nsystem architecture is an instantiation of meta-architecture mechanisms plus a collection of policy managers \nthat provide the required OODB functionality. Open Zeitgeist is one such system architecture. The demonstration, \na follow-up to the 1991 demonstration, provides an overview of the Open Zeitgeist architecture, with \na focus on the meta- architecture facilities. We will demonstrate the steps for adding an extension to \nan application, including specifying the events to be extended, trapping of events, and performing the \nactual extension of the event by the policy manager. S-10 October 1992 -233- G++: An Object-Oriented \nDesign and Prototyping Environment for Manufacturing Systems - Giuseppe Menga Politecnico Di Torino, \nItaly This demonstration is based on the results of a large research project carried out at Politecnico \ndi Torino, one of the major engineering schools in Italy, on 00 programming in manufacturing applications, \nand addresses the following topics: real time, concurrency, distribution, and fast prototyping. The demonstration \nwill feature: Reference models in Computer Integrated Manufacturing, Reusability in 00 programming allied \nto Manufacturing, Objects, concurrency, real time and distribution, Libraries of basic classes for OOP \n(data  structures, control objects and graphic objects), . Active objects: the client/server and producer/consumer \nmodels, A methodology for the design of hierarchical control systems, Introduction to ESA-HOOD (Hierarchical \n00 Design), Introduction to CCITT-SDL (Specification Description Language), Specification and fast \nprototyping of active objects through SDL, The case study of a Flexible Manufacturing System with simulation \nin a concentrated environment and emulation on a distributed environment.  The demonstration will present \nthe graphical editors and the FMS control system. SDaCetalk: Obiect-Oriented Environment and Tools for \nBuilding Open dbject-Based GIS Environments Augustin Mrazik and Janka Kleinertova ArtinAppleS Ltd. CSFR \nSpacetalk was presented in a live demonstration at OOPSLA 90 as a model of a knowledge representation \nenvironment for dynamic modelling of spatial systems. It was implemented in SmalltalkN-286. It has now \nbeen ported to Objectworks\\Smalltalk and its principles and ideas are built on several projects all fully \nimplemented in Objectworks\\Smalltallr; ArtBase, an object oriented database, CanDLE, a dynamic link stntcture \nenvironment and, Planar Geometry, the implementation of a closed set of geometric relations. This is \npowerful ground for the modelled world where intelligent spatial objects can act and reflect the reality. \nCharacteristics of the Spacetalk system include: no more passive data-all data, behavior, knowledge and \nspatial properties are represented by dynamic and evolutive objects with attributes, methods, constraints, \nrules, bodies and parts; analytical description of spatial properties, all geometric relations and operations \nin 2D including (comparing relations, intersection, union, complement); interfaces to raster-based data \n(up to 24 bit), conversion from/to spatial objects, various image operations including logical, arithmetic \noperations, classification and overlay; uniform object-oriented approach to the representation of the \nreal world heterogenity; . ready-made graphical user interfaces as well as tools for rapid prototyping \nof new applications. Dynamics/V Alfred Peisl SI-Datenverarbeitungsservice GmbH, Germany There are classes \nof problems where the OOP languages of today lack the concepts to map directly the real world objects \ninvolved on equivalent software objects: real world objects show a very dynamic behavior. They can play \nmultiple roles, add or drop roles dynamically and adapt these roles to specific situations. On the other \nhand there may exist different views (cooperators have) of the same object at the same time and these \nviews may change dynamically too. If we enhance an OOP language with the concepts of dynamic behavior, \nthe transition from OOA/OOD to an implementation becomes a very smooth one. Dynamics/V transparently \nembeds dynamic objects into Smalltalk. It is divided into two separate building blocks: (1) the basic \ntechnology of dynamic objects (platform independent) and (2) a set of tools for visualizing, constructing \nand maintaining dynamic objects. The key features of the basic technology are: objects that play multiple \nroles; the role concept (a role embeds an object within a transparent shell of security and flexibility); \n. multiple dynamic classification with new and powerful conflict resolution techniques; dynamic role \npriorities; multi alias technique; multiple dynamic views and the means to control this enormous expressiveness; \n . the ability to define a limited set of roles a dynamic object can play; . the ability to define multiple \nsets of mutual exclusive roles; the ability to guarantee a constant behavior over a period of time (freezing); \n . the ability to trace the complete behavior of a dynamic object. Dynamics/V is a very new and intuitive \napproach to modelling real world dynamic objects. It is based on a well known and proven OOP language, \nit is still perfect Smalltalk! Playing around with this technology over the last months has shown us \na universe of possibilities to attack problems that have been thus far difficult to resolve.  The Integrated \nModel Development Environment: An Object-Oriented Approach to Modeling Pat Clark, Jeff Honious and Kerris \nJ. Renken TASC The Integrated Model Development Environment (IMDE) is a software system designed to make \nsimulation studies easier. It provides graphical description and construction of models, maintains configuration \ncontrol of models, input and output files, and their constituent parts, analyzes simulation results using \npowerful statistical techniques, and allows documentation to be integrated with the models. IMDE runs \non Sun workstations as a multi-user system, and is implemented under the OpenWindows user interface, \nusing the MODSIM II object-oriented discrete-event simulation language, the Versant Object-Oriented Database \nManagement Systems (OODBMS), and C++. TASC is developing IMDE under the sponsorship of the Human Resources \nDivision of the Armstrong Laboratories at Wright-Patterson APB, Ohio. The overall IMDE architecture is \nbased on the division of the simulation process into three stages, the Preprocessor, the Simulator, and \nthe Postprocessor. The Preprocessor constructs, configures, and documents simulation models or model \nparts. The Simulator manages execution of the model and collects desired raw statistical data. The Postprocessor \nanalyzes raw data generated from the Simulator and produces requested reports. These major components \ninteract with each other through data stored in either the Premodel or Project database. All these components \nare integrated by an OpenWindows user interface.  Object-Oriented Program Development Using CLOS and \nCLIM Chris Richardson Franz, Inc. In this demonstration we will show program development using CLOS, \nthe Common Lisp Object System. We will also demonstrate CLOS-based programming tools, such as CLIM, the \nCommon Lisp Interface Manager, and Composer, an object- oriented development environment. CLOS is a subset \nof Common Lisp. Lisp has come a long way since it was first designed and implemented in the late 1950s. \nA proliferation of Lisp dialects through the years eventually led to the formation of the Common Lisp \nlanguage, which is now in the final stages of becoming an ANSI standard. Common Lisp is widely implemented \nand available on PCs, workstations and mainframes. Some of the significant features of Common Lisp include \ngarbage collection, incremental compilation, interactive working and language extension through a macro \nfacility. In addition the Common Lisp Object System (CLOS) offers a number of interesting features that \ndifferentiate it from other popular object-oriented languages including multiple inheritance, method \ninvocation based on generic function rather than The Visual Compiler-Compiler SIC Lothar Schmitz Universitit \nDer Bundeswehr Miinchen, Germany The Smalltalk-based Interactive Compiler-Compiler (SIC) is an educational \ntool for visualizing modem compiling techniques. While conventional compilers are black boxes whose internals \nare hidden from the user, SIC helps to open the box and have a look at what is going on inside. SIC automatically \ngenerates demonstration compilers from suitable language descriptions. The generated compilers continuously \ndisplay their internal states and are controlled with the mouse to move back and forth in single or larger \nsteps, etc. Auxiliary information derived from the language description can be viewed interactively at \nany time. Technically speaking, the major components of SIC are a parser generator and an attribute evaluator \ngenerator. When creating a parser, the user may choose between the LL(l), LR(O), LR(l), SLR(l), and LALR(1) \nparsing strategies, which are typical of modem compilers. SIC-parsers can be operated non- OOPSLA 92 \n-2?6- message passing, method combination, the ability to (re)define classes and methods dynamically \nand a metaobject protocol that allows extension of the implementation. Composer is a CLOS development \nenvironment from Franz Inc. Modeled after the facilities offered by dedicated Lisp machines, Composer \nprovides an integrated set of windowized tools including an inspector for examining data structures, \nbrowsers for examining definitions of classes and generic functions, a cross reference tool for examining \nprogram calling structure and a profiler for optimizing performance and memory allocation of a program. \nIn addition we will demonstrate CLIM, the Common Lisp Interface Manager, which is the emerging standard \nfor GUI development in Common Lisp. CLIM is an example of a system written using CLOS. CLIM provides \nportability across multiple window systems and toolkits. We intend to demonstrate the X Window system \nof CLIM which interfaces to the Motif and Open Look GUI toolkits. deterministically, e.g., an SLR( 1) \nparser for a non- SLR( 1) grammar. Ambiguities are then resolved either by backtracking or by taking \nadvice from the user. The input to SIC-parsers may contain both technical symbols and syntactic variables. \nIn contrast, the input of conventional parsers may contain terminal symbols only. Attribute evaluation \ncan either be controlled by hand, by selecting one of a set of predefined strategies, or by preparing \nan individual evaluation sequence using a special editor. In the presentation we shall demonstrate the \nfeatures of SIC using two small examples: One is a partial evaluator for arithmetic expressions. Here, \nSIC is used to generate three standard compiler components (a lexical analyser, a parser, and an attribute \nevaluator) from a given attribute grammar. The second example, where line graphics are computed from \ntextual descriptions, indicates that Vancouver, British Columbia attribute grammar technology is useful \nnot only for Also, we will briefly address implementation issues compiler construction. and describe \nuser reactions and experiences. Bruce Schwartz and Mark Lentczner Glyphic Technology Glyphic Technology \nhas created a small, yet powerful programming environment and language combining the techniques of Direct \nProgramming and Unified Object Models. The work is a result of research into providing programming systems \nthat are flexible enough to be used in both novice and expert situations. Direct Programming environments \nare highly interactive, in which the structures of program objects are built graphically, and their behavior \nis programmed incrementally. They offer the user the programming equivalent of a WYSIWYG text processor. \nSuch environments have become popular in recent years: HyperCard and Visual Basic are two examples. While \nexcellent for simple applications, these existing environments were not built on formal object models \nand so are difficult or impossible to use for moderate to complex tasks. We  Introduction to OOP: have \nfound that a Unified Object Model is a good match to the user needs and expectations of Direct Programming \nsystems. A Unified Object Model unites the concepts of classes and objects: any object can be used as \na prototype (class) and any object can have new behavior attached to it. This model provides power with \nminimal constructs and makes all program entities concrete and accessible for the user. For example, \neven the prototypes can have graphical views. We will show and discuss our work, including: The running \nenvironment with examples Our object model and language How a Unified Object Model enhances Direct Programming \nA Comparison with other models (specifically Smalltalk and Self)  Teaching Object-Oriented Programming \nConcepts and Skills Using Multi-Media, Computer-Assisted Instruction Steve Strong Apple Computer, Inc. \n The goals of the demonstration are threefold: 1) to familiarize attendees with the nature and capability \nof Intro to OOP, 2) to document the design criteria as well as the implementation decisions and methodologies \nused in its development and 3) to highlight the effectiveness and limitations of Intro to OOP for the \npurpose of training students to do commercial quality object-oriented programming. In the rest of this \nabstract we will discuss how each of these goals will be achieved. In order to familiarize attendees \nwith the nature and capabilities of Intro to OOP, samples from several animated lessons will be presented \nas well as a brief demonstration of the navigational features of the system. Attendees will see how concepts \nsuch as subclassing and overriding of inherited behavior, using abstract classes and polymorphism to \nbuild highly maintainable and reusable code and using 5-10 October 1992 application frameworks are taught \nusing a multi- media approach. Test questions and lab instructions will also be shown and attendees will \nlearn how these facets of the system are integrated with the computer-delivered animations to produce \na learning environment that is responsive to the needs and learning styles of each student. Slides will \nbe used to present the design and implementation decisions that resulted in Intro to OOP being created \nin the format that exists today. Design criteria such as platform, language and applications framework \nindependence will be highlighted as well as factors that limited the development team s ability to meet \nthese criteria. Finally, the demonstration will conclude with information on the effectiveness of the \nsystem which was obtained from students who completed the course. Considerable discussion will follow \non the for the training of object-oriented programmers as strengths and weaknesses of this form of delivery \nwell as areas for future investigation. TermWorks: A Flexible Framework for Implementing (Nearly) Arbitrary \n Kinds of Terms Andreas Tonne MPI Informatik, Germany In this demonstration we will show the utilization \nof the TermWorks framework for implementing terms and applications using these terms. TermWorks has been \ndeveloped over the last two years at the University of Dortmund and the Max- Planck-Institute for Computer \nScience as a platform for implementation of applications of formal systems. For example: logic programming, \ntheorem proving, algebraic specification languages, computer algebra, and type theory. The demonstration \nhighlights two aspects of TermWorks that are useful for both educational and industrial purposes. First, \nwe will advocate our style of designing complicated class hierarchies as a synergy of several self-contained \nconcept-hierarchies. We show how a consistent application of object oriented Lapidary: An Interactive \nDesign Tool Brad Vander Zanden University of Tennessee Lapidary is an interactive design tool that allows \ndesigners to specify all graphical aspects of an application, including both the objects that control \nan application, such as menus, scroll bars, and buttons, as well as the application-specific graphics \nthemselves, such as boxes and arrows, game boards and pieces, and pictorial images of data structures. \nThe designer can also specify the behaviors that these graphics exhibit, either by demonstrating them \ndirectly, or entering parameters into behavior- defining dialog boxes. Lapidary is unique among graphical \ninterface builders in that it allows the designer to specify the contents of the application window, \nnot just the control objects that surround it. Lapidary is being developed as part of the Garnet user \ninterface development environment and is intended to provide a visual programming environment for Garnet. \nGarnet provides a number of tools that help programmers develop graphical interfaces, including an object-oriented \nprogramming environment, a graphical object system, a constraint system, and a OOPSLA 92 -238- techniques-abstraction, \ninheritance and delegation-help to organize the complicated interconnections between these hierarchies. \nSecond, we show how a direct implementation of terms results in a very natural way of implementing applications \nthat use them. Alternatively, we could invent and implement an abstract encoding of terms. However, we \nwould loose the tight intentional relationship between terms and applications. The example used during \nthe demonstration is a tiny Prolog interpreter. We show how we derive the needed Prolog terms by extending \na predefined class of first order terms. Then the Prolog machinery is sketched. The state of this machinery \nis represented by a new kind of terms. This allows us to use a structural and graphical term-editor that \nmonitors the Prolog execution elegantly. behavioral model called interactors for handling input. Lapidary \nprovides access to the graphical object system through a direct manipulation drawing editor, supports \nconstraints via various iconic menus that graphically depict the most commonly used alignment constraints, \nand provides dialog boxes that allow users to specify the behavior of objects by entering parameters \nfor various interactors. Although some experimental interface builders use constraints to control the \nstatic layout of objects, Lapidary is novel in that it uses constraints to define the dynamic run-time \nbehavior of application objects. Lapidary is also unique in that it allows the behavior of application \nobjects to be specified Lapidary supports the creation of five types of behaviors: object creation, text \nentry, choice selection, moving or growing, and entering an angle. Lapidary provides dialog boxes that \nrepresent each of these behaviors and that allow the designer to indicate enter parameters that customize \nthe behavior, such as which objects the interactor operates on or what type of feedback the interactor \nprovides. As an alternative to the dialog boxes, the designer may choose to directly demonstrate a particular \nbehavior.   \n\t\t\t", "proc_id": "157709", "abstract": "<p>Sniff is a pragmatic C++ programming environment which has beenimplemented during the last fifteen months. Sniff is implemented inC++ with the ET++ application framework. It runs on a large numberof UNIX workstations under several window management systems suchas OSF-Motif, OpenWindows, and Sunview. Sniff is an openenvironment providing browsing, cross-referencing, designvisualization, documentation, and editing support. It delegatescompilation and debugging to any C++ compiler and debugger ofchoice. Sniff has been in internal use at UBS (Union Bank ofSwitzerland) since August 1991. Since then several developers haveapplied Sniff in developing non- trivial software systems as wellas in evolving Sniff. Public domain distribution off Sniff willcommenced in May 1992.</p><p>The main goal in developing Sniff was to create an efficientportable C++ programming environment which makes it possible toedit and browse large software systems textually and graphicallywith a high degree of comfort, without wasting huge amounts of RAMor slowing down in an annoying way. A further goal was to achieveapplicable results within one person year.</p>", "authors": [{"name": "Walter R. Bischofberger", "author_profile_id": "81100495223", "affiliation": "", "person_id": "PP31070446", "email_address": "", "orcid_id": ""}], "doi_number": "10.1145/157709.157795", "year": "1992", "article_id": "157795", "conference": "OOPSLA", "title": "Sniff (abstract): a pragmatic approach to a C++ programming environment", "url": "http://dl.acm.org/citation.cfm?id=157795"}