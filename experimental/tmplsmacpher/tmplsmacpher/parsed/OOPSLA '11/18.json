{"article_publication_date": "10-22-2011", "fulltext": "\n Ribbons: A Partially Shared Memory Programming Model * Kevin Hoffman Harrison Metzger Patrick Eugster \nDepartment of Computer Science, Purdue University {kjhoffma,hmetzger,peugster}@cs.purdue.edu Abstract \nThe need for programs to execute subcomponents in iso\u00adlation from each other or with lower privileges \nis preva\u00adlent among today s systems. We introduce ribbons: a shared memory programming model that allows \nfor more implicit sharing of memory than processes but is more restrictive than threads. Ribbons structure \nthe heap into protection do\u00admains. Privileges between these protection domains are care\u00adfully controlled \nin order to con.ne computation. We pro\u00adpose RIBBONJ, a backwards-compatible extension of Java, to easily \ncreate or port programs to use the ribbons model. We study the progress and isolation properties of a \nsubset of the language. Building on JikesRVM we implement ribbons by leveraging existing memory protection \nmechanisms in modern hardware and operating systems, avoiding the over\u00adhead of inline security checks \nand read or write barriers. We evaluate ef.ciency via microbenchmarks and the DaCapo suite, observing \nminor overhead. Additionally, we refactor Apache Tomcat to use ribbons for application isolation, dis\u00adcuss \nthe refactoring s design and complexity, and evaluate performance using the SPECweb2009 benchmark. Categories \nand Subject Descriptors D.1.3 [Programming Techniques]: Concurrent Programming; D.3.3 [Program\u00adming Languages]: \nLanguage Constructs and Features Concurrent programming structures; D.4.1 [Operating Sys\u00adtems]: Process \nManagement Threads General Terms Design, Languages, Security Keywords shared memory, virtual memory, \naccess control, heap partitioning, multithreading, ribbons * Financially supported by NSF grants 0834619 \nand 1117065. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n11, October 22 27, 2011, Portland, Oregon, USA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0940-0/11/10. \n. . $10.00 1. Introduction Today s systems need the ability to execute subcomponents with lower privileges \nor in (partial) isolation from each other. Web servers, application servers, and web browsers allow for \nembedded execution of third-party subcomponents such as plugins, which are often targets of exploitation. \nCurrent isolation mechanisms typically apply the follow\u00ading techniques: (1) executing code within a separate \npro\u00adcess and interacting with it via inter-process communica\u00adtion (IPC), (2) relying on a reference monitor \nto mediate all accesses from the isolated code to sensitive resources, and (3) static isolation of classes \nsuch as through multiple Java class loaders. The .rst technique tends to increase complex\u00adity and introduce \nsigni.cant performance overhead when the interaction between the components is non-trivial. For ex\u00adample, \nthe Multitasking Virtual Machine (MVM) [14] uses the doors IPC technique in Solaris to implement native \ncode isolation and observes a 397\u00d7 slowdown on Java Native In\u00adterface (JNI) calls (an increase from 0.136\u00b5s \nto 54\u00b5s). The second technique tends to be application-speci.c, hampering re-use, and can be expensive \nwhen applied to heap objects (e.g., 2\u00d7 to 8\u00d7 slowdown [20]). The third technique ties iso\u00ad lation boundaries \nto lexical scope, precluding dynamic isola\u00adtion boundaries, and depends on application-speci.c mech\u00adanisms \nto protect access to data in globally shared classes. Consider the case of Apache Tomcat, an open-source \nim\u00adplementation of the Java Servlet and Java Server Pages (JSP) technologies. Tomcat allows multiple \nweb applications and related components to run in isolation from other each other within the same Java \nVirtual Machine (JVM). Executing components (servlets, JSPs, tag libraries, etc.) are isolated so that \nthey can not interfere either with the operation of the main Tomcat server nor with other running components. \nTomcat enforces isolation through two mechanisms: (a) a separate class loader for each web application, \nand (b) the Java Security Manager [16], an access monitor enforcing isolation boundaries upon JVM properties, \n.les and directo\u00adries, networking, and re.ection. Using separate class loaders prevents a web application \nfrom accessing Tomcat s inter\u00adnals or other applications state, only allowing applications to interact \nwith the host server code through certain classes loaded by the global class loader. Class loaders achieve \nthis isolation by copying loaded classes and giving them names which are logically distinct across loaders. \nThe normal type\u00adsafety mechanisms in the JVM thus enforce isolation be\u00adtween uses of a class loaded by \ndifferent class loaders. This mechanism, however, is subject to vulnerabilities through bugs in classes \nloaded by Tomcat s global class loader (CVE-2009-07831). The bug allows a web application to escape isolation \nby replacing Tomcat s XML parser at runtime, allowing a malicious application to read sensitive .les \nof other applications (e.g., containing passwords). The complexity of Tomcat s ad-hoc isolation mechanisms \nmakes it hard to verify that any given version is 100% correct and remains so as the code evolves. Another \napproach is to run each isolated component in a separate VM or process. This strategy is used by the \nGoogle Chrome and Firefox 4 web browsers, which execute tabs and plugins in distinct processes. These \ntechniques induce runtime overhead due to increased memory usage (e.g., ex\u00adtra copies of objects) and \nIPC between tabs and the main process (e.g., remote method invocations if using something like Isolates \n[14, 24]). IPC also increases code complexity. Speci.c solutions such as browser isolation mechanisms \n[9] cannot easily be applied to other cases such as application servers, or even related plugin architectures \nsuch as inte\u00adgrated development environments (e.g., Eclipse). We propose ribbons to allow the heaps of \nsubcompo\u00adnents within a process to be fully or partially isolated in well-structured ways, without signi.cant \nruntime overhead. The heap is divided into an arbitrary and dynamic number of protection domains. Access \nprivileges are tracked pair-wise between protection domains, and threads are grouped into ribbons. Ribbons \nsubsume threads, and protect against inad\u00advertent or malicious access to data and mitigate unbounded \nheap corruption in unsafe runtime environments. Enforce\u00adment during execution relies on standard hardware-level \nvir\u00adtual memory and memory protection mechanisms, avoiding per-instruction overheads. This paper makes \nthe following contributions: We de.ne the ribbons programming model.  We introduce RIBBONJ, a Java \nlanguage extension, for writing programs using the ribbons model.  We present RIBBONJ-LITE, a formalism \nfor RIBBONJ s core, to study progress and isolation properties.  We evaluate our implementation in JikesRVM, \nusing mi\u00adcrobenchmarks and the DaCapo benchmarks [5], with re\u00ad sults showing minor runtime overhead (0% \nto 12%).  We discuss experiences applying ribbons to small-scale applications, including lusearch and \njIRCd.  1 http://cve.mitre.org/cgi-bin/cvename.cgi?name= CVE-2009-0783  We present a case study wherein \nwe refactor Apache Tomcat to isolate web applications using ribbons. This ribbonization only required \n680 new lines of code. Results indicate a moderate latency increase without throughput decrease. Some \napplications may require more than just heap isola\u00adtion for safeguarding the execution of sub-components \n(e.g., if sub-components need to execute with different OS-level privileges). For example, web browsers \nmay desire to exe\u00adcute plugins with highly restricted access to the local .lesys\u00adtem. Additionally, using \ndistinct processes for isolation can provide kill-safety [21], if designed correctly. This paper focuses \nsolely on isolation of the heap and does not claim to provide complete isolation of sub-components or \nkill-safety. Full isolation and kill-safety would require ad\u00additional support for ribbons within the \nOS kernel. In this paper, we lay a foundation for such future work by de.ning the ribbons programming \nmodel and language (including a formal model), and by implementing and evaluating the mechanisms necessary \nfor heap isolation. We also demon\u00adstrate the immediate value of ef.cient heap-based isolation mechanisms \nthrough the Apache Tomcat case study. Roadmap. Section 2 details the ribbon model and its con\u00ad cepts \nin RIBBONJ. We formalize a subset of RIBBONJ in Section 3 to study isolation and progress properties. \nSection 4 discusses our implementation of RIBBONJ in JikesRVM, and Section 5 evaluates it. Section 6 \npresents our ribbonization of Tomcat. Section 7 discusses related work. Section 8 presents conclusions. \n2. Protection Domains, Ribbons, and RIBBONJ In this section we .rst overview the ribbon memory pro\u00adgramming \nmodel, and then describe RIBBONJ, a backwards\u00adcompatible extension of Java that provides the features \nof the ribbon model. 2.1 Ribbon Memory Programming Model The ribbons model de.nes three abstractions: \nprotection do\u00admains, domain sharing privileges, and actual ribbons. For illustrative purposes, Figure \n1 visualizes how these concepts could be applied to provide heap isolation for components within a web \nbrowser. Protection domains are the basic unit from which memory sharing constraints are formed. All \nmemory allocations are associated with some protection do\u00admain (implicitly or explicitly), such that \neach area of mem\u00adory allocated (each object in object-oriented languages) is placed within that domain. \nIn the browser example, the global private and shared states represent two domains. Every thread in a \nprogram is associated with one or more protection domains, which determines its set of privileges Figure \n1. How ribbons could provide heap isolation for components within a web browser. Note that ribbons for \ntab #2 and scripts #2 and #3 are not shown. DOM represents the web page contents.  as follows: Domain \nsharing privileges specify the access that threads executing within the context of one protection domain \n(termed the source domain) have on memory con\u00adtained within some other protection domain (target domain). \nA privilege is composed of a source domain identi.er SD,a target domain identi.er TD, and any number \nof the follow\u00ading permissions: read: Domain SD can read memory in domain TD. write: Domain SD can write \nmemory in domain TD. inject: Domain SD can allocate memory in domain TD. As an example, the browser global \nshared state domain can not write into the global private state. Scripts can only access their tabs. \nFinally, a ribbon is a set of protection domains that mod\u00adels the assignment of threads to sets of protection \ndomains. Creating a new ribbon also creates a new thread that is as\u00adsociated with a new set of existing \nprotection domains (pro\u00adgrammatically speci.ed). This thread and all threads that it spawns execute within \nthe context of these protection do\u00admains. Once created, the set of domain sharing privileges for a ribbon \ncannot be changed. The privileges acquired by a ribbon upon creation are upper bounded by the privileges \nof the ribbon of the creating thread. This ensures that once sharing constraints are placed upon a newly \ncreated ribbon, all future computation resulting directly or indirectly from that ribbon will never violate \nthe sharing constraints. In summary, a process contains one or more ribbons, and a ribbon contains one \nor more threads. Threads spawned within a ribbon share the ribbon s set of protection domains. Upon process \ncreation, a new ribbon is created, and thereby a new thread. Programs that are unaware of ribbons operate \nas before, as they are contained within a single ribbon, and all threads share the same protection domain. \n 2.2 RIBBONJ We introduce an extension of Java called RIBBONJ, imple\u00admenting the ribbon memory programming \nmodel. Model\u00ading ribbon concepts at the language level offers improved programmability through type system \nsupport and syntactic sugar. Additionally, a carefully designed language support\u00ading ribbons can help \nthe compiler understand information needed for optimization and automatic parallelization (such as aliasing). \nThe protectiondomain keyword is used to de.ne new protection domain types. These types represent entire \nclasses of protection domains that may be instantiated at runtime. The type optionally accepts as domain \narguments other typed protection domains. The protectiondomain de.nition contains a list of rules that \naffect privileges when a new domain of that type is created: grant adds a new priv\u00adilege where the source \ndomain is explicitly indicated, and the target domain is the new protection domain; require adds a new \nprivilege where the target domain is explicitly indicated, and the source domain is the new protection \ndo\u00admain. The list of rules is abstract and is just a policy until an actual protection domain is created \nat runtime and concrete protection domains (instead of abstract types) are bound to the domain arguments. \nNote that require is needed in addition to grant be\u00adcause privilege speci.cations are used only when \na new pro\u00adtection domain is created, and a new protection domain can\u00adnot grant a privilege to a protection \ndomain that has not yet been created. In the web browser example, the browser global shared state domain \ncannot grant privileges to do\u00admains for tabs, because the tab domains do not exist when the global shared \nstate domain is created; rather, the tab do\u00admains must require certain privileges from the global shared \nstate domain when a tab domain is created. Ribbons are modeled in the language by special classes that \nimplicitly inherit from java.lang.ThreadGroup and implement the Ribbon interface. The ribbon keyword \nde\u00adclares new ribbon types. The declaration includes a list of named protection domains, termed the domain \narguments, which represent the protection domains with which threads within the ribbon will be associated. \nThe primary protection domain designates the .rst in this list. The actual domain argument values are \nnot speci.ed until the ribbon is instan\u00adtiated. The getdomain operator is provided to retrieve the protection \ndomain value of a given name for a given rib\u00adbon object. ribbon classes may optionally extend others, \nand are instantiated using the normal new keyword and con\u00adstructor call, followed by a where clause to \nspecify the do\u00admain argument values for the new ribbon. Once instantiated,  Figure 2. Modeling a master/worker \nrelationship in ribbons. a ribbon begins execution via the start method exposed through the Ribbon interface, \nallowing the application to indicate the java.lang.Thread to use as the .rst thread. The new operator \nis also extended so that a new object can be allocated within a speci.c protection domain. If the extended \nnew operator is not used, then the new object is allocated within the primary protection domain of the \nribbon associated with the currently executing thread. Finally, the thisribbon keyword is added for convenience \nto get the object representing the ribbon associated with the currently executing thread.  2.3 RIBBONJ \nExample We give the speci.cs of the RIBBONJ syntax through an\u00adother example to broaden the illustration. \nThe example, de\u00adpicted in Figure 2, represents a master/worker scenario, as it can model application \nservers. Each master may spawn mul\u00adtiple workers, yet: Masters may not read/write/inject other masters. \n Masters may read data in workers that are spawned by that master but not by other masters.  Workers \nmay not read/write/inject other workers.  Workers may only receive work from their respective masters. \n Three classes of protection domains are required to model this: MasterDomain (stores information needed \nto produce items), WorkerDomain (stores information needed to process items), and QueueDomain (stores \nproduced items ready for consumption). Note that multiple masters may be created (e.g., one master for \nHTTP requests and another for HTTPS). One must distinguish between the protection do\u00admains of these masters. \nThis is effectively modeled within RIBBONJ since protection domains are modeled as types that are used \nas templates and not fully instantiated un\u00adtil runtime. Protection domain types structure runtime pro\u00adtection \ndomains, providing rich information for static anal\u00adyses and compiler optimizations. Below are the protection \ndomain types: protectiondomain QueueDomain {} protectiondomain MasterDomain( ProtectionDomain owner, \nQueueDomain q) { grant {read,write,inject} to {owner}; require {read} from {owner}; require {read,write,inject} \nfrom {q};  } protectiondomain WorkerDomain( MasterDomain m, QueueDomain q) { require {read,write} from \n{q}; grant {read} to {m};  } Note how the MasterDomain requires read access to some generic owner domain. \nAlso, note that MasterDomain needs inject access to the QueueDomain to allocate new objects inside that \ndomain, while WorkerDomain only re\u00adquires read/write access to remove objects from the worker queue for \nprocessing. Also of interest is that a Master needs to be able to read data in Worker domains that it \ncreates. This cannot be speci.ed in the MasterDomain, because the Worker domains do not exist when the \nMaster is created. The grant statement allows a Worker, when it is created, to add to the privileges \nof the MasterDomain passed to the Worker instantiation. The protection domain types de.ned above can \nthen be used to instantiate ribbons that operate within them: ribbon Worker(WorkerDomain wdom) { static \nclass WorkerThread extends Thread { public void run() { ... } } } ribbon Master(MasterDomain mdom) { \nQueueDomain qdom = mdom.q; Queue q = new<qdom> Queue(); public void createWorker() { Worker w = new \nWorker() where (new WorkerDomain( getdomain(thisribbon, mdom), qdom)); w.start(new Worker.WorkerThread()); \n} class MasterThread extends java.lang.Thread { public void produce() { q.add(new<qdom> WorkItem(...)); \n} public void run() { for (int i=0; i<5; i++){ createWorker(); } ... } } } When a new work item is \nproduced, the Master must allocate it within the QueueDomain so that Worker ob\u00adjects can modify it. This \ncan be done by specifying a concrete protection domain (some object deriving from ProtectionDomain) within \nangle brackets after the new operator and before the type name. Also, when a new Worker ribbon is instantiated, \n.rst a new WorkerDomain protection domain is created. The con\u00adstructor for the WorkerDomain requires \ntwo domain argu\u00adments. Here, they are the protection domain named mdom for the current ribbon, and the \nqdom protection domain value created earlier. In this way the protection domain template is applied to \neffect the runtime privileges for the new do\u00admain. The new WorkerDomain value is used to create a new \nWorker ribbon. The newly instantiated ribbon is then told to begin execution, using a new WorkerThread \nthread class as the .rst thread of execution within the newly executing ribbon. Note that the WorkerThread \nand MasterThread classes need not have been declared as inner classes of their respective ribbons, but \nwere done so for convenience. 3. RIBBONJ-LITE To study the isolation properties of RIBBONJ we formal\u00adize \nits core. The resulting syntax and semantics follow in the spirit of other object calculi, e.g., Featherweight \nJava (FJ) [26], Classic Java [22]. 3.1 Syntax and De.nitions The syntax of our core language, RIBBONJ-LITE, \nis pre\u00adsented below. RIBBONJ-LITE can be viewed as FJ without subclasses (and thus casts) for simplicity, \nbut augmented with: protection domain types (D) and protection domain values (p), ribbon types (R) and \nribbon values (r(R)), loca\u00adtion values (l(p,C )), .eld assignments (t.f =t), sequences of terms (t;), \nthreads (newthread <t>{t;}), and ribbons (newribbon R( t ){t;}). program Q ::= \u00d8| Q \u00b7 T{t;} protection \ndom. P D ::= protectiondomain D(Dx){P } privilege P ::= Z(A, x); privilege type Z ::= grant | require \naccess type A ::= read | write | inject ribbon RB ::= ribbon R(Dx) class CL ::= class C {Tf ; KM} construction \nK ::= C(Tf){this.f=f;} method M ::= Tm(Tx){t;} type T ::= C | D | R term t ::= x | v | t.f | t.f=t | \nt.m(t) | new<t> C(t) | newdomain D(t) | newribbon R(t){t;} | thisribbon | newthread<t>{t;} getdomain(t, \nx) value v ::= p(D) | r(R) | l(p, C) Protection domain values model .rst class heaps, and consist of \na typed identi.er denoting a concrete instance of the protection domain (rather than actually containing \nthe values within the protection domain). Protection domain val\u00adues are typed, and corresponding declarations \ninstantiated to yield new protection domains (heaps) at runtime. The pro\u00adtection domain types indicate \nwhich permissions to grant to or require from existing protection domains when creating a new domain. \nA global protection domain that always exists is identi.ed as p., which has a protection domain type \nof PDomain. Ribbon values model the set of protection domains that should be active when executing terms \nin threads be\u00adlonging to the ribbon. Ribbon values consist of a sequence storing the values of the named \nprotection domains for that ribbon. Location values l(p,C ) uniquely identify how to re\u00adtrieve an object \nfrom the object store. C denotes the type of the object, while p denotes the protection domain value \nwithin which the object is contained. Locations may be writ\u00adten simply l for brevity when the containing \nprotection do\u00admain and type C are not germane to the context. In RIBBONJ-LITE we chose not to overload \nthe new op\u00aderator for readability, but instead introduced different opera\u00adtors to create new ribbons, \nprotection domains, and objects. The newdomain operator creates new protection domains and accepts concrete \nprotection domain values referenced within the relevant protection domain type. newribbon creates new \nribbons and accepts the protection domain values within which the new ribbon should operate. The .rst \nprotection do\u00admain value passed to the ribbon constructor is also de.ned as the default protection domain \nfor the new ribbon. In addition to creating a new memory execution context the new ribbon also implicitly \ncreates a new thread within the new ribbon s memory context. thisribbon provides access to the ribbon \nvalue of the ribbon in which the current thread is execut\u00ading. getdomain allows retrieval of one of the \nnamed protec\u00adtion domain values associated with a given ribbon value (or the default protection domain \nvalue). Thread creation is aug\u00admented to indicate the ribbon value of the ribbon in which the new thread \nshould execute. Object creation is augmented to accept the protection domain value in which the new ob\u00adject \nshould be created. new C (t) is syntactic sugar for new <getdomain (thisribbon, default)> C (t). Figure \n3 has auxiliary de.nitions for the language. One noteworth de.\u00adnition is buildnewprivs, which implicitly \nde.nes the set of privileges that protection domains have over each other. Typing rules do not offer \nany surprises, thus we omit them and the corresponding type preservation proof for brevity. 3.2 Dynamic \nSemantics Figure 4 de.nes an operational semantics for RIBBONJ-LITE. Global evaluation is of the form \nI (Q, E , P , R)=.(QI, E I, P I, R) where Q is a parallel com\u00adposition of executing threads (T{. .}), \nE is an object store, P is the privilege set, and R is the ribbon thread context an ordered set of ribbon \nvalues storing the current ribbon value for each active thread. The privilege set tracks permissions \n fields(Thread)=\u00d8 class C{. M} I Tm(Tx){t;} . M protectiondomain D(.. ){P } mbody(m, C)=(x, t)Z(A, x); \n. P (Z, A, x). domprivs(D) ribbon R(Dx) rfields(R)= class C {Tf ; .. } PDomain default, Dx fields(C)=Tf \nprotectiondomain D(Dx). dfields(PDomain)=\u00d8 dfields(D)=Dx (Z, A, x). domprivs(D) Z=grant (x:px) . . (px, \np, A). buildnewprivs(P , R, .,p(D)) (BUILD-GRANT-PRIVS) (Z, A, x). domprivs(D) Z=require (x:px) . . (p, \npx,A). buildnewprivs(P , R, .,p(D)) (BUILD-REQUIRE-PRIVS) Figure 3. Auxiliary de.nitions. for source \nprotection domains pSD on target domains pTD using tuples (pSD,pTD, privilege). Congruence on global \nevaluation (CONGR-E) relies on evaluation contexts E: E::= [] | E.f | E.f=t | v.f=E | E.m(t) | v.m(E) \n| v,E,t | v;E;t | newribbon R(E){t;} | newribbon R(v){E;} | new<E> C(t) | newthread <E>{t;} | getdomain(E, \nx) | new<p> C(E) | newdomain D(E) | newthread<v>{E;} Rules for local evaluation (t, E , P , R)-.(tI , \nE I , P I , R)only include one ribbon value, R, corresponding to the rib\u00adbon value associated with the \nthread of the single thread term being reduced. Note that local evaluation never changes R. Rule FORK-E \ncreates a new thread of control operating within the context of the speci.ed ribbon. The ribbon thread \ncontext R=r(R) is appended with the given ribbon value, remembering for each thread the ribbon within \nwhich the thread is operating. The newthread expression on the cre\u00adating thread of execution is replaced \nwith an expression to create a new Thread object representing the newly created thread. For brevity, \nbut without loss of validity, we omit a rule for cleaning up completed threads. Rule CONS-E creates a \nnew object within a speci.ed protection domain, verify\u00ading that the current ribbon has the inject privilege \non the target domain. The access check occurring within the sec\u00adond line of the rule s antecedent ensures \nthat at least one of the protection domains associated with the current thread s ribbon has the inject \nprivilege on the protection domain within which the new object is being created. Rules FIELD-ACC-E and \nFIELD-ASS-E allow .eld access and assignment and checks for the read or write privilege as appropriate. \nThe rule for method calls, METH-E, veri.es that the cur\u00adrent ribbon has the read privilege on the target \nobject. Rule (t, E , P , Rj )-.(tI , E I , PI , Rj) (CONGR-E) III (T{. } \u00b7 TjI {E[t]} \u00b7 T{. }, E , P \n, R\u00b7Rj \u00b7R)=. III (T{. .} \u00b7 TjI {E[tI]} \u00b7 T{.. }, E I , P I , R\u00b7Rj \u00b7R) II (T{. }\u00b7TI j {E[newthread<r(R)>{t;}]}\u00b7T{. \n.}, E, P , R)=. II (T{. }\u00b7TI j {E[new Thread()]}\u00b7T{. }\u00b7T{t;}, E, P , R\u00b7r(R)) (FORK-E) l . dom(E ) E \nI={l .[f1:v1, . ., fn:vn]}E fields(C)=Tf . (xi:pi) . r(R)|(pi, p, inject).P (new<p> C(v), E , P ,r(R))-.(l(p, \nC), E I , P ,r(R)) (CONS-E) E (l)=[. ., fi:v, . ] . (xi:pi) . r(R)|(pi, p, read).P (l(p, C).fi, E , P \n,r(R) )-.(v, E , P ,r(R)) (FIELD-ACC-E) E (l)=[. ., fi:v, . ] . (xi:pi) . r(R)|(pi, p, write).P I (l(p, \nC).fi=v, E , P ,r(R))-. II (v, {l .[. ., fi:v, . ]}E , P ,r(R)) (FIELD-ASS-E) mbody(m, C)=(x, t) . (xi:pi) \n. r(R) |(pi, p, read).P (l(p, C).m(v), E , P ,r(R) )-.({l/this, v/x }t, E , P ,r(R) ) (METH-E) (v1;. \n;vn, E , P , R)-.(vn, E , P , R) (SEQUENCE-NEXT-E) . .(p(D),. ) . dom(E ) .=[x1:v1, . ., xn:vn] dfields(D)=Tx \nP I=buildnewprivs(P , R, .,p(D)) .P (newdomain D(v), E , P , R)-.(p(D) , E , PI , R) (NEW-DOMAIN-E) \nr(R)=[default:v1,x1:v1, . ., xn:vn] rfields(R)=Tx (newribbon R(v){t;}, E , P , R)-. (newthread<r(R)>{t;};r(R) \n, E , P, R) (NEW-RIBBON-E) (thisribbon, E , P ,r(R))-.(r(R) , E , P,r(R) ) (THIS-RIBBON-E) II (getdomain([. \n., xi:v, . ],xi), E , P , R)-.(v, E , P , R) (GET-DOMAIN-E) Figure 4. Global evaluation in the form \nI (Q, E , P , R)=.(QI , E I , PI , R) and local evaluation in the form (t, E , P , R)-.(tI , E I , P \nI , R). SEQUENCE-NEXT-E reduces a sequence to the last value after all terms in the sequence have been \nfully evaluated. Rule NEW-DOMAIN-E creates a new protection domain value using the given protection domain \ntype as a template. This template is used to add to the privilege set to both (a) grant other protection \ndomains privileges to the new domain (through grant), and (b) grant the new protection domain privileges \nto other domains (through require). These effects are modeled through buildnewprivs. Rule NEW-RIBBON-E \ncreates a new ribbon value and forks a thread using this value. The new ribbon value s named protection \ndomain val\u00adues are initialized using the protection domain values passed as arguments. Note that the \nvalue to which the newribbon term evaluates is the new ribbon value, not the value that the newthread \nexpression evaluates to. Rule THIS-RIBBON-E exposes the value of the current thread term s ribbon value. \nRule GET-DOMAIN-E retrieves a named protection domain value from a given ribbon value.  3.3 Progress \nIn the absence of casts, the original progress theorem of FJ is simpli.ed, notwithstanding our additions \nof locations (since locations explicitly include type information). We de.ne stuck terms to account for \nthe cases where a protection domain privilege check fails. Theorem 1 (Local Progress). Suppose t is a \nclosed, well\u00adtyped normal form under -. and t is within (t, E , P , R). Then either t is a value, or \n.E such that either of the following holds: 1. t = E[new<p> C(v)] . . (xi:pi) . R|(pi, p, inject). P \n 2. t = E[l(p, C).fi] . . (xi:pi) . R|(pi, p, read).P 3. t = E[l(p, C).fi=vI] . . (xi:pi) . R|(pi, p, \nwrite). P 4. t = E[l(p, C).m(v)] . . (xi :pi) . R|(pi, p, read). P  Proof. Straightforward by induction \non derivation of -.. Theorem 2 (Global Progress). Suppose Q is a closed, well\u00adtyped normal form under \n=.. Then either of the following holds: 1. Q is a parallel composition of non-value terms where each \nterm matches one of the non-value normal forms in Theorem 1.  2. Q is a parallel composition of zero \nexecuting threads.  Proof. Proof by contradiction. There are two cases to con\u00adsider: 1. Suppose Q is \nin normal form and is a parallel composi\u00adtion of thread terms, and at least one of the terms is not a \nvalue and is not one of the stuck terms listed in Theo\u00adrem 1. If this term is a newthread term, then \nbecause Q is well typed and because of type preservation, the rule FORK-E is applicable and progress \nis made. If this term is not a newthread term then by Theorem 1 this non-value term can be further evaluated \nunder -., and thus global progress can be made under CONGR-E. Thus, in either case, Q cannot be in normal \nform. 2. Suppose Q is in normal form and is a parallel compo\u00adsition of thread terms, and at least one \nof the terms is a value. For such a term, the rule END-E is applicable and progress is made. Thus, Q \ncannot be in normal form. 3.4 Isolation With the RIBBONJ-LITE semantics above, a new protection domain \ncan grant or require privileges to or from any other domain. While this structures the heap and prevents \ninad\u00advertent accesses, it is not strict enough to fully isolate or sandbox code executing in ribbons. \nWe provide two exten\u00adsions for different levels of isolation, ending with an isola\u00adtion model matching \nthat of RIBBONJ. 3.4.1 Cooperative Isolation Under this .rst model, a new protection domain P cannot \nre\u00adquire a privilege from another protection domain Q unless at least one of the protection domains in \nthe creator s ribbon already has the privilege on domain Q. Thus, the new pro\u00adtection domain is unable \nto increase the scope of what the creator s ribbon is able to access, but the new domain is able to grant \nprivileges to other domains which these did not have on the creator s ribbon. The creating ribbon thereby \ncontrols which protection domains have access to the new domain via the protection domain values it passes \nto the domain being constructed. While not suitable for sandboxing potentially malicious or insecure \ncomponents, this isolation level does allow for more .exibility in that a ribbon can create a new protection \ndomain in order to communicate, indirectly, with domains which with it currently does not have privileges \nto communicate. The semantics of Figure 4 are retained, but we replace the BUILD-REQUIRE-PRIVS rule of \nFigure 3 as follows: (Z, A, x). domprivs(D) Z=require (x:px) . . R=r(R) . (xi:pi) . r(R)|(pi,px,A).P \n(p, px,A). buildnewprivs(P , R, .,p(D)) (BUILD-REQUIRE-PRIVS) This rule has an additional check in the \nantecedent, ensuring that the creating ribbon already has the privilege that the new protection domain \nis requiring. Observe that rather than creating a new kind of stuck term, progress is still made if a \nnew protection domain tries to require a privilege it is not allowed to receive. Instead of becoming \nstuck, such a privilege is not added to the new set. Local evaluation could later get stuck if it tries \nto access a location in a protection domain that it was not allowed to require a privilege to.  3.4.2 \nFull Isolation In this level the same restrictions apply as in cooperative isolation. Additionally, a \nnew protection domain P cannot grant a privilege to another protection domain Q unless domain Q already \nhas this privilege on one of the domains of the creator s ribbon. Under this level of isolation, a new \nprotection domain is fully sandboxed within its creating ribbon. This matches the isolation behavior \nof RIBBONJ. The dynamic semantics of this isolation level are the same as with cooperative isolation, \nexcept that BUILD-GRANT-PRIVS is substituted with: (Z, A, x). domprivs(D) Z=grant (x:px) . . R=r(R) . \n(xi:pi) . r(R)|(px,pi,A).P (px, p, A). buildnewprivs(P , R, .,p(D)) (BUILD-GRANT-PRIVS) A privilege \ncheck is added to the antecedent of the rule to ensure that a privilege can only be granted when appropriate, \nas de.ned above. The effect on progress is similar to that of cooperative isolation no new stuck terms \nare added, but rather local evaluation may become stuck if it tries to use a privilege that was not granted \nwhen the protection domain was created.  3.4.3 Adaptable Isolation Levels The isolation level need not \nbe decided once for the whole program, but can be indicated when a new ribbon is created. Only a same \nor more strict isolation level than the current ribbon s level would be allowed, and the rules for construct\u00ading \nthe modi.ed privilege set would depend on the isolation level. We outline the required changes to the \ndynamic semantics to support adaptable isolation levels. First, ribbon values would be augmented to store \nthe isolation levels associated with them. Ribbon creation would be augmented to allow the new isolation \nlevel to be speci.ed. A check would be added to the evaluation rule for newribbon such that the isolation \nlevel of a new ribbon r could not be less restrictive than the isolation level of the ribbon value associated \nwith the thread that is creating r. Finally, the different variants of the BUILD-GRANT-PRIVS and BUILD-REQUIRE-PRIVS \nrules would become applicable based on the isolation level of the new ribbon. A narrowing extension [25] \nprovides a yet .ner granular\u00ad ity by allowing segments of code in a thread to execute with fewer privileges \nthan the rest. This is supported by option\u00adally allowing a ribbon value to be speci.ed as the context \nwhen calling a method. 4. Implementation of Ribbons The implementation is 3-fold, comprised of the compiler \nmodi.cations for RIBBONJ within JastAdd [19], the mod\u00ad i.cations to JikesRVM [2], and the system level \nsupport. All code and evaluation data is available for download [25]. 4.1 Language Frontend: JastAdd \nThe parser and bytecode compiler for RIBBONJ are im\u00adplemented with JastAdd [19]. JastAdd provides declarative \nmechanisms for modular and composable compiler exten\u00adsions. We implemented modules for extending the \nlexer and parser, RIBBONJ-speci.c type checking, which were then composed with the unmodi.ed modules \nfor the JastAdd Java 5 compiler. Most of the RIBBONJ features were imple\u00admented through straightforward \nAST rewriting mechanisms to translate to a Java API implemented by the VM. Two ex\u00adceptions were ribbon \ninitialization after construction (where clause) and the extended new operator, which were imple\u00admented \nby modifying bytecode generation in the compiler backend. If a speci.c protection domain is given to \nthe extended new operator, bytecode is generated to call a special static method with the protection \ndomain instance immediately be\u00adfore the new call. This special static method is inlined by the JVM to \nset a thread-local variable indicating the protection domain from which to attempt to allocate for just \nthe next object allocation on that thread. Ribbon initialization byte\u00adcode is generated after the constructor \ncall to duplicate the operand and then call an additional initialization method on the ribbon object \nwith the protection domain arguments. 4.2 VM Implementation: JikesRVM The JikesRVM modi.cations are \nbuilt on top of a lower\u00adlevel C library and interact with most areas relating to mem\u00adory management and \nallocation. Brie.y, JikesRVM divides up the heap into spaces being managed by Space-derived classes. \nSpaces acquire and release memory in 4MB chunks in coordination with a map of the virtual address space \nand in accordance with a vmRequest. We added a new type of vmRequest that indicated memory should be \nobtained from the lower-level memory domain C library and which memory domain to use. Spaces work in \ncoordination with page resource objects, which are responsible for resource ac\u00adcounting and distributing \npages within allocated chunks. All spaces and page resources were modi.ed to let the memory domain C \nlibrary handle page (un)protection and freeing if the associated virtual address was managed by memory \ndo\u00admains. Each protection domain is modeled as a distinct space object. Previously, JikesRVM would assume \na static number of spaces would be created at JVM startup, and the num\u00adber and type depending on the \ngarbage collector (GC) se\u00adlected. For example; a large object space, an immortal space, a nursery space, \na mature space, etc. Our implementation now allows for an arbitrary number of spaces to be created at \nruntime. Exactly how many spaces would be created for each memory domain is speci.c to the GC plan selected. \nIn our implementation we modi.ed the basic mark-sweep GC, which involved modifying the resource accounting, \ntracing, and sweeping phases to become aware of dynamically cre\u00adated spaces. The GC itself operates within \na ribbon that has privileges to all memory domains within the JVM. Free pages identi.ed by the GC are \nfreed from their correspond\u00ading memory domain as appropriate. Modifying a copying or generational collector \nis planned, but introduces complexi\u00adties that are beyond the scope of this paper. Thread-local data \nwas added to remember if the next ob\u00adject allocation was for a speci.c protection domain. This thread-local \n.eld is reset to null after each allocation. Addi\u00adtionally, each thread remembers the default protection \ndo\u00admain to use for allocation. Allocation in JikesRVM is mod\u00adeled using classes derived from Allocator \nwhich are per\u00admanently attached to a particular Space instance upon al\u00adlocator creation. For the mark-sweep \nGC the allocator itself did not need to be modi.ed, as it was based on segregated free-lists (for different \nsize classes) and could handle discon\u00adtiguous regions effectively. JikesRVM additionally creates thread-local \nallocators that do not require synchronization in their fast path. In our implementation each thread \nnow has up to N alloca\u00adtors (e.g., N = 16) one for each space associated with the protection domains \nused by that thread. For speed this is implemented by a .xed-size table mapping protection do\u00admains to \nallocator instances. The table is initially empty. Upon allocation the table is linearly scanned to .nd \nthe al\u00adlocator associated with the requested protection domain. If it is not found, a check is made to \nensure the thread s rib\u00adbon is associated with at least one protection domain that has the inject privilege \non the target domain. If the privilege check passes, a new allocator is then created and attached to \nthe space associated with the requested protection domain, and the allocation mapping table for the thread \nis updated. The limitation of the .xed-size allocator mapping table can be overcome by reverting to a \nhash table when a particular thread has allocated in more than N protection domains. Implementing ribbons \nwithin JikesRVM required the merging of JikesRVM s custom SIGSEGV handler with the memory domain SIGSEGV \nhandler. Additionally, thread startup and bootstrap was modi.ed to understand the ribbon concept, with \na new ribbon initialization mode for thread creation that uses the ribbon C library instead of pthreads. \nA support class for the language frontend is also provided that tracks the privileges between protection \ndomains instan\u00adtiated at runtime and then upon ribbon creation applies the proper isolation checks (as \ndescribed in Section 3.4) while setting up the memory domain privileges for the new ribbon.  4.3 Operating \nSystem (OS) Support: Linux While the system level support ultimately belongs in the ker\u00adnel, the rich \nfunctionality of POSIX and Linux APIs make a user-space prototype possible. We employ POSIX shared memory, \nalong with the mmap, mprotect, and clone2 sys\u00adtem calls. Conceptually, the implementation consists of \nthree concepts. A memory domain, which corresponds to an in\u00adstantiated protection domain, is a set of \nvirtual memory pages. A ribbon is a container of threads. A privilege is a mapping between a memory domain \nand ribbon to a set of actions (read, write, etc.). JikesRVM interacts with the sys\u00adtem via a strict \nAPI, such that future work could swap this implementation for one in the kernel without modi.cation. \nA ribbon in our implementation represents a separate and distinct virtual memory space. It is created \n(along with its .rst thread) by a system call to Linux s clone. The calling thread is cloned; however, \na special .ag is passed to indi\u00adcate that the new clone should not share the same virtual address space \nmappings but will share all other properties (e.g., shared .le table) of a new thread. In this way, a \nrib\u00adbon appears as another thread within the same process ex\u00adcept that it can control its virtual memory \nmapping and per\u00admissions independently. At process startup, a (large) mem\u00adory area is reserved3, and \na memory domain is a collection of pages from this area. Permissions dictate speci.c actions that a ribbon \ncan perform on the pages belonging to each memory domain. We say that a page is unmapped in a rib\u00adbon \nif that particular ribbon can not currently access it, even if the privileges permits the access. Likewise, \nwe say that a page is mapped if a ribbon can currently access it. The mprotect system call is used to \nactually map and un\u00admap pages from a ribbon. Throughout program execution, pages are mapped and unmapped \nfrom ribbons as needed to enforce the privileges and isolation properties of given ribbon instances. \nSince modern hardware enforces memory permissions, the overhead from this for normal usage is non\u00adexistent \nand is minimal during the mapping, unmapping, creation, and destruction of ribbons, memory domains, and \nprivileges. As a memory domain grows (or shrinks) it allocates (or releases) pages from the reserved \nmemory area claimed at startup. Accesses to this area are serialized such that no two memory domains \ncould allocate the same page, as this would become problematic should a single ribbon need to access \nboth memory domains simultaneously mapped into it. Dur\u00ading execution, a memory domain could grow (by \nclaiming pages from the reserved area) because a ribbon attempted to allocate an object inside it. These \nadditional pages will 2 A generalization of the fork system call used to spawn new threads. 3 The size \nof this area is con.gurable, but in our implementation it far ex\u00adceeds the system s RAM. However, because \nof Linux s on-demand paging and memory over-commit, pages in this area from the OS s perspective re\u00admain \nunused until a write attempt has been made to it. subsequently be mapped into the ribbon such that the \nac\u00adtual hardware permits access to them. However, another rib\u00adbon could also have access privileges to \nthis memory do\u00admain but will be unaware of the change. The pages in this other ribbon would still be \nunmapped. Likewise, should a ribbon s actions cause a memory domain to shrink by re\u00adturning pages to \nthe reserved area, these pages may still be mapped in another ribbon. To address growing memory do\u00admains, \nsimply do nothing. When a ribbon tries to access an unmapped page the hardware generates a fault causing \nthe OS to issue a SIGSEGV signal. Normally, this signal results in the termination of the process, but \na custom signal han\u00addler is installed instead. When invoked, special code checks to see if a ribbon has \naccess privileges to this area. If so, this page and opportunistically its surrounding pages are mapped \ninto the current ribbon. If not, an error is raised. This type of on-demand mapping technique is prevalent \nin system im\u00adplementations. We do not directly address shrinking memory domains as this is better addressed \nin the kernel. Possible solutions such as sending signals to other ribbons could be used. We simply avoid \nthe issue by not shrinking any mem\u00adory domains. Throughout our evaluation this never caused a problem. \nA limitation of the implementation is that isolation only strongly applies to the JIT-ed Java bytecode, \nwhich we term as untrusted code. We assume that all native code is inherently trusted. Thus, any untrusted \ncode must not be al\u00adlowed to invoke native (JNI) method calls that are not known to be trusted (e.g., \npart of the class library implementation). This can be enforced by either the JIT compiler or by the \nclass loader. Further care is taken to protect the metadata for ribbons, memory domains, and privileges. \nThe pages where this metadata exist are unmapped from all ribbons during normal execution, and only mapped \nin during certain system level code. This provides some protection against untrusted native code. With \nthe metadata in user-space, isolation is only ensured for pure Java code compiled by the JIT natively \ncompiled code can potentially modify this metadata, thus manipulat\u00ading protection boundaries. In order \nfor isolation to be guar\u00adanteed for native code, there must be support in the kernel. This paper focuses \non de.ning the ribbon concept, the RIB-BONJ semantics, and the JVM implementation issues. The details \nof kernel support is beyond its scope. 5. Evaluation In this section we evaluate the performance of our \nimple\u00admentation by comparing the performance of the version of JikesRVM that we started (from SVN version \n15779) to our custom version. We report on .rst experiences with rib\u00adbonizing small-scale programs. \n5.1 Methods and Benchmarks All benchmarks were run on a dedicated system with 6-core AMD Phenom II 1090T \nCPU with 8 GB DDR3 RAM, run\u00adning Gentoo Linux 2.6.36 SMP. JikesRVM was con.gured with the mark-sweep \nGC with the optimizing compiler. It was also con.gured to run with a .xed heap size and to use 6 threads \nfor parallel GC (one per core). To avoid variations introduced by the adaptive optimization system (AOS), \nAOS was disabled and loaded classes were immediately compiled by the fully optimizing compiler on .rst \naccess. Three JVMs were evaluated: (1) unmodi.ed JikesRVM (2) ribbonized JikesRVM with lazy mapping \n(termed RibbonRVM-lazy), (3) ribbonized JikesRVM where all pages are immediately mapped in upon allocation \n(termed RibbonRVM-nolazy). Ten benchmark iterations were per\u00adformed. Each iteration executed all benchmarks, \nrunning all 3 JVMs for the same benchmark back to back. Alternating JVMs and benchmarks between iterations \nminimizes bias due to systematic disturbance. In each benchmark run, two warmup runs of the benchmark \nwere taken (without JVM restarting) to allow all methods to be fully compiled and for the system to reach \na stable state before the timed run began. All data points represent the mean over 10 iterations and \nare given with 99% t-test con.dence intervals. Overhead was evaluated using the DaCapo benchmark suite \n[5] (version 2006-10-MR24) as well as with an imple\u00ad mentation of the Master/Worker example from Section \n1. We also ribbonized lusearch to use 32 ribbons instead of 32 threads (lusearch-rib). The Master/Worker \nbenchmark (mw) consists of master threads producing work that is con\u00adsumed by worker threads. In the \nbenchmark, a synchronized queue is .lled with homogenous items (objects). Each item contains an array \nof long integers. The queue is prepopu\u00adlated with enough items to .ll 32 MB of memory. All master threads \nshared the same ribbon, but each worker had its own ribbon and protection domain, just as in the example. \nThe masters produce an item by copying the array data into the appropriate worker item in the queue. \nThe workers consume an item by copying the array data out of the queue item and into a work buffer and \nthen summing all of the longs in that item. The benchmark was designed to be memory-bound as opposed \nto being CPU-bound. On our benchmark system we found maximum performance was achieved with 2 master threads \n(1 ribbon) and 2 worker threads (2 ribbons), so this con.guration was used for all runs. We varied the \nwork item size from 512 bytes to 1 MB to vary the effects of memory bandwidth and synchronization. 4 \nThe unmodi.ed version of JikesRVM does not yet run well on DaCapo version 9.12, see http://dacapo.anu.edu.au/regression/ \nsanity/2010-11-19-Fri-02-46/jikesrvm-svn.html   5.2 Benchmark Results Figure 5 presents the wall-clock \nrunning times for the bench\u00ad marks. No signi.cant overhead is observed for antlr, hsqldb, and xalan. \nThe overhead of most other bench\u00admarks is between 2% and 6%. Interestingly, the degree of parallelism \ndoes not seem to correlate with observed overhead. The overhead for the parallel benchmarks (mw, hsqldb, \nlusearch, xalan) varies widely. Additionally, the outlier is jython (single threaded benchmark), with \nan overhead of 10%. The overhead on the DaCapo benchmarks (except for lusearch-rib) cannot be due to \nadditional memory map\u00adping, page faults, or context switching caused by ribboniza\u00adtion, because these \nbenchmarks are still running within the context of a single ribbon. For DaCapo performance over\u00adheads \nare caused more by the additional complexities intro\u00adduced into the fast allocation path. Currently the \nRIBBONJ compiler uses a thread-local .eld (in the MutatorContext instances) to store which protection \ndomain a new object should be allocated within (note that this .eld is only set if a non-default domain \nis used for allocation). The fast allo\u00adcation path must retrieve this additional .eld and also reset \nit after the allocation. There is also an additional conditional to test if a non-default protection \ndomain needs to be used for allocation. To further substantiate the above theory, we re\u00admoved the thread-local \n.eld accesses from the fast allocation path and the overhead on jython lowered to 6%. However, when we \ninstead removed the extra conditional, performance on jython did not improve. While DaCapo primarily \nmeasures overhead in the con\u00adtext of a single ribbon, mw is a better test for overhead caused by having \nmultiple ribbons. The mw benchmark avoids object allocation almost entirely during the timed run by allocat\u00ading \nall objects during the warmup phase. The same items are then re-used (being put back into the queue where \nthey can be re-populated by a Master thread). Overheads are thus instead caused by increased memory mapping \noperations (each ribbon has to map in the appropriate memory) and cor\u00adresponding page faults, and changes \nin scheduling and con\u00adtext switching (the kernel currently views ribbons as separate processes). We found \nruntimes varied more widely than for DaCapo, so we increased the iteration count to 15 for these benchmarks. \n In the smallest case, a slowdown of 3% was observed. For the medium item size, results were not statistically \nsig\u00adni.cant. Notably, for the 1MB item size case performance actually consistently improves. We re-ran \nthis case (another 15 iterations), and the results were consistent (5% improve\u00adment). Our theory to explain \nthis performance increase is that because ribbons are treated as processes instead of as threads the \nscheduling (by the kernel) is more favorable in this case. Another possibility is that ribbons slightly \nchanges the virtual address memory layout of the JVM, which could affect caching behaviors (as cachegrind \nand other tools do not support our special use of the clone system call, it is dif.cult to better substantiate \nthis theory). We ran the bench\u00admark on a machine with a different con.guration (Dual 2.8 GHz Quad Core \nIntel Xeon) but observed an overhead of 2% to 3% instead. The lusearch-rib benchmark runs with 32 ribbons \nand measures overhead from all factors, since it performs signif\u00adicant object allocation and is highly \nconcurrent. lusearch had the most overhead of any parallel benchmark in the threaded version, and it \nis also the most concurrent bench\u00admark. Thus, overhead of ribbonization is likely to be the highest of \nany of the parallel benchmarks. Overhead for lusearch was just over 12%, highlighting potential for future \nperformance optimizations. Kernel-level support for ribbons is anticipated to signi.cantly reduce overhead \nfor highly concurrent, fast allocating programs. 5.3 Security To verify that privileges were properly \nenforced we modi\u00ad.ed the Master/Worker example to reference memory that it should not have privileges \nfor. For example, we had a Worker try to write to the queue data domain, which the Worker only had read \naccess to. This produced the following RuntimeException: org.mmtk.vm.Memdom$ViolationException at MasterWorker$QueueDomain.take(...) \nat MasterWorker$WorkerRibbonThread.run(...)  5.4 Small-scale Refactoring Experiences We refactored several \napplications to gain experience using RIBBONJ in practice, and brie.y summarize our experiences thus \nfar. First, we implemented the master/worker example in 291 lines of Java. Ribbonizing this program to \nisolate each worker required changing 23 lines of code (13 lines for pro\u00adtection domains, 2 lines for \nribbons, 3 lines for changed al\u00adlocation sites, and 5 for changes to threads). We also rib\u00adbonized the \nlusearch DaCapo benchmark, in this case not to gain any isolation but just to introduce ribbons for bench\u00admarking. \nOnly 3 lines of code had to be changed (1 line for the ribbon declaration, 2 to instantiate the ribbon). \njIRCd5 is an open source Java IRC daemon, consisting of 9,556 lines of code and 121 classes. We applied \na two\u00adtier isolation model where each connection operates within its own protection domain, and there \nis a global protection domain for shared state. Ribbonization required 19 lines of code. Most of the \nclient-speci.c state was allocated in just a few places, so using the appropriate default protection \ndomain for each ribbon allowed us to keep modi.cation of allocation sites to a minimum. We note that \ndespite the signi.cant difference in size between the master/worker example (291 lines) and jIRCd (9,556) \nthe code changes required to ribbonize the applica\u00adtion is about the same (23 lines vs 19 lines). For \nthese rela\u00adtively smaller applications, it is clear that the complexity of ribbonization is not determined \nby program size but rather determined by how cleanly the heap can be segmented into classes of objects \n(in this case, isolation classes). To un\u00adderstand whether this principle extends onto more industrial\u00adstrength \napplications we ribbonized the Tomcat web server, as detailed in Section 6. 6. Case Study: Ribbonization \nof Tomcat This section presents a case study in ribbonizing the Apache Tomcat web server. We discuss \nthe minor program exten\u00adsions necessary and compare the performance of our rib\u00adbonized version to the \noriginal one. 6.1 Apache Tomcat Overview As discussed in the introduction, Tomcat is a web server implementing \nthe Java Servlet and JSP standards, and is used in many enterprise applications. Tomcat was .rst released \nin 1999 and has grown to become a mature open-source project, comprising over 410,000 lines of Java code. \n5 http://j-ircd.sourceforge.net/  To use Tomcat, developers package servlets and JSPs as applications \ninto WAR .les, which can then be dynamically deployed or undeployed to or from a running Tomcat server. \nApplications deployed as WAR .les typically run in com\u00adplete isolation from each other. This isolation \nis enforced in Tomcat through private class loaders (one per application context) and the Java Security \nManager. Using a private class loader for each context provides strong isolation, but also results in \nmemory overhead from redundant class metadata for identical classes shared by dis\u00adtinct web applications. \nAdditionally, private class loaders cause increased startup costs, due to having to decode, ver\u00adify, \nand compile several copies of the same method instead of just one copy of each unique method. While memory \nsavings per instance may be relatively mi\u00adnor (e.g., in the MVM system [14] they found a savings of 5MB-7MB \nper additional deployed application for the li\u00adbraries they studied), these savings can add up signi.cantly \nconsidering that there may be hundreds or even thousands of deployed applications on a single Tomcat \nserver. As indi\u00advidual servers grow increasingly powerful (and can therefore accomodate more users and \ndeployed apps), the memory and CPU overhead from duplicate metadata and class compila\u00adtion becomes increasingly \nrelevant. To reduce these inef.ciencies we refactored Tomcat ver\u00adsion 5.5.31 with RibbonJ to use protection \ndomains to iso\u00adlate the heaps of deployed web applications and to use rib\u00adbons to enforce this isolation \nwhile an application processes a request. Our prototype, TomcatRJ, uses our modi.ed ver\u00adsion of JikesRVM \nfor its runtime, and supports the same fea\u00adtures and deployment con.gurations as the original version \nof Tomcat that we started with. 6.2 Architecture and Coding Overview The left side of Figure 6(a) shows \nthe class loader hierar\u00ad chy for the unmodi.ed version of Tomcat. While there are several class loaders \nin the hierarchy, most are used only to isolate sensitive parts of the Tomcat runtime from any shared \nstate and private application state, and once their initial set of classes are loaded they do not load \nmany additional classes. The exceptions are the application private class loaders, of which there can \nbe an arbitrary number, and so we focus our efforts on eliminating these class loaders through ribboniza\u00adtion. \nThe right side of Figure 6(a) shows the straightfor\u00adward division of the Tomcat heap into protection \ndomains, wherein each application-private class loader is replaced by an application-private protection \ndomain. Note how only one global protection domain is used for all of the .xed class loaders. Within \nthis global protection domain the class loaders provide the isolation, and so we do not need to iso\u00adlate \nfurther using protection domains. Additionally, in the  (a) The class loader hierarchy under the non-ribbonized \n(left) and ribbonized (right) (b) Using ribbons to isolate heaps of web applications instead Tomcat. \nof using private class loaders. Figure 6. Overview of Tomcat ribbonization. new architecture classes \nloaded by applications are loaded by the Shared class loader, ensuring there is only one copy of relevant \nclass metadata. Figure 6(b) shows how we map ribbons onto the protec\u00ad tion domains and also the domain \nsharing privileges. All of the threads in the original design of Tomcat continue to run in the main Tomcat \nribbon, termed the daemon ribbon. Dur\u00ading the processing of a request, we need to ensure that the request \nis processed within an isolated context. To do this, we maintain an additional processing thread pool \nfor each deployed application, hand the request off through a shared queue for processing on the application-private \nribbon, and wait for the result. Hand-off and waiting is accomplished through normal Java synchronization \nprimitives. Tomcat follows the chain-of-responsibility software de\u00adsign pattern for request processing. \nA Pipeline models a sequence of actions required to process a request. Actions are modeled by Valve objects. \nThis design lends itself quite nicely to ribbonization. We created a new type of Valve that of.oaded \nrequests to a private processing ribbon and waited for the response. Valve objects are aware of lifecy\u00adcle, \nand so during startup and shutdown the appropriate pro\u00adtection domain, ribbon, and thread pool could \nbe constructed or cleaned up, as appropriate. Then if the application is con\u00ad.gured to use ribbonization \nfor isolation instead of a private class loader, a ribbonizing Valve would be inserted (at run\u00adtime) \ninto the processing Pipeline for that application. Note that in our design we did not modify the architec\u00adture \nof Tomcat s original request processing queue Tomcat will accept a new connection and perform application \ndis\u00adpatching from within the daemon ribbon, and only once it has been dispatched to the proper application \nwill it then be redirected to the appropriate application-speci.c ribbon. The main challenge in ribbonizing \nthe original thread pool itself is that we do not know which application needs to process a request until \nthe request has been partially decoded. Be\u00adcause a thread cannot switch to a different ribbon, the re\u00adquest \nmust be passed off to a different thread in the desired ribbon; we thus require two extra context switches \n(one to pass off the request, and one to receive the response once processed). The overhead of this technique \nis measured in detail below. Finally, certain class metadata must not be shared, such as the values \nof static .elds and the locks of objects, in order to provide the same level of isolation as private \nclass loaders. In our implementation, we rewrite the bytecode to mediate accesses to static .elds and \nredirect them to ribbon-local values of these .elds instead. Our prototype does not address the redirection \nof object locking; however, this could likely be addressed at the VM level without too much dif.culty \nby redirecting to a ribbon\u00adlocal lock for the object when an object s lock is promoted to a heavyweight \nlock. Additionally, the benchmark we used to evaluate the performance of our prototype (SPECweb2009) \ndoes not make use of locks on isolated objects, so our perfor\u00admance numbers would not change signi.cantly \nif locks were fully isolated. The benchmark was designed to be represen\u00adtative of the designs of modern \nweb applications. In Tom\u00adcat web applications most shared state is contained in either the session object \n(which is not managed by the application\u00adprivate class loader), or in a database (which does not rely \non Java object synchronization for concurrency control). Thus, we did not focus our efforts on isolating \nlocks for this refac\u00adtoring of Tomcat. 6.3 Assessment of Refactoring Efforts The refactoring required \nrelatively little coding and was ex\u00adhibited purely as new lines of code (no existing lines of code needed \nto be changed). In total there were 680 new lines of code, most of which were for the implementation \nof the rib\u00adbonizing Valve. AspectJ was used to write a short yet pow\u00aderful aspect to redirect static \n.eld accesses to a ribbon-local value cache. Only two of the original Tomcat Java .les had to be changed \n 21 lines of code were inserted to check if an application should be ribbonized, and if so, to insert \nthe ribbonizing Valve into the appropriate Pipeline. This con.rms the results found in Section 5.4 that \nthe complexity required to ribbonize a program does not depend on program size, but rather how cleanly \nthe heap can be coarsely partitioned at the source level. Tomcat s heap al\u00adready had very clear boundaries \nof division, which combined with its use of design patterns allowed for a highly modular implementation \nof ribbonization.  6.4 Performance Evaluation We used the SPECweb20096 benchmark to evaluate the per\u00adformance \nof TomcatRJ under realistic workloads. In this pa\u00adper we focus on the Banking workload of SPECweb2009, \nwhich was modeled after the actual workload and design of a major banking system in Texas. The benchmark \nis divided into three tiers: backend, application logic, and static con\u00adtent. The backend tier is simulated \nby an Apache FastCGI module written in C. The application logic is written in JSP and Java, which we \nhost on Tomcat. Finally, static content such as bank check images are pre-generated and stored on the \n.lesystem. We also use Tomcat to serve static content. The benchmark is driven by one or more multithreaded \nclients, which make requests to the static web and appli\u00adcation server, simulating the behavior of actual \nusers. We con.gured the benchmark to eliminate any simulated user think time, such that once a response \nto a request was re\u00adturned the client would immediately make another request; this puts a higher than \nnormal load on the web and applica\u00adtion server as all clients are making requests as fast as possi\u00adble. \nWe used one client running on its own system with a 2.8 GHz Quad-Core Intel Xeon processor and 8GB of \nRAM, running OSX 10.5. The client was con.gured to spawn 40 concurrent request generating threads. During \nthe bench\u00admark the CPU on the client system remained under 50%, so the client was not a bottleneck. The \nclient system was con\u00adnected to the server system through a single Gigabit switch. The server system \nhad a 2.8 GHz Quad-Core Intel Xeon processor and 4GB of RAM, running x86 Linux kernel 2.6.32-22-generic \n#36-Ubuntu SMP. Both Tomcat and the backend simulator were run on the same system. Through\u00adout the benchmark \nwe observed the backend simulator using less than 5% of the CPU, so it was not a bottleneck. We ran three \niterations of the banking workload, in\u00adterleaving between two con.gurations: .rst, the unmodi\u00ad.ed version \nof JikesRVM (fully optimized build) running the original Tomcat, and second, the ribbonized version of \nJikesRVM (fully optimized build) running TomcatRJ. The SPECweb2009 benchmark strives to maintain a con\u00adstant \nlevel of throughput and then measures request latency to determine if requests were processed within \na good amount of time, tolerable amount of time, or unaccept\u00adable amount of time. In all runs all requests \nwere processed 6 http://www.spec.org/web2009/   in a good amount of time. The benchmark slowly ramps \nup throughput to the target throughput, then warms up the server by maintaining the target throughput, \nand .nally per\u00adforms the actual benchmark run. Every 10 seconds data is recorded on the aggregate throughput \nand average request latency. Additionally, we collected statistics on the individ\u00adual processing times \nof requests within Tomcat. In Tomca\u00adtRJ we recorded the time required to actually process the request \nitself as well as the processing time including the time to of.oad the request to another ribbon and \nwait for the response to be returned to the calling ribbon. In this way we could accurately measure the \nadditional latency caused by ribbonization. Tomcat TomcatRJ Difference Lines of Code 413,972 414,477 \n+680 lines New+Modi.ed LOC N/A 680 0.122% of total Total # of Requests 5,537 5,562 +25 Median Latency \n2.97ms 3.60ms +0.63ms Mean Latency 4.42ms 6.11ms +1.69ms Latency 99th Percentile 23.5ms 31.5ms +8ms Latency \n99.9th Percentile 51.4ms 259.2ms +207.8ms Table 1. Summary of data from the evaluation of Tomcat Table \n1 summarizes the key results of the evaluation. Fig\u00ad ure 7 offers insight into the differences in request \nprocessing latency. From the boxplot, we see that TomcatRJ median la\u00adtency is less than 1ms more than \nfor Tomcat (0.63ms, see Table 1). In both cases, the mean is above the upper quartile (75th percentile), \nindicating there are very large outliers on the upper end. The upper quartile stretches farther for Tom\u00adcatRJ, \nindicating the upper half of the distribution is more evenly distributed, and thus interruptions in processing \ntime are more likely. Undoubtedly, this extra source of variation is caused by the extra context switches. \nIn most cases, the extra context switches happen relatively quickly, but in the TomcatRJ case small delays \nhappen more frequently, and the duration of rare delays is larger. From the CDF we can see that for approximately \n80% to 85% of all requests the difference in latency is less than 1ms. However, past this point, the \noutliers become more dramatic in TomcatRJ. The 99th and 99.9th percentile for latency in Table 1 provide \ninsights into the differences in these extreme outliers. At the 99th percentile, the difference is still \nnot so dramatic (8ms longer for TomcatRJ), but at the 99.9th percentile, the outlier for TomcatRJ is \nmore than 4 times the outlier for Tomcat. When the system is under heavy load (having 40 clients make \nrequests as fast as possible to the server application), it appears that in very rare cases one or both \nof the threads processing a request is starved while waiting to be scheduled to receive the processed \nresult. Table 2 and Figure 8 present the observed additional latency caused by ribbonization. The additional \nlatency is calculated by taking the request processing time as observed in the main daemon pool for a \nthread and subtracting the TomcatRJ Median Add. Latency 0.559ms Mean Add. Latency 0.988ms Add. Latency \n90th Percentile 1.005ms Add. Latency 99th Percentile 3.658ms Add. Latency 99.9th Percentile 47.070ms \nAdd. Latency 99.99th Percentile 443.7ms Table 2. Summary of additional latency in request process\u00ading \ndue to ribbonization in TomcatRJ  Figure 8. Visualizes the distribution for the additional time required \nto process requests in Tomcat due to ribbonization during SPECweb2009 Banking. The vertical line at 1ms \non the CDF marks the 90th percentile. time it took to actually process the request on the isolated thread. \nThis can be obtained by having the .nal Valve in the Pipeline (which excutes on the isolated ribbon) \nrecord the time it takes to process the request just on that thread.  Figure 9. Throughput for each \n10-second interval during SPECweb2009 Banking, averaged over 3 runs. Excludes warmup and rampdown. The \ndifference thus includes both the extra time required to pass off a request and the extra time waiting \nto be scheduled to receive and process the response. The interesting observation here is that at the \n99th and 99.9th percentile, the observed additional time required for ribbonization is signi.cantly smaller \nthan the observed dif\u00adferences in total request processing time. It appears that the increased OS scheduling \nqueue lengths and increased use of locking when passing objects between ribbons is caus\u00ading context switches \nin general to take longer on average, sometimes signi.cantly longer due to starvation, and thus in\u00adcreasing \nlatency of work that happens during a request (e.g., network I/O) in addition to the dispatching of a \nrequest. Measured throughput over the life of the workload is shown in Figure 9. It is important to note \nthat despite the increase in latency in TomcatRJ, there is no statistically sig\u00adni.cant difference in \ntotal throughput. This indicates that the additional context switch is not causing signi.cant overhead \nin terms of CPU cycles. This is not surprising considering that a modern CPU on a modern OS can perform \nmillions of context switches per second. This result also indicates that the additional logic in the \nallocation fast path in the ribbonized version of JikesRVM is not causing signi.cant overhead for this \nworkload. Surprisingly, even the same general shape of the through\u00adput graph is similar over time. We \npostulate that each bench\u00admark client thread is seeded deterministically, and that be\u00adcause the throughput \nof the benchmark is carefully regu\u00adlated, similar patterns of throughput over time can be ob\u00adserved even \nwhen averaging data points across several dis\u00adtinct runs. In conclusion, we have observed that for almost \nall re\u00adquests, the cost of ribbonization was less than 1ms and that total throughput is maintained at \nprevious levels. However, the additional context switch introduces variation into the total processing \ntime of a request, such that 1 out of every 1000 requests is expected to experience an additional delay \nbetween 200ms and 550ms and 1 out of every 100 requests is expected to experience an additional delay \nof 8ms. 7. Related Work Many proposals for .ne-and course-grained memory pro\u00adtection based on hardware \nmodi.cations have appeared, in\u00adcluding Mondrian [39], Legba [38], InfoShield [32], and oth\u00ad ers (e.g., \n[40]). These systems only provide protection mech\u00ad anisms at the lowest level, and do not address programmabil\u00adity \nwithin such models. Traditional capability-based access\u00adcontrol mechanisms (e.g. [13, 28]) are not suitable \nfor pro\u00ad tecting memory regions as they can be shared in an unre\u00adstricted fashion across threads. Both \nhardware-based [18, 27, 31, 36] and software\u00ad based [10, 29] techniques have been proposed for guarding \nagainst heap corruption and memory bugs. These techniques target speci.c types of .aws and do not provide \ngeneral\u00adpurpose protection. Also, they either do not distinguish be\u00adtween threads in a process [18, 27, \n29, 31] or are based solely on temporal constraints [10, 36]. All hardware-based techniques except [27] \nrequire hardware modi.cations. Region-based memory management has been investigated in various programming \nparadigms, e.g., functional [35], im\u00ad perative [23], as well as in real-time systems [3, 7]. The main \ndriving force is to avoid costly heap allocation and garbage collection overheads, which is achieved \nby intro\u00adducing structure into the memory such as to deallocate en\u00adtire regions in single steps. Alas, \nregion-based memory man\u00adagement approaches force rigid hierarchical organizational patterns on the heap \nwhose lifetime is tied to code scope, and focus on performance but provide no protection features. Memory \nstructuring is also the motivation for isolates intro\u00adduced in the Multitasking Virtual Machine (MVM) \n[14, 24], which reduces the memory footprint by allowing code shar\u00ading without sharing state. This leads \nto security bene.ts, but at a very coarse grain, and still requires IPC mechanisms for communication \nbetween isolates. Ownership types [6, 12] and derivatives attempt to con\u00ad trol the effects of aliasing \nin object settings, by limiting ac\u00adcesses to objects to their owners. The latter entities ob\u00adjects themselves \n are given certain access rights on the former entities, while the same rights are denied to others. \nIdeally, ownership relationships lead to a hierarchical struc\u00adture of the heap, or can even allow for \nstack allocation in\u00adstead of heap allocation. Ownership types target at static en\u00adforcement of access \nrules which is quite restrictive because communication patterns are .xed statically by type differ\u00adent \nthreads acting in different roles may not access the same type differently. Most importantly, however, \nin the present context, ownership types as such cannot fully guard against malicious components and cannot \nprotect low-level system components. The implementation for lightweight protection domains in Nooks \n[33] and others (e.g., [11, 34])also utilizes page table manipulation and/or hardware segmentation. The \npro\u00adtection domains and corresponding privileges were .xed in these systems, and so are not easily extended \nto support rib\u00adbons. Opal [8] is an OS with features for processes with partially-shared memory address \nspaces. Opal requires a sin\u00adgle system-wide shared virtual address space, and does not model allocation, \nwhich is important for security and al\u00adlocation optimization. Its dynamic grant/deny segmentation model \nis potentially less secure (accidental capability leak\u00adage via bugs, manipulation) and prevents analysis \nof pro\u00adgrams for automatic parallelization. Others (e.g., [15, 17, 30]) have similar limitations. Pure \nsoftware techniques based on code rewriting [37], inline monitors [20], and static enforcement through \ntyp\u00ad ing [1, 4], termed software-isolated processes (SIPs), have been proposed and show promise for ef.cient \nenforcement of .ne-grained protection mechanisms. Code rewriting and inline monitors rely on either a \ntrusted rewriter or a trusted static veri.er to ensure correctness. Additionally, these tech\u00adniques either \nhave .xed protection domains [37] or re\u00adquire slow paths with excessive overheads (2\u00d7 to 8\u00d7 slow\u00addown \n[20]), and may be highly architecture speci.c, as was the case with [37]. SIPs in [1] require completely \ndisjoint protection domains, and do not allow for arbitrarily .exible communication patterns that can \nbe safely adjusted at run\u00adtime. None of these prior techniques can be easily adapted to ef.ciently provide \ndifferent protection domains for different threads within the same process. 8. Conclusions Herein we \npresented Ribbons, a new model for program\u00adming components with full or partial heap isolation. We de.ned \nRIBBONJ, a realization of this model in Java, and explored its formal properties in RIBBONJ-LITE. We \nknow of no other language that supports (1) typed protection do\u00admains instantiated at runtime and associated \nwith a group of threads, (2) the inject privilege, and (3) adaptable isolation levels. We discussed the \ndesign and implementation of the Rib\u00adbonJ compiler, supporting JVM, and Linux user-space run\u00adtime. The \nfull RibbonJ compiler and ribbonized JikesRVM are freely available for download and experimentation [25]. \nOur initial system demonstrates reasonable overheads for many workloads. In our case study of Apache \nTomcat we discussed the design, implementation, and evaluation of iso\u00adlating web applications using ribbons. \nWe found that isola\u00adtion could be implemented using ribbons without complex or intrusive code changes. \nWe also found that typical over\u00adhead is less than 1ms per request, although ribbonization did increase \nlatency signi.cantly for outliers. Future work will focus on kernel-level support for rib\u00adbons. We anticipate \nkernel-level support providing (a) sig\u00adni.cant performance improvements through tighter integra\u00adtion \nwith virtual memory protection mechanisms and the OS scheduler, and (b) the potential to provide full \nor partial iso\u00adlation of ribbons beyond the heap. Many open questions sur\u00adround how to best model the \nisolation of non-heap resources using ribbons, including how to do so in such a way as to allow for kill-safety \nof individual ribbons running within a process. We envision the ribbons programming model pro\u00adviding \na comprehensive framework for the ef.cient isolation of components at a language, language runtime, and \nsystems level. References [1] M. Aiken, F. F\u00a8ahndrich, C. Hawblitzel, G. Hunt, and J. Larus. Deconstructing \nProcess Isolation. MSPC 06. [2] B. Alpern, S. Augart, S. M. Blackburn, M. Butrico, A. Coc\u00adchi, P. Cheng, \nJ. Dolby, S. Fink, D. Grove, M. Hind, K. S. McKinley, M. Mergen, J. E. B. Moss, T. Ngo, and V. Sarkar. \nThe Jikes Research Virtual Machine Project: Building an Open-source Research Community. IBM Systems Journal, \n44(2):399 417, 2005. [3] C. Andreae, Y. Coady, C. Gibbs, J. Noble, J. Vitek, and T. Zhao. Scoped Types \nand Aspects for Real-Time Java. ECOOP 06. [4] B. N. Bershad, S. Savage, P. Pardyak, E. G. Sirer, M. \nE. Fi\u00aduczynski, D. Becker, C. Chambers, and S. Eggers. Extensi\u00adbility Safety and Performance in the SPIN \nOperating System. SIGOPS OSR, 29(5):267 283, 1995. [5] S. M. Blackburn, R. Garner, C. Hoffmann, A. M. \nKhang, K. S. McKinley, R. Bentzur, A. Diwan, D. Feinberg, D. Frampton, S. Z. Guyer, M. Hirzel, A. Hosking, \nM. Jump, H. Lee, J. E. B. Moss, B. Moss, A. Phansalkar, D. Stefanovi\u00b4c, T. VanDrunen, D. von Dincklage, \nand B. Wiedermann. The DaCapo Bench\u00admarks: Java Benchmarking Development and Analysis. OOP\u00adSLA 06. [6] \nC. Boyapati, R. Lee, and M. C. Rinard. Ownership Types for Safe Programming: Preventing Data Races and \nDeadlocks. OOPSLA 02. [7] C. Boyapati, A. Salcianu, W. S. Beebee, and M. C. Rinard. Ownership Types for \nSafe Region-based Memory Manage\u00adment in Real-time Java. PLDI 03. [8] J. S. Chase, H. M. Levy, M. J. Feeley, \nand E. D. Lazowska. Sharing and Protection in a Single-address-space Operating System. ACM TOCS, 12(4):271 \n307, 1994. [9] S. Chen, D. Ross, and Y.-M. Wang. An Analysis of Browser Domain-isolation Bugs and a Light-weight \nTransparent De\u00adfense Mechanism. CCS 07. [10] Y. Chiba. Heap Protection for Java Virtual Machines. PPPJ \n06. [11] T. Chiueh, G. Venkitachalam, and P. Pradhan. Integrating Segmentation and Paging Protection \nfor Safe, Ef.cient and Transparent Software Extensions. SOSP 99. [12] D. G. Clarke, J. Potter, and J. \nNoble. Ownership Types for Flexible Alias Protection. OOPSLA 98. [13] E. Cohen and D. Jefferson. Protection \nin the Hydra Operating System. SOSP 75. [14] G. Czajkowski, L. Dayn`es, and B. Titzer. A Multi-user Virtual \nMachine. USENIX ATC 03. [15] P. Dasgupta, J. Richard J. LeBlanc, M. Ahamad, and U. Ra\u00admachandran. The \nClouds Distributed Operating System. IEEE Computer, 24(11):34 44, 1991. [16] D. Dean, E. W. Felten, and \nD. S. Wallach. Java Security: from HotJava to Netscape and Beyond. SP 96. [17] A. Dearle and D. Hulse. \nOperating System Support for Per\u00adsistent Systems: Past, Present and Future. Software Practice &#38; Experience, \n30(4):295 324, 2000. [18] J. Devietti, C. Blundell, M. Martin, and S. Zdancewic. Hard\u00adbound: Architectural \nSupport for Spatial Safety of the C Pro\u00adgramming Language. ASPLOS 08. [19] T. Ekman and G. Hedin. The \nJastAdd Extensible Java Com\u00adpiler. OOPSLA 07. [20] U. Erlingsson, M. Abadi, M. Vrable, M. Budiu, and \nG. Nec\u00adula. XFI: Software Guards for System Address Spaces. OSDI 06. [21] M. Flatt and R. Findler. Kill-safe \nSynchronization Abstrac\u00adtions. PLDI 04. [22] M. Flatt, S. Krishnamurthi, and M. Felleisen. Classes and \nMixins. POPL 98. [23] D. Grossman, J. G. Morrisett, T. Jim, M. W. Hicks, Y. Wang, and J. Cheney. Region-Based \nMemory Management in Cy\u00adclone. PLDI 02. [24] J. J. Heiss. The Multi-Tasking Virtual Machine: Building \na Highly Scalable JVM. Java Developers Forum, March 2005. [25] K. Hoffman. http://kevinjhoffman.com/ \nribbons/, 2011. [26] A. Igarashi, B. C. Pierce, and P. Wadler. Featherweight Java: a Minimal Core Calculus \nfor Java and GJ. ACM TOPLAS, 23(3):396 450, 2001. [27] F. Qin, S. Lu, and Y. Zhou. SafeMem: Exploiting \nECC-Memory for Detecting Memory Leaks and Memory Corrup\u00adtion During Production Runs. HPCA 05. [28] S. \nRajunas, N. Hardy, A. Bomberger, W. Frantz, and C. Lan\u00addau. Security In KeyKOS. SP 86. [29] M. Rinard, \nC. Cadar, D. Dumitran, D. Roy, T. Leu, and W. B. Jr. Enhancing Server Availability and Security Through \nFailure-Oblivious Computing. OSDI 04. [30] J. Rosenberg. The MONADS Architecture: A Layered View. POS \n90. [31] R. Shetty, M. Kharbutli, Y. Solihin, and M. Prvulovic. Heap-Mon: A Helper-thread Approach to \nProgrammable, Auto\u00admatic, and Low-overhead Memory Bug Detection. IBM Jour\u00adnal of Research and Development, \n50(2/3), 2006. [32] W. Shi, J. Fryman, G. Gu, H.-H. Lee, Y. Zhang, and J. Yang. InfoShield: a Security \nArchitecture for Protecting Information Usage in Memory. HPCA 06. [33] M. Swift, B. Bershad, and H. Levy. \nImproving the Reliability of Commodity Operating Systems. ACM TOCS, 23(1):77 110, 2005. [34] M. Takahashi, \nK. Kono, and T. Masuda. Ef.cient Kernel Sup\u00adport of Fine-Grained Protection Domains for Mobile Code. \nICDCS 99. [35] M. Tofte and L. Birkedal. A Region Inference Algorithm. ACM TOPLAS, 20(4):724 767, 1998. \n[36] G. Venkataramani, B. Roemer, Y. Solihin, and M. Prvulovic. MemTracker: Ef.cient and Programmable \nSupport for Mem\u00adory Access Monitoring and Debugging. HPCA 07. [37] R. Wahbe, S. Lucco, T. E. Anderson, \nand S. L. Graham. Ef.cient Software-based Fault Isolation. SIGOPS OSR, 27(5):203 216, 1993. [38] A. Wiggins, \nS. Winwood, H. Tuch, and G. Heiser. Legba: Fast Hardware Support for Fine-Grained Protection. ACSAC 03. \n[39] E. Witchel, J. Rhee, and K. Asanovic. Mondrix: Memory Isolation for Linux Using Mondriaan Memory \nProtection. SOSP 05. [40] K. Zhang, T. Zhang, and S. Pande. Memory Protection through Dynamic Access \nControl. MICRO 06.    \n\t\t\t", "proc_id": "2048066", "abstract": "<p>The need for programs to execute subcomponents in isolation from each other or with lower privileges is prevalent among today's systems. We introduce ribbons: a shared memory programming model that allows for more implicit sharing of memory than processes but is more restrictive than threads. Ribbons structure the heap into protection domains. Privileges between these protection domains are carefully controlled in order to confine computation. We propose RibbonJ, a backwards-compatible extension of Java, to easily create or port programs to use the ribbons model. We study the progress and isolation properties of a subset of the language. Building on JikesRVM we implement ribbons by leveraging existing memory protection mechanisms in modern hardware and operating systems, avoiding the overhead of inline security checks and read or write barriers. We evaluate efficiency via microbenchmarks and the DaCapo suite, observing minor overhead. Additionally, we refactor Apache Tomcat to use ribbons for application isolation, discuss the refactoring's design and complexity, and evaluate performance using the SPECweb2009 benchmark.</p>", "authors": [{"name": "Kevin J. Hoffman", "author_profile_id": "81541928856", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P2839184", "email_address": "kjhoffma@cs.purdue.edu", "orcid_id": ""}, {"name": "Harrison Metzger", "author_profile_id": "81490688180", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P2839185", "email_address": "hmetzger@cs.purdue.edu", "orcid_id": ""}, {"name": "Patrick Eugster", "author_profile_id": "81100562902", "affiliation": "Purdue University, West Lafayette, IN, USA", "person_id": "P2839186", "email_address": "peugster@cs.purdue.edu", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048091", "year": "2011", "article_id": "2048091", "conference": "OOPSLA", "title": "Ribbons: a partially shared memory programming model", "url": "http://dl.acm.org/citation.cfm?id=2048091"}