{"article_publication_date": "10-22-2011", "fulltext": "\n F4F: Taint Analysis of Framework-based Web Applications Manu Sridharan1 Shay Artzi1 Marco Pistoia1 \nSalvatore Guarnieri2 Omer Tripp2,3 Ryan Berg2 1IBM T. J. Watson Research Center, Yorktown Heights, NY \nUSA 2IBM Software Group, Littleton, MA USA 3Tel-Aviv University, Tel Aviv, Israel {msridhar,artzi,pistoia,sguarni}@us.ibm.com, \nomert@il.ibm.com, ryan.berg@us.ibm.com Abstract This paper presents F4F (Framework For Frameworks), a \nsystem for effective taint analysis of framework-based web applications. Most modern web applications \nutilize one or more web frameworks, which provide useful abstractions for common functionality. Due to \nextensive use of re.ec\u00adtive language constructs in framework implementations, ex\u00adisting static taint \nanalyses are often ineffective when applied to framework-based applications. While previous work has \nincluded ad hoc support for certain framework constructs, adding support for a large number of frameworks \nin this manner does not scale from an engineering standpoint. F4F employs an initial analysis pass in \nwhich both appli\u00adcation code and con.guration .les are processed to generate a speci.cation of framework-related \nbehaviors. A taint anal\u00adysis engine can leverage these speci.cations to perform a much deeper, more precise \nanalysis of framework-based ap\u00adplications. Our speci.cation language has only a small num\u00adber of simple \nbut powerful constructs, easing analysis engine integration. With this architecture, new frameworks can \nbe handled with no changes to the core analysis engine, yield\u00ading signi.cant engineering bene.ts. We \nimplemented speci.cation generators for several web frameworks and added F4F support to a state-of-the-art \ntaint-analysis engine. In an experimental evaluation, the taint analysis enhanced with F4F discovered \n525 new issues across nine benchmarks, a harmonic mean of 2.10X more issues per benchmark. Furthermore, \nmanual inspection of a subset of the new issues showed that many were exploitable or re.ected bad security \npractice. Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n11, October 22 27, 2011, Portland, Oregon, USA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0940-0/11/10. \n. . $10.00 Categories and Subject Descriptors D.2.4 [Software Engi\u00adneering]: Software/Program Veri.cation; \nD.2.5 [Software Engineering]: Testing and Debugging General Terms Languages, Security 1. Introduction \nTaint analysis has emerged as a useful technique for dis\u00adcovering security vulnerabilities in web applications \n[13 15, 18, 20]. Security taint analysis is an information-.ow analysis that automatically detects .ows \nof untrusted data into security-sensitive computations (integrity violations) or .ows of private data \ninto computations that expose in\u00adformation to public observers (con.dentiality violations). Information-.ow \nsecurity vulnerabilities account for six of the top ten security vulnerabilities according to the Open \nWeb Application Security Project (OWASP).1 Previous work has shown that taint analysis can effectively \nexpose such vulnerabilities in real-world web applications [13, 14, 18, 20]. Most modern web applications \nare built using one or more sophisticated web application frameworks. These frameworks are special software \nlibraries that simplify web application development by providing higher-level abstrac\u00adtions for common \ntasks. For example, many frameworks provide automatic population of user-de.ned data structures with \nHTTP request data and mechanisms to ease mixing of static HTML and dynamically generated content (see \n\u00a72 for further discussion). Unfortunately, static analysis of web applications is sig\u00adni.cantly hindered \nby their use of frameworks. Framework implementations often invoke application code using re.ec\u00adtion, \nbased on information provided in con.guration .les. Extensive use of re.ection causes well-known dif.culties \nfor static analysis. Real-world bug-.nding analyses often ignore re.ective code, but for framework-based \nweb applications this leads to many false negatives, since the application code is primarily invoked \nvia re.ection. Other techniques model re.ection usage based solely on code analysis [4, 12], but 1 http://owasp.org \n this is also ineffective for our target applications, as the con\u00ad.guration .le information used by \nthe frameworks cannot be precisely recovered via code analysis alone. Handling re.ec\u00adtion via code analysis \ncan also cause scalability problems, as excessively over-approximate re.ection handling can lead to analysis \nof a large amount of unreachable code. Besides re\u00ad.ection, complex string manipulation and data structure \nus\u00adage in framework code can also cause static analysis dif.\u00adculties, to be illustrated in detail in \n\u00a72. Some previous analyses have integrated ad hoc handling of certain web framework features [6, 20], \nbut none provide a general solution for handling the large number of frame\u00adworks in common use today. \nWikipedia lists nearly 100 web frameworks, including more than 30 for Java alone [23]. Fur\u00adthermore, \nindividual frameworks can also vary signi.cantly between versions, necessitating special handling for \neach version. Handling each individual framework through modi\u00ad.cation of the core static analysis engine \ndoes not scale from an engineering standpoint, since it requires a developer with signi.cant analysis \nexpertise. Also, some previous work on framework handling was based on code analysis alone [20], making \nframework features heavily dependent on con.gura\u00adtion .le data impractical to handle. In this paper, \nwe present Framework for Frameworks (F4F), a novel solution that augments taint analysis engines with \nprecise framework support and allows for handling new frameworks without modifying the core analysis \nengine.2 In F4F, a framework analyzer .rst generates a speci.cation of an application s framework-related \nbehavior in a simple lan\u00adguage called WAFL (for Web Application Framework Lan\u00adguage). The WAFL speci.cation \nis generated based on both lightweight code analyses and information found in other relevant artifacts \nsuch as con.guration .les. The taint anal\u00adysis then uses the WAFL speci.cation to enhance its analy\u00adsis \nof the application. This approach has several advantages over previous work: By utilizing con.guration \n.le data, F4F can yield a far more precise and complete handling of framework se\u00admantics than previous \napproaches. Additionally, con.g\u00aduration .le data can enhance the usefulness of the issues reported by \nanalysis, e.g., by enabling the association of each issue with the URLs that cause the corresponding \ncode to run.  With F4F, the analysis engine need only understand WAFL speci.cations, not the details \nof handled web frameworks, making the engine design cleaner. Further\u00admore, WAFL was carefully designed \nto make adding F4F support to an existing taint analysis straightforward.  WAFL speci.cation generators \ncan be written by de\u00advelopers unversed in the details of the analysis engine,  2 Although many of our \ntechniques could be generalized to other analyses, in this paper we focus concretely on how to use F4F \nfor taint analysis, due to its importance for web application security. greatly easing the process of \nhandling new frameworks. The speci.cations could even be generated by a user of the analysis tool, for \nexample to handle a custom frame\u00adwork not available to the tool developers. For analysis of languages \nsuch as Java and C#, handling of re.ection in the analysis engine can be much less con\u00adservative, as \nmuch of the relevant behavior is present in the WAFL speci.cation.3 This less conservative re.ec\u00adtion \nhandling can lead to scalability improvements and reduced false positives. We have implemented WAFL speci.cation \ngenerators for several frameworks and added WAFL support to a state-of\u00adthe-art taint analysis. In practice, \nwe found that lightweight intraprocedural analyses and con.guration .le processing suf.ced for generating \nspeci.cations of the framework\u00adrelated behaviors we encountered. Furthermore, we were able to add WAFL \nsupport to the taint analysis with very minimal changes to its code. In an experimental evalua\u00adtion, \nwe compared the effectiveness of the taint analysis on several applications with and without F4F. F4F \nmade a signi.cant impact: the analysis found 525 more issues with framework support enabled across our \nnine benchmarks, a harmonic mean of 2.10X more issues per benchmark. Fur\u00adthermore, manual inspection \nof a subset of the new issues showed that many were exploitable or re.ected bad security practice. We \nhave also added F4F support to a version of Ra\u00adtional AppScan Source Edition,4 a commercial taint-analysis \nproduct. This paper makes the following contributions: We de.ne WAFL, a simple speci.cation language \nfor expressing framework-related behaviors of web applica\u00adtions.  We describe automatic WAFL generators \nfor several pop\u00adular Java web frameworks.  We describe a non-intrusive technique for enhancing an existing \ntaint analysis engine to support WAFL speci.ca\u00adtions.  We present an experimental evaluation showing \nthat framework support enabled hundreds of new issues to be reported across a suite of benchmarks.  \nThe remainder of this paper is organized as follows. First, we present a detailed motivating example \nin \u00a72, showing the dif.culty of analyzing framework-based web applications and how F4F aids this analysis. \nWe then describe WAFL, our speci.cation language, in \u00a73. In \u00a74, we describe the WAFL generators we have \nbuilt thus far and what analyses were required in these generators. \u00a75 explains how we added support \nfor WAFL to a state-of-the-art taint analysis engine. 3 This could compromise soundness, but we know \nof no practical security analysis tool that is sound for Java in the presence of re.ection, native methods, \nand dynamic class loading. 4 http://www.ibm.com/software/rational/products/appscan/source/  \u00a76 presents \nour experimental evaluation of F4F on a range of web applications. Finally, \u00a77 discusses related work, \nand \u00a78 concludes and discusses future work. 2. Motivating Example In this section, we give some brief \nbackground on taint analysis and Java web frameworks, and then we illustrate how F4F can improve taint \nanalysis of framework-based applications via a detailed example. 2.1 Taint Analysis Security bugs in \nweb applications can often be discovered by taint analysis. Web-application vulnerabilities are often \ndue to either .ow of untrusted information into a security\u00adsensitive operation (integrity violations), \nor .ow of con\u00ad.dential information into publicly-observable parts of the application (con.dentiality \nviolations). Taint analysis is an information-.ow analysis that models both integrity and con.dentiality \nviolations in a natural way. The client speci\u00ad.es a set of security rules, where a rule is a triple comprised \nof sources, sinks and sanitizers. Sources introduce untrusted or con.dential data into the application. \nSinks represent either security-sensitive operations (for integrity rules) or release points (for con.dentiality \nrules). Finally, sanitizers represent operations that endorse the data, either by declas\u00adsifying it or \nby modifying it to make it benign. Given a rule r, taint analysis tries to .nd data-.ow paths in an applica\u00adtion \nfrom sources of r to sinks of r that do not pass through a sanitizer of r any such path is an indication \nof a potential security vulnerability. For a more detailed discussion of taint analysis, see previous \nwork, e.g., [13, 20].  2.2 Java Web Frameworks Java EE Java Platform, Enterprise Edition (Java EE, for\u00admerly \nJ2EE) [10] is the framework upon which most Java web applications and web frameworks are built. At its \ncore, a typical web application accepts a request from a client, performs some computation (possibly \ninteracting with a database), and sends a response back to the client (usually HTML and JavaScript). \nThe goal of a web framework is to provide abstractions that ease programming the more te\u00addious, error-prone \nparts of this process. Java EE provides several such abstractions, two of which are particularly im\u00adportant \nfrom a security perspective: servlets and Java Server Pages (JSPs). In a Java EE application, the logic \nfor each web page re\u00adsides in a servlet class, typically in a method with a signature like the following: \nvoid doGet(HttpServletRequest req, HttpServletResponse resp); Given a client request, Java EE invokes \ndoGet() on an appropriate servlet to generate the response. The Http-ServletRequest and HttpServletResponse \nparameters re\u00adspectively give typed interfaces to the request and response (a friendlier interface than \nraw network data). A deploy\u00adment descriptor con.guration .le describes which servlet the framework should \ninvoke for each URL, saving the de\u00adveloper from writing custom dispatch code. Also, servlets may use \nthe session state abstraction provided by Java EE to store data across multiple client requests, e.g., \nto maintain a shopping cart in an e-commerce application. Java Server Pages (JSPs) [11] ease the process \nof sending an HTML response to a client. In a servlet, HTML can be sent to the client by passing strings \nto a java.io.Writer object obtained from the HttpServletRequest, a rather low\u00adlevel API. In contrast, \nin a JSP .le, one writes the desired HTML directly, using special syntax to execute Java code and include \nits output in the HTML. The Java EE framework compiles JSPs to Java code that sends the contents of the \nJSP to the client when executed. A servlet can invoke a JSP by forwarding to the JSP s URL, passing data \nby storing it in the session state or in the HttpServletRequest object. In this manner, a developer can \nobtain some separation between the logic of handling a request (done in the servlet) and the rendering \nof the response (done in the JSP). The Struts Framework Apache Struts5 is a framework built atop Java \nEE, with higher-level abstractions to fur\u00adther ease web development. Like many other web frame\u00adworks, \nStruts encourages a model-view-controller (MVC) design [5], yielding a clean separation between the core \nlogic for handling a request (the controller), the rendering of the response (the view), and how state \nis communicated between the two (the model). At runtime, Struts connects the model, view, and controller \ncomponents based on settings in a con\u00ad.guration .le (to be illustrated in \u00a72.3). The top graph in Figure \n1 shows the .ow of server-side code that occurs when a Struts application processes a re\u00adquest. Initially, \nthe request is handled by internal Struts code (the .rst shaded node), which (1) parses the request URL \nto determine which controller should be invoked and (2) populates a form object of some user-de.ned type \n(speci\u00ad.ed in a con.guration .le) with data from the request. The term form object stems from the common \ncase of request data including values entered into a web form. Struts s auto\u00admatic form object population \nsaves the developer from writ\u00ading code to extract each piece of form data from the request, perform type \nconversions, etc. After form object population, Struts invokes the controller (the .rst oval, a sub-class \nof the Struts Action class), which reads the form object and performs necessary database interactions \nand business logic. The controller returns a view name, which Struts uses to for\u00adward to the appropriate \nview, again based on con.guration .le information (the second shaded node); this indirection enables \nthe view technology to be changed without modify\u00ading the controller code. Finally, the view (often a \nJSP) ren\u00adders the .nal response. 5 http://struts.apache.org/1.x/ \n\t\t\t", "proc_id": "2048066", "abstract": "<p>This paper presents F4F (Framework For Frameworks), a system for effective taint analysis of framework-based web applications. Most modern web applications utilize one or more web frameworks, which provide useful abstractions for common functionality. Due to extensive use of reflective language constructs in framework implementations, existing static taint analyses are often ineffective when applied to framework-based applications. While previous work has included ad hoc support for certain framework constructs, adding support for a large number of frameworks in this manner does not scale from an engineering standpoint.</p> <p>F4F employs an initial analysis pass in which both application code and configuration files are processed to generate a specification of framework-related behaviors. A taint analysis engine can leverage these specifications to perform a much deeper, more precise analysis of framework-based applications. Our specification language has only a small number of simple but powerful constructs, easing analysis engine integration. With this architecture, new frameworks can be handled with no changes to the core analysis engine, yielding significant engineering benefits.</p> <p>We implemented specification generators for several web frameworks and added F4F support to a state-of-the-art taint-analysis engine. In an experimental evaluation, the taint analysis enhanced with F4F discovered 525 new issues across nine benchmarks, a harmonic mean of 2.10X more issues per benchmark. Furthermore, manual inspection of a subset of the new issues showed that many were exploitable or reflected bad security practice.</p>", "authors": [{"name": "Manu Sridharan", "author_profile_id": "81100641428", "affiliation": "IBM T.J. Watson Research Center, Yorktown Heights, NY, USA", "person_id": "P2839322", "email_address": "msridhar@us.ibm.com", "orcid_id": ""}, {"name": "Shay Artzi", "author_profile_id": "81100175361", "affiliation": "IBM T.J. Watson Research Center, Yorktown Heights, NY, USA", "person_id": "P2839323", "email_address": "artzi@us.ibm.com", "orcid_id": ""}, {"name": "Marco Pistoia", "author_profile_id": "81100510307", "affiliation": "IBM T.J. Watson Research Center, Yorktown Heights, NY, USA", "person_id": "P2839324", "email_address": "pistoia@us.ibm.com", "orcid_id": ""}, {"name": "Salvatore Guarnieri", "author_profile_id": "81467671393", "affiliation": "IBM Software Group, Littleton, MA, USA", "person_id": "P2839325", "email_address": "sguarni@us.ibm.com", "orcid_id": ""}, {"name": "Omer Tripp", "author_profile_id": "81435610768", "affiliation": "IBM Software Group, Littleton, MA, USA", "person_id": "P2839326", "email_address": "omert@il.ibm.com", "orcid_id": ""}, {"name": "Ryan Berg", "author_profile_id": "81487641867", "affiliation": "IBM Software Group, Littleton, MA, USA", "person_id": "P2839327", "email_address": "ryan.berg@us.ibm.com", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048145", "year": "2011", "article_id": "2048145", "conference": "OOPSLA", "title": "F4F: taint analysis of framework-based web applications", "url": "http://dl.acm.org/citation.cfm?id=2048145"}