{"article_publication_date": "10-22-2011", "fulltext": "\n SHERIFF: Precise Detection and Automatic Mitigation of False Sharing Tongping Liu Emery D. Berger Department \nof Computer Science University of Massachusetts, Amherst Amherst, MA 01003 {tonyliu,emery}@cs.umass.edu \nAbstract False sharing is an insidious problem for multithreaded pro\u00adgrams running on multicore processors, \nwhere it can silently degrade performance and scalability. Previous tools for de\u00adtecting false sharing \nare severely limited: they cannot distin\u00adguish false sharing from true sharing, have high false pos\u00aditive \nrates, and provide limited assistance to help program\u00admers locate and resolve false sharing. This paper \npresents two tools that attack the problem of false sharing: SHERIFF-DETECT and SHERIFF-PROTECT. Both \ntools leverage a framework we introduce here called SHERIFF. SHERIFF breaks out threads into separate \npro\u00adcesses, and exposes an API that allows programs to perform per-thread memory isolation and tracking \non a per-page ba\u00adsis. We believe SHERIFF is of independent interest. SHERIFF-DETECT .nds instances of \nfalse sharing by comparing updates within the same cache lines by differ\u00adent threads, and uses sampling \nto rank them by performance impact. SHERIFF-DETECT is precise (no false positives), runs with low overhead \n(on average, 20%), and is accu\u00adrate, pinpointing the exact objects involved in false sharing. We present \na case study demonstrating SHERIFF-DETECT s effectiveness at locating false sharing in a variety of bench\u00admarks. \nRewriting a program to .x false sharing can be infeasi\u00adble when source is unavailable, or undesirable \nwhen padding objects would unacceptably increase memory consumption or further worsen runtime performance. \nSHERIFF-PROTECT mitigates false sharing by adaptively isolating shared up\u00addates from different threads \ninto separate physical addresses, effectively eliminating most of the performance impact of Permission \nto make digital or hard copies of all or part of this work for personal or classroom use is granted without \nfee provided that copies are not made or distributed for pro.t or commercial advantage and that copies \nbear this notice and the full citation on the .rst page. To copy otherwise, to republish, to post on \nservers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA 11, October \n22 27, 2011, Portland, Oregon, USA. Copyright c &#38;#169; 2011 ACM 978-1-4503-0940-0/11/10. . . $10.00 \nfalse sharing. We show that SHERIFF-PROTECT can improve performance for programs with catastrophic false \nsharing by up to 9\u00d7, without programmer intervention. Categories and Subject Descriptors D.1.3 [Software]: \nConcurrent Programming Parallel Programming; D.4.8 [Software]: Operating Systems Performance General \nTerms Performance, Measurement Keywords False Sharing, Multi-threaded 1. Introduction Writing multithreaded \nprograms can be challenging. Not only must programmers cope with the dif.culty of writing concurrent \nprograms (races, atomicity violations, and dead\u00adlocks), they must also make sure they are ef.cient and \nscal\u00adable. Key to achieving high performance and scalability is reducing contention for shared resources. \nHowever, threads can still suffer from false sharing when multiple objects that are not logically shared \nreside on the same cache line. When false sharing is frequent enough, the resulting ping\u00adponging of cache \nlines across processors can cause perfor\u00admance to plummet [5, 11]. False sharing can degrade appli\u00ad cation \nperformance by as much as an order of magnitude. Two trends the prevalence of multicore architectures \nand the expected increase in the number of multithreaded appli\u00adcations in broad use, and increasing cache \nline sizes are likely to make false sharing increasingly common. Locating false sharing requires tool \nsupport. Past false sharing detection tools operate on binaries, either via sim\u00adulation [22] or binary \ninstrumentation [10, 18, 25], and in\u00ad tercept all reads and writes (leading to slowdowns of up to 200\u00d7), \nor rely on hardware performance monitors and cor\u00adrelate cache invalidations with function calls [12, \n13] These false sharing detection tools suffer from problems that greatly limit their usefulness. They \ngenerate numer\u00adous false positives: addresses that appear shared but are just reused by the memory allocator, \ninstances of true sharing, and objects that were falsely shared so few times that they do not present \na performance bottleneck. They also provide little actionable information for programmers seeking to \nre\u00adsolve false sharing in their programs. Their reports range from a list of suspicious memory addresses \nwith functions that accessed them at some point [12, 22] to a single num\u00ad ber representing the overall \nfalse sharing rate for the entire program [10, 18, 25].  This paper presents two tools designed to help \nprogram\u00admers effectively address the challenges of locating and dealing with false sharing in multithreaded \napplications. SHERIFF-DETECT .nds and reports most cases of false shar\u00ading accurately (no false positives) \nand precisely, indicating the exact objects responsible for false sharing. When rewrit\u00ading an application \nto resolve false sharing is infeasible (be\u00adcause source is unavailable, or padding data structures would \nunacceptably reduce cache utilization and/or increase mem\u00adory consumption), SHERIFF-PROTECT can be used \nas a run\u00adtime system that eliminates all false sharing automatically. Both tools leverage a common framework \nwe introduce here called SHERIFF that enables them to operate ef.ciently. Figure 1 presents a sample \nwork.ow for using SHERIFF-DETECT and SHERIFF-PROTECT. A multithreaded program is .rst executed with SHERIFF-DETECT \nto uncover any false sharing. The programmer can then act on SHERIFF-DETECT s reports to correct false \nsharing by applying padding or aligning objects to cache line boundaries. If these .xes resolve the problem, \nthen the modi.ed program can be used with the standard pthreads library. If the .xes degrade performance \nor introduce excessive memory con\u00adsumption [25], or when it is impractical or impossible to modify the \nprogram, then SHERIFF-PROTECT can be used as a substitute runtime system to automatically eliminate false \nsharing. Contributions This paper makes the following contributions: It presents SHERIFF, a software-only \nframework that replaces the standard pthreads library and transforms threads into OS processes. It exposes \nan API that enables per-thread memory protection and optional memory iso\u00adlation on a per-page basis. \nWe believe SHERIFF is of in\u00addependent interest since it enables a range of possible ap\u00adplications, including \nlanguage support and enforcement of data sharing, software transactional memory, thread\u00adlevel speculation, \nand race detection [19], though we use SHERIFF here to build two tools focused on false sharing.  It \npresents SHERIFF-DETECT, a tool that .nds and re\u00adports instances of false sharing with high precision \nand with no false positives. SHERIFF-DETECT only reports actual false sharing not true sharing, and not \nartifacts from heap object reuse. It uses sampling to rank instances of false sharing by their potential \nperformance impact. SHERIFF-DETECT pinpoints false sharing locations by indicating offsets and global \nvariables or heap objects (with allocation sites), making false sharing relatively  Figure 1. A work.ow \nfor using SHERIFF-DETECT and SHERIFF-PROTECT. easy to locate and correct. SHERIFF-DETECT is gener\u00adally \nef.cient: on average, it slows down execution time by just 20%. It presents SHERIFF-PROTECT, a tool that \neliminates false sharing automatically without the need for code modi.cations or recompilation. SHERIFF-PROTECT \ncan dramatically increase performance in the face of false sharing. To our knowledge, SHERIFF-PROTECT \nis the .rst false sharing resistant runtime for shared-memory multithreaded programs. We evaluate SHERIFF-DETECT \nand SHERIFF-PROTECT over a range of applications, including the Phoenix and PAR-SEC benchmark suites; \nthe latter is designed to be represen\u00adtative of next-generation shared-memory programs for chip\u00admultiprocessors \n[4]. We show that SHERIFF-DETECT can successfully guide programmers to the exact sources of false sharing, \nand use its results to remove false sharing in several applications. We also apply SHERIFF-PROTECT to \nautomati\u00adcally mitigate false sharing in these applications; in one case, an applicaton suffering from \ncatastrophic false sharing runs 9\u00d7 faster with SHERIFF-PROTECT than with the standard pthreads library. \nOutline The remainder of this paper is organized as follows. Sec\u00adtion 2 describes key related work. Section \n3 describes SHER-IFF s mechanisms and algorithms in detail. Section 4 de\u00ad scribes the SHERIFF-DETECT \ntool and how it works to lo\u00adcate false sharing problems. Section 5 presents the SHERIFF-PROTECT runtime \nsystem. Section 6 presents experimental results, including several case studies of using SHERIFF-DETECT \nto detect and guide the correction of false sharing. Finally, Section 7 concludes.  2. Related Work \nThe proliferation of multicore systems has increased interest in tool support to detect false sharing, \nsince standard pro.l\u00aders like OPro.le [17] or gprof [9] only report overall cache misses. Simulation \nand Instrumentation Approaches: Schinde\u00adwolf describes a system based on the SIMICS functional simulator \nthat reports full cache miss information, including invalidations caused by sharing [22]. Pluto uses \nthe Valgrind framework to track the sequence of load and store events on different threads and reports \na worst-case estimate of pos\u00adsible false sharing [10]. Similarly, Liu uses Pin to collect memory access \ninformation and then reports total false shar\u00ading miss information [18]. Independently and in parallel \nwith this work, Zhao et al. developed a tool designed to detect false sharing and other sources of cache \ncontention in multithreaded applica\u00adtions [25]. This tool uses shadow memory to track ownership of cache \nlines and cache access patterns. It is currently lim\u00adited to at most 8 simultaneous threads. Like Liu \nabove, it only reports an overall false sharing rate for the whole pro\u00adgram, placing the burden on programmers \nto examine the entire source base to locate any instances of false sharing. Unlike SHERIFF-DETECT, these \nsystems generally suf\u00adfer from high performance overhead (5 - 200\u00d7 slower) or memory overheads. They \ncannot differentiate true sharing from false sharing, yielding numerous false positives. Be\u00adcause they \noperate at the binary level, they can all be misled by aliasing due to memory object reuse. Finally, \nand most importantly, they do not point to the objects responsible for false sharing, limiting their \nvalue to the programmer. Sampling-Based Approaches: Intel s performance tuning utility (PTU) [12, 13] \nuses event-based sampling, allowing it to operate ef.ciently. PTU can discover shared physical cache \nlines, and can identify possible false sharing at the grain of individual function calls. PTU suffers \nfrom a high false positive rate caused by aliasing due to reuse of heap ob\u00adjects, and reports false sharing \ninstances that have no impact on performance. PTU cannot differentiate true from false sharing or pinpoint \nthe source of false sharing problems, unlike SHERIFF-DETECT. Section 6 contains an extensive empirical \ncomparison of PTU to SHERIFF-DETECT demon\u00adstrating PTU s relative shortcomings. Pesterev et al. describe \nDProf, a tool that leverages AMD s instruction-based sampling hardware to help pro\u00adgrammers identify \nthe sources of cache misses [20]. DProf requires manual annotation to locate data types and object .elds, \nand cannot detect false sharing when multiple ob\u00adjects reside on the same cache line. By contrast, SHERIFF-DETECT \nis architecture independent, requires no manual intervention, and precisely identi.es false sharing regardless \nof the .ow of data or which data types are involved. False Sharing Avoidance: In some restricted cases, \nit is possible to eliminate false sharing, obviating the need for detection. Jeremiassen and Eggers describe \na compiler trans\u00adformation that adjusts the memory layout of applications through padding and alignment \n[14]. Chow et al. describe an approach that alters parallel loop scheduling to avoid shar\u00ading [7]. The \neffectiveness of these static analysis based ap\u00ad proaches is primarily limited to regular, array-based \nscien\u00adti.c codes, while SHERIFF-PROTECT can prevent false shar\u00ading in any application. Berger et al. \ndescribe Hoard, a scalable memory allocator that can reduce the likelihood of false sharing of distinct \nheap objects [1]. Hoard limits accidental false sharing of entire heap objects by making it unlikely \nthat two threads will use the same cache lines to satisfy memory requests, but this has no effect on \nfalse sharing within individual heap objects, which SHERIFF-PROTECT avoids. Other Related Work: SHERIFF \nadopts the process-as\u00adthread model as exempli.ed by Grace [2] but otherwise differs from it in semantics, \ngenerality, and goals. Grace is a process-based approach designed to prevent concurrency errors, such \nas deadlock, race conditions, and atomicity errors by imposing a sequential semantics on speculatively-executed \nthreads. Grace supports only fork\u00adjoin programs without inter-thread communication (e.g., condition variables \nor barriers), and rolls back threads when their effects would violate sequential semantics. SHERIFF extends \nGrace to handle arbitrary multithreaded programs; for example, Grace is incompatible with any ap\u00adplications \nthat employ inter-thread communication, includ\u00ading the PARSEC benchmarks we examine here. SHERIFF ap\u00adplies \ndiffs at synchronization points in the program to enable updates without rollback, giving it far greater \nperformance (but different semantics) than Grace. SHERIFF does not elim\u00adinate concurrency errors, but \ninstead allows applications to selectively track updates and isolate memory, enabling tools like SHERIFF-DETECT \nand SHERIFF-PROTECT. 3. SHERIFF SHERIFF is a functional replacement for the pthreads li\u00adbrary that extends \nit with two novel features: per-thread memory protection (allowing each thread to track memory accesses \nindependently of each other thread s accesses) and optional memory isolation (allowing each thread to \nread and write memory without interference from other threads). SHERIFF works through a combination of \nreplacing threads by processes [2] and page-level twinning and dif.ng [6, 15]. Replacing pthreads with \nprocesses is surprisingly inex\u00adpensive, especially on Linux where both pthreads and pro\u00adcesses are invoked \nusing the same underlying system call. Process invocation can actually outperform threads because operating \nsystems initially assign threads to the invoking CPU to maximize locality, while it spreads processes \nacross all CPUs [2]. To achieve the effect of shared memory, SHER\u00ad\n\t\t\t", "proc_id": "2048066", "abstract": "<p>False sharing is an insidious problem for multithreaded programs running on multicore processors, where it can silently degrade performance and scalability. Previous tools for detecting false sharing are severely limited: they cannot distinguish false sharing from true sharing, have high false positive rates, and provide limited assistance to help programmers locate and resolve false sharing.</p> <p>This paper presents two tools that attack the problem of false sharing: Sheriff-Detect and Sheriff-Protect. Both tools leverage a framework we introduce here called Sheriff. Sheriff breaks out threads into separate processes, and exposes an API that allows programs to perform per-thread memory isolation and tracking on a per-page basis. We believe Sheriff is of independent interest.</p> <p>Sheriff-Detect finds instances of false sharing by comparing updates within the same cache lines by different threads, and uses sampling to rank them by performance impact. Sheriff-Detect is precise (no false positives), runs with low overhead (on average, 20%), and is accurate, pinpointing the exact objects involved in false sharing. We present a case study demonstrating Sheriff-Detect's effectiveness at locating false sharing in a variety of benchmarks.</p> <p>Rewriting a program to fix false sharing can be infeasible when source is unavailable, or undesirable when padding objects would unacceptably increase memory consumption or further worsen runtime performance. Sheriff-Protect mitigates false sharing by adaptively isolating shared updates from different threads into separate physical addresses, effectively eliminating most of the performance impact of false sharing. We show that Sheriff-Protect can improve performance for programs with catastrophic false sharing by up to 9&#215;, without programmer intervention.</p>", "authors": [{"name": "Tongping Liu", "author_profile_id": "81444607968", "affiliation": "University of Massachusetts, Amherst, Amherst, MA, USA", "person_id": "P2839118", "email_address": "tonyliu@cs.umass.edu", "orcid_id": ""}, {"name": "Emery D. Berger", "author_profile_id": "81100228645", "affiliation": "University of Massachusetts, Amherst, Amherst, MA, USA", "person_id": "P2839119", "email_address": "emery@cs.umass.edu", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048070", "year": "2011", "article_id": "2048070", "conference": "OOPSLA", "title": "SHERIFF: precise detection and automatic mitigation of false sharing", "url": "http://dl.acm.org/citation.cfm?id=2048070"}