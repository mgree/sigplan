{"article_publication_date": "10-22-2011", "fulltext": "\n Flexible Object Layouts Enabling Lightweight Language Extensions by Intercepting Slot Access Toon Verwaest \nMircea Lungu Camillo Bruni Oscar Nierstrasz RMoD, INRIA Lille -Nord Europe, France Software Composition \nGroup, University of Bern, http://rmod.lille.inria.fr Switzerland http://scg.unibe.ch  Abstract Programming \nidioms, design patterns and application li\u00adbraries often introduce cumbersome and repetitive boiler\u00adplate \ncode to a software system. Language extensions and external DSLs (domain speci.c languages) are sometimes \nintroduced to reduce the need for boilerplate code, but they also complicate the system by introducing \nthe need for lan\u00adguage dialects and inter-language mediation. To address this, we propose to extend the \nstructural re.ec\u00adtive model of the language with object layouts, layout scopes and slots. Based on the \nnew re.ective language model we can 1) provide behavioral hooks to object layouts that are triggered \nwhen the .elds of an object are accessed and 2) simplify the implementation of state-related language \nexten\u00adsions such as stateful traits. By doing this we show how many idiomatic use cases that normally \nrequire boilerplate code can be more effectively supported. We present an implementation in Smalltalk, \nand illustrate its usage through a series of extended examples. Categories and Subject Descriptors D.3.4 \n[Programming Language]: Processors Interpreters, Runtime environments; D.3.3 [Programming Language]: \nLanguage Constructs and Features; D.3.2 [Programming Language]: Language Class\u00adifications Very high-level \nlanguages General Terms Re.ection Keywords Smalltalk, Structural Re.ection, Metaobject Protocol, Traits \nPermission to make digital or hard copies of all or part of this work for personal or classroom use is \ngranted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n11, October 22 27, 2011, Portland, Oregon, USA. Copyright &#38;#169; 2011 ACM 978-1-4503-0940-0/11/10. \n. . $10.00 1. Introduction Object-oriented programming languages (OOPL) are highly effective as modeling \nlanguages. Features including classes and inheritance can be used to model concepts at a high level of \nabstraction, normally leading to compact and con\u00adcise code. Unfortunately there are many situations in \nwhich idiomatic programming constructs nevertheless lead to ver\u00adbose boilerplate code. Consider, for \nexample, the need in certain applications to model .rst-class relationships between objects. Since no \nmainstream OOPL provides .rst-class relationships as a pro\u00adgramming construct, they must be laboriously \nsimulated in code. Even if we were to develop a library to implement re\u00adlationships, a relatively large \namount of boilerplate code will be required to properly con.gure the relationships and to en\u00adsure that \nall access to the related .elds triggers the library. A possible solution is to extend our programming \nlanguage to provide .rst-class support for relationships [6]. Although feasible, this is undesirable \nfor various reasons: Language extensions that change the syntax and semantics of a pro\u00adgramming language \nmake it harder for programmers to grasp the entire language. Moreover, language developers are bur\u00addened \nwith ensuring that all development tools of the host language properly support the language extension. \nIf we look more closely at this use case, we see that all boilerplate code concerning the management \nof .rst-class relationships is related to .eld initialization and access. By intercepting access to the \n.elds that are used to represent relationships, we can trigger the required behavior and avoid the need \nfor boilerplate code without the need to modify the syntax or semantics of the host language. We argue \nthat boilerplate code is a common problem aris\u00ading from idiomatic programming practices that attempt \nto compensate for the lack of missing meta-level abstractions. One such missing abstraction is the rei.cation \nof the .ne\u00adgrained composition of the object layouts as they are known to the language and its runtime. \nIn this paper we present as solution a .rst-class model of object layouts, layout scopes and slots that \ncombines the primitive object representation from the virtual machine with the implicit representation \nfrom the language and rei.es it. The resulting model is suf.ciently .ne-grained to provide re.ective \nhooks at all levels of abstraction and allows us to avoid boilerplate code that results from the lack \nof sub-class\u00adlevel reuse. The contributions of this paper are: proposing the .exible object layouts, \nour approach to modelling instance variables through .rst-class slots,  presenting a classi.cation and \nexamples of customized slots and their associated behavior,  introducing and discussing an implementation \nof the .ex\u00adible object layouts in Smalltalk.  Outline In Section 2 we analyze related work and con\u00ad \nclude that boilerplate code can be avoided by intercepting .eld access. Section 3 introduces our approach \nof .exible object layouts in which object .elds are represented by .rst\u00adclass slots. In Section 4 we \npresent a series of examples of different kinds of slots with their associated behavior. Sec\u00ad tion 5 \nillustrates how .rst-class layout scopes are used to control the visibility of slots. Section 6 shows \nhow stateful traits are implemented using .rst-class layouts. In Section 7 we shed light on how to build \nand migrate classes based on layouts. Finally we sum up our .ndings in Section 8. 2. State of the Art \nVarious techniques in software engineering exist to to ad\u00address problems that stem from the lack of appropriate \npro\u00adgramming language abstractions. In this section we list sev\u00aderal techniques whose raison d etre is, \nat least partially, to address the lack of adequate abstractions for object state ma\u00adnipulation, access, \nand composition. 2.1 Language Extensions When application concerns cannot be properly expressed in a \nprogramming language, this leads to crosscutting boiler\u00adplate code. External DSLs [14, 16] are often \nused to ad\u00ad dress this problem. When external DSLs are tightly inte\u00adgrated into our programming language \nthey essentially be\u00adcome language extensions [18, 24]. However, application\u00ad speci.c extensions to a \nlanguage limit understandability, us\u00adability and portability. Mixins [9] and traits [4, 11] are language \nextensions built for reuse below the class-level. They promote removal of boilerplate code by extracting \nit to the introduced reusable components. Traits improve over mixins by requiring ex\u00adplicit con.ict resolution \nand avoiding lookup problems re\u00adsulting from multiple inheritance through the .attening property. While \nboth approaches support reuse related to the state of objects, the abstractions themselves are fairly \nheavy-weight and they require glue code, another form of boilerplate code, to con.gure the .nal class. \n Aspect oriented programming [17], a language extension in itself, addresses the problem of cross-cutting \nconcerns re\u00adlated to behaviour in a system. However, it does not address the cross-cutting problems regarding \nstate. 2.2 Meta Modeling As opposed to language extensions meta modeling focuses on describing data \nby generally relying on existing language features. These meta descriptions don t interfere with the \ncore language and thus are generally decoupled from the actual objects they describe. However by only \naccessing data only through the meta model it is possible to alter access using .rst-class objects. Magritte \n[23] is a meta modelling framework mainly used together with Seaside [5]. Magritte is used to describe \nat\u00ad tributes, relationship and their constraints. All descriptions are provided as .rst-class Smalltalk \nobjects. Unlike the pre\u00advious two examples, Magritte provides a complete interface to read and write \nattributes of an instance through its meta descriptions. A favorable property of Magritte is, that it \nis meta-descriptions are described in terms of themselves. This way it is possible to rely on the same \ntools to work with in\u00adstances and with the model themselves. Magritte and meta-modelling tools in general \noverlap in many regions with our approach of .rst-class layouts, scopes and slots. However these tools \nare built on top of an exist\u00ading language and not into it. For instance Magritte s meta description are \ndecoupled from the classes of an object. Hence the objects themselves won t directly bene.t from their \nadded meta-descriptions. For instances it is still pos\u00adsible to use direct instance variable access inside \nan instance and assign values which con.ict with the well-de.ned meta\u00addescription. Thus meta-modelling \nframeworks show only the same behavior as .rst-class slots when attributes of objects are accessed solely \ntrough the meta-descriptions. But due to the decoupled implementation this is not enforced and rather \nrelies on the discipline of the programmer. 2.2.1 Annotations Several programming languages support annotations \nto at\u00adtach metadata to program structure. Java annotations, avail\u00adable since version 5.0 of the language, \nare probably the most prominent example. Annotations are generally a way to di\u00adrectly attach meta information \nto source elements. Later on the information in the annotations can be queried using a re.ection API. \nIn this sense annotations cannot be used di\u00adrectly to alter state access. However it is possible to provide \nnew tools which use annotation to control access and vali\u00addate the state of a model. In Java, annotations \ncan be sup\u00adplied for classes, methods and instance variables. Generally the annotations are only used \nfor adding meta-descriptions to the code. This metadata is then later accessed at runtime using re.ection. \nExample use-cases of annotations include unit-tests [3] and compile-time model constraints veri.ca\u00ad tion \n[12]. Annotations can be used to avoid manually written boil\u00aderplate code by generating code from the \nannotations. Java 6 features pluggable annotation processors that can hook into the compiler and transform \nthe AST. However it is not pos\u00adsible to directly modify the annotated sources. Using this in\u00adfrastructure \nit is only possible to create new class de.nitions that take slot de.nitions into account. Due to this \nlimitation it would be required to use the generated sources.  2.2.2 Object Relational Mapping A special \ncase of meta modelling worth mentioning is the use of structural and semantic meta information to model \nobject relational mapping [2]. Meta information is needed to provide a meaningful mapping from the objects \nto the database. However generally the objects should stay fully functional thus some part of the semantics \ndescribed in the meta information has to be available. Several object oriented front ends for relational \ndatabases support slot-like structures to describe the database .elds. Django [10] provides several types \nof .elds to describe and constrain what kind of data can be stored in the different instance variables. \nThis metadata is further used to create the table description. Although the .eld descriptors could be \ndirectly used to generate getters and setters which dynami\u00adcally validate the assigned data, this is \nonly done when se\u00adrializing the object to the database. As such relationship are only indirectly usable \nby storing and loading objects from the database. In the Active Record implementation used with Ruby \non Rails class-side methods are used to create descriptions of the .elds used in a table. These methods \nuse Ruby s re.ective capabilities to install getters and setters. In this sense there are no slots objects \nbut class-side methods to create slot descriptions.  2.3 First-Class Slots The Common Lisp Object System \n(CLOS) [7, 20] provides support for .rst-class slots1. Upon de.ning a class slots are described as part \nof the class de.nition. Internally CLOS uses this information to decide which slot class to use. Stan\u00addard \nCLOS always relies on the default slot class. In Per\u00adsistent CLOS (PCLOS) [19] the lookup was customized, \nto decide based on an extra keyword whether the default or the persistent slot class should be used. \nOn accessing slots the slot-value function is called. This is a generic function similar to the instVarAt: \nand instVarAt:put: methods in Smalltalk which can be used to directly access the .elds of an object using \nindices. It can be overridden to specialize slot access for the entire class. Internally this function \nrelies on a class-side method slot-value-using-class. This method can .nally specialize variable access \nto the type of class and the type of slot. 1 What we call .elds is called slots in CLOS. Slot is named \nslot-descriptor in CLOS. While CLOS already provides slots as one of the main missing rei.cations, standard \nCLOS does not provide a way to specialize instance variable access. As PCLOS shows it would however be \nfairly easy to hook into the protocol and allow programmers to provide custom slot metaobjects. CLOS \nhowever does not reify any instance structure beyond the level of slots. The E programming language [25] \nprovides slots as ob\u00ad jects representing the location where values of instance vari\u00adables are stored \nfor speci.c instances. This model is the clos\u00adest to what is presented in the paper. However it requires \nthe system to generate a multitude of objects for each user-level object, as all instance variables of \na single instance need their own metaobject. Since C and C++ provide references which can be used to \nmimic the availability of .rst-class slots. However such ref\u00aderences are simply lvalues providing direct \naccess to the raw memory. They cannot in.uence any access semantics, nor do they provide a higher-level \nabstraction that can be reused by other instance variables by bundling accessor methods. 2.4 Slots as \nMethods In Self [26] and Newspeak [8] everything is a message send. Slots are just special methods that \nreturn a value. This forces the user to always access values through a standardized inter\u00adface that can \n.exibly react to change. Even more interesting is that (Selfs version of subclasses) can change the behavior \nof slots just like methods can be specialized. Data becomes completely public however since objects cannot \nbe hidden. Since the accessors and initialization code have to be over\u00adridden separately, this implies \nthat their specialization has to be done over and over again for each individual slot. There is no standard \nway to bundle these methods in a specialized metaobject and install them as a single unit. 3. Flexible \nObject Layouts in a Nutshell Tools like compilers and class builders are needed to support programming \nlanguages. They are necessarily linked to the runtime that they target. If they are however too tightly \ncoupled to the assumptions made in the VM they become less extensible. By introducing .exible object \nlayouts as a new layer of abstraction between the programming language and its runtime, we decouple language \ntools and the runtime. This layer consists of three main concepts, directly related to the low-level \nview of how classes are constructed: layouts, layout scopes and slots. Layouts are the direct rei.cation \nof the object headers known to the VM. Just like VMs generally relate an object header to the class of \nan object, we relate a single layout in\u00adstance to each class. A class knows its layout, and the layout \nknows the class to which it belongs. As shown in Figure 1, layouts are installed in Class Behavior, the \nsuperclass of both Class and Metaclass, in the layout instance vari\u00ad  Figure 1. Flexible Object Layouts \nOverview able. The layout itself links back to the Class Behavior through the host instance variable. \nThe number of available layout types depends on the VM. Our prototype implementation is implemented in \nthe Pharo Smalltalk [21] dialect and provides a fairly typical set of object types: words, bytes, pointers, \nvariable sized, weak pointers, compiled methods, and small integers [15]. Pharo additionally relies on \ncompact classes to save memory for the instances of widely used classes by not keeping a pointer from \nan instance to a class. All this information encoded in the object header, which is normally only available \nto the VM, is now directly available in the .rst-class layout. Layout scopes group instance variables \nthat are declared in the same scope. Apart from a few special cases, most classes declare a collection \nof instance variables. Such classes are related to a layout with slots. A class inherits instance vari\u00adables \nfrom its superclass and potentially adds several itself. In our abstraction layer this is directly modeled \nusing layout scopes. The different layout scopes are nested in a hierar\u00adchy parallel to that of the class \nstructure. As Figure 1 shows, layout scopes are contained by layouts with slots. Slots are a .rst-class \nrepresentation of instance variables and their corresponding .elds2. They are referred to by a program \ns source code when their name is mentioned in an instance variable access. As such they can modify read \nand write access to .elds. In our current implementation the access semantics de.ned by the slots are \ndirectly inlined by the compiler. As Figure 1 shows, slots are contained by  layout scopes. Figure \n2. Scopes related to Dictionary Figure 2 illustrates our model using the layout of Dic\u00ad tionary. This \nparticular class builds instances with a to-#buckets, they are linked as slots from the related class \ntal of two .elds, related to the instance variables #tally scope. Since Object has no slots, its class \nscope is empty. and #buckets. Classes that build such instances with a A list of scopes generally ends \nin the empty scope, just like .xed size have a Pointer Layout. Since this layout is a lists end in nil. \nsubclass of Layout With Slots, it is related to a class scope. Since Dictionary is a subclass of Hashed \nCollec-4. First-Class Slots tion, the class scope of Dictionary has as parentScope While normally it \nis the compiler that is solely responsible the class scope of Hashed Collection. Because Hashed for mapping \ninstance variables to .elds, slots provide an ab-Collection has two direct instance variables #tally \nand straction that can assume this responsibility. This allows the slots to in.uence the semantics of \naccessing instance vari\u00ad 2 For clarity we refer to the memory location in an object as the .eld. The \ntoken in source code that refers to the .eld we call instance variable. ables. We distinguish between \nfour types of actions: initial\u00ad ization, reading, writing and migration. Slots can specialize the semantics \nof any of these four actions by overriding the related method in the slot class de.nition. We classify \nslots as follows: Primitive slots are the direct rei.cation of the link be\u00adtween instance variables \nand .elds.  Customized slots de.ne custom semantics for the four main actions related to slots: initialization, \nreading, writ\u00ading and migration.  Virtual slots have no direct representation in the related objects \nbut rather read state from an aliased .eld or derive their state in another way.  4.1 Primitive Slots \nPrimitive slots are metaobjects that simply bind an instance variable to a .eld index. Object subclass: \n#Slot layout: PointerLayout slots: { #index => Slot. #name => Slot. }. Slot >> initializeInstance: anInstance \nself write: nil to: anInstance Slot >> read: anInstance t anInstance instVarAt: index. Slot >> write: \naValue to: anInstance t anInstance instVarAt: index put: aValue. Listing 1. Default Slot Implementation \nInstance variables are by default replaced by standard Slot instances. Listing 1 shows the core implementation \nof the default Slot with the three actions for slots: Initialize: The method named initializeInstance: \nis called during object instantiation for all Slots. As in most languages the .elds of newly created \nobject are initialized with nil.  Read: The read: takes the object instance as an argu\u00adment and uses \nthe low-level instVarAt: to directly ac\u00adcess the .eld in the instance.  Write: The write:to: method \nworks similar to the write: method and delegates the write access to the low\u00adlevel instVarAt:put: operation. \n Notice that the slots used by the de.nition of Slot are such standard metaobjects, making the Slot \nde.nition a recursive one. As shown in Listing 1, to read out a standard slot we need to .rst access \nthe index slot of the slot. But to access the index slot, we need to be able to access the index slot, \nand so on. 3 This circularity is however easily broken by 3 This is similar to methods. They are conceptually \ninstances of the Method class. While this class could have a method telling the runtime how to execute \nthe method, this equally recurses in.nitely. letting the VM directly execute it. Slots break the recursion \nby directly inlining accessor code into the methods that refer to them. 4.2 Customized Slots Whereas \naccesses to primitive slots immediately translate into accesses to the related .eld, it is advantageous \nto be able to customize the semantics of accessing the slot into some\u00adthing more elaborate. There are \nfour main types of actions related to slots: initialization, read, write and migration. In standard object-oriented \ncode initialization of slots is handled directly in constructor methods. This implies that initialization \ncode needs to be duplicated for similar but dif\u00adferent instance variables, independent of the instance \nvari\u00adables being present on the same class. By providing an ini\u00adtialization mechanism on the slot metaobject \nthis initializa\u00adtion code is shared between all instance variables related to the same type of slot. \nThe initialization procedure can be fur\u00adther customized towards the class and .nally the instance. By \ncustomizing the reading and writing of slots we di\u00adrectly in.uence all source code that mentions the \nrelated in\u00adstance variable. A slot is read by using it as an rvalue. This triggers the protocol slot \nread: anInstance. Slots are written to by using it as an lvalue, triggering the protocol slot write: \naValue to: anInstance. This allows de\u00advelopers to create reusable components at the level of in\u00adstance \nvariables that avoid the need for boilerplate code to access them. Finally slots are related to class \nupdates. Whenever in\u00adstance variables of a class are removed or added this directly impacts the class \nand its subclasses, their methods and all their instances. While full-blown solutions to class updates \nare outside the scope of this paper, it is important to men\u00adtion that our model supports the construction \nof solutions for class updates. Slots can determine how instances should be migrated at the .eld-level. \n4.2.1 Type-checked Slots As a .rst example Listing 2 shows how we can easily build type-checked slots. \nSlot subclass: #TypedSlot layout: PointerLayout slots: { #type => TypedSlot type: Class. }. TypedSlot \n>> write: aValue to: anInstance (aValue isNil or: [aValue isKindOf: type]) ifFalse: [ InvalidTypeError \nsignal ] t super write: aValue to: anInstance. Listing 2. Typed Slot Implementation Although it is possible \nto provide the same functionality as slots by implementing accessor methods, this does not pro\u00advide the \nsame level of abstraction. It is not possible to en\u00adforce that all code indirectly accesses the state \nover a getter method. Each instance variable requiring preconditions to be ful.lled can also be used \nin a direct way, circumventing the tests. By relying on slots however, the programmer has only one single \nway access the instance variable. Here the guard can be enforced for all methods. A second advantage \nof using typed slots rather than re\u00adlying on modi.ed setter functions is that the semantics of the slot \nare rei.ed. In the case of typed-checked slots this al\u00adready provides metadata to gradually add typing \nto the partly dynamically-typed application, a technique also known as hardening [27]. By encapsulating \ntype checks in slots we can avoid code that would otherwise duplicated. In an untyped language type checks \nwould either occur at instance variable write or in setter methods. Since we can even create a speci.c \nslot class for a speci.c, for example PositiveIntegerSlot, there is no need to explicitely type check \ninstance variables anymore.  4.2.2 First-class Relationships Using slots it is possible to model .rst-class \nrelationships that integrate seamlessly into the existing language. We model relationships by modeling \nboth possible sides of one-to-one, one-to-many and many-to-many relationships by de.ning a One Slot and \na Many Slot. To complete the relationship such slots will then have another one or many slot as opposite \nslot. Listing 3 implements two classes Boss and Clerk that are in a one-to-many relationship. A boss \nhas a staff of many clerks, but a clerk just has a single boss. In step 1 of Figure 3 we create one instance \nof the Boss class and N Clerk instances. In step 2 we set the boss of c1 and c2. This makes the boss \nhave two clerks as his staff, and the two clerks have a boss. All the other clerks are unaffected. In \nstep 3 we overwrite the staff by the array of clerks c3 till cN. This breaks the relationship between \nthe boss and c1 and c2 and creates new relationships with the clerks c3 till cN. If in step 4 we set \nthe staff of the boss to the empty array, all relationships are broken again. Object subclass: #Boss \nlayout: PointerLayout slots: { #staff => ManySlot opposite: #boss class: Clerk. } Boss >> staff: aCollection \nstaff := aCollection Object subclass: #Clerk layout: PointerLayout slots: { #boss => OneSlot opposite: \n#staff class: Boss. } Clerk >> boss: aBoss Figure 3. Relationships in Action boss := aBoss Listing 3. \nMany Relationship Usage The code in Listing 4 shows the full implementation of the related classes. \nBoth ends of a relationship need to be typed, so we reuse the Typed Slot class from Listing 2. We extend \nit by adding a subclass Opposite Slot that knows that both slots that occur in a relationship refer back \nto each other using the opposite instance variable4. Finally the One Slot knows that it will contain \na single value, while the Many Slot has many values. To make the picture complete, in the case of a Many \nSlot we install a hot collection. This is a special kind of collection that knows that it has to update \nthe opposite side on every change. This is required since the collection itself is a way to avoid having \nto directly access the data via the slot. TypedSlot subclass: #OppositeSlot layout: PointerLayout slots: \n{ #opposite => OneSlot opposite: #opposite class: OppositeSlot. } 4 Notice that #opposite is also declared \nas a One Slot, referring back to itself. This is because a slot #y that has slot #x as its opposite, \nis by itself the opposite of #x. Slots that are in a relationship at the base-level are also in a relationship \non the meta-level. OppositeSlot subclass: #ManySlot layout: PointerLayout slots: { #oppositeHost => \nSlot. } ManySlot >> initializeInstance: anInstance |set| set := HotSet new oppositeSlot: opposite; myself: \nanInstance; type: self oppositeHost. super internalWrite: set to: anInstance. ManySlot >> write: aValueCollection \nto: anObject |hotSet| hotSet := self read: anObject. hotSet removeAll. aValueCollection ensureType: Collection. \nhotSet addAll: aValueCollection. OppositeSlot subclass: #OneSlot layout: PointerLayout slots: {} OneSlot \n>> write: aValue to: anObject (self internalRead: anObject) ifNotNilDo: [:oldValue| opposite remove: \nanObject from: oldValue]. super write: aValue to: anObject. aValue ifNotNil: [opposite add: anObject \nto: aValue]. Listing 4. Relationship Slot Implementation There are several advantages to using slots \nrather than speci.c language extensions. A library encapsulates the core behavior of relationships but \nstill requires a signi.cant amount of glue code to invoke all necessary hooks. However it is possible \nto dispense with glue code altogether by imple\u00admenting the .rst-class relationships directly as a language \nextension. But language changes require all the tools to be changed as well. Hence we argue in favor \nof an implementa\u00adtion which solely requires .rst-class slots that intercept read and write access. As \nshown in Listing 3 it is suf.cient to specify the relationship with slots.  4.3 Virtual Slots Virtual \nslots do not require a .eld in the related object but redirect access the data elsewhere. Alias slots \nare a trivial kind of virtual slot that simply redi\u00adrect all accesses to the aliased slots. Listing 5 \nshows the ba\u00ad sic implementation details of the alias slot. The basic ac\u00adcess operations read: and write:to: \nare forwarded to aliasedSlot. This is useful for providing a compatibility interface for legacy or external \ncode. Wrongly named vari\u00adable accesses can be redirected by specifying an alias to an existing slot. \nSince accesses to the slot are directly compiled as accesses to the aliased slot there is no extra overhead \nby using an alias slot over a normal one. VirtualSlot subclass: #AliasSlot layout: PointerLayout slots: \n{ #aliasedSlot => TypedSlot type: Slot. }.  AliasSlot >> read: anInstance t aliasedSlot read: anInstance \nAliasSlot >> write: aValue to: anInstance t aliasedSlot write: aValue to: anInstance Listing 5. Alias \nSlot Implementation Derived slots are computed from the values of other slots. They can be used for \nexample to provide a dual represen\u00adtation of values without having to duplicate support code or add explicit \ntransformation code. The code in Listing 6 shows a Color object which has three standard slots for the \nthree color compounds red, green and blue. The fourth slot is a virtual slot combining the three compounds \ninto a sin\u00adgle integer value. The RGBSlot internally links to the three other color components, denoted \nby the slots named #r, #g and #b. Internally the RGBSlot uses these slots as sources and transforms the \ninput and output to represent one single integer value. On assignment the RBG Slot splits the written \ninteger value into the three compounds and forwards them to the corresponding slots. On read access the \nsingle integer value is computed from the three other slots. By reading from the rgb instance variable \nthe full combined integer value is read. This has the advantage over a normal method invocation in that \nit can be directly inlined by the compiler and that it stays private to the class. Whenever this dual \nnumber representation is required elsewhere it is suf.cient to copy over the RGB Slot and thus the slot \nhelps to reduce code duplication. VirtualSlot subclass: #RGBSlot layout: PointerLayout slots: { #redSlot \n=> TypedSlot type: Slot. #greenSlot => TypedSlot type: Slot. #blueSlot => TypedSlot type: Slot. }. RGBSlot \n>> read: aColor (((redSlot read: aColor) &#38; 0xFF) << 16) t + (((greenSlot read: aColor) &#38; 0xFF) \n<< 8) + ((blueSlot read: aColor) &#38; 0xFF).  RGBSlot >> write: anInt to: aColor redSlot write:((anInt \n&#38; 0xFF0000) >> 16) to: aColor. greenSlot write:((anInt &#38; 0x00FF00) >> 8) to: aColor. blueSlot \nwrite: (anInt &#38; 0x0000FF) to: aColor. Object subclass: #Color layout: PointerLayout slots: { #r \n=> PositiveIntSlot limit: 0xFF. #g => PositiveIntSlot limit: 0xFF. #b => PositiveIntSlot limit: 0xFF. \n#rgb => RGBSlot redSlot: #r  greenSlot: #g blueSlot: #b. }. Listing 6. RGB Color Slot Implementation \n5. First-Class Layout Scopes In our system a layout consists of layout scopes, which themselves again \ncan contain slots. Layout scopes provide a level of reusable object semantics that is orthogonal to the \nstandard reuse through subclassing. They are responsible for providing access to instance variables and \nrequiring the .elds in the .nal instance. This allows them to in.uence the visibility of slots while \nstill requiring enough space for all slots in the .nal instances. By creating custom layout scopes we \ncan implement more complex use-cases which would otherwise require boilerplate code. The two core scopes, \nthe empty scope and the class scope are shown in Figure 1. As a default for each class a class scope \nis generated and link to a parent scope which holds the slots form the superclass. These layout scopes \nform a chain which eventually ends in an empty scope, as shown in Figure 2. With this approach we have \na compatible model to represent slot reuse through subclassing. So far we only assumed that the scopes \nwill contain exactly the slots from the class de.nition. The following examples however, show situations \nwhere new slots are introduced depending on the slots speci.ed in the class de.nition. We introduce addi\u00adtional \nslots by adding specialized scopes. Hence the class scopes always contain exactly the scops provided \nwith the class de.nition. In addition to the empty scope and class scopes two general groups of additional \nlayout scopes exist. slot hiding scopes only give access to a part of the actually declared slots, and \nslot issuing scopes give access to more slots than are declared by the scope. The following two examples \nboth introduce a new slots and thus are to be seen as slot issuing scopes. 5.1 Bit Field Layout Scope \nIn several languages the number of instances variables is re\u00adstricted, for instance many Smalltalk VMs \nlimit the number of instances variables to something less than 64 on many systems. When using many instance \nvariables that only use booleans it feels natural to combine them into a single .eld. Normally each instance \nvariable would require a full pointer to store a value that can be represented with a single bit. Combining \nthese variables into a single .eld helps to reduce the memory footprint of an object. In our implementation \nwe can combine multiple boolean .elds into a single bit .eld. This not only reduces the memory footprint \nbut also helps to speed up the garbage collection. Due to the single .eld the garbage collector has to \ntraverse fewer .elds. Listing 7 shows the implementation details of the BitSlot. Each BitSlot knows \nits storage location in the object de\u00adnoted by the bitSlot instance variable. The bitIndex is used to \nextract the corresponding bit out of the integer stored at the location of the bitSlot. In order to read \na boolean value, the BitSlot reads the full integer value from the bitSlot and masks out the corresponding \nbit. VirtualSlot subclass: #BitSlot layout: PointerLayout slots: { #bitlndex => PositiveIntegerSlot. \n#bitFieldSlot => TypedSlot type: BitHolderSlot. } read: anInstance mask := (0x01 >> index). t (bitFieldSlot \nread: anInstance) &#38; mask == mask. write: aBoolean to: anInstance |int| int := bitFieldSlot read: \nanInstance. int := int &#38; (0x01 >> index) invert. \"mask the bit\" int := int | (aBoolean asBit >> index) \n\"set the bit\" bitSlot write: int to: anInstance t aBoolean Listing 7. Bit Field Slot Implementation \nUsing bit .elds in a normal object is a matter of changing the slot de.nition. Instead of using the default \nSlot the BitSlot has to be used. Listing 8 shows the basic de.nition of an object using bit slots. When \nusing such an object up to 30 bit slots are combined into a single .eld. Figure 4 shows a transcript \nof how the boolean values are written to the single instance variable. If this were implemented without \nencapsulating the behavior in slots, the code of the write:to: or read: method would have to be copied \nat least into a getter or setter. In this case there is a single de.nition of the extraction semantics \nin the bit slot, which serves as a template. Object subclass: #BitObject layout: PointerLayout slots: \n{ boolean1 => BitSlot. boolean2 => BitSlot. ... booleanN => BitSlot. } Listing 8. Bit Object using Bit \nSlots Unlike the previous examples of slots the BitSlots re\u00adquire the layout to add a storage slot. \nAs a reminder, the BitSlots are virtual and hence do not occupy a .eld in the instance. The situation \nis further complication in that the number of storage slot is not .xed and depends on the num\u00adber of \nBitSlots, since each storage integer .xed number of bits. Instead of changing the current class scope, \nand thus obfuscating the original slots de.nition we add speci.c bit  Figure 4. A BitField Instance \nin Action Figure 5. Bit Field Scope Example scopes. In Figure 5 we see that the layout of the Bit Object \npoints to a normal class scope which contains the slot def\u00adinition mentioned in the class de.nition. \nInstead of linking directly to the class scope de.ning the slots of the superclass the parent scope is \nset to a special bit .eld scope. The bit scope internally contains the bit slot which is used to store \nthe different bits in it. Each virtual bit slot points to a non\u00advirtual bit .eld slot de.ned in a bit \nscope.  5.2 Property Layout Scope The previous example using bit .elds displayed that by using slots \nand slots scopes it is possible to transparently optimize the footprint of an object using boolean instance \nvariables. Here we will show how this technique can be used to selec\u00adtively but drastically transform \nthe layout of objects. JavaScript [13] and Python [22] use dictionaries as the internal representation \nfor objects. This enables the dynamic addition of instance variables and saves memory when there are \nmany unused instance variables. The simplicity of the object design comes with two major drawbacks however: \n1) typing mistakes in instance variable names are not easily detected, and 2) attribute access is dif.cult \nto optimize. In standard Smalltalk the number of instance variables is .xed up-front in the class. However \nwe easily overcome this limitation by using an intermediate dictionary which holds all the object s instance \nvariables. Without .rst-class layouts this would enforce us to use unchecked symbols as .eld names to \naccess the properties. Furthermore each instance variable access would have to be manually replace with \na dictionary access, which can be completely avoided in our case. In our implementation it is possible \nto bene.t from both worlds by only enabling dictionary-based storage where it is needed, while still \nproviding syntax checking for slots. Object subclass: #PropertyObject layout: PointerLayout slots: { \nfield => Slot property1 => PropertySlot. property2 => PropertySlot. ... propertyN => PropertySlot. } \nListing 9. Property Object using Property Slots Listing 9 provides a class de.nition of an object which \nuses a normal slot, named field and an arbitrary number of virtual slots that use a dictionary as storage \ntarget. Figure 6 shows an example usage of this property object. Note that the resulting instance uses \nonly two .elds. The property holder named dict is lazily .lled with the values for the different properties. \nSimilar to the previous bit .eld example we have to in\u00adtroduce a data holder slot depending on the types \nof speci\u00ad.ed slot. In this case we use a special property scope. Fig\u00ad ure 7 shows that the property scope \nholds an instance of a PropertyHoldertSlot which is required to reserve one .eld for the property storage. \nThis .eld holds a property dic\u00adtionary that maps property slots onto their values. Listing 10 shows how \naccesses are rewritten by property slots such that they access the state via the property dictionary. \nVirtualSlot subclass: #PropertySlot layout: PointerLayout slots: { #dictSlot => TypedSlot type: PropertyHolderSlot. \n}. PropertySlot >> read: anInstance t (dictSlot read: anInstance) at: name ifAbsent: [ nil ].  Figure \n6. Property Object in Action PropertySlot >> write: aValue to: anInstance t (dictSlot read: anInstance) \nat: name put: aValue. Listing 10. Property Slot Implementation This approach has three main advantages \nover the default behavior in Python or JavaScript. First the overall perfor\u00admance of the system does \nnot suffer since only the accesses of selected property slots are rewritten to go over the dictio\u00adnary. \nSecondly converting a property slot into a normal slot is matter of changing the type of slot. The only \ndif.culty being that special care has to be taken to convert the values in property dictionaries of existing \nlive instances back into normal .elds. Finally, in contrast to the standard Python or JavaScript approach \nour model minimizes the risk of run\u00adtime errors related to misspelled variable names by requir\u00ading the \nproperty slots to be explicitly speci.ed in the layout scope up-front. This allows us to provide proper \ncompile\u00adtime checks of property slots just like for all other Smalltalk slots. 6. Stateful Traits In \nthis section we show that by reifying the state of the objects and making it available in the programming \nlanguage new concepts that revolve around state can be implemented with less effort. As case-study we \nimplement stateful traits [11], a mechanism for sharing behavior and state in standard Figure 7. Property \nScope Example object-oriented systems which is orthogonal to subclassing. Stateful traits are components \nof reuse that are more .ne\u00adgrained than classes but generally larger than slots. Although a previous \nimplementation for Smalltalk exists it was more dif.cult to attain and includes ad-hoc solutions like \nrenaming instance variables to avoid name clashes. 6.1 Traits Fundamentally traits are used as collections \nof reusable methods that are installed on classes. Normally, installing a trait is implemented by .attening \nout the collection in the method dictionary of the target class. All con.icts result\u00ading from installing \na trait have to be resolved by the devel\u00adoper. This includes renaming methods, rejecting methods and \noverriding methods. On installing a trait, the trait object is copied before in\u00adstallation. The trait \nmethods are recompiled on the receiv\u00ading class to ensure correct semantics for superclass sends. Whenever \na trait-related method is modi.ed, the trait and all its users are noti.ed of the change and updated \naccordingly. A trait is uninstalled by removing all methods introduced by the trait. Finally whenever \na class is updated, its trait com\u00adposition is copied over from the previous version of the class to the \nnew version of the class. 6.2 Stateful Traits Stateful traits [4] add the possibility to de.ne state \nrelated to traits. When composing a stateful trait with a class not only the methods are installed, but \nalso the associated state is added to the class. Stateful traits are closely related to mixins  Figure \n8. Stateful Trait Example [9] except that they follow the con.ict-avoiding composition strategy of standard \ntraits.  6.3 Installing State of Stateful Traits By relying on our model of .rst-class layouts and scopes \nit becomes straightforward to extend traits with state. A state\u00adful trait is in essence a subclass of \nTrait which is extended with a layout. Where we previously declared a class to use a trait, we can now \nallow it to equally rely on a stateful trait. The behavior has to be mixed in the exact same location \nas standard traits. The only additional step required is the mix\u00ading of the state declared by the trait \nwith the state declared by the class. Figure 8 shows an example of such a stateful trait, the Sync Trait. \nIn addition to the provided methods, the stateful trait has a layout. This layout is linked to the related \ntrait scope that contains a single slot lock. The class builder is the tool responsible for installing \nthe state of a stateful trait. During this process we want to avoid name clashes with the state of the \ntarget class. To avoid complex renaming required by the original stateful trait work, we introduce a \nnew kind of layout scope in our model, the fork scope. A fork scope is a scope that does not only have \na parent scope, just like a normal class scope, but also a list of side scopes. The side scopes contribute \nto the .nal number of .elds that an associated object has, but they do not provide any visible slots. \nTheir state in the resulting object is essentially private to the owner of the scope. The trait scopes \nare then installed in the fork scope as side scopes. Figure 9 shows how the trait from Figure 8 is applied \nto the Sync Stream class. The modelling challenge when installing stateful traits is to correctly update \nthe .eld indices and scope instance vari\u00adable access. The index calculation has to take into account \nthe .elds in the superclass and other installed traits. For the normal operations on a class (e.g., compiling \na method inside the class) the visible slots will be computed by recursively traversing the parent links \nof the scopes, ag\u00adgregating the slots from the class scopes, but ignoring the side scopes of fork scopes. \nDuring compilation of the trait\u00adspeci.c behavior the trait providing the behavior is used as compilation \ntarget. This way, at compilation time, the class methods do not have access to the trait state and vice-versa. \n Figure 9. Stateful Trait with Fork Scopes  6.4 Installing Behavior of Stateful Traits After the class \nhas been successfully composed by the class builder, the methods of the used traits are installed. Stateful \ntrait methods are installed by updating them in the context of the installed trait copy, meaning in the \ncontext of the trait scope that was installed rather than the original trait scope. The indices of the \nslots in the installed scope are already updated to re.ect their installed offset. Recompiling methods \nin the installed scope will equally update them to re.ect this modi.cation. This is a simpli.cation of \nthe copy down technique [1] in that it does not try to save memory but always installs methods by copy. \nBytecode modi.cation can be used to reduce the runtime overhead of installing traits. 7. Class Building \nIn Smalltalk class de.nitions are themselves objects just like anything else. Modifying the class de.nitions \nimplies changing the layout of the class objects. Since a class is part of a class hierarchy this layout \nchange has to be propagated throughout the hierarchy. The class builder is the programming language tool \nthat supports this evolution of class de.nitions. It requires the most changes to support our layout-based \nmodel. However, after the changes the implementation becomes much simpler since its responsibilities \nare now distributed over the differ\u00adent types of layouts, layout scopes and slots, making it more adept \nto change:  A layout knows the rules the VM imposes on it, for example that it is not allowed to subclass \na class with byte array slots.  Slot scopes know exactly how many slots they have and which slots are \nsupposed to be visible.  Slots themselves know their access semantics and how they are related to .elds \nin instances.  By delegating the responsibility to those speci.c objects, we allow libraries to provide \nnew types of layouts or slots without modifying the class builder. The class builder will gladly support \nsuch metaobjects as long as they are poly\u00admorph to the primitive slot and layout. 7.1 Class Modi.cation \nModel The class builder itself is responsible for building or chang\u00ading classes for a class installer. \nThe builder constructs new classes from their de.nition and noti.es the installer about the new class. \nIn case the class installer already had a ver\u00adsion of the new class, the class builder builds up a class \nmodi.cation model of the difference between the old class and the new class. In case the old class had \nsubclasses and if the change impacts the layout of the .nal instances or its methods, this has to be \npropagated to the subclasses. For each subclass of a class modi.cation, a class modi.cation propagation \nis created. These propagations are cheaper than the normal propagation since the .elds they add have \nto be shifted by the difference in the number of .elds of the su\u00adperclass. All the other changes are \nthe same for the modi.ed class as for any of its subclasses, so it only needs to be cal\u00adculated once \nfor each class hierarchy. The class modi.cation is validated by checking if all new layouts are consistent. \nThis means that no slots should be introduced that mask or will be masked by existing slots, and that \nall layout types in the hierarchy are still compatible. A class modi.cation is calculated by asking the \nnew layout how it differs from the old layout. The layouts rely all of their slots, hidden and visible, \nto calculate the exact model. The layouts know which slots have been removed, added or were modi.ed in \nplace. Once the class modi.cation is ready we have all the information required to build an instance \nmigration model and a method modi.cation model. Once the modi.cation model is validated the class builder \nwill tell the class installer to perform the migration. This consists of copying over the related methods \nand updating their code, migrating instances to the new classes and .nally fully replacing the old version \nof the class hierarchy by the new hierarchy. Since everything is validated up front we know that this \nchange will not raise any con.icts and can apply the migration in a single transaction.  7.2 Instance \nMigration Instance migration is a fairly low-level operation that builds instances from a class-based \non other instances from an old version of the class. Our instance migration model is built directly from \nthe class modi.cation model-based on the knowledge of how slots have changed since the old version of \nthe class. Since instances are built at the level of .elds, our instance migration model is built up \nusing .eld modi.cation objects, specifying the semantics of how to initialize the .elds in the migrated \ninstances. There are .ve different types of .eld modi.cation objects: added, removed, modi.ed, shifted \nand unmodi.ed. Since the .eld modi.cation objects have access to the slot objects, they can forward this \ndecision back to the slot. This provides another new hook into the meta-system that allows users to control \nexactly what happens to their instances when software is updated. 7.3 Method Updating Similar to the \ninstance migration model, we build a method modi.cation model. Depending on how the instances changed \n(e.g., a .eld was moved) the method sources have to be up\u00addated as well. These modi.cations are again \ncalculated from the class modi.cation model. Whereas the instance migra\u00adtion builds new instances from \nold instances, the method modi.cation model is used by a method .eld updater that applies bytecode rewriting \non existing methods to re.ect the new layout of the instance. Whenever a .eld is removed, we replace \nthe access to the .eld by a message send to the removed .eld object. This will throw an exception at \nruntime when someone tries to read from the removed .eld instead of maybe reading from an invalid location. \nBy inserting the removed .eld object we also keep enough metadata to later on retract the inserted code \nand replace it by another access when the slot is reintroduced. 8. Conclusion The lack of proper abstractions \nreifying object state is of\u00adten the reason for the introduction of boilerplate code. To address this \nproblem we propose to extend the structural re\u00ad.ective model of the language with object layouts, layout \nscopes and slots. Layouts and slots are .rst-class representa\u00adtions of the assumptions which conventionally \nexist only as implicit contracts between the virtual machine and the com\u00adpiler. Layouts describe the \nobject layout of instances of a class while slots represent the conceptual link between in\u00adstance variables \nand .elds. Layout scopes reify how classes extend the layout of their superclass. We have shown that \n.rst-class slots encapsulate the de.nition of custom semantics for instance variable initialization, \naccess and migration (e.g., .rst-class relationships), promoting con\u00adsistent .ne-grained reuse,  and \nthat layout scopes support language extensions (e.g., stateful traits) that in.uence layout composition. \nWe have classi.ed slots into primitive slots, customized slots and virtual slots and provided examples \nfor each. The pro\u00adgramming language tool that requires the most fundamen\u00adtal change to support our layout-based \nmodel is the class builder, and we have shown how even its implementation becomes simpler by using slots. \nIn the future we would like to investigate further poten\u00adtial uses of our model (e.g., dynamic software \nupdates) and to see whether we can provide better tool support for soft\u00adware development based on the \nnew re.ective model (e.g., specialized object inspectors and debuggers). Code Availability. We have implemented \nall the concepts that we have presented in this article in Pharo Smalltalk. The code is released under \nan BSD licence and is available at http://www.squeaksource.com/ PlayOut.html Acknowledgments We would \nlike to thank Erwann Wernli and Niko Schwarz for kindly reviewing earlier drafts and providing constructive \nfeedback. We gratefully acknowledge the .nancial support of the Swiss National Science Foundation for \nthe project Synchronizing Models and Code (SNF Project No. 200020-131 827, Oct. 2010 -Sept. 2012). References \n[1] L. Bak, G. Bracha, S. Grarup, R. Griesemer, D. Griswold, and U. H\u00a8 olzle. Mixins in Strongtalk. In \nECOOP 02 Workshop on Inheritance, June 2002. [2] R. Barcia, G. Hambrick, K. Brown, R. Peterson, and K. \nBho\u00adgal. Persistence in the enterprise: a guide to persis\u00adtence technologies. IBM Press, .rst edition, \n2008. ISBN 9780768680591. [3] K. Beck and E. Gamma. Test infected: Programmers love writing tests. Java \nReport, 3(7):51 56, 1998. [4] A. Bergel, S. Ducasse, O. Nierstrasz, and R. Wuyts. State\u00adful traits and \ntheir formalization. Journal of Computer Lan\u00adguages, Systems and Structures, 34(2-3):83 108, 2008. ISSN \n1477-8424. doi: 10.1016/j.cl.2007.05.003. [5] A. Bergel, S. Ducasse, and L. Renggli. Seaside advanced \ncomposition and control .ow for dynamic web applications. ERCIM News, 72, Jan. 2008. [6] G. Bierman. \nFirst-class relationships in an object-oriented language. In ECOOP, pages 262 286. Springer-Verlag, 2005. \ndoi: 10.1007/11531142 12. [7] D. G. Bobrow, K. Kahn, G. Kiczales, L. Masinter, M. Ste\u00ad.k, and F. Zdybel. \nCommonloops: Merging lisp and object\u00adoriented programming. In Proceedings OOPSLA 86, ACM SIGPLAN Notices, \nvolume 21, pages 17 29, Nov. 1986. [8] G. Bracha. Executable grammars in Newspeak. Electron. Notes Theor. \nComput. Sci., 193:3 18, 2007. ISSN 1571-0661. doi: 10.1016/j.entcs.2007.10.004. [9] G. Bracha and W. \nCook. Mixin-based inheritance. In Pro\u00adceedings OOPSLA/ECOOP 90, ACM SIGPLAN Notices, vol\u00adume 25, pages \n303 311, Oct. 1990. [10] Django. Django. http://www.djangoproject.com. [11] S. Ducasse, O. Nierstrasz, \nN. Sch\u00a8arli, R. Wuyts, and A. P. Black. Traits: A mechanism for .ne-grained reuse. ACM Transactions on \nProgramming Languages and Systems (TOPLAS), 28(2):331 388, Mar. 2006. ISSN 0164-0925. doi: 10.1145/1119479.1119483. \n [12] G. Ferreira, E. Loureiro, and E. Oliveira. A java code an\u00adnotation approach for model checking \nsoftware systems. In Proceedings of the 2007 ACM symposium on Applied comput\u00ading, SAC 07, pages 1536 \n1537, New York, NY, USA, 2007. ACM. ISBN 1-59593-480-4. doi: 10.1145/1244002.1244330. [13] D. Flanagan. \nJavaScript: The De.nitive Guide. O Reilly &#38; Associates, second edition, Jan. 1997. ISBN 1-56592-234-4. \n[14] M. Fowler. Language workbenches: The killer-app for domain-speci.c languages, June 2005. http://www. \nmartinfowler.com/articles/languageWorkbench. html. [15] A. Goldberg and D. Robson. Smalltalk 80: the \nLanguage and its Implementation. Addison Wesley, Reading, Mass., May 1983. ISBN 0-201-13688-0. [16] P. \nHudak. Modular domain speci.c languages and tools. In P. Devanbu and J. Poulin, editors, Proceedings: \nFifth Interna\u00adtional Conference on Software Reuse, pages 134 142. IEEE Computer Society Press, 1998. \n [17] G. Kiczales, J. Lamping, A. Mendhekar, C. Maeda, C. Lopes, J.-M. Loingtier, and J. Irwin. Aspect-Oriented \nProgramming. In M. Aksit and S. Matsuoka, editors, Proceedings ECOOP 97, volume 1241 of LNCS, pages 220 \n242, Jyvaskyla, Fin\u00adland, June 1997. Springer-Verlag. [18] E. Meijer, B. Beckman, and G. Bierman. LINQ: \nreconcil\u00ading object, relations and XML in the .NET framework. In SIGMOD 06: Proceedings of the 2006 ACM \nSIGMOD inter\u00adnational conference on Management of data, pages 706 706, New York, NY, USA, 2006. ACM. \nISBN 1-59593-434-0. doi: 10.1145/1142473.1142552. [19] A. Paepcke. PCLOS: Stress testing CLOS experiencing \nthe metaobject protocol. In Proceedings OOPSLA/ECOOP 90, ACM SIGPLAN Notices, volume 25, pages 194 211, \nOct. 1990. [20] A. Paepcke. User-level language crafting. In Object-Oriented Programming: the CLOS perspective, \npages 66 99. MIT Press, 1993. [21] Pharo. Pharo. http://www.pharo-project.org. [22] Python. Python. http://www.python.org. \n[23] L. Renggli, S. Ducasse, and A. Kuhn. Magritte a meta\u00addriven approach to empower developers and \nend users. In G. Engels, B. Opdyke, D. C. Schmidt, and F. Weil, editors, Model Driven Engineering Languages \nand Systems, volume 4735 of LNCS, pages 106 120. Springer, Sept. 2007. ISBN 978-3-540-75208-0. doi: 10.1007/978-3-540-75209-7 \n8. [24] L. Renggli, T. G irba, and O. Nierstrasz. Embedding languages without breaking tools. In T. \nD Hondt, editor, ECOOP 10: Proceedings of the 24th European Conference on Object-Oriented Programming, \nvolume 6183 of LNCS, pages 380 404, Maribor, Slovenia, 2010. Springer-Verlag. ISBN 978-3\u00ad642-14106-5. \ndoi: 10.1007/978-3-642-14107-2 19. [25] M. Stiegler. The E language in a walnut, 2004. www.skyhunter.com/marcs/ewalnut.html. \n[26] D. Ungar and R. B. Smith. Self: The power of simplicity. In Proceedings OOPSLA 87, ACM SIGPLAN Notices, \nvol\u00adume 22, pages 227 242, Dec. 1987. doi: 10.1145/38765. 38828. [27] T. Wrigstad, P. Eugster, J. Field, \nN. Nystrom, and J. Vitek. Software hardening: a research agenda. In Proceedings for the 1st workshop \non Script to Program Evolution, STOP 09, pages 58 70, New York, NY, USA, 2009. ACM. ISBN 978\u00ad1-60558-543-7. \ndoi: 10.1145/1570506.1570513.    \n\t\t\t", "proc_id": "2048066", "abstract": "<p>Programming idioms, design patterns and application libraries often introduce cumbersome and repetitive boilerplate code to a software system. Language extensions and external DSLs (domain specific languages) are sometimes introduced to reduce the need for boilerplate code, but they also complicate the system by introducing the need for language dialects and inter-language mediation. To address this, we propose to extend the structural reflective model of the language with object layouts, layout scopes and slots. Based on the new reflective language model we can 1) provide behavioral hooks to object layouts that are triggered when the fields of an object are accessed and 2) simplify the implementation of state-related language extensions such as stateful traits. By doing this we show how many idiomatic use cases that normally require boilerplate code can be more effectively supported.</p> <p>We present an implementation in Smalltalk, and illustrate its usage through a series of extended examples.</p>", "authors": [{"name": "Toon Verwaest", "author_profile_id": "81388601470", "affiliation": "University of Berne, Bern, Switzerland", "person_id": "P2839303", "email_address": "verwaest@iam.unibe.ch___amp___gt;", "orcid_id": ""}, {"name": "Camillo Bruni", "author_profile_id": "81470648839", "affiliation": "INRIA Lille , Lille, France", "person_id": "P2839304", "email_address": "camillo.bruni@inria.fr", "orcid_id": ""}, {"name": "Mircea Lungu", "author_profile_id": "81310486353", "affiliation": "Univerisity of Berne, Bern, Switzerland", "person_id": "P2839305", "email_address": "lungu@iam.unibe.ch", "orcid_id": ""}, {"name": "Oscar Nierstrasz", "author_profile_id": "81100134506", "affiliation": "Univerisity of Berne, Bern, Switzerland", "person_id": "P2839306", "email_address": "oscar@iam.unibe.ch", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048138", "year": "2011", "article_id": "2048138", "conference": "OOPSLA", "title": "Flexible object layouts: enabling lightweight language extensions by intercepting slot access", "url": "http://dl.acm.org/citation.cfm?id=2048138"}