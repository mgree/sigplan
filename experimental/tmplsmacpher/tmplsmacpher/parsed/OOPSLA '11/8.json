{"article_publication_date": "10-22-2011", "fulltext": "\n Tool-supported Refactoring for JavaScript Asger Feldthaus* ToddMillstein Anders M\u00f8ller* Aarhus University \nUniversityofCalifornia, Aarhus University asf@cs.au.dk Los Angeles amoeller@cs.au.dk todd@cs.ucla.edu \n Max Sch\u00e4fer Frank Tip UniversityofOxford IBM Research max.schaefer@cs.ox.ac.uk ftip@us.ibm.com Abstract \nRefactoringis apopulartechniqueforimproving the struc\u00adture of existing programs while maintaining their \nbehav\u00adior. For statically typed programming languages such as Java, a wide variety of refactorings have \nbeen described, and tool support for performing refactorings and ensuring their correctnessis widelyavailablein \nmodernIDEs.Forthe JavaScriptprogramminglanguage,however,existing refac\u00adtoring tools are less mature and \noften unable to ensure that programbehaviorispreserved.Refactoring algorithmsthat have been developed \nfor statically typed languages are not applicabletoJavaScriptbecause ofitsdynamic nature. Weproposeaframeworkfor \nspecifying andimplement\u00ading JavaScript refactorings based on pointer analysis. We describe novel refactorings \nmotivated by best practice re\u00adcommendations for JavaScript programming, and demon\u00adstrate how they can \nbe described concisely in terms of queriesprovidedbyourframework.Experimentsperformed with aprototypeimplementation \non a suite of existing appli\u00adcations showthat our approachis well-suitedfordeveloping practicalrefactoringtoolsforJavaScript. \nCategories and Subject Descriptors D.2.7 [Distribution, Maintenance, andEnhancement]:Restructuring, reverse \nen\u00adgineering, andreengineering GeneralTerms Languages * Supported by the Danish Research Council for \nTechnology and Produc\u00adtion,grant no.09-064210. Supportedby theUSNationalScienceFoundation, awardCCF-0545850. \nPermission to make digital or hard copies of all or part of this work for personal or classroomuseisgranted \nwithoutfeeprovided that copiesarenot madeordistributed forpro.tor commercial advantage andthat copiesbearthis \nnotice andthefull citation onthe .rstpage.Tocopy otherwise,torepublish,topostonservers ortoredistribute \ntolists, requiresprior speci.cpermission and/or afee. OOPSLA 11, October22 27,2011,Portland,Oregon,USA. \nCopyright c &#38;#169;2011ACM978-1-4503-0940-0/11/10. . .$10.00  1. Introduction Refactoringistheprocess \nofimprovingthe structure ofsoft\u00adwareby applyingbehavior-preservingprogramtransforma\u00adtions[9], andhasbecomeanintegralpartof \ncurrentsoftware developmentmethodologies[4].Theseprogramtransforma\u00adtions,themselves called refactorings, \nare typicallyidenti.ed by a name, such as RENAME FIELD, and characterized by a set of preconditions under \nwhich they are applicable and a set of algorithmic steps for transforming the program s source code.Checkingthesepreconditions \nand applyingthe transformations manually is tedious and error-prone, so in\u00adterest in automated tool support \nfor refactorings has been growing.Currently,popularIDEs such asEclipse,1Visual\u00adStudio,2 and IntelliJ \nIDEA3 provide automated support for many common refactorings on various programming lan\u00adguages.In addition,thereis \nmuch recentresearchliterature on soundlyperforming a variety of refactorings(seeSec\u00adtion7for an overview). \nHowever, most research on refactoring has focused on statically typedlanguages, such as Java, for which \nexpress\u00ading the preconditions and source code transformations can take advantage of static type information \nand name resolu\u00adtion.Refactoringfordynamiclanguagessuch asJavaScript is complicatedbecauseidenti.ersare \nresolvedatruntime.Of thefewpreviousapproachesto refactoringfordynamically typedlanguages, the most well-developed \none canbefound intheSmalltalkRefactoringBrowser[24], whichrelies on a combination of runtimeinstrumentation \nandthe existence of a test suite to ensurethatbehaviorispreserved.By contrast, we aimfor a sound technique \nthatdoes not require compre\u00adhensivetest suites. Inthispaper, wepresentaframeworkfor refactoringpro\u00adgrams \nwritten in JavaScript, a dynamically typed scripting 1http://www.eclipse.org/ 2http://www.microsoft.com/visualstudio/ \n3http://www.jetbrains.com/idea/  languagethathasbecomethelinguafranca ofwebbrowsers. To understand why \nimplementing even simple refactorings inJavaScriptis more challengingthanimplementing analo\u00adgous refactoringsfor \nstaticallytypedlanguagessuchasJava, considertheRENAME FIELD refactoringinJava.Akey re\u00adquirement when \nrenaming .eld f of class C to g is to iden\u00adtify all references to that .eld so they can be renamed con\u00adsistently.Renaming \nall referencestoa .eldiseasy forJava programssince statictypeinformationis available.For ex\u00adample, an \nexpression of the form e.f where the static type of e isC de.nitelyreferstothe renamed.eld.In contrast,the \ncorrespondingtaskfor a RENAME PROPERTY refactoringin JavaScriptisingeneralimpossible to solve exactlybystatic \nmeans. While .elds in Java are statically declared within classde.nitions,propertiesinJavaScript are \nonly associated withdynamicallycreatedobjectsandarethemselvesdynam\u00adically created upon .rst write. Further \ncomplications arise from otherdynamicfeatures ofJavaScript, such as the abil\u00adity to dynamically delete \nproperties, change the prototype hierarchy, or reference apropertyby specifyingits name as adynamically \ncomputed string. We describe a methodology for implementing auto\u00admated refactorings on a nearly complete \nsubset of the EC\u00adMAScript5language[7],the chief omissionbeingdynam\u00adicallygenerated code(i.e., eval). \nOur approach relies on static pointer analysis for JavaScript to de.ne a set of gen\u00aderal analysis queries. \nWe have used this methodology to implementbothwell-knowntraditional refactorings, such as renaming,andnovelJavaScript-speci.crefactoringsthattar\u00adgetdesirableprogrammingidioms \nadvocatedbyin.uential practitioners[5]. In the process, we have devised various techniques to handle \nJavaScript s highly dynamic features and lack of static typing. For example, while naively over-or under\u00adapproximatingthe \nset of expressions e.f that mustbe modi\u00ad.ed when apropertyf is renamed(e.g., usinga conventional must-or \nmay-point-to analysis) would be unsound, we de\u00adscribe an algorithm that over-approximatesthis setin a \nsafe manner.We also ensure,throughpreconditionsthat canbe expressed in terms of the analysis queries, \nthat behavior is preserved in the presence of complex JavaScript features such as re.ective for-in loops, \n.rst-class functions, and prototype-basedinheritance.In cases where we cannotguar\u00adanteebehaviorpreservation, \nrefactorings arepreventedfrom beingapplied. We have speci.ed and implemented three refactorings using \nourapproach:RENAME (whichis ageneralizationof thepreviouslymentionedRENAME PROPERTY),ENCAPSU-LATE PROPERTY, \nand EXTRACT MODULE. We have eval\u00aduated thequality of ourimplementationsby applying these refactorings \nsystematically to a set of 50 benchmark pro\u00adgrams, measuring how often refactorings are applied suc\u00adcessfully \nand analyzing causes for rejection. Our results show that most refactorings areperformed successfully \nand rejectionsaregenerallyjusti.edbya realdangerofunsound\u00adness. This demonstrates that our approach is \na viable basis forimplementingrefactoringtoolsforJavaScript. In summary, the major contributions of this \npaper are as follows: We present a framework for specifying and imple\u00admentingJavaScriptrefactorings,basedona \nset ofanal\u00adysisqueries on topof apointer analysis.  Wegive concise,detailed speci.cations ofJavaScript\u00adspeci.c \nrefactorings expressed using theframework.To the best of our knowledge, we are the .rst to give such \nspeci.cationsin the context ofJavaScript.  We experimentally validate our approach by exercis\u00ading a \nprototype implementation of the framework and the refactorings on a set of JavaScript benchmarks. We \ndemonstrate that the preconditions of our speci.cations are not overly conservative, and that a relatively \nsimple pointer analysis appears to suf.ce in practice for many programs rangingin sizefrom300to1700lines \nofcode.  The remainder of this paper is organized as follows. Section 2 introduces a motivating example \nto illustrate the challenges that arise in de.ning several refactorings for JavaScript. Section 3 presents \na framework of analysis queriesbased onpointeranalysis.Section4 showshowthe three refactorings under \nconsideration are expressed using thisframework.Details oftheimplementation aredescribed inSection5,whileSection6givesan \nevaluationofour refac\u00adtorings on a set of JavaScript benchmarks. Related work is discussedinSection7.Finally, \nconclusions arepresentedin Section8.  2. MotivatingExamples Figure1 shows a smallJavaScriptprogram that \nwe will use toillustrate some of the challenges of refactoringJavaScript programs.Part(a) of the .gureshowsalibrary \nthatde.nes two shapes: circles and rectangles.Part(b) shows a client application that uses this library \nto draw a number of such shapes of randomly chosen sizes at random coordinates in the browser. We will \n.rst explain some key details of this program, and then discuss some of the issues raised by ap\u00adplying \nthe RENAME, ENCAPSULATE PROPERTY, and EX-TRACT MODULE refactorings. 2.1 AJavaScriptExampleProgram As \na prototype-based language, JavaScript does not have built-in support for classes. Instead, they are \ncommonly simulated using constructor functions. In the example of Figure 1, two constructor functions \nare provided: Circle (lines1 11)andRectangle (lines13 24).These enablethe programmer to create circle \nand rectangle objects using the new operator(e.g.,line 41).Constructorfunctions typically contain statements \nto initialize a number of object proper\u00adties, which are not explicitly declared but created upon the \nFigure 1. Shapes example.Part(a) shows a smalllibrary thatde.nes several types of shapes.Part(b) shows \na small client applicationthat uses thelibrarytodraw shapesin thebrowser.  1 f u n c t i o n C i r c \nl e( x , y , r , c ) { 28 f u n c t i o n r ( n ) { r e t u r n Math . r o u n d( M a t h . r a n d o \nm ( ) * n ) ; } 2 this . x = x ; 29 3 this . y = y ; 30 f u n c t i o n d r a w A l l( s h ) { 4 this \n. r a d i u s = r ; 31 var gr = 5 this . c o l o r = c ; 32 new j s G r a p h i c s( d o c u m e n t. \ng e t E l e m e n t B y I d( \" c a n v a s\" ) ) ; 6 this . d r a w S h a p e = f u n c t i o n ( g r \n) { 33 sh . m a p ( f u n c t i o n( s ) { s . d r a w S h a p e( g r ) ; } ) ; 7 gr . f i l l C i r \nc l e( new j s C o l o r( thi s . c o l o r) , 34 } 8 new j s P o i n t( this .x , this . y ) , 35 9 \nthis . r a d i u s) ; 36 var s h a p e s = [ ] ; 10 }; 37 for ( var i = 0; i < 500; i ++) { 11 } 38 var \no = new j s C o l o r( ) . r g b T o H e x( r ( 2 5 5 ) , r ( 2 5 5 ) , r ( 2 5 5 ) ) ; 12 39 s w i t \nc h( r ( 2 ) ) { 13 f u n c t i o n R e c t a n g l e( x , y , w , h , c ) { 40 case 0: 14 this . x = \nx ; 41 s h a p e s[ i ] = new C i r c l e( r ( 5 0 0 ) , r ( 5 0 0 ) , r ( 5 0 ) , o ) ; 15 this . y \n= y ; 42 b r e a k; 16 this . w i d t h = w ; 43 case 1: 17 this . h e i g h t = h ; 44 s h a p e s[ \ni ] = new R e c t a n g l e( r ( 5 0 0 ) , r ( 5 0 0 ) , r ( 5 0 ) , r ( 5 0 ) , o ) ; 18 this . c o \nl o r = c ; 45 a l e r t( s h a p e s[ i ] . g e t A r e a( ) ) ; 19 this . d r a w S h a p e = f u n \nc t i o n ( g r ) { 46 b r e a k; 20 gr . f i l l R e c t a n g l e( new j s C o l o r( this . c o l \no r) , 47 } 21 new j s P o i n t( this . x , this . y ) , 48 } 22 this . w i d t h , this . h e i g h \nt) ; 49 d r a w A l l( s h a p e s ) ; 23 }; 24 } 25 R e c t a n g l e. p r o t o t y p e. g e t A r \ne a = f u n c t i o n() { 26 r e t u r n t h i s . w i d t h * this . h e i g h t; 27 }; (a) (b) .rst \nwrite.Forexample,the constructorfor Circle creates andinitializesproperties x, y, radius, and color (lines2 \n5)byassigningthem values that arepassedin asparameters to thefunction, and similarfor Rectangle. Both \nalso create properties drawShape on line 6 and line 19 that contain functions to display the appropriate \ngeometric shape.4Thesefunctions can referto their receiver object using this expressions, and thus actlike \nmethods. Function Rectangle shows another way of emulating methods that makes use ofJavaScript sprototype-based \nna\u00adture.Functionslike Circle and Rectangle are themselves objects, and hence can have properties. In \nparticular, ev\u00adery function object has a prototype property that is im\u00adplicitly initialized to an empty \nobject. On line 25 we create a property getArea in this object by assigning it a func\u00adtion that computes \nthe area of a rectangle. Every object created by invoking new Rectangle(...) has an inter\u00adnal prototype \nproperty, which references the object stored inRectangle.prototype.When aproperty x islookedup onthis \nobject,butthe objectdoesnotitselfde.neproperty x, theinternalprototypeis searchedfor x instead. Thus, \nevery rectangle has both a getArea and a drawShape property, the latter de.ned in the object itself, \nthe former de.ned in its internal prototype. But while ev\u00adery rectangle has its own copy of drawShape \n(created on line19),thereis onlyone copy of getArea, whichis shared byall rectangles. 4The functions \nare implemented using jsDraw2D, a graphics library for JavaScript, whichis availablefromhttp://jsdraw2d.jsfiction.com/. \nFunction r (line 28) returns a random value between 0 andits argument n.Function drawAll (lines30 34)takes \nas an argument an array shapes, and online33 uses a closure and the map functiontoinvokedrawShape on \neach element of the array. Lines 36 49 contain a sequence of statements that are executed when the page \ncontaining the script is loaded.This code creates an array of500 randomly colored shapes of variouskinds,displayingthe \narea of every rectan\u00adgle upon creation on line 45, and then invokes drawAll to drawthese shapesin thebrowser. \nNote that in the invocation shapes[i].getArea() on line 45, the function to be invoked is found on the \ninternal prototype object of shapes[i],butits receiverobject(i.e., the value of this) is shapes[i] itself, \nnot the prototype object. This ensures, for instance, that the property access this.width in line 26 \nrefers to the property de.ned on line16. We will now discuss the issues that arise when three refactorings \nRENAME, ENCAPSULATE PROPERTY, and EXTRACT MODULE are applied to the example program ofFigure1.  2.2 \nRENAME We begin by considering some applications of the RE-NAME refactoring to the example program of \nFigure 1. In JavaScript, there are no property declarations. Although it is natural to think of the assignment \nto this.x in Circle asadeclaration,itisjust awriteaccesstoaproperty x that is created onthe .y sinceitdoesnotexistyet.Theabsence \nof declarations and static typing information makes refac\u00adtoring moredif.cultbecauseitis necessary todetermine \nall propertyexpressionsin aprogramthatmay refertothe same property and rename them consistently. We consider \na few examples:  The property expression this.x online2 in Circle can be renamed to xCoord. This requires \nupdating the property expression this.x on line 8 to this.xCoord as well. However, there is no need to \nrename the prop\u00aderty expression this.x on line 14, because the proper\u00adties accessed on lines 8 and 14 \nmust reside in different objects.If we neverthelessdodecideto rename this.x online14 to this.xCoord as \nwell, then the subsequent property expression on line 21 must also be changed to this.xCoord.  Refactoring \nthe property expression this.drawShape on line 6 in Circle to this.draw requires that the property expression \nthis.drawShape on line 19 in Rectangle is refactored to this.draw as well: the re\u00adceiver s in the expressions.drawShape(gr) \nonline33 can be bound to a Circle or a Rectangle object, and therefore the methods have to be renamed \nconsistently. Note that Circle and Rectangle are completely unre\u00adlated;inparticularthereis noprototype \nrelationship.  Asthese examplesillustrate,thekeycorrectnessrequirement for renaming is name binding \npreservation each use of a propertyinthe refactoredprogramshould refertothesame propertyasinthe originalprogram.Namebindingpreserva\u00adtionis \nalso a natural correctness conditionfor other refactor\u00adings, as wedescribebelow.Sch\u00e4fer etal.[26] used \nthis con\u00addition successfully toprovide sound automated refactorings forJava,includingrenaming.Unfortunately,theirtechniques \nrely on explicit declarations and static scoping, so they are notdirectly applicabletoJavaScript. Anaturalapproachisto \nuse a staticpointeranalysisto ap\u00adproximatenamebindinginformation.However,a naiveuse ofpointer analysis \nwouldbe unsound.For example,consider the renaming of this.drawShape online 6in Circle de\u00adscribed above. \nRenaming only expressions that must point to the samepropertyas the one referencedonline6isinsuf\u00ad.cient. \nA sound must-point-to analysis could indicate that there is no other access of drawShape that must de.nitely \npoint to the same property, therefore requiring nothing else to be renamed. On the other hand, renaming \nonly expres\u00adsions that may point to the property referenced on line 6 is alsoinsuf.cient.For example,a \nsound may-point-toanaly\u00adsis could excludetheproperty expression this.drawShape on line 19 in Rectangle \nsince it de.nitely accesses a dis\u00adtinct property from that of Circle. However, that expres\u00adsion mustinfactberenamed \ntopreserveprogrambehavior, as we saw above.Wede.nea notionof relatedness in Sec\u00adtion 3 based on may-points-to \ninformation, which captures the set ofpropertyexpressionsin aprogramthat are affected byrenaming aparticular \nexpression a. 50 function dble(c) { 51 var nc = new Circle(); 52 for ( var a in c) { 53 nc[a] = (a != \n\"radius\") ? c[a] : c[a]*2; 54 } 55 return nc; 56 } 57 58 function r(n) { return Math.round(Math.random() \n* n); } 59 60 function drawAll(sh) { 61 var gr = 62 new jsGraphics( document. getElementById(\" canvas\" \n)); 63 sh. map( function(s) { s.drawShape(gr); }); 64 } 65 66 var shapes = []; 67 for ( var i = 0; i \n< 500; i++){ 68 var o= new jsColor().rgbToHex(r(255) ,r(255) ,r(255)); 69 switch(r(2)) { 70 case 0: 71 \nshapes[i] = 72 dble( new Circle(r(500) ,r(500) ,r(50),o)); 73 break; 74 case 1: 75 shapes[i] = 76 new \nRectangle(r(500) ,r(500) ,r(50),r(50),o); 77 alert( shapes[i ]. getArea()); 78 break; 79 } 80 } 81 drawAll( \nshapes); Figure 2. Modi.ed client application, with dble function added. We now consider a minor variation \non the client applica\u00adtion where afunction dble hasbeen added(lines50 56)as shown in Figure 2. The client \napplication is the same as in Figure1(b) except that dble is used todoubletheradiusof circles createdinline72. \nThe function dble takes an argument c, which is as\u00adsumedtobe a Circle object, and returns a new Circle \nob\u00adject at the same coordinatesbutwith adoubled radius.This functionillustrates severalinterestingfeatures \nofJavaScript. First, on line 51, the constructor of Circle is called with\u00adout any explicit arguments, \nwhich causes the special value undefined to be passed as default argument. Second, line 52 shows a for-in \nloop, in which the variable a it\u00aderates through the names ofpropertiesin the objectpointed to by parameter \nc. Line 53 also provides several examples of a dynamicpropertyexpression.For example,thedynamic propertyexpression \nc[a] on thatline refers to theproperty of c namedby the value of a.Together, these re.ectivefea\u00adtureshave \nthe effect of copying allproperty valuesfrom the argument c into the corresponding property of the newly \ncreated object, except for radius, which is also multiplied bytwo.Thesefeaturespose some challengesfor \nrefactoring: Applying RENAME to this.radius on line 4 is prob\u00adlematic because of the for-in loop anddynamicprop\u00adertyexpressionin \ndble.For example,renamingtheprop\u00aderty expressionto this.rad would require changingthe string constant \n\"radius\" online53in order topreserve behavior.Ingeneral,dynamicproperty expressions may use values computed \nat runtime, which wouldthwart any static analysis.In orderto ensurethatdynamicproperty expressions do \nnot cause changes in program behavior when applying the RENAME refactoring, our approach (asdetailedinSection4)isto \nconservativelydisallowthe renaming of anypropertyin any object on whichproper\u00adties maybe accessed re.ectively.Hence,inthis \nexample, we disallow renaming any of the properties in Circle objects.  The names of the drawShape \nmethods in Circle and Rectangle mustbekeptconsistent,becausethecall on line 63 may resolve to either \none of these, as we ex\u00adplained above. Since we now disallow renaming any of thepropertiesin Circle, we \nmust also disallow renam\u00adingdrawShape inRectangle.  TheremainingpropertiesofRectangle,i.e., x, y, width, \nand height can stillbe renamed.   2.3 ENCAPSULATE PROPERTY InJava,theENCAPSULATE FIELD refactoringcanbe \nusedto encapsulatestateby making a .eld private and redirecting access to that .eld via newly introduced \ngetter and setter methods[9,page206].Unfortunately,JavaScriptdoes not provide language constructs to \ncontrol the accessibility of properties in objects: If a function has a reference to an object,it can \naccess anyproperty of that object.Such alack of encapsulationisproblematicbecauseitleads to code that \nisbrittle, andhardto understandand maintain. A commonly used technique, suggested for instance in Crockford \ns popular textbook [5], uses local variables of constructor functions to simulate private properties. \nLocal variables in JavaScript (i.e., variables declared using the var keyword) can onlybe accessed withinthe \nscopeof the declaring function.Inthe case of constructorfunctions,lo\u00adcal variables exist as long as the \nobject exists, and they can onlybe accessedbyfunctionsde.ned withinthe constructor functionitself.Thebasicidea \nof the ENCAPSULATE PROP-ERTY refactoringistoencapsulatestateby storing valuesin local variablesinstead \nofproperties of objects, and tointro\u00adducegetter/setter methodsto retrieve andmodifythem. Figure 3 shows \nhow the library of Figure 1 is changed by applying the ENCAPSULATE PROPERTY refactoring to the width \nproperty of Rectangle, with changed bits of codehighlightedingray.The width property was changed into \nalocal variable online98, and methods getWidth and setWidth wereintroducedonlines101 106.5Furthermore, \ntheproperty expression this.width was replacedby a call to getWidth on line 114. Note that there was \nno need to introduce a callto getWidth online110becausethe width variablecanbe accesseddirectly.No callsto \nsetWidth need tobeintroduced since there are no write accesses to width. 5Thisis nottobe confusedwiththe \nnewgetter/setter mechanismintroduced inECMAScript5, which only applies to objectliterals[7,\u00a711.1.5]. \n82 function Circle(x, y, r, c) { 83 this .x = x; 84 this .y = y; 85 this .radius = r; 86 this .color \n= c; 87 this .drawShape = function(gr) { 88 gr. fillCircle( new jsColor( this .color), 89 new jsPoint( \nthis .x, 90 this .y), 91 this . radius); 92 }; 93 } 94 95 function Rectangle(x, y, w, h, c) { 96 this \n.x = x; 97 this .y = y; 98 var width = w; 99 this .height = h; 100 this .color = c; 101 this.getWidth \n= function() { 102 return width; 103 }; 104 this.setWidth = function(w) { 105 return width = w; 106 }; \n107 this .drawShape = function(gr) { 108 gr.fillRectangle( new jsColor( this . color), 109 new jsPoint( \nthis .x, this .y), 110 width , this . height); 111 }; 112 } 113 Rectangle.prototype.getArea = function() \n{ 114 return this.getWidth() * this . height; 115 }; Figure3. ThelibraryofFigure1(a) after applyingENCAP-SULATE \nPROPERTY to the width propertyof Rectangle. The source code of the client application in Figure 1(b) \nis unaffectedby this refactoringbecauseitdoes not access the width property. Namebindingpreservationis \nakeycorrectness condition alsofortheENCAPSULATE PROPERTY refactoring,butthere are otherissues as well. \nEncapsulatingthe width propertyof Rectangle didnot causeanyproblems,and all otherpropertiesof Rectangle \ncanbe encapsulated similarly.However,thisis notthe case for the properties of Circle. To see this, consider \na sit\u00aduation where the radius property of Circle is encapsu\u00adlated in a scenario where the library is \nrefactored together withthe modi.edclient applicationofFigure2.The for-in loop online52inthe originalprograminFigure2iterates \nthroughallproperties of a Circle object, sothebehavior of this loop changes if radius becomes a variable \ninstead of aproperty.The multiplicationintheloop is nolonger exe\u00adcuted since there is no radius property \nto be copied. The for-in loop will also copy the drawShape property, but the copied function object will \ncontinue to refer to the lo\u00adcal variables of the original Circle object that was being copied.As a result,theprogram \nwould continuetodraw cir\u00adcles,butwithjusthalfthe radius.TheENCAPSULATE PROP-ERTY refactoringshouldclearlybedisallowedinthis \ncase.A JavaScript refactoring tool must carefully take into account howproperties are accesseddynamically \nandprevent EN\u00ad  116 var r1 = new Rectangle(0, 0, 100, 200, red ); 117 var r2 = new Rectangle(0, 0, 300, \n100, blue ); 118 r1.drawShape = r2.drawShape; 119 drawAll([r1]); Figure4. Alternative clientprogram. \nCAPSULATE PROPERTY in cases whereit mightlead tobe\u00adhavioralchanges.Inthisparticular case, atool could \nconser\u00advativelydisallow anyofthepropertiesof Circle frombeing encapsulated. JavaScriptallows onetodynamicallyassignfunction \nval\u00aduestoproperties,which causesfurthercomplications.Sup\u00adposethatwe wantto applyENCAPSULATE PROPERTY \ntothe width property of Rectangle in a situation that includes thelibrary ofFigure1(a) and the(arti.cial) \nclientprogram ofFigure4.The original version oftheprogramdraws a red 100-by-200 rectangle. However, if \nwidth is encapsulated, as shown in Figure 3, a red 300-by-200 rectangle is drawn instead. To see why, \nnote that the function stored in prop\u00aderty r1.drawShape and invoked by drawAll comes from r2.drawShape,and \ncontainsthefunction originally created duringthe constructorinvocation online117.Henceitslex\u00adical environment \nstores the value300for width, and thisis the value read on line 110. The height, on the other hand, is \nread from property height of object this; the value of this is always the object on which thefunctionisinvoked, \nherer1, so this.height yields200. The problem can be resolved by replacing the identi.er reference width \non line 110 by a call this.getWidth(). In Section 3, we de.ne the notion of well-scopedness to characterizefunctionsthat \nact as methods of a single object, making it safeto accessthe encapsulatedproperty directly. Roughly \nspeaking, a function is well-scoped if, on every call, its receiver object is the same as the value that \nthis had when the function was de.ned. In the presence of the client ofFigure4, drawShape is notwell-scopedbecause \nof the assignment on line 118. Therefore, our refactoring tool knows thatit must replace theidenti.er \nreference width on line110bya call to this.getWidth.  2.4 EXTRACT MODULE JavaScript does not provide \nlanguage constructs for modu\u00adlarizationandreliesona singleglobalnamespaceforalltop\u00adlevelfunctions andvariables, \neven those that aredeclaredin different.les.Thisisproblematic,becauseitcan easilylead to situations wheredeclarationsofglobalvariablesandfunc\u00adtionsin \none .le are clobberedby thosedeclaredinanother. Fortunately,itispossible to obtain most of thebene.ts \nof a module system using closures[5,page40]. Figure 5 shows the example program of Figure 1 af\u00adter applying \nEXTRACT MODULE to move the Circle and Rectangle functions into a new module called geometry. The basic \nidea is that these previously global functionsbecomelocalfunctionsinside an anonymousfunc\u00adtion,which \nreturnsanobjectliteral withproperties Circle and Rectangle throughwhichthefunctions canbeinvoked (lines149 \n152).This anonymousfunctionisinvokedimme\u00addiately(line153), andthe resultis assignedto a newlyintro\u00adducedglobalvariable, \ngeometry (line120).Hence,the con\u00adstructor functions are now available as geometry.Circle and geometry.Rectangle. \nFigure 5(b) shows how the client application of Figure 1(b) is updated, by using these quali.ed names \n.Notethatthis approachhastheimportant bene.t that inside the newly introduced closure function, thereis \nno needto refertothegeometry variable.For exam\u00adple, the nameRectangle online145 need notbequali.ed. A \nrefactoring tool must take certain precautions when applying EXTRACT MODULE. For example, observe that \nchoosing the name shapes for the new moduleisproblem\u00adatic because a variable with the same name is already \nde\u00adclared on line 161. If we were to perform the refactoring anyway,theshapes module wouldbeoverwritten,and \nthe constructorcallsonlines167 and 171 would causeruntime errors since the empty array shapes does not \nhave proper\u00adties Circle or Rectangle. 2.5 Discussion Theexamplesinthis sectionshowthat refactoringtoolsfor \nJavaScripthavetoaddressa numberofchallengesthatdonot arisein staticallytypedlanguagessuch asJava.Chief \namong these challenges is the lack of static typing and variable declarations, and the use of re.ective \nconstructs such as for-in loops. We address these challenges with a number of query operations de.ned \non top of a pointer analysis framework. We present the framework and its queries in Section 3 and put \nthem to work in Section 4 by specifying the refactoringsintroducedin this sectionin moredetail.  3. \nAFrameworkforRefactoring with PointerAnalysis In this section, we develop the technical machinery needed \ntopreciselyspecifyandimplementrefactoringslikethe ones described in the previous section. We .rst describe \na set of basicqueriestobeprovidedbyan underlyingpointer analy\u00adsis such asthe onediscussedinSection5.Then,we \nmotivate the analysisquestions a refactoring tool needs to answerby taking a closer look at some of the \nissues illustrated above, and we show how to crystallize them into reusable queries that canbeimplemented \non top of thebasicqueryinterface. Section4willdemonstratehowthesequeriesareinturnused togivedetailed \nspeci.cationsfor several refactorings. 3.1 BasicQueries As the foundation of our framework, we assume \na pointer analysis that de.nes a .nite set L of object labels such that every object at runtimeis representedby \nalabel.We assume that L includeslabelsto represent environment records[7, \u00a710.2.1].Fortechnicalreasons, \nwe requirethatif an object  120 var geometry = (function(){ 154 function r(n) { return Math.round(Math.random() \n* n); } 121 function Circle (x, y, r, c) { 155 122 this .x =x; 156 function drawAll(shapes) { 123 this \n.y =y; 157 var gr = new jsGraphics( document. getElementById(\" canvas\" )); 124 this .radius = r; 158 \nshapes. map( function(s) { s.drawShape(gr); }); 125 this .color = c; 159 } 126 this .drawShape = function \n(gr) { 160 127 gr. fillCircle( new jsColor( this .color), 161 var shapes = []; 128 new jsPoint( this \n.x, this .y), 162 for ( var i= 0; i< 500; i++) { 129 this . radius); 163 var o= new jsColor().rgbToHex(r(255), \nr(255), r(255)); 130 }; 164 switch(r(2)) { 131 } 165 case 0: 132 166 shapes[i] = 133 function Rectangle \n(x, y, w, h, c) { 167 new geometry.Circle(r(500),r(500),r(50), o); 134 this .x =x; 168 break; 135 this \n.y =y; 169 case 1: 136 this .width = w; 170 shapes[i] = 137 this .height = h; 171 new geometry.Rectangle(r(500),r(500),r(50), \nr(50), o); 138 this .color = c; 172 alert( shapes[i ]. getArea()); 139 this .drawShape = function (gr) \n{ 173 break; 140 gr. fillRectangle( new jsColor( this . color), 174 } 141 new jsPoint( this .x, this \n.y), 175 } 142 this .width, this . height); 176 drawAll( shapes); 143 }; 144 } 145 Rectangle.prototype.getArea \n= function() { 146 return this .width * this .height; 147 }; 148 149 return { 150 Circle : Circle, 151 \nRectangle : Rectangle 152 153 })(); (a) (b) Figure5. The exampleprogram ofFigure1 after applyingEXTRACT \nMODULE to Circle and Rectangle. label represents an object allocated by a particular new ex\u00adpression,then \nall objects representedby thatlabel are allo\u00adcatedbythat expression.Similarly, a single objectlabel can\u00adnot \nrepresent two function objects associated with different textualde.nitions. We say that a set L of objectlabels \nover-approximatesa set O of runtime objectsif every object o . O is represented by some l . L. For brevity, \nwe will use the term function de.nition tomean functiondeclarationorfunctionexpres\u00adsion and invocation \nexpression to mean function call ex\u00adpression ornew expression . Thepointeranalysis shouldprovidethefollowingqueries: \nobjects For anyexpression e intheprogram,objects(e) .L over-approximatesthe set of objectsto which e \nmay eval\u00aduate, including objects arising from ToObject conver\u00adsion[7,\u00a79.9].For afunctiondeclaration f, \nobjects(f) over-approximates the set of function objects that may resultfrom evaluating f. scope For \nany function de.nition or catch clause e, scope(e) . L over-approximatesthe setof environment records \ncorresponding to e at runtime.6 We additionally de.nescope(e) := objects(e) for anywith expression e. \n6Observe that scope(f ) for a function de.nition f is not necessarily the same as objects(f ):theformer \napproximates environment records,thelatter approximates function objects. proto Foranyobjectlabell,proto(l) \n. L over-approximates the possible prototype objects of the runtime objects l represents. We write proto+(L) \nfor the set of transitive prototypes ofL . L asdeterminedby thisquery. props Foranyobjectlabell,props(l) \n.L over-approximates the set of objects that could be stored in properties of l (excludinginternalproperties). \nmayHaveProp, mustHaveProp For any object label l and propertyname p, mayHaveProp(l,p) shouldhold when\u00adever \nany object representedby l mayhave aproperty p; mustHaveProp(l,p), conversely, should only hold if ev\u00adery \nobject representedby l has a property p at all times (forinstanceifl represents an environment record \nand p is alocal variabledeclaredin that environment). arg,ret Foranobjectlabellanda naturalnumber i, \narg(l,i) over-approximates the set of objects that may be passed as the ith argument (or the receiver \nin case i =0) to any function labelled by l. Similarly, ret(l) over\u00adapproximates the set of objects that \nmay be returned froml. builtin Given the name n of abuilt-inobject as speci.edin thelanguage speci.cation[7,\u00a715], \nbuiltin(n) returnsthe correspondingobjectlabel.The objectlabel oftheglobal object willbedenoted as global.We \nalsode.ne  apply := builtin(Function.prototype.apply) bind := builtin(Function.prototype.bind) call \n:= builtin(Function.prototype.call)  3.2 Visited andBaseObjects Many preconditions deal with name binding. \nAny refac\u00adtoring thatintroduces, renames or removesproperties risks causing name capture, i.e., situations \nwhere a property ex\u00adpression refers to a different object in the refactored pro\u00adgram.Twokey conceptsare \nneeded whenformulatingpre\u00adconditions to avoid name capture: the visited objects of a propertyexpression, \nandits base objects. PropertylookupinJavaScriptis,in most circumstances, prototypebased.This meansthatwhen \nevaluatingaproperty expression e.x,theproperty x is .rstlookedupontheobject o1 that e evaluates to; if \no1 does not have a property of this name, its prototype object o2 is examined, and so on. Eventually, \nan object on is encountered that either has a property x, ordoes nothave aprototype object(in which case \nthelookup returns the undefined value).Wedescribe this process by saying that the lookup of e.x visits \nobjects o1,...,on; if thepropertyis ultimatelyfound on object on, we call on the base object of thelookup. \nTo seehowthese concepts are usefulfor specifyingrefac\u00adtorings, consider the case of a refactoring that \nadds a prop\u00aderty y on some object o. This refactoring needs to ensure that o is not among the objects \nthat any existing property expression e.y may visit. Otherwise, the base object of an evaluation ofthat \nexpression could change,possibly altering programbehavior. The usual purpose of adding a new property \ny to an ex\u00adisting object is to rewrite property expressions that used to resolve to some property x on \nthat object so that they now instead resolve to y.Forinstance,ENCAPSULATE PROP-ERTY rewrites this.width \non line 26 of Figure 1 into this.getWidth on line 114 of Figure 3 to make it re\u00adsolve to the newly introduced \ngetter function. To prevent the refactoredproperty expressionfrombeing resolved with the wrongbase object \norfrom overwriting an existingprop\u00aderty, wehave to requirethat alookup of this.getWidth at thispositionin \nthe originalprogram would come up empty\u00adhanded,thatis,that noneof the visited objectsof theprop\u00aderty \nexpressionhas aproperty getWidth.Thisisindeedthe case in this example because no property getWidth is \nde\u00ad.ned anywhereinFigure1. The same considerations applyto thelookupoflocal and global variables:global \nvariables arejustproperties ofthe globalobject, whilelocal variables canbe viewed asproper\u00adties of environment \nrecords.The concepts of visited objects and base objects can hence be extended to identi.er refer\u00adencesin \na straightforwardmanner as showninthe accompa\u00adnyingtechnical report[8]. To underscore this commonality, \nwe introduce the um\u00adbrella term access to refer tobothidenti.er references(like r on line 4 of Figure \n1) and property expressions, includ\u00ading both .xed-property expressions like s.drawShape on line63 ofFigure2 \nanddynamic oneslike nc[a] online53 ofFigure2.7Identi.er references and.xed-propertyexpres\u00adsions are called \nnamed accesses. An over-approximationpossiblyNamed(p) ofallaccesses in the program that possibly have \nname p in some execu\u00adtion, and an under-approximationde.nitelyNamed(p) of ac\u00adcesses thatde.nitelyhave \nname pin everyexecution canbe computed based on purely syntactic information, although pointer analysis \nmay provide additional information that can, e.g.,be used todeterminethat adynamicproperty ac\u00adcessis \nalways used as an arrayindex andhence cannothave a non-numericproperty name. GiventhebasicqueriesintroducedinSection3.1,itis \nnot hard tode.nequeries visited and base toover-approximate visited andbase objects of accesses. For \na property expression e.x, for instance, visited(e.x) can be computed as the smallest set Lv . L satisfying \nthe followingtwo conditions: 1. objects(e) . Lv; 2. if e.x is in rvalue position, then for every l . \nLv with \u00acmustHaveProp(l,x) we musthave proto(l) . Lv.  Theprovisoofthe secondconditionaccountsforthefactthat \ndeletion of and assignment to properties does not consider prototypes. Thede.nition of visited foridenti.er \nreferencesis simi\u00adlar, usingscope to obtain the relevant environment records. To over-approximate the \nset of base objects, we .rst de\u00ad.nea .ltered versionof visited asfollows: visited(a,x) := {l . visited(a) \n|mayHaveProp(l,x)} This discards all object labels that cannot possibly have a propertyx fromvisited(a).For \na named access a with name x in rvalueposition, wethende.nebase(a) := visited(a,x), whereasfor adynamicpropertyaccess \nor an accessinlvalue position we setbase(a) := visited(a). It will also be convenient to have a query \nlookup(e,x) thatsimulateslocal variablelookup of anidenti.er x at the position of the expression e, and \napproximates the set of environmentrecords or objects on which x maybe resolved. This query can be implemented \nby traversing the function de.nitions,with blocks andcatch clauses enclosing e, and thenusing scope and \nmayHaveProp to .ndpossibletargets.  3.3 RelatedAccesses Whenrenamingan access,itisimportanttodeterminewhich \nother accesses in the program refer to the same property. Thisis nota well-de.nedquestioningeneral: agiven \naccess 7Thetechnical report[8]generalizesthe concept of accesses evenfurther, butfor expositorypurposes \nwe refrainfromdoing sohere.  may atdifferenttimesbelooked up ondifferentbase objects and evenrefertodifferentproperty \nnames, sotwo accesses may sometimes refertothe samepropertyname onthe same object, while at othertimesthey \ndo not.Ingeneral,we can only determine whether two accesses must always refer to the sameproperty, or \nwhetherthey may sometimes do so. Must-alias information is not very useful for renaming, as explainedinSection2: \nwhen renamingthis.drawShape online6 ofFigure1, we alsohaveto rename s.drawShape on line 33, even though \nit does not necessarily refer to the same property. But if we rename s.drawShape, we also have to rename \nany access that may refer to the same propertyasthat access, viz., this.drawShape online6 and this.drawShape \nonline19. This example suggests that we have to close the set of accessesto rename underthe may-aliasrelation.Morepre\u00adcisely, \nlet us call two accesses a1 and a2 directly related if theirbase object maybe the same and they may refer \nto the sameproperty name.The set related(a1) of accesses related to a1 is then computed as the smallest \nset R satisfying the followingtwo closure conditions: 1. a1 . R; '' 2. for everya . R,if a is an access \nsuch that a and a are ' directlyrelated, then also a . R. When renaming a1 we also rename all accesses \nit is re\u00adlatedto.Wehave arguedabovewhyitis necessarytoinclude all related accessesin the renaming.On \nthe otherhand,itis ' also suf.cienttojust renamethese accesses:if any access a may at runtime refer to \nthe sameproperty as some renamed '' access a, then a and a aredirectly related andhence a will alsobe \nrenamed.The set of related accesses thus represents afamily ofpropertiesthathave tobe refactoredtogether. \n 3.4 InitializingFunctions The ENCAPSULATE PROPERTY refactoring looks similar totheENCAPSULATE FIELD \nrefactoringforlanguageslike Java andC#,but the veryliberalobject system ofJavaScript allows for subtle \ncorner cases that the refactoring needs to handle.Whileitis commoninJavaScript to make adistinc\u00adtionbetweennormalfunctionsandconstructorfunctionsthat \nare only usedtoinitialize newly created objects,thisdistinc\u00adtionis not enforcedby thelanguage. Any function \nf can either be invoked through a new expression new f(...), in which case the receiver object is a newly \ncreated object,orthrough afunctioninvocation,in which case the receiver objectisdeterminedfrom the shape \nof theinvocation:for aninvocation of theform e.f(...), the receiverobjectisthe valueof e;for an unquali.edinvocation \nf(...), the receiver objectis usually theglobal object. We capture the notion of a function behaving \nlike a constructor by saying that afunction initializes an object o ifitisinvokedpreciselyonce with that \nobject asits receiver, and this invocation happens before any of o s properties are accessed.Forinstance,function \nRectangle inFigure1 initializes all of the objects created on line 44 by invoking new Rectangle(...). \nIfafunctionis only everinvoked using new and neverin\u00advoked re.ectively or using a normal function invocation, \nit obviously initializes all objects created by these new invo\u00adcations.Thisprovides an easy wayto approximatethe \nset of objectsthat areinitializedbyafunction.Let us .rstde.ne an over-approximationof the set ofpossible \ncallees of aninvo\u00adcation expression c bycallees(c) := objects(cf ) where cf is thepartof c containingtheinvokedexpression.Now,givena \nfunctionde.nition f, an under-approximation initializes(f) of the set of objects that f initializes canbedeterminedby \nensuringthefollowing: 1. f is onlyinvokedthroughnew,thatis (a)Nofunction/methodcall c has callees(c) \nnobjects(f) .\u00d8. = (b)f is notinvokedre.ectively,i.e., args(apply,0) nobjects(f)= \u00d8, and similarlyfor \nbind and call. 2. For anynew expression n with callees(n) nobjects(f) .\u00d8 = wehave callees(n) . objects(f) \n This ensures thatn de.nitelycalls f. The .rst condition ensures that f is invoked at most once on each \nreceiver object, and the second condition ensures thatitisinvokedatleast once.Ifboth conditionshold, \nf ini\u00adtializes allits receiverobjects, so we can setinitializes(f) := l.objects(f) arg(l,0); otherwise, \nwe conservatively set initializes(f) := \u00d8.  3.5 Well-scopedness Justas there are nogenuine constructorsinJavaScript,there \nare no real methods either.Althoughitis commontothink of afunction storedin aproperty of an object o \nas a method of o that is only invoked with o as its receiver, this is not enforcedby thelanguage,and \nsuch a method can,infact, beinvokedon any object.As showninFigure4 thisleads to problems when encapsulatingproperties. \nWe capture the notion of a function behaving like a method by the concept of well-scopedness. A function \nf is well-scoped in a function g if f is de.ned within g and whenever an execution of g on some receiver \nobject o eval\u00aduates the de.nition of f,yielding a newfunctionobject fo, then this implies that fo is \nalways invoked with o as its re\u00adceiver. If g additionally initializes all objects on which it is  177 \nfunction A(g) { 178 if (g) 179 this .f =g; 180 else 181 this .f = function() {}; 182 } 183 184 var a= \nnew A(), b = new A(a.f); 185 b.f(); Figure6. Exampleprogram toillustrate the approximation of well-scopedness. \ninvoked, then f is guaranteed to behave like a method on these objects. To prove that a function de.nition \nf is well-scoped in g,as expressedby thequery wellscoped(f,g),it suf.ces to checkthefollowing conditions: \n1. f is adirectinnerfunction ofg. 2. f is only assigned to properties of the receiver of g: whenever \nthe right-hand side er of a simple assignment may evaluateto f (i.e.,objects(er) nobjects(f) .= \u00d8),the \nsoleintra-procedural reachingde.nition of er is f itself, and the left-hand side of the assignment is \na property expression oftheform this.p (for someidenti.erp). 3. f is only invoked on the object in whose \nproperty it is stored: anyinvocation expression c that may call f must be of the form e.p(...), and mayHaveProp(o,p) \nis false for everyo . proto+(objects(e)). 4. f is notinvokedre.ectively(cf. condition1bin thede.\u00adnition \nof initializes).  The second condition is motivated by considering the exampleprograminFigure6.Thefunction \nstoredin a.f is not well-scopedin A:the receiver of A at thepoint wherethe functionisde.nedisa,yet whenitis \ncalledthrough b.f the receiver object is b. This non-well-scopedness results from the assignmentinline179 \nandisdetectedby condition2.  3.6 IntrinsicsandRe.ectivePropertyAccess A number of intrinsic properties \nare treated specially by the runtime system, the browser, or the standard library in JavaScript,forinstancethelength \npropertyofarrayobjects or the src property of HTML image objects. Refactorings must not attempt to modifytheseproperties.Wehence \nneed a query intrinsic so that intrinsic(l,p) holds whenever p is an intrinsic property on an object \nlabelled by l. This query can be de.ned in terms of builtin, consulting the relevant standards[7,29]. \nSeveral standard library functions access properties of their argument objects in a re.ective way: for \ninstance, Object.keys returns an array containing the names of all propertiesofits argument.To makeitpossibleforrefactor\u00adings \nto check for this kind of usage, we need a query re.-PropAcc such that re.PropAcc(l) holds whenever a \nprop\u00aderty of an object labelled by l may be accessed re.ectively byone ofthesefunctions.Thisquerycanbede.nedinterms \nof builtin,arg,ret and props. Finally, queries builtin and arg also make it possible to conservatively \ndetermine whether a program uses dynami\u00adcallygenerated codeby checking whether the built-infunc\u00adtion \neval and its various synonyms are ever invoked, and whether the intrinsic property innerHTML is assigned \nto. Our refactoring speci.cations assume that such a check is performed .rst and a warning is issued \nif a use of any of thesefeatureshasbeendetected.  4. Speci.cationsofThreeRefactorings We will nowgivedetailed \nspeci.cationsof the refactorings RENAME, ENCAPSULATE PROPERTY andEXTRACT MOD-ULE that wereinformallydescribedinSection2. \nEach speci.cationdescribestheinputtothe refactoring, the preconditions that have to be ful.lled in order \nfor the refactoring to preserve program behavior, and the transfor\u00admation itself. The preconditions are \nformulated in terms of thequeriesintroducedin theprevious section. We alsoprovideabriefinformaljusti.cation \nof thepre\u00adconditions. 4.1 RENAME Input A named access a and a new name y. Overview The refactoring renames \na and its related ac\u00adcesses to y. De.nitions Let B := base(r); this set labels r.related(a) all objects \nthat are affected by the renaming. Let x be the namepart of the access a.  Preconditions 1. x is notanintrinsicproperty \non B: .l . B: \u00acintrinsic(l,x) 2. Everyaccess tobe renamedde.nitelyhas name x: related(a) . de.nitelyNamed(x) \n3. The accesses in related(a) can be renamed to y without name capture: .r . related(a): visited(r,y)= \n\u00d8 In this case, we will also say that y is free forrelated(a). 4. y does notcause name capture on B, \nthatis: (a)Existingaccesses are not captured: .r . possiblyNamed(y): visited(r) nB = \u00d8 (b)y is notanintrinsicproperty \non B: .l . B: \u00acintrinsic(l,y)  (c)Properties of the objects in B must not be accessed re.ectively,thatis: \ni. Foranyfor-in loopwithloopexpressione itmust be the case thatB nobjects(e)= \u00d8. ii. We musthave.l . \nB: \u00acre.PropAcc(l). Transformation Rename everyaccessin related(a) to y. Justi.cation Precondition 2 prevents \nthe renaming if it could affect a computedpropertyaccess whose name cannot be staticallydetermined. Preconditions3 \nand4a ensurethat accessesinthe refac\u00adtoredprogram resolve to the sameproperty at runtime asin the originalprogram:by \n3, an access renamedfrom x to y is not capturedby an existingproperty y;by4a, an existing access named \ny is not capturedby aproperty renamedfrom x to y. Preconditions1and4b ensurethatthe renamingdoes not \naffectpropertiesthathavespecial meaninginthelanguage; for instance, renaming the prototype of a function \nor the length propertyof an array should notbe allowed. Finally,precondition4c ensuresthat none of the \nobjects whose properties may be affected by the refactoring have theirproperties examined re.ectively. \n 4.2 ENCAPSULATE PROPERTY Input A .xed-propertyexpressiona. Overview This refactoring identi.es a function \nc that ini\u00adtializes all base objects of a and its related accesses, and turns theproperty accessedby \na into alocalvariable of c. Any accessestothepropertyfrom withinthefunction c canbe turnedinto accesses \nto thelocal variableif theyhap\u00adpenfrominside well-scopedfunctions;otherwisetheymight refer to the wrong \nvariable as seen in Section 2. Accesses from outsidec arehandledbyde.ninggetter andsetterfunc\u00adtionsinc \nand rewriting accessesinto callstothesefunctions. Thepreconditionsidentifya suitable c,determinehowto \nrewrite accesses, and checkfor namebindingissues. De.nitions Let x be the namepartof a, andlet g and \ns be appropriategetter and setter namesderivedfrom x. Let B := base(r); this is the set of objects r.related(a) \nwhoseproperties named x we want to encapsulate.  Preconditions 1. Thereis afunctionde.nitionc with B \n.initializes(c). Thegetter and setterfunctions areintroducedin c; since c is invoked on every affected \nobject before any of its properties are accessed, we can be sure that these func\u00adtionsareinplacebeforetheir \n.rst use. 2. The affectedobjectsdo not appear on each other sproto\u00adtype chains,i.e.,  \u00ac.b1,b2 . B : \nb2 . proto+(b1) 3. Every access in related(a) is either a .xed-property ex\u00adpression or anidenti.er reference.(Thelatter \ncan only happenif a with statementisinvolved.) 4.Thereis apartitioning related(a)= Ai .Ag .As such that: \n(a)Every a . Ai is of the form this.x, it is not an operand of delete, and its enclosing function de.\u00adnition \nf is well-scopedinc,i.e. wellscoped(f,c). These are the accesses thatwillbe replacedbyidenti\u00ad.er references \nx. (b)Noa . Ag isin anlvalueposition. These accesses can be turned into invocations of the getterfunction. \n(c)Every a . As forms the left-hand side of a simple assignment. These accesses can be turned into invocations \nof the setterfunction. 5. Properties of B must not be accessed re.ectively (cf. precondition4c of RENAME). \n 6. Namingchecks: (a)Ai canbe refactored without name capture:  .a . Ai : lookup(a,x) .{global} (b)The \ndeclaration of the new local variable x in c does not capture existingidenti.er references. .a . possiblyNamed(x): \nvisited(a) nscope(c)= \u00d8 (c)x is notanintrinsicproperty on B: .l . B: \u00acintrinsic(l,x) 7. IfAg .\u00d8then g \nmustbefreefor Ag = and must not cause name capture on initializes(c) (cf.preconditions3and4 ofRENAME).Similarly,ifAs \n.\u00d8then = s mustbefreefor As and must not cause name capture on initializes(c). Transformation Insert \na declaration var x into c. Insert a de.nition of the getter function into c if Ag .\u00d8, and = similarly \nfor As and the setter function. Replace accesses in Ai with x, accesses in Ag with invocations of the \ngetter, inAs withinvocations ofthe setter. Justi.cation This refactoring converts properties of ob\u00adjects \ninto bindings in environment records. The precondi\u00adtions ensure thatproperty accesses canbe rewritteninto \nac\u00adcesses to the corresponding local variable binding, while preventingany changesto other accessestoproperties \norlo\u00adcal variables thatdo notparticipatein the refactoring. Consider a runtime object o labeled by some \nl . B. By condition 1, there is precisely one invocation of c on o, which creates an environment record \n.o. In the refactored program, this environment record contains a binding for a local variable x, which \nis captured by the getter and setter functions storedinpropertiesg and s of o.  Consider now a property \naccess ax in the original pro\u00adgram that accesses property x of object o. This means that ax . related(a), \nso condition4 ensuresthat ax is in one of Ai, Ag and As. In the two latter cases, the property access \nwillbe rewritteninto aninvocation ofthegetter method g or the setter method s on o. Bycondition7thisinvocation \nwill notbe capturedby an\u00adothermethodofthesame name,andbycondition2itwillnot be captured by the accessor \nmethods of another refactored object.By condition1, g and s are alreadyde.ned, andby condition7they areguaranteednottohavebeen \noverwritten inthe meantime,hencethe accessorfunctionssetupby c are executed, accessing the correctbindingin \n.o. If ax . Ai,theproperty accessis refactored to a simple identi.er reference x. We know from condition \n4a that ax must occur in some function de.nition f, which is well\u00adscopedin c, andthatit mustbe oftheform \nthis.x.Hence f is,infact,invokedwitho as receiver, whichbythede.nition of well-scopedness means that \nthe invocation of c whose bindings are captured by f also has receiver o. In other words, f captures \nthe bindings of .o.Condition6a ensures that the identi.er reference x in the refactored program is not \ncapturedby any otherlocal variable, andhence accesses thebinding of x in.o asdesired. The requirement \nabout ax not being an operand of delete is purely technical: local variable bindings cannot bedeletedinJavaScript. \nSincetheset ofpropertiesof o has changedin the refac\u00adtoredprogram, any codethat re.ectively accessesproperties \nof o or the set of property names of o may change its be\u00adhavior; conditions 3, 5 and 6c guard against \nthis. Finally, condition6b ensuresthat no existinglocal variablebindings are upsetby the newlyintroducedlocal \nvariable x inc. Remarks Note that condition 4 makes it impossible to refactor accesseslike ++e.x thatboth \nread and writethe en\u00adcapsulatedproperty, unless they canbe replacedby aniden\u00adti.er reference.Itis straightforwardto \nextendthe refactoring to take care of such accesses, at the cost of a slightly more complicated transformationinvolvingbothgetter \nand setter invocationsin the same expression[8].  4.3 EXTRACT MODULE Input Contiguous top-level statements \ns1,...,sm con\u00adtaining a set P = {p1,...,pn}of identi.ers to extract and anidenti.er M tobe used as module \nname. Overview The global variables p1,...,pn are turned into properties of a newly declared global module \nvariable M. Schematically, the transformation performed by the refac\u00adtoringis asfollows: var M = ( f \nu n c t i o n() { s1 ; var p1 , . . ., pn ; s1 ; . . . sm ; . . . r e t u r n { . p1 : p1 , . . ., pn \n: pn sm ; }; } ) ( ) ; We referto the codede.ningM as the moduleinitializa\u00adtion code.To reason aboutthe \ncorrectness ofthetransforma\u00adtion, it is helpful to partition program execution into three phases: before, \nduring and after execution of the initializa\u00adtion code.Being atop-level statement,the moduleinitializa\u00adtion \ncodeis executed only once. None ofthe variablesinP mustbe accessedbefore mod\u00adule initialization since \nthe module M containing them has not been de.ned yet. After module initialization, on the other hand, \nthey can be accessed as properties of M, i.e., M.p1,. . .,M.pn.Itis clearly notpossible to access themin \nthis wayduringmoduleinitialization(M is, after all, notde\u00ad.nedyet),but we caninstead accessthe correspondinglocal \nvariables p1,...,pn if they arein scope. Closures createdduringmoduleinitialization may stillbe able \nto access a local variable even after module initializa\u00adtion has .nished. This should, however, be avoided \nunless it can be proved that the variable is never assigned to af\u00adter module initialization: if not, \nthe local variable pi and the property M.pi may have different values, which could changeprogrambehavior. \nThepreconditionsdetermine a setQof accessesthathave tobe convertedintopropertyaccesses oftheformM.pi, \nand a set U of accesses that can use the local variables of the module. The preconditions also prevent \naccess to module variablesbeforeinitialization and namebindingissues. De.nitions Let S be the set of \nall accesses appearing in the statements s1,...,sm, and let I . S be the accesses that are not nested \ninside functions. Accesses in I are thus guaranteedto onlybe evaluatedduringmoduleinitialization. LetI* \nbe an over-approximationofthe setof all accesses thatmaybe evaluatedbefore orduringmoduleinitialization. \nThis canbe obtainedbybuildingatransitive call-graphofall top-level statements up to sm, usingquery callees \ntodeter\u00admine possible callees of invocations. Finally, let C contain all accesses in the program except \nthose in I *. Accesses in C are thusguaranteed onlytobe evaluated after moduleini\u00adtializationis complete. \nFor p . P, we de.ne Ap to be the set of accesses that may refertotheglobal variable p, and AP := .We \np.P Ap de.ne mutable(p) toholdif Ap contains a write access that does not belong to I, i.e., if p may \nbe written after module initializationis complete.  Preconditions 1. Any access that may refer to some \nproperty in P must referto thatproperty,i.e.,for every p . P and a . Ap: a . de.nitelyNamed(p) .visited(a,p)= \n{global} Figure 7. The refactoring plug-in for Eclipse. The user has attempted to rename Vector.prototype.removeFirst \nto remove, which the tool correctlydetermines would clash with an existingproperty of the same name. \n  2. Thereis apartitioningAP = Q.U asfollows: (a)Q.C (b)M is free for every q . Q (cf. precondition \n3 of RENAME). (c)For every u . U referring to p . P, the following holds: i. u . I .(u . S .\u00acmutable(p)) \nii. u is anidenti.er reference. iii. lookup(u,p) .{global}. 3. M does not cause name capture on global \n(cf.precondi\u00adtion4 of RENAME). 4. Nop . P is anintrinsic onglobal:  .l . B: \u00acintrinsic(l,p) Transformation \nReplaces1,...,sm with thede.nition of module M as shown above;qualify accessesin Qwith M. Justi.cation \nThe refactoringintroduces a newglobalvari\u00adable M and removes the global variables p1,...,pn. Con\u00addition \n3 ensures that no existing access to a variable M is capturedby the newlyintroduced module variable, \nand that the set ofglobal variablesis not examined re.ectively.Con\u00addition4ensures that none of theglobal \nvariablestobe mod\u00adularizedhas special semantics.It should,forinstance,beim\u00adpossibleto extracttheglobalvariablewindow \ninto a module. The remaining preconditions ensure that accesses to global variables p1,...,pm can be \nconsistently refactored. Condition 1 requires that any access either must de.nitely refer to some p . \nP, or must not refer to any variable in P.Condition2a checksthat accessesin Q, which are to be quali.edwith \na referenceto M, are only evaluated after the moduleisde.ned.Forthe same set of accesses, condition2b \nensures that the reference to M that will be inserted by the refactoring cannotbe capturedby an existing \nvariable M. Finally, condition2c makes surethateveryaccess u . U, which used to refer to one of the global \nvariables p . P, can directly access the local variable this variable has been turnedinto.Sub-condition2(c)irequiresthat \nu is either only evaluatedduring moduleinitialization, or thatit refers to an immutablemodulememberandislexicallynestedwithinthe \nmodule de.nition. Either way it can access module mem\u00adbers withoutquali.cation.Sub-condition2(c)iirules \nout the somewhat subtle case of an access of the form e.p, where e evaluates to the global object, but \nmay have side effects; such an access cannot simplybeturnedinto anidenti.er ref\u00aderence p, as this would \nsuppress the side effects of e. Sub\u00adcondition2(c)iii ensuresthat no existing local variablewill capturethe \nrefactored access u.  5. Implementation We have implemented a refactoring tool in Java that offers \nthe refactoringsdescribedinSection4.Thetoolisintegrated as a plug-in into Eclipse as shown in Figure \n7.8 In this section, we will describe the pointer analysis that underlies the implementation of the framework \nthat we presented in Section3.  We .rst derive a .ow graph from the source code of the original program, \nsimilar to the one used in the TAJS program analysis [18]. From this .ow graph, we create a def-use graph \nthat abstracts away control .ow and with statements. We then run a pointer analysis using standard techniques, \nwith lattice and constraints that are reminiscent of the ones usedinGatekeeper[12](although without using \nDatalog).Theuse ofadef-usegraphcapturesa smallamount of.ow sensitivity,similartowhatSSA-formhasbeenshown \ntocontributetoa .ow-insensitiveanalysis[16]. Forcontextsensitivity,weexperimentedwithbothk-CFA and object \nsensitivity(i.e., using the value of this as the context), and found object sensitivity to be the most \neffec\u00adtive.The analysis usesheap specialization(i.e., some object labels include a context component) \nand a simple widening function to ensure termination when combined with object sensitivity. To obtaina \nusefulmodelingofarrays, weintroducea spe\u00adcialpropertyname NumberPropertyrepresentingallproper\u00adties whosenameis \na number(i.e.,array entries).Fordy\u00adnamicproperty expressions where theproperty nameisdef\u00adinitelya number,the \nanalysis reads/writesthe NumberProp\u00aderty ofthereceiver;otherwise,it conservativelyreads/writes all ofitsproperties. \nSeveralbuilt-infunctions(such as call and apply)are supported by means of specialized transfer functions. \nAll other built-in functions are modelled by simple JavaScript mock-upfunctionsthat weincludein the analysis. \nWe model the HTML DOM and some other browser features using a special object label DOM. Some global variables,suchas \ndocument,areinitializedtoreferto DOM. Moreover,we conservativelyassumethat(1)anypropertyof DOM maypointto \nDOM,(2) anyfunctionreachablefrom DOM maybeinvokedwith DOM asthe this argumentand any number of actual \nargumentsthat all maypointto DOM, and (3) if DOM is invoked as a function, it stores all its argumentsaspropertieson \nDOM, and returns DOM.Rules 2and3 togethertake care of eventhandlersbeing registered on HTML elements. \nWe avoid many of the challenges that arise with the moredetailed modeling usedinTAJS[20]by using a relatively \nsimple abstractdomain. Given this basis, the queries of the framework of Sec\u00adtion3 are straightforward \ntoimplement, as are the refactor\u00adings themselves. 8Note that this is purely a UI-level integration; the \nunderlying analysis and the code for precondition checking and program transformation is independent \nofEclipse.  6. Evaluation Togain someinsightintothepracticalapplicability and use\u00adfulness of our approach, \nwe have evaluated our refactoring tool on a collection of existingJavaScriptprograms. In situations where \nthe tool determines that a requested refactoring canbeperformed,the refactoringpreconditions ensure that \nit is safe to perform the refactoring, without changing the behavior of the program. When a refactoring \nattempt is rejected by the tool, either the refactoring would infactchangethebehavior oftheprogram,in \nwhichcasethe answergivenbythetoolis correct, orthe rejectionis caused bythe analysisbeing too conservative.In \nthelatter case, the imprecision maybein the refactoringpreconditionsthat are de.nedin terms of ourqueries(Section4),in \nthede.nition of thederivedqueries on top of thebasic ones(Section3.2 3.6), or in the underlying pointer \nanalysis that we employ toimplementthebasicqueries(Section5).Toquantifyhow oftenthese situations occur, \nwe aimto answerthese research questions: Q1: Howoftenis arefactoring rejectedbecauseitsprecon\u00ad ditions \nare too conservative? Q2: How often is a refactoring rejected because a derived queryisde.nedtoo conservatively? \nQ3: How oftenis a refactoringrejectedbecause ofimpreci\u00ad sionin the underlyingpointer analysis? Forthe \nRENAME refactoring,itis also relevanthowitper\u00adforms compared to the naive alternative of simply using \nsearch-and-replacethroughtheprogram source code: Q4: How often does our RENAME refactoring give a dif\u00ad \nferent outcome than syntactic search-and-replace asper\u00ad formedin syntax-directededitors? We collected \na suite of benchmark programs and de\u00adsigned a set of experimentsfor each ofthe refactoringsspec\u00adi.edinSection4to \nevaluatethem withregardtotheseques\u00adtions. Table 1 shows an overview of our evaluation results, ex\u00adplained \nin more detail below: for every refactoring, the ta\u00adble shows the total number of attempted refactorings \non our benchmarks in column total applications , with the num\u00adberof successful applicationsinthe nextcolumn; \nweparti\u00adtionthe set of rejectedapplicationsaccordingto our research questions into cases where overly \nstrict preconditions pre\u00advented the application of an otherwise unproblematic refac\u00adtoring, cases whereimprecisederivedqueries \nwere an obsta\u00adcle, cases wherethe underlyingpointer analysisitself was at fault,and .nally caseswheretherejectionwasindicativeof \na realdanger of unsoundness. We will now .rst give an overview of our benchmark collection, then present \ndetailed evaluation results for each of the refactorings, and .nally summarize our .ndings by answeringthe \nresearchquestions.  refactoring total applications successful applications rejected applications total \nimprecise preconditions imprecise queries imprecise analysis justi.ed RENAME 16612 10693 5919 0 0 669 \n5250 ENCAPSULATE PROPERTY 510 363 147 35 0 30 82 EXTRACT MODULE (1) 50 43 7 0 0 0 7 EXTRACT MODULE (2) \n15 11 4 0 0 0 4 Table1. Quantitative evaluation ofour refactoringtool. 6.1 BenchmarkPrograms We have \ngathered 50 JavaScript programs. Four are taken from theV8benchmarks,9 23fromChromeExperiments,10 18 \nfrom the 10K Apart Challenge,11 and 5 from IE Test Drive.12 When collecting these benchmarks, we explicitly \nexcludedprograms that ourpointer analysis cannot analyze in afew minutes andonesthat use non-trivialdynamic \ncode execution(e.g., using eval). Four of the benchmarks use trivial dynamic code, such as setTimeout(\"loop();\", \n50), whichwehave manuallyreplacedbythe more manage\u00adable variant setTimeout(loop, 50).For27 ofthebench\u00admarks, \nthe tool produces a warning that they may contain assignments to the innerHTML property of a DOM object, \nwhich canpotentiallybe used to rundynamicallygenerated code,howevermanualinspection revealedthatthisis \nnotthe casein any of theprograms. Each benchmark comprises between 300 and 1700 lines of JavaScript code, \nand all perform non-trivial tasks. On a 3.0 GHz PC, each benchmark is analyzed in less than 4 seconds \nusing 256 MB memory. The time required for refactoring-speci.ccomputationsis negligiblecompared to the \ntime takenby thepointer analysis. 6.2 RENAME Our RENAME refactoring can rename both local variables \nand properties. Local variables are trivial to rename since there are nowith statementsin ourbenchmarks,so \nwefocus on renaming ofproperties. We have systematically applied our refactoring to every property expression \nand property initializer in each bench\u00admark, with the aggregate results showninTable1inthe row labeled \nRENAME.Out of a total of16612 attempted rename operations,10693 were successfully applied, and5919 were \nrejected by our tool. Further analysis revealed that of these rejections,5250 werejusti.ed.Twobenchmarks \nare respon\u00adsible for the remaining 669 rejections. In raytracer from ChromeExperiments,there are1062renamableaccessesbut \n665 of these arewrongly rejected,duetothepointeranaly\u00adsis beingimprecise. In .yingimages from the IE \nTest Drive 9http://v8.googlecode.com/svn/data/benchmarks/ 10http://www.chromeexperiments.com/ 11http://10k.aneventapart.com/ \n12http://ie.microsoft.com/testdrive/ benchmarks, theprogram adds some customproperties to a DOM element, \nwhichdue to ourimpreciseDOM model are then assumedtobeintrinsic;thus ourtool refusesto rename theseproperties.The \nremaining48benchmarksdo notgive rise to anyRENAME-speci.c spurious warnings. To evaluate how our tool \ncompares to a simple search\u00adand-replaceperformedatthelevel ofthe abstract syntaxtree (AST) in a syntax \ndirected editor, we use the equivalence classesde.nedbythe related querytodivide allthe accesses in abenchmarkinto \ncomponents.Accessesin a single com\u00adponent alwaysget renamed together.Ourtooldistinguishes itself from \nsimple search-and-replace tools when different components contain accesses with the same name. In par\u00adticular, \nour tool will rename a smaller set of accesses than search-and-replacewould,andif onecomponent canbe \nre\u00adnamed while anothercannot(e.g.,an accessinit may refer to an intrinsic property), search-and-replace \nwould change theprogram sbehavior, whereas our approach would reject the refactoring. Thetool.ndsthat28ofthe50benchmarkscontainmulti\u00adple \nrenamable components withthe same name, and19con\u00adtain same-name components where some can be renamed \nandothersare correctly rejected(18benchmarksfallinto both categories). Overall, our tool succeeds in \nrenaming 1567components, with393 of themhaving a namein com\u00admonwith anothercomponentinthe sameprogram.Thisin\u00addicatesthatour \nRENAME refactoringwill oftenbe morepre\u00adcise than search-and-replaceinpractice. To summarize, RENAME leads \nto smaller source code transformationsthan search-and-replacein about25% ofthe cases.Ofthe refactoring \nattempts that were notjusti.ably rejected,itissues spurious warningsin only6% ofthe cases. The spurious \nwarningsare all causedby imprecisioninthe pointer analysis.  6.3 ENCAPSULATE PROPERTY We have exhaustively \napplied the ENCAPSULATE PROP-ERTY refactoring to every property expression of the form this.x appearingin \nanlvaluepositioninside afunctionthat isinvokedatleast oncein a new expression, with the results showninTable1inthe \nrowlabeledENCAPSULATE PROP-ERTY. In the 50 benchmarks, there are 510 such expressions. Our tool is able \nto successfully encapsulate 363 of them, ignoring warnings about assignments to innerHTML.In the remaining147 \ncases,thetool reports apreconditionfailure and rejects the refactoring.  For82 ofthese cases,the rejectionisjusti.ed:inthree \ncases,getter/settermethodsalready exist; in eightcasesthe encapsulatedproperty would shadow referencesto \naglobal variable;inthe remaining71casesthereis a name clash with aparameter orlocal variable of the enclosing \nfunction.We manually veri.edthatthese cases canbe refactored success\u00adfullyifthenaming con.ictis .rst \nresolvedby renaming. Of the 65 remaining cases, where the refactoring is re\u00adjectedalthough it should \nhave been successful, 35 are due to alimitation of our speci.cation of ENCAPSULATE PROP-ERTY:it requires \nall objects on whichthepropertyis encap\u00adsulatedtobeinitializedbythe samefunction.In some cases, however, \nthere are identically named properties on objects constructed by different constructors, which need to \nbe en\u00adcapsulated at the same time because there are accesses that may referto eitherproperty.Supportingthis \nsituation seems like a worthwhile extension. Finally, there are 30 cases where the pointer analysis yieldsimprecise \nresults that cause spuriousprecondition vi\u00adolations.Of these,19 casescouldbe .xedbyimprovingthe modelling \nof standardlibrary arrayfunctions. The concept of well-scopedness and the conservative analysistodeterminewell-scopednessdescribedaboveprove \nto be adequate on the considered benchmarks: there are 28 cases wherepropertiestobe encapsulated are \naccessedfrom within aninnerfunctionof the constructor,andin all cases the analysis can establish well-scopedness, \nallowing the ac\u00adcess to be replaced by an identi.er reference instead of a getterinvocation. In summary, \nour tool is able to handle about 85% of the encapsulation attempts satisfactorily (not counting the justi.ablyrejectedattempts).The \nremaining15% are caused by,in about equalparts, restrictions of the speci.cation and imprecision ofthepointer \nanalysis.  6.4 EXTRACT MODULE TheEXTRACT MODULE refactoringisdif.cultto evaluate in an automated fashion, \nsince appropriate module bound\u00adaries have to be provided for every benchmark. We have performed two sets \nof experiments. In the .rst experiment, we extracted,for everybenchmark,the codein eachHTML script element \ninto its own module; in the case of stand\u00adalonebenchmarkswechosesource .lesastheunit of mod\u00adularizationinstead.The \nresults ofthis experiment are shown in Table 1inthe rowlabeledEXTRACT MODULE (1).In the secondexperiment,we \nmanuallydetermineda suitable mod\u00adularizationfor a subset of ourbenchmarks and used ourtool toperformit; \nagain, the results are showninTable1in row EXTRACT MODULE (2). For the .rst experiment, the automated \nmodularization was successfully performed on 43 out of 50 benchmarks. Onthe remainingsevenbenchmarks,the \nrefactoring was re\u00adjected since they contain accesses to module members for whichthe refactoringcannotprovethatthey \neitherde.nitely happen onlyduring moduleinitialization, orde.nitelyhap\u00adpen only afterinitialization.These \nrejectionsturn outtobe justi.ed: the accesses in question are performed by event handlers registered \nbefore or during module initialization. Whileitishighlylikelythatthesehandlerswillnot .reuntil afterinitializationis \ncomplete,thisis notguaranteed. In three cases, the rejections are arguablydue to the very coarse module \nstructureimposedby this experiment.If the code that installs the event handlers is excluded from the \nmodule, the handlers are guaranteed to only .re after ini\u00adtialization and the refactoring can go ahead. \nIn the remain\u00ading four benchmarks, on the other hand, event handlers are installed throughHTML attributesbeforethehandlerfunc\u00adtions \nare even de.ned, which could potentially cause races evenin the originalprogram. For the second experiment, \nwe randomly selected 15 benchmarks that are not already modularized and whose globalvariableshave suf.cientlydescriptive \nnamesto make it easy to manuallydetermineapossiblemodularization.In three oftheseprograms,wetookcommentsinto \naccountthat already suggested afunctionalgrouping ofglobalfunctions. Our tool canperform theproposed \nmodularization on11 of the 15 benchmarks. The remaining four are again rejected duetopotentialraces on \neventhandlers. In both experiments, our tool was thus able tohandle all testcases correctly.The categorizationofaccesses \naccording to whether they are evaluatedbefore or after moduleinitial\u00adization proved to be a valuable \naid in detecting potentially subtlebugs that couldbeintroducedby the refactoring.  6.5 Summary Overall, \nthe results of our evaluation are promising. Most attemptedrefactoringsareperformedsuccessfully,andwhen \nour tool rejects a refactoring it mostly does so for a good reason. We brie.y summarize our .ndings and \nanswer the general research questions posed at the beginning of this section. Q1:Rejectionsdue to rigidpreconditions \nSpurious rejec\u00adtions resulting from overly conservative preconditions are notvery common:thishappensin35 \noutof510-82 appli\u00adcations(8.2%) of ENCAPSULATE PROPERTY, and not at all for RENAME and EXTRACT MODULE. \nQ2:Rejectionsduetoderivedqueries Thederivedqueries are always suf.ciently precise in our experiments. \nFor in\u00adstance, ENCAPSULATE PROPERTY needs to prove well\u00adscopedness for 28 functions, and all of them \nare indeed shown tobe well-scopedby the algorithmdescribedinSec\u00adtion3.5. Q3: Rejections due to imprecise \npointer analysis Spuri\u00adous rejections resultingfromimprecision ofthepointeranal\u00adysis occur occasionally: \n669 of 16612-5250 applications (5.9%)of RENAME and 30 of 510-82 applications(7.0%) of ENCAPSULATE PROPERTY \nare rejected for this reason; and nonefor EXTRACT MODULE.  Q4:Improvementover naive search-and-replace \nFor393 out of 1567 groups of accesses that must be renamed to\u00adgether (25%), RENAME avoids some of the \nunnecessary modi.cationsperformedbyAST-level search-and-replace. These results indicate that the precision \nof the refactoring preconditions,thederivedqueries, and thepointer analysis is suf.cient for practical \nuse, and that our technique has advantagesinpractice comparedto naive approaches.  6.6 Discussion The \nvalidity of our evaluation may be threatened by (1) benchmarkselection,(2) analysislimitations, and(3) \nselec\u00adtion of refactoringtargets. While we only consider a relatively small number of benchmarks of modest \nsize, the programs included do demonstratea varietyofapplicationareas,fromthe morenu\u00admerically orientedV8 \nbenchmarks to browser-basedgames and visualization programs in the other benchmark sets. They also exhibit \nvery different programming styles, with some benchmarks making heavy use of the object system and others \nwrittenin an entirelyprocedural style. One notable feature of all our benchmarks is that none of them \nmake use of a framework library such as jQuery, Prototype, orMooTools.Thepointer analysis currentlyused \nin our implementation cannot tackle such libraries due to scalability issues. It is possible that the \nmeta-programming techniques employed by some of these frameworks could lead to very imprecise analysis \nresults that may lead to a large number of spurious rejections.In this case,it couldbe worthwhile to \nextend the analysis with special knowledge aboutparticularlytrickyframeworkfunctions. Ouranalysishas \ncertainlimitationsthatmayaffectthe va\u00adlidity of our results. In particular, our implementation only analyzes \ncode that is reachable either from top-level state\u00adments or from the DOM. Other code does not in.uence \nthe refactoring andisitself not affectedby refactoring.This means that our tool cannot safelybe applied \ntolibrary code alone, since most ofthefunctionsin alibrary willbe consid\u00adered dead code when there is \nno client to invoke them. For statically typedlanguages,thisproblem canbe side-stepped byassuming,forinstance, \neverymethodtobe an entrypoint, with the parameter types providing a conservative approxi\u00admation of the \npossible points-to sets of arguments. This is not easytodoinJavaScript, and makingworst-case assump\u00adtions \naboutargumentvalues wouldleadto unacceptablepre\u00adcision loss. All of our benchmarks are standalone applica\u00adtions,yet \nabouthalf of them contained some amount of un\u00adused code.Thisindicatesthattheissue mayindeeddeserve further \nattention. As a second restriction, our analysis currently does not attemptto analyzedynamicallygenerated \ncode.Wehandle thisin our refactoringtoolbyissuinga warningif apotential use of such code is detected \nto alert the user of possible changesto thebehavior of theprogram. Finally, our pointer analysis does \nnot currently model ECMAScript5getter andsetterproperties on objectliterals, but these are notusedin \nthebenchmarks anyway. These shortcomings ofthe analysis,however,do notseri\u00adouslyjeopardizethe validity \nof our approach, since wehave been careful to introduce a clean separation between anal\u00adysis and refactoring \nby means of the framework described inSection3.Thismakesit easy toplugina morepowerful pointer analysis \nwithouthavingto change the speci.cations orimplementations of the refactoringsthemselves. As a .nal threat \nto validity, one might question the se\u00adlection of targets on which to apply our refactoring tool. We \nhave based our evaluation on exhaustively applying the refactorings to as many targets in the code as \npossible to avoid selectionbias.Many ofthese applications would most likely not make sense in an actual \ndevelopment context; it is hence not clear what percentage of spurious rejections a user of our tool \nwould experienceinpractice.However, the overallpercentageof spurious rejectionsin our experimental evaluation \nis so low as to make it seem likely that our tool wouldbehave reasonablyinpractice.  7. RelatedWork \nTwo broad categories of related work can be distinguished: previous work on refactoringingeneral, and \nwork on static analysis ofJavaScriptprograms. 7.1 Refactoring The .eld of refactoring started in the \nearly 1990s with the Ph.D. theses ofOpdyke[23] andGriswold[11].Since then, the refactoring community \nhas focused on developing au\u00adtomated refactoring tools for both dynamically typed lan\u00adguages (e.g., [22, \n24]), and for statically typed languages (e.g.,[10,27,28]).Thediscussionbelow willfocus onpre\u00advious work \non refactoringfordynamicallytypedlanguages. Workby Roberts et al. ontheRefactoring Browser[24] targets \nSmalltalk, a dynamically typed language in which some of the same challenges addressed in this paper \narise. Formethodrenaming,e.g.,itbecomesdif.cultorimpossible to determine statically which call sites \nneed to be updated in the presence of polymorphism and dynamically created messages. Unlike our approach, \nwhich is based on static pointer analysis,Roberts et al. adopt adynamic approachto thisproblem,in which \nrenaming a methodinvolvesputting a method wrapper on the original method. As the program runs,the wrapperdetects \nsitesthat call the original method and rewrites those call sites to refer to the renamed method instead.The \nmaindrawbackof this approachis thatit relies on a test suite that exercises all call sites tobe rewritten. \nTheGurutoolbyMoore[22] provides automatic refac\u00adtoringfor theSelfprogramminglanguage.Gurutakes a col\u00adlection \nof objects, which need notbe relatedbyinheritance, and restructures them into a new inheritance hierarchy \nin which there are no duplicated methods, in a way that pre\u00adserves program behavior. Moore s algorithm \nis based on a static analysis of the relationshipbetween objects and meth\u00adodsin the system.Unlike our \nwork,Moore s approachdoes notinvolvetheprogrammerindeciding what refactoringsto apply and whereto applythem. \n RefactoringsupportinIDEsforJavaScript appears tobe initsinfancy.EclipseJSDT[6] andtheJetBrainsJavaScript \nEditor[21]aimtoproviderefactoringsupportforJavaScript, butthe currentimplementationsarefairlynaive.RENAME \nin theJavaScriptEditor,forinstance,seemsto essentiallyjust perform search-and-replace ontheAST.Renamingproperty \nx inCircle in the example ofFigure1,forinstance, would also rename all properties with name x in the \njsDraw2D librarythat theprogram uses. Two projects at the IFS Institute for Software focused on developing \nJavaScript refactoring plug-ins for Eclipse JSDT [2, 3], but their results do not seem to have been publishedand \nare not currently available.  7.2 AnalysisforJavaScript Several authorshavepursuedforms of staticprogramanal\u00adysis \nfor JavaScript. The TAJS analysis tool by Jensen et al.[18 20]aims atdetectingcommonprogrammingerrorsin \nJavaScriptprograms.Anderson et al.[1] de.ne atype sys\u00adtem for a core calculus based on JavaScript along \nwith an associated constraint-based type inference algorithm. Jang andChoe[17] use a constraint-based \nanalysisfor optimiz\u00ading programs written in a restricted variant of JavaScript. TheGatekeeper toolbyGuarnieri \nandLivshits[12] and the Actarus toolbyGuarnieri et al.[13] use static analysis to enforce security policies \nin JavaScript programs, e.g., that a program may not redirect the browser to a new location orthat untrustedinformationcannot \n.owtosensitiveopera\u00adtions.Guha et al.[15]describe a core calculusforJavaScript and use that formalism \nto design a type system that stati\u00adcally ensures a form of sandboxing. Other work by Guha et al. [14] \ninvolves a k-CFA analysis for extracting mod\u00adels of client behavior in AJAX applications. The Kudzu toolbySaxena \net al.[25] performs symbolic execution on JavaScriptcode and usesthe resultstoidentify vulnerability \nto codeinjection attacks. Like our work, manyofthese analyses relyheavilyonthe results of apointer analysis.For \nexample,theTAJS toolper\u00adforms apointer analysis aspartofits analysis,the optimiza\u00adtion technique by Jang \nand Choe relies directly on pointer analysis, and Gatekeeper s security policies are expressed interms \nof aDatalog-basedpointeranalysis.Inall of these instances,thepointer analysisprovidesmay-point-toinfor\u00admation, \nsimilar to the underlying analysisin our refactoring framework. However, as we have illustrated in Sections \n2 and 3, may-point-to information does not directly provide a useful abstraction for sound refactorings \nin JavaScript, whichhas motivatedthehigher-levelconceptsthat appear as queriesin ourframework, suchas \nthe notions of relatedness and well-scopedness.  8. Conclusion Wehavepresentedaprincipled approachfor \ntool-supported refactoringforJavaScriptprograms.Thekey insight of our work is that despite the challenging \ndynamic features of theJavaScriptlanguage itispossibleto capturefundamen\u00adtal correctnessproperties ofJavaScript \nrefactoringsusing a small collection ofqueriesin aframeworkbased onpointer analysis. With this framework, \nwe have demonstrated that thecomplexpreconditionsofrefactorings,suchasRENAME, ENCAPSULATE PROPERTY andEXTRACT \nMODULE,canbe expressed in a concise manner. Our experiments show that the refactoringpreconditionsweformulatehavehigh \naccu\u00adracy.Mostimportantly,ifaprogrammer srequesttoperform a refactoringis rejectedby the tool,itis usuallybecause \nthe refactoring would in fact change the behavior of the pro\u00adgram. Infuture work, we willfocus on advancingthe \nscalability of the underlying pointer analysis, and we plan to provide speci.cations andimplementationsof \nother refactoringsby way of ourframework.Anotherdirection of workisto adapt ourtechniquesto otherdynamicallytypedlanguages. \n References [1] C.Anderson,P.Giannini,andS.Drossopoulou. TowardsType InferenceforJavaScript. In Proc. \n19th European Conference on Object-Oriented Programming, volume 3586 of LNCS. Springer-Verlag,July2005. \n[2] C. Bachmann and E. P.ster. JavaScript Refactoring Eclipse Plug-in. Bachelor thesis,University ofApplied \nScienceRap\u00adperswil,2008. [3] M. Balmer and R. K\u00fchni. Refactoring Support f\u00fcr Eclipse JavaScriptDevelopment \nTools. Diploma thesis,University of AppliedScienceRapperswil,2008. [4] K. Beck. Extreme Programming Explained: \nEmbrace Change. Addison-Wesley,2000. [5] D.Crockford. JavaScript: TheGoodParts. O Reilly,2008. [6] Eclipse. \nJavaScript Development Tools. http://wiki. eclipse.org/JSDT. [7] ECMA. ECMAScript Language Speci.cation, \n5th edition, 2009. ECMA-262. [8] A. Feldthaus, T.Millstein,A. M\u00f8ller, M. Sch\u00e4fer, and F.Tip. Tool-supported \nRefactoring for JavaScript. http://www. brics.dk/jsrefactor/, 2011. TechnicalReport. [9] M. Fowler. Refactoring: \nImproving the Design of Existing Code. Addison-Wesley,1999. [10] A.Garrido andR.E.Johnson. RefactoringCwithConditional \nCompilation. InProc.18thIEEEInternationalConference on AutomatedSoftware Engineering,October2003. [11] \nW.G.Griswold. ProgramRestructuringas anAidtoSoftware Maintenance. Ph.D. thesis,University ofWashington,1991. \n [12] S. Guarnieri and V. B. Livshits. Gatekeeper: Mostly static enforcement of security and reliabilitypoliciesfor \nJavaScript code. In Proc. 18th USENIX Security Symposium, August 2009. [13] S. Guarnieri, M. Pistoia, \nO. Tripp, J. Dolby, S. Teilhet, and R. Berg. Saving the world wide web from vulnerable JavaScript. In \nProc. 20th International Symposium on Soft\u00adwareTesting and Analysis,July2011. [14] A.Guha,S.Krishnamurthi, \nandT.Jim. UsingStaticAnalysis for Ajax Intrusion Detection. In Proc. 18th International Conference onWorld \nWideWeb,May2009. [15] A. Guha, C. Saftoiu, and S. Krishnamurthi. The Essence of JavaScript. In Proc. \n24th European Conference on Object-Oriented Programming, volume 6183 of LNCS. Springer\u00adVerlag,June2010. \n[16] R. Hasti and S. Horwitz. Using Static Single Assignment FormtoImproveFlow-InsensitivePointerAnalysis. \nIn Proc. ACM SIGPLAN Conference on Programming Language De\u00adsign and Implementation,June1998. [17] D.JangandK.-M.Choe. \nPoints-toAnalysisforJavaScript. In Proc. 24th Annual ACM Symposium on Applied Computing, ProgrammingLanguage \nTrack,March2009. [18] S. H. Jensen, A. M\u00f8ller, and P. Thiemann. Type Analysis for JavaScript. In Proc. \n16th International Static Analysis Symposium, volume 5673 of LNCS. Springer-Verlag, August 2009. [19] \nS. H. Jensen, A. M\u00f8ller, and P. Thiemann. Interprocedural Analysis with Lazy Propagation. In Proc. 17th \nInternational Static Analysis Symposium, volume 6337 of LNCS.Springer\u00adVerlag,September2010. [20] S. H. \nJensen, M. Madsen, and A. M\u00f8ller. Modeling the HTMLDOMandbrowserAPIin static analysis ofJavaScript web \napplications. In Proc. European Software Engineering Conference and ACM SIGSOFT International Symposium \non Foundations ofSoftware Engineering,September2011. [21] JetBrains.JavaScriptEditor.http://www.jetbrains.com/ \neditors/javascript_editor.jsp. [22] I.Moore. AutomaticInheritanceHierarchyRestructuringand Method Refactoring. \nIn Proc. ACM SIGPLAN Conference on Object-Oriented Programming, Systems, Languages, and Applications,October1996. \n[23] W. F. Opdyke. Refactoring Object-Oriented Frameworks. Ph.D. thesis, University of Illinois at Urbana-Champaign, \n1992. [24] D. B. Roberts, J. Brant, and R. Johnson. A Refactoring Tool for Smalltalk. Theory and Practice \nof Object Systems, 3(4): 253 263, 1997. [25] P.Saxena,D.Akhawe,S.Hanna,S.McCamant,D.Song, and F. Mao. \nA Symbolic Execution Framework for JavaScript. In Proc.31stIEEESymposium on Security and Privacy,May \n2010. [26] M.Sch\u00e4fer,T.Ekman, andO.deMoor. SoundandExtensible Renaming for Java. In Proc. ACM SIGPLAN \nConference on Object-Oriented Programming, Systems, Languages, and Applications,October2008. [27] F. \nTip. Refactoring Using Type Constraints. In Proc. 14th International Static Analysis Symposium, volume \n4634 of LNCS.Springer-Verlag,August2007. [28] D. von Dincklage and A. Diwan. Converting Java Classes \nto Use Generics. In Proc. ACM SIGPLAN Conference on Object-OrientedProgramming,Systems,Languages, andAp\u00adplications,October2004. \n[29] World Wide Web Consortium. Document Object Model Level3. http://www.w3.org/DOM/DOMTR#dom3.  \n\t\t\t", "proc_id": "2048066", "abstract": "<p>Refactoring is a popular technique for improving the structure of existing programs while maintaining their behavior. For statically typed programming languages such as Java, a wide variety of refactorings have been described, and tool support for performing refactorings and ensuring their correctness is widely available in modern IDEs. For the JavaScript programming language, however, existing refactoring tools are less mature and often unable to ensure that program behavior is preserved. Refactoring algorithms that have been developed for statically typed languages are not applicable to JavaScript because of its dynamic nature. We propose a framework for specifying and implementing JavaScript refactorings based on pointer analysis. We describe novel refactorings motivated by best practice recommendations for JavaScript programming, and demonstrate how they can be described concisely in terms of queries provided by our framework. Experiments performed with a prototype implementation on a suite of existing applications show that our approach is well-suited for developing practical refactoring tools for JavaScript.</p>", "authors": [{"name": "Asger Feldthaus", "author_profile_id": "81490694597", "affiliation": "Aarhus University, Aarhus, Denmark", "person_id": "P2839141", "email_address": "asf@cs.au.dk", "orcid_id": ""}, {"name": "Todd Millstein", "author_profile_id": "81100018064", "affiliation": "University of California, Los Angeles, Los Angeles, CA, USA", "person_id": "P2839142", "email_address": "todd@cs.ucla.edu", "orcid_id": ""}, {"name": "Anders M&#248;ller", "author_profile_id": "81100071429", "affiliation": "Aarhus University, Aarhus, Denmark", "person_id": "P2839143", "email_address": "amoeller@cs.au.dk", "orcid_id": ""}, {"name": "Max Sch&#228;fer", "author_profile_id": "81381592942", "affiliation": "University of Oxford, Oxford, United Kingdom", "person_id": "P2839144", "email_address": "max.schaefer@cs.ox.ac.uk", "orcid_id": ""}, {"name": "Frank Tip", "author_profile_id": "81100333471", "affiliation": "IBM Research, Hawthorne, NY, USA", "person_id": "P2839145", "email_address": "ftip@us.ibm.com", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048078", "year": "2011", "article_id": "2048078", "conference": "OOPSLA", "title": "Tool-supported refactoring for JavaScript", "url": "http://dl.acm.org/citation.cfm?id=2048078"}