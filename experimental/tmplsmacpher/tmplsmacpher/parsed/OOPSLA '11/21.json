{"article_publication_date": "10-22-2011", "fulltext": "\n JET: Exception Checking in the Java Native Interface Siliang Li Lehigh University sil206@cse.lehigh.edu \n Abstract Java s type system enforces exception-checking rules that stipulate a checked exception thrown \nby a method must be declared in the throws clause of the method. Software writ\u00adten in Java often invokes \nnative methods through the use of the Java Native Interface (JNI). Java s type system, how\u00adever, cannot \nenforce the same exception-checking rules on Java exceptions raised in native methods. This gap makes \nJava software potentially buggy and often dif.cult to de\u00adbug when an exception is raised in native code. \nIn this pa\u00adper, we propose a complete static-analysis framework called JET to extend exception-checking \nrules even on native code. The framework has a two-stage design where the .rst stage throws away a large \nportion of irrelevant code so that the sec\u00adond stage, a .ne-grained analysis, can concentrate on a small \nset of code for accurate bug .nding. This design achieves both high ef.ciency and accuracy. We have applied \nJET on a set of benchmark programs with a total over 227K lines of source code and identi.ed 12 inconsistent \nnative-method exception declarations. Categories and Subject Descriptors D.2.4 [Software Engi\u00adneering]: \nSoftware/Program Veri.cation; D.2.12 [Software Engineering]: Interoperability General Terms Languages, \nReliability Keywords Exception Checking, Java Native Interface, Static Analysis 1. Introduction The \nJava programming language has a strong type sys\u00adtem that makes it a type-safe language. Among many other \nthings, its type system performs compile-time checking of exceptions. Speci.cally, a Java compiler enforces \nthat a checked exception must be declared in a method s (or con\u00adstructor s) throws clause if it is thrown \nand not caught by Permission to make digital or hard copies of all or part of this work for personal \nor classroom use is granted without fee provided that copies are not made or distributed for pro.t or \ncommercial advantage and that copies bear this notice and the full citation on the .rst page. To copy \notherwise, to republish, to post on servers or to redistribute to lists, requires prior speci.c permission \nand/or a fee. OOPSLA 11, October 22 27, 2011, Portland, Oregon, USA. Copyright c &#38;#169; 2011 ACM \n978-1-4503-0940-0/11/10. . . $10.00 Gang Tan Lehigh University gtan@cse.lehigh.edu the method (or constructor). \nWhen used properly, checked exceptions improve program reliability by enabling the com\u00adpiler to identify \nunhandled exceptional situations during compile time. The Java Native Interface (JNI) allows Java programs \nto interface with low-level C/C++/assembly code (i.e., native code). The JNI provides convenience and \nef.ciency in the Java software development. It allows Java code to invoke and to be invoked by native-code \nmodules. A native method is declared in a Java class by adding the native modi.er. For example, the ZipFile \nclass in Fig. 1 declares a native method named open. Once declared, native methods are invoked in Java \nin the same way as how Java methods are invoked. In the example, the ZipFile constructor invokes the \nnative open method. Native-method implementation can interact with Java through a set of JNI interface \nfunctions (called JNI func\u00adtions hereafter) as well as using all the features provided by the native \nlanguage. Through JNI functions, native methods can inspect, modify, and create Java objects, invoke \nJava methods, and so on. What is relevant for this paper is that native methods can also throw, handle, \nand clear Java exceptions through JNI functions. However, a Java compiler does not perform static exception \nchecking on native methods, in contrast to how exception checking is performed on Java methods. This \nlack of static exception checking on native methods might lead to unexpected crashes in Java programs. \nLet us use the program in Fig. 1 as an example. The Java-side declaration of open does not have any throws \nclause, leading programmers and the compiler to think that no checked exceptions can be thrown. However, \nthe C-code implementation does throw an IOException, violating the declaration. This cannot be de\u00adtected \nby a Java compiler and will escape from detection of Java s type system. Consequently, when the ZipFile \ncon\u00adstructor invokes the native open method, the constructor is not required to handle the exception \nor declare it. But in real\u00adity a thrown IOException in open crashes the program, out of the expectation \nof programmers and the compiler. This ex\u00adample was actually a real bug in java.util.zip.Zipfile of Sun \ns Java Development Kit (JDK); it was .xed only re\u00adcently in JDK6U23 (JDK 6 update 23) by adding a throws \nIOException clause to open.  Java code class ZipFile { // Declare a native method; // no exception declared \n private static native long open (String name, int mode, long lastModified); public ZipFile (...) { // \nCalling the method may crash the program ...; open(...); ... } static {System.loadLibrary(\"ZipFile\");} \n} C code void Java_ZipFile_open (JNIEnv *env, ...){ ... // An exception is thrown ThrowIOException(); \n... } Figure 1: An example demonstrating how a native method can violate its exception declaration. DEFINITION \n1. A native method has an inconsistent excep\u00adtion declaration if one or more checked exceptions that \ncan be thrown from its implementation is not a subclass of the exceptions declared in the method s Java \nsignature. This type of bugs can be dif.cult to debug when they occur. The JVM will report a Java stack \ntrace through which programmers can know the exception originates in a native method. However, since \nthe exception may be thrown due to nested function calls in native code, it is still dif.cult to locate \nthe source of the exception without knowing the native call stack. JNI debuggers (e.g., Blink [12] and \nothers [5]) can help, but not all bugs manifest themselves during particular program runs. The major \ncontribution of this paper is the design and im\u00adplementation of JET, a complete tool that extends Java \ns ex\u00adception checking mechanism to cover native code. JET stat\u00adically analyzes and examines JNI code \nfor .nding excep\u00adtion inconsistencies between native method declarations and implementations. It makes \nsound engineering trade-offs to achieve both high ef.ciency and accuracy. JET was evaluated on a set \nof benchmark programs from the Java Development Kit (JDK) and other sources with a total over 227K lines \nof C code. In all, 12 errors were identi.ed. The rest of the paper is structured as follows: we provide \nbackground information next. Details of JET s design are discussed in Section 3. Prototype implementation \nand eval\u00aduation are presented in section 4. We discuss closely related work in Section 5, and conclude \nin section 6.  2. Background Checked vs. unchecked exceptions. Java uses exceptions to handle errors \nand exceptional situations. An exception that may be thrown by a Java method is an effect of the method. \nTherefore, we use the term exception effects to refer to the set of exceptions that may escape a Java \nmethod. There are two kinds of exceptions: checked exceptions and unchecked exceptions1. Checked exceptions \nare used to represent those error conditions that a program can recover from and are therefore statically \nchecked by Java s type sys\u00adtem. That is, a checked exception that can escape a Java method (or constructor) \nhas to be a subclass of the exception classes declared in the method s (or constructor s) throws clause. \nBy contrast, unchecked exceptions represent irrecov\u00aderable situations and are not statically checked. \nFollowing Java s practice, JET performs exception checking only on checked exceptions. Nevertheless, \nJET can be easily adapted to infer the set of unchecked exceptions that are possibly pending in native \nmethods; this information would be use\u00adful to check if exceptions (either checked or unchecked) are handled \nproperly in native methods [15]. For convenience, we use exceptions and checked exceptions interchangeably \nin the rest of the paper unless specially noted. How JNI exceptions can be thrown and handled. Both Java \ncode and native code may throw exceptions. There are many ways that an exception may become pending in \nthe native side: Native code can throw exceptions directly through JNI functions such as Throw and ThrowNew. \n Many JNI functions throw exceptions to indicate failures. For instance, NewCharArray throws an exception \nwhen the allocation fails.  A native method can call back a Java method through JNI functions such as \nCallVoidMethod. The Java method may throw an exception. After the Java method returns, the exception \nbecomes pending in the native side.  All these situations result in a pending exception on the native \nside. In the rest of this paper, we will use the term JNI exceptions for those exceptions that are pending \non the native side, while using the term Java exceptions for those pending on the Java side. When a JNI \nexception is pending, native code is supposed to perform either one of the following things: 1 Java s \nunchecked exceptions include Error, RuntimeException and their subclasses; all other exception classes \nare checked exceptions  Perform some clean-up work (e.g., freeing buffers) and return the control to \nthe Java side. Then the exception handling mechanism of the JVM takes over.  Handle and clear the exception \non the native side using certain JNI functions. For example, ExceptionClear clears the pending exception; \nExceptionDescribe prints information associated with the pending exception; ExceptionOccurred checks \nif an exception is pending.  Interface vs. library code. Native code associated with a JNI package can \nroughly be divided into two categories: interface code and library code. The library code is the code \nthat belongs to a common native library. The interface code implements Java native methods and glues \nJava with C libraries through the JNI. For example, the implementation of the Java classes under java.util.zip \nhas a thin layer of interface code that links Java with the popular zlib C library. Typically, the size \nof interface code is much smaller than the size of library code. It is also worth mentioning that some \nJNI packages include only interface code. For example, native code in java.io directly invoke OS system \ncalls for I/O operations and does not go through a native library.  3. Design of JET JET is a static-analysis \nframework that examines excep\u00adtion effects of a native method s implementation and reports warnings if \nany inconsistency is found between the actual exception effects and the declared exception effects. The \nuse of static analysis allows us to examine every control .ow path in a program and to catch all potential \nbugs. This would have been more dif.cult if not impossible if using dynamic analysis. 3.1 System architecture \nFig. 2 presents a high-level diagram that depicts JET s archi\u00adtecture. At a high level, JET takes as \ninput a JNI code pack\u00adage, which is comprised of both Java class .les and native code. The package is \nfed into a two-stage exception analy\u00adsis. For each native-method implementation, the exception analysis \noutputs its actual exception effects. Afterward, JET compares the actual effects with the declared exception \nef\u00adfects extracted from Java class .les. If there is a mismatch, the warning generator issues a warning. \nNote that our anal\u00adysis does not examine Java code and examines only native code and type signatures \nin Java class .les. The Java com\u00adpiler already enforces Java code is well typed. A two-stage design. \nThe core of JET is a two-stage excep\u00adtion analysis, motivated by the following two observations. (1) \nLibrary code in a JNI package does not affect Java s state. As discussed in the background section, native \ncode in a JNI package consists of interface and library code. Intuitively, a general-purpose library \nsuch as the zlib C library works independently of Java. Only inter\u00adface code, which bridges between Java \nand the library, inspects and changes Java s state via JNI functions. In particular, only interface code \nwill throw, clear, or han\u00addle JNI exceptions. (2) Accurately computing exception effects of native meth\u00adods \nrequires .ne-grained static analysis. The need for this will be explained in more detail. But at a high \nlevel, the analysis needs path sensitivity since JNI code fre\u00adquently correlates its exception state \nwith other parts of the execution state; it needs context sensitivity because JNI code often invokes \nutility functions that groups sev\u00aderal JNI function calls. JET uses a two-stage design to take advantage \nof these observations. The .rst stage of JET s exception analysis is a coarse-grained analysis that aims \nto separate interface code from library code automatically. It is conservative and quickly throws away \ncode that is irrelevant for calculating exception effects. Afterward, the second stage can focus on the \nremaining smaller set of interface code. The second stage is much slower as it needs the full set of \nsensitivity for accurate analysis. It also performs exception-effect look\u00adups in Java class .les since \nnative code can call back Java methods, which may throw exceptions.  3.2 Separating interface and library \ncode The .rst stage of JET s exception analysis is a crude, .ow\u00adinsensitive analysis with the goal of \nseparating interface and library code. This analysis is helped by JNI s design philos\u00adophy that interaction \nwith the JVM in native code is through a set of well-de.ned JNI interface functions.2 Accordingly, a \nnative function is de.ned as part of the interface code if (1) it invokes a JNI function, or (2) it \ninvokes another native function that is part of the interface code.  If a native function does not belong \nto the interface code (by the above de.nition), then its execution will not have any effect on the JVM \ns exception state. A straightforward worklist algorithm that iterates through all functions is im\u00adplemented \nto calculate the set of interface code. We note that the above de.nition of interface code cov\u00aders the \ncase of calling back a Java method since a Java call back is achieved through invoking a JNI function \nsuch as CallVoidMethod. This implies that any native function that performs a Java call back is part \nof the interface code. Calling-back-into-Java is rare in some JNI packages, but can be common in others. \nFor instance, the sun.awt JNI pack\u00adage of JDK6 has almost one hundred call-back functions. 2 There are \nexceptions; for instance, native code can have a direct native pointer to a Java primitive-type array \nand read/rewrite the array elements through the pointer. Nevertheless, JVM s exception state (the focus \nof this paper) can be changed only by JNI functions.  Figure 2: System architecture of JET. Having \nthe .rst-stage exception analysis helps JET achieve (a) high ef.ciency, as our experiments demonstrate \n(see Sec. 4). Brie.y, without the .rst-stage analysis, JET s analysis time would be increased by about \n60 times on the set of JNI programs we studied. Another option that could avoid the .rst-stage analysis \nis to manually separate interface and li\u00adbrary code. Manual separation is straightforward to perform \nin practice as a JNI package is usually organized in a way that its library code is in a separate directory. \nNevertheless, it has two downsides. First, the manual process may make mistakes and code that does affect \nJava s state would be wrongly removed. Second, since manual classi.cation most likely uses a .le as the \nunit, it would include irrelevant func\u00adtions into interface code when they are in .les that mix rel\u00adevant \nand irrelevant functions. Our .rst-stage analysis uses functions as the classi.cation unit and provides \nautomatic classi.cation.  3.3 Fine-grained tracking of exception states At the second stage, JET applies \na .ne-grained analysis that is path-sensitive and context-sensitive. By applying the .ne\u00adgrained analysis \non the remaining interface code, JET can precisely identify the exception effects at each control-.ow \nedge. We next discuss requirements of performing accurate tracking before presenting our solutions. \n3.3.1 Requirements of JET s exception analysis The .rst requirement is that the analysis needs path sen\u00adsitivity \nbecause JNI programs often exploit correlation be\u00adtween exception states and other execution states. \nFor in\u00adstance, many JNI functions return an error value and at the same time throw an exception to signal \nfailures (sim\u00ad int *p = GetIntArrayElements(arr, NULL); if (p == NULL) /*exception thrown*/ return; for \n(i=0; i<10; i++) sum += p[i]; (b) void ThrowByName(const char* cn){ jclass cls = FindClass(cn); if(cls \n!= NULL){ ThrowNew(cls); } } Figure 3: Examples illustrate the need for path and context sensitivity. \nilar situation occurs in the Python/C API). As a result of this correlation between the exception state \nand the return value, JNI programs can either invoke JNI functions such as ExceptionOccured or check \nthe return value to decide on the exception state. Checking the return value is the pre\u00adferred way as \nit is more ef.cient. Fig. 3(a) presents such an example involving GetIntArrayElements, which returns \nthe null value and throws an exception when it fails.3 Invoking GetIntArrayElements results in two possible \ncases: an exception is thrown and p equals NULL; no excep\u00adtionisthrownand p equals non-null. That is, \nthe value of p is 3 JNI programs use a JNI environment pointer to access JNI functions; to avoid cluttering, \nthe use of the environment pointer is removed in all examples.  Figure 4: An FSM speci.cation of exception \nstates. Only the transitions of Throw, ExceptionClear, and unsafe opera\u00adtions are included. correlated \nwith the exception state. To infer correctly that the state before the loop is always a no-exception \nstate, a static analysis has to be path sensitive, taking the branch condition into account. The second \nrequirement is that the analysis also needs context sensitivity because JNI programs often use utility \nfunctions to group several JNI function calls. JNI program\u00adming is tedious; a single operation on the \nJava side usually involves several steps in native code. For instance, the func\u00adtion in Fig. 3(b) uses \na two-step process for throwing an ex\u00adception: .rst to get a reference to the class of the exception \nand then to throw the exception using the reference. For convenience, JNI programmers often use these \nkinds of utility functions to simplify programming. What excep\u00adtion is pending after an invocation of \nthe function in Fig. 3(b) depends on what the context passes in as the argument. Clearly, it is not possible \nfor JET to infer in every case the exact exception effects. For instance, suppose a JNI program calls \nback a Java method and JET cannot determine which Java method it is. In such cases, JET has to be conservative \nand assume any kind of exceptions can be thrown. In the analysis, this is encoded by specifying the exception \nstate afterwards becomes java.lang.Exception, the root class of all checked exceptions.  3.3.2 An FSM \nspeci.cation of exception-state transitions Before we introduce JET s (second-stage) exception anal\u00adysis, \nwe .rst present an FSM (Finite State Machine) that speci.es transitions of exception states; this is \nused in JET s static analysis to track how exception states change. JNI functions can change JVM s exception \nstate. For instance, an exception becomes pending after Throw;after ExceptionClear, the current pending \nexception is cleared. Transitions between exception states can be described by an FSM. Fig. 4 presents \na partial FSM speci.cation. The following table summarizes the meaning of the states in the FSM: NoExn \nNo JNI exception is pending ChkedExn(E) A checked exception E is pending UnChkedExn There is an unchecked \nexception pending Error A pending exception is not prop\u00aderly handled Since JET is primarily concerned \nwith checked excep\u00adtions, the FSM has a state for each speci.c type of checked exceptions but has only \none state that collectively represents all unchecked exceptions. The error state is used for capturing \nmistakes of mishan\u00addling JNI exceptions. The JNI requires very strict rules on handling JNI exceptions. \nFor instance, after a JNI exception is pending, calling Throw again results in unde.ned behav\u00adior; the \noriginal exception must be properly handled .rst. Our previous work [15] proposed a framework for identi\u00adfying \nbugs of mishandled JNI exceptions. JET s focus is to compute exception effects of native methods, which \nthe pre\u00advious system cannot do due to its simpler static analysis. We next discuss these differences \nbetween the two work in pro\u00adviding the design rational of JET.  3.3.3 Path-sensitive analysis Static-analysis \nalgorithms that capture full path sensitivity (e.g., [20]) are rather slow since they track all execution \nstates. Fortunately, we are interested only in exception states and transitions between exception states \nthat are described by the FSM. JET adopts ESP, proposed by Das et al. [4], a framework that is well-suited \nfor capturing partial path sensitivity. Givena safetyproperty speci.edbyanFSM, ESP sym\u00adbolically evaluates \nthe program being analyzed, tracks and updates symbolic states. A symbolic state consists of a prop\u00aderty \nstate and an execution state. A property state is a state in the FSM. An execution state models the rest \nof the pro\u00adgram s state and can be con.gured with different precision. The framework provides a conservative, \nscalable, and pre\u00adcise analysis to verify program safety properties. Readers may refer to the ESP paper \nfor a more detailed description. In the end, ESP infers information of the following format at each control-.ow \nedge: {(ps1, es1),..., (ps, esn)} n It contains n symbolic states and each symbolic state has its ownpropertystate \n(ps) and execution state (es). Intuitively, it means that there are n possible cases when the program \ns control is at the control-.ow edge. In the i-th case, the property state is psi and the execution state \nis esi. In the context of exception analysis, JET uses the FSM speci.ed in Fig. 4. That is, a property \nstate is an exception state. For the execution state, JET tracks two kinds of infor\u00admation: (1) constant \nvalues of variables of simple types; and  t ::= jobjn(sc) | jclsn(sc) | jthwn(sc) | jfidn(sc,sf ,st) \n| jmidn(sc,sm,st) s ::= Str |. n ::= 0 | 1 |* Figure 5: Syntax of Java types that JET tracks. (2) Java-side \ninformation of variables that hold Java refer\u00adences. We next explain how these two kinds of information \nare tracked. Tracking constant values. For variables of simple types, JET tracks their constant values \nusing an interprocedural and conditional constant propagation [26]. In particular, it tracks integer \nconstants and string constants. String constants are tracked since JNI programs often use them for .nding \na class, .nding a method ID, and other operations. Take the program in Fig. 3(a) as an example. After \nGetIntArrayElements, there are two symbolic states en\u00adcoded as follows. {(NoExn, { p = .}), (UnChkedExn, \n{ p =0 }) } There are two cases. In the .rst case, there are no exception pending and p is not a constant. \nIn the second case, there is an unchecked exception pending, and p =0. This infor\u00admation correlates the \nexception state with the value of p and enables the analysis to take advantage of the following if\u00adbranch \nto infer that before the loop it must be the case that no exception is pending. Following the standard \nconstant propagation, we use . for uninitialized variables and . for non-constants. Tracking Java types \nof C variables. JNI programs hold references to Java-side objects and use references to ma\u00adnipulate the \nJava state. These references are of special types in the native side. For example, a reference of type \njobject holds a reference to a Java object; a reference of type jmethodID holds a reference to a Java \nmethod ID. To track accurately exception states, it is necessary to in\u00adfer more Java-side information \nabout these references. For instance, since the JNI function Throw takes a jobject ref\u00aderence, JET has \nto know the class of the Java object to infer the exact exception class it throws. JET uses a simple \ntype system to capture this kind of information. The type system is presented in Fig. 5. The following \ntable summarizes the meaning of each kind of types. jobjn(sc) A reference to a Java object whose class \nis sc jclsn(sc) A reference to a Java class object with the class being sc jthwn(sc) A reference to a \nJava Throwable object whose class is sc jmidn(sc,sm,st) A reference to a Java method ID in class sc with \nname sm and type st jfidn(sc,sf ,st) A reference to a Java .eld ID in class sc with name sf and type \nst Each s represents either a constant string, or a unknown value (represented by .). When n is 0, it \nmeans the reference is a null value; when n is 1, it is non-null; when n is *, it can be either null \nor non-null. As an example, the following syntax denotes a non-null Java method ID in class Demo with \nname callback and type ()V . The type means that the function takes zero arguments and returns the void \ntype. jmid1( Demo , callback , ()V ) Fig. 6 presents a more elaborate example demonstrating how path \nsensitivity works in JET. The JNI program invokes a call-back method in class Demo. We assume that the \ncall\u00adback method throws a checked exception IOException, abbreviated as IOExn in the .gure. Before invoking \na Java method, there is a series of preparation steps in the program: (1) .nd a reference to the class \nDemo; (2) allocate an object; (3) get the method ID of the call-back function. Since each step may throw \nan exception, proper checking of null return values after each call is inserted in the code.  For each \ncontrol-.ow edge, Fig. 6 contains annotation that speci.es what JET s exception analysis infers. Notice \nthat after FindClass, there are two symbolic states repre\u00adsenting two cases. The following conditional \ntest checks the return value and as a result the number of symbolic states is reduced to one on both \nbranches. After CallVoidMethod, the only exception state is ChkedExn(IOException). JET can infer this \naccurately because it knows exactly which Java method the code is calling thanks to the information associated \nwith mid before the call. Since JET also takes Java class .les as input, it uses the method ID to perform \na method look-up in class .les and extracts its type signature. The type signature tells what ex\u00adceptions \nare declared in the method s throws clause. That is, our system takes advantage of the fact that the \nJava compiler enforces the declared exception effects on Java methods.  3.3.4 Context-sensitive analysis \nESP-style path-sensitivity works well on a single function. However, the context of its inter-procedural \nversion is based on the property state alone [4] and is not suf.cient for JNI programs. Fig. 7 presents \na typical JNI program for demon\u00adstrating the problem.  Figure 6: Example of JET path sensitivity. In \nthe example, function ThrowByName is used by the At L1, exception E1 is thrown and at L2, exception E2.We \nJava demo main function to throw exceptions. There are assume both E1 and E2 are checked exceptions. \ntwo places, denoted by L1 and L2, that invoke ThrowByName. ESP merges the execution states of the two \ncall sites when analyzing ThrowByName since their property states are the Figure 7: An example illustrating \nthe difference between ESP and JET. same; both are in the NoExn state. As a result, the value of parameter \ncn of ThrowByName equals . and the analysis de\u00adtermines that ThrowByName has the ChkedExn(Exception) \neffect. But in reality, E1 can only be thrown at L1,and E2 at L2. JET improves the context by using the \ncall-string ap\u00adproach (of length one) [22]. The context now becomes (nc, ps),where nc is the caller node \nand ps the property state. As a result, the format of information at a control-.ow edge becomes (nc, \nps): {(ps1, es1),..., (ps, esn)} n It represents the set of symbolic states when the context is (nc, \nps). With the added contextual information, JET is able to in\u00adfer the exception effects accurately for \nthe program in Fig. 7. In the .gure, we use m to represent a special (unknown) context that invokes \nthe Java Demo main function. The overall interprocedural algorithm is given in the ap\u00adpendix, using notations \nsimilar to those used in the ESP pa\u00adper. The complexity of this algorithm is Calls \u00d7|D|2 \u00d7 E \u00d7 V 2,where \nCalls is the number of call sites in the program, |D| is the number of exception states, E is the number \nof control-.ow edges in the control-.ow graph, and V is the number of variables in the program. The time \ncomplexity is more than that of ESP, but still remains polynomial.  3.3.5 Merging symbolic states At \na merge point of a control .ow graph, JET groups sym\u00adbolic states in the following fashion. First, JET \nmerges sym\u00adbolic states with respect to identical execution states. This is similar to the grouping function \nin ESP. Second, JET merges symbolic states that have identical execution states and merge their respective \nexception states. As property states are just Java exceptions, JET merges exception types according to \nthe Java exception class hierarchy. The second step of merging is possible because of the Java exception\u00adclass \nhierarchy. Grouping exception classes and only using a parent class of the exceptions is sound and conservative. \nThis may introduce imprecision. The advantage is that by having less symbolic states, the analysis runs \nfaster. 3.3.6 Transfer functions for JNI functons Invoking a JNI function updates the symbolic state. \nThe effects on the symbolic state are de.ned by a set of transfer functions. These transfer functions \nare de.ned according to their speci.cation in the JNI manual [16].   4. Prototype Implementation and \nEvaluation The core functionality of JET is implemented in OCaml, with about 3,000 lines of source code. \nIt utilizes CIL [18] to transform native C code into CIL s intermediate represen\u00adtation for exception \nanalysis. It uses the merge option pro\u00advided by CIL so that all native C code in a JNI software pack\u00adage \nis merged into a single .le and analyzed together. JET cannot analyze C++ code because CIL cannot parse \nit. JET also utilizes JavaLib [10] for looking up and accessing infor\u00admation in Java class .les. It allows \nJET to .nd Java method signatures and to retrieve information in the Java class hier\u00adarchy including \nthose related to exception classes, JET can be con.gured to search in any set of Java class .les. In \nour experiments, we con.gured JET to work with the entire set of classes in the JDK as well as non-JDK \nbenchmark pro\u00adgrams. 4.1 Experimental evaluation To evaluate JET, we conducted experiments to evaluate \nits accuracy and ef.ciency. All experiments were carried out on a Linux Ubuntu 9.10 box with Intel Core2 \nDuo CPU at 2.53GHz and with 512MB memory. The experiments were designed to answer the following set of \nquestions: (1) How effective is JET at uncovering true bugs? Does it generate too many false positives \nalong the process? (2) How ef.cient is JET in terms of analysis time? Does it scale to large programs? \n (3) Is the two-stage exception analysis necessary? We compiled a set of JNI packages for experimentation. \nThe packages and their numbers of lines of source code are listed in Table 1. The packages with names \nstarting with java are extracted from Sun s JDK6U03 (release 6 update 3). These packages cover all native \ncode in Sun s JDK under the share and solaris directories. Other packages include the following programs: \n(1) libec is a library for elliptic curve cryptography; OpenJDK provides JNI bindings for in\u00adterfacing \nwith the library; (2) hpdf is an open-source PDF creation library; as it does not ship with JNI bindings, \nwe created our own; (3) libreadline is a package that pro\u00advides JNI wrappers for accessing the GNU readline \nlibrary; (4) posix 1.0 is a package that provides JNI wrappers for accessing OS system calls; (5) spread \nis an open-source toolkit that provides a high performance messaging service across local and wide area \nnetworks; it comes with its default JNI bindings.  Evaluating JET s effectiveness and accuracy. For \nthe set of benchmark programs, Table 1 presents the number of warnings and the number of true bugs. Of \nthese programs, JET reported a total of 18 warnings, among which 12 are true bugs after manual inspection. \nThe overall false positive rate is 33%. ... data->name = \"java.io.IOException\"; ... if(data->name != \nNULL){ ThrowByName(data->name); } ... Figure 8: A typical example of false positives. There are conceptually \ntwo categories of bugs. The .rst category occurs when a native method does not de\u00adclare any exceptions \nbut its implementation can actually throw some. The second category occurs when a native method declares \nsome exceptions but the implementation can actually throw a checked exception that is not a sub\u00adclass \nof any of the declared exceptions. All the bugs we identi.ed in the benchmark programs belong to the \n.rst category. For example, in the libec package, the imple\u00admentation of native method generateECKeyPair \nthrows java.security.KeyException. However, the method s Java signature does not declare any exception. \nA same type of bug is found in the java.nio package of Sun s JDK, where native method force0 throws java.io.IOException \nbut the method s Java-side signature does not declare any exception. We manually checked against JDK6U23, \na new version of the JDK, for the bugs identi.ed in JDK6U03 and found that one bug in ZipFile has been \n.xed in JDK6U23. But other bugs in the JDK remain. There are six false positives. All false positives \nare caused by the imprecision when tracking the execution state. Fig. 8 presents a typical example. A \nstring constant that represents the name of a Java exception class is stored in a C struct and used later \nfor throwing an exception. Since JET tracks only constant values of C variables of simple types, when \nit en\u00adcounters the ThrowByName, it cannot tell the exact exception class. Consequently, it will report \nthe method that contains the code can possibly throw java.lang.Exception,the top checked exception class. \nHowever, the native method s Java-side signature declares a more precise exception class, java.io.IOException. \nWe could further improve JET s static analysis to reduce these false positives. But since the total number \nof false positives is quite small, we did not feel it is necessary. Although JET is designed to be conservative, \nit is possible for JET to have false negatives due to errors in its implemen\u00adtation. We conducted manual \naudit in half of the packages of our benchmark programs, obtained the ground truth, and 4 java.lang.other \nincludes all native code in java.lang but not in java.lang.strictmath.  JNI Package LOC Warnings True \nBugs java.io java.lang.other4 java.nio java.sql java.util.timezone libec libreadline 0.8.0 spread  \n   2,057 3 1 3,153 1 1 385 1 1 190 0 700 0 0 19,465 1 1 1,847 2 2 27,803 3 3     Table 1: Evaluation \nof accuracy of JET. compared it with the results reported by JET. This served as a way to debug JET and \nto gain con.dence. Analysis time. Table 2 presents the analysis time of JET on the benchmark programs. \nAs we can see, JET s coarse\u00adgrained exception analysis (.rst stage) is very ef.cient, tak\u00ading only 400 \n\u00b5s for all packages. The second stage dom\u00adinates the total time taken by JET. In all, it takes about \n8 seconds for all packages. Effectiveness of the two-stage system. Table 2 also presents metrics that \nare used to evaluate the effectiveness of the two-stage system. The third column (LOC retained/reduced) \nshows the numbers of lines of source code retained and re\u00adduced by the coarse-grained analysis. The numbers \nshow that it is very effective in terms of separating the code that affects Java s state. It reduces \nthe amount of code necessary to be analyzed by almost 99%. Only a small portion of code is left for the \n.ne-grained analysis. The column interface/library LOC (manual separation) shows the number of interface \ncode and library code deter\u00admined by manual separation. This is a quick, rough classi.\u00adcation using .les \nas the unit. That is, if a .le contains some JNI function calls, we put it under the category of interface \ncode. When compared to the column of LOC retained/re\u00adduced by the .rst stage, we see our automatic algorithm \nis better at separating interface code and library code; the main reason is that it uses functions as \nthe classi.cation unit. Finally, the column Time without 1st stage presents the analysis time if the \nwhole package is fed directly into the second stage without going through the .rst stage. This resulted \nin a dramatic slow down in runtime.  5. Related Work Almost all widely used programming languages support \na foreign function interface (FFI) for interoperating with pro\u00adgram modules developed in low-level code \n(e.g., [1, 2, 6, 14, 16, 19]). Most early work on FFIs aimed to provide ef.cient implementations. In \nrecent years, researchers studied how to improve upon FFIs safety, reliability, and security. FFI-based \ncode is often a rich source of software errors; a few recent studies reported hundreds of interface bugs \nin JNI programs ([8, 11, 15]). Errors occur often in interface code because FFIs gener\u00adally provide little \nor no support for safety checking, and also because writing interface code requires resolving dif\u00adferences \n(e.g., memory models and language features) be\u00adtween two languages. Past work on improving FFIs safety \ncan be roughly classi.ed into several categories: (1) Static analysis has been used to identify speci.c \nclasses of errors in FFI code [7, 8, 11, 15, 24]; (2) In another approach, dy\u00adnamic checks are inserted \nat the language boundary and/or in the native code for catching interface errors (see [13]) or for isolating \nerrors in native code so that they do not affect the host language s safety [25] and security [23]; (3) \nNew interface languages are designed to help programmers write safer interface code (e.g., [9]). JET \ntakes the static-analysis approach, following how checked exceptions are enforced in Java s type system. \nWe next compare in more detail with three closely re\u00adlated work on using static analysis to .nd bugs \nin JNI pro\u00adgrams [8, 11, 15]. Our previous system [15] and a system by Kondoh and Onodera [11] identify \nsituations of mishan\u00addling JNI exceptions in native code. Both systems compute at each program location \nwhether there is a possible JNI exception pending. However, they do not compute speci.c classes of pending \nexceptions. To do that, JET has to use a much more complicated static analysis. The analysis tracks information \nof C variables in native code and correlates them with the exception state; it also takes Java-method \nsignatures into account for tracking exceptions that may be pending when invoking a Java method. Both \nare necessary for com\u00adputing exception effects. J-Saf.re [8] identi.es type misuses in JNI-based code \nbut does not compute exception effects for native methods. J-Saf.re also .nds it necessary to track in\u00adformation \nof C variables that hold Java references. J-Saf.re performs polymorphic type inference that is based \non semi\u00aduni.cation, while JET uses interprocedural data.ow analy\u00adsis. There are cases where J-Saf.re \ns type inference can infer more precise information. However, we did not .nd this is a problem in practice. \n JNI Package 1st stage LOC 2nd stage Total interface/library LOC Time without time (\u00b5s) retained/reduced \ntime (s) time (s) (manual separation) 1st stage (s)     java.lang.strictmath 30 0/10,819 0 30\u00b5 2,314/8,505 \n1.11     java.net 100 527/8,968 3.13 3.13 9,748/0 94.69     java.security 0 0/78 0 0 78/0 0.05 \n    java.util.concurrent.atomic 0 0/16 0 0 16/0 0.08     java.util.zip 20 364/13,850 0.87 0.87 \n797/13417 63.73     hpdf 60 165/134,874 0.45 0.45 327/134,712 187.13     posix1.0 20 261/1,917 \n0.05 0.05 2,178/0 8.50     TOTAL 400 3,249/223,958 8.34 8.34 25,237/202,284 488.02 Table 2: Evaluation \nof ef.ciency of JET.      Many systems perform additional exception analysis, stronger than the \nbuilt-in static exception checking of lan\u00adguages such as Java. For example, the Jex tool [21] and others \n(e.g., [3, 17]) can compute what exceptions might be pending at each program point. This information \nis essential for understanding where exceptions are thrown and caught. JET computes this information \nfor JNI programs.  6. Conclusions Exceptions are commonly used in Foreign-Function Inter\u00adfaces (FFIs) \nas a way for native code to report error condi\u00adtions to the host language. Java adopts the notion of \nchecked exceptions, which are useful for statically identifying un\u00adhandled exceptional situations. JET \nis a system that extends Java s rules for checked exceptions to native code. It is both scalable and \nhas high precision thanks to its careful engi\u00adneering trade-offs. Evaluation demonstrates JET is effective \nat identifying exception-related bugs in native code. We are turning JET into an Eclipse plug-in tool, \nwhich will be useful for Java software developers.  Acknowledgments The authors would like to thank \nthe anonymous reviewers for their valuable comments.  References [1] M. Blume. No-longer-foreign: Teaching \nan ML compiler to speak C natively . Electronic Notes in Theoretical Computer Science, 59(1), 2001. [2] \nE. M. Chakravarty. The Haskell 98 foreign function interface 1.0: An addendum to the Haskell 98 report. \nhttp://www.cse.unsw.edu.au/~ chak/haskell/ffi/, 2005. [3] B.-M. Chang, J.-W. Jo, K. Yi, and K.-M. Choe. \nInterproce\u00addural exception analysis for Java. In SAC 01: Proceedings of the 2001 ACM symposium on Applied \ncomputing, pages 620 625, New York, NY, USA, 2001. ACM. [4] M. Das, S. Lerner, and M. Seigle. ESP: path-sensitive \nprogram veri.cation in polynomial time. In ACM Conference on Programming Language Design and Implementation \n(PLDI), pages 57 68, 2002. [5] C. Elford. Integrated debugger for Java/JNI environ\u00adments. http://software.intel.com/en-us/articles/ \nintegrated-debugger-for-javajni-environments/, Oct. 2010.  [6] K. Fisher, R. Pucella, and J. H. Reppy. \nA framework for interoperability. Electronic Notes in Theoretical Computer Science, 59(1), 2001. [7] \nM. Furr and J. S. Foster. Checking type safety of foreign function calls. In ACM Conference on Programming \nLanguage Design and Implementation (PLDI), pages 62 72, 2005. [8] M. Furr and J. S. Foster. Polymorphic \ntype inference for the JNI. In 15th European Symposium on Programming (ESOP), pages 309 324, 2006. [9] \nM. Hirzel and R. Grimm. Jeannie: Granting Java Native Interface developers their wishes. In ACM Conference \non Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA), pages 19 38, 2007. [10] \nJavaLib. JavaLib. http://javalib.gforge.inria.fr/. [11] G. Kondoh and T. Onodera. Finding bugs in Java \nNative Interface programs. In ISSTA 08: Proceedings of the 2008 International Symposium on Software Testing \nand Analysis, pages 109 118, New York, NY, USA, 2008. ACM. [12] B. Lee, M. Hirzel, R. Grimm, and K. McKinley. \nDebug all your code: A portable mixed-environment debugger for Java and C. In ACM Conference on Object-Oriented \nProgramming, Systems, Languages, and Applications (OOPSLA), pages 207 226, 2009. [13] B. Lee, M. Hirzel, \nR. Grimm, B. Wiedermann, and K. S. McKinley. Jinn: Synthesizing a dynamic bug detector for foreign language \ninterfaces. In ACM Conference on Programming Language Design and Implementation (PLDI), 2010. To appear. \n[14] X. Leroy. The Objective Caml system, 2008. http://caml. inria.fr/pub/docs/manual-ocaml/index.html. \n[15] S. Li and G. Tan. Finding bugs in exceptional situations of JNI programs. In Proceedings of the \n16th ACM conference on Computer and communications security (CCS), pages 442 452, 2009. [16] S. Liang. \nJava Native Interface: Programmer s Guide and Reference. Addison-Wesley Longman Publishing Co., Inc., \n1999. ISBN 0201325772. [17] D. Malayeri and J. Aldrich. Practical exception speci.cations. In Advanced \nTopics in Exception Handling Techniques, volume 4119 of Lecture Notes in Computer Science, pages 200 \n220. Springer, 2006. [18] G. C. Necula, S. McPeak, S. P. Rahul, and W. Weimer. CIL: Intermediate language \nand tools for analysis and transformation of C programs. In International Conference on Compiler Construction \n(CC), pages 213 228, 2002. [19] Python/C FFI. Python/C API reference manual. http: //docs.python.org/c-api/index.html, \nApr. 2009. [20] T. Reps, S. Horwitz, and M. Sagiv. Precise interprocedural data.ow analysis via graph \nreachability. In 22nd ACM Sym\u00adposium on Principles of Programming Languages (POPL), pages 49 61, 1995. \n[21] M. P. Robillard and G. C. Murphy. Static analysis to support the evolution of exception structure \nin object-oriented systems. ACM Transactions on Programming Languages and Systems, 12(2):191 221, 2003. \nISSN 1049-331X. [22] M. Sharir and A. Pnueli. Two approaches to inter-procedural data.ow analysis. In \nS. S. Muchnick and N. D. Jones, editors, Program Flow Analysis: Theory and Applications. Prentice-Hall \nInc., 1981. [23] J. Siefers, G. Tan, and G. Morrisett. Robusta: Taming the native beast of the JVM. In \nProceedings of the 17th ACM conference on Computer and communications security (CCS), pages 201 211, \n2010. [24] G. Tan and G. Morrisett. ILEA: Inter-language analysis across Java and C. In ACM Conference \non Object-Oriented Programming, Systems, Languages, and Applications (OOP-SLA), pages 39 56, 2007. [25] \nG. Tan, A. W. Appel, S. Chakradhar, A. Raghunathan, S. Ravi, and D. Wang. Safe Java Native Interface. \nIn Proceedings of IEEE International Symposium on Secure Software Engineering, pages 97 106, 2006. [26] \nM. N. Wegman and F. K. Zadeck. Constant propagation with conditional branches. ACM Transactions on Programming \nLanguages and Systems, 13(2):181 210, April 1991. A. Inter-procedural exception analysis We .rst describe \nsome notations. A symbolic state S = D \u00d7 X, where a property state D = { NoExn, ChkedExn(E1),..., ChkedExn(En), \nUnChkedExn, Error }, and an execution state X is a map from variables to values in a constant\u00adpropagation \nlattice or Java types. Given a symbolic state s, ps(s) is its property state and es(s) is its execution \nstate. A global control-.ow graph = [N, E, F ],where N is a set of nodes, E is the set of edges, and \nF is the set of functions. Notation src(e) denotes edge e s source node and dst(e) the destination node. \nFor node n, notation In0(n) stands for its .rst incoming edge and In1(n) the second (if there is one). \nA merger node is assumed to have two incoming edges. For a non-branch node, OutT (n) stands for its only \noutgoing edge. For a branch node, OutT (n) stands for the true branch and OutF (n) the false branch. \nWe assume each function has a distinguished entry node, denoted by entryNode(f ). Notation fn(n) denotes \nthe function that node n belongs to. When n stands for a function-call node, callee(n) denotes the callee \nfunction. As in ESP, a denotes a function that merges a set of symbolic states according to the property \nstate: a(ss )= { [d, es(s)] | d . D . ss[d]= \u00d8} s.ss[d] where ss[d]= { s | s . ss . d = ps(s) }. We use \nF to denote transfer functions for nodes. For instance, FMerge is the transfer function for merger nodes. \n FMerge(n, ss1, ss2)= a(ss1 ss2). ' FCall (f, ss ,a\u00af)= a({s'|s= fCall (f, s,a\u00af) . s . ss }) where fCall \nbinds parameters of f to the symbolic\u00adevaluation results of arguments a\u00afin symbolic state s; it also \ntake cares of scoping by removing bindings for variables not in the scope of f.  ' FBranch (n, ss ,v)= \na({ s ' |s = fBranch (n, s,v) . s . ss . es(s ')= .}),where fBranch takes advantage of the fact that \nthe result of the branching condition is v and adjusts the symbolic state s. '' FExit (f, ss )= a({ \ns | s = fExit (f, s) . s . ss }), where fExit takes care of scoping by removing variables that are only \nin the scope of f from the symbolic state.  We use FJNI to denote the transfer functions for JNI functions \nand we use FOther to denote the transfer func\u00adtion for all other nodes.  Algorithm 1: Auxiliary procedures \nprocedure Add(e, nc,d, ss ) begin if Info(e, nc,d)= ss then Info(e, nc,d):= ss ;  Worklist := Worklist \n{[dst(e),nc,d]}; procedure AddTrigger(n, nc,d, ss,a\u00af) begin ' ss := FCall (fn(n), ss ,a\u00af); e := OutT \n(n); ' ' ss := a(ss Info(e, nc,d)); Add(e, nc,d, ss '); procedure AddToSummary(n, nc,d, ss ) begin ' \nss = FExit (fn(n), ss ); ' if Summary(fn(n),nc,d)= ss then Summary(fn(n),nc,d):= ss ' ; foreach '' n \n,d ' . D such that Info(In0(nc),n ,d ')= \u00d8 cc do  ' Worklist := Worklist {[nc,n ,d ']}; c Algorithm \n2: Inter-procedural exception analysis Input Global control-.ow graph=[N, E, F ]; fentry . F is an entry \nfunction to be analyzed Globals Worklist :2N\u00d7N\u00d7D; Info :(E \u00d7 N \u00d7 D) . 2S; Summary :(F \u00d7 N \u00d7 D) . 2S; \nprocedure solve begin . e, n, d, Info(e, n, d)= \u00d8; . f ,n,d, Summary(f ,n,d)= \u00d8; e := OutT (entryNode(fentry \n)); Info(e, m, NoExn):= {[NoExn, .]}; Worklist := {[dst(e), m, NoExn]}; while Worklist = \u00d8 do Remove \n[n, nc,d] from Worklist; ssin := Info(In0(n),nc,d);  switch n do case n . Merge ssout := FMerge(n, \nssin , Info(In1(n),nc,d)); case n . Branch Add(OutT (n),nc,d,FBranch (n, ssin ,T )); Add(OutF (n),nc,d,FBranch \n(n, ssin ,F )); case n . JNIFun Add(OutT (n),nc,d,FJNI (n, ssin ,nc,d)); case n . Call(\u00afa) ssout := \u00d8; \nforeach d ' . D such that ssin [d ']= \u00d8 do sm := Summary(callee(n),n,d '); if sm = \u00d8 then ssout := ssout \nsm; AddTrigger(entryNode(callee(n)), n, d ' , ssin [d '],a\u00af); Add(OutT (n),nc,d,a(ssout )); case n . \nExit AddToSummary(n, nc,d, ssin ); case n . Other ssout := FOther (n, ssin ,nc,d); Add(OutT (n),nc,d, \nssout ); return Info        \n\t\t\t", "proc_id": "2048066", "abstract": "<p>Java's type system enforces exception-checking rules that stipulate a checked exception thrown by a method must be declared in the throws clause of the method. Software written in Java often invokes native methods through the use of the Java Native Interface (JNI). Java's type system, however, cannot enforce the same exception-checking rules on Java exceptions raised in native methods. This gap makes Java software potentially buggy and often difficult to debug when an exception is raised in native code. In this paper, we propose a complete static-analysis framework called JET to extend exception-checking rules even on native code. The framework has a two-stage design where the first stage throws away a large portion of irrelevant code so that the second stage, a fine-grained analysis, can concentrate on a small set of code for accurate bug finding. This design achieves both high efficiency and accuracy. We have applied JET on a set of benchmark programs with a total over 227K lines of source code and identified 12 inconsistent native-method exception declarations.</p>", "authors": [{"name": "Siliang Li", "author_profile_id": "81447597431", "affiliation": "Lehigh University, Bethlehem, PA, USA", "person_id": "P2839194", "email_address": "sil206@cse.lehigh.edu", "orcid_id": ""}, {"name": "Gang Tan", "author_profile_id": "81309504867", "affiliation": "Lehigh University, Bethlehem, PA, USA", "person_id": "P2839195", "email_address": "gtan@cse.lehigh.edu", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048095", "year": "2011", "article_id": "2048095", "conference": "OOPSLA", "title": "JET: exception checking in the Java native interface", "url": "http://dl.acm.org/citation.cfm?id=2048095"}