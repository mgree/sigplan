{"article_publication_date": "10-22-2011", "fulltext": "\n Freedom Before Commitment A LightweightType System for Object Initialisation AlexanderJ. Summers PeterM\u00a8uller \nETH Zurich, Switzerland {Alexander.Summers, Peter.Mueller}@inf.ethz.ch Abstract One of the main purposes \nof object initialisation is to estab\u00adlish invariants such as a .eld being non-null or an immutable data \nstructure containing speci.c values. These invariants are then implicitly assumed by the rest of the \nimplementa\u00adtion, for instance, to ensure that a .eld may be safely derefer\u00adenced or that immutable data \nmay be accessed concurrently. Consequently, letting an object escape from its constructor is dangerous; \nthe escaping object might not yet satisfy its in\u00advariants, leading to errors in code that relies on them. \nNever\u00adtheless, preventing objects entirely from escaping from their constructors is too restrictive; \nit is often useful to call auxil\u00adiary methods on the object under initialisation or to pass it to another \nconstructor to set up mutually-recursive structures. We present a type system that tracks which objects \nare fully initialised and which are still under initialisation. The system can be used to prevent objects \nfrom escaping, but also to allow safe escaping by making explicit which ob\u00adjects might not yet satisfy \ntheir invariants.We designed, for\u00admalised and implemented our system as an extension to a non-null type \nsystem,but it is not limited to this application. Our system is conceptually simple and requires little \nanno\u00adtation overhead; it is sound and suf.ciently expressive for many common programming idioms. Therefore, \nwe believe it to be the .rst such system suitable for mainstream use. Categories and Subject Descriptors \nD.3.3 [Language Constructs andFeatures]: Classes and Objects General Terms Design, Languages, Reliability \n1. Introduction Object-oriented programs maintain numerous invariants about their heap data structures. \nThese invariants re.ect de- Permission to make digital or hard copies of all or part of this work for \npersonal or classroomuseisgrantedwithout feeprovidedthat copies arenot madeordistributed forpro.torcommercialadvantage \nandthatcopiesbearthisnoticeandthefullcitation onthe .rstpage.To copy otherwise,to republish,topostonserversorto \nredistribute tolists, requirespriorspeci.cpermission and/ora fee. OOPSLA 11, October22 27,2011, Portland,Oregon,USA. \nCopyright c &#38;#169;2011ACM978-1-4503-0940-0/11/10. . .$10.00 sign decisions that are crucial for developing, \nunderstanding, and maintaining the code. They are assumed by method im\u00adplementations, for instance, to \nensure that a .eld may be safely dereferenced. Most invariants do not hold for newly-allocated objects; \ntheyneed to be established during object initialisation before the code operating on the object may rely \non them. Main\u00adstream programming languages such as Java, C# and C++ provide constructors to separate \ninitialisation code that has to establish invariants from other code that may rely on the invariants. \nA problem occurs when an object escapes from its constructor before it is fully initialised. The escaping \nob\u00adject might not yet satisfy its invariants, which may lead to errors in code that relies on them. Due \nto dynamic method binding, determining which code potentially operates on an escaped object is in general \nnon-modular. Escaping occurs if a constructor (1) calls a method on the object under initialisation, \n(2) passes the object as an argument to a method or constructor, or (3) stores the object in a .eld of \nanother object, in a static .eld, or in an array. Letting an object escape from its constructor is often \nconsidered bad programming practice. Many programming guidelines and blogs recommend to avoid escaping, \nstyle checkers such as PMD [1] issue warnings for some forms of escaping, and languages such as Java \nand C# enforce some ad-hoc rules to prevent some forms of escaping (for instance, Java does not allow \none to refer to the this literal before calling the superclass constructor). However, none of these approaches \neffectively prevents escaping. Entirely preventing objects from escaping their construc\u00adtors would be \ntoo restrictive. It is useful to call auxiliary methods on a new object, and to pass it to other construc\u00adtors \nto set up mutually-recursive structures. All three forms of escaping occur in the Java API implementation. \nFor in\u00adstance, a constructor of class LinkedList calls the method addAll to add all elements of a collection \nto the new list; a constructor of class ScrollPane passes this as argument to a constructor of PeerFixer, \nwhich stores it in a .eld. In this paper, we present a type system that tracks which objects are fully \ninitialised and which are still under initiali\u00adsation. The type system can be used to prevent objects \nfrom escaping,but also to allow safe escapingby makingexplicit which objects might not yet satisfy their \ninvariants. Our ob\u00adjective is to design a system that is suitable for mainstream use, which requires \nit to satisfy the following design goals:  1. Modularity: The type system can check each class sepa\u00adrately \nfrom its subclasses and clients. 2. Soundness: The system is type safe: objects that are con\u00adsidered \nto be fully initialised do satisfy their invariants. 3. Expressiveness: The type system handles common \nini\u00adtialisation patterns. In particular, it allows objects to es\u00adcape from their constructors and supports \nthe initialisa\u00adtion of cyclic structures. 4. Simplicity: The type system is conceptually simple and \nrequires little annotation overhead, making it easy and convenient to learn and use.  For concreteness, \nwe present our type system as an ex\u00adtension of a non-null type system [10], which has several advantages: \n(1) Preventing null-dereferencing statically is of great practical importance. (2) The expected invariant \nis very clear: .elds of non-null types contain non-null values. (3) Targeting an invariant that can be \nchecked by a type system rather than runtime checks or veri.cation allows us to formalize the whole system \nin one coherent framework. (4) Most of the related work on object initialisation has been applied to \nnon-null types, which enables detailed compar\u00adisons. Beyond non-nullness, our type system generally sup\u00adports \nmonotonic invariants: invariants that get established by a constructor and are never violated afterwards. \nThese invari\u00adants include one-state invariants, which are supposed to hold in each execution state (such \nas non-nullness of a .eld), as well as two-state invariants, which are supposed to hold for all pairs \nof states (such as immutability of a data structure).  Contributions. The key contribution of this paper \nis a type system for object initialisation that is suitable for main\u00adstream use. More speci.cally, we \npresent: the .rst type system for object initialisation that meets all four design goals stated above; \n a formalization of the type system for a sequential core language with non-null types, and preservation \nproof;  a discussion of how to support concurrency and addi\u00adtional language features such as arrays \nand static .elds;  a discussion of how to support monotonic invariants be\u00adsides the non-nullity of .elds; \n an implementation of the type checker in the Spec# com\u00adpiler [15];  an evaluation using two major \napplications written in Spec# as well as examples from the literature.  Outline. In the next section, \nwe provide the background on non-null types, and discuss previous attempts to handle object initialisation \nin this context. We present the design of our type system informally in Sec. 3 and formalise it in Sec. \n4. We discuss extensions of our type system to further language features and invariants in Sec. 5.We \nreport on our implementation and its application in Sec. 6, discuss related work in Sec. 7, and conclude \nin Sec. 8. 2. Background on Non-NullTypes To detect null-dereferences statically,F\u00a8ahndrich and Leino \nproposed a non-null type system [10], in which reference types can be annotated with non-nullity expectations. \nTheir idea has been widely adopted in the research community various non-null type systems have been \ndeveloped for Spec# (an extension of C#) [11, 15], Eiffel [6, 17, 19], and Java [7]. In this section, \nwe present those aspects of non\u00adnull types that webuild on and summarise previouswork on object initialisation \nin non-null type systems. 2.1 Non-NullTypes The existing non-null type systems share the same funda\u00admental \nidea: each reference type C (in the declaration of a .eld, variable, method signature, or in a cast, \netc.) is replaced by two variants C? and C!, indicating a possibly-null and a non-null type, respectively. \nThe type system enforces that expressions with non-null types do not evaluate to the null value; it then \nprevents null pointer exceptions by forbidding the dereferencing of expressions with possibly-null types. \nThe doubly-linked list example in Fig. 1 (the motivating example from [10]) illustrates the use of non-null \ntypes. Ev\u00adery Node has references to its predecessor and successor in the list. The corresponding .elds \nprev and next are of the non-null type Node!, which means that the list is cyclic. In addition, each \nnode has a non-null reference to the List ob\u00adject it belongs to. The list elements stored in the nodes \nare of type Object?, that is, are allowed to be null. Each instance of class List stores a non-null reference \nto a sentinel node. The method call this.sentinel.insertAfter(data) in method insert type-checks because \nthis is implicitly non\u00adnull and sentinel is declared to be non-null; hence, both expressions may be dereferenced. \nC! is a subtype of C? for any C since C! is a speciali\u00adsation of C? both in terms of sets of possible \nvalues and in terms of behaviour (one can do strictly less with a C? refer\u00adence). With this subtype relation, \nthe usual type rule for as\u00adsignment ensures that only non-null values can be assigned to variables declared \nwith a non-null type (called non-null variables in the following). In particular, it ensures that the \ninitialisation of non-null .elds is monotonic: once a non-null .eld has been initialised with a non-null \nvalue, it will never store null. Downcasts from possibly-null types to non-null types are possible and \nentail a runtime check.  2.2 Object Initialisation The main technical challenge in designing a non-null \ntype system is how to handle object initialisation. The problem  class List { Node! sentinel ; List() \n{ this.sentinel = new Node(this); } void insert (Object? data) { this.sentinel.insertAfter(data); } \n} class Node { Node! prev; Node! next; List! parent; Object? data; // for sentinel construction Node([Free] \nList! parent) { this.parent = parent; this.prev = this; this.next = this; } // for data node construction \n Node(Node! prev, Node! next, Object? data){ this.parent = prev.parent ; this.prev = prev; this.next \n= next; this.data = data; } void insertAfter (Object? data) { Node n = new Node(this, this.next, data); \nthis.next.prev = n; this.next = n; } } Figure 1. Doubly-linked list example. The List construc\u00adtor \nillustrates mutual object initialisation; the this reference is passed to the .rst Node constructor and \nassigned to the node s parent .eld while the List object is still under ini\u00adtialisation. Like in Java \ns LinkedList implementation, the nodes of our list form a cyclic structure, whose initialisation is illustrated \nby the .rst Node constructor. The [Free] an\u00adnotation in its signature is explained in Sec. 3. is that \nthe runtime system initialises all .elds of a new object with zero-equivalent values. So even .elds declared \nas non-null start out being null. Until all non-null .elds of the newly-created object have been initialised \nwith non-null values, it would not be sound to make use of their declared non-null information. Several \nsolutions have been proposed for tackling the problem of initialisation for a non-null type system. They \nall require constructors to initialise the non-null .elds of their class with non-null values before \ntheyterminate1. This is en\u00adforced statically using a straightforward de.nite assignment analysis, which \nchecks that each non-null .eld of a class can be statically guaranteed to be assigned to at least once \nin its constructor. The existing solutions differ in how theyhandle objects that escape from their constructor.We \nsummarise the approaches in the following and evaluate them using the four design goals stated in the \nintroduction. RawTypes. The originalworkofF\u00a8ahndrich and Leino [10] introduced raw types to handle initialisation. \nIn addition to the non-null information, raw types have an additional an\u00adnotation indicating that the \nreferred object may not be fully initialised and, thus, may not be reliable in terms of non\u00adnull guarantees. \nAn object is allowed to escape via a method or constructor call, provided the signature of the method \nor constructor explicitly permits its receiver or arguments to be raw (and consequently does not rely \non their non-null guar\u00adantees). However, the system does not permit a raw refer\u00adence to be assigned to \na .eld of any object, even of the referenced object itself. This restriction prevents common implementations \nsuch as the mutual initialisation of multi\u00adple objects, or cyclic data structures such as the Node struc\u00adture \nin the example from Fig. 1. So with respect to our de\u00adsign goals,F\u00a8ahndrich and Leino s type system is \nrelatively simple2, sound, and modular,but not suf.cientlyexpressive to handle the initialisation of \nrecursive structures. The only work-around for this problem is to declare the .elds of the recursive \nstructure with possibly-null types and to inject a downcast each time theyget dereferenced, which clutters \nup the code and leads to unnecessary runtime checks. DelayedTypes. F\u00a8ahndrich and Xia s delayed types \n[11] dec\u00adorate reference types with a delay time which indicates the notional point during execution \nafter which the referenced object satis.es its non-null annotations. Delay scopes are in\u00adtroduced into \nthe program text to indicate points at which certain times will expire. Delay times on reference types \ncan be existentially quanti.ed, with bounds expressing relation\u00adships between various delay times. Because \nreferences to many objects can share the same delay types, the system is .exible enough to support practical \nexamples. So with respect to our design goals, delayed types are expressive, sound, and modular. However, \nthe complexity of the annota\u00adtions makes the system as presented in the paper unsuitable for mainstream \nuse. Indeed, when implementing the system in Spec# [15], F\u00a8 ahndrich and Xia decided to greatly cut down \nthe complex\u00adity of the type system, including only a single Delayed 1Masked Types [21] free constructors \nfrom this obligation for those .elds that the constructor s signature declares to be left un-initialised. \n2Some complexity comes from thefact that raw types include information to which class in the inheritance \nhierarchy an object has been initialised. For instance, raw(A) expresses that the .elds declared in class \nA and its superclasses have already been initialised, whereas the remaining .elds of the object might \nnot.  attribute in the language, representing an unknown delay time. The resulting implementation is \nhowever unsound: at method calls it allows any parameters to be provided as de\u00adlayed arguments,but inside \nthe method bodies assumes each such argument to have the same delay time. This assump\u00adtion can be exploited \nto provoke a null pointer exception; we discuss such an example in Sec. 7. Fixing this problem by enforcing \nthat all delayed references have the same de\u00adlay time would make the system too in.exible to handle the \nmutual initialisation of multiple objects. Attached Types. Eiffel s non-null types (called attached types \n) do not appear to address the problem of object ini\u00adtialisation soundly. According to the Eiffel standard \n[6], a .eld of class C may be considered properly set (essentially, fully initialised) provided it . \n. . is (recursively) properly set at the end position of every creation procedure of C. Since objects \nmay escape from their creation procedures (construc\u00adtors), this is not suf.cient for soundness. The problematic \nsituation can sometimes be avoided by providing default cre\u00adation procedures for all types of non-null \n.elds these get implicitly called when a .eld is found not to be initialised yet. However, default initialisation \ncannot handle cases such as cyclic lists, or the mutual initialisation of objects. So with respect to \nour design goals, attached types are simple, ex\u00adpressive, and modular,but not sound. The actual Eiffel \nimplementation appears (by experi\u00adment) to actually prevent unsoundness by enforcing much stronger rules: \nUsing an object under initialisation as re\u00adceiver or argument of a call is permitted if the code of the \ncalled method type-checks without making non-null as\u00adsumptions for that object. For dynamically-bound \nmethods, this check needs to be repeated for each override of the called method, which makes the type \nchecking non-modular. Moreover, an object may not be assigned to any .eld until its initialisation is \ncomplete. This rule makes cyclic and mu\u00adtual initialisations impossible. So the Eiffel implementation \nis simple and sound,but neitherexpressive nor modular. MaskedTypes. The recent work of Qi and Myers [21] \npro\u00adposes masked types to tackle object initialisation. This sys\u00adtem provides versions of class types \nin which any subset of .elds can be masked , indicating that the initialisation of such .elds cannot \nbe relied upon. This permits various kinds of incremental initialisation, including cyclic struc\u00adtures. \nHowever, even the simple examples found in their pa\u00adper require manyannotations. So while this system \nis sound, modular, and the most expressive approach yet, it is unlikely that an average programmer would \n.nd it simple enough to handle the everyday problem of sound object initialisation. We provide a more \ndetailed discussion and comparison with MaskedTypes in Sec. 7.2. Summary. As summarised by the following \ntable, none of the existing solutions for object initialisation in non-null type systems satis.es all \nfour design goals that we consider essential for the usefulness of a type system. Delayed types and masked \ntypes are the only sound systems that are suf\u00ad.ciently expressive to handle recursive structures, but \nboth systems are conceptually complex and require signi.cant an\u00adnotation overhead. Since our goal is \nto develop a system for mainstream use, we resolve the trade-off differently. As far as practical examples \nare concerned, our system is slightly lessexpressive than delayed types and masked types,but sig\u00adni.cantly \nsimpler. System Simple Expressive Sound Modular RawTypes . .. Delayed Types . .. (paper) Delayed Types \n.. . (implementation) Attached Types .. . (ECMA) Attached Types . . (implementation) MaskedTypes \n. .. 3. The Design In this section, we explain the main concepts of our type system informally. We introduce \ninitialisation types that re\u00ad.ect whether an object has been fully initialised or is still un\u00adder initialisation, \nand motivate the most important type rules. The type system is formalized in the next section. Additional \nlanguage features such as subclassing, arrays, generics, and concurrency are discussed later in Sec. \n5. 3.1 Initialisation States Each object is in one of two initialisation states: it is ei\u00adther under \ninitialisation or it is initialised. When a new object is allocated as part of executing a new-expression, \nit is initially under initialisation until execution reaches a point from which on we consider the object \nto be initialised. This change of the initialisation state happens when a cer\u00adtain new-expression terminates,but \nnot necessarily the new\u00adexpression that created the object.We call the point at which the state change \noccurs the commitment point of the object and will explain later when it occurs. Initialised objects \nhave to satisfy their invariants, in par\u00adticular, their non-null .elds must contain non-null values. \nMoreover, references stored in .elds of an initialised object must point to objects that are also initialised. \nThis deep ini\u00adtialisation guarantee is important for the practicality of the system. It ensures that \nall objects that are encountered while traversing an object structure starting from an initialised ob\u00adject \nare also initialised and, thus, the traversal can rely on the invariants of the whole structure. Objects \nunder initialisation might satisfy their invariants, but they are not required to. The .elds of such \nobjects may store references to objects in either initialisation state. These .elds may refer to objects \nthat are themselves under initiali\u00adsation, which allows one to initialise cyclic structures.  It is \nimportant to understand that initialisation states are a purely conceptual notion. Neither do we store \nan object s initialisation state in memory nor is it generally possible to infer an object s initialisation \nstate by inspecting the heap. In particular, an object might satisfy its invariantsbut never\u00adtheless \nbe under initialisation because it has not yet reached its commitment point. A program may still assign \nan un\u00adinitialised object to a .eld of such an object and thereby vi\u00adolate its deep initialisation. Such \nassignments are no longer possible once the object has passed its commitment point.  3.2 InitialisationTypes \nIn our type system, the type of an expression re.ects the ini\u00adtialisation state of the object the expression \nrefers to at run\u00adtime. It uses this information to provide guarantees about the invariants of the object \nand to enforce restrictions that guar\u00adantee soundness. For this purpose, we equip each reference type \nwith one of the following three initialisation modi.ers: committed: Expressions of committed types evaluate \nto ref\u00ad erences to initialised objects. free: Expressions of free types evaluate to references to objects \nunder initialisation. unclassi.ed: Expressions of unclassi.ed types may evalu\u00ad ate to any reference. \nAn unclassi.ed type is a supertype of the corresponding committed and free types. Note that these initialisation \nmodi.ers are independent of the non-nullity of a type we can have both non-null and possibly-null types \nwith anyof the three modi.ers above (in the latter case, guarantees about the referred-to object only \napply if the reference is not null). Despite attaching both nul\u00adlity and initialisation information to \nreference types, the an\u00adnotation overhead of our system is low. Almost all references handled in a program \nare committed, non-null references, such that a suitable default avoids overhead for those refer\u00adences. \nInitialisation modi.ers need to be declared explicitly only for non-trivial initialisation patterns. \nIn our examples, we make nullity information explicit; the default initialisa\u00adtion modi.er for all reference \ntypes is committed, except for the type of this insidea constructor, whichis free.We use the syntax [Free] \nand [Unclassified] to declare free and unclassi.ed types, resp. With these defaults, the List exam\u00adplein \nFig.1 requiresa single [Free] annotation. Fig. 2 illustrates the use of these modi.ers. When a new object \nis allocated, its type is initially a free type (hence the default for this in constructors). Once it \nreaches its commitment point, the type changes to a committed type, indicating that the program can now \nrely on the object to be deeply initialised. The type system enforces that the object will remain deeply \ninitialised until its de-allocation.  3.3 Fields Field types include non-null annotations, but no initialisa\u00adtion \nmodi.ers. In particular, there are no free .elds for  free type committed type unclassified typype \nFigure 2. Newly-allocated objects have a free type until they reach their commitment point, when the \ntype changes to a committed type for the rest of the object s lifetime. Unclassi.ed types subsume free \nand committed types. two reasons. First, the type of an object changes from free to committed when it \nreaches its commitment point. This type change would be problematic if the object was referenced from \na free .eld because this .eld would be ill-typed after the type change. Second, free .elds contradict \nthe expecta\u00adtion that objects of committed types be deeply initialised. Field Update. For a .eld update \nof the form x.f = y, our type system performs nullity and initialisation checks. The nullity checks are \ntrivial: x must be non-null, and the nullity of y must conform to the nullity declared for f. The former \ncheck prevents null-pointer dereferencing whereas the latter ensures that only non-null values are assigned \nto non-null .elds; in particular, this check ensures that the non\u00adnullity invariant is monotonic. Once \na non-null .eld has been assigned a non-null value, it will remain non-null. For the initialisation types, \nthe update is allowed if the initialisation modi.ers satisfy at least one of the following two cases. \nFirst, if x is free, we may store objects with any initialisation state in its .elds. This is acceptable \nbecause the free modi.er does not make any guarantees about the ini\u00adtialisation state of reachable objects. \nIn particular, allowing y to be free enables the initialisation of cyclic structures, as illustrated \nby Node s .rst constructor (Fig. 1). All its .eld updates type check because this is implicitly free \ninside a constructor. Second, if y is committed, we may assign it to .elds of any object. If x is committed, \nthen we preserve the deep initialisation guarantee; if x is free or unclassi.ed, it does not make any \nguarantees about the initialisation state of reachable objects anyway. The following table summarises \nthe admissible .eld up\u00addates. The case where x is committed and y is free is dis\u00adallowed because such \nan update would violate the deep ini\u00adtialisation requirement for committed objects. An update is allowed \nfor unclassi.ed references only if it is allowed for both committed and free references. x.f = y y committed \nfree unclassi.ed x committed . free . . . unclassi.ed .  An important consequence of the rule for .eld \nupdates is that our type system must prevent aliasing between commit\u00adted and free references, which we \ncall cross-type aliasing. If an object x was reachable via a committed and a free ref\u00aderence then one \ncould use the free reference to store an un\u00adinitialised (free) object in a .eld of x, which would clearly \nviolate the deep initialisation expectation of the committed reference to x and therefore compromise \nsoundness. Cross\u00adtype aliasing is prevented by not having a subtype relation\u00adship between committed and \nfree types (in contrast to raw types, which are supertypes of the corresponding non-raw types [10]). \nField Read. When reading a .eld x.f, we infer the nullity and initialisation expectation of the result \nas follows: The re\u00adsult is non-null if and only if f is declared non-null and x is committed (recall \nthat the committed type is the only type that guarantees that the referenced object is initialised). \nThe result is committed if and only if x is committed (since com\u00admitment provides a guarantee about all \nreachable objects); otherwise the result is unclassi.ed since the .elds of free ref\u00aderences may store \nboth free and committed references. The following type summarises this rule. x.f f C! C? x committed \ncommitted C! committed C? free unclassi.ed C? unclassi.ed C? unclassi.ed unclassi.ed C? unclassi.ed C? \n Consider the new-expression in method insertAfter (Fig. 1). The type of the second argument this.next \nis committed and non-null because this is by default com\u00admitted in methods, as discussed in the next \nsection.  3.4 Methods and Constructors Method signatures include initialisation modi.ers for the method \nparameters as well as for the receiver. The type rule for method calls is like in all object-oriented \nlanguages: The types of the actual arguments must be subtypes of the de\u00adclared parameter types. An analogous \ncheck is performed for the receiver of a call. This rule ensures that an object under initialisation \nmay be passed to a method as receiver or argu\u00adment only if the receiver or parameter in the method signa\u00adture \nhas a free or unclassi.ed type. In both cases, the method will not rely on the object to be initialised, \nwhich makes this form of escaping safe. Method overriding requires the usual contra-variance of parameter \ntypes and co-variance of result types. Constructors are treated analogous to methods, but their signature \ndoes not contain an initialisation modi.er for the receiver because the receiver of a constructor is \nalways free. The .rst constructor in class Node declares its parameter parent with a free-modi.er. Therefore, \nthe List construc\u00adtor may pass the free object this as an argument. A de.nite assignment analysis enforces \nthat the body of a constructor establishes the invariant of the receiver, that is, assigns non-null values \nto all non-null .elds declared in the enclosing class. In our example, both Node constructors satisfy \nthis analysis because theyinitialise all three non-null .elds. Note that the de.nite assignment analysis \nis the reason why we require invariants to be monotonic, even for free objects. Assigning null to a non-null \n.eld of a free object would not compromise soundness because free objects are not expected to satisfy \ntheir invariants. However, if such non\u00admonotonic updates were permitted, the de.nite assignment analysis \nwould have to assume conservatively that each time a free object is passed to a method or constructor, \nit will come back with its .elds set to null, even if they were previously assigned non-null values. \nSuch an analysis would produce manyfalse positives and, thus, not be practical.  3.5 CommitmentPoints \nAcentral concept of our type system is the notion of commit\u00adment point, the point in time when an object \nis no longer un\u00adder initialisationbut now considered initialised; this change of the initialisation state \nwill be re.ected in a change of the object s type from free to committed. The commitment point may occur \nwhen two requirements are satis.ed. First, the type system must be able to determine statically that \nthe ob\u00adject is deeply initialised. Second, when an object reaches its commitment point and becomes committed, \nthe type system must be able to guarantee that there are no free references to the object. As explained \nearlier, such cross-type aliases could be used to violate the deep initialisation of the object and, \nthus, compromise soundness. To satisfy these requirements, we de.ne the commitment point as follows. \nWhen a new-expression that takes only committed arguments terminates then all objects that have been \ncreated during the execution of this new-expression (and the associated constructor) reach their commitment \npoint (unless they have already reached it when a nested new-expression with only committed arguments \nterminated). Consider the List constructor in Fig. 1. The Node object n created by the expression new \nNode(this) does not yet reach its commitment point when the new-expression termi\u00adnates because it takes \na free argument, this. Infact, n is not deeply initialised then because n.parent.sentinel is still null \nand, therefore, violates the .rst requirement for commit\u00adment points. The same argument applies if an \nunclassi.ed reference is passed as argument to a new-expression, since it may (via subtyping) disguise \na free reference. But when the expression new List() terminates then both the new List object and its \nsentinel node reach their commitment point. This de.nition of commitment point leads to a very simple \ntype rule for new-expressions. An expression new C(x1 ,...,xn) has type committed C! if the static types \nof all actual arguments xi are committed. Otherwise, it has type free C!.We justify our de.nition of \ncommitment point and the corresponding type rule for new-expressions in the following.  New-Expressions \nwith Free or Unclassi.ed Arguments. The List constructor illustrates whyit would be unsound to assign \na committed type to new-expressions with at least one free or unclassi.ed argument. However, considering \nthe new object as free is safe if we can guarantee that there are no cross-type aliases. This is the \ncase because no local variables refer to the new object and because inside the constructor, the new object \nwas referred to via a free reference and, therefore, the constructor could not store the reference in \nthe .eld of a committed object. New-Expressions with Committed Arguments Only. Con\u00adsider a new-expression \nwhere all arguments are committed (which subsumes the case that the constructor does not have parameters). \nLet n be the object that gets created by this new-expression. During the execution of n s constructor, \nthe set of reachable objects consists of the set of objects R that are reachable from the new-expression \ns arguments and the set of objects N that includes n and all objects cre\u00adated during the execution of \nn s constructor. The situation is illustrated in Fig. 3. For the List constructor, the set R is empty, \nwhereas N contains the new List object and its sentinel node. When the new-expression terminates, the \nconstructors of all objects in N have run and therefore, the non-null .elds of these objects contain \nnon-null values. The values assigned to their .elds are references to objects in R or N because these \nare all the reachable objects. Therefore, we know that the objects in N are deeply initialised because \nall objects reachable from them are in R or in N and thus initialised3. So the .rst requirement for commitment \npoints is satis.ed. To argue that the second requirement is satis.ed, we have to show that there is no \ncross-type aliasing, that is, no free reference to an object in N. When the new-expression terminates, \nno local variable refers to an object in N. The only objects that possibly refer to objects in N are \nthe objects in N and R. These objects are all committed when the new\u00adexpression terminates, and so is \nthe reference to the new object n. Note that for constructors that have only committed for\u00admal parameters, \nit might be tempting to consider the receiver initialised as soon as the de.nite assignment analysis \ncon\u00ad.rms that all .elds have been initialised. However, this so\u00adlution would be unsound because it violates \nboth require\u00adments for commitment points. First, during the execution of a constructor, we can in general \nnot determine modularly whether there are subclass constructors, which have not exe\u00adcuted yet. So there \nmight be non-null .elds declared in sub\u00adclasses that have not been initialised. Second, the constructor \nmight have local variables that store free references to the re\u00adceiver, which creates cross-type aliasing. \n3This argument generalises trivially to global data if the global vari\u00adables (that is, static .elds) \nare enforced to store committed references, see Sec. 5.3. Figure 3. Heap structure for the execution \nof a new\u00adexpression that takes only committed arguments. Objects are depicted by rounded boxes; references \nin .elds and on the stack are depicted by solid and dashed arrows, respectively. The set N contains the \nobjects created during the execu\u00adtion of the new-expression; the set R contains the (commit\u00adted) objects \nreachable from the new-expression s arguments. Here, both objects in N are free until the new-expression \nter\u00adminates and, therefore, cannot be referred to by the commit\u00adted objects in R.  3.6 Data.ow Analysis \nWe use a simple intra-procedural data.ow analysis to re.ne the non-nullity and initialisation information \nprovided by the type system. For instance, if a conditional-statement tests a local variable x for being \nnon-null then x may be assumed to have a non-null type in the then-block of the conditional and, therefore, \nmay be dereferenced and assigned to non\u00adnull variables. Similarly, a data.ow analysis can provide initialisation \ninformation for unclassi.ed variables and .elds of free objects. Such a data.ow analysis is important \nfor the practicality of the type system, but it is orthogonal to the focus of this paper and therefore \nlargely ignored in the following. Any such analysis, whether simple or complex, could be used to complement \nthe type system we outline. For example, if support is needed for initialising .elds via method calls, \nsuitably chosen extra annotations on method signatures and/or inter-procedural analyses could be used \nto provide the necessary extra information to the type checker.  3.7 Runtime Support As in other non-null \ntype systems, we allow the down\u00adcasting of an expression from a possibly-null type to a non-null type. \nThe associated runtime check ensures that the expression indeed evaluates to a non-null value. We do \nnot however allow down-casts to change initialisation mod\u00adi.ers (from unclassi.ed to free or committed) \nnor do we al\u00adlow instanceof-expressions to check initialisation modi.ers. Such casts and instanceof-expressions \nwould essentially re\u00adquire us to store each object s initialisation state in the heap, which leads to \nruntime overhead and problems with library code. Consequently, the only runtime support our system re\u00adquires \nis simple non-null checks for down-casts to non-null types.  4. TheFormalisation In this section, we \npresent a formalisation of our approach. Much of the formalisation is standard. However, the sound\u00adness \narguments for our system are subtle, especially the treatment of commitment points described in Sec. \n3.5. Our soundness result (in Sec. 4.4) makes these arguments ex\u00adplicit. 4.1 Programming Language We \nfocus on a very simple language, which nonetheless il\u00adlustrates the main features of the problems of \nobject initial\u00adisation and our solutions. We consider a simple class-based language (without generics), \nin which we have exactly one constructor per class. Note that we do not model calls to su\u00adpertype constructors \nhere a constructor is obliged to fully initialise a new object. DEFINITION 1 (Classes andTypes). We assume \na .nite set of classes, ranged over by C,D, and a pre-de.ned re.exive, transitive, acyclic subclassing \nrelation on classes, written C = D. We assume a set of method names, ranged over by m, and a set of .eld \nnames, ranged over by f,g. We assume the existence of a function .ds() from classes to sets of .eld names, \nand a function meths() from classes to sets of method names. Non-null annotations, ranged over by n, \nare de.ned by n ::=? |! Initialisation modi.ers, ranged over by k, are de.ned by: k ::= 0 (free) | 1 \n(committed) |. (unclassi.ed) Types, ranged over by T, are de.ned by T ::= Ckn. SimpleTypes, ranged over \nby t, are de.ned by t ::= Cn. For example, C0 ! is a type for a non-null free reference of class C, while \nC.? is a type for a possibly-null unclassi.ed reference. Simple types are used in .eld declarations and \nin casts, where initialisation modi.ers are not permitted. Subtyping combines specialisation of initialisation \nmodi\u00ad.ers, non-nullity and classes themselves (i.e., subclassing): DEFINITION 2 (Type Relations). Initialisation \nspecialisa\u00adtion is a binary relation on initialisation modi.ers, written k1 = k2 and de.ned by: k1 = \nk2 . k1 = k2 .k2 = .. Non-null specialisation is a binary relation on non-null an\u00adnotations, written \nn1 = n2 and de.ned by: n1 = n2 . n1 = n2 .n2 =?. Subtyping is a binary relation on types, written T1 \n= T2 and de.ned by: C1 k1 n1 = C2 k2 n2 . C1 = C2 .k1 = k2 .n1 = n2 . We de.ne three auxiliary predicates \non types. nullable(Ck n) holds exactly when n =?. committed(Ckn) holds exactly when k =1. free(Ckn)holds \nexactly when k =0. In order to de.ne the type system and operational seman\u00adtics, we require the existence \nof .eld and method lookup functions. In particular, we need to be able to retrieve the de\u00adclared (simple) \ntype for a .eld in a class, and the signatures of methods and constructors. Method signatures include \nthe possibility of specifying an initialisation modi.er for the re\u00adceiver of the method, as well as its \narguments and return type. Constructors only have such modi.ers for arguments; during execution of a \nconstructor its receiver is always a free reference, and after execution the initialisation type of the \nnew expression is determined by those of the passed argu\u00adments (cf. Sec. 3.5). Both kinds of signatures \nalso include declarations of local variables used within the method body, but this is just to simplify \nthe formal presentation. DEFINITION 3 (Field and Method Lookups). Field type lookup is modelled by a \npartial function fType(C,f)from pairs of class-name and .eld-name to simple types. A Method Signature \nis a four-tuple (k,xi:Ti,T,yj:Tj), whose elements are as follows4: (1) an initialisation mod\u00adi.er k, \nindicating the initialisation type of the receiver, (2) a sequence xi:Ti of parameter names (variable \nnames) along with their declared types, (3) a type T representing the re\u00ad turn value of the method, and \n(4) a sequence yj:Tj of local variable names along with their declared types. A Constructor Signature \nis a two-tuple (xi:Ti,yj:Tj), simi\u00adlarly declaring parameters and local variables. Method signature lookup \nis modelled by a partial func\u00adtion mSig(C,m) from pairs of class-name and method\u00adname to method signatures. \nIt satis.es the usual variance requirements for subclassing (covariant return types and contravariant \nparameter types). Method body lookup is modelled by a partial function mBody(C,m) (with the same domain \nas mSig) from pairs of class-name and method-name to statements. Constructor signature lookup is modelled \nby a function cSig(C) from class-names to constructor signatures. Con\u00adstructor body lookup is modelled \nby a function cBody(C) from class-names to statements. Our statements include assignments, method calls, \nobject creation and casts.We do not include conditionals since they would only be of interest when combining \nour type system with a data.ow analysis (Sec. 3.6). Note that we do not have a return statement; methods \nreturn the value of a pre-de.ned local variable res.For simplicity, we treat .eld assignments, calls, \nobject creation, and casts as statements. Complex ex\u00adpressions can be decomposed using local variables. \n4We use vector notation xi for sequence/repetition with elements indexed by i (the index clari.es which \nterms vary in a sequence). Use of different indexes indicates sequences with different index sets.  \nDEFINITION 4 (Expressions and Statements). We assume a set of program variables, ranged over by x,y,z, \nincluding a distinguished variable this. Expressions, ranged over by e, are de.ned by the following grammar: \ne ::= x |x.f |null Statements, ranged over by s, are de.ned by the following grammar, with the extra \nrestriction that (in all cases) x may not be the special variable this: s ::= x = e (variable assignment) \n| z.f = y (.eld assignment) | x = y.m( zi) (method call) | x = new C(zi) (object creation) | x =(t)y \n(cast) | s1 ;s2 (sequential composition) Note that casts employ only simple types. As discussed in Sec. \n3.7, we do not support casts that change the initialisa\u00adtion type of a reference.  4.2 Type System We \nnow turn to the de.nition of our type system, which includes de.nite assignment checks. There are two \nkinds of checks made. Firstly, a set .of de.nitely assigned program variables is used in judgements, \nto (conservatively) track which variables can be safely read from. Local variables can only be safely \nread from if they are named in the set .;this is necessary since all local variables are initialised \nto null in our operational semantics, regardless of their types. When typing expressions, we enforce \nthis check an expression is only well-typed if it reads only from variables named in the current .. When \ntyping statements we use a before and after .to track this information in the type system. Secondly, \nwe employ a set of .eld names S, which con\u00adservatively record which .elds of the current receiver are \nde.nitely assigned during execution of a statement. This set is relevant only for constructors; it is \nused to enforce the re\u00adquirement that constructors guarantee to assign all non-null .elds. Since we do \nnot need to make anyintermediate checks based on this set, it only occurs once in each typing judge\u00adment, \nindicating the .elds de.nitely assigned between the beginning and end of execution of the statement. \nDEFINITION 5 (StaticType Assignment). A type environ\u00adment Gis a partial function from program variables \nto types. An assigned variables set . is a set of variable names (in\u00addicating which have been de.nitely \nassigned). An assigned .elds set Sis a set of .eld names (indicating which .elds of the receiver have \nbeen de.nitely assigned). Expression typing is de.ned by judgements G;. . e : T, indicating that e has \ntype T under assumptions G, possibly reading variables in .. The judgements are de.ned inFig. 4. Statement \ntyping is de.ned by judgements G;. . s |. ' ;S, indicating that s is well-typed under assumptions G, \nreads only variables in . and, after execution, will guarantee that variables . ' and .elds S are de.nitely \nassigned. The judgements are de.ned inFig. 5. x . . (TNULL)(TVAR) G;. . null : Ck? G;. . x : G(x) G;. \n. x : Ck1 ! fType(C,f)= Dn1 { 1 if k1 =1 k2 = . otherwise { ! if n1 =! and k1 =1 n2 = ? otherwise (TFLD) \nG;. . x.f : Dk2 n2 Figure 4. Expression typing. G;. . e : TT = G(x) (TVARASS) G;. . x = e |..{x};\u00d8 G;. \n. x : Ck1 ! fType(C,f)= Dn G;. . y : TT = Dk2 n k1 =0 .k2 =1 { {f} if x = this S= \u00d8 otherwise (TFLDASS) \nG;. . x.f = y |.;S G;. . y : Ck1 ! mSig( C,m)=(k2 ,xi :Ti,T,yj:Tj)  '' G;. . zi : TT = Ti ii T = G(x) \nk1 = k2 (TCALL) G;. . x = y.m( zi)|..{x};\u00d8 cSig (C)=(xi:Ti ,yj:Tj)  '' G;. . zi : T T = i i Ti A ' \nk = committed(T ) Ck! = G(x) i (TCREATE) G;. . x = new C( zi)|..{x};\u00d8 G;. . y : Ck n1 t = Dn2 Dk n2 = \nG(x) (TCAST) G;. . x =(t)y |..{x};\u00d8 G;. . s1 |.1 ;S1 G;.1 . s2 |.2 ;S2 (TSEQ) G;. . s1 ;s2 |.2 ;S1 .S2 \nFigure 5. Statement typing. Our expression typing judgement plays a dual role in our formalisation. It \nchecks not only that the expression is typeable in a standard way, but also that it can be read from \n; any variable mentioned has to be known to be already assigned. Since our judgement does not include \nsubtyping (which is dealt with at the level of typing statements), we have the property that a variable \nx can be typed exactly with the type G(x), and only when x occurs in . (i.e., it has been assigned). \nWhen de.ning subsequent typing rules, we choose between applyingthe rule(TVAR)tovariables,or just looking \nup the type G(x)directly, depending on whether or not we require the variable to already be assigned. \n The rule(TVAR)looksup the type foravariablein the en\u00advironment, also checking that the variable has \nalready been assigned (i.e., it is named in .). The rule (TNULL)allows a null expression to be typed \nwith any class and initiali\u00adsation type, but of course it must take a possibly-null type. The rule for \n.eld read, (TFLD), .rst checks that the receiver expression x is typeable with a non-null type; this \nalso im\u00adplicitly enforces the requirement that x is known to be as\u00adsigned (this would not have been the \ncase if we had looked up the type for x directly in G). Then, based on the class type C of x, the appropriate \n.eld type is retrieved (this im\u00adplicitly requires that the .eld is de.ned for the class). The type for \nthe whole expression is then derived. The class type is whatever was declared in the .eld type. The type \nis com\u00admitted if the receiver expression x was typed as committed, and is unclassi.ed otherwise. Finally, \nthe expression is non\u00adnull if the .eld was declared non-null and the receiver was also of committed type; \notherwise, the expression is typed as possibly-null. Note that while we have no subtyping here, webuild \nit into the statement typing rules where required. In the rules for statement typing (Fig. 5), we take \ncare to update the variables known to be assigned (via the second set of variables in the judgements), \nand also to record the .elds of this which get assigned values (this information is only needed for checking \nconstructor bodies,but for simplic\u00aditly, we accumulate it in general). The rule for variable as\u00adsignment, \n(T VARASS), checks that the source expression is typeable with a subtype of the declared type of the \nvariable, and adds the variable to those known to be assigned. Note that the destination variable is \nnot subject to the expression typing judgement; this means we do not erroneously insist on it being assigned \nbeforehand (while any variables refer\u00adenced in the source expression must be). In the rule for .eld assignment, \n(T FLDASS), we require both the receiver and the source variable to be assigned and typeable, and impose \nthe extra requirement that the receiver must be free or the source variable must be committed. If the \nreceiver is this, we also record the .eld to be assigned, in the set S. The rule for method call(TCALL)checks \nthat the receiver is assigned and non-null, and then checks that the types of the receiver, arguments \nand return value destination, all agree with the declared method signature. Note that in the case of \nthe receiver, this involves checking that the receiver initialisation type k1 specialises the initialisation \ntype k2 declared for the receiver in the method signature. Sis empty in this rule; the basic .ow analysis \nwe use here does not handle initialisation via a method (but see Sec. 3.6). The rule for object creation \n(TCREATE) speci.es that the initialisation type of the returned value is de.ned to be committed (1) if \nall the arguments have committed types, and free(0)otherwise; we denote this conjunction with the A \n' shorthand committed(T ). Our rule for casting (TCAST) i incorporates a variable assignment, and allows \nthe class type and non-null type of the value to change arbitrarily, but does not affect the initialisation \ntype. Finally, our rule for sequential composition(T SEQ)chains together the inference of which variables \nhave been assigned, and accumulates the .elds of this known to have been assigned in either statement. \nIf one wanted to adapt our formalisation to check for some other kind of invariant (such as immutability) \nand not for non-null types, the changes that would be needed are fairly small. Firstly, one should remove \nthe requirement that variables dereferenced always have non-null types (TFLD, TFLDASS,TCALL). One might \nalso simplify/modify the rule for computing the type of a .eld read (TFLD). The role of S in our judgements \nis speci.c to tracking progress towards a newly-constructed object being initialised. The use of this \njudgement for the proof might well vary depending on the invariant in question. Finally, the check for \na well-formed constructor (WFCONS) below would need to be adjusted to guarantee initialisation with respect \nto the invariant in question (for non-null types, we require that every non-null\u00addeclared .eld of the \nnew object gets assigned). We can now type check class de.nitions. DEFINITION 6 (Well-formed program). \nA program is well\u00adformed if for eachclass C of the program, eachmethod m . meths(C)is well-formed(.m \nC,m), and the constructor is well-formed(.C C). These judgements are de.ned inFig. 6. mBody(C,m)= s mSig(C,m)=(k,xi:Ti,T,yj:Tj) \n\u00ac nullable(T). res . . G =(xi:Ti, this:Ck!,yj:Tj, res:T) G; {xi, this}.s |.;S  (WFMETH) .m C,m  cBody(C)= \ns cSig(C)=(xi:Ti,yj:Tj) {f..ds(C)| \u00acnullable(fType (C,f))}.S G =(xi:Ti, this:C0 !,yj:Tj) G; {xi, this}.s \n|.;S (WFCONS) .C C Figure 6. Well-formed methods and constructors. Essentially,every method body(WFMETH)mustbe \ntypeable with respect to its signature, under the assumption that all  parameters are initially assigned. \nFurthermore, the method body must assign to the result variable res (of course, this restriction could \nbe relaxed to support void methods). For constructors (WFCONS), the body must be typeable with respect \nto its signature, along with the assumption that the receiver is a free, non-null reference of the appropriate \nclass type. Furthermore, every non-null-declared .eld of the class must be assigned a value in the method \nbody.  4.3 Semantics We adopt a reasonably standard heap model on which to de.ne our operational semantics. \nNote that the heap model does not contain any type-system-speci.c information; in particular, no support \nfor the initialisation aspects of our type system is needed at runtime; as we described earlier, initialisation \nstates of objects are purely conceptual, and used to explain the workings of the static type system. \nThis fact is essential for the feasibility of our type system for mainstream languages. DEFINITION 7 \n(Heaps,Values and Allocation). We assume a .nite set of addresses, ranged over by .. Values, ranged over \nby v are de.ned5 by v ::= . |null. Aheap his a pair (hv,hc)of partial functions; hv from pairs of address \nand .eld-name to values, and hc from addresses to class names. The domains of the functions are related \nby: dom(hc)= {. |.f.(.,f) . dom(hv)}. As shorthand, we will typically use h in place of hv or hc. We \nwrite heap lookup as h(.,f)(de.ned as hv(.,f), only when (.,f). dom(hv)). We write h[(.,f) .v] for heap \nupdate/extension (meaning standard map update of hv). We write class lookup as cls(h,.), meaning hc(.)(provided \nthat . . dom(hc)). We model object allocation via a function alloc which takes a heap and a class-name \nas parameters, and returns a pair of heap and address, satisfying the following properties: . . . . dom(hc) \n. . h ' = hv[( .,fi) . null] v (h ' ,.)= alloc(h,C). . where fi = .ds(C) . . h ' = hc[. . C] c We can \nnow de.ne the evaluation of expressions. Note that evaluation is not guaranteed per se to produce a value, \nsince we might dereference a null variable. We model this by introducing an exception state (later, our \nmain theorem will show that for a well-typed program, this exception state is never encountered). DEFINITION \n8 (Expression evaluation). A stack frame s is a partial function from program variables to values. We \nwrite s(x)to denote the corresponding lookup (de.ned only when x . dom(s)), and we write s[x .v]for stack \nupdate. 5Note that we use both null as an expression in the source language, and null as a distinguished \nvalue. However, the two are always distinguishable by context. Extended Values, ranged over by V, are \nvalues v plus the special value derefExc (denoting failure to obtain a value). Expression evaluation \nmaps an expression e, heap h and stack frame s to an extended value. It is written .e.h,s , and de.ned \nas follows: .x.h,s = s(x) . .null.h,s = null . h(., f) if s(x)= . and .x.f.h,s = f . .ds(cls(h, .)) . \nderefExc otherwise We can now de.ne our operational semantics. DEFINITION 9 (Operational Semantics). \nException States, ranged over by o, are one of three possible concrete values: o ::= ok |derefExc |castExc. \nRuntime Type Assignment assigns simple types to runtime values, according to the subclassing relationship \nin the pro-gram.Itis de.nedinFig.7.We de.nea big-step operational semantics via judgements o, h,s,s \" \nh ' ,s ' ,o ' , indicat\u00ading the execution of statement s starting in exception state o, heap h and stack-frame \ns, and .nishing with heap h ' , stack-frame s and exception state o ' . The rules are de.ned inFig. 8. \ncls(h,.)= C (RNULL) (RADDR) h . null : C? h . . : Cn Figure 7. Runtime type assignment.  4.4 Soundness \nResults We can now turn to the formalisation of our soundness results. Firstly, we need to formally de.ne \nour initialisation and reachability concepts. DEFINITION 10 (Initialisation and Reachability). An ad\u00address \nis locally initialised in a heap, written init(h,.), if all non-null .elds contain non-null values: init(h,.). \n(.f . .ds(cls(h,.)) : \u00acnullable(fType(cls(h,.),f)). h(.,f) = null) An address reaches another address \nin a heap, written reaches(h,.1 ,.2 ), as de.ned recursively by the least .xpoint solution of the following \nequation: reaches(h,.1 ,.2 ). .1 = .2 ..f,.3 : h(.1 ,f)= .3 .reaches(h,.3 ,.2 ) Given an address and \nheap, the set of addresses reachable, written reachable(h,.)is de.ned by: reachable(h,.)= {. ' | reaches(h,.,. \n' )}. An address is deeply initialised in a heap, written as a pred\u00adicate deep init(h,.), if all reachable \naddresses are locally initialised: deep init(h,.)... ' . reachable(h,.): init(h,. ' )  .e.= vh,s (VARASS) \nok, h,s,x = e h,s[x.v],ok .e.= derefExc h,s (VARASSBAD) ok, h,s,x = e h,s, derefExc s(x)= . (FLDASS) \nok,h,s,x.f = yh[(.,f).s(y)],s, ok s(x)= null (FLDASSBAD) ok, h,s,x.f = y h,s, derefExc s(y)= .C = cls(h,.) \nmSig(C,m)=(k,xi:Ti,T,yj:Tj) s1 = this..,xi.s(zi),res.null,yj.null mBody(C,m)= s ok, h,s1 ,s h ' ,s ' \n,o (CALL) ok, h,s,x = y.m(zi) h ' ,s[x.s ' (res)],o s(y)= null (CALLBAD) ok, h,s,x = y.m(zi) h,s, derefExc \ncSig(C)=(xi:Ti,yj:Tj) (h1 ,.1 )= alloc(h,C) s1 = this..1 ,xi.s(zi),yj.null cBody(C)= s ok,h1 ,s1 ,s h \n' ,s2 ,o (CREATE) ok, h,s,x = new C(zi) h ' ,s[x..1 ],o h . s(y): t (CAST) ok, h,s,x =(t)y h,s[x.s(y)], \nok h . s(y): t (CASTBAD) ok,h,s,x =(t)y h,s, castExc ok, h, s, s1 h1 , s1 , ok ok, h1 , s1 ,s2 h2 , s2 \n, o (SEQ) ok, h, s, s1 ;s2 h2 , s2 , o ok, h,s,s1 h1 ,s1 ,o o = ok (SEQBAD) ok, h,s,s1 ;s2 h1 ,s1 ,o \nFigure 8. Operational semantics. Now, we are in a position to specify exactly what our type system preserves \nabout the stack and the heap. We identify .ve conditions which go together to make up a good con\u00ad.guration. \nThe .rst just forces the stack to have a suitable domain, while the second is the standard property that \n.elds contain only objects which agree with their declared class type. The third expresses the meaning \nof our de.nite as\u00adsignment checks for local variables, and the fourth expresses that stack variables \nwhich have been initialised contain suit\u00adable values. Finally, we characterise the type invariants of \nour system: committed references are deeply initialised and cannot reach objects directly referred to \nby free references. DEFINITION 11 (Good Con.gurations). Apair of heap and stack-frame is a good con.guration \nfor G,., written G;. . h,s, if the following conditions hold: 1. dom(s)= dom(G) . this . dom(s) 2. .. \n. dom(h),f . .ds(cls(h,.)) : (.,f) . dom(h). (h(.,f)= null . cls(h,h(.,f)) = fType(cls(h,.),f)) 3. .x \n. dom(s): (\u00acnullable(G(x)) .x . . . s(x)= null) 4. .x . dom(s):(s(x)= null . h . s(x): G(x)) 5. .x,y \n. dom(s):(committed(G(x)) . deep init(h,s(x)) . (free(G(y)) .\u00acreaches(h,s(x),s(y))))  We can now state \nour desired soundness theorem: THEOREM 1 (Preservation and Safety). If G;. . h,s and G;. . s | . ' ;S \nand ok,h,s,s h ' ,s ' ,o and o = castExc all hold, then G;. ' . h ' ,s ' . o = ok. The proof of this \ntheorem is challenging for a number of rea\u00adsons. Not only is the design of our approach centred around \nreachability in the heap, but we present good con.gura\u00adtions as a property local to each particular stack-frame. \nThis means that there is much work to do in the proof when we change stack frame, particularly for a \nmethod or construc\u00adtor return. Furthermore, because initialisation states are not present at runtime, \nwe need to infer the expected initiali\u00adsation state for an object via the static types of references \nto that object. In fact, we identi.ed a number of interesting properties of our formalisation (some of \nwhich were not ini\u00adtially obvious) which lead to the proof. For any well-typed statement execution in \nour semantics the following proper\u00adties hold in addition to the properties claimed in the theorem: 1. \nThe domain of the stack is preserved, and the domain of the heap only grows. 2. After execution of the \nstatement, all non-null .elds in S of the receiver object contain non-null values. 3. Non-null .elds \nwhich were initialised before execution of the statement, are still initialised afterwards. 4. Objects \nlocally initialised before the execution of the statement are still locally initialised afterwards. \n5. Any objects newly-allocated during the execution of the statement are locally initialised afterwards. \n 6. Any object which is not locally initialised and reachable from a stack variable after execution,is \nreachable from a stack variable before execution. 7. If, after execution, an object . is reachable from \na com\u00admitted stack variable, and both . and the object referred   to by the stack variable exist before \nexecution, then .was reachable from a committed stack variable before execu\u00adtion. 8. If, after execution, \nan object .1 reaches an object .2 re\u00adferred to by a free stack variable, and both objects exist before \nexecution, then .1 reaches an object referred to by a free stack variable before execution. 9. If an \nobject .1 reaches another .2 after execution, and both objects exist before execution, then at least \none of the following properties must hold before execution:  (a) .1 reaches .2 . (b) .2 can be reached \nfrom a committed stack variable. (c) .1 reaches an object referred to by a free stack variable, and .2 \ncan be reached from a (possibly different) stack variable. Property 9 particularly deserves explanation. \nIt re.ects the connecting of objects that can possibly happen during exe\u00adcution. Because committed references \ncan be assigned to any .elds, an object reachable from a committed local variable before execution could \npotentially be reachable by any ob\u00adject after execution. The only other kind of .eld assignment we allow, \nis the assignment of references to the .elds of free references. In this case, an object which newly \nreaches an\u00adother must have previously reached the receiver of such a .eldupdate,thatis,afree reference.Weusealloftheabove\u00admentioned \nproperties to strengthen our inductionhypothesis; we prove the following lemma (from which Theorem1 fol\u00adlows), \nwhich includes properties 1 9: LEMMA 1 (Preservation and Safety (strengthened)). If G;. . h,s and G;. \n. s |. ' ;Sand ok,h,s,s h ' ,s ' ,o and o = castExc all hold, then: 0. G;. ' . h ' ,s ' . o = ok 1. \ns ' (this)= s(this) . dom(s ' )= dom(s) . h = h ' 2. .f . S: (\u00acnullable(fType(cls(h,s(this)),f)) . h \n' (s(this),f)= null) 3. .. . dom(h): ((\u00acnullable(fType(cls(h,.),f)) . h(.,f)= null). h ' (.,f)= null) \n 4. .. . dom(h):(init(h,.). init(h ' ,.)) 5. .. . dom(h ' ):(. . dom(h). init(h ' ,.)) 6. .. . dom(h \n' ),x . dom(s ' ):(reaches(h ' ,s ' (x),.). \u00acinit(h ' ,.). (.y . dom(s): reaches(h,s(y),.))) 7. .. . \ndom(h ' ),x . dom(s ' ):(reaches(h ' ,s ' (x),.). committed(G(x)) . . . dom(h). s ' (x) . dom(h) . (.y \n. dom(s): committed(G(y)).reaches(h,s(y),.))) 8. .. . dom(h ' ),x . dom(s ' ):(reaches(h ' ,.,s ' (x)) \n. free(G(x)) .. . dom(h).s ' (x). dom(h). (.y . dom(s): free(G(y)) .reaches(h,.,s(y)))) 9. ..1 . dom(h),.2 \n. dom(h):(reaches(h ' ,.1 ,.2 ) . reaches(h,.1 ,.2 ).(.x . dom(s): committed(G(x)) . reaches(h,s(x),.2 \n)) . (.y . dom(s),z . dom(s): free(G(y)) .free(G(z)) .reaches(h,.1 ,s(y)) . reaches(h,s(z),.2 )))  PROOF \n1. By (elaborate) induction on the derivation of ok,h,s,s h ' ,s ' ,o. The full proof and accompanying \nlemmas are available in our technical report [23]. 5. Extensions In this section we discuss how to support \nadditional language features and approaches to make our type system even more expressive. 5.1 Concurrency \nOur type system naturally extends to concurrency. The only requirement that is necessary to preserve \nsoundness is that each object is thread-local until it is initialised. That is, we maintain an invariant \nthat anyshared object (reachable from more than one thread) is initialised. Sharing uninitialised objects \ncould lead to cross-type aliases when the object reaches its commitment point in the thread that created \nit. In Java this invariant can be maintained by two rules. Firstly, only initialised Thread objects can \nbe started; that is, the Thread.start method requires a committed receiver. This rule ensures that starting \na new thread preserves the in\u00advariant because the Thread object can only reach initialised objects. Secondly, \nonly committed references can be stored in static .elds (see below). This rule ensures that threads cannot \npass free references from one thread to another via a static .eld. Since starting a thread is a synchronization \naction in Java s memory model, this argument also applies to Java s weak memory model. The rules for \nconcurrency are an example where we use initialisation types to prevent escaping (namely escaping of \na free reference from the creating thread) rather than making escaping safe (as for the escaping from \nconstructors).  5.2 Arrays Arrays do not have constructors and their number of ele\u00adments might not be \nstatically known. Therefore, it is not easily possible to use a de.nite assignment analysis to deter\u00admine \nwhen an array has been initialised. Delayed types [11] allow programmers to call a special marker method \nto indi\u00adcate that an array of non-null elements has been initialised; the method performs a runtime check \nto ensure that the array elements are indeed non-null. We adopt this approach and use the return from \nthe marker method as the commitment point for the array. How\u00adever, since we do not store initialisation \nstates at runtime, we cannot check at runtime that the array elements are them\u00adselves initialised, that \nis, we cannot check that the array is deeply initialised. Therefore, we ensure deep initialisation of \nthe array by a type rule. An array update of the form a[i]= e requires e to have a committed type. This \nrule is more re\u00adstrictive than the corresponding rule for .eld updates; it does not allow one to store \nfree objects in any arrays and, there\u00adfore, does not support the initialisation of cyclic structures \nthat include an array of non-null elements.  The initialisation modi.er of a new array with a non\u00adnull \nelement type is unclassi.ed. An array reference is never free, which avoids cross-type aliases when the \narray reaches its commitment point. The initialisation modi.er of a new array with a possibly-null element \ntype is committed. Such arrays do not have an invariant to establish and (as all arrays) can never reach \nuninitialised objects. So they can safely be regarded as committed at creation.  5.3 Static Fields Static \n.elds belong to classes rather than objects and are ini\u00adtialised by static class initialisers rather \nthan constructors. It is in general not possible to determine modularly when static class initialisers \nexecute and, thus, when a static .eld is ini\u00adtialised. Therefore, we use a conservative type rule: static \n.elds must not have non-null types and may only be assigned null and committed objects. The latter requirement \nis neces\u00adsary to guarantee that objects cannot reach uninitialised ob\u00adjects when theyreach their commitment \npoint (see Sec. 3.5) and to handle concurrency(see Sec. 5.1). 5.4 Factory Methods One alternative approach \nto initialisation is the use of factory methods, in which complex initialisation code is performed in \na (usually static) method rather than a constructor. We could extend our technique to handle factory \nmethods, at the expense of more complex annotations. Firstly, to allow interesting initialisation infactory \nmethods, we would need to support a special kind of weak constructor which is not obliged to initialise \nthe .elds of the new object. Weak constructors could only be invoked via new expressions in factory methods \n(or super calls from weak constructors), and would always return a free reference. Further, we would \nneed the ability to mark certain methods asfactory methods, which would be tasked with initialising the \nreturned object (which must have been newly-allocated). Calls to factory methods could then be treated \nsimilarly to our rules for handling newexpressions.Sofar, such anextension has not appeared to be worth \nthe additional complexity involved. 5.5 Subclassing Extending our formalisation with subclassing and \ninheri\u00adtance affects the de.nite assignment analysis for construc\u00adtors and the data.ow analysis in general \nSec. 3.6. The def\u00adinite assignment analysis requires each constructor to ini\u00adtialise the non-null .elds \nof the enclosing class. Fields de\u00adclared in superclasses will be initialised by a superclass con\u00adstructor. \nSince our .eld initialisation is monotonic, this is suf.cient to ensure that all non-null .elds of an \nobject have been initialised when the new-expression terminates; that is, when the last constructor of \nthe object has run. The data.ow analysis may safely assume that after a call to a super-constructor, \neach non-null .eld f declared in a superclass contains a non-null value. So it is safe to give this.f \na non-null type even though this is free. After a call to a constructor of the same class, one may additionally \nassume that the non-null .elds of that class have been initialised. Note that this design avoids having \nto parameterise our types with type frames (as in raw types), to express partial initialisation: our \nfree references, along with the data.ow analysis, already give us the expressiveness we require. Note \nfurther that we do not need to prevent dynamically-bound method calls on free references (a common source \nof initial\u00adisation errors); our type system will check that such calls can handle free receivers, which \nwill in turn force the method implementation not to assume that the receiver is initialised. 5.6 Generics \nWe allow type arguments for generic classes to include non\u00adnullity modi.ers but not initialisation modi.ers. \nThe solu\u00adtion for non-nullityis adopted from Spec#.Parameterisinga class with initialisation modi.ers \nisn t very useful because .eld types cannothave initialisation modi.ers.Forexample, a committed instance \nof class List<T> may store only com\u00admitted objects; thus it would not be meaningful to instantiate the \ntype parameter T with a free or unclassi.ed type. It is potentially useful to parameterise methods with \nini\u00adtialisation modi.ers.For instance, an identity-methodworks for eachofthe three initialisation modi.ers.Toavoidhaving \nto de.ne several copies of such a method for different ini\u00adtialisation modi.ers, we can support for polymorphism \nover initialisation modi.ers in method signatures.We omitted the feature here and in our implementation \nbecause we have not yet seen code in the wild that needs the extra expressive\u00adness provided. However, \nwe did include it in our extended formalisation and soundness proof [23].  5.7 Committed-only Fields \nThe type system presented so far does not generally handle situations where a constructor stores a committed \nreference into a .eld of its receiver, and then reads it back to perform some computation on it.Forexample, \nconsider the following code (based on an example we found while experimenting with our implementation): \nclass C { Stack! s; // library class public C(object o) { this.s = new Stack(); // committed value \n ... // other code this.s.push(o); // fails to type-check } } The problem here is that the push method \nof class Stack does not (and cannot be expected to) support anything but a committed receiver. However, \nsince this is free, the .eld read this.s has an unclassi.ed type and, thus, the call does not type check. \nOne might initially think that this problem can be best handled by extending the data.ow analysis to \nremember the initialisation states of values stored in .elds.  However, one cannot (soundly and modularly) \npreserve this information across method calls because the method might reassign the .eld, possibly with \na free value. We observed that many .elds are only ever used to store committed values (at all program \npoints), and for such .elds, one would prefer to make this discipline explicit and use the information \nto re.ne our type system s expressiveness. In fact, it is suf.cient to distinguish two kinds of .elds: \ncommitted-only and standard .elds.Acommitted-only .eld may only be assigned values which have committed \ntypes. Any value which is read from a committed-only .eld can (if known not to be null) be assumed to \nrefer to an initialised object; we therefore give such .eld-reads a committed type even when reading \nfrom a receiver which is not committed. Committed-only .elds proved useful in many practical examples. \nIn fact, we found it most fruitful in our experi\u00adments to make committed-only the default declaration \nfor .elds, and to introduce explicit annotations only for those .elds which need to store non-committed \nreferences at some point during initialisation. This means a few extra annota\u00adtions are required for \nthe initialisation of interesting cyclic structures,but on the other handexamples like the one above \ncan be supported without annotations.  5.8 Invariants We presented our type system as an extension to \na non\u00adnull type system, but it is far more general. Our approach supports all monotonic one-state and \ntwo-state invariants that satisfy the following two requirements. First, it must be possible to determine \nthat the invariant holds for the new object at the end of a new-expression. For non-null types, we achieve \nthat with a .ow analysis. For other one-state invariants, one could use an assertion that the invariant \nholds; the assertion can then be checked at runtimeorveri.ed statically.Fortwo-stateinvariantssuchas \nimmutability, no check is required; it suf.ces to check that the invariant holds for all pairs of states \nfrom now on. Second, it must be possible to check that the invariant is monotonic. For non-null types, \nwe achieve that by prevent\u00ading programs from storing null in non-null .elds. For other one-state and \ntwo-state invariants, one could add an assertion to each .eld update witha committed or unclassi.ed receiver \nthat checks a condition that is suf.cient for the preservation of the invariant (for instance in the \nform of update guards [3]).For immutability, this assertionwouldalwaysfail. 6. Experimental Evaluation \nIn order to evaluate our type system in practice, we wrote a modi.ed version of the Spec# compiler [15], \nimplement\u00ading our type system. Starting from Spec# gave us the prac\u00adtical advantage that the existing \nnon-null type checking and data.ow analysis could be reused. Our implementation adapted and replaced \nthe implementation of delayed types; in most cases we were greatly aided by being able to adapt or extend \nthe existing code written by Manuel F\u00a8ahndrich and Songtao Xia. In the implementation (unlike our formal\u00adisation), \nwe made use of the data.ow analysis to infer the initialisation states for local variables. This makes \nthe sys\u00adtem much more usable for substantial code. Our compiler implements the type system presented \nin this paper, with ad\u00additional support for base calls, static .elds and methods, and arrays (see Sec. \n5.2). In the course of our experiments, we realised that the committed-only-.elds extension (discussed \nin Sec. 5.7) would enable us to handle many more cases, and so we also implemented this extension. We \ntested our implementation on two fairly large code\u00adbases -a version of SSCBoogie (the Spec# veri.er, \nwhich is written entirely in Spec#), and an old version of the widely\u00adused Boogie program veri.er (written \nin Spec#; we used an older version because the Boogie project has been mi\u00adgrated to pure C# since June \n2010). As well as these two large projects, we also tested our compiler against the Spec# collections \nused by the compiler itself, and by-hand encod\u00adings of the examples found in this paper. All of this \ncode was already written with non-null annotations (but without appropriate initialisation annotations). \nOur approach was to start from the code without any initialisation-related annotations, and .rst see \nhow many type-checking warnings were issued by our compiler; this indicates how many cases were not already \nhandled by the defaults in our type system.We then investigated how many of these warnings could be eliminated \nby the addition of [Free] and [Unclassi.ed] annotations, without performing any other changes to the \ncode itself. This process was very mechanical; in the end, it amounted to the systematic appli\u00adcation \nof three rules: 1. When the type system warned that the receiver of a method call was expected to be \ninitialised, but was not guaranteed to be so (i.e., its static type was free or unclas\u00adsi.ed) we annotated \nthe signature of the called method with [Unclassi.ed]. 2. When the type system warned that an argument \nto a method call was expected to be initialised, but was not guaranteed to be so (i.e., its static type \nwas free or unclas\u00adsi.ed) we annotated the formal parameter of the called method with [Unclassi.ed]. \n 3. When the type system warned that we attempted to store a non-committed value in a committed-only \n.eld, we removed the committed-only status from the .eld.  The results of this annotation effort are \nshown in Fig. 9. In some cases (particularly for the .rst two rules above), these rules had to be iterated; \nwhen we mark a new receiver of a method as [Unclassi.ed], for example, this means that any uses of the \nreceiver inside the method body might no longer type-check. In the case of the third rule, it could be \nthat parts of the code already depend on the committed-only status of the .eld; in this case, unless \nthose parts could themselves Figure 9. Experimental evaluation results. Our modi.ed version of the Spec# \ncompiler was run on two large projects: a Spec# version of the Boogie veri.er, and the veri.er for the \nSpec# language itself, SSCBoogie.We also ran our compiler on several small, challenging examples, including \nthose used in this paper (included together under Other in the table). We show the total type-checking \nwarnings generated for the un-annotated code, indicating how many initialisation problems are not handled \nby the defaults in our type system. We then annotated the code in a mechanical fashion, to see how many \nwarnings could be removed. The (few) remaining cases indicate that some code refactoring was still needed \nto make the code type-check, by moving some code which depends on initialisation being complete, to outside \nof a constructor body.  Boogie SSCBoogie Other Lines of code 43996 15672 1739 Total warnings 43 108 \n19 Annotations used 74 28 19 Warnings removed 42 106 18 Warnings remaining 1 2 1 be .xed with annotations \nas above, we marked the case as one which required refactoring (cf. Warnings remaining in the table). \nThis also applied if we found that we needed to add annotations to code to widely-used superclasses, \nsince these would in general prohibit interesting implementations. Similarly, we were not able to annotate \nanylibrary code. The results provide convincing evidence that our type system is usable; we found only \nfour points in the code ex\u00adamined where we couldn t make the code type-check sim\u00adply by adding appropriate \nannotations. The .rst of these in\u00advolved calling a method on the receiver in a constructor, and then \nwithin the method relying on a non-null .eld contain\u00ading a non-null value. Two cases involved passing \nthe this reference from a constructor as an argument to an overrid\u00adden method call for which we could \nnot re-annotate the su\u00adperclass signature. The .nal case is the example discussed in Sec. 7.2. All four \ncases could be handled by moving the problematic lines to outside of the constructor (which makes sense \nin general, since there might still be subclasses to ini\u00adtialise after the constructor executes). The \nnumber of annotations required in our experiments is very low; on average about one annotation per warning \nabout initialisation, and per about 500 lines of code. In fact, it was often the case that several warnings \ncould be removed by a single annotation, while in the worst case we had to provide thirteen annotations \nto deal with one original issue, when an escaping object was passed between many calls before .nally \nbeing captured in the .eld of another new object. Because of our positive experiences and the soundness \nguarantees our type system provides, we plan that our implementation will replace the current release \nof Spec#. We anticipated worse results than we actually discov\u00adered, because the old approach to initialisation \nin Spec# supported optional non-delayed constructors , which en\u00adcourage a programming style in which \nextra code can be (soundly) included in the body of a constructor, after ini\u00adtialisation is known to \nbe completed. These non-delayed constructors initialise the type-frames of an object bottom\u00adup rather \nthan top-down; one must initialise the non-null subclass .elds before the superclass ones. This initialisation \nmust take place before the base ( super , in Java) call is made in the constructor body. In this way, \none can be sure that after the base call is made, the object has been initialised at all type-frames, \nand therefore can take part in arbitrary code. We chose not to support this feature in our type sys\u00adtem \nor implementation, mainly because it requires runtime behaviour which is not typically supported by mainstream \nOO languages; for example, these constructors cannot be supported directly in Java or C#. We were pleasantly \nsur\u00adprised to .nd that, even given an initial codebase which in\u00adcluded manycomplex constructor de.nitions \nwhich allowed the newly constructed object to escape in interesting ways, our type system was able to \nhandle virtually all cases eas\u00adily. We judge this to be because the complicated construc\u00adtors still typically \nenforced an informal discipline for han\u00addling escaped objects; such objects were sometimes captured in \nthe .elds of other objects under initialisation, but almost never had their own .elds written to, and \nthose .elds which were read from an escapee object typically only ever stored committed values or null, \nat all program points. Thus, the combination of free references (particularly inside construc\u00adtors), \n[Unclassi.ed] annotations to support the passing of escaped objects, and committed-only .elds, allows \nto pro\u00adgrammer to enforce these apparent informal policies in a way which can be expressed and directly \nchecked in our type system. 7. RelatedWork 7.1 Avoiding Initialisation Bugs We .rst revisit some of \nthe related work discussed in Sec. 2, with respect to a simple example of faulty object initialisa\u00adtion, \nshown in Fig. 10. A non-null type system must reject the constructor of class C because its execution \nleads to a null dereference exception. The constructor .rst initialises .eld f with a reference to the \n(already initialised) object p. The next statement is the one that causes the problem: it stores the \nthis reference in a .eld of the initialised object p, which violates the deep initialisation guarantee \nof p. This vi\u00adolation is then exploited in the third statement by expecting falsely that all objects \nreachable from p are initialised and, thus, their non-null .elds contain non-null values, which is not \nthe case for this.g. Raw types prevent this example by forbidding raw refer\u00adences to be stored in any \n.eld. So if setF s parameter q is typed as raw, the method body does not type check. If q is not  public \nclass C { C! f, g; public setF(C! q) { this.f = q; } public C(C! p) { this.setF(p); // alias p as \nthis .f this.f.setF(this); // assign this to p.f this.g = p.f.g.f; // null ptr ex ception } } Figure \n10. Example offaulty object initialisation. raw then the call this.f.setF(this) does not type check because \nthis is raw inside the constructor. However, while this solution is type-safe, it prevents implementations \nsuch as the .rst Node constructor in Fig. 1, which assigns objects that are still under initialisation \nto all three .elds. Delayed types prevent the faulty example essentially by requiring of the call this.f.setF(this) \nthat this and this.f (that is, p) have the same delay time, which is not the case be\u00adcause p is initialised,but \nthis is not.We already argued in the introduction that this treatment is sound, but makes the system \ncomplex. The simpli.ed version of delayed types im\u00adplemented in Spec# does not prevent the example, which \nil\u00adlustrates that this system is unsound! If both the receiver and the parameter of setF are marked as \ndelayed, the type sys\u00adtem assumes that both have the same delay time and permits the assignment. However, \nthis assumption is not (and can\u00adnot) be checked at the call site, which causes the unsound\u00adness. Let \ns now discusshow our system prevents thefaultyex\u00adample from Fig. 10. Consider the second call to setF \nin C s constructor. The receiver of this call, this.f, is unclassi\u00ad.ed because this is not committed. \nTherefore, the call type checks only if setF s receiver is declared unclassi.ed. The argument of the \ncall, this, can be typed with a free or un\u00adclassi.ed modi.er. So the call type checks only if setF s \npa\u00adrameter q is declared free or unclassi.ed. In both cases, the .eld update in setF s body is rejected \nby the type checker (the receiver of the update is not free and the right-hand side is not committed). \nThis illustrates that our system prevents storing objects that are not expected to be initialised in \n.elds of objects that are expected to be initialised, which prevents the unsoundness.  7.2 Comparison \nwith MaskedTypes Since we believe Masked Types to be the most expressive comparable approach to object \ninitialisation, we provide a more-detailed comparison with our approach here. Fig. 11 shows the running \nexample from the Masked Types paper [21]. MaskedTypes allowa programmer to .exiblyexpress a wide variety \nof different re.nements of a class type. For example, while the types Leaf and Binary are standard OO \nclass types, the type Binary\\parent! \\left[root.parent]\\right[root.parent] describes a reference to a \nBinary object whose parent is not assigned, and whose left and right .elds may refer to a objects which \ncannot be assumed to be fully initialised until the .eld root.parent is assigned a value (this is called \na condi\u00adtional mask on the .elds). Using the various kinds of .eld masks included in their type system, \nit is possible to stati\u00adcally describe arbitrary combinations of uninitialised .elds and mutually-dependent \nconditions under which masks can be lifted, and the .elds read from.Aprogrammer can poten\u00adtially express \nprecisely under which conditions a .eld can be soundly assumed to be permanently initialised, on a per\u00ad.eld \nbasis. Furthermore, method and constructor signatures are annotated with explicit effects which describe \nhow the mask information associated with references passed to the call evolves during the method execution. \nIn contrast to our system, the programmer is not forced to initialise all non\u00adnull .elds before a constructor \nterminates; instead, a con\u00adstructor can employ an effects annotation to make explicit the state of each \nuninitialised .eld, potentially in terms of conditional masks which can later be lifted in the client \ncode. Masked Types are highly expressive; they can encode arbitrarily complicated idioms in a precise \nand statically\u00adchecked way. But this complexity inevitably .nds its way into the type system itself, \neven at the source level. As we ex\u00adplained in our design goals, we believe that an important cri\u00adterion \nfor widespread adoption of a type system is simplicity, which encompasses both the conceptual understanding \nre\u00adquired to use the system, and the level of annotation required for typical programming idioms. The \nMasked Types syntax for annotations includes grammars for .exible effects anno\u00adtations and sequenced \nmasks, abstractions over masks, con\u00adstraints on these abstract masks, and so on. The concepts and notations \na programmer must learn in order to understand and use this type system are both numerous and sophisti\u00adcated \nin nature. Furthermore, fully understanding the typing rules can be quite subtle, e.g., for eliminating \n.eld masks: In general, if some dependencies form a strongly connected component in which no mask depends \non a mask outside the component, they can allbe removed together .For these rea\u00adsons, we believe that \nthe technical complexity and richness of the type annotation language, while extremely powerful, makes \nthe system unsuitable for widespread use by program\u00admers, which was our overall design aim. A modi.ed \nversion of the binary tree example (using our type system) is shown in Fig. 12.To be able to type the \nex\u00adample, we had to make two changes. Firstly, the original example initialises the parent of the new \nBinary object outside the constructor (in the last line of Fig. 11). Since our system enforces that constructors \ninitialise all non-null .elds, we added a default assignment of the parent .eld in  class Node { Node! \nparent; Node() effect *! -> *! { } } final class Leaf extends Node { Leaf() effect *! -> parent! { \n} } final class Binary extends Node { Node left, right; Binary(Node\\parent!\\Node.sub[l.parent] -> *[this.parent] \nl, Node\\parent!\\Node.sub[r.parent] -> *[this.parent] r) effect *! -> parent!, left[this.parent], right[this.parent] \n { this.left = l; this.right = r; l.parent = this; r.parent = this; } } Leaf\\parent! l = new Leaf(); \nLeaf\\parent! r = new Leaf(); Binary\\parent!\\left[root.parent] \\right[root.parent] root = new Binary(l, \nr); root.parent = root; // Now fully initialised Figure 11. Tree with back-pointers using masked types. \nclass Node. Secondly, the Binary constructor in the origi\u00adnal example assigns this to the parent .eld \nof the argu\u00adments l and r. Our system does not permit these assign\u00adments because this is free inside \nthe constructor and, thus, may be assigned only to .elds of other free objects. How\u00adever, l and r are \nconsidered committed in our example code. The reason the masked types typing is sound (even though it \npoints the constructor arguments at an object under ini\u00adtialisation), is that the constructor signature \nbuilds in the requirement that the l and r parameters passed must not yet have had their parent .elds \ninitialised. Effectively, this means that their constructor de.nition can only be used with Leaf instances \nwhich are themselves still under initialisa\u00adtion. Our constructor, on the other hand, must be called \nwith initialised Leaf arguments (we could weaken this require\u00adment my annotating the parameters as unclassi.ed); \nin the client code our Node constructor takes care of the default initialisation for us. Note that our \nrefactored code would re\u00admain typeable without extra annotations even if the Leaf and Binary classes \nwere not declared final, which is not the case for the original code. class Node { Node! parent; Node() \n{ parent = this; } } class Leaf extends Node { } class Binary extends Node { Node! left, right; Binary(Node! \nl, Node! r) { this.left = l; this.right = r; } } Leaf! l = new Leaf(); Leaf! r = new Leaf(); Binary! \nroot = new Binary(l, r); l.parent = root; r.parent = root; Figure 12. Tree with back-pointers in our \ntype system. The comparison of the two versions of the example il\u00adlustrates that our version reduces \nthe annotation overhead tremendously. We do not have to add a single annotation to handle the initialisation \nof the cyclic structure6. Our system does not directly support the deferral of initialisation until af\u00adter \nthe constructor has terminated; if such a deferred initial\u00adisation is required, the constructor needs \nto assign a dummy object to the non-null .eld, which gets replaced later (similar dummy assignments are \nsometimes necessary for local vari\u00adables in Java and C# to pass the de.nite assignment checks). However, \nthe implementation is also more general; we do not require Leaf objects to be partially initialised in \norder to add them to Binary objects. We believe that these differences illustrate different mo\u00adtivations. \nMasked Types provide a very general and expres\u00adsive solution (which can handle more-complex typing disci\u00adplines \nwith regard to initialisation), and also tackles alterna\u00adtive problems such as object recycling, which \nour paper does not.Ourmotivation,onthe otherhand,isverymuchtokeep to a proposal which is as simple and \nlightweight as possible for programmers to be able to use for the speci.c problem of object initialisation. \n 7.3 Other RelatedWork Haack and Poll present a type system for object immutabil\u00adity [12], which has \nsome similarities to our work. As they remark in Section 4 of their paper, the initialisation prob\u00adlem \nfor immutability is simpler because one does not need 6Although, with the committed-only-.elds extension \n(Sec. 5.7) we need a single annotation on the .eld parent to override our chosen default.  to handle \ncomplex interactions between immutable and mu\u00adtable references, unlike the problems of initialising mutual \nor cyclic data structures with non-null types. The same is true for the Javari work of Tschantz and Ernst \n[24]. However, the work of Haack and Poll can support initialisation of im\u00admutable structures by introducing \nextra generic quali.er arguments to methods, and using these to explicitly scope and then end the initialisation \nphase for a group of objects. This requires extra annotation overhead, although some an\u00adnotations can \nbe inferred for their system. In recent work, Zibin et al. present a type system which combines ownership \ntypes with immutability [25]. This system can handle cyclic data structures, provided they are initialised \nunder a single common owner object; in our terminology, the owner s com\u00admitment point can be used to \nimplicitly de.ne the commit\u00adment point of all owned objects, which can be initialised .exibly in the \nmeantime. Various implementations and practical works have been based on the original proposals ofF\u00a8 \nahndrich and Leino [10] (with their raw types approach to object initialisation). Several implementations \nhave been based on pluggable types frameworks [4]. Andreae et al. developed the Java-COP framework, and \nimplemented a non-null type checker in the framework [2]. Ekman and Hedin [7] have written a pluggable \ntypes implementation of the type system on top of their JAstAdd compiler framework [8]. Papi et al. have \nde\u00adveloped the Checker framework [20], to facilitate the .exi\u00adble development of type systems based on \ncustomisable Java annotations. This framework has since been used to develop many type checkers for different \nproperties [9]. As future work, we aim to develop a pluggable types implementation using one of these \nframeworks, so that we can also evaluate our design against Java code. Hubert et al. [14] present a machine-checked \nanalysis for inferring non-null types, and Hubert has also extended this work to the level of Java bytecode \n[13]. Male et al. [16] also present a bytecode veri.cation for non-null types, while Chalin and James \n[5] present an empirical study on the use (and defaults) of non-null types. All of these works take essentially \nthe original raw types approach ofF \u00a8 ahndrich and Leino (if any) to object initialisation; that is, \nthey cannot handle examples involving mutual or cyclic initialisation (with the exception of some special \ncases for the this reference in the work of Hubert et al.). Spoto and Ernst [22] have recently presented \nan inter\u00adprocedural .ow analysis (implemented in the Julia tool) for inferring raw annotations from unannotated \nJava byte\u00adcode; their technique can also be broadly applied to other initialisation-related properties. \nIn other recent work, Zibin et al. [26] present a type\u00adsystem for object initialisation in the open-source \nlanguage X10. Their work has similar design goals to ours in terms of simplicity and soundness,but they \nare more restrictive; they require that dynamic method calls be forbidden on objects under initialisation \n(for the sake of ease of understanding by the user). The implemented version of their type system also \ndoes not support cyclic patterns of initialisation, although a possible extension to handle this is sketched. \n8. FutureWork and Conclusions 8.1 FutureWork Since the annotation efforts required in our experiments \nturned out to be very mechanical, it seems natural to in\u00advestigate the possibility of developing inference \ntools to provide or suggest annotations for existing code. We have not yet seen many cases in practice \nwhere such inference would need to be sophisticated, but in principle there are some interesting design \nchoices to be made. For example, so far whenever we found that a method was called with a non-committed \nactual parameter, we tried annotating the method formal parameter with [Unclassi.ed]. However, in cases \nwhere such a method is only called with free actual parameters, one might gain .exibility by choosing \na [Free] annotation; this would allow the passed parameter to have its .elds written to. So far in the \ncode we have examined, we have not seen any cases where an object escapes from its constructor and then \nhas its .elds written to via other methods; it seems that this (dif.cult to reason about) coding pattern \nis typically avoided. The experimental results obtained with our implementa\u00adtion are very promising, \nand we plan to extend our experi\u00adments to further codebases. Since Spec# is a superset of C# 2.0, one \npossibility is to port existing C# codebases to Spec#, allowing us to experiment with annotating widely-used \nclass implementations.We plan to migrate our implementation to the open source version of the Spec# compiler. \nAs mentioned above, we also plan to implement our type system in a plug\u00adgable types framework for Java; \nthis will provide a simple way to access large bodies of critical code, and see how well our annotations \nwork for, e.g., the Java standard libraries. It will also provide a more convenient means for other re\u00adsearchers \nto experiment with using our type system directly. We are also interested in developing prototype implemen\u00adtations \nfor other suitable languages, and to apply our type system to the initialisation of invariants other \nthan non-null types. We have been informed that the Eiffel development team plan to adopt and implement \nour approach to handle initialisation in the Eiffel language [18].  8.2 Conclusions We have presented \na novel type-based approach to object initialisation, based on a simple distinction between objects known \nto be under initialisation, and objects known to be initialised. The core of our system has been formalised \nand proven sound, speci.cally for the problem of handling ob\u00adject initialisationfor non-null types,butinaway \nwhich gen\u00aderalises to other monotonic object invariants such as im\u00admutability. Our type system is implemented, \nand experi\u00adments on large codebases have yielded promising results both in terms of expressiveness and \nease of use. While our implementation is based around Spec#, the type system itself is suitable for use \nin any heap-based language with explicit constructors (or an equivalent language concept).  Since the \ngoal of our work was to design a system suitable for mainstream use, let us revisit the design goals \nwhich we highlighted in the introduction. Our type system is modular;each method is type-checked independently \nof the others, and the usual rules for co-and contra-variant method overriding allows our analysis to \nre\u00admain ignorant of overriding subclass implementations. The type system is sound; we have provided a \ndetailed formalisation for a small language which illustrates the criti\u00adcal aspects of the problem, and \nthe full soundness proofs are available online in our technical report [23]. Our presented solution is \nsuitably expressive;our experi\u00adments on large volumes of code show that the defaults in our type system \nhandle the vast majority of constructors; almost all remaining cases can be dealt with simply by the \nstraight\u00adforward addition of type annotations. Last,but not least, our type system is simple. Understand\u00ading \nhow to use the system requires classifying objects into just two initialisation states, and handling \nreferences using just three initialisation modi.ers (the most common being the default). Our experiments \nshow that the modi.ers are rarely needed, and are generally suf.cient to handle interest\u00ading initialisation \npatterns which do arise, both in practice and in research papers.We believe that the conceptual simplicity \nof our approach, along with its low annotation burden and lack of required runtime support, make it a \npromising candi\u00addate for future use in mainstream programming languages. Acknowledgments We are grateful \nto the anonymous referees for extensive and constructive feedback. We would like to thank Manuel F\u00a8 ahndrich \nfor helpful discussions of delayed types and the previous Spec# implementation.We thank Hermann Lehner \nand Sophia Drossopoulou for useful discussions on the de\u00adtails of the formalisation and presentation. \nWe especially thank Arsenii Rudich for many discussions on the inception and details of this work, and \nfor last-minute food supplies. References [1] PMD tool. http://pmd.sourceforge.net/, 2002. [2] C. Andreae, \nJ. Noble, S. Markstrum, and T. Millstein. A framework for implementing pluggable type systems. In OOPSLA, \npages 57 74.ACM, 2006. [3] M. Barnett and D. Naumann. Friends need a bit more: Main\u00adtaining invariants \nover shared state. In MPC, volume 3125 of LNCS, pages 54 84. Springer, 2004. [4] G. Bracha. Pluggable \ntype systems. In OOPSLA 04Workshop on Revival of Dynamic Languages, 2004. [5] P. Chalin and P. R. James. \nNon-null references by default in Java: Alleviating the nullity annotation burden. In ECOOP, pages 227 \n247, 2007. [6] ECMA. ECMA-367: Eiffel analysis, design and programming language. ECMA, 2006. [7] T. Ekman \nand G. Hedin. Pluggable checking and inferencing of non-null types for Java. Journal of Object Technology,6 \n(7), 2007. [8] T. Ekman and G. Hedin. The jastadd extensible Java compiler. In OOPSLA, pages 1 18.ACM, \n2007. [9] M. D. Ernst and M. Ali. Building and using pluggable type systems. In FSE, pages 375 376.ACM, \n2010. [10] M.F\u00a8ahndrich and K. R. M. Leino. Declaring and checking non-null types in an object-oriented \nlanguage. In OOPSLA, pages 302 312.ACM, 2003. [11] M.F\u00a8ahndrich and S. Xia. Establishing object invariants \nwith delayed types. In OOPSLA, pages 337 350.ACM, 2007. [12] C. Haack and E. Poll. Type-based object \nimmutability with .exible initialization. In ECOOP, LNCS, pages 520 545. Springer, 2009. [13] L. Hubert.Anon-null \nannotation inferencer forJava bytecode. In PASTE, pages 36 42.ACM, 2008. [14] L. Hubert, T. P. Jensen, \nand D. Pichardie. Semantic foun\u00addations and inference of non-null annotations. In FMOODS, pages 132 149, \n2008. [15] K. R. M. Leino and P. M\u00a8Using the Spec# language, uller. methodology, and tools to writebug-free \nprograms. In LASER Summer School 2007/2008, volume 6029 of LNCS, pages 91 139. Springer, 2010. [16] C. \nMale, D. J. Pearce, A. Potanin, and C. Dymnikov. Java bytecode veri.cation for @NonNull types. In CC, \nLNCS, pages 229 244. Springer, 2008. [17] B. Meyer. Attached types and their application to three open \nproblems of object-oriented programming. In ECOOP, pages 1 32, 2005. [18] B. Meyer. Personal commmunication, \n2011. [19] B. Meyer, A. Kogtenkov, and E. Stapf. Avoid a void: The eradication of null dereferencing. \n2010. [20] M. M.Papi, M. Ali,T. L. Correa Jr., J. H. Perkins, and M. D. Ernst. Practical pluggable types \nfor Java. In ISSTA, pages 201 212, 2008. [21] X. Qi and A. C. Myers. Masked types for sound object initialization. \nIn POPL, pages 53 65, 2009. [22] F. Spoto and M. D. Ernst. Inference of .eld initialization. In ICSE, \nMay 25 27, 2011. [23] A. J. Summers andP.M\u00a8uller. Freedom before commitment: Simple .exible initialisation \nfor non-null types. Technical Report 716, ETH Zurich, 2011. [24] M. S. Tschantz and M. D. Ernst. Javari: \nadding reference immutability to Java. In OOPSLA, 2005. [25] Y. Zibin, A. Potanin, P. Li, M. Ali, and \nM. D. Ernst. Owner\u00adship and immutability in generic Java. In OOPSLA, 2010. [26] Y. Zibin, D. Cunningham, \nI. Peshansky, and V. Saraswat. Object initialization in X10. In X10Workshop, 2011.     \n\t\t\t", "proc_id": "2048066", "abstract": "<p>One of the main purposes of object initialisation is to establish invariants such as a field being non-null or an immutable data structure containing specific values. These invariants are then implicitly assumed by the rest of the implementation, for instance, to ensure that a field may be safely dereferenced or that immutable data may be accessed concurrently. Consequently, letting an object escape from its constructor is dangerous; the escaping object might not yet satisfy its invariants, leading to errors in code that relies on them. Nevertheless, preventing objects entirely from escaping from their constructors is too restrictive; it is often useful to call auxiliary methods on the object under initialisation or to pass it to another constructor to set up mutually-recursive structures.</p> <p>We present a type system that tracks which objects are fully initialised and which are still under initialisation. The system can be used to prevent objects from escaping, but also to allow safe escaping by making explicit which objects might not yet satisfy their invariants. We designed, formalised and implemented our system as an extension to a non-null type system, but it is not limited to this application. Our system is conceptually simple and requires little annotation overhead; it is sound and sufficiently expressive for many common programming idioms. Therefore, we believe it to be the first such system suitable for mainstream use.</p>", "authors": [{"name": "Alexander J. Summers", "author_profile_id": "81350573661", "affiliation": "ETH Zurich, Z&#252;rich, Switzerland", "person_id": "P2839318", "email_address": "alexander.summers@inf.ethz.ch", "orcid_id": ""}, {"name": "Peter Mueller", "author_profile_id": "81100614430", "affiliation": "ETH Zurich, Z&#252;rich, Switzerland", "person_id": "P2839319", "email_address": "peter.mueller@inf.ethz.ch", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048142", "year": "2011", "article_id": "2048142", "conference": "OOPSLA", "title": "Freedom before commitment: a lightweight type system for object initialisation", "url": "http://dl.acm.org/citation.cfm?id=2048142"}