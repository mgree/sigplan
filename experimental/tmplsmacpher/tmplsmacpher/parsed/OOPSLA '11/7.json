{"article_publication_date": "10-22-2011", "fulltext": "\n Kind Analysis for MATLAB Jesse Doherty, Laurie Hendren and Soroush Radpour McGill University [jdoher1,hendren,sradpo]@cs.mcgill.ca \nAbstract MATLAB is a popular dynamic programming language used for scienti.c and numerical programming. \nAs a language, it has evolved from a small scripting language intended as an interactive interface to \nnumerical libraries, to a very popular language supporting many language features and libraries. The \noverloaded syntax and dynamic nature of the language, plus the somewhat organic addition of language \nfeatures over the years, makes static analysis of modern MATLAB quite challenging. A fundamental problem \nin MATLAB is determining the kind of an identi.er. Does an identi.er refer to a variable, a named function \nor a pre.x? Although this is a trivial problem for most programming languages, it was not clear how to \ndo this properly in MATLAB. Furthermore, there was no simple explanation of kind analysis suitable for \nMATLAB program\u00admers, nor a publicly-available implementation suitable for compiler researchers. This \npaper explains the required background of MATLAB, clari.es the kind assignment program, and proposes \nsome general guidelines for developing good kind analyses. Based on these foundations we present our \ndesign and implementa\u00adtion of a variety of kind analyses, including an approach that matches the intended \nbehaviour of modern MATLAB 7and two potentially better alternatives. We have implemented all the variations \nof the kind anal\u00adysis in MCLAB, our extensible compiler framework, and we present an empirical evaluation \nof the various analyses on a large set of benchmark programs. Categories and Subject Descriptors D.3.4 \n[Processors]: Compilers General Terms Experimentation, Languages, Performance Keywords MATLAB, Name Resolution, \nKind Analysis Permission to make digital or hard copies of all or part of this work for personal or classroom \nuse is granted without fee provided that copies are not made or distributed for pro.t or commercial advantage \nand that copies bear this notice and the full citation on the .rst page. To copy otherwise, to republish, \nto post on servers or to redistribute to lists, requires prior speci.c permission and/or a fee. OOPSLA \n11, October 22 27, 2011, Portland, Oregon, USA. Copyright &#38;#169; 2011 ACM 978-1-4503-0940-0/11/10. \n. . $10.00  1. Introduction MATLAB is a popular dynamic programming language used for scienti.c and \nnumerical programming with a very large and increasing user base. The most recent data from Math-Works \nshows that the number of users of MATLAB was 1 million in 2004, with the number of users doubling every \n1.5 to 2 years.1 Certainly it is one of the key languages used in education, research and development \nfor scienti.c and en\u00adgineering applications. There are currently over 1200 books based on MATLAB and \nits companion software, Simulink (http://www.mathworks.com/support/books). This large and diverse collection \nof books illustrates the many scien\u00adti.c areas which rely on computational approaches and use MATLAB. \nGiven the importance of MATLAB there is a real lack of publicly-available compiler toolkits for analyzing \nMATLAB programs, thus hindering development in the research com\u00admunity for new optimization, program \nunderstanding, refac\u00adtoring and veri.cation tools. All of these tools need a good framework for program \nanalysis. However, the dynamic na\u00adture of the language, the overloaded syntax, plus the some\u00adwhat organic \naddition of language features over the years, makes static analysis of modern MATLAB quite challenging. \nThis paper tackles the foundational problem of determin\u00ading whether an identi.er refers to a pre.x, a \nvariable, a named function. We call this kind analysis. It might seem surprising that this is a problem \nworth investigating, but while building our MCLAB [7] system for analyzing MAT-LAB we found that this \nwas a crucial concept to understand correctly, and a crucial .rst phase of our analysis framework. Without \nknowing the correct kinds of identi.ers one can\u00adnot even build a very speci.c intermediate representation \n(IR). For example, an expression of the form a(i) could correspond to four different meanings depending \non whether a is a variable or a named function, and whether i is variable or named function. If both \nare variables, then this is a simple array access of array a , indexed by variable i . If both are named \nfunctions, then this is a call to func\u00adtion a , with an argument which is the result of a call to function \ni . The two other cases correspond to when one 1 From www.mathworks.com/company/newsletters/news_notes/ \nclevescorner/jan06.pdf. identi.er is a variable and the other is a function. Clearly, to build an IR \nthat is suitable for further analyses one would like to explicitly represent these different cases. Since \nMATLAB does not have type declarations, and since it does not syntactically distinguish between array/variable \naccesses and function calls, older versions of MATLAB and other interpreter-based implementations such \nas Octave[8] actually determine the meaning of identi.ers completely at runtime. In such systems an expression \nsuch as a(i) is stored as a very unspeci.c fashion such as a parameter\u00adized expression, and the meaning \nof that expression is de\u00adtermined, at runtime, by the interpreter. Each identi.er is looked up .rst in \nthe current workspace, and if it is found then the identi.er refers to that variable. If it is not in \nthe current workspace, then it is looked up in the current path of function de.nitions. If it is found, \nthen the identi.er refers to that named function, and if it is still not found then it is a runtime error. \nHaving these dynamic semantics to determine the mean\u00ading of identi.ers is very easy to implement in an \ninterpreter, but it has two main disadvantages. First, it is quite dif.\u00adcult for programmers and IDEs \nto determine the meaning of identi.ers. Secondly, with such completely dynamic se\u00admantics it is hard \nfor a JIT compiler to produce very ef.\u00adcient code. Thus, in more modern versions of MATLAB the semantics \nhave been changed to include a static kind assign\u00adment to identi.ers. In systems such as MATLAB 7, when \na function is .rst loaded (JIT-compiled), a static kind analysis is applied which assigns a kind to each \nidenti.er in the body of the function. The kind analysis also raises compile-time errors for situations \nin which an identi.er is used as both a function and variable within the same function body. It is important \nto note that the static kind analysis in MATLAB 7 is not a static approximation of the old dy\u00adnamic semantics, \nbut effectively de.nes a new semantics for MATLAB. The new semantics will reject some programs that would \npreviously execute in the old semantics, and it changes the meaning of some programs, particularly those \nthat make use of other dynamic features such as eval and assignin . Thus, to properly understand the \nmeaning of a MATLAB program, and to correctly implement compilers for modern versions of MATLAB such \nas MATLAB 7, it is im\u00adportant to have a clear de.nition and implementation of kind analysis. We were \nunable to .nd either, and so our de.ni\u00adtion and implementation of kind analysis is the topic of this \npaper. We .rst give a motivating example in Section 2. This il\u00adlustrates the difference between the dynamic \nand static se\u00admantics and also shows the confusion caused when an IDE does not understand the analysis, \nand when a programmer does not understand the de.nition of the kind analysis (or even knows that such \nan analysis is performed by the sys\u00adtem). As many compiler writers are not familiar with MATLAB, and \nsince there is no accessible formal de.nition of the lan\u00adguage, we provide the essence of MATLAB semantics \nin Sec\u00adtion 3. This information is needed to completely understand the problem and solution in this paper, \nand may also be use\u00adful for those interested in working on other compiler prob\u00adlems for MATLAB. Given \nthere was no documentation for kind analysis, we developed a large set of test programs designed to expose \nthe intended semantics of MATLAB 7 kind analysis, and we designed and implemented a .ow analysis which \nmatches those semantics. This analysis is neither .ow-insensitive nor fully .ow-sensitive, but is de.ned \nby a depth-.rst traversal over the AST.2 This analysis is presented in Section 4. By de.ning and implementing \na kind analysis to match MATLAB 7, we noted several bugs which we reported to MathWorks3, and we also \nfound some issues which caused us to rethink kind analysis and to suggest some alternatives. In Section \n5 we present our alternatives. The .rst alterna\u00adtive is a .ow-sensitive analysis very similar in spirit \nto the MATLAB 7 analysis, and the second alternative is a .ow\u00adinsensitive approach. We have implemented \nboth the MATLAB 7 approach and our alternatives in our MCLAB extensible compiler frame\u00adwork, where it \nnow forms the basis for all subsequent static analyses. We examined the results of the analyses on a \nlarge suite of MATLAB programs collected from a variety of sources and the results of those results are \npresented and evaluated in Section 6. We found that our alternative .ow\u00adsensitive analysis provided a \ncleaner speci.cation while at the same time matching the original MATLAB 7 approach except in cases where \nour approach detected more static er\u00adrors. The main contributions of this paper are: We identify static \nkind analysis as an important concept that must be clearly de.ned and understood by MATLAB programmers \nand compiler developers. We also provide a summary of MATLAB semantics so other researchers can understand \nboth the kind analyses in this paper and other analyses they may wish to develop.  We present an algorithm \nto compute kinds which matches the intended semantics of MATLAB 7.  We point out weaknesses of the current \nkind semant\u00adics/analyses and suggest two alternatives, a .ow-sensitive approach and a .ow-insensitive \napproach.  We implemented all variations of the kind analysis and we present a comparison of the results, \nand we discuss the pros and cons of each approach. The implementation is part of a publicly-available \ntoolkit.4.  2 It took us some time to discover this, as we were expecting either a .ow\u00ad sensitive or \n.ow-insensitive approach. 3 These were acknowledged as bugs by MathWorks and the algorithm pre\u00adsented \nin the paper .xes those bugs. 4 http://www.sable.mcgill.ca/mclab/download_mclab.html  2. Motivating \nExample To demonstrate the problem of not having a clear de.nition of kind analysis, consider the toy \nexample for the MATLAB function iassigni given in Figure 1(a). This is the display produced with MATLAB \n7.11 IDE. The IDE signals that there are potential problems with this function via the red bar on the \nright. When the user clicks on the red bar, the warnings and explanation given in Figure 1(b) are displayed. \nThese warnings would make sense if all occurrences of the identi.er i refer to variables. However, the \nIDE appears to be oblivious of kind analysis, and in fact the warnings are not correct, and when the \nuser attempts to call the function, a completely different error occurs, as listed in Figure 1(c). What \nis going on? To try and understand the problem, the user might type the statements one by one into the \nread-eval-print loop. Fig\u00adure 1(d) shows such an interaction. Each line beginning with >> is a user input. \nThe user starts by clearing the workspace. The user then checks the binding of identi.er i using the \ncommand which i . This returns the fact that i refers to a built-in named function in one of the standard \ntoolboxes (returning the mathematical value for i). The user then types in the previously troublesome \nstatement i=i . This actually has a well de.ned meaning; it .rst evaluates the right-hand-side, which \nis a call to the built-in function called i , and then assigns the value to a variable called i . Since \nvariables are not declared in MATLAB,they are created upon their .rst de.nition. The user then veri.es \nthat i is now a variable using another call to which i . Fi\u00adnally, the call to display is done, which \ndisplays the value of the variable i . The root of all this confusion is that the semantics of name lookups \ndepends on whether or not a static kind anal\u00adysis is being used. When the function iassigni is called, \nthe JIT compiler is invoked and a kind analysis is applied. This kind analysis will determine that the \n.rst use of i cor\u00adresponds to a call of the named library function i , whereas the assignment to i corresponds \nto a variable. This kind con.ict results in the error message. However, when the user enters the same \ncomputation line-by-line into the read-eval-print loop the kind analysis is not applied to the whole \ncomputation, which results in dynamic lookup semantics.5 There are two important points demonstrated \nby this example. First, it shows that all tools, including optimiz\u00ading compilers, program-understanding \ntools and refactoring tools need to correctly implement kind analysis. In this case, the IDE apparently \ndoes not perform kind analysis (or does not integrate it correctly). Thus, it assumes that all occur\u00adrences \nof i are variables, does not correctly identify the kind con.ict, and gives misleading warning messages. \nIn 5Older versions of MATLAB and interpreter-based systems like Octave do not have a kind analysis, in \nthese systems the function body would be interpreted using the dynamic lookup semantics.  >> iassigni() \n??? Error: File: iassigni.m Line: 2 Column: 4 \"i\" previously appeared to be used as a function or command, \nconflicting with a variable. A possible cause of this error is that you forgot to initialize the variable, \nor you have initialized it implicitly using load or eval. (c) error when executed >> clear >> which \ni built-in (C:\\MATLAB\\R2010b\\toolbox\\matlab\\elmat\\i) >>i= i i=0+ 1.0000i >> which i i is a variable. \n >> display(i) i=0+ 1.0000i (d) read-eval-print execution Figure 1. Motivating toy example the case \nof optimizing compilers the kinds of identi.ers are needed for building correct call graphs and for correctly \nap\u00adplying many transformations such as inlining. In the case of tools like refactoring tools, refactoring \ntransformations must ensure that the refactoring does not change the kind of an identi.er and does not \nintroduce a kind con.ict. Second, this example shows that the dynamic semantics for identi.er lookup \nthat programmers may expect from hav\u00ading performed a computation in the read-eval-print loop are not \nvalid within function and script de.nitions. Thus, pro\u00adgrammers must be given some simple rules so they \ncan de\u00adtermine the kind of identi.ers in function/script de.nitions. This will make it easier for them \nto ensure they are us\u00ading identi.ers consistently within a function/script and will make the programs \neasier to understand. Although this is just one toy example, it does demonstrate that it is important \nfor both MATLAB programmers and the compiler/toolkit developers to have a clear understanding and clean \nimplementation of kind analysis. In Section 4 we present a kind analysis that matches the current MATLAB \n7 semantics and in the subsequent section we present some alternative kind analyses.  3. The Essence \nof MATLAB In this section we provide a brief overview of the semantics of MATLAB, concentrating on the \nrules for resolving iden\u00adti.ers.6 For the purposes of this paper we are concentrating on the non object-oriented \npart of MATLAB and we assume that all functions are either de.ned as MATLAB source or are well-de.ned \nbuilt-in functions. At a high level, a MATLAB computation executes relative to a pair <library, env> \nwhere library is a collection of named function/script de.nitions, and env is a mapping of variable names \nto values. We de.ne the library and env in more detail in the next two subsections. 3.1 MATLAB library \nof function/script de.nitions MATLAB functions and scripts are stored in directories with a speci.c format. \nA directory d, may contain: .m source .les: Each .le of the form f.m contains either: (a) a script, which \nis simply a sequence of MATLAB state\u00adments; or (b) a sequence of function de.nitions. If the .le f.m \nde.nes functions, then the .rst function de.ned in the .le should be called f (although even if it is \nnot called f it is known by that name in MATLAB). The .rst function is known as the primary function. \nSubsequent functions are subfunctions. The primary and subfunctions within f.m are visible to each other, \nbut only the primary function is visible to functions de.ned in other .m .les. Functions may be nested, \nfollowing the usual static scop\u00ading semantics of nested functions. That is, given some nested function \nf , all enclosing functions, and all func\u00adtions declared in the same nested scope are visible within \nthe body of f . 6 Since we were unable to .nd any of.cial language speci.cation docu\u00adments, these semantics \nhave been determined from reading user-level doc\u00adumentation [6], and observing the behaviour of MATLAB \n7.11. Private directories: A directory may contain a directory named private/. Package directories: \nPackage directories start with a + , for example +mypkg/. The primary function in each .le f.m de.ned \ninside a package directory +p corresponds to a function named p.f. To refer to this function one must \nuse the fully quali.ed name, or an equivalent import declaration. Package directories may be nested. \n Type-specialized directories: It is possible to overload function declarations using type-specialized \ndirectories. These directories have names of the form @<typename>, for example @int32/. The primary function \nin a .le f.m contained in a directory @typename/ matches calls to f(a1,...), where the run-time type \nof the primary (.rst) argument is typename. The lookup of a script/function is performed relative to: \nf, the current function/script being executed; source.le,the .le in which f is de.ned; fdir, the directory \ncontaining the last called non-private function (calling scripts or private functions does not change \nfdir); dir, the current directory; and path, a list of other directories. When looking up func\u00adtion/script \nnames, .rst f is searched for a nested function, then source.le is searched for a subfunction, then the \nprivate directory of fdir is searched, then dir is searched, followed by the directories on path. In \nthe case where there is both a non-specialized and type\u00adspecialized function matching a call, the non-specialized \nversion will be selected if it is de.ned as a nested, subfunc\u00adtion or private function, otherwise the \nspecialized function takes precedence. The current directory and path do not normally change during the \nexecution of the program. This is particularly true if the application has been written in a way that \nmakes it somewhat portable. However, there do exist run-time func\u00adtions which allow dir and path to change \nat run-time. 3.2 Environment and Values The environment, env, corresponds to the MATLAB notion of a \nworkspace. The environment maps variable names to values. We can think of the environment as consisting \nof the following four parts: Main workspace: This is the initial workspace, a mapping of variable names \nto values, which is acted upon by commands entered into the main read-eval-print loop. Function call \nworkspace stack: A call to a function cre\u00adates and pushes a new workspace, which becomes the current \nworkspace. A return from a function pops the workspace, restoring back the new top of the stack as the \ncurrent workspace. In the case of a stack frame cor\u00adresponding to a nested function, there are the usual \ndis\u00adplay pointers to the stack frame workspaces correspond\u00ading to the outer scopes. A call to a script \ndoes not create a new workspace, but rather uses the workspace of the last called function (i.e. the \ntopmost stack frame).  Globals: The globals structure maps global variable names to values. There is \none such globals structure shared by all functions. A variable x is local within a function un\u00adtil a \ncall to global(x) occurs within the function body. Currently it is possible for a function body to contain \nboth local and global uses of x . However, the current version of MATLAB issues warnings that future \nversions will not allow this. Presumably this means that in future versions a call to global(x) will \nhave to dominate all other oc\u00adcurrences of x within the function body. Persistents: The persistents structure \nmaps (fully quali.ed \u00adfunction name x variable name) to values. Persistent variables are like global \nvariables, but are associated with a speci.c named function only. Within function f , a variable x is \nmade persistent through a call persist\u00adent(x) . Calls to persistent may only occur in function bodies \n(and not scripts) and a call to persistent(x) must dominate all other occurrences of x in the func\u00adtion \nbody. AMATLAB value can be one of the following types: array, function handle, struct or cell array. \nWe can think of the basic types as being arrays and func\u00adtion handles. Arrays are homogeneous (i.e. all \nelements have the same type) and the elements must have some numeric type (double, int32, char, ...). \nIn particular, the elements of arrays cannot be handles, structs or cell arrays. Arrays have a shape \nand contents, and arrays are mutable. A scalar is simply a 1x1 array. A function handle refers to a closure, \nwhere the closure consists of a reference to the function and a reference to a workspace that maps free \nvariables to val\u00adues. A function handle is created by either taking the handle of a named function (for \nexample, h = @sin; ) or by cre\u00adating a handle to an anonymous function (for example, h= @(x)(x+1); ). \nStructs and cell arrays are heterogeneous and provide a way of aggregating data. Structs do not have \nexplicit types but are constructed using calls like a = struct( x ,exp1,\u00ad y ,exp2) , which would create \na structure with two .elds, x initialized to the value denoted by exp1 and y ini\u00adtialized to the value \ndenoted by exp2 . Each .eld can con\u00adtain any type (array, handle, struct or cell array). Cell arrays \nhave the same rectangular structure as arrays, but their ele\u00adments are cells instead of numeric values, \nwhere each cell can contain any type. Thus cell arrays allow one to create heterogeneous and nested arrays. \nCell arrays are accessed using a(...) which denotes the cells or a{...} which denotes the contents of \nthe cells.  3.3 General Identi.er Lookup Semantics In the read-eval-print loop of MATLAB, the meaning \nof an identi.er is determined at run-time, which is potentially quite expensive. The basic idea is quite \nsimple, as outlined in generalLookup below. First a lookup in the current environment is performed, and \nif the identi.er is found then the lookup returns a variable. If the identi.er is not found in the environment, \nthen a lookup in the library is performed and if an entry is found, then the lookup returns a named function/script. \n generalLookup(id,env, lib ) { if ( existsInEnv (id,env)) return(lookupInEnv(id,env)) else if ( existsInLib \n(id, lib )) return(lookupInLib(id, lib )) else error( Unde.ned variable or function ) }  4. Kind Analysis \nA kind analysis for MATLAB must perform two functions: (1) it must assign a kind to each identi.er occurrence \nin the body of functions/scripts; and (2) it must detect clashes in kind assignments within a function/script \nbody and produce appropriate errors/warnings. Since we were not able to .nd any formal description of \nthe semantics, nor any description of the kind analysis (or even the existence of such an analysis), \nwe developed an ex\u00adtensive set of test cases and observed the behaviour of MAT-LAB 7.11. Based on those \nobservations we have de.ned the following kind analysis, which appears to replicate the se\u00admantics of \nMATLAB 7. By de.ning this analysis precisely we can both implement it in our own MATLAB system and use \nit as the basis for subsequent static analyses. In fact, any system attempting to match the semantics \nof modern MAT-LAB systems must implement this kind analysis (or an equiv\u00adalent one), otherwise the meaning \nof identi.ers at run-time may not be correct. Our kind analysis assigns to each identi.er one of the \nfollowing abstract values: ID: It is not known if the identi.er refers to a named func\u00adtion/script or \na variable. At run-time, an identi.er with this kind must be looked up with the general lookup func\u00adtion, \n.rst looking in the environment and then in the li\u00adbrary. FN: The identi.er refers to a named function/script. \nAt run\u00adtime, an identi.er with this kind is looked up directly in the library. Thus, even if a variable \nwith this name exists at run-time, the named function/script is used.7 If at run\u00adtime a function/script \nwith this name does not exist in the current library, then it is an unde.ned function error. VAR: The \nidenti.er refers to a variable. At run-time a vari\u00adable with this kind is looked up in the environment \nonly. 7 A variable may exist due to the use of dynamic features available in MAT\u00adLAB,such as eval and \nassignin . In older versions of MATLAB, which did not have a kind analysis, such dynamically-created \nvariables would shadow the function of the same name. If at run-time a variable with this name is not \nin the envi\u00adronment, then it is an unde.ned variable error. PREFIX: The identi.er refers to a package, \nas the pre.x of a fully-quali.ed function name. For example in the expres\u00adsion mypkg.f, mypkg would have \nthe kind PREFIX. At the end of the analysis each identi.er will be assigned one of the values ID,FN,VAR,or \nPREFIX or a compile\u00adtime error signaling a kind clash will be raised. During the analysis we use two \nfurther abstract values: UNDEF: This is a special value used when analyzing func\u00adtions and is used to \ndenote the fact that the identi.er has not yet occurred in any statements already analyzed. If the analysis \nends without a compile-time error, then there will be no UNDEF values since every identi.er will be visited \nat least once. MAYVAR: This is a special value to indicate that the iden\u00adti.er might be a VAR. It is \nused when an identi.er is ex\u00adplicitly mentioned by a load command. In this case the identi.er may or \nmay not refer to a variable, depending on whether or not the variable exists in the loaded .le. The MAYVAR \nvalue is also used as an initial approxi\u00admation when analyzing script bodies. At the end of the analysis \nif any identi.er remains mapped to MAYVAR, its .nal kind is set to ID because a general lookup should \nbe used. These abstract values are ordered as shown in Figure 2, and based on this ordering the N operation \nis de.ned, which is the join of the two values where it exists, and error other\u00adwise. For example, there \nis no join for VAR and FN,sothe result is error. Although discovering the structure and details of the \nanal\u00adysis was quite challenging, in the end the analysis itself is quite straight-forward, and consists \nof three steps: Initialize: The initial kinds are set such that there is an initial value, kind[id] for \neach identi.er occurring in the function/script. Traverse function/script updating the kind abstraction: \nThis is a simple traversal of the AST representation of the function/script based on the program structure, \nupdating the kind abstractions, and detecting compile-time kind errors. The traversal order is a simple \ndepth-.rst traversal of the AST. Sequences of statements are visited in the order found in the sequence; \nin assignment statements .rst the right-hand side is visited, followed by the left-hand side; in expressions \nthe sub-expressions are visited .rst8,left\u00adto-right; in if statements the condition is visited .rst, \n8 We should note that is important to always visit the sub-expressions .rst, even when processing the \nleft-hand side of an assignment. In developing our algorithm, we uncovered a bug in the MATLAB 7.11 implementation \nof kind analysis. Consider the example, size(size(i))=1 . In this case the sub-expression should .rst \nbe evaluated. Since size is a function followed by the then part, followed by the else part; and in loops \n.rst the condition/header is visited and then the body. In the case of functions with inner functions, \nthese are processed recursively, .rst the body of the outer function, followed by a recursive analysis \nof all functions which are immediately nested. As the AST is traversed an abstract kind is assigned to \neach identi.er.9 Finalize kind assignments: The .nal step is to .nalize the kind assignments for identi.er \noccurrences based on ei\u00adther the .nal kind abstraction (functions) or the kinds computed during the traversal \n(scripts). The analysis for functions and scripts differ from each other in terms of the initial approximation \nand the .naliza\u00adtion step (the .rst and third steps). The actual traversal and kind approximation rules \n(i.e. the second step) are the same in both cases. We .rst present the approach for both func\u00adtions (Section \n4.1) and scripts (Section 4.2), and then give an example to illustrate the rules, and the differences \nbetween functions and scripts (Section 4.3). 4.1 Kind analysis for functions For functions, the initial \nkind approximation starts by assign\u00ading VAR to each input and output parameter, and UNDEF to all other \nidenti.ers (indicating no occurrence of identi\u00ad.er has been visited yet). Then, each statement is processed \nusing a depth-.rst traversal of the AST, updating the kind approximation using the following rules and \nthe merge (N ) operation de.ned in Figure 2. Variable De.nition: If identi.er x is being de.ned (i.e. \nx is being used as an lvalue on the left-hand side of an assignment statement), or x is an argument to \nglobal(x) or persistent(x) , then x must be a variable in this statement. Hence the following rule is \nused: kind[x] . kind[x] N VAR Note that if the previous approximation for kind[x] was FN, then this indicates \na compile-time kind error because there must be another place where the identi.er was bound to a named \nfunction and the current MATLAB semantics disallow an identi.er being used both as a variable and a named \nfunction/script. Thus, in this case the analysis terminates with an error. Cell Array Access: If identi.er \nx is being used in a cell array access (either as an rvalue or lvalue), then x must be a variable. This \nis one case where the syntactic in the library, it has kind FN. Then the outer use of size should be \nprocessed, which is a de.nition of a variable, and so the kind should be VAR, which is a kind clash. \nThis clash is not reported by the current MATLAB 7.11 implementation and MathWorks has acknowledged that \nthis is a bug. 9 This traversal is made more explicit when we compare this approach with our proposed \n.ow-sensitive analysis in the next section. PREFIX FN VAR N UNDEF ID MAYVAR PREFIX FN VAR  UNDEF \n UNDEF ID MAYVAR PREFIX FN VAR ID ID ID MAYVAR PREFIX FN VAR MAYVAR MAYVAR MAYVAR MAYVAR MAYVAR PREFIX \nFN VAR PREFIX PREFIX PREFIX PREFIX PREFIX error error ID FN FN FN FN error FN error VAR  VAR VAR \nVAR error error VAR UNDEF   Figure 2. Merge (N ) operation for kind analysis structure clearly disambiguates \nbetween a variable and a named function. The same analysis rule as for Variable De.nition is used: kind[x] \n. kind[x] N VAR Handle Expression or Command Statement: If identi.er x occurs in a handle expression \n(i.e. an expression of the form @x ) or as the name of a command (i.e. in a statement of the form x arg), \nthen x must be a named function/script.10 Hence the following rule is used: kind[x] . kind[x] N FN Note \nthat if the previous approximation for kind[x] is VAR, a compile-time error is raised (VAR N FN evaluates \nto error). Variable Use: If the identi.er is a use of x (i.e. occurs as an rvalue), then we .rst check \nto see if the kind[x] is one of UNDEF or ID, in which case no previous statement has given this identi.er \na speci.c kind. In particular, this means no previously analyzed statement has made this identi.er a \nVAR. If the identi.er is in the library, we know that this occurrence of the identi.er must refer to \na named function. If the identi.er is not in the library as a function, then we check to see if it is \nthe name of a class/package. Hence given identi.er x , and the current library lib , the following rule \nis used: if ((kind[x] .{ID, UNDEF})&#38;(exists function(x,lib))) kind[x] . FN elseif ((kind[x] .{ID, \nUNDEF})&#38;(exists package(x,lib))) kind[x] . PREFIX else kind[x] . kind[x] N ID Explicit Load: MATLAB \nallows loading variables from saved .mat .les. Thus, a statement of the form load(\u00ad mydata , x ) will \nattempt to load the value of variable 10In MATLAB afunctioncalloftheform foo( mystring ),where the argument \nis a string, may also be written foo mystring, where the sec\u00adond alternative implicitly treats mystring \nas a string and not a variable. This is a very natural syntax for some commands, especially those used \nin the read-eval-print loop, for example one can use cd mydata instead of cd( mydata ). When used as \na command, it clearly references a named function and not a variable.  x from the .le mydata . If the \nload succeeds (i.e. x is de.ned in the .le) then the variable will be de.ned in the workspace, but otherwise \nit will not. Thus, we have to represent the situation where a variable may or may not exist. For this \nsituation we use the special abstract value MAYVAR. In particular, note that if a subsequent state\u00adment \n.nds the kind to be FN, then this is not considered to be an error, and the kind will updated to FN. \nkind[x] . kind[x] N MAYVAR Variable Binding an end : There is one remaining corner case, which is not \nat all obvious. In MATLAB, one can use the keyword end to denote the last index of an ar\u00adray. For example, \nif a is an array and f is a named function, then the value denoted by end in the expres\u00adsion a(f(end)) \nis the index of the last element of a . However, in order to bind end to the correct identi.er, we need \nto know which is the closest enclosing variable name. We have followed the intended MATLAB 7 seman\u00adtics. \nAssume we are analyzing identi.er x inanex\u00adpression of the form id 1(id 2 ...(id k (x (id m... (id n(... \nend)...) , and that all of id m to id n have already been processed. If any of the more closely nested \nidenti.ers ( id m to id n ) have the kind VAR, then the end has been bound. If the end has not already \nbeen bound by a VAR,then there are three cases: FN :Ifthekindof x is FN,then x is not binding the end \n, so the kind of x does not change and the analysis proceeds to the next outer level. If this was the \noutermost level, then an error is produced indicating that there is no variable binding end . VAR :Ifthekindof \nx is VAR,then x is the binding var, and the kind remains as VAR and the binding process terminates. MAYVAR, \nID or UNDEF: In this case the analysis needs to determine if x is the only remaining possibility to bind \nend or not. If there are any outer identi.ers ( id 1 to id k ) that have kind VAR,ID,MAYVAR or UNDEF, \nthen there is no way to determine which identi.er binds end , and a kind error is generated to indicate \nthat the binding of end is ambiguous.11 If there are no such outer identi.ers, then x is the only remaining \npossibility to bind the end , so its kind is changed to VAR, even though it is not certain that the identi.er \nis a variable (i.e. it has not been explicitly assigned to). In the MATLAB 7 implementation the kind \nis changed without generating any warning, but in our suggested alternative analyses we generate a warning \nfor this case.       After traversing the complete AST of a function, the .nal kind assignments \nare made to the identi.ers. In the case of functions, all occurrences of an identi.er x are given the \nsame kind, based on the .nal values computed by the kind analysis (this is not the case for scripts). \nThe exact assignment is as follows, assuming that the .nal kind assignment is stored in the mapping kind \n. for each id occurrence in f do if kind[id] in {ID,MAYVAR}id.kind = ID else /* kind[id] in {VAR, FN, \nPREFIX} */ id.kind = kind[id]  4.2 Kind analysis for scripts Scripts in MATLAB are simply a sequence \nof MATLAB state\u00adments. A script is called either from the main read-eval-print loop, or from a function \nor another script. In the .rst case the script executes in the main workspace, and in the other cases \nit executes using the topmost stack workspace. The static kind analysis of a script must take into consideration \nthat, unlike the case of functions, the initial set of variables is not known. Thus the initial set approximation \nfor all identi.ers is MAYVAR, representing the situation that the variable may or may not exist. Given \nthis initial approximation the same rules are applied as with the function case. There is one additional \ntwist in handling the end ex\u00adpression for scripts. The rule used for functions may gen\u00aderate too many \nerrors because many identi.ers in scripts have the kind MAYVAR, and thus there may be many am\u00adbiguities \nin binding end . For example, a script may have a statement of the form size(a(end)) where both a and \nsize have kind MAYVAR.Since size is a library func\u00adtion and a is not a library function, it is very likely \n(but not certain) that the programmer intended end tobind to a . Thus, within scripts, the current MATLAB \n7 implementation checks if one of the identi.ers is in the library and the other is not. If this is the \ncase, it binds the end to the identi.er not in the library. If both identi.ers are in the library, then \n11 Note that we have implemented the intended MATLAB 7 semantics for the ambiguous case and not the current \nimplementation in MATLAB 7.11, which has an acknowledged bug. The current MATLAB 7 implementation only \n.nds an ambiguous binding if the ambiguous identi.er is the immedi\u00adately nesting one and thus misses \nsome ambiguous bindings. it somewhat arbitrarily chooses the outermost one. If neither identi.er is \nin the library, then it issues an ambiguity error.12 The script case also differs from the function case \nin how the .nal kinds are assigned to identi.er occurrences. Unlike in the function case, where the .nal \nkind values are used, in the script case the values that were computed during the analysis are used. \nThus, when analyzing scripts the kind analysis decorates each identi.er occurrence with the current value \nof kind[id]. The .nal kind assignment makes a .nal pass through the AST adjusting the kind values as \nfollows. Any identi.er occurrence which had a kind of VAR or MAYVAR is set to be ID.13 Note, however, \nthat the analysis rules will still give compile-time errors for obvious mismatching of kinds. for each \nid occurrence in s do if id.kind in {VAR,MAYVAR} id.kind = ID else /* id . kind must be FN, it can't \nbe ID or UNDEF */ id.kind = FN  4.3 Illustrative Examples In order to illustrate the kind analysis, \nand also to demon\u00adstrate the differences between functions and scripts, consider the examples in Figure \n3. 4.3.1 Kind analysis for myfunc In MATLAB the declaration of a function starts with the key\u00adword function \nfollowed by an optional list of output pa\u00adrameters, followed by the function name, an optional list input \nparameters, and then the function body which is ter\u00adminated with the keyword end . The function myfunc \nin Figure 3(a) has one output parameter ( r ), and two input parameters size and i . Parameters have \nno types, and variables within the function body are declared implicitly upon .rst de.nition. The kind \nanalysis for myfunc is summarized in Fig\u00adure 3(c). The table lists all the identi.ers occurring in the \nfunction de.nition. The initialization sets the parameters ( r , size and i )) to VAR, and all other \nidenti.ers to UNDEF. The body of the function is then traversed, applying the analysis rules. For example, \nat line 8, identi.er s is de\u00ad.ned, so its kind is set to VAR. At line 9 there are two iden\u00adti.er uses, \ns and magic . Following the rule for uses, s is already a VAR, so nothing needs to be done. At this point \nmagic is still UNDEF, so a lookup is made in the library. Since magic is in the standard MATLAB library, \nits kind is set to FN. The analysis continues until the complete func\u00ad 12 In our alternative approaches \nwe are slightly more rigorous. We issue a warning in the case where one identi.er is in the library and \nthe other is not, and we issue an error when both identi.ers are in the library and we also issue an \nerror when neither identi.er is in the library. 13 This seems like a strange decision to us, and we think \nthis may just be an artifact of how scripts interact with the current JIT compiler in MATLAB 7. We suggest \nan alternative approach in the .ow-sensitive analysis we present in the next section.  1 function [r \n] = myfunc(size,i ) 1 % Assumes prev defn of size and i 2 % Returns sin or cos of magic 2 % Returns sin \nor cos of magic 3 % square with dim. size ( i ) 3 % square with dim. size ( i ) 4 % If size ( i ) is \nodd, 4 % If size ( i ) is odd, 5 % return sin of magic square 5 % return sin of magic square 6 %else \n6 %else 7 % return cos of magic square 7 % return cos of magic square 8 s= size (i ); %s:VAR,size:VAR,i:VAR \n8 s= size (i ); %s:ID,size :ID,i:ID 9 a= magic(s); %s:VAR,magic:FN,a:VAR 9 a= magic(s); %a:ID,magic:ID,s:ID \n10 if (mod(s,2)==1) %mod:FN,s:VAR 10 if (mod(s,2)==1) % mod:ID,s:ID 11 fp = @sin; %fp:VAR,sin:FN 11 fp \n= @sin; %fp:ID,sin:FN 12 r = fp(a ); %r:VAR,fp:VAR,a:VAR 12 r = fp(a ); %r:ID,fp:ID,a:ID 13 else 13 else \n14 r= cos(a ); %r:VAR,cos:FN,a:VAR 14 r= cos(a ); %r:ID,cos:ID,a:ID 15 end 15 end 16 display (r ); % \ndisplay :FN,r:VAR 16 display ( r ); % display :ID,r:ID 17 fp2 = @display; % fp2:VAR, display:FN 17 fp2 \n= @display; %fp2:ID, display :FN 18 display (r ); % display :FN,r:VAR 18 display ( r ); % display :FN,r:ID \n19 end 19 % end of script (a) myfunc.m (b) myscript.m 8 9 10 11 12 14 16 17 18 .nal init 8 9 10 11 12 \n14 16 17 18 VVVUUUUUUUU U VVVVUUUUUUU U VVVVFVUUUUU U VVVVFVFUUUU U VVVVFVFFUVU U VVVVFVFFUVU U VVVVFVFFF \nVU U VVVVFVFFFV F U VVVVFVFFFV F V VVVVFVFFFV F V VVVVFVFFFV F V (c) Kind analysis for myfunc MMMMMMMMMMMM \nMMMVMMMMMMMM MMMVMVMMMMMM MMMVMVMMMMMM MMMVMVM F MVMM VMMVMVM F MVMM VMMVMVM F MVMM VMMVMVM F MVMM VMMVMVMFMV \nFM VMMVMVMFMV F V (d) Kind analysis for myscript Figure 3. Kind analysis for a function and script (Note \nthat to save space the kinds in the table use only the .rst letter of the kind.) tion body has been traversed, \nproducing the .nal kind ap\u00adproximation shown at the bottom of the table. Identi.ers r , size , i , s \n, a , fp and fp2 are VAR,and the re\u00admaining identi.ers are FN. The .nalization phase traverses through \nthe AST anno\u00adtating each identi.er occurrence with the kind found in the .nal approximation. In Figure \n3(a) we have put the .nal kind values for identi.er occurrence.  4.3.2 Kind analysis for myscript MATLAB \nscripts are simply a sequence of MATLAB state\u00adments. The run-time meaning of identi.ers in the script \nbody can depend on the context in which the script is called. Most importantly, the free identi.ers may \nor may not refer to ex\u00adisting variables. The analysis for myscript is summarized in Fig\u00adure 3(d). In \nthe case of scripts we do not know the con\u00adtext in which the script will be called, and thus we have \nto assume that every identi.er may or may not be a variable. This corresponds precisely to the MAYVAR \nabstraction, so all identi.ers are initialized to MAYVAR. The body of the script is then analyzed. Because \nall of the identi.ers have an initial value of MAYVAR, the anal\u00adysis can detect many fewer cases where \nan identi.er must refer to a FN. For example, at line 9 in myfunc we could determine that since magic \nwas not a variable, and since it was in the library, its kind became FN. However, at line 9in myscript \n, magic may be a variable, as denoted by MAYVAR. Hence, we cannot sharpen the kind estimation. In fact, \nit is only at lines 11 and 17, where there are explicit uses of the @ operator, where we can determine \nthat an identi.er has kind FN. The .nalization phase traverses through the AST .nal\u00adizing the kind assignment \nof each identi.er occurrence us\u00ading the information computed at the statement. All VAR and MAYVAR values \nare coarsened to ID,and all FN values re\u00admain. Note that unlike the case of functions, different oc\u00adcurrences \nof the same identi.er in a script can be given dif\u00adferent kinds. For example, at line 16 display is an \nID, whereas at line 18 display is a FN. Thismeansthat if the myscript script were to be executed in an \nenviron\u00adment where display was a variable, the statement at line 16 would refer to the variable, whereas \nthe statement at line 18 would refer to the named function.14 4.3.3 Implications of the differences \nin kind analysis for scripts and functions There are two important implications of the differences be\u00adtween \nthe kind analysis for functions and scripts. Firstly, the kind analysis in scripts is likely to produce \nmuch less pre\u00adcise (and hence less useful) kind information. This has nega\u00ad 14This is another feature \nof the existing MATLAB 7 semantics that we think is problematic, and which we address in our upcoming \n.ow-sensitive analysis. tive impact on our ability to effectively analyze and optimize code in scripts. \nSecondly, one cannot easily inline scripts (at the source code level), because the kind assignment (and \nhence the identi.er lookup results) could be quite different when the code is inlined into a function. \nThis means that any inlining in a compiler are most easily done after the kind as\u00adsignment has been done, \nand the kinds that were computed in the script body must be retained in the inlined code.  4.3.4 How \nkind analysis changes the semantics of MATLAB The introduction of the kind analysis in modern versions \nof MATLAB has changed the semantics of the language in two ways. The .rst change is that some programs \nthat previously computed a value will cause a compile-time kind error when .rst load/compiled by the \nJIT compiler. This was demon\u00adstrated by our motivating example in Figure 1. This exam\u00adple would run under \nthe old dynamic name lookup (as we demonstrated using the eval-print-loop), but triggers a kind error \nwhen compiled using modern MATLAB 7.11. The second change is due to the fact that the kind anal\u00adysis \nassigns a speci.c kind to identi.ers, and then at run\u00adtime performs a lookup of only that kind. Thus, \nprograms may compute different results as compared to the dynamic lookup. For example, consider the program \nin Figure 4. With a purely dynamic lookup sum denotes the function sum at line 2 and the variable sum \nat line4. This is because line 3 indirectly assigns to sum . Such indirect assignments may be via calls \nto dynamic functions like eval or via calls to scripts. With a kind analysis, a static decision must \nbe taken about whether sum denotes a VAR or FN. Since there is no direct assignment to sum , and sum \nis in the library, sum will denote the function sum at both line 2 and line 4, even though a variable \nsum exists at runtime at line 4. 1 function [r] = KindEx(a) 2 x=a+ sum(j); 3 eval ( ' sum = ones (10); \n' ); 4 r= sum(x); 5 end Figure 4. Example of dynamic lookup versus lookup with kind analysis Since kind \nanalysis changes the semantics, both program\u00admers and compiler-based tools must be aware of kind anal\u00adysis \nand must implement it correctly in order to match the semantics of MATLAB 7.11.   5. Alternative Kind \nAnalyses Our original goal for this research was to clearly understand the MATLAB 7 kind analysis and \nto provide an algorithm and implementation for it. In the previous section we have ac\u00adcomplished that. \nHowever, as we speci.ed and implemented the algorithm we were struck by ways in which it could be improved, \nand in this section we describe the features of the MATLAB 7 algorithm that we think are problematic, \nand the two different approaches we suggest. As we discuss our approaches, it is important to keep in \nmind the requirements for a good kind analysis. Firstly, the kind analysis should be very simple to understand \nfor the programmers, so that it is trivial for a programmer (or an IDE) to determine the kind of each \nidenti.er. Likewise, the kind analysis should be simple and ef.cient to implement. Ideally the IDE should \ncompute the kinds as the user edits, and perhaps colour code the identi.ers to distinguish vari\u00adables \nfrom functions. Related to this .rst point, we think the kind analysis for functions and scripts should \nbe as similar to each other as possible. We found it very confusing that the kind analysis for functions \nand scripts for MATLAB 7 produce quite dif\u00adferent .nal results. Secondly, we think that the kind analysis \nshould be ex\u00adplicitly .ow-sensitive or explicitly .ow-insensitive. The MATLAB 7 kind analysis gives the \nillusion of being .ow\u00adsensitive, since it is computed by a depth-.rst traversal of the AST. However, \nit is not completely .ow-sensitive as it does not handle control-.ow merge points. For example, consider \nthe program snippets in Figure 5. We can see from this example that the MATLAB 7 kind analysis is traversal\u00adsensitive. \nIn the case of conditionals, it .rst analyzes the then branch and then analyzes the else branch. For \nex\u00adample, in Figure 5(a), on the then branch sum gets the kind FN, and then there is a kind mismatch \nwhen the else branch is evaluated, because now sum is being assigned-to and is therefore a VAR. However, \nthe semantically equiva\u00adlent snippet in Figure 5(b) gives a different answer. In this case the then branch \ndetermines that sum is a VAR,and then the else branch also determines it is a VAR. We think that whatever \nanalysis you use should give the same result for both the (a) and (b) variations. The analysis should \neither give an error for both variations (as with our .ow-sensitive analysis), or it should assign VAR \nfor both cases (as with our .ow-insensitive analysis). 1 2 3 if (exp) ... = sum(10); else %sum:FN 1 2 \n3 if (! exp) sum(10) = ...; else %sum:VAR 4 5 sum(10) = ...; endif % *error* 4 5 ... = sum(10); endif \n%sum:VAR (a) (b) Figure 5. Anomaly due to traversal-sensitive analysis Thirdly, we don t think that \nthe kind analysis should silently make assumptions about the binding of end for the cases where there \nis some uncertainty, but where there is a common case where an assumption is usually correct. We agree \nthat it is practical to handle to common cases without resorting to errors, but we believe that warnings \nshould be issued in cases where such assumptions are being made. For example, in the case for size(a(end)) \n, where size is FN and a is either MAYVAR or ID, it makes sense to bind end to a and to therefore assume \na is VAR, since this is the common case. However, in such situations, the user should be warned that \nthis assumption is being made. Finally, we are mindful that there are a lot of existing MATLAB programs \nand MATLAB programmers. In our al\u00adternate approaches we wish to keep the same spirit of the MATLAB 7 \nkind analysis. We aim provide alternative analy\u00adses which are cleaner and easier to understand than the \nMAT-LAB 7 approach, while at the same time produce the same results for almost all real MATLAB programs. \nIn Section 5.1 we outline a .ow-sensitive approach, in Section 5.2 we outline .ow-insensitive approach, \nand in Section 5.3 we provide a summary of how the MATLAB 7 approach and our two approaches compare. \n 5.1 Flow-Sensitive Kind Analysis We have implemented both the MATLAB 7 and our alterna\u00adtive analyses \nusing our structure-based .ow analysis frame\u00adwork in MCLAB. These analyses are structured as traversals \nover the AST. Listing 1 gives the top-level structure of our implementation of the MATLAB 7 analysis. \nThe procedure AnalyzeFile is applied to a .le, which in turn applies the appropriate analyses for scripts \nor functions. Note that since the MATLAB 7 kind analysis for scripts has special requirements (for example, \nthe analysis needs to store results for each identi.er occurrence), there is a global variable to indicate \nwhether a script of function is being analyzed. Both AnaylzeScript and AnalyzeFunction have three phases, \n.rst the kind abstractions are initialized, then the body of the script/function is analyzed, and lastly \nthe .nal mapping of the identi.ers is made. AnalyzeFunction also handles the case of nested functions. \nListing 2 gives the top-level rules for our .ow-sensitive semantics. The overall structure of the analysis \nis very simi\u00adlar to the MATLAB 7 version. However, there are two notable differences in these top-level \nrules. First, we have decided that there is no need for the analy\u00adsis of scripts to keep their kind results \nat each program point and thus there is no need for a global variable to differentiate between analyzing \nscripts and functions. Second, we see no reason why the .nal mapping of kinds for scripts needs to be \ndifferent than for functions, as it is in the MATLAB 7 semantics. Thus, in our .ow-sensitive version \nwe use the same .nal mapping of kinds for functions and scripts (i.e. we use the .nal result after analyzing \nthe body, except that MAYVAR must be mapped to ID because the general lookup should be used for these \nidenti.ers). We can see the impact of these changes in the analysis of scripts by revisiting the myscript \nexample. Figure 6(a) shows the kind analysis. The MATLAB 7 semantics uses the kind analysis results associated \nwith each statement, and maps that information to either ID of FN. If the kind was FN at that program \npoint, then the result is FN.However, if 1 AnalyzeFile ( .leAst ) 2 switch on type of .leAst 3 case \nScript 4 global inScript = true 5 AnalyzeScript ( .leAst ) 6 7 case Function 8 global inScript = false \n9 for each f in .leAst . functionList 10 AnalyzeFunction( f , {} ) 11 12 function AnalyzeScript ( script \n) 13 # initialize all names to MAYVAR 14 names = all name uses in script 15 initial = {(n:MAYVAR)| n \n. names } 16 # analyze body 17 out = Analyze( script .body, initial ) 18 # map each name corresponding \nto VAR ,MAYVAR to ID 19 for each node in script 20 for each name in node.kind 21 if out[name].{VAR,MAYVAR} \n22 set out[name] = ID 23 return out 24 25 function AnalyzeFunction( fun, outer ) 26 # initialize all \nparams to VAR 27 in = copy(outer) 28 remove all (n:FUN) from in 29 p1= {(n:VAR)| n . node.inArgs } 30 \np2= {(n:VAR)| n . node.outArgs } 31 initial = (p1 N p2) N in 32 # analyze the function body 33 out = \nAnalyze( node.body, initial 34 # analyze nested functions 35 for each n in node.nested 36 outN = AnalyzeFunction( \nnested , 37 for each (name:kind) in outN ) out ) 38 if outN[name]==VAR and out[N] in {ID,MAYVAR}39 set \nout[name] = VAR 40 #map MAYVAR to ID in output 41 for each name in out 42 if out[name] == MAYVAR 43 set \nout[name] = ID 44 return out Listing 1. Top-level Analysis Rules -MATLAB 7 the kind was anything else \nat that program point (including VAR), then it is mapped to ID. As you can see in Figure 6(b), this results \nis almost all identi.ers being mapped to ID. In contrast, our proposed analysis takes the kind results \nas collected by analyzing the whole script body, and maps it to create one .nal kind mapping that is \nused for all program points. These values are shown on the last row of the table in Figure 6(a). There \nappears to be no good reason to throw away the information that an identi.er is a VAR,sowe retain that \ninformation, and we only map MAYVAR to ID (the same rule as used for functions). It is clear that the \nkind information, as shown in Figure 6(c), is much more useful. Many more identi.er uses can be determined \nto be VAR. Furthermore, the kind assignment is consistent across the whole script body. In particular, \ndisplay has a kindof FN at both lines 16 and 18, whereas it had different kinds using the the MATLAB \n7 approach.  init MMMMMMMMMMMM 8 MMMVMMMMMMMM 9 MMMVMVMMMMMM 10 MMMVMVMMMMMM 11 MMMVMVMFMVMM 12 VMMVMVMFMVMM \n14 VMMVMVMFMVMM 16 VMMVMVMFMVMM 17 VMMVMVMFMVFM 18 VMMVMVMFMV F V .nal VI IVIVI F IVFV (a) kind analysis \n 1 % Assumes prev defn of size and i 1 % Assumes prev defn of size and i 2 % Returns sin or cos of magic \n2 % Returns sin or cos of magic 3 % square with dim. size ( i ) 3 % square with dim. size ( i ) 4 % If \nsize ( i ) is odd, 4 % If size ( i ) is odd, 5 % return sin of magic square 5 % return sin of magic square \n6 %else 6 %else 7 % return cos of magic square 7 % return cos of magic square 8 s= size (i ); %s:ID,size \n:ID,i:ID 8 s= size (i ); %s:VAR,size:ID,i:ID 9 a= magic(s); %a:ID,magic:ID,s:ID 9 a= magic(s); %a:VAR,magic:ID,s:VAR \n10 if (mod(s,2)==1) % mod:ID,s:ID 10 if (mod(s,2)==1) % mod:ID,s:VAR 11 fp = @sin; %fp:ID,sin:FN 11 fp \n= @sin; %fp:VAR,sin:FN 12 r = fp(a ); %r:ID,fp:ID,a:ID 12 r = fp(a ); %r:VAR,fp:VAR,a:VAR 13 else 13 \nelse 14 r= cos(a ); %r:ID,cos:ID,a:ID 14 r= cos(a ); %r:VAR,cos:ID,a:VAR 15 end 15 end 16 display ( r \n); %display : ID,r:ID 16 display ( r ); %display :FN,r:VAR 17 fp2 = @display; % fp2:ID,display :FN 17 \nfp2 = @display; %fp2:VAR,display:FN 18 display ( r ); %display : FN,r:ID 18 display ( r ); %display :FN,r:VAR \n19 % end of script 19 % end of script (b) .nal mapping: MATLAB 7 (c) .nal mapping: .ow-sensitive Figure \n6. Kind analysis for script, MATLAB 7 approach vs. .ow-sensitive 1 AnalyzeFile ( .leAst ) 2 switch on \ntype of .leAst 3 case Script 4 AnalyzeScript ( .leAst ) 5 6 case Functions 7 for each f in .leAst . \nfunctionList 8 AnalyzeFunction( f, {} ) 9 10 function AnalyzeScript ( script ) 11 # initialize all names \nto MAYVAR 12 names = all name uses in script 13 initial = {(n:MAYVAR)| n . names }14 # analyze body 15 \nout = Analyze( script .body, initial ) 16 #map MAYVAR to ID in output 17 for each name in out 18 if out[name]== \nMAYVAR 19 set out[name] = ID 20 return out 21 22 function AnalyzeFunction( fun, 23 # ... same as before \n... outer ) Listing 2. Top-level Analysis Rules -Flow-sensitive Listing 3 gives the core analysis rules \nfor the MATLAB 7 approach, and Listing 4 gives the rules for our .ow-sensitive approach. 15 We have already \nexplained the basic MATLAB 7 rules in some detail in Section 4. The interesting differences here are \nthe way in the control-.ow constructs are handled. For example, consider the IfStmt case. The MATLAB \n7 analysis visits the condition, the then part and the else part, propagating kind information as it \ngoes. In contrast, the .ow-sensitive approach takes control-.ow into account. It analyzes the condition \nand uses that output as the input to both the then and else parts, and then merges the outputs. 15 Note \nthat statements assigning to .ow sets do not denote copies of the .ow set, one .ow set is propagated, \nand copies are created only by using an explicitly call to the copy function. Similarly, the .ow-sensitive \nanalysis of the loops imple\u00adments a proper .xed-point computation.16 We have made one other small improvement \nin the .ow\u00adsensitive analysis. We feel that when a programmer explic\u00aditly loads a variable using the \nload function with the name of a variable as a string constant (i.e. load( mydata , x ) ), we should \ntreat this the same as a direct assignment to the variable, and assign it a kind of VAR. Even though \nthe load may not create the variable, the programmer s ob\u00advious intent is that the identi.er should be \na variable. This is also consistent with the fact that a variable only needs to be de.ned on one control-.ow \npath to be assigned the kind VAR. 5.2 Flow-Insensitive Kind Analysis The .ow-sensitive kind analysis \nprovides a simpler de.\u00adnition of the kind semantics than the MATLAB 7 version. However, to understand \nthe analysis a programmer must rea\u00adson about control-.ow and merge points in their programs. One question \nthat arises is: is the added complexity of .ow\u00adsensitivity necessary? An alternative way of looking at \nthe kind analysis is in a .ow-insensitive way. Simply look at ev\u00adery occurrence of an identi.er and determine \nits kind based on how it was used, or give an error if it was used in an inconsistent way. This de.nition \nis simple to understand, it should be simple to implement and it should be ef.cient to execute. To formalize \nthis de.nition we need to de.ne how differ\u00adent uses of an identi.er are used to determine its kind. This \nde.nition is exactly the same as how different uses deter\u00admine kind in the .ow-sensitivity analysis. \nIf an identi.er is assigned to, it should be a VAR; if a handle is taken of it, it 16 For this particular \nanalysis the .xed-point computation only needs one iteration, but we have expressed it using our standard \nloop analysis frame\u00adwork. 1 Analyze( node, in ) 2 switch on type of node 3 case WhileStmt 4 out1 = Analyze( \nnode.cond, in ) out2 = Analyze( node.body, out1 ) 6 out = out2 7 8 case IfStmt 9 out1 = Analyze( node.cond, \nin ) out2 = Analyze( node.then body, out1 ) 11 out3 = Analyze( node.else body, out2 ) 12 out = out3 \n13 14 case List out =in 16 for n in node. list 17 out = Analyze( n, out ) 18 19 case AssignmentStmt out \n= Analyze( node.RHS, in ) 21 for each lvalue in node.LHS 22 out = Analyze( lvalue . subExpressions , \nout ) 23 out =out N {(lvalue:VAR)} 24 case ParameterizedExpr 26 if ( !containsEnds( node ) ) 27 out1 \n= Analyze( node.arguments, in ) 28 out2 = Analyze( node. target , out1 ) 29 out = out2 else 31 (out, \nhasEnd)=AnalyzeExprWithEnds(node,in, null ) 32 33 case CellIndexExpr 34 if ( !containsEnds( node ) ) \nout1 = in N {(node.target:VAR)}36 out = Analyze( node.arguments, out1 ) 37 else 38 (out ,boundToID) = \nAnalyzeExprWithEnds( arg, in, node ) 39 case NameExpr 41 if in [node.name] .{UNDEF, ID}42 if exists function \n(node.name, library ) 43 out=in N {(node.name:FN)}44 else if exists package (node.name, library ) out \n=in N {(node.name:PREFIX)} 46 else 47 out =in N {(node.name:ID)} 48 49 case HandleExpr out =in N {(node.name:FN)}51 \ncase CommandStmt 52 out=in N {(node.cmdName:FN)} 53 54 case GlobalStmt or PersistentStmt out =in 56 for \neach name in node.names 57 out =out N {(name:VAR)} 58 59 case Load for i = 2:size(load.arg) 61 if load.arg[i] \nis a string 62 if load.arg[i] does not start with ' -' 63 out=in N {(load.arg[i]:MAYVAR)} 64 if ( inScript \n) node.kind = copy(out) else node.kind = out 66 return out Listing 3. Main Analysis Rules: MATLAB 7 \n1 Analyze( node, in ) 2 switch on type of node 3 case WhileStmt 4 out = Analyze( node.cond, in ) 5 previousIn \n= in 6 do 7 previousOut = out 8 outBody = Analyze( node.body, previousOut ) 9 newIn = out N previousIn \n10 out = Analyze( node.cond, newIn ) 11 while( out != previousOut ) 12 13 case IfStmt 14 condOut = Analyze( \nnode.cond, in ) 15 thenIn = copy(condOut) 16 elseIn = copy(condOut) 17 thenOut = Analyze( node.then body, \nthenIn ) 18 elseOut = Analyze( node.else body, elseIn ) 19 out = thenOut N elseOut 20 21 # ... other \ncases are the same ... 22 23 case Load 24 for i = 2:size(load.arg) 25 if load.arg[i] is a string 26 if \nload.arg[i] does not start with ' -' 27 out=in N {(load.arg[i]:VAR)} 28 29 node.kind = out 30 return \nout Listing 4. Main Analysis Rules -modi.ed .ow-sensitive should be a FN; if it s explicitly loaded, \nit should be a VAR; if it is in the library, it should be a FN;if it scellindexed or has an end bound \nto it, it should be a VAR. The difference is in the ordering of when these cases are applied. Even though \nthis analysis will be .ow-insensitive, some care is needed when ordering how identi.ers get assigned \na kind. To demonstrate this, we present the following simple program: 1 i=3; 2 x=i; A programmer would \nexpect this program to execute without issue. It s reasonable to expect this even though i is a function \nde.ned in the MATLAB library. However, if the .ow-insensitive analysis were to look at the occurrence \nof i on line 2 before the one on line 1, this would be an error. It s an error because .rst we determined \nthat i has kind FN, then we saw an occurrence of it being assigned to. This causesustotry to make i s \nkind VAR,but as was seen in Section 4, this would cause a kind con.ict error. Alternatively, if the analysis \nsaw line 1 before line 2, it would cause no error. The behavior of the kind analysis should be deterministic, \nso an ordering needs to be de.ned. This ordering should not cause reasonable programs, such as our example, \nto be rejected. Finally, the ordering should be de.ned in a simple and clear way. Rather than de.ne an \nordering to how nodes are visited, the .ow-insensitive analysis de.nes .ve phases. Each phase conceptually \nrepresents a traversal of all nodes in the AST, and each phase performs one case for determining the \nkind of identi.ers. These phases performed in the following order. 1. Assign VAR to all identi.ers on \nthe left-hand side of as\u00adsignments; identi.ers mentioned in a load , global , persistent ; or identi.ers \nindexed with cell indexing. 2. Assign FN to all identi.ers that have a handle taken of them or used \nfor command syntax. 3. Assign FN to all identi.ers that are not VAR and are in the library as a function \nor PREFIX if it is in the library as a package. 4. Check that all end expressions can be bound without \nambiguity and issue an error for ambiguous cases. 5. For each unambiguous end expression select the \ncor\u00adrect identi.er to bind to the end . If the selected identi\u00ad.er has kind ID, change it to kind VAR \nand issue a warn\u00ading. If there is no selected identi.er, issue an error.  The .rst three phases can \nbe thought of in the following way. First all obvious variables are found, then all obvious functions, \nthen the less obvious functions. Each of these phases is run completely, and if any phase tries to assign \na kind to an identi.ers that already has a con.icting kind, then a kind con.ict error occurs. The fourth \nand .fth phases handle the case for binding end expressions. The fourth phase processes all expres\u00adsions \ncontaining end to ensure that there is no ambiguity in choosing the binding identi.er. The .fth phase \nthen revisits the unambiguous expressions containing end , determines which identi.er binds the end . \nIf the binding identi.er has kind ID, it assigns it the kind VAR and issues a warning. If there is no \nbinding identi.er, then it issues an error. The fourth and .fth stages must be conceptually separate \npasses because we do not want traversal order to matter. If we were to change the kind of some identi.er \nx from ID to VAR during the fourth pass, this could affect a subsequent ambiguity check involving x. \nThis would mean that different traversal orders could give different results. To prevent this, all of \nthe ambiguity checks are completed in the fourth pass and then all unambiguous bindings and changes of \nkinds from ID to VAR are made in the .fth pass. Pseudo-code that demonstrates this ordering is given \nin Listing 5. This pseudo-code gives the top-level rule for an\u00adalyzing functions and scripts. Listing \n6 presents the main analysis rules for the .ow-insensitive analysis. It s impor\u00adtant to note that there \nare no rules for nodes like if and while . Traversal over these nodes is captured in the top\u00adlevel rules. \nIt s important to note that this ordering has a preference for assigning VAR. This causes some differences \nover the .ow-sensitive analysis when it comes to error reporting. For example, the following code: 1 \nx=i; 2 i=3; 1 function AnalyzeFunction( fun, outer ) 2 in = copy(outer) 3 remove all (n:FUN) from in \n4 out1 = {(n:VAR)| n . node.inArgs } 5 out2 = {(n:VAR)| n . node.outArgs } 6 out = (out1 N out2) N in \n7 AnalyzeBody(fun.body) 8 9 for each n in node.nested 10 outN = AnalyzeFunction( nested , out ) 11 for \neach (name:kind) in outN 12 if outN[name]==VAR and out[N] in {ID,MAYVAR}13 set out[name] = VAR 14 15 \nfunction AnalyzeScript ( script ) 16 # initialize all names to MAYVAR 17 names = all name uses in script \n18 initial = {(n:MAYVAR)| n . names }19 AnayzeBody(script.body) 20 21 function AnalyzeBody( body ) 22 \nout1 = out 23 for each AssignmentStmt,Load,Global, Persistent , CellIndex node in body 24 out1 = Analyze( \nnode, out1 ) 25 26 out2 = out1 27 for each HandleExpr handle in body 28 out2 = Analyze( handle , out2 \n) 29 30 out3 = out2 31 for each NameExpr name in body 32 out3 = Analyze( name, out3 ) 33 34 out4 = out3 \n35 for each ParameterizedExpr exp in body 36 if hasEnd(exp) 37 out4 = AmbiguityCheck( name, out4 ) 38 \n39 out5 = out4 40 for each ParameterizedExpr exp in body 41 if hasEnd(exp) 42 out5 = Analyze( name, out5 \n) 43 44 out = out5 Listing 5. Ordering of Flow-Insensitive Analysis In the .ow-sensitive analysis, \nthis code would have been .agged as causing an error. This is because line 1 is visited before line 2 \nand on line 1 the occurrence of i is treated as a function call. When it reaches line 2, the .ow-sensitive \nanalysis tries to make i a VAR, which causes the error. In the .ow-insensitive version, this code would \nnot be .agged. It simply treats i as a variable. Presumably, at runtime, if this variable had no value, \nit would cause a variable-not\u00adde.ned error. This means the .ow-insensitive analysis pro\u00advides fewer static \nguarantees. However, if an error occurred at runtime, the kind information could be used to give a more \nprecise error since it knew that it was expecting a variable to be de.ned. Even though the analysis is \ndescribed as .ve passes through the code, our implementation optimizes this by in\u00adtroducing some new \nabstract values and implements one pass through the code that handles the .rst three phases, 1 function \nAnalyze( node, in ) 2 switch on type of node 3 case AssignmentStmt 4 for each lvalue in node.LHS 5 out \n= out N {(lvalue:VAR)} 6 7 case NameExpr 8 if in [node.name] .{UNDEF, ID} and node.name . library 9 out \n= in N {(node.name:FN)} 10 else 11 out =in N {(node.name:ID)} 12 13 case HandleExpr 14 out=in N {(node.name:FN)} \n15 16 case Load 17 for i = 2:size(load.arg) 18 if load.arg[i] is a string 19 if load.arg[i] does not \nstart with ' -' 20 out=in N {(load.arg[i]:VAR)} 21 22 # ... ParameterizedExpr, GlobalStmt, PersistentStmt \n, CellIndex same 23 24 node.kind = out Listing 6. Main Analysis Rules -modi.ed .ow-insensitive and a \nsecond pass through only the expressions that contain end expression. We believe that the .ow-insensitive \nanalysis is more suit\u00adable for use in an IDE because the analysis does not depend on the order of visiting \nthe nodes, and it is quite easy to up\u00addate the results if the user adds a new statement.   5.3 Summary \nof Analysis Differences We have presented three algorithms for kind analysis and discussed their differences. \nTable 1 gives an overall sum\u00admary of the key differences. The leftmost column gives a name to each situation, \nwhere D stands for a de.nition, U stands for a use, and H stands for a function handle. There are also \ntwo specializations of uses, Ul stands for an iden\u00adti.er which corresponds to a function in the library \nand Un stands for an identi.er that does not correspond to a function in the library. For each situation \nwe give a small snippet of code which corresponds to the situation, and the analysis results for that \npiece of code for each of the three analyses. For the MATLAB 7 and .ow-sensitive analyses we give the \nanalysis results that would be computed during the propagation phase of the analysis, and then the .nal \nkind assignment. For the .ow\u00adinsensitive analysis we give only the .nal result. The .rst block of .ve \nsituations represents cases when there is only one statement involving identi.er i . All three analyses \ncompute exactly the same result for the .rst four situations. However, the .fth situation, Eu, does show \na difference. This is the case where the variable i is binding and end , and i has kind UNDEF or ID.The \nMATLAB 7 approach silently determines that i is a VAR, whereas our two approaches warn that this kind \nassignment is being made. The second block of .ve situations represents cases where there are two statements \ninvolving identi.er i where there is sequential control .ow between the two state\u00ad ments. Again the .rst \nfour situations give identical results for all three analyses, but the .fth one, UlD, gives a different \nresult for the .ow-insensitive analysis (as discussed in the previous subsection). The .nal block of \nsix situations corresponds to cases where there are two statements involving identi.er i , but there \nis no control .ow between them. These exhibit more differences between the analyses. The two cases D||Ul \nand Ul||D are particularly interesting. In both of these cases i should be a FN on one branch and a VAR \non the other branch, and thus there should be a kind con.ict. The strange traversal strategy of the MATLAB \n7 approach .nds the error in second case, but not in the .rst, whereas the .ow-sensitive approach correctly \n.nds errors in both cases. The .ow-insensitive .. approach ignores any control .ow and does not signal \nan error in either case, but gives a kind of VAR because there exists an assignment to i .  6. Empirical \nStudy In order to experiment with our analyses we gathered a large number of MATLAB projects.17 The benchmarks \ncome from a wide variety of application areas including Computational Physics, Statistics, Computational \nBiology, Geometry, Lin\u00adear Algebra, Signal Processing and Image Processing. We analyzed 3057 projects \ncomposed of 11692 functions and 2307 scripts. The projects vary in size between 283 .les in one project \nto a single .le. A summary of the size distribu\u00adtion of the benchmarks is given in Table 2 which shows \nthat the benchmarks tend to be small to medium in size. How\u00adever, we have also found 9 large and 2 very \nlarge bench\u00admarks. The benchmarks presented here are the most down\u00adloaded projects among the mentioned \ncategories which may mean that the average code quality is higher than many less used projects.18 Benchmark \nCategory # Benchmarks Single (1 .le) 2067 Small (2-9 .les) 859 Medium (10-49 .les) 120 Large (50-99 .les) \n9 Very Large (= 100 .les) 2 Total 3057 Table 2. Distribution of size of the benchmarks 17 Benchmarks \nwere obtained from individual contributors plus projects from http://www.mathworks.com/matlabcentral/fileexchange, \nhttp://people.sc.fsu.edu/ jburkardt/m\\_src/m\\_src.html, http://www.csse.uwa.edu.au/ pk/Research/MatlabFns/ \nand http://www.mathtools.net/MATLAB/. 18 We continue to add to the benchmark set, further contributions \nare most welcome.  Flow-Name Code MATLAB 7 Flow-Sensitive Insensitive   DU i = // S1 ... =i// S2 \nS1 S2 Prop VAR VAR Final VAR VAR S1 S2 Prop VAR VAR Final VAR VAR S* Final VAR DH i = // S1 ... =@i// \nS2 S1 S2 Prop VAR error Final error error S1 S2 Prop VAR error Final error error S* Final error HD =@i// \nS1 ... i = // S2 S1 S2 Prop FN error Final error error S1 S2 Prop FN error Final error error S* Final \nerror UnD =i// S1 ... i = // S2 S1 S2 Prop ID VAR Final VAR VAR S1 S2 Prop ID VAR Final VAR VAR S* Final \nVAR UlD =i// S1 ... i = // S2 S1 S2 Prop FN error Final error error S1 S2 Prop FN error Final error error \nS* Final VAR D||Un if (e) i = // S1 else = i // S2 end // S3 S1 S2 Prop VAR VAR Final VAR VAR S1 S2 \nS3 Prop VAR ID VAR Final VAR VAR VAR S* Final VAR Un||D if (e) = i // S1 else i = // S2 end // S3 S1 \nS2 Prop ID VAR Final VAR VAR S1 S2 S3 Prop ID VAR VAR Final VAR VAR VAR S* Final VAR D||Ul if (e) i = \n// S1 else = i // S2 end // S3 S1 S2 Prop VAR VAR Final VAR VAR S1 S2 S3 Prop VAR FN error Final error \nerror error S* Final VAR Ul||D if (e) = i // S1 else i = // S2 end // S3 S1 S2 Prop FN error Final error \nerror S1 S2 S3 Prop FN VAR error Final error error error S* Final VAR D||H if (e) i = // S1 else =@i \n//S2 end // S3 S1 S2 Prop VAR error Final error error S1 S2 S3 Prop VAR FN error Final error error error \nS* Final error H||D if (e) =@i //S1 else i = // S2 end // S3 S1 S2 Prop FN error Final error error S1 \nS2 S3 Prop FN VAR error Final error error error S* Final error Table 1. Comparative Summary of the three \nkind analyses We ran the three kind analyses on all .les in the bench\u00admarks, and we categorized all \nidenti.ers based on their kind assignment. The cumulative results for both functions in Ta\u00adble 3 and \nscripts in Table 4. 6.1 Kind results for functions Table 3 gives the results for the functions. For \nfunctions we counted the number of identi.ers (not identi.er occur\u00adrences). For example, for myfunc in \nFigure 3(a) there are 12 identi.ers and we would have counted 7 VAR and 5 FN, meaning that we found 7 \nvariables and 5 named functions. Overall, we found that about 58% of the identi.ers were variables and \nabout 40% were named functions. Only 1.2% of the identi.ers remained uncategorized (ID) after the kind \nanalysis. The three different kind analyses had only small differences in their outputs, which is what \nwe intended. We examined all benchmarks where the results differed in order to determine the cause of \nthe difference. Kind # Id. (Matlab) # Id. (FS) # Id. (FI) VAR 107327 107340 107345 FN 75486 75486 75486 \nID 2357 2333 2333 PREFIX 12 12 12 error 1 3 0 warn 0 9 7 Total 185183 185183 185183 Table 3. Cumulative \nResults for Kind Analysis of 11698 functions Let us .rst summarize the differences in the number of errors \nfound. The .ow-insensitive (FI) approach did not .nd any kind errors in any of the benchmarks. The .ow\u00adinsensitive \napproach can only .nd kind clashes for very ex\u00adplicit situations such as DH, HD, D||H,and H||D. The fact \nthat no such kind error occurs in any of the benchmarks may mean that programmers .nd those rules easy \nto follow and are unlikely to make this sort of error. The MATLAB 7 approach found only one more kind \nerror than the .ow\u00adinsensitive approach, and this corresponded to a Ul||D case. As we expected, the .ow-sensitive \n(FS) approach caught more programming errors. The two extra errors that were only found using the .ow-sensitive \napproach were of type D||Ul. Both our .ow-sensitive and .ow-insensitive approaches issue warnings when \nan end expression causes an identi\u00ad.erto begiven thetype VAR (the Eu situation). The .ow\u00adinsensitive \nversion .nds fewer such warnings. The two warn\u00adings which are caught by the .ow-sensitive approach, but \nnot by the .ow-insensitive approach, are in situations where there is an assignment to the identi.er \nlater in the program. In the .ow-insensitive case all assignments are analyzed .rst, so when the end \nexpression is analyzed the kind[x] is already VAR, and no warning is issued. The number of identi.ers \nfound to be FN was exactly the same for all three approaches. All of the remaining differ\u00adencescomefromassigning \nVARinsteadof MAYVAR(which is mapped to ID when analysis ends) to load arguments. Perhaps the most interesting \naspect of the results is the small differences between the results using the original MATLAB 7 semantics \nand our proposed approaches. Our goal was to design cleaner approaches, to make the results of kind analysis \neasier to understand, but to avoid breaking the working codes as much as possible. Based on our results \nwe feel that we achieved that, and we can recommend the improved approaches to be used in future versions \nof the MATLAB language. 6.2 Kind results for scripts Table 4 gives the results for the scripts. Recall \nthat in MAT-LAB 7 approach, a variable inside a script can only have .nal kinds of ID,FN or error, and \nthat one identi.er can actually have different kinds at different program points. However, in our two \nalternative approaches we update the kind of all occurrences of an identi.er based on the .nal kind analysis \nresults, and we retain the VAR kind. Because the MATLAB 7 results are program-point spe\u00adci.c, for scripts \nwe counted the kinds for each identi.er oc\u00adcurrence. For example, for the script in Figure 6, we would \ncount the kind for the 22 identi.er occurrences as summa\u00adrized in the comments. We have also reported, \nfor the MAT-LAB 7 case, the kinds both before and after the .nal mapping (post-process) of kinds. Kind \n#Id. Matlab raw #Id. Matlab post-process #Id. FS #Id. FI VAR FN ID error warn 153563 1 69027 0 0 0 1 \n222590 0 0 154065 3 68413 0 110 154075 3 68413 0 100 Total 222591 222591 222591 222591  Table 4. Cumulative \nResults for Kind Analysis of 2305 scripts The results for scripts are very different than for func\u00adtions, \nwith almost all of the identi.ers being given the kind ID in the MATLAB 7 approach (even though before \nthe post\u00adprocess step many identi.ers had been determined to be VAR). Since almost all identi.ers will \nhave kind ID,which have an expensive general lookup, the runtime overheads for resolving names in scripts \nwill be higher than for functions. This lack of accurate static information about the identi.ers in scripts \nalso implies that any subsequent static analysis of the script will have limited precision. In both our \n.ow\u00adsensitive and .ow-insensitive approaches, we .nd a signif\u00adicant number of VAR identi.ers, which improves \nthe situa\u00adtion. Furthermore, keeping the VAR kind makes the behavior for scripts more similar to functions \nand as a result makes the language easier to understand. This will also help in subse\u00adquent static analysis \nand compilation of the code. It is also interesting to note that the .ow-sensitive and .ow-insensitive \nanalysis compute the same kinds for almost all identi.er occurrences in the scripts. Again like in func\u00adtions, \nthe .ow-insensitive approach found fewer warnings. Both of them manage to .nd slightly more VAR instances \nthan the MATLAB 7 approach (before post-processing) be\u00adcause of our treatment of explicit loads to named \nvariables (remember that we use VAR instead of MAYVAR). The two cases of FN is from a code that references \nan identi.er twice and then takes a function handle of the identi.er. In scripts MATLAB keeps copy of \nthe kind at each program\u00adpoint so the previous occurrences of the identi.er don t see the change of kind \nto FN. Even with our improved analysis for scripts it is in\u00adevitable that many identi.ers will not be \nable to be assigned a kind more precise than ID. The overall numbers show a similar trend to what we \nobserved in the myscript exam\u00adple from Figure 6. In that example, 5 of the 12 identi.ers are given a \n.nal kind of ID (size,i,magic, mod and cos). In all of these cases there are no explicit statements within \nthe body of the script which can determine if these have kind VAR or FN. Indeed, whether they are VAR \nor FN depends on the context from which they are called. If the identi.er is a variable in the caller \ns workspace, then the identi.er will refer to a variable, and if it is not in the caller s workspace, \nthe identi.er will refer to a named function. Thus, there re\u00admain overheads for using scripts, both in \nthe extra lookups required and in the possible imprecision of subsequent anal\u00adyses.  7. Related Work \nThis paper tackles a very basic problem, giving a meaning to identi.ers in a program. With many languages \nthese are trivial issues that are dealt with by standard front-end parsing and symbol table modules. \nEven reasonably complicated sit\u00aduations, such as properly disambiguating package names in Java, usually \nhave quite clear speci.cations and static types to work with. However, as we discovered when building \nour MATLAB infrastructure, the kind analysis problem for MAT-LAB was not obvious and we could .nd no \ndocumentation or prior work on this problem. There are other open MATLAB-like systems such as Octave[8] \nand Scilab[3]. Octave uses a syntax mostly com\u00adpatible with MATLAB, whereas Scilab de.nes a somewhat \ndifferent syntax. Both of these systems concentrate on pro\u00adviding an interpreter for a MATLAB-like language, \nrather than providing a static analysis framework. Thus, all of the complexities of deciding the meaning \nof an identi.er are deferred until runtime and these systems do not use a kind analysis. For example, \nin Octave, the example of i=i from the motivating example of Figure 1 executes without raising a compile-time \nerror. Octave uses the completely dy\u00adnamic semantics -at run-time the right-hand-side i refers to a function \nand the left-hand-side i refers to a variable. There have also been research systems which had impres\u00adsive \nstatic type inference analyses for subsets of MATLAB, including the FALCON[9], MAGICA[4] and MaJIC[1] \nsys\u00adtems. More recently the McFor[5] and McVM[2] systems have implemented variations on type and shape \nanalysis in the context of ahead-of-time and JIT compilers for subsets of MATLAB. This paper is really \naddressing a simpler, but fundamental, problem for a modern version of MATLAB.To match the semantics \nof MATLAB 7, the kind analysis must be .rst be run to assign kinds to identi.ers and to create an appropriately \nspecialized IR on which the more complex shape analyses can be applied. Our hope is that a wide va\u00adriety \nof static analyses, including similar sophisticated type inference algorithms, can be implemented more \neasily and for a larger language subset starting with our infrastructure. 8. Conclusions This paper \nhas presented the problem of de.ning and imple\u00admenting kind analyses for MATLAB. When we started our \nproject for developing an open and extensible compiler and analysis framework for MATLAB we did not imagine \nthat this was a potential paper topic -we expected it to be trivial to build a good intermediate representation \nand that a decent front-end could resolve all the identi.ers. However, the more we learned about MATLAB, \nthe more we realized that this is actually a foundational problem and that a good solution to this problem \nwas imperative as a starting point for all other static analyses. Our .rst objective was to specify the \nkind analysis as it is implemented in MATLAB 7. As there is no written language standard for MATLAB, \nwe accomplished this by developing a large set of tests that were designed to expose the subtleties of \nthe kind analysis. Based on these tests we developed a kind analysis which appears to match the intended \nMATLAB 7 semantics. In this process we discovered several bugs or inconsistencies in the MATLAB 7 implementation, \nwhich we reported to MathWorks. While developing the MATLAB 7 kind analysis algo\u00adrithm, we found aspects \nof the approach that we thought could be improved. Thus, we also designed two new vari\u00adations of the \nkind analysis, one .ow-sensitive analysis, and another .ow-insensitive analysis. In both cases we incorpo\u00adrated \nimprovements to the analysis, especially in the treat\u00adment of scripts. Our objective was to keep the \ngeneral intention of the MATLAB 7 kind analysis, but to have cleaner speci.cations which would be easier \nfor programmers to understand and for tool implementers to implement. We implemented all three kind analyses \nin our MCLAB compiler framework, and evaluated the three analyses on a large number of MATLAB 7 programs \nwhich come from a wide variety of sources. We were quite pleased to see that our cleaner kind analyses \ndid not differ in many cases from the original MATLAB 7 approach. Although as compiler researchers we \ntend to prefer the .ow-sensitive analysis because it gives more precise results and is able to detect \na few more compile-time warnings and errors, we think that the .ow-insensitive approach has important \npractical merits. It is almost as good as the .ow\u00adsensitive analysis in .nding kind warnings and errors, \nit is probably simpler to explain to MATLAB programmers, and it is likely more suitable for implementing \nin an IDE. Thus, we would recommend that the .ow-insensitive de.nition of kind analysis be adopted for \nMATLAB, and that a standard be developed based on that de.nition. As compiler researchers more familiar \nwith imperative and object-oriented languages, which normally have an of\u00ad.cial language speci.cation, \nwe had to spend consider\u00adable time and effort understanding the implicit semantics of MATLAB, and formulating \nthose semantics more explic\u00aditly in a way that we could understand in the context of static analysis. \nThus, we hope that another key contribution of this paper is explaining the essence of MATLAB so that \nother compiler researchers can bene.t from our experience. The techniques presented in this paper now \nform the foundation of our analysis framework[7]. Based on kind analysis we are able to build a good \nintermediate repre\u00adsentation suitable for further analysis development, both in the .eld of optimizations \nand for other applications such as refactoring tools.  Acknowledgements This work was done with support \nfrom NSERC (Canada), McGill University (Canada), and The Leverhulme Trust (UK). Many thanks to the many \nMcGill students who have worked on building the MCLAB framework, and the OOP-SLA reviewers who had many \nuseful suggestions.  References [1] G. Alm\u00b4asi and D. Padua. MaJIC: compiling MATLAB for speed and responsiveness. \nIn PLDI 02: Proceedings of the ACM SIGPLAN 2002 Conference on Programming language design and implementation, \npages 294 303, New York, NY, USA, 2002. ACM. [2] M. Chevalier-Boisvert, L. Hendren, and C. Verbrugge. \nOpti\u00admizing MATLAB through Just-In-Time Specialization. In In\u00adternational Conference on Compiler Construction, \npages 46 65, March 2010. [3] INRIA. Scilab, 2009. http://www.scilab.org/ platform/. [4] P. G. Joisha \nand P. Banerjee. Correctly detecting intrinsic type errors in typeless languages such as MATLAB. In APL \n01: Proceedings of the 2001 conference on APL, pages 7 21, New York, NY, USA, 2001. ACM. [5] J. Li. McFOR: \nA MATLAB to FORTRAN 95 compiler. Mas\u00adter s thesis, McGill University, Montreal, Canada, 2009. [6] MathWorks. \nMATLAB Documentation, 2010. http:// www.mathworks.com/. [7] McLAB. McLAB. http://www.sable.mcgill.ca/ \nmclab/. [8] Octave. GNU Octave. http://www.gnu.org/ software/octave/index.html. [9] L. D. Rose and D. \nPadua. Techniques for the translation of MATLAB programs into Fortran 90. ACM Trans. Program. Lang. Syst., \n21(2):286 323, 1999.  \n\t\t\t", "proc_id": "2048066", "abstract": "<p>MATLAB is a popular dynamic programming language used for scientific and numerical programming. As a language, it has evolved from a small scripting language intended as an interactive interface to numerical libraries, to a very popular language supporting many language features and libraries. The overloaded syntax and dynamic nature of the language, plus the somewhat organic addition of language features over the years, makes static analysis of modern MATLAB quite challenging. A fundamental problem in MATLAB is determining the kind of an identifier. Does an identifier refer to a variable, a named function or a prefix? Although this is a trivial problem for most programming languages, it was not clear how to do this properly in MATLAB. Furthermore, there was no simple explanation of kind analysis suitable for MATLAB programmers, nor a publicly-available implementation suitable for compiler researchers.</p> <p>This paper explains the required background of MATLAB, clarifies the kind assignment program, and proposes some general guidelines for developing good kind analyses. Based on these foundations we present our design and implementation of a variety of kind analyses, including an approach that matches the intended behaviour of modern MATLAB 7 and two potentially better alternatives.</p> <p>We have implemented all the variations of the kind analysis in McLab, our extensible compiler framework, and we present an empirical evaluation of the various analyses on a large set of benchmark programs.</p>", "authors": [{"name": "Jesse Doherty", "author_profile_id": "81458646251", "affiliation": "McGill University, Montreal, PQ, Canada", "person_id": "P2839138", "email_address": "jdoher1@cs.mcgill.ca", "orcid_id": ""}, {"name": "Laurie Hendren", "author_profile_id": "81100646110", "affiliation": "McGill University, Montreal, PQ, Canada", "person_id": "P2839139", "email_address": "hendren@cs.mcgill.ca", "orcid_id": ""}, {"name": "Soroush Radpour", "author_profile_id": "81466648292", "affiliation": "McGill University, Montreal, PQ, Canada", "person_id": "P2839140", "email_address": "sradpo@cs.mcgill.ca", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048077", "year": "2011", "article_id": "2048077", "conference": "OOPSLA", "title": "Kind analysis for MATLAB", "url": "http://dl.acm.org/citation.cfm?id=2048077"}