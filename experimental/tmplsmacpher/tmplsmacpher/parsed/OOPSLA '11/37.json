{"article_publication_date": "10-22-2011", "fulltext": "\n A Theory of Substructural Types and Control Jesse A. Tov Riccardo Pucella Northeastern University, Boston, \nMassachusetts, USA {tov,riccardo}@ccs.neu.edu Abstract Exceptions are invaluable for structured error \nhandling in high-level languages, but they are at odds with linear types. More generally, control effects \nmay delete or duplicate por\u00adtions of the stack, which, if we are not careful, can invalidate all substructural \nusage guarantees for values on the stack. We have developed a type-and-effect system that tracks con\u00adtrol \neffects and ensures that values on the stack are never wrongly duplicated or dropped. We present the \nsystem .rst with abstract control effects and prove its soundness. We then give examples of three instantiations \nwith particular control effects, including exceptions and delimited contin\u00aduations, and show that they \nmeet the soundness criteria for speci.c control effects. Categories and Subject Descriptors D.3.3 [Programming \nLanguages]: Language Constructs and Features General Terms Languages 1. Substructural Types and Control \nConsider, for example, a language like Scala (Odersky and Zenger 2005) with mutable references and arithmetic. \nHere is a method that takes two integers and divides each by the other, returning a pair of references \nto their quotients: def divRef (z 1: Int, z2: Int) = (new Ref(z 1 / z2), new Ref(z2 / z 1)) Suppose that \nreferences in this language are linear, mean\u00ading that they cannot be duplicated, and must be explicitly \ndeallocated rather than implicitly dropped. In such a lan\u00adguage, divRef has a memory leak. Most uses \nof divRef are harmless, but consider the expression divRef (0, 5). The method will raise a division-by-zero \nexception, but (assum\u00ading one reasonable evaluation order) only after it has allo\u00adcated a reference to \nhold the result of the .rst division. Be- Permission to make digital or hard copies of all or part of \nthis work for personal or classroom use is granted without fee provided that copies are not made or distributed \nfor pro.t or commercial advantage and that copies bear this notice and the full citation on the .rst \npage. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior \nspeci.c permission and/or a fee. OOPSLA 11, October 22 27, 2011, Portland, Oregon, USA. Copyright c &#38;#169; \n2011 ACM 978-1-4503-0940-0/11/10. . . $10.00 cause the method raises an exception but does not return \nthe successfully allocated reference, there is no way for recovery code that catches the exception to \nfree the reference. In short, exceptions and linear types refuse to get along, because linear types make \npromises that exceptions do not let them keep. With af.ne rather than linear types, however, divRef is \nnot a problem, because such a type system does not require that references be freed explicitly. In a \nlanguage with af.ne types, implicitly dropping a value is just .ne presumably there is a garbage collector \nand only duplication is forbid\u00adden. Consider, however, adding delimited continuation oper\u00adators such \nas shift and reset to a language with af.ne types. Assuming a method unref that dereferences and deallocates \na reference, we might attempt to de.ne a method squareRef that takes a reference to an integer, frees \nit, and returns its contents, squared: def twiceTo(x: Int) = shift { (k: Int . Int) . k(k(x)) } def squareRef \n(r: Ref[Int]) = reset { twiceTo(1) \u00d7 r.unref () } Method twiceTo uses shift to capture its continuation \nup to the nearest enclosing reset, and it then applies the captured continuation k twice to the parameter \nx. Method squareRef provides the context for twiceTo to capture, which is to free r and multiply by its \ncontents: [] \u00d7 r.unref () . Since twiceTo uses its continuation twice, the second use of the continuation \nwill access a dangling pointer that the .rst use freed. Typically, an af.ne type system works by imposing \ntwo syntactic requirements: a variable of af.ne type, such as r, cannot appear twice in its scope (up \nto branching), and a function that closes over an af.ne variable must itself have an af.ne type. The \nsquareRef example violates neither dictum. In the presence of delimited continuations, we need to add \na third rule: that a captured continuation that contains an af.ne value must not duplicated. A simple \napproximation of this rule is to give all captured continuations an af.ne (or in a linear system, linear) \ntype. Such a rule would per\u00admit some limited uses of delimited continuations, such as Our solution. The \nmemory leak and dangling pointer in the above examples can be .xed by small changes to the code. For \ndivRef , it suf.ces to ensure that both divisions happen before both allocations:  def divRef (z 1: \nInt, z2: Int) ={ val z12 = z1 / z2 val z21 = z2 / z1 (new Ref(z12), new Ref(z21)) } For squareRef , we \nneed the dereferencing to happen once, outside the reset delimiter: def squareRef (r: Ref[Int]) ={ val \nz = r.unref () reset { twiceTo(1) \u00d7 z } } Unfortunately, the conservative approximation suggested above, \nthat all continuations be treated linearly, would still disallow these repaired examples. We have designed \na type\u00adand-effect system (Lucassen and Gifford 1988) that permits these two repaired versions of the \nmethods while forbidding the original, erroneous versions. The key idea is to assign to each expression \na control effect that re.ects whether it may duplicate or drop its continuation, and to prohibit using \nan expression in a context that cannot be treated as the control effect allows. In this paper, we exhibit \na generic type system for substructural types and control de.ned in terms of an unspeci.ed, abstract \ncon\u00adtrol effect (\u00a74);  give soundness criteria for the abstract control effect and prove type safety \nfor the generic system, relying on the soundness of the abstract control effect (\u00a75); and  demonstrate \nthree concrete instantiations of control ef\u00adfects and prove that they meet the soundness criteria (\u00a76). \n The generic type-and-effect system in \u00a74 is de.ned as an extension to .URAL (Ahmed et al. 2005), a \nsubstructural . calculus, which we review in \u00a73, after discussing related work in \u00a72. 2. Related Work \nand Comparison This work is not the .rst to relate substructural types to con\u00adtrol operators and control \neffects. Thielecke (2003) shows how to use a type-and-effect system to reason about how expressions treat \ntheir continuations. In particular, he gives a continuation-passing style transform where continuations \nthat will be used linearly are given a linear type. Thielecke notes that many useful applications of \ncontinuations treat them linearly. However, his goals are different than ours. He uses substructural \ntypes in his object language to reason about how continuations will be used in a non-substructural source \nlanguage, whereas we want to reason about contin\u00aduations in order to safely use substructural types. \nThielecke has linear types only in the object language of his translation, whereas we are interested \nin linear (and other substructural) types in the source language. Other recent work relates substructural \nlogics and control. Kiselyov and Shan (2007) use a substructural logic to al\u00ad low the dynamic control \noperator shift0 to modify answer types in a typed setting. Unlike this work, their terms are structures \nin substructural logic, not their types. Mazurak and Zdancewic s Lolliproc (2010) relates double negation \nelimination in classical linear logic to delimited control. We draw signi.cantly on other work on control \noperators, effect systems, and substructural types as well. Control operators. The literature contains \na large vocabu\u00adlary of control operators, extending back to ISWIM s J opera\u00adtor (Landin 1965), Reynolds \ns escape (1972), and Scheme s call-with-current-continuation (Clinger 1985). However, for integration \nin a language with substructural types, control operators with delimited extent, originating with Felleisen \ns F (1988), are most appropriate, because without some way to mask out control effects, any use of control \npollutes the entire program and severely limits the utility of substructural types. As examples of control \nfeatures to add to our calculus, we consider the delimited continuation operators shift and reset (Danvy \nand Filinski 1989) and structured exception handling (Goodenough 1975). Both shift/reset and structured \nexcep\u00adtions have been combined with type-and-effect systems to make them more amenable to static reasoning. \nType-and-effect systems for control. Java (Gosling et al. 1996) has checked exceptions, an effect system \nfor tracking the exceptions that a method may raise. Our version of exception effects is similar to Java \ns, except that we offer ef\u00adfect polymorphism, which makes higher-order programming with checked exceptions \nmore convenient. Our type system for exceptions appears in \u00a76.3. Because Danvy and Filinski s shift (1989) \ncaptures a de\u00ad limited continuation up to the nearest reset delimiter, typing shift and reset requires \nsome nonlocal means of communi\u00adcating types between delimiters and control operators. They realize this \ncommunication with a type-and-effect system, which allows shift to capture and compose continuations \nof varying types. Asai and Kameyama (2007) extend Danvy and Filinski s (monomorphic) type system with \npolymor\u00ad phism, which includes polymorphism of answer types. We give two substructural type systems with \nshift and reset. Section 6.1 presents a simpler version that severely limits the answer types of continuations \nthat may be captured. Then, in \u00a76.2, we combine the simpler system with a polymor\u00ad phic version of Danvy \nand Filinski s, similar to Asai and Kameyama s, to allow answer-type modi.cation and poly\u00ad morphism in \na substructural setting.  Substructural type systems. Researchers have proposed a v ::= x | .x.e | ..e \n|0 | inl v | inr v (values) plethora of substructural type systems. These range from e ::= v | e1 e2 \n| e | let 0 = e1 in e2 (expressions) minimalistic models (Wadler 1992; Bierman 1993; Bar\u00ad | case e of \ninl x1 . e1; inr x2 . e2 ber 1996; Morrisett et al. 2005) based on Girard s linear logic (1987), to real \nprogramming languages, which are often oriented toward speci.c problems such as safety in low-level languages \n(Grossman et al. 2002), typestate and protocol checking (Aldrich et al. 2009), or security (Swamy et \nal. 2010). We translate our substructural type-and-effect system into Ahmed et al. s .URAL (2005), which \nis a polymorphic . calculus that supports a variety of substructural typing dis\u00adciplines. We provide \na primer on .URAL in \u00a73. Motivation. The software engineering case for structured exception handling \nis widely acknowledged and understood, but shift and reset (Danvy and Filinski 1989), the other control \noperators discussed in this paper, are more obscure. The essential idea is simple: whereas raising an \nexception discards the context up to some delimiter the exception handler shift captures and rei.es the \ncontext up to its delim\u00aditer, reset, which allows reinstating the context later. These control operators \nmay be used to implement exceptions, by capturing continuations but never reinvoking them, but they may \nalso express other control structures, such as coroutines and cooperative multithreading, and they may \nbe used to abstract non-determinism and search in an elegant way. Our goal is to safely integrate control \noperators with substructural types. A substructural type system regulates the order and number of uses \nof data by statically ensuring that some values be used at most once, at least once, or ex\u00adactly once \n(Walker 2005). Like shift and reset, substructural types are a general facility that can express a variety \nof spe\u00adci.c language features, mostly for the purpose of managing stateful resources, such as typestate, \nregion-based memory management, and session types. The direct impetus for this work is the design of \nthe programming language Alms (Tov and Pucella 2011), which provides both exceptions and af.ne types, \na variety of sub\u00adstructural type that can prohibit reusing particular values. As demonstrated in \u00a71, \nthe combination of af.ne types and exceptions is not a problem. However, as we observe in that previous \nwork, we anticipate that safely combining linear\u00adity with exceptions requires a type-and-effect system \nto track when raising an exception would implicitly discard linear values. Our desire to add linear types \nto Alms motivates this development of a general theory of substructural types and control effects. 3. \nSyntax and Semantics of .URAL In this paper, we add control effects to Ahmed et al. s .URAL (2005), a \nsubstructural . calculus. Our presentation of .URAL is heavily based on theirs, with a few small changes. \nq .{U, R, A, L} (quali.er constants) . ::= a | q (quali.ers) t ::= a | t1 -t2 |.a:..t | 1 | t1 . t2 (pretypes) \nt ::= a | .t (types) . ::= . | t | t (type-level terms) . ::= QUAL | * | * (kinds) Figure 1. .URAL syntax \n1 The syntax of .URAL appears in Figure 1. The expression level. Values include abstractions, type ab\u00adstractions, \nthe unit value, and injections into a sum. (This differs from Ahmed et al. s presentation of .URAL by \nin\u00adcluding sums additive disjunctions, to be precise rather than multiplicative conjunctions. Our theorems \nhandle both, but we omit products in this paper for brevity. Sums are more useful for our purposes here.) \nExpressions include val\u00adues, application, type application, unit elimination, and sum elimination. Following \nAhmed et al., we elide the formal parameter in type abstractions and the actual parameter in type applications. \nThe type level. Expressions in .URAL are classi.ed by types (t ), but the language at the type level \nis much richer. Four constant quali.ers (q) distinguish four substructural properties that may be enforced \nfor values: L as in linear, for values that may be neither duplicated nor implicitly dropped; A as in \naf.ne, for values that may be L dropped (weakening) but not dupli\u00ad cated; AR R as in relevant, for values \nthat may be duplicated (contraction) but not dropped; and U U as in unlimited, for ordinary values that \nallow both dropping and dupli\u00ad cation. The four constant quali.ers form a lattice, whereby it is always \nsafe to treat a value as if it has a higher quali.er than its own. Quali.ers (.) include both quali.er \nconstants and type variables, allowing for quali.er polymorphism. Pretypes (t) 1 This is the black-and-white \nversion of this paper, suitable for printing; a version that uses colors to distinguish non-terminals \nfrom two different cal\u00adculi is available online at www.ccs.neu.edu/~tov/pubs/substructural\u00ad control. \n E ::= [] | Ee2 | v1 E | E (evaluation contexts) | let 0 = E in e2 | case E of inl x1 . e1; inr x2 . \ne2 ' e -. e (reduction) (.x.e1) v2 -. {v2/x}e2 (..e) -. e let 0 = 0 in e -. e case inl v of inl x1 . \ne1; inr x2 . e2 -. {v/x1}e1 case inr v of inl x1 . e1; inr x2 . e2 -. {v/x2}e2 ' e -.eE[e] -. E[e'] Figure \n2. .URAL operational semantics . f . : . (kinding type-level terms) K-VAR K-QUAL a:. . . . f a : . . \nf q : QUAL K-ARR K-ALL . f t1 : * . f t2 : * .,a:. f t : * . f t1 -t2 : * . f.a:..t : * K-SUM K-UNIT \n. f t1 : * . f t2 : * . f 1 : * . f t1 . t2 : * K-TYPE . f t : * . f . : QUAL . f .t : * Figure 3. .URAL \nstatics (i): kinding specify the representation of a value, and its introduction and elimination rules. \nPretypes include type variables, function types, universal quanti.cation, the unit type, and additive \ndisjunction. Types (t) classify expressions. A type is either a pretype decorated with its quali.er (.t) \nor a type variable. We use non-terminal . to refer to the three kinds of type-level terms as a group. \nThe kind level. Types in .URAL are classi.ed by three kinds (.): QUAL for quali.ers, * for pretypes, \nand * for types. Type variables may have any of these three kinds, which is why universal quanti.cation \n(.a:..t ) speci.es the kind of a. . f .1 .2 (quali.er subsumption) QSUB-BOT QSUB-TOP QSUB-REFL . f . \n: QUAL . f . : QUAL . f . : QUAL . f U . . f . L . f . . . f t . (quali.er bound for types) B-VAR B-TYPE \n. f a : * . f t : * . f .' . . f a L . f .e t . . f G . (quali.er bound for type contexts) B-NIL B-CONS \n. f . : QUAL . f G . . f t . . f . . f G,x:t . Figure 4. .URAL statics (ii): quali.ers . f G G1 E G2 \n(type context splitting) S-NIL S-CONSL . f G G1 E G2 . f t : * . f  E . f G, x:t (G1, x:t ) E G2 S-CONSR \n . f G G1 E G2 . f t : * . f G,x:t G1 E (G2,x:t ) S-CONTRACT . f G G1 E G2 . f t R . f G,x:t (G1,x:t) \nE (G2,x:t) Figure 5. .URAL statics (iii): context splitting 3.1 Operational Semantics The operational \nsemantics of .URAL is completely standard and appears in Figure 2. Reduction is call-by-value and eval\u00ad \nuates operators before operands, which is important when we consider the sequencing of effects in \u00a74. \n 3.2 Static Semantics Type judgments for .URAL use two kinds of contexts: . ::= | .,a:. (kind contexts) \nG ::= | G,x:t (type contexts) Figure 3 contains the kinding judgment (. f . : .), which assigns kinds \nto type-level terms. This judgment en\u00ad  (typing expressions) T-WEAK T-VAR T-ABS . f GG1 E G2 . f G2 \nA .; G1 f e : t . f t : * . f G . .; G,x:t1 f e : t2 .; G f e : t .; ,x:t f x : t .; G f .x.e : .(t1 \n-t2) T-INL T-INR T-TABS T-UNIT . f t1 . . f t2 : * . f t2 . . f t1 : * . f G . .,a:.;G f e : t . f . \n: QUAL .; G f v1 : t1 .; G f v2 : t2 .; G f ..e : ..a:..t .; f0 : .1 .; G f inl v1 : .(t1 . t2) .;G f \ninr v2 : .(t1 . t2) T-APP . f G G1 E G2 .; G1 f e1 : .(t1 -t2) .; G2 f e2 : t1 .; G f e1 e2 : t2 T-TAPP \n.; G f e : ..a:..t . f . : . .; G f e : {./a}t T-LETUNIT . f G .; G1 f e1 : .1 .; G f let 0 G1 E G2 .; \nG2 f e2 : t = e1 in e2 : t T-CASE . f G G1 E G2 .; G1 f e : .(t1 . t2) .; G2, x1:t1 f e1 : t .; G2, x2:t2 \nf e2 : t .; G f case e of inl x1 . e1; inr x2 . e2 : t Figure 6. .URAL statics (iv): typing forces the \ntype/pretype structure, whereby type constructors such as . form a pretype from types (rule K-SUM), and \ndecorating a pretype with a quali.er forms a type (rule K-TYPE). In Figure 4, three judgments relate \nquali.ers to each other, to types, and to type contexts. Quali.er subsumption (. f .1 .2) de.nes the \nquali.er order, with top L and bottom U. The next judgment bounds a type by a quali.er; judgment . f \nt. means that values of type t may safely be used according to the structural rules implied by .. Finally, \nbounding a type context by a quali.er (. f G .) means that every type in context G is bounded by quali.er \n.. Figure 5 gives rules for splitting a type context into two (. f GG1 E G2), which is necessary for \ndis\u00adtributing typing assumptions to multiple subterms of a term. Any variable may be distributed to one \nside or the other. Rule S-CONTRACT implements the contraction structural rule, whereby variables whose \ntype is unlimited or relevant may be duplicated to both contexts. Finally, Figure 6 gives the judgment \nfor assigning types to expressions (.; G f e : t ). Several points are worthy of note: The weakening \nrule, T-WEAK, allows discarding por\u00ad tions of the context that are upper-bounded by A, which means that \nall the values dropped are either af.ne or unlimited.  The rules for application and for unit and sum \nelimina\u00adtion, T-APP, T-LETUNIT, and T-CASE, split the con\u00ad text to distribute assumptions to subterms. \nNote, however,  that both branches of a case expression share the same context. Rule T-ABS selects a \nquali.er . for a function type based on bounding the context, G. This means that the quali.er of a function \ntype must upper bound the quali.ers of the types of the function s free variables. As we will see in \n\u00a75, this property is key to our soundness theorem. 4. Generic Control Effects Rather than add a speci.c \ncontrol effect, such as exceptions or delimited continuations, to .URAL, we aim to design a sub\u00adstructural \ntype system with a general notion of control effect. Thus, in this section, we de.ne a new calculus, \n.URAL(C), parameterized by an unspeci.ed control effect. 4.1 The Control Effect Parameter In this subsection, \nwe give the form of the parameter that stands for a particular control effect. Our de.nition of .URAL(C) \nrelies only on this abstract speci.cation of the formal parameter. In \u00a75, we specify several properties \nof the parameter that are suf.cient for a generic soundness theorem to hold, and in \u00a76 we give three \nexamples of actual control effect parameters. De.nition 4.1 (Control effect). A control effect instance \nis a triple (C, .C, G) where C is a set of control effects (c), .C . C is a distinguished pure effect \nthat denotes no actual control, and G : C \u00d7 C -C is an associative, partial, binary operation denoting \neffect sequencing.  (kinding type-level terms) C (quali.er bound for control effects) C-K-BOT C-B-PURE \nC-B-UNL ffDDCfDC C fDC . : QUAL c : CTL . C : CTL . C C . fDC c C U C-K-ARR D fCt1 : * D fC D fCt1 ffDDCffDDC \nCSUB-REFL CSUB-TRANS '' CC fDC ffD,ak D:C fDC C-K-ALL C t2 : * c : CTL (control effect subsumption) c1 \nc2 fDC c - -t2 : * c : CTL fDC c1 c cc2t : * c : CTL .ca:k.t : * cc c1 c2 Figure 7. .URAL(C) statics \n(i): updated kinding rules Figure 8. .URAL(C) statics (ii): control effect judgments For example, in \n\u00a76.3 we add exception handling to .URAL(C). An exception effect is the set of exceptions that may be \nraised by an expression, the distinguished pure effect .C is the empty set, and sequencing is set union. \nA non-empty effect indicates that an expression may discard part of its continuation, whereas the empty \neffect guarantees that an expression treats its continuation linearly. In simple cases, as with exceptions, \neffects form a join semilattice where sequencing is the join, but this is not necessarily true in general \n(\u00a76.2).  4.2 Updated Syntax In .URAL(C), control effects constitute a fourth kind of type\u00adlevel term, \nin addition to quali.ers, pretypes, and types. We add a new kind, CTL, and include abstract control effects \n(c . C) among the type-level terms: G1 E G2) are isomorphic splittingtypecontexts(fDC C to the .URAL \nversions of those judgments from Figures 4 and 5. They are merely updated with new non-terminals as appropriate \n(i.e., . to k, t to t, and t to t). Kinding. We identify control effects as the type-level terms (i) \nthat are assigned kind CTL by the kinding judg\u00adment. Figure 7 shows one new kinding rule, C-K-BOT, which \nassigns kind CTL to the pure effect .C. We update rules C-K-ARR and C-K-ALL to account for latent effects \nin function and universal pretypes. The remaining kinding rules are the same as for .URAL, with non-terminals \nmutatis mutandis. Speci.c control effect instances (\u00a76) must de.ne additional kinding rules for their \nparticular effects. Control effect judgments. The .rst new judgment for con\u00adtrol effects (D fc C ., Figure \n8) relates control effects to G k ::= QUAL | * | * | CTL (kinds) quali.ers. This gives the meaning of \na control effect in terms i ::= . | t | t | c (type-level terms) of a lower bound for how an expression \nwith that effect may treat its own continuation. For example, if an expression e Function and universal \npretypes now have latent effects, has some effect c such that D f c C A, this indicates that C e may \ndrop but not duplicate its continuation. We give two which record the effect that will happen when an \nabstraction is applied. We update the de.nition of pretypes to include rules here: these latent effects: \nc t ::= \u00b7\u00b7\u00b7 | t1 -|.ca:k.t (pretypes) -t2 t ::= a | .t (types) The other pretype (t) productions remain \nunchanged. For non-terminal symbols that differ between .URAL and .URAL(C), we use Roman letters (t, \nk, G, ...)for .URAL(C) to distinguish them from .URAL, where they appeared in Greek (t, ., G, ...). 4.3 \nStatic Semantics of .URAL(C) All type system judgments from .URAL are updated for  Rule C-B-PURE says \nthat the pure effect is bounded by any quali.er, which means that a pure expression satis.es any requirement \nfor how it treats its continuation.  Rule C-B-UNL says that all control effects are bounded by U, which \nmeans that we may assume, conservatively, that any expression might freely duplicate or drop its continuation. \n Speci.c instances of the control effect parameter will extend this judgment to take into account the \nproperties of a partic\u00adular control effect. .URAL(C), and .URAL(C) adds two new judgments as well. The \nsecond judgment for control effects (D C types(),boundingtypecontexts ffD .DC C fThe kinding and expression \ntyping judgments are the only c2) de.nes a subsumption order for control effects. This two to change \nsigni.cantly. The judgments for bounding means that an expression whose effect is c1 may be safely c1 \n G .), and considered to have effect c2. Only two rules for the judgment t  (typing expressions) C-T-SUBSUME \nC-T-WEAK C-T-VAR fD;:t,xC '' fffffD;G DDD;GD: t ;eccc 1C C C C C G1 E G2 fDC A G G2 t : *e : t ; c ffDD;G \nC C-T-ABS C-T-TABS C-T-INL ffD;D;G C C C ffD;G D;G C ffDDC CC fDC c1 G c2 G c : CTL x : t ; .Ce : t \n; c e : t ; c fDCfDC v1 : t1 ; .C G . G . . t2 : * C-T-UNIT t1 c D; G f.(t1 - -t2); .C fD;G:t,x1C C \nD; G f..ca:k.t ; .C fD,ak;G :C C . : QUAL e : t2 ; c e : t ; c .1 ; .C .(t1 . t2); .C 0 inl v1 : .x.e \n: ..e : : C-T-APP G1 E G2 fDC-ff); D;GD;G -tc212CC fD;G C e c C D fD f fDC C C-T-TAPP G .1 (t1 ..c \nD fc2 C .1 fD;G1C C a:k.t ; c C-T-INR fDC e1 : e2 : t1 ; c2 e : v2 : t2 ; .C fDC t1 : * . c1 G c2 G c \n: CTL fDCfDC c1 C .2 G2 .2 i : kt2 ' D; G finr v2 : fD;G C C : CTL c G c ' .(t1 . t2); .C fDC fD;G1C \nC-T-LETUNIT C-T-CASE fD;G C : {i/a}t ; c G ce1 e2 : t2 ; c1 G c2 G c e G1 E G2 .1 (t1 . t2); cG1 E G2 \n.1 1 ; c1 fDC G fDC fD;G1C '' G e : D fG2 .2 fD;G2C C fD;G:t,x211C fDC ' fD;G:t,x222CfG.D22C e1 \n: e2 : t ; c2 e1 : t ; c e2 : t ; c c1 C .2 C .1 fDC C D f: CTL c G c ' c C .2c ' let 0 fDC c1 G c2 : \nCTL ffD;G D;G C Figure 9. .URAL(C) statics (iii): typing appear in Figure 8, which together ensure that \ncontrol effect (4) This premise relates the type of e1 to the effect of e2 subsumption is a preorder. \nAs with control effect bounding, to ensure that e2 s effect does not violate e1 s invariants. speci.c \ncontrol effect instances will extend this judgment. Because we .x a left-to-right evaluation order, by \nthe toexpressions: fD;G cC time e2 gets to run, e1 has reduced to a value of type Expression typing. \nThe expression typing judgment for c .1 (t1 - -t2), which thus may be treated according to qual- C .URAL(C) \n(Figure 9) assigns not only a type t but an effect i.er .1. Because that value is part of e2 s continuation, \ncase e of inl x1 . e1; inr x2 . e2 : t ; c G c = e1 in e2 : t ; c1 G c2 e : t ; c. Having seven premises, \nwe require that e2 s effect, c2, be lower-bounded by .1.the rule for applications (C-T-APP) is unwieldy, \nbut it likely In other words, e2 will treat its continuation no more fD;G2C fDCfD C fDCfD;G1C gives \nthe most insight into how .URAL(C) works: liberally than .1 allows. G1 E G2 (1) G (5 6) These premises \nrelate the free variables of e2 to the c .1 (t1 - -t2); c1 (2) e1 : effect of e1. Due to the evaluation \norder, e2 appears unevaluated in e1 s continuation, which means that if (3) e2 : t1 ; c2 e1 drops or \nduplicates its continuation then e2 may be (4) c2 C .1 evaluated never or more than once. Premise (5) \nsays that (5) G2 .2 the type context for typing e2, and thus e2 s free variables, (6) are bounded above \nby some quali.er .2, and this quali.er c1 C .2 (7) fDC fD;G C We consider the premises in order: (1) \nThe .rst premise, as in .URAL, splits the type context G into G1 for typing e1 and G2 for typing e2. \n(2 3) As in .URAL, these premises assign types to expres\u00adsions e1 and e2, but they assign effects c1 \nand c2 as well. e1 e2 : t2 ; c1 G c2 G c thus indicates how many times it is safe to evaluate e2. Premise \n(6) lower bounds e1 s effect, c1, by .2, ensuring that e1 s effect treats e2 properly. (7) The net effect \nof the application expression is a sequence of the effect of e1 (c1), then the effect of e2 (c2), and \n.nally the latent effect of the function to which e1 must evaluate (c): c1 G c2 G c. This premise checks \nthat those three effects may be sequenced in that order according to  QUAL* = QUAL ** = * (kinds) ** \n= * CTL* = QUAL * = (D, a:k)* = D*, a:k* (kind contexts) Figure 10. CCoS translation (i): kinds and \nkind contexts  Parameter Properties (\u00a75.3). A control effect instance must satisfy several properties \non which the generic type safety theorem relies. Generic Type Safety (\u00a75.4). The section culminates in \na generic proof of type safety for .URAL(C). 5.1 The Translation Parameter De.nition 5.1 (Translation \nparameter). The de.nition of the generic CCoS translation relies on the following effect-speci.c de.nitions: \na metafunction (\u00b7)* from effects to quali.ers, such that * . C = L and a* = a; a value doneC, to use \nas the initial continuation for a CCoSed program; and - + a pair of answer-type metafunctions 00\u00b7, \u00b7 \nand 00\u00b7, \u00b7 , cc each of which maps a .URAL type and a .URAL(C) effect to a .URAL type. - Intuitively, \nwe can understand metafunctions (\u00b7)* , 00\u00b7, \u00b7 , c + and 00\u00b7, \u00b7 as relating the effect of a .URAL(C) expression \nc to the type of its translation into .URAL. Typically, the CPS translation of an expression of some \ntype t yields a type like (t . Answer) . Answer. Given a .URAL(C) expression whose translated type is \nt and whose effect is c, our translation yields type * c - + (t -0 t0,c ) -0 t0,c CC for some answer \ntype t0. That is, (\u00b7)* gives the quali.er of the continuation, and the other two metafunctions give the \nanswer types, which may depend on the nature of the control effect. Because they give the answer types \nin negative and - positive positions, respectively, we call 0 t, c the negative C a particular control \neffect s de.nition of sequencing and the kinding judgment. Rules C-T-LETUNIT and C-T-CASE (unit and sum \nelimi\u00adnation) are similar, since they need to safely sequence two subexpressions. Both rules follow rule \nC-T-APP in relating the effect of the .rst subexpression to the type context of the second and effect \nof the second to the quali.er of the .rst. Rule C-T-TAPP (type application), while dealing with only \none effectful subexpression, needs to sequence the effect of evaluating the expression in a type application \nwith the latent effect of the resulting type abstraction value. The subsumption rule C-T-SUBSUME implements \ncon\u00adtrol effect subsumption, whereby an expression of effect c '' may also be considered to have effect \nc if c is less than c in the control effect subsumption order. C-T-WEAK, which handles weakening, is \nunchanged from .URAL . The remaining rules are for typing values, which always have the pure effect .C. \nRules C-T-UNIT, C-T-INL, and C-T-INR, for unit and sum introduction, are unchanged from .URAL, except \nthat each of them assigns the pure effect. Rules C-T-ABS and C-T-TABS also assign the pure effect to \ntheir values, but each records the effect of the abstraction body as the latent effect in the resulting \ntype. 5. The Generic Theory To prove type safety for .URAL(C), we de.ne a type-preserv\u00ading translation \nto .URAL. Rather than provide a reduction semantics for .URAL(C), we de.ne its operational seman\u00adtics \nin terms of the translation and the reduction semantics of .URAL (\u00a73.1). Thus, if we can show that all \nwell-typed .URAL(C) programs translate to well-typed .URAL programs, then .URAL s type safety theorem \napplies to .URAL(C) as well. The translation is into what Danvy and Filinski (1989) call continuation-composing \nstyle (henceforth CCoS ). It is similar to continuation-passing style, but unlike continuation\u00adpassing \nstyle it still relies on the object language s order of evaluation. In order to specify the translation \nand prove the proposi\u00adtions speci.ed later in this section, we impose several more requirements on the \nabstract control effect parameter. As the semantics of .URAL(C) was parameterized by an abstract control \neffect, so is the theory of .URAL(C) parameterized by several de.nitions and properties that a control \neffect must satisfy. answer type and 0 t, c + C the positive answer type. The development of this section \nis constrained by several dependencies, so we provide an outline:  5.2 The Translation The Translation \nParameter (\u00a75.1). A control effect instance In this subsection, we specify the CCoS translation from \nmust supply a few de.nitions to fully specify its particu\u00ad .URAL(C) to .URAL. In several places, we \nrely on the de.\u00adlar CCoS translation. *- nitions of c , doneC, 0 t, c C , and 0 t, c + supplied by the \n The Translation (\u00a75.2). The de.nition of the CCoS transla-control effect parameter. tion relies on the \nde.nitions supplied by the control effect The translation for kinds and kind contexts appears in Fig\u00adparameter. \nure 10. The control effect kind CTL translates to QUAL, and * (t1 . t2)* = t1 * . t2 (t1 -= -t2)* * \n*- + .a: *.L(t1 -L(c * (t2 -0 a, c C ) -0 a, c C )) (.c\u00df:k.t)* = L(c - + .a: *.L.\u00df:k* . * (t * -0 a, \nc C ) -0 a, c C ) a* = a (types) .* (.t)* = t * = (type contexts) (G,x:t)* =G* ,x:t * Figure 11. CCoS \ntranslation (ii): type-level terms and con\u00adtexts the other three kinds translate to themselves. The translation \nof a kind context merely translates each kind in its range. Figure 11 presents the translation for pretypes, \ntypes, and type contexts. Most of this translation is straightforward: type variables and the unit pretype \ntranslate to themselves, sum types translate both disjuncts, types composed of a qual\u00adi.er and a pretype \ntranslate the pretype, and type contexts translate all the types in their range. The two interesting \ncases are for function and universal pretypes. These follow the usual CPS translation for function and \nuniversal types, with several re.nements: Each adds an extra universal quanti.er in front of its result, \nwhich is used to make (type) abstractions polymor\u00adphic in their answer types.  Because the effect of \nan expression limits how it may  * use its continuation, the translation c of latent effect c becomes \nthe quali.er of the continuation. All other quali.ers of the translated pretype are L. (This is because \nthe translation never needs to duplicate partially\u00adapplied continuations, so L is a suf.ciently permissive \nquali.er for those continuations. Furthermore, because the type rules for abstractions always allow a \nquali.er of L, using L wherever possible simpli.es the proof.) Translation of values and expressions \nis de.ned by mu\u00ad The result of evaluating e1, bound to x1, is in each case instantiated by a type application, \nwhich compensates for the new type abstraction in the translation of abstractions. For the type application \ncase, x1 is instantiated then again, corresponding to the instantiation from the source expression. \n Curiously, the continuation y is .-expanded to .x.y x. While .-expanding a variable may seem useless, \nit is actually necessary to obtain a type-preserving translation.  In particular, the reason for this \n. expansion is to handle effect subsumption. Effects in .URAL(C) are translated to quali.ers in .URAL, \nand while .URAL(C) supports effect sub\u00adsumption directly, there is no analogous quali.er subsump\u00adtion \nin .URAL. However, quali.er subsumption for function types can be done explicitly using . expansion: \nLemma 5.2 (Dereliction). If .; G f v : .(t1 -t2) and . f .. ' then .; G f .x.v x : .e (t1 -t2). The proof \nof Lemma 5.2 relies on another lemma: Lemma 5.3 (Value strengthening). Any quali.er that upper bounds \nthe type of a value also bounds the portion of the type context necessary for typing that value. That \nis, if .; G f v : t and . f t. then there exist some G1 and G2 such that . f GG1 E G2,  .; G1 f v : \nt ,  . f G1 ., and  . f G2 A.  Proof. By induction on the typing derivation for v. Proof of Lemma \n5.2. Choose type contexts G1 and G2 ac\u00adcording to Lemma 5.3. Then .; G1,x:t1 f vx : t2 by rule T-APP. \nBy induction on the length of G1 and transitivity of quali.er subsumption, we know that . f G1 . '. Then \nby rule T-ABS, .; G1 f .x.v x : .e (t1 -t2), and we change G1 to G by rule T-WEAK. Operational semantics \nof .URAL(C). Having de.ned the translation, we run a program e by applying the CCoS trans\u00adlation and \npassing it the initial continuation doneC. We de\u00ad.ne the operational semantics of .URAL(C) as a partial \nfunc\u00adtion eval : Expressions -Values .{WRONG}: . . . . . * tual induction in Figure 12. Value translation \n(v *) is mostly if [e]C doneC -. v; v * straightforward. Both value and type abstraction have an additional \ntype abstraction added to the front, which matches ' WRONG doneC -. e eval(e)= if [e]C ' such that e \nis not a value the addition of the universal quanti.er in the type translation, and \u00ac.e '' .e ' -. e \n'' . and both translate the body according to the expression trans\u00ad 5.3 Parameter Properties lation \n[e]C. The expression translation is standard except for two unusual aspects of the translation of applications \nand Having de.ned the CCoS translation, we are now ready to type applications: state the additional properties \nthat the abstract control effect * x = x (values) Parameter Property 2 (Done). (.x.e)* = If . f t A \nthen .; f doneC : L(t -0 t). (..e)* = RATIONALE. The doneC value must be well typed for (inl v)* = ...x. \n[e]C .... [e]C * inl v the translation of a whole program to be well typed. * (inr v)* = inr v Parameter \nProperty 3 (Effect sequencing). * If fDC * : CTL then D* f (c1 G c2)* c1 0 0 and = c1 G c2 * c2 . D* \nf (c1 G c2)* = .y.y v* (expressions) [v]C RATIONALE. [e1 e2]C = .y. [e1]C (.x1. [e2]C (.x2.x1 x2 (.x.y \nx))) [e1 ]C = .y. [e1]C (.x1.x1 (.x.y x)) Sequencing lowers the translation of control effects in the \nquali.er order. This makes sense, because if either of two sequenced expressions may duplicate or discard \ntheir continuations, then the com\u00ad [let 0 = e1 in e2]C pound expression may do the same. = .y. [e1]C \n(.x1. let 0 = x1 in [e2]C y) Parameter Property 4 (Bottom and lifting). [case e of inl x1 . e1; inr x2 \n. e2]C .y. [e]C inr x2 y) 1. c1 G c2 = .C if and only if c1 = c2 = .C. RATIONALE. =(.x. case x of inl \nx1 . e1 y; C Sequencing impure expressions should . [ e2] C Figure 12. CCoS translation (iii): values \nand expressions not result in a pure expression. 2.If fDC some c fDC c1 G c2 : CTL and c1 G c2 , then \nthere exist = .C '' and c such that = .C 1= .C 2 ' c1 c1, ' fDCC '' c1 G c2 = c1 G c2, and '' D f2 : \nCTL. c2 c parameter must satisfy for the generic type safety theorem (\u00a75.4) to hold: 2, c 1 G c RATIONALE. \nParameter Property 1 (Answer types). This assumption is likely not necessary, 1. For all t , 0 t, .C \n- C = 0 t, .C + C . but it signi.cantly simpli.es the proof by allowing the effects in a sequence to \nbe considered either all pureRATIONALE. For pure expressions, the negative and or all impure. positive \nanswer types agree, because a pure expression .nishes by calling its continuation. Henceforth, we The \n.nal property concerns four lemmas that we state and \u00a3 are justi.ed de.ning the pure answer type 0 tprove \nfor the generic system in the next subsection. An C + 0 t, .C . C actual control effect instance needs \nto extend these lemmas to cover any additional rules added to the relevant judgments: f t : * and D fc \n: CTL then D*- C 2. If D* f0 t, c : * C and D* f0 t, c + C : *. Parameter Property 5 (New rules). For \nthe translation to be well typed, RATIONALE. 1. Lemma 5.4 (\u00a75.4) must be extended, by induction on well-kinded \ntypes and effects must become well\u00ad derivations, for any rules added to the kinding judgment kinded answer \ntypes. fDC 2. Lemma 5.5 (\u00a75.4) must be extended, by induction on i : k. 3. For all D, t, c1 .C, and c2 \n= boundingjudgment(a) fD0 t,cG c12C suchthat fDC c1 G c2 : CTL, derivations, for any rules added to \nthe control effect -- .C = c C ..= 0 t, c2 , CC 3. Lemma 5.6 (\u00a75.4) must be extended, by induction on \n(b) 0 t, c1 G c2 - (c) 0 t, c1 ++ , and = 0 t, c1 CC derivations, for any rules added to the control \neffect sub\u00ad + C . 0 t, c2 = C sumptionjudgment fDC 4. Lemma 5.7 (\u00a75.4) must be extended, by induction \non c1 c2. RATIONALE. Effect sequencing must maintain an\u00ad swer types in order for the continuations of \nsequenced derivations, for any rules added to the expression typing expressions to compose. judgment \nfD;GC c1 c2, then for every type t there exists some In \u00a76, we give several example control effects and \nshow e : t ; c. 4.If fDC ' '- -' such that 0 t and 0 t + type t 0 t, c2 = that they satisfy the above \nproperties. ,c1 = ,c1 CCC + 0 t, c2 .  5.4 Generic Type Safety RATIONALE. For control effect subsumption \nto be Assuming that the above properties hold of the control valid, related control effects must generate \nrelated effect parameter, we can now prove a type safety theorem answer types.  - ''- Then it suf.ces \nto substitute 0 t0,c for 0 t and 0,c C '' for 0 t0,c , which we know to be equal by + C www.ccs.neu.edu/~tov/pubs/substructural-control. \nD; G1 f D f Property1(part4). C fD;G2C fDCC We begin with a lemma that ensures that control effects G1 \nE G2 fDC c1 G c2 G c : CTL G G2 .2 translate to well-formed quali.ers: c .1 (t1 - -t2); c1 fDC c1 C .2e1 \n: fDC c2 C .1 Lemma 5.4 (Translation of kinding). e2 : t1 ; c2 i : k then D* f i* : k* We continue with \ntwo lemmas concerning how the trans- Forall ,and ,if fDikD,C . Case . fD;GC-* --+( ) ( ) QQQQt) t,ccc,ccc012012C \nC For rule C-T-APP, we want to show that [e1 e2]Clation of control effects to quali.ers relates to quali.er \nsub-type sumption. The former ensures that the control effect bound e1 e2 : t2 ; c1 G c2 G c has L(.0 \n(t2 ). used by typing rules such as C-T-APP matches the quali.er assigned to the type of a continuation \nby the CCoS trans-Consider the translation of e1 e2, lation. The latter shows that a larger control \neffect, which indicates more liberal treatment of a continuation, maps to a .y.[e1]C (.x1.[e2]C (.x2.x1 \nx2 (.x.y x))). smaller quali.er, which indicates more liberal treatment of any value. The type derivation \nis too large to show here in detail, but Lemma 5.5 (Translation of effect bounds). it hinges on giving \nthe right quali.ers to the types of con\u00ad * tinuations. We will consider the continuation passed to c \nC . then D* f .c . the whole expression and the continuations constructed Lemma 5.6 (Translation of effect \nsubsumption). for e1, e2, and the function application itself, in turn. If fDC ** c2 then D* f c2 c1 \nProofs of Lemmas 5.4, 5.5, and 5.6. By induction on deriva\u00adtions. The most dif.cult lemma, and the heart \nof the proof, is about typing translated expressions. Given a .URAL(C) expression whose control effect \nis c, the translation of the control effect, c *, is the quali.er of the continuation of the translated \nexpression: Lemma 5.7 (Translation of term typing). If fDC c1 e : t ; c then * . First we consider y, \nthe continuation of the whole appli\u00ad cation expression. Given the type that we need to derive for the \nwhole expression, the quali.er of y s type must be .0. Furthermore, from the assumptions of the lemma, \nwe know that D* f .0 (c1 G c2 G c)*. By Property 3, each ** of c1 , c2 *, and c is greater than (c1 G \nc2 G c)*, so by transitivity, .0 is less than each of these. Expression e1 has effect c1, so by the induction \nhypothe\u00adsis, its continuation may have quali.er c1 *. The continu\u00ad ation passed to [e1]C is (.x2.x1 x2 \n(.x.y x)), D * ;G * f [e] Proof. By induction on the typing derivation, generalizing the induction hypothesis \nthus: If fD;GC :C L(c (t **- * + -0 t ) -0 t ). ,c C ,c C .x1.[e2]C whose free variables are {y}. fv(e2). \nThus, the quali\u00ad.er of this function must upper bound both .0 and the quali.ers of the types in G2 (the \ntype context for e2). * We have D* f .0 c1 from the previous paragraph. e : t ; c, then for all t0 such \nthat D* f t0 : *, If fD;GC and for all .0 such that D* f .0 c *, we have Furthermore, looking at the \npremises of rule T-APP, we see that .2 upper bounds the types in G2 and is less than fD;GC D*;G* f [e]C \n: L(.0 (t * We consider two cases here: - + -0 t0,c ) -0 t0,c ). * c1 (by Property 5 (part 2)), so by \ntransitivity, D* f * G2 c1 *, as desired. CC C '' Expression e2 has effect c2, so similarly, its continuation \nD fcc e : t ; c *. The free variables of e2 s con- Case . should have quali.er c2 fD;GC * By Property \n5 (part 3), D* f cc '*, and thus by e : t ; c tinuation are only y and x1, which is the value of e1. \nWe c handle y as before. The type of x1 is .1 ((t1 - -t2)*), so ' Property 1 (part 4), there exists some \ntype t such that 0 it remains to show that D* f .1 c2 *, by Property 5 ''- -'' and 0 t . By the ++ 0 \nt 0 t0,c 0 t0,c 0,c = 0,c = (part2)appliedtothepremise fDC c Finally, given that x1 has type .1 ((t1 \n- -t2)*), it expects c2 C .1. C CCC lemma assumption, D* f .0 c *, and by transitivity of quali.er subsumption, \nD* f .0 c '*. Thus, we can ', using a continuation whose quali.er is c *. The type of y has applytheinductionhypothesisat \nfD;GC ' the same .0 but with t for t0, yielding quali.er .0, which is less than c *. Then by Lemma 5.2 \n0 (Dereliction), the type of the . expansion .x.y x may be e : t ; c * '' L(.0 (t D * ;G * f [e]C : -0 \nt0,c - '' + * given quali.er c ) -0 t ). 0,c . C C If D; G fe : t ; .C where D ft A, then CC * D * \n;G * f [e]C doneC : 0 t C. Proof. By Lemma 5.4, Lemma 5.7, Property 2, and rules QSUB-REFL and T-APP. \nLemma 5.9 (.URAL safety). * If ; f e1 : t and e1 -. e2, then either .v2.e2 = v2 or .e3.e2 -. e3. Proof. \nSee the proof in Ahmed et al. (2005). Theorem 5.10 (.URAL(C) safety). If ; fe : t ; .C, and ft A then \neval(e)= WRONG. CC Proof. By Corollary 5.8, ; f [e]C doneC : 0 t * . Then by Lemma 5.9, either [e]C doneC \nreduces to a value v, in which case eval(e)= v, or [e]C doneC diverges, in which case eval(e) is unde.ned. \nC 6. Example Control Effects In the previous section, we proved type safety for .URAL(C), a substructural \n. calculus parameterized by abstract control effects. In this section, we give three instances of control \neffects as described by De.nition 4.1 and show that they sat\u00adisfy the properties on which the generic \ntype safety theorem depends. 6.1 Shift and Reset We de.ne here a control effect instance for delimited \ncon\u00adtinuations. In this example, we restrict answer types to the unit type U1 in order to keep the effects \nsimple. In \u00a76.2, we show how to de.ne a more general control effect instance that allows answer-type \nmodi.cation. We add shift and reset to .URAL(C) as follows. First, we extend the syntax: e ::= \u00b7\u00b7\u00b7 | \nshift x in e | reset e (expressions) We give the dynamics of the new expressions by de.ning their CCoS \ntranslations, which are standard: [reset e = .y.y ([e]D (.x.x)) D [shift x in e] D = .y.(.x. [e]D (.x \n' .x ' )) (...x..y ' .y ' (yx)) To type shift and reset, we de.ne delimited continuation effects d as \nthe dual lattice of the quali.er lattice . with a new point .D: d ::= .D (no effect) | a (an effect variable) \n| . (treats continuation like .) | d1 U d2 (effect join) Let D be the set of delimited continuation effects \n(d) quo\u00adtiented by the following equivalences: L U . = . U L = .; d U.D = .D U d = d U d = d. (The quotient \nsimpli.es de.ning other functions and rela\u00adtions on delimited continuation effects.) Then we de.ne delimited \ncontinuation effects as the triple (D, .D, U). We extend the type system of .URAL(C) with the new rules \nin Figure 13. The new kinding rules say that quali.ers\u00adas-effects (.) and joins (d1 U d2) are well-kinded \nif their components are. The new control effect bound rules say that a control effect . ' is bounded \nby all quali.ers . that are less than . ' and that any bound of both effects in a join bounds the join \nas well. The rules added for effect subsumption ef\u00adfectively axiomatize the delimited continuation effect \nlattice. Finally, we add two rules for typing shift and reset. To type an expression reset e, subexpression \ne may have any effect whatsoever, but must return type U1. (We lift this restriction in \u00a76.2.) Then reset \ne is pure and also has type U1. To -.D type shift x in e, we give x type .(t --U1) for checking e, where \n. is joined with the effect of e to get the effect of the whole shift expression. That is, because shift \ncaptures its continuation and gives the rei.ed continuation quali.er ., its effect must be at least ., \nsince that quali.er determines how it might treat its captured continuation. Type safety. To prove type \nsafety for .URAL(C) extended with delimited continuation effects, we need to give the translation parameter \nas described by De.nition 5.1. We de.ne the translation parameter as follows: - + 0 t, d D = 0 t, d D \n= U1 doneD = .x.0 . L if d = .D . . a if d = a d * = . if d = . . . U otherwise Then, we must show \nthat this de.nition satis.es the prop\u00aderties of \u00a75.3: Theorem 6.1 (Delimited continuation properties). \nDelimited continuation effects (D, .D, U) satisfy Proper\u00adties 1 5. Proof. Property 1 (Answer types). \nWe must show several equal\u00ad - + ities on answer types, such as 0 t, d1 D = 0 t, d2 D , hold whenever \nd1Ud2 is well formed. All of the equalities - + are trivial because 0 t, d D = 0 t, d D = U1. Property \n2 (Done). We need to show that .; f doneD : L(t -0 t D). Given the de.nition of doneD, we can  D (kinding \ndelimited control effects) D (quali.er bound for delimited control effects) D-K-QUAL D-K-JOIN D-B-QUAL \nD-B-JOIN ffDD ffDDDfD fffDDD fDD DD DD DDD . ' . : QUAL . d1 : CTL d2 : CTL d1 C . fDD d2 C . . ' C . \nd1 U d2 C . d1 U d2 : CTL . : CTL fDDD (delimited control effect subsumption) DSUB-JOIN D fD f D d1 d2 \nfDD d ' 1 d ' 2 d1 U d2 : CTL fDD d1 d2 DSUB-BOT DSUB-LIN DSUB-TOP fffDDDDffDDfDD D D DD d ' 1 U d ' \n2 : CTL. : QUAL d : CTLd : CTL d ' 1 U d ' 2 . D fDD d1 U d2 L U d . d (delimited control expression \ntyping) D-T-RESET D-T-SHIFT D; G fe : t ; d D U.U-f11d D;G()-;:t,xDfD;GD -.D e : U1 ; d D; G freset \ne : fD;GD D e : U1 ; .D shift x in e : t ; d U . Figure 13. Statics for delimited continuation effects \n* d2 implies that D* f d2 : L(t fDDD 2.Weshowthat fDD D type derivation. d1 *, again by induction on \nthe derivation. The only Property 3 (Effect sequencing). We need to show that nontrivial case is when \nD fD f show .; f .x.0 ) by a straightforward d1 -0 t D * d1 U d2 : CTL implies that D* f (d1 U d2)* d1 \nand D* f (d1 U d2)* d2 *. By symmetry, it suf.ces to fDD d ' 1 d ' 2 fDD d1 U d2 : CTL d1 d2 d ' 1 U \nd ' 2 : CTL show the former: . d ' 1 U d ' 2 fDD We show that D* f (d1 ' U d ' 2)* (d1 U d2)* d1 U d2 \n(1) D f (2) D f (3) D f  DDD(4) fDD (5) D* f (d1 U d2)* by CSUB-REFL by d1 d1 exhaustively enumerating \nthe possibilities for d1, d2, . D d2 by DSUB-BOT d ' , and d ' such that the premises hold. 12 d1 U.D \nd1 U d2 by (1 2), DSUB-JOIN 3.Fortranslationofkinding,weshowthat fDby(3),UU.ddddd=C11211D * implies \nthat D* f d* d1 by (4), Lemma 5.6. d : CTL : QUAL. We proceed, as usual, by a simple induction on the \nderivation, considering the two new kinding rules for delimited continuation Property 4 (Bottom and \nlifting). effects. 1. To show that d1 Ud2 = .D if and only if d1 = d2 = 4. For translation of typing, \nwe use the generalized in\u00ad.D, we consider the quotienting of D. duction hypothesis as in the proof of \nLemma 5.7. 2.Wemustalsoshowthatif fDD d1 U d2 = .D, then there exist some d ' = .D requires a large type \nderivation. 1 and d ' 2 = .D with particular properties. For each di (i.{1,2}), if di = .D then let \nd ' = L; otherwise, 6.2 Shift and Reset with Answer-Type Modi.cation i d1 U d2 : CTL and There are two \ncases, for shift and reset, each of which let d ' i d ' i , .Thisensuresthat1 2)each fdDiD 3) d1 U d2 \n= d ' 1 U d ' , and 4) d ' 1 U d ' is well formed. 22 di The type-and-effect system for shift and reset \ndescribed in \u00a76.1 requires that all answer types the type of all reset = Property 5 (New rules). expressions \nbe U1. Our second example adds answer-type d C . implies that D* f .d* , modi.cation (\u00e0 la Danvy and \nFilinski 1989), which allows 1.Weshowthat fDD by induction on the derivation. The only new cases shift \nto capture and compose continuations of differing types to consider are for rules D-B-QUAL and D-B-JOIN. \nand allows the answer delivered by reset to have any type. These require a lemma about the translation \nof quali-Both the syntax and CCoS translation are as in \u00a76.1, but .er subsumption derivations. we change \nthe de.nition of control effects as follows. An A (kinding answer-type effects) A (quali.er bound for \nanswer-type effects) A-K-EFFECT A-B-QUAL fDAfD fDA ffDD fDA A ffDDA AA A .1 : QUAL .k : QUAL ..1 \u00b7\u00b7\u00b7 \n..j \u00b7\u00b7\u00b7 D ft2 : * fDA A t1 : * t2 : * t1 : * .1,...,.k (t1 t2): CTL .1,...,.j (t1 t2) C . (answer-type \neffect subsumption) ASUB-L ASUB-TOP a1 a2 fDA ASUB-BOT fDA fDA .(t t): CTL .(t1 t2): CTL fDA .(t1 t2): \nCTL fDA .(t1 t2) U(t1 t2)L(t1 t2) .(t1 t2) fDA .(t t) . A ASUB-JOIN .e D f1 (t1 t2) A fDA .1 (t1 t2) \n.e .2 (t1 t2) 2 (t1 t2) .e 1,.e .1,.2 (t1 t2) 2 (t1 t2) fDA fDA A A ffD;G D;GA (answer-type effect \nexpression typing) A-T-RESET A-T-SHIFT . D; G fD; G,x:.(t1 - -t2) fe : t0 ; .(t0 t) AA D; G fe : t \n; a A .(t0 t) e : t0 ; .,.(t2 t) reset e : t ; .A shift x in e : t1 ; Figure 14. Statics for answer-type \neffects answer-type control effect a is either the pure effect .A or eration is partial. Effects can \nbe sequenced only if their a collection of quali.ers .1,...,.j along with old and new answer types agree \nin the right way, as follows: answer types t1 and t2: . A . a = a a ::= .A (pure) a ..A = a | .(t1 t2) \n(a control effect) ' where . ::= .1,...,.j .(t t2) . .e (t1 t ' )= .,.e (t1 t2). Atypederivation fD;GA \nunderstood as follows: e : t ; .1,...,.j (t1 t2) may be Any other cases are unde.ned. Then we de.ne answer-type \nmodi.cation effects as the triple (A, .A, .). The new type rules for answer-type effects appear in Figure \n14. For the most part, these rules treat the collection The collection of quali.ers .1,...,.j keeps track \nof all the ways that expression e may treat its context; expres\u00adof quali.ers .1,...,.j similarly to the \ndelimited continua\u00adsion e may be considered to treat its context according to any quali.er . that lower \nbounds all of .1,...,.j . We need a collection of quali.ers because quali.ers do not, in the presence \nof quali.er variables, have greatest lower bounds. Evaluated in a context expecting type t whose original \nanswer type was t1, expression e changes the answer type to t2. This means that our type-and-effect judgment, \ndisregarding substructural considerations, is equivalent to the type judgment that Danvy and Filinski \nwrite as G,t1 f e : t, t2. For answer-type modi.cation effects, the sequencing op\u00adtion effect .1 U\u00b7 \u00b7\u00b7U \n.j from \u00a76.1. However, there is some subtlety to the de.nition of answer-type effect subsumption: the \nonly non-bottom effects related by subsumption are those whose before and after answer types match, pairwise, \nbut the pure effect .A is less than any effect whose before and after answer types match each other (rule \nASUB-BOT). This makes sense, as pure expressions do not change the answer type. The rules for typing \nshift and reset expressions are a hybrid of the rules from \u00a76.1, which they follow for the quali.er portion, \nand the rules from Danvy and Filinski (1989), which they follow for maintaining answer types.  X (kinding \nexception effects) with answer-type modi.cation, we de.ne the translation pa\u00adrameter as follows: X-K-UNION \nX-K-SING ffDDXfDX X fDX .2 : CTL.1 : CTL - 0 t, .A = t {.} : CTL .1 . .2 : CTL A -* 0 t, .(t1 t2) = t1 \nA + 0 t, .A = t (quali.er bound for exception effects) D f. C . X A * 0 t, .(t1 + t2) = t2 X-B-RAISE \nA fDX doneA .: CTL = .x.x . .. fDX . C A L if a = .A * a = . if a = .(t1 t2) .. (exception effect expression \ntyping) D; G fe : t ;. X U otherwise fDX X-T-RAISE Theorem 6.2 (Answer-type effect properties). t : * \nAnswer-type modi.cation effects (A, .A, .) satisfy Proper- fD;G1X fD;X6.3Exceptions X-T-HANDLE X fD;GXfD;G2X \nD f raise . : t ; {.} ties 1 5. G1 E G2G We add exceptions to .URAL(C) as follows. We assume a e1 : t \n; {.}. . e2 : t ;. D fG2 set Exn of exception names . and extend the syntax of A expressions: X e1 handle \n. . e2 : t ;. . . Exn (exceptions) e ::= \u00b7\u00b7\u00b7 | raise . | e1 handle . . e2 (expressions) Figure 15. Statics \nfor exception effects it. (Of course, the empty exception set \u00d8is bounded by L by rule C-B-PURE.) To \nde.ne the CCoS translation, we assume a run-time representation of exceptions and exception sets as follows: \n There is an exception pretype exn such that . f exn : *.  Each exception . is represented by a .URAL \nvalue .* , such that .; f .* : Uexn.  For each exception . and pair of .URAL values v1 and v2, there \nis a .URAL value [v1,v2]. such that  . = . ' [v1,v2]. . * -. v1 . * [v1,v2]. . '* -. v2 . '* . .1 (U \n.; G f v1 : exn -t). f .1 . .2 (U .; G f v2 : exn -t). f .2 . While these exceptions are simple tags, \nit would not be dif.cult to have exceptions carry values. As in the previous example, we de.ne the dynamics \nby the CCoS translation. However, because the CCoS translation for exceptions is type directed, we show \nhow the type system is extended .rst. To type exceptions, we instantiate .URAL(C) as follows. Exception \neffects, ., are sets of primitive exception names .: . ::= \u00d8 (pure) | a | {.}| .1 . .2 (an effect variable) \n(a single exception) (exception set union) Let X be the set of exception effects (.). Then we de\u00ad.ne \nexception effects as the triple (X, \u00d8, .). We consider exception effects as true sets, not merely as \nthe free algebra generated by the syntax. Thus, the subsumption order is set containment: .(U (exception \neffect subsumption) .; G f [v1,v2]. : exn -t ) fDX .1 .2 ffDDX fDX X XSUB-SUBSET Intuitively, [v1,v2]. \nperforms case analysis on exception . .2 .1 : CTL .2 : CTL .1 values: when applied to exception ., it \npasses the exception .1 .2 to v1, and when applied to any other exception, it passes the exception to \nv2. The other new type rules for exception effects appear in For exception effects, we use a typed CCoS \ntranslation Figure 15. Note that rule X-B-RAISE says that all exception that takes an extra parameter: \nthe exception effect of the ex\u00adeffects are bounded below by A; this is because exceptions pression to \nbe translated. We assume that the generic CCoS allow an expression to discard its context but not duplicate \nhas been updated to translate type derivations as well in order to propagate control effects correctly. \nThen we can give the Theorem 6.3 (Exception effect properties). CCoS translation for exceptions: Exception \neffects (X, \u00d8, .) satisfy Properties 1 5. . = . . inl . * The proofs of theorems in this section appear \nin the ex\u00ad [raise .][e1 handle . . e2] tended version of this paper, available at www.ccs.neu.edu/ \n~tov/pubs/substructural-control. {.}.. y, .x. inl x]. if .= \u00d8. X . X (.x. inr x)) if .= \u00d8; = .y.[v, y]([e1] \n. .[e2] .[e2] The .rst Scala example from \u00a71 may be recast \u00d8 X y 7. Conclusion where v = . X [. We began \nthis study with the desire to add linear types to Example. Alms, a general-purpose programming language \nwith af.ne types and exceptions. The treatment of exceptions in \u00a76.3in .URAL (with references, pairs, \nand integer division) as follows: points the way toward that goal. One question that remains, however, \nconcerns the pragmatics of checked exceptions in a .z1 z2.pair (ref (z1 /z2)) (ref (z2 /z1)) higher-order \nlanguage such as Alms, where latent exception effects are likely to appear on many function arrows. We \nLet us assume the following (monomorphic, for brevity) believe that with appropriate defaults most function \narrowstypes for the operations: - \u00d8 will not require annotation, but more research is required in that \ndirection. U(Uint -U(Uint {DivBy0} ------Uint)) \u00b7 / \u00b7 : Another potential direction for future research \nis to con\u00ad --Lintref) U(Lintref--L(Lintref \u00d8 \u00d8 U(Uint ref : sider how other control effects .t into \nour general framework. We suspect that some control operators common to impera\u00adtive languages, such as \nreturn, break, and goto, absent .rst\u00ad --L(Lintref . Lintref))) To type the application of term pair (ref(z1 \n/z2)) to term \u00d8 pair : class labels, would be straightforward. More exotic forms of control may be harder. \nSome control operators, such as shift0, are very dif.cult to type even in a simpler setting (Kiselyov \nand Shan 2007), which is why have not considered them. Others, such as Felleisen s prompt and control \n(1988) ref(z2 /z1), according to premise (6) of rule C-T-APP, the effect of the operator must be bounded \nby the quali.er of the type of the operand. The effect of the operator, Lthetypeoftheoperand, ,is .Butrefintref \nf(/z)z21X pair (ref (z1 /z2)), is {DivBy0}, based on the type of /; are probably tractable with a more \nexpressive version of our generic type system, because effects need to re.ect not only how an expression \ntreats its continuation, but how a continu\u00adation, if captured and reinvoked, treats its new continuation. \nFor the cases we consider, however, .URAL(C) provides a simple and generic framework for integrating \nsubstruc\u00adtural types and control effects. We have shown that our type system for .URAL(C) is sound provided \nthat the particular instantiation of control effects meets several criteria, and we have exhibited three \ninstances of control effects that meet these criteria. We contend that this provides a solid ground\u00ad \ning for the extension of realistic substructural programming {DivBy0}C L is not derivable a term that \ncan raise an exception does not necessarily treat it context linearly so the original code has a type \nerror in .URAL(C). \u00d8 references are allocated: Wecanrepairtheexample,aswedidin\u00a71,byexplicitly orderingtheeffectssothatbothdivisionshappenbeforeany \npairrefref.z(.x()())(/z)(/z)zxxxzz12.12.121221Term hasanunlimitedtype:pairrefref.x()()xxx12.12\u00d8UULLLintintrefintref--.(()))-\u00ad \nU(Uint Thus, it does not matter that its argument, z1 /z2, has non\u00adtrivial effect. Similarly, because \nthe codomain of that type is unlimited, it is permissible that the second argument, z2 /z1, has non-trivial \neffect as well. Thus, the repaired example is typeable in .URAL(C). Type safety. To prove type safety \nfor .URAL(C) extended with exceptions, we de.ne the translation parameter as fol\u00adlows: - + L(U 0 t, . \n0 t, . exn . t) = = XX languages with control effects. Acknowledgments We wish to thank Vincent St-Amour, \nSam Tobin-Hochstadt, Aaron Turon, and the anonymous referees for their helpful comments, discussion, \nand corrections. This research was supported in part by AFOSR grant FA9550-09-1-0110. References A. Ahmed, \nM. Fluet, and G. Morrisett. A step-indexed model of substructural state. In Proc. 10th ACM SIG\u00ad doneX \n= .x. inr x . * = L if . = \u00d8 PLAN International Conference on Functional Program\u00adming (ICFP 05), pages \n78 91, Tallinn, Estonia, Septem- A if . = \u00d8 ber 2005.  J. Aldrich, J. Sunshine, D. Saini, and Z. Sparks. \nTypestate\u00ad oriented programming. In Proc. Onward!, pages 1015 1022, Orlando, FL, USA, October 2009. K. \nAsai and Y. Kameyama. Polymorphic delimited continu\u00ad ations. In Programming Languages and Systems, volume \n4807 of Lecture Notes in Computer Science, pages 239 254. Springer, 2007. A. Barber. Dual intuitionistic \nlinear logic. Technical Report ECS-LFCS-960347, Laboratory for Foundations of Com\u00adputer Science, University \nof Edinburgh, September 1996. G. M. Bierman. On Intuitionistic Linear Logic. PhD thesis, University of \nCambridge, August 1993. W. Clinger, ed. The revised revised report on Scheme or an UnCommon Lisp. AI \nMemo No. 848, MIT AI Lab, Cambridge, MA, USA, August 1985. O. Danvy and A. Filinski. A functional abstraction \nof typed contexts. Technical Report DIKU Rapport 89/12, Com\u00adputer Science Department, University of Copenhagen, \nDenmark, 1989. M. Felleisen. The theory and practice of .rst-class prompts. In Proc. 15th Annual ACM \nSymposium on Principles of Programming Languages (POPL 88), pages 180 190, San Diego, CA, USA, January \n1988. J.-Y. Girard. Linear logic. Theoretical Computer Science, 50(1):1 102, 1987. J. B. Goodenough. \nStructured exception handling. In Proc. 2th Annual ACM Symposium on Principles of Pro\u00adgramming Languages \n(POPL 75), pages 204 224, Palo Alto, CA, USA, January 1975. J. Gosling, B. Joy, and G. Steele. The Java \nLanguage Speci.cation. Addison Wesley, 1996. D. Grossman, G. Morrisett, T. Jim, M. Hicks, Y. Wang, and \nJ. Cheney. Region-based memory management in Cyclone. In Proc. 2002 ACM SIGPLAN Conference on Programming \nLanguage Design and Implementation (PLDI 02), pages 282 293, Berlin, Germany, June 2002. O. Kiselyov \nand C. Shan. A substructural type system for delimited continuations. In Proc. 8th International Conference \non Typed Lambda Calculi and Applications (TLCA 07), pages 223 239, Paris, France, June 2007. P. J. Landin. \nA generalization of jumps and labels. Technical report, UNIVAC Systems Programming Research, 1965. J. \nM. Lucassen and D. K. Gifford. Polymorphic effect systems. In Proc. 15th Annual ACM Symposium on Principles \nof Programming Languages (POPL 88), pages 47 57, San Diego, CA, USA, January 1988. K. Mazurak and S. \nZdancewic. Lolliproc: to concurrency from classical linear logic via Curry-Howard and control. In Proc. \n15th ACM SIGPLAN International Conference on Functional Programming (ICFP 10), pages 39 50, Baltimore, \nMD, USA, September 2010. G. Morrisett, A. Ahmed, and M. Fluet. L3: A linear language with locations. \nIn Proc. 7th International Conference on Typed Lambda Calculi and Applications (TLCA 05), pages 293 307, \nNara, Japan, April 2005. M. Odersky and M. Zenger. Scalable component ab\u00ad stractions. In Proc 20th ACM \nConference on Object-Oriented Programming, Systems, Languages, and Ap\u00adplications (OOPSLA 05), pages 41 \n57, San Diego, CA, USA, October 2005. J. C. Reynolds. De.nitional interpreters for higher-order pro\u00ad \ngramming languages. In Proc. ACM Annual Conference, volume 2, pages 717 470, Boston, MA, USA, August \n1972. N. Swamy, J. Chen, and R. Chugh. Enforcing stateful authorization and information .ow policies \nin Fine. In A. D. Gordon, editor, Proc. 19th European Symposium on Programming (ESOP 10), volume 6012 \nof Lecture Notes in Computer Science, pages 529 549, Paphos, Cyprus, March 2010. H. Thielecke. From control \neffects to typed continuation passing. In Proc. 30th Annual ACM Symposium on Principles of Programming \nLanguages (POPL 03), pages 139 149, New Orleans, LA, USA, January 2003. J. A. Tov and R. Pucella. Practical \naf.ne types. In Proc. 38th Annual ACM Symposium on Principles of Programming Languages (POPL 11), pages \n447 458, Austin, TX, USA, January 2011. P. Wadler. There s no substitute for linear logic. In Proc. 8th \nInternational Workshop on the Mathematical Foundations of Programming Semantics (MFPS 92), Ox\u00adford, UK, \nApril 1992. D. Walker. Substructural type systems. In B. C. Pierce, editor, Advanced Topics in Types \nand Programming Lan\u00adguages, pages 3 44. MIT Press, Cambridge, 2005.    \n\t\t\t", "proc_id": "2048066", "abstract": "<p>Exceptions are invaluable for structured error handling in high-level languages, but they are at odds with linear types. More generally, control effects may delete or duplicate portions of the stack, which, if we are not careful, can invalidate all substructural usage guarantees for values on the stack. We have developed a type-and-effect system that tracks control effects and ensures that values on the stack are never wrongly duplicated or dropped. We present the system first with abstract control effects and prove its soundness. We then give examples of three instantiations with particular control effects, including exceptions and delimited continuations, and show that they meet the soundness criteria for specific control effects.</p>", "authors": [{"name": "Jesse A. Tov", "author_profile_id": "81372593761", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P2839240", "email_address": "tov@ccs.neu.edu", "orcid_id": ""}, {"name": "Riccardo Pucella", "author_profile_id": "81100260833", "affiliation": "Northeastern University, Boston, MA, USA", "person_id": "P2839241", "email_address": "riccardo@ccs.neu.edu", "orcid_id": ""}], "doi_number": "10.1145/2048066.2048115", "year": "2011", "article_id": "2048115", "conference": "OOPSLA", "title": "A theory of substructural types and control", "url": "http://dl.acm.org/citation.cfm?id=2048115"}